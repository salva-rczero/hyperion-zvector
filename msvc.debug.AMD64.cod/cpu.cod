; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	s390_run_cpu
PUBLIC	s370_run_cpu
PUBLIC	z900_run_cpu
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	s370_store_psw
PUBLIC	s370_load_psw
PUBLIC	s370_process_trace
PUBLIC	s390_load_psw
PUBLIC	s390_store_psw
PUBLIC	s390_process_trace
PUBLIC	z900_load_psw
PUBLIC	z900_store_psw
PUBLIC	z900_process_trace
PUBLIC	cpu_init
PUBLIC	s370_perform_io_interrupt
PUBLIC	s370_checkstop_all_cpus
PUBLIC	make_psw64
PUBLIC	s370_SuccessfulBranch
PUBLIC	s370_SuccessfulRelativeBranch
PUBLIC	s370_fix_program_interrupt_PSW
PUBLIC	s370_trace_program_interrupt
PUBLIC	cpu_thread
PUBLIC	copy_psw
PUBLIC	display_psw
PUBLIC	str_psw
PUBLIC	str_arch_psw
PUBLIC	do_automatic_tracing
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	s370_program_interrupt
PUBLIC	s390_program_interrupt
PUBLIC	z900_program_interrupt
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__or_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s370_maddr_l
PUBLIC	s370_instfetch
PUBLIC	s370_process_interrupt
PUBLIC	s390_perform_io_interrupt
PUBLIC	s390_checkstop_all_cpus
PUBLIC	s390_SuccessfulBranch
PUBLIC	s390_SuccessfulRelativeBranch
PUBLIC	s390_fix_program_interrupt_PSW
PUBLIC	s390_trace_program_interrupt
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	s390_maddr_l
PUBLIC	s390_instfetch
PUBLIC	s390_process_interrupt
PUBLIC	z900_perform_io_interrupt
PUBLIC	z900_checkstop_all_cpus
PUBLIC	z900_Set_BEAR_Reg
PUBLIC	z900_SuccessfulBranch
PUBLIC	z900_SuccessfulRelativeBranch
PUBLIC	z900_fix_program_interrupt_PSW
PUBLIC	z900_trace_program_interrupt
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_maddr_l
PUBLIC	z900_instfetch
PUBLIC	z900_process_interrupt
PUBLIC	??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
PUBLIC	??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@ ; `string'
EXTRN	__imp__errno:PROC
EXTRN	strlen:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	__imp__aligned_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_destroy_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_hthread_set_thread_name:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_do_make_psw64:PROC
EXTRN	__imp_PIC2Name:PROC
EXTRN	__imp_perc2name:PROC
EXTRN	__imp_tf_0800:PROC
EXTRN	__imp_tf_0801:PROC
EXTRN	__imp_tf_0802:PROC
EXTRN	__imp_tf_0803:PROC
EXTRN	__imp_tf_0804:PROC
EXTRN	__imp_tf_0806:PROC
EXTRN	__imp_tf_0807:PROC
EXTRN	__imp_tf_0808:PROC
EXTRN	__imp_tf_0809:PROC
EXTRN	__imp_tf_0811:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_clock_gettime:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_set_thread_name:PROC
EXTRN	get_tod_epoch:PROC
EXTRN	get_cpu_timer:PROC
EXTRN	set_cpu_timer:PROC
EXTRN	s370_present_io_interrupt:PROC
EXTRN	s370_perform_external_interrupt:PROC
EXTRN	s370_store_status:PROC
EXTRN	s370_cpu_reset:PROC
EXTRN	initial_cpu_reset:PROC
EXTRN	s370_initial_cpu_reset:PROC
EXTRN	s370_present_mck_interrupt:PROC
EXTRN	init_regs_runtime_opcode_pointers:PROC
EXTRN	s370_display_inst:PROC
EXTRN	s370_display_pgmint_inst:PROC
EXTRN	txf_why_str:PROC
EXTRN	setCpuIdregs:PROC
EXTRN	timer_thread:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	z900_abort_transaction:PROC
EXTRN	z900_txf_do_pi_filtering:PROC
EXTRN	alloc_txfmap:PROC
EXTRN	free_txfmap:PROC
EXTRN	insttrace_all:PROC
EXTRN	s390_invalidate_guest_aia:PROC
EXTRN	z900_invalidate_guest_aia:PROC
EXTRN	s370_purge_tlb:PROC
EXTRN	s390_purge_tlb:PROC
EXTRN	z900_purge_tlb:PROC
EXTRN	s390_purge_alb:PROC
EXTRN	z900_purge_alb:PROC
EXTRN	s370_invalidate_tlbe:PROC
EXTRN	s390_invalidate_tlbe:PROC
EXTRN	z900_invalidate_tlbe:PROC
EXTRN	s390_display_inst:PROC
EXTRN	z900_display_inst:PROC
EXTRN	s390_update_guest_psw_ia:PROC
EXTRN	z900_update_guest_psw_ia:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	get_arch_name:PROC
EXTRN	init_cpu_facilities:PROC
EXTRN	s370_logical_to_main_l:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	s370_invalidate_tlb:PROC
EXTRN	s390_present_io_interrupt:PROC
EXTRN	s390_perform_external_interrupt:PROC
EXTRN	s390_store_status:PROC
EXTRN	s390_cpu_reset:PROC
EXTRN	s390_initial_cpu_reset:PROC
EXTRN	s390_present_mck_interrupt:PROC
EXTRN	s390_display_pgmint_inst:PROC
EXTRN	s390_sie_exit:PROC
EXTRN	s390_invalidate_tlb:PROC
EXTRN	z900_present_io_interrupt:PROC
EXTRN	z900_perform_external_interrupt:PROC
EXTRN	z900_store_status:PROC
EXTRN	z900_cpu_reset:PROC
EXTRN	z900_initial_cpu_reset:PROC
EXTRN	z900_present_mck_interrupt:PROC
EXTRN	z900_display_pgmint_inst:PROC
EXTRN	z900_sie_exit:PROC
EXTRN	z900_invalidate_tlb:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	_setjmp:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_debug_program_interrupt:QWORD
EXTRN	__security_cookie:QWORD
_BSS	SEGMENT
?inst_count@?1??do_automatic_tracing@@9@9 DQ 01H DUP (?) ; `do_automatic_tracing'::`2'::inst_count
?missed_by@?1??do_automatic_tracing@@9@9 DQ 01H DUP (?)	; `do_automatic_tracing'::`2'::missed_by
?too_much@?1??do_automatic_tracing@@9@9 DQ 01H DUP (?)	; `do_automatic_tracing'::`2'::too_much
?beg_count@?2??do_automatic_tracing@@9@9 DQ 01H DUP (?)	; `do_automatic_tracing'::`3'::beg_count
?auto_trace_beg@?2??do_automatic_tracing@@9@9 DQ 01H DUP (?) ; `do_automatic_tracing'::`3'::auto_trace_beg
?auto_trace_amt@?2??do_automatic_tracing@@9@9 DQ 01H DUP (?) ; `do_automatic_tracing'::`3'::auto_trace_amt
?traced_amt@?2??do_automatic_tracing@@9@9 DQ 01H DUP (?) ; `do_automatic_tracing'::`3'::traced_amt
_BSS	ENDS
pdata	SEGMENT
$pdata$host_tod DD imagerel host_tod
	DD	imagerel host_tod+169
	DD	imagerel $unwind$host_tod
$pdata$s370_store_psw DD imagerel $LN10
	DD	imagerel $LN10+212
	DD	imagerel $unwind$s370_store_psw
$pdata$s370_load_psw DD imagerel $LN127
	DD	imagerel $LN127+4531
	DD	imagerel $unwind$s370_load_psw
$pdata$s370_process_trace DD imagerel $LN39
	DD	imagerel $LN39+2382
	DD	imagerel $unwind$s370_process_trace
$pdata$s390_load_psw DD imagerel $LN108
	DD	imagerel $LN108+3657
	DD	imagerel $unwind$s390_load_psw
$pdata$s390_store_psw DD imagerel $LN8
	DD	imagerel $LN8+163
	DD	imagerel $unwind$s390_store_psw
$pdata$s390_process_trace DD imagerel $LN39
	DD	imagerel $LN39+2446
	DD	imagerel $unwind$s390_process_trace
$pdata$z900_load_psw DD imagerel $LN111
	DD	imagerel $LN111+3854
	DD	imagerel $unwind$z900_load_psw
$pdata$z900_store_psw DD imagerel $LN8
	DD	imagerel $LN8+200
	DD	imagerel $unwind$z900_store_psw
$pdata$z900_process_trace DD imagerel $LN39
	DD	imagerel $LN39+2446
	DD	imagerel $unwind$z900_process_trace
$pdata$cpu_init DD imagerel $LN27
	DD	imagerel $LN27+1491
	DD	imagerel $unwind$cpu_init
$pdata$s370_perform_io_interrupt DD imagerel $LN43
	DD	imagerel $LN43+3238
	DD	imagerel $unwind$s370_perform_io_interrupt
$pdata$s370_checkstop_all_cpus DD imagerel $LN14
	DD	imagerel $LN14+303
	DD	imagerel $unwind$s370_checkstop_all_cpus
$pdata$make_psw64 DD imagerel $LN13
	DD	imagerel $LN13+189
	DD	imagerel $unwind$make_psw64
$pdata$s370_SuccessfulBranch DD imagerel $LN30
	DD	imagerel $LN30+506
	DD	imagerel $unwind$s370_SuccessfulBranch
$pdata$s370_SuccessfulRelativeBranch DD imagerel $LN36
	DD	imagerel $LN36+777
	DD	imagerel $unwind$s370_SuccessfulRelativeBranch
$pdata$s370_fix_program_interrupt_PSW DD imagerel $LN38
	DD	imagerel $LN38+822
	DD	imagerel $unwind$s370_fix_program_interrupt_PSW
$pdata$s370_trace_program_interrupt DD imagerel $LN44
	DD	imagerel $LN44+3083
	DD	imagerel $unwind$s370_trace_program_interrupt
$pdata$cpu_thread DD imagerel $LN17
	DD	imagerel $LN17+1033
	DD	imagerel $unwind$cpu_thread
$pdata$copy_psw DD imagerel $LN14
	DD	imagerel $LN14+274
	DD	imagerel $unwind$copy_psw
$pdata$display_psw DD imagerel $LN5
	DD	imagerel $LN5+116
	DD	imagerel $unwind$display_psw
$pdata$str_psw DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$str_psw
$pdata$str_arch_psw DD imagerel $LN5
	DD	imagerel $LN5+801
	DD	imagerel $unwind$str_arch_psw
$pdata$do_automatic_tracing DD imagerel $LN29
	DD	imagerel $LN29+1109
	DD	imagerel $unwind$do_automatic_tracing
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$s370_program_interrupt DD imagerel $LN170
	DD	imagerel $LN170+7840
	DD	imagerel $unwind$s370_program_interrupt
$pdata$s390_program_interrupt DD imagerel $LN219
	DD	imagerel $LN219+9368
	DD	imagerel $unwind$s390_program_interrupt
$pdata$z900_program_interrupt DD imagerel $LN249
	DD	imagerel $LN249+10436
	DD	imagerel $unwind$z900_program_interrupt
$pdata$wakeup_cpu DD imagerel wakeup_cpu
	DD	imagerel wakeup_cpu+44
	DD	imagerel $unwind$wakeup_cpu
$pdata$wakeup_cpu_mask DD imagerel wakeup_cpu_mask
	DD	imagerel wakeup_cpu_mask+251
	DD	imagerel $unwind$wakeup_cpu_mask
$pdata$wakeup_cpus_mask DD imagerel wakeup_cpus_mask
	DD	imagerel wakeup_cpus_mask+106
	DD	imagerel $unwind$wakeup_cpus_mask
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_instfetch DD imagerel $LN68
	DD	imagerel $LN68+1960
	DD	imagerel $unwind$s370_instfetch
pdata	ENDS
pdata	SEGMENT
$pdata$CPU_Wait DD imagerel CPU_Wait
	DD	imagerel CPU_Wait+438
	DD	imagerel $unwind$CPU_Wait
$pdata$cpu_uninit DD imagerel cpu_uninit
	DD	imagerel cpu_uninit+547
	DD	imagerel $unwind$cpu_uninit
$pdata$s370_restart_interrupt DD imagerel s370_restart_interrupt
	DD	imagerel s370_restart_interrupt+330
	DD	imagerel $unwind$s370_restart_interrupt
$pdata$s370_perform_mck_interrupt DD imagerel s370_perform_mck_interrupt
	DD	imagerel s370_perform_mck_interrupt+2388
	DD	imagerel $unwind$s370_perform_mck_interrupt
$pdata$s370_process_interrupt DD imagerel $LN83
	DD	imagerel $LN83+2547
	DD	imagerel $unwind$s370_process_interrupt
$pdata$s370_run_cpu DD imagerel $LN53
	DD	imagerel $LN53+2666
	DD	imagerel $unwind$s370_run_cpu
$pdata$s390_perform_io_interrupt DD imagerel $LN41
	DD	imagerel $LN41+2819
	DD	imagerel $unwind$s390_perform_io_interrupt
$pdata$s390_checkstop_all_cpus DD imagerel $LN14
	DD	imagerel $LN14+303
	DD	imagerel $unwind$s390_checkstop_all_cpus
$pdata$s390_SuccessfulBranch DD imagerel $LN37
	DD	imagerel $LN37+924
	DD	imagerel $unwind$s390_SuccessfulBranch
$pdata$s390_SuccessfulRelativeBranch DD imagerel $LN43
	DD	imagerel $LN43+1201
	DD	imagerel $unwind$s390_SuccessfulRelativeBranch
$pdata$s390_fix_program_interrupt_PSW DD imagerel $LN38
	DD	imagerel $LN38+822
	DD	imagerel $unwind$s390_fix_program_interrupt_PSW
$pdata$s390_trace_program_interrupt DD imagerel $LN44
	DD	imagerel $LN44+3171
	DD	imagerel $unwind$s390_trace_program_interrupt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_instfetch DD imagerel $LN76
	DD	imagerel $LN76+2248
	DD	imagerel $unwind$s390_instfetch
pdata	ENDS
pdata	SEGMENT
$pdata$s390_restart_interrupt DD imagerel s390_restart_interrupt
	DD	imagerel s390_restart_interrupt+330
	DD	imagerel $unwind$s390_restart_interrupt
$pdata$s390_perform_mck_interrupt DD imagerel s390_perform_mck_interrupt
	DD	imagerel s390_perform_mck_interrupt+2476
	DD	imagerel $unwind$s390_perform_mck_interrupt
$pdata$s390_process_interrupt DD imagerel $LN83
	DD	imagerel $LN83+2571
	DD	imagerel $unwind$s390_process_interrupt
$pdata$s390_run_cpu DD imagerel $LN53
	DD	imagerel $LN53+2666
	DD	imagerel $unwind$s390_run_cpu
$pdata$z900_perform_io_interrupt DD imagerel $LN46
	DD	imagerel $LN46+3018
	DD	imagerel $unwind$z900_perform_io_interrupt
$pdata$z900_checkstop_all_cpus DD imagerel $LN14
	DD	imagerel $LN14+303
	DD	imagerel $unwind$z900_checkstop_all_cpus
$pdata$z900_Set_BEAR_Reg DD imagerel $LN31
	DD	imagerel $LN31+773
	DD	imagerel $unwind$z900_Set_BEAR_Reg
$pdata$z900_SuccessfulBranch DD imagerel $LN37
	DD	imagerel $LN37+964
	DD	imagerel $unwind$z900_SuccessfulBranch
$pdata$z900_SuccessfulRelativeBranch DD imagerel $LN43
	DD	imagerel $LN43+1232
	DD	imagerel $unwind$z900_SuccessfulRelativeBranch
$pdata$z900_fix_program_interrupt_PSW DD imagerel $LN38
	DD	imagerel $LN38+821
	DD	imagerel $unwind$z900_fix_program_interrupt_PSW
$pdata$z900_trace_program_interrupt DD imagerel $LN45
	DD	imagerel $LN45+3244
	DD	imagerel $unwind$z900_trace_program_interrupt
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_instfetch DD imagerel $LN96
	DD	imagerel $LN96+2956
	DD	imagerel $unwind$z900_instfetch
pdata	ENDS
pdata	SEGMENT
$pdata$z900_restart_interrupt DD imagerel z900_restart_interrupt
	DD	imagerel z900_restart_interrupt+510
	DD	imagerel $unwind$z900_restart_interrupt
$pdata$z900_perform_mck_interrupt DD imagerel z900_perform_mck_interrupt
	DD	imagerel z900_perform_mck_interrupt+2646
	DD	imagerel $unwind$z900_perform_mck_interrupt
$pdata$z900_process_interrupt DD imagerel $LN85
	DD	imagerel $LN85+2662
	DD	imagerel $unwind$z900_process_interrupt
$pdata$z900_run_cpu DD imagerel $LN166
	DD	imagerel $LN166+5701
	DD	imagerel $unwind$z900_run_cpu
pdata	ENDS
;	COMDAT ??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\vstore.h:943', 00H	; `string'
_DATA	ENDS
;	COMDAT ??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@
_DATA	SEGMENT
??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@ DB 'C:\papa\MyG'
	DB	'it\hyperion-zvector\vstore.h:863', 00H	; `string'
_DATA	ENDS
_DATA	SEGMENT
$SG169563 DB	'cpu.c:94', 00H
	ORG $+3
$SG169754 DB	'I', 00H
	ORG $+2
$SG169755 DB	'HHC00800%s Processor %s%02X: loaded wait state PSW %s', 0aH
	DB	00H
	ORG $+1
$SG169756 DB	's370_load_psw', 00H
	ORG $+2
$SG169757 DB	'cpu.c', 00H
	ORG $+2
$SG169802 DB	'cpu.c:381', 00H
	ORG $+2
$SG169803 DB	'branch', 00H
	ORG $+1
$SG169956 DB	'I', 00H
	ORG $+2
$SG169805 DB	'cpu.c:392', 00H
	ORG $+2
$SG169806 DB	'branch', 00H
	ORG $+1
$SG170316 DB	'PGM', 00H
$SG169855 DB	'cpu.c:419', 00H
	ORG $+2
$SG170394 DB	'I', 00H
	ORG $+2
$SG169856 DB	'rbranch <', 00H
	ORG $+2
$SG170405 DB	'PGM ec', 00H
	ORG $+1
$SG170430 DB	'I', 00H
	ORG $+2
$SG169858 DB	'cpu.c:427', 00H
	ORG $+2
$SG170524 DB	'*IOINT', 00H
	ORG $+1
$SG170552 DB	'I', 00H
	ORG $+2
$SG169859 DB	'rbranch >', 00H
	ORG $+2
$SG170616 DB	'I', 00H
	ORG $+2
$SG169863 DB	'cpu.c:439', 00H
	ORG $+2
$SG170741 DB	'I', 00H
	ORG $+2
$SG169864 DB	'rbranch >', 00H
	ORG $+2
$SG170754 DB	'I', 00H
	ORG $+2
$SG169945 DB	'cpu.c:490', 00H
	ORG $+2
$SG170828 DB	'I', 00H
	ORG $+2
$SG169946 DB	'tr PGM int', 00H
	ORG $+1
$SG170834 DB	'I', 00H
	ORG $+2
$SG169948 DB	'cpu.c:502', 00H
	ORG $+2
$SG170847 DB	'E', 00H
	ORG $+2
$SG169949 DB	'tr PGM int', 00H
	ORG $+1
$SG169952 DB	'SIE: ', 00H
	ORG $+2
$SG170858 DB	'W', 00H
	ORG $+2
$SG169954 DB	' DXC=%2.2X', 00H
	ORG $+5
$SG169958 DB	's370_trace_program_interrupt', 00H
	ORG $+3
$SG169959 DB	'cpu.c', 00H
	ORG $+2
$SG169957 DB	'HHC00801%s Processor %s%02X: %s%s%s interruption code %4'
	DB	'.4X ilc %d%s%s', 0aH, 00H
$SG170001 DB	'cpu.c:594', 00H
	ORG $+2
$SG181083 DB	'I', 00H
	ORG $+2
$SG170002 DB	'fxpiPSW ilc', 00H
$SG181292 DB	'I', 00H
	ORG $+2
$SG170005 DB	'cpu.c:604', 00H
	ORG $+2
$SG181137 DB	'branch', 00H
	ORG $+1
$SG181677 DB	'PGM', 00H
$SG170006 DB	'fxpiPSW ilc', 00H
$SG181776 DB	'I', 00H
	ORG $+2
$SG170008 DB	'cpu.c:616', 00H
	ORG $+2
$SG181140 DB	'branch', 00H
	ORG $+1
$SG181811 DB	'I', 00H
	ORG $+2
$SG170009 DB	'fxpiPSW ilc', 00H
$SG181927 DB	'I', 00H
	ORG $+2
$SG170011 DB	'cpu.c:621', 00H
	ORG $+2
$SG181786 DB	'PGM ec', 00H
	ORG $+1
$SG181991 DB	'I', 00H
	ORG $+2
$SG170012 DB	'fxpiPSW ret', 00H
$SG182116 DB	'I', 00H
	ORG $+2
$SG170315 DB	'cpu.c:666', 00H
	ORG $+2
$SG181901 DB	'*IOINT', 00H
	ORG $+1
$SG182129 DB	'I', 00H
	ORG $+2
$SG170318 DB	'cpu.c:681', 00H
	ORG $+2
$SG182203 DB	'I', 00H
	ORG $+2
$SG170319 DB	'PGM (r)h,g,a', 00H
	ORG $+3
$SG170321 DB	'cpu.c:689', 00H
	ORG $+2
$SG182209 DB	'I', 00H
	ORG $+2
$SG170324 DB	'cpu.c:693', 00H
	ORG $+2
$SG182222 DB	'E', 00H
	ORG $+2
$SG170327 DB	'cpu.c:706', 00H
	ORG $+2
$SG182233 DB	'W', 00H
	ORG $+2
$SG170328 DB	'PGM ilc', 00H
$SG170330 DB	'cpu.c:792', 00H
	ORG $+2
$SG195335 DB	'I', 00H
	ORG $+2
$SG170331 DB	'PGM execflag', 00H
	ORG $+3
$SG170333 DB	'cpu.c:799', 00H
	ORG $+2
$SG195426 DB	'bear =', 00H
	ORG $+1
$SG195622 DB	'I', 00H
	ORG $+2
$SG170334 DB	'PGM execflag', 00H
	ORG $+3
$SG170337 DB	'cpu.c:853', 00H
	ORG $+2
$SG195466 DB	'branch', 00H
	ORG $+1
$SG196061 DB	'PGM', 00H
$SG170338 DB	'PGM psw.IA', 00H
	ORG $+1
$SG196175 DB	'I', 00H
	ORG $+2
$SG170342 DB	'cpu.c:894', 00H
	ORG $+2
$SG195469 DB	'branch', 00H
	ORG $+1
$SG196215 DB	'I', 00H
	ORG $+2
$SG170343 DB	'PGM IA-ilc', 00H
	ORG $+1
$SG196354 DB	'I', 00H
	ORG $+2
$SG170347 DB	'cpu.c:921', 00H
	ORG $+2
$SG196185 DB	'PGM ec', 00H
	ORG $+1
$SG196432 DB	'I', 00H
	ORG $+2
$SG170348 DB	'PGM IA+ilc', 00H
	ORG $+1
$SG196564 DB	'I', 00H
	ORG $+2
$SG170350 DB	'cpu.c:931', 00H
	ORG $+2
$SG196328 DB	'*IOINT', 00H
	ORG $+1
$SG196577 DB	'I', 00H
	ORG $+2
$SG170351 DB	'PGM inval=0', 00H
$SG196740 DB	'I', 00H
	ORG $+2
$SG170363 DB	'cpu.c:1012', 00H
	ORG $+1
$SG196746 DB	'I', 00H
	ORG $+2
$SG170364 DB	'PGM !icept', 00H
	ORG $+1
$SG196759 DB	'E', 00H
	ORG $+2
$SG170366 DB	'cpu.c:1033', 00H
	ORG $+1
$SG196772 DB	'W', 00H
	ORG $+2
$SG170367 DB	'PGM icept', 00H
	ORG $+6
$SG170396 DB	's370_program_interrupt', 00H
	ORG $+1
$SG170395 DB	'HHC00802%s Processor %s%02X: PER event: code %4.4X perc '
	DB	'%2.2X=%s addr %8.8X', 0aH, 00H
	ORG $+3
$SG170397 DB	'cpu.c', 00H
	ORG $+2
$SG170404 DB	'cpu.c:1147', 00H
	ORG $+1
$SG196782 DB	'W', 00H
	ORG $+2
$SG170421 DB	'cpu.c:1330', 00H
	ORG $+1
$SG196794 DB	'W', 00H
	ORG $+2
$SG170422 DB	'*PGM *lpsw', 00H
	ORG $+1
$SG196802 DB	0b2H, 0f8H, 00H
	ORG $+1
$SG170424 DB	'cpu.c:1331', 00H
	ORG $+1
$SG196812 DB	0b2H, 0f8H, 00H
	ORG $+1
$SG170425 DB	'PGM progjmp', 00H
$SG196822 DB	0b2H, 0f8H, 00H
	ORG $+1
$SG170431 DB	'HHC00803%s Processor %s%02X: program interrupt loop PSW '
	DB	'%s', 0aH, 00H
$SG196908 DB	'E', 00H
	ORG $+2
$SG170432 DB	's370_program_interrupt', 00H
	ORG $+1
$SG170433 DB	'cpu.c', 00H
	ORG $+2
$SG170434 DB	'cpu.c:1369', 00H
	ORG $+1
$SG196916 DB	'I', 00H
	ORG $+2
$SG170435 DB	'cpu.c:1374', 00H
	ORG $+1
$SG196924 DB	'I', 00H
	ORG $+2
$SG170437 DB	'cpu.c:1383', 00H
	ORG $+1
$SG197133 DB	'I', 00H
	ORG $+2
$SG170438 DB	'PGM !icept', 00H
	ORG $+1
$SG197138 DB	'I', 00H
	ORG $+2
$SG170440 DB	'cpu.c:1384', 00H
	ORG $+5
$SG170441 DB	'PGM progjmp', 00H
	ORG $+4
$SG170443 DB	'cpu.c:1397', 00H
	ORG $+5
$SG170444 DB	'PGM icept', 00H
	ORG $+6
$SG170446 DB	'cpu.c:1398', 00H
	ORG $+5
$SG170447 DB	'PGM progjmp', 00H
	ORG $+4
$SG170465 DB	'cpu.c:1412', 00H
	ORG $+5
$SG170466 DB	'*RESTART', 00H
	ORG $+7
$SG170468 DB	'cpu.c:1445', 00H
	ORG $+5
$SG170523 DB	'cpu.c:1475', 00H
	ORG $+1
$SG170555 DB	'cpu.c', 00H
	ORG $+6
$SG170553 DB	'HHC00804%s Processor %s%02X: I/O interrupt code %1.1X:%4'
	DB	'.4X CSW %2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X', 0aH, 00H
	ORG $+5
$SG170554 DB	's370_perform_io_interrupt', 00H
	ORG $+6
$SG170558 DB	'cpu.c:1585', 00H
	ORG $+5
$SG170559 DB	'cpu.c:1590', 00H
	ORG $+5
$SG170617 DB	'HHC00807%s Processor %s%02X: machine check code %16.16ll'
	DB	'u', 0aH, 00H
	ORG $+5
$SG170618 DB	's370_perform_mck_interrupt', 00H
	ORG $+1
$SG170619 DB	'cpu.c', 00H
	ORG $+6
$SG170620 DB	'cpu.c:1668', 00H
	ORG $+5
$SG170723 DB	'cpu.c:1686', 00H
	ORG $+5
$SG170732 DB	'cpu.c:1744', 00H
	ORG $+5
$SG170736 DB	'cpu.c:1766', 00H
	ORG $+5
$SG170738 DB	'cpu.c:1776', 00H
	ORG $+5
$SG170742 DB	'HHC00808%s Processor %s%02X: store status completed', 0aH
	DB	00H
	ORG $+3
$SG170743 DB	's370_process_interrupt', 00H
	ORG $+1
$SG170744 DB	'cpu.c', 00H
	ORG $+2
$SG170748 DB	'cpu.c:1836', 00H
	ORG $+5
$SG170755 DB	'HHC00809%s Processor %s%02X: disabled wait state %s', 0aH
	DB	00H
	ORG $+3
$SG170756 DB	's370_process_interrupt', 00H
	ORG $+1
$SG170757 DB	'cpu.c', 00H
	ORG $+2
$SG170758 DB	'cpu.c:1866', 00H
	ORG $+5
$SG170760 DB	'cpu.c:1892', 00H
	ORG $+5
$SG170761 DB	'cpu.c:1897', 00H
	ORG $+5
$SG170826 DB	'cpu.c:1929', 00H
	ORG $+5
$SG170829 DB	'HHC00811%s Processor %s%02X: architecture mode %s', 0aH, 00H
	ORG $+5
$SG170830 DB	's370_run_cpu', 00H
	ORG $+3
$SG170831 DB	'cpu.c', 00H
	ORG $+2
$SG170835 DB	'HHC00811%s Processor %s%02X: architecture mode %s', 0aH, 00H
	ORG $+5
$SG170836 DB	's370_run_cpu', 00H
	ORG $+3
$SG170837 DB	'cpu.c', 00H
	ORG $+2
$SG170841 DB	'cpu.c:1976', 00H
	ORG $+5
$SG170842 DB	'*SETARCH', 00H
	ORG $+7
$SG170845 DB	'cpu.c:1986', 00H
	ORG $+5
$SG170846 DB	'malloc(%d)', 00H
	ORG $+5
$SG170848 DB	'HHC00813%s Processor %s%02X: error in function %s: %s', 0aH
	DB	00H
	ORG $+1
$SG170849 DB	's370_run_cpu', 00H
	ORG $+3
$SG170850 DB	'cpu.c', 00H
	ORG $+2
$SG170852 DB	'cpu.c:2010', 00H
	ORG $+5
$SG170853 DB	'cpu.c:2012', 00H
	ORG $+5
$SG170860 DB	's370_run_cpu', 00H
	ORG $+3
$SG170861 DB	'cpu.c', 00H
	ORG $+2
$SG170859 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG170904 DB	'cpu.c:2200', 00H
	ORG $+5
$SG170905 DB	'cpu.c:2217', 00H
	ORG $+5
$SG170906 DB	'cpu.c:2230', 00H
	ORG $+5
$SG180945 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:94', 00H
$SG181084 DB	'HHC00800%s Processor %s%02X: loaded wait state PSW %s', 0aH
	DB	00H
	ORG $+1
$SG181085 DB	's390_load_psw', 00H
	ORG $+2
$SG181086 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG181136 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:381', 00H
	ORG $+7
$SG181139 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:392', 00H
	ORG $+7
$SG181190 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:419', 00H
	ORG $+7
$SG181191 DB	'rbranch <', 00H
	ORG $+6
$SG181193 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:427', 00H
	ORG $+7
$SG181194 DB	'rbranch >', 00H
	ORG $+6
$SG181198 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:439', 00H
	ORG $+7
$SG181199 DB	'rbranch >', 00H
	ORG $+6
$SG181281 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:490', 00H
	ORG $+7
$SG181282 DB	'tr PGM int', 00H
	ORG $+5
$SG181284 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:502', 00H
	ORG $+7
$SG181285 DB	'tr PGM int', 00H
	ORG $+1
$SG181288 DB	'SIE: ', 00H
	ORG $+6
$SG181290 DB	' DXC=%2.2X', 00H
	ORG $+5
$SG181293 DB	'HHC00801%s Processor %s%02X: %s%s%s interruption code %4'
	DB	'.4X ilc %d%s%s', 0aH, 00H
$SG181294 DB	's390_trace_program_interrupt', 00H
	ORG $+3
$SG181295 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG181337 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:594', 00H
	ORG $+7
$SG181338 DB	'fxpiPSW ilc', 00H
	ORG $+4
$SG181341 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:604', 00H
	ORG $+7
$SG181342 DB	'fxpiPSW ilc', 00H
	ORG $+4
$SG181344 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:616', 00H
	ORG $+7
$SG181345 DB	'fxpiPSW ilc', 00H
	ORG $+4
$SG181347 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:621', 00H
	ORG $+7
$SG181348 DB	'fxpiPSW ret', 00H
	ORG $+4
$SG181676 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:666', 00H
	ORG $+7
$SG181679 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:681', 00H
	ORG $+7
$SG181680 DB	'PGM (r)h,g,a', 00H
	ORG $+3
$SG181682 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:689', 00H
	ORG $+7
$SG181685 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:693', 00H
	ORG $+7
$SG181689 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:706', 00H
	ORG $+7
$SG181690 DB	'PGM ilc', 00H
$SG181694 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:718', 00H
	ORG $+7
$SG181695 DB	'PGM sie_ilc', 00H
	ORG $+4
$SG181697 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:792', 00H
	ORG $+7
$SG181698 DB	'PGM execflag', 00H
	ORG $+3
$SG181701 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:799', 00H
	ORG $+7
$SG181702 DB	'PGM execflag', 00H
	ORG $+3
$SG181711 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:853', 00H
	ORG $+7
$SG181712 DB	'PGM psw.IA', 00H
	ORG $+5
$SG181716 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:894', 00H
	ORG $+7
$SG181717 DB	'PGM IA-ilc', 00H
	ORG $+5
$SG181722 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:921', 00H
	ORG $+7
$SG181723 DB	'PGM IA+ilc', 00H
	ORG $+5
$SG181725 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:931', 00H
	ORG $+7
$SG181726 DB	'PGM inval=0', 00H
	ORG $+4
$SG181729 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:940', 00H
	ORG $+7
$SG181730 DB	'PGM >sie_exit', 00H
	ORG $+2
$SG181745 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1012', 00H
	ORG $+6
$SG181746 DB	'PGM !icept', 00H
	ORG $+5
$SG181748 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1033', 00H
	ORG $+6
$SG181749 DB	'PGM icept', 00H
	ORG $+6
$SG181778 DB	's390_program_interrupt', 00H
	ORG $+1
$SG181777 DB	'HHC00802%s Processor %s%02X: PER event: code %4.4X perc '
	DB	'%2.2X=%s addr %8.8X', 0aH, 00H
	ORG $+3
$SG181779 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG181785 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1147', 00H
	ORG $+6
$SG181802 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1330', 00H
	ORG $+6
$SG181803 DB	'*PGM *lpsw', 00H
	ORG $+5
$SG181805 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1331', 00H
	ORG $+6
$SG181806 DB	'PGM progjmp', 00H
	ORG $+4
$SG181812 DB	'HHC00803%s Processor %s%02X: program interrupt loop PSW '
	DB	'%s', 0aH, 00H
	ORG $+4
$SG181813 DB	's390_program_interrupt', 00H
	ORG $+1
$SG181814 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG181815 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1369', 00H
	ORG $+6
$SG181816 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1374', 00H
	ORG $+6
$SG181818 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1383', 00H
	ORG $+6
$SG181819 DB	'PGM !icept', 00H
	ORG $+5
$SG181821 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1384', 00H
	ORG $+6
$SG181822 DB	'PGM progjmp', 00H
	ORG $+4
$SG181824 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1397', 00H
	ORG $+6
$SG181825 DB	'PGM icept', 00H
	ORG $+6
$SG181827 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1398', 00H
	ORG $+6
$SG181828 DB	'PGM progjmp', 00H
	ORG $+4
$SG181846 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1412', 00H
	ORG $+6
$SG181847 DB	'*RESTART', 00H
	ORG $+7
$SG181849 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1445', 00H
	ORG $+6
$SG181900 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1475', 00H
	ORG $+6
$SG181930 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG181928 DB	'HHC00806%s Processor %s%02X: I/O interrupt code %8.8X pa'
	DB	'rm %8.8X id %8.8X', 0aH, 00H
	ORG $+5
$SG181929 DB	's390_perform_io_interrupt', 00H
	ORG $+6
$SG181933 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1585', 00H
	ORG $+6
$SG181934 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1590', 00H
	ORG $+6
$SG181992 DB	'HHC00807%s Processor %s%02X: machine check code %16.16ll'
	DB	'u', 0aH, 00H
	ORG $+5
$SG181993 DB	's390_perform_mck_interrupt', 00H
	ORG $+5
$SG181994 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG181995 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1668', 00H
	ORG $+6
$SG182098 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1686', 00H
	ORG $+6
$SG182107 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1744', 00H
	ORG $+6
$SG182111 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1766', 00H
	ORG $+6
$SG182113 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1776', 00H
	ORG $+6
$SG182117 DB	'HHC00808%s Processor %s%02X: store status completed', 0aH
	DB	00H
	ORG $+3
$SG182118 DB	's390_process_interrupt', 00H
	ORG $+1
$SG182119 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG182123 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1836', 00H
	ORG $+6
$SG182130 DB	'HHC00809%s Processor %s%02X: disabled wait state %s', 0aH
	DB	00H
	ORG $+3
$SG182131 DB	's390_process_interrupt', 00H
	ORG $+1
$SG182132 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG182133 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1866', 00H
	ORG $+6
$SG182135 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1892', 00H
	ORG $+6
$SG182136 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1897', 00H
	ORG $+6
$SG182201 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1929', 00H
	ORG $+6
$SG182204 DB	'HHC00811%s Processor %s%02X: architecture mode %s', 0aH, 00H
	ORG $+5
$SG182205 DB	's390_run_cpu', 00H
	ORG $+3
$SG182206 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG182210 DB	'HHC00811%s Processor %s%02X: architecture mode %s', 0aH, 00H
	ORG $+5
$SG182211 DB	's390_run_cpu', 00H
	ORG $+3
$SG182212 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG182216 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1976', 00H
	ORG $+6
$SG182217 DB	'*SETARCH', 00H
	ORG $+7
$SG182220 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1986', 00H
	ORG $+6
$SG182221 DB	'malloc(%d)', 00H
	ORG $+5
$SG182223 DB	'HHC00813%s Processor %s%02X: error in function %s: %s', 0aH
	DB	00H
	ORG $+1
$SG182224 DB	's390_run_cpu', 00H
	ORG $+3
$SG182225 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG182227 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2010', 00H
	ORG $+6
$SG182228 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2012', 00H
	ORG $+6
$SG182235 DB	's390_run_cpu', 00H
	ORG $+3
$SG182236 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG182234 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG182279 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2200', 00H
	ORG $+6
$SG182280 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2217', 00H
	ORG $+6
$SG182281 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2230', 00H
	ORG $+6
$SG195197 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:94', 00H
$SG195336 DB	'HHC00800%s Processor %s%02X: loaded wait state PSW %s', 0aH
	DB	00H
	ORG $+1
$SG195337 DB	'z900_load_psw', 00H
	ORG $+2
$SG195338 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG195410 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:305', 00H
	ORG $+7
$SG195411 DB	'bear = ex', 00H
	ORG $+6
$SG195416 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:331', 00H
	ORG $+7
$SG195417 DB	'ip < aip', 00H
	ORG $+7
$SG195420 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:341', 00H
	ORG $+7
$SG195421 DB	'ip >= aip+page', 00H
	ORG $+1
$SG195425 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:352', 00H
	ORG $+7
$SG195428 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:354', 00H
	ORG $+7
$SG195429 DB	'bear_ex =', 00H
	ORG $+6
$SG195465 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:381', 00H
	ORG $+7
$SG195468 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:392', 00H
	ORG $+7
$SG195519 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:419', 00H
	ORG $+7
$SG195520 DB	'rbranch <', 00H
	ORG $+6
$SG195522 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:427', 00H
	ORG $+7
$SG195523 DB	'rbranch >', 00H
	ORG $+6
$SG195527 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:439', 00H
	ORG $+7
$SG195528 DB	'rbranch >', 00H
	ORG $+6
$SG195610 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:490', 00H
	ORG $+7
$SG195611 DB	'tr PGM int', 00H
	ORG $+5
$SG195613 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:502', 00H
	ORG $+7
$SG195614 DB	'tr PGM int', 00H
	ORG $+1
$SG195617 DB	'SIE: ', 00H
	ORG $+6
$SG195620 DB	' DXC=%2.2X', 00H
	ORG $+5
$SG195623 DB	'HHC00801%s Processor %s%02X: %s%s%s interruption code %4'
	DB	'.4X ilc %d%s%s', 0aH, 00H
$SG195624 DB	'z900_trace_program_interrupt', 00H
	ORG $+3
$SG195625 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG195667 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:594', 00H
	ORG $+7
$SG195668 DB	'fxpiPSW ilc', 00H
	ORG $+4
$SG195671 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:604', 00H
	ORG $+7
$SG195672 DB	'fxpiPSW ilc', 00H
	ORG $+4
$SG195674 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:616', 00H
	ORG $+7
$SG195675 DB	'fxpiPSW ilc', 00H
	ORG $+4
$SG195677 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:621', 00H
	ORG $+7
$SG195678 DB	'fxpiPSW ret', 00H
	ORG $+4
$SG196060 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:666', 00H
	ORG $+7
$SG196063 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:681', 00H
	ORG $+7
$SG196064 DB	'PGM (r)h,g,a', 00H
	ORG $+3
$SG196066 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:689', 00H
	ORG $+7
$SG196069 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:693', 00H
	ORG $+7
$SG196073 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:706', 00H
	ORG $+7
$SG196074 DB	'PGM ilc', 00H
$SG196078 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:718', 00H
	ORG $+7
$SG196079 DB	'PGM sie_ilc', 00H
	ORG $+4
$SG196083 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:753', 00H
	ORG $+7
$SG196084 DB	'TXF PIID', 00H
	ORG $+7
$SG196086 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:760', 00H
	ORG $+7
$SG196087 DB	'TXF PROG?', 00H
	ORG $+6
$SG196090 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:766', 00H
	ORG $+7
$SG196091 DB	'*TXF UPROG!', 00H
	ORG $+4
$SG196094 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:782', 00H
	ORG $+7
$SG196095 DB	'*TXF 218!', 00H
	ORG $+6
$SG196097 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:792', 00H
	ORG $+7
$SG196098 DB	'PGM execflag', 00H
	ORG $+3
$SG196101 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:799', 00H
	ORG $+7
$SG196102 DB	'PGM execflag', 00H
	ORG $+3
$SG196111 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:853', 00H
	ORG $+7
$SG196112 DB	'PGM psw.IA', 00H
	ORG $+5
$SG196116 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:894', 00H
	ORG $+7
$SG196117 DB	'PGM IA-ilc', 00H
	ORG $+5
$SG196122 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:921', 00H
	ORG $+7
$SG196123 DB	'PGM IA+ilc', 00H
	ORG $+5
$SG196125 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:931', 00H
	ORG $+7
$SG196126 DB	'PGM inval=0', 00H
	ORG $+4
$SG196129 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:940', 00H
	ORG $+7
$SG196130 DB	'PGM >sie_exit', 00H
	ORG $+2
$SG196142 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1012', 00H
	ORG $+6
$SG196143 DB	'PGM !icept', 00H
	ORG $+5
$SG196146 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1033', 00H
	ORG $+6
$SG196147 DB	'PGM icept', 00H
	ORG $+6
$SG196177 DB	'z900_program_interrupt', 00H
	ORG $+1
$SG196176 DB	'HHC00802%s Processor %s%02X: PER event: code %4.4X perc '
	DB	'%2.2X=%s addr %16.16llX', 0aH, 00H
	ORG $+7
$SG196178 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196184 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1147', 00H
	ORG $+6
$SG196197 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1293', 00H
	ORG $+6
$SG196198 DB	'PGM bear', 00H
	ORG $+7
$SG196206 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1330', 00H
	ORG $+6
$SG196207 DB	'*PGM *lpsw', 00H
	ORG $+5
$SG196209 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1331', 00H
	ORG $+6
$SG196210 DB	'PGM progjmp', 00H
	ORG $+4
$SG196216 DB	'HHC00803%s Processor %s%02X: program interrupt loop PSW '
	DB	'%s', 0aH, 00H
	ORG $+4
$SG196217 DB	'z900_program_interrupt', 00H
	ORG $+1
$SG196218 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196219 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1369', 00H
	ORG $+6
$SG196220 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1374', 00H
	ORG $+6
$SG196222 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1383', 00H
	ORG $+6
$SG196223 DB	'PGM !icept', 00H
	ORG $+5
$SG196225 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1384', 00H
	ORG $+6
$SG196226 DB	'PGM progjmp', 00H
	ORG $+4
$SG196228 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1397', 00H
	ORG $+6
$SG196229 DB	'PGM icept', 00H
	ORG $+6
$SG196231 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1398', 00H
	ORG $+6
$SG196232 DB	'PGM progjmp', 00H
	ORG $+4
$SG196259 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1412', 00H
	ORG $+6
$SG196260 DB	'*RESTART', 00H
	ORG $+7
$SG196263 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1428', 00H
	ORG $+6
$SG196264 DB	'*TXF MISC', 00H
	ORG $+6
$SG196265 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1430', 00H
	ORG $+6
$SG196267 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1445', 00H
	ORG $+6
$SG196327 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1475', 00H
	ORG $+6
$SG196355 DB	'HHC00806%s Processor %s%02X: I/O interrupt code %8.8X pa'
	DB	'rm %8.8X id %8.8X', 0aH, 00H
	ORG $+5
$SG196356 DB	'z900_perform_io_interrupt', 00H
	ORG $+6
$SG196357 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196361 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1572', 00H
	ORG $+6
$SG196362 DB	'*TXF IO', 00H
$SG196363 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1574', 00H
	ORG $+6
$SG196365 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1585', 00H
	ORG $+6
$SG196366 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1590', 00H
	ORG $+6
$SG196433 DB	'HHC00807%s Processor %s%02X: machine check code %16.16ll'
	DB	'u', 0aH, 00H
	ORG $+5
$SG196434 DB	'z900_perform_mck_interrupt', 00H
	ORG $+5
$SG196435 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196438 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1657', 00H
	ORG $+6
$SG196439 DB	'*TXF MCK', 00H
	ORG $+7
$SG196440 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1659', 00H
	ORG $+6
$SG196441 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1668', 00H
	ORG $+6
$SG196544 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1686', 00H
	ORG $+6
$SG196555 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1744', 00H
	ORG $+6
$SG196559 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1766', 00H
	ORG $+6
$SG196561 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1776', 00H
	ORG $+6
$SG196565 DB	'HHC00808%s Processor %s%02X: store status completed', 0aH
	DB	00H
	ORG $+3
$SG196566 DB	'z900_process_interrupt', 00H
	ORG $+1
$SG196567 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196571 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1836', 00H
	ORG $+6
$SG196578 DB	'HHC00809%s Processor %s%02X: disabled wait state %s', 0aH
	DB	00H
	ORG $+3
$SG196579 DB	'z900_process_interrupt', 00H
	ORG $+1
$SG196580 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196581 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1866', 00H
	ORG $+6
$SG196583 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1892', 00H
	ORG $+6
$SG196584 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1897', 00H
	ORG $+6
$SG196738 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1929', 00H
	ORG $+6
$SG196741 DB	'HHC00811%s Processor %s%02X: architecture mode %s', 0aH, 00H
	ORG $+5
$SG196742 DB	'z900_run_cpu', 00H
	ORG $+3
$SG196743 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196747 DB	'HHC00811%s Processor %s%02X: architecture mode %s', 0aH, 00H
	ORG $+5
$SG196748 DB	'z900_run_cpu', 00H
	ORG $+3
$SG196749 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196753 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1976', 00H
	ORG $+6
$SG196754 DB	'*SETARCH', 00H
	ORG $+7
$SG196757 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:1986', 00H
	ORG $+6
$SG196758 DB	'malloc(%d)', 00H
	ORG $+5
$SG196760 DB	'HHC00813%s Processor %s%02X: error in function %s: %s', 0aH
	DB	00H
	ORG $+1
$SG196761 DB	'z900_run_cpu', 00H
	ORG $+3
$SG196762 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196764 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2010', 00H
	ORG $+6
$SG196765 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2012', 00H
	ORG $+6
$SG196774 DB	'z900_run_cpu', 00H
	ORG $+3
$SG196775 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196773 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG196783 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG196784 DB	'z900_run_cpu', 00H
	ORG $+3
$SG196785 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196797 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196795 DB	'HHC00835%s Processor %s%02X: aie invalidated; instructio'
	DB	'n being refetched', 0aH, 00H
	ORG $+5
$SG196796 DB	'z900_run_cpu', 00H
	ORG $+3
$SG196800 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2139', 00H
	ORG $+6
$SG196803 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2139', 00H
	ORG $+6
$SG196805 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2139', 00H
	ORG $+6
$SG196810 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2148', 00H
	ORG $+6
$SG196813 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2148', 00H
	ORG $+6
$SG196815 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2148', 00H
	ORG $+6
$SG196820 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2153', 00H
	ORG $+6
$SG196823 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2153', 00H
	ORG $+6
$SG196825 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2153', 00H
	ORG $+6
$SG196866 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2200', 00H
	ORG $+6
$SG196867 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2217', 00H
	ORG $+6
$SG196868 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2230', 00H
	ORG $+6
run_cpu	DQ	FLAT:s370_run_cpu
	DQ	FLAT:s390_run_cpu
	DQ	FLAT:z900_run_cpu
$SG196902 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2330', 00H
	ORG $+6
$SG196905 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2343', 00H
	ORG $+6
$SG196906 DB	'timer_thread', 00H
	ORG $+3
$SG196909 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG196910 DB	'cpu_thread', 00H
	ORG $+5
$SG196911 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196912 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2348', 00H
	ORG $+6
$SG196913 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2354', 00H
	ORG $+6
$SG196914 DB	'Processor %s%02X', 00H
	ORG $+7
$SG196915 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2359', 00H
	ORG $+6
$SG196917 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG196918 DB	'cpu_thread', 00H
	ORG $+5
$SG196919 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196922 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2381', 00H
	ORG $+6
$SG196923 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2384', 00H
	ORG $+6
$SG196925 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG196926 DB	'cpu_thread', 00H
	ORG $+5
$SG196927 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG196928 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2386', 00H
	ORG $+6
$SG196963 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2398', 00H
	ORG $+2
$SG196964 DB	'REGS', 00H
	ORG $+7
$SG196965 DB	'%-4.4s_%s%02X', 00H
	ORG $+2
$SG196966 DB	'END ', 00H
	ORG $+3
$SG196967 DB	'SDL 4.00', 00H
	ORG $+7
$SG196969 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2429', 00H
	ORG $+6
$SG196976 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2519', 00H
	ORG $+6
$SG196990 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2534', 00H
	ORG $+6
$SG196993 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2560', 00H
	ORG $+6
$SG197019 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2586', 00H
	ORG $+6
$SG197020 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2587', 00H
	ORG $+6
$SG197023 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2604', 00H
	ORG $+6
$SG197025 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2608', 00H
	ORG $+6
$SG197026 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2610', 00H
	ORG $+6
$SG197027 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2614', 00H
	ORG $+6
$SG197075 DB	'%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X', 00H
	ORG $+6
$SG197076 DB	'%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X'
	DB	'%2.2X%2.2X%2.2X%2.2X%2.2X', 00H
	ORG $+6
$SG197121 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2728', 00H
	ORG $+6
$SG197123 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2740', 00H
	ORG $+6
$SG197130 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c:2783', 00H
	ORG $+6
$SG197135 DB	'do_automatic_tracing', 00H
	ORG $+3
$SG197134 DB	'HHC02370%s Automatic tracing started at instrcount %llu '
	DB	'(BEG+%llu)', 0aH, 00H
	ORG $+4
$SG197136 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
	ORG $+3
$SG197139 DB	'HHC02371%s Automatic tracing stopped at instrcount %llu '
	DB	'(AMT+%llu)', 0aH, 00H
	ORG $+4
$SG197140 DB	'do_automatic_tracing', 00H
	ORG $+3
$SG197141 DB	'C:\papa\MyGit\hyperion-zvector\cpu.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_instfetch DD 021001H
	DD	0170110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_instfetch DD 021001H
	DD	0150110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_instfetch DD 021001H
	DD	0130110H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:atomic_update64
	DD	014H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_run_cpu
	DD	01cH
	DD	0162bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_process_interrupt
	DD	016H
	DD	0a4eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_trace_program_interrupt
	DD	020H
	DD	0c93H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_perform_io_interrupt
	DD	016H
	DD	0bb2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_run_cpu
	DD	01cH
	DD	0a50H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_process_interrupt
	DD	016H
	DD	09f3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_trace_program_interrupt
	DD	020H
	DD	0c4aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_perform_io_interrupt
	DD	016H
	DD	0aebH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_run_cpu
	DD	01cH
	DD	0a50H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_process_interrupt
	DD	016H
	DD	09dbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_program_interrupt
	DD	01cH
	DD	028aaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_program_interrupt
	DD	01cH
	DD	0247eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_program_interrupt
	DD	01cH
	DD	01e86H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:str_arch_psw
	DD	030H
	DD	02fdH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:copy_psw
	DD	030H
	DD	0f8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cpu_thread
	DD	016H
	DD	03f1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_trace_program_interrupt
	DD	020H
	DD	0bf2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_perform_io_interrupt
	DD	01cH
	DD	0c88H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:cpu_init
	DD	01dH
	DD	05c0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_psw
	DD	01bH
	DD	0ef6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_psw
	DD	01bH
	DD	0e31H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_psw
	DD	01bH
	DD	0119bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:host_tod
	DD	0eH
	DD	097H
voltbl	ENDS
xdata	SEGMENT
$unwind$host_tod DD 011319H
	DD	0a204H
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$s370_store_psw DD 010e01H
	DD	0420eH
$unwind$s370_load_psw DD 022319H
	DD	0210111H
	DD	imagerel __GSHandlerCheck
	DD	0f8H
$unwind$s370_process_trace DD 020f01H
	DD	0700b920fH
$unwind$s390_load_psw DD 022319H
	DD	01d0111H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$s390_store_psw DD 010e01H
	DD	0420eH
$unwind$s390_process_trace DD 020f01H
	DD	0700b920fH
$unwind$z900_load_psw DD 022319H
	DD	01f0111H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$z900_store_psw DD 010e01H
	DD	0420eH
$unwind$z900_process_trace DD 020f01H
	DD	0700b920fH
$unwind$cpu_init DD 022219H
	DD	0700fb213H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$s370_perform_io_interrupt DD 072419H
	DD	0240112H
	DD	07009e00bH
	DD	050076008H
	DD	03006H
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$s370_checkstop_all_cpus DD 010901H
	DD	06209H
$unwind$make_psw64 DD 011201H
	DD	06212H
$unwind$s370_SuccessfulBranch DD 010d01H
	DD	0a20dH
$unwind$s370_SuccessfulRelativeBranch DD 010e01H
	DD	0a20eH
$unwind$s370_fix_program_interrupt_PSW DD 010901H
	DD	0e209H
$unwind$s370_trace_program_interrupt DD 032819H
	DD	0420116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$cpu_thread DD 021e19H
	DD	015010cH
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$copy_psw DD 053719H
	DD	02c36011aH
	DD	0600c700dH
	DD	0500bH
	DD	imagerel __GSHandlerCheck
	DD	016104H
	DD	0a0H
	DD	080H
$unwind$display_psw DD 011301H
	DD	06213H
$unwind$str_psw DD 011301H
	DD	04213H
$unwind$str_arch_psw DD 0a3819H
	DD	0190126H
	DD	0e01df01fH
	DD	0c019d01bH
	DD	060167017H
	DD	030145015H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$do_automatic_tracing DD 010401H
	DD	0e204H
$unwind$s370_program_interrupt DD 042419H
	DD	0350112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$s390_program_interrupt DD 042419H
	DD	03b0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	01c0H
$unwind$z900_program_interrupt DD 042419H
	DD	03f0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$wakeup_cpu DD 010e01H
	DD	0420eH
$unwind$wakeup_cpu_mask DD 010e01H
	DD	0a20eH
$unwind$wakeup_cpus_mask DD 010e01H
	DD	0620eH
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$CPU_Wait DD 010901H
	DD	04209H
$unwind$cpu_uninit DD 010d01H
	DD	0a20dH
$unwind$s370_restart_interrupt DD 010901H
	DD	0a209H
$unwind$s370_perform_mck_interrupt DD 020d01H
	DD	07006f20dH
$unwind$s370_process_interrupt DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s370_run_cpu DD 042419H
	DD	0230112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$s390_perform_io_interrupt DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s390_checkstop_all_cpus DD 010901H
	DD	06209H
$unwind$s390_SuccessfulBranch DD 010d01H
	DD	0c20dH
$unwind$s390_SuccessfulRelativeBranch DD 010e01H
	DD	0c20eH
$unwind$s390_fix_program_interrupt_PSW DD 010901H
	DD	0e209H
$unwind$s390_trace_program_interrupt DD 032819H
	DD	0420116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$s390_restart_interrupt DD 010901H
	DD	0a209H
$unwind$s390_perform_mck_interrupt DD 020d01H
	DD	07006f20dH
$unwind$s390_process_interrupt DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$s390_run_cpu DD 042419H
	DD	0230112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0100H
$unwind$z900_perform_io_interrupt DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_checkstop_all_cpus DD 010901H
	DD	06209H
$unwind$z900_Set_BEAR_Reg DD 011301H
	DD	0a213H
$unwind$z900_SuccessfulBranch DD 010e01H
	DD	0c20eH
$unwind$z900_SuccessfulRelativeBranch DD 010e01H
	DD	0c20eH
$unwind$z900_fix_program_interrupt_PSW DD 010901H
	DD	0e209H
$unwind$z900_trace_program_interrupt DD 032819H
	DD	0420116H
	DD	0700fH
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$z900_restart_interrupt DD 010901H
	DD	0a209H
$unwind$z900_perform_mck_interrupt DD 020c01H
	DD	011010cH
$unwind$z900_process_interrupt DD 021e19H
	DD	019010cH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_run_cpu DD 042419H
	DD	0290112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0130H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 96
i$ = 104
ip$ = 112
current_opcode_table$ = 120
tv222 = 128
tv371 = 132
tv489 = 136
tv613 = 140
aswitch$ = 144
tv392 = 148
tv510 = 152
tv634 = 156
tv79 = 160
tv377 = 168
tv495 = 176
tv619 = 184
tv145 = 192
tv153 = 200
tv184 = 208
tv192 = 216
tv275 = 224
tv296 = 232
tv394 = 240
tv512 = 248
tv636 = 256
buf$1 = 264
__$ArrayPad$ = 304
cpu$ = 352
oldregs$ = 360
z900_run_cpu PROC

; 1905 : {

$LN166:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1906 : const INSTR_FUNC   *current_opcode_table;
; 1907 : register REGS   *regs;
; 1908 : BYTE   *ip;
; 1909 : int     i = 0;

  00024	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1910 : int     aswitch;
; 1911 : 
; 1912 :     /* Assign new regs if not already assigned */
; 1913 :     regs = sysblk.regs[cpu] ?

  0002c	48 63 84 24 60
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003b	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00044	74 21		 je	 SHORT $LN136@z900_run_c
  00046	48 63 84 24 60
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00055	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0005d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  00065	eb 18		 jmp	 SHORT $LN137@z900_run_c
$LN136@z900_run_c:
  00067	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0006c	b9 00 70 01 00	 mov	 ecx, 94208		; 00017000H
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  00077	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN137@z900_run_c:
  0007f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv79[rsp]
  00087	48 89 44 24 60	 mov	 QWORD PTR regs$[rsp], rax

; 1914 :            sysblk.regs[cpu] :
; 1915 :            malloc_aligned( ROUND_UP( sizeof( REGS ), _4K ), _4K );
; 1916 : 
; 1917 :     if (oldregs)

  0008c	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR oldregs$[rsp], 0
  00095	0f 84 b6 01 00
	00		 je	 $LN86@z900_run_c

; 1918 :     {
; 1919 :         if (oldregs != regs)

  0009b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	48 39 84 24 68
	01 00 00	 cmp	 QWORD PTR oldregs$[rsp], rax
  000a8	0f 84 9e 01 00
	00		 je	 $LN88@z900_run_c

; 1920 :         {
; 1921 :             TXF_FREEMAP( oldregs );

  000ae	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR oldregs$[rsp]
  000b6	e8 00 00 00 00	 call	 free_txfmap

; 1922 :             memcpy (regs, oldregs, sizeof(REGS));

  000bb	48 8b 7c 24 60	 mov	 rdi, QWORD PTR regs$[rsp]
  000c0	48 8b b4 24 68
	01 00 00	 mov	 rsi, QWORD PTR oldregs$[rsp]
  000c8	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  000cd	f3 a4		 rep movsb

; 1923 :             free_aligned(oldregs);

  000cf	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR oldregs$[rsp]
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 1924 :             regs->blkloc = CSWAP64((U64)((uintptr_t)regs));

  000dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000e2	e8 00 00 00 00	 call	 _byteswap_uint64
  000e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1925 :             HOSTREGS = regs;

  000f0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000fa	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 1926 :             if (GUESTREGS)

  00101	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00106	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  0010e	74 18		 je	 SHORT $LN89@z900_run_c

; 1927 :                 HOST(GUESTREGS) = regs;

  00110	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00115	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx
$LN89@z900_run_c:

; 1928 :             sysblk.regs[cpu] = regs;

  00128	48 63 84 24 60
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00130	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00137	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 89 94 c1 98
	0b 00 00	 mov	 QWORD PTR [rcx+rax*8+2968], rdx

; 1929 :             release_lock(&sysblk.cpulock[cpu]);

  00144	48 63 84 24 60
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0014c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00153	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196738
  00162	48 8b c8	 mov	 rcx, rax
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1930 :             if (regs->insttrace && sysblk.traceFILE)

  0016b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00170	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00176	c1 e8 0f	 shr	 eax, 15
  00179	83 e0 01	 and	 eax, 1
  0017c	85 c0		 test	 eax, eax
  0017e	74 29		 je	 SHORT $LN90@z900_run_c
  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00187	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0018f	74 18		 je	 SHORT $LN90@z900_run_c

; 1931 :                 tf_0811( regs, get_arch_name( regs ));

  00191	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	e8 00 00 00 00	 call	 get_arch_name
  0019b	48 8b d0	 mov	 rdx, rax
  0019e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0811
$LN90@z900_run_c:

; 1932 :             // "Processor %s%02X: architecture mode %s"
; 1933 :             WRMSG( HHC00811, "I", PTYPSTR( cpu ), cpu, get_arch_name( regs ));

  001a9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	e8 00 00 00 00	 call	 get_arch_name
  001b3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv145[rsp], rax
  001bb	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  001c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001ca	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001d8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv153[rsp], rax
  001e0	b9 01 00 00 00	 mov	 ecx, 1
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001eb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv145[rsp]
  001f3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001f8	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  001ff	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00203	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv153[rsp]
  0020b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196740
  00217	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196741
  00223	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00228	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00233	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196742
  0023a	ba 8d 07 00 00	 mov	 edx, 1933		; 0000078dH
  0023f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196743
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN88@z900_run_c:

; 1934 :         }
; 1935 :     }

  0024c	e9 0e 01 00 00	 jmp	 $LN87@z900_run_c
$LN86@z900_run_c:

; 1936 :     else
; 1937 :     {
; 1938 :         memset(regs, 0, sizeof(REGS));

  00251	48 8b 7c 24 60	 mov	 rdi, QWORD PTR regs$[rsp]
  00256	33 c0		 xor	 eax, eax
  00258	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  0025d	f3 aa		 rep stosb

; 1939 :         
; 1940 :                 if (cpu_init( cpu, regs, NULL ))

  0025f	45 33 c0	 xor	 r8d, r8d
  00262	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00267	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0026e	e8 00 00 00 00	 call	 cpu_init
  00273	85 c0		 test	 eax, eax
  00275	74 07		 je	 SHORT $LN91@z900_run_c

; 1941 :             return NULL;

  00277	33 c0		 xor	 eax, eax
  00279	e9 ad 13 00 00	 jmp	 $LN1@z900_run_c
$LN91@z900_run_c:

; 1942 : 
; 1943 :         if (regs->insttrace && sysblk.traceFILE)

  0027e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00283	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00289	c1 e8 0f	 shr	 eax, 15
  0028c	83 e0 01	 and	 eax, 1
  0028f	85 c0		 test	 eax, eax
  00291	74 29		 je	 SHORT $LN92@z900_run_c
  00293	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0029a	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  002a2	74 18		 je	 SHORT $LN92@z900_run_c

; 1944 :             tf_0811( regs, get_arch_name( regs ));

  002a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	e8 00 00 00 00	 call	 get_arch_name
  002ae	48 8b d0	 mov	 rdx, rax
  002b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0811
$LN92@z900_run_c:

; 1945 : 
; 1946 :         // "Processor %s%02X: architecture mode %s"
; 1947 :         WRMSG( HHC00811, "I", PTYPSTR( cpu ), cpu, get_arch_name( regs ));

  002bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002c1	e8 00 00 00 00	 call	 get_arch_name
  002c6	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv184[rsp], rax
  002ce	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  002d6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002dd	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  002eb	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv192[rsp], rax
  002f3	b9 01 00 00 00	 mov	 ecx, 1
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002fe	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv184[rsp]
  00306	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0030b	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00312	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00316	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv192[rsp]
  0031e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196746
  0032a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0032f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196747
  00336	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0033b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00340	41 b9 03 00 00
	00		 mov	 r9d, 3
  00346	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196748
  0034d	ba 9b 07 00 00	 mov	 edx, 1947		; 0000079bH
  00352	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196749
  00359	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN87@z900_run_c:

; 1948 : 
; 1949 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 1950 :         if (regs->vf->online)
; 1951 :         {
; 1952 :             if (regs->insttrace && sysblk.traceFILE)
; 1953 :                 tf_0812( regs, get_arch_name( regs ));
; 1954 : 
; 1955 :             // "Processor %s%02X: vector facility online"
; 1956 :             WRMSG( HHC00812, "I", PTYPSTR( cpu ), cpu );
; 1957 :         }
; 1958 : #endif
; 1959 :     }
; 1960 : 
; 1961 :     regs->program_interrupt = &ARCH_DEP(program_interrupt);

  0035f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00364	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:z900_program_interrupt
  0036b	48 89 88 20 0d
	00 00		 mov	 QWORD PTR [rax+3360], rcx

; 1962 : 
; 1963 :     regs->breakortrace = (sysblk.instbreak || (sysblk.insttrace && regs->insttrace));

  00372	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00379	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0037f	c1 e8 0a	 shr	 eax, 10
  00382	83 e0 01	 and	 eax, 1
  00385	85 c0		 test	 eax, eax
  00387	75 39		 jne	 SHORT $LN139@z900_run_c
  00389	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00390	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00396	c1 e8 08	 shr	 eax, 8
  00399	83 e0 01	 and	 eax, 1
  0039c	85 c0		 test	 eax, eax
  0039e	74 15		 je	 SHORT $LN138@z900_run_c
  003a0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003a5	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003ab	c1 e8 0f	 shr	 eax, 15
  003ae	83 e0 01	 and	 eax, 1
  003b1	85 c0		 test	 eax, eax
  003b3	75 0d		 jne	 SHORT $LN139@z900_run_c
$LN138@z900_run_c:
  003b5	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv222[rsp], 0
  003c0	eb 0b		 jmp	 SHORT $LN140@z900_run_c
$LN139@z900_run_c:
  003c2	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv222[rsp], 1
$LN140@z900_run_c:
  003cd	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv222[rsp]
  003d4	83 e0 01	 and	 eax, 1
  003d7	c1 e0 10	 shl	 eax, 16
  003da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  003e5	0f ba f1 10	 btr	 ecx, 16
  003e9	0b c8		 or	 ecx, eax
  003eb	8b c1		 mov	 eax, ecx
  003ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003f2	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1964 :     regs->ints_state |= sysblk.ints_state;

  003f8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00404	8b 89 a0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4768]
  0040a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0040d	0b c1		 or	 eax, ecx
  0040f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00414	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1965 : 
; 1966 :     /* Establish longjmp destination for cpu thread exit */
; 1967 :     if (setjmp(regs->exitjmp))

  00417	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0041c	48 05 80 0b 00
	00		 add	 rax, 2944		; 00000b80H
  00422	48 8b c8	 mov	 rcx, rax
  00425	48 8b d4	 mov	 rdx, rsp
  00428	e8 00 00 00 00	 call	 _setjmp
  0042d	85 c0		 test	 eax, eax
  0042f	74 16		 je	 SHORT $LN93@z900_run_c

; 1968 :         return cpu_uninit(cpu, regs);

  00431	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00436	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0043d	e8 00 00 00 00	 call	 cpu_uninit
  00442	e9 e4 11 00 00	 jmp	 $LN1@z900_run_c
$LN93@z900_run_c:

; 1969 : 
; 1970 :     /* Establish longjmp destination for architecture switch */
; 1971 :     aswitch = setjmp(regs->archjmp);

  00447	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0044c	48 05 80 0a 00
	00		 add	 rax, 2688		; 00000a80H
  00452	48 8b c8	 mov	 rcx, rax
  00455	48 8b d4	 mov	 rdx, rsp
  00458	e8 00 00 00 00	 call	 _setjmp
  0045d	89 84 24 90 00
	00 00		 mov	 DWORD PTR aswitch$[rsp], eax

; 1972 : 
; 1973 :     /* Switch architecture mode if appropriate */
; 1974 :     if(sysblk.arch_mode != regs->arch_mode)

  00464	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0046b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00470	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  00473	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  00479	0f 84 fb 01 00
	00		 je	 $LN94@z900_run_c
$LN4@z900_run_c:

; 1975 :     {
; 1976 :         PTT_INF("*SETARCH",regs->arch_mode,sysblk.arch_mode,cpu);

  0047f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00486	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00489	48 83 e0 08	 and	 rax, 8
  0048d	48 85 c0	 test	 rax, rax
  00490	74 51		 je	 SHORT $LN95@z900_run_c
  00492	48 63 84 24 60
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0049a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004a1	48 63 89 88 00
	00 00		 movsxd	 rcx, DWORD PTR [rcx+136]
  004a8	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  004ad	48 63 52 64	 movsxd	 rdx, DWORD PTR [rdx+100]
  004b1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004ba	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196753
  004c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004cb	4c 8b c9	 mov	 r9, rcx
  004ce	4c 8b c2	 mov	 r8, rdx
  004d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196754
  004d8	b9 08 00 00 00	 mov	 ecx, 8
  004dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN95@z900_run_c:
  004e3	33 c0		 xor	 eax, eax
  004e5	85 c0		 test	 eax, eax
  004e7	75 96		 jne	 SHORT $LN4@z900_run_c

; 1977 :         regs->arch_mode = sysblk.arch_mode;

  004e9	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  004ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004f5	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  004fb	89 48 64	 mov	 DWORD PTR [rax+100], ecx

; 1978 : 
; 1979 :         /* Ensure CPU ID is accurate in case archmode changed */
; 1980 :         setCpuIdregs( regs, -1, -1, -1, -1, true );

  004fe	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  00503	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  0050b	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00511	66 41 b8 ff ff	 mov	 r8w, -1
  00516	ba ff ff ff ff	 mov	 edx, -1
  0051b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00520	e8 00 00 00 00	 call	 setCpuIdregs

; 1981 : 
; 1982 :         oldregs = malloc_aligned(sizeof(REGS), 4096);

  00525	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0052a	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  0052f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  00535	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR oldregs$[rsp], rax

; 1983 :         if (oldregs)

  0053d	48 83 bc 24 68
	01 00 00 00	 cmp	 QWORD PTR oldregs$[rsp], 0
  00546	74 40		 je	 SHORT $LN96@z900_run_c

; 1984 :         {
; 1985 :             memcpy(oldregs, regs, sizeof(REGS));

  00548	48 8b bc 24 68
	01 00 00	 mov	 rdi, QWORD PTR oldregs$[rsp]
  00550	48 8b 74 24 60	 mov	 rsi, QWORD PTR regs$[rsp]
  00555	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  0055a	f3 a4		 rep movsb

; 1986 :             obtain_lock(&sysblk.cpulock[cpu]);

  0055c	48 63 84 24 60
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00564	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0056b	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00573	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196757
  0057a	48 8b c8	 mov	 rcx, rax
  0057d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1987 :         }

  00583	e9 e5 00 00 00	 jmp	 $LN97@z900_run_c
$LN96@z900_run_c:

; 1988 :         else
; 1989 :         {
; 1990 :             char buf[40];
; 1991 :             MSGBUF(buf, "malloc(%d)", (int)sizeof(REGS));

  00588	41 b9 80 60 01
	00		 mov	 r9d, 90240		; 00016080H
  0058e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196758
  00595	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  0059a	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1992 :             // "Processor %s%02X: error in function %s: %s"
; 1993 :             WRMSG (HHC00813, "E", PTYPSTR(cpu), cpu, buf, strerror(errno));

  005a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005ae	8b 08		 mov	 ecx, DWORD PTR [rax]
  005b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  005b6	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
  005be	48 63 8c 24 60
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  005c6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005cd	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  005d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  005db	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv296[rsp], rax
  005e3	b9 01 00 00 00	 mov	 ecx, 1
  005e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ee	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv275[rsp]
  005f6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005fb	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00603	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00608	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0060f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00613	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv296[rsp]
  0061b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00620	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196759
  00627	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0062c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196760
  00633	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00638	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0063d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00643	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196761
  0064a	ba c9 07 00 00	 mov	 edx, 1993		; 000007c9H
  0064f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196762
  00656	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1994 :             cpu_uninit (cpu, regs);

  0065c	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00661	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00668	e8 00 00 00 00	 call	 cpu_uninit
$LN97@z900_run_c:

; 1995 :         }
; 1996 :         return oldregs;

  0066d	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR oldregs$[rsp]
  00675	e9 b1 0f 00 00	 jmp	 $LN1@z900_run_c
$LN94@z900_run_c:

; 1997 :     }
; 1998 : 
; 1999 :     /* Initialize Facilities List */
; 2000 :     init_cpu_facilities( regs );

  0067a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0067f	e8 00 00 00 00	 call	 init_cpu_facilities

; 2001 : 
; 2002 :     /* Initialize Transactional-Execution Facility */
; 2003 :     TXF_ALLOCMAP( regs );

  00684	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00689	e8 00 00 00 00	 call	 alloc_txfmap

; 2004 : 
; 2005 :     /* Get pointer to primary opcode table */
; 2006 :     current_opcode_table = regs->ARCH_DEP( runtime_opcode_xxxx );

  0068e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00693	48 8b 80 28 b0
	00 00		 mov	 rax, QWORD PTR [rax+45096]
  0069a	48 89 44 24 78	 mov	 QWORD PTR current_opcode_table$[rsp], rax

; 2007 : 
; 2008 :     /* Signal cpu has started */
; 2009 :     if(!aswitch)

  0069f	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR aswitch$[rsp], 0
  006a7	75 1d		 jne	 SHORT $LN98@z900_run_c

; 2010 :         signal_condition (&sysblk.cpucond);

  006a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006b0	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  006b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196764
  006bd	48 8b c8	 mov	 rcx, rax
  006c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN98@z900_run_c:

; 2011 : 
; 2012 :     RELEASE_INTLOCK(regs);

  006c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196765
  006cd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006d2	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2013 : 
; 2014 :     /* Establish longjmp destination for program check or
; 2015 :        RETURN_INTCHECK, or SIE_INTERCEPT, or longjmp, etc.
; 2016 :     */
; 2017 :     if (setjmp( regs->progjmp ) && sysblk.ipled)

  006d7	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006dc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  006e2	48 8b c8	 mov	 rcx, rax
  006e5	48 8b d4	 mov	 rdx, rsp
  006e8	e8 00 00 00 00	 call	 _setjmp
  006ed	85 c0		 test	 eax, eax
  006ef	74 56		 je	 SHORT $LN99@z900_run_c
  006f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006f8	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006fe	d1 e8		 shr	 eax, 1
  00700	83 e0 01	 and	 eax, 1
  00703	85 c0		 test	 eax, eax
  00705	74 40		 je	 SHORT $LN99@z900_run_c

; 2018 :     {
; 2019 :         /* Our instruction execution loop further below didn't finish
; 2020 :            due to a longjmp(progjmp) having been executed bringing us
; 2021 :            to here, thereby causing the instruction counter to not be
; 2022 :            properly updated. Thus, we need to update it here instead.
; 2023 :        */
; 2024 :         regs->instcount   +=     (i * 2);

  00707	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0070c	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00712	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  00716	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  00719	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0071e	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2025 :         UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  00724	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00728	03 c0		 add	 eax, eax
  0072a	48 98		 cdqe
  0072c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00733	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  0073a	48 8b d0	 mov	 rdx, rax
  0073d	e8 00 00 00 00	 call	 atomic_update64

; 2026 : 
; 2027 :         /* Perform automatic instruction tracing if it's enabled */
; 2028 :         do_automatic_tracing();

  00742	e8 00 00 00 00	 call	 do_automatic_tracing
$LN99@z900_run_c:

; 2029 :     }
; 2030 : 
; 2031 :     /* Set `execflag' to 0 in case EXecuted instruction did a longjmp() */
; 2032 :     regs->execflag = 0;

  00747	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0074c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00752	83 e0 fe	 and	 eax, -2			; fffffffeH
  00755	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0075a	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2033 : 
; 2034 :     //--------------------------------------------------------------
; 2035 :     //                    PROGRAMMING NOTE
; 2036 :     //--------------------------------------------------------------
; 2037 :     // The first 'fastest_no_txf_loop' loop below is used when the
; 2038 :     // TXF facility is not enabled, and since facilities cannot be
; 2039 :     // enabled or disabled once the guest system has been IPLed and
; 2040 :     // started, it utilizes our original instruction execution loop
; 2041 :     // which uses the 'EXECUTE_INSTRUCTION' and 'UNROLLED_EXECUTE'
; 2042 :     // macros which do not have any TXF related code in them.
; 2043 :     //
; 2044 :     // The second and third loops below (the 'txf_facility_loop' and
; 2045 :     // 'txf_slower_loop') are used when the TXF facility is enabled,
; 2046 :     // requiring us to check whether or not a transaction is active
; 2047 :     // or not after each instruction is executed.
; 2048 :     //
; 2049 :     // If no transaction is active, the normal 'EXECUTE_INSTRUCTION'
; 2050 :     // and 'UNROLLED_EXECUTE' macros can be used, but a check for an
; 2051 :     // active transaction still needs to be performed after each and
; 2052 :     // every instruction (so we can know which loop we need to use).
; 2053 :     //
; 2054 :     // When a transaction is active, we use the third (slowest) loop
; 2055 :     // called 'txf_slower_loop', using the 'TXF_EXECUTE_INSTRUCTION'
; 2056 :     // and 'TXF_UNROLLED_EXECUTE' macros, which contain code that
; 2057 :     // enforces certain Transaction-Exceution Facility constraints.
; 2058 :     //--------------------------------------------------------------
; 2059 : 
; 2060 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 2061 :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  00760	b8 01 00 00 00	 mov	 eax, 1
  00765	48 6b c0 09	 imul	 rax, rax, 9
  00769	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0076e	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00776	83 e0 40	 and	 eax, 64			; 00000040H
  00779	85 c0		 test	 eax, eax
  0077b	74 2d		 je	 SHORT $LN100@z900_run_c

; 2062 :         if (regs->CR(0) & CR0_TXC)

  0077d	b8 08 00 00 00	 mov	 eax, 8
  00782	48 6b c0 01	 imul	 rax, rax, 1
  00786	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0078b	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  00795	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0079d	48 23 c2	 and	 rax, rdx
  007a0	48 85 c0	 test	 rax, rax
  007a3	74 05		 je	 SHORT $LN101@z900_run_c

; 2063 :             goto txf_facility_loop;

  007a5	e9 0d 03 00 00	 jmp	 $txf_facility_loop$167
$LN101@z900_run_c:
$LN100@z900_run_c:
$fastest_no_txf_loop$168:

; 2064 : #endif
; 2065 : 
; 2066 : fastest_no_txf_loop:
; 2067 : 
; 2068 :     if (INTERRUPT_PENDING( regs ))

  007aa	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007b4	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  007b7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  007ba	23 c1		 and	 eax, ecx
  007bc	85 c0		 test	 eax, eax
  007be	74 0a		 je	 SHORT $LN102@z900_run_c

; 2069 :         ARCH_DEP( process_interrupt )( regs );

  007c0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007c5	e8 00 00 00 00	 call	 z900_process_interrupt
$LN102@z900_run_c:
$enter_fastest_no_txf_loop$169:

; 2070 : 
; 2071 : enter_fastest_no_txf_loop:
; 2072 : 
; 2073 :     ip = INSTRUCTION_FETCH( regs, 0 );

  007ca	33 c0		 xor	 eax, eax
  007cc	83 f8 01	 cmp	 eax, 1
  007cf	74 17		 je	 SHORT $LN141@z900_run_c
  007d1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007db	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  007e2	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  007e6	72 13		 jb	 SHORT $LN142@z900_run_c
$LN141@z900_run_c:
  007e8	33 c0		 xor	 eax, eax
  007ea	85 c0		 test	 eax, eax
  007ec	75 0d		 jne	 SHORT $LN142@z900_run_c
  007ee	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv371[rsp], 0
  007f9	eb 0b		 jmp	 SHORT $LN146@z900_run_c
$LN142@z900_run_c:
  007fb	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv371[rsp], 1
$LN146@z900_run_c:
  00806	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv371[rsp], 0
  0080e	74 13		 je	 SHORT $LN147@z900_run_c
  00810	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00815	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00819	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv377[rsp], rax
  00821	eb 14		 jmp	 SHORT $LN148@z900_run_c
$LN147@z900_run_c:
  00823	33 d2		 xor	 edx, edx
  00825	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0082a	e8 00 00 00 00	 call	 z900_instfetch
  0082f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv377[rsp], rax
$LN148@z900_run_c:
  00837	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv377[rsp]
  0083f	48 89 44 24 70	 mov	 QWORD PTR ip$[rsp], rax
$LN7@z900_run_c:

; 2074 :     PROCESS_TRACE( regs, ip, enter_fastest_no_txf_loop );

  00844	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00849	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0084f	c1 e8 10	 shr	 eax, 16
  00852	83 e0 01	 and	 eax, 1
  00855	85 c0		 test	 eax, eax
  00857	0f 84 e6 00 00
	00		 je	 $LN103@z900_run_c
  0085d	48 8b 54 24 70	 mov	 rdx, QWORD PTR ip$[rsp]
  00862	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00867	e8 00 00 00 00	 call	 z900_process_trace
  0086c	33 c0		 xor	 eax, eax
  0086e	83 f8 01	 cmp	 eax, 1
  00871	0f 84 cc 00 00
	00		 je	 $LN104@z900_run_c
  00877	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0087c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00882	c1 e8 11	 shr	 eax, 17
  00885	83 e0 01	 and	 eax, 1
  00888	85 c0		 test	 eax, eax
  0088a	0f 84 b3 00 00
	00		 je	 $LN104@z900_run_c
  00890	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00895	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0089d	0f 85 a0 00 00
	00		 jne	 $LN104@z900_run_c
  008a3	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  008a8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  008af	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv392[rsp], eax
  008b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  008bb	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  008c2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008c9	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  008d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  008d7	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv394[rsp], rax
  008df	b9 01 00 00 00	 mov	 ecx, 1
  008e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008ea	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv392[rsp]
  008f1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008f5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv394[rsp]
  008fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00902	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196772
  00909	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0090e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196773
  00915	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0091a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0091f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00925	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196774
  0092c	ba 1a 08 00 00	 mov	 edx, 2074		; 0000081aH
  00931	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196775
  00938	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0093e	e9 87 fe ff ff	 jmp	 $enter_fastest_no_txf_loop$169
$LN104@z900_run_c:
$LN103@z900_run_c:
  00943	33 c0		 xor	 eax, eax
  00945	85 c0		 test	 eax, eax
  00947	0f 85 f7 fe ff
	ff		 jne	 $LN7@z900_run_c
$LN10@z900_run_c:

; 2075 :     EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );

  0094d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  00952	e8 00 00 00 00	 call	 fetch_hw_noswap
  00957	0f b7 c8	 movzx	 ecx, ax
  0095a	e8 00 00 00 00	 call	 _byteswap_ushort
  0095f	0f b7 c0	 movzx	 eax, ax
  00962	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00967	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  0096c	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00971	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00974	33 c0		 xor	 eax, eax
  00976	85 c0		 test	 eax, eax
  00978	75 d3		 jne	 SHORT $LN10@z900_run_c

; 2076 :     regs->instcount++;

  0097a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0097f	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00985	ff c0		 inc	 eax
  00987	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0098c	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2077 :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  00992	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00999	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  0099f	ba 01 00 00 00	 mov	 edx, 1
  009a4	48 8b c8	 mov	 rcx, rax
  009a7	e8 00 00 00 00	 call	 atomic_update64

; 2078 : 
; 2079 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)

  009ac	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  009b4	eb 0a		 jmp	 SHORT $LN13@z900_run_c
$LN11@z900_run_c:
  009b6	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  009ba	ff c0		 inc	 eax
  009bc	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_run_c:
  009c0	81 7c 24 68 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  009c8	0f 8d a4 00 00
	00		 jge	 $LN12@z900_run_c

; 2080 :     {
; 2081 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  009ce	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  009d3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  009d8	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  009df	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  009e3	72 05		 jb	 SHORT $LN105@z900_run_c
  009e5	e9 88 00 00 00	 jmp	 $LN12@z900_run_c
$LN105@z900_run_c:
$LN16@z900_run_c:
  009ea	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  009ef	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  009f3	e8 00 00 00 00	 call	 fetch_hw_noswap
  009f8	0f b7 c8	 movzx	 ecx, ax
  009fb	e8 00 00 00 00	 call	 _byteswap_ushort
  00a00	0f b7 c0	 movzx	 eax, ax
  00a03	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00a08	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00a0d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00a11	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00a16	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00a19	33 c0		 xor	 eax, eax
  00a1b	85 c0		 test	 eax, eax
  00a1d	75 cb		 jne	 SHORT $LN16@z900_run_c

; 2082 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  00a1f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00a24	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00a29	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00a30	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00a34	72 02		 jb	 SHORT $LN106@z900_run_c
  00a36	eb 3a		 jmp	 SHORT $LN12@z900_run_c
$LN106@z900_run_c:
$LN19@z900_run_c:
  00a38	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00a3d	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00a41	e8 00 00 00 00	 call	 fetch_hw_noswap
  00a46	0f b7 c8	 movzx	 ecx, ax
  00a49	e8 00 00 00 00	 call	 _byteswap_ushort
  00a4e	0f b7 c0	 movzx	 eax, ax
  00a51	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00a56	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00a5b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00a5f	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00a64	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00a67	33 c0		 xor	 eax, eax
  00a69	85 c0		 test	 eax, eax
  00a6b	75 cb		 jne	 SHORT $LN19@z900_run_c

; 2083 :     }

  00a6d	e9 44 ff ff ff	 jmp	 $LN11@z900_run_c
$LN12@z900_run_c:

; 2084 :     regs->instcount   +=     (i * 2);

  00a72	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00a77	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00a7d	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  00a81	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  00a84	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00a89	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2085 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  00a8f	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a93	03 c0		 add	 eax, eax
  00a95	48 98		 cdqe
  00a97	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a9e	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  00aa5	48 8b d0	 mov	 rdx, rax
  00aa8	e8 00 00 00 00	 call	 atomic_update64

; 2086 : 
; 2087 :     /* Perform automatic instruction tracing if it's enabled */
; 2088 :     do_automatic_tracing();

  00aad	e8 00 00 00 00	 call	 do_automatic_tracing

; 2089 :     goto fastest_no_txf_loop;

  00ab2	e9 f3 fc ff ff	 jmp	 $fastest_no_txf_loop$168
$txf_facility_loop$167:

; 2090 : 
; 2091 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 2092 : 
; 2093 : txf_facility_loop:
; 2094 : 
; 2095 :     if (INTERRUPT_PENDING( regs ))

  00ab7	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00abc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac1	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00ac4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00ac7	23 c1		 and	 eax, ecx
  00ac9	85 c0		 test	 eax, eax
  00acb	74 0a		 je	 SHORT $LN107@z900_run_c

; 2096 :         ARCH_DEP( process_interrupt )( regs );

  00acd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00ad2	e8 00 00 00 00	 call	 z900_process_interrupt
$LN107@z900_run_c:

; 2097 : 
; 2098 :     if (regs->txf_tnd)

  00ad7	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00adc	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00ae3	85 c0		 test	 eax, eax
  00ae5	74 05		 je	 SHORT $LN108@z900_run_c

; 2099 :         goto enter_txf_slower_loop;

  00ae7	e9 44 03 00 00	 jmp	 $enter_txf_slower_loop$170
$LN108@z900_run_c:
$LN165@z900_run_c:
$enter_txf_faster_loop$171:

; 2100 : 
; 2101 : enter_txf_faster_loop:
; 2102 : 
; 2103 :     ip = INSTRUCTION_FETCH( regs, 0 );

  00aec	33 c0		 xor	 eax, eax
  00aee	83 f8 01	 cmp	 eax, 1
  00af1	74 17		 je	 SHORT $LN149@z900_run_c
  00af3	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00af8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00afd	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00b04	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00b08	72 13		 jb	 SHORT $LN150@z900_run_c
$LN149@z900_run_c:
  00b0a	33 c0		 xor	 eax, eax
  00b0c	85 c0		 test	 eax, eax
  00b0e	75 0d		 jne	 SHORT $LN150@z900_run_c
  00b10	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv489[rsp], 0
  00b1b	eb 0b		 jmp	 SHORT $LN154@z900_run_c
$LN150@z900_run_c:
  00b1d	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv489[rsp], 1
$LN154@z900_run_c:
  00b28	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR tv489[rsp], 0
  00b30	74 13		 je	 SHORT $LN155@z900_run_c
  00b32	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00b37	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00b3b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv495[rsp], rax
  00b43	eb 14		 jmp	 SHORT $LN156@z900_run_c
$LN155@z900_run_c:
  00b45	33 d2		 xor	 edx, edx
  00b47	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00b4c	e8 00 00 00 00	 call	 z900_instfetch
  00b51	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv495[rsp], rax
$LN156@z900_run_c:
  00b59	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv495[rsp]
  00b61	48 89 44 24 70	 mov	 QWORD PTR ip$[rsp], rax
$LN22@z900_run_c:

; 2104 :     PROCESS_TRACE( regs, ip, enter_txf_faster_loop );

  00b66	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00b6b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b71	c1 e8 10	 shr	 eax, 16
  00b74	83 e0 01	 and	 eax, 1
  00b77	85 c0		 test	 eax, eax
  00b79	0f 84 e6 00 00
	00		 je	 $LN109@z900_run_c
  00b7f	48 8b 54 24 70	 mov	 rdx, QWORD PTR ip$[rsp]
  00b84	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00b89	e8 00 00 00 00	 call	 z900_process_trace
  00b8e	33 c0		 xor	 eax, eax
  00b90	83 f8 01	 cmp	 eax, 1
  00b93	0f 84 cc 00 00
	00		 je	 $LN110@z900_run_c
  00b99	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00b9e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00ba4	c1 e8 11	 shr	 eax, 17
  00ba7	83 e0 01	 and	 eax, 1
  00baa	85 c0		 test	 eax, eax
  00bac	0f 84 b3 00 00
	00		 je	 $LN110@z900_run_c
  00bb2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00bb7	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00bbf	0f 85 a0 00 00
	00		 jne	 $LN110@z900_run_c
  00bc5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00bca	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00bd1	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv510[rsp], eax
  00bd8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00bdd	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00be4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00beb	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00bf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00bf9	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv512[rsp], rax
  00c01	b9 01 00 00 00	 mov	 ecx, 1
  00c06	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c0c	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv510[rsp]
  00c13	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c17	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv512[rsp]
  00c1f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196782
  00c2b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196783
  00c37	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c3c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c41	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c47	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196784
  00c4e	ba 38 08 00 00	 mov	 edx, 2104		; 00000838H
  00c53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196785
  00c5a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00c60	e9 87 fe ff ff	 jmp	 $enter_txf_faster_loop$171
$LN110@z900_run_c:
$LN109@z900_run_c:
  00c65	33 c0		 xor	 eax, eax
  00c67	85 c0		 test	 eax, eax
  00c69	0f 85 f7 fe ff
	ff		 jne	 $LN22@z900_run_c
$LN25@z900_run_c:

; 2105 :     EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );

  00c6f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  00c74	e8 00 00 00 00	 call	 fetch_hw_noswap
  00c79	0f b7 c8	 movzx	 ecx, ax
  00c7c	e8 00 00 00 00	 call	 _byteswap_ushort
  00c81	0f b7 c0	 movzx	 eax, ax
  00c84	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00c89	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  00c8e	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00c93	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00c96	33 c0		 xor	 eax, eax
  00c98	85 c0		 test	 eax, eax
  00c9a	75 d3		 jne	 SHORT $LN25@z900_run_c

; 2106 :     regs->instcount++;

  00c9c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00ca1	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00ca7	ff c0		 inc	 eax
  00ca9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00cae	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2107 :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  00cb4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cbb	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  00cc1	ba 01 00 00 00	 mov	 edx, 1
  00cc6	48 8b c8	 mov	 rcx, rax
  00cc9	e8 00 00 00 00	 call	 atomic_update64

; 2108 : 
; 2109 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)

  00cce	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00cd6	eb 0a		 jmp	 SHORT $LN28@z900_run_c
$LN26@z900_run_c:
  00cd8	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00cdc	ff c0		 inc	 eax
  00cde	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN28@z900_run_c:
  00ce2	81 7c 24 68 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  00cea	0f 8d cb 00 00
	00		 jge	 $LN27@z900_run_c

; 2110 :     {
; 2111 :         if (regs->txf_tnd)

  00cf0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00cf5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00cfc	85 c0		 test	 eax, eax
  00cfe	74 05		 je	 SHORT $LN111@z900_run_c

; 2112 :             break;

  00d00	e9 b6 00 00 00	 jmp	 $LN27@z900_run_c
$LN111@z900_run_c:

; 2113 : 
; 2114 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  00d05	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00d0a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00d0f	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00d16	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00d1a	72 05		 jb	 SHORT $LN112@z900_run_c
  00d1c	e9 9a 00 00 00	 jmp	 $LN27@z900_run_c
$LN112@z900_run_c:
$LN31@z900_run_c:
  00d21	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00d26	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00d2a	e8 00 00 00 00	 call	 fetch_hw_noswap
  00d2f	0f b7 c8	 movzx	 ecx, ax
  00d32	e8 00 00 00 00	 call	 _byteswap_ushort
  00d37	0f b7 c0	 movzx	 eax, ax
  00d3a	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00d3f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00d44	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00d48	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00d4d	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00d50	33 c0		 xor	 eax, eax
  00d52	85 c0		 test	 eax, eax
  00d54	75 cb		 jne	 SHORT $LN31@z900_run_c

; 2115 : 
; 2116 :         if (regs->txf_tnd)

  00d56	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00d5b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00d62	85 c0		 test	 eax, eax
  00d64	74 02		 je	 SHORT $LN113@z900_run_c

; 2117 :             break;

  00d66	eb 53		 jmp	 SHORT $LN27@z900_run_c
$LN113@z900_run_c:

; 2118 : 
; 2119 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  00d68	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00d6d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00d72	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00d79	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00d7d	72 02		 jb	 SHORT $LN114@z900_run_c
  00d7f	eb 3a		 jmp	 SHORT $LN27@z900_run_c
$LN114@z900_run_c:
$LN34@z900_run_c:
  00d81	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00d86	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00d8a	e8 00 00 00 00	 call	 fetch_hw_noswap
  00d8f	0f b7 c8	 movzx	 ecx, ax
  00d92	e8 00 00 00 00	 call	 _byteswap_ushort
  00d97	0f b7 c0	 movzx	 eax, ax
  00d9a	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00d9f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00da4	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00da8	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00dad	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00db0	33 c0		 xor	 eax, eax
  00db2	85 c0		 test	 eax, eax
  00db4	75 cb		 jne	 SHORT $LN34@z900_run_c

; 2120 :     }

  00db6	e9 1d ff ff ff	 jmp	 $LN26@z900_run_c
$LN27@z900_run_c:

; 2121 :     regs->instcount   +=     (i * 2);

  00dbb	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00dc0	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00dc6	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  00dca	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  00dcd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00dd2	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2122 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  00dd8	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00ddc	03 c0		 add	 eax, eax
  00dde	48 98		 cdqe
  00de0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00de7	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  00dee	48 8b d0	 mov	 rdx, rax
  00df1	e8 00 00 00 00	 call	 atomic_update64

; 2123 : 
; 2124 :     /* Perform automatic instruction tracing if it's enabled */
; 2125 :     do_automatic_tracing();

  00df6	e8 00 00 00 00	 call	 do_automatic_tracing

; 2126 : 
; 2127 : //txf_slower_loop:
; 2128 : 
; 2129 :     if (INTERRUPT_PENDING( regs ))

  00dfb	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00e00	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00e05	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00e08	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00e0b	23 c1		 and	 eax, ecx
  00e0d	85 c0		 test	 eax, eax
  00e0f	74 0a		 je	 SHORT $LN115@z900_run_c

; 2130 :         ARCH_DEP( process_interrupt )( regs );

  00e11	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00e16	e8 00 00 00 00	 call	 z900_process_interrupt
$LN115@z900_run_c:

; 2131 : 
; 2132 :     if (!regs->txf_tnd)

  00e1b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00e20	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00e27	85 c0		 test	 eax, eax
  00e29	75 05		 jne	 SHORT $LN116@z900_run_c

; 2133 :         goto enter_txf_faster_loop;

  00e2b	e9 bc fc ff ff	 jmp	 $LN165@z900_run_c
$LN116@z900_run_c:
$enter_txf_slower_loop$170:

; 2134 : 
; 2135 : enter_txf_slower_loop:
; 2136 : 
; 2137 :     ip = INSTRUCTION_FETCH( regs, 0 );

  00e30	33 c0		 xor	 eax, eax
  00e32	83 f8 01	 cmp	 eax, 1
  00e35	74 17		 je	 SHORT $LN157@z900_run_c
  00e37	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00e3c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00e41	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00e48	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00e4c	72 13		 jb	 SHORT $LN158@z900_run_c
$LN157@z900_run_c:
  00e4e	33 c0		 xor	 eax, eax
  00e50	85 c0		 test	 eax, eax
  00e52	75 0d		 jne	 SHORT $LN158@z900_run_c
  00e54	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv613[rsp], 0
  00e5f	eb 0b		 jmp	 SHORT $LN162@z900_run_c
$LN158@z900_run_c:
  00e61	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv613[rsp], 1
$LN162@z900_run_c:
  00e6c	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR tv613[rsp], 0
  00e74	74 13		 je	 SHORT $LN163@z900_run_c
  00e76	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00e7b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00e7f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv619[rsp], rax
  00e87	eb 14		 jmp	 SHORT $LN164@z900_run_c
$LN163@z900_run_c:
  00e89	33 d2		 xor	 edx, edx
  00e8b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00e90	e8 00 00 00 00	 call	 z900_instfetch
  00e95	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv619[rsp], rax
$LN164@z900_run_c:
  00e9d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv619[rsp]
  00ea5	48 89 44 24 70	 mov	 QWORD PTR ip$[rsp], rax
$LN37@z900_run_c:

; 2138 :     PROCESS_TRACE( regs, ip, enter_txf_slower_loop );

  00eaa	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00eaf	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00eb5	c1 e8 10	 shr	 eax, 16
  00eb8	83 e0 01	 and	 eax, 1
  00ebb	85 c0		 test	 eax, eax
  00ebd	0f 84 e6 00 00
	00		 je	 $LN117@z900_run_c
  00ec3	48 8b 54 24 70	 mov	 rdx, QWORD PTR ip$[rsp]
  00ec8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00ecd	e8 00 00 00 00	 call	 z900_process_trace
  00ed2	33 c0		 xor	 eax, eax
  00ed4	83 f8 01	 cmp	 eax, 1
  00ed7	0f 84 cc 00 00
	00		 je	 $LN118@z900_run_c
  00edd	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00ee2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00ee8	c1 e8 11	 shr	 eax, 17
  00eeb	83 e0 01	 and	 eax, 1
  00eee	85 c0		 test	 eax, eax
  00ef0	0f 84 b3 00 00
	00		 je	 $LN118@z900_run_c
  00ef6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00efb	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00f03	0f 85 a0 00 00
	00		 jne	 $LN118@z900_run_c
  00f09	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00f0e	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00f15	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv634[rsp], eax
  00f1c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00f21	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00f28	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00f2f	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00f37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00f3d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv636[rsp], rax
  00f45	b9 01 00 00 00	 mov	 ecx, 1
  00f4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f50	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv634[rsp]
  00f57	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f5b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv636[rsp]
  00f63	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00f68	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196794
  00f6f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196795
  00f7b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f80	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f85	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f8b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196796
  00f92	ba 5a 08 00 00	 mov	 edx, 2138		; 0000085aH
  00f97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196797
  00f9e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00fa4	e9 87 fe ff ff	 jmp	 $enter_txf_slower_loop$170
$LN118@z900_run_c:
$LN117@z900_run_c:
  00fa9	33 c0		 xor	 eax, eax
  00fab	85 c0		 test	 eax, eax
  00fad	0f 85 f7 fe ff
	ff		 jne	 $LN37@z900_run_c
$LN40@z900_run_c:
$LN43@z900_run_c:

; 2139 :     TXF_EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );

  00fb3	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00fb8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00fbf	85 c0		 test	 eax, eax
  00fc1	0f 84 79 01 00
	00		 je	 $LN119@z900_run_c
$LN46@z900_run_c:
  00fc7	33 c0		 xor	 eax, eax
  00fc9	83 f8 01	 cmp	 eax, 1
  00fcc	74 5d		 je	 SHORT $LN120@z900_run_c
  00fce	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00fd3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00fda	85 c0		 test	 eax, eax
  00fdc	74 4d		 je	 SHORT $LN120@z900_run_c
  00fde	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00fe3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00fe8	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  00fef	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00ff3	72 36		 jb	 SHORT $LN120@z900_run_c
  00ff5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00ffa	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01000	0f ba e8 1f	 bts	 eax, 31
  01004	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01009	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0100f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196800
  01016	41 b8 0b 00 00
	00		 mov	 r8d, 11
  0101c	ba fe ff ff ff	 mov	 edx, -2
  01021	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01026	e8 00 00 00 00	 call	 z900_abort_transaction
$LN120@z900_run_c:
  0102b	33 c0		 xor	 eax, eax
  0102d	85 c0		 test	 eax, eax
  0102f	75 96		 jne	 SHORT $LN46@z900_run_c
  01031	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01036	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  0103d	66 ff c0	 inc	 ax
  01040	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01045	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax
$LN49@z900_run_c:
  0104c	33 c0		 xor	 eax, eax
  0104e	83 f8 01	 cmp	 eax, 1
  01051	74 72		 je	 SHORT $LN121@z900_run_c
  01053	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01058	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0105f	85 c0		 test	 eax, eax
  01061	74 62		 je	 SHORT $LN121@z900_run_c
  01063	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01068	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  0106f	83 f8 20	 cmp	 eax, 32			; 00000020H
  01072	7e 51		 jle	 SHORT $LN121@z900_run_c
  01074	41 b8 02 00 00
	00		 mov	 r8d, 2
  0107a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196802
  01081	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  01086	e8 00 00 00 00	 call	 memcmp
  0108b	85 c0		 test	 eax, eax
  0108d	74 36		 je	 SHORT $LN121@z900_run_c
  0108f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01094	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0109a	0f ba e8 1e	 bts	 eax, 30
  0109e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  010a3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  010a9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196803
  010b0	41 b8 0b 00 00
	00		 mov	 r8d, 11
  010b6	ba fe ff ff ff	 mov	 edx, -2
  010bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  010c0	e8 00 00 00 00	 call	 z900_abort_transaction
$LN121@z900_run_c:
  010c5	33 c0		 xor	 eax, eax
  010c7	85 c0		 test	 eax, eax
  010c9	75 81		 jne	 SHORT $LN49@z900_run_c
$LN52@z900_run_c:
  010cb	33 c0		 xor	 eax, eax
  010cd	83 f8 01	 cmp	 eax, 1
  010d0	74 68		 je	 SHORT $LN122@z900_run_c
  010d2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  010d7	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  010de	85 c0		 test	 eax, eax
  010e0	74 58		 je	 SHORT $LN122@z900_run_c
  010e2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  010e7	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  010ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  010f3	0f b7 89 60 0e
	00 00		 movzx	 ecx, WORD PTR [rcx+3680]
  010fa	3b c1		 cmp	 eax, ecx
  010fc	7c 3c		 jl	 SHORT $LN122@z900_run_c
  010fe	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01103	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01109	0f ba e8 1d	 bts	 eax, 29
  0110d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01112	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01118	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196805
  0111f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01124	44 8b 80 0c af
	00 00		 mov	 r8d, DWORD PTR [rax+44812]
  0112b	ba fe ff ff ff	 mov	 edx, -2
  01130	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01135	e8 00 00 00 00	 call	 z900_abort_transaction
$LN122@z900_run_c:
  0113a	33 c0		 xor	 eax, eax
  0113c	85 c0		 test	 eax, eax
  0113e	75 8b		 jne	 SHORT $LN52@z900_run_c
$LN119@z900_run_c:
  01140	33 c0		 xor	 eax, eax
  01142	85 c0		 test	 eax, eax
  01144	0f 85 69 fe ff
	ff		 jne	 $LN43@z900_run_c
  0114a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  0114f	e8 00 00 00 00	 call	 fetch_hw_noswap
  01154	0f b7 c8	 movzx	 ecx, ax
  01157	e8 00 00 00 00	 call	 _byteswap_ushort
  0115c	0f b7 c0	 movzx	 eax, ax
  0115f	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  01164	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  01169	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  0116e	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  01171	33 c0		 xor	 eax, eax
  01173	85 c0		 test	 eax, eax
  01175	0f 85 38 fe ff
	ff		 jne	 $LN40@z900_run_c

; 2140 :     regs->instcount++;

  0117b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01180	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  01186	ff c0		 inc	 eax
  01188	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0118d	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2141 :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  01193	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0119a	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  011a0	ba 01 00 00 00	 mov	 edx, 1
  011a5	48 8b c8	 mov	 rcx, rax
  011a8	e8 00 00 00 00	 call	 atomic_update64

; 2142 : 
; 2143 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)

  011ad	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  011b5	eb 0a		 jmp	 SHORT $LN55@z900_run_c
$LN53@z900_run_c:
  011b7	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  011bb	ff c0		 inc	 eax
  011bd	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN55@z900_run_c:
  011c1	81 7c 24 68 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  011c9	0f 8d 17 04 00
	00		 jge	 $LN54@z900_run_c

; 2144 :     {
; 2145 :         if (!regs->txf_tnd)

  011cf	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  011d4	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  011db	85 c0		 test	 eax, eax
  011dd	75 05		 jne	 SHORT $LN123@z900_run_c

; 2146 :             break;

  011df	e9 02 04 00 00	 jmp	 $LN54@z900_run_c
$LN123@z900_run_c:

; 2147 : 
; 2148 :         TXF_UNROLLED_EXECUTE( current_opcode_table, regs );

  011e4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  011e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  011ee	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  011f5	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  011f9	72 05		 jb	 SHORT $LN124@z900_run_c
  011fb	e9 e6 03 00 00	 jmp	 $LN54@z900_run_c
$LN124@z900_run_c:
$LN58@z900_run_c:
$LN61@z900_run_c:
  01200	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01205	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0120c	85 c0		 test	 eax, eax
  0120e	0f 84 81 01 00
	00		 je	 $LN125@z900_run_c
$LN64@z900_run_c:
  01214	33 c0		 xor	 eax, eax
  01216	83 f8 01	 cmp	 eax, 1
  01219	74 5d		 je	 SHORT $LN126@z900_run_c
  0121b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01220	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01227	85 c0		 test	 eax, eax
  01229	74 4d		 je	 SHORT $LN126@z900_run_c
  0122b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01230	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01235	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  0123c	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01240	72 36		 jb	 SHORT $LN126@z900_run_c
  01242	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01247	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0124d	0f ba e8 1f	 bts	 eax, 31
  01251	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01256	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0125c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196810
  01263	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01269	ba fe ff ff ff	 mov	 edx, -2
  0126e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01273	e8 00 00 00 00	 call	 z900_abort_transaction
$LN126@z900_run_c:
  01278	33 c0		 xor	 eax, eax
  0127a	85 c0		 test	 eax, eax
  0127c	75 96		 jne	 SHORT $LN64@z900_run_c
  0127e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01283	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  0128a	66 ff c0	 inc	 ax
  0128d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01292	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax
$LN67@z900_run_c:
  01299	33 c0		 xor	 eax, eax
  0129b	83 f8 01	 cmp	 eax, 1
  0129e	74 76		 je	 SHORT $LN127@z900_run_c
  012a0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  012a5	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  012ac	85 c0		 test	 eax, eax
  012ae	74 66		 je	 SHORT $LN127@z900_run_c
  012b0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  012b5	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  012bc	83 f8 20	 cmp	 eax, 32			; 00000020H
  012bf	7e 55		 jle	 SHORT $LN127@z900_run_c
  012c1	41 b8 02 00 00
	00		 mov	 r8d, 2
  012c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196812
  012ce	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  012d3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  012d7	e8 00 00 00 00	 call	 memcmp
  012dc	85 c0		 test	 eax, eax
  012de	74 36		 je	 SHORT $LN127@z900_run_c
  012e0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  012e5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  012eb	0f ba e8 1e	 bts	 eax, 30
  012ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  012f4	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  012fa	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196813
  01301	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01307	ba fe ff ff ff	 mov	 edx, -2
  0130c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01311	e8 00 00 00 00	 call	 z900_abort_transaction
$LN127@z900_run_c:
  01316	33 c0		 xor	 eax, eax
  01318	85 c0		 test	 eax, eax
  0131a	0f 85 79 ff ff
	ff		 jne	 $LN67@z900_run_c
$LN70@z900_run_c:
  01320	33 c0		 xor	 eax, eax
  01322	83 f8 01	 cmp	 eax, 1
  01325	74 68		 je	 SHORT $LN128@z900_run_c
  01327	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0132c	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  01333	85 c0		 test	 eax, eax
  01335	74 58		 je	 SHORT $LN128@z900_run_c
  01337	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0133c	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  01343	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01348	0f b7 89 60 0e
	00 00		 movzx	 ecx, WORD PTR [rcx+3680]
  0134f	3b c1		 cmp	 eax, ecx
  01351	7c 3c		 jl	 SHORT $LN128@z900_run_c
  01353	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01358	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  0135e	0f ba e8 1d	 bts	 eax, 29
  01362	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01367	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0136d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196815
  01374	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01379	44 8b 80 0c af
	00 00		 mov	 r8d, DWORD PTR [rax+44812]
  01380	ba fe ff ff ff	 mov	 edx, -2
  01385	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0138a	e8 00 00 00 00	 call	 z900_abort_transaction
$LN128@z900_run_c:
  0138f	33 c0		 xor	 eax, eax
  01391	85 c0		 test	 eax, eax
  01393	75 8b		 jne	 SHORT $LN70@z900_run_c
$LN125@z900_run_c:
  01395	33 c0		 xor	 eax, eax
  01397	85 c0		 test	 eax, eax
  01399	0f 85 61 fe ff
	ff		 jne	 $LN61@z900_run_c
  0139f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  013a4	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  013a8	e8 00 00 00 00	 call	 fetch_hw_noswap
  013ad	0f b7 c8	 movzx	 ecx, ax
  013b0	e8 00 00 00 00	 call	 _byteswap_ushort
  013b5	0f b7 c0	 movzx	 eax, ax
  013b8	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  013bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  013c2	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  013c6	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  013cb	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  013ce	33 c0		 xor	 eax, eax
  013d0	85 c0		 test	 eax, eax
  013d2	0f 85 28 fe ff
	ff		 jne	 $LN58@z900_run_c

; 2149 : 
; 2150 :         if (!regs->txf_tnd)

  013d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  013dd	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  013e4	85 c0		 test	 eax, eax
  013e6	75 05		 jne	 SHORT $LN129@z900_run_c

; 2151 :             break;

  013e8	e9 f9 01 00 00	 jmp	 $LN54@z900_run_c
$LN129@z900_run_c:

; 2152 : 
; 2153 :         TXF_UNROLLED_EXECUTE( current_opcode_table, regs );

  013ed	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  013f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  013f7	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  013fe	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01402	72 05		 jb	 SHORT $LN130@z900_run_c
  01404	e9 dd 01 00 00	 jmp	 $LN54@z900_run_c
$LN130@z900_run_c:
$LN73@z900_run_c:
$LN76@z900_run_c:
  01409	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0140e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01415	85 c0		 test	 eax, eax
  01417	0f 84 81 01 00
	00		 je	 $LN131@z900_run_c
$LN79@z900_run_c:
  0141d	33 c0		 xor	 eax, eax
  0141f	83 f8 01	 cmp	 eax, 1
  01422	74 5d		 je	 SHORT $LN132@z900_run_c
  01424	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01429	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01430	85 c0		 test	 eax, eax
  01432	74 4d		 je	 SHORT $LN132@z900_run_c
  01434	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01439	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0143e	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  01445	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  01449	72 36		 jb	 SHORT $LN132@z900_run_c
  0144b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01450	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01456	0f ba e8 1f	 bts	 eax, 31
  0145a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0145f	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01465	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196820
  0146c	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01472	ba fe ff ff ff	 mov	 edx, -2
  01477	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0147c	e8 00 00 00 00	 call	 z900_abort_transaction
$LN132@z900_run_c:
  01481	33 c0		 xor	 eax, eax
  01483	85 c0		 test	 eax, eax
  01485	75 96		 jne	 SHORT $LN79@z900_run_c
  01487	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0148c	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  01493	66 ff c0	 inc	 ax
  01496	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0149b	66 89 81 5e 0e
	00 00		 mov	 WORD PTR [rcx+3678], ax
$LN82@z900_run_c:
  014a2	33 c0		 xor	 eax, eax
  014a4	83 f8 01	 cmp	 eax, 1
  014a7	74 76		 je	 SHORT $LN133@z900_run_c
  014a9	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  014ae	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  014b5	85 c0		 test	 eax, eax
  014b7	74 66		 je	 SHORT $LN133@z900_run_c
  014b9	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  014be	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  014c5	83 f8 20	 cmp	 eax, 32			; 00000020H
  014c8	7e 55		 jle	 SHORT $LN133@z900_run_c
  014ca	41 b8 02 00 00
	00		 mov	 r8d, 2
  014d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196822
  014d7	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  014dc	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  014e0	e8 00 00 00 00	 call	 memcmp
  014e5	85 c0		 test	 eax, eax
  014e7	74 36		 je	 SHORT $LN133@z900_run_c
  014e9	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  014ee	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  014f4	0f ba e8 1e	 bts	 eax, 30
  014f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  014fd	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01503	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196823
  0150a	41 b8 0b 00 00
	00		 mov	 r8d, 11
  01510	ba fe ff ff ff	 mov	 edx, -2
  01515	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0151a	e8 00 00 00 00	 call	 z900_abort_transaction
$LN133@z900_run_c:
  0151f	33 c0		 xor	 eax, eax
  01521	85 c0		 test	 eax, eax
  01523	0f 85 79 ff ff
	ff		 jne	 $LN82@z900_run_c
$LN85@z900_run_c:
  01529	33 c0		 xor	 eax, eax
  0152b	83 f8 01	 cmp	 eax, 1
  0152e	74 68		 je	 SHORT $LN134@z900_run_c
  01530	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01535	0f b7 80 60 0e
	00 00		 movzx	 eax, WORD PTR [rax+3680]
  0153c	85 c0		 test	 eax, eax
  0153e	74 58		 je	 SHORT $LN134@z900_run_c
  01540	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01545	0f b7 80 5e 0e
	00 00		 movzx	 eax, WORD PTR [rax+3678]
  0154c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01551	0f b7 89 60 0e
	00 00		 movzx	 ecx, WORD PTR [rcx+3680]
  01558	3b c1		 cmp	 eax, ecx
  0155a	7c 3c		 jl	 SHORT $LN134@z900_run_c
  0155c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01561	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  01567	0f ba e8 1d	 bts	 eax, 29
  0156b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01570	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  01576	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196825
  0157d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  01582	44 8b 80 0c af
	00 00		 mov	 r8d, DWORD PTR [rax+44812]
  01589	ba fe ff ff ff	 mov	 edx, -2
  0158e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  01593	e8 00 00 00 00	 call	 z900_abort_transaction
$LN134@z900_run_c:
  01598	33 c0		 xor	 eax, eax
  0159a	85 c0		 test	 eax, eax
  0159c	75 8b		 jne	 SHORT $LN85@z900_run_c
$LN131@z900_run_c:
  0159e	33 c0		 xor	 eax, eax
  015a0	85 c0		 test	 eax, eax
  015a2	0f 85 61 fe ff
	ff		 jne	 $LN76@z900_run_c
  015a8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  015ad	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  015b1	e8 00 00 00 00	 call	 fetch_hw_noswap
  015b6	0f b7 c8	 movzx	 ecx, ax
  015b9	e8 00 00 00 00	 call	 _byteswap_ushort
  015be	0f b7 c0	 movzx	 eax, ax
  015c1	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  015c6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  015cb	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  015cf	48 8b 7c 24 78	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  015d4	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  015d7	33 c0		 xor	 eax, eax
  015d9	85 c0		 test	 eax, eax
  015db	0f 85 28 fe ff
	ff		 jne	 $LN73@z900_run_c

; 2154 :     }

  015e1	e9 d1 fb ff ff	 jmp	 $LN53@z900_run_c
$LN54@z900_run_c:

; 2155 :     regs->instcount   +=     (i * 2);

  015e6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  015eb	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  015f1	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  015f5	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  015f8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  015fd	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2156 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  01603	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  01607	d1 e0		 shl	 eax, 1
  01609	48 98		 cdqe
  0160b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01612	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  01619	48 8b d0	 mov	 rdx, rax
  0161c	e8 00 00 00 00	 call	 atomic_update64

; 2157 : 
; 2158 :     /* Perform automatic instruction tracing if it's enabled */
; 2159 :     do_automatic_tracing();

  01621	e8 00 00 00 00	 call	 do_automatic_tracing

; 2160 :     goto txf_facility_loop;

  01626	e9 8c f4 ff ff	 jmp	 $txf_facility_loop$167
$LN1@z900_run_c:
$LN135@z900_run_c:

; 2161 : 
; 2162 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 2163 : 
; 2164 :     UNREACHABLE_CODE( return NULL );
; 2165 : 
; 2166 : } /* end function run_cpu */

  0162b	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01633	48 33 cc	 xor	 rcx, rsp
  01636	e8 00 00 00 00	 call	 __security_check_cookie
  0163b	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  01642	5f		 pop	 rdi
  01643	5e		 pop	 rsi
  01644	c3		 ret	 0
z900_run_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv91 = 80
tv151 = 84
tv164 = 88
tv215 = 92
tv303 = 96
tv420 = 100
tv267 = 104
tv370 = 108
tv269 = 112
saved_timer$1 = 120
tv372 = 128
buf$2 = 136
__$ArrayPad$ = 176
regs$ = 208
z900_process_interrupt PROC

; 1680 : {

$LN85:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1681 :     /* Process PER program interrupts */
; 1682 :     if( OPEN_IC_PER(regs) )

  0001e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00026	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00031	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00034	23 c1		 and	 eax, ecx
  00036	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0003b	85 c0		 test	 eax, eax
  0003d	74 1b		 je	 SHORT $LN35@z900_proce

; 1683 :         regs->program_interrupt (regs, PGM_PER_EVENT);

  0003f	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00044	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00054	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@z900_proce:

; 1684 : 
; 1685 :     /* Obtain the interrupt lock */
; 1686 :     OBTAIN_INTLOCK(regs);

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196544
  00061	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN4@z900_proce:

; 1687 :     OFF_IC_INTERRUPT(regs);

  0006e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00076	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00079	0f ba f0 1f	 btr	 eax, 31
  0007d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00088	33 c0		 xor	 eax, eax
  0008a	85 c0		 test	 eax, eax
  0008c	75 e0		 jne	 SHORT $LN4@z900_proce

; 1688 :     regs->breakortrace = (sysblk.instbreak || (sysblk.insttrace && regs->insttrace));

  0008e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00095	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0009b	c1 e8 0a	 shr	 eax, 10
  0009e	83 e0 01	 and	 eax, 1
  000a1	85 c0		 test	 eax, eax
  000a3	75 39		 jne	 SHORT $LN63@z900_proce
  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ac	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000b2	c1 e8 08	 shr	 eax, 8
  000b5	83 e0 01	 and	 eax, 1
  000b8	85 c0		 test	 eax, eax
  000ba	74 18		 je	 SHORT $LN62@z900_proce
  000bc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000ca	c1 e8 0f	 shr	 eax, 15
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	75 0a		 jne	 SHORT $LN63@z900_proce
$LN62@z900_proce:
  000d4	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000dc	eb 08		 jmp	 SHORT $LN64@z900_proce
$LN63@z900_proce:
  000de	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
$LN64@z900_proce:
  000e6	8b 44 24 50	 mov	 eax, DWORD PTR tv91[rsp]
  000ea	83 e0 01	 and	 eax, 1
  000ed	c1 e0 10	 shl	 eax, 16
  000f0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  000fe	0f ba f1 10	 btr	 ecx, 16
  00102	0b c8		 or	 ecx, eax
  00104	8b c1		 mov	 eax, ecx
  00106	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN7@z900_proce:

; 1689 : 
; 1690 :     /* Ensure psw.IA is set and invalidate the aia */
; 1691 :     INVALIDATE_AIA(regs);

  00114	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00124	74 64		 je	 SHORT $LN36@z900_proce
  00126	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0013d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00141	48 2b c1	 sub	 rax, rcx
  00144	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00153	48 03 c8	 add	 rcx, rax
  00156	48 8b c1	 mov	 rax, rcx
  00159	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00168	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00177	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017f	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN36@z900_proce:
  0018a	33 c0		 xor	 eax, eax
  0018c	85 c0		 test	 eax, eax
  0018e	75 84		 jne	 SHORT $LN7@z900_proce

; 1692 : 
; 1693 :     /* Perform invalidation */
; 1694 :     if (unlikely(regs->invalidate))

  00190	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019e	c1 e8 0e	 shr	 eax, 14
  001a1	83 e0 01	 and	 eax, 1
  001a4	85 c0		 test	 eax, eax
  001a6	74 0a		 je	 SHORT $LN67@z900_proce
  001a8	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  001b0	eb 08		 jmp	 SHORT $LN68@z900_proce
$LN67@z900_proce:
  001b2	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN68@z900_proce:
  001ba	83 7c 24 54 00	 cmp	 DWORD PTR tv151[rsp], 0
  001bf	74 1c		 je	 SHORT $LN37@z900_proce

; 1695 :         ARCH_DEP(invalidate_tlbe)(regs, regs->invalidate_main);

  001c1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c9	48 8b 90 00 09
	00 00		 mov	 rdx, QWORD PTR [rax+2304]
  001d0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d8	e8 00 00 00 00	 call	 z900_invalidate_tlbe
$LN37@z900_proce:

; 1696 : 
; 1697 :     /* Take interrupts if CPU is not stopped */
; 1698 :     if (likely(regs->cpustate == CPUSTATE_STARTED))

  001dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e5	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  001e9	83 f8 01	 cmp	 eax, 1
  001ec	75 0a		 jne	 SHORT $LN71@z900_proce
  001ee	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv164[rsp], 1
  001f6	eb 08		 jmp	 SHORT $LN72@z900_proce
$LN71@z900_proce:
  001f8	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv164[rsp], 0
$LN72@z900_proce:
  00200	83 7c 24 58 00	 cmp	 DWORD PTR tv164[rsp], 0
  00205	0f 84 3d 01 00
	00		 je	 $LN38@z900_proce

; 1699 :     {
; 1700 :         /* Process machine check interrupt */
; 1701 :         if ( OPEN_IC_MCKPENDING(regs) )

  0020b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00213	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0021e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00221	23 c1		 and	 eax, ecx
  00223	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00228	85 c0		 test	 eax, eax
  0022a	74 16		 je	 SHORT $LN39@z900_proce

; 1702 :         {
; 1703 :             PERFORM_SERIALIZATION (regs);

  0022c	0f ae f0	 mfence
$LN10@z900_proce:

; 1704 :             PERFORM_CHKPT_SYNC (regs);

  0022f	33 c0		 xor	 eax, eax
  00231	85 c0		 test	 eax, eax
  00233	75 fa		 jne	 SHORT $LN10@z900_proce

; 1705 :             ARCH_DEP (perform_mck_interrupt) (regs);

  00235	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023d	e8 00 00 00 00	 call	 z900_perform_mck_interrupt
$LN39@z900_proce:

; 1706 :         }
; 1707 : 
; 1708 :         /* Process external interrupt */
; 1709 :         if (1
; 1710 :             && OPEN_IC_EXTPENDING( regs )
; 1711 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1712 :             /* Don't interrupt active transaction */
; 1713 :             && (0

  00242	33 c0		 xor	 eax, eax
  00244	83 f8 01	 cmp	 eax, 1
  00247	74 61		 je	 SHORT $LN40@z900_proce
  00249	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00251	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00259	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0025c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0025f	23 c1		 and	 eax, ecx
  00261	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00266	85 c0		 test	 eax, eax
  00268	74 40		 je	 SHORT $LN40@z900_proce
  0026a	33 c0		 xor	 eax, eax
  0026c	85 c0		 test	 eax, eax
  0026e	75 24		 jne	 SHORT $LN41@z900_proce
  00270	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00278	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0027f	85 c0		 test	 eax, eax
  00281	74 11		 je	 SHORT $LN41@z900_proce
  00283	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028b	83 b8 54 0e 00
	00 02		 cmp	 DWORD PTR [rax+3668], 2
  00292	7d 16		 jge	 SHORT $LN40@z900_proce
$LN41@z900_proce:

; 1714 :                 || regs->txf_tnd == 0
; 1715 :                 || regs->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1716 :                )
; 1717 : #endif
; 1718 :         )
; 1719 :         {
; 1720 :             PERFORM_SERIALIZATION( regs );

  00294	0f ae f0	 mfence
$LN13@z900_proce:

; 1721 :             PERFORM_CHKPT_SYNC( regs );

  00297	33 c0		 xor	 eax, eax
  00299	85 c0		 test	 eax, eax
  0029b	75 fa		 jne	 SHORT $LN13@z900_proce

; 1722 :             ARCH_DEP( perform_external_interrupt )( regs );

  0029d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a5	e8 00 00 00 00	 call	 z900_perform_external_interrupt
$LN40@z900_proce:

; 1723 :         }
; 1724 : 
; 1725 :         /* Process I/O interrupt */
; 1726 :         if (IS_IC_IOPENDING)

  002aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002b1	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  002b7	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002bc	85 c0		 test	 eax, eax
  002be	0f 84 84 00 00
	00		 je	 $LN42@z900_proce

; 1727 :         {
; 1728 :             if (1
; 1729 :                 && OPEN_IC_IOPENDING( regs )
; 1730 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1731 :                 /* Don't interrupt active transaction */
; 1732 :                 && (0

  002c4	33 c0		 xor	 eax, eax
  002c6	83 f8 01	 cmp	 eax, 1
  002c9	74 63		 je	 SHORT $LN43@z900_proce
  002cb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  002de	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002e1	23 c1		 and	 eax, ecx
  002e3	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002e8	85 c0		 test	 eax, eax
  002ea	74 42		 je	 SHORT $LN43@z900_proce
  002ec	33 c0		 xor	 eax, eax
  002ee	85 c0		 test	 eax, eax
  002f0	75 24		 jne	 SHORT $LN45@z900_proce
  002f2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fa	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00301	85 c0		 test	 eax, eax
  00303	74 11		 je	 SHORT $LN45@z900_proce
  00305	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	83 b8 54 0e 00
	00 02		 cmp	 DWORD PTR [rax+3668], 2
  00314	7d 18		 jge	 SHORT $LN43@z900_proce
$LN45@z900_proce:

; 1733 :                     || regs->txf_tnd == 0
; 1734 :                     || regs->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1735 :                    )
; 1736 : #endif
; 1737 :             )
; 1738 :             {
; 1739 :                 PERFORM_SERIALIZATION( regs );

  00316	0f ae f0	 mfence
$LN16@z900_proce:

; 1740 :                 PERFORM_CHKPT_SYNC( regs );

  00319	33 c0		 xor	 eax, eax
  0031b	85 c0		 test	 eax, eax
  0031d	75 fa		 jne	 SHORT $LN16@z900_proce

; 1741 :                 ARCH_DEP( perform_io_interrupt )( regs );

  0031f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00327	e8 00 00 00 00	 call	 z900_perform_io_interrupt

; 1742 :             }

  0032c	eb 1a		 jmp	 SHORT $LN44@z900_proce
$LN43@z900_proce:

; 1743 :             else
; 1744 :                 WAKEUP_CPU_MASK(sysblk.waiting_mask);

  0032e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196555
  00335	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0033c	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  00343	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN44@z900_proce:
$LN42@z900_proce:
$LN38@z900_proce:

; 1745 :         }
; 1746 :     } /*CPU_STARTED*/
; 1747 : 
; 1748 :     /* If CPU is stopping, change status to stopped */
; 1749 :     if (unlikely(regs->cpustate == CPUSTATE_STOPPING))

  00348	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00350	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00354	83 f8 02	 cmp	 eax, 2
  00357	75 0a		 jne	 SHORT $LN75@z900_proce
  00359	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
  00361	eb 08		 jmp	 SHORT $LN76@z900_proce
$LN75@z900_proce:
  00363	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN76@z900_proce:
  0036b	83 7c 24 5c 00	 cmp	 DWORD PTR tv215[rsp], 0
  00370	0f 84 28 02 00
	00		 je	 $LN46@z900_proce
$cpustate_stopping$86:

; 1750 :     {
; 1751 :         /* Change CPU status to stopped */
; 1752 : cpustate_stopping:
; 1753 :         regs->opinterv = 0;

  00376	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00384	83 e0 ef	 and	 eax, -17		; ffffffefH
  00387	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038f	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1754 :         regs->cpustate = CPUSTATE_STOPPED;

  00395	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039d	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3

; 1755 : 
; 1756 :         /* Thread exit (note - intlock still held) */
; 1757 :         if (!regs->configured)

  003a1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003af	c1 e8 0b	 shr	 eax, 11
  003b2	83 e0 01	 and	 eax, 1
  003b5	85 c0		 test	 eax, eax
  003b7	75 1b		 jne	 SHORT $LN47@z900_proce

; 1758 :             longjmp(regs->exitjmp, SIE_NO_INTERCEPT);

  003b9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c1	48 05 80 0b 00
	00		 add	 rax, 2944		; 00000b80H
  003c7	ba ff ff ff ff	 mov	 edx, -1
  003cc	48 8b c8	 mov	 rcx, rax
  003cf	e8 00 00 00 00	 call	 longjmp
$LN47@z900_proce:

; 1759 : 
; 1760 :         /* If initial CPU reset pending then perform reset */
; 1761 :         if (regs->sigp_ini_reset)

  003d4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003e2	c1 e8 14	 shr	 eax, 20
  003e5	83 e0 01	 and	 eax, 1
  003e8	85 c0		 test	 eax, eax
  003ea	74 45		 je	 SHORT $LN48@z900_proce

; 1762 :         {
; 1763 :             PERFORM_SERIALIZATION (regs);

  003ec	0f ae f0	 mfence
$LN19@z900_proce:

; 1764 :             PERFORM_CHKPT_SYNC (regs);

  003ef	33 c0		 xor	 eax, eax
  003f1	85 c0		 test	 eax, eax
  003f3	75 fa		 jne	 SHORT $LN19@z900_proce

; 1765 :             ARCH_DEP (initial_cpu_reset) (regs);

  003f5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fd	e8 00 00 00 00	 call	 z900_initial_cpu_reset

; 1766 :             RELEASE_INTLOCK(regs);

  00402	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196559
  00409	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00411	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1767 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  00416	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041e	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00424	ba ff ff ff ff	 mov	 edx, -1
  00429	48 8b c8	 mov	 rcx, rax
  0042c	e8 00 00 00 00	 call	 longjmp
$LN48@z900_proce:

; 1768 :         }
; 1769 : 
; 1770 :         /* If a CPU reset is pending then perform the reset */
; 1771 :         if (regs->sigp_reset)

  00431	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00439	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0043f	c1 e8 13	 shr	 eax, 19
  00442	83 e0 01	 and	 eax, 1
  00445	85 c0		 test	 eax, eax
  00447	74 45		 je	 SHORT $LN49@z900_proce

; 1772 :         {
; 1773 :             PERFORM_SERIALIZATION (regs);

  00449	0f ae f0	 mfence
$LN22@z900_proce:

; 1774 :             PERFORM_CHKPT_SYNC (regs);

  0044c	33 c0		 xor	 eax, eax
  0044e	85 c0		 test	 eax, eax
  00450	75 fa		 jne	 SHORT $LN22@z900_proce

; 1775 :             ARCH_DEP(cpu_reset) (regs);

  00452	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045a	e8 00 00 00 00	 call	 z900_cpu_reset

; 1776 :             RELEASE_INTLOCK(regs);

  0045f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196561
  00466	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046e	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1777 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  00473	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00481	ba ff ff ff ff	 mov	 edx, -1
  00486	48 8b c8	 mov	 rcx, rax
  00489	e8 00 00 00 00	 call	 longjmp
$LN49@z900_proce:

; 1778 :         }
; 1779 : 
; 1780 :         /* Store status at absolute location 0 if requested */
; 1781 :         if (IS_IC_STORSTAT(regs))

  0048e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00496	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00499	83 e0 08	 and	 eax, 8
  0049c	85 c0		 test	 eax, eax
  0049e	0f 84 fa 00 00
	00		 je	 $LN50@z900_proce
$LN25@z900_proce:

; 1782 :         {
; 1783 :             OFF_IC_STORSTAT(regs);

  004a4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004af	83 e0 f7	 and	 eax, -9			; fffffff7H
  004b2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ba	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  004bd	33 c0		 xor	 eax, eax
  004bf	85 c0		 test	 eax, eax
  004c1	75 e1		 jne	 SHORT $LN25@z900_proce

; 1784 :             ARCH_DEP(store_status) (regs, 0);

  004c3	33 d2		 xor	 edx, edx
  004c5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004cd	e8 00 00 00 00	 call	 z900_store_status

; 1785 : 
; 1786 :             if (regs->insttrace && sysblk.traceFILE)

  004d2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004da	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  004e0	c1 e8 0f	 shr	 eax, 15
  004e3	83 e0 01	 and	 eax, 1
  004e6	85 c0		 test	 eax, eax
  004e8	74 1f		 je	 SHORT $LN51@z900_proce
  004ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004f1	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  004f9	74 0e		 je	 SHORT $LN51@z900_proce

; 1787 :                 tf_0808( regs );

  004fb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00503	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0808
$LN51@z900_proce:

; 1788 : 
; 1789 :             // "Processor %s%02X: store status completed"
; 1790 :             WRMSG( HHC00808, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  00509	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00511	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00518	89 44 24 68	 mov	 DWORD PTR tv267[rsp], eax
  0051c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00524	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0052b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00532	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0053a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00540	48 89 44 24 70	 mov	 QWORD PTR tv269[rsp], rax
  00545	b9 01 00 00 00	 mov	 ecx, 1
  0054a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00550	8b 4c 24 68	 mov	 ecx, DWORD PTR tv267[rsp]
  00554	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00558	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv269[rsp]
  0055d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00562	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196564
  00569	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0056e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196565
  00575	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0057a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0057f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00585	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196566
  0058c	ba fe 06 00 00	 mov	 edx, 1790		; 000006feH
  00591	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196567
  00598	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN50@z900_proce:
$LN46@z900_proce:

; 1791 : 
; 1792 :             /* ISW 20071102 : Do not return via longjmp here. */
; 1793 :             /*    process_interrupt needs to finish putting the */
; 1794 :             /*    CPU in its manual state                     */
; 1795 :             /*
; 1796 :             RELEASE_INTLOCK(regs);
; 1797 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);
; 1798 :             */
; 1799 :         }
; 1800 :     } /*CPUSTATE_STOPPING*/
; 1801 : 
; 1802 :     /* Perform restart interrupt if pending */
; 1803 :     if ( IS_IC_RESTART(regs) )

  0059e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005a9	83 e0 02	 and	 eax, 2
  005ac	85 c0		 test	 eax, eax
  005ae	74 35		 je	 SHORT $LN52@z900_proce

; 1804 :     {
; 1805 :         PERFORM_SERIALIZATION (regs);

  005b0	0f ae f0	 mfence
$LN28@z900_proce:

; 1806 :         PERFORM_CHKPT_SYNC (regs);

  005b3	33 c0		 xor	 eax, eax
  005b5	85 c0		 test	 eax, eax
  005b7	75 fa		 jne	 SHORT $LN28@z900_proce
$LN31@z900_proce:

; 1807 :         OFF_IC_RESTART(regs);

  005b9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  005c4	83 e0 fd	 and	 eax, -3			; fffffffdH
  005c7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005cf	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  005d2	33 c0		 xor	 eax, eax
  005d4	85 c0		 test	 eax, eax
  005d6	75 e1		 jne	 SHORT $LN31@z900_proce

; 1808 :         ARCH_DEP(restart_interrupt) (regs);

  005d8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e0	e8 00 00 00 00	 call	 z900_restart_interrupt
$LN52@z900_proce:

; 1809 :     } /* end if(restart) */
; 1810 : 
; 1811 :     /* This is where a stopped CPU will wait */
; 1812 :     if (unlikely(regs->cpustate == CPUSTATE_STOPPED))

  005e5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ed	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  005f1	83 f8 03	 cmp	 eax, 3
  005f4	75 0a		 jne	 SHORT $LN79@z900_proce
  005f6	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv303[rsp], 1
  005fe	eb 08		 jmp	 SHORT $LN80@z900_proce
$LN79@z900_proce:
  00600	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv303[rsp], 0
$LN80@z900_proce:
  00608	83 7c 24 60 00	 cmp	 DWORD PTR tv303[rsp], 0
  0060d	0f 84 59 01 00
	00		 je	 $LN53@z900_proce

; 1813 :     {
; 1814 :         S64 saved_timer = get_cpu_timer(regs);

  00613	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061b	e8 00 00 00 00	 call	 get_cpu_timer
  00620	48 89 44 24 78	 mov	 QWORD PTR saved_timer$1[rsp], rax

; 1815 :         regs->ints_state = IC_INITIAL_STATE;

  00625	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062d	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 1816 :         sysblk.started_mask ^= regs->cpubit;

  00634	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0063b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00643	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00647	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0064e	48 33 c1	 xor	 rax, rcx
  00651	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00658	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 1817 : 
; 1818 :         CPU_Wait(regs);

  0065f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00667	e8 00 00 00 00	 call	 CPU_Wait

; 1819 : 
; 1820 :         sysblk.started_mask |= regs->cpubit;

  0066c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00673	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0067f	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00686	48 0b c1	 or	 rax, rcx
  00689	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00690	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 1821 :         regs->ints_state |= sysblk.ints_state;

  00697	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0069f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006a6	8b 89 a0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4768]
  006ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  006af	0b c1		 or	 eax, ecx
  006b1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b9	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1822 :         set_cpu_timer(regs,saved_timer);

  006bc	48 8b 54 24 78	 mov	 rdx, QWORD PTR saved_timer$1[rsp]
  006c1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c9	e8 00 00 00 00	 call	 set_cpu_timer
$LN34@z900_proce:

; 1823 : 
; 1824 :         ON_IC_INTERRUPT(regs);

  006ce	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  006d9	0f ba e8 1f	 bts	 eax, 31
  006dd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e5	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  006e8	33 c0		 xor	 eax, eax
  006ea	85 c0		 test	 eax, eax
  006ec	75 e0		 jne	 SHORT $LN34@z900_proce

; 1825 : 
; 1826 :         /* Purge the lookaside buffers */
; 1827 :         ARCH_DEP(purge_tlb) (regs);

  006ee	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006f6	e8 00 00 00 00	 call	 z900_purge_tlb

; 1828 : #if defined(FEATURE_ACCESS_REGISTERS)
; 1829 :         ARCH_DEP(purge_alb) (regs);

  006fb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00703	e8 00 00 00 00	 call	 z900_purge_alb

; 1830 : #endif /*defined(FEATURE_ACCESS_REGISTERS)*/
; 1831 : 
; 1832 :         /* If the architecture mode has changed we must adapt */
; 1833 :         if(sysblk.arch_mode != regs->arch_mode)

  00708	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00717	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  0071a	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  00720	74 1b		 je	 SHORT $LN54@z900_proce

; 1834 :             longjmp(regs->archjmp,SIE_NO_INTERCEPT);

  00722	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072a	48 05 80 0a 00
	00		 add	 rax, 2688		; 00000a80H
  00730	ba ff ff ff ff	 mov	 edx, -1
  00735	48 8b c8	 mov	 rcx, rax
  00738	e8 00 00 00 00	 call	 longjmp
$LN54@z900_proce:

; 1835 : 
; 1836 :         RELEASE_INTLOCK(regs);

  0073d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196571
  00744	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0074c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1837 :         longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  00751	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00759	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0075f	ba ff ff ff ff	 mov	 edx, -1
  00764	48 8b c8	 mov	 rcx, rax
  00767	e8 00 00 00 00	 call	 longjmp
$LN53@z900_proce:

; 1838 :     } /*CPUSTATE_STOPPED*/
; 1839 : 
; 1840 :     /* Test for wait state */
; 1841 :     if (WAITSTATE(&regs->psw))

  0076c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00774	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00778	83 e0 02	 and	 eax, 2
  0077b	85 c0		 test	 eax, eax
  0077d	0f 84 b7 02 00
	00		 je	 $LN55@z900_proce

; 1842 :     {
; 1843 :         regs->waittod = host_tod();

  00783	e8 00 00 00 00	 call	 host_tod
  00788	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00790	48 89 81 b8 07
	00 00		 mov	 QWORD PTR [rcx+1976], rax

; 1844 : 
; 1845 :         /* Test for disabled wait PSW and issue message */
; 1846 :         if (IS_IC_DISABLED_WAIT_PSW( regs ))

  00797	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  007a2	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  007a7	85 c0		 test	 eax, eax
  007a9	0f 85 7f 01 00
	00		 jne	 $LN56@z900_proce

; 1847 :         {
; 1848 :             /* Don't log the disabled wait when OSTAILOR VM is active
; 1849 :                unless it is the very last CPU in the configuration. */
; 1850 :             if (0
; 1851 :                 || !(sysblk.ostailor & OSTAILOR_VM)
; 1852 :                 || !(sysblk.started_mask ^ regs->cpubit)

  007af	33 c0		 xor	 eax, eax
  007b1	85 c0		 test	 eax, eax
  007b3	75 3c		 jne	 SHORT $LN58@z900_proce
  007b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007bc	8b 80 50 13 00
	00		 mov	 eax, DWORD PTR [rax+4944]
  007c2	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  007c7	85 c0		 test	 eax, eax
  007c9	74 26		 je	 SHORT $LN58@z900_proce
  007cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007d2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007da	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007de	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  007e5	48 33 c1	 xor	 rax, rcx
  007e8	48 85 c0	 test	 rax, rax
  007eb	0f 85 02 01 00
	00		 jne	 $LN57@z900_proce
$LN58@z900_proce:

; 1853 :             )
; 1854 :             {
; 1855 :                 char buf[40];
; 1856 :                 STR_PSW( regs, buf );

  007f1	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  007f7	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$2[rsp]
  007ff	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00807	e8 00 00 00 00	 call	 str_psw

; 1857 : 
; 1858 :                 if (regs->insttrace && sysblk.traceFILE)

  0080c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00814	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0081a	c1 e8 0f	 shr	 eax, 15
  0081d	83 e0 01	 and	 eax, 1
  00820	85 c0		 test	 eax, eax
  00822	74 27		 je	 SHORT $LN59@z900_proce
  00824	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0082b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00833	74 16		 je	 SHORT $LN59@z900_proce

; 1859 :                     tf_0809( regs, buf );

  00835	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$2[rsp]
  0083d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00845	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0809
$LN59@z900_proce:

; 1860 : 
; 1861 :                 // "Processor %s%02X: disabled wait state %s"
; 1862 :                 WRMSG( HHC00809, "I", PTYPSTR( regs->cpuad ),

  0084b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00853	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0085a	89 44 24 6c	 mov	 DWORD PTR tv370[rsp], eax
  0085e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00866	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0086d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00874	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0087c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00882	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv372[rsp], rax
  0088a	b9 01 00 00 00	 mov	 ecx, 1
  0088f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00895	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0089d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  008a2	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv370[rsp]
  008a6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  008aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv372[rsp]
  008b2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196577
  008be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196578
  008ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  008da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196579
  008e1	ba 47 07 00 00	 mov	 edx, 1863		; 00000747H
  008e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196580
  008ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN57@z900_proce:

; 1863 :                     regs->cpuad, buf );
; 1864 :             }
; 1865 :             regs->cpustate = CPUSTATE_STOPPING;

  008f3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fb	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2

; 1866 :             RELEASE_INTLOCK( regs );

  008ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196581
  00906	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0090e	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1867 :             longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  00913	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0091b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00921	ba ff ff ff ff	 mov	 edx, -1
  00926	48 8b c8	 mov	 rcx, rax
  00929	e8 00 00 00 00	 call	 longjmp
$LN56@z900_proce:

; 1868 :         }
; 1869 : 
; 1870 :         /* Indicate waiting and invoke CPU wait */
; 1871 :         sysblk.waiting_mask |= regs->cpubit;

  0092e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00935	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00941	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  00948	48 0b c1	 or	 rax, rcx
  0094b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00952	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1872 :         CPU_Wait(regs);

  00959	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00961	e8 00 00 00 00	 call	 CPU_Wait

; 1873 : 
; 1874 :         /* Turn off the waiting bit .
; 1875 :          *
; 1876 :          * Note: ANDing off of the CPU waiting bit, rather than using
; 1877 :          * XOR, is required to handle the remote and rare case when the
; 1878 :          * CPU is removed from the sysblk.waiting_mask while in
; 1879 :          * wait_condition (intlock is NOT held; use of XOR incorrectly
; 1880 :          * turns the CPU waiting bit back on).
; 1881 :          */
; 1882 :         sysblk.waiting_mask &= ~(regs->cpubit);

  00966	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0096e	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00972	48 f7 d0	 not	 rax
  00975	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0097c	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00983	48 23 c8	 and	 rcx, rax
  00986	48 8b c1	 mov	 rax, rcx
  00989	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00990	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1883 : 
; 1884 :         /* Calculate the time we waited */
; 1885 :         regs->waittime += host_tod() - regs->waittod;

  00997	e8 00 00 00 00	 call	 host_tod
  0099c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a4	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  009ab	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009b3	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  009ba	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c2	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 1886 :         regs->waittod = 0;

  009c9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d1	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 1887 : 
; 1888 :         /* If late state change to stopping, go reprocess */
; 1889 :         if (unlikely(regs->cpustate == CPUSTATE_STOPPING))

  009dc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e4	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  009e8	83 f8 02	 cmp	 eax, 2
  009eb	75 0a		 jne	 SHORT $LN83@z900_proce
  009ed	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv420[rsp], 1
  009f5	eb 08		 jmp	 SHORT $LN84@z900_proce
$LN83@z900_proce:
  009f7	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv420[rsp], 0
$LN84@z900_proce:
  009ff	83 7c 24 64 00	 cmp	 DWORD PTR tv420[rsp], 0
  00a04	74 05		 je	 SHORT $LN60@z900_proce

; 1890 :             goto cpustate_stopping;

  00a06	e9 6b f9 ff ff	 jmp	 $cpustate_stopping$86
$LN60@z900_proce:

; 1891 : 
; 1892 :         RELEASE_INTLOCK(regs);

  00a0b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196583
  00a12	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a1a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1893 :         longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  00a1f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a27	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00a2d	ba ff ff ff ff	 mov	 edx, -1
  00a32	48 8b c8	 mov	 rcx, rax
  00a35	e8 00 00 00 00	 call	 longjmp
$LN55@z900_proce:

; 1894 :     } /* end if(wait) */
; 1895 : 
; 1896 :     /* Release the interrupt lock */
; 1897 :     RELEASE_INTLOCK(regs);

  00a3a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196584
  00a41	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a49	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN61@z900_proce:

; 1898 : 
; 1899 : } /* process_interrupt */

  00a4e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a56	48 33 cc	 xor	 rcx, rsp
  00a59	e8 00 00 00 00	 call	 __security_check_cookie
  00a5e	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00a65	c3		 ret	 0
z900_process_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
rc$ = 80
tv94 = 84
xdmg$ = 88
tv361 = 92
psa$ = 96
mcic$ = 104
fsta$ = 112
tv363 = 120
regs$ = 144
z900_perform_mck_interrupt PROC

; 1601 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1602 : int     rc;                             /* Return code               */
; 1603 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1604 : U64     mcic;                           /* Mach.check interrupt code */
; 1605 : U32     xdmg;                           /* External damage code      */
; 1606 : RADR    fsta;                           /* Failing storage address   */
; 1607 : 
; 1608 :     /* Test and clear pending machine check interrupt */
; 1609 :     rc = ARCH_DEP(present_mck_interrupt) (regs, &mcic, &xdmg, &fsta);

  0000c	4c 8d 4c 24 70	 lea	 r9, QWORD PTR fsta$[rsp]
  00011	4c 8d 44 24 58	 lea	 r8, QWORD PTR xdmg$[rsp]
  00016	48 8d 54 24 68	 lea	 rdx, QWORD PTR mcic$[rsp]
  0001b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00023	e8 00 00 00 00	 call	 z900_present_mck_interrupt
  00028	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1610 : 
; 1611 :     /* Exit if no machine check was presented */
; 1612 :     if (rc == 0) return;

  0002c	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00031	75 05		 jne	 SHORT $LN5@z900_perfo
  00033	e9 16 0a 00 00	 jmp	 $LN1@z900_perfo
$LN5@z900_perfo:

; 1613 : 
; 1614 :     /* Set the main storage reference and change bits */
; 1615 :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  00038	b2 06		 mov	 dl, 6
  0003a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00042	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00046	e8 00 00 00 00	 call	 z900_or_storage_key

; 1616 : 
; 1617 :     /* Point to the PSA in main storage */
; 1618 :     psa = (void*)(regs->mainstor + regs->PX);

  0004b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00053	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0005a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  00066	48 89 44 24 60	 mov	 QWORD PTR psa$[rsp], rax

; 1619 : 
; 1620 :     /* Store registers in machine check save area */
; 1621 :     ARCH_DEP(store_status) (regs, regs->PX);

  0006b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00073	48 8b 50 70	 mov	 rdx, QWORD PTR [rax+112]
  00077	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007f	e8 00 00 00 00	 call	 z900_store_status

; 1622 : 
; 1623 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1624 :     /* Set the extended logout area to zeros */
; 1625 :     memset(psa->storepsw, 0, 16);
; 1626 : #endif
; 1627 : 
; 1628 :     /* Store the machine check interrupt code at PSA+232 */
; 1629 :     STORE_DW(psa->mckint, mcic);

  00084	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mcic$[rsp]
  00089	e8 00 00 00 00	 call	 _byteswap_uint64
  0008e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  00093	48 81 c1 e8 00
	00 00		 add	 rcx, 232		; 000000e8H
  0009a	48 8b d0	 mov	 rdx, rax
  0009d	e8 00 00 00 00	 call	 store_dw_noswap

; 1630 : 
; 1631 :     /* Trace the machine check interrupt */
; 1632 :     if (CPU_STEPPING_OR_TRACING(regs, 0))

  000a2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000b0	c1 e8 10	 shr	 eax, 16
  000b3	83 e0 01	 and	 eax, 1
  000b6	85 c0		 test	 eax, eax
  000b8	74 0a		 je	 SHORT $LN33@z900_perfo
  000ba	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000c2	eb 08		 jmp	 SHORT $LN34@z900_perfo
$LN33@z900_perfo:
  000c4	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN34@z900_perfo:
  000cc	83 7c 24 54 00	 cmp	 DWORD PTR tv94[rsp], 0
  000d1	0f 84 f5 07 00
	00		 je	 $LN6@z900_perfo
  000d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000de	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000e4	c1 e8 0a	 shr	 eax, 10
  000e7	83 e0 01	 and	 eax, 1
  000ea	85 c0		 test	 eax, eax
  000ec	0f 84 55 03 00
	00		 je	 $LN8@z900_perfo
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	0f 85 2d 01 00
	00		 jne	 $LN9@z900_perfo
  000fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00103	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00109	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0010e	85 c0		 test	 eax, eax
  00110	0f 84 13 01 00
	00		 je	 $LN9@z900_perfo
  00116	33 c0		 xor	 eax, eax
  00118	83 f8 01	 cmp	 eax, 1
  0011b	0f 84 26 03 00
	00		 je	 $LN8@z900_perfo
  00121	33 c0		 xor	 eax, eax
  00123	85 c0		 test	 eax, eax
  00125	75 37		 jne	 SHORT $LN10@z900_perfo
  00127	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012e	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00134	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00139	85 c0		 test	 eax, eax
  0013b	74 21		 je	 SHORT $LN10@z900_perfo
  0013d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00145	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0014c	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00152	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00158	0f 85 e9 02 00
	00		 jne	 $LN8@z900_perfo
$LN10@z900_perfo:
  0015e	33 c0		 xor	 eax, eax
  00160	85 c0		 test	 eax, eax
  00162	75 37		 jne	 SHORT $LN11@z900_perfo
  00164	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0016b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00171	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00176	85 c0		 test	 eax, eax
  00178	74 21		 je	 SHORT $LN11@z900_perfo
  0017a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00189	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  0018f	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00195	0f 8c ac 02 00
	00		 jl	 $LN8@z900_perfo
$LN11@z900_perfo:
  0019b	33 c0		 xor	 eax, eax
  0019d	85 c0		 test	 eax, eax
  0019f	0f 85 84 00 00
	00		 jne	 $LN12@z900_perfo
  001a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ac	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  001b2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001b7	85 c0		 test	 eax, eax
  001b9	74 26		 je	 SHORT $LN13@z900_perfo
  001bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c3	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  001ca	85 c0		 test	 eax, eax
  001cc	74 13		 je	 SHORT $LN13@z900_perfo
  001ce	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001dd	85 c0		 test	 eax, eax
  001df	75 48		 jne	 SHORT $LN12@z900_perfo
$LN13@z900_perfo:
  001e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e8	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  001ee	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  001f3	85 c0		 test	 eax, eax
  001f5	0f 84 4c 02 00
	00		 je	 $LN8@z900_perfo
  001fb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00203	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0020a	85 c0		 test	 eax, eax
  0020c	0f 84 35 02 00
	00		 je	 $LN8@z900_perfo
  00212	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00221	85 c0		 test	 eax, eax
  00223	0f 85 1e 02 00
	00		 jne	 $LN8@z900_perfo
$LN12@z900_perfo:
$LN9@z900_perfo:
  00229	b8 08 00 00 00	 mov	 eax, 8
  0022e	48 6b c0 00	 imul	 rax, rax, 0
  00232	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00239	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00242	75 1f		 jne	 SHORT $LN14@z900_perfo
  00244	b8 08 00 00 00	 mov	 eax, 8
  00249	48 6b c0 01	 imul	 rax, rax, 1
  0024d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00254	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0025d	0f 84 7f 05 00
	00		 je	 $LN7@z900_perfo
$LN14@z900_perfo:
  00263	b8 08 00 00 00	 mov	 eax, 8
  00268	48 6b c0 00	 imul	 rax, rax, 0
  0026c	b9 08 00 00 00	 mov	 ecx, 8
  00271	48 6b c9 01	 imul	 rcx, rcx, 1
  00275	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0027c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00283	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  0028b	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00293	0f 87 bc 00 00
	00		 ja	 $LN15@z900_perfo
  00299	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  002b0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002b4	48 2b c1	 sub	 rax, rcx
  002b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  002c6	48 03 c8	 add	 rcx, rax
  002c9	48 8b c1	 mov	 rax, rcx
  002cc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002db	b9 08 00 00 00	 mov	 ecx, 8
  002e0	48 6b c9 00	 imul	 rcx, rcx, 0
  002e4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002eb	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  002f3	72 60		 jb	 SHORT $LN15@z900_perfo
  002f5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00305	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0030c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00310	48 2b c1	 sub	 rax, rcx
  00313	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031b	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00322	48 03 c8	 add	 rcx, rax
  00325	48 8b c1	 mov	 rax, rcx
  00328	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00337	b9 08 00 00 00	 mov	 ecx, 8
  0033c	48 6b c9 01	 imul	 rcx, rcx, 1
  00340	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00347	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0034f	0f 86 8d 04 00
	00		 jbe	 $LN7@z900_perfo
$LN15@z900_perfo:
  00355	b8 08 00 00 00	 mov	 eax, 8
  0035a	48 6b c0 00	 imul	 rax, rax, 0
  0035e	b9 08 00 00 00	 mov	 ecx, 8
  00363	48 6b c9 01	 imul	 rcx, rcx, 1
  00367	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0036e	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00375	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  0037d	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00385	0f 86 bc 00 00
	00		 jbe	 $LN16@z900_perfo
  0038b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00393	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003a2	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  003a6	48 2b c1	 sub	 rax, rcx
  003a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b1	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  003b8	48 03 c8	 add	 rcx, rax
  003bb	48 8b c1	 mov	 rax, rcx
  003be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c6	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003cd	b9 08 00 00 00	 mov	 ecx, 8
  003d2	48 6b c9 01	 imul	 rcx, rcx, 1
  003d6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003dd	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  003e5	72 60		 jb	 SHORT $LN16@z900_perfo
  003e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ef	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f7	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003fe	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00402	48 2b c1	 sub	 rax, rcx
  00405	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040d	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00414	48 03 c8	 add	 rcx, rax
  00417	48 8b c1	 mov	 rax, rcx
  0041a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00422	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00429	b9 08 00 00 00	 mov	 ecx, 8
  0042e	48 6b c9 00	 imul	 rcx, rcx, 0
  00432	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00439	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00441	0f 86 9b 03 00
	00		 jbe	 $LN7@z900_perfo
$LN16@z900_perfo:
$LN8@z900_perfo:
  00447	33 c0		 xor	 eax, eax
  00449	83 f8 01	 cmp	 eax, 1
  0044c	0f 84 7a 04 00
	00		 je	 $LN6@z900_perfo
  00452	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00459	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0045f	c1 e8 08	 shr	 eax, 8
  00462	83 e0 01	 and	 eax, 1
  00465	85 c0		 test	 eax, eax
  00467	0f 84 5f 04 00
	00		 je	 $LN6@z900_perfo
  0046d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00475	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0047b	c1 e8 0f	 shr	 eax, 15
  0047e	83 e0 01	 and	 eax, 1
  00481	85 c0		 test	 eax, eax
  00483	0f 84 43 04 00
	00		 je	 $LN6@z900_perfo
  00489	33 c0		 xor	 eax, eax
  0048b	85 c0		 test	 eax, eax
  0048d	0f 85 2d 01 00
	00		 jne	 $LN17@z900_perfo
  00493	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  004a0	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  004a5	85 c0		 test	 eax, eax
  004a7	0f 84 13 01 00
	00		 je	 $LN17@z900_perfo
  004ad	33 c0		 xor	 eax, eax
  004af	83 f8 01	 cmp	 eax, 1
  004b2	0f 84 14 04 00
	00		 je	 $LN6@z900_perfo
  004b8	33 c0		 xor	 eax, eax
  004ba	85 c0		 test	 eax, eax
  004bc	75 37		 jne	 SHORT $LN18@z900_perfo
  004be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004c5	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  004cb	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  004d0	85 c0		 test	 eax, eax
  004d2	74 21		 je	 SHORT $LN18@z900_perfo
  004d4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004e3	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  004e9	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  004ef	0f 85 d7 03 00
	00		 jne	 $LN6@z900_perfo
$LN18@z900_perfo:
  004f5	33 c0		 xor	 eax, eax
  004f7	85 c0		 test	 eax, eax
  004f9	75 37		 jne	 SHORT $LN19@z900_perfo
  004fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00502	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00508	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0050d	85 c0		 test	 eax, eax
  0050f	74 21		 je	 SHORT $LN19@z900_perfo
  00511	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00519	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00520	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00526	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0052c	0f 8c 9a 03 00
	00		 jl	 $LN6@z900_perfo
$LN19@z900_perfo:
  00532	33 c0		 xor	 eax, eax
  00534	85 c0		 test	 eax, eax
  00536	0f 85 84 00 00
	00		 jne	 $LN20@z900_perfo
  0053c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00543	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00549	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0054e	85 c0		 test	 eax, eax
  00550	74 26		 je	 SHORT $LN21@z900_perfo
  00552	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00561	85 c0		 test	 eax, eax
  00563	74 13		 je	 SHORT $LN21@z900_perfo
  00565	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056d	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00574	85 c0		 test	 eax, eax
  00576	75 48		 jne	 SHORT $LN20@z900_perfo
$LN21@z900_perfo:
  00578	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0057f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00585	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0058a	85 c0		 test	 eax, eax
  0058c	0f 84 3a 03 00
	00		 je	 $LN6@z900_perfo
  00592	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  005a1	85 c0		 test	 eax, eax
  005a3	0f 84 23 03 00
	00		 je	 $LN6@z900_perfo
  005a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b1	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  005b8	85 c0		 test	 eax, eax
  005ba	0f 85 0c 03 00
	00		 jne	 $LN6@z900_perfo
$LN20@z900_perfo:
$LN17@z900_perfo:
  005c0	b8 08 00 00 00	 mov	 eax, 8
  005c5	48 6b c0 00	 imul	 rax, rax, 0
  005c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005d0	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  005d9	75 1f		 jne	 SHORT $LN23@z900_perfo
  005db	b8 08 00 00 00	 mov	 eax, 8
  005e0	48 6b c0 01	 imul	 rax, rax, 1
  005e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005eb	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  005f4	0f 84 e8 01 00
	00		 je	 $LN22@z900_perfo
$LN23@z900_perfo:
  005fa	b8 08 00 00 00	 mov	 eax, 8
  005ff	48 6b c0 00	 imul	 rax, rax, 0
  00603	b9 08 00 00 00	 mov	 ecx, 8
  00608	48 6b c9 01	 imul	 rcx, rcx, 1
  0060c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00613	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0061a	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  00622	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  0062a	0f 87 bc 00 00
	00		 ja	 $LN24@z900_perfo
  00630	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00638	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00640	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00647	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0064b	48 2b c1	 sub	 rax, rcx
  0064e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00656	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0065d	48 03 c8	 add	 rcx, rax
  00660	48 8b c1	 mov	 rax, rcx
  00663	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00672	b9 08 00 00 00	 mov	 ecx, 8
  00677	48 6b c9 00	 imul	 rcx, rcx, 0
  0067b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00682	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0068a	72 60		 jb	 SHORT $LN24@z900_perfo
  0068c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00694	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0069c	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  006a3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  006a7	48 2b c1	 sub	 rax, rcx
  006aa	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b2	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  006b9	48 03 c8	 add	 rcx, rax
  006bc	48 8b c1	 mov	 rax, rcx
  006bf	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  006ce	b9 08 00 00 00	 mov	 ecx, 8
  006d3	48 6b c9 01	 imul	 rcx, rcx, 1
  006d7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006de	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  006e6	0f 86 f6 00 00
	00		 jbe	 $LN22@z900_perfo
$LN24@z900_perfo:
  006ec	b8 08 00 00 00	 mov	 eax, 8
  006f1	48 6b c0 00	 imul	 rax, rax, 0
  006f5	b9 08 00 00 00	 mov	 ecx, 8
  006fa	48 6b c9 01	 imul	 rcx, rcx, 1
  006fe	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00705	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0070c	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  00714	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  0071c	0f 86 aa 01 00
	00		 jbe	 $LN6@z900_perfo
  00722	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00732	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00739	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0073d	48 2b c1	 sub	 rax, rcx
  00740	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00748	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0074f	48 03 c8	 add	 rcx, rax
  00752	48 8b c1	 mov	 rax, rcx
  00755	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00764	b9 08 00 00 00	 mov	 ecx, 8
  00769	48 6b c9 01	 imul	 rcx, rcx, 1
  0076d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00774	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0077c	0f 82 4a 01 00
	00		 jb	 $LN6@z900_perfo
  00782	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00792	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00799	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0079d	48 2b c1	 sub	 rax, rcx
  007a0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a8	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  007af	48 03 c8	 add	 rcx, rax
  007b2	48 8b c1	 mov	 rax, rcx
  007b5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007bd	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  007c4	b9 08 00 00 00	 mov	 ecx, 8
  007c9	48 6b c9 00	 imul	 rcx, rcx, 0
  007cd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007d4	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  007dc	0f 87 ea 00 00
	00		 ja	 $LN6@z900_perfo
$LN22@z900_perfo:
$LN7@z900_perfo:

; 1633 :     {
; 1634 :         if (regs->insttrace && sysblk.traceFILE)

  007e2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ea	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007f0	c1 e8 0f	 shr	 eax, 15
  007f3	83 e0 01	 and	 eax, 1
  007f6	85 c0		 test	 eax, eax
  007f8	74 33		 je	 SHORT $LN25@z900_perfo
  007fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00801	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00809	74 22		 je	 SHORT $LN25@z900_perfo

; 1635 :             tf_0807( regs, mcic, fsta, xdmg );

  0080b	44 8b 4c 24 58	 mov	 r9d, DWORD PTR xdmg$[rsp]
  00810	4c 8b 44 24 70	 mov	 r8, QWORD PTR fsta$[rsp]
  00815	48 8b 54 24 68	 mov	 rdx, QWORD PTR mcic$[rsp]
  0081a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00822	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0807
  00828	e9 9f 00 00 00	 jmp	 $LN26@z900_perfo
$LN25@z900_perfo:

; 1636 :         else
; 1637 :             // "Processor %s%02X: machine check code %16.16"PRIu64
; 1638 :             WRMSG (HHC00807, "I", PTYPSTR(regs->cpuad), regs->cpuad, mcic);

  0082d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00835	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0083c	89 44 24 5c	 mov	 DWORD PTR tv361[rsp], eax
  00840	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00848	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0084f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00856	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0085e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00864	48 89 44 24 78	 mov	 QWORD PTR tv363[rsp], rax
  00869	b9 01 00 00 00	 mov	 ecx, 1
  0086e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00874	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mcic$[rsp]
  00879	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0087e	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv361[rsp]
  00882	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00886	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv363[rsp]
  0088b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00890	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196432
  00897	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0089c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196433
  008a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196434
  008ba	ba 66 06 00 00	 mov	 edx, 1638		; 00000666H
  008bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196435
  008c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN26@z900_perfo:
$LN6@z900_perfo:

; 1639 :     }
; 1640 : 
; 1641 :     /* Store the external damage code at PSA+244 */
; 1642 :     STORE_FW(psa->xdmgcode, xdmg);

  008cc	8b 4c 24 58	 mov	 ecx, DWORD PTR xdmg$[rsp]
  008d0	e8 00 00 00 00	 call	 _byteswap_ulong
  008d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  008da	48 81 c1 f4 00
	00 00		 add	 rcx, 244		; 000000f4H
  008e1	8b d0		 mov	 edx, eax
  008e3	e8 00 00 00 00	 call	 store_fw_noswap

; 1643 : 
; 1644 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1645 :     /* Store the failing storage address at PSA+248 */
; 1646 :     STORE_DW(psa->mcstorad, fsta);

  008e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR fsta$[rsp]
  008ed	e8 00 00 00 00	 call	 _byteswap_uint64
  008f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  008f7	48 81 c1 f8 00
	00 00		 add	 rcx, 248		; 000000f8H
  008fe	48 8b d0	 mov	 rdx, rax
  00901	e8 00 00 00 00	 call	 store_dw_noswap

; 1647 : #else
; 1648 :     /* Store the failing storage address at PSA+248 */
; 1649 :     STORE_FW(psa->mcstorad, fsta);
; 1650 : #endif
; 1651 : 
; 1652 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1653 :     /* Abort any active transaction and then return back to here
; 1654 :        to continue with machine check interrupt processing */
; 1655 :     if (regs->txf_tnd)

  00906	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0090e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00915	85 c0		 test	 eax, eax
  00917	0f 84 a7 00 00
	00		 je	 $LN27@z900_perfo
$LN4@z900_perfo:

; 1656 :     {
; 1657 :         PTT_TXF( "*TXF MCK", 0, regs->txf_contran, regs->txf_tnd );

  0091d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00924	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00927	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0092d	48 85 c0	 test	 rax, rax
  00930	74 50		 je	 SHORT $LN28@z900_perfo
  00932	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0093a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00941	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00949	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00950	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00959	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0095e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196438
  00965	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0096a	44 8b c9	 mov	 r9d, ecx
  0096d	45 33 c0	 xor	 r8d, r8d
  00970	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196439
  00977	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0097c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@z900_perfo:
  00982	33 c0		 xor	 eax, eax
  00984	85 c0		 test	 eax, eax
  00986	75 95		 jne	 SHORT $LN4@z900_perfo

; 1658 :         regs->txf_why |= TXF_WHY_MCK_INT;

  00988	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00990	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00996	0f ba e8 12	 bts	 eax, 18
  0099a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a2	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1659 :         ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_MCK );

  009a8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196440
  009af	41 b8 05 00 00
	00		 mov	 r8d, 5
  009b5	33 d2		 xor	 edx, edx
  009b7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009bf	e8 00 00 00 00	 call	 z900_abort_transaction
$LN27@z900_perfo:

; 1660 :     }
; 1661 : #endif
; 1662 :     /* Store current PSW at PSA+X'30' */
; 1663 :     ARCH_DEP(store_psw) ( regs, psa->mckold );

  009c4	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  009c9	48 05 60 01 00
	00		 add	 rax, 352		; 00000160H
  009cf	48 8b d0	 mov	 rdx, rax
  009d2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009da	e8 00 00 00 00	 call	 z900_store_psw

; 1664 : 
; 1665 :     /* Load new PSW from PSA+X'70' */
; 1666 :     rc = ARCH_DEP(load_psw) ( regs, psa->mcknew );

  009df	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  009e4	48 05 e0 01 00
	00		 add	 rax, 480		; 000001e0H
  009ea	48 8b d0	 mov	 rdx, rax
  009ed	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009f5	e8 00 00 00 00	 call	 z900_load_psw
  009fa	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1667 : 
; 1668 :     RELEASE_INTLOCK(regs);

  009fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196441
  00a05	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a0d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1669 : 
; 1670 :     if ( rc )

  00a12	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a17	74 1a		 je	 SHORT $LN29@z900_perfo

; 1671 :         regs->program_interrupt (regs, rc);

  00a19	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  00a1d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a25	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a2d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@z900_perfo:

; 1672 : 
; 1673 :     longjmp (regs->progjmp, SIE_INTERCEPT_MCK);

  00a33	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a3b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00a41	ba f5 ff ff ff	 mov	 edx, -11
  00a46	48 8b c8	 mov	 rcx, rax
  00a49	e8 00 00 00 00	 call	 longjmp
$LN1@z900_perfo:
$LN30@z900_perfo:

; 1674 : } /* end function perform_mck_interrupt */

  00a4e	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00a55	c3		 ret	 0
z900_perform_mck_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
rc$ = 64
psa$ = 72
regs$ = 96
z900_restart_interrupt PROC

; 1408 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@z900_resta:

; 1409 : int     rc;                             /* Return code               */
; 1410 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1411 : 
; 1412 :     PTT_INF("*RESTART",regs->cpuad,regs->cpustate,regs->psw.IA_L);

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 83 e0 08	 and	 rax, 8
  00017	48 85 c0	 test	 rax, rax
  0001a	74 52		 je	 SHORT $LN8@z900_resta
  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	0f b6 49 60	 movzx	 ecx, BYTE PTR [rcx+96]
  00030	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00035	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  0003c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00045	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196259
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	44 8b c9	 mov	 r9d, ecx
  00059	44 8b c2	 mov	 r8d, edx
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196260
  00063	b9 08 00 00 00	 mov	 ecx, 8
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN8@z900_resta:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 95		 jne	 SHORT $LN4@z900_resta

; 1413 : 
; 1414 :     /* Set the main storage reference and change bits */
; 1415 :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  00074	b2 06		 mov	 dl, 6
  00076	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0007b	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0007f	e8 00 00 00 00	 call	 z900_or_storage_key

; 1416 : 
; 1417 :     /* Zeroize the interrupt code in the PSW */
; 1418 :     regs->psw.intcode = 0;

  00084	33 c0		 xor	 eax, eax
  00086	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 1419 : 
; 1420 :     /* Point to PSA in main storage */
; 1421 :     psa = (PSA*)(regs->mainstor + regs->PX);

  00092	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00097	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0009e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	48 03 41 70	 add	 rax, QWORD PTR [rcx+112]
  000a7	48 89 44 24 48	 mov	 QWORD PTR psa$[rsp], rax

; 1422 : 
; 1423 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1424 :     /* Abort any active transaction and then return back to here
; 1425 :        to continue with restart interrupt processing */
; 1426 :     if (regs->txf_tnd)

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000b1	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000b8	85 c0		 test	 eax, eax
  000ba	0f 84 98 00 00
	00		 je	 $LN9@z900_resta
$LN7@z900_resta:

; 1427 :     {
; 1428 :         PTT_TXF( "*TXF MISC", 0, regs->txf_contran, regs->txf_tnd );

  000c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ca	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  000d0	48 85 c0	 test	 rax, rax
  000d3	74 4a		 je	 SHORT $LN10@z900_resta
  000d5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000da	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  000e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000e6	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  000ed	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000f6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196263
  00102	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00107	44 8b c9	 mov	 r9d, ecx
  0010a	45 33 c0	 xor	 r8d, r8d
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196264
  00114	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN10@z900_resta:
  0011f	33 c0		 xor	 eax, eax
  00121	85 c0		 test	 eax, eax
  00123	75 9b		 jne	 SHORT $LN7@z900_resta

; 1429 :         regs->txf_why |= TXF_WHY_RESTART_INT;

  00125	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00130	0f ba e8 14	 bts	 eax, 20
  00134	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1430 :         ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_MISC );

  0013f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196265
  00146	41 b8 ff 00 00
	00		 mov	 r8d, 255		; 000000ffH
  0014c	33 d2		 xor	 edx, edx
  0014e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	e8 00 00 00 00	 call	 z900_abort_transaction
$LN9@z900_resta:

; 1431 :     }
; 1432 : #endif
; 1433 :     /* Store current PSW at PSA+X'8' or PSA+X'120' for ESAME  */
; 1434 :     ARCH_DEP(store_psw) (regs, psa->RSTOLD);

  00158	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  0015d	48 05 20 01 00
	00		 add	 rax, 288		; 00000120H
  00163	48 8b d0	 mov	 rdx, rax
  00166	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	e8 00 00 00 00	 call	 z900_store_psw

; 1435 : 
; 1436 :     /* Load new PSW from PSA+X'0' or PSA+X'1A0' for ESAME */
; 1437 :     rc = ARCH_DEP(load_psw) (regs, psa->RSTNEW);

  00170	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  00175	48 05 a0 01 00
	00		 add	 rax, 416		; 000001a0H
  0017b	48 8b d0	 mov	 rdx, rax
  0017e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	e8 00 00 00 00	 call	 z900_load_psw
  00188	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 1438 : 
; 1439 :     if ( rc == 0)

  0018c	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00191	75 22		 jne	 SHORT $LN11@z900_resta

; 1440 :     {
; 1441 :         regs->opinterv = 0;

  00193	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00198	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019e	83 e0 ef	 and	 eax, -17		; ffffffefH
  001a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1442 :         regs->cpustate = CPUSTATE_STARTED;

  001ac	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001b1	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1
$LN11@z900_resta:

; 1443 :     }
; 1444 : 
; 1445 :     RELEASE_INTLOCK(regs);

  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196267
  001bc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001c1	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1446 : 
; 1447 :     if ( rc )

  001c6	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  001cb	74 14		 je	 SHORT $LN12@z900_resta

; 1448 :         regs->program_interrupt(regs, rc);

  001cd	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  001d1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001db	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_resta:

; 1449 : 
; 1450 :     longjmp (regs->progjmp, SIE_INTERCEPT_RESTART);

  001e1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  001ec	ba f6 ff ff ff	 mov	 edx, -10
  001f1	48 8b c8	 mov	 rcx, rax
  001f4	e8 00 00 00 00	 call	 longjmp
$LN13@z900_resta:

; 1451 : } /* end function restart_interrupt */

  001f9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001fd	c3		 ret	 0
z900_restart_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 56
ip$ = 64
offset$ = 72
len$ = 76
tv128 = 80
tv130 = 84
tv137 = 88
tv156 = 92
tv172 = 96
tv174 = 100
tv180 = 104
tv187 = 108
tv204 = 112
tv239 = 116
tv238 = 120
tv240 = 124
tv256 = 128
tv350 = 132
tv351 = 136
dest$ = 144
tv75 = 152
tv77 = 160
tv357 = 168
regs$ = 192
exec$ = 200
z900_instfetch PROC					; COMDAT

; 777  : {

$LN96:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 1c		 je	 SHORT $LN52@z900_instf
  0001a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  00029	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
  00031	e9 85 00 00 00	 jmp	 $LN53@z900_instf
$LN52@z900_instf:
  00036	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003e	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00046	74 4c		 je	 SHORT $LN50@z900_instf
  00048	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00050	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00058	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0005f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00063	48 2b c1	 sub	 rax, rcx
  00066	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00075	48 03 c8	 add	 rcx, rax
  00078	48 8b c1	 mov	 rax, rcx
  0007b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0008a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  00092	eb 17		 jmp	 SHORT $LN51@z900_instf
$LN50@z900_instf:
  00094	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009c	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  000a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
$LN51@z900_instf:
  000ab	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv75[rsp]
  000b3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
$LN53@z900_instf:
  000bb	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv77[rsp]
  000c3	48 89 44 24 30	 mov	 QWORD PTR addr$[rsp], rax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  000c8	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000d0	75 69		 jne	 SHORT $LN23@z900_instf
$LN4@z900_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000d2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000e2	74 51		 je	 SHORT $LN24@z900_instf
  000e4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  000fb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ff	48 2b c1	 sub	 rax, rcx
  00102	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00111	48 03 c8	 add	 rcx, rax
  00114	48 8b c1	 mov	 rax, rcx
  00117	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00126	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN24@z900_instf:
  00135	33 c0		 xor	 eax, eax
  00137	85 c0		 test	 eax, eax
  00139	75 97		 jne	 SHORT $LN4@z900_instf
$LN23@z900_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  0013b	48 8b 44 24 30	 mov	 rax, QWORD PTR addr$[rsp]
  00140	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00146	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  0014a	48 81 7c 24 30
	00 08 00 00	 cmp	 QWORD PTR addr$[rsp], 2048 ; 00000800H
  00153	73 0a		 jae	 SHORT $LN56@z900_instf
  00155	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  0015d	eb 08		 jmp	 SHORT $LN57@z900_instf
$LN56@z900_instf:
  0015f	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN57@z900_instf:
  00167	83 7c 24 50 00	 cmp	 DWORD PTR tv128[rsp], 0
  0016c	74 0a		 je	 SHORT $LN58@z900_instf
  0016e	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv130[rsp], 2048 ; 00000800H
  00176	eb 08		 jmp	 SHORT $LN59@z900_instf
$LN58@z900_instf:
  00178	c7 44 24 54 00
	10 00 00	 mov	 DWORD PTR tv130[rsp], 4096 ; 00001000H
$LN59@z900_instf:
  00180	8b 44 24 54	 mov	 eax, DWORD PTR tv130[rsp]
  00184	89 44 24 38	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  00188	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  0018c	83 e0 01	 and	 eax, 1
  0018f	85 c0		 test	 eax, eax
  00191	74 0a		 je	 SHORT $LN62@z900_instf
  00193	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  0019b	eb 08		 jmp	 SHORT $LN63@z900_instf
$LN62@z900_instf:
  0019d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN63@z900_instf:
  001a5	83 7c 24 58 00	 cmp	 DWORD PTR tv137[rsp], 0
  001aa	74 44		 je	 SHORT $LN25@z900_instf

; 798  :     {
; 799  :         if (!exec)

  001ac	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  001b4	75 1f		 jne	 SHORT $LN26@z900_instf

; 800  :             regs->instinvalid = 1;

  001b6	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001be	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c4	83 c8 08	 or	 eax, 8
  001c7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cf	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN26@z900_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001d5	ba 06 00 00 00	 mov	 edx, 6
  001da	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ea	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@z900_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001f0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001fe	c1 e8 02	 shr	 eax, 2
  00201	83 e0 01	 and	 eax, 1
  00204	85 c0		 test	 eax, eax
  00206	74 0a		 je	 SHORT $LN66@z900_instf
  00208	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv156[rsp], 1
  00210	eb 08		 jmp	 SHORT $LN67@z900_instf
$LN66@z900_instf:
  00212	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN67@z900_instf:
  0021a	83 7c 24 5c 00	 cmp	 DWORD PTR tv156[rsp], 0
  0021f	0f 84 16 05 00
	00		 je	 $LN27@z900_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */

  00225	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00231	83 e0 04	 and	 eax, 4
  00234	85 c0		 test	 eax, eax
  00236	74 0a		 je	 SHORT $LN68@z900_instf
  00238	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  00240	eb 08		 jmp	 SHORT $LN69@z900_instf
$LN68@z900_instf:
  00242	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN69@z900_instf:
  0024a	83 7c 24 60 00	 cmp	 DWORD PTR tv172[rsp], 0
  0024f	74 0a		 je	 SHORT $LN70@z900_instf
  00251	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv174[rsp], 16
  00259	eb 08		 jmp	 SHORT $LN71@z900_instf
$LN70@z900_instf:
  0025b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN71@z900_instf:
  00263	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0026f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00274	85 c0		 test	 eax, eax
  00276	74 0a		 je	 SHORT $LN72@z900_instf
  00278	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  00280	eb 08		 jmp	 SHORT $LN73@z900_instf
$LN72@z900_instf:
  00282	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN73@z900_instf:
  0028a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00292	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00296	83 e0 40	 and	 eax, 64			; 00000040H
  00299	85 c0		 test	 eax, eax
  0029b	74 0a		 je	 SHORT $LN74@z900_instf
  0029d	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  002a5	eb 08		 jmp	 SHORT $LN75@z900_instf
$LN74@z900_instf:
  002a7	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN75@z900_instf:
  002af	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002bd	83 e0 01	 and	 eax, 1
  002c0	c1 e0 07	 shl	 eax, 7
  002c3	83 c8 40	 or	 eax, 64			; 00000040H
  002c6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ce	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  002d4	d1 e9		 shr	 ecx, 1
  002d6	83 e1 01	 and	 ecx, 1
  002d9	c1 e1 05	 shl	 ecx, 5
  002dc	0b c1		 or	 eax, ecx
  002de	0b 44 24 64	 or	 eax, DWORD PTR tv174[rsp]
  002e2	8b 4c 24 68	 mov	 ecx, DWORD PTR tv180[rsp]
  002e6	c1 e1 03	 shl	 ecx, 3
  002e9	0b c1		 or	 eax, ecx
  002eb	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv187[rsp]
  002ef	c1 e1 02	 shl	 ecx, 2
  002f2	0b c1		 or	 eax, ecx
  002f4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fc	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;
; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  00303	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0030b	75 14		 jne	 SHORT $LN28@z900_instf

; 822  :             regs->peradr = addr;

  0030d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00315	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0031a	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN28@z900_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  00321	33 c0		 xor	 eax, eax
  00323	83 f8 01	 cmp	 eax, 1
  00326	0f 84 22 02 00
	00		 je	 $LN29@z900_instf
  0032c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00334	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0033a	c1 e8 02	 shr	 eax, 2
  0033d	83 e0 01	 and	 eax, 1
  00340	85 c0		 test	 eax, eax
  00342	74 0a		 je	 SHORT $LN78@z900_instf
  00344	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  0034c	eb 08		 jmp	 SHORT $LN79@z900_instf
$LN78@z900_instf:
  0034e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN79@z900_instf:
  00356	83 7c 24 70 00	 cmp	 DWORD PTR tv204[rsp], 0
  0035b	0f 84 ed 01 00
	00		 je	 $LN29@z900_instf
  00361	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0036c	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00371	85 c0		 test	 eax, eax
  00373	0f 84 d5 01 00
	00		 je	 $LN29@z900_instf
  00379	b8 08 00 00 00	 mov	 eax, 8
  0037e	48 6b c0 0c	 imul	 rax, rax, 12
  00382	b9 08 00 00 00	 mov	 ecx, 8
  00387	48 6b c9 0b	 imul	 rcx, rcx, 11
  0038b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00393	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0039b	49 8b 8c 08 00
	06 00 00	 mov	 rcx, QWORD PTR [r8+rcx+1536]
  003a3	48 39 8c 02 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax+1536], rcx
  003ab	72 5c		 jb	 SHORT $LN84@z900_instf
  003ad	b8 08 00 00 00	 mov	 eax, 8
  003b2	48 6b c0 0b	 imul	 rax, rax, 11
  003b6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003be	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  003c6	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  003cb	72 2a		 jb	 SHORT $LN80@z900_instf
  003cd	b8 08 00 00 00	 mov	 eax, 8
  003d2	48 6b c0 0c	 imul	 rax, rax, 12
  003d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003de	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  003e6	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  003eb	77 0a		 ja	 SHORT $LN80@z900_instf
  003ed	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv239[rsp], 1
  003f5	eb 08		 jmp	 SHORT $LN83@z900_instf
$LN80@z900_instf:
  003f7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv239[rsp], 0
$LN83@z900_instf:
  003ff	8b 44 24 74	 mov	 eax, DWORD PTR tv239[rsp]
  00403	89 44 24 7c	 mov	 DWORD PTR tv240[rsp], eax
  00407	eb 5a		 jmp	 SHORT $LN85@z900_instf
$LN84@z900_instf:
  00409	b8 08 00 00 00	 mov	 eax, 8
  0040e	48 6b c0 0b	 imul	 rax, rax, 11
  00412	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00422	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  00427	73 2a		 jae	 SHORT $LN81@z900_instf
  00429	b8 08 00 00 00	 mov	 eax, 8
  0042e	48 6b c0 0c	 imul	 rax, rax, 12
  00432	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043a	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00442	48 39 44 24 30	 cmp	 QWORD PTR addr$[rsp], rax
  00447	76 0a		 jbe	 SHORT $LN81@z900_instf
  00449	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv238[rsp], 0
  00451	eb 08		 jmp	 SHORT $LN82@z900_instf
$LN81@z900_instf:
  00453	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv238[rsp], 1
$LN82@z900_instf:
  0045b	8b 44 24 78	 mov	 eax, DWORD PTR tv238[rsp]
  0045f	89 44 24 7c	 mov	 DWORD PTR tv240[rsp], eax
$LN85@z900_instf:
  00463	83 7c 24 7c 00	 cmp	 DWORD PTR tv240[rsp], 0
  00468	0f 84 e0 00 00
	00		 je	 $LN29@z900_instf
$LN7@z900_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  0046e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00476	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00479	0f ba e8 16	 bts	 eax, 22
  0047d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00485	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00488	33 c0		 xor	 eax, eax
  0048a	85 c0		 test	 eax, eax
  0048c	75 e0		 jne	 SHORT $LN7@z900_instf

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))

  0048e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00496	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049c	c1 e8 02	 shr	 eax, 2
  0049f	83 e0 01	 and	 eax, 1
  004a2	85 c0		 test	 eax, eax
  004a4	74 0d		 je	 SHORT $LN88@z900_instf
  004a6	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv256[rsp], 1
  004b1	eb 0b		 jmp	 SHORT $LN89@z900_instf
$LN88@z900_instf:
  004b3	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv256[rsp], 0
$LN89@z900_instf:
  004be	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv256[rsp], 0
  004c6	0f 84 82 00 00
	00		 je	 $LN30@z900_instf
  004cc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  004d7	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  004dc	85 c0		 test	 eax, eax
  004de	74 6e		 je	 SHORT $LN30@z900_instf
$LN10@z900_instf:

; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );

  004e0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e8	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  004eb	0f ba e8 10	 bts	 eax, 16
  004ef	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f7	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  004fa	33 c0		 xor	 eax, eax
  004fc	85 c0		 test	 eax, eax
  004fe	75 e0		 jne	 SHORT $LN10@z900_instf

; 839  :                 regs->psw.IA = addr;

  00500	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00508	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0050d	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 840  :                 regs->psw.zeroilc = 1;

  00514	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0051c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00522	83 c8 04	 or	 eax, 4
  00525	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052d	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );

  00533	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00538	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00540	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@z900_instf:
$LN29@z900_instf:

; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  0054e	33 c0		 xor	 eax, eax
  00550	83 f8 01	 cmp	 eax, 1
  00553	0f 84 e2 01 00
	00		 je	 $LN31@z900_instf
  00559	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00561	0f 85 d4 01 00
	00		 jne	 $LN31@z900_instf
  00567	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00575	c1 e8 10	 shr	 eax, 16
  00578	83 e0 01	 and	 eax, 1
  0057b	85 c0		 test	 eax, eax
  0057d	0f 85 b8 01 00
	00		 jne	 $LN31@z900_instf
  00583	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058b	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00593	0f 84 a2 01 00
	00		 je	 $LN31@z900_instf
  00599	48 63 44 24 38	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0059e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a6	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  005ad	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  005b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ba	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  005be	0f 83 77 01 00
	00		 jae	 $LN31@z900_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)

  005c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005cc	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  005d3	85 c0		 test	 eax, eax
  005d5	74 4d		 je	 SHORT $LN32@z900_instf

; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)

  005d7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e7	48 8b 89 70 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44912]
  005ee	48 39 88 10 02
	00 00		 cmp	 QWORD PTR [rax+528], rcx
  005f5	75 2d		 jne	 SHORT $LN33@z900_instf

; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;

  005f7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ff	48 63 80 78 af
	00 00		 movsxd	 rax, DWORD PTR [rax+44920]
  00606	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060e	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  00615	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061d	48 89 81 60 af
	00 00		 mov	 QWORD PTR [rcx+44896], rax
$LN33@z900_instf:
$LN32@z900_instf:
$LN13@z900_instf:

; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );

  00624	33 c0		 xor	 eax, eax
  00626	83 f8 01	 cmp	 eax, 1
  00629	74 6f		 je	 SHORT $LN34@z900_instf
  0062b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00633	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0063a	85 c0		 test	 eax, eax
  0063c	74 5c		 je	 SHORT $LN34@z900_instf
  0063e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00646	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0064e	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  00655	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00659	72 3f		 jb	 SHORT $LN34@z900_instf
  0065b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00663	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00669	0f ba e8 1f	 bts	 eax, 31
  0066d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00675	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  0067b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CM@GFKCBHDD@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00682	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00688	ba fe ff ff ff	 mov	 edx, -2
  0068d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00695	e8 00 00 00 00	 call	 z900_abort_transaction
$LN34@z900_instf:
  0069a	33 c0		 xor	 eax, eax
  0069c	85 c0		 test	 eax, eax
  0069e	75 84		 jne	 SHORT $LN13@z900_instf

; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  006a0	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b0	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  006b7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  006bb	48 2b c1	 sub	 rax, rcx
  006be	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c6	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  006cd	48 03 c8	 add	 rcx, rax
  006d0	48 8b c1	 mov	 rax, rcx
  006d3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006db	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  006e2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ea	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  006f1	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  006f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006fe	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00703	0f b6 c0	 movzx	 eax, al
  00706	85 c0		 test	 eax, eax
  00708	74 20		 je	 SHORT $LN35@z900_instf
$LN16@z900_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  0070a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00712	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00715	0f ba f0 16	 btr	 eax, 22
  00719	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00721	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00724	33 c0		 xor	 eax, eax
  00726	85 c0		 test	 eax, eax
  00728	75 e0		 jne	 SHORT $LN16@z900_instf
$LN35@z900_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  0072a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00732	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00736	e9 49 04 00 00	 jmp	 $LN1@z900_instf
$LN31@z900_instf:
$LN27@z900_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  0073b	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00743	75 1f		 jne	 SHORT $LN36@z900_instf

; 882  :         regs->instinvalid = 1;

  00745	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00753	83 c8 08	 or	 eax, 8
  00756	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075e	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN36@z900_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  00764	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00770	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00774	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0077c	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00784	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  0078a	ba 06 00 00 00	 mov	 edx, 6
  0078f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  00794	e8 00 00 00 00	 call	 z900_maddr_l
  00799	48 89 44 24 40	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  0079e	b8 01 00 00 00	 mov	 eax, 1
  007a3	48 6b c0 00	 imul	 rax, rax, 0
  007a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  007ac	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007b0	83 f8 40	 cmp	 eax, 64			; 00000040H
  007b3	7d 0d		 jge	 SHORT $LN92@z900_instf
  007b5	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv351[rsp], 2
  007c0	eb 3f		 jmp	 SHORT $LN93@z900_instf
$LN92@z900_instf:
  007c2	b8 01 00 00 00	 mov	 eax, 1
  007c7	48 6b c0 00	 imul	 rax, rax, 0
  007cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  007d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  007d4	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  007d9	7d 0d		 jge	 SHORT $LN90@z900_instf
  007db	c7 84 24 84 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv350[rsp], 4
  007e6	eb 0b		 jmp	 SHORT $LN91@z900_instf
$LN90@z900_instf:
  007e8	c7 84 24 84 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv350[rsp], 6
$LN91@z900_instf:
  007f3	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv350[rsp]
  007fa	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv351[rsp], eax
$LN93@z900_instf:
  00801	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv351[rsp]
  00808	8b 4c 24 48	 mov	 ecx, DWORD PTR offset$[rsp]
  0080c	03 c8		 add	 ecx, eax
  0080e	8b c1		 mov	 eax, ecx
  00810	3b 44 24 38	 cmp	 eax, DWORD PTR pagesz$[rsp]
  00814	0f 8e 06 01 00
	00		 jle	 $LN37@z900_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  0081a	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00822	74 18		 je	 SHORT $LN94@z900_instf
  00824	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0082c	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  00832	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
  0083a	eb 16		 jmp	 SHORT $LN95@z900_instf
$LN94@z900_instf:
  0083c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00844	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0084a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv357[rsp], rax
$LN95@z900_instf:
  00852	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv357[rsp]
  0085a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00862	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0086a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  0086f	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00871	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  00873	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00877	8b 4c 24 38	 mov	 ecx, DWORD PTR pagesz$[rsp]
  0087b	2b c8		 sub	 ecx, eax
  0087d	8b c1		 mov	 eax, ecx
  0087f	89 44 24 4c	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  00883	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  00888	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  0088d	48 03 c8	 add	 rcx, rax
  00890	48 8b c1	 mov	 rax, rcx
  00893	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0089b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  008a2	48 89 44 24 30	 mov	 QWORD PTR addr$[rsp], rax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  008a7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008af	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  008b3	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  008b7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  008bf	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008c7	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  008cd	ba 01 00 00 00	 mov	 edx, 1
  008d2	48 8b 4c 24 30	 mov	 rcx, QWORD PTR addr$[rsp]
  008d7	e8 00 00 00 00	 call	 z900_maddr_l
  008dc	48 89 44 24 40	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  008e1	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  008e9	75 1c		 jne	 SHORT $LN39@z900_instf

; 899  :             regs->ip = ip - len;

  008eb	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  008f0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  008f5	48 2b c8	 sub	 rcx, rax
  008f8	48 8b c1	 mov	 rax, rcx
  008fb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00903	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN39@z900_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00907	48 63 44 24 4c	 movsxd	 rax, DWORD PTR len$[rsp]
  0090c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00914	48 8b 54 24 40	 mov	 rdx, QWORD PTR ip$[rsp]
  00919	8b 12		 mov	 edx, DWORD PTR [rdx]
  0091b	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0091e	eb 28		 jmp	 SHORT $LN38@z900_instf
$LN37@z900_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  00920	48 8b 44 24 40	 mov	 rax, QWORD PTR ip$[rsp]
  00925	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  0092d	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00935	75 11		 jne	 SHORT $LN40@z900_instf

; 907  :             regs->ip = ip;

  00937	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0093f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ip$[rsp]
  00944	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN40@z900_instf:
$LN38@z900_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00948	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00950	0f 85 c0 00 00
	00		 jne	 $LN41@z900_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00956	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0095e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00964	83 e0 f7	 and	 eax, -9			; fffffff7H
  00967	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0096f	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  00975	48 8b 44 24 30	 mov	 rax, QWORD PTR addr$[rsp]
  0097a	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00980	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00988	48 89 81 10 02
	00 00		 mov	 QWORD PTR [rcx+528], rax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  0098f	48 8b 44 24 40	 mov	 rax, QWORD PTR ip$[rsp]
  00994	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0099a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a2	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  009a9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009b7	c1 e8 10	 shr	 eax, 16
  009ba	83 e0 01	 and	 eax, 1
  009bd	85 c0		 test	 eax, eax
  009bf	75 18		 jne	 SHORT $LN44@z900_instf
  009c1	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009c9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009cf	c1 e8 02	 shr	 eax, 2
  009d2	83 e0 01	 and	 eax, 1
  009d5	85 c0		 test	 eax, eax
  009d7	74 15		 je	 SHORT $LN42@z900_instf
$LN44@z900_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  009d9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e1	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  009ec	eb 28		 jmp	 SHORT $LN43@z900_instf
$LN42@z900_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  009ee	48 63 44 24 38	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  009f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009fb	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00a02	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00a07	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a0f	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN43@z900_instf:
$LN41@z900_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)

  00a16	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a1e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00a25	85 c0		 test	 eax, eax
  00a27	74 4d		 je	 SHORT $LN45@z900_instf

; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)

  00a29	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a31	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a39	48 8b 89 70 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44912]
  00a40	48 39 88 10 02
	00 00		 cmp	 QWORD PTR [rax+528], rcx
  00a47	75 2d		 jne	 SHORT $LN46@z900_instf

; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;

  00a49	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a51	48 63 80 78 af
	00 00		 movsxd	 rax, DWORD PTR [rax+44920]
  00a58	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a60	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  00a67	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a6f	48 89 81 60 af
	00 00		 mov	 QWORD PTR [rcx+44896], rax
$LN46@z900_instf:
$LN45@z900_instf:
$LN19@z900_instf:

; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );

  00a76	33 c0		 xor	 eax, eax
  00a78	83 f8 01	 cmp	 eax, 1
  00a7b	74 6f		 je	 SHORT $LN47@z900_instf
  00a7d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a85	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00a8c	85 c0		 test	 eax, eax
  00a8e	74 5c		 je	 SHORT $LN47@z900_instf
  00a90	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a98	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa0	48 8b 89 60 af
	00 00		 mov	 rcx, QWORD PTR [rcx+44896]
  00aa7	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00aab	72 3f		 jb	 SHORT $LN47@z900_instf
  00aad	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ab5	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00abb	0f ba e8 1f	 bts	 eax, 31
  00abf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac7	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  00acd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0CM@NOJKKEDI@C?3?2papa?2MyGit?2hyperion?9zvector?2@
  00ad4	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00ada	ba fe ff ff ff	 mov	 edx, -2
  00adf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ae7	e8 00 00 00 00	 call	 z900_abort_transaction
$LN47@z900_instf:
  00aec	33 c0		 xor	 eax, eax
  00aee	85 c0		 test	 eax, eax
  00af0	75 84		 jne	 SHORT $LN19@z900_instf

; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00af2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00afa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b02	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00b09	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00b0d	48 2b c1	 sub	 rax, rcx
  00b10	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b18	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00b1f	48 03 c8	 add	 rcx, rax
  00b22	48 8b c1	 mov	 rax, rcx
  00b25	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b2d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00b34	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b3c	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00b43	ba 00 00 00 40	 mov	 edx, 1073741824		; 40000000H
  00b48	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b50	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00b55	0f b6 c0	 movzx	 eax, al
  00b58	85 c0		 test	 eax, eax
  00b5a	74 20		 je	 SHORT $LN48@z900_instf
$LN22@z900_instf:

; 952  :         OFF_IC_PER_IF( regs );

  00b5c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b64	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00b67	0f ba f0 16	 btr	 eax, 22
  00b6b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b73	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00b76	33 c0		 xor	 eax, eax
  00b78	85 c0		 test	 eax, eax
  00b7a	75 e0		 jne	 SHORT $LN22@z900_instf
$LN48@z900_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  00b7c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@z900_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  00b84	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00b8b	c3		 ret	 0
z900_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
code$ = 128
tv132 = 132
ip$ = 136
tv471 = 144
tv404 = 152
tv406 = 160
tv527 = 168
tv465 = 176
tv473 = 184
dxcstr$ = 192
sie_mode_str$ = 200
sie_debug_arch$ = 216
txf_why$ = 256
__$ArrayPad$ = 512
regs$ = 544
pcode$ = 552
ilc$ = 560
z900_trace_program_interrupt PROC

; 447  : {

$LN45:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 448  :     char sie_mode_str    [ 10]  = {0};  // maybe "SIE: "

  00028	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR sie_mode_str$[rsp]
  00030	48 8b f8	 mov	 rdi, rax
  00033	33 c0		 xor	 eax, eax
  00035	b9 0a 00 00 00	 mov	 ecx, 10
  0003a	f3 aa		 rep stosb

; 449  :     char sie_debug_arch  [ 32]  = {0};  // "370", "390" or "900" if defined( SIE_DEBUG )

  0003c	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR sie_debug_arch$[rsp]
  00044	48 8b f8	 mov	 rdi, rax
  00047	33 c0		 xor	 eax, eax
  00049	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004e	f3 aa		 rep stosb

; 450  :     char txf_why         [256]  = {0};  // TXF "why" string if txf pgmint

  00050	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR txf_why$[rsp]
  00058	48 8b f8	 mov	 rdi, rax
  0005b	33 c0		 xor	 eax, eax
  0005d	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00062	f3 aa		 rep stosb

; 451  :     char dxcstr          [  8]  = {0};  // data exception code if PGM_DATA_EXCEPTION

  00064	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dxcstr$[rsp]
  0006c	48 8b f8	 mov	 rdi, rax
  0006f	33 c0		 xor	 eax, eax
  00071	b9 08 00 00 00	 mov	 ecx, 8
  00076	f3 aa		 rep stosb

; 452  : 
; 453  :     BYTE* ip;      /* ptr to instr that program checked or NULL  */
; 454  : 
; 455  :     /* Just the low byte of program interrupt code itself please */
; 456  :     int code = (pcode & 0xFF);

  00078	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  0007f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00084	89 84 24 80 00
	00 00		 mov	 DWORD PTR code$[rsp], eax

; 457  : 
; 458  :     /* If the program interrupt code is zero, or if it's not, if the
; 459  :        code isn't one they're interested in seeing (as determiend by
; 460  :        OSTAILOR/pgmtrace) AND instruction tracing is NOT active, then
; 461  :        there's nothing for us to do.
; 462  :     */
; 463  :     if (0
; 464  :         || !code
; 465  :         || (1

  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	0f 85 16 08 00
	00		 jne	 $LN9@z900_trace
  00095	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR code$[rsp], 0
  0009d	0f 84 08 08 00
	00		 je	 $LN9@z900_trace
  000a3	33 c0		 xor	 eax, eax
  000a5	83 f8 01	 cmp	 eax, 1
  000a8	0f 84 02 08 00
	00		 je	 $LN8@z900_trace
  000ae	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR code$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ba	b9 01 00 00 00	 mov	 ecx, 1
  000bf	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv527[rsp], rcx
  000c7	0f b6 c8	 movzx	 ecx, al
  000ca	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv527[rsp]
  000d2	48 d3 e0	 shl	 rax, cl
  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000dc	48 8b 89 48 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4936]
  000e3	48 23 c8	 and	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 85 c0	 test	 rax, rax
  000ec	0f 85 be 07 00
	00		 jne	 $LN8@z900_trace
  000f2	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00100	c1 e8 10	 shr	 eax, 16
  00103	83 e0 01	 and	 eax, 1
  00106	85 c0		 test	 eax, eax
  00108	74 0d		 je	 SHORT $LN39@z900_trace
  0010a	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv132[rsp], 1
  00115	eb 0b		 jmp	 SHORT $LN40@z900_trace
$LN39@z900_trace:
  00117	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN40@z900_trace:
  00122	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv132[rsp], 0
  0012a	0f 84 7b 07 00
	00		 je	 $LN10@z900_trace
  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00137	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0013d	c1 e8 0a	 shr	 eax, 10
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	0f 84 91 03 00
	00		 je	 $LN11@z900_trace
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	0f 85 2d 01 00
	00		 jne	 $LN12@z900_trace
  00155	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00162	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00167	85 c0		 test	 eax, eax
  00169	0f 84 13 01 00
	00		 je	 $LN12@z900_trace
  0016f	33 c0		 xor	 eax, eax
  00171	83 f8 01	 cmp	 eax, 1
  00174	0f 84 62 03 00
	00		 je	 $LN11@z900_trace
  0017a	33 c0		 xor	 eax, eax
  0017c	85 c0		 test	 eax, eax
  0017e	75 37		 jne	 SHORT $LN13@z900_trace
  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00187	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0018d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00192	85 c0		 test	 eax, eax
  00194	74 21		 je	 SHORT $LN13@z900_trace
  00196	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a5	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  001ab	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  001b1	0f 85 25 03 00
	00		 jne	 $LN11@z900_trace
$LN13@z900_trace:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	75 37		 jne	 SHORT $LN14@z900_trace
  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  001ca	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  001cf	85 c0		 test	 eax, eax
  001d1	74 21		 je	 SHORT $LN14@z900_trace
  001d3	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001e2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  001e8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  001ee	0f 8c e8 02 00
	00		 jl	 $LN11@z900_trace
$LN14@z900_trace:
  001f4	33 c0		 xor	 eax, eax
  001f6	85 c0		 test	 eax, eax
  001f8	0f 85 84 00 00
	00		 jne	 $LN15@z900_trace
  001fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00205	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0020b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00210	85 c0		 test	 eax, eax
  00212	74 26		 je	 SHORT $LN16@z900_trace
  00214	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00223	85 c0		 test	 eax, eax
  00225	74 13		 je	 SHORT $LN16@z900_trace
  00227	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00236	85 c0		 test	 eax, eax
  00238	75 48		 jne	 SHORT $LN15@z900_trace
$LN16@z900_trace:
  0023a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00241	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00247	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0024c	85 c0		 test	 eax, eax
  0024e	0f 84 88 02 00
	00		 je	 $LN11@z900_trace
  00254	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00263	85 c0		 test	 eax, eax
  00265	0f 84 71 02 00
	00		 je	 $LN11@z900_trace
  0026b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00273	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0027a	85 c0		 test	 eax, eax
  0027c	0f 85 5a 02 00
	00		 jne	 $LN11@z900_trace
$LN15@z900_trace:
$LN12@z900_trace:
  00282	b8 08 00 00 00	 mov	 eax, 8
  00287	48 6b c0 00	 imul	 rax, rax, 0
  0028b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00292	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0029b	75 1f		 jne	 SHORT $LN17@z900_trace
  0029d	b8 08 00 00 00	 mov	 eax, 8
  002a2	48 6b c0 01	 imul	 rax, rax, 1
  002a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002ad	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  002b6	0f 84 f4 05 00
	00		 je	 $LN8@z900_trace
$LN17@z900_trace:
  002bc	b8 08 00 00 00	 mov	 eax, 8
  002c1	48 6b c0 00	 imul	 rax, rax, 0
  002c5	b9 08 00 00 00	 mov	 ecx, 8
  002ca	48 6b c9 01	 imul	 rcx, rcx, 1
  002ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002d5	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  002dc	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  002e4	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  002ec	0f 87 da 00 00
	00		 ja	 $LN18@z900_trace
  002f2	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fa	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00302	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00309	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0030d	48 2b c1	 sub	 rax, rcx
  00310	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00318	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0031f	48 03 c8	 add	 rcx, rax
  00322	48 8b c1	 mov	 rax, rcx
  00325	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0032c	f7 d9		 neg	 ecx
  0032e	48 63 c9	 movsxd	 rcx, ecx
  00331	48 03 c1	 add	 rax, rcx
  00334	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00343	b9 08 00 00 00	 mov	 ecx, 8
  00348	48 6b c9 00	 imul	 rcx, rcx, 0
  0034c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00353	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0035b	72 6f		 jb	 SHORT $LN18@z900_trace
  0035d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00365	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036d	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00374	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00378	48 2b c1	 sub	 rax, rcx
  0037b	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0038a	48 03 c8	 add	 rcx, rax
  0038d	48 8b c1	 mov	 rax, rcx
  00390	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00397	f7 d9		 neg	 ecx
  00399	48 63 c9	 movsxd	 rcx, ecx
  0039c	48 03 c1	 add	 rax, rcx
  0039f	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003ae	b9 08 00 00 00	 mov	 ecx, 8
  003b3	48 6b c9 01	 imul	 rcx, rcx, 1
  003b7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003be	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  003c6	0f 86 e4 04 00
	00		 jbe	 $LN8@z900_trace
$LN18@z900_trace:
  003cc	b8 08 00 00 00	 mov	 eax, 8
  003d1	48 6b c0 00	 imul	 rax, rax, 0
  003d5	b9 08 00 00 00	 mov	 ecx, 8
  003da	48 6b c9 01	 imul	 rcx, rcx, 1
  003de	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003e5	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  003ec	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  003f4	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  003fc	0f 86 da 00 00
	00		 jbe	 $LN19@z900_trace
  00402	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00412	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00419	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0041d	48 2b c1	 sub	 rax, rcx
  00420	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00428	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0042f	48 03 c8	 add	 rcx, rax
  00432	48 8b c1	 mov	 rax, rcx
  00435	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0043c	f7 d9		 neg	 ecx
  0043e	48 63 c9	 movsxd	 rcx, ecx
  00441	48 03 c1	 add	 rax, rcx
  00444	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00453	b9 08 00 00 00	 mov	 ecx, 8
  00458	48 6b c9 01	 imul	 rcx, rcx, 1
  0045c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00463	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0046b	72 6f		 jb	 SHORT $LN19@z900_trace
  0046d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00475	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047d	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00484	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00488	48 2b c1	 sub	 rax, rcx
  0048b	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00493	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0049a	48 03 c8	 add	 rcx, rax
  0049d	48 8b c1	 mov	 rax, rcx
  004a0	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  004a7	f7 d9		 neg	 ecx
  004a9	48 63 c9	 movsxd	 rcx, ecx
  004ac	48 03 c1	 add	 rax, rcx
  004af	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004be	b9 08 00 00 00	 mov	 ecx, 8
  004c3	48 6b c9 00	 imul	 rcx, rcx, 0
  004c7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004ce	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  004d6	0f 86 d4 03 00
	00		 jbe	 $LN8@z900_trace
$LN19@z900_trace:
$LN11@z900_trace:
  004dc	33 c0		 xor	 eax, eax
  004de	83 f8 01	 cmp	 eax, 1
  004e1	0f 84 c4 03 00
	00		 je	 $LN20@z900_trace
  004e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ee	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  004f4	c1 e8 08	 shr	 eax, 8
  004f7	83 e0 01	 and	 eax, 1
  004fa	85 c0		 test	 eax, eax
  004fc	0f 84 a9 03 00
	00		 je	 $LN20@z900_trace
  00502	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00510	c1 e8 0f	 shr	 eax, 15
  00513	83 e0 01	 and	 eax, 1
  00516	85 c0		 test	 eax, eax
  00518	0f 84 8d 03 00
	00		 je	 $LN20@z900_trace
  0051e	33 c0		 xor	 eax, eax
  00520	85 c0		 test	 eax, eax
  00522	0f 85 2d 01 00
	00		 jne	 $LN21@z900_trace
  00528	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0052f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00535	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0053a	85 c0		 test	 eax, eax
  0053c	0f 84 13 01 00
	00		 je	 $LN21@z900_trace
  00542	33 c0		 xor	 eax, eax
  00544	83 f8 01	 cmp	 eax, 1
  00547	0f 84 5e 03 00
	00		 je	 $LN20@z900_trace
  0054d	33 c0		 xor	 eax, eax
  0054f	85 c0		 test	 eax, eax
  00551	75 37		 jne	 SHORT $LN22@z900_trace
  00553	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0055a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00560	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00565	85 c0		 test	 eax, eax
  00567	74 21		 je	 SHORT $LN22@z900_trace
  00569	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00578	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0057e	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00584	0f 85 21 03 00
	00		 jne	 $LN20@z900_trace
$LN22@z900_trace:
  0058a	33 c0		 xor	 eax, eax
  0058c	85 c0		 test	 eax, eax
  0058e	75 37		 jne	 SHORT $LN23@z900_trace
  00590	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00597	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0059d	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  005a2	85 c0		 test	 eax, eax
  005a4	74 21		 je	 SHORT $LN23@z900_trace
  005a6	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005b5	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  005bb	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  005c1	0f 8c e4 02 00
	00		 jl	 $LN20@z900_trace
$LN23@z900_trace:
  005c7	33 c0		 xor	 eax, eax
  005c9	85 c0		 test	 eax, eax
  005cb	0f 85 84 00 00
	00		 jne	 $LN24@z900_trace
  005d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005d8	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005de	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005e3	85 c0		 test	 eax, eax
  005e5	74 26		 je	 SHORT $LN25@z900_trace
  005e7	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ef	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  005f6	85 c0		 test	 eax, eax
  005f8	74 13		 je	 SHORT $LN25@z900_trace
  005fa	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00602	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00609	85 c0		 test	 eax, eax
  0060b	75 48		 jne	 SHORT $LN24@z900_trace
$LN25@z900_trace:
  0060d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00614	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0061a	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0061f	85 c0		 test	 eax, eax
  00621	0f 84 84 02 00
	00		 je	 $LN20@z900_trace
  00627	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00636	85 c0		 test	 eax, eax
  00638	0f 84 6d 02 00
	00		 je	 $LN20@z900_trace
  0063e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00646	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0064d	85 c0		 test	 eax, eax
  0064f	0f 85 56 02 00
	00		 jne	 $LN20@z900_trace
$LN24@z900_trace:
$LN21@z900_trace:
  00655	b8 08 00 00 00	 mov	 eax, 8
  0065a	48 6b c0 00	 imul	 rax, rax, 0
  0065e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00665	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0066e	75 1f		 jne	 SHORT $LN26@z900_trace
  00670	b8 08 00 00 00	 mov	 eax, 8
  00675	48 6b c0 01	 imul	 rax, rax, 1
  00679	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00680	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00689	0f 84 21 02 00
	00		 je	 $LN8@z900_trace
$LN26@z900_trace:
  0068f	b8 08 00 00 00	 mov	 eax, 8
  00694	48 6b c0 00	 imul	 rax, rax, 0
  00698	b9 08 00 00 00	 mov	 ecx, 8
  0069d	48 6b c9 01	 imul	 rcx, rcx, 1
  006a1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006a8	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  006af	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  006b7	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  006bf	0f 87 da 00 00
	00		 ja	 $LN27@z900_trace
  006c5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006cd	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006d5	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  006dc	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  006e0	48 2b c1	 sub	 rax, rcx
  006e3	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006eb	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  006f2	48 03 c8	 add	 rcx, rax
  006f5	48 8b c1	 mov	 rax, rcx
  006f8	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  006ff	f7 d9		 neg	 ecx
  00701	48 63 c9	 movsxd	 rcx, ecx
  00704	48 03 c1	 add	 rax, rcx
  00707	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0070f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00716	b9 08 00 00 00	 mov	 ecx, 8
  0071b	48 6b c9 00	 imul	 rcx, rcx, 0
  0071f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00726	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0072e	72 6f		 jb	 SHORT $LN27@z900_trace
  00730	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00738	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00740	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00747	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0074b	48 2b c1	 sub	 rax, rcx
  0074e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00756	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0075d	48 03 c8	 add	 rcx, rax
  00760	48 8b c1	 mov	 rax, rcx
  00763	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0076a	f7 d9		 neg	 ecx
  0076c	48 63 c9	 movsxd	 rcx, ecx
  0076f	48 03 c1	 add	 rax, rcx
  00772	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00781	b9 08 00 00 00	 mov	 ecx, 8
  00786	48 6b c9 01	 imul	 rcx, rcx, 1
  0078a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00791	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00799	0f 86 11 01 00
	00		 jbe	 $LN8@z900_trace
$LN27@z900_trace:
  0079f	b8 08 00 00 00	 mov	 eax, 8
  007a4	48 6b c0 00	 imul	 rax, rax, 0
  007a8	b9 08 00 00 00	 mov	 ecx, 8
  007ad	48 6b c9 01	 imul	 rcx, rcx, 1
  007b1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007b8	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  007bf	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  007c7	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  007cf	0f 86 d6 00 00
	00		 jbe	 $LN28@z900_trace
  007d5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dd	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007e5	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  007ec	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  007f0	48 2b c1	 sub	 rax, rcx
  007f3	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007fb	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00802	48 03 c8	 add	 rcx, rax
  00805	48 8b c1	 mov	 rax, rcx
  00808	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0080f	f7 d9		 neg	 ecx
  00811	48 63 c9	 movsxd	 rcx, ecx
  00814	48 03 c1	 add	 rax, rcx
  00817	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0081f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00826	b9 08 00 00 00	 mov	 ecx, 8
  0082b	48 6b c9 01	 imul	 rcx, rcx, 1
  0082f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00836	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0083e	72 6b		 jb	 SHORT $LN28@z900_trace
  00840	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00848	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00850	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00857	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0085b	48 2b c1	 sub	 rax, rcx
  0085e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00866	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0086d	48 03 c8	 add	 rcx, rax
  00870	48 8b c1	 mov	 rax, rcx
  00873	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0087a	f7 d9		 neg	 ecx
  0087c	48 63 c9	 movsxd	 rcx, ecx
  0087f	48 03 c1	 add	 rax, rcx
  00882	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00891	b9 08 00 00 00	 mov	 ecx, 8
  00896	48 6b c9 00	 imul	 rcx, rcx, 0
  0089a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008a1	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  008a9	76 05		 jbe	 SHORT $LN8@z900_trace
$LN28@z900_trace:
$LN20@z900_trace:
$LN10@z900_trace:
$LN9@z900_trace:

; 466  :             && !(sysblk.pgminttr & ((U64) 1 << ((code - 1) & 0x3F)))
; 467  :             && !CPU_STEPPING_OR_TRACING( regs, ilc )
; 468  :            )
; 469  :     )
; 470  :     {
; 471  :         return;     // (nothing to do; quick exit)

  008ab	e9 e3 03 00 00	 jmp	 $LN1@z900_trace
$LN8@z900_trace:
$LN4@z900_trace:

; 472  :     }
; 473  : 
; 474  :     /*
; 475  :        First things first: backup the 'ip' by the 'ilc' value to point
; 476  :        to the actual instruction that actually program checked.
; 477  : 
; 478  :        If 'instinvalid' is set it means an instruction fetch error
; 479  :        occurred so we shouldn't rely on the value of regs->ip.
; 480  : 
; 481  :        Otherwise if the instruction that program checked (i.e. after
; 482  :        backing up 'ip' by 'ilc' amount) appears to be in the previous
; 483  :        mainstor page (meaning the instruction itself crossed a page
; 484  :        boundary), use the the copy of the instruction that was saved
; 485  :        in regs->inst for our instruction pointer instead.
; 486  : 
; 487  :        If neither condition is true (the most common case) then we
; 488  :        simply use current regs->ip value backed up by the ilc amount.
; 489  :     */
; 490  :     PTT_PGM( "tr PGM int", regs->ip, regs->aip, ilc );

  008b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008ba	48 83 e0 20	 and	 rax, 32			; 00000020H
  008be	48 85 c0	 test	 rax, rax
  008c1	74 4f		 je	 SHORT $LN29@z900_trace
  008c3	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  008cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  008d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195610
  008e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ed	4c 8b 88 00 02
	00 00		 mov	 r9, QWORD PTR [rax+512]
  008f4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fc	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00900	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195611
  00907	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0090c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@z900_trace:
  00912	33 c0		 xor	 eax, eax
  00914	85 c0		 test	 eax, eax
  00916	75 98		 jne	 SHORT $LN4@z900_trace

; 491  :     ip =

  00918	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00920	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00926	c1 e8 03	 shr	 eax, 3
  00929	83 e0 01	 and	 eax, 1
  0092c	85 c0		 test	 eax, eax
  0092e	74 0e		 je	 SHORT $LN43@z900_trace
  00930	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv406[rsp], 0
  0093c	eb 75		 jmp	 SHORT $LN44@z900_trace
$LN43@z900_trace:
  0093e	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00946	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0094e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00952	48 2b c8	 sub	 rcx, rax
  00955	48 8b c1	 mov	 rax, rcx
  00958	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00960	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  00967	73 18		 jae	 SHORT $LN41@z900_trace
  00969	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00971	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  00977	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
  0097f	eb 22		 jmp	 SHORT $LN42@z900_trace
$LN41@z900_trace:
  00981	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00989	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00991	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00995	48 2b c8	 sub	 rcx, rax
  00998	48 8b c1	 mov	 rax, rcx
  0099b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
$LN42@z900_trace:
  009a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv404[rsp]
  009ab	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv406[rsp], rax
$LN44@z900_trace:
  009b3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv406[rsp]
  009bb	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ip$[rsp], rax
$LN7@z900_trace:

; 492  :     (
; 493  :         /* Instruction fetch error? (least likely) */
; 494  :         regs->instinvalid ? NULL
; 495  : 
; 496  :         /* Instruction crossed page boundary? (unlikely) */
; 497  :         : ((regs->ip - ilc) < regs->aip) ? regs->inst
; 498  : 
; 499  :         /* Instruction still on same page (most likely) */
; 500  :         :  (regs->ip - ilc)
; 501  :     );
; 502  :     PTT_PGM( "tr PGM int", ip, regs->aip, ilc );

  009c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  009ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009cd	48 83 e0 20	 and	 rax, 32			; 00000020H
  009d1	48 85 c0	 test	 rax, rax
  009d4	74 4b		 je	 SHORT $LN30@z900_trace
  009d6	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  009de	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  009e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  009ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195613
  009f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009f8	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a00	4c 8b 88 00 02
	00 00		 mov	 r9, QWORD PTR [rax+512]
  00a07	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR ip$[rsp]
  00a0f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195614
  00a16	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00a1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@z900_trace:
  00a21	33 c0		 xor	 eax, eax
  00a23	85 c0		 test	 eax, eax
  00a25	75 9c		 jne	 SHORT $LN7@z900_trace

; 503  : 
; 504  : #if defined( OPTION_FOOTPRINT_BUFFER )
; 505  :     if (!(sysblk.insttrace || sysblk.instbreak))
; 506  :     {
; 507  :         U32  n;
; 508  :         for (n = sysblk.footprptr[ regs->cpuad ] + 1;
; 509  :             n != sysblk.footprptr[ regs->cpuad ];
; 510  :             n++, n &= OPTION_FOOTPRINT_BUFFER - 1
; 511  :         )
; 512  :         {
; 513  :             ARCH_DEP( display_inst )(
; 514  :                 &sysblk.footprregs[ regs->cpuad ][n],
; 515  :                  sysblk.footprregs[ regs->cpuad ][n].inst );
; 516  :         }
; 517  :     }
; 518  : #endif
; 519  : 
; 520  :     /* Suppress LRA Special Operation Exception tracing if requested */
; 521  :     if (1
; 522  :         && code == PGM_SPECIAL_OPERATION_EXCEPTION
; 523  :         && ip && ip[0] == 0xB1    // LRA
; 524  :         && sysblk.nolrasoe        // suppression enabled

  00a27	33 c0		 xor	 eax, eax
  00a29	83 f8 01	 cmp	 eax, 1
  00a2c	74 4d		 je	 SHORT $LN31@z900_trace
  00a2e	83 bc 24 80 00
	00 00 13	 cmp	 DWORD PTR code$[rsp], 19
  00a36	75 43		 jne	 SHORT $LN31@z900_trace
  00a38	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR ip$[rsp], 0
  00a41	74 38		 je	 SHORT $LN31@z900_trace
  00a43	b8 01 00 00 00	 mov	 eax, 1
  00a48	48 6b c0 00	 imul	 rax, rax, 0
  00a4c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  00a54	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a58	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  00a5d	75 1c		 jne	 SHORT $LN31@z900_trace
  00a5f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a66	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00a6c	c1 e8 18	 shr	 eax, 24
  00a6f	83 e0 01	 and	 eax, 1
  00a72	85 c0		 test	 eax, eax
  00a74	74 05		 je	 SHORT $LN31@z900_trace

; 525  :     )
; 526  :     {
; 527  :         return;     // (nothing to do; quick exit)

  00a76	e9 18 02 00 00	 jmp	 $LN1@z900_trace
$LN31@z900_trace:

; 528  :     }
; 529  : 
; 530  :     /* Trace this program interrupt... */
; 531  : 
; 532  : #if defined( _FEATURE_SIE )
; 533  :     if (SIE_MODE( regs ))

  00a7b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a83	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a89	d1 e8		 shr	 eax, 1
  00a8b	83 e0 01	 and	 eax, 1
  00a8e	85 c0		 test	 eax, eax
  00a90	74 1b		 je	 SHORT $LN32@z900_trace

; 534  :       STRLCPY( sie_mode_str, "SIE: " );

  00a92	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00a98	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195617
  00a9f	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR sie_mode_str$[rsp]
  00aa7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN32@z900_trace:

; 535  : #endif
; 536  : 
; 537  : #if defined( SIE_DEBUG )
; 538  :     STRLCPY( sie_debug_arch, QSTR( _GEN_ARCH ));
; 539  :     STRLCAT( sie_debug_arch, " " );
; 540  : #endif
; 541  : 
; 542  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 543  :     if (1
; 544  :         && pcode & PGM_TXF_EVENT
; 545  :         && regs->txf_why

  00aad	33 c0		 xor	 eax, eax
  00aaf	83 f8 01	 cmp	 eax, 1
  00ab2	74 42		 je	 SHORT $LN33@z900_trace
  00ab4	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  00abb	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00ac0	85 c0		 test	 eax, eax
  00ac2	74 32		 je	 SHORT $LN33@z900_trace
  00ac4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00acc	83 b8 84 af 00
	00 00		 cmp	 DWORD PTR [rax+44932], 0
  00ad3	74 21		 je	 SHORT $LN33@z900_trace

; 546  :     )
; 547  :         txf_why_str( txf_why, sizeof( txf_why ), regs->txf_why );

  00ad5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00add	44 8b 80 84 af
	00 00		 mov	 r8d, DWORD PTR [rax+44932]
  00ae4	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00ae9	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txf_why$[rsp]
  00af1	e8 00 00 00 00	 call	 txf_why_str
$LN33@z900_trace:

; 548  : #endif
; 549  : 
; 550  :     if (code == PGM_DATA_EXCEPTION)

  00af6	83 bc 24 80 00
	00 00 07	 cmp	 DWORD PTR code$[rsp], 7
  00afe	75 29		 jne	 SHORT $LN34@z900_trace

; 551  :        MSGBUF( dxcstr, " DXC=%2.2X", regs->dxc );

  00b00	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b08	44 8b 88 08 07
	00 00		 mov	 r9d, DWORD PTR [rax+1800]
  00b0f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195620
  00b16	ba 08 00 00 00	 mov	 edx, 8
  00b1b	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dxcstr$[rsp]
  00b23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN34@z900_trace:

; 552  : 
; 553  :     if (regs->insttrace && sysblk.traceFILE)

  00b29	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b31	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b37	c1 e8 0f	 shr	 eax, 15
  00b3a	83 e0 01	 and	 eax, 1
  00b3d	85 c0		 test	 eax, eax
  00b3f	74 30		 je	 SHORT $LN35@z900_trace
  00b41	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b48	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b50	74 1f		 je	 SHORT $LN35@z900_trace

; 554  :         tf_0801( regs, pcode, ilc );

  00b52	44 0f b6 84 24
	30 02 00 00	 movzx	 r8d, BYTE PTR ilc$[rsp]
  00b5b	0f b7 94 24 28
	02 00 00	 movzx	 edx, WORD PTR pcode$[rsp]
  00b63	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0801
$LN35@z900_trace:

; 555  : 
; 556  :     // "Processor %s%02X: %s%s %s interruption code %4.4X ilc %d%s%s"
; 557  :     WRMSG( HHC00801, "I",

  00b71	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR code$[rsp]
  00b78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00b7e	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv465[rsp], rax
  00b86	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b8e	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00b95	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv471[rsp], ecx
  00b9c	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ba4	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00bab	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00bb2	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  00bba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00bc0	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv473[rsp], rax
  00bc8	b9 01 00 00 00	 mov	 ecx, 1
  00bcd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bd3	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txf_why$[rsp]
  00bdb	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  00be0	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dxcstr$[rsp]
  00be8	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00bed	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00bf4	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00bf8	8b 8c 24 28 02
	00 00		 mov	 ecx, DWORD PTR pcode$[rsp]
  00bff	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00c03	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv465[rsp]
  00c0b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00c10	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR sie_debug_arch$[rsp]
  00c18	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00c1d	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR sie_mode_str$[rsp]
  00c25	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c2a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv471[rsp]
  00c31	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c35	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv473[rsp]
  00c3d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195622
  00c49	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195623
  00c55	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c5a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c5f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c65	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195624
  00c6c	ba 31 02 00 00	 mov	 edx, 561		; 00000231H
  00c71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195625
  00c78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 558  :         PTYPSTR( regs->cpuad ), regs->cpuad,
; 559  :         sie_mode_str, sie_debug_arch,
; 560  :         PIC2Name( code ), pcode,
; 561  :         ilc, dxcstr, txf_why );
; 562  : 
; 563  :     // HHC02324 "PSW=... INST=...  OPCODE  operands   name"
; 564  :     ARCH_DEP( display_pgmint_inst )( regs, ip );

  00c7e	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR ip$[rsp]
  00c86	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c8e	e8 00 00 00 00	 call	 z900_display_pgmint_inst
$LN1@z900_trace:

; 565  : 
; 566  : } /* end function ARCH_DEP( trace_program_interrupt ) */

  00c93	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c9b	48 33 cc	 xor	 rcx, rsp
  00c9e	e8 00 00 00 00	 call	 __security_check_cookie
  00ca3	48 81 c4 10 02
	00 00		 add	 rsp, 528		; 00000210H
  00caa	5f		 pop	 rdi
  00cab	c3		 ret	 0
z900_trace_program_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
ilc$ = 64
tv70 = 68
tv77 = 72
tv84 = 76
tv86 = 80
tv88 = 84
tv142 = 88
tv147 = 92
tv149 = 96
regs$ = 128
z900_fix_program_interrupt_PSW PROC

; 572  : {

$LN38:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 573  :     /* Determine the instruction length code (ilc).
; 574  : 
; 575  :        The 'zeroilc' flag is set when the Instruction Length Code
; 576  :        should be reported as zero (such as when instruction-fetching
; 577  :        nullification PER option is set in CR9 or when the load PSW
; 578  :        instruction results in an invalid PSW being loaded).
; 579  : 
; 580  :        The PSW 'ilc' value can also be specifically set to '0' when
; 581  :        a BALR, BASR or BASSM program checks during 'trace_br' call.
; 582  :     */
; 583  :     int ilc =

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00011	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00017	c1 e8 02	 shr	 eax, 2
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	74 0d		 je	 SHORT $LN30@z900_fix_p
  00021	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
  00029	e9 95 00 00 00	 jmp	 $LN31@z900_fix_p
$LN30@z900_fix_p:
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	75 0a		 jne	 SHORT $LN20@z900_fix_p
  00043	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0004b	eb 08		 jmp	 SHORT $LN21@z900_fix_p
$LN20@z900_fix_p:
  0004d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN21@z900_fix_p:
  00055	83 7c 24 44 00	 cmp	 DWORD PTR tv70[rsp], 0
  0005a	74 0a		 je	 SHORT $LN24@z900_fix_p
  0005c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  00064	eb 08		 jmp	 SHORT $LN25@z900_fix_p
$LN24@z900_fix_p:
  00066	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN25@z900_fix_p:
  0006e	83 7c 24 48 00	 cmp	 DWORD PTR tv77[rsp], 0
  00073	74 15		 je	 SHORT $LN28@z900_fix_p
  00075	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00084	89 44 24 50	 mov	 DWORD PTR tv86[rsp], eax
  00088	eb 31		 jmp	 SHORT $LN29@z900_fix_p
$LN28@z900_fix_p:
  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00092	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00098	d1 e8		 shr	 eax, 1
  0009a	83 e0 01	 and	 eax, 1
  0009d	85 c0		 test	 eax, eax
  0009f	74 0a		 je	 SHORT $LN26@z900_fix_p
  000a1	c7 44 24 4c 06
	00 00 00	 mov	 DWORD PTR tv84[rsp], 6
  000a9	eb 08		 jmp	 SHORT $LN27@z900_fix_p
$LN26@z900_fix_p:
  000ab	c7 44 24 4c 04
	00 00 00	 mov	 DWORD PTR tv84[rsp], 4
$LN27@z900_fix_p:
  000b3	8b 44 24 4c	 mov	 eax, DWORD PTR tv84[rsp]
  000b7	89 44 24 50	 mov	 DWORD PTR tv86[rsp], eax
$LN29@z900_fix_p:
  000bb	8b 44 24 50	 mov	 eax, DWORD PTR tv86[rsp]
  000bf	89 44 24 54	 mov	 DWORD PTR tv88[rsp], eax
$LN31@z900_fix_p:
  000c3	8b 44 24 54	 mov	 eax, DWORD PTR tv88[rsp]
  000c7	89 44 24 40	 mov	 DWORD PTR ilc$[rsp], eax
$LN4@z900_fix_p:

; 584  :     (
; 585  :         /* If zeroilc flag is set, then we MUST use zero for the ilc */
; 586  :         regs->psw.zeroilc ? 0
; 587  : 
; 588  :         /* Otherwise use either the ilc value set in the PSW or the
; 589  :            length of the EX/EXRL instruction is the instruction is
; 590  :            being executed.
; 591  :         */
; 592  :         : REAL_ILC( regs )
; 593  :     );
; 594  :     PTT_PGM( "fxpiPSW ilc", 0, 0, ilc );

  000cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 83 e0 20	 and	 rax, 32			; 00000020H
  000d9	48 85 c0	 test	 rax, rax
  000dc	74 37		 je	 SHORT $LN14@z900_fix_p
  000de	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  000e3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195667
  000f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fd	45 33 c9	 xor	 r9d, r9d
  00100	45 33 c0	 xor	 r8d, r8d
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195668
  0010a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@z900_fix_p:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	75 b0		 jne	 SHORT $LN4@z900_fix_p

; 595  : 
; 596  :     /* If our resulting ilc is still 0 but the zeroilc flag is NOT set,
; 597  :        then we're left with no choice but to GUESS the 'ilc' value
; 598  :        based on whether the instruction was being executed or not.
; 599  :     */
; 600  :     if (regs->psw.ilc == 0 && !regs->psw.zeroilc)

  0011b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00123	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  0012a	85 c0		 test	 eax, eax
  0012c	0f 85 aa 01 00
	00		 jne	 $LN15@z900_fix_p
  00132	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00140	c1 e8 02	 shr	 eax, 2
  00143	83 e0 01	 and	 eax, 1
  00146	85 c0		 test	 eax, eax
  00148	0f 85 8e 01 00
	00		 jne	 $LN15@z900_fix_p

; 601  :     {
; 602  :         ilc = (!regs->execflag ? 2 : (regs->exrl ? 6 : 4));

  0014e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00156	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0015c	83 e0 01	 and	 eax, 1
  0015f	85 c0		 test	 eax, eax
  00161	75 0a		 jne	 SHORT $LN32@z900_fix_p
  00163	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  0016b	eb 08		 jmp	 SHORT $LN33@z900_fix_p
$LN32@z900_fix_p:
  0016d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN33@z900_fix_p:
  00175	83 7c 24 58 00	 cmp	 DWORD PTR tv142[rsp], 0
  0017a	74 0a		 je	 SHORT $LN36@z900_fix_p
  0017c	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv149[rsp], 2
  00184	eb 31		 jmp	 SHORT $LN37@z900_fix_p
$LN36@z900_fix_p:
  00186	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00194	d1 e8		 shr	 eax, 1
  00196	83 e0 01	 and	 eax, 1
  00199	85 c0		 test	 eax, eax
  0019b	74 0a		 je	 SHORT $LN34@z900_fix_p
  0019d	c7 44 24 5c 06
	00 00 00	 mov	 DWORD PTR tv147[rsp], 6
  001a5	eb 08		 jmp	 SHORT $LN35@z900_fix_p
$LN34@z900_fix_p:
  001a7	c7 44 24 5c 04
	00 00 00	 mov	 DWORD PTR tv147[rsp], 4
$LN35@z900_fix_p:
  001af	8b 44 24 5c	 mov	 eax, DWORD PTR tv147[rsp]
  001b3	89 44 24 60	 mov	 DWORD PTR tv149[rsp], eax
$LN37@z900_fix_p:
  001b7	8b 44 24 60	 mov	 eax, DWORD PTR tv149[rsp]
  001bb	89 44 24 40	 mov	 DWORD PTR ilc$[rsp], eax
$LN7@z900_fix_p:

; 603  : 
; 604  :         PTT_PGM( "fxpiPSW ilc", regs->ip, regs->psw.IA, ilc );

  001bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c9	48 83 e0 20	 and	 rax, 32			; 00000020H
  001cd	48 85 c0	 test	 rax, rax
  001d0	74 4c		 je	 SHORT $LN16@z900_fix_p
  001d2	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  001d7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001e0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195671
  001ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f9	4c 8b 88 88 00
	00 00		 mov	 r9, QWORD PTR [rax+136]
  00200	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00208	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195672
  00213	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@z900_fix_p:
  0021e	33 c0		 xor	 eax, eax
  00220	85 c0		 test	 eax, eax
  00222	75 9b		 jne	 SHORT $LN7@z900_fix_p

; 605  : 
; 606  :         /* Now ADVANCE the 'ip' mainstor instruction pointer and
; 607  :            psw 'IA' instruction address by that ilc amount so that
; 608  :            the 'trace_program_interrupt' can then back them both up
; 609  :            by the same amount to point to the actual instruction
; 610  :            that actually program checked.
; 611  :         */
; 612  :         regs->psw.ilc  = ilc;  // (guessed value)

  00224	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022c	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ilc$[rsp]
  00231	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl

; 613  :         regs->ip      += ilc;  // (so trace_program_interrupt can undo)

  00237	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0023c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00248	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 614  :         regs->psw.IA  += ilc;  // (so trace_program_interrupt can undo)

  00254	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00259	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00261	48 03 81 88 00
	00 00		 add	 rax, QWORD PTR [rcx+136]
  00268	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN10@z900_fix_p:

; 615  : 
; 616  :         PTT_PGM( "fxpiPSW ilc", regs->ip, regs->psw.IA, ilc );

  00277	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0027e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00281	48 83 e0 20	 and	 rax, 32			; 00000020H
  00285	48 85 c0	 test	 rax, rax
  00288	74 4c		 je	 SHORT $LN17@z900_fix_p
  0028a	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0028f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00298	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0029d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195674
  002a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b1	4c 8b 88 88 00
	00 00		 mov	 r9, QWORD PTR [rax+136]
  002b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c0	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  002c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195675
  002cb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN17@z900_fix_p:
  002d6	33 c0		 xor	 eax, eax
  002d8	85 c0		 test	 eax, eax
  002da	75 9b		 jne	 SHORT $LN10@z900_fix_p
$LN15@z900_fix_p:
$LN13@z900_fix_p:

; 617  :     }
; 618  : 
; 619  :     /* Return ilc value to be passed to 'trace_program_interrupt' */
; 620  : 
; 621  :     PTT_PGM( "fxpiPSW ret", 0, 0, ilc );

  002dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002e3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e6	48 83 e0 20	 and	 rax, 32			; 00000020H
  002ea	48 85 c0	 test	 rax, rax
  002ed	74 37		 je	 SHORT $LN18@z900_fix_p
  002ef	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  002f4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002fd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00302	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195677
  00309	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030e	45 33 c9	 xor	 r9d, r9d
  00311	45 33 c0	 xor	 r8d, r8d
  00314	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195678
  0031b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00320	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@z900_fix_p:
  00326	33 c0		 xor	 eax, eax
  00328	85 c0		 test	 eax, eax
  0032a	75 b0		 jne	 SHORT $LN13@z900_fix_p

; 622  :     return ilc;

  0032c	8b 44 24 40	 mov	 eax, DWORD PTR ilc$[rsp]

; 623  : }

  00330	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00334	c3		 ret	 0
z900_fix_program_interrupt_PSW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv193 = 64
tv213 = 68
tv269 = 72
tv268 = 76
tv270 = 80
regs$ = 112
offset$ = 120
z900_SuccessfulRelativeBranch PROC

; 400  : {

$LN43:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 401  :     /* Set BEAR to branch instruction. Note: for branch instructions
; 402  :        regs->ip is not updated to point to the next instruction and
; 403  :        thus is still pointing to the branch instruction itself.
; 404  :     */
; 405  :     SET_BEAR_REG( regs, regs->ip );

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 18 02 00
	00		 add	 rax, 536		; 00000218H
  00019	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0001e	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00022	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00027	48 8b c8	 mov	 rcx, rax
  0002a	e8 00 00 00 00	 call	 z900_Set_BEAR_Reg

; 406  : 
; 407  :     /* Branch target still within same page as branch instruction? */
; 408  :     if (1
; 409  :         && !regs->permode
; 410  :         && !regs->execflag
; 411  :         &&  offset > -4096
; 412  :         &&  offset < +4096
; 413  :         && (regs->ip + offset) >= regs->aip
; 414  :         && (regs->ip + offset) <  regs->aie

  0002f	33 c0		 xor	 eax, eax
  00031	83 f8 01	 cmp	 eax, 1
  00034	0f 84 04 01 00
	00		 je	 $LN17@z900_Succe
  0003a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00045	c1 e8 02	 shr	 eax, 2
  00048	83 e0 01	 and	 eax, 1
  0004b	85 c0		 test	 eax, eax
  0004d	0f 85 eb 00 00
	00		 jne	 $LN17@z900_Succe
  00053	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00058	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0005e	83 e0 01	 and	 eax, 1
  00061	85 c0		 test	 eax, eax
  00063	0f 85 d5 00 00
	00		 jne	 $LN17@z900_Succe
  00069	48 81 7c 24 78
	00 f0 ff ff	 cmp	 QWORD PTR offset$[rsp], -4096 ; fffffffffffff000H
  00072	0f 8e c6 00 00
	00		 jle	 $LN17@z900_Succe
  00078	48 81 7c 24 78
	00 10 00 00	 cmp	 QWORD PTR offset$[rsp], 4096 ; 00001000H
  00081	0f 8d b7 00 00
	00		 jge	 $LN17@z900_Succe
  00087	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0008c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00090	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  00095	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  000a1	0f 82 97 00 00
	00		 jb	 $LN17@z900_Succe
  000a7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b0	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  000b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ba	48 3b 81 08 02
	00 00		 cmp	 rax, QWORD PTR [rcx+520]
  000c1	73 7b		 jae	 SHORT $LN17@z900_Succe

; 415  :     )
; 416  :     {
; 417  :         /* Branch directly to the new instruction */
; 418  :         regs->ip = regs->ip + offset;

  000c3	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000c8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000cc	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  000d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000d6	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN4@z900_Succe:

; 419  :         PTT_INF( "rbranch <", regs->ip, offset, regs->aip );

  000da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e4	48 83 e0 08	 and	 rax, 8
  000e8	48 85 c0	 test	 rax, rax
  000eb	74 46		 je	 SHORT $LN18@z900_Succe
  000ed	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000f6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000fb	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  00102	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00107	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195519
  0010e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00113	4c 8b 4c 24 78	 mov	 r9, QWORD PTR offset$[rsp]
  00118	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195520
  00128	b9 08 00 00 00	 mov	 ecx, 8
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@z900_Succe:
  00133	33 c0		 xor	 eax, eax
  00135	85 c0		 test	 eax, eax
  00137	75 a1		 jne	 SHORT $LN4@z900_Succe

; 420  :         return;

  00139	e9 8d 03 00 00	 jmp	 $LN1@z900_Succe
$LN17@z900_Succe:
$LN7@z900_Succe:

; 421  :     }
; 422  : 
; 423  :     /* Branch target is in another page: point the PSW to the target
; 424  :        instruction and force a new "regs->ip" value to get set by
; 425  :        forcing a full instruction fetch from the new target address.
; 426  :     */
; 427  :     PTT_INF( "rbranch >", regs->psw.IA, offset, regs->execflag );

  0013e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00145	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00148	48 83 e0 08	 and	 rax, 8
  0014c	48 85 c0	 test	 rax, rax
  0014f	74 4d		 je	 SHORT $LN19@z900_Succe
  00151	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00156	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0015c	83 e0 01	 and	 eax, 1
  0015f	8b c0		 mov	 eax, eax
  00161	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0016a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0016f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195522
  00176	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0017b	4c 8b 4c 24 78	 mov	 r9, QWORD PTR offset$[rsp]
  00180	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00185	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  0018c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195523
  00193	b9 08 00 00 00	 mov	 ecx, 8
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@z900_Succe:
  0019e	33 c0		 xor	 eax, eax
  001a0	85 c0		 test	 eax, eax
  001a2	75 9a		 jne	 SHORT $LN7@z900_Succe

; 428  : 
; 429  :     /* Point PSW to target instruction */
; 430  :     if (!regs->execflag)

  001a4	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001a9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001af	83 e0 01	 and	 eax, 1
  001b2	85 c0		 test	 eax, eax
  001b4	75 49		 jne	 SHORT $LN20@z900_Succe

; 431  :         regs->psw.IA = PSW_IA_FROM_IP( regs, offset );

  001b6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001c0	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  001c7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001cb	48 2b c1	 sub	 rax, rcx
  001ce	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001d3	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  001da	48 03 c8	 add	 rcx, rax
  001dd	48 8b c1	 mov	 rax, rcx
  001e0	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  001e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001ea	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001f1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  001fd	eb 44		 jmp	 SHORT $LN21@z900_Succe
$LN20@z900_Succe:

; 432  :     else
; 433  :     {
; 434  :         regs->psw.IA = regs->ET + offset;

  001ff	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00204	48 8b 80 20 07
	00 00		 mov	 rax, QWORD PTR [rax+1824]
  0020b	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  00210	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00215	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 435  :         regs->psw.IA &= ADDRESS_MAXWRAP( regs );

  0021c	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00221	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00226	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  0022d	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00234	48 23 c1	 and	 rax, rcx
  00237	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0023c	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN21@z900_Succe:

; 436  :     }
; 437  :     regs->aie = INVALID_AIE;            /* Force a fresh 'instfetch' */

  00243	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00248	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN10@z900_Succe:

; 438  : 
; 439  :     PTT_INF( "rbranch >", regs->psw.IA, offset, regs->execflag );

  00253	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0025a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025d	48 83 e0 08	 and	 rax, 8
  00261	48 85 c0	 test	 rax, rax
  00264	74 4d		 je	 SHORT $LN22@z900_Succe
  00266	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00271	83 e0 01	 and	 eax, 1
  00274	8b c0		 mov	 eax, eax
  00276	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0027f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00284	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195527
  0028b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00290	4c 8b 4c 24 78	 mov	 r9, QWORD PTR offset$[rsp]
  00295	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  002a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195528
  002a8	b9 08 00 00 00	 mov	 ecx, 8
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_Succe:
  002b3	33 c0		 xor	 eax, eax
  002b5	85 c0		 test	 eax, eax
  002b7	75 9a		 jne	 SHORT $LN10@z900_Succe
$LN13@z900_Succe:

; 440  :     PER_SB( regs, regs->psw.IA );

  002b9	33 c0		 xor	 eax, eax
  002bb	83 f8 01	 cmp	 eax, 1
  002be	0f 84 fd 01 00
	00		 je	 $LN23@z900_Succe
  002c4	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002c9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002cf	c1 e8 02	 shr	 eax, 2
  002d2	83 e0 01	 and	 eax, 1
  002d5	85 c0		 test	 eax, eax
  002d7	74 0a		 je	 SHORT $LN28@z900_Succe
  002d9	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  002e1	eb 08		 jmp	 SHORT $LN29@z900_Succe
$LN28@z900_Succe:
  002e3	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN29@z900_Succe:
  002eb	83 7c 24 40 00	 cmp	 DWORD PTR tv193[rsp], 0
  002f0	74 1b		 je	 SHORT $LN30@z900_Succe
  002f2	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002f7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002fa	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  002ff	85 c0		 test	 eax, eax
  00301	74 0a		 je	 SHORT $LN30@z900_Succe
  00303	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  0030b	eb 08		 jmp	 SHORT $LN36@z900_Succe
$LN30@z900_Succe:
  0030d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv213[rsp], 0
$LN36@z900_Succe:
  00315	83 7c 24 44 00	 cmp	 DWORD PTR tv213[rsp], 0
  0031a	0f 84 a1 01 00
	00		 je	 $LN23@z900_Succe
  00320	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00325	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0032a	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  0032f	0f b6 c0	 movzx	 eax, al
  00332	85 c0		 test	 eax, eax
  00334	0f 85 87 01 00
	00		 jne	 $LN23@z900_Succe
  0033a	33 c0		 xor	 eax, eax
  0033c	85 c0		 test	 eax, eax
  0033e	0f 85 63 01 00
	00		 jne	 $LN24@z900_Succe
  00344	b8 08 00 00 00	 mov	 eax, 8
  00349	48 6b c0 0a	 imul	 rax, rax, 10
  0034d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0035a	48 25 00 00 80
	00		 and	 rax, 8388608		; 00800000H
  00360	48 85 c0	 test	 rax, rax
  00363	0f 84 3e 01 00
	00		 je	 $LN24@z900_Succe
  00369	b8 08 00 00 00	 mov	 eax, 8
  0036e	48 6b c0 0c	 imul	 rax, rax, 12
  00372	b9 08 00 00 00	 mov	 ecx, 8
  00377	48 6b c9 0b	 imul	 rcx, rcx, 11
  0037b	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00380	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00385	49 8b 8c 08 00
	06 00 00	 mov	 rcx, QWORD PTR [r8+rcx+1536]
  0038d	48 39 8c 02 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax+1536], rcx
  00395	0f 82 85 00 00
	00		 jb	 $LN41@z900_Succe
  0039b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  003a0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  003ac	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  003b3	48 23 c1	 and	 rax, rcx
  003b6	b9 08 00 00 00	 mov	 ecx, 8
  003bb	48 6b c9 0b	 imul	 rcx, rcx, 11
  003bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  003c4	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  003cc	72 3d		 jb	 SHORT $LN37@z900_Succe
  003ce	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  003d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  003d8	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  003df	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  003e6	48 23 c1	 and	 rax, rcx
  003e9	b9 08 00 00 00	 mov	 ecx, 8
  003ee	48 6b c9 0c	 imul	 rcx, rcx, 12
  003f2	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  003f7	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  003ff	77 0a		 ja	 SHORT $LN37@z900_Succe
  00401	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv269[rsp], 1
  00409	eb 08		 jmp	 SHORT $LN40@z900_Succe
$LN37@z900_Succe:
  0040b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv269[rsp], 0
$LN40@z900_Succe:
  00413	8b 44 24 48	 mov	 eax, DWORD PTR tv269[rsp]
  00417	89 44 24 50	 mov	 DWORD PTR tv270[rsp], eax
  0041b	e9 80 00 00 00	 jmp	 $LN42@z900_Succe
$LN41@z900_Succe:
  00420	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00425	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0042a	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00431	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00438	48 23 c1	 and	 rax, rcx
  0043b	b9 08 00 00 00	 mov	 ecx, 8
  00440	48 6b c9 0b	 imul	 rcx, rcx, 11
  00444	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00449	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00451	73 3d		 jae	 SHORT $LN38@z900_Succe
  00453	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00458	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0045d	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00464	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0046b	48 23 c1	 and	 rax, rcx
  0046e	b9 08 00 00 00	 mov	 ecx, 8
  00473	48 6b c9 0c	 imul	 rcx, rcx, 12
  00477	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0047c	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00484	76 0a		 jbe	 SHORT $LN38@z900_Succe
  00486	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv268[rsp], 0
  0048e	eb 08		 jmp	 SHORT $LN39@z900_Succe
$LN38@z900_Succe:
  00490	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv268[rsp], 1
$LN39@z900_Succe:
  00498	8b 44 24 4c	 mov	 eax, DWORD PTR tv268[rsp]
  0049c	89 44 24 50	 mov	 DWORD PTR tv270[rsp], eax
$LN42@z900_Succe:
  004a0	83 7c 24 50 00	 cmp	 DWORD PTR tv270[rsp], 0
  004a5	74 1a		 je	 SHORT $LN23@z900_Succe
$LN24@z900_Succe:
$LN16@z900_Succe:
  004a7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  004ac	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  004af	0f ba e8 17	 bts	 eax, 23
  004b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  004b8	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  004bb	33 c0		 xor	 eax, eax
  004bd	85 c0		 test	 eax, eax
  004bf	75 e6		 jne	 SHORT $LN16@z900_Succe
$LN23@z900_Succe:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	0f 85 ee fd ff
	ff		 jne	 $LN13@z900_Succe
$LN1@z900_Succe:

; 441  : }

  004cb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004cf	c3		 ret	 0
z900_SuccessfulRelativeBranch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv155 = 64
tv175 = 68
tv231 = 72
tv230 = 76
tv232 = 80
regs$ = 112
vaddr$ = 120
z900_SuccessfulBranch PROC

; 363  : {

$LN37:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 364  :     vaddr &= ADDRESS_MAXWRAP( regs );

  0000e	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0001a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR vaddr$[rsp]
  0001f	48 23 c8	 and	 rcx, rax
  00022	48 8b c1	 mov	 rax, rcx
  00025	48 89 44 24 78	 mov	 QWORD PTR vaddr$[rsp], rax

; 365  : 
; 366  :     /* Set BEAR to branch instruction. Note: for branch instructions
; 367  :        regs->ip is not updated to point to the next instruction and
; 368  :        thus is still pointing to the branch instruction itself.
; 369  :     */
; 370  :     SET_BEAR_REG( regs, regs->ip );

  0002a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0002f	48 05 18 02 00
	00		 add	 rax, 536		; 00000218H
  00035	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003a	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  0003e	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00043	48 8b c8	 mov	 rcx, rax
  00046	e8 00 00 00 00	 call	 z900_Set_BEAR_Reg

; 371  : 
; 372  :     /* Branch target still within same page as branch instruction? */
; 373  :     if (1
; 374  :         && !regs->permode
; 375  :         && !regs->execflag
; 376  :         && (vaddr & (PAGEFRAME_PAGEMASK | 0x01)) == regs->AIV

  0004b	33 c0		 xor	 eax, eax
  0004d	83 f8 01	 cmp	 eax, 1
  00050	0f 84 dc 00 00
	00		 je	 $LN14@z900_Succe
  00056	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00061	c1 e8 02	 shr	 eax, 2
  00064	83 e0 01	 and	 eax, 1
  00067	85 c0		 test	 eax, eax
  00069	0f 85 c3 00 00
	00		 jne	 $LN14@z900_Succe
  0006f	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00074	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0007a	83 e0 01	 and	 eax, 1
  0007d	85 c0		 test	 eax, eax
  0007f	0f 85 ad 00 00
	00		 jne	 $LN14@z900_Succe
  00085	48 8b 44 24 78	 mov	 rax, QWORD PTR vaddr$[rsp]
  0008a	48 25 01 f0 ff
	ff		 and	 rax, -4095		; fffffffffffff001H
  00090	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00095	48 3b 81 10 02
	00 00		 cmp	 rax, QWORD PTR [rcx+528]
  0009c	0f 85 90 00 00
	00		 jne	 $LN14@z900_Succe

; 377  :     )
; 378  :     {
; 379  :         /* Branch directly to the new instruction */
; 380  :         regs->ip = regs->aip + (vaddr - regs->AIV);

  000a2	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 80 10 02
	00 00		 mov	 rax, QWORD PTR [rax+528]
  000ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR vaddr$[rsp]
  000b3	48 2b c8	 sub	 rcx, rax
  000b6	48 8b c1	 mov	 rax, rcx
  000b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  000c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN4@z900_Succe:

; 381  :         PTT_INF( "branch", vaddr, regs->AIV, regs->ip );

  000ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d8	48 83 e0 08	 and	 rax, 8
  000dc	48 85 c0	 test	 rax, rax
  000df	74 46		 je	 SHORT $LN15@z900_Succe
  000e1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ea	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000ef	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000f3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195465
  000ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00104	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00109	4c 8b 88 10 02
	00 00		 mov	 r9, QWORD PTR [rax+528]
  00110	4c 8b 44 24 78	 mov	 r8, QWORD PTR vaddr$[rsp]
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195466
  0011c	b9 08 00 00 00	 mov	 ecx, 8
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@z900_Succe:
  00127	33 c0		 xor	 eax, eax
  00129	85 c0		 test	 eax, eax
  0012b	75 a1		 jne	 SHORT $LN4@z900_Succe

; 382  :         return;

  0012d	e9 8d 02 00 00	 jmp	 $LN1@z900_Succe
$LN14@z900_Succe:

; 383  :     }
; 384  : 
; 385  :     /* Branch target is in another page: point the PSW to the target
; 386  :        instruction and force a new "regs->ip" value to get set by
; 387  :        forcing a full instruction fetch from the new target address.
; 388  :     */
; 389  :     regs->psw.IA = vaddr;               /* Point PSW to target instr */

  00132	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00137	48 8b 4c 24 78	 mov	 rcx, QWORD PTR vaddr$[rsp]
  0013c	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx

; 390  :     regs->aie = INVALID_AIE;            /* Force a fresh 'instfetch' */

  00143	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00148	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN7@z900_Succe:

; 391  : 
; 392  :     PTT_INF( "branch", vaddr, regs->AIV, 0 );

  00153	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0015a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015d	48 83 e0 08	 and	 rax, 8
  00161	48 85 c0	 test	 rax, rax
  00164	74 41		 je	 SHORT $LN16@z900_Succe
  00166	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0016f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00178	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195468
  0017f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00184	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00189	4c 8b 88 10 02
	00 00		 mov	 r9, QWORD PTR [rax+528]
  00190	4c 8b 44 24 78	 mov	 r8, QWORD PTR vaddr$[rsp]
  00195	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195469
  0019c	b9 08 00 00 00	 mov	 ecx, 8
  001a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@z900_Succe:
  001a7	33 c0		 xor	 eax, eax
  001a9	85 c0		 test	 eax, eax
  001ab	75 a6		 jne	 SHORT $LN7@z900_Succe
$LN10@z900_Succe:

; 393  :     PER_SB( regs, regs->psw.IA );

  001ad	33 c0		 xor	 eax, eax
  001af	83 f8 01	 cmp	 eax, 1
  001b2	0f 84 fd 01 00
	00		 je	 $LN17@z900_Succe
  001b8	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001bd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c3	c1 e8 02	 shr	 eax, 2
  001c6	83 e0 01	 and	 eax, 1
  001c9	85 c0		 test	 eax, eax
  001cb	74 0a		 je	 SHORT $LN22@z900_Succe
  001cd	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  001d5	eb 08		 jmp	 SHORT $LN23@z900_Succe
$LN22@z900_Succe:
  001d7	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN23@z900_Succe:
  001df	83 7c 24 40 00	 cmp	 DWORD PTR tv155[rsp], 0
  001e4	74 1b		 je	 SHORT $LN24@z900_Succe
  001e6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001ee	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  001f3	85 c0		 test	 eax, eax
  001f5	74 0a		 je	 SHORT $LN24@z900_Succe
  001f7	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  001ff	eb 08		 jmp	 SHORT $LN30@z900_Succe
$LN24@z900_Succe:
  00201	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN30@z900_Succe:
  00209	83 7c 24 44 00	 cmp	 DWORD PTR tv175[rsp], 0
  0020e	0f 84 a1 01 00
	00		 je	 $LN17@z900_Succe
  00214	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00219	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0021e	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00223	0f b6 c0	 movzx	 eax, al
  00226	85 c0		 test	 eax, eax
  00228	0f 85 87 01 00
	00		 jne	 $LN17@z900_Succe
  0022e	33 c0		 xor	 eax, eax
  00230	85 c0		 test	 eax, eax
  00232	0f 85 63 01 00
	00		 jne	 $LN18@z900_Succe
  00238	b8 08 00 00 00	 mov	 eax, 8
  0023d	48 6b c0 0a	 imul	 rax, rax, 10
  00241	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0024e	48 25 00 00 80
	00		 and	 rax, 8388608		; 00800000H
  00254	48 85 c0	 test	 rax, rax
  00257	0f 84 3e 01 00
	00		 je	 $LN18@z900_Succe
  0025d	b8 08 00 00 00	 mov	 eax, 8
  00262	48 6b c0 0c	 imul	 rax, rax, 12
  00266	b9 08 00 00 00	 mov	 ecx, 8
  0026b	48 6b c9 0b	 imul	 rcx, rcx, 11
  0026f	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00274	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00279	49 8b 8c 08 00
	06 00 00	 mov	 rcx, QWORD PTR [r8+rcx+1536]
  00281	48 39 8c 02 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax+1536], rcx
  00289	0f 82 85 00 00
	00		 jb	 $LN35@z900_Succe
  0028f	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00294	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00299	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  002a0	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  002a7	48 23 c1	 and	 rax, rcx
  002aa	b9 08 00 00 00	 mov	 ecx, 8
  002af	48 6b c9 0b	 imul	 rcx, rcx, 11
  002b3	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  002b8	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  002c0	72 3d		 jb	 SHORT $LN31@z900_Succe
  002c2	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  002d3	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  002da	48 23 c1	 and	 rax, rcx
  002dd	b9 08 00 00 00	 mov	 ecx, 8
  002e2	48 6b c9 0c	 imul	 rcx, rcx, 12
  002e6	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  002eb	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  002f3	77 0a		 ja	 SHORT $LN31@z900_Succe
  002f5	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv231[rsp], 1
  002fd	eb 08		 jmp	 SHORT $LN34@z900_Succe
$LN31@z900_Succe:
  002ff	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
$LN34@z900_Succe:
  00307	8b 44 24 48	 mov	 eax, DWORD PTR tv231[rsp]
  0030b	89 44 24 50	 mov	 DWORD PTR tv232[rsp], eax
  0030f	e9 80 00 00 00	 jmp	 $LN36@z900_Succe
$LN35@z900_Succe:
  00314	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00319	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00325	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0032c	48 23 c1	 and	 rax, rcx
  0032f	b9 08 00 00 00	 mov	 ecx, 8
  00334	48 6b c9 0b	 imul	 rcx, rcx, 11
  00338	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0033d	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00345	73 3d		 jae	 SHORT $LN32@z900_Succe
  00347	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0034c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00351	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00358	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  0035f	48 23 c1	 and	 rax, rcx
  00362	b9 08 00 00 00	 mov	 ecx, 8
  00367	48 6b c9 0c	 imul	 rcx, rcx, 12
  0036b	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00370	48 3b 84 0a 00
	06 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+1536]
  00378	76 0a		 jbe	 SHORT $LN32@z900_Succe
  0037a	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv230[rsp], 0
  00382	eb 08		 jmp	 SHORT $LN33@z900_Succe
$LN32@z900_Succe:
  00384	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv230[rsp], 1
$LN33@z900_Succe:
  0038c	8b 44 24 4c	 mov	 eax, DWORD PTR tv230[rsp]
  00390	89 44 24 50	 mov	 DWORD PTR tv232[rsp], eax
$LN36@z900_Succe:
  00394	83 7c 24 50 00	 cmp	 DWORD PTR tv232[rsp], 0
  00399	74 1a		 je	 SHORT $LN17@z900_Succe
$LN18@z900_Succe:
$LN13@z900_Succe:
  0039b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  003a0	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  003a3	0f ba e8 17	 bts	 eax, 23
  003a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  003ac	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  003af	33 c0		 xor	 eax, eax
  003b1	85 c0		 test	 eax, eax
  003b3	75 e6		 jne	 SHORT $LN13@z900_Succe
$LN17@z900_Succe:
  003b5	33 c0		 xor	 eax, eax
  003b7	85 c0		 test	 eax, eax
  003b9	0f 85 ee fd ff
	ff		 jne	 $LN10@z900_Succe
$LN1@z900_Succe:

; 394  : }

  003bf	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003c3	c3		 ret	 0
z900_SuccessfulBranch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
aip$1 = 64
aiv$2 = 72
bear$ = 96
regs$ = 104
ip$ = 112
z900_Set_BEAR_Reg PROC

; 293  : {

$LN31:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 294  :     /* "If the instruction causing the breaking event is the
; 295  :         target of an execute-type instruction (EX or EXRL),
; 296  :         then the instruction address used to fetch the EX/EXRL
; 297  :         instruction is placed in the BEAR."
; 298  :     */
; 299  :     if (1
; 300  :         && bear != &regs->bear_ex   /* NOT saving EX/EXRL address?   */
; 301  :         && regs->execflag           /* EX/EXRL target caused event?  */

  00013	33 c0		 xor	 eax, eax
  00015	83 f8 01	 cmp	 eax, 1
  00018	0f 84 9d 00 00
	00		 je	 $LN17@z900_Set_B
  0001e	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00023	48 05 20 02 00
	00		 add	 rax, 544		; 00000220H
  00029	48 39 44 24 60	 cmp	 QWORD PTR bear$[rsp], rax
  0002e	0f 84 87 00 00
	00		 je	 $LN17@z900_Set_B
  00034	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00039	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003f	83 e0 01	 and	 eax, 1
  00042	85 c0		 test	 eax, eax
  00044	74 75		 je	 SHORT $LN17@z900_Set_B

; 302  :     )
; 303  :     {
; 304  :         regs->bear = regs->bear_ex; /* BEAR = EX/EXRL instr address  */

  00046	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00050	48 8b 89 20 02
	00 00		 mov	 rcx, QWORD PTR [rcx+544]
  00057	48 89 88 18 02
	00 00		 mov	 QWORD PTR [rax+536], rcx
$LN4@z900_Set_B:

; 305  :         PTT_INF( "bear = ex", regs->bear_ex, 0, 0 );

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00065	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00068	48 83 e0 08	 and	 rax, 8
  0006c	48 85 c0	 test	 rax, rax
  0006f	74 3f		 je	 SHORT $LN19@z900_Set_B
  00071	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0007a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195410
  0008a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008f	45 33 c9	 xor	 r9d, r9d
  00092	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00097	4c 8b 80 20 02
	00 00		 mov	 r8, QWORD PTR [rax+544]
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195411
  000a5	b9 08 00 00 00	 mov	 ecx, 8
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@z900_Set_B:
  000b0	33 c0		 xor	 eax, eax
  000b2	85 c0		 test	 eax, eax
  000b4	75 a8		 jne	 SHORT $LN4@z900_Set_B

; 306  :     }

  000b6	e9 45 02 00 00	 jmp	 $LN18@z900_Set_B
$LN17@z900_Set_B:

; 307  :     else if (ip)

  000bb	48 83 7c 24 70
	00		 cmp	 QWORD PTR ip$[rsp], 0
  000c1	0f 84 39 02 00
	00		 je	 $LN20@z900_Set_B

; 308  :     {
; 309  :         /* BEAR = Address of the beginning of virtual ('aiv') page
; 310  :            plus same displacement from begin of mainstor ('ip') page
; 311  :            also know as 'aip'.
; 312  : 
; 313  :            HOWEVER, since the 'ip' value passed to us might not match
; 314  :            regs->ip (it might have been passed to us as "regs->ip - 4"),
; 315  :            we cannot blindly rely on the 'ip' value passed to us being
; 316  :            on the same mainstor page as regs->aip. It could be pointing
; 317  :            before where regs->aip is currently pointing if regs->ip
; 318  :            was pointing to the first instruction on the page and thus
; 319  :            after backing up 4 bytes would cause it to point before
; 320  :            where regs->aip points. The below logic takes situations
; 321  :            such as that into consideration.
; 322  :         */
; 323  :         BYTE* aip = regs->aip;      /* Begin of mainstor page */

  000c7	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  000d3	48 89 44 24 40	 mov	 QWORD PTR aip$1[rsp], rax

; 324  :         U64   aiv = regs->AIV;      /* Begin of virtual page  */

  000d8	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 80 10 02
	00 00		 mov	 rax, QWORD PTR [rax+528]
  000e4	48 89 44 24 48	 mov	 QWORD PTR aiv$2[rsp], rax

; 325  : 
; 326  :         if (ip < regs->aip)         /* pointing to prev page? */

  000e9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ee	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  000f5	48 39 44 24 70	 cmp	 QWORD PTR ip$[rsp], rax
  000fa	73 79		 jae	 SHORT $LN21@z900_Set_B
$LN7@z900_Set_B:

; 327  :         {
; 328  :             /* The instruction pointer that was passed to us
; 329  :                points somewhere in the PREVIOUS mainstor page */
; 330  : 
; 331  :             PTT_INF( "ip < aip", ip, aip, aiv );

  000fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00103	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00106	48 83 e0 08	 and	 rax, 8
  0010a	48 85 c0	 test	 rax, rax
  0010d	74 3b		 je	 SHORT $LN23@z900_Set_B
  0010f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00118	48 8b 44 24 48	 mov	 rax, QWORD PTR aiv$2[rsp]
  0011d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00122	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195416
  00129	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012e	4c 8b 4c 24 40	 mov	 r9, QWORD PTR aip$1[rsp]
  00133	4c 8b 44 24 70	 mov	 r8, QWORD PTR ip$[rsp]
  00138	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195417
  0013f	b9 08 00 00 00	 mov	 ecx, 8
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN23@z900_Set_B:
  0014a	33 c0		 xor	 eax, eax
  0014c	85 c0		 test	 eax, eax
  0014e	75 ac		 jne	 SHORT $LN7@z900_Set_B

; 332  : 
; 333  :             aip -= PAGEFRAME_PAGESIZE;

  00150	48 8b 44 24 40	 mov	 rax, QWORD PTR aip$1[rsp]
  00155	48 2d 00 10 00
	00		 sub	 rax, 4096		; 00001000H
  0015b	48 89 44 24 40	 mov	 QWORD PTR aip$1[rsp], rax

; 334  :             aiv -= PAGEFRAME_PAGESIZE;

  00160	48 8b 44 24 48	 mov	 rax, QWORD PTR aiv$2[rsp]
  00165	48 2d 00 10 00
	00		 sub	 rax, 4096		; 00001000H
  0016b	48 89 44 24 48	 mov	 QWORD PTR aiv$2[rsp], rax

; 335  :         }

  00170	e9 8d 00 00 00	 jmp	 $LN22@z900_Set_B
$LN21@z900_Set_B:

; 336  :         else if (ip >= (regs->aip + PAGEFRAME_PAGESIZE))

  00175	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0017a	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  00181	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  00187	48 39 44 24 70	 cmp	 QWORD PTR ip$[rsp], rax
  0018c	72 74		 jb	 SHORT $LN24@z900_Set_B
$LN10@z900_Set_B:

; 337  :         {
; 338  :             /* The instruction pointer that was passed to us
; 339  :                points somewhere in the NEXT mainstor page */
; 340  : 
; 341  :             PTT_INF( "ip >= aip+page", ip, aip, aiv );

  0018e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00195	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00198	48 83 e0 08	 and	 rax, 8
  0019c	48 85 c0	 test	 rax, rax
  0019f	74 3b		 je	 SHORT $LN25@z900_Set_B
  001a1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001aa	48 8b 44 24 48	 mov	 rax, QWORD PTR aiv$2[rsp]
  001af	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195420
  001bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c0	4c 8b 4c 24 40	 mov	 r9, QWORD PTR aip$1[rsp]
  001c5	4c 8b 44 24 70	 mov	 r8, QWORD PTR ip$[rsp]
  001ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195421
  001d1	b9 08 00 00 00	 mov	 ecx, 8
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@z900_Set_B:
  001dc	33 c0		 xor	 eax, eax
  001de	85 c0		 test	 eax, eax
  001e0	75 ac		 jne	 SHORT $LN10@z900_Set_B

; 342  : 
; 343  :             aip += PAGEFRAME_PAGESIZE;

  001e2	48 8b 44 24 40	 mov	 rax, QWORD PTR aip$1[rsp]
  001e7	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  001ed	48 89 44 24 40	 mov	 QWORD PTR aip$1[rsp], rax

; 344  :             aiv += PAGEFRAME_PAGESIZE;

  001f2	48 8b 44 24 48	 mov	 rax, QWORD PTR aiv$2[rsp]
  001f7	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  001fd	48 89 44 24 48	 mov	 QWORD PTR aiv$2[rsp], rax
$LN24@z900_Set_B:
$LN22@z900_Set_B:

; 345  :         }
; 346  : 
; 347  :         /* Calculate and set BEAR appropriately */
; 348  :         *bear = aiv + (ip - aip);           /* Save virtual address  */

  00202	48 8b 44 24 40	 mov	 rax, QWORD PTR aip$1[rsp]
  00207	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ip$[rsp]
  0020c	48 2b c8	 sub	 rcx, rax
  0020f	48 8b c1	 mov	 rax, rcx
  00212	48 8b 4c 24 48	 mov	 rcx, QWORD PTR aiv$2[rsp]
  00217	48 03 c8	 add	 rcx, rax
  0021a	48 8b c1	 mov	 rax, rcx
  0021d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bear$[rsp]
  00222	48 89 01	 mov	 QWORD PTR [rcx], rax

; 349  :         *bear &= ADDRESS_MAXWRAP( regs );   /* of the breaking event */

  00225	48 8b 44 24 60	 mov	 rax, QWORD PTR bear$[rsp]
  0022a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0022f	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00236	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00239	48 23 c1	 and	 rax, rcx
  0023c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR bear$[rsp]
  00241	48 89 01	 mov	 QWORD PTR [rcx], rax

; 350  : 
; 351  :         if (bear == &regs->bear)

  00244	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00249	48 05 18 02 00
	00		 add	 rax, 536		; 00000218H
  0024f	48 39 44 24 60	 cmp	 QWORD PTR bear$[rsp], rax
  00254	75 56		 jne	 SHORT $LN26@z900_Set_B
$LN13@z900_Set_B:

; 352  :             PTT_INF( "bear =", *bear, 0, 0 );

  00256	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0025d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00260	48 83 e0 08	 and	 rax, 8
  00264	48 85 c0	 test	 rax, rax
  00267	74 3b		 je	 SHORT $LN28@z900_Set_B
  00269	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00272	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0027b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195425
  00282	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00287	45 33 c9	 xor	 r9d, r9d
  0028a	48 8b 44 24 60	 mov	 rax, QWORD PTR bear$[rsp]
  0028f	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00292	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195426
  00299	b9 08 00 00 00	 mov	 ecx, 8
  0029e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@z900_Set_B:
  002a4	33 c0		 xor	 eax, eax
  002a6	85 c0		 test	 eax, eax
  002a8	75 ac		 jne	 SHORT $LN13@z900_Set_B
  002aa	eb 54		 jmp	 SHORT $LN27@z900_Set_B
$LN26@z900_Set_B:
$LN16@z900_Set_B:

; 353  :         else
; 354  :             PTT_INF( "bear_ex =", *bear, 0, 0 );

  002ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002b3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002b6	48 83 e0 08	 and	 rax, 8
  002ba	48 85 c0	 test	 rax, rax
  002bd	74 3b		 je	 SHORT $LN29@z900_Set_B
  002bf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002c8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG195428
  002d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002dd	45 33 c9	 xor	 r9d, r9d
  002e0	48 8b 44 24 60	 mov	 rax, QWORD PTR bear$[rsp]
  002e5	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  002e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195429
  002ef	b9 08 00 00 00	 mov	 ecx, 8
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@z900_Set_B:
  002fa	33 c0		 xor	 eax, eax
  002fc	85 c0		 test	 eax, eax
  002fe	75 ac		 jne	 SHORT $LN16@z900_Set_B
$LN27@z900_Set_B:
$LN20@z900_Set_B:
$LN18@z900_Set_B:

; 355  :     }
; 356  : }

  00300	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00304	c3		 ret	 0
z900_Set_BEAR_Reg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
i$ = 32
p$1 = 40
regs$ = 64
z900_checkstop_all_cpus PROC

; 79   : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 80   :     int  i;
; 81   : 
; 82   :     if (!IS_INTLOCK_HELD( regs ))

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0001c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00023	3b c1		 cmp	 eax, ecx
  00025	74 17		 je	 SHORT $LN11@z900_check
$LN4@z900_check:

; 83   :         CRASH();

  00027	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0
  00038	33 c0		 xor	 eax, eax
  0003a	85 c0		 test	 eax, eax
  0003c	75 e9		 jne	 SHORT $LN4@z900_check
$LN11@z900_check:

; 84   : 
; 85   :     for (i=0; i < sysblk.maxcpu; i++)

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN7@z900_check
$LN5@z900_check:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_check:
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00063	0f 8d a7 00 00
	00		 jge	 $LN6@z900_check

; 86   :     {
; 87   :         if (IS_CPU_ONLINE(i))

  00069	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00075	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0007e	0f 84 87 00 00
	00		 je	 $LN12@z900_check

; 88   :         {
; 89   :             sysblk.regs[i]->cpustate = CPUSTATE_STOPPING;

  00084	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00090	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00098	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2

; 90   :             sysblk.regs[i]->checkstop = 1;

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a8	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000b0	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000b6	83 c8 20	 or	 eax, 32			; 00000020H
  000b9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000be	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000c5	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000cd	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN10@z900_check:

; 91   :             ON_IC_INTERRUPT( sysblk.regs[i] );

  000d3	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000e7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000ea	0f ba e8 1f	 bts	 eax, 31
  000ee	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000fa	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00102	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 c8		 jne	 SHORT $LN10@z900_check
$LN12@z900_check:

; 92   :         }
; 93   :     }

  0010b	e9 38 ff ff ff	 jmp	 $LN5@z900_check
$LN6@z900_check:

; 94   :     WAKEUP_CPUS_MASK( sysblk.waiting_mask );

  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG195197
  00117	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011e	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  00125	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 95   : }

  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	c3		 ret	 0
z900_checkstop_all_cpus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
iointid$ = 96
ioparm$ = 100
ioid$ = 104
icode$ = 108
psa$ = 112
tv166 = 120
rc$ = 124
tv407 = 128
tv136 = 136
pfx$ = 144
dev$ = 152
tv409 = 160
csw$ = 168
__$ArrayPad$ = 176
regs$ = 208
z900_perform_io_interrupt PROC

; 1458 : {

$LN46:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1459 : int     rc;                             /* Return code               */
; 1460 : int     icode;                          /* Intercept code            */
; 1461 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1462 : U32     ioparm;                         /* I/O interruption parameter*/
; 1463 : U32     ioid;                           /* I/O interruption address  */
; 1464 : U32     iointid;                        /* I/O interruption ident    */
; 1465 : RADR    pfx;                            /* Prefix                    */
; 1466 : DBLWRD  csw;                            /* CSW for S/370 channels    */
; 1467 : DEVBLK *dev;                            /* dev presenting interrupt  */
; 1468 : 
; 1469 :     /* Test and clear pending I/O interrupt */
; 1470 :     icode = ARCH_DEP( present_io_interrupt )( regs, &ioid, &ioparm, &iointid, csw, &dev );

  0001e	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dev$[rsp]
  00026	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002b	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR csw$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	4c 8d 4c 24 60	 lea	 r9, QWORD PTR iointid$[rsp]
  0003d	4c 8d 44 24 64	 lea	 r8, QWORD PTR ioparm$[rsp]
  00042	48 8d 54 24 68	 lea	 rdx, QWORD PTR ioid$[rsp]
  00047	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 z900_present_io_interrupt
  00054	89 44 24 6c	 mov	 DWORD PTR icode$[rsp], eax

; 1471 : 
; 1472 :     /* Exit if no interrupt was presented */
; 1473 :     if (icode == 0) return;

  00058	83 7c 24 6c 00	 cmp	 DWORD PTR icode$[rsp], 0
  0005d	75 05		 jne	 SHORT $LN8@z900_perfo
  0005f	e9 4e 0b 00 00	 jmp	 $LN1@z900_perfo
$LN8@z900_perfo:
$LN4@z900_perfo:

; 1474 : 
; 1475 :     PTT_IO("*IOINT",ioid,ioparm,iointid);

  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00074	48 85 c0	 test	 rax, rax
  00077	74 3e		 je	 SHORT $LN9@z900_perfo
  00079	8b 44 24 60	 mov	 eax, DWORD PTR iointid$[rsp]
  0007d	8b 4c 24 64	 mov	 ecx, DWORD PTR ioparm$[rsp]
  00081	8b 54 24 68	 mov	 edx, DWORD PTR ioid$[rsp]
  00085	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0008e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00093	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196327
  0009a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009f	44 8b c9	 mov	 r9d, ecx
  000a2	44 8b c2	 mov	 r8d, edx
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196328
  000ac	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@z900_perfo:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 a7		 jne	 SHORT $LN4@z900_perfo

; 1476 : 
; 1477 : #if defined(_FEATURE_IO_ASSIST)
; 1478 :     if(SIE_MODE(regs) && icode != SIE_NO_INTERCEPT)

  000bd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000cb	d1 e8		 shr	 eax, 1
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 4e		 je	 SHORT $LN10@z900_perfo
  000d4	83 7c 24 6c ff	 cmp	 DWORD PTR icode$[rsp], -1
  000d9	74 47		 je	 SHORT $LN10@z900_perfo

; 1479 :     {
; 1480 :         /* Point to SIE copy of PSA in state descriptor */
; 1481 :         psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_II_PSA_OFFSET);

  000db	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ea	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000f1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f9	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  00100	48 8d 44 08 30	 lea	 rax, QWORD PTR [rax+rcx+48]
  00105	48 89 44 24 70	 mov	 QWORD PTR psa$[rsp], rax

; 1482 :         ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  0010a	b2 06		 mov	 dl, 6
  0010c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  0011b	e8 00 00 00 00	 call	 z900_or_storage_key

; 1483 :     }

  00120	eb 7f		 jmp	 SHORT $LN11@z900_perfo
$LN10@z900_perfo:

; 1484 :     else
; 1485 : #endif
; 1486 :     {
; 1487 :         /* Point to PSA in main storage */
; 1488 :         pfx =

  00122	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00130	d1 e8		 shr	 eax, 1
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	74 19		 je	 SHORT $LN40@z900_perfo
  00139	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 80 90 08
	00 00		 mov	 rax, QWORD PTR [rax+2192]
  00148	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
  00150	eb 14		 jmp	 SHORT $LN41@z900_perfo
$LN40@z900_perfo:
  00152	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0015e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv136[rsp], rax
$LN41@z900_perfo:
  00166	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv136[rsp]
  0016e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pfx$[rsp], rax

; 1489 : #if defined(_FEATURE_SIE)
; 1490 :               SIE_MODE(regs) ? regs->sie_px :
; 1491 : #endif
; 1492 :               regs->PX;
; 1493 :         psa = (void*)(regs->mainstor + pfx);

  00176	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00185	48 03 84 24 90
	00 00 00	 add	 rax, QWORD PTR pfx$[rsp]
  0018d	48 89 44 24 70	 mov	 QWORD PTR psa$[rsp], rax

; 1494 :         ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  00192	b2 06		 mov	 dl, 6
  00194	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pfx$[rsp]
  0019c	e8 00 00 00 00	 call	 z900_or_storage_key
$LN11@z900_perfo:

; 1495 :     }
; 1496 : 
; 1497 : #ifdef FEATURE_S370_CHANNEL
; 1498 :     /* CSW has already been stored at PSA+X'40' */
; 1499 : 
; 1500 :     if (sysblk.arch_mode == ARCH_370_IDX &&
; 1501 :         ECMODE(&regs->psw))
; 1502 :     {
; 1503 :         /* For ECMODE, store the I/O device address at PSA+X'B8' */
; 1504 :         STORE_FW(psa->ioid,
; 1505 :                  ((((U32)psa->ioid[0] << 8) |
; 1506 :                    ((U32)SSID_TO_LCSS(ioid >> 16) & 0x07)) << 16) |
; 1507 :                  (ioid & 0x0000FFFFUL));
; 1508 :     }
; 1509 :     else
; 1510 :     {
; 1511 :         /* Set the interrupt code to the I/O device address */
; 1512 :         regs->psw.intcode = ioid;
; 1513 :     }
; 1514 : 
; 1515 :     /* Trace the I/O interrupt */
; 1516 :     if (CPU_STEPPING_OR_TRACING( regs, 0 ) || dev->ccwtrace)
; 1517 :     {
; 1518 :         BYTE* csw = psa->csw;
; 1519 : 
; 1520 :         if (regs->insttrace && sysblk.traceFILE)
; 1521 :             tf_0804( regs, csw, ioid, SSID_TO_LCSS(ioid >> 16) & 0x07 );
; 1522 :         else
; 1523 :         {
; 1524 :             // "Processor %s%02X: I/O interrupt code %1.1X:%4.4X CSW %2.2X...
; 1525 :             WRMSG( HHC00804, "I", PTYPSTR( regs->cpuad ), regs->cpuad,
; 1526 :                     SSID_TO_LCSS( ioid >> 16 ) & 0x07, ioid,
; 1527 :                     csw[0], csw[1], csw[2], csw[3],
; 1528 :                     csw[4], csw[5], csw[6], csw[7] );
; 1529 :         }
; 1530 :     }
; 1531 : #endif /*FEATURE_S370_CHANNEL*/
; 1532 : 
; 1533 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 1534 :     /* Store X'0001' + subchannel number at PSA+X'B8' */
; 1535 :     STORE_FW(psa->ioid, ioid);

  001a1	8b 4c 24 68	 mov	 ecx, DWORD PTR ioid$[rsp]
  001a5	e8 00 00 00 00	 call	 _byteswap_ulong
  001aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  001af	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  001b6	8b d0		 mov	 edx, eax
  001b8	e8 00 00 00 00	 call	 store_fw_noswap

; 1536 : 
; 1537 :     /* Store the I/O interruption parameter at PSA+X'BC' */
; 1538 :     STORE_FW(psa->ioparm, ioparm);

  001bd	8b 4c 24 64	 mov	 ecx, DWORD PTR ioparm$[rsp]
  001c1	e8 00 00 00 00	 call	 _byteswap_ulong
  001c6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  001cb	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  001d2	8b d0		 mov	 edx, eax
  001d4	e8 00 00 00 00	 call	 store_fw_noswap

; 1539 : 
; 1540 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 1541 :     /* Store the I/O interruption identification word at PSA+X'C0' */
; 1542 :     STORE_FW(psa->iointid, iointid);

  001d9	8b 4c 24 60	 mov	 ecx, DWORD PTR iointid$[rsp]
  001dd	e8 00 00 00 00	 call	 _byteswap_ulong
  001e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  001e7	48 81 c1 c0 00
	00 00		 add	 rcx, 192		; 000000c0H
  001ee	8b d0		 mov	 edx, eax
  001f0	e8 00 00 00 00	 call	 store_fw_noswap

; 1543 : #endif
; 1544 : 
; 1545 :     /* Trace the I/O interrupt */
; 1546 :     if (CPU_STEPPING_OR_TRACING( regs, 0 ) || dev->ccwtrace)

  001f5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00203	c1 e8 10	 shr	 eax, 16
  00206	83 e0 01	 and	 eax, 1
  00209	85 c0		 test	 eax, eax
  0020b	74 0a		 je	 SHORT $LN44@z900_perfo
  0020d	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv166[rsp], 1
  00215	eb 08		 jmp	 SHORT $LN45@z900_perfo
$LN44@z900_perfo:
  00217	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN45@z900_perfo:
  0021f	83 7c 24 78 00	 cmp	 DWORD PTR tv166[rsp], 0
  00224	0f 84 03 07 00
	00		 je	 $LN14@z900_perfo
  0022a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00231	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00237	c1 e8 0a	 shr	 eax, 10
  0023a	83 e0 01	 and	 eax, 1
  0023d	85 c0		 test	 eax, eax
  0023f	0f 84 55 03 00
	00		 je	 $LN15@z900_perfo
  00245	33 c0		 xor	 eax, eax
  00247	85 c0		 test	 eax, eax
  00249	0f 85 2d 01 00
	00		 jne	 $LN16@z900_perfo
  0024f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00256	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0025c	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00261	85 c0		 test	 eax, eax
  00263	0f 84 13 01 00
	00		 je	 $LN16@z900_perfo
  00269	33 c0		 xor	 eax, eax
  0026b	83 f8 01	 cmp	 eax, 1
  0026e	0f 84 26 03 00
	00		 je	 $LN15@z900_perfo
  00274	33 c0		 xor	 eax, eax
  00276	85 c0		 test	 eax, eax
  00278	75 37		 jne	 SHORT $LN17@z900_perfo
  0027a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00281	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00287	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0028c	85 c0		 test	 eax, eax
  0028e	74 21		 je	 SHORT $LN17@z900_perfo
  00290	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00298	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0029f	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  002a5	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  002ab	0f 85 e9 02 00
	00		 jne	 $LN15@z900_perfo
$LN17@z900_perfo:
  002b1	33 c0		 xor	 eax, eax
  002b3	85 c0		 test	 eax, eax
  002b5	75 37		 jne	 SHORT $LN18@z900_perfo
  002b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002be	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  002c4	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  002c9	85 c0		 test	 eax, eax
  002cb	74 21		 je	 SHORT $LN18@z900_perfo
  002cd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002dc	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  002e2	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  002e8	0f 8c ac 02 00
	00		 jl	 $LN15@z900_perfo
$LN18@z900_perfo:
  002ee	33 c0		 xor	 eax, eax
  002f0	85 c0		 test	 eax, eax
  002f2	0f 85 84 00 00
	00		 jne	 $LN19@z900_perfo
  002f8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ff	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00305	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0030a	85 c0		 test	 eax, eax
  0030c	74 26		 je	 SHORT $LN20@z900_perfo
  0030e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00316	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0031d	85 c0		 test	 eax, eax
  0031f	74 13		 je	 SHORT $LN20@z900_perfo
  00321	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00329	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00330	85 c0		 test	 eax, eax
  00332	75 48		 jne	 SHORT $LN19@z900_perfo
$LN20@z900_perfo:
  00334	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0033b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00341	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00346	85 c0		 test	 eax, eax
  00348	0f 84 4c 02 00
	00		 je	 $LN15@z900_perfo
  0034e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00356	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0035d	85 c0		 test	 eax, eax
  0035f	0f 84 35 02 00
	00		 je	 $LN15@z900_perfo
  00365	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036d	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00374	85 c0		 test	 eax, eax
  00376	0f 85 1e 02 00
	00		 jne	 $LN15@z900_perfo
$LN19@z900_perfo:
$LN16@z900_perfo:
  0037c	b8 08 00 00 00	 mov	 eax, 8
  00381	48 6b c0 00	 imul	 rax, rax, 0
  00385	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0038c	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00395	75 1f		 jne	 SHORT $LN21@z900_perfo
  00397	b8 08 00 00 00	 mov	 eax, 8
  0039c	48 6b c0 01	 imul	 rax, rax, 1
  003a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003a7	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  003b0	0f 84 93 05 00
	00		 je	 $LN13@z900_perfo
$LN21@z900_perfo:
  003b6	b8 08 00 00 00	 mov	 eax, 8
  003bb	48 6b c0 00	 imul	 rax, rax, 0
  003bf	b9 08 00 00 00	 mov	 ecx, 8
  003c4	48 6b c9 01	 imul	 rcx, rcx, 1
  003c8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003cf	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  003d6	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  003de	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  003e6	0f 87 bc 00 00
	00		 ja	 $LN22@z900_perfo
  003ec	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fc	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00403	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00407	48 2b c1	 sub	 rax, rcx
  0040a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00412	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00419	48 03 c8	 add	 rcx, rax
  0041c	48 8b c1	 mov	 rax, rcx
  0041f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00427	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0042e	b9 08 00 00 00	 mov	 ecx, 8
  00433	48 6b c9 00	 imul	 rcx, rcx, 0
  00437	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0043e	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00446	72 60		 jb	 SHORT $LN22@z900_perfo
  00448	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00450	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00458	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0045f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00463	48 2b c1	 sub	 rax, rcx
  00466	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046e	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00475	48 03 c8	 add	 rcx, rax
  00478	48 8b c1	 mov	 rax, rcx
  0047b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00483	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0048a	b9 08 00 00 00	 mov	 ecx, 8
  0048f	48 6b c9 01	 imul	 rcx, rcx, 1
  00493	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0049a	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  004a2	0f 86 a1 04 00
	00		 jbe	 $LN13@z900_perfo
$LN22@z900_perfo:
  004a8	b8 08 00 00 00	 mov	 eax, 8
  004ad	48 6b c0 00	 imul	 rax, rax, 0
  004b1	b9 08 00 00 00	 mov	 ecx, 8
  004b6	48 6b c9 01	 imul	 rcx, rcx, 1
  004ba	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004c1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  004c8	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  004d0	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  004d8	0f 86 bc 00 00
	00		 jbe	 $LN23@z900_perfo
  004de	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ee	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  004f5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  004f9	48 2b c1	 sub	 rax, rcx
  004fc	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00504	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0050b	48 03 c8	 add	 rcx, rax
  0050e	48 8b c1	 mov	 rax, rcx
  00511	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00519	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00520	b9 08 00 00 00	 mov	 ecx, 8
  00525	48 6b c9 01	 imul	 rcx, rcx, 1
  00529	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00530	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00538	72 60		 jb	 SHORT $LN23@z900_perfo
  0053a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00542	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054a	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00551	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00555	48 2b c1	 sub	 rax, rcx
  00558	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00560	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00567	48 03 c8	 add	 rcx, rax
  0056a	48 8b c1	 mov	 rax, rcx
  0056d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00575	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0057c	b9 08 00 00 00	 mov	 ecx, 8
  00581	48 6b c9 00	 imul	 rcx, rcx, 0
  00585	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0058c	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00594	0f 86 af 03 00
	00		 jbe	 $LN13@z900_perfo
$LN23@z900_perfo:
$LN15@z900_perfo:
  0059a	33 c0		 xor	 eax, eax
  0059c	83 f8 01	 cmp	 eax, 1
  0059f	0f 84 88 03 00
	00		 je	 $LN24@z900_perfo
  005a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ac	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  005b2	c1 e8 08	 shr	 eax, 8
  005b5	83 e0 01	 and	 eax, 1
  005b8	85 c0		 test	 eax, eax
  005ba	0f 84 6d 03 00
	00		 je	 $LN24@z900_perfo
  005c0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005ce	c1 e8 0f	 shr	 eax, 15
  005d1	83 e0 01	 and	 eax, 1
  005d4	85 c0		 test	 eax, eax
  005d6	0f 84 51 03 00
	00		 je	 $LN24@z900_perfo
  005dc	33 c0		 xor	 eax, eax
  005de	85 c0		 test	 eax, eax
  005e0	0f 85 2d 01 00
	00		 jne	 $LN25@z900_perfo
  005e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ed	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005f3	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  005f8	85 c0		 test	 eax, eax
  005fa	0f 84 13 01 00
	00		 je	 $LN25@z900_perfo
  00600	33 c0		 xor	 eax, eax
  00602	83 f8 01	 cmp	 eax, 1
  00605	0f 84 22 03 00
	00		 je	 $LN24@z900_perfo
  0060b	33 c0		 xor	 eax, eax
  0060d	85 c0		 test	 eax, eax
  0060f	75 37		 jne	 SHORT $LN26@z900_perfo
  00611	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00618	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0061e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00623	85 c0		 test	 eax, eax
  00625	74 21		 je	 SHORT $LN26@z900_perfo
  00627	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00636	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0063c	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00642	0f 85 e5 02 00
	00		 jne	 $LN24@z900_perfo
$LN26@z900_perfo:
  00648	33 c0		 xor	 eax, eax
  0064a	85 c0		 test	 eax, eax
  0064c	75 37		 jne	 SHORT $LN27@z900_perfo
  0064e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00655	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0065b	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00660	85 c0		 test	 eax, eax
  00662	74 21		 je	 SHORT $LN27@z900_perfo
  00664	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0066c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00673	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00679	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0067f	0f 8c a8 02 00
	00		 jl	 $LN24@z900_perfo
$LN27@z900_perfo:
  00685	33 c0		 xor	 eax, eax
  00687	85 c0		 test	 eax, eax
  00689	0f 85 84 00 00
	00		 jne	 $LN28@z900_perfo
  0068f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00696	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0069c	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  006a1	85 c0		 test	 eax, eax
  006a3	74 26		 je	 SHORT $LN29@z900_perfo
  006a5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ad	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  006b4	85 c0		 test	 eax, eax
  006b6	74 13		 je	 SHORT $LN29@z900_perfo
  006b8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c0	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  006c7	85 c0		 test	 eax, eax
  006c9	75 48		 jne	 SHORT $LN28@z900_perfo
$LN29@z900_perfo:
  006cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006d2	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006d8	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  006dd	85 c0		 test	 eax, eax
  006df	0f 84 48 02 00
	00		 je	 $LN24@z900_perfo
  006e5	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ed	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  006f4	85 c0		 test	 eax, eax
  006f6	0f 84 31 02 00
	00		 je	 $LN24@z900_perfo
  006fc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00704	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0070b	85 c0		 test	 eax, eax
  0070d	0f 85 1a 02 00
	00		 jne	 $LN24@z900_perfo
$LN28@z900_perfo:
$LN25@z900_perfo:
  00713	b8 08 00 00 00	 mov	 eax, 8
  00718	48 6b c0 00	 imul	 rax, rax, 0
  0071c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00723	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0072c	75 1f		 jne	 SHORT $LN30@z900_perfo
  0072e	b8 08 00 00 00	 mov	 eax, 8
  00733	48 6b c0 01	 imul	 rax, rax, 1
  00737	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0073e	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00747	0f 84 fc 01 00
	00		 je	 $LN13@z900_perfo
$LN30@z900_perfo:
  0074d	b8 08 00 00 00	 mov	 eax, 8
  00752	48 6b c0 00	 imul	 rax, rax, 0
  00756	b9 08 00 00 00	 mov	 ecx, 8
  0075b	48 6b c9 01	 imul	 rcx, rcx, 1
  0075f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00766	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0076d	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  00775	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  0077d	0f 87 bc 00 00
	00		 ja	 $LN31@z900_perfo
  00783	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00793	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0079a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0079e	48 2b c1	 sub	 rax, rcx
  007a1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a9	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  007b0	48 03 c8	 add	 rcx, rax
  007b3	48 8b c1	 mov	 rax, rcx
  007b6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007be	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  007c5	b9 08 00 00 00	 mov	 ecx, 8
  007ca	48 6b c9 00	 imul	 rcx, rcx, 0
  007ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007d5	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  007dd	72 60		 jb	 SHORT $LN31@z900_perfo
  007df	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ef	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  007f6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  007fa	48 2b c1	 sub	 rax, rcx
  007fd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00805	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0080c	48 03 c8	 add	 rcx, rax
  0080f	48 8b c1	 mov	 rax, rcx
  00812	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0081a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00821	b9 08 00 00 00	 mov	 ecx, 8
  00826	48 6b c9 01	 imul	 rcx, rcx, 1
  0082a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00831	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00839	0f 86 0a 01 00
	00		 jbe	 $LN13@z900_perfo
$LN31@z900_perfo:
  0083f	b8 08 00 00 00	 mov	 eax, 8
  00844	48 6b c0 00	 imul	 rax, rax, 0
  00848	b9 08 00 00 00	 mov	 ecx, 8
  0084d	48 6b c9 01	 imul	 rcx, rcx, 1
  00851	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00858	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0085f	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  00867	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  0086f	0f 86 b8 00 00
	00		 jbe	 $LN32@z900_perfo
  00875	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0087d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00885	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0088c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00890	48 2b c1	 sub	 rax, rcx
  00893	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0089b	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  008a2	48 03 c8	 add	 rcx, rax
  008a5	48 8b c1	 mov	 rax, rcx
  008a8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b0	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  008b7	b9 08 00 00 00	 mov	 ecx, 8
  008bc	48 6b c9 01	 imul	 rcx, rcx, 1
  008c0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008c7	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  008cf	72 5c		 jb	 SHORT $LN32@z900_perfo
  008d1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e1	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  008e8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  008ec	48 2b c1	 sub	 rax, rcx
  008ef	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f7	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  008fe	48 03 c8	 add	 rcx, rax
  00901	48 8b c1	 mov	 rax, rcx
  00904	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0090c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00913	b9 08 00 00 00	 mov	 ecx, 8
  00918	48 6b c9 00	 imul	 rcx, rcx, 0
  0091c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00923	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0092b	76 1c		 jbe	 SHORT $LN13@z900_perfo
$LN32@z900_perfo:
$LN24@z900_perfo:
$LN14@z900_perfo:
  0092d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00935	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0093b	c1 e8 0f	 shr	 eax, 15
  0093e	83 e0 01	 and	 eax, 1
  00941	85 c0		 test	 eax, eax
  00943	0f 84 03 01 00
	00		 je	 $LN12@z900_perfo
$LN13@z900_perfo:

; 1547 :     {
; 1548 :         if (regs->insttrace && sysblk.traceFILE)

  00949	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00951	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00957	c1 e8 0f	 shr	 eax, 15
  0095a	83 e0 01	 and	 eax, 1
  0095d	85 c0		 test	 eax, eax
  0095f	74 32		 je	 SHORT $LN33@z900_perfo
  00961	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00968	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00970	74 21		 je	 SHORT $LN33@z900_perfo

; 1549 :             tf_0806( regs, ioid, ioparm, iointid );

  00972	44 8b 4c 24 60	 mov	 r9d, DWORD PTR iointid$[rsp]
  00977	44 8b 44 24 64	 mov	 r8d, DWORD PTR ioparm$[rsp]
  0097c	8b 54 24 68	 mov	 edx, DWORD PTR ioid$[rsp]
  00980	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00988	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0806
  0098e	e9 b9 00 00 00	 jmp	 $LN34@z900_perfo
$LN33@z900_perfo:

; 1550 :         else
; 1551 :         {
; 1552 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) && !defined( _FEATURE_IO_ASSIST )
; 1553 :             // "Processor %s%02X: I/O interrupt code %8.8X parm %8.8X"
; 1554 :             WRMSG (HHC00805, "I", PTYPSTR(regs->cpuad), regs->cpuad, ioid, ioparm);
; 1555 : #else
; 1556 :             // "Processor %s%02X: I/O interrupt code %8.8X parm %8.8X id %8.8X"
; 1557 :             WRMSG (HHC00806, "I", PTYPSTR(regs->cpuad), regs->cpuad, ioid, ioparm, iointid);

  00993	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0099b	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  009a2	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv407[rsp], eax
  009a9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009b1	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  009b8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  009bf	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  009c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  009cd	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv409[rsp], rax
  009d5	b9 01 00 00 00	 mov	 ecx, 1
  009da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009e0	8b 4c 24 60	 mov	 ecx, DWORD PTR iointid$[rsp]
  009e4	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  009e8	8b 4c 24 64	 mov	 ecx, DWORD PTR ioparm$[rsp]
  009ec	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  009f0	8b 4c 24 68	 mov	 ecx, DWORD PTR ioid$[rsp]
  009f4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  009f8	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv407[rsp]
  009ff	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a03	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv409[rsp]
  00a0b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196354
  00a17	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a1c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196355
  00a23	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a28	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a2d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a33	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196356
  00a3a	ba 15 06 00 00	 mov	 edx, 1557		; 00000615H
  00a3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196357
  00a46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN34@z900_perfo:
$LN12@z900_perfo:

; 1558 : #endif
; 1559 :         }
; 1560 :     }
; 1561 : #endif /* FEATURE_CHANNEL_SUBSYSTEM */
; 1562 : 
; 1563 : #if defined( _FEATURE_IO_ASSIST )
; 1564 :     if (icode == SIE_NO_INTERCEPT)

  00a4c	83 7c 24 6c ff	 cmp	 DWORD PTR icode$[rsp], -1
  00a51	0f 85 2d 01 00
	00		 jne	 $LN35@z900_perfo

; 1565 : #endif
; 1566 :     {
; 1567 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1568 :         /* Abort any active transaction and then return back to here
; 1569 :            to continue with I/O interrupt processing */
; 1570 :         if (regs->txf_tnd)

  00a57	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a5f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00a66	85 c0		 test	 eax, eax
  00a68	0f 84 a7 00 00
	00		 je	 $LN36@z900_perfo
$LN7@z900_perfo:

; 1571 :         {
; 1572 :             PTT_TXF( "*TXF IO", 0, regs->txf_contran, regs->txf_tnd );

  00a6e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00a75	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a78	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00a7e	48 85 c0	 test	 rax, rax
  00a81	74 50		 je	 SHORT $LN37@z900_perfo
  00a83	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a8b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00a92	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a9a	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  00aa1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00aaa	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00aaf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196361
  00ab6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00abb	44 8b c9	 mov	 r9d, ecx
  00abe	45 33 c0	 xor	 r8d, r8d
  00ac1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196362
  00ac8	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00acd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN37@z900_perfo:
  00ad3	33 c0		 xor	 eax, eax
  00ad5	85 c0		 test	 eax, eax
  00ad7	75 95		 jne	 SHORT $LN7@z900_perfo

; 1573 :             regs->txf_why |= TXF_WHY_IO_INT;

  00ad9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ae1	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  00ae7	0f ba e8 13	 bts	 eax, 19
  00aeb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00af3	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax

; 1574 :             ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_IO );

  00af9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196363
  00b00	41 b8 06 00 00
	00		 mov	 r8d, 6
  00b06	33 d2		 xor	 edx, edx
  00b08	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b10	e8 00 00 00 00	 call	 z900_abort_transaction
$LN36@z900_perfo:

; 1575 :         }
; 1576 : #endif
; 1577 :         /* Store current PSW at PSA+X'38' or PSA+X'170' for ESAME */
; 1578 :         ARCH_DEP(store_psw) ( regs, psa->iopold );

  00b15	48 8b 44 24 70	 mov	 rax, QWORD PTR psa$[rsp]
  00b1a	48 05 70 01 00
	00		 add	 rax, 368		; 00000170H
  00b20	48 8b d0	 mov	 rdx, rax
  00b23	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b2b	e8 00 00 00 00	 call	 z900_store_psw

; 1579 : 
; 1580 :         /* Load new PSW from PSA+X'78' or PSA+X'1F0' for ESAME */
; 1581 :         rc = ARCH_DEP(load_psw) ( regs, psa->iopnew );

  00b30	48 8b 44 24 70	 mov	 rax, QWORD PTR psa$[rsp]
  00b35	48 05 f0 01 00
	00		 add	 rax, 496		; 000001f0H
  00b3b	48 8b d0	 mov	 rdx, rax
  00b3e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b46	e8 00 00 00 00	 call	 z900_load_psw
  00b4b	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1582 : 
; 1583 :         if ( rc )

  00b4f	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00b54	74 2e		 je	 SHORT $LN38@z900_perfo

; 1584 :         {
; 1585 :             RELEASE_INTLOCK(regs);

  00b56	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196365
  00b5d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b65	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1586 :             regs->program_interrupt (regs, rc);

  00b6a	8b 54 24 7c	 mov	 edx, DWORD PTR rc$[rsp]
  00b6e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b76	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b7e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN38@z900_perfo:
$LN35@z900_perfo:

; 1587 :         }
; 1588 :     }
; 1589 : 
; 1590 :     RELEASE_INTLOCK(regs);

  00b84	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196366
  00b8b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b93	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1591 : 
; 1592 :     longjmp(regs->progjmp, icode);

  00b98	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba0	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00ba6	8b 54 24 6c	 mov	 edx, DWORD PTR icode$[rsp]
  00baa	48 8b c8	 mov	 rcx, rax
  00bad	e8 00 00 00 00	 call	 longjmp
$LN1@z900_perfo:
$LN39@z900_perfo:

; 1593 : 
; 1594 : } /* end function perform_io_interrupt */

  00bb2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00bba	48 33 cc	 xor	 rcx, rsp
  00bbd	e8 00 00 00 00	 call	 __security_check_cookie
  00bc2	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00bc9	c3		 ret	 0
z900_perform_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 96
i$ = 104
tv221 = 108
tv357 = 112
aswitch$ = 116
tv378 = 120
ip$ = 128
current_opcode_table$ = 136
tv79 = 144
tv363 = 152
tv144 = 160
tv152 = 168
tv183 = 176
tv191 = 184
tv274 = 192
tv295 = 200
tv380 = 208
buf$1 = 216
__$ArrayPad$ = 256
cpu$ = 304
oldregs$ = 312
s390_run_cpu PROC

; 1905 : {

$LN53:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1906 : const INSTR_FUNC   *current_opcode_table;
; 1907 : register REGS   *regs;
; 1908 : BYTE   *ip;
; 1909 : int     i = 0;

  00024	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1910 : int     aswitch;
; 1911 : 
; 1912 :     /* Assign new regs if not already assigned */
; 1913 :     regs = sysblk.regs[cpu] ?

  0002c	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003b	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00044	74 21		 je	 SHORT $LN40@s390_run_c
  00046	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00055	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0005d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  00065	eb 18		 jmp	 SHORT $LN41@s390_run_c
$LN40@s390_run_c:
  00067	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0006c	b9 00 70 01 00	 mov	 ecx, 94208		; 00017000H
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  00077	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN41@s390_run_c:
  0007f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv79[rsp]
  00087	48 89 44 24 60	 mov	 QWORD PTR regs$[rsp], rax

; 1914 :            sysblk.regs[cpu] :
; 1915 :            malloc_aligned( ROUND_UP( sizeof( REGS ), _4K ), _4K );
; 1916 : 
; 1917 :     if (oldregs)

  0008c	48 83 bc 24 38
	01 00 00 00	 cmp	 QWORD PTR oldregs$[rsp], 0
  00095	0f 84 a9 01 00
	00		 je	 $LN20@s390_run_c

; 1918 :     {
; 1919 :         if (oldregs != regs)

  0009b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	48 39 84 24 38
	01 00 00	 cmp	 QWORD PTR oldregs$[rsp], rax
  000a8	0f 84 91 01 00
	00		 je	 $LN22@s390_run_c

; 1920 :         {
; 1921 :             TXF_FREEMAP( oldregs );
; 1922 :             memcpy (regs, oldregs, sizeof(REGS));

  000ae	48 8b 7c 24 60	 mov	 rdi, QWORD PTR regs$[rsp]
  000b3	48 8b b4 24 38
	01 00 00	 mov	 rsi, QWORD PTR oldregs$[rsp]
  000bb	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  000c0	f3 a4		 rep movsb

; 1923 :             free_aligned(oldregs);

  000c2	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR oldregs$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 1924 :             regs->blkloc = CSWAP64((U64)((uintptr_t)regs));

  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	e8 00 00 00 00	 call	 _byteswap_uint64
  000da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1925 :             HOSTREGS = regs;

  000e3	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 1926 :             if (GUESTREGS)

  000f4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00101	74 18		 je	 SHORT $LN23@s390_run_c

; 1927 :                 HOST(GUESTREGS) = regs;

  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00108	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx
$LN23@s390_run_c:

; 1928 :             sysblk.regs[cpu] = regs;

  0011b	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00123	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012a	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0012f	48 89 94 c1 98
	0b 00 00	 mov	 QWORD PTR [rcx+rax*8+2968], rdx

; 1929 :             release_lock(&sysblk.cpulock[cpu]);

  00137	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0013f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00146	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182201
  00155	48 8b c8	 mov	 rcx, rax
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1930 :             if (regs->insttrace && sysblk.traceFILE)

  0015e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00163	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00169	c1 e8 0f	 shr	 eax, 15
  0016c	83 e0 01	 and	 eax, 1
  0016f	85 c0		 test	 eax, eax
  00171	74 29		 je	 SHORT $LN24@s390_run_c
  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017a	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00182	74 18		 je	 SHORT $LN24@s390_run_c

; 1931 :                 tf_0811( regs, get_arch_name( regs ));

  00184	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	e8 00 00 00 00	 call	 get_arch_name
  0018e	48 8b d0	 mov	 rdx, rax
  00191	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0811
$LN24@s390_run_c:

; 1932 :             // "Processor %s%02X: architecture mode %s"
; 1933 :             WRMSG( HHC00811, "I", PTYPSTR( cpu ), cpu, get_arch_name( regs ));

  0019c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001a1	e8 00 00 00 00	 call	 get_arch_name
  001a6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv144[rsp], rax
  001ae	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  001b6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001bd	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001cb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001de	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv144[rsp]
  001e6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001eb	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  001f2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001f6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  001fe	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182203
  0020a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182204
  00216	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00220	41 b9 03 00 00
	00		 mov	 r9d, 3
  00226	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182205
  0022d	ba 8d 07 00 00	 mov	 edx, 1933		; 0000078dH
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182206
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@s390_run_c:

; 1934 :         }
; 1935 :     }

  0023f	e9 0e 01 00 00	 jmp	 $LN21@s390_run_c
$LN20@s390_run_c:

; 1936 :     else
; 1937 :     {
; 1938 :         memset(regs, 0, sizeof(REGS));

  00244	48 8b 7c 24 60	 mov	 rdi, QWORD PTR regs$[rsp]
  00249	33 c0		 xor	 eax, eax
  0024b	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  00250	f3 aa		 rep stosb

; 1939 :         
; 1940 :                 if (cpu_init( cpu, regs, NULL ))

  00252	45 33 c0	 xor	 r8d, r8d
  00255	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0025a	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00261	e8 00 00 00 00	 call	 cpu_init
  00266	85 c0		 test	 eax, eax
  00268	74 07		 je	 SHORT $LN25@s390_run_c

; 1941 :             return NULL;

  0026a	33 c0		 xor	 eax, eax
  0026c	e9 df 07 00 00	 jmp	 $LN1@s390_run_c
$LN25@s390_run_c:

; 1942 : 
; 1943 :         if (regs->insttrace && sysblk.traceFILE)

  00271	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00276	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0027c	c1 e8 0f	 shr	 eax, 15
  0027f	83 e0 01	 and	 eax, 1
  00282	85 c0		 test	 eax, eax
  00284	74 29		 je	 SHORT $LN26@s390_run_c
  00286	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028d	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00295	74 18		 je	 SHORT $LN26@s390_run_c

; 1944 :             tf_0811( regs, get_arch_name( regs ));

  00297	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	e8 00 00 00 00	 call	 get_arch_name
  002a1	48 8b d0	 mov	 rdx, rax
  002a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0811
$LN26@s390_run_c:

; 1945 : 
; 1946 :         // "Processor %s%02X: architecture mode %s"
; 1947 :         WRMSG( HHC00811, "I", PTYPSTR( cpu ), cpu, get_arch_name( regs ));

  002af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	e8 00 00 00 00	 call	 get_arch_name
  002b9	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
  002c1	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  002c9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002d0	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  002de	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
  002e6	b9 01 00 00 00	 mov	 ecx, 1
  002eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv183[rsp]
  002f9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002fe	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00305	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00309	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv191[rsp]
  00311	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182209
  0031d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182210
  00329	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00333	41 b9 03 00 00
	00		 mov	 r9d, 3
  00339	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182211
  00340	ba 9b 07 00 00	 mov	 edx, 1947		; 0000079bH
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182212
  0034c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@s390_run_c:

; 1948 : 
; 1949 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 1950 :         if (regs->vf->online)
; 1951 :         {
; 1952 :             if (regs->insttrace && sysblk.traceFILE)
; 1953 :                 tf_0812( regs, get_arch_name( regs ));
; 1954 : 
; 1955 :             // "Processor %s%02X: vector facility online"
; 1956 :             WRMSG( HHC00812, "I", PTYPSTR( cpu ), cpu );
; 1957 :         }
; 1958 : #endif
; 1959 :     }
; 1960 : 
; 1961 :     regs->program_interrupt = &ARCH_DEP(program_interrupt);

  00352	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s390_program_interrupt
  0035e	48 89 88 20 0d
	00 00		 mov	 QWORD PTR [rax+3360], rcx

; 1962 : 
; 1963 :     regs->breakortrace = (sysblk.instbreak || (sysblk.insttrace && regs->insttrace));

  00365	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0036c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00372	c1 e8 0a	 shr	 eax, 10
  00375	83 e0 01	 and	 eax, 1
  00378	85 c0		 test	 eax, eax
  0037a	75 36		 jne	 SHORT $LN43@s390_run_c
  0037c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00383	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00389	c1 e8 08	 shr	 eax, 8
  0038c	83 e0 01	 and	 eax, 1
  0038f	85 c0		 test	 eax, eax
  00391	74 15		 je	 SHORT $LN42@s390_run_c
  00393	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00398	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0039e	c1 e8 0f	 shr	 eax, 15
  003a1	83 e0 01	 and	 eax, 1
  003a4	85 c0		 test	 eax, eax
  003a6	75 0a		 jne	 SHORT $LN43@s390_run_c
$LN42@s390_run_c:
  003a8	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv221[rsp], 0
  003b0	eb 08		 jmp	 SHORT $LN44@s390_run_c
$LN43@s390_run_c:
  003b2	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv221[rsp], 1
$LN44@s390_run_c:
  003ba	8b 44 24 6c	 mov	 eax, DWORD PTR tv221[rsp]
  003be	83 e0 01	 and	 eax, 1
  003c1	c1 e0 10	 shl	 eax, 16
  003c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  003cf	0f ba f1 10	 btr	 ecx, 16
  003d3	0b c8		 or	 ecx, eax
  003d5	8b c1		 mov	 eax, ecx
  003d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003dc	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1964 :     regs->ints_state |= sysblk.ints_state;

  003e2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003ee	8b 89 a0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4768]
  003f4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003f7	0b c1		 or	 eax, ecx
  003f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003fe	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1965 : 
; 1966 :     /* Establish longjmp destination for cpu thread exit */
; 1967 :     if (setjmp(regs->exitjmp))

  00401	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00406	48 05 80 0b 00
	00		 add	 rax, 2944		; 00000b80H
  0040c	48 8b c8	 mov	 rcx, rax
  0040f	48 8b d4	 mov	 rdx, rsp
  00412	e8 00 00 00 00	 call	 _setjmp
  00417	85 c0		 test	 eax, eax
  00419	74 16		 je	 SHORT $LN27@s390_run_c

; 1968 :         return cpu_uninit(cpu, regs);

  0041b	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00420	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00427	e8 00 00 00 00	 call	 cpu_uninit
  0042c	e9 1f 06 00 00	 jmp	 $LN1@s390_run_c
$LN27@s390_run_c:

; 1969 : 
; 1970 :     /* Establish longjmp destination for architecture switch */
; 1971 :     aswitch = setjmp(regs->archjmp);

  00431	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00436	48 05 80 0a 00
	00		 add	 rax, 2688		; 00000a80H
  0043c	48 8b c8	 mov	 rcx, rax
  0043f	48 8b d4	 mov	 rdx, rsp
  00442	e8 00 00 00 00	 call	 _setjmp
  00447	89 44 24 74	 mov	 DWORD PTR aswitch$[rsp], eax

; 1972 : 
; 1973 :     /* Switch architecture mode if appropriate */
; 1974 :     if(sysblk.arch_mode != regs->arch_mode)

  0044b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00452	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00457	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  0045a	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  00460	0f 84 fb 01 00
	00		 je	 $LN28@s390_run_c
$LN4@s390_run_c:

; 1975 :     {
; 1976 :         PTT_INF("*SETARCH",regs->arch_mode,sysblk.arch_mode,cpu);

  00466	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0046d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00470	48 83 e0 08	 and	 rax, 8
  00474	48 85 c0	 test	 rax, rax
  00477	74 51		 je	 SHORT $LN29@s390_run_c
  00479	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00481	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00488	48 63 89 88 00
	00 00		 movsxd	 rcx, DWORD PTR [rcx+136]
  0048f	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00494	48 63 52 64	 movsxd	 rdx, DWORD PTR [rdx+100]
  00498	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004a1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG182216
  004ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b2	4c 8b c9	 mov	 r9, rcx
  004b5	4c 8b c2	 mov	 r8, rdx
  004b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182217
  004bf	b9 08 00 00 00	 mov	 ecx, 8
  004c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@s390_run_c:
  004ca	33 c0		 xor	 eax, eax
  004cc	85 c0		 test	 eax, eax
  004ce	75 96		 jne	 SHORT $LN4@s390_run_c

; 1977 :         regs->arch_mode = sysblk.arch_mode;

  004d0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  004d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004dc	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  004e2	89 48 64	 mov	 DWORD PTR [rax+100], ecx

; 1978 : 
; 1979 :         /* Ensure CPU ID is accurate in case archmode changed */
; 1980 :         setCpuIdregs( regs, -1, -1, -1, -1, true );

  004e5	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  004ea	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  004f2	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  004f8	66 41 b8 ff ff	 mov	 r8w, -1
  004fd	ba ff ff ff ff	 mov	 edx, -1
  00502	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00507	e8 00 00 00 00	 call	 setCpuIdregs

; 1981 : 
; 1982 :         oldregs = malloc_aligned(sizeof(REGS), 4096);

  0050c	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00511	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  0051c	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR oldregs$[rsp], rax

; 1983 :         if (oldregs)

  00524	48 83 bc 24 38
	01 00 00 00	 cmp	 QWORD PTR oldregs$[rsp], 0
  0052d	74 40		 je	 SHORT $LN30@s390_run_c

; 1984 :         {
; 1985 :             memcpy(oldregs, regs, sizeof(REGS));

  0052f	48 8b bc 24 38
	01 00 00	 mov	 rdi, QWORD PTR oldregs$[rsp]
  00537	48 8b 74 24 60	 mov	 rsi, QWORD PTR regs$[rsp]
  0053c	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  00541	f3 a4		 rep movsb

; 1986 :             obtain_lock(&sysblk.cpulock[cpu]);

  00543	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0054b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00552	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0055a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182220
  00561	48 8b c8	 mov	 rcx, rax
  00564	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1987 :         }

  0056a	e9 e5 00 00 00	 jmp	 $LN31@s390_run_c
$LN30@s390_run_c:

; 1988 :         else
; 1989 :         {
; 1990 :             char buf[40];
; 1991 :             MSGBUF(buf, "malloc(%d)", (int)sizeof(REGS));

  0056f	41 b9 80 60 01
	00		 mov	 r9d, 90240		; 00016080H
  00575	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182221
  0057c	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00581	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1992 :             // "Processor %s%02X: error in function %s: %s"
; 1993 :             WRMSG (HHC00813, "E", PTYPSTR(cpu), cpu, buf, strerror(errno));

  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00595	8b 08		 mov	 ecx, DWORD PTR [rax]
  00597	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0059d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv274[rsp], rax
  005a5	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  005ad	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005b4	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  005bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  005c2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv295[rsp], rax
  005ca	b9 01 00 00 00	 mov	 ecx, 1
  005cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005d5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv274[rsp]
  005dd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005e2	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  005ea	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005ef	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  005f6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005fa	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv295[rsp]
  00602	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00607	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182222
  0060e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00613	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182223
  0061a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0061f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00624	41 b9 03 00 00
	00		 mov	 r9d, 3
  0062a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182224
  00631	ba c9 07 00 00	 mov	 edx, 1993		; 000007c9H
  00636	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182225
  0063d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1994 :             cpu_uninit (cpu, regs);

  00643	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00648	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0064f	e8 00 00 00 00	 call	 cpu_uninit
$LN31@s390_run_c:

; 1995 :         }
; 1996 :         return oldregs;

  00654	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR oldregs$[rsp]
  0065c	e9 ef 03 00 00	 jmp	 $LN1@s390_run_c
$LN28@s390_run_c:

; 1997 :     }
; 1998 : 
; 1999 :     /* Initialize Facilities List */
; 2000 :     init_cpu_facilities( regs );

  00661	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00666	e8 00 00 00 00	 call	 init_cpu_facilities

; 2001 : 
; 2002 :     /* Initialize Transactional-Execution Facility */
; 2003 :     TXF_ALLOCMAP( regs );
; 2004 : 
; 2005 :     /* Get pointer to primary opcode table */
; 2006 :     current_opcode_table = regs->ARCH_DEP( runtime_opcode_xxxx );

  0066b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00670	48 8b 80 f8 af
	00 00		 mov	 rax, QWORD PTR [rax+45048]
  00677	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR current_opcode_table$[rsp], rax

; 2007 : 
; 2008 :     /* Signal cpu has started */
; 2009 :     if(!aswitch)

  0067f	83 7c 24 74 00	 cmp	 DWORD PTR aswitch$[rsp], 0
  00684	75 1d		 jne	 SHORT $LN32@s390_run_c

; 2010 :         signal_condition (&sysblk.cpucond);

  00686	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0068d	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  00693	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182227
  0069a	48 8b c8	 mov	 rcx, rax
  0069d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN32@s390_run_c:

; 2011 : 
; 2012 :     RELEASE_INTLOCK(regs);

  006a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182228
  006aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006af	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2013 : 
; 2014 :     /* Establish longjmp destination for program check or
; 2015 :        RETURN_INTCHECK, or SIE_INTERCEPT, or longjmp, etc.
; 2016 :     */
; 2017 :     if (setjmp( regs->progjmp ) && sysblk.ipled)

  006b4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006b9	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  006bf	48 8b c8	 mov	 rcx, rax
  006c2	48 8b d4	 mov	 rdx, rsp
  006c5	e8 00 00 00 00	 call	 _setjmp
  006ca	85 c0		 test	 eax, eax
  006cc	74 56		 je	 SHORT $LN33@s390_run_c
  006ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006d5	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006db	d1 e8		 shr	 eax, 1
  006dd	83 e0 01	 and	 eax, 1
  006e0	85 c0		 test	 eax, eax
  006e2	74 40		 je	 SHORT $LN33@s390_run_c

; 2018 :     {
; 2019 :         /* Our instruction execution loop further below didn't finish
; 2020 :            due to a longjmp(progjmp) having been executed bringing us
; 2021 :            to here, thereby causing the instruction counter to not be
; 2022 :            properly updated. Thus, we need to update it here instead.
; 2023 :        */
; 2024 :         regs->instcount   +=     (i * 2);

  006e4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006e9	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  006ef	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  006f3	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  006f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006fb	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2025 :         UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  00701	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00705	03 c0		 add	 eax, eax
  00707	48 98		 cdqe
  00709	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00710	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  00717	48 8b d0	 mov	 rdx, rax
  0071a	e8 00 00 00 00	 call	 atomic_update64

; 2026 : 
; 2027 :         /* Perform automatic instruction tracing if it's enabled */
; 2028 :         do_automatic_tracing();

  0071f	e8 00 00 00 00	 call	 do_automatic_tracing
$LN33@s390_run_c:

; 2029 :     }
; 2030 : 
; 2031 :     /* Set `execflag' to 0 in case EXecuted instruction did a longjmp() */
; 2032 :     regs->execflag = 0;

  00724	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00729	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0072f	83 e0 fe	 and	 eax, -2			; fffffffeH
  00732	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00737	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$fastest_no_txf_loop$54:

; 2033 : 
; 2034 :     //--------------------------------------------------------------
; 2035 :     //                    PROGRAMMING NOTE
; 2036 :     //--------------------------------------------------------------
; 2037 :     // The first 'fastest_no_txf_loop' loop below is used when the
; 2038 :     // TXF facility is not enabled, and since facilities cannot be
; 2039 :     // enabled or disabled once the guest system has been IPLed and
; 2040 :     // started, it utilizes our original instruction execution loop
; 2041 :     // which uses the 'EXECUTE_INSTRUCTION' and 'UNROLLED_EXECUTE'
; 2042 :     // macros which do not have any TXF related code in them.
; 2043 :     //
; 2044 :     // The second and third loops below (the 'txf_facility_loop' and
; 2045 :     // 'txf_slower_loop') are used when the TXF facility is enabled,
; 2046 :     // requiring us to check whether or not a transaction is active
; 2047 :     // or not after each instruction is executed.
; 2048 :     //
; 2049 :     // If no transaction is active, the normal 'EXECUTE_INSTRUCTION'
; 2050 :     // and 'UNROLLED_EXECUTE' macros can be used, but a check for an
; 2051 :     // active transaction still needs to be performed after each and
; 2052 :     // every instruction (so we can know which loop we need to use).
; 2053 :     //
; 2054 :     // When a transaction is active, we use the third (slowest) loop
; 2055 :     // called 'txf_slower_loop', using the 'TXF_EXECUTE_INSTRUCTION'
; 2056 :     // and 'TXF_UNROLLED_EXECUTE' macros, which contain code that
; 2057 :     // enforces certain Transaction-Exceution Facility constraints.
; 2058 :     //--------------------------------------------------------------
; 2059 : 
; 2060 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 2061 :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 2062 :         if (regs->CR(0) & CR0_TXC)
; 2063 :             goto txf_facility_loop;
; 2064 : #endif
; 2065 : 
; 2066 : fastest_no_txf_loop:
; 2067 : 
; 2068 :     if (INTERRUPT_PENDING( regs ))

  0073d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00742	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00747	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0074a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0074d	23 c1		 and	 eax, ecx
  0074f	85 c0		 test	 eax, eax
  00751	74 0a		 je	 SHORT $LN34@s390_run_c

; 2069 :         ARCH_DEP( process_interrupt )( regs );

  00753	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00758	e8 00 00 00 00	 call	 s390_process_interrupt
$LN34@s390_run_c:
$enter_fastest_no_txf_loop$55:

; 2070 : 
; 2071 : enter_fastest_no_txf_loop:
; 2072 : 
; 2073 :     ip = INSTRUCTION_FETCH( regs, 0 );

  0075d	33 c0		 xor	 eax, eax
  0075f	83 f8 01	 cmp	 eax, 1
  00762	74 17		 je	 SHORT $LN45@s390_run_c
  00764	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00769	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0076e	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00775	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00779	72 10		 jb	 SHORT $LN46@s390_run_c
$LN45@s390_run_c:
  0077b	33 c0		 xor	 eax, eax
  0077d	85 c0		 test	 eax, eax
  0077f	75 0a		 jne	 SHORT $LN46@s390_run_c
  00781	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv357[rsp], 0
  00789	eb 08		 jmp	 SHORT $LN50@s390_run_c
$LN46@s390_run_c:
  0078b	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv357[rsp], 1
$LN50@s390_run_c:
  00793	83 7c 24 70 00	 cmp	 DWORD PTR tv357[rsp], 0
  00798	74 13		 je	 SHORT $LN51@s390_run_c
  0079a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0079f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  007a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv363[rsp], rax
  007ab	eb 14		 jmp	 SHORT $LN52@s390_run_c
$LN51@s390_run_c:
  007ad	33 d2		 xor	 edx, edx
  007af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007b4	e8 00 00 00 00	 call	 s390_instfetch
  007b9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv363[rsp], rax
$LN52@s390_run_c:
  007c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv363[rsp]
  007c9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ip$[rsp], rax
$LN7@s390_run_c:

; 2074 :     PROCESS_TRACE( regs, ip, enter_fastest_no_txf_loop );

  007d1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007d6	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007dc	c1 e8 10	 shr	 eax, 16
  007df	83 e0 01	 and	 eax, 1
  007e2	85 c0		 test	 eax, eax
  007e4	0f 84 e3 00 00
	00		 je	 $LN35@s390_run_c
  007ea	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ip$[rsp]
  007f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007f7	e8 00 00 00 00	 call	 s390_process_trace
  007fc	33 c0		 xor	 eax, eax
  007fe	83 f8 01	 cmp	 eax, 1
  00801	0f 84 c6 00 00
	00		 je	 $LN36@s390_run_c
  00807	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0080c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00812	c1 e8 11	 shr	 eax, 17
  00815	83 e0 01	 and	 eax, 1
  00818	85 c0		 test	 eax, eax
  0081a	0f 84 ad 00 00
	00		 je	 $LN36@s390_run_c
  00820	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00825	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0082d	0f 85 9a 00 00
	00		 jne	 $LN36@s390_run_c
  00833	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00838	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0083f	89 44 24 78	 mov	 DWORD PTR tv378[rsp], eax
  00843	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00848	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0084f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00856	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0085e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00864	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv380[rsp], rax
  0086c	b9 01 00 00 00	 mov	 ecx, 1
  00871	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00877	8b 4c 24 78	 mov	 ecx, DWORD PTR tv378[rsp]
  0087b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0087f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv380[rsp]
  00887	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0088c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182233
  00893	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00898	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182234
  0089f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  008af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182235
  008b6	ba 1a 08 00 00	 mov	 edx, 2074		; 0000081aH
  008bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182236
  008c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  008c8	e9 90 fe ff ff	 jmp	 $enter_fastest_no_txf_loop$55
$LN36@s390_run_c:
$LN35@s390_run_c:
  008cd	33 c0		 xor	 eax, eax
  008cf	85 c0		 test	 eax, eax
  008d1	0f 85 fa fe ff
	ff		 jne	 $LN7@s390_run_c
$LN10@s390_run_c:

; 2075 :     EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );

  008d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  008df	e8 00 00 00 00	 call	 fetch_hw_noswap
  008e4	0f b7 c8	 movzx	 ecx, ax
  008e7	e8 00 00 00 00	 call	 _byteswap_ushort
  008ec	0f b7 c0	 movzx	 eax, ax
  008ef	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  008f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  008fc	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00904	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00907	33 c0		 xor	 eax, eax
  00909	85 c0		 test	 eax, eax
  0090b	75 ca		 jne	 SHORT $LN10@s390_run_c

; 2076 :     regs->instcount++;

  0090d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00912	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00918	ff c0		 inc	 eax
  0091a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0091f	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2077 :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  00925	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0092c	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  00932	ba 01 00 00 00	 mov	 edx, 1
  00937	48 8b c8	 mov	 rcx, rax
  0093a	e8 00 00 00 00	 call	 atomic_update64

; 2078 : 
; 2079 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)

  0093f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00947	eb 0a		 jmp	 SHORT $LN13@s390_run_c
$LN11@s390_run_c:
  00949	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0094d	ff c0		 inc	 eax
  0094f	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN13@s390_run_c:
  00953	81 7c 24 68 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  0095b	0f 8d aa 00 00
	00		 jge	 $LN12@s390_run_c

; 2080 :     {
; 2081 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  00961	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00966	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0096b	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00972	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00976	72 05		 jb	 SHORT $LN37@s390_run_c
  00978	e9 8e 00 00 00	 jmp	 $LN12@s390_run_c
$LN37@s390_run_c:
$LN16@s390_run_c:
  0097d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00982	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00986	e8 00 00 00 00	 call	 fetch_hw_noswap
  0098b	0f b7 c8	 movzx	 ecx, ax
  0098e	e8 00 00 00 00	 call	 _byteswap_ushort
  00993	0f b7 c0	 movzx	 eax, ax
  00996	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0099b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  009a0	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  009a4	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  009ac	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  009af	33 c0		 xor	 eax, eax
  009b1	85 c0		 test	 eax, eax
  009b3	75 c8		 jne	 SHORT $LN16@s390_run_c

; 2082 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  009b5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  009ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  009bf	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  009c6	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  009ca	72 02		 jb	 SHORT $LN38@s390_run_c
  009cc	eb 3d		 jmp	 SHORT $LN12@s390_run_c
$LN38@s390_run_c:
$LN19@s390_run_c:
  009ce	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  009d3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  009d7	e8 00 00 00 00	 call	 fetch_hw_noswap
  009dc	0f b7 c8	 movzx	 ecx, ax
  009df	e8 00 00 00 00	 call	 _byteswap_ushort
  009e4	0f b7 c0	 movzx	 eax, ax
  009e7	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  009ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  009f1	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  009f5	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  009fd	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00a00	33 c0		 xor	 eax, eax
  00a02	85 c0		 test	 eax, eax
  00a04	75 c8		 jne	 SHORT $LN19@s390_run_c

; 2083 :     }

  00a06	e9 3e ff ff ff	 jmp	 $LN11@s390_run_c
$LN12@s390_run_c:

; 2084 :     regs->instcount   +=     (i * 2);

  00a0b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00a10	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00a16	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  00a1a	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  00a1d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00a22	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2085 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  00a28	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a2c	d1 e0		 shl	 eax, 1
  00a2e	48 98		 cdqe
  00a30	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a37	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  00a3e	48 8b d0	 mov	 rdx, rax
  00a41	e8 00 00 00 00	 call	 atomic_update64

; 2086 : 
; 2087 :     /* Perform automatic instruction tracing if it's enabled */
; 2088 :     do_automatic_tracing();

  00a46	e8 00 00 00 00	 call	 do_automatic_tracing

; 2089 :     goto fastest_no_txf_loop;

  00a4b	e9 ed fc ff ff	 jmp	 $fastest_no_txf_loop$54
$LN1@s390_run_c:
$LN39@s390_run_c:

; 2090 : 
; 2091 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 2092 : 
; 2093 : txf_facility_loop:
; 2094 : 
; 2095 :     if (INTERRUPT_PENDING( regs ))
; 2096 :         ARCH_DEP( process_interrupt )( regs );
; 2097 : 
; 2098 :     if (regs->txf_tnd)
; 2099 :         goto enter_txf_slower_loop;
; 2100 : 
; 2101 : enter_txf_faster_loop:
; 2102 : 
; 2103 :     ip = INSTRUCTION_FETCH( regs, 0 );
; 2104 :     PROCESS_TRACE( regs, ip, enter_txf_faster_loop );
; 2105 :     EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );
; 2106 :     regs->instcount++;
; 2107 :     UPDATE_SYSBLK_INSTCOUNT( 1 );
; 2108 : 
; 2109 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 2110 :     {
; 2111 :         if (regs->txf_tnd)
; 2112 :             break;
; 2113 : 
; 2114 :         UNROLLED_EXECUTE( current_opcode_table, regs );
; 2115 : 
; 2116 :         if (regs->txf_tnd)
; 2117 :             break;
; 2118 : 
; 2119 :         UNROLLED_EXECUTE( current_opcode_table, regs );
; 2120 :     }
; 2121 :     regs->instcount   +=     (i * 2);
; 2122 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 2123 : 
; 2124 :     /* Perform automatic instruction tracing if it's enabled */
; 2125 :     do_automatic_tracing();
; 2126 : 
; 2127 : //txf_slower_loop:
; 2128 : 
; 2129 :     if (INTERRUPT_PENDING( regs ))
; 2130 :         ARCH_DEP( process_interrupt )( regs );
; 2131 : 
; 2132 :     if (!regs->txf_tnd)
; 2133 :         goto enter_txf_faster_loop;
; 2134 : 
; 2135 : enter_txf_slower_loop:
; 2136 : 
; 2137 :     ip = INSTRUCTION_FETCH( regs, 0 );
; 2138 :     PROCESS_TRACE( regs, ip, enter_txf_slower_loop );
; 2139 :     TXF_EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );
; 2140 :     regs->instcount++;
; 2141 :     UPDATE_SYSBLK_INSTCOUNT( 1 );
; 2142 : 
; 2143 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 2144 :     {
; 2145 :         if (!regs->txf_tnd)
; 2146 :             break;
; 2147 : 
; 2148 :         TXF_UNROLLED_EXECUTE( current_opcode_table, regs );
; 2149 : 
; 2150 :         if (!regs->txf_tnd)
; 2151 :             break;
; 2152 : 
; 2153 :         TXF_UNROLLED_EXECUTE( current_opcode_table, regs );
; 2154 :     }
; 2155 :     regs->instcount   +=     (i * 2);
; 2156 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 2157 : 
; 2158 :     /* Perform automatic instruction tracing if it's enabled */
; 2159 :     do_automatic_tracing();
; 2160 :     goto txf_facility_loop;
; 2161 : 
; 2162 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 2163 : 
; 2164 :     UNREACHABLE_CODE( return NULL );
; 2165 : 
; 2166 : } /* end function run_cpu */

  00a50	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a58	48 33 cc	 xor	 rcx, rsp
  00a5b	e8 00 00 00 00	 call	 __security_check_cookie
  00a60	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00a67	5f		 pop	 rdi
  00a68	5e		 pop	 rsi
  00a69	c3		 ret	 0
s390_run_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv91 = 80
tv154 = 84
tv167 = 88
tv206 = 92
tv294 = 96
tv411 = 100
tv258 = 104
tv361 = 108
tv260 = 112
saved_timer$1 = 120
tv363 = 128
buf$2 = 136
__$ArrayPad$ = 176
regs$ = 208
s390_process_interrupt PROC

; 1680 : {

$LN83:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1681 :     /* Process PER program interrupts */
; 1682 :     if( OPEN_IC_PER(regs) )

  0001e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00026	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00031	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00034	23 c1		 and	 eax, ecx
  00036	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0003b	85 c0		 test	 eax, eax
  0003d	74 1b		 je	 SHORT $LN35@s390_proce

; 1683 :         regs->program_interrupt (regs, PGM_PER_EVENT);

  0003f	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00044	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00054	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@s390_proce:

; 1684 : 
; 1685 :     /* Obtain the interrupt lock */
; 1686 :     OBTAIN_INTLOCK(regs);

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182098
  00061	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN4@s390_proce:

; 1687 :     OFF_IC_INTERRUPT(regs);

  0006e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00076	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00079	0f ba f0 1f	 btr	 eax, 31
  0007d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00088	33 c0		 xor	 eax, eax
  0008a	85 c0		 test	 eax, eax
  0008c	75 e0		 jne	 SHORT $LN4@s390_proce

; 1688 :     regs->breakortrace = (sysblk.instbreak || (sysblk.insttrace && regs->insttrace));

  0008e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00095	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0009b	c1 e8 0a	 shr	 eax, 10
  0009e	83 e0 01	 and	 eax, 1
  000a1	85 c0		 test	 eax, eax
  000a3	75 39		 jne	 SHORT $LN61@s390_proce
  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ac	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000b2	c1 e8 08	 shr	 eax, 8
  000b5	83 e0 01	 and	 eax, 1
  000b8	85 c0		 test	 eax, eax
  000ba	74 18		 je	 SHORT $LN60@s390_proce
  000bc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000ca	c1 e8 0f	 shr	 eax, 15
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	75 0a		 jne	 SHORT $LN61@s390_proce
$LN60@s390_proce:
  000d4	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000dc	eb 08		 jmp	 SHORT $LN62@s390_proce
$LN61@s390_proce:
  000de	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
$LN62@s390_proce:
  000e6	8b 44 24 50	 mov	 eax, DWORD PTR tv91[rsp]
  000ea	83 e0 01	 and	 eax, 1
  000ed	c1 e0 10	 shl	 eax, 16
  000f0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  000fe	0f ba f1 10	 btr	 ecx, 16
  00102	0b c8		 or	 ecx, eax
  00104	8b c1		 mov	 eax, ecx
  00106	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN7@s390_proce:

; 1689 : 
; 1690 :     /* Ensure psw.IA is set and invalidate the aia */
; 1691 :     INVALIDATE_AIA(regs);

  00114	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00124	74 61		 je	 SHORT $LN36@s390_proce
  00126	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00134	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00144	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0014b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0014f	48 2b ca	 sub	 rcx, rdx
  00152	48 03 c1	 add	 rax, rcx
  00155	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015d	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00163	48 23 c1	 and	 rax, rcx
  00166	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00174	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017c	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN36@s390_proce:
  00187	33 c0		 xor	 eax, eax
  00189	85 c0		 test	 eax, eax
  0018b	75 87		 jne	 SHORT $LN7@s390_proce

; 1692 : 
; 1693 :     /* Perform invalidation */
; 1694 :     if (unlikely(regs->invalidate))

  0018d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00195	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019b	c1 e8 0e	 shr	 eax, 14
  0019e	83 e0 01	 and	 eax, 1
  001a1	85 c0		 test	 eax, eax
  001a3	74 0a		 je	 SHORT $LN65@s390_proce
  001a5	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv154[rsp], 1
  001ad	eb 08		 jmp	 SHORT $LN66@s390_proce
$LN65@s390_proce:
  001af	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv154[rsp], 0
$LN66@s390_proce:
  001b7	83 7c 24 54 00	 cmp	 DWORD PTR tv154[rsp], 0
  001bc	74 1c		 je	 SHORT $LN37@s390_proce

; 1695 :         ARCH_DEP(invalidate_tlbe)(regs, regs->invalidate_main);

  001be	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c6	48 8b 90 00 09
	00 00		 mov	 rdx, QWORD PTR [rax+2304]
  001cd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	e8 00 00 00 00	 call	 s390_invalidate_tlbe
$LN37@s390_proce:

; 1696 : 
; 1697 :     /* Take interrupts if CPU is not stopped */
; 1698 :     if (likely(regs->cpustate == CPUSTATE_STARTED))

  001da	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e2	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  001e6	83 f8 01	 cmp	 eax, 1
  001e9	75 0a		 jne	 SHORT $LN69@s390_proce
  001eb	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  001f3	eb 08		 jmp	 SHORT $LN70@s390_proce
$LN69@s390_proce:
  001f5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN70@s390_proce:
  001fd	83 7c 24 58 00	 cmp	 DWORD PTR tv167[rsp], 0
  00202	0f 84 e5 00 00
	00		 je	 $LN38@s390_proce

; 1699 :     {
; 1700 :         /* Process machine check interrupt */
; 1701 :         if ( OPEN_IC_MCKPENDING(regs) )

  00208	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00210	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0021b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0021e	23 c1		 and	 eax, ecx
  00220	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00225	85 c0		 test	 eax, eax
  00227	74 16		 je	 SHORT $LN39@s390_proce

; 1702 :         {
; 1703 :             PERFORM_SERIALIZATION (regs);

  00229	0f ae f0	 mfence
$LN10@s390_proce:

; 1704 :             PERFORM_CHKPT_SYNC (regs);

  0022c	33 c0		 xor	 eax, eax
  0022e	85 c0		 test	 eax, eax
  00230	75 fa		 jne	 SHORT $LN10@s390_proce

; 1705 :             ARCH_DEP (perform_mck_interrupt) (regs);

  00232	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023a	e8 00 00 00 00	 call	 s390_perform_mck_interrupt
$LN39@s390_proce:

; 1706 :         }
; 1707 : 
; 1708 :         /* Process external interrupt */
; 1709 :         if (1
; 1710 :             && OPEN_IC_EXTPENDING( regs )

  0023f	33 c0		 xor	 eax, eax
  00241	83 f8 01	 cmp	 eax, 1
  00244	74 37		 je	 SHORT $LN40@s390_proce
  00246	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00259	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0025c	23 c1		 and	 eax, ecx
  0025e	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00263	85 c0		 test	 eax, eax
  00265	74 16		 je	 SHORT $LN40@s390_proce

; 1711 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1712 :             /* Don't interrupt active transaction */
; 1713 :             && (0
; 1714 :                 || regs->txf_tnd == 0
; 1715 :                 || regs->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1716 :                )
; 1717 : #endif
; 1718 :         )
; 1719 :         {
; 1720 :             PERFORM_SERIALIZATION( regs );

  00267	0f ae f0	 mfence
$LN13@s390_proce:

; 1721 :             PERFORM_CHKPT_SYNC( regs );

  0026a	33 c0		 xor	 eax, eax
  0026c	85 c0		 test	 eax, eax
  0026e	75 fa		 jne	 SHORT $LN13@s390_proce

; 1722 :             ARCH_DEP( perform_external_interrupt )( regs );

  00270	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00278	e8 00 00 00 00	 call	 s390_perform_external_interrupt
$LN40@s390_proce:

; 1723 :         }
; 1724 : 
; 1725 :         /* Process I/O interrupt */
; 1726 :         if (IS_IC_IOPENDING)

  0027d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00284	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0028a	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0028f	85 c0		 test	 eax, eax
  00291	74 5a		 je	 SHORT $LN41@s390_proce

; 1727 :         {
; 1728 :             if (1
; 1729 :                 && OPEN_IC_IOPENDING( regs )

  00293	33 c0		 xor	 eax, eax
  00295	83 f8 01	 cmp	 eax, 1
  00298	74 39		 je	 SHORT $LN42@s390_proce
  0029a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002aa	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  002ad	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002b0	23 c1		 and	 eax, ecx
  002b2	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002b7	85 c0		 test	 eax, eax
  002b9	74 18		 je	 SHORT $LN42@s390_proce

; 1730 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1731 :                 /* Don't interrupt active transaction */
; 1732 :                 && (0
; 1733 :                     || regs->txf_tnd == 0
; 1734 :                     || regs->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1735 :                    )
; 1736 : #endif
; 1737 :             )
; 1738 :             {
; 1739 :                 PERFORM_SERIALIZATION( regs );

  002bb	0f ae f0	 mfence
$LN16@s390_proce:

; 1740 :                 PERFORM_CHKPT_SYNC( regs );

  002be	33 c0		 xor	 eax, eax
  002c0	85 c0		 test	 eax, eax
  002c2	75 fa		 jne	 SHORT $LN16@s390_proce

; 1741 :                 ARCH_DEP( perform_io_interrupt )( regs );

  002c4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	e8 00 00 00 00	 call	 s390_perform_io_interrupt

; 1742 :             }

  002d1	eb 1a		 jmp	 SHORT $LN43@s390_proce
$LN42@s390_proce:

; 1743 :             else
; 1744 :                 WAKEUP_CPU_MASK(sysblk.waiting_mask);

  002d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182107
  002da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e1	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  002e8	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN43@s390_proce:
$LN41@s390_proce:
$LN38@s390_proce:

; 1745 :         }
; 1746 :     } /*CPU_STARTED*/
; 1747 : 
; 1748 :     /* If CPU is stopping, change status to stopped */
; 1749 :     if (unlikely(regs->cpustate == CPUSTATE_STOPPING))

  002ed	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f5	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  002f9	83 f8 02	 cmp	 eax, 2
  002fc	75 0a		 jne	 SHORT $LN73@s390_proce
  002fe	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv206[rsp], 1
  00306	eb 08		 jmp	 SHORT $LN74@s390_proce
$LN73@s390_proce:
  00308	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv206[rsp], 0
$LN74@s390_proce:
  00310	83 7c 24 5c 00	 cmp	 DWORD PTR tv206[rsp], 0
  00315	0f 84 28 02 00
	00		 je	 $LN44@s390_proce
$cpustate_stopping$84:

; 1750 :     {
; 1751 :         /* Change CPU status to stopped */
; 1752 : cpustate_stopping:
; 1753 :         regs->opinterv = 0;

  0031b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00323	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00329	83 e0 ef	 and	 eax, -17		; ffffffefH
  0032c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00334	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1754 :         regs->cpustate = CPUSTATE_STOPPED;

  0033a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00342	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3

; 1755 : 
; 1756 :         /* Thread exit (note - intlock still held) */
; 1757 :         if (!regs->configured)

  00346	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00354	c1 e8 0b	 shr	 eax, 11
  00357	83 e0 01	 and	 eax, 1
  0035a	85 c0		 test	 eax, eax
  0035c	75 1b		 jne	 SHORT $LN45@s390_proce

; 1758 :             longjmp(regs->exitjmp, SIE_NO_INTERCEPT);

  0035e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00366	48 05 80 0b 00
	00		 add	 rax, 2944		; 00000b80H
  0036c	ba ff ff ff ff	 mov	 edx, -1
  00371	48 8b c8	 mov	 rcx, rax
  00374	e8 00 00 00 00	 call	 longjmp
$LN45@s390_proce:

; 1759 : 
; 1760 :         /* If initial CPU reset pending then perform reset */
; 1761 :         if (regs->sigp_ini_reset)

  00379	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00381	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00387	c1 e8 14	 shr	 eax, 20
  0038a	83 e0 01	 and	 eax, 1
  0038d	85 c0		 test	 eax, eax
  0038f	74 45		 je	 SHORT $LN46@s390_proce

; 1762 :         {
; 1763 :             PERFORM_SERIALIZATION (regs);

  00391	0f ae f0	 mfence
$LN19@s390_proce:

; 1764 :             PERFORM_CHKPT_SYNC (regs);

  00394	33 c0		 xor	 eax, eax
  00396	85 c0		 test	 eax, eax
  00398	75 fa		 jne	 SHORT $LN19@s390_proce

; 1765 :             ARCH_DEP (initial_cpu_reset) (regs);

  0039a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a2	e8 00 00 00 00	 call	 s390_initial_cpu_reset

; 1766 :             RELEASE_INTLOCK(regs);

  003a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182111
  003ae	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b6	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1767 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  003bb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c3	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  003c9	ba ff ff ff ff	 mov	 edx, -1
  003ce	48 8b c8	 mov	 rcx, rax
  003d1	e8 00 00 00 00	 call	 longjmp
$LN46@s390_proce:

; 1768 :         }
; 1769 : 
; 1770 :         /* If a CPU reset is pending then perform the reset */
; 1771 :         if (regs->sigp_reset)

  003d6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003de	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003e4	c1 e8 13	 shr	 eax, 19
  003e7	83 e0 01	 and	 eax, 1
  003ea	85 c0		 test	 eax, eax
  003ec	74 45		 je	 SHORT $LN47@s390_proce

; 1772 :         {
; 1773 :             PERFORM_SERIALIZATION (regs);

  003ee	0f ae f0	 mfence
$LN22@s390_proce:

; 1774 :             PERFORM_CHKPT_SYNC (regs);

  003f1	33 c0		 xor	 eax, eax
  003f3	85 c0		 test	 eax, eax
  003f5	75 fa		 jne	 SHORT $LN22@s390_proce

; 1775 :             ARCH_DEP(cpu_reset) (regs);

  003f7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ff	e8 00 00 00 00	 call	 s390_cpu_reset

; 1776 :             RELEASE_INTLOCK(regs);

  00404	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182113
  0040b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00413	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1777 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  00418	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00420	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00426	ba ff ff ff ff	 mov	 edx, -1
  0042b	48 8b c8	 mov	 rcx, rax
  0042e	e8 00 00 00 00	 call	 longjmp
$LN47@s390_proce:

; 1778 :         }
; 1779 : 
; 1780 :         /* Store status at absolute location 0 if requested */
; 1781 :         if (IS_IC_STORSTAT(regs))

  00433	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0043e	83 e0 08	 and	 eax, 8
  00441	85 c0		 test	 eax, eax
  00443	0f 84 fa 00 00
	00		 je	 $LN48@s390_proce
$LN25@s390_proce:

; 1782 :         {
; 1783 :             OFF_IC_STORSTAT(regs);

  00449	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00451	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00454	83 e0 f7	 and	 eax, -9			; fffffff7H
  00457	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00462	33 c0		 xor	 eax, eax
  00464	85 c0		 test	 eax, eax
  00466	75 e1		 jne	 SHORT $LN25@s390_proce

; 1784 :             ARCH_DEP(store_status) (regs, 0);

  00468	33 d2		 xor	 edx, edx
  0046a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00472	e8 00 00 00 00	 call	 s390_store_status

; 1785 : 
; 1786 :             if (regs->insttrace && sysblk.traceFILE)

  00477	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00485	c1 e8 0f	 shr	 eax, 15
  00488	83 e0 01	 and	 eax, 1
  0048b	85 c0		 test	 eax, eax
  0048d	74 1f		 je	 SHORT $LN49@s390_proce
  0048f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00496	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0049e	74 0e		 je	 SHORT $LN49@s390_proce

; 1787 :                 tf_0808( regs );

  004a0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0808
$LN49@s390_proce:

; 1788 : 
; 1789 :             // "Processor %s%02X: store status completed"
; 1790 :             WRMSG( HHC00808, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  004ae	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b6	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  004bd	89 44 24 68	 mov	 DWORD PTR tv258[rsp], eax
  004c1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c9	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  004d0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004d7	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  004df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  004e5	48 89 44 24 70	 mov	 QWORD PTR tv260[rsp], rax
  004ea	b9 01 00 00 00	 mov	 ecx, 1
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004f5	8b 4c 24 68	 mov	 ecx, DWORD PTR tv258[rsp]
  004f9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004fd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv260[rsp]
  00502	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00507	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182116
  0050e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00513	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182117
  0051a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0051f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00524	41 b9 03 00 00
	00		 mov	 r9d, 3
  0052a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182118
  00531	ba fe 06 00 00	 mov	 edx, 1790		; 000006feH
  00536	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182119
  0053d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN48@s390_proce:
$LN44@s390_proce:

; 1791 : 
; 1792 :             /* ISW 20071102 : Do not return via longjmp here. */
; 1793 :             /*    process_interrupt needs to finish putting the */
; 1794 :             /*    CPU in its manual state                     */
; 1795 :             /*
; 1796 :             RELEASE_INTLOCK(regs);
; 1797 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);
; 1798 :             */
; 1799 :         }
; 1800 :     } /*CPUSTATE_STOPPING*/
; 1801 : 
; 1802 :     /* Perform restart interrupt if pending */
; 1803 :     if ( IS_IC_RESTART(regs) )

  00543	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0054e	83 e0 02	 and	 eax, 2
  00551	85 c0		 test	 eax, eax
  00553	74 35		 je	 SHORT $LN50@s390_proce

; 1804 :     {
; 1805 :         PERFORM_SERIALIZATION (regs);

  00555	0f ae f0	 mfence
$LN28@s390_proce:

; 1806 :         PERFORM_CHKPT_SYNC (regs);

  00558	33 c0		 xor	 eax, eax
  0055a	85 c0		 test	 eax, eax
  0055c	75 fa		 jne	 SHORT $LN28@s390_proce
$LN31@s390_proce:

; 1807 :         OFF_IC_RESTART(regs);

  0055e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00566	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00569	83 e0 fd	 and	 eax, -3			; fffffffdH
  0056c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00574	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00577	33 c0		 xor	 eax, eax
  00579	85 c0		 test	 eax, eax
  0057b	75 e1		 jne	 SHORT $LN31@s390_proce

; 1808 :         ARCH_DEP(restart_interrupt) (regs);

  0057d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00585	e8 00 00 00 00	 call	 s390_restart_interrupt
$LN50@s390_proce:

; 1809 :     } /* end if(restart) */
; 1810 : 
; 1811 :     /* This is where a stopped CPU will wait */
; 1812 :     if (unlikely(regs->cpustate == CPUSTATE_STOPPED))

  0058a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00592	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00596	83 f8 03	 cmp	 eax, 3
  00599	75 0a		 jne	 SHORT $LN77@s390_proce
  0059b	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv294[rsp], 1
  005a3	eb 08		 jmp	 SHORT $LN78@s390_proce
$LN77@s390_proce:
  005a5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv294[rsp], 0
$LN78@s390_proce:
  005ad	83 7c 24 60 00	 cmp	 DWORD PTR tv294[rsp], 0
  005b2	0f 84 59 01 00
	00		 je	 $LN51@s390_proce

; 1813 :     {
; 1814 :         S64 saved_timer = get_cpu_timer(regs);

  005b8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c0	e8 00 00 00 00	 call	 get_cpu_timer
  005c5	48 89 44 24 78	 mov	 QWORD PTR saved_timer$1[rsp], rax

; 1815 :         regs->ints_state = IC_INITIAL_STATE;

  005ca	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d2	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 1816 :         sysblk.started_mask ^= regs->cpubit;

  005d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005e0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  005ec	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  005f3	48 33 c1	 xor	 rax, rcx
  005f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005fd	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 1817 : 
; 1818 :         CPU_Wait(regs);

  00604	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060c	e8 00 00 00 00	 call	 CPU_Wait

; 1819 : 
; 1820 :         sysblk.started_mask |= regs->cpubit;

  00611	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00618	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00620	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00624	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0062b	48 0b c1	 or	 rax, rcx
  0062e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00635	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 1821 :         regs->ints_state |= sysblk.ints_state;

  0063c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00644	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0064b	8b 89 a0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4768]
  00651	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00654	0b c1		 or	 eax, ecx
  00656	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0065e	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1822 :         set_cpu_timer(regs,saved_timer);

  00661	48 8b 54 24 78	 mov	 rdx, QWORD PTR saved_timer$1[rsp]
  00666	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066e	e8 00 00 00 00	 call	 set_cpu_timer
$LN34@s390_proce:

; 1823 : 
; 1824 :         ON_IC_INTERRUPT(regs);

  00673	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0067e	0f ba e8 1f	 bts	 eax, 31
  00682	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068a	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0068d	33 c0		 xor	 eax, eax
  0068f	85 c0		 test	 eax, eax
  00691	75 e0		 jne	 SHORT $LN34@s390_proce

; 1825 : 
; 1826 :         /* Purge the lookaside buffers */
; 1827 :         ARCH_DEP(purge_tlb) (regs);

  00693	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0069b	e8 00 00 00 00	 call	 s390_purge_tlb

; 1828 : #if defined(FEATURE_ACCESS_REGISTERS)
; 1829 :         ARCH_DEP(purge_alb) (regs);

  006a0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a8	e8 00 00 00 00	 call	 s390_purge_alb

; 1830 : #endif /*defined(FEATURE_ACCESS_REGISTERS)*/
; 1831 : 
; 1832 :         /* If the architecture mode has changed we must adapt */
; 1833 :         if(sysblk.arch_mode != regs->arch_mode)

  006ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bc	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  006bf	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  006c5	74 1b		 je	 SHORT $LN52@s390_proce

; 1834 :             longjmp(regs->archjmp,SIE_NO_INTERCEPT);

  006c7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006cf	48 05 80 0a 00
	00		 add	 rax, 2688		; 00000a80H
  006d5	ba ff ff ff ff	 mov	 edx, -1
  006da	48 8b c8	 mov	 rcx, rax
  006dd	e8 00 00 00 00	 call	 longjmp
$LN52@s390_proce:

; 1835 : 
; 1836 :         RELEASE_INTLOCK(regs);

  006e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182123
  006e9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006f1	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1837 :         longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  006f6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fe	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00704	ba ff ff ff ff	 mov	 edx, -1
  00709	48 8b c8	 mov	 rcx, rax
  0070c	e8 00 00 00 00	 call	 longjmp
$LN51@s390_proce:

; 1838 :     } /*CPUSTATE_STOPPED*/
; 1839 : 
; 1840 :     /* Test for wait state */
; 1841 :     if (WAITSTATE(&regs->psw))

  00711	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00719	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0071d	83 e0 02	 and	 eax, 2
  00720	85 c0		 test	 eax, eax
  00722	0f 84 b7 02 00
	00		 je	 $LN53@s390_proce

; 1842 :     {
; 1843 :         regs->waittod = host_tod();

  00728	e8 00 00 00 00	 call	 host_tod
  0072d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00735	48 89 81 b8 07
	00 00		 mov	 QWORD PTR [rcx+1976], rax

; 1844 : 
; 1845 :         /* Test for disabled wait PSW and issue message */
; 1846 :         if (IS_IC_DISABLED_WAIT_PSW( regs ))

  0073c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00744	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00747	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  0074c	85 c0		 test	 eax, eax
  0074e	0f 85 7f 01 00
	00		 jne	 $LN54@s390_proce

; 1847 :         {
; 1848 :             /* Don't log the disabled wait when OSTAILOR VM is active
; 1849 :                unless it is the very last CPU in the configuration. */
; 1850 :             if (0
; 1851 :                 || !(sysblk.ostailor & OSTAILOR_VM)
; 1852 :                 || !(sysblk.started_mask ^ regs->cpubit)

  00754	33 c0		 xor	 eax, eax
  00756	85 c0		 test	 eax, eax
  00758	75 3c		 jne	 SHORT $LN56@s390_proce
  0075a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00761	8b 80 50 13 00
	00		 mov	 eax, DWORD PTR [rax+4944]
  00767	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  0076c	85 c0		 test	 eax, eax
  0076e	74 26		 je	 SHORT $LN56@s390_proce
  00770	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00777	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077f	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00783	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0078a	48 33 c1	 xor	 rax, rcx
  0078d	48 85 c0	 test	 rax, rax
  00790	0f 85 02 01 00
	00		 jne	 $LN55@s390_proce
$LN56@s390_proce:

; 1853 :             )
; 1854 :             {
; 1855 :                 char buf[40];
; 1856 :                 STR_PSW( regs, buf );

  00796	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  0079c	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$2[rsp]
  007a4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ac	e8 00 00 00 00	 call	 str_psw

; 1857 : 
; 1858 :                 if (regs->insttrace && sysblk.traceFILE)

  007b1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007bf	c1 e8 0f	 shr	 eax, 15
  007c2	83 e0 01	 and	 eax, 1
  007c5	85 c0		 test	 eax, eax
  007c7	74 27		 je	 SHORT $LN57@s390_proce
  007c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007d0	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  007d8	74 16		 je	 SHORT $LN57@s390_proce

; 1859 :                     tf_0809( regs, buf );

  007da	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$2[rsp]
  007e2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0809
$LN57@s390_proce:

; 1860 : 
; 1861 :                 // "Processor %s%02X: disabled wait state %s"
; 1862 :                 WRMSG( HHC00809, "I", PTYPSTR( regs->cpuad ),

  007f0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f8	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007ff	89 44 24 6c	 mov	 DWORD PTR tv361[rsp], eax
  00803	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080b	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00812	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00819	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00821	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00827	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv363[rsp], rax
  0082f	b9 01 00 00 00	 mov	 ecx, 1
  00834	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0083a	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  00842	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00847	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv361[rsp]
  0084b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0084f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv363[rsp]
  00857	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0085c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182129
  00863	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00868	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182130
  0086f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00874	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00879	41 b9 03 00 00
	00		 mov	 r9d, 3
  0087f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182131
  00886	ba 47 07 00 00	 mov	 edx, 1863		; 00000747H
  0088b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG182132
  00892	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@s390_proce:

; 1863 :                     regs->cpuad, buf );
; 1864 :             }
; 1865 :             regs->cpustate = CPUSTATE_STOPPING;

  00898	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a0	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2

; 1866 :             RELEASE_INTLOCK( regs );

  008a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182133
  008ab	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b3	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1867 :             longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  008b8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c0	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  008c6	ba ff ff ff ff	 mov	 edx, -1
  008cb	48 8b c8	 mov	 rcx, rax
  008ce	e8 00 00 00 00	 call	 longjmp
$LN54@s390_proce:

; 1868 :         }
; 1869 : 
; 1870 :         /* Indicate waiting and invoke CPU wait */
; 1871 :         sysblk.waiting_mask |= regs->cpubit;

  008d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008da	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  008e6	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  008ed	48 0b c1	 or	 rax, rcx
  008f0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008f7	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1872 :         CPU_Wait(regs);

  008fe	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00906	e8 00 00 00 00	 call	 CPU_Wait

; 1873 : 
; 1874 :         /* Turn off the waiting bit .
; 1875 :          *
; 1876 :          * Note: ANDing off of the CPU waiting bit, rather than using
; 1877 :          * XOR, is required to handle the remote and rare case when the
; 1878 :          * CPU is removed from the sysblk.waiting_mask while in
; 1879 :          * wait_condition (intlock is NOT held; use of XOR incorrectly
; 1880 :          * turns the CPU waiting bit back on).
; 1881 :          */
; 1882 :         sysblk.waiting_mask &= ~(regs->cpubit);

  0090b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00913	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00917	48 f7 d0	 not	 rax
  0091a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00921	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00928	48 23 c8	 and	 rcx, rax
  0092b	48 8b c1	 mov	 rax, rcx
  0092e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00935	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1883 : 
; 1884 :         /* Calculate the time we waited */
; 1885 :         regs->waittime += host_tod() - regs->waittod;

  0093c	e8 00 00 00 00	 call	 host_tod
  00941	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00949	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  00950	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00958	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  0095f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00967	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 1886 :         regs->waittod = 0;

  0096e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00976	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 1887 : 
; 1888 :         /* If late state change to stopping, go reprocess */
; 1889 :         if (unlikely(regs->cpustate == CPUSTATE_STOPPING))

  00981	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00989	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0098d	83 f8 02	 cmp	 eax, 2
  00990	75 0a		 jne	 SHORT $LN81@s390_proce
  00992	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv411[rsp], 1
  0099a	eb 08		 jmp	 SHORT $LN82@s390_proce
$LN81@s390_proce:
  0099c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv411[rsp], 0
$LN82@s390_proce:
  009a4	83 7c 24 64 00	 cmp	 DWORD PTR tv411[rsp], 0
  009a9	74 05		 je	 SHORT $LN58@s390_proce

; 1890 :             goto cpustate_stopping;

  009ab	e9 6b f9 ff ff	 jmp	 $cpustate_stopping$84
$LN58@s390_proce:

; 1891 : 
; 1892 :         RELEASE_INTLOCK(regs);

  009b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182135
  009b7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009bf	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1893 :         longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  009c4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009cc	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  009d2	ba ff ff ff ff	 mov	 edx, -1
  009d7	48 8b c8	 mov	 rcx, rax
  009da	e8 00 00 00 00	 call	 longjmp
$LN53@s390_proce:

; 1894 :     } /* end if(wait) */
; 1895 : 
; 1896 :     /* Release the interrupt lock */
; 1897 :     RELEASE_INTLOCK(regs);

  009df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182136
  009e6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ee	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN59@s390_proce:

; 1898 : 
; 1899 : } /* process_interrupt */

  009f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009fb	48 33 cc	 xor	 rcx, rsp
  009fe	e8 00 00 00 00	 call	 __security_check_cookie
  00a03	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00a0a	c3		 ret	 0
s390_process_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
rc$ = 80
tv134 = 84
xdmg$ = 88
tv401 = 92
psa$ = 96
mcic$ = 104
fsta$ = 112
tv403 = 120
regs$ = 144
s390_perform_mck_interrupt PROC

; 1601 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1602 : int     rc;                             /* Return code               */
; 1603 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1604 : U64     mcic;                           /* Mach.check interrupt code */
; 1605 : U32     xdmg;                           /* External damage code      */
; 1606 : RADR    fsta;                           /* Failing storage address   */
; 1607 : 
; 1608 :     /* Test and clear pending machine check interrupt */
; 1609 :     rc = ARCH_DEP(present_mck_interrupt) (regs, &mcic, &xdmg, &fsta);

  0000d	4c 8d 4c 24 70	 lea	 r9, QWORD PTR fsta$[rsp]
  00012	4c 8d 44 24 58	 lea	 r8, QWORD PTR xdmg$[rsp]
  00017	48 8d 54 24 68	 lea	 rdx, QWORD PTR mcic$[rsp]
  0001c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00024	e8 00 00 00 00	 call	 s390_present_mck_interrupt
  00029	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1610 : 
; 1611 :     /* Exit if no machine check was presented */
; 1612 :     if (rc == 0) return;

  0002d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00032	75 05		 jne	 SHORT $LN2@s390_perfo
  00034	e9 6a 09 00 00	 jmp	 $LN1@s390_perfo
$LN2@s390_perfo:

; 1613 : 
; 1614 :     /* Set the main storage reference and change bits */
; 1615 :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  00039	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00041	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00044	b2 06		 mov	 dl, 6
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 s390_or_storage_key

; 1616 : 
; 1617 :     /* Point to the PSA in main storage */
; 1618 :     psa = (void*)(regs->mainstor + regs->PX);

  0004d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00055	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00058	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00067	48 89 44 24 60	 mov	 QWORD PTR psa$[rsp], rax

; 1619 : 
; 1620 :     /* Store registers in machine check save area */
; 1621 :     ARCH_DEP(store_status) (regs, regs->PX);

  0006c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00077	8b d0		 mov	 edx, eax
  00079	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	e8 00 00 00 00	 call	 s390_store_status

; 1622 : 
; 1623 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1624 :     /* Set the extended logout area to zeros */
; 1625 :     memset(psa->storepsw, 0, 16);

  00086	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  0008b	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  00091	48 8b f8	 mov	 rdi, rax
  00094	33 c0		 xor	 eax, eax
  00096	b9 10 00 00 00	 mov	 ecx, 16
  0009b	f3 aa		 rep stosb

; 1626 : #endif
; 1627 : 
; 1628 :     /* Store the machine check interrupt code at PSA+232 */
; 1629 :     STORE_DW(psa->mckint, mcic);

  0009d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mcic$[rsp]
  000a2	e8 00 00 00 00	 call	 _byteswap_uint64
  000a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  000ac	48 81 c1 e8 00
	00 00		 add	 rcx, 232		; 000000e8H
  000b3	48 8b d0	 mov	 rdx, rax
  000b6	e8 00 00 00 00	 call	 store_dw_noswap

; 1630 : 
; 1631 :     /* Trace the machine check interrupt */
; 1632 :     if (CPU_STEPPING_OR_TRACING(regs, 0))

  000bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000c9	c1 e8 10	 shr	 eax, 16
  000cc	83 e0 01	 and	 eax, 1
  000cf	85 c0		 test	 eax, eax
  000d1	74 0a		 je	 SHORT $LN28@s390_perfo
  000d3	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000db	eb 08		 jmp	 SHORT $LN29@s390_perfo
$LN28@s390_perfo:
  000dd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN29@s390_perfo:
  000e5	83 7c 24 54 00	 cmp	 DWORD PTR tv134[rsp], 0
  000ea	0f 84 f5 07 00
	00		 je	 $LN3@s390_perfo
  000f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000fd	c1 e8 0a	 shr	 eax, 10
  00100	83 e0 01	 and	 eax, 1
  00103	85 c0		 test	 eax, eax
  00105	0f 84 55 03 00
	00		 je	 $LN5@s390_perfo
  0010b	33 c0		 xor	 eax, eax
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 2d 01 00
	00		 jne	 $LN6@s390_perfo
  00115	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00122	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00127	85 c0		 test	 eax, eax
  00129	0f 84 13 01 00
	00		 je	 $LN6@s390_perfo
  0012f	33 c0		 xor	 eax, eax
  00131	83 f8 01	 cmp	 eax, 1
  00134	0f 84 26 03 00
	00		 je	 $LN5@s390_perfo
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 37		 jne	 SHORT $LN7@s390_perfo
  00140	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00147	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0014d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00152	85 c0		 test	 eax, eax
  00154	74 21		 je	 SHORT $LN7@s390_perfo
  00156	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00165	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0016b	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00171	0f 85 e9 02 00
	00		 jne	 $LN5@s390_perfo
$LN7@s390_perfo:
  00177	33 c0		 xor	 eax, eax
  00179	85 c0		 test	 eax, eax
  0017b	75 37		 jne	 SHORT $LN8@s390_perfo
  0017d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00184	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0018a	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0018f	85 c0		 test	 eax, eax
  00191	74 21		 je	 SHORT $LN8@s390_perfo
  00193	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  001a8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  001ae	0f 8c ac 02 00
	00		 jl	 $LN5@s390_perfo
$LN8@s390_perfo:
  001b4	33 c0		 xor	 eax, eax
  001b6	85 c0		 test	 eax, eax
  001b8	0f 85 84 00 00
	00		 jne	 $LN9@s390_perfo
  001be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c5	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  001cb	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001d0	85 c0		 test	 eax, eax
  001d2	74 26		 je	 SHORT $LN10@s390_perfo
  001d4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  001e3	85 c0		 test	 eax, eax
  001e5	74 13		 je	 SHORT $LN10@s390_perfo
  001e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001f6	85 c0		 test	 eax, eax
  001f8	75 48		 jne	 SHORT $LN9@s390_perfo
$LN10@s390_perfo:
  001fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00201	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00207	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0020c	85 c0		 test	 eax, eax
  0020e	0f 84 4c 02 00
	00		 je	 $LN5@s390_perfo
  00214	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00223	85 c0		 test	 eax, eax
  00225	0f 84 35 02 00
	00		 je	 $LN5@s390_perfo
  0022b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0023a	85 c0		 test	 eax, eax
  0023c	0f 85 1e 02 00
	00		 jne	 $LN5@s390_perfo
$LN9@s390_perfo:
$LN6@s390_perfo:
  00242	b8 08 00 00 00	 mov	 eax, 8
  00247	48 6b c0 00	 imul	 rax, rax, 0
  0024b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00252	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0025b	75 1f		 jne	 SHORT $LN11@s390_perfo
  0025d	b8 08 00 00 00	 mov	 eax, 8
  00262	48 6b c0 01	 imul	 rax, rax, 1
  00266	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0026d	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00276	0f 84 7f 05 00
	00		 je	 $LN4@s390_perfo
$LN11@s390_perfo:
  0027c	b8 08 00 00 00	 mov	 eax, 8
  00281	48 6b c0 00	 imul	 rax, rax, 0
  00285	b9 08 00 00 00	 mov	 ecx, 8
  0028a	48 6b c9 01	 imul	 rcx, rcx, 1
  0028e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00295	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  0029c	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  002a4	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  002ac	0f 87 bc 00 00
	00		 ja	 $LN12@s390_perfo
  002b2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ba	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  002c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d0	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  002d7	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002db	48 2b ca	 sub	 rcx, rdx
  002de	48 03 c1	 add	 rax, rcx
  002e1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  002ef	48 23 c1	 and	 rax, rcx
  002f2	8b c0		 mov	 eax, eax
  002f4	b9 08 00 00 00	 mov	 ecx, 8
  002f9	48 6b c9 00	 imul	 rcx, rcx, 0
  002fd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00304	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0030c	72 60		 jb	 SHORT $LN12@s390_perfo
  0030e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00316	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0031c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00324	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0032c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00333	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00337	48 2b ca	 sub	 rcx, rdx
  0033a	48 03 c1	 add	 rax, rcx
  0033d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00345	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0034b	48 23 c1	 and	 rax, rcx
  0034e	8b c0		 mov	 eax, eax
  00350	b9 08 00 00 00	 mov	 ecx, 8
  00355	48 6b c9 01	 imul	 rcx, rcx, 1
  00359	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00360	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00368	0f 86 8d 04 00
	00		 jbe	 $LN4@s390_perfo
$LN12@s390_perfo:
  0036e	b8 08 00 00 00	 mov	 eax, 8
  00373	48 6b c0 00	 imul	 rax, rax, 0
  00377	b9 08 00 00 00	 mov	 ecx, 8
  0037c	48 6b c9 01	 imul	 rcx, rcx, 1
  00380	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00387	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  0038e	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  00396	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  0039e	0f 86 bc 00 00
	00		 jbe	 $LN13@s390_perfo
  003a4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ac	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  003b2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ba	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003c2	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003c9	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003cd	48 2b ca	 sub	 rcx, rdx
  003d0	48 03 c1	 add	 rax, rcx
  003d3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003db	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  003e1	48 23 c1	 and	 rax, rcx
  003e4	8b c0		 mov	 eax, eax
  003e6	b9 08 00 00 00	 mov	 ecx, 8
  003eb	48 6b c9 01	 imul	 rcx, rcx, 1
  003ef	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003f6	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  003fe	72 60		 jb	 SHORT $LN13@s390_perfo
  00400	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00408	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0040e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00416	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0041e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00425	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00429	48 2b ca	 sub	 rcx, rdx
  0042c	48 03 c1	 add	 rax, rcx
  0042f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00437	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0043d	48 23 c1	 and	 rax, rcx
  00440	8b c0		 mov	 eax, eax
  00442	b9 08 00 00 00	 mov	 ecx, 8
  00447	48 6b c9 00	 imul	 rcx, rcx, 0
  0044b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00452	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0045a	0f 86 9b 03 00
	00		 jbe	 $LN4@s390_perfo
$LN13@s390_perfo:
$LN5@s390_perfo:
  00460	33 c0		 xor	 eax, eax
  00462	83 f8 01	 cmp	 eax, 1
  00465	0f 84 7a 04 00
	00		 je	 $LN3@s390_perfo
  0046b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00472	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00478	c1 e8 08	 shr	 eax, 8
  0047b	83 e0 01	 and	 eax, 1
  0047e	85 c0		 test	 eax, eax
  00480	0f 84 5f 04 00
	00		 je	 $LN3@s390_perfo
  00486	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00494	c1 e8 0f	 shr	 eax, 15
  00497	83 e0 01	 and	 eax, 1
  0049a	85 c0		 test	 eax, eax
  0049c	0f 84 43 04 00
	00		 je	 $LN3@s390_perfo
  004a2	33 c0		 xor	 eax, eax
  004a4	85 c0		 test	 eax, eax
  004a6	0f 85 2d 01 00
	00		 jne	 $LN14@s390_perfo
  004ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004b3	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  004b9	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  004be	85 c0		 test	 eax, eax
  004c0	0f 84 13 01 00
	00		 je	 $LN14@s390_perfo
  004c6	33 c0		 xor	 eax, eax
  004c8	83 f8 01	 cmp	 eax, 1
  004cb	0f 84 14 04 00
	00		 je	 $LN3@s390_perfo
  004d1	33 c0		 xor	 eax, eax
  004d3	85 c0		 test	 eax, eax
  004d5	75 37		 jne	 SHORT $LN15@s390_perfo
  004d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004de	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  004e4	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  004e9	85 c0		 test	 eax, eax
  004eb	74 21		 je	 SHORT $LN15@s390_perfo
  004ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004fc	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00502	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00508	0f 85 d7 03 00
	00		 jne	 $LN3@s390_perfo
$LN15@s390_perfo:
  0050e	33 c0		 xor	 eax, eax
  00510	85 c0		 test	 eax, eax
  00512	75 37		 jne	 SHORT $LN16@s390_perfo
  00514	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0051b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00521	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00526	85 c0		 test	 eax, eax
  00528	74 21		 je	 SHORT $LN16@s390_perfo
  0052a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00532	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00539	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  0053f	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00545	0f 8c 9a 03 00
	00		 jl	 $LN3@s390_perfo
$LN16@s390_perfo:
  0054b	33 c0		 xor	 eax, eax
  0054d	85 c0		 test	 eax, eax
  0054f	0f 85 84 00 00
	00		 jne	 $LN17@s390_perfo
  00555	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0055c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00562	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00567	85 c0		 test	 eax, eax
  00569	74 26		 je	 SHORT $LN18@s390_perfo
  0056b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00573	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0057a	85 c0		 test	 eax, eax
  0057c	74 13		 je	 SHORT $LN18@s390_perfo
  0057e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00586	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0058d	85 c0		 test	 eax, eax
  0058f	75 48		 jne	 SHORT $LN17@s390_perfo
$LN18@s390_perfo:
  00591	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00598	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0059e	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  005a3	85 c0		 test	 eax, eax
  005a5	0f 84 3a 03 00
	00		 je	 $LN3@s390_perfo
  005ab	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b3	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  005ba	85 c0		 test	 eax, eax
  005bc	0f 84 23 03 00
	00		 je	 $LN3@s390_perfo
  005c2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ca	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  005d1	85 c0		 test	 eax, eax
  005d3	0f 85 0c 03 00
	00		 jne	 $LN3@s390_perfo
$LN17@s390_perfo:
$LN14@s390_perfo:
  005d9	b8 08 00 00 00	 mov	 eax, 8
  005de	48 6b c0 00	 imul	 rax, rax, 0
  005e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005e9	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  005f2	75 1f		 jne	 SHORT $LN20@s390_perfo
  005f4	b8 08 00 00 00	 mov	 eax, 8
  005f9	48 6b c0 01	 imul	 rax, rax, 1
  005fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00604	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0060d	0f 84 e8 01 00
	00		 je	 $LN19@s390_perfo
$LN20@s390_perfo:
  00613	b8 08 00 00 00	 mov	 eax, 8
  00618	48 6b c0 00	 imul	 rax, rax, 0
  0061c	b9 08 00 00 00	 mov	 ecx, 8
  00621	48 6b c9 01	 imul	 rcx, rcx, 1
  00625	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0062c	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00633	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  0063b	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  00643	0f 87 bc 00 00
	00		 ja	 $LN21@s390_perfo
  00649	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00651	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00657	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0065f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00667	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0066e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00672	48 2b ca	 sub	 rcx, rdx
  00675	48 03 c1	 add	 rax, rcx
  00678	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00680	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00686	48 23 c1	 and	 rax, rcx
  00689	8b c0		 mov	 eax, eax
  0068b	b9 08 00 00 00	 mov	 ecx, 8
  00690	48 6b c9 00	 imul	 rcx, rcx, 0
  00694	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0069b	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  006a3	72 60		 jb	 SHORT $LN21@s390_perfo
  006a5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ad	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  006b3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006c3	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  006ca	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  006ce	48 2b ca	 sub	 rcx, rdx
  006d1	48 03 c1	 add	 rax, rcx
  006d4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006dc	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  006e2	48 23 c1	 and	 rax, rcx
  006e5	8b c0		 mov	 eax, eax
  006e7	b9 08 00 00 00	 mov	 ecx, 8
  006ec	48 6b c9 01	 imul	 rcx, rcx, 1
  006f0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006f7	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  006ff	0f 86 f6 00 00
	00		 jbe	 $LN19@s390_perfo
$LN21@s390_perfo:
  00705	b8 08 00 00 00	 mov	 eax, 8
  0070a	48 6b c0 00	 imul	 rax, rax, 0
  0070e	b9 08 00 00 00	 mov	 ecx, 8
  00713	48 6b c9 01	 imul	 rcx, rcx, 1
  00717	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0071e	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00725	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  0072d	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  00735	0f 86 aa 01 00
	00		 jbe	 $LN3@s390_perfo
  0073b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00743	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00749	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00751	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00759	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00760	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00764	48 2b ca	 sub	 rcx, rdx
  00767	48 03 c1	 add	 rax, rcx
  0076a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00772	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00778	48 23 c1	 and	 rax, rcx
  0077b	8b c0		 mov	 eax, eax
  0077d	b9 08 00 00 00	 mov	 ecx, 8
  00782	48 6b c9 01	 imul	 rcx, rcx, 1
  00786	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0078d	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00795	0f 82 4a 01 00
	00		 jb	 $LN3@s390_perfo
  0079b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a3	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  007a9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b1	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007b9	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  007c0	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  007c4	48 2b ca	 sub	 rcx, rdx
  007c7	48 03 c1	 add	 rax, rcx
  007ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007d2	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  007d8	48 23 c1	 and	 rax, rcx
  007db	8b c0		 mov	 eax, eax
  007dd	b9 08 00 00 00	 mov	 ecx, 8
  007e2	48 6b c9 00	 imul	 rcx, rcx, 0
  007e6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007ed	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  007f5	0f 87 ea 00 00
	00		 ja	 $LN3@s390_perfo
$LN19@s390_perfo:
$LN4@s390_perfo:

; 1633 :     {
; 1634 :         if (regs->insttrace && sysblk.traceFILE)

  007fb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00803	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00809	c1 e8 0f	 shr	 eax, 15
  0080c	83 e0 01	 and	 eax, 1
  0080f	85 c0		 test	 eax, eax
  00811	74 33		 je	 SHORT $LN22@s390_perfo
  00813	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0081a	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00822	74 22		 je	 SHORT $LN22@s390_perfo

; 1635 :             tf_0807( regs, mcic, fsta, xdmg );

  00824	44 8b 4c 24 58	 mov	 r9d, DWORD PTR xdmg$[rsp]
  00829	4c 8b 44 24 70	 mov	 r8, QWORD PTR fsta$[rsp]
  0082e	48 8b 54 24 68	 mov	 rdx, QWORD PTR mcic$[rsp]
  00833	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0083b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0807
  00841	e9 9f 00 00 00	 jmp	 $LN23@s390_perfo
$LN22@s390_perfo:

; 1636 :         else
; 1637 :             // "Processor %s%02X: machine check code %16.16"PRIu64
; 1638 :             WRMSG (HHC00807, "I", PTYPSTR(regs->cpuad), regs->cpuad, mcic);

  00846	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0084e	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00855	89 44 24 5c	 mov	 DWORD PTR tv401[rsp], eax
  00859	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00861	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00868	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0086f	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00877	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0087d	48 89 44 24 78	 mov	 QWORD PTR tv403[rsp], rax
  00882	b9 01 00 00 00	 mov	 ecx, 1
  00887	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0088d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mcic$[rsp]
  00892	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00897	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv401[rsp]
  0089b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0089f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv403[rsp]
  008a4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181991
  008b0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181992
  008bc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008c1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c6	41 b9 03 00 00
	00		 mov	 r9d, 3
  008cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181993
  008d3	ba 66 06 00 00	 mov	 edx, 1638		; 00000666H
  008d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181994
  008df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@s390_perfo:
$LN3@s390_perfo:

; 1639 :     }
; 1640 : 
; 1641 :     /* Store the external damage code at PSA+244 */
; 1642 :     STORE_FW(psa->xdmgcode, xdmg);

  008e5	8b 4c 24 58	 mov	 ecx, DWORD PTR xdmg$[rsp]
  008e9	e8 00 00 00 00	 call	 _byteswap_ulong
  008ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  008f3	48 81 c1 f4 00
	00 00		 add	 rcx, 244		; 000000f4H
  008fa	8b d0		 mov	 edx, eax
  008fc	e8 00 00 00 00	 call	 store_fw_noswap

; 1643 : 
; 1644 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1645 :     /* Store the failing storage address at PSA+248 */
; 1646 :     STORE_DW(psa->mcstorad, fsta);
; 1647 : #else
; 1648 :     /* Store the failing storage address at PSA+248 */
; 1649 :     STORE_FW(psa->mcstorad, fsta);

  00901	8b 4c 24 70	 mov	 ecx, DWORD PTR fsta$[rsp]
  00905	e8 00 00 00 00	 call	 _byteswap_ulong
  0090a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  0090f	48 81 c1 f8 00
	00 00		 add	 rcx, 248		; 000000f8H
  00916	8b d0		 mov	 edx, eax
  00918	e8 00 00 00 00	 call	 store_fw_noswap

; 1650 : #endif
; 1651 : 
; 1652 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1653 :     /* Abort any active transaction and then return back to here
; 1654 :        to continue with machine check interrupt processing */
; 1655 :     if (regs->txf_tnd)
; 1656 :     {
; 1657 :         PTT_TXF( "*TXF MCK", 0, regs->txf_contran, regs->txf_tnd );
; 1658 :         regs->txf_why |= TXF_WHY_MCK_INT;
; 1659 :         ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_MCK );
; 1660 :     }
; 1661 : #endif
; 1662 :     /* Store current PSW at PSA+X'30' */
; 1663 :     ARCH_DEP(store_psw) ( regs, psa->mckold );

  0091d	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  00922	48 83 c0 30	 add	 rax, 48			; 00000030H
  00926	48 8b d0	 mov	 rdx, rax
  00929	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00931	e8 00 00 00 00	 call	 s390_store_psw

; 1664 : 
; 1665 :     /* Load new PSW from PSA+X'70' */
; 1666 :     rc = ARCH_DEP(load_psw) ( regs, psa->mcknew );

  00936	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  0093b	48 83 c0 70	 add	 rax, 112		; 00000070H
  0093f	48 8b d0	 mov	 rdx, rax
  00942	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0094a	e8 00 00 00 00	 call	 s390_load_psw
  0094f	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1667 : 
; 1668 :     RELEASE_INTLOCK(regs);

  00953	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181995
  0095a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00962	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1669 : 
; 1670 :     if ( rc )

  00967	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0096c	74 1a		 je	 SHORT $LN24@s390_perfo

; 1671 :         regs->program_interrupt (regs, rc);

  0096e	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  00972	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0097a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00982	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@s390_perfo:

; 1672 : 
; 1673 :     longjmp (regs->progjmp, SIE_INTERCEPT_MCK);

  00988	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00990	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00996	ba f5 ff ff ff	 mov	 edx, -11
  0099b	48 8b c8	 mov	 rcx, rax
  0099e	e8 00 00 00 00	 call	 longjmp
$LN1@s390_perfo:
$LN25@s390_perfo:

; 1674 : } /* end function perform_mck_interrupt */

  009a3	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  009aa	5f		 pop	 rdi
  009ab	c3		 ret	 0
s390_perform_mck_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
rc$ = 64
psa$ = 72
regs$ = 96
s390_restart_interrupt PROC

; 1408 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@s390_resta:

; 1409 : int     rc;                             /* Return code               */
; 1410 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1411 : 
; 1412 :     PTT_INF("*RESTART",regs->cpuad,regs->cpustate,regs->psw.IA_L);

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 83 e0 08	 and	 rax, 8
  00017	48 85 c0	 test	 rax, rax
  0001a	74 52		 je	 SHORT $LN5@s390_resta
  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	0f b6 49 60	 movzx	 ecx, BYTE PTR [rcx+96]
  00030	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00035	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  0003c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00045	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181846
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	44 8b c9	 mov	 r9d, ecx
  00059	44 8b c2	 mov	 r8d, edx
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181847
  00063	b9 08 00 00 00	 mov	 ecx, 8
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN5@s390_resta:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 95		 jne	 SHORT $LN4@s390_resta

; 1413 : 
; 1414 :     /* Set the main storage reference and change bits */
; 1415 :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00079	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007c	b2 06		 mov	 dl, 6
  0007e	8b c8		 mov	 ecx, eax
  00080	e8 00 00 00 00	 call	 s390_or_storage_key

; 1416 : 
; 1417 :     /* Zeroize the interrupt code in the PSW */
; 1418 :     regs->psw.intcode = 0;

  00085	33 c0		 xor	 eax, eax
  00087	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 1419 : 
; 1420 :     /* Point to PSA in main storage */
; 1421 :     psa = (PSA*)(regs->mainstor + regs->PX);

  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00098	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  000a7	48 89 44 24 48	 mov	 QWORD PTR psa$[rsp], rax

; 1422 : 
; 1423 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1424 :     /* Abort any active transaction and then return back to here
; 1425 :        to continue with restart interrupt processing */
; 1426 :     if (regs->txf_tnd)
; 1427 :     {
; 1428 :         PTT_TXF( "*TXF MISC", 0, regs->txf_contran, regs->txf_tnd );
; 1429 :         regs->txf_why |= TXF_WHY_RESTART_INT;
; 1430 :         ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_MISC );
; 1431 :     }
; 1432 : #endif
; 1433 :     /* Store current PSW at PSA+X'8' or PSA+X'120' for ESAME  */
; 1434 :     ARCH_DEP(store_psw) (regs, psa->RSTOLD);

  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  000b1	48 83 c0 08	 add	 rax, 8
  000b5	48 8b d0	 mov	 rdx, rax
  000b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000bd	e8 00 00 00 00	 call	 s390_store_psw

; 1435 : 
; 1436 :     /* Load new PSW from PSA+X'0' or PSA+X'1A0' for ESAME */
; 1437 :     rc = ARCH_DEP(load_psw) (regs, psa->RSTNEW);

  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  000c7	48 8b d0	 mov	 rdx, rax
  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	e8 00 00 00 00	 call	 s390_load_psw
  000d4	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 1438 : 
; 1439 :     if ( rc == 0)

  000d8	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000dd	75 22		 jne	 SHORT $LN6@s390_resta

; 1440 :     {
; 1441 :         regs->opinterv = 0;

  000df	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000ea	83 e0 ef	 and	 eax, -17		; ffffffefH
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1442 :         regs->cpustate = CPUSTATE_STARTED;

  000f8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1
$LN6@s390_resta:

; 1443 :     }
; 1444 : 
; 1445 :     RELEASE_INTLOCK(regs);

  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181849
  00108	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1446 : 
; 1447 :     if ( rc )

  00112	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00117	74 14		 je	 SHORT $LN7@s390_resta

; 1448 :         regs->program_interrupt(regs, rc);

  00119	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  0011d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00127	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN7@s390_resta:

; 1449 : 
; 1450 :     longjmp (regs->progjmp, SIE_INTERCEPT_RESTART);

  0012d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00132	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00138	ba f6 ff ff ff	 mov	 edx, -10
  0013d	48 8b c8	 mov	 rcx, rax
  00140	e8 00 00 00 00	 call	 longjmp
$LN8@s390_resta:

; 1451 : } /* end function restart_interrupt */

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	c3		 ret	 0
s390_restart_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 52
ip$ = 56
offset$ = 64
len$ = 68
tv78 = 72
tv80 = 76
tv133 = 80
tv135 = 84
tv142 = 88
tv161 = 92
tv177 = 96
tv179 = 100
tv185 = 104
tv192 = 108
tv210 = 112
tv251 = 116
tv250 = 120
tv252 = 124
tv310 = 128
tv311 = 132
dest$ = 136
tv317 = 144
regs$ = 176
exec$ = 184
s390_instfetch PROC					; COMDAT

; 777  : {

$LN76:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 14		 je	 SHORT $LN36@s390_instf
  0001a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  00028	89 44 24 4c	 mov	 DWORD PTR tv80[rsp], eax
  0002c	eb 72		 jmp	 SHORT $LN37@s390_instf
$LN36@s390_instf:
  0002e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0003e	74 46		 je	 SHORT $LN34@s390_instf
  00040	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0004e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0005e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00065	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00069	48 2b ca	 sub	 rcx, rdx
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0007d	48 23 c1	 and	 rax, rcx
  00080	89 44 24 48	 mov	 DWORD PTR tv78[rsp], eax
  00084	eb 12		 jmp	 SHORT $LN35@s390_instf
$LN34@s390_instf:
  00086	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00094	89 44 24 48	 mov	 DWORD PTR tv78[rsp], eax
$LN35@s390_instf:
  00098	8b 44 24 48	 mov	 eax, DWORD PTR tv78[rsp]
  0009c	89 44 24 4c	 mov	 DWORD PTR tv80[rsp], eax
$LN37@s390_instf:
  000a0	8b 44 24 4c	 mov	 eax, DWORD PTR tv80[rsp]
  000a4	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  000a8	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000b0	75 66		 jne	 SHORT $LN14@s390_instf
$LN4@s390_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000c2	74 4e		 je	 SHORT $LN15@s390_instf
  000c4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cc	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000d2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000da	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000e2	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  000e9	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000ed	48 2b ca	 sub	 rcx, rdx
  000f0	48 03 c1	 add	 rax, rcx
  000f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fb	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00101	48 23 c1	 and	 rax, rcx
  00104	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN15@s390_instf:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 9a		 jne	 SHORT $LN4@s390_instf
$LN14@s390_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  00118	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  0011c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00121	89 44 24 40	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  00125	81 7c 24 30 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  0012d	73 0a		 jae	 SHORT $LN40@s390_instf
  0012f	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  00137	eb 08		 jmp	 SHORT $LN41@s390_instf
$LN40@s390_instf:
  00139	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN41@s390_instf:
  00141	83 7c 24 50 00	 cmp	 DWORD PTR tv133[rsp], 0
  00146	74 0a		 je	 SHORT $LN42@s390_instf
  00148	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv135[rsp], 2048 ; 00000800H
  00150	eb 08		 jmp	 SHORT $LN43@s390_instf
$LN42@s390_instf:
  00152	c7 44 24 54 00
	10 00 00	 mov	 DWORD PTR tv135[rsp], 4096 ; 00001000H
$LN43@s390_instf:
  0015a	8b 44 24 54	 mov	 eax, DWORD PTR tv135[rsp]
  0015e	89 44 24 34	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  00162	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  00166	83 e0 01	 and	 eax, 1
  00169	85 c0		 test	 eax, eax
  0016b	74 0a		 je	 SHORT $LN46@s390_instf
  0016d	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  00175	eb 08		 jmp	 SHORT $LN47@s390_instf
$LN46@s390_instf:
  00177	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN47@s390_instf:
  0017f	83 7c 24 58 00	 cmp	 DWORD PTR tv142[rsp], 0
  00184	74 44		 je	 SHORT $LN16@s390_instf

; 798  :     {
; 799  :         if (!exec)

  00186	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0018e	75 1f		 jne	 SHORT $LN17@s390_instf

; 800  :             regs->instinvalid = 1;

  00190	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00198	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019e	83 c8 08	 or	 eax, 8
  001a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN17@s390_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  001af	ba 06 00 00 00	 mov	 edx, 6
  001b4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s390_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001ca	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001d8	c1 e8 02	 shr	 eax, 2
  001db	83 e0 01	 and	 eax, 1
  001de	85 c0		 test	 eax, eax
  001e0	74 0a		 je	 SHORT $LN50@s390_instf
  001e2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  001ea	eb 08		 jmp	 SHORT $LN51@s390_instf
$LN50@s390_instf:
  001ec	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN51@s390_instf:
  001f4	83 7c 24 5c 00	 cmp	 DWORD PTR tv161[rsp], 0
  001f9	0f 84 72 03 00
	00		 je	 $LN18@s390_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */

  001ff	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00207	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0020b	83 e0 04	 and	 eax, 4
  0020e	85 c0		 test	 eax, eax
  00210	74 0a		 je	 SHORT $LN52@s390_instf
  00212	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv177[rsp], 1
  0021a	eb 08		 jmp	 SHORT $LN53@s390_instf
$LN52@s390_instf:
  0021c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN53@s390_instf:
  00224	83 7c 24 60 00	 cmp	 DWORD PTR tv177[rsp], 0
  00229	74 0a		 je	 SHORT $LN54@s390_instf
  0022b	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv179[rsp], 16
  00233	eb 08		 jmp	 SHORT $LN55@s390_instf
$LN54@s390_instf:
  00235	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN55@s390_instf:
  0023d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00245	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00249	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0024e	85 c0		 test	 eax, eax
  00250	74 0a		 je	 SHORT $LN56@s390_instf
  00252	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv185[rsp], 1
  0025a	eb 08		 jmp	 SHORT $LN57@s390_instf
$LN56@s390_instf:
  0025c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN57@s390_instf:
  00264	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00270	83 e0 40	 and	 eax, 64			; 00000040H
  00273	85 c0		 test	 eax, eax
  00275	74 0a		 je	 SHORT $LN58@s390_instf
  00277	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  0027f	eb 08		 jmp	 SHORT $LN59@s390_instf
$LN58@s390_instf:
  00281	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN59@s390_instf:
  00289	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00297	83 e0 01	 and	 eax, 1
  0029a	c1 e0 07	 shl	 eax, 7
  0029d	83 c8 40	 or	 eax, 64			; 00000040H
  002a0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a8	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  002ae	d1 e9		 shr	 ecx, 1
  002b0	83 e1 01	 and	 ecx, 1
  002b3	c1 e1 05	 shl	 ecx, 5
  002b6	0b c1		 or	 eax, ecx
  002b8	0b 44 24 64	 or	 eax, DWORD PTR tv179[rsp]
  002bc	8b 4c 24 68	 mov	 ecx, DWORD PTR tv185[rsp]
  002c0	c1 e1 03	 shl	 ecx, 3
  002c3	0b c1		 or	 eax, ecx
  002c5	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv192[rsp]
  002c9	c1 e1 02	 shl	 ecx, 2
  002cc	0b c1		 or	 eax, ecx
  002ce	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;
; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  002dd	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  002e5	75 13		 jne	 SHORT $LN19@s390_instf

; 822  :             regs->peradr = addr;

  002e7	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  002eb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f3	48 89 81 d8 08
	00 00		 mov	 QWORD PTR [rcx+2264], rax
$LN19@s390_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  002fa	33 c0		 xor	 eax, eax
  002fc	83 f8 01	 cmp	 eax, 1
  002ff	0f 84 6e 01 00
	00		 je	 $LN20@s390_instf
  00305	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00313	c1 e8 02	 shr	 eax, 2
  00316	83 e0 01	 and	 eax, 1
  00319	85 c0		 test	 eax, eax
  0031b	74 0a		 je	 SHORT $LN62@s390_instf
  0031d	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv210[rsp], 1
  00325	eb 08		 jmp	 SHORT $LN63@s390_instf
$LN62@s390_instf:
  00327	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv210[rsp], 0
$LN63@s390_instf:
  0032f	83 7c 24 70 00	 cmp	 DWORD PTR tv210[rsp], 0
  00334	0f 84 39 01 00
	00		 je	 $LN20@s390_instf
  0033a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00342	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00345	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  0034a	85 c0		 test	 eax, eax
  0034c	0f 84 21 01 00
	00		 je	 $LN20@s390_instf
  00352	b8 08 00 00 00	 mov	 eax, 8
  00357	48 6b c0 0c	 imul	 rax, rax, 12
  0035b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00363	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0036a	0f ba f0 1f	 btr	 eax, 31
  0036e	b9 08 00 00 00	 mov	 ecx, 8
  00373	48 6b c9 0b	 imul	 rcx, rcx, 11
  00377	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0037f	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00386	0f ba f1 1f	 btr	 ecx, 31
  0038a	3b c1		 cmp	 eax, ecx
  0038c	72 60		 jb	 SHORT $LN68@s390_instf
  0038e	b8 08 00 00 00	 mov	 eax, 8
  00393	48 6b c0 0b	 imul	 rax, rax, 11
  00397	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003a6	0f ba f0 1f	 btr	 eax, 31
  003aa	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  003ae	72 2c		 jb	 SHORT $LN64@s390_instf
  003b0	b8 08 00 00 00	 mov	 eax, 8
  003b5	48 6b c0 0c	 imul	 rax, rax, 12
  003b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c1	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  003c8	0f ba f0 1f	 btr	 eax, 31
  003cc	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  003d0	77 0a		 ja	 SHORT $LN64@s390_instf
  003d2	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv251[rsp], 1
  003da	eb 08		 jmp	 SHORT $LN67@s390_instf
$LN64@s390_instf:
  003dc	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv251[rsp], 0
$LN67@s390_instf:
  003e4	8b 44 24 74	 mov	 eax, DWORD PTR tv251[rsp]
  003e8	89 44 24 7c	 mov	 DWORD PTR tv252[rsp], eax
  003ec	eb 5e		 jmp	 SHORT $LN69@s390_instf
$LN68@s390_instf:
  003ee	b8 08 00 00 00	 mov	 eax, 8
  003f3	48 6b c0 0b	 imul	 rax, rax, 11
  003f7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ff	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00406	0f ba f0 1f	 btr	 eax, 31
  0040a	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  0040e	73 2c		 jae	 SHORT $LN65@s390_instf
  00410	b8 08 00 00 00	 mov	 eax, 8
  00415	48 6b c0 0c	 imul	 rax, rax, 12
  00419	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00421	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00428	0f ba f0 1f	 btr	 eax, 31
  0042c	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00430	76 0a		 jbe	 SHORT $LN65@s390_instf
  00432	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv250[rsp], 0
  0043a	eb 08		 jmp	 SHORT $LN66@s390_instf
$LN65@s390_instf:
  0043c	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv250[rsp], 1
$LN66@s390_instf:
  00444	8b 44 24 78	 mov	 eax, DWORD PTR tv250[rsp]
  00448	89 44 24 7c	 mov	 DWORD PTR tv252[rsp], eax
$LN69@s390_instf:
  0044c	83 7c 24 7c 00	 cmp	 DWORD PTR tv252[rsp], 0
  00451	74 20		 je	 SHORT $LN20@s390_instf
$LN7@s390_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  00453	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0045e	0f ba e8 16	 bts	 eax, 22
  00462	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0046d	33 c0		 xor	 eax, eax
  0046f	85 c0		 test	 eax, eax
  00471	75 e0		 jne	 SHORT $LN7@s390_instf
$LN20@s390_instf:

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))
; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );
; 839  :                 regs->psw.IA = addr;
; 840  :                 regs->psw.zeroilc = 1;
; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );
; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  00473	33 c0		 xor	 eax, eax
  00475	83 f8 01	 cmp	 eax, 1
  00478	0f 84 f3 00 00
	00		 je	 $LN21@s390_instf
  0047e	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00486	0f 85 e5 00 00
	00		 jne	 $LN21@s390_instf
  0048c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00494	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049a	c1 e8 10	 shr	 eax, 16
  0049d	83 e0 01	 and	 eax, 1
  004a0	85 c0		 test	 eax, eax
  004a2	0f 85 c9 00 00
	00		 jne	 $LN21@s390_instf
  004a8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b0	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  004b8	0f 84 b3 00 00
	00		 je	 $LN21@s390_instf
  004be	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  004c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004cb	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  004d2	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  004d7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004df	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  004e3	0f 83 88 00 00
	00		 jae	 $LN21@s390_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)
; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)
; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );
; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  004e9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  004f7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ff	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00507	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0050e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00512	48 2b ca	 sub	 rcx, rdx
  00515	48 03 c1	 add	 rax, rcx
  00518	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00520	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00526	48 23 c1	 and	 rax, rcx
  00529	8b c0		 mov	 eax, eax
  0052b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00533	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  0053a	33 c0		 xor	 eax, eax
  0053c	85 c0		 test	 eax, eax
  0053e	74 20		 je	 SHORT $LN22@s390_instf
$LN10@s390_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  00540	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00548	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0054b	0f ba f0 16	 btr	 eax, 22
  0054f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00557	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0055a	33 c0		 xor	 eax, eax
  0055c	85 c0		 test	 eax, eax
  0055e	75 e0		 jne	 SHORT $LN10@s390_instf
$LN22@s390_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  00560	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00568	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0056c	e9 4f 03 00 00	 jmp	 $LN1@s390_instf
$LN21@s390_instf:
$LN18@s390_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  00571	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00579	75 1f		 jne	 SHORT $LN23@s390_instf

; 882  :         regs->instinvalid = 1;

  0057b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00583	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00589	83 c8 08	 or	 eax, 8
  0058c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00594	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN23@s390_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  0059a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  005a6	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  005aa	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  005b2	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005ba	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  005c0	ba 06 00 00 00	 mov	 edx, 6
  005c5	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005c9	e8 00 00 00 00	 call	 s390_maddr_l
  005ce	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  005d3	b8 01 00 00 00	 mov	 eax, 1
  005d8	48 6b c0 00	 imul	 rax, rax, 0
  005dc	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  005e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005e5	83 f8 40	 cmp	 eax, 64			; 00000040H
  005e8	7d 0d		 jge	 SHORT $LN72@s390_instf
  005ea	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv311[rsp], 2
  005f5	eb 3f		 jmp	 SHORT $LN73@s390_instf
$LN72@s390_instf:
  005f7	b8 01 00 00 00	 mov	 eax, 1
  005fc	48 6b c0 00	 imul	 rax, rax, 0
  00600	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00605	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00609	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0060e	7d 0d		 jge	 SHORT $LN70@s390_instf
  00610	c7 84 24 80 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv310[rsp], 4
  0061b	eb 0b		 jmp	 SHORT $LN71@s390_instf
$LN70@s390_instf:
  0061d	c7 84 24 80 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv310[rsp], 6
$LN71@s390_instf:
  00628	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv310[rsp]
  0062f	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv311[rsp], eax
$LN73@s390_instf:
  00636	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv311[rsp]
  0063d	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  00641	03 c8		 add	 ecx, eax
  00643	8b c1		 mov	 eax, ecx
  00645	3b 44 24 34	 cmp	 eax, DWORD PTR pagesz$[rsp]
  00649	0f 8e ff 00 00
	00		 jle	 $LN24@s390_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  0064f	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00657	74 18		 je	 SHORT $LN74@s390_instf
  00659	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00661	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  00667	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
  0066f	eb 16		 jmp	 SHORT $LN75@s390_instf
$LN74@s390_instf:
  00671	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00679	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0067f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv317[rsp], rax
$LN75@s390_instf:
  00687	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv317[rsp]
  0068f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00697	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0069f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  006a4	8b 09		 mov	 ecx, DWORD PTR [rcx]
  006a6	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  006a8	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  006ac	8b 4c 24 34	 mov	 ecx, DWORD PTR pagesz$[rsp]
  006b0	2b c8		 sub	 ecx, eax
  006b2	8b c1		 mov	 eax, ecx
  006b4	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  006b8	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  006bc	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  006c0	03 c8		 add	 ecx, eax
  006c2	8b c1		 mov	 eax, ecx
  006c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006cc	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  006d2	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  006d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006de	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  006e2	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  006e6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  006ee	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006f6	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  006fc	ba 01 00 00 00	 mov	 edx, 1
  00701	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  00705	e8 00 00 00 00	 call	 s390_maddr_l
  0070a	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  0070f	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00717	75 1c		 jne	 SHORT $LN26@s390_instf

; 899  :             regs->ip = ip - len;

  00719	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0071e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00723	48 2b c8	 sub	 rcx, rax
  00726	48 8b c1	 mov	 rax, rcx
  00729	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00731	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN26@s390_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00735	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0073a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR dest$[rsp]
  00742	48 8b 54 24 38	 mov	 rdx, QWORD PTR ip$[rsp]
  00747	8b 12		 mov	 edx, DWORD PTR [rdx]
  00749	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0074c	eb 28		 jmp	 SHORT $LN25@s390_instf
$LN24@s390_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  0074e	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  00753	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  0075b	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00763	75 11		 jne	 SHORT $LN27@s390_instf

; 907  :             regs->ip = ip;

  00765	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0076d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00772	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN27@s390_instf:
$LN25@s390_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00776	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0077e	0f 85 bd 00 00
	00		 jne	 $LN28@s390_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00784	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00792	83 e0 f7	 and	 eax, -9			; fffffff7H
  00795	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079d	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  007a3	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  007a7	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  007ac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b4	89 81 10 02 00
	00		 mov	 DWORD PTR [rcx+528], eax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  007ba	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  007bf	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  007c5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cd	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  007d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007e2	c1 e8 10	 shr	 eax, 16
  007e5	83 e0 01	 and	 eax, 1
  007e8	85 c0		 test	 eax, eax
  007ea	75 18		 jne	 SHORT $LN31@s390_instf
  007ec	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007fa	c1 e8 02	 shr	 eax, 2
  007fd	83 e0 01	 and	 eax, 1
  00800	85 c0		 test	 eax, eax
  00802	74 15		 je	 SHORT $LN29@s390_instf
$LN31@s390_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  00804	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080c	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  00817	eb 28		 jmp	 SHORT $LN30@s390_instf
$LN29@s390_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  00819	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0081e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00826	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0082d	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00832	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0083a	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN30@s390_instf:
$LN28@s390_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)
; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)
; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );
; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00841	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00849	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0084f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00857	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0085f	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00866	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0086a	48 2b ca	 sub	 rcx, rdx
  0086d	48 03 c1	 add	 rax, rcx
  00870	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00878	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0087e	48 23 c1	 and	 rax, rcx
  00881	8b c0		 mov	 eax, eax
  00883	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088b	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00892	33 c0		 xor	 eax, eax
  00894	85 c0		 test	 eax, eax
  00896	74 20		 je	 SHORT $LN32@s390_instf
$LN13@s390_instf:

; 952  :         OFF_IC_PER_IF( regs );

  00898	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a0	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  008a3	0f ba f0 16	 btr	 eax, 22
  008a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008af	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  008b2	33 c0		 xor	 eax, eax
  008b4	85 c0		 test	 eax, eax
  008b6	75 e0		 jne	 SHORT $LN13@s390_instf
$LN32@s390_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  008b8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@s390_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  008c0	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  008c7	c3		 ret	 0
s390_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
code$ = 128
tv132 = 132
ip$ = 136
tv494 = 144
tv436 = 152
tv438 = 160
tv542 = 168
tv488 = 176
tv496 = 184
dxcstr$ = 192
sie_mode_str$ = 200
sie_debug_arch$ = 216
txf_why$ = 256
__$ArrayPad$ = 512
regs$ = 544
pcode$ = 552
ilc$ = 560
s390_trace_program_interrupt PROC

; 447  : {

$LN44:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 448  :     char sie_mode_str    [ 10]  = {0};  // maybe "SIE: "

  00028	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR sie_mode_str$[rsp]
  00030	48 8b f8	 mov	 rdi, rax
  00033	33 c0		 xor	 eax, eax
  00035	b9 0a 00 00 00	 mov	 ecx, 10
  0003a	f3 aa		 rep stosb

; 449  :     char sie_debug_arch  [ 32]  = {0};  // "370", "390" or "900" if defined( SIE_DEBUG )

  0003c	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR sie_debug_arch$[rsp]
  00044	48 8b f8	 mov	 rdi, rax
  00047	33 c0		 xor	 eax, eax
  00049	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004e	f3 aa		 rep stosb

; 450  :     char txf_why         [256]  = {0};  // TXF "why" string if txf pgmint

  00050	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR txf_why$[rsp]
  00058	48 8b f8	 mov	 rdi, rax
  0005b	33 c0		 xor	 eax, eax
  0005d	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00062	f3 aa		 rep stosb

; 451  :     char dxcstr          [  8]  = {0};  // data exception code if PGM_DATA_EXCEPTION

  00064	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dxcstr$[rsp]
  0006c	48 8b f8	 mov	 rdi, rax
  0006f	33 c0		 xor	 eax, eax
  00071	b9 08 00 00 00	 mov	 ecx, 8
  00076	f3 aa		 rep stosb

; 452  : 
; 453  :     BYTE* ip;      /* ptr to instr that program checked or NULL  */
; 454  : 
; 455  :     /* Just the low byte of program interrupt code itself please */
; 456  :     int code = (pcode & 0xFF);

  00078	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  0007f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00084	89 84 24 80 00
	00 00		 mov	 DWORD PTR code$[rsp], eax

; 457  : 
; 458  :     /* If the program interrupt code is zero, or if it's not, if the
; 459  :        code isn't one they're interested in seeing (as determiend by
; 460  :        OSTAILOR/pgmtrace) AND instruction tracing is NOT active, then
; 461  :        there's nothing for us to do.
; 462  :     */
; 463  :     if (0
; 464  :         || !code
; 465  :         || (1

  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	0f 85 16 08 00
	00		 jne	 $LN9@s390_trace
  00095	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR code$[rsp], 0
  0009d	0f 84 08 08 00
	00		 je	 $LN9@s390_trace
  000a3	33 c0		 xor	 eax, eax
  000a5	83 f8 01	 cmp	 eax, 1
  000a8	0f 84 02 08 00
	00		 je	 $LN8@s390_trace
  000ae	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR code$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ba	b9 01 00 00 00	 mov	 ecx, 1
  000bf	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv542[rsp], rcx
  000c7	0f b6 c8	 movzx	 ecx, al
  000ca	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv542[rsp]
  000d2	48 d3 e0	 shl	 rax, cl
  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000dc	48 8b 89 48 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4936]
  000e3	48 23 c8	 and	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 85 c0	 test	 rax, rax
  000ec	0f 85 be 07 00
	00		 jne	 $LN8@s390_trace
  000f2	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00100	c1 e8 10	 shr	 eax, 16
  00103	83 e0 01	 and	 eax, 1
  00106	85 c0		 test	 eax, eax
  00108	74 0d		 je	 SHORT $LN38@s390_trace
  0010a	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv132[rsp], 1
  00115	eb 0b		 jmp	 SHORT $LN39@s390_trace
$LN38@s390_trace:
  00117	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN39@s390_trace:
  00122	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv132[rsp], 0
  0012a	0f 84 7b 07 00
	00		 je	 $LN10@s390_trace
  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00137	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0013d	c1 e8 0a	 shr	 eax, 10
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	0f 84 91 03 00
	00		 je	 $LN11@s390_trace
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	0f 85 2d 01 00
	00		 jne	 $LN12@s390_trace
  00155	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00162	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00167	85 c0		 test	 eax, eax
  00169	0f 84 13 01 00
	00		 je	 $LN12@s390_trace
  0016f	33 c0		 xor	 eax, eax
  00171	83 f8 01	 cmp	 eax, 1
  00174	0f 84 62 03 00
	00		 je	 $LN11@s390_trace
  0017a	33 c0		 xor	 eax, eax
  0017c	85 c0		 test	 eax, eax
  0017e	75 37		 jne	 SHORT $LN13@s390_trace
  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00187	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0018d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00192	85 c0		 test	 eax, eax
  00194	74 21		 je	 SHORT $LN13@s390_trace
  00196	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a5	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  001ab	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  001b1	0f 85 25 03 00
	00		 jne	 $LN11@s390_trace
$LN13@s390_trace:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	75 37		 jne	 SHORT $LN14@s390_trace
  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  001ca	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  001cf	85 c0		 test	 eax, eax
  001d1	74 21		 je	 SHORT $LN14@s390_trace
  001d3	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001e2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  001e8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  001ee	0f 8c e8 02 00
	00		 jl	 $LN11@s390_trace
$LN14@s390_trace:
  001f4	33 c0		 xor	 eax, eax
  001f6	85 c0		 test	 eax, eax
  001f8	0f 85 84 00 00
	00		 jne	 $LN15@s390_trace
  001fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00205	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0020b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00210	85 c0		 test	 eax, eax
  00212	74 26		 je	 SHORT $LN16@s390_trace
  00214	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00223	85 c0		 test	 eax, eax
  00225	74 13		 je	 SHORT $LN16@s390_trace
  00227	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00236	85 c0		 test	 eax, eax
  00238	75 48		 jne	 SHORT $LN15@s390_trace
$LN16@s390_trace:
  0023a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00241	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00247	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0024c	85 c0		 test	 eax, eax
  0024e	0f 84 88 02 00
	00		 je	 $LN11@s390_trace
  00254	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00263	85 c0		 test	 eax, eax
  00265	0f 84 71 02 00
	00		 je	 $LN11@s390_trace
  0026b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00273	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0027a	85 c0		 test	 eax, eax
  0027c	0f 85 5a 02 00
	00		 jne	 $LN11@s390_trace
$LN15@s390_trace:
$LN12@s390_trace:
  00282	b8 08 00 00 00	 mov	 eax, 8
  00287	48 6b c0 00	 imul	 rax, rax, 0
  0028b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00292	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0029b	75 1f		 jne	 SHORT $LN17@s390_trace
  0029d	b8 08 00 00 00	 mov	 eax, 8
  002a2	48 6b c0 01	 imul	 rax, rax, 1
  002a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002ad	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  002b6	0f 84 f4 05 00
	00		 je	 $LN8@s390_trace
$LN17@s390_trace:
  002bc	b8 08 00 00 00	 mov	 eax, 8
  002c1	48 6b c0 00	 imul	 rax, rax, 0
  002c5	b9 08 00 00 00	 mov	 ecx, 8
  002ca	48 6b c9 01	 imul	 rcx, rcx, 1
  002ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002d5	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  002dc	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  002e4	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  002ec	0f 87 da 00 00
	00		 ja	 $LN18@s390_trace
  002f2	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fa	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00300	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00308	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00310	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00317	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0031b	48 2b ca	 sub	 rcx, rdx
  0031e	48 03 c1	 add	 rax, rcx
  00321	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00328	f7 d9		 neg	 ecx
  0032a	48 63 c9	 movsxd	 rcx, ecx
  0032d	48 03 c1	 add	 rax, rcx
  00330	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00338	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0033e	48 23 c1	 and	 rax, rcx
  00341	8b c0		 mov	 eax, eax
  00343	b9 08 00 00 00	 mov	 ecx, 8
  00348	48 6b c9 00	 imul	 rcx, rcx, 0
  0034c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00353	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0035b	72 6f		 jb	 SHORT $LN18@s390_trace
  0035d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00365	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0036b	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00373	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0037b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00382	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00386	48 2b ca	 sub	 rcx, rdx
  00389	48 03 c1	 add	 rax, rcx
  0038c	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00393	f7 d9		 neg	 ecx
  00395	48 63 c9	 movsxd	 rcx, ecx
  00398	48 03 c1	 add	 rax, rcx
  0039b	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a3	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  003a9	48 23 c1	 and	 rax, rcx
  003ac	8b c0		 mov	 eax, eax
  003ae	b9 08 00 00 00	 mov	 ecx, 8
  003b3	48 6b c9 01	 imul	 rcx, rcx, 1
  003b7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003be	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  003c6	0f 86 e4 04 00
	00		 jbe	 $LN8@s390_trace
$LN18@s390_trace:
  003cc	b8 08 00 00 00	 mov	 eax, 8
  003d1	48 6b c0 00	 imul	 rax, rax, 0
  003d5	b9 08 00 00 00	 mov	 ecx, 8
  003da	48 6b c9 01	 imul	 rcx, rcx, 1
  003de	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003e5	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  003ec	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  003f4	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  003fc	0f 86 da 00 00
	00		 jbe	 $LN19@s390_trace
  00402	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040a	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00410	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00418	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00420	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00427	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0042b	48 2b ca	 sub	 rcx, rdx
  0042e	48 03 c1	 add	 rax, rcx
  00431	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00438	f7 d9		 neg	 ecx
  0043a	48 63 c9	 movsxd	 rcx, ecx
  0043d	48 03 c1	 add	 rax, rcx
  00440	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00448	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0044e	48 23 c1	 and	 rax, rcx
  00451	8b c0		 mov	 eax, eax
  00453	b9 08 00 00 00	 mov	 ecx, 8
  00458	48 6b c9 01	 imul	 rcx, rcx, 1
  0045c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00463	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0046b	72 6f		 jb	 SHORT $LN19@s390_trace
  0046d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00475	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0047b	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00483	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0048b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00492	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00496	48 2b ca	 sub	 rcx, rdx
  00499	48 03 c1	 add	 rax, rcx
  0049c	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  004a3	f7 d9		 neg	 ecx
  004a5	48 63 c9	 movsxd	 rcx, ecx
  004a8	48 03 c1	 add	 rax, rcx
  004ab	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b3	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  004b9	48 23 c1	 and	 rax, rcx
  004bc	8b c0		 mov	 eax, eax
  004be	b9 08 00 00 00	 mov	 ecx, 8
  004c3	48 6b c9 00	 imul	 rcx, rcx, 0
  004c7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004ce	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  004d6	0f 86 d4 03 00
	00		 jbe	 $LN8@s390_trace
$LN19@s390_trace:
$LN11@s390_trace:
  004dc	33 c0		 xor	 eax, eax
  004de	83 f8 01	 cmp	 eax, 1
  004e1	0f 84 c4 03 00
	00		 je	 $LN20@s390_trace
  004e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ee	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  004f4	c1 e8 08	 shr	 eax, 8
  004f7	83 e0 01	 and	 eax, 1
  004fa	85 c0		 test	 eax, eax
  004fc	0f 84 a9 03 00
	00		 je	 $LN20@s390_trace
  00502	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00510	c1 e8 0f	 shr	 eax, 15
  00513	83 e0 01	 and	 eax, 1
  00516	85 c0		 test	 eax, eax
  00518	0f 84 8d 03 00
	00		 je	 $LN20@s390_trace
  0051e	33 c0		 xor	 eax, eax
  00520	85 c0		 test	 eax, eax
  00522	0f 85 2d 01 00
	00		 jne	 $LN21@s390_trace
  00528	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0052f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00535	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0053a	85 c0		 test	 eax, eax
  0053c	0f 84 13 01 00
	00		 je	 $LN21@s390_trace
  00542	33 c0		 xor	 eax, eax
  00544	83 f8 01	 cmp	 eax, 1
  00547	0f 84 5e 03 00
	00		 je	 $LN20@s390_trace
  0054d	33 c0		 xor	 eax, eax
  0054f	85 c0		 test	 eax, eax
  00551	75 37		 jne	 SHORT $LN22@s390_trace
  00553	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0055a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00560	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00565	85 c0		 test	 eax, eax
  00567	74 21		 je	 SHORT $LN22@s390_trace
  00569	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00578	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0057e	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00584	0f 85 21 03 00
	00		 jne	 $LN20@s390_trace
$LN22@s390_trace:
  0058a	33 c0		 xor	 eax, eax
  0058c	85 c0		 test	 eax, eax
  0058e	75 37		 jne	 SHORT $LN23@s390_trace
  00590	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00597	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0059d	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  005a2	85 c0		 test	 eax, eax
  005a4	74 21		 je	 SHORT $LN23@s390_trace
  005a6	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005b5	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  005bb	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  005c1	0f 8c e4 02 00
	00		 jl	 $LN20@s390_trace
$LN23@s390_trace:
  005c7	33 c0		 xor	 eax, eax
  005c9	85 c0		 test	 eax, eax
  005cb	0f 85 84 00 00
	00		 jne	 $LN24@s390_trace
  005d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005d8	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005de	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005e3	85 c0		 test	 eax, eax
  005e5	74 26		 je	 SHORT $LN25@s390_trace
  005e7	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ef	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  005f6	85 c0		 test	 eax, eax
  005f8	74 13		 je	 SHORT $LN25@s390_trace
  005fa	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00602	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00609	85 c0		 test	 eax, eax
  0060b	75 48		 jne	 SHORT $LN24@s390_trace
$LN25@s390_trace:
  0060d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00614	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0061a	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0061f	85 c0		 test	 eax, eax
  00621	0f 84 84 02 00
	00		 je	 $LN20@s390_trace
  00627	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00636	85 c0		 test	 eax, eax
  00638	0f 84 6d 02 00
	00		 je	 $LN20@s390_trace
  0063e	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00646	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0064d	85 c0		 test	 eax, eax
  0064f	0f 85 56 02 00
	00		 jne	 $LN20@s390_trace
$LN24@s390_trace:
$LN21@s390_trace:
  00655	b8 08 00 00 00	 mov	 eax, 8
  0065a	48 6b c0 00	 imul	 rax, rax, 0
  0065e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00665	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0066e	75 1f		 jne	 SHORT $LN26@s390_trace
  00670	b8 08 00 00 00	 mov	 eax, 8
  00675	48 6b c0 01	 imul	 rax, rax, 1
  00679	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00680	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00689	0f 84 21 02 00
	00		 je	 $LN8@s390_trace
$LN26@s390_trace:
  0068f	b8 08 00 00 00	 mov	 eax, 8
  00694	48 6b c0 00	 imul	 rax, rax, 0
  00698	b9 08 00 00 00	 mov	 ecx, 8
  0069d	48 6b c9 01	 imul	 rcx, rcx, 1
  006a1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006a8	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  006af	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  006b7	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  006bf	0f 87 da 00 00
	00		 ja	 $LN27@s390_trace
  006c5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006cd	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  006d3	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006db	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006e3	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  006ea	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  006ee	48 2b ca	 sub	 rcx, rdx
  006f1	48 03 c1	 add	 rax, rcx
  006f4	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  006fb	f7 d9		 neg	 ecx
  006fd	48 63 c9	 movsxd	 rcx, ecx
  00700	48 03 c1	 add	 rax, rcx
  00703	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0070b	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00711	48 23 c1	 and	 rax, rcx
  00714	8b c0		 mov	 eax, eax
  00716	b9 08 00 00 00	 mov	 ecx, 8
  0071b	48 6b c9 00	 imul	 rcx, rcx, 0
  0071f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00726	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0072e	72 6f		 jb	 SHORT $LN27@s390_trace
  00730	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00738	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0073e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00746	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0074e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00755	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00759	48 2b ca	 sub	 rcx, rdx
  0075c	48 03 c1	 add	 rax, rcx
  0075f	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00766	f7 d9		 neg	 ecx
  00768	48 63 c9	 movsxd	 rcx, ecx
  0076b	48 03 c1	 add	 rax, rcx
  0076e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00776	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0077c	48 23 c1	 and	 rax, rcx
  0077f	8b c0		 mov	 eax, eax
  00781	b9 08 00 00 00	 mov	 ecx, 8
  00786	48 6b c9 01	 imul	 rcx, rcx, 1
  0078a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00791	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00799	0f 86 11 01 00
	00		 jbe	 $LN8@s390_trace
$LN27@s390_trace:
  0079f	b8 08 00 00 00	 mov	 eax, 8
  007a4	48 6b c0 00	 imul	 rax, rax, 0
  007a8	b9 08 00 00 00	 mov	 ecx, 8
  007ad	48 6b c9 01	 imul	 rcx, rcx, 1
  007b1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007b8	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  007bf	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  007c7	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  007cf	0f 86 d6 00 00
	00		 jbe	 $LN28@s390_trace
  007d5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dd	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  007e3	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007eb	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007f3	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  007fa	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  007fe	48 2b ca	 sub	 rcx, rdx
  00801	48 03 c1	 add	 rax, rcx
  00804	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0080b	f7 d9		 neg	 ecx
  0080d	48 63 c9	 movsxd	 rcx, ecx
  00810	48 03 c1	 add	 rax, rcx
  00813	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0081b	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00821	48 23 c1	 and	 rax, rcx
  00824	8b c0		 mov	 eax, eax
  00826	b9 08 00 00 00	 mov	 ecx, 8
  0082b	48 6b c9 01	 imul	 rcx, rcx, 1
  0082f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00836	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0083e	72 6b		 jb	 SHORT $LN28@s390_trace
  00840	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00848	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0084e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00856	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0085e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00865	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00869	48 2b ca	 sub	 rcx, rdx
  0086c	48 03 c1	 add	 rax, rcx
  0086f	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00876	f7 d9		 neg	 ecx
  00878	48 63 c9	 movsxd	 rcx, ecx
  0087b	48 03 c1	 add	 rax, rcx
  0087e	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00886	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0088c	48 23 c1	 and	 rax, rcx
  0088f	8b c0		 mov	 eax, eax
  00891	b9 08 00 00 00	 mov	 ecx, 8
  00896	48 6b c9 00	 imul	 rcx, rcx, 0
  0089a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008a1	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  008a9	76 05		 jbe	 SHORT $LN8@s390_trace
$LN28@s390_trace:
$LN20@s390_trace:
$LN10@s390_trace:
$LN9@s390_trace:

; 466  :             && !(sysblk.pgminttr & ((U64) 1 << ((code - 1) & 0x3F)))
; 467  :             && !CPU_STEPPING_OR_TRACING( regs, ilc )
; 468  :            )
; 469  :     )
; 470  :     {
; 471  :         return;     // (nothing to do; quick exit)

  008ab	e9 9a 03 00 00	 jmp	 $LN1@s390_trace
$LN8@s390_trace:
$LN4@s390_trace:

; 472  :     }
; 473  : 
; 474  :     /*
; 475  :        First things first: backup the 'ip' by the 'ilc' value to point
; 476  :        to the actual instruction that actually program checked.
; 477  : 
; 478  :        If 'instinvalid' is set it means an instruction fetch error
; 479  :        occurred so we shouldn't rely on the value of regs->ip.
; 480  : 
; 481  :        Otherwise if the instruction that program checked (i.e. after
; 482  :        backing up 'ip' by 'ilc' amount) appears to be in the previous
; 483  :        mainstor page (meaning the instruction itself crossed a page
; 484  :        boundary), use the the copy of the instruction that was saved
; 485  :        in regs->inst for our instruction pointer instead.
; 486  : 
; 487  :        If neither condition is true (the most common case) then we
; 488  :        simply use current regs->ip value backed up by the ilc amount.
; 489  :     */
; 490  :     PTT_PGM( "tr PGM int", regs->ip, regs->aip, ilc );

  008b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008b7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008ba	48 83 e0 20	 and	 rax, 32			; 00000020H
  008be	48 85 c0	 test	 rax, rax
  008c1	74 4f		 je	 SHORT $LN29@s390_trace
  008c3	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  008cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  008d4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008d9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181281
  008e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008e5	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ed	4c 8b 88 00 02
	00 00		 mov	 r9, QWORD PTR [rax+512]
  008f4	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fc	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00900	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181282
  00907	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0090c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@s390_trace:
  00912	33 c0		 xor	 eax, eax
  00914	85 c0		 test	 eax, eax
  00916	75 98		 jne	 SHORT $LN4@s390_trace

; 491  :     ip =

  00918	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00920	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00926	c1 e8 03	 shr	 eax, 3
  00929	83 e0 01	 and	 eax, 1
  0092c	85 c0		 test	 eax, eax
  0092e	74 0e		 je	 SHORT $LN42@s390_trace
  00930	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv438[rsp], 0
  0093c	eb 75		 jmp	 SHORT $LN43@s390_trace
$LN42@s390_trace:
  0093e	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00946	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0094e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00952	48 2b c8	 sub	 rcx, rax
  00955	48 8b c1	 mov	 rax, rcx
  00958	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00960	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  00967	73 18		 jae	 SHORT $LN40@s390_trace
  00969	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00971	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  00977	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv436[rsp], rax
  0097f	eb 22		 jmp	 SHORT $LN41@s390_trace
$LN40@s390_trace:
  00981	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00989	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00991	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00995	48 2b c8	 sub	 rcx, rax
  00998	48 8b c1	 mov	 rax, rcx
  0099b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv436[rsp], rax
$LN41@s390_trace:
  009a3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv436[rsp]
  009ab	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv438[rsp], rax
$LN43@s390_trace:
  009b3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv438[rsp]
  009bb	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ip$[rsp], rax
$LN7@s390_trace:

; 492  :     (
; 493  :         /* Instruction fetch error? (least likely) */
; 494  :         regs->instinvalid ? NULL
; 495  : 
; 496  :         /* Instruction crossed page boundary? (unlikely) */
; 497  :         : ((regs->ip - ilc) < regs->aip) ? regs->inst
; 498  : 
; 499  :         /* Instruction still on same page (most likely) */
; 500  :         :  (regs->ip - ilc)
; 501  :     );
; 502  :     PTT_PGM( "tr PGM int", ip, regs->aip, ilc );

  009c3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  009ca	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009cd	48 83 e0 20	 and	 rax, 32			; 00000020H
  009d1	48 85 c0	 test	 rax, rax
  009d4	74 4b		 je	 SHORT $LN30@s390_trace
  009d6	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  009de	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  009e7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  009ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181284
  009f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009f8	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a00	4c 8b 88 00 02
	00 00		 mov	 r9, QWORD PTR [rax+512]
  00a07	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR ip$[rsp]
  00a0f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181285
  00a16	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00a1b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@s390_trace:
  00a21	33 c0		 xor	 eax, eax
  00a23	85 c0		 test	 eax, eax
  00a25	75 9c		 jne	 SHORT $LN7@s390_trace

; 503  : 
; 504  : #if defined( OPTION_FOOTPRINT_BUFFER )
; 505  :     if (!(sysblk.insttrace || sysblk.instbreak))
; 506  :     {
; 507  :         U32  n;
; 508  :         for (n = sysblk.footprptr[ regs->cpuad ] + 1;
; 509  :             n != sysblk.footprptr[ regs->cpuad ];
; 510  :             n++, n &= OPTION_FOOTPRINT_BUFFER - 1
; 511  :         )
; 512  :         {
; 513  :             ARCH_DEP( display_inst )(
; 514  :                 &sysblk.footprregs[ regs->cpuad ][n],
; 515  :                  sysblk.footprregs[ regs->cpuad ][n].inst );
; 516  :         }
; 517  :     }
; 518  : #endif
; 519  : 
; 520  :     /* Suppress LRA Special Operation Exception tracing if requested */
; 521  :     if (1
; 522  :         && code == PGM_SPECIAL_OPERATION_EXCEPTION
; 523  :         && ip && ip[0] == 0xB1    // LRA
; 524  :         && sysblk.nolrasoe        // suppression enabled

  00a27	33 c0		 xor	 eax, eax
  00a29	83 f8 01	 cmp	 eax, 1
  00a2c	74 4d		 je	 SHORT $LN31@s390_trace
  00a2e	83 bc 24 80 00
	00 00 13	 cmp	 DWORD PTR code$[rsp], 19
  00a36	75 43		 jne	 SHORT $LN31@s390_trace
  00a38	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR ip$[rsp], 0
  00a41	74 38		 je	 SHORT $LN31@s390_trace
  00a43	b8 01 00 00 00	 mov	 eax, 1
  00a48	48 6b c0 00	 imul	 rax, rax, 0
  00a4c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  00a54	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a58	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  00a5d	75 1c		 jne	 SHORT $LN31@s390_trace
  00a5f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a66	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00a6c	c1 e8 18	 shr	 eax, 24
  00a6f	83 e0 01	 and	 eax, 1
  00a72	85 c0		 test	 eax, eax
  00a74	74 05		 je	 SHORT $LN31@s390_trace

; 525  :     )
; 526  :     {
; 527  :         return;     // (nothing to do; quick exit)

  00a76	e9 cf 01 00 00	 jmp	 $LN1@s390_trace
$LN31@s390_trace:

; 528  :     }
; 529  : 
; 530  :     /* Trace this program interrupt... */
; 531  : 
; 532  : #if defined( _FEATURE_SIE )
; 533  :     if (SIE_MODE( regs ))

  00a7b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a83	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a89	d1 e8		 shr	 eax, 1
  00a8b	83 e0 01	 and	 eax, 1
  00a8e	85 c0		 test	 eax, eax
  00a90	74 1b		 je	 SHORT $LN32@s390_trace

; 534  :       STRLCPY( sie_mode_str, "SIE: " );

  00a92	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00a98	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181288
  00a9f	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR sie_mode_str$[rsp]
  00aa7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN32@s390_trace:

; 535  : #endif
; 536  : 
; 537  : #if defined( SIE_DEBUG )
; 538  :     STRLCPY( sie_debug_arch, QSTR( _GEN_ARCH ));
; 539  :     STRLCAT( sie_debug_arch, " " );
; 540  : #endif
; 541  : 
; 542  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 543  :     if (1
; 544  :         && pcode & PGM_TXF_EVENT
; 545  :         && regs->txf_why
; 546  :     )
; 547  :         txf_why_str( txf_why, sizeof( txf_why ), regs->txf_why );
; 548  : #endif
; 549  : 
; 550  :     if (code == PGM_DATA_EXCEPTION)

  00aad	83 bc 24 80 00
	00 00 07	 cmp	 DWORD PTR code$[rsp], 7
  00ab5	75 29		 jne	 SHORT $LN33@s390_trace

; 551  :        MSGBUF( dxcstr, " DXC=%2.2X", regs->dxc );

  00ab7	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00abf	44 8b 88 08 07
	00 00		 mov	 r9d, DWORD PTR [rax+1800]
  00ac6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181290
  00acd	ba 08 00 00 00	 mov	 edx, 8
  00ad2	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dxcstr$[rsp]
  00ada	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN33@s390_trace:

; 552  : 
; 553  :     if (regs->insttrace && sysblk.traceFILE)

  00ae0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ae8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00aee	c1 e8 0f	 shr	 eax, 15
  00af1	83 e0 01	 and	 eax, 1
  00af4	85 c0		 test	 eax, eax
  00af6	74 30		 je	 SHORT $LN34@s390_trace
  00af8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aff	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b07	74 1f		 je	 SHORT $LN34@s390_trace

; 554  :         tf_0801( regs, pcode, ilc );

  00b09	44 0f b6 84 24
	30 02 00 00	 movzx	 r8d, BYTE PTR ilc$[rsp]
  00b12	0f b7 94 24 28
	02 00 00	 movzx	 edx, WORD PTR pcode$[rsp]
  00b1a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b22	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0801
$LN34@s390_trace:

; 555  : 
; 556  :     // "Processor %s%02X: %s%s %s interruption code %4.4X ilc %d%s%s"
; 557  :     WRMSG( HHC00801, "I",

  00b28	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR code$[rsp]
  00b2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00b35	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv488[rsp], rax
  00b3d	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b45	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00b4c	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv494[rsp], ecx
  00b53	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b5b	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00b62	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00b69	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  00b71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00b77	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv496[rsp], rax
  00b7f	b9 01 00 00 00	 mov	 ecx, 1
  00b84	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b8a	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txf_why$[rsp]
  00b92	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  00b97	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dxcstr$[rsp]
  00b9f	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00ba4	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00bab	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00baf	8b 8c 24 28 02
	00 00		 mov	 ecx, DWORD PTR pcode$[rsp]
  00bb6	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00bba	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv488[rsp]
  00bc2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00bc7	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR sie_debug_arch$[rsp]
  00bcf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00bd4	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR sie_mode_str$[rsp]
  00bdc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00be1	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv494[rsp]
  00be8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bec	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv496[rsp]
  00bf4	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00bf9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181292
  00c00	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181293
  00c0c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c11	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c16	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c1c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181294
  00c23	ba 31 02 00 00	 mov	 edx, 561		; 00000231H
  00c28	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181295
  00c2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 558  :         PTYPSTR( regs->cpuad ), regs->cpuad,
; 559  :         sie_mode_str, sie_debug_arch,
; 560  :         PIC2Name( code ), pcode,
; 561  :         ilc, dxcstr, txf_why );
; 562  : 
; 563  :     // HHC02324 "PSW=... INST=...  OPCODE  operands   name"
; 564  :     ARCH_DEP( display_pgmint_inst )( regs, ip );

  00c35	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR ip$[rsp]
  00c3d	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c45	e8 00 00 00 00	 call	 s390_display_pgmint_inst
$LN1@s390_trace:

; 565  : 
; 566  : } /* end function ARCH_DEP( trace_program_interrupt ) */

  00c4a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c52	48 33 cc	 xor	 rcx, rsp
  00c55	e8 00 00 00 00	 call	 __security_check_cookie
  00c5a	48 81 c4 10 02
	00 00		 add	 rsp, 528		; 00000210H
  00c61	5f		 pop	 rdi
  00c62	c3		 ret	 0
s390_trace_program_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
ilc$ = 64
tv70 = 68
tv77 = 72
tv84 = 76
tv86 = 80
tv88 = 84
tv142 = 88
tv147 = 92
tv149 = 96
regs$ = 128
s390_fix_program_interrupt_PSW PROC

; 572  : {

$LN38:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 573  :     /* Determine the instruction length code (ilc).
; 574  : 
; 575  :        The 'zeroilc' flag is set when the Instruction Length Code
; 576  :        should be reported as zero (such as when instruction-fetching
; 577  :        nullification PER option is set in CR9 or when the load PSW
; 578  :        instruction results in an invalid PSW being loaded).
; 579  : 
; 580  :        The PSW 'ilc' value can also be specifically set to '0' when
; 581  :        a BALR, BASR or BASSM program checks during 'trace_br' call.
; 582  :     */
; 583  :     int ilc =

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00011	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00017	c1 e8 02	 shr	 eax, 2
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	74 0d		 je	 SHORT $LN30@s390_fix_p
  00021	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
  00029	e9 95 00 00 00	 jmp	 $LN31@s390_fix_p
$LN30@s390_fix_p:
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	75 0a		 jne	 SHORT $LN20@s390_fix_p
  00043	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0004b	eb 08		 jmp	 SHORT $LN21@s390_fix_p
$LN20@s390_fix_p:
  0004d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN21@s390_fix_p:
  00055	83 7c 24 44 00	 cmp	 DWORD PTR tv70[rsp], 0
  0005a	74 0a		 je	 SHORT $LN24@s390_fix_p
  0005c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  00064	eb 08		 jmp	 SHORT $LN25@s390_fix_p
$LN24@s390_fix_p:
  00066	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN25@s390_fix_p:
  0006e	83 7c 24 48 00	 cmp	 DWORD PTR tv77[rsp], 0
  00073	74 15		 je	 SHORT $LN28@s390_fix_p
  00075	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00084	89 44 24 50	 mov	 DWORD PTR tv86[rsp], eax
  00088	eb 31		 jmp	 SHORT $LN29@s390_fix_p
$LN28@s390_fix_p:
  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00092	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00098	d1 e8		 shr	 eax, 1
  0009a	83 e0 01	 and	 eax, 1
  0009d	85 c0		 test	 eax, eax
  0009f	74 0a		 je	 SHORT $LN26@s390_fix_p
  000a1	c7 44 24 4c 06
	00 00 00	 mov	 DWORD PTR tv84[rsp], 6
  000a9	eb 08		 jmp	 SHORT $LN27@s390_fix_p
$LN26@s390_fix_p:
  000ab	c7 44 24 4c 04
	00 00 00	 mov	 DWORD PTR tv84[rsp], 4
$LN27@s390_fix_p:
  000b3	8b 44 24 4c	 mov	 eax, DWORD PTR tv84[rsp]
  000b7	89 44 24 50	 mov	 DWORD PTR tv86[rsp], eax
$LN29@s390_fix_p:
  000bb	8b 44 24 50	 mov	 eax, DWORD PTR tv86[rsp]
  000bf	89 44 24 54	 mov	 DWORD PTR tv88[rsp], eax
$LN31@s390_fix_p:
  000c3	8b 44 24 54	 mov	 eax, DWORD PTR tv88[rsp]
  000c7	89 44 24 40	 mov	 DWORD PTR ilc$[rsp], eax
$LN4@s390_fix_p:

; 584  :     (
; 585  :         /* If zeroilc flag is set, then we MUST use zero for the ilc */
; 586  :         regs->psw.zeroilc ? 0
; 587  : 
; 588  :         /* Otherwise use either the ilc value set in the PSW or the
; 589  :            length of the EX/EXRL instruction is the instruction is
; 590  :            being executed.
; 591  :         */
; 592  :         : REAL_ILC( regs )
; 593  :     );
; 594  :     PTT_PGM( "fxpiPSW ilc", 0, 0, ilc );

  000cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 83 e0 20	 and	 rax, 32			; 00000020H
  000d9	48 85 c0	 test	 rax, rax
  000dc	74 37		 je	 SHORT $LN14@s390_fix_p
  000de	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  000e3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181337
  000f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fd	45 33 c9	 xor	 r9d, r9d
  00100	45 33 c0	 xor	 r8d, r8d
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181338
  0010a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@s390_fix_p:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	75 b0		 jne	 SHORT $LN4@s390_fix_p

; 595  : 
; 596  :     /* If our resulting ilc is still 0 but the zeroilc flag is NOT set,
; 597  :        then we're left with no choice but to GUESS the 'ilc' value
; 598  :        based on whether the instruction was being executed or not.
; 599  :     */
; 600  :     if (regs->psw.ilc == 0 && !regs->psw.zeroilc)

  0011b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00123	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  0012a	85 c0		 test	 eax, eax
  0012c	0f 85 ab 01 00
	00		 jne	 $LN15@s390_fix_p
  00132	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00140	c1 e8 02	 shr	 eax, 2
  00143	83 e0 01	 and	 eax, 1
  00146	85 c0		 test	 eax, eax
  00148	0f 85 8f 01 00
	00		 jne	 $LN15@s390_fix_p

; 601  :     {
; 602  :         ilc = (!regs->execflag ? 2 : (regs->exrl ? 6 : 4));

  0014e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00156	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0015c	83 e0 01	 and	 eax, 1
  0015f	85 c0		 test	 eax, eax
  00161	75 0a		 jne	 SHORT $LN32@s390_fix_p
  00163	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  0016b	eb 08		 jmp	 SHORT $LN33@s390_fix_p
$LN32@s390_fix_p:
  0016d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN33@s390_fix_p:
  00175	83 7c 24 58 00	 cmp	 DWORD PTR tv142[rsp], 0
  0017a	74 0a		 je	 SHORT $LN36@s390_fix_p
  0017c	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv149[rsp], 2
  00184	eb 31		 jmp	 SHORT $LN37@s390_fix_p
$LN36@s390_fix_p:
  00186	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00194	d1 e8		 shr	 eax, 1
  00196	83 e0 01	 and	 eax, 1
  00199	85 c0		 test	 eax, eax
  0019b	74 0a		 je	 SHORT $LN34@s390_fix_p
  0019d	c7 44 24 5c 06
	00 00 00	 mov	 DWORD PTR tv147[rsp], 6
  001a5	eb 08		 jmp	 SHORT $LN35@s390_fix_p
$LN34@s390_fix_p:
  001a7	c7 44 24 5c 04
	00 00 00	 mov	 DWORD PTR tv147[rsp], 4
$LN35@s390_fix_p:
  001af	8b 44 24 5c	 mov	 eax, DWORD PTR tv147[rsp]
  001b3	89 44 24 60	 mov	 DWORD PTR tv149[rsp], eax
$LN37@s390_fix_p:
  001b7	8b 44 24 60	 mov	 eax, DWORD PTR tv149[rsp]
  001bb	89 44 24 40	 mov	 DWORD PTR ilc$[rsp], eax
$LN7@s390_fix_p:

; 603  : 
; 604  :         PTT_PGM( "fxpiPSW ilc", regs->ip, regs->psw.IA, ilc );

  001bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c9	48 83 e0 20	 and	 rax, 32			; 00000020H
  001cd	48 85 c0	 test	 rax, rax
  001d0	74 4e		 je	 SHORT $LN16@s390_fix_p
  001d2	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  001d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  001e5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ee	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181341
  001fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ff	44 8b c9	 mov	 r9d, ecx
  00202	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020a	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181342
  00215	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s390_fix_p:
  00220	33 c0		 xor	 eax, eax
  00222	85 c0		 test	 eax, eax
  00224	75 99		 jne	 SHORT $LN7@s390_fix_p

; 605  : 
; 606  :         /* Now ADVANCE the 'ip' mainstor instruction pointer and
; 607  :            psw 'IA' instruction address by that ilc amount so that
; 608  :            the 'trace_program_interrupt' can then back them both up
; 609  :            by the same amount to point to the actual instruction
; 610  :            that actually program checked.
; 611  :         */
; 612  :         regs->psw.ilc  = ilc;  // (guessed value)

  00226	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022e	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ilc$[rsp]
  00233	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl

; 613  :         regs->ip      += ilc;  // (so trace_program_interrupt can undo)

  00239	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0023e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  0024a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00252	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 614  :         regs->psw.IA  += ilc;  // (so trace_program_interrupt can undo)

  00256	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00264	03 44 24 40	 add	 eax, DWORD PTR ilc$[rsp]
  00268	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN10@s390_fix_p:

; 615  : 
; 616  :         PTT_PGM( "fxpiPSW ilc", regs->ip, regs->psw.IA, ilc );

  00276	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0027d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00280	48 83 e0 20	 and	 rax, 32			; 00000020H
  00284	48 85 c0	 test	 rax, rax
  00287	74 4e		 je	 SHORT $LN17@s390_fix_p
  00289	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0028e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00296	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  0029c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181344
  002b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b6	44 8b c9	 mov	 r9d, ecx
  002b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c1	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181345
  002cc	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN17@s390_fix_p:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	75 99		 jne	 SHORT $LN10@s390_fix_p
$LN15@s390_fix_p:
$LN13@s390_fix_p:

; 617  :     }
; 618  : 
; 619  :     /* Return ilc value to be passed to 'trace_program_interrupt' */
; 620  : 
; 621  :     PTT_PGM( "fxpiPSW ret", 0, 0, ilc );

  002dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e7	48 83 e0 20	 and	 rax, 32			; 00000020H
  002eb	48 85 c0	 test	 rax, rax
  002ee	74 37		 je	 SHORT $LN18@s390_fix_p
  002f0	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  002f5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002fe	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00303	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181347
  0030a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030f	45 33 c9	 xor	 r9d, r9d
  00312	45 33 c0	 xor	 r8d, r8d
  00315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181348
  0031c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s390_fix_p:
  00327	33 c0		 xor	 eax, eax
  00329	85 c0		 test	 eax, eax
  0032b	75 b0		 jne	 SHORT $LN13@s390_fix_p

; 622  :     return ilc;

  0032d	8b 44 24 40	 mov	 eax, DWORD PTR ilc$[rsp]

; 623  : }

  00331	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00335	c3		 ret	 0
s390_fix_program_interrupt_PSW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv195 = 64
tv215 = 68
tv273 = 72
tv272 = 76
tv274 = 80
regs$ = 112
offset$ = 120
s390_SuccessfulRelativeBranch PROC

; 400  : {

$LN43:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 401  :     /* Set BEAR to branch instruction. Note: for branch instructions
; 402  :        regs->ip is not updated to point to the next instruction and
; 403  :        thus is still pointing to the branch instruction itself.
; 404  :     */
; 405  :     SET_BEAR_REG( regs, regs->ip );
; 406  : 
; 407  :     /* Branch target still within same page as branch instruction? */
; 408  :     if (1
; 409  :         && !regs->permode
; 410  :         && !regs->execflag
; 411  :         &&  offset > -4096
; 412  :         &&  offset < +4096
; 413  :         && (regs->ip + offset) >= regs->aip
; 414  :         && (regs->ip + offset) <  regs->aie

  0000e	33 c0		 xor	 eax, eax
  00010	83 f8 01	 cmp	 eax, 1
  00013	0f 84 04 01 00
	00		 je	 $LN17@s390_Succe
  00019	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00024	c1 e8 02	 shr	 eax, 2
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	0f 85 eb 00 00
	00		 jne	 $LN17@s390_Succe
  00032	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003d	83 e0 01	 and	 eax, 1
  00040	85 c0		 test	 eax, eax
  00042	0f 85 d5 00 00
	00		 jne	 $LN17@s390_Succe
  00048	48 81 7c 24 78
	00 f0 ff ff	 cmp	 QWORD PTR offset$[rsp], -4096 ; fffffffffffff000H
  00051	0f 8e c6 00 00
	00		 jle	 $LN17@s390_Succe
  00057	48 81 7c 24 78
	00 10 00 00	 cmp	 QWORD PTR offset$[rsp], 4096 ; 00001000H
  00060	0f 8d b7 00 00
	00		 jge	 $LN17@s390_Succe
  00066	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006f	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  00074	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  00080	0f 82 97 00 00
	00		 jb	 $LN17@s390_Succe
  00086	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  00094	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	48 3b 81 08 02
	00 00		 cmp	 rax, QWORD PTR [rcx+520]
  000a0	73 7b		 jae	 SHORT $LN17@s390_Succe

; 415  :     )
; 416  :     {
; 417  :         /* Branch directly to the new instruction */
; 418  :         regs->ip = regs->ip + offset;

  000a2	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ab	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  000b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN4@s390_Succe:

; 419  :         PTT_INF( "rbranch <", regs->ip, offset, regs->aip );

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	48 83 e0 08	 and	 rax, 8
  000c7	48 85 c0	 test	 rax, rax
  000ca	74 46		 je	 SHORT $LN18@s390_Succe
  000cc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000d5	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  000e1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181190
  000ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f2	4c 8b 4c 24 78	 mov	 r9, QWORD PTR offset$[rsp]
  000f7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181191
  00107	b9 08 00 00 00	 mov	 ecx, 8
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s390_Succe:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 a1		 jne	 SHORT $LN4@s390_Succe

; 420  :         return;

  00118	e9 8f 03 00 00	 jmp	 $LN1@s390_Succe
$LN17@s390_Succe:
$LN7@s390_Succe:

; 421  :     }
; 422  : 
; 423  :     /* Branch target is in another page: point the PSW to the target
; 424  :        instruction and force a new "regs->ip" value to get set by
; 425  :        forcing a full instruction fetch from the new target address.
; 426  :     */
; 427  :     PTT_INF( "rbranch >", regs->psw.IA, offset, regs->execflag );

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00124	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00127	48 83 e0 08	 and	 rax, 8
  0012b	48 85 c0	 test	 rax, rax
  0012e	74 4f		 je	 SHORT $LN19@s390_Succe
  00130	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00135	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0013b	83 e0 01	 and	 eax, 1
  0013e	8b c0		 mov	 eax, eax
  00140	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  0014b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00154	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00159	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181193
  00160	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00165	4c 8b 4c 24 78	 mov	 r9, QWORD PTR offset$[rsp]
  0016a	44 8b c1	 mov	 r8d, ecx
  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181194
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@s390_Succe:
  0017f	33 c0		 xor	 eax, eax
  00181	85 c0		 test	 eax, eax
  00183	75 98		 jne	 SHORT $LN7@s390_Succe

; 428  : 
; 429  :     /* Point PSW to target instruction */
; 430  :     if (!regs->execflag)

  00185	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00190	83 e0 01	 and	 eax, 1
  00193	85 c0		 test	 eax, eax
  00195	75 4f		 jne	 SHORT $LN20@s390_Succe

; 431  :         regs->psw.IA = PSW_IA_FROM_IP( regs, offset );

  00197	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0019c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  001a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  001ac	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  001b3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001b7	48 2b ca	 sub	 rcx, rdx
  001ba	48 8b 54 24 78	 mov	 rdx, QWORD PTR offset$[rsp]
  001bf	48 03 d0	 add	 rdx, rax
  001c2	48 8b c2	 mov	 rax, rdx
  001c5	48 03 c8	 add	 rcx, rax
  001c8	48 8b c1	 mov	 rax, rcx
  001cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  001d6	48 23 c1	 and	 rax, rcx
  001d9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001de	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  001e4	eb 3e		 jmp	 SHORT $LN21@s390_Succe
$LN20@s390_Succe:

; 432  :     else
; 433  :     {
; 434  :         regs->psw.IA = regs->ET + offset;

  001e6	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001eb	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  001f1	48 03 44 24 78	 add	 rax, QWORD PTR offset$[rsp]
  001f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  001fb	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 435  :         regs->psw.IA &= ADDRESS_MAXWRAP( regs );

  00201	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00206	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0020b	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00211	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00217	23 c1		 and	 eax, ecx
  00219	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0021e	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN21@s390_Succe:

; 436  :     }
; 437  :     regs->aie = INVALID_AIE;            /* Force a fresh 'instfetch' */

  00224	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00229	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN10@s390_Succe:

; 438  : 
; 439  :     PTT_INF( "rbranch >", regs->psw.IA, offset, regs->execflag );

  00234	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0023b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0023e	48 83 e0 08	 and	 rax, 8
  00242	48 85 c0	 test	 rax, rax
  00245	74 4f		 je	 SHORT $LN22@s390_Succe
  00247	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00252	83 e0 01	 and	 eax, 1
  00255	8b c0		 mov	 eax, eax
  00257	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00262	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0026b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00270	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181198
  00277	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027c	4c 8b 4c 24 78	 mov	 r9, QWORD PTR offset$[rsp]
  00281	44 8b c1	 mov	 r8d, ecx
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181199
  0028b	b9 08 00 00 00	 mov	 ecx, 8
  00290	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@s390_Succe:
  00296	33 c0		 xor	 eax, eax
  00298	85 c0		 test	 eax, eax
  0029a	75 98		 jne	 SHORT $LN10@s390_Succe
$LN13@s390_Succe:

; 440  :     PER_SB( regs, regs->psw.IA );

  0029c	33 c0		 xor	 eax, eax
  0029e	83 f8 01	 cmp	 eax, 1
  002a1	0f 84 fb 01 00
	00		 je	 $LN23@s390_Succe
  002a7	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002ac	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  002b2	c1 e8 02	 shr	 eax, 2
  002b5	83 e0 01	 and	 eax, 1
  002b8	85 c0		 test	 eax, eax
  002ba	74 0a		 je	 SHORT $LN28@s390_Succe
  002bc	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  002c4	eb 08		 jmp	 SHORT $LN29@s390_Succe
$LN28@s390_Succe:
  002c6	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN29@s390_Succe:
  002ce	83 7c 24 40 00	 cmp	 DWORD PTR tv195[rsp], 0
  002d3	74 1b		 je	 SHORT $LN30@s390_Succe
  002d5	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002da	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002dd	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  002e2	85 c0		 test	 eax, eax
  002e4	74 0a		 je	 SHORT $LN30@s390_Succe
  002e6	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
  002ee	eb 08		 jmp	 SHORT $LN36@s390_Succe
$LN30@s390_Succe:
  002f0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN36@s390_Succe:
  002f8	83 7c 24 44 00	 cmp	 DWORD PTR tv215[rsp], 0
  002fd	0f 84 9f 01 00
	00		 je	 $LN23@s390_Succe
  00303	33 c0		 xor	 eax, eax
  00305	83 f8 01	 cmp	 eax, 1
  00308	0f 84 94 01 00
	00		 je	 $LN23@s390_Succe
  0030e	33 c0		 xor	 eax, eax
  00310	85 c0		 test	 eax, eax
  00312	0f 85 70 01 00
	00		 jne	 $LN24@s390_Succe
  00318	b8 08 00 00 00	 mov	 eax, 8
  0031d	48 6b c0 0a	 imul	 rax, rax, 10
  00321	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00326	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0032d	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  00332	85 c0		 test	 eax, eax
  00334	0f 84 4e 01 00
	00		 je	 $LN24@s390_Succe
  0033a	b8 08 00 00 00	 mov	 eax, 8
  0033f	48 6b c0 0c	 imul	 rax, rax, 12
  00343	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00348	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0034f	0f ba f0 1f	 btr	 eax, 31
  00353	b9 08 00 00 00	 mov	 ecx, 8
  00358	48 6b c9 0b	 imul	 rcx, rcx, 11
  0035c	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00361	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00368	0f ba f1 1f	 btr	 ecx, 31
  0036c	3b c1		 cmp	 eax, ecx
  0036e	0f 82 89 00 00
	00		 jb	 $LN41@s390_Succe
  00374	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00379	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0037e	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00384	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0038a	23 c1		 and	 eax, ecx
  0038c	b9 08 00 00 00	 mov	 ecx, 8
  00391	48 6b c9 0b	 imul	 rcx, rcx, 11
  00395	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0039a	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  003a1	0f ba f1 1f	 btr	 ecx, 31
  003a5	3b c1		 cmp	 eax, ecx
  003a7	72 3f		 jb	 SHORT $LN37@s390_Succe
  003a9	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  003ae	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  003b3	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  003b9	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  003bf	23 c1		 and	 eax, ecx
  003c1	b9 08 00 00 00	 mov	 ecx, 8
  003c6	48 6b c9 0c	 imul	 rcx, rcx, 12
  003ca	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  003cf	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  003d6	0f ba f1 1f	 btr	 ecx, 31
  003da	3b c1		 cmp	 eax, ecx
  003dc	77 0a		 ja	 SHORT $LN37@s390_Succe
  003de	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv273[rsp], 1
  003e6	eb 08		 jmp	 SHORT $LN40@s390_Succe
$LN37@s390_Succe:
  003e8	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv273[rsp], 0
$LN40@s390_Succe:
  003f0	8b 44 24 48	 mov	 eax, DWORD PTR tv273[rsp]
  003f4	89 44 24 50	 mov	 DWORD PTR tv274[rsp], eax
  003f8	e9 84 00 00 00	 jmp	 $LN42@s390_Succe
$LN41@s390_Succe:
  003fd	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00402	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00407	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0040d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00413	23 c1		 and	 eax, ecx
  00415	b9 08 00 00 00	 mov	 ecx, 8
  0041a	48 6b c9 0b	 imul	 rcx, rcx, 11
  0041e	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00423	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  0042a	0f ba f1 1f	 btr	 ecx, 31
  0042e	3b c1		 cmp	 eax, ecx
  00430	73 3f		 jae	 SHORT $LN38@s390_Succe
  00432	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00437	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0043c	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00442	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00448	23 c1		 and	 eax, ecx
  0044a	b9 08 00 00 00	 mov	 ecx, 8
  0044f	48 6b c9 0c	 imul	 rcx, rcx, 12
  00453	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00458	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  0045f	0f ba f1 1f	 btr	 ecx, 31
  00463	3b c1		 cmp	 eax, ecx
  00465	76 0a		 jbe	 SHORT $LN38@s390_Succe
  00467	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv272[rsp], 0
  0046f	eb 08		 jmp	 SHORT $LN39@s390_Succe
$LN38@s390_Succe:
  00471	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv272[rsp], 1
$LN39@s390_Succe:
  00479	8b 44 24 4c	 mov	 eax, DWORD PTR tv272[rsp]
  0047d	89 44 24 50	 mov	 DWORD PTR tv274[rsp], eax
$LN42@s390_Succe:
  00481	83 7c 24 50 00	 cmp	 DWORD PTR tv274[rsp], 0
  00486	74 1a		 je	 SHORT $LN23@s390_Succe
$LN24@s390_Succe:
$LN16@s390_Succe:
  00488	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0048d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00490	0f ba e8 17	 bts	 eax, 23
  00494	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00499	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0049c	33 c0		 xor	 eax, eax
  0049e	85 c0		 test	 eax, eax
  004a0	75 e6		 jne	 SHORT $LN16@s390_Succe
$LN23@s390_Succe:
  004a2	33 c0		 xor	 eax, eax
  004a4	85 c0		 test	 eax, eax
  004a6	0f 85 f0 fd ff
	ff		 jne	 $LN13@s390_Succe
$LN1@s390_Succe:

; 441  : }

  004ac	48 83 c4 68	 add	 rsp, 104		; 00000068H
  004b0	c3		 ret	 0
s390_SuccessfulRelativeBranch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv155 = 64
tv175 = 68
tv233 = 72
tv232 = 76
tv234 = 80
regs$ = 112
vaddr$ = 120
s390_SuccessfulBranch PROC

; 363  : {

$LN37:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 364  :     vaddr &= ADDRESS_MAXWRAP( regs );

  0000d	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00018	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  0001c	23 c8		 and	 ecx, eax
  0001e	8b c1		 mov	 eax, ecx
  00020	89 44 24 78	 mov	 DWORD PTR vaddr$[rsp], eax

; 365  : 
; 366  :     /* Set BEAR to branch instruction. Note: for branch instructions
; 367  :        regs->ip is not updated to point to the next instruction and
; 368  :        thus is still pointing to the branch instruction itself.
; 369  :     */
; 370  :     SET_BEAR_REG( regs, regs->ip );
; 371  : 
; 372  :     /* Branch target still within same page as branch instruction? */
; 373  :     if (1
; 374  :         && !regs->permode
; 375  :         && !regs->execflag
; 376  :         && (vaddr & (PAGEFRAME_PAGEMASK | 0x01)) == regs->AIV

  00024	33 c0		 xor	 eax, eax
  00026	83 f8 01	 cmp	 eax, 1
  00029	0f 84 db 00 00
	00		 je	 $LN14@s390_Succe
  0002f	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00034	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003a	c1 e8 02	 shr	 eax, 2
  0003d	83 e0 01	 and	 eax, 1
  00040	85 c0		 test	 eax, eax
  00042	0f 85 c2 00 00
	00		 jne	 $LN14@s390_Succe
  00048	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00053	83 e0 01	 and	 eax, 1
  00056	85 c0		 test	 eax, eax
  00058	0f 85 ac 00 00
	00		 jne	 $LN14@s390_Succe
  0005e	8b 44 24 78	 mov	 eax, DWORD PTR vaddr$[rsp]
  00062	25 01 f0 ff 7f	 and	 eax, 2147479553		; 7ffff001H
  00067	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	3b 81 10 02 00
	00		 cmp	 eax, DWORD PTR [rcx+528]
  00072	0f 85 92 00 00
	00		 jne	 $LN14@s390_Succe

; 377  :     )
; 378  :     {
; 379  :         /* Branch directly to the new instruction */
; 380  :         regs->ip = regs->aip + (vaddr - regs->AIV);

  00078	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00083	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00087	2b c8		 sub	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	8b c0		 mov	 eax, eax
  0008d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00092	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  00099	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0009e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN4@s390_Succe:

; 381  :         PTT_INF( "branch", vaddr, regs->AIV, regs->ip );

  000a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000a9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ac	48 83 e0 08	 and	 rax, 8
  000b0	48 85 c0	 test	 rax, rax
  000b3	74 4a		 je	 SHORT $LN15@s390_Succe
  000b5	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000c0	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  000c4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000cd	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  000d2	48 8b 52 68	 mov	 rdx, QWORD PTR [rdx+104]
  000d6	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181136
  000e2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000e7	44 8b c8	 mov	 r9d, eax
  000ea	44 8b c1	 mov	 r8d, ecx
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181137
  000f4	b9 08 00 00 00	 mov	 ecx, 8
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@s390_Succe:
  000ff	33 c0		 xor	 eax, eax
  00101	85 c0		 test	 eax, eax
  00103	75 9d		 jne	 SHORT $LN4@s390_Succe

; 382  :         return;

  00105	e9 8d 02 00 00	 jmp	 $LN1@s390_Succe
$LN14@s390_Succe:

; 383  :     }
; 384  : 
; 385  :     /* Branch target is in another page: point the PSW to the target
; 386  :        instruction and force a new "regs->ip" value to get set by
; 387  :        forcing a full instruction fetch from the new target address.
; 388  :     */
; 389  :     regs->psw.IA = vaddr;               /* Point PSW to target instr */

  0010a	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0010f	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00113	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 390  :     regs->aie = INVALID_AIE;            /* Force a fresh 'instfetch' */

  00119	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0011e	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN7@s390_Succe:

; 391  : 
; 392  :     PTT_INF( "branch", vaddr, regs->AIV, 0 );

  00129	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00130	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00133	48 83 e0 08	 and	 rax, 8
  00137	48 85 c0	 test	 rax, rax
  0013a	74 45		 je	 SHORT $LN16@s390_Succe
  0013c	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00141	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00147	8b 4c 24 78	 mov	 ecx, DWORD PTR vaddr$[rsp]
  0014b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00154	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181139
  00164	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00169	44 8b c8	 mov	 r9d, eax
  0016c	44 8b c1	 mov	 r8d, ecx
  0016f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181140
  00176	b9 08 00 00 00	 mov	 ecx, 8
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s390_Succe:
  00181	33 c0		 xor	 eax, eax
  00183	85 c0		 test	 eax, eax
  00185	75 a2		 jne	 SHORT $LN7@s390_Succe
$LN10@s390_Succe:

; 393  :     PER_SB( regs, regs->psw.IA );

  00187	33 c0		 xor	 eax, eax
  00189	83 f8 01	 cmp	 eax, 1
  0018c	0f 84 fb 01 00
	00		 je	 $LN17@s390_Succe
  00192	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00197	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0019d	c1 e8 02	 shr	 eax, 2
  001a0	83 e0 01	 and	 eax, 1
  001a3	85 c0		 test	 eax, eax
  001a5	74 0a		 je	 SHORT $LN22@s390_Succe
  001a7	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv155[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN23@s390_Succe
$LN22@s390_Succe:
  001b1	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN23@s390_Succe:
  001b9	83 7c 24 40 00	 cmp	 DWORD PTR tv155[rsp], 0
  001be	74 1b		 je	 SHORT $LN24@s390_Succe
  001c0	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  001c5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001c8	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  001cd	85 c0		 test	 eax, eax
  001cf	74 0a		 je	 SHORT $LN24@s390_Succe
  001d1	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  001d9	eb 08		 jmp	 SHORT $LN30@s390_Succe
$LN24@s390_Succe:
  001db	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN30@s390_Succe:
  001e3	83 7c 24 44 00	 cmp	 DWORD PTR tv175[rsp], 0
  001e8	0f 84 9f 01 00
	00		 je	 $LN17@s390_Succe
  001ee	33 c0		 xor	 eax, eax
  001f0	83 f8 01	 cmp	 eax, 1
  001f3	0f 84 94 01 00
	00		 je	 $LN17@s390_Succe
  001f9	33 c0		 xor	 eax, eax
  001fb	85 c0		 test	 eax, eax
  001fd	0f 85 70 01 00
	00		 jne	 $LN18@s390_Succe
  00203	b8 08 00 00 00	 mov	 eax, 8
  00208	48 6b c0 0a	 imul	 rax, rax, 10
  0020c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00211	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00218	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  0021d	85 c0		 test	 eax, eax
  0021f	0f 84 4e 01 00
	00		 je	 $LN18@s390_Succe
  00225	b8 08 00 00 00	 mov	 eax, 8
  0022a	48 6b c0 0c	 imul	 rax, rax, 12
  0022e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00233	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0023a	0f ba f0 1f	 btr	 eax, 31
  0023e	b9 08 00 00 00	 mov	 ecx, 8
  00243	48 6b c9 0b	 imul	 rcx, rcx, 11
  00247	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0024c	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00253	0f ba f1 1f	 btr	 ecx, 31
  00257	3b c1		 cmp	 eax, ecx
  00259	0f 82 89 00 00
	00		 jb	 $LN35@s390_Succe
  0025f	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00264	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00269	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0026f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00275	23 c1		 and	 eax, ecx
  00277	b9 08 00 00 00	 mov	 ecx, 8
  0027c	48 6b c9 0b	 imul	 rcx, rcx, 11
  00280	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00285	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  0028c	0f ba f1 1f	 btr	 ecx, 31
  00290	3b c1		 cmp	 eax, ecx
  00292	72 3f		 jb	 SHORT $LN31@s390_Succe
  00294	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00299	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  002a4	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002aa	23 c1		 and	 eax, ecx
  002ac	b9 08 00 00 00	 mov	 ecx, 8
  002b1	48 6b c9 0c	 imul	 rcx, rcx, 12
  002b5	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  002ba	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  002c1	0f ba f1 1f	 btr	 ecx, 31
  002c5	3b c1		 cmp	 eax, ecx
  002c7	77 0a		 ja	 SHORT $LN31@s390_Succe
  002c9	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  002d1	eb 08		 jmp	 SHORT $LN34@s390_Succe
$LN31@s390_Succe:
  002d3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
$LN34@s390_Succe:
  002db	8b 44 24 48	 mov	 eax, DWORD PTR tv233[rsp]
  002df	89 44 24 50	 mov	 DWORD PTR tv234[rsp], eax
  002e3	e9 84 00 00 00	 jmp	 $LN36@s390_Succe
$LN35@s390_Succe:
  002e8	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  002ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  002f8	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  002fe	23 c1		 and	 eax, ecx
  00300	b9 08 00 00 00	 mov	 ecx, 8
  00305	48 6b c9 0b	 imul	 rcx, rcx, 11
  00309	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0030e	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  00315	0f ba f1 1f	 btr	 ecx, 31
  00319	3b c1		 cmp	 eax, ecx
  0031b	73 3f		 jae	 SHORT $LN32@s390_Succe
  0031d	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00322	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00327	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0032d	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00333	23 c1		 and	 eax, ecx
  00335	b9 08 00 00 00	 mov	 ecx, 8
  0033a	48 6b c9 0c	 imul	 rcx, rcx, 12
  0033e	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  00343	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  0034a	0f ba f1 1f	 btr	 ecx, 31
  0034e	3b c1		 cmp	 eax, ecx
  00350	76 0a		 jbe	 SHORT $LN32@s390_Succe
  00352	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv232[rsp], 0
  0035a	eb 08		 jmp	 SHORT $LN33@s390_Succe
$LN32@s390_Succe:
  0035c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv232[rsp], 1
$LN33@s390_Succe:
  00364	8b 44 24 4c	 mov	 eax, DWORD PTR tv232[rsp]
  00368	89 44 24 50	 mov	 DWORD PTR tv234[rsp], eax
$LN36@s390_Succe:
  0036c	83 7c 24 50 00	 cmp	 DWORD PTR tv234[rsp], 0
  00371	74 1a		 je	 SHORT $LN17@s390_Succe
$LN18@s390_Succe:
$LN13@s390_Succe:
  00373	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00378	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0037b	0f ba e8 17	 bts	 eax, 23
  0037f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00387	33 c0		 xor	 eax, eax
  00389	85 c0		 test	 eax, eax
  0038b	75 e6		 jne	 SHORT $LN13@s390_Succe
$LN17@s390_Succe:
  0038d	33 c0		 xor	 eax, eax
  0038f	85 c0		 test	 eax, eax
  00391	0f 85 f0 fd ff
	ff		 jne	 $LN10@s390_Succe
$LN1@s390_Succe:

; 394  : }

  00397	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0039b	c3		 ret	 0
s390_SuccessfulBranch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
i$ = 32
p$1 = 40
regs$ = 64
s390_checkstop_all_cpus PROC

; 79   : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 80   :     int  i;
; 81   : 
; 82   :     if (!IS_INTLOCK_HELD( regs ))

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0001c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00023	3b c1		 cmp	 eax, ecx
  00025	74 17		 je	 SHORT $LN11@s390_check
$LN4@s390_check:

; 83   :         CRASH();

  00027	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0
  00038	33 c0		 xor	 eax, eax
  0003a	85 c0		 test	 eax, eax
  0003c	75 e9		 jne	 SHORT $LN4@s390_check
$LN11@s390_check:

; 84   : 
; 85   :     for (i=0; i < sysblk.maxcpu; i++)

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN7@s390_check
$LN5@s390_check:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_check:
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00063	0f 8d a7 00 00
	00		 jge	 $LN6@s390_check

; 86   :     {
; 87   :         if (IS_CPU_ONLINE(i))

  00069	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00075	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0007e	0f 84 87 00 00
	00		 je	 $LN12@s390_check

; 88   :         {
; 89   :             sysblk.regs[i]->cpustate = CPUSTATE_STOPPING;

  00084	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00090	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00098	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2

; 90   :             sysblk.regs[i]->checkstop = 1;

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a8	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000b0	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000b6	83 c8 20	 or	 eax, 32			; 00000020H
  000b9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000be	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000c5	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000cd	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN10@s390_check:

; 91   :             ON_IC_INTERRUPT( sysblk.regs[i] );

  000d3	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000e7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000ea	0f ba e8 1f	 bts	 eax, 31
  000ee	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000fa	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00102	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 c8		 jne	 SHORT $LN10@s390_check
$LN12@s390_check:

; 92   :         }
; 93   :     }

  0010b	e9 38 ff ff ff	 jmp	 $LN5@s390_check
$LN6@s390_check:

; 94   :     WAKEUP_CPUS_MASK( sysblk.waiting_mask );

  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180945
  00117	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011e	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  00125	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 95   : }

  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	c3		 ret	 0
s390_checkstop_all_cpus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
iointid$ = 96
ioparm$ = 100
ioid$ = 104
icode$ = 108
psa$ = 112
tv167 = 120
rc$ = 124
tv440 = 128
tv137 = 136
pfx$ = 144
dev$ = 152
tv442 = 160
csw$ = 168
__$ArrayPad$ = 176
regs$ = 208
s390_perform_io_interrupt PROC

; 1458 : {

$LN41:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1459 : int     rc;                             /* Return code               */
; 1460 : int     icode;                          /* Intercept code            */
; 1461 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1462 : U32     ioparm;                         /* I/O interruption parameter*/
; 1463 : U32     ioid;                           /* I/O interruption address  */
; 1464 : U32     iointid;                        /* I/O interruption ident    */
; 1465 : RADR    pfx;                            /* Prefix                    */
; 1466 : DBLWRD  csw;                            /* CSW for S/370 channels    */
; 1467 : DEVBLK *dev;                            /* dev presenting interrupt  */
; 1468 : 
; 1469 :     /* Test and clear pending I/O interrupt */
; 1470 :     icode = ARCH_DEP( present_io_interrupt )( regs, &ioid, &ioparm, &iointid, csw, &dev );

  0001e	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR dev$[rsp]
  00026	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0002b	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR csw$[rsp]
  00033	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00038	4c 8d 4c 24 60	 lea	 r9, QWORD PTR iointid$[rsp]
  0003d	4c 8d 44 24 64	 lea	 r8, QWORD PTR ioparm$[rsp]
  00042	48 8d 54 24 68	 lea	 rdx, QWORD PTR ioid$[rsp]
  00047	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	e8 00 00 00 00	 call	 s390_present_io_interrupt
  00054	89 44 24 6c	 mov	 DWORD PTR icode$[rsp], eax

; 1471 : 
; 1472 :     /* Exit if no interrupt was presented */
; 1473 :     if (icode == 0) return;

  00058	83 7c 24 6c 00	 cmp	 DWORD PTR icode$[rsp], 0
  0005d	75 05		 jne	 SHORT $LN5@s390_perfo
  0005f	e9 87 0a 00 00	 jmp	 $LN1@s390_perfo
$LN5@s390_perfo:
$LN4@s390_perfo:

; 1474 : 
; 1475 :     PTT_IO("*IOINT",ioid,ioparm,iointid);

  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00074	48 85 c0	 test	 rax, rax
  00077	74 3e		 je	 SHORT $LN6@s390_perfo
  00079	8b 44 24 60	 mov	 eax, DWORD PTR iointid$[rsp]
  0007d	8b 4c 24 64	 mov	 ecx, DWORD PTR ioparm$[rsp]
  00081	8b 54 24 68	 mov	 edx, DWORD PTR ioid$[rsp]
  00085	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0008e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00093	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181900
  0009a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009f	44 8b c9	 mov	 r9d, ecx
  000a2	44 8b c2	 mov	 r8d, edx
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181901
  000ac	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN6@s390_perfo:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 a7		 jne	 SHORT $LN4@s390_perfo

; 1476 : 
; 1477 : #if defined(_FEATURE_IO_ASSIST)
; 1478 :     if(SIE_MODE(regs) && icode != SIE_NO_INTERCEPT)

  000bd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000cb	d1 e8		 shr	 eax, 1
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 4e		 je	 SHORT $LN7@s390_perfo
  000d4	83 7c 24 6c ff	 cmp	 DWORD PTR icode$[rsp], -1
  000d9	74 47		 je	 SHORT $LN7@s390_perfo

; 1479 :     {
; 1480 :         /* Point to SIE copy of PSA in state descriptor */
; 1481 :         psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_II_PSA_OFFSET);

  000db	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000ea	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  000f1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f9	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  00100	48 8d 44 08 30	 lea	 rax, QWORD PTR [rax+rcx+48]
  00105	48 89 44 24 70	 mov	 QWORD PTR psa$[rsp], rax

; 1482 :         ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  0010a	b2 06		 mov	 dl, 6
  0010c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00114	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  0011b	e8 00 00 00 00	 call	 s390_or_storage_key

; 1483 :     }

  00120	eb 7e		 jmp	 SHORT $LN8@s390_perfo
$LN7@s390_perfo:

; 1484 :     else
; 1485 : #endif
; 1486 :     {
; 1487 :         /* Point to PSA in main storage */
; 1488 :         pfx =

  00122	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00130	d1 e8		 shr	 eax, 1
  00132	83 e0 01	 and	 eax, 1
  00135	85 c0		 test	 eax, eax
  00137	74 19		 je	 SHORT $LN35@s390_perfo
  00139	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00141	48 8b 80 90 08
	00 00		 mov	 rax, QWORD PTR [rax+2192]
  00148	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv137[rsp], rax
  00150	eb 13		 jmp	 SHORT $LN36@s390_perfo
$LN35@s390_perfo:
  00152	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0015d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv137[rsp], rax
$LN36@s390_perfo:
  00165	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv137[rsp]
  0016d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pfx$[rsp], rax

; 1489 : #if defined(_FEATURE_SIE)
; 1490 :               SIE_MODE(regs) ? regs->sie_px :
; 1491 : #endif
; 1492 :               regs->PX;
; 1493 :         psa = (void*)(regs->mainstor + pfx);

  00175	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00184	48 03 84 24 90
	00 00 00	 add	 rax, QWORD PTR pfx$[rsp]
  0018c	48 89 44 24 70	 mov	 QWORD PTR psa$[rsp], rax

; 1494 :         ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  00191	b2 06		 mov	 dl, 6
  00193	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pfx$[rsp]
  0019b	e8 00 00 00 00	 call	 s390_or_storage_key
$LN8@s390_perfo:

; 1495 :     }
; 1496 : 
; 1497 : #ifdef FEATURE_S370_CHANNEL
; 1498 :     /* CSW has already been stored at PSA+X'40' */
; 1499 : 
; 1500 :     if (sysblk.arch_mode == ARCH_370_IDX &&
; 1501 :         ECMODE(&regs->psw))
; 1502 :     {
; 1503 :         /* For ECMODE, store the I/O device address at PSA+X'B8' */
; 1504 :         STORE_FW(psa->ioid,
; 1505 :                  ((((U32)psa->ioid[0] << 8) |
; 1506 :                    ((U32)SSID_TO_LCSS(ioid >> 16) & 0x07)) << 16) |
; 1507 :                  (ioid & 0x0000FFFFUL));
; 1508 :     }
; 1509 :     else
; 1510 :     {
; 1511 :         /* Set the interrupt code to the I/O device address */
; 1512 :         regs->psw.intcode = ioid;
; 1513 :     }
; 1514 : 
; 1515 :     /* Trace the I/O interrupt */
; 1516 :     if (CPU_STEPPING_OR_TRACING( regs, 0 ) || dev->ccwtrace)
; 1517 :     {
; 1518 :         BYTE* csw = psa->csw;
; 1519 : 
; 1520 :         if (regs->insttrace && sysblk.traceFILE)
; 1521 :             tf_0804( regs, csw, ioid, SSID_TO_LCSS(ioid >> 16) & 0x07 );
; 1522 :         else
; 1523 :         {
; 1524 :             // "Processor %s%02X: I/O interrupt code %1.1X:%4.4X CSW %2.2X...
; 1525 :             WRMSG( HHC00804, "I", PTYPSTR( regs->cpuad ), regs->cpuad,
; 1526 :                     SSID_TO_LCSS( ioid >> 16 ) & 0x07, ioid,
; 1527 :                     csw[0], csw[1], csw[2], csw[3],
; 1528 :                     csw[4], csw[5], csw[6], csw[7] );
; 1529 :         }
; 1530 :     }
; 1531 : #endif /*FEATURE_S370_CHANNEL*/
; 1532 : 
; 1533 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 1534 :     /* Store X'0001' + subchannel number at PSA+X'B8' */
; 1535 :     STORE_FW(psa->ioid, ioid);

  001a0	8b 4c 24 68	 mov	 ecx, DWORD PTR ioid$[rsp]
  001a4	e8 00 00 00 00	 call	 _byteswap_ulong
  001a9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  001ae	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  001b5	8b d0		 mov	 edx, eax
  001b7	e8 00 00 00 00	 call	 store_fw_noswap

; 1536 : 
; 1537 :     /* Store the I/O interruption parameter at PSA+X'BC' */
; 1538 :     STORE_FW(psa->ioparm, ioparm);

  001bc	8b 4c 24 64	 mov	 ecx, DWORD PTR ioparm$[rsp]
  001c0	e8 00 00 00 00	 call	 _byteswap_ulong
  001c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  001ca	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  001d1	8b d0		 mov	 edx, eax
  001d3	e8 00 00 00 00	 call	 store_fw_noswap

; 1539 : 
; 1540 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 1541 :     /* Store the I/O interruption identification word at PSA+X'C0' */
; 1542 :     STORE_FW(psa->iointid, iointid);

  001d8	8b 4c 24 60	 mov	 ecx, DWORD PTR iointid$[rsp]
  001dc	e8 00 00 00 00	 call	 _byteswap_ulong
  001e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR psa$[rsp]
  001e6	48 81 c1 c0 00
	00 00		 add	 rcx, 192		; 000000c0H
  001ed	8b d0		 mov	 edx, eax
  001ef	e8 00 00 00 00	 call	 store_fw_noswap

; 1543 : #endif
; 1544 : 
; 1545 :     /* Trace the I/O interrupt */
; 1546 :     if (CPU_STEPPING_OR_TRACING( regs, 0 ) || dev->ccwtrace)

  001f4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00202	c1 e8 10	 shr	 eax, 16
  00205	83 e0 01	 and	 eax, 1
  00208	85 c0		 test	 eax, eax
  0020a	74 0a		 je	 SHORT $LN39@s390_perfo
  0020c	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  00214	eb 08		 jmp	 SHORT $LN40@s390_perfo
$LN39@s390_perfo:
  00216	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN40@s390_perfo:
  0021e	83 7c 24 78 00	 cmp	 DWORD PTR tv167[rsp], 0
  00223	0f 84 03 07 00
	00		 je	 $LN11@s390_perfo
  00229	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00230	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00236	c1 e8 0a	 shr	 eax, 10
  00239	83 e0 01	 and	 eax, 1
  0023c	85 c0		 test	 eax, eax
  0023e	0f 84 55 03 00
	00		 je	 $LN12@s390_perfo
  00244	33 c0		 xor	 eax, eax
  00246	85 c0		 test	 eax, eax
  00248	0f 85 2d 01 00
	00		 jne	 $LN13@s390_perfo
  0024e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00255	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0025b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00260	85 c0		 test	 eax, eax
  00262	0f 84 13 01 00
	00		 je	 $LN13@s390_perfo
  00268	33 c0		 xor	 eax, eax
  0026a	83 f8 01	 cmp	 eax, 1
  0026d	0f 84 26 03 00
	00		 je	 $LN12@s390_perfo
  00273	33 c0		 xor	 eax, eax
  00275	85 c0		 test	 eax, eax
  00277	75 37		 jne	 SHORT $LN14@s390_perfo
  00279	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00280	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00286	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0028b	85 c0		 test	 eax, eax
  0028d	74 21		 je	 SHORT $LN14@s390_perfo
  0028f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00297	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0029e	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  002a4	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  002aa	0f 85 e9 02 00
	00		 jne	 $LN12@s390_perfo
$LN14@s390_perfo:
  002b0	33 c0		 xor	 eax, eax
  002b2	85 c0		 test	 eax, eax
  002b4	75 37		 jne	 SHORT $LN15@s390_perfo
  002b6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002bd	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  002c3	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  002c8	85 c0		 test	 eax, eax
  002ca	74 21		 je	 SHORT $LN15@s390_perfo
  002cc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002db	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  002e1	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  002e7	0f 8c ac 02 00
	00		 jl	 $LN12@s390_perfo
$LN15@s390_perfo:
  002ed	33 c0		 xor	 eax, eax
  002ef	85 c0		 test	 eax, eax
  002f1	0f 85 84 00 00
	00		 jne	 $LN16@s390_perfo
  002f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002fe	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00304	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00309	85 c0		 test	 eax, eax
  0030b	74 26		 je	 SHORT $LN17@s390_perfo
  0030d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00315	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0031c	85 c0		 test	 eax, eax
  0031e	74 13		 je	 SHORT $LN17@s390_perfo
  00320	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00328	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0032f	85 c0		 test	 eax, eax
  00331	75 48		 jne	 SHORT $LN16@s390_perfo
$LN17@s390_perfo:
  00333	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0033a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00340	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00345	85 c0		 test	 eax, eax
  00347	0f 84 4c 02 00
	00		 je	 $LN12@s390_perfo
  0034d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00355	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0035c	85 c0		 test	 eax, eax
  0035e	0f 84 35 02 00
	00		 je	 $LN12@s390_perfo
  00364	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036c	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00373	85 c0		 test	 eax, eax
  00375	0f 85 1e 02 00
	00		 jne	 $LN12@s390_perfo
$LN16@s390_perfo:
$LN13@s390_perfo:
  0037b	b8 08 00 00 00	 mov	 eax, 8
  00380	48 6b c0 00	 imul	 rax, rax, 0
  00384	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0038b	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00394	75 1f		 jne	 SHORT $LN18@s390_perfo
  00396	b8 08 00 00 00	 mov	 eax, 8
  0039b	48 6b c0 01	 imul	 rax, rax, 1
  0039f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003a6	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  003af	0f 84 93 05 00
	00		 je	 $LN10@s390_perfo
$LN18@s390_perfo:
  003b5	b8 08 00 00 00	 mov	 eax, 8
  003ba	48 6b c0 00	 imul	 rax, rax, 0
  003be	b9 08 00 00 00	 mov	 ecx, 8
  003c3	48 6b c9 01	 imul	 rcx, rcx, 1
  003c7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003ce	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  003d5	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  003dd	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  003e5	0f 87 bc 00 00
	00		 ja	 $LN19@s390_perfo
  003eb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f3	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  003f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00401	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00409	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00410	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00414	48 2b ca	 sub	 rcx, rdx
  00417	48 03 c1	 add	 rax, rcx
  0041a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00422	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00428	48 23 c1	 and	 rax, rcx
  0042b	8b c0		 mov	 eax, eax
  0042d	b9 08 00 00 00	 mov	 ecx, 8
  00432	48 6b c9 00	 imul	 rcx, rcx, 0
  00436	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0043d	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00445	72 60		 jb	 SHORT $LN19@s390_perfo
  00447	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044f	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00455	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045d	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00465	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0046c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00470	48 2b ca	 sub	 rcx, rdx
  00473	48 03 c1	 add	 rax, rcx
  00476	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047e	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00484	48 23 c1	 and	 rax, rcx
  00487	8b c0		 mov	 eax, eax
  00489	b9 08 00 00 00	 mov	 ecx, 8
  0048e	48 6b c9 01	 imul	 rcx, rcx, 1
  00492	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00499	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  004a1	0f 86 a1 04 00
	00		 jbe	 $LN10@s390_perfo
$LN19@s390_perfo:
  004a7	b8 08 00 00 00	 mov	 eax, 8
  004ac	48 6b c0 00	 imul	 rax, rax, 0
  004b0	b9 08 00 00 00	 mov	 ecx, 8
  004b5	48 6b c9 01	 imul	 rcx, rcx, 1
  004b9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004c0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  004c7	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  004cf	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  004d7	0f 86 bc 00 00
	00		 jbe	 $LN20@s390_perfo
  004dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e5	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  004eb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f3	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004fb	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00502	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00506	48 2b ca	 sub	 rcx, rdx
  00509	48 03 c1	 add	 rax, rcx
  0050c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00514	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0051a	48 23 c1	 and	 rax, rcx
  0051d	8b c0		 mov	 eax, eax
  0051f	b9 08 00 00 00	 mov	 ecx, 8
  00524	48 6b c9 01	 imul	 rcx, rcx, 1
  00528	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0052f	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00537	72 60		 jb	 SHORT $LN20@s390_perfo
  00539	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00541	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00547	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054f	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00557	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0055e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00562	48 2b ca	 sub	 rcx, rdx
  00565	48 03 c1	 add	 rax, rcx
  00568	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00570	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00576	48 23 c1	 and	 rax, rcx
  00579	8b c0		 mov	 eax, eax
  0057b	b9 08 00 00 00	 mov	 ecx, 8
  00580	48 6b c9 00	 imul	 rcx, rcx, 0
  00584	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0058b	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00593	0f 86 af 03 00
	00		 jbe	 $LN10@s390_perfo
$LN20@s390_perfo:
$LN12@s390_perfo:
  00599	33 c0		 xor	 eax, eax
  0059b	83 f8 01	 cmp	 eax, 1
  0059e	0f 84 88 03 00
	00		 je	 $LN21@s390_perfo
  005a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ab	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  005b1	c1 e8 08	 shr	 eax, 8
  005b4	83 e0 01	 and	 eax, 1
  005b7	85 c0		 test	 eax, eax
  005b9	0f 84 6d 03 00
	00		 je	 $LN21@s390_perfo
  005bf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005cd	c1 e8 0f	 shr	 eax, 15
  005d0	83 e0 01	 and	 eax, 1
  005d3	85 c0		 test	 eax, eax
  005d5	0f 84 51 03 00
	00		 je	 $LN21@s390_perfo
  005db	33 c0		 xor	 eax, eax
  005dd	85 c0		 test	 eax, eax
  005df	0f 85 2d 01 00
	00		 jne	 $LN22@s390_perfo
  005e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ec	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005f2	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  005f7	85 c0		 test	 eax, eax
  005f9	0f 84 13 01 00
	00		 je	 $LN22@s390_perfo
  005ff	33 c0		 xor	 eax, eax
  00601	83 f8 01	 cmp	 eax, 1
  00604	0f 84 22 03 00
	00		 je	 $LN21@s390_perfo
  0060a	33 c0		 xor	 eax, eax
  0060c	85 c0		 test	 eax, eax
  0060e	75 37		 jne	 SHORT $LN23@s390_perfo
  00610	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00617	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0061d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00622	85 c0		 test	 eax, eax
  00624	74 21		 je	 SHORT $LN23@s390_perfo
  00626	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00635	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0063b	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00641	0f 85 e5 02 00
	00		 jne	 $LN21@s390_perfo
$LN23@s390_perfo:
  00647	33 c0		 xor	 eax, eax
  00649	85 c0		 test	 eax, eax
  0064b	75 37		 jne	 SHORT $LN24@s390_perfo
  0064d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00654	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0065a	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0065f	85 c0		 test	 eax, eax
  00661	74 21		 je	 SHORT $LN24@s390_perfo
  00663	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0066b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00672	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00678	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0067e	0f 8c a8 02 00
	00		 jl	 $LN21@s390_perfo
$LN24@s390_perfo:
  00684	33 c0		 xor	 eax, eax
  00686	85 c0		 test	 eax, eax
  00688	0f 85 84 00 00
	00		 jne	 $LN25@s390_perfo
  0068e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00695	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0069b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  006a0	85 c0		 test	 eax, eax
  006a2	74 26		 je	 SHORT $LN26@s390_perfo
  006a4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ac	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  006b3	85 c0		 test	 eax, eax
  006b5	74 13		 je	 SHORT $LN26@s390_perfo
  006b7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006bf	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  006c6	85 c0		 test	 eax, eax
  006c8	75 48		 jne	 SHORT $LN25@s390_perfo
$LN26@s390_perfo:
  006ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006d1	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006d7	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  006dc	85 c0		 test	 eax, eax
  006de	0f 84 48 02 00
	00		 je	 $LN21@s390_perfo
  006e4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ec	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  006f3	85 c0		 test	 eax, eax
  006f5	0f 84 31 02 00
	00		 je	 $LN21@s390_perfo
  006fb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00703	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0070a	85 c0		 test	 eax, eax
  0070c	0f 85 1a 02 00
	00		 jne	 $LN21@s390_perfo
$LN25@s390_perfo:
$LN22@s390_perfo:
  00712	b8 08 00 00 00	 mov	 eax, 8
  00717	48 6b c0 00	 imul	 rax, rax, 0
  0071b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00722	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0072b	75 1f		 jne	 SHORT $LN27@s390_perfo
  0072d	b8 08 00 00 00	 mov	 eax, 8
  00732	48 6b c0 01	 imul	 rax, rax, 1
  00736	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0073d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00746	0f 84 fc 01 00
	00		 je	 $LN10@s390_perfo
$LN27@s390_perfo:
  0074c	b8 08 00 00 00	 mov	 eax, 8
  00751	48 6b c0 00	 imul	 rax, rax, 0
  00755	b9 08 00 00 00	 mov	 ecx, 8
  0075a	48 6b c9 01	 imul	 rcx, rcx, 1
  0075e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00765	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0076c	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  00774	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  0077c	0f 87 bc 00 00
	00		 ja	 $LN28@s390_perfo
  00782	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078a	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00790	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00798	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007a0	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  007a7	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  007ab	48 2b ca	 sub	 rcx, rdx
  007ae	48 03 c1	 add	 rax, rcx
  007b1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b9	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  007bf	48 23 c1	 and	 rax, rcx
  007c2	8b c0		 mov	 eax, eax
  007c4	b9 08 00 00 00	 mov	 ecx, 8
  007c9	48 6b c9 00	 imul	 rcx, rcx, 0
  007cd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007d4	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  007dc	72 60		 jb	 SHORT $LN28@s390_perfo
  007de	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e6	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  007ec	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f4	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007fc	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00803	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00807	48 2b ca	 sub	 rcx, rdx
  0080a	48 03 c1	 add	 rax, rcx
  0080d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00815	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0081b	48 23 c1	 and	 rax, rcx
  0081e	8b c0		 mov	 eax, eax
  00820	b9 08 00 00 00	 mov	 ecx, 8
  00825	48 6b c9 01	 imul	 rcx, rcx, 1
  00829	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00830	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00838	0f 86 0a 01 00
	00		 jbe	 $LN10@s390_perfo
$LN28@s390_perfo:
  0083e	b8 08 00 00 00	 mov	 eax, 8
  00843	48 6b c0 00	 imul	 rax, rax, 0
  00847	b9 08 00 00 00	 mov	 ecx, 8
  0084c	48 6b c9 01	 imul	 rcx, rcx, 1
  00850	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00857	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0085e	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  00866	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  0086e	0f 86 b8 00 00
	00		 jbe	 $LN29@s390_perfo
  00874	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0087c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00882	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088a	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00892	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00899	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0089d	48 2b ca	 sub	 rcx, rdx
  008a0	48 03 c1	 add	 rax, rcx
  008a3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ab	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  008b1	48 23 c1	 and	 rax, rcx
  008b4	8b c0		 mov	 eax, eax
  008b6	b9 08 00 00 00	 mov	 ecx, 8
  008bb	48 6b c9 01	 imul	 rcx, rcx, 1
  008bf	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008c6	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  008ce	72 5c		 jb	 SHORT $LN29@s390_perfo
  008d0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d8	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  008de	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e6	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008ee	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  008f5	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  008f9	48 2b ca	 sub	 rcx, rdx
  008fc	48 03 c1	 add	 rax, rcx
  008ff	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00907	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0090d	48 23 c1	 and	 rax, rcx
  00910	8b c0		 mov	 eax, eax
  00912	b9 08 00 00 00	 mov	 ecx, 8
  00917	48 6b c9 00	 imul	 rcx, rcx, 0
  0091b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00922	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0092a	76 1c		 jbe	 SHORT $LN10@s390_perfo
$LN29@s390_perfo:
$LN21@s390_perfo:
$LN11@s390_perfo:
  0092c	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00934	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0093a	c1 e8 0f	 shr	 eax, 15
  0093d	83 e0 01	 and	 eax, 1
  00940	85 c0		 test	 eax, eax
  00942	0f 84 03 01 00
	00		 je	 $LN9@s390_perfo
$LN10@s390_perfo:

; 1547 :     {
; 1548 :         if (regs->insttrace && sysblk.traceFILE)

  00948	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00950	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00956	c1 e8 0f	 shr	 eax, 15
  00959	83 e0 01	 and	 eax, 1
  0095c	85 c0		 test	 eax, eax
  0095e	74 32		 je	 SHORT $LN30@s390_perfo
  00960	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00967	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0096f	74 21		 je	 SHORT $LN30@s390_perfo

; 1549 :             tf_0806( regs, ioid, ioparm, iointid );

  00971	44 8b 4c 24 60	 mov	 r9d, DWORD PTR iointid$[rsp]
  00976	44 8b 44 24 64	 mov	 r8d, DWORD PTR ioparm$[rsp]
  0097b	8b 54 24 68	 mov	 edx, DWORD PTR ioid$[rsp]
  0097f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00987	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0806
  0098d	e9 b9 00 00 00	 jmp	 $LN31@s390_perfo
$LN30@s390_perfo:

; 1550 :         else
; 1551 :         {
; 1552 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) && !defined( _FEATURE_IO_ASSIST )
; 1553 :             // "Processor %s%02X: I/O interrupt code %8.8X parm %8.8X"
; 1554 :             WRMSG (HHC00805, "I", PTYPSTR(regs->cpuad), regs->cpuad, ioid, ioparm);
; 1555 : #else
; 1556 :             // "Processor %s%02X: I/O interrupt code %8.8X parm %8.8X id %8.8X"
; 1557 :             WRMSG (HHC00806, "I", PTYPSTR(regs->cpuad), regs->cpuad, ioid, ioparm, iointid);

  00992	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0099a	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  009a1	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv440[rsp], eax
  009a8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009b0	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  009b7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  009be	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  009c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  009cc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv442[rsp], rax
  009d4	b9 01 00 00 00	 mov	 ecx, 1
  009d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009df	8b 4c 24 60	 mov	 ecx, DWORD PTR iointid$[rsp]
  009e3	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  009e7	8b 4c 24 64	 mov	 ecx, DWORD PTR ioparm$[rsp]
  009eb	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  009ef	8b 4c 24 68	 mov	 ecx, DWORD PTR ioid$[rsp]
  009f3	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  009f7	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv440[rsp]
  009fe	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a02	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv442[rsp]
  00a0a	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a0f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181927
  00a16	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a1b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181928
  00a22	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a27	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a2c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a32	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181929
  00a39	ba 15 06 00 00	 mov	 edx, 1557		; 00000615H
  00a3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181930
  00a45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@s390_perfo:
$LN9@s390_perfo:

; 1558 : #endif
; 1559 :         }
; 1560 :     }
; 1561 : #endif /* FEATURE_CHANNEL_SUBSYSTEM */
; 1562 : 
; 1563 : #if defined( _FEATURE_IO_ASSIST )
; 1564 :     if (icode == SIE_NO_INTERCEPT)

  00a4b	83 7c 24 6c ff	 cmp	 DWORD PTR icode$[rsp], -1
  00a50	75 6b		 jne	 SHORT $LN32@s390_perfo

; 1565 : #endif
; 1566 :     {
; 1567 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1568 :         /* Abort any active transaction and then return back to here
; 1569 :            to continue with I/O interrupt processing */
; 1570 :         if (regs->txf_tnd)
; 1571 :         {
; 1572 :             PTT_TXF( "*TXF IO", 0, regs->txf_contran, regs->txf_tnd );
; 1573 :             regs->txf_why |= TXF_WHY_IO_INT;
; 1574 :             ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_IO );
; 1575 :         }
; 1576 : #endif
; 1577 :         /* Store current PSW at PSA+X'38' or PSA+X'170' for ESAME */
; 1578 :         ARCH_DEP(store_psw) ( regs, psa->iopold );

  00a52	48 8b 44 24 70	 mov	 rax, QWORD PTR psa$[rsp]
  00a57	48 83 c0 38	 add	 rax, 56			; 00000038H
  00a5b	48 8b d0	 mov	 rdx, rax
  00a5e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a66	e8 00 00 00 00	 call	 s390_store_psw

; 1579 : 
; 1580 :         /* Load new PSW from PSA+X'78' or PSA+X'1F0' for ESAME */
; 1581 :         rc = ARCH_DEP(load_psw) ( regs, psa->iopnew );

  00a6b	48 8b 44 24 70	 mov	 rax, QWORD PTR psa$[rsp]
  00a70	48 83 c0 78	 add	 rax, 120		; 00000078H
  00a74	48 8b d0	 mov	 rdx, rax
  00a77	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a7f	e8 00 00 00 00	 call	 s390_load_psw
  00a84	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1582 : 
; 1583 :         if ( rc )

  00a88	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a8d	74 2e		 je	 SHORT $LN33@s390_perfo

; 1584 :         {
; 1585 :             RELEASE_INTLOCK(regs);

  00a8f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181933
  00a96	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a9e	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1586 :             regs->program_interrupt (regs, rc);

  00aa3	8b 54 24 7c	 mov	 edx, DWORD PTR rc$[rsp]
  00aa7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aaf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ab7	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@s390_perfo:
$LN32@s390_perfo:

; 1587 :         }
; 1588 :     }
; 1589 : 
; 1590 :     RELEASE_INTLOCK(regs);

  00abd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181934
  00ac4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00acc	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1591 : 
; 1592 :     longjmp(regs->progjmp, icode);

  00ad1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ad9	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00adf	8b 54 24 6c	 mov	 edx, DWORD PTR icode$[rsp]
  00ae3	48 8b c8	 mov	 rcx, rax
  00ae6	e8 00 00 00 00	 call	 longjmp
$LN1@s390_perfo:
$LN34@s390_perfo:

; 1593 : 
; 1594 : } /* end function perform_io_interrupt */

  00aeb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00af3	48 33 cc	 xor	 rcx, rsp
  00af6	e8 00 00 00 00	 call	 __security_check_cookie
  00afb	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00b02	c3		 ret	 0
s390_perform_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 96
i$ = 104
tv221 = 108
tv357 = 112
aswitch$ = 116
tv378 = 120
ip$ = 128
current_opcode_table$ = 136
tv79 = 144
tv363 = 152
tv144 = 160
tv152 = 168
tv183 = 176
tv191 = 184
tv274 = 192
tv295 = 200
tv380 = 208
buf$1 = 216
__$ArrayPad$ = 256
cpu$ = 304
oldregs$ = 312
s370_run_cpu PROC

; 1905 : {

$LN53:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1906 : const INSTR_FUNC   *current_opcode_table;
; 1907 : register REGS   *regs;
; 1908 : BYTE   *ip;
; 1909 : int     i = 0;

  00024	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 1910 : int     aswitch;
; 1911 : 
; 1912 :     /* Assign new regs if not already assigned */
; 1913 :     regs = sysblk.regs[cpu] ?

  0002c	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00034	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003b	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00044	74 21		 je	 SHORT $LN40@s370_run_c
  00046	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0004e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00055	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0005d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
  00065	eb 18		 jmp	 SHORT $LN41@s370_run_c
$LN40@s370_run_c:
  00067	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  0006c	b9 00 70 01 00	 mov	 ecx, 94208		; 00017000H
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  00077	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv79[rsp], rax
$LN41@s370_run_c:
  0007f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv79[rsp]
  00087	48 89 44 24 60	 mov	 QWORD PTR regs$[rsp], rax

; 1914 :            sysblk.regs[cpu] :
; 1915 :            malloc_aligned( ROUND_UP( sizeof( REGS ), _4K ), _4K );
; 1916 : 
; 1917 :     if (oldregs)

  0008c	48 83 bc 24 38
	01 00 00 00	 cmp	 QWORD PTR oldregs$[rsp], 0
  00095	0f 84 a9 01 00
	00		 je	 $LN20@s370_run_c

; 1918 :     {
; 1919 :         if (oldregs != regs)

  0009b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	48 39 84 24 38
	01 00 00	 cmp	 QWORD PTR oldregs$[rsp], rax
  000a8	0f 84 91 01 00
	00		 je	 $LN22@s370_run_c

; 1920 :         {
; 1921 :             TXF_FREEMAP( oldregs );
; 1922 :             memcpy (regs, oldregs, sizeof(REGS));

  000ae	48 8b 7c 24 60	 mov	 rdi, QWORD PTR regs$[rsp]
  000b3	48 8b b4 24 38
	01 00 00	 mov	 rsi, QWORD PTR oldregs$[rsp]
  000bb	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  000c0	f3 a4		 rep movsb

; 1923 :             free_aligned(oldregs);

  000c2	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR oldregs$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 1924 :             regs->blkloc = CSWAP64((U64)((uintptr_t)regs));

  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	e8 00 00 00 00	 call	 _byteswap_uint64
  000da	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1925 :             HOSTREGS = regs;

  000e3	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 1926 :             if (GUESTREGS)

  000f4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000f9	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00101	74 18		 je	 SHORT $LN23@s370_run_c

; 1927 :                 HOST(GUESTREGS) = regs;

  00103	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00108	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0010f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx
$LN23@s370_run_c:

; 1928 :             sysblk.regs[cpu] = regs;

  0011b	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00123	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012a	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0012f	48 89 94 c1 98
	0b 00 00	 mov	 QWORD PTR [rcx+rax*8+2968], rdx

; 1929 :             release_lock(&sysblk.cpulock[cpu]);

  00137	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0013f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00146	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170826
  00155	48 8b c8	 mov	 rcx, rax
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1930 :             if (regs->insttrace && sysblk.traceFILE)

  0015e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00163	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00169	c1 e8 0f	 shr	 eax, 15
  0016c	83 e0 01	 and	 eax, 1
  0016f	85 c0		 test	 eax, eax
  00171	74 29		 je	 SHORT $LN24@s370_run_c
  00173	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017a	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00182	74 18		 je	 SHORT $LN24@s370_run_c

; 1931 :                 tf_0811( regs, get_arch_name( regs ));

  00184	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	e8 00 00 00 00	 call	 get_arch_name
  0018e	48 8b d0	 mov	 rdx, rax
  00191	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0811
$LN24@s370_run_c:

; 1932 :             // "Processor %s%02X: architecture mode %s"
; 1933 :             WRMSG( HHC00811, "I", PTYPSTR( cpu ), cpu, get_arch_name( regs ));

  0019c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001a1	e8 00 00 00 00	 call	 get_arch_name
  001a6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv144[rsp], rax
  001ae	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  001b6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001bd	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  001c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  001cb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv152[rsp], rax
  001d3	b9 01 00 00 00	 mov	 ecx, 1
  001d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001de	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv144[rsp]
  001e6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001eb	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  001f2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001f6	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv152[rsp]
  001fe	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170828
  0020a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170829
  00216	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00220	41 b9 03 00 00
	00		 mov	 r9d, 3
  00226	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170830
  0022d	ba 8d 07 00 00	 mov	 edx, 1933		; 0000078dH
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170831
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@s370_run_c:

; 1934 :         }
; 1935 :     }

  0023f	e9 0e 01 00 00	 jmp	 $LN21@s370_run_c
$LN20@s370_run_c:

; 1936 :     else
; 1937 :     {
; 1938 :         memset(regs, 0, sizeof(REGS));

  00244	48 8b 7c 24 60	 mov	 rdi, QWORD PTR regs$[rsp]
  00249	33 c0		 xor	 eax, eax
  0024b	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  00250	f3 aa		 rep stosb

; 1939 :         
; 1940 :                 if (cpu_init( cpu, regs, NULL ))

  00252	45 33 c0	 xor	 r8d, r8d
  00255	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0025a	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00261	e8 00 00 00 00	 call	 cpu_init
  00266	85 c0		 test	 eax, eax
  00268	74 07		 je	 SHORT $LN25@s370_run_c

; 1941 :             return NULL;

  0026a	33 c0		 xor	 eax, eax
  0026c	e9 df 07 00 00	 jmp	 $LN1@s370_run_c
$LN25@s370_run_c:

; 1942 : 
; 1943 :         if (regs->insttrace && sysblk.traceFILE)

  00271	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00276	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0027c	c1 e8 0f	 shr	 eax, 15
  0027f	83 e0 01	 and	 eax, 1
  00282	85 c0		 test	 eax, eax
  00284	74 29		 je	 SHORT $LN26@s370_run_c
  00286	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028d	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00295	74 18		 je	 SHORT $LN26@s370_run_c

; 1944 :             tf_0811( regs, get_arch_name( regs ));

  00297	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0029c	e8 00 00 00 00	 call	 get_arch_name
  002a1	48 8b d0	 mov	 rdx, rax
  002a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0811
$LN26@s370_run_c:

; 1945 : 
; 1946 :         // "Processor %s%02X: architecture mode %s"
; 1947 :         WRMSG( HHC00811, "I", PTYPSTR( cpu ), cpu, get_arch_name( regs ));

  002af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	e8 00 00 00 00	 call	 get_arch_name
  002b9	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
  002c1	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  002c9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002d0	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  002de	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
  002e6	b9 01 00 00 00	 mov	 ecx, 1
  002eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv183[rsp]
  002f9	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002fe	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00305	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00309	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv191[rsp]
  00311	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170834
  0031d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170835
  00329	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0032e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00333	41 b9 03 00 00
	00		 mov	 r9d, 3
  00339	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170836
  00340	ba 9b 07 00 00	 mov	 edx, 1947		; 0000079bH
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170837
  0034c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN21@s370_run_c:

; 1948 : 
; 1949 : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 1950 :         if (regs->vf->online)
; 1951 :         {
; 1952 :             if (regs->insttrace && sysblk.traceFILE)
; 1953 :                 tf_0812( regs, get_arch_name( regs ));
; 1954 : 
; 1955 :             // "Processor %s%02X: vector facility online"
; 1956 :             WRMSG( HHC00812, "I", PTYPSTR( cpu ), cpu );
; 1957 :         }
; 1958 : #endif
; 1959 :     }
; 1960 : 
; 1961 :     regs->program_interrupt = &ARCH_DEP(program_interrupt);

  00352	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00357	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:s370_program_interrupt
  0035e	48 89 88 20 0d
	00 00		 mov	 QWORD PTR [rax+3360], rcx

; 1962 : 
; 1963 :     regs->breakortrace = (sysblk.instbreak || (sysblk.insttrace && regs->insttrace));

  00365	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0036c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00372	c1 e8 0a	 shr	 eax, 10
  00375	83 e0 01	 and	 eax, 1
  00378	85 c0		 test	 eax, eax
  0037a	75 36		 jne	 SHORT $LN43@s370_run_c
  0037c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00383	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00389	c1 e8 08	 shr	 eax, 8
  0038c	83 e0 01	 and	 eax, 1
  0038f	85 c0		 test	 eax, eax
  00391	74 15		 je	 SHORT $LN42@s370_run_c
  00393	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00398	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0039e	c1 e8 0f	 shr	 eax, 15
  003a1	83 e0 01	 and	 eax, 1
  003a4	85 c0		 test	 eax, eax
  003a6	75 0a		 jne	 SHORT $LN43@s370_run_c
$LN42@s370_run_c:
  003a8	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv221[rsp], 0
  003b0	eb 08		 jmp	 SHORT $LN44@s370_run_c
$LN43@s370_run_c:
  003b2	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv221[rsp], 1
$LN44@s370_run_c:
  003ba	8b 44 24 6c	 mov	 eax, DWORD PTR tv221[rsp]
  003be	83 e0 01	 and	 eax, 1
  003c1	c1 e0 10	 shl	 eax, 16
  003c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  003cf	0f ba f1 10	 btr	 ecx, 16
  003d3	0b c8		 or	 ecx, eax
  003d5	8b c1		 mov	 eax, ecx
  003d7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003dc	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1964 :     regs->ints_state |= sysblk.ints_state;

  003e2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003ee	8b 89 a0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4768]
  003f4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  003f7	0b c1		 or	 eax, ecx
  003f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  003fe	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1965 : 
; 1966 :     /* Establish longjmp destination for cpu thread exit */
; 1967 :     if (setjmp(regs->exitjmp))

  00401	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00406	48 05 80 0b 00
	00		 add	 rax, 2944		; 00000b80H
  0040c	48 8b c8	 mov	 rcx, rax
  0040f	48 8b d4	 mov	 rdx, rsp
  00412	e8 00 00 00 00	 call	 _setjmp
  00417	85 c0		 test	 eax, eax
  00419	74 16		 je	 SHORT $LN27@s370_run_c

; 1968 :         return cpu_uninit(cpu, regs);

  0041b	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00420	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  00427	e8 00 00 00 00	 call	 cpu_uninit
  0042c	e9 1f 06 00 00	 jmp	 $LN1@s370_run_c
$LN27@s370_run_c:

; 1969 : 
; 1970 :     /* Establish longjmp destination for architecture switch */
; 1971 :     aswitch = setjmp(regs->archjmp);

  00431	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00436	48 05 80 0a 00
	00		 add	 rax, 2688		; 00000a80H
  0043c	48 8b c8	 mov	 rcx, rax
  0043f	48 8b d4	 mov	 rdx, rsp
  00442	e8 00 00 00 00	 call	 _setjmp
  00447	89 44 24 74	 mov	 DWORD PTR aswitch$[rsp], eax

; 1972 : 
; 1973 :     /* Switch architecture mode if appropriate */
; 1974 :     if(sysblk.arch_mode != regs->arch_mode)

  0044b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00452	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00457	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  0045a	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  00460	0f 84 fb 01 00
	00		 je	 $LN28@s370_run_c
$LN4@s370_run_c:

; 1975 :     {
; 1976 :         PTT_INF("*SETARCH",regs->arch_mode,sysblk.arch_mode,cpu);

  00466	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0046d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00470	48 83 e0 08	 and	 rax, 8
  00474	48 85 c0	 test	 rax, rax
  00477	74 51		 je	 SHORT $LN29@s370_run_c
  00479	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00481	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00488	48 63 89 88 00
	00 00		 movsxd	 rcx, DWORD PTR [rcx+136]
  0048f	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00494	48 63 52 64	 movsxd	 rdx, DWORD PTR [rdx+100]
  00498	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004a1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004a6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170841
  004ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004b2	4c 8b c9	 mov	 r9, rcx
  004b5	4c 8b c2	 mov	 r8, rdx
  004b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170842
  004bf	b9 08 00 00 00	 mov	 ecx, 8
  004c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@s370_run_c:
  004ca	33 c0		 xor	 eax, eax
  004cc	85 c0		 test	 eax, eax
  004ce	75 96		 jne	 SHORT $LN4@s370_run_c

; 1977 :         regs->arch_mode = sysblk.arch_mode;

  004d0	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  004d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004dc	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  004e2	89 48 64	 mov	 DWORD PTR [rax+100], ecx

; 1978 : 
; 1979 :         /* Ensure CPU ID is accurate in case archmode changed */
; 1980 :         setCpuIdregs( regs, -1, -1, -1, -1, true );

  004e5	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  004ea	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  004f2	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  004f8	66 41 b8 ff ff	 mov	 r8w, -1
  004fd	ba ff ff ff ff	 mov	 edx, -1
  00502	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00507	e8 00 00 00 00	 call	 setCpuIdregs

; 1981 : 
; 1982 :         oldregs = malloc_aligned(sizeof(REGS), 4096);

  0050c	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00511	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_malloc
  0051c	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR oldregs$[rsp], rax

; 1983 :         if (oldregs)

  00524	48 83 bc 24 38
	01 00 00 00	 cmp	 QWORD PTR oldregs$[rsp], 0
  0052d	74 40		 je	 SHORT $LN30@s370_run_c

; 1984 :         {
; 1985 :             memcpy(oldregs, regs, sizeof(REGS));

  0052f	48 8b bc 24 38
	01 00 00	 mov	 rdi, QWORD PTR oldregs$[rsp]
  00537	48 8b 74 24 60	 mov	 rsi, QWORD PTR regs$[rsp]
  0053c	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  00541	f3 a4		 rep movsb

; 1986 :             obtain_lock(&sysblk.cpulock[cpu]);

  00543	48 63 84 24 30
	01 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0054b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00552	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0055a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170845
  00561	48 8b c8	 mov	 rcx, rax
  00564	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1987 :         }

  0056a	e9 e5 00 00 00	 jmp	 $LN31@s370_run_c
$LN30@s370_run_c:

; 1988 :         else
; 1989 :         {
; 1990 :             char buf[40];
; 1991 :             MSGBUF(buf, "malloc(%d)", (int)sizeof(REGS));

  0056f	41 b9 80 60 01
	00		 mov	 r9d, 90240		; 00016080H
  00575	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170846
  0057c	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00581	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00589	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1992 :             // "Processor %s%02X: error in function %s: %s"
; 1993 :             WRMSG (HHC00813, "E", PTYPSTR(cpu), cpu, buf, strerror(errno));

  0058f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00595	8b 08		 mov	 ecx, DWORD PTR [rax]
  00597	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0059d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv274[rsp], rax
  005a5	48 63 8c 24 30
	01 00 00	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  005ad	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005b4	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  005bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  005c2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv295[rsp], rax
  005ca	b9 01 00 00 00	 mov	 ecx, 1
  005cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005d5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv274[rsp]
  005dd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005e2	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  005ea	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005ef	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  005f6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005fa	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv295[rsp]
  00602	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00607	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170847
  0060e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00613	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170848
  0061a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0061f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00624	41 b9 03 00 00
	00		 mov	 r9d, 3
  0062a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170849
  00631	ba c9 07 00 00	 mov	 edx, 1993		; 000007c9H
  00636	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170850
  0063d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1994 :             cpu_uninit (cpu, regs);

  00643	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00648	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0064f	e8 00 00 00 00	 call	 cpu_uninit
$LN31@s370_run_c:

; 1995 :         }
; 1996 :         return oldregs;

  00654	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR oldregs$[rsp]
  0065c	e9 ef 03 00 00	 jmp	 $LN1@s370_run_c
$LN28@s370_run_c:

; 1997 :     }
; 1998 : 
; 1999 :     /* Initialize Facilities List */
; 2000 :     init_cpu_facilities( regs );

  00661	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00666	e8 00 00 00 00	 call	 init_cpu_facilities

; 2001 : 
; 2002 :     /* Initialize Transactional-Execution Facility */
; 2003 :     TXF_ALLOCMAP( regs );
; 2004 : 
; 2005 :     /* Get pointer to primary opcode table */
; 2006 :     current_opcode_table = regs->ARCH_DEP( runtime_opcode_xxxx );

  0066b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00670	48 8b 80 c8 af
	00 00		 mov	 rax, QWORD PTR [rax+45000]
  00677	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR current_opcode_table$[rsp], rax

; 2007 : 
; 2008 :     /* Signal cpu has started */
; 2009 :     if(!aswitch)

  0067f	83 7c 24 74 00	 cmp	 DWORD PTR aswitch$[rsp], 0
  00684	75 1d		 jne	 SHORT $LN32@s370_run_c

; 2010 :         signal_condition (&sysblk.cpucond);

  00686	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0068d	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  00693	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170852
  0069a	48 8b c8	 mov	 rcx, rax
  0069d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN32@s370_run_c:

; 2011 : 
; 2012 :     RELEASE_INTLOCK(regs);

  006a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170853
  006aa	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006af	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2013 : 
; 2014 :     /* Establish longjmp destination for program check or
; 2015 :        RETURN_INTCHECK, or SIE_INTERCEPT, or longjmp, etc.
; 2016 :     */
; 2017 :     if (setjmp( regs->progjmp ) && sysblk.ipled)

  006b4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006b9	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  006bf	48 8b c8	 mov	 rcx, rax
  006c2	48 8b d4	 mov	 rdx, rsp
  006c5	e8 00 00 00 00	 call	 _setjmp
  006ca	85 c0		 test	 eax, eax
  006cc	74 56		 je	 SHORT $LN33@s370_run_c
  006ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006d5	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  006db	d1 e8		 shr	 eax, 1
  006dd	83 e0 01	 and	 eax, 1
  006e0	85 c0		 test	 eax, eax
  006e2	74 40		 je	 SHORT $LN33@s370_run_c

; 2018 :     {
; 2019 :         /* Our instruction execution loop further below didn't finish
; 2020 :            due to a longjmp(progjmp) having been executed bringing us
; 2021 :            to here, thereby causing the instruction counter to not be
; 2022 :            properly updated. Thus, we need to update it here instead.
; 2023 :        */
; 2024 :         regs->instcount   +=     (i * 2);

  006e4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006e9	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  006ef	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  006f3	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  006f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006fb	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2025 :         UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  00701	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00705	03 c0		 add	 eax, eax
  00707	48 98		 cdqe
  00709	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00710	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  00717	48 8b d0	 mov	 rdx, rax
  0071a	e8 00 00 00 00	 call	 atomic_update64

; 2026 : 
; 2027 :         /* Perform automatic instruction tracing if it's enabled */
; 2028 :         do_automatic_tracing();

  0071f	e8 00 00 00 00	 call	 do_automatic_tracing
$LN33@s370_run_c:

; 2029 :     }
; 2030 : 
; 2031 :     /* Set `execflag' to 0 in case EXecuted instruction did a longjmp() */
; 2032 :     regs->execflag = 0;

  00724	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00729	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0072f	83 e0 fe	 and	 eax, -2			; fffffffeH
  00732	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00737	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$fastest_no_txf_loop$54:

; 2033 : 
; 2034 :     //--------------------------------------------------------------
; 2035 :     //                    PROGRAMMING NOTE
; 2036 :     //--------------------------------------------------------------
; 2037 :     // The first 'fastest_no_txf_loop' loop below is used when the
; 2038 :     // TXF facility is not enabled, and since facilities cannot be
; 2039 :     // enabled or disabled once the guest system has been IPLed and
; 2040 :     // started, it utilizes our original instruction execution loop
; 2041 :     // which uses the 'EXECUTE_INSTRUCTION' and 'UNROLLED_EXECUTE'
; 2042 :     // macros which do not have any TXF related code in them.
; 2043 :     //
; 2044 :     // The second and third loops below (the 'txf_facility_loop' and
; 2045 :     // 'txf_slower_loop') are used when the TXF facility is enabled,
; 2046 :     // requiring us to check whether or not a transaction is active
; 2047 :     // or not after each instruction is executed.
; 2048 :     //
; 2049 :     // If no transaction is active, the normal 'EXECUTE_INSTRUCTION'
; 2050 :     // and 'UNROLLED_EXECUTE' macros can be used, but a check for an
; 2051 :     // active transaction still needs to be performed after each and
; 2052 :     // every instruction (so we can know which loop we need to use).
; 2053 :     //
; 2054 :     // When a transaction is active, we use the third (slowest) loop
; 2055 :     // called 'txf_slower_loop', using the 'TXF_EXECUTE_INSTRUCTION'
; 2056 :     // and 'TXF_UNROLLED_EXECUTE' macros, which contain code that
; 2057 :     // enforces certain Transaction-Exceution Facility constraints.
; 2058 :     //--------------------------------------------------------------
; 2059 : 
; 2060 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 2061 :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 2062 :         if (regs->CR(0) & CR0_TXC)
; 2063 :             goto txf_facility_loop;
; 2064 : #endif
; 2065 : 
; 2066 : fastest_no_txf_loop:
; 2067 : 
; 2068 :     if (INTERRUPT_PENDING( regs ))

  0073d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00742	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00747	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0074a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0074d	23 c1		 and	 eax, ecx
  0074f	85 c0		 test	 eax, eax
  00751	74 0a		 je	 SHORT $LN34@s370_run_c

; 2069 :         ARCH_DEP( process_interrupt )( regs );

  00753	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00758	e8 00 00 00 00	 call	 s370_process_interrupt
$LN34@s370_run_c:
$enter_fastest_no_txf_loop$55:

; 2070 : 
; 2071 : enter_fastest_no_txf_loop:
; 2072 : 
; 2073 :     ip = INSTRUCTION_FETCH( regs, 0 );

  0075d	33 c0		 xor	 eax, eax
  0075f	83 f8 01	 cmp	 eax, 1
  00762	74 17		 je	 SHORT $LN45@s370_run_c
  00764	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00769	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0076e	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00775	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00779	72 10		 jb	 SHORT $LN46@s370_run_c
$LN45@s370_run_c:
  0077b	33 c0		 xor	 eax, eax
  0077d	85 c0		 test	 eax, eax
  0077f	75 0a		 jne	 SHORT $LN46@s370_run_c
  00781	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv357[rsp], 0
  00789	eb 08		 jmp	 SHORT $LN50@s370_run_c
$LN46@s370_run_c:
  0078b	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv357[rsp], 1
$LN50@s370_run_c:
  00793	83 7c 24 70 00	 cmp	 DWORD PTR tv357[rsp], 0
  00798	74 13		 je	 SHORT $LN51@s370_run_c
  0079a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0079f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  007a3	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv363[rsp], rax
  007ab	eb 14		 jmp	 SHORT $LN52@s370_run_c
$LN51@s370_run_c:
  007ad	33 d2		 xor	 edx, edx
  007af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007b4	e8 00 00 00 00	 call	 s370_instfetch
  007b9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv363[rsp], rax
$LN52@s370_run_c:
  007c1	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv363[rsp]
  007c9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ip$[rsp], rax
$LN7@s370_run_c:

; 2074 :     PROCESS_TRACE( regs, ip, enter_fastest_no_txf_loop );

  007d1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007d6	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007dc	c1 e8 10	 shr	 eax, 16
  007df	83 e0 01	 and	 eax, 1
  007e2	85 c0		 test	 eax, eax
  007e4	0f 84 e3 00 00
	00		 je	 $LN35@s370_run_c
  007ea	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR ip$[rsp]
  007f2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007f7	e8 00 00 00 00	 call	 s370_process_trace
  007fc	33 c0		 xor	 eax, eax
  007fe	83 f8 01	 cmp	 eax, 1
  00801	0f 84 c6 00 00
	00		 je	 $LN36@s370_run_c
  00807	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0080c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00812	c1 e8 11	 shr	 eax, 17
  00815	83 e0 01	 and	 eax, 1
  00818	85 c0		 test	 eax, eax
  0081a	0f 84 ad 00 00
	00		 je	 $LN36@s370_run_c
  00820	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00825	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0082d	0f 85 9a 00 00
	00		 jne	 $LN36@s370_run_c
  00833	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00838	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0083f	89 44 24 78	 mov	 DWORD PTR tv378[rsp], eax
  00843	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00848	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0084f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00856	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0085e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00864	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv380[rsp], rax
  0086c	b9 01 00 00 00	 mov	 ecx, 1
  00871	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00877	8b 4c 24 78	 mov	 ecx, DWORD PTR tv378[rsp]
  0087b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0087f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv380[rsp]
  00887	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0088c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170858
  00893	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00898	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170859
  0089f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  008af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170860
  008b6	ba 1a 08 00 00	 mov	 edx, 2074		; 0000081aH
  008bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170861
  008c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  008c8	e9 90 fe ff ff	 jmp	 $enter_fastest_no_txf_loop$55
$LN36@s370_run_c:
$LN35@s370_run_c:
  008cd	33 c0		 xor	 eax, eax
  008cf	85 c0		 test	 eax, eax
  008d1	0f 85 fa fe ff
	ff		 jne	 $LN7@s370_run_c
$LN10@s370_run_c:

; 2075 :     EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );

  008d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  008df	e8 00 00 00 00	 call	 fetch_hw_noswap
  008e4	0f b7 c8	 movzx	 ecx, ax
  008e7	e8 00 00 00 00	 call	 _byteswap_ushort
  008ec	0f b7 c0	 movzx	 eax, ax
  008ef	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  008f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  008fc	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  00904	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00907	33 c0		 xor	 eax, eax
  00909	85 c0		 test	 eax, eax
  0090b	75 ca		 jne	 SHORT $LN10@s370_run_c

; 2076 :     regs->instcount++;

  0090d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00912	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00918	ff c0		 inc	 eax
  0091a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0091f	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2077 :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  00925	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0092c	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  00932	ba 01 00 00 00	 mov	 edx, 1
  00937	48 8b c8	 mov	 rcx, rax
  0093a	e8 00 00 00 00	 call	 atomic_update64

; 2078 : 
; 2079 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)

  0093f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00947	eb 0a		 jmp	 SHORT $LN13@s370_run_c
$LN11@s370_run_c:
  00949	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0094d	ff c0		 inc	 eax
  0094f	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN13@s370_run_c:
  00953	81 7c 24 68 80
	00 00 00	 cmp	 DWORD PTR i$[rsp], 128	; 00000080H
  0095b	0f 8d aa 00 00
	00		 jge	 $LN12@s370_run_c

; 2080 :     {
; 2081 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  00961	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00966	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0096b	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  00972	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  00976	72 05		 jb	 SHORT $LN37@s370_run_c
  00978	e9 8e 00 00 00	 jmp	 $LN12@s370_run_c
$LN37@s370_run_c:
$LN16@s370_run_c:
  0097d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00982	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  00986	e8 00 00 00 00	 call	 fetch_hw_noswap
  0098b	0f b7 c8	 movzx	 ecx, ax
  0098e	e8 00 00 00 00	 call	 _byteswap_ushort
  00993	0f b7 c0	 movzx	 eax, ax
  00996	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0099b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  009a0	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  009a4	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  009ac	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  009af	33 c0		 xor	 eax, eax
  009b1	85 c0		 test	 eax, eax
  009b3	75 c8		 jne	 SHORT $LN16@s370_run_c

; 2082 :         UNROLLED_EXECUTE( current_opcode_table, regs );

  009b5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  009ba	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  009bf	48 8b 89 08 02
	00 00		 mov	 rcx, QWORD PTR [rcx+520]
  009c6	48 39 48 68	 cmp	 QWORD PTR [rax+104], rcx
  009ca	72 02		 jb	 SHORT $LN38@s370_run_c
  009cc	eb 3d		 jmp	 SHORT $LN12@s370_run_c
$LN38@s370_run_c:
$LN19@s370_run_c:
  009ce	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  009d3	48 8b 48 68	 mov	 rcx, QWORD PTR [rax+104]
  009d7	e8 00 00 00 00	 call	 fetch_hw_noswap
  009dc	0f b7 c8	 movzx	 ecx, ax
  009df	e8 00 00 00 00	 call	 _byteswap_ushort
  009e4	0f b7 c0	 movzx	 eax, ax
  009e7	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  009ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  009f1	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  009f5	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR current_opcode_table$[rsp]
  009fd	ff 14 c7	 call	 QWORD PTR [rdi+rax*8]
  00a00	33 c0		 xor	 eax, eax
  00a02	85 c0		 test	 eax, eax
  00a04	75 c8		 jne	 SHORT $LN19@s370_run_c

; 2083 :     }

  00a06	e9 3e ff ff ff	 jmp	 $LN11@s370_run_c
$LN12@s370_run_c:

; 2084 :     regs->instcount   +=     (i * 2);

  00a0b	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00a10	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  00a16	8b 4c 24 68	 mov	 ecx, DWORD PTR i$[rsp]
  00a1a	8d 04 48	 lea	 eax, DWORD PTR [rax+rcx*2]
  00a1d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00a22	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 2085 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );

  00a28	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a2c	d1 e0		 shl	 eax, 1
  00a2e	48 98		 cdqe
  00a30	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a37	48 81 c1 80 14
	00 00		 add	 rcx, 5248		; 00001480H
  00a3e	48 8b d0	 mov	 rdx, rax
  00a41	e8 00 00 00 00	 call	 atomic_update64

; 2086 : 
; 2087 :     /* Perform automatic instruction tracing if it's enabled */
; 2088 :     do_automatic_tracing();

  00a46	e8 00 00 00 00	 call	 do_automatic_tracing

; 2089 :     goto fastest_no_txf_loop;

  00a4b	e9 ed fc ff ff	 jmp	 $fastest_no_txf_loop$54
$LN1@s370_run_c:
$LN39@s370_run_c:

; 2090 : 
; 2091 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 2092 : 
; 2093 : txf_facility_loop:
; 2094 : 
; 2095 :     if (INTERRUPT_PENDING( regs ))
; 2096 :         ARCH_DEP( process_interrupt )( regs );
; 2097 : 
; 2098 :     if (regs->txf_tnd)
; 2099 :         goto enter_txf_slower_loop;
; 2100 : 
; 2101 : enter_txf_faster_loop:
; 2102 : 
; 2103 :     ip = INSTRUCTION_FETCH( regs, 0 );
; 2104 :     PROCESS_TRACE( regs, ip, enter_txf_faster_loop );
; 2105 :     EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );
; 2106 :     regs->instcount++;
; 2107 :     UPDATE_SYSBLK_INSTCOUNT( 1 );
; 2108 : 
; 2109 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 2110 :     {
; 2111 :         if (regs->txf_tnd)
; 2112 :             break;
; 2113 : 
; 2114 :         UNROLLED_EXECUTE( current_opcode_table, regs );
; 2115 : 
; 2116 :         if (regs->txf_tnd)
; 2117 :             break;
; 2118 : 
; 2119 :         UNROLLED_EXECUTE( current_opcode_table, regs );
; 2120 :     }
; 2121 :     regs->instcount   +=     (i * 2);
; 2122 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 2123 : 
; 2124 :     /* Perform automatic instruction tracing if it's enabled */
; 2125 :     do_automatic_tracing();
; 2126 : 
; 2127 : //txf_slower_loop:
; 2128 : 
; 2129 :     if (INTERRUPT_PENDING( regs ))
; 2130 :         ARCH_DEP( process_interrupt )( regs );
; 2131 : 
; 2132 :     if (!regs->txf_tnd)
; 2133 :         goto enter_txf_faster_loop;
; 2134 : 
; 2135 : enter_txf_slower_loop:
; 2136 : 
; 2137 :     ip = INSTRUCTION_FETCH( regs, 0 );
; 2138 :     PROCESS_TRACE( regs, ip, enter_txf_slower_loop );
; 2139 :     TXF_EXECUTE_INSTRUCTION( current_opcode_table, ip, regs );
; 2140 :     regs->instcount++;
; 2141 :     UPDATE_SYSBLK_INSTCOUNT( 1 );
; 2142 : 
; 2143 :     for (i=0; i < MAX_CPU_LOOPS/2; i++)
; 2144 :     {
; 2145 :         if (!regs->txf_tnd)
; 2146 :             break;
; 2147 : 
; 2148 :         TXF_UNROLLED_EXECUTE( current_opcode_table, regs );
; 2149 : 
; 2150 :         if (!regs->txf_tnd)
; 2151 :             break;
; 2152 : 
; 2153 :         TXF_UNROLLED_EXECUTE( current_opcode_table, regs );
; 2154 :     }
; 2155 :     regs->instcount   +=     (i * 2);
; 2156 :     UPDATE_SYSBLK_INSTCOUNT( (i * 2) );
; 2157 : 
; 2158 :     /* Perform automatic instruction tracing if it's enabled */
; 2159 :     do_automatic_tracing();
; 2160 :     goto txf_facility_loop;
; 2161 : 
; 2162 : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 2163 : 
; 2164 :     UNREACHABLE_CODE( return NULL );
; 2165 : 
; 2166 : } /* end function run_cpu */

  00a50	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a58	48 33 cc	 xor	 rcx, rsp
  00a5b	e8 00 00 00 00	 call	 __security_check_cookie
  00a60	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00a67	5f		 pop	 rdi
  00a68	5e		 pop	 rsi
  00a69	c3		 ret	 0
s370_run_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv91 = 80
tv152 = 84
tv165 = 88
tv204 = 92
tv292 = 96
tv408 = 100
tv256 = 104
tv358 = 108
tv258 = 112
saved_timer$1 = 120
tv360 = 128
buf$2 = 136
__$ArrayPad$ = 176
regs$ = 208
s370_process_interrupt PROC

; 1680 : {

$LN83:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1681 :     /* Process PER program interrupts */
; 1682 :     if( OPEN_IC_PER(regs) )

  0001e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00026	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00031	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00034	23 c1		 and	 eax, ecx
  00036	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0003b	85 c0		 test	 eax, eax
  0003d	74 1b		 je	 SHORT $LN35@s370_proce

; 1683 :         regs->program_interrupt (regs, PGM_PER_EVENT);

  0003f	ba 80 00 00 00	 mov	 edx, 128		; 00000080H
  00044	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00054	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@s370_proce:

; 1684 : 
; 1685 :     /* Obtain the interrupt lock */
; 1686 :     OBTAIN_INTLOCK(regs);

  0005a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170723
  00061	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00069	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN4@s370_proce:

; 1687 :     OFF_IC_INTERRUPT(regs);

  0006e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00076	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00079	0f ba f0 1f	 btr	 eax, 31
  0007d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00088	33 c0		 xor	 eax, eax
  0008a	85 c0		 test	 eax, eax
  0008c	75 e0		 jne	 SHORT $LN4@s370_proce

; 1688 :     regs->breakortrace = (sysblk.instbreak || (sysblk.insttrace && regs->insttrace));

  0008e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00095	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0009b	c1 e8 0a	 shr	 eax, 10
  0009e	83 e0 01	 and	 eax, 1
  000a1	85 c0		 test	 eax, eax
  000a3	75 39		 jne	 SHORT $LN61@s370_proce
  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ac	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000b2	c1 e8 08	 shr	 eax, 8
  000b5	83 e0 01	 and	 eax, 1
  000b8	85 c0		 test	 eax, eax
  000ba	74 18		 je	 SHORT $LN60@s370_proce
  000bc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000ca	c1 e8 0f	 shr	 eax, 15
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	75 0a		 jne	 SHORT $LN61@s370_proce
$LN60@s370_proce:
  000d4	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
  000dc	eb 08		 jmp	 SHORT $LN62@s370_proce
$LN61@s370_proce:
  000de	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
$LN62@s370_proce:
  000e6	8b 44 24 50	 mov	 eax, DWORD PTR tv91[rsp]
  000ea	83 e0 01	 and	 eax, 1
  000ed	c1 e0 10	 shl	 eax, 16
  000f0	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  000fe	0f ba f1 10	 btr	 ecx, 16
  00102	0b c8		 or	 ecx, eax
  00104	8b c1		 mov	 eax, ecx
  00106	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN7@s370_proce:

; 1689 : 
; 1690 :     /* Ensure psw.IA is set and invalidate the aia */
; 1691 :     INVALIDATE_AIA(regs);

  00114	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00124	74 56		 je	 SHORT $LN36@s370_proce
  00126	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00134	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013c	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00144	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0014b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0014f	48 2b ca	 sub	 rcx, rdx
  00152	48 03 c1	 add	 rax, rcx
  00155	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0015b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00163	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00169	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00171	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN36@s370_proce:
  0017c	33 c0		 xor	 eax, eax
  0017e	85 c0		 test	 eax, eax
  00180	75 92		 jne	 SHORT $LN7@s370_proce

; 1692 : 
; 1693 :     /* Perform invalidation */
; 1694 :     if (unlikely(regs->invalidate))

  00182	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00190	c1 e8 0e	 shr	 eax, 14
  00193	83 e0 01	 and	 eax, 1
  00196	85 c0		 test	 eax, eax
  00198	74 0a		 je	 SHORT $LN65@s370_proce
  0019a	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
  001a2	eb 08		 jmp	 SHORT $LN66@s370_proce
$LN65@s370_proce:
  001a4	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN66@s370_proce:
  001ac	83 7c 24 54 00	 cmp	 DWORD PTR tv152[rsp], 0
  001b1	74 1c		 je	 SHORT $LN37@s370_proce

; 1695 :         ARCH_DEP(invalidate_tlbe)(regs, regs->invalidate_main);

  001b3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bb	48 8b 90 00 09
	00 00		 mov	 rdx, QWORD PTR [rax+2304]
  001c2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ca	e8 00 00 00 00	 call	 s370_invalidate_tlbe
$LN37@s370_proce:

; 1696 : 
; 1697 :     /* Take interrupts if CPU is not stopped */
; 1698 :     if (likely(regs->cpustate == CPUSTATE_STARTED))

  001cf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d7	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  001db	83 f8 01	 cmp	 eax, 1
  001de	75 0a		 jne	 SHORT $LN69@s370_proce
  001e0	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv165[rsp], 1
  001e8	eb 08		 jmp	 SHORT $LN70@s370_proce
$LN69@s370_proce:
  001ea	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv165[rsp], 0
$LN70@s370_proce:
  001f2	83 7c 24 58 00	 cmp	 DWORD PTR tv165[rsp], 0
  001f7	0f 84 e5 00 00
	00		 je	 $LN38@s370_proce

; 1699 :     {
; 1700 :         /* Process machine check interrupt */
; 1701 :         if ( OPEN_IC_MCKPENDING(regs) )

  001fd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00205	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020d	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00210	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00213	23 c1		 and	 eax, ecx
  00215	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  0021a	85 c0		 test	 eax, eax
  0021c	74 16		 je	 SHORT $LN39@s370_proce

; 1702 :         {
; 1703 :             PERFORM_SERIALIZATION (regs);

  0021e	0f ae f0	 mfence
$LN10@s370_proce:

; 1704 :             PERFORM_CHKPT_SYNC (regs);

  00221	33 c0		 xor	 eax, eax
  00223	85 c0		 test	 eax, eax
  00225	75 fa		 jne	 SHORT $LN10@s370_proce

; 1705 :             ARCH_DEP (perform_mck_interrupt) (regs);

  00227	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022f	e8 00 00 00 00	 call	 s370_perform_mck_interrupt
$LN39@s370_proce:

; 1706 :         }
; 1707 : 
; 1708 :         /* Process external interrupt */
; 1709 :         if (1
; 1710 :             && OPEN_IC_EXTPENDING( regs )

  00234	33 c0		 xor	 eax, eax
  00236	83 f8 01	 cmp	 eax, 1
  00239	74 37		 je	 SHORT $LN40@s370_proce
  0023b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00243	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024b	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0024e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00251	23 c1		 and	 eax, ecx
  00253	25 f0 ff 00 00	 and	 eax, 65520		; 0000fff0H
  00258	85 c0		 test	 eax, eax
  0025a	74 16		 je	 SHORT $LN40@s370_proce

; 1711 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1712 :             /* Don't interrupt active transaction */
; 1713 :             && (0
; 1714 :                 || regs->txf_tnd == 0
; 1715 :                 || regs->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1716 :                )
; 1717 : #endif
; 1718 :         )
; 1719 :         {
; 1720 :             PERFORM_SERIALIZATION( regs );

  0025c	0f ae f0	 mfence
$LN13@s370_proce:

; 1721 :             PERFORM_CHKPT_SYNC( regs );

  0025f	33 c0		 xor	 eax, eax
  00261	85 c0		 test	 eax, eax
  00263	75 fa		 jne	 SHORT $LN13@s370_proce

; 1722 :             ARCH_DEP( perform_external_interrupt )( regs );

  00265	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026d	e8 00 00 00 00	 call	 s370_perform_external_interrupt
$LN40@s370_proce:

; 1723 :         }
; 1724 : 
; 1725 :         /* Process I/O interrupt */
; 1726 :         if (IS_IC_IOPENDING)

  00272	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00279	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  0027f	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00284	85 c0		 test	 eax, eax
  00286	74 5a		 je	 SHORT $LN41@s370_proce

; 1727 :         {
; 1728 :             if (1
; 1729 :                 && OPEN_IC_IOPENDING( regs )

  00288	33 c0		 xor	 eax, eax
  0028a	83 f8 01	 cmp	 eax, 1
  0028d	74 39		 je	 SHORT $LN42@s370_proce
  0028f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00297	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029f	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  002a2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002a5	23 c1		 and	 eax, ecx
  002a7	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002ac	85 c0		 test	 eax, eax
  002ae	74 18		 je	 SHORT $LN42@s370_proce

; 1730 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1731 :                 /* Don't interrupt active transaction */
; 1732 :                 && (0
; 1733 :                     || regs->txf_tnd == 0
; 1734 :                     || regs->txf_PPA < PPA_MUCH_HELP_THRESHOLD
; 1735 :                    )
; 1736 : #endif
; 1737 :             )
; 1738 :             {
; 1739 :                 PERFORM_SERIALIZATION( regs );

  002b0	0f ae f0	 mfence
$LN16@s370_proce:

; 1740 :                 PERFORM_CHKPT_SYNC( regs );

  002b3	33 c0		 xor	 eax, eax
  002b5	85 c0		 test	 eax, eax
  002b7	75 fa		 jne	 SHORT $LN16@s370_proce

; 1741 :                 ARCH_DEP( perform_io_interrupt )( regs );

  002b9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c1	e8 00 00 00 00	 call	 s370_perform_io_interrupt

; 1742 :             }

  002c6	eb 1a		 jmp	 SHORT $LN43@s370_proce
$LN42@s370_proce:

; 1743 :             else
; 1744 :                 WAKEUP_CPU_MASK(sysblk.waiting_mask);

  002c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170732
  002cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d6	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  002dd	e8 00 00 00 00	 call	 wakeup_cpu_mask
$LN43@s370_proce:
$LN41@s370_proce:
$LN38@s370_proce:

; 1745 :         }
; 1746 :     } /*CPU_STARTED*/
; 1747 : 
; 1748 :     /* If CPU is stopping, change status to stopped */
; 1749 :     if (unlikely(regs->cpustate == CPUSTATE_STOPPING))

  002e2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ea	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  002ee	83 f8 02	 cmp	 eax, 2
  002f1	75 0a		 jne	 SHORT $LN73@s370_proce
  002f3	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  002fb	eb 08		 jmp	 SHORT $LN74@s370_proce
$LN73@s370_proce:
  002fd	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN74@s370_proce:
  00305	83 7c 24 5c 00	 cmp	 DWORD PTR tv204[rsp], 0
  0030a	0f 84 28 02 00
	00		 je	 $LN44@s370_proce
$cpustate_stopping$84:

; 1750 :     {
; 1751 :         /* Change CPU status to stopped */
; 1752 : cpustate_stopping:
; 1753 :         regs->opinterv = 0;

  00310	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00318	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0031e	83 e0 ef	 and	 eax, -17		; ffffffefH
  00321	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00329	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1754 :         regs->cpustate = CPUSTATE_STOPPED;

  0032f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00337	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3

; 1755 : 
; 1756 :         /* Thread exit (note - intlock still held) */
; 1757 :         if (!regs->configured)

  0033b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00343	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00349	c1 e8 0b	 shr	 eax, 11
  0034c	83 e0 01	 and	 eax, 1
  0034f	85 c0		 test	 eax, eax
  00351	75 1b		 jne	 SHORT $LN45@s370_proce

; 1758 :             longjmp(regs->exitjmp, SIE_NO_INTERCEPT);

  00353	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035b	48 05 80 0b 00
	00		 add	 rax, 2944		; 00000b80H
  00361	ba ff ff ff ff	 mov	 edx, -1
  00366	48 8b c8	 mov	 rcx, rax
  00369	e8 00 00 00 00	 call	 longjmp
$LN45@s370_proce:

; 1759 : 
; 1760 :         /* If initial CPU reset pending then perform reset */
; 1761 :         if (regs->sigp_ini_reset)

  0036e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00376	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0037c	c1 e8 14	 shr	 eax, 20
  0037f	83 e0 01	 and	 eax, 1
  00382	85 c0		 test	 eax, eax
  00384	74 45		 je	 SHORT $LN46@s370_proce

; 1762 :         {
; 1763 :             PERFORM_SERIALIZATION (regs);

  00386	0f ae f0	 mfence
$LN19@s370_proce:

; 1764 :             PERFORM_CHKPT_SYNC (regs);

  00389	33 c0		 xor	 eax, eax
  0038b	85 c0		 test	 eax, eax
  0038d	75 fa		 jne	 SHORT $LN19@s370_proce

; 1765 :             ARCH_DEP (initial_cpu_reset) (regs);

  0038f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00397	e8 00 00 00 00	 call	 s370_initial_cpu_reset

; 1766 :             RELEASE_INTLOCK(regs);

  0039c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170736
  003a3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ab	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1767 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  003b0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  003be	ba ff ff ff ff	 mov	 edx, -1
  003c3	48 8b c8	 mov	 rcx, rax
  003c6	e8 00 00 00 00	 call	 longjmp
$LN46@s370_proce:

; 1768 :         }
; 1769 : 
; 1770 :         /* If a CPU reset is pending then perform the reset */
; 1771 :         if (regs->sigp_reset)

  003cb	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d3	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003d9	c1 e8 13	 shr	 eax, 19
  003dc	83 e0 01	 and	 eax, 1
  003df	85 c0		 test	 eax, eax
  003e1	74 45		 je	 SHORT $LN47@s370_proce

; 1772 :         {
; 1773 :             PERFORM_SERIALIZATION (regs);

  003e3	0f ae f0	 mfence
$LN22@s370_proce:

; 1774 :             PERFORM_CHKPT_SYNC (regs);

  003e6	33 c0		 xor	 eax, eax
  003e8	85 c0		 test	 eax, eax
  003ea	75 fa		 jne	 SHORT $LN22@s370_proce

; 1775 :             ARCH_DEP(cpu_reset) (regs);

  003ec	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f4	e8 00 00 00 00	 call	 s370_cpu_reset

; 1776 :             RELEASE_INTLOCK(regs);

  003f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170738
  00400	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00408	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1777 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  0040d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00415	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0041b	ba ff ff ff ff	 mov	 edx, -1
  00420	48 8b c8	 mov	 rcx, rax
  00423	e8 00 00 00 00	 call	 longjmp
$LN47@s370_proce:

; 1778 :         }
; 1779 : 
; 1780 :         /* Store status at absolute location 0 if requested */
; 1781 :         if (IS_IC_STORSTAT(regs))

  00428	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00430	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00433	83 e0 08	 and	 eax, 8
  00436	85 c0		 test	 eax, eax
  00438	0f 84 fa 00 00
	00		 je	 $LN48@s370_proce
$LN25@s370_proce:

; 1782 :         {
; 1783 :             OFF_IC_STORSTAT(regs);

  0043e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00446	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00449	83 e0 f7	 and	 eax, -9			; fffffff7H
  0044c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00454	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00457	33 c0		 xor	 eax, eax
  00459	85 c0		 test	 eax, eax
  0045b	75 e1		 jne	 SHORT $LN25@s370_proce

; 1784 :             ARCH_DEP(store_status) (regs, 0);

  0045d	33 d2		 xor	 edx, edx
  0045f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00467	e8 00 00 00 00	 call	 s370_store_status

; 1785 : 
; 1786 :             if (regs->insttrace && sysblk.traceFILE)

  0046c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00474	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0047a	c1 e8 0f	 shr	 eax, 15
  0047d	83 e0 01	 and	 eax, 1
  00480	85 c0		 test	 eax, eax
  00482	74 1f		 je	 SHORT $LN49@s370_proce
  00484	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0048b	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00493	74 0e		 je	 SHORT $LN49@s370_proce

; 1787 :                 tf_0808( regs );

  00495	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0808
$LN49@s370_proce:

; 1788 : 
; 1789 :             // "Processor %s%02X: store status completed"
; 1790 :             WRMSG( HHC00808, "I", PTYPSTR( regs->cpuad ), regs->cpuad );

  004a3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ab	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  004b2	89 44 24 68	 mov	 DWORD PTR tv256[rsp], eax
  004b6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004be	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  004c5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004cc	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  004d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  004da	48 89 44 24 70	 mov	 QWORD PTR tv258[rsp], rax
  004df	b9 01 00 00 00	 mov	 ecx, 1
  004e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ea	8b 4c 24 68	 mov	 ecx, DWORD PTR tv256[rsp]
  004ee	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv258[rsp]
  004f7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  004fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170741
  00503	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00508	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170742
  0050f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00514	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00519	41 b9 03 00 00
	00		 mov	 r9d, 3
  0051f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170743
  00526	ba fe 06 00 00	 mov	 edx, 1790		; 000006feH
  0052b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170744
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN48@s370_proce:
$LN44@s370_proce:

; 1791 : 
; 1792 :             /* ISW 20071102 : Do not return via longjmp here. */
; 1793 :             /*    process_interrupt needs to finish putting the */
; 1794 :             /*    CPU in its manual state                     */
; 1795 :             /*
; 1796 :             RELEASE_INTLOCK(regs);
; 1797 :             longjmp(regs->progjmp, SIE_NO_INTERCEPT);
; 1798 :             */
; 1799 :         }
; 1800 :     } /*CPUSTATE_STOPPING*/
; 1801 : 
; 1802 :     /* Perform restart interrupt if pending */
; 1803 :     if ( IS_IC_RESTART(regs) )

  00538	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00540	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00543	83 e0 02	 and	 eax, 2
  00546	85 c0		 test	 eax, eax
  00548	74 35		 je	 SHORT $LN50@s370_proce

; 1804 :     {
; 1805 :         PERFORM_SERIALIZATION (regs);

  0054a	0f ae f0	 mfence
$LN28@s370_proce:

; 1806 :         PERFORM_CHKPT_SYNC (regs);

  0054d	33 c0		 xor	 eax, eax
  0054f	85 c0		 test	 eax, eax
  00551	75 fa		 jne	 SHORT $LN28@s370_proce
$LN31@s370_proce:

; 1807 :         OFF_IC_RESTART(regs);

  00553	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0055e	83 e0 fd	 and	 eax, -3			; fffffffdH
  00561	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00569	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0056c	33 c0		 xor	 eax, eax
  0056e	85 c0		 test	 eax, eax
  00570	75 e1		 jne	 SHORT $LN31@s370_proce

; 1808 :         ARCH_DEP(restart_interrupt) (regs);

  00572	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057a	e8 00 00 00 00	 call	 s370_restart_interrupt
$LN50@s370_proce:

; 1809 :     } /* end if(restart) */
; 1810 : 
; 1811 :     /* This is where a stopped CPU will wait */
; 1812 :     if (unlikely(regs->cpustate == CPUSTATE_STOPPED))

  0057f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00587	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0058b	83 f8 03	 cmp	 eax, 3
  0058e	75 0a		 jne	 SHORT $LN77@s370_proce
  00590	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv292[rsp], 1
  00598	eb 08		 jmp	 SHORT $LN78@s370_proce
$LN77@s370_proce:
  0059a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv292[rsp], 0
$LN78@s370_proce:
  005a2	83 7c 24 60 00	 cmp	 DWORD PTR tv292[rsp], 0
  005a7	0f 84 4c 01 00
	00		 je	 $LN51@s370_proce

; 1813 :     {
; 1814 :         S64 saved_timer = get_cpu_timer(regs);

  005ad	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b5	e8 00 00 00 00	 call	 get_cpu_timer
  005ba	48 89 44 24 78	 mov	 QWORD PTR saved_timer$1[rsp], rax

; 1815 :         regs->ints_state = IC_INITIAL_STATE;

  005bf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c7	c7 40 48 01 00
	00 00		 mov	 DWORD PTR [rax+72], 1

; 1816 :         sysblk.started_mask ^= regs->cpubit;

  005ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005d5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005dd	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  005e1	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  005e8	48 33 c1	 xor	 rax, rcx
  005eb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005f2	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 1817 : 
; 1818 :         CPU_Wait(regs);

  005f9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00601	e8 00 00 00 00	 call	 CPU_Wait

; 1819 : 
; 1820 :         sysblk.started_mask |= regs->cpubit;

  00606	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0060d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00615	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00619	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00620	48 0b c1	 or	 rax, rcx
  00623	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0062a	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 1821 :         regs->ints_state |= sysblk.ints_state;

  00631	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00639	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00640	8b 89 a0 12 00
	00		 mov	 ecx, DWORD PTR [rcx+4768]
  00646	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00649	0b c1		 or	 eax, ecx
  0064b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00653	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 1822 :         set_cpu_timer(regs,saved_timer);

  00656	48 8b 54 24 78	 mov	 rdx, QWORD PTR saved_timer$1[rsp]
  0065b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00663	e8 00 00 00 00	 call	 set_cpu_timer
$LN34@s370_proce:

; 1823 : 
; 1824 :         ON_IC_INTERRUPT(regs);

  00668	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00670	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00673	0f ba e8 1f	 bts	 eax, 31
  00677	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067f	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00682	33 c0		 xor	 eax, eax
  00684	85 c0		 test	 eax, eax
  00686	75 e0		 jne	 SHORT $LN34@s370_proce

; 1825 : 
; 1826 :         /* Purge the lookaside buffers */
; 1827 :         ARCH_DEP(purge_tlb) (regs);

  00688	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00690	e8 00 00 00 00	 call	 s370_purge_tlb

; 1828 : #if defined(FEATURE_ACCESS_REGISTERS)
; 1829 :         ARCH_DEP(purge_alb) (regs);
; 1830 : #endif /*defined(FEATURE_ACCESS_REGISTERS)*/
; 1831 : 
; 1832 :         /* If the architecture mode has changed we must adapt */
; 1833 :         if(sysblk.arch_mode != regs->arch_mode)

  00695	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0069c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a4	8b 49 64	 mov	 ecx, DWORD PTR [rcx+100]
  006a7	39 88 88 00 00
	00		 cmp	 DWORD PTR [rax+136], ecx
  006ad	74 1b		 je	 SHORT $LN52@s370_proce

; 1834 :             longjmp(regs->archjmp,SIE_NO_INTERCEPT);

  006af	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b7	48 05 80 0a 00
	00		 add	 rax, 2688		; 00000a80H
  006bd	ba ff ff ff ff	 mov	 edx, -1
  006c2	48 8b c8	 mov	 rcx, rax
  006c5	e8 00 00 00 00	 call	 longjmp
$LN52@s370_proce:

; 1835 : 
; 1836 :         RELEASE_INTLOCK(regs);

  006ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170748
  006d1	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006d9	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1837 :         longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  006de	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e6	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  006ec	ba ff ff ff ff	 mov	 edx, -1
  006f1	48 8b c8	 mov	 rcx, rax
  006f4	e8 00 00 00 00	 call	 longjmp
$LN51@s370_proce:

; 1838 :     } /*CPUSTATE_STOPPED*/
; 1839 : 
; 1840 :     /* Test for wait state */
; 1841 :     if (WAITSTATE(&regs->psw))

  006f9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00701	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00705	83 e0 02	 and	 eax, 2
  00708	85 c0		 test	 eax, eax
  0070a	0f 84 b7 02 00
	00		 je	 $LN53@s370_proce

; 1842 :     {
; 1843 :         regs->waittod = host_tod();

  00710	e8 00 00 00 00	 call	 host_tod
  00715	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0071d	48 89 81 b8 07
	00 00		 mov	 QWORD PTR [rcx+1976], rax

; 1844 : 
; 1845 :         /* Test for disabled wait PSW and issue message */
; 1846 :         if (IS_IC_DISABLED_WAIT_PSW( regs ))

  00724	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0072c	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0072f	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  00734	85 c0		 test	 eax, eax
  00736	0f 85 7f 01 00
	00		 jne	 $LN54@s370_proce

; 1847 :         {
; 1848 :             /* Don't log the disabled wait when OSTAILOR VM is active
; 1849 :                unless it is the very last CPU in the configuration. */
; 1850 :             if (0
; 1851 :                 || !(sysblk.ostailor & OSTAILOR_VM)
; 1852 :                 || !(sysblk.started_mask ^ regs->cpubit)

  0073c	33 c0		 xor	 eax, eax
  0073e	85 c0		 test	 eax, eax
  00740	75 3c		 jne	 SHORT $LN56@s370_proce
  00742	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00749	8b 80 50 13 00
	00		 mov	 eax, DWORD PTR [rax+4944]
  0074f	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  00754	85 c0		 test	 eax, eax
  00756	74 26		 je	 SHORT $LN56@s370_proce
  00758	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0075f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00767	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0076b	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  00772	48 33 c1	 xor	 rax, rcx
  00775	48 85 c0	 test	 rax, rax
  00778	0f 85 02 01 00
	00		 jne	 $LN55@s370_proce
$LN56@s370_proce:

; 1853 :             )
; 1854 :             {
; 1855 :                 char buf[40];
; 1856 :                 STR_PSW( regs, buf );

  0077e	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00784	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$2[rsp]
  0078c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00794	e8 00 00 00 00	 call	 str_psw

; 1857 : 
; 1858 :                 if (regs->insttrace && sysblk.traceFILE)

  00799	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007a1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007a7	c1 e8 0f	 shr	 eax, 15
  007aa	83 e0 01	 and	 eax, 1
  007ad	85 c0		 test	 eax, eax
  007af	74 27		 je	 SHORT $LN57@s370_proce
  007b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007b8	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  007c0	74 16		 je	 SHORT $LN57@s370_proce

; 1859 :                     tf_0809( regs, buf );

  007c2	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR buf$2[rsp]
  007ca	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0809
$LN57@s370_proce:

; 1860 : 
; 1861 :                 // "Processor %s%02X: disabled wait state %s"
; 1862 :                 WRMSG( HHC00809, "I", PTYPSTR( regs->cpuad ),

  007d8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e0	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007e7	89 44 24 6c	 mov	 DWORD PTR tv358[rsp], eax
  007eb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f3	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  007fa	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00801	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00809	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0080f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv360[rsp], rax
  00817	b9 01 00 00 00	 mov	 ecx, 1
  0081c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00822	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  0082a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0082f	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv358[rsp]
  00833	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00837	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv360[rsp]
  0083f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00844	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170754
  0084b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00850	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170755
  00857	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0085c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00861	41 b9 03 00 00
	00		 mov	 r9d, 3
  00867	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170756
  0086e	ba 47 07 00 00	 mov	 edx, 1863		; 00000747H
  00873	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170757
  0087a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@s370_proce:

; 1863 :                     regs->cpuad, buf );
; 1864 :             }
; 1865 :             regs->cpustate = CPUSTATE_STOPPING;

  00880	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00888	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2

; 1866 :             RELEASE_INTLOCK( regs );

  0088c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170758
  00893	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0089b	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1867 :             longjmp( regs->progjmp, SIE_NO_INTERCEPT );

  008a0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a8	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  008ae	ba ff ff ff ff	 mov	 edx, -1
  008b3	48 8b c8	 mov	 rcx, rax
  008b6	e8 00 00 00 00	 call	 longjmp
$LN54@s370_proce:

; 1868 :         }
; 1869 : 
; 1870 :         /* Indicate waiting and invoke CPU wait */
; 1871 :         sysblk.waiting_mask |= regs->cpubit;

  008bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008c2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ca	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  008ce	48 8b 80 b8 12
	00 00		 mov	 rax, QWORD PTR [rax+4792]
  008d5	48 0b c1	 or	 rax, rcx
  008d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008df	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1872 :         CPU_Wait(regs);

  008e6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ee	e8 00 00 00 00	 call	 CPU_Wait

; 1873 : 
; 1874 :         /* Turn off the waiting bit .
; 1875 :          *
; 1876 :          * Note: ANDing off of the CPU waiting bit, rather than using
; 1877 :          * XOR, is required to handle the remote and rare case when the
; 1878 :          * CPU is removed from the sysblk.waiting_mask while in
; 1879 :          * wait_condition (intlock is NOT held; use of XOR incorrectly
; 1880 :          * turns the CPU waiting bit back on).
; 1881 :          */
; 1882 :         sysblk.waiting_mask &= ~(regs->cpubit);

  008f3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fb	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  008ff	48 f7 d0	 not	 rax
  00902	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00909	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  00910	48 23 c8	 and	 rcx, rax
  00913	48 8b c1	 mov	 rax, rcx
  00916	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0091d	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 1883 : 
; 1884 :         /* Calculate the time we waited */
; 1885 :         regs->waittime += host_tod() - regs->waittod;

  00924	e8 00 00 00 00	 call	 host_tod
  00929	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00931	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  00938	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00940	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  00947	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0094f	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 1886 :         regs->waittod = 0;

  00956	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0095e	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 1887 : 
; 1888 :         /* If late state change to stopping, go reprocess */
; 1889 :         if (unlikely(regs->cpustate == CPUSTATE_STOPPING))

  00969	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00971	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00975	83 f8 02	 cmp	 eax, 2
  00978	75 0a		 jne	 SHORT $LN81@s370_proce
  0097a	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv408[rsp], 1
  00982	eb 08		 jmp	 SHORT $LN82@s370_proce
$LN81@s370_proce:
  00984	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv408[rsp], 0
$LN82@s370_proce:
  0098c	83 7c 24 64 00	 cmp	 DWORD PTR tv408[rsp], 0
  00991	74 05		 je	 SHORT $LN58@s370_proce

; 1890 :             goto cpustate_stopping;

  00993	e9 78 f9 ff ff	 jmp	 $cpustate_stopping$84
$LN58@s370_proce:

; 1891 : 
; 1892 :         RELEASE_INTLOCK(regs);

  00998	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170760
  0099f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a7	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1893 :         longjmp(regs->progjmp, SIE_NO_INTERCEPT);

  009ac	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b4	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  009ba	ba ff ff ff ff	 mov	 edx, -1
  009bf	48 8b c8	 mov	 rcx, rax
  009c2	e8 00 00 00 00	 call	 longjmp
$LN53@s370_proce:

; 1894 :     } /* end if(wait) */
; 1895 : 
; 1896 :     /* Release the interrupt lock */
; 1897 :     RELEASE_INTLOCK(regs);

  009c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170761
  009ce	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009d6	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN59@s370_proce:

; 1898 : 
; 1899 : } /* process_interrupt */

  009db	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009e3	48 33 cc	 xor	 rcx, rsp
  009e6	e8 00 00 00 00	 call	 __security_check_cookie
  009eb	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  009f2	c3		 ret	 0
s370_process_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
rc$ = 80
tv134 = 84
xdmg$ = 88
tv385 = 92
psa$ = 96
mcic$ = 104
fsta$ = 112
tv387 = 120
regs$ = 144
s370_perform_mck_interrupt PROC

; 1601 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 1602 : int     rc;                             /* Return code               */
; 1603 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1604 : U64     mcic;                           /* Mach.check interrupt code */
; 1605 : U32     xdmg;                           /* External damage code      */
; 1606 : RADR    fsta;                           /* Failing storage address   */
; 1607 : 
; 1608 :     /* Test and clear pending machine check interrupt */
; 1609 :     rc = ARCH_DEP(present_mck_interrupt) (regs, &mcic, &xdmg, &fsta);

  0000d	4c 8d 4c 24 70	 lea	 r9, QWORD PTR fsta$[rsp]
  00012	4c 8d 44 24 58	 lea	 r8, QWORD PTR xdmg$[rsp]
  00017	48 8d 54 24 68	 lea	 rdx, QWORD PTR mcic$[rsp]
  0001c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00024	e8 00 00 00 00	 call	 s370_present_mck_interrupt
  00029	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1610 : 
; 1611 :     /* Exit if no machine check was presented */
; 1612 :     if (rc == 0) return;

  0002d	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00032	75 05		 jne	 SHORT $LN2@s370_perfo
  00034	e9 12 09 00 00	 jmp	 $LN1@s370_perfo
$LN2@s370_perfo:

; 1613 : 
; 1614 :     /* Set the main storage reference and change bits */
; 1615 :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  00039	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00041	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00044	b2 06		 mov	 dl, 6
  00046	8b c8		 mov	 ecx, eax
  00048	e8 00 00 00 00	 call	 s370_or_storage_key

; 1616 : 
; 1617 :     /* Point to the PSA in main storage */
; 1618 :     psa = (void*)(regs->mainstor + regs->PX);

  0004d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00055	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00058	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  00067	48 89 44 24 60	 mov	 QWORD PTR psa$[rsp], rax

; 1619 : 
; 1620 :     /* Store registers in machine check save area */
; 1621 :     ARCH_DEP(store_status) (regs, regs->PX);

  0006c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00077	8b d0		 mov	 edx, eax
  00079	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	e8 00 00 00 00	 call	 s370_store_status

; 1622 : 
; 1623 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1624 :     /* Set the extended logout area to zeros */
; 1625 :     memset(psa->storepsw, 0, 16);

  00086	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  0008b	48 05 00 01 00
	00		 add	 rax, 256		; 00000100H
  00091	48 8b f8	 mov	 rdi, rax
  00094	33 c0		 xor	 eax, eax
  00096	b9 10 00 00 00	 mov	 ecx, 16
  0009b	f3 aa		 rep stosb

; 1626 : #endif
; 1627 : 
; 1628 :     /* Store the machine check interrupt code at PSA+232 */
; 1629 :     STORE_DW(psa->mckint, mcic);

  0009d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mcic$[rsp]
  000a2	e8 00 00 00 00	 call	 _byteswap_uint64
  000a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  000ac	48 81 c1 e8 00
	00 00		 add	 rcx, 232		; 000000e8H
  000b3	48 8b d0	 mov	 rdx, rax
  000b6	e8 00 00 00 00	 call	 store_dw_noswap

; 1630 : 
; 1631 :     /* Trace the machine check interrupt */
; 1632 :     if (CPU_STEPPING_OR_TRACING(regs, 0))

  000bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c3	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000c9	c1 e8 10	 shr	 eax, 16
  000cc	83 e0 01	 and	 eax, 1
  000cf	85 c0		 test	 eax, eax
  000d1	74 0a		 je	 SHORT $LN28@s370_perfo
  000d3	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv134[rsp], 1
  000db	eb 08		 jmp	 SHORT $LN29@s370_perfo
$LN28@s370_perfo:
  000dd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN29@s370_perfo:
  000e5	83 7c 24 54 00	 cmp	 DWORD PTR tv134[rsp], 0
  000ea	0f 84 9d 07 00
	00		 je	 $LN3@s370_perfo
  000f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000fd	c1 e8 0a	 shr	 eax, 10
  00100	83 e0 01	 and	 eax, 1
  00103	85 c0		 test	 eax, eax
  00105	0f 84 29 03 00
	00		 je	 $LN5@s370_perfo
  0010b	33 c0		 xor	 eax, eax
  0010d	85 c0		 test	 eax, eax
  0010f	0f 85 2d 01 00
	00		 jne	 $LN6@s370_perfo
  00115	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00122	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00127	85 c0		 test	 eax, eax
  00129	0f 84 13 01 00
	00		 je	 $LN6@s370_perfo
  0012f	33 c0		 xor	 eax, eax
  00131	83 f8 01	 cmp	 eax, 1
  00134	0f 84 fa 02 00
	00		 je	 $LN5@s370_perfo
  0013a	33 c0		 xor	 eax, eax
  0013c	85 c0		 test	 eax, eax
  0013e	75 37		 jne	 SHORT $LN7@s370_perfo
  00140	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00147	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0014d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00152	85 c0		 test	 eax, eax
  00154	74 21		 je	 SHORT $LN7@s370_perfo
  00156	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00165	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0016b	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00171	0f 85 bd 02 00
	00		 jne	 $LN5@s370_perfo
$LN7@s370_perfo:
  00177	33 c0		 xor	 eax, eax
  00179	85 c0		 test	 eax, eax
  0017b	75 37		 jne	 SHORT $LN8@s370_perfo
  0017d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00184	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0018a	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0018f	85 c0		 test	 eax, eax
  00191	74 21		 je	 SHORT $LN8@s370_perfo
  00193	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  001a8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  001ae	0f 8c 80 02 00
	00		 jl	 $LN5@s370_perfo
$LN8@s370_perfo:
  001b4	33 c0		 xor	 eax, eax
  001b6	85 c0		 test	 eax, eax
  001b8	0f 85 84 00 00
	00		 jne	 $LN9@s370_perfo
  001be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c5	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  001cb	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  001d0	85 c0		 test	 eax, eax
  001d2	74 26		 je	 SHORT $LN10@s370_perfo
  001d4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dc	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  001e3	85 c0		 test	 eax, eax
  001e5	74 13		 je	 SHORT $LN10@s370_perfo
  001e7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  001f6	85 c0		 test	 eax, eax
  001f8	75 48		 jne	 SHORT $LN9@s370_perfo
$LN10@s370_perfo:
  001fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00201	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00207	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0020c	85 c0		 test	 eax, eax
  0020e	0f 84 20 02 00
	00		 je	 $LN5@s370_perfo
  00214	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00223	85 c0		 test	 eax, eax
  00225	0f 84 09 02 00
	00		 je	 $LN5@s370_perfo
  0022b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00233	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0023a	85 c0		 test	 eax, eax
  0023c	0f 85 f2 01 00
	00		 jne	 $LN5@s370_perfo
$LN9@s370_perfo:
$LN6@s370_perfo:
  00242	b8 08 00 00 00	 mov	 eax, 8
  00247	48 6b c0 00	 imul	 rax, rax, 0
  0024b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00252	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0025b	75 1f		 jne	 SHORT $LN11@s370_perfo
  0025d	b8 08 00 00 00	 mov	 eax, 8
  00262	48 6b c0 01	 imul	 rax, rax, 1
  00266	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0026d	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00276	0f 84 27 05 00
	00		 je	 $LN4@s370_perfo
$LN11@s370_perfo:
  0027c	b8 08 00 00 00	 mov	 eax, 8
  00281	48 6b c0 00	 imul	 rax, rax, 0
  00285	b9 08 00 00 00	 mov	 ecx, 8
  0028a	48 6b c9 01	 imul	 rcx, rcx, 1
  0028e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00295	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  0029c	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  002a4	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  002ac	0f 87 a6 00 00
	00		 ja	 $LN12@s370_perfo
  002b2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ba	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  002c0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d0	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  002d7	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002db	48 2b ca	 sub	 rcx, rdx
  002de	48 03 c1	 add	 rax, rcx
  002e1	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  002e7	8b c0		 mov	 eax, eax
  002e9	b9 08 00 00 00	 mov	 ecx, 8
  002ee	48 6b c9 00	 imul	 rcx, rcx, 0
  002f2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002f9	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00301	72 55		 jb	 SHORT $LN12@s370_perfo
  00303	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030b	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00311	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00321	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00328	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0032c	48 2b ca	 sub	 rcx, rdx
  0032f	48 03 c1	 add	 rax, rcx
  00332	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00338	8b c0		 mov	 eax, eax
  0033a	b9 08 00 00 00	 mov	 ecx, 8
  0033f	48 6b c9 01	 imul	 rcx, rcx, 1
  00343	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0034a	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00352	0f 86 4b 04 00
	00		 jbe	 $LN4@s370_perfo
$LN12@s370_perfo:
  00358	b8 08 00 00 00	 mov	 eax, 8
  0035d	48 6b c0 00	 imul	 rax, rax, 0
  00361	b9 08 00 00 00	 mov	 ecx, 8
  00366	48 6b c9 01	 imul	 rcx, rcx, 1
  0036a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00371	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00378	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  00380	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00388	0f 86 a6 00 00
	00		 jbe	 $LN13@s370_perfo
  0038e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00396	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0039c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003ac	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003b3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003b7	48 2b ca	 sub	 rcx, rdx
  003ba	48 03 c1	 add	 rax, rcx
  003bd	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  003c3	8b c0		 mov	 eax, eax
  003c5	b9 08 00 00 00	 mov	 ecx, 8
  003ca	48 6b c9 01	 imul	 rcx, rcx, 1
  003ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003d5	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  003dd	72 55		 jb	 SHORT $LN13@s370_perfo
  003df	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e7	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  003ed	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f5	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003fd	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00404	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00408	48 2b ca	 sub	 rcx, rdx
  0040b	48 03 c1	 add	 rax, rcx
  0040e	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00414	8b c0		 mov	 eax, eax
  00416	b9 08 00 00 00	 mov	 ecx, 8
  0041b	48 6b c9 00	 imul	 rcx, rcx, 0
  0041f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00426	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0042e	0f 86 6f 03 00
	00		 jbe	 $LN4@s370_perfo
$LN13@s370_perfo:
$LN5@s370_perfo:
  00434	33 c0		 xor	 eax, eax
  00436	83 f8 01	 cmp	 eax, 1
  00439	0f 84 4e 04 00
	00		 je	 $LN3@s370_perfo
  0043f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00446	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0044c	c1 e8 08	 shr	 eax, 8
  0044f	83 e0 01	 and	 eax, 1
  00452	85 c0		 test	 eax, eax
  00454	0f 84 33 04 00
	00		 je	 $LN3@s370_perfo
  0045a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00462	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00468	c1 e8 0f	 shr	 eax, 15
  0046b	83 e0 01	 and	 eax, 1
  0046e	85 c0		 test	 eax, eax
  00470	0f 84 17 04 00
	00		 je	 $LN3@s370_perfo
  00476	33 c0		 xor	 eax, eax
  00478	85 c0		 test	 eax, eax
  0047a	0f 85 2d 01 00
	00		 jne	 $LN14@s370_perfo
  00480	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00487	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0048d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00492	85 c0		 test	 eax, eax
  00494	0f 84 13 01 00
	00		 je	 $LN14@s370_perfo
  0049a	33 c0		 xor	 eax, eax
  0049c	83 f8 01	 cmp	 eax, 1
  0049f	0f 84 e8 03 00
	00		 je	 $LN3@s370_perfo
  004a5	33 c0		 xor	 eax, eax
  004a7	85 c0		 test	 eax, eax
  004a9	75 37		 jne	 SHORT $LN15@s370_perfo
  004ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004b2	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  004b8	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  004bd	85 c0		 test	 eax, eax
  004bf	74 21		 je	 SHORT $LN15@s370_perfo
  004c1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004d0	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  004d6	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  004dc	0f 85 ab 03 00
	00		 jne	 $LN3@s370_perfo
$LN15@s370_perfo:
  004e2	33 c0		 xor	 eax, eax
  004e4	85 c0		 test	 eax, eax
  004e6	75 37		 jne	 SHORT $LN16@s370_perfo
  004e8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ef	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  004f5	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  004fa	85 c0		 test	 eax, eax
  004fc	74 21		 je	 SHORT $LN16@s370_perfo
  004fe	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00506	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0050d	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00513	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00519	0f 8c 6e 03 00
	00		 jl	 $LN3@s370_perfo
$LN16@s370_perfo:
  0051f	33 c0		 xor	 eax, eax
  00521	85 c0		 test	 eax, eax
  00523	0f 85 84 00 00
	00		 jne	 $LN17@s370_perfo
  00529	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00530	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00536	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0053b	85 c0		 test	 eax, eax
  0053d	74 26		 je	 SHORT $LN18@s370_perfo
  0053f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00547	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0054e	85 c0		 test	 eax, eax
  00550	74 13		 je	 SHORT $LN18@s370_perfo
  00552	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00561	85 c0		 test	 eax, eax
  00563	75 48		 jne	 SHORT $LN17@s370_perfo
$LN18@s370_perfo:
  00565	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0056c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00572	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00577	85 c0		 test	 eax, eax
  00579	0f 84 0e 03 00
	00		 je	 $LN3@s370_perfo
  0057f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00587	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0058e	85 c0		 test	 eax, eax
  00590	0f 84 f7 02 00
	00		 je	 $LN3@s370_perfo
  00596	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0059e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  005a5	85 c0		 test	 eax, eax
  005a7	0f 85 e0 02 00
	00		 jne	 $LN3@s370_perfo
$LN17@s370_perfo:
$LN14@s370_perfo:
  005ad	b8 08 00 00 00	 mov	 eax, 8
  005b2	48 6b c0 00	 imul	 rax, rax, 0
  005b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005bd	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  005c6	75 1f		 jne	 SHORT $LN20@s370_perfo
  005c8	b8 08 00 00 00	 mov	 eax, 8
  005cd	48 6b c0 01	 imul	 rax, rax, 1
  005d1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005d8	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  005e1	0f 84 bc 01 00
	00		 je	 $LN19@s370_perfo
$LN20@s370_perfo:
  005e7	b8 08 00 00 00	 mov	 eax, 8
  005ec	48 6b c0 00	 imul	 rax, rax, 0
  005f0	b9 08 00 00 00	 mov	 ecx, 8
  005f5	48 6b c9 01	 imul	 rcx, rcx, 1
  005f9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00600	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00607	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  0060f	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  00617	0f 87 a6 00 00
	00		 ja	 $LN21@s370_perfo
  0061d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00625	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0062b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00633	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0063b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00642	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00646	48 2b ca	 sub	 rcx, rdx
  00649	48 03 c1	 add	 rax, rcx
  0064c	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00652	8b c0		 mov	 eax, eax
  00654	b9 08 00 00 00	 mov	 ecx, 8
  00659	48 6b c9 00	 imul	 rcx, rcx, 0
  0065d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00664	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0066c	72 55		 jb	 SHORT $LN21@s370_perfo
  0066e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00676	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0067c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00684	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0068c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00693	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00697	48 2b ca	 sub	 rcx, rdx
  0069a	48 03 c1	 add	 rax, rcx
  0069d	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  006a3	8b c0		 mov	 eax, eax
  006a5	b9 08 00 00 00	 mov	 ecx, 8
  006aa	48 6b c9 01	 imul	 rcx, rcx, 1
  006ae	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006b5	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  006bd	0f 86 e0 00 00
	00		 jbe	 $LN19@s370_perfo
$LN21@s370_perfo:
  006c3	b8 08 00 00 00	 mov	 eax, 8
  006c8	48 6b c0 00	 imul	 rax, rax, 0
  006cc	b9 08 00 00 00	 mov	 ecx, 8
  006d1	48 6b c9 01	 imul	 rcx, rcx, 1
  006d5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006dc	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  006e3	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  006eb	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  006f3	0f 86 94 01 00
	00		 jbe	 $LN3@s370_perfo
  006f9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00701	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00707	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0070f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00717	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0071e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00722	48 2b ca	 sub	 rcx, rdx
  00725	48 03 c1	 add	 rax, rcx
  00728	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0072e	8b c0		 mov	 eax, eax
  00730	b9 08 00 00 00	 mov	 ecx, 8
  00735	48 6b c9 01	 imul	 rcx, rcx, 1
  00739	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00740	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00748	0f 82 3f 01 00
	00		 jb	 $LN3@s370_perfo
  0074e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00756	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0075c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00764	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0076c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00773	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00777	48 2b ca	 sub	 rcx, rdx
  0077a	48 03 c1	 add	 rax, rcx
  0077d	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00783	8b c0		 mov	 eax, eax
  00785	b9 08 00 00 00	 mov	 ecx, 8
  0078a	48 6b c9 00	 imul	 rcx, rcx, 0
  0078e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00795	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0079d	0f 87 ea 00 00
	00		 ja	 $LN3@s370_perfo
$LN19@s370_perfo:
$LN4@s370_perfo:

; 1633 :     {
; 1634 :         if (regs->insttrace && sysblk.traceFILE)

  007a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ab	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007b1	c1 e8 0f	 shr	 eax, 15
  007b4	83 e0 01	 and	 eax, 1
  007b7	85 c0		 test	 eax, eax
  007b9	74 33		 je	 SHORT $LN22@s370_perfo
  007bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007c2	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  007ca	74 22		 je	 SHORT $LN22@s370_perfo

; 1635 :             tf_0807( regs, mcic, fsta, xdmg );

  007cc	44 8b 4c 24 58	 mov	 r9d, DWORD PTR xdmg$[rsp]
  007d1	4c 8b 44 24 70	 mov	 r8, QWORD PTR fsta$[rsp]
  007d6	48 8b 54 24 68	 mov	 rdx, QWORD PTR mcic$[rsp]
  007db	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0807
  007e9	e9 9f 00 00 00	 jmp	 $LN23@s370_perfo
$LN22@s370_perfo:

; 1636 :         else
; 1637 :             // "Processor %s%02X: machine check code %16.16"PRIu64
; 1638 :             WRMSG (HHC00807, "I", PTYPSTR(regs->cpuad), regs->cpuad, mcic);

  007ee	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f6	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  007fd	89 44 24 5c	 mov	 DWORD PTR tv385[rsp], eax
  00801	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00809	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00810	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00817	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0081f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00825	48 89 44 24 78	 mov	 QWORD PTR tv387[rsp], rax
  0082a	b9 01 00 00 00	 mov	 ecx, 1
  0082f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00835	48 8b 4c 24 68	 mov	 rcx, QWORD PTR mcic$[rsp]
  0083a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0083f	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv385[rsp]
  00843	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00847	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv387[rsp]
  0084c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00851	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170616
  00858	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0085d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170617
  00864	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00869	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0086e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00874	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170618
  0087b	ba 66 06 00 00	 mov	 edx, 1638		; 00000666H
  00880	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170619
  00887	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@s370_perfo:
$LN3@s370_perfo:

; 1639 :     }
; 1640 : 
; 1641 :     /* Store the external damage code at PSA+244 */
; 1642 :     STORE_FW(psa->xdmgcode, xdmg);

  0088d	8b 4c 24 58	 mov	 ecx, DWORD PTR xdmg$[rsp]
  00891	e8 00 00 00 00	 call	 _byteswap_ulong
  00896	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  0089b	48 81 c1 f4 00
	00 00		 add	 rcx, 244		; 000000f4H
  008a2	8b d0		 mov	 edx, eax
  008a4	e8 00 00 00 00	 call	 store_fw_noswap

; 1643 : 
; 1644 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1645 :     /* Store the failing storage address at PSA+248 */
; 1646 :     STORE_DW(psa->mcstorad, fsta);
; 1647 : #else
; 1648 :     /* Store the failing storage address at PSA+248 */
; 1649 :     STORE_FW(psa->mcstorad, fsta);

  008a9	8b 4c 24 70	 mov	 ecx, DWORD PTR fsta$[rsp]
  008ad	e8 00 00 00 00	 call	 _byteswap_ulong
  008b2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR psa$[rsp]
  008b7	48 81 c1 f8 00
	00 00		 add	 rcx, 248		; 000000f8H
  008be	8b d0		 mov	 edx, eax
  008c0	e8 00 00 00 00	 call	 store_fw_noswap

; 1650 : #endif
; 1651 : 
; 1652 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1653 :     /* Abort any active transaction and then return back to here
; 1654 :        to continue with machine check interrupt processing */
; 1655 :     if (regs->txf_tnd)
; 1656 :     {
; 1657 :         PTT_TXF( "*TXF MCK", 0, regs->txf_contran, regs->txf_tnd );
; 1658 :         regs->txf_why |= TXF_WHY_MCK_INT;
; 1659 :         ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_MCK );
; 1660 :     }
; 1661 : #endif
; 1662 :     /* Store current PSW at PSA+X'30' */
; 1663 :     ARCH_DEP(store_psw) ( regs, psa->mckold );

  008c5	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  008ca	48 83 c0 30	 add	 rax, 48			; 00000030H
  008ce	48 8b d0	 mov	 rdx, rax
  008d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d9	e8 00 00 00 00	 call	 s370_store_psw

; 1664 : 
; 1665 :     /* Load new PSW from PSA+X'70' */
; 1666 :     rc = ARCH_DEP(load_psw) ( regs, psa->mcknew );

  008de	48 8b 44 24 60	 mov	 rax, QWORD PTR psa$[rsp]
  008e3	48 83 c0 70	 add	 rax, 112		; 00000070H
  008e7	48 8b d0	 mov	 rdx, rax
  008ea	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f2	e8 00 00 00 00	 call	 s370_load_psw
  008f7	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1667 : 
; 1668 :     RELEASE_INTLOCK(regs);

  008fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170620
  00902	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0090a	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1669 : 
; 1670 :     if ( rc )

  0090f	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00914	74 1a		 je	 SHORT $LN24@s370_perfo

; 1671 :         regs->program_interrupt (regs, rc);

  00916	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  0091a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00922	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0092a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@s370_perfo:

; 1672 : 
; 1673 :     longjmp (regs->progjmp, SIE_INTERCEPT_MCK);

  00930	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00938	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0093e	ba f5 ff ff ff	 mov	 edx, -11
  00943	48 8b c8	 mov	 rcx, rax
  00946	e8 00 00 00 00	 call	 longjmp
$LN1@s370_perfo:
$LN25@s370_perfo:

; 1674 : } /* end function perform_mck_interrupt */

  0094b	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00952	5f		 pop	 rdi
  00953	c3		 ret	 0
s370_perform_mck_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
rc$ = 64
psa$ = 72
regs$ = 96
s370_restart_interrupt PROC

; 1408 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@s370_resta:

; 1409 : int     rc;                             /* Return code               */
; 1410 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1411 : 
; 1412 :     PTT_INF("*RESTART",regs->cpuad,regs->cpustate,regs->psw.IA_L);

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00010	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00013	48 83 e0 08	 and	 rax, 8
  00017	48 85 c0	 test	 rax, rax
  0001a	74 52		 je	 SHORT $LN5@s370_resta
  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0002c	0f b6 49 60	 movzx	 ecx, BYTE PTR [rcx+96]
  00030	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00035	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  0003c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00045	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170465
  00051	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00056	44 8b c9	 mov	 r9d, ecx
  00059	44 8b c2	 mov	 r8d, edx
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170466
  00063	b9 08 00 00 00	 mov	 ecx, 8
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN5@s370_resta:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 95		 jne	 SHORT $LN4@s370_resta

; 1413 : 
; 1414 :     /* Set the main storage reference and change bits */
; 1415 :     ARCH_DEP( or_storage_key )( regs->PX, (STORKEY_REF | STORKEY_CHANGE) );

  00074	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00079	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0007c	b2 06		 mov	 dl, 6
  0007e	8b c8		 mov	 ecx, eax
  00080	e8 00 00 00 00	 call	 s370_or_storage_key

; 1416 : 
; 1417 :     /* Zeroize the interrupt code in the PSW */
; 1418 :     regs->psw.intcode = 0;

  00085	33 c0		 xor	 eax, eax
  00087	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 1419 : 
; 1420 :     /* Point to PSA in main storage */
; 1421 :     psa = (PSA*)(regs->mainstor + regs->PX);

  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00098	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0009b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000a0	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  000a7	48 89 44 24 48	 mov	 QWORD PTR psa$[rsp], rax

; 1422 : 
; 1423 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1424 :     /* Abort any active transaction and then return back to here
; 1425 :        to continue with restart interrupt processing */
; 1426 :     if (regs->txf_tnd)
; 1427 :     {
; 1428 :         PTT_TXF( "*TXF MISC", 0, regs->txf_contran, regs->txf_tnd );
; 1429 :         regs->txf_why |= TXF_WHY_RESTART_INT;
; 1430 :         ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_MISC );
; 1431 :     }
; 1432 : #endif
; 1433 :     /* Store current PSW at PSA+X'8' or PSA+X'120' for ESAME  */
; 1434 :     ARCH_DEP(store_psw) (regs, psa->RSTOLD);

  000ac	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  000b1	48 83 c0 08	 add	 rax, 8
  000b5	48 8b d0	 mov	 rdx, rax
  000b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000bd	e8 00 00 00 00	 call	 s370_store_psw

; 1435 : 
; 1436 :     /* Load new PSW from PSA+X'0' or PSA+X'1A0' for ESAME */
; 1437 :     rc = ARCH_DEP(load_psw) (regs, psa->RSTNEW);

  000c2	48 8b 44 24 48	 mov	 rax, QWORD PTR psa$[rsp]
  000c7	48 8b d0	 mov	 rdx, rax
  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	e8 00 00 00 00	 call	 s370_load_psw
  000d4	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 1438 : 
; 1439 :     if ( rc == 0)

  000d8	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  000dd	75 22		 jne	 SHORT $LN6@s370_resta

; 1440 :     {
; 1441 :         regs->opinterv = 0;

  000df	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000e4	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000ea	83 e0 ef	 and	 eax, -17		; ffffffefH
  000ed	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1442 :         regs->cpustate = CPUSTATE_STARTED;

  000f8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1
$LN6@s370_resta:

; 1443 :     }
; 1444 : 
; 1445 :     RELEASE_INTLOCK(regs);

  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170468
  00108	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0010d	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1446 : 
; 1447 :     if ( rc )

  00112	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00117	74 14		 je	 SHORT $LN7@s370_resta

; 1448 :         regs->program_interrupt(regs, rc);

  00119	8b 54 24 40	 mov	 edx, DWORD PTR rc$[rsp]
  0011d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00127	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN7@s370_resta:

; 1449 : 
; 1450 :     longjmp (regs->progjmp, SIE_INTERCEPT_RESTART);

  0012d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00132	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00138	ba f6 ff ff ff	 mov	 edx, -10
  0013d	48 8b c8	 mov	 rcx, rax
  00140	e8 00 00 00 00	 call	 longjmp
$LN8@s370_resta:

; 1451 : } /* end function restart_interrupt */

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	c3		 ret	 0
s370_restart_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv73 = 32
processHostRegs$ = 36
tv90 = 40
tv178 = 48
tv185 = 56
tv192 = 64
cpu$ = 96
regs$ = 104
cpu_uninit PROC

; 2528 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2529 :     int processHostRegs = (regs->host &&

  0000d	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00018	c1 e8 07	 shr	 eax, 7
  0001b	83 e0 01	 and	 eax, 1
  0001e	85 c0		 test	 eax, eax
  00020	74 25		 je	 SHORT $LN6@cpu_uninit
  00022	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00036	48 39 44 24 68	 cmp	 QWORD PTR regs$[rsp], rax
  0003b	75 0a		 jne	 SHORT $LN6@cpu_uninit
  0003d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00045	eb 08		 jmp	 SHORT $LN7@cpu_uninit
$LN6@cpu_uninit:
  00047	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN7@cpu_uninit:
  0004f	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  00053	89 44 24 24	 mov	 DWORD PTR processHostRegs$[rsp], eax

; 2530 :                            regs == sysblk.regs[cpu]);
; 2531 : 
; 2532 :     if (processHostRegs)

  00057	83 7c 24 24 00	 cmp	 DWORD PTR processHostRegs$[rsp], 0
  0005c	74 7c		 je	 SHORT $LN2@cpu_uninit

; 2533 :     {
; 2534 :         obtain_lock (&sysblk.cpulock[cpu]);

  0005e	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00063	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0006a	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00072	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196990
  00079	48 8b c8	 mov	 rcx, rax
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2535 : 
; 2536 :         /* If pointing to guest REGS structure, free the guest REGS
; 2537 :          * structure ONLY if it is not ourself, and set the guest REGS
; 2538 :          * pointer to NULL;
; 2539 :          */
; 2540 :         if (GUESTREGS)

  00082	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00087	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  0008f	74 49		 je	 SHORT $LN3@cpu_uninit

; 2541 :             GUESTREGS = (regs == GUESTREGS) ?

  00091	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00096	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0009d	48 39 44 24 68	 cmp	 QWORD PTR regs$[rsp], rax
  000a2	75 0b		 jne	 SHORT $LN8@cpu_uninit
  000a4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv90[rsp], 0
  000ad	eb 1a		 jmp	 SHORT $LN9@cpu_uninit
$LN8@cpu_uninit:
  000af	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000b4	48 8b 90 70 08
	00 00		 mov	 rdx, QWORD PTR [rax+2160]
  000bb	8b 4c 24 60	 mov	 ecx, DWORD PTR cpu$[rsp]
  000bf	e8 00 00 00 00	 call	 cpu_uninit
  000c4	48 89 44 24 28	 mov	 QWORD PTR tv90[rsp], rax
$LN9@cpu_uninit:
  000c9	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000ce	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tv90[rsp]
  000d3	48 89 88 70 08
	00 00		 mov	 QWORD PTR [rax+2160], rcx
$LN3@cpu_uninit:
$LN2@cpu_uninit:

; 2542 :                 NULL : cpu_uninit( cpu, GUESTREGS );
; 2543 :     }
; 2544 : 
; 2545 :     destroy_condition(&regs->intcond);

  000da	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  000df	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_condition

; 2546 : 
; 2547 :     if (processHostRegs)

  000ee	83 7c 24 24 00	 cmp	 DWORD PTR processHostRegs$[rsp], 0
  000f3	0f 84 0e 01 00
	00		 je	 $LN4@cpu_uninit

; 2548 :     {
; 2549 : #if defined( _FEATURE_S370_S390_VECTOR_FACILITY )
; 2550 :         /* Mark Vector Facility offline */
; 2551 :         regs->vf->online = 0;
; 2552 : #endif
; 2553 : 
; 2554 :         /* Remove CPU from all CPU bit masks */
; 2555 :         sysblk.config_mask &= ~CPU_BIT(cpu);

  000f9	8b 44 24 60	 mov	 eax, DWORD PTR cpu$[rsp]
  000fd	b9 01 00 00 00	 mov	 ecx, 1
  00102	48 89 4c 24 30	 mov	 QWORD PTR tv178[rsp], rcx
  00107	0f b6 c8	 movzx	 ecx, al
  0010a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv178[rsp]
  0010f	48 d3 e0	 shl	 rax, cl
  00112	48 f7 d0	 not	 rax
  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0011c	48 8b 89 a8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4776]
  00123	48 23 c8	 and	 rcx, rax
  00126	48 8b c1	 mov	 rax, rcx
  00129	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00130	48 89 81 a8 12
	00 00		 mov	 QWORD PTR [rcx+4776], rax

; 2556 :         sysblk.started_mask &= ~CPU_BIT(cpu);

  00137	8b 44 24 60	 mov	 eax, DWORD PTR cpu$[rsp]
  0013b	b9 01 00 00 00	 mov	 ecx, 1
  00140	48 89 4c 24 38	 mov	 QWORD PTR tv185[rsp], rcx
  00145	0f b6 c8	 movzx	 ecx, al
  00148	48 8b 44 24 38	 mov	 rax, QWORD PTR tv185[rsp]
  0014d	48 d3 e0	 shl	 rax, cl
  00150	48 f7 d0	 not	 rax
  00153	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0015a	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  00161	48 23 c8	 and	 rcx, rax
  00164	48 8b c1	 mov	 rax, rcx
  00167	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0016e	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2557 :         sysblk.waiting_mask &= ~CPU_BIT(cpu);

  00175	8b 44 24 60	 mov	 eax, DWORD PTR cpu$[rsp]
  00179	b9 01 00 00 00	 mov	 ecx, 1
  0017e	48 89 4c 24 40	 mov	 QWORD PTR tv192[rsp], rcx
  00183	0f b6 c8	 movzx	 ecx, al
  00186	48 8b 44 24 40	 mov	 rax, QWORD PTR tv192[rsp]
  0018b	48 d3 e0	 shl	 rax, cl
  0018e	48 f7 d0	 not	 rax
  00191	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00198	48 8b 89 b8 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4792]
  0019f	48 23 c8	 and	 rcx, rax
  001a2	48 8b c1	 mov	 rax, rcx
  001a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ac	48 89 81 b8 12
	00 00		 mov	 QWORD PTR [rcx+4792], rax

; 2558 :         sysblk.regs[cpu] = NULL;

  001b3	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  001b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001bf	48 c7 84 c1 98
	0b 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+2968], 0

; 2559 :         sysblk.cpucreateTOD[cpu] = 0;

  001cb	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  001d0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d7	48 c7 84 c1 48
	07 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+1864], 0

; 2560 :         release_lock (&sysblk.cpulock[cpu]);

  001e3	48 63 44 24 60	 movsxd	 rax, DWORD PTR cpu$[rsp]
  001e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ef	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  001f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196993
  001fe	48 8b c8	 mov	 rcx, rax
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN4@cpu_uninit:

; 2561 :     }
; 2562 : 
; 2563 :     /* Free the REGS structure */
; 2564 :     TXF_FREEMAP( regs );

  00207	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0020c	e8 00 00 00 00	 call	 free_txfmap

; 2565 :     free_aligned( regs );

  00211	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 2566 : 
; 2567 :     return NULL;

  0021c	33 c0		 xor	 eax, eax

; 2568 : }

  0021e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00222	c3		 ret	 0
cpu_uninit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 48
CPU_Wait PROC

; 2577 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2578 :     /* Indicate we are giving up intlock */
; 2579 :     sysblk.intowner = LOCK_OWNER_NONE;

  00009	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0000e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00015	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN2@CPU_Wait:

; 2580 : 
; 2581 :     /* Wait while SYNCHRONIZE_CPUS is in progress */
; 2582 :     while (sysblk.syncing)

  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00023	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  0002a	85 c0		 test	 eax, eax
  0002c	0f 84 93 00 00
	00		 je	 $LN3@CPU_Wait

; 2583 :     {
; 2584 :         sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003e	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00042	48 f7 d0	 not	 rax
  00045	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004c	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00053	48 23 c8	 and	 rcx, rax
  00056	48 8b c1	 mov	 rax, rcx
  00059	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00060	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 2585 :         if (!sysblk.sync_mask)

  00067	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006e	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00076	75 1d		 jne	 SHORT $LN4@CPU_Wait

; 2586 :             signal_condition(&sysblk.all_synced_cond);

  00078	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007f	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197019
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN4@CPU_Wait:

; 2587 :         wait_condition (&sysblk.sync_done_cond, &sysblk.intlock);

  00095	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0009c	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a9	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG197020
  000b7	48 8b d0	 mov	 rdx, rax
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 2588 :     }

  000c0	e9 57 ff ff ff	 jmp	 $LN2@CPU_Wait
$LN3@CPU_Wait:

; 2589 : 
; 2590 :     /*
; 2591 :     ** Let test script know when a CPU either stops or loads a
; 2592 :     ** disabled wait state PSW, but NOT when a CPU simply loads
; 2593 :     ** an ENABLED wait PSW such as when it wishes to simply wait
; 2594 :     ** for an I/O, External or other type of interrupt.
; 2595 :     **
; 2596 :     ** NOTE: we can't rely on just sysblk.started_mask since there
; 2597 :     ** is no guarantee the last CPU to have its sysblk.started_mask
; 2598 :     ** cleared will actually be the last CPU to reach this point.
; 2599 :     */
; 2600 :     if (WAITSTATE( &regs->psw ) && !IS_IC_DISABLED_WAIT_PSW( regs ))

  000c5	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  000ce	83 e0 02	 and	 eax, 2
  000d1	85 c0		 test	 eax, eax
  000d3	74 16		 je	 SHORT $LN5@CPU_Wait
  000d5	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000da	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000dd	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  000e2	85 c0		 test	 eax, eax
  000e4	74 05		 je	 SHORT $LN5@CPU_Wait

; 2601 :         ;   /* enabled wait: do nothing */

  000e6	e9 83 00 00 00	 jmp	 $LN6@CPU_Wait
$LN5@CPU_Wait:

; 2602 :     else
; 2603 :     {
; 2604 :         obtain_lock( &sysblk.scrlock );

  000eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f2	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  000f8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197023
  000ff	48 8b c8	 mov	 rcx, rax
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2605 :         if (sysblk.scrtest)

  00108	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0010f	83 b8 18 11 00
	00 00		 cmp	 DWORD PTR [rax+4376], 0
  00116	74 39		 je	 SHORT $LN7@CPU_Wait

; 2606 :         {
; 2607 :             sysblk.scrtest++;

  00118	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011f	8b 80 18 11 00
	00		 mov	 eax, DWORD PTR [rax+4376]
  00125	ff c0		 inc	 eax
  00127	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012e	89 81 18 11 00
	00		 mov	 DWORD PTR [rcx+4376], eax

; 2608 :             broadcast_condition( &sysblk.scrcond );

  00134	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013b	48 05 10 11 00
	00		 add	 rax, 4368		; 00001110H
  00141	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197025
  00148	48 8b c8	 mov	 rcx, rax
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN7@CPU_Wait:

; 2609 :         }
; 2610 :         release_lock( &sysblk.scrlock );

  00151	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00158	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197026
  00165	48 8b c8	 mov	 rcx, rax
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN6@CPU_Wait:

; 2611 :     }
; 2612 : 
; 2613 :     /* Wait for interrupt */
; 2614 :     wait_condition (&regs->intcond, &sysblk.intlock);

  0016e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00175	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0017b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00180	48 81 c1 80 0c
	00 00		 add	 rcx, 3200		; 00000c80H
  00187	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG197027
  0018e	48 8b d0	 mov	 rdx, rax
  00191	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 2615 : 
; 2616 :     /* And we're the owner of intlock once again */
; 2617 :     sysblk.intowner = regs->cpuad;

  00197	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0019e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  001a3	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  001aa	66 89 88 62 10
	00 00		 mov	 WORD PTR [rax+4194], cx

; 2618 : }

  001b1	48 83 c4 28	 add	 rsp, 40			; 00000028H
  001b5	c3		 ret	 0
CPU_Wait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_instfetch
_TEXT	SEGMENT
addr$ = 48
pagesz$ = 52
ip$ = 56
offset$ = 64
len$ = 68
tv76 = 72
tv78 = 76
tv129 = 80
tv131 = 84
tv138 = 88
tv157 = 92
tv174 = 96
tv215 = 100
tv214 = 104
tv216 = 108
tv272 = 112
tv273 = 116
dest$ = 120
tv279 = 128
regs$ = 160
exec$ = 168
s370_instfetch PROC					; COMDAT

; 777  : {

$LN68:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 778  : VADR    addr;                           /* Instruction address       */
; 779  : BYTE*   ip;                             /* Instruction pointer       */
; 780  : BYTE*   dest;                           /* Fetched Instruction       */
; 781  : int     pagesz;                         /* Effective page size       */
; 782  : int     offset;                         /* Address offset into page  */
; 783  : int     len;                            /* Length for page crossing  */
; 784  : 
; 785  :     addr = exec ? regs->ET : VALID_AIE( regs ) ?

  00010	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00018	74 14		 je	 SHORT $LN36@s370_instf
  0001a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  00028	89 44 24 4c	 mov	 DWORD PTR tv78[rsp], eax
  0002c	eb 67		 jmp	 SHORT $LN37@s370_instf
$LN36@s370_instf:
  0002e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0003e	74 3b		 je	 SHORT $LN34@s370_instf
  00040	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00048	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0004e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00056	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0005e	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00065	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00069	48 2b ca	 sub	 rcx, rdx
  0006c	48 03 c1	 add	 rax, rcx
  0006f	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00075	89 44 24 48	 mov	 DWORD PTR tv76[rsp], eax
  00079	eb 12		 jmp	 SHORT $LN35@s370_instf
$LN34@s370_instf:
  0007b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00083	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00089	89 44 24 48	 mov	 DWORD PTR tv76[rsp], eax
$LN35@s370_instf:
  0008d	8b 44 24 48	 mov	 eax, DWORD PTR tv76[rsp]
  00091	89 44 24 4c	 mov	 DWORD PTR tv78[rsp], eax
$LN37@s370_instf:
  00095	8b 44 24 4c	 mov	 eax, DWORD PTR tv78[rsp]
  00099	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 786  :         PSW_IA_FROM_IP( regs, 0 ) : regs->psw.IA;
; 787  : 
; 788  :     /* Ensure PSW IA matches the instruction we're fetching */
; 789  :     if (!exec)

  0009d	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  000a5	75 5b		 jne	 SHORT $LN14@s370_instf
$LN4@s370_instf:

; 790  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  000a7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000af	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  000b7	74 43		 je	 SHORT $LN15@s370_instf
  000b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000c7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d7	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  000de	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000e2	48 2b ca	 sub	 rcx, rdx
  000e5	48 03 c1	 add	 rax, rcx
  000e8	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  000ee	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN15@s370_instf:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 a5		 jne	 SHORT $LN4@s370_instf
$LN14@s370_instf:

; 791  : 
; 792  :     offset = (int)(addr & PAGEFRAME_BYTEMASK);

  00102	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00106	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0010b	89 44 24 40	 mov	 DWORD PTR offset$[rsp], eax

; 793  : 
; 794  :     pagesz = unlikely( addr < 0x800 ) ? 0x800 : PAGEFRAME_PAGESIZE;

  0010f	81 7c 24 30 00
	08 00 00	 cmp	 DWORD PTR addr$[rsp], 2048 ; 00000800H
  00117	73 0a		 jae	 SHORT $LN40@s370_instf
  00119	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv129[rsp], 1
  00121	eb 08		 jmp	 SHORT $LN41@s370_instf
$LN40@s370_instf:
  00123	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN41@s370_instf:
  0012b	83 7c 24 50 00	 cmp	 DWORD PTR tv129[rsp], 0
  00130	74 0a		 je	 SHORT $LN42@s370_instf
  00132	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv131[rsp], 2048 ; 00000800H
  0013a	eb 08		 jmp	 SHORT $LN43@s370_instf
$LN42@s370_instf:
  0013c	c7 44 24 54 00
	08 00 00	 mov	 DWORD PTR tv131[rsp], 2048 ; 00000800H
$LN43@s370_instf:
  00144	8b 44 24 54	 mov	 eax, DWORD PTR tv131[rsp]
  00148	89 44 24 34	 mov	 DWORD PTR pagesz$[rsp], eax

; 795  : 
; 796  :     /* Program check if instruction address is odd */
; 797  :     if (unlikely( offset & 0x01 ))

  0014c	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 0a		 je	 SHORT $LN46@s370_instf
  00157	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  0015f	eb 08		 jmp	 SHORT $LN47@s370_instf
$LN46@s370_instf:
  00161	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN47@s370_instf:
  00169	83 7c 24 58 00	 cmp	 DWORD PTR tv138[rsp], 0
  0016e	74 44		 je	 SHORT $LN16@s370_instf

; 798  :     {
; 799  :         if (!exec)

  00170	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00178	75 1f		 jne	 SHORT $LN17@s370_instf

; 800  :             regs->instinvalid = 1;

  0017a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00188	83 c8 08	 or	 eax, 8
  0018b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN17@s370_instf:

; 801  : 
; 802  :         regs->program_interrupt( regs, PGM_SPECIFICATION_EXCEPTION );

  00199	ba 06 00 00 00	 mov	 edx, 6
  0019e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN16@s370_instf:

; 803  :     }
; 804  : 
; 805  : #if defined( FEATURE_PER )
; 806  : 
; 807  :     /* Save the address used to fetch the instruction */
; 808  :     if (EN_IC_PER( regs ))

  001b4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001bc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  001c2	c1 e8 02	 shr	 eax, 2
  001c5	83 e0 01	 and	 eax, 1
  001c8	85 c0		 test	 eax, eax
  001ca	74 0a		 je	 SHORT $LN50@s370_instf
  001cc	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  001d4	eb 08		 jmp	 SHORT $LN51@s370_instf
$LN50@s370_instf:
  001d6	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN51@s370_instf:
  001de	83 7c 24 5c 00	 cmp	 DWORD PTR tv157[rsp], 0
  001e3	0f 84 9d 02 00
	00		 je	 $LN18@s370_instf

; 809  :     {
; 810  : #if defined( FEATURE_PER2 )
; 811  :         regs->perc = 0x40    /* ATMID-validity */
; 812  :                    | (regs->psw.amode64        << 7 )
; 813  :                    | (regs->psw.amode          << 5 )
; 814  :                    | (!REAL_MODE( &regs->psw ) ? 0x10 : 0 )
; 815  :                    | (SPACE_BIT(  &regs->psw ) << 3 )
; 816  :                    | (AR_BIT   (  &regs->psw ) << 2 );
; 817  : #else
; 818  :         regs->perc = 0;

  001e9	33 c0		 xor	 eax, eax
  001eb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 819  : #endif /* defined( FEATURE_PER2 ) */
; 820  : 
; 821  :         if (!exec)

  001fa	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00202	75 13		 jne	 SHORT $LN19@s370_instf

; 822  :             regs->peradr = addr;

  00204	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00208	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00210	48 89 81 d8 08
	00 00		 mov	 QWORD PTR [rcx+2264], rax
$LN19@s370_instf:

; 823  : 
; 824  :         /* Test for PER instruction-fetching event */
; 825  :         if (1
; 826  :             && EN_IC_PER_IF( regs )
; 827  :             && PER_RANGE_CHECK( addr, regs->CR(10), regs->CR(11) )

  00217	33 c0		 xor	 eax, eax
  00219	83 f8 01	 cmp	 eax, 1
  0021c	0f 84 75 01 00
	00		 je	 $LN20@s370_instf
  00222	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00230	c1 e8 02	 shr	 eax, 2
  00233	83 e0 01	 and	 eax, 1
  00236	85 c0		 test	 eax, eax
  00238	74 0a		 je	 SHORT $LN54@s370_instf
  0023a	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00242	eb 08		 jmp	 SHORT $LN55@s370_instf
$LN54@s370_instf:
  00244	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN55@s370_instf:
  0024c	83 7c 24 60 00	 cmp	 DWORD PTR tv174[rsp], 0
  00251	0f 84 40 01 00
	00		 je	 $LN20@s370_instf
  00257	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00262	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00267	85 c0		 test	 eax, eax
  00269	0f 84 28 01 00
	00		 je	 $LN20@s370_instf
  0026f	b8 08 00 00 00	 mov	 eax, 8
  00274	48 6b c0 0c	 imul	 rax, rax, 12
  00278	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00280	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00287	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0028c	b9 08 00 00 00	 mov	 ecx, 8
  00291	48 6b c9 0b	 imul	 rcx, rcx, 11
  00295	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0029d	8b 8c 0a 00 06
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+1536]
  002a4	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  002aa	3b c1		 cmp	 eax, ecx
  002ac	72 62		 jb	 SHORT $LN60@s370_instf
  002ae	b8 08 00 00 00	 mov	 eax, 8
  002b3	48 6b c0 0b	 imul	 rax, rax, 11
  002b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002c6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002cb	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  002cf	72 2d		 jb	 SHORT $LN56@s370_instf
  002d1	b8 08 00 00 00	 mov	 eax, 8
  002d6	48 6b c0 0c	 imul	 rax, rax, 12
  002da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  002e9	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002ee	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  002f2	77 0a		 ja	 SHORT $LN56@s370_instf
  002f4	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
  002fc	eb 08		 jmp	 SHORT $LN59@s370_instf
$LN56@s370_instf:
  002fe	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN59@s370_instf:
  00306	8b 44 24 64	 mov	 eax, DWORD PTR tv215[rsp]
  0030a	89 44 24 6c	 mov	 DWORD PTR tv216[rsp], eax
  0030e	eb 60		 jmp	 SHORT $LN61@s370_instf
$LN60@s370_instf:
  00310	b8 08 00 00 00	 mov	 eax, 8
  00315	48 6b c0 0b	 imul	 rax, rax, 11
  00319	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00328	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0032d	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00331	73 2d		 jae	 SHORT $LN57@s370_instf
  00333	b8 08 00 00 00	 mov	 eax, 8
  00338	48 6b c0 0c	 imul	 rax, rax, 12
  0033c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00344	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0034b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00350	39 44 24 30	 cmp	 DWORD PTR addr$[rsp], eax
  00354	76 0a		 jbe	 SHORT $LN57@s370_instf
  00356	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
  0035e	eb 08		 jmp	 SHORT $LN58@s370_instf
$LN57@s370_instf:
  00360	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
$LN58@s370_instf:
  00368	8b 44 24 68	 mov	 eax, DWORD PTR tv214[rsp]
  0036c	89 44 24 6c	 mov	 DWORD PTR tv216[rsp], eax
$LN61@s370_instf:
  00370	83 7c 24 6c 00	 cmp	 DWORD PTR tv216[rsp], 0
  00375	74 20		 je	 SHORT $LN20@s370_instf
$LN7@s370_instf:

; 828  :         )
; 829  :         {
; 830  :             ON_IC_PER_IF( regs );

  00377	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037f	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00382	0f ba e8 16	 bts	 eax, 22
  00386	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038e	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00391	33 c0		 xor	 eax, eax
  00393	85 c0		 test	 eax, eax
  00395	75 e0		 jne	 SHORT $LN7@s370_instf
$LN20@s370_instf:

; 831  : 
; 832  : #if defined( FEATURE_PER3 )
; 833  :             /* If CR9_IFNUL (PER instruction-fetching nullification) is
; 834  :                set, take a program check immediately, without executing
; 835  :                the instruction or updating the PSW instruction address */
; 836  :             if (EN_IC_PER_IFNUL( regs ))
; 837  :             {
; 838  :                 ON_IC_PER_IFNUL( regs );
; 839  :                 regs->psw.IA = addr;
; 840  :                 regs->psw.zeroilc = 1;
; 841  :                 regs->program_interrupt( regs, PGM_PER_EVENT );
; 842  :             }
; 843  : #endif /* defined( FEATURE_PER3 ) */
; 844  :         }
; 845  : 
; 846  :         /* Quick exit if AIA is still valid */
; 847  :         if (1
; 848  :             && !exec
; 849  :             && !regs->breakortrace
; 850  :             &&  VALID_AIE( regs )
; 851  :             &&  regs->ip < (regs->aip + pagesz - 5)

  00397	33 c0		 xor	 eax, eax
  00399	83 f8 01	 cmp	 eax, 1
  0039c	0f 84 e4 00 00
	00		 je	 $LN21@s370_instf
  003a2	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  003aa	0f 85 d6 00 00
	00		 jne	 $LN21@s370_instf
  003b0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003be	c1 e8 10	 shr	 eax, 16
  003c1	83 e0 01	 and	 eax, 1
  003c4	85 c0		 test	 eax, eax
  003c6	0f 85 ba 00 00
	00		 jne	 $LN21@s370_instf
  003cc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d4	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  003dc	0f 84 a4 00 00
	00		 je	 $LN21@s370_instf
  003e2	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  003e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ef	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  003f6	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  003fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00403	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  00407	73 7d		 jae	 SHORT $LN21@s370_instf

; 852  :         )
; 853  :         {
; 854  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 855  : 
; 856  :             /* Update CONSTRAINED trans instruction fetch constraint */
; 857  :             if (regs->txf_contran)
; 858  :             {
; 859  :                 if (regs->AIV == regs->txf_aie_aiv2)
; 860  :                     regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 861  :             }
; 862  : 
; 863  :             TXF_INSTRADDR_CONSTRAINT( regs );
; 864  : 
; 865  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 866  : 
; 867  :             /* Save the address of the instruction ABOUT to be executed */
; 868  :             regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  00409	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00411	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00417	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00427	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0042e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00432	48 2b ca	 sub	 rcx, rdx
  00435	48 03 c1	 add	 rax, rcx
  00438	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0043e	8b c0		 mov	 eax, eax
  00440	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00448	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 869  : 
; 870  :             /* Suppress PER instruction fetch event if appropriate */
; 871  :             if (IS_PER_SUPRESS( regs, CR9_IF ))

  0044f	33 c0		 xor	 eax, eax
  00451	85 c0		 test	 eax, eax
  00453	74 20		 je	 SHORT $LN22@s370_instf
$LN10@s370_instf:

; 872  :                 OFF_IC_PER_IF( regs );

  00455	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00460	0f ba f0 16	 btr	 eax, 22
  00464	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0046f	33 c0		 xor	 eax, eax
  00471	85 c0		 test	 eax, eax
  00473	75 e0		 jne	 SHORT $LN10@s370_instf
$LN22@s370_instf:

; 873  : 
; 874  :             /* Return to caller to execute this instruction */
; 875  :             return regs->ip;

  00475	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00481	e9 1a 03 00 00	 jmp	 $LN1@s370_instf
$LN21@s370_instf:
$LN18@s370_instf:

; 876  :         }
; 877  :     }
; 878  : #endif /* defined( FEATURE_PER ) */
; 879  : 
; 880  :     /* Set instinvalid in case of addressing or translation exception */
; 881  :     if (!exec)

  00486	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0048e	75 1f		 jne	 SHORT $LN23@s370_instf

; 882  :         regs->instinvalid = 1;

  00490	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00498	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0049e	83 c8 08	 or	 eax, 8
  004a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN23@s370_instf:

; 883  : 
; 884  :     /* Get instruction address */
; 885  :     ip = MADDRL( addr, 6, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  004af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b7	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  004bb	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  004bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  004c7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004cf	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  004d5	ba 06 00 00 00	 mov	 edx, 6
  004da	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  004de	e8 00 00 00 00	 call	 s370_maddr_l
  004e3	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 886  : 
; 887  :     /* If boundary is crossed then copy instruction to destination */
; 888  :     if (offset + ILC( ip[0] ) > pagesz)

  004e8	b8 01 00 00 00	 mov	 eax, 1
  004ed	48 6b c0 00	 imul	 rax, rax, 0
  004f1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  004f6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004fa	83 f8 40	 cmp	 eax, 64			; 00000040H
  004fd	7d 0a		 jge	 SHORT $LN64@s370_instf
  004ff	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv273[rsp], 2
  00507	eb 33		 jmp	 SHORT $LN65@s370_instf
$LN64@s370_instf:
  00509	b8 01 00 00 00	 mov	 eax, 1
  0050e	48 6b c0 00	 imul	 rax, rax, 0
  00512	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00517	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0051b	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00520	7d 0a		 jge	 SHORT $LN62@s370_instf
  00522	c7 44 24 70 04
	00 00 00	 mov	 DWORD PTR tv272[rsp], 4
  0052a	eb 08		 jmp	 SHORT $LN63@s370_instf
$LN62@s370_instf:
  0052c	c7 44 24 70 06
	00 00 00	 mov	 DWORD PTR tv272[rsp], 6
$LN63@s370_instf:
  00534	8b 44 24 70	 mov	 eax, DWORD PTR tv272[rsp]
  00538	89 44 24 74	 mov	 DWORD PTR tv273[rsp], eax
$LN65@s370_instf:
  0053c	8b 44 24 74	 mov	 eax, DWORD PTR tv273[rsp]
  00540	8b 4c 24 40	 mov	 ecx, DWORD PTR offset$[rsp]
  00544	03 c8		 add	 ecx, eax
  00546	8b c1		 mov	 eax, ecx
  00548	3b 44 24 34	 cmp	 eax, DWORD PTR pagesz$[rsp]
  0054c	0f 8e ed 00 00
	00		 jle	 $LN24@s370_instf

; 889  :     {
; 890  :         /* Copy first part of instruction (note: dest is 8 bytes) */
; 891  :         dest = exec ? regs->exinst : regs->inst;

  00552	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0055a	74 18		 je	 SHORT $LN66@s370_instf
  0055c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00564	48 05 40 08 00
	00		 add	 rax, 2112		; 00000840H
  0056a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  00572	eb 16		 jmp	 SHORT $LN67@s370_instf
$LN66@s370_instf:
  00574	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057c	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  00582	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
$LN67@s370_instf:
  0058a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv279[rsp]
  00592	48 89 44 24 78	 mov	 QWORD PTR dest$[rsp], rax

; 892  :         memcpy( dest, ip, 4 );

  00597	48 8b 44 24 78	 mov	 rax, QWORD PTR dest$[rsp]
  0059c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  005a1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  005a3	89 08		 mov	 DWORD PTR [rax], ecx

; 893  : 
; 894  :         /* Copy second part of instruction */
; 895  :         len = pagesz - offset;

  005a5	8b 44 24 40	 mov	 eax, DWORD PTR offset$[rsp]
  005a9	8b 4c 24 34	 mov	 ecx, DWORD PTR pagesz$[rsp]
  005ad	2b c8		 sub	 ecx, eax
  005af	8b c1		 mov	 eax, ecx
  005b1	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 896  :         addr = (addr + len) & ADDRESS_MAXWRAP( regs );

  005b5	8b 44 24 44	 mov	 eax, DWORD PTR len$[rsp]
  005b9	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005bd	03 c8		 add	 ecx, eax
  005bf	8b c1		 mov	 eax, ecx
  005c1	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  005c6	89 44 24 30	 mov	 DWORD PTR addr$[rsp], eax

; 897  :         ip = MADDR( addr, USE_INST_SPACE, regs, ACCTYPE_INSTFETCH, regs->psw.pkey );

  005ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d2	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  005d6	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  005da	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  005e2	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005ea	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  005f0	ba 01 00 00 00	 mov	 edx, 1
  005f5	8b 4c 24 30	 mov	 ecx, DWORD PTR addr$[rsp]
  005f9	e8 00 00 00 00	 call	 s370_maddr_l
  005fe	48 89 44 24 38	 mov	 QWORD PTR ip$[rsp], rax

; 898  :         if (!exec)

  00603	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0060b	75 1c		 jne	 SHORT $LN26@s370_instf

; 899  :             regs->ip = ip - len;

  0060d	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  00612	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00617	48 2b c8	 sub	 rcx, rax
  0061a	48 8b c1	 mov	 rax, rcx
  0061d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00625	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN26@s370_instf:

; 900  :         memcpy( dest + len, ip, 4 );

  00629	48 63 44 24 44	 movsxd	 rax, DWORD PTR len$[rsp]
  0062e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR dest$[rsp]
  00633	48 8b 54 24 38	 mov	 rdx, QWORD PTR ip$[rsp]
  00638	8b 12		 mov	 edx, DWORD PTR [rdx]
  0063a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx

; 901  :     }

  0063d	eb 25		 jmp	 SHORT $LN25@s370_instf
$LN24@s370_instf:

; 902  :     else /* boundary NOT crossed */
; 903  :     {
; 904  :         dest = ip;

  0063f	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  00644	48 89 44 24 78	 mov	 QWORD PTR dest$[rsp], rax

; 905  : 
; 906  :         if (!exec)

  00649	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  00651	75 11		 jne	 SHORT $LN27@s370_instf

; 907  :             regs->ip = ip;

  00653	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ip$[rsp]
  00660	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx
$LN27@s370_instf:
$LN25@s370_instf:

; 908  :     }
; 909  : 
; 910  :     if (!exec)

  00664	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR exec$[rsp], 0
  0066c	0f 85 bd 00 00
	00		 jne	 $LN28@s370_instf

; 911  :     {
; 912  :         /* Instr addr now known to be valid so reset instinvalid flag */
; 913  :         regs->instinvalid = 0;

  00672	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00680	83 e0 f7	 and	 eax, -9			; fffffff7H
  00683	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068b	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 914  : 
; 915  :         /* Update the AIA values */
; 916  :         regs->AIV = addr & PAGEFRAME_PAGEMASK;

  00691	8b 44 24 30	 mov	 eax, DWORD PTR addr$[rsp]
  00695	25 00 f8 ff 7f	 and	 eax, 2147481600		; 7ffff800H
  0069a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a2	89 81 10 02 00
	00		 mov	 DWORD PTR [rcx+528], eax

; 917  :         regs->aip = (BYTE*)((uintptr_t)ip & ~PAGEFRAME_BYTEMASK);

  006a8	48 8b 44 24 38	 mov	 rax, QWORD PTR ip$[rsp]
  006ad	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  006b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bb	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax

; 918  : 
; 919  :         /* If tracing, stepping or PER is still active,
; 920  :            force another instfetch after this instruction.
; 921  :         */
; 922  :         if (regs->breakortrace || regs->permode)

  006c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ca	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006d0	c1 e8 10	 shr	 eax, 16
  006d3	83 e0 01	 and	 eax, 1
  006d6	85 c0		 test	 eax, eax
  006d8	75 18		 jne	 SHORT $LN31@s370_instf
  006da	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006e8	c1 e8 02	 shr	 eax, 2
  006eb	83 e0 01	 and	 eax, 1
  006ee	85 c0		 test	 eax, eax
  006f0	74 15		 je	 SHORT $LN29@s370_instf
$LN31@s370_instf:

; 923  :         {
; 924  :             /* Force instfetch to be called again on next inst. */
; 925  :             regs->aie = PSEUDO_INVALID_AIE;

  006f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fa	48 c7 80 08 02
	00 00 01 00 00
	00		 mov	 QWORD PTR [rax+520], 1

; 926  :         }

  00705	eb 28		 jmp	 SHORT $LN30@s370_instf
$LN29@s370_instf:

; 927  :         else /* (stepping/tracing/PER is NOT active) */
; 928  :         {
; 929  :             /* Call instfetch again ONLY when truly needed */
; 930  :             regs->aie = regs->aip + pagesz - 5;

  00707	48 63 44 24 34	 movsxd	 rax, DWORD PTR pagesz$[rsp]
  0070c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00714	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0071b	48 8d 44 01 fb	 lea	 rax, QWORD PTR [rcx+rax-5]
  00720	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00728	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN30@s370_instf:
$LN28@s370_instf:

; 931  :         }
; 932  :     }
; 933  : 
; 934  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 935  : 
; 936  :     /* Update CONSTRAINED trans instruction fetch constraint */
; 937  :     if (regs->txf_contran)
; 938  :     {
; 939  :         if (regs->AIV == regs->txf_aie_aiv2)
; 940  :             regs->txf_aie = regs->aip + regs->txf_aie_off2;
; 941  :     }
; 942  : 
; 943  :     TXF_INSTRADDR_CONSTRAINT( regs );
; 944  : 
; 945  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 946  : 
; 947  :     /* Save the address of the instruction ABOUT to be executed */
; 948  :     regs->periaddr = PSW_IA_FROM_IP( regs, 0 );

  0072f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00737	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0073d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00745	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0074d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00754	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00758	48 2b ca	 sub	 rcx, rdx
  0075b	48 03 c1	 add	 rax, rcx
  0075e	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00764	8b c0		 mov	 eax, eax
  00766	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0076e	48 89 81 e8 08
	00 00		 mov	 QWORD PTR [rcx+2280], rax

; 949  : 
; 950  :     /* Suppress PER instruction fetch event if appropriate */
; 951  :     if (IS_PER_SUPRESS( regs, CR9_IF ))

  00775	33 c0		 xor	 eax, eax
  00777	85 c0		 test	 eax, eax
  00779	74 20		 je	 SHORT $LN32@s370_instf
$LN13@s370_instf:

; 952  :         OFF_IC_PER_IF( regs );

  0077b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00786	0f ba f0 16	 btr	 eax, 22
  0078a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00792	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00795	33 c0		 xor	 eax, eax
  00797	85 c0		 test	 eax, eax
  00799	75 e0		 jne	 SHORT $LN13@s370_instf
$LN32@s370_instf:

; 953  : 
; 954  :     /* Return to caller to execute this instruction */
; 955  :     return dest;

  0079b	48 8b 44 24 78	 mov	 rax, QWORD PTR dest$[rsp]
$LN1@s370_instf:

; 956  : 
; 957  : } /* end function ARCH_DEP( instfetch ) */

  007a0	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  007a7	c3		 ret	 0
s370_instfetch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s370_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
p$ = 8
count$ = 16
atomic_update64 PROC

; 425  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 426  : #if defined( _MSVC_ )
; 427  :     InterlockedExchangeAdd64( p, count );

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR p$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR count$[rsp]
  00014	f0 48 01 08	 lock add QWORD PTR [rax], rcx

; 428  : #else // GCC (and CLANG?)
; 429  :   #if defined( HAVE_SYNC_BUILTINS )
; 430  :     __sync_fetch_and_add( p, count );
; 431  :   #else
; 432  :     *p += count;  /* (N.B. non-atomic!) */
; 433  :   #endif
; 434  : #endif
; 435  : }

  00018	c3		 ret	 0
atomic_update64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
mask$ = 64
location$ = 72
wakeup_cpus_mask PROC

; 325  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 326  :     int i;
; 327  : 
; 328  :     for (i=0; mask; mask >>= 1, i++)

  0000e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0001d	48 d1 e8	 shr	 rax, 1
  00020	48 89 44 24 40	 mov	 QWORD PTR mask$[rsp], rax
  00025	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00029	ff c0		 inc	 eax
  0002b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR mask$[rsp], 0
  00035	74 2e		 je	 SHORT $LN3@wakeup_cpu

; 329  :     {
; 330  :         if (mask & 1)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR mask$[rsp]
  0003c	48 83 e0 01	 and	 rax, 1
  00040	48 85 c0	 test	 rax, rax
  00043	74 1e		 je	 SHORT $LN5@wakeup_cpu

; 331  :             wakeup_cpu( sysblk.regs[i], location );

  00045	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0004f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00056	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  0005e	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 332  :     }

  00063	eb b3		 jmp	 SHORT $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 333  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
wakeup_cpus_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
i$ = 32
current_waittod$ = 40
lru_regs$ = 48
current_regs$ = 56
lru_waittod$ = 64
mask$ = 96
location$ = 104
wakeup_cpu_mask PROC

; 275  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 276  :     REGS*  current_regs;
; 277  :     REGS*  lru_regs = NULL;

  0000e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR lru_regs$[rsp], 0

; 278  :     TOD    current_waittod;
; 279  :     TOD    lru_waittod;
; 280  :     int    i;
; 281  : 
; 282  :     if (mask)

  00017	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0001d	0f 84 d3 00 00
	00		 je	 $LN5@wakeup_cpu

; 283  :     {
; 284  :         for (i=0; mask; mask >>= 1, ++i)

  00023	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002b	eb 17		 jmp	 SHORT $LN4@wakeup_cpu
$LN2@wakeup_cpu:
  0002d	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$[rsp]
  00032	48 d1 e8	 shr	 rax, 1
  00035	48 89 44 24 60	 mov	 QWORD PTR mask$[rsp], rax
  0003a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0003e	ff c0		 inc	 eax
  00040	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wakeup_cpu:
  00044	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$[rsp], 0
  0004a	0f 84 97 00 00
	00		 je	 $LN3@wakeup_cpu

; 285  :         {
; 286  :             if (mask & 1)

  00050	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$[rsp]
  00055	48 83 e0 01	 and	 rax, 1
  00059	48 85 c0	 test	 rax, rax
  0005c	0f 84 80 00 00
	00		 je	 $LN6@wakeup_cpu

; 287  :             {
; 288  :                 current_regs = sysblk.regs[i];

  00062	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00067	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0006e	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00076	48 89 44 24 38	 mov	 QWORD PTR current_regs$[rsp], rax

; 289  :                 current_waittod = current_regs->waittod;

  0007b	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  00080	48 8b 80 b8 07
	00 00		 mov	 rax, QWORD PTR [rax+1976]
  00087	48 89 44 24 28	 mov	 QWORD PTR current_waittod$[rsp], rax

; 290  : 
; 291  :                 /* Select least recently used CPU
; 292  :                  *
; 293  :                  * The LRU CPU is chosen to keep the CPU threads active
; 294  :                  * and to distribute the I/O load across the available
; 295  :                  * CPUs.
; 296  :                  *
; 297  :                  * The current_waittod should never be zero; however,
; 298  :                  * we check it in case the cache from another processor
; 299  :                  * has not yet been written back to memory, which can
; 300  :                  * happen once the lock structure is updated for
; 301  :                  * individual CPU locks. (OBTAIN/RELEASE_INTLOCK(regs)
; 302  :                  * at present locks ALL CPUs, despite the specification
; 303  :                  * of regs.)
; 304  :                  */
; 305  :                 if (lru_regs == NULL ||

  0008c	48 83 7c 24 30
	00		 cmp	 QWORD PTR lru_regs$[rsp], 0
  00092	74 3a		 je	 SHORT $LN8@wakeup_cpu
  00094	48 83 7c 24 28
	00		 cmp	 QWORD PTR current_waittod$[rsp], 0
  0009a	76 46		 jbe	 SHORT $LN7@wakeup_cpu
  0009c	48 8b 44 24 40	 mov	 rax, QWORD PTR lru_waittod$[rsp]
  000a1	48 39 44 24 28	 cmp	 QWORD PTR current_waittod$[rsp], rax
  000a6	72 26		 jb	 SHORT $LN9@wakeup_cpu
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR lru_waittod$[rsp]
  000ad	48 39 44 24 28	 cmp	 QWORD PTR current_waittod$[rsp], rax
  000b2	75 2e		 jne	 SHORT $LN7@wakeup_cpu
  000b4	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  000b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lru_regs$[rsp]
  000be	48 8b 89 c0 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1984]
  000c5	48 39 88 c0 07
	00 00		 cmp	 QWORD PTR [rax+1984], rcx
  000cc	72 14		 jb	 SHORT $LN7@wakeup_cpu
$LN9@wakeup_cpu:
$LN8@wakeup_cpu:

; 306  :                     (current_waittod > 0 &&
; 307  :                      (current_waittod < lru_waittod ||
; 308  :                       (current_waittod == lru_waittod &&
; 309  :                        current_regs->waittime >= lru_regs->waittime))))
; 310  :                 {
; 311  :                     lru_regs = current_regs;

  000ce	48 8b 44 24 38	 mov	 rax, QWORD PTR current_regs$[rsp]
  000d3	48 89 44 24 30	 mov	 QWORD PTR lru_regs$[rsp], rax

; 312  :                     lru_waittod = current_waittod;

  000d8	48 8b 44 24 28	 mov	 rax, QWORD PTR current_waittod$[rsp]
  000dd	48 89 44 24 40	 mov	 QWORD PTR lru_waittod$[rsp], rax
$LN7@wakeup_cpu:
$LN6@wakeup_cpu:

; 313  :                 }
; 314  :             }
; 315  :         }

  000e2	e9 46 ff ff ff	 jmp	 $LN2@wakeup_cpu
$LN3@wakeup_cpu:

; 316  : 
; 317  :         /* Wake up the least recently used CPU */
; 318  :         wakeup_cpu( lru_regs, location );

  000e7	48 8b 54 24 68	 mov	 rdx, QWORD PTR location$[rsp]
  000ec	48 8b 4c 24 30	 mov	 rcx, QWORD PTR lru_regs$[rsp]
  000f1	e8 00 00 00 00	 call	 wakeup_cpu
$LN5@wakeup_cpu:

; 319  :     }
; 320  : }

  000f6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000fa	c3		 ret	 0
wakeup_cpu_mask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
wakeup_cpu PROC

; 268  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 269  :     hthread_signal_condition( &regs->intcond, location );

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  00019	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 270  : }

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
wakeup_cpu ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
realregs$ = 112
code$ = 120
intercept$ = 124
ilc$ = 128
perc$1 = 132
psa$ = 136
sie_ilc$ = 144
tv441 = 148
detect_pgmintloop$2 = 152
pgmintloop$3 = 156
tv228 = 160
tv236 = 164
tv245 = 168
tv247 = 172
tv249 = 176
tv263 = 180
tv271 = 184
tv277 = 188
tv279 = 192
tv312 = 196
tv821 = 200
px$ = 208
tv1098 = 216
tv1102 = 220
tv1421 = 224
zmoncode$ = 232
tv132 = 240
p$4 = 248
p$5 = 256
tv596 = 264
_psa$6 = 272
tv1095 = 280
tv1104 = 288
tv1423 = 296
pgmold$7 = 304
pgmnew$8 = 344
percname$9 = 384
buf$10 = 416
__$ArrayPad$ = 480
regs$ = 528
pcode$ = 536
z900_program_interrupt PROC

; 635  : {

$LN249:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 636  : PSA    *psa;                            /* -> Prefixed storage area  */
; 637  : REGS   *realregs;                       /* True regs structure       */
; 638  : RADR    px;                             /* host real address of pfx  */
; 639  : int     code;                           /* pcode without PER ind.    */
; 640  : int     ilc;                            /* instruction length        */
; 641  : 
; 642  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 643  :                                         /* FIXME : SEE ISW20090110-1 */
; 644  : void   *zmoncode = NULL;                /* mon call SIE intercept;

  00024	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR zmoncode$[rsp], 0

; 645  :                                            special reloc for z/Arch  */
; 646  :                                         /* FIXME : zmoncode not being
; 647  :                                            initialized here raises a
; 648  :                                            potentially non-initialized
; 649  :                                            warning in GCC.. can't find
; 650  :                                            why. ISW 2009/02/04       */
; 651  : #endif
; 652  : #if defined( FEATURE_SIE )
; 653  : int     sie_ilc=0;                      /* SIE instruction length    */

  00030	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sie_ilc$[rsp], 0

; 654  : #endif
; 655  : #if defined( _FEATURE_SIE )
; 656  : bool    intercept;                      /* False for virtual pgmint  */
; 657  :                                         /* (True for host interrupt?)*/
; 658  : #endif
; 659  : 
; 660  :     /* If called with ghost registers (ie from hercules command
; 661  :        then ignore all interrupt handling and report the error
; 662  :        to the caller */
; 663  :     if (regs->ghostregs)

  0003b	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00043	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00049	c1 e8 0d	 shr	 eax, 13
  0004c	83 e0 01	 and	 eax, 1
  0004f	85 c0		 test	 eax, eax
  00051	74 1d		 je	 SHORT $LN103@z900_progr

; 664  :         longjmp( regs->progjmp, pcode );

  00053	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00061	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  00068	48 8b c8	 mov	 rcx, rax
  0006b	e8 00 00 00 00	 call	 longjmp
$LN103@z900_progr:
$LN4@z900_progr:

; 665  : 
; 666  :     PTT_PGM("PGM", pcode, regs->TEA, regs->psw.IA );

  00070	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00077	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007a	48 83 e0 20	 and	 rax, 32			; 00000020H
  0007e	48 85 c0	 test	 rax, rax
  00081	74 55		 je	 SHORT $LN104@z900_progr
  00083	48 63 84 24 18
	02 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  0008b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00094	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009c	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  000a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196060
  000af	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b4	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bc	4c 8b 89 18 07
	00 00		 mov	 r9, QWORD PTR [rcx+1816]
  000c3	4c 8b c0	 mov	 r8, rax
  000c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196061
  000cd	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN104@z900_progr:
  000d8	33 c0		 xor	 eax, eax
  000da	85 c0		 test	 eax, eax
  000dc	75 92		 jne	 SHORT $LN4@z900_progr

; 667  : 
; 668  :     /* program_interrupt() may be called with a shadow copy of the
; 669  :        regs structure, realregs is the pointer to the real structure
; 670  :        which must be used when loading/storing the psw, or backing up
; 671  :        the instruction address in case of nullification
; 672  :     */
; 673  : #if defined( _FEATURE_SIE )
; 674  :         realregs = SIE_MODE( regs )

  000de	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ec	d1 e8		 shr	 eax, 1
  000ee	83 e0 01	 and	 eax, 1
  000f1	85 c0		 test	 eax, eax
  000f3	74 2f		 je	 SHORT $LN217@z900_progr
  000f5	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fd	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00104	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0010b	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00113	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0011a	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  00122	eb 2d		 jmp	 SHORT $LN218@z900_progr
$LN217@z900_progr:
  00124	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00133	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0013a	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00142	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00149	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
$LN218@z900_progr:
  00151	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv132[rsp]
  00159	48 89 44 24 70	 mov	 QWORD PTR realregs$[rsp], rax
$LN7@z900_progr:

; 675  :                  ? GUEST( sysblk.regs[ regs->cpuad ])
; 676  :                  : HOST(  sysblk.regs[ regs->cpuad ]);
; 677  : #else
; 678  :     realregs = HOST( sysblk.regs[ regs->cpuad ]);
; 679  : #endif
; 680  : 
; 681  :     PTT_PGM( "PGM (r)h,g,a", realregs->host, realregs->guest, realregs->sie_active );

  0015e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00165	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00168	48 83 e0 20	 and	 rax, 32			; 00000020H
  0016c	48 85 c0	 test	 rax, rax
  0016f	74 68		 je	 SHORT $LN105@z900_progr
  00171	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00176	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0017c	83 e0 01	 and	 eax, 1
  0017f	8b c0		 mov	 eax, eax
  00181	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00186	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0018c	c1 e9 08	 shr	 ecx, 8
  0018f	83 e1 01	 and	 ecx, 1
  00192	8b c9		 mov	 ecx, ecx
  00194	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00199	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  0019f	c1 ea 07	 shr	 edx, 7
  001a2	83 e2 01	 and	 edx, 1
  001a5	8b d2		 mov	 edx, edx
  001a7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001b0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196063
  001bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c1	44 8b c9	 mov	 r9d, ecx
  001c4	44 8b c2	 mov	 r8d, edx
  001c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196064
  001ce	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN105@z900_progr:
  001d9	33 c0		 xor	 eax, eax
  001db	85 c0		 test	 eax, eax
  001dd	0f 85 7b ff ff
	ff		 jne	 $LN7@z900_progr

; 682  : 
; 683  :     /* Prevent machine check when in (almost) interrupt loop */
; 684  :     realregs->instcount++;

  001e3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  001e8	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  001ee	ff c0		 inc	 eax
  001f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  001f5	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 685  :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  001fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00202	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  00208	ba 01 00 00 00	 mov	 edx, 1
  0020d	48 8b c8	 mov	 rcx, rax
  00210	e8 00 00 00 00	 call	 atomic_update64

; 686  : 
; 687  :     /* Release any locks */
; 688  :     if (IS_INTLOCK_HELD( realregs ))

  00215	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0021c	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00223	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00228	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0022f	3b c1		 cmp	 eax, ecx
  00231	75 11		 jne	 SHORT $LN106@z900_progr

; 689  :         RELEASE_INTLOCK( realregs );

  00233	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196066
  0023a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0023f	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN106@z900_progr:

; 690  : 
; 691  :     /* Unlock the main storage lock if held */
; 692  :     if (sysblk.mainowner == realregs->cpuad)

  00244	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0024b	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00252	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00257	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0025e	3b c1		 cmp	 eax, ecx
  00260	75 61		 jne	 SHORT $LN107@z900_progr
$LN10@z900_progr:

; 693  :         RELEASE_MAINLOCK_UNCONDITIONAL( realregs );

  00262	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00267	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0026b	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00272	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00277	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  0027e	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00285	3b c1		 cmp	 eax, ecx
  00287	75 34		 jne	 SHORT $LN108@z900_progr
  00289	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0028e	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00292	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00297	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  0029e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002a3	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  002a7	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  002ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196069
  002b4	48 8b c8	 mov	 rcx, rax
  002b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN108@z900_progr:
  002bd	33 c0		 xor	 eax, eax
  002bf	85 c0		 test	 eax, eax
  002c1	75 9f		 jne	 SHORT $LN10@z900_progr
$LN107@z900_progr:
$LN13@z900_progr:

; 694  : 
; 695  :     /* Ensure psw.IA is set and aia invalidated */
; 696  :     INVALIDATE_AIA(realregs);

  002c3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002c8	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  002d0	74 52		 je	 SHORT $LN109@z900_progr
  002d2	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002d7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  002dc	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  002e3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002e7	48 2b c1	 sub	 rax, rcx
  002ea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  002ef	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  002f6	48 03 c8	 add	 rcx, rax
  002f9	48 8b c1	 mov	 rax, rcx
  002fc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00301	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00308	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0030d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00314	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00319	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN109@z900_progr:
  00324	33 c0		 xor	 eax, eax
  00326	85 c0		 test	 eax, eax
  00328	75 99		 jne	 SHORT $LN13@z900_progr

; 697  : 
; 698  : #if defined( FEATURE_SIE )
; 699  :     if (realregs->sie_active)

  0032a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0032f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00335	83 e0 01	 and	 eax, 1
  00338	85 c0		 test	 eax, eax
  0033a	74 11		 je	 SHORT $LN110@z900_progr

; 700  :         ARCH_DEP( invalidate_guest_aia )( GUEST( realregs ));

  0033c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00341	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00348	e8 00 00 00 00	 call	 z900_invalidate_guest_aia
$LN110@z900_progr:

; 701  : #endif
; 702  : 
; 703  :     /* Fix PSW and get instruction length (ilc) */
; 704  :     ilc = ARCH_DEP( fix_program_interrupt_PSW )( realregs );

  0034d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00352	e8 00 00 00 00	 call	 z900_fix_program_interrupt_PSW
  00357	89 84 24 80 00
	00 00		 mov	 DWORD PTR ilc$[rsp], eax
$LN16@z900_progr:

; 705  : 
; 706  :     PTT_PGM( "PGM ilc", 0, 0, ilc );

  0035e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00365	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00368	48 83 e0 20	 and	 rax, 32			; 00000020H
  0036c	48 85 c0	 test	 rax, rax
  0036f	74 3a		 je	 SHORT $LN111@z900_progr
  00371	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00379	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00382	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00387	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196073
  0038e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00393	45 33 c9	 xor	 r9d, r9d
  00396	45 33 c0	 xor	 r8d, r8d
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196074
  003a0	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN111@z900_progr:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	75 ad		 jne	 SHORT $LN16@z900_progr

; 707  : 
; 708  : #if defined( FEATURE_SIE )
; 709  :     if (realregs->sie_active)

  003b1	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  003b6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003bc	83 e0 01	 and	 eax, 1
  003bf	85 c0		 test	 eax, eax
  003c1	0f 84 63 02 00
	00		 je	 $LN112@z900_progr

; 710  :     {
; 711  :         sie_ilc = GUEST( realregs )->psw.zeroilc ? 0 : REAL_ILC( GUEST( realregs ));

  003c7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  003cc	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003d3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003d9	c1 e8 02	 shr	 eax, 2
  003dc	83 e0 01	 and	 eax, 1
  003df	85 c0		 test	 eax, eax
  003e1	74 10		 je	 SHORT $LN229@z900_progr
  003e3	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv249[rsp], 0
  003ee	e9 c8 00 00 00	 jmp	 $LN230@z900_progr
$LN229@z900_progr:
  003f3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  003f8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003ff	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00405	83 e0 01	 and	 eax, 1
  00408	85 c0		 test	 eax, eax
  0040a	75 0d		 jne	 SHORT $LN219@z900_progr
  0040c	c7 84 24 a0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv228[rsp], 1
  00417	eb 0b		 jmp	 SHORT $LN220@z900_progr
$LN219@z900_progr:
  00419	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv228[rsp], 0
$LN220@z900_progr:
  00424	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR tv228[rsp], 0
  0042c	74 0d		 je	 SHORT $LN223@z900_progr
  0042e	c7 84 24 a4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv236[rsp], 1
  00439	eb 0b		 jmp	 SHORT $LN224@z900_progr
$LN223@z900_progr:
  0043b	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv236[rsp], 0
$LN224@z900_progr:
  00446	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR tv236[rsp], 0
  0044e	74 1c		 je	 SHORT $LN227@z900_progr
  00450	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00455	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0045c	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00463	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv247[rsp], eax
  0046a	eb 41		 jmp	 SHORT $LN228@z900_progr
$LN227@z900_progr:
  0046c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00471	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00478	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0047e	d1 e8		 shr	 eax, 1
  00480	83 e0 01	 and	 eax, 1
  00483	85 c0		 test	 eax, eax
  00485	74 0d		 je	 SHORT $LN225@z900_progr
  00487	c7 84 24 a8 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv245[rsp], 6
  00492	eb 0b		 jmp	 SHORT $LN226@z900_progr
$LN225@z900_progr:
  00494	c7 84 24 a8 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv245[rsp], 4
$LN226@z900_progr:
  0049f	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv245[rsp]
  004a6	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv247[rsp], eax
$LN228@z900_progr:
  004ad	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv247[rsp]
  004b4	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv249[rsp], eax
$LN230@z900_progr:
  004bb	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv249[rsp]
  004c2	89 84 24 90 00
	00 00		 mov	 DWORD PTR sie_ilc$[rsp], eax

; 712  :         if (GUEST( realregs )->psw.ilc == 0 && !GUEST( realregs )->psw.zeroilc)

  004c9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  004ce	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004d5	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  004dc	85 c0		 test	 eax, eax
  004de	0f 85 f3 00 00
	00		 jne	 $LN113@z900_progr
  004e4	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  004e9	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004f0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004f6	c1 e8 02	 shr	 eax, 2
  004f9	83 e0 01	 and	 eax, 1
  004fc	85 c0		 test	 eax, eax
  004fe	0f 85 d3 00 00
	00		 jne	 $LN113@z900_progr

; 713  :         {
; 714  :             sie_ilc = likely( !GUEST( realregs )->execflag) ? 2 : GUEST( realregs )->exrl ? 6 : 4;

  00504	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00509	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00510	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00516	83 e0 01	 and	 eax, 1
  00519	85 c0		 test	 eax, eax
  0051b	75 0d		 jne	 SHORT $LN231@z900_progr
  0051d	c7 84 24 b4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv263[rsp], 1
  00528	eb 0b		 jmp	 SHORT $LN232@z900_progr
$LN231@z900_progr:
  0052a	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv263[rsp], 0
$LN232@z900_progr:
  00535	83 bc 24 b4 00
	00 00 00	 cmp	 DWORD PTR tv263[rsp], 0
  0053d	74 0d		 je	 SHORT $LN235@z900_progr
  0053f	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv271[rsp], 1
  0054a	eb 0b		 jmp	 SHORT $LN236@z900_progr
$LN235@z900_progr:
  0054c	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv271[rsp], 0
$LN236@z900_progr:
  00557	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR tv271[rsp], 0
  0055f	74 0d		 je	 SHORT $LN239@z900_progr
  00561	c7 84 24 c0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv279[rsp], 2
  0056c	eb 41		 jmp	 SHORT $LN240@z900_progr
$LN239@z900_progr:
  0056e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00573	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0057a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00580	d1 e8		 shr	 eax, 1
  00582	83 e0 01	 and	 eax, 1
  00585	85 c0		 test	 eax, eax
  00587	74 0d		 je	 SHORT $LN237@z900_progr
  00589	c7 84 24 bc 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv277[rsp], 6
  00594	eb 0b		 jmp	 SHORT $LN238@z900_progr
$LN237@z900_progr:
  00596	c7 84 24 bc 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv277[rsp], 4
$LN238@z900_progr:
  005a1	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv277[rsp]
  005a8	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv279[rsp], eax
$LN240@z900_progr:
  005af	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv279[rsp]
  005b6	89 84 24 90 00
	00 00		 mov	 DWORD PTR sie_ilc$[rsp], eax

; 715  :             GUEST( realregs )->psw.ilc  = sie_ilc;

  005bd	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  005c2	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005c9	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR sie_ilc$[rsp]
  005d1	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl
$LN113@z900_progr:
$LN19@z900_progr:

; 716  :         }
; 717  : 
; 718  :         PTT_PGM( "PGM sie_ilc", 0, 0, sie_ilc );

  005d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005de	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005e1	48 83 e0 20	 and	 rax, 32			; 00000020H
  005e5	48 85 c0	 test	 rax, rax
  005e8	74 3a		 je	 SHORT $LN114@z900_progr
  005ea	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR sie_ilc$[rsp]
  005f2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005fb	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00600	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196078
  00607	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0060c	45 33 c9	 xor	 r9d, r9d
  0060f	45 33 c0	 xor	 r8d, r8d
  00612	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196079
  00619	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0061e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN114@z900_progr:
  00624	33 c0		 xor	 eax, eax
  00626	85 c0		 test	 eax, eax
  00628	75 ad		 jne	 SHORT $LN19@z900_progr
$LN112@z900_progr:

; 719  :     }
; 720  : #endif
; 721  : 
; 722  :     /* Trace the program interrupt right away */
; 723  :     ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );

  0062a	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR ilc$[rsp]
  00632	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  00639	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00641	e8 00 00 00 00	 call	 z900_trace_program_interrupt

; 724  : 
; 725  :     /* Remove PER indication from program interrupt code
; 726  :        such that interrupt code specific tests may be done.
; 727  :        The PER indication will be stored in the PER handling
; 728  :        code */
; 729  :     code = pcode & ~PGM_PER_EVENT;

  00646	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  0064d	0f ba f0 07	 btr	 eax, 7
  00651	89 44 24 78	 mov	 DWORD PTR code$[rsp], eax

; 730  : 
; 731  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 732  : 
; 733  :     /* If transaction is active, check if interrupt can be filtered */
; 734  :     if (realregs->txf_tnd)

  00655	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0065a	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00661	85 c0		 test	 eax, eax
  00663	0f 84 28 02 00
	00		 je	 $LN115@z900_progr

; 735  :     {
; 736  :         /* Indicate TXF related program interrupt */
; 737  :         pcode |= PGM_TXF_EVENT;

  00669	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  00670	0f ba e8 09	 bts	 eax, 9
  00674	89 84 24 18 02
	00 00		 mov	 DWORD PTR pcode$[rsp], eax

; 738  : 
; 739  :         /* Always reset the NTSTG indicator on any program interrupt */
; 740  :         regs->txf_NTSTG = false;

  0067b	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00683	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 741  : 
; 742  :         /* Save the program interrupt and data exception codes */
; 743  :         realregs->txf_piid   = pcode;

  0068a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0068f	8b 8c 24 18 02
	00 00		 mov	 ecx, DWORD PTR pcode$[rsp]
  00696	89 88 7c af 00
	00		 mov	 DWORD PTR [rax+44924], ecx

; 744  :         realregs->txf_piid  |= (ilc << 16);

  0069c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR ilc$[rsp]
  006a3	c1 e0 10	 shl	 eax, 16
  006a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  006ab	8b 89 7c af 00
	00		 mov	 ecx, DWORD PTR [rcx+44924]
  006b1	0b c8		 or	 ecx, eax
  006b3	8b c1		 mov	 eax, ecx
  006b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  006ba	89 81 7c af 00
	00		 mov	 DWORD PTR [rcx+44924], eax

; 745  : 
; 746  :         realregs->txf_dxc_vxc =

  006c0	33 c0		 xor	 eax, eax
  006c2	85 c0		 test	 eax, eax
  006c4	75 21		 jne	 SHORT $LN241@z900_progr
  006c6	83 bc 24 18 02
	00 00 07	 cmp	 DWORD PTR pcode$[rsp], 7
  006ce	74 17		 je	 SHORT $LN241@z900_progr
  006d0	83 bc 24 18 02
	00 00 1b	 cmp	 DWORD PTR pcode$[rsp], 27
  006d8	74 0d		 je	 SHORT $LN241@z900_progr
  006da	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv312[rsp], 0
  006e5	eb 12		 jmp	 SHORT $LN242@z900_progr
$LN241@z900_progr:
  006e7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  006ec	8b 80 08 07 00
	00		 mov	 eax, DWORD PTR [rax+1800]
  006f2	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv312[rsp], eax
$LN242@z900_progr:
  006f9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  006fe	0f b6 8c 24 c4
	00 00 00	 movzx	 ecx, BYTE PTR tv312[rsp]
  00706	88 88 80 af 00
	00		 mov	 BYTE PTR [rax+44928], cl
$LN22@z900_progr:

; 747  :         (0
; 748  :             || pcode == PGM_DATA_EXCEPTION
; 749  :             || pcode == PGM_VECTOR_PROCESSING_EXCEPTION
; 750  :         )
; 751  :         ?  realregs->dxc : 0;
; 752  : 
; 753  :         PTT_TXF( "TXF PIID", realregs->txf_piid, realregs->txf_dxc_vxc, 0 );

  0070c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00713	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00716	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  0071c	48 85 c0	 test	 rax, rax
  0071f	74 4d		 je	 SHORT $LN117@z900_progr
  00721	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00726	0f b6 80 80 af
	00 00		 movzx	 eax, BYTE PTR [rax+44928]
  0072d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00732	8b 89 7c af 00
	00		 mov	 ecx, DWORD PTR [rcx+44924]
  00738	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00741	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0074a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196083
  00751	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00756	44 8b c8	 mov	 r9d, eax
  00759	44 8b c1	 mov	 r8d, ecx
  0075c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196084
  00763	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00768	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN117@z900_progr:
  0076e	33 c0		 xor	 eax, eax
  00770	85 c0		 test	 eax, eax
  00772	75 98		 jne	 SHORT $LN22@z900_progr
$LN25@z900_progr:

; 754  : 
; 755  :         /* 'txf_do_pi_filtering' does not return for filterable
; 756  :             program interrupts. It returns only if the program
; 757  :             interrupt is unfilterable, and when it returns, the
; 758  :             active transaction has already been aborted.
; 759  :         */
; 760  :         PTT_TXF( "TXF PROG?", (code & 0xFF), realregs->txf_contran, realregs->txf_tnd );

  00774	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0077b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0077e	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00784	48 85 c0	 test	 rax, rax
  00787	74 57		 je	 SHORT $LN118@z900_progr
  00789	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0078e	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00795	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0079a	0f b6 89 4c 0e
	00 00		 movzx	 ecx, BYTE PTR [rcx+3660]
  007a1	8b 54 24 78	 mov	 edx, DWORD PTR code$[rsp]
  007a5	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  007ab	48 63 d2	 movsxd	 rdx, edx
  007ae	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  007b7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196086
  007c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007c8	44 8b c9	 mov	 r9d, ecx
  007cb	4c 8b c2	 mov	 r8, rdx
  007ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196087
  007d5	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  007da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN118@z900_progr:
  007e0	33 c0		 xor	 eax, eax
  007e2	85 c0		 test	 eax, eax
  007e4	75 8e		 jne	 SHORT $LN25@z900_progr

; 761  :         ARCH_DEP( txf_do_pi_filtering )( realregs, pcode );

  007e6	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  007ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  007f2	e8 00 00 00 00	 call	 z900_txf_do_pi_filtering

; 762  : 
; 763  :         if (realregs->txf_tnd ) // (sanity check)

  007f7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  007fc	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00803	85 c0		 test	 eax, eax
  00805	74 1d		 je	 SHORT $LN119@z900_progr
$LN28@z900_progr:

; 764  :             CRASH();            // (sanity check)

  00807	48 c7 84 24 f8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$4[rsp], 0
  00813	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR p$4[rsp]
  0081b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0081e	33 c0		 xor	 eax, eax
  00820	85 c0		 test	 eax, eax
  00822	75 e3		 jne	 SHORT $LN28@z900_progr
$LN119@z900_progr:
$LN31@z900_progr:

; 765  : 
; 766  :         PTT_TXF( "*TXF UPROG!", (code & 0xFF), 0, 0 );

  00824	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0082b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0082e	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00834	48 85 c0	 test	 rax, rax
  00837	74 41		 je	 SHORT $LN120@z900_progr
  00839	8b 44 24 78	 mov	 eax, DWORD PTR code$[rsp]
  0083d	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00842	48 98		 cdqe
  00844	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0084d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00856	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196090
  0085d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00862	45 33 c9	 xor	 r9d, r9d
  00865	4c 8b c0	 mov	 r8, rax
  00868	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196091
  0086f	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00874	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN120@z900_progr:
  0087a	33 c0		 xor	 eax, eax
  0087c	85 c0		 test	 eax, eax
  0087e	75 a4		 jne	 SHORT $LN31@z900_progr

; 767  : 
; 768  :         /* Set flag for sie_exit */
; 769  :         realregs->txf_UPGM_abort = true;

  00880	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00885	c6 80 4d 0e 00
	00 01		 mov	 BYTE PTR [rax+3661], 1

; 770  :     }

  0088c	e9 85 00 00 00	 jmp	 $LN116@z900_progr
$LN115@z900_progr:

; 771  :     else /* (no transaction is CURRENTLY active) */
; 772  :     {
; 773  :         /* While no transaction is CURRENTLY active, it's possible
; 774  :            that a previously active transaction was aborted BEFORE
; 775  :            we were called, so we need to check for that.
; 776  :         */
; 777  :         if ((code & 0xFF) == PGM_TRANSACTION_CONSTRAINT_EXCEPTION)

  00891	8b 44 24 78	 mov	 eax, DWORD PTR code$[rsp]
  00895	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0089a	83 f8 18	 cmp	 eax, 24
  0089d	75 77		 jne	 SHORT $LN121@z900_progr

; 778  :         {
; 779  :             /* Indicate TXF related program interrupt */
; 780  :             pcode |= PGM_TXF_EVENT;

  0089f	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  008a6	0f ba e8 09	 bts	 eax, 9
  008aa	89 84 24 18 02
	00 00		 mov	 DWORD PTR pcode$[rsp], eax
$LN34@z900_progr:

; 781  : 
; 782  :             PTT_TXF( "*TXF 218!", pcode, 0, 0 );

  008b1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  008b8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008bb	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  008c1	48 85 c0	 test	 rax, rax
  008c4	74 3e		 je	 SHORT $LN122@z900_progr
  008c6	48 63 84 24 18
	02 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  008ce	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  008d7	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  008e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196094
  008e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008ec	45 33 c9	 xor	 r9d, r9d
  008ef	4c 8b c0	 mov	 r8, rax
  008f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196095
  008f9	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  008fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN122@z900_progr:
  00904	33 c0		 xor	 eax, eax
  00906	85 c0		 test	 eax, eax
  00908	75 a7		 jne	 SHORT $LN34@z900_progr

; 783  : 
; 784  :             /* Set flag for sie_exit */
; 785  :             realregs->txf_UPGM_abort = true;

  0090a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0090f	c6 80 4d 0e 00
	00 01		 mov	 BYTE PTR [rax+3661], 1
$LN121@z900_progr:
$LN116@z900_progr:
$LN37@z900_progr:

; 786  :         }
; 787  :     }
; 788  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 789  : 
; 790  :     /* Set 'execflag' to 0 in case EXecuted instruction program-checked */
; 791  : 
; 792  :     PTT_PGM( "PGM execflag", realregs->execflag, realregs->sie_active, 0 );

  00916	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0091d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00920	48 83 e0 20	 and	 rax, 32			; 00000020H
  00924	48 85 c0	 test	 rax, rax
  00927	74 56		 je	 SHORT $LN123@z900_progr
  00929	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0092e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00934	83 e0 01	 and	 eax, 1
  00937	8b c0		 mov	 eax, eax
  00939	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0093e	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00944	83 e1 01	 and	 ecx, 1
  00947	8b c9		 mov	 ecx, ecx
  00949	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00952	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0095b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196097
  00962	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00967	44 8b c8	 mov	 r9d, eax
  0096a	44 8b c1	 mov	 r8d, ecx
  0096d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196098
  00974	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00979	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN123@z900_progr:
  0097f	33 c0		 xor	 eax, eax
  00981	85 c0		 test	 eax, eax
  00983	75 91		 jne	 SHORT $LN37@z900_progr

; 793  :     realregs->execflag = 0;

  00985	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0098a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00990	83 e0 fe	 and	 eax, -2			; fffffffeH
  00993	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00998	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 794  : 
; 795  : #if defined( FEATURE_SIE )
; 796  :     if (realregs->sie_active)

  0099e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  009a3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  009a9	83 e0 01	 and	 eax, 1
  009ac	85 c0		 test	 eax, eax
  009ae	74 27		 je	 SHORT $LN124@z900_progr

; 797  :         GUEST( realregs )->execflag = 0;

  009b0	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  009b5	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  009bc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009c2	83 e0 fe	 and	 eax, -2			; fffffffeH
  009c5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  009ca	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  009d1	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN124@z900_progr:
$LN40@z900_progr:

; 798  : #endif
; 799  :     PTT_PGM( "PGM execflag", realregs->execflag, realregs->sie_active, 0 );

  009d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  009de	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009e1	48 83 e0 20	 and	 rax, 32			; 00000020H
  009e5	48 85 c0	 test	 rax, rax
  009e8	74 56		 je	 SHORT $LN125@z900_progr
  009ea	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  009ef	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  009f5	83 e0 01	 and	 eax, 1
  009f8	8b c0		 mov	 eax, eax
  009fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  009ff	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00a05	83 e1 01	 and	 ecx, 1
  00a08	8b c9		 mov	 ecx, ecx
  00a0a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a13	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00a1c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196101
  00a23	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00a28	44 8b c8	 mov	 r9d, eax
  00a2b	44 8b c1	 mov	 r8d, ecx
  00a2e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196102
  00a35	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00a3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN125@z900_progr:
  00a40	33 c0		 xor	 eax, eax
  00a42	85 c0		 test	 eax, eax
  00a44	75 91		 jne	 SHORT $LN40@z900_progr

; 800  : 
; 801  :     /* If this is a concurrent PER event
; 802  :        then we must add the PER bit to the interrupts code */
; 803  :     if (OPEN_IC_PER (realregs ))

  00a46	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00a4b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00a50	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00a53	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00a56	23 c1		 and	 eax, ecx
  00a58	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00a5d	85 c0		 test	 eax, eax
  00a5f	74 12		 je	 SHORT $LN126@z900_progr

; 804  :         pcode |= PGM_PER_EVENT;

  00a61	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  00a68	0f ba e8 07	 bts	 eax, 7
  00a6c	89 84 24 18 02
	00 00		 mov	 DWORD PTR pcode$[rsp], eax
$LN126@z900_progr:

; 805  : 
; 806  :     /* Perform serialization and checkpoint synchronization */
; 807  :     PERFORM_SERIALIZATION( realregs );

  00a73	0f ae f0	 mfence
$LN43@z900_progr:

; 808  :     PERFORM_CHKPT_SYNC( realregs );

  00a76	33 c0		 xor	 eax, eax
  00a78	85 c0		 test	 eax, eax
  00a7a	75 fa		 jne	 SHORT $LN43@z900_progr

; 809  : 
; 810  : #if defined( FEATURE_SIE )
; 811  :     /* Host protection and addressing exceptions
; 812  :        must be reflected to the guest */
; 813  :     if (1
; 814  :         && realregs->sie_active
; 815  :         && (0

  00a7c	33 c0		 xor	 eax, eax
  00a7e	83 f8 01	 cmp	 eax, 1
  00a81	0f 84 84 01 00
	00		 je	 $LN127@z900_progr
  00a87	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00a8c	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a92	83 e0 01	 and	 eax, 1
  00a95	85 c0		 test	 eax, eax
  00a97	0f 84 6e 01 00
	00		 je	 $LN127@z900_progr
  00a9d	33 c0		 xor	 eax, eax
  00a9f	85 c0		 test	 eax, eax
  00aa1	75 2e		 jne	 SHORT $LN128@z900_progr
  00aa3	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  00aa8	74 27		 je	 SHORT $LN128@z900_progr
  00aaa	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  00aaf	74 20		 je	 SHORT $LN128@z900_progr
  00ab1	83 7c 24 78 28	 cmp	 DWORD PTR code$[rsp], 40 ; 00000028H
  00ab6	74 19		 je	 SHORT $LN128@z900_progr
  00ab8	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  00abd	74 12		 je	 SHORT $LN128@z900_progr
  00abf	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  00ac4	74 0b		 je	 SHORT $LN128@z900_progr
  00ac6	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  00acb	0f 85 3a 01 00
	00		 jne	 $LN127@z900_progr
$LN128@z900_progr:

; 816  :             || code == PGM_PROTECTION_EXCEPTION
; 817  :             || code == PGM_ADDRESSING_EXCEPTION
; 818  : 
; 819  : #if defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 820  :             || code == PGM_ALET_SPECIFICATION_EXCEPTION
; 821  :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 822  :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 823  :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 824  : #endif
; 825  :            )
; 826  :     )
; 827  :     {
; 828  :         /* Pass this interrupt to the guest */
; 829  : #if defined( SIE_DEBUG )
; 830  :         LOGMSG( "program_int() passing to guest code=%4.4X\n", pcode );
; 831  : #endif
; 832  :         switch (GUEST( realregs )->arch_mode)

  00ad1	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00ad6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00add	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00ae0	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv441[rsp], eax
  00ae7	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv441[rsp], 0
  00aef	74 16		 je	 SHORT $LN129@z900_progr
  00af1	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR tv441[rsp], 1
  00af9	74 2b		 je	 SHORT $LN130@z900_progr
  00afb	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR tv441[rsp], 2
  00b03	74 40		 je	 SHORT $LN131@z900_progr
  00b05	eb 5f		 jmp	 SHORT $LN132@z900_progr
$LN129@z900_progr:

; 833  :         {
; 834  :         case ARCH_370_IDX: GUEST( realregs )->TEA_370 = realregs->TEA; break;

  00b07	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00b0c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b13	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00b18	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  00b1e	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  00b24	eb 5d		 jmp	 SHORT $LN44@z900_progr
$LN130@z900_progr:

; 835  :         case ARCH_390_IDX: GUEST( realregs )->TEA_390 = realregs->TEA; break;

  00b26	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00b2b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b32	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00b37	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  00b3d	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  00b43	eb 3e		 jmp	 SHORT $LN44@z900_progr
$LN131@z900_progr:

; 836  :         case ARCH_900_IDX: GUEST( realregs )->TEA_900 = realregs->TEA; break;

  00b45	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00b4a	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b51	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00b56	48 8b 89 18 07
	00 00		 mov	 rcx, QWORD PTR [rcx+1816]
  00b5d	48 89 88 18 07
	00 00		 mov	 QWORD PTR [rax+1816], rcx
  00b64	eb 1d		 jmp	 SHORT $LN44@z900_progr
$LN132@z900_progr:
$LN48@z900_progr:

; 837  :         default: CRASH();

  00b66	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR p$5[rsp], 0
  00b72	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  00b7a	c6 00 00	 mov	 BYTE PTR [rax], 0
  00b7d	33 c0		 xor	 eax, eax
  00b7f	85 c0		 test	 eax, eax
  00b81	75 e3		 jne	 SHORT $LN48@z900_progr
$LN44@z900_progr:

; 838  :         }
; 839  : 
; 840  :         GUEST( realregs )->excarid = realregs->excarid;

  00b83	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00b88	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b8f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00b94	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  00b9b	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 841  :         GUEST( realregs )->opndrid = realregs->opndrid;

  00ba1	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00ba6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00bb2	0f b6 89 3f 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2111]
  00bb9	88 88 3f 08 00
	00		 mov	 BYTE PTR [rax+2111], cl

; 842  : 
; 843  : #if defined(_FEATURE_PROTECTION_INTERCEPTION_CONTROL)
; 844  :         GUEST( realregs )->hostint = 1;

  00bbf	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00bc4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bcb	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00bd1	83 c8 40	 or	 eax, 64			; 00000040H
  00bd4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00bd9	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00be0	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 845  : #endif
; 846  :         GUEST( realregs )->program_interrupt( GUEST( realregs ), pcode );

  00be6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00beb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00bf2	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  00bf9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00bfe	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00c05	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN127@z900_progr:
$LN51@z900_progr:

; 847  :     }
; 848  : #endif /* defined( FEATURE_SIE ) */
; 849  : 
; 850  :     /* Back up the PSW for exceptions which cause nullification,
; 851  :        unless the exception occurred during instruction fetch
; 852  :     */
; 853  :     PTT_PGM( "PGM psw.IA", realregs->psw.IA, realregs->instinvalid, ilc );

  00c0b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00c12	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c15	48 83 e0 20	 and	 rax, 32			; 00000020H
  00c19	48 85 c0	 test	 rax, rax
  00c1c	74 56		 je	 SHORT $LN133@z900_progr
  00c1e	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00c26	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00c2b	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00c31	c1 e9 03	 shr	 ecx, 3
  00c34	83 e1 01	 and	 ecx, 1
  00c37	8b c9		 mov	 ecx, ecx
  00c39	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00c42	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00c47	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196111
  00c4e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c53	44 8b c9	 mov	 r9d, ecx
  00c56	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00c5b	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  00c62	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196112
  00c69	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00c6e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN133@z900_progr:
  00c74	33 c0		 xor	 eax, eax
  00c76	85 c0		 test	 eax, eax
  00c78	75 91		 jne	 SHORT $LN51@z900_progr

; 854  :     if (1
; 855  :         && !realregs->instinvalid
; 856  :         && (0

  00c7a	33 c0		 xor	 eax, eax
  00c7c	83 f8 01	 cmp	 eax, 1
  00c7f	0f 84 19 02 00
	00		 je	 $LN134@z900_progr
  00c85	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00c8a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00c90	c1 e8 03	 shr	 eax, 3
  00c93	83 e0 01	 and	 eax, 1
  00c96	85 c0		 test	 eax, eax
  00c98	0f 85 00 02 00
	00		 jne	 $LN134@z900_progr
  00c9e	33 c0		 xor	 eax, eax
  00ca0	85 c0		 test	 eax, eax
  00ca2	0f 85 f0 00 00
	00		 jne	 $LN135@z900_progr
  00ca8	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  00cad	0f 84 e5 00 00
	00		 je	 $LN135@z900_progr
  00cb3	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  00cb8	0f 84 da 00 00
	00		 je	 $LN135@z900_progr
  00cbe	83 7c 24 78 38	 cmp	 DWORD PTR code$[rsp], 56 ; 00000038H
  00cc3	0f 84 cf 00 00
	00		 je	 $LN135@z900_progr
  00cc9	83 7c 24 78 39	 cmp	 DWORD PTR code$[rsp], 57 ; 00000039H
  00cce	0f 84 c4 00 00
	00		 je	 $LN135@z900_progr
  00cd4	83 7c 24 78 3a	 cmp	 DWORD PTR code$[rsp], 58 ; 0000003aH
  00cd9	0f 84 b9 00 00
	00		 je	 $LN135@z900_progr
  00cdf	83 7c 24 78 3b	 cmp	 DWORD PTR code$[rsp], 59 ; 0000003bH
  00ce4	0f 84 ae 00 00
	00		 je	 $LN135@z900_progr
  00cea	83 7c 24 78 16	 cmp	 DWORD PTR code$[rsp], 22
  00cef	0f 84 a3 00 00
	00		 je	 $LN135@z900_progr
  00cf5	83 7c 24 78 20	 cmp	 DWORD PTR code$[rsp], 32 ; 00000020H
  00cfa	0f 84 98 00 00
	00		 je	 $LN135@z900_progr
  00d00	83 7c 24 78 21	 cmp	 DWORD PTR code$[rsp], 33 ; 00000021H
  00d05	0f 84 8d 00 00
	00		 je	 $LN135@z900_progr
  00d0b	83 7c 24 78 22	 cmp	 DWORD PTR code$[rsp], 34 ; 00000022H
  00d10	0f 84 82 00 00
	00		 je	 $LN135@z900_progr
  00d16	83 7c 24 78 26	 cmp	 DWORD PTR code$[rsp], 38 ; 00000026H
  00d1b	74 7b		 je	 SHORT $LN135@z900_progr
  00d1d	83 7c 24 78 27	 cmp	 DWORD PTR code$[rsp], 39 ; 00000027H
  00d22	74 74		 je	 SHORT $LN135@z900_progr
  00d24	83 7c 24 78 2e	 cmp	 DWORD PTR code$[rsp], 46 ; 0000002eH
  00d29	74 6d		 je	 SHORT $LN135@z900_progr
  00d2b	83 7c 24 78 23	 cmp	 DWORD PTR code$[rsp], 35 ; 00000023H
  00d30	74 66		 je	 SHORT $LN135@z900_progr
  00d32	83 7c 24 78 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  00d37	74 5f		 je	 SHORT $LN135@z900_progr
  00d39	83 7c 24 78 25	 cmp	 DWORD PTR code$[rsp], 37 ; 00000025H
  00d3e	74 58		 je	 SHORT $LN135@z900_progr
  00d40	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  00d45	74 51		 je	 SHORT $LN135@z900_progr
  00d47	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  00d4c	74 4a		 je	 SHORT $LN135@z900_progr
  00d4e	83 7c 24 78 2b	 cmp	 DWORD PTR code$[rsp], 43 ; 0000002bH
  00d53	74 43		 je	 SHORT $LN135@z900_progr
  00d55	83 7c 24 78 2c	 cmp	 DWORD PTR code$[rsp], 44 ; 0000002cH
  00d5a	74 3c		 je	 SHORT $LN135@z900_progr
  00d5c	83 7c 24 78 2f	 cmp	 DWORD PTR code$[rsp], 47 ; 0000002fH
  00d61	74 35		 je	 SHORT $LN135@z900_progr
  00d63	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  00d68	74 2e		 je	 SHORT $LN135@z900_progr
  00d6a	83 7c 24 78 30	 cmp	 DWORD PTR code$[rsp], 48 ; 00000030H
  00d6f	74 27		 je	 SHORT $LN135@z900_progr
  00d71	83 7c 24 78 31	 cmp	 DWORD PTR code$[rsp], 49 ; 00000031H
  00d76	74 20		 je	 SHORT $LN135@z900_progr
  00d78	83 7c 24 78 32	 cmp	 DWORD PTR code$[rsp], 50 ; 00000032H
  00d7d	74 19		 je	 SHORT $LN135@z900_progr
  00d7f	83 7c 24 78 33	 cmp	 DWORD PTR code$[rsp], 51 ; 00000033H
  00d84	74 12		 je	 SHORT $LN135@z900_progr
  00d86	83 7c 24 78 34	 cmp	 DWORD PTR code$[rsp], 52 ; 00000034H
  00d8b	74 0b		 je	 SHORT $LN135@z900_progr
  00d8d	83 7c 24 78 19	 cmp	 DWORD PTR code$[rsp], 25
  00d92	0f 85 06 01 00
	00		 jne	 $LN134@z900_progr
$LN135@z900_progr:

; 857  :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 858  :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 859  : 
; 860  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 861  :             || code == PGM_ASCE_TYPE_EXCEPTION
; 862  :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 863  :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 864  :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 865  : #endif
; 866  :             || code == PGM_TRACE_TABLE_EXCEPTION
; 867  :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 868  :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 869  :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 870  :             || code == PGM_LFX_TRANSLATION_EXCEPTION
; 871  :             || code == PGM_LSX_TRANSLATION_EXCEPTION
; 872  :             || code == PGM_LSTE_SEQUENCE_EXCEPTION
; 873  :             || code == PGM_EX_TRANSLATION_EXCEPTION
; 874  :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 875  :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 876  :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 877  :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 878  :             || code == PGM_ASTE_VALIDITY_EXCEPTION
; 879  :             || code == PGM_ASTE_SEQUENCE_EXCEPTION
; 880  :             || code == PGM_ASTE_INSTANCE_EXCEPTION
; 881  :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 882  :             || code == PGM_STACK_FULL_EXCEPTION
; 883  :             || code == PGM_STACK_EMPTY_EXCEPTION
; 884  :             || code == PGM_STACK_SPECIFICATION_EXCEPTION
; 885  :             || code == PGM_STACK_TYPE_EXCEPTION
; 886  :             || code == PGM_STACK_OPERATION_EXCEPTION
; 887  :             || code == PGM_VECTOR_OPERATION_EXCEPTION
; 888  :            )
; 889  :     )
; 890  :     {
; 891  :         realregs->psw.IA -= ilc;

  00d98	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00da0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00da5	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00dac	48 2b c8	 sub	 rcx, rax
  00daf	48 8b c1	 mov	 rax, rcx
  00db2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00db7	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 892  :         realregs->psw.IA &= ADDRESS_MAXWRAP(realregs);

  00dbe	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00dc3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00dc8	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00dcf	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00dd6	48 23 c1	 and	 rax, rcx
  00dd9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00dde	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN54@z900_progr:

; 893  : 
; 894  :         PTT_PGM( "PGM IA-ilc", realregs->psw.IA, realregs->instinvalid, ilc );

  00de5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00dec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00def	48 83 e0 20	 and	 rax, 32			; 00000020H
  00df3	48 85 c0	 test	 rax, rax
  00df6	74 56		 je	 SHORT $LN136@z900_progr
  00df8	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00e00	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00e05	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00e0b	c1 e9 03	 shr	 ecx, 3
  00e0e	83 e1 01	 and	 ecx, 1
  00e11	8b c9		 mov	 ecx, ecx
  00e13	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00e1c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00e21	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196116
  00e28	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e2d	44 8b c9	 mov	 r9d, ecx
  00e30	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00e35	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  00e3c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196117
  00e43	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00e48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN136@z900_progr:
  00e4e	33 c0		 xor	 eax, eax
  00e50	85 c0		 test	 eax, eax
  00e52	75 91		 jne	 SHORT $LN54@z900_progr

; 895  : 
; 896  : #if defined( FEATURE_SIE )
; 897  :         /* When in SIE mode the guest instruction
; 898  :            causing this host exception must also be nullified
; 899  :         */
; 900  :         if (realregs->sie_active && !GUEST( realregs )->instinvalid)

  00e54	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00e59	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00e5f	83 e0 01	 and	 eax, 1
  00e62	85 c0		 test	 eax, eax
  00e64	74 38		 je	 SHORT $LN137@z900_progr
  00e66	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00e6b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00e72	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00e78	c1 e8 03	 shr	 eax, 3
  00e7b	83 e0 01	 and	 eax, 1
  00e7e	85 c0		 test	 eax, eax
  00e80	75 1c		 jne	 SHORT $LN137@z900_progr

; 901  :             ARCH_DEP( update_guest_psw_ia )( GUEST( realregs ), -sie_ilc );

  00e82	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR sie_ilc$[rsp]
  00e89	f7 d8		 neg	 eax
  00e8b	8b d0		 mov	 edx, eax
  00e8d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00e92	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00e99	e8 00 00 00 00	 call	 z900_update_guest_psw_ia
$LN137@z900_progr:
$LN134@z900_progr:

; 902  : #endif
; 903  :     }
; 904  : 
; 905  :     /* The OLD PSW must be incremented
; 906  :        on the following exceptions during instfetch
; 907  :     */
; 908  :     if (1
; 909  :         && realregs->instinvalid
; 910  :         && (0

  00e9e	33 c0		 xor	 eax, eax
  00ea0	83 f8 01	 cmp	 eax, 1
  00ea3	0f 84 f5 00 00
	00		 je	 $LN138@z900_progr
  00ea9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00eae	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00eb4	c1 e8 03	 shr	 eax, 3
  00eb7	83 e0 01	 and	 eax, 1
  00eba	85 c0		 test	 eax, eax
  00ebc	0f 84 dc 00 00
	00		 je	 $LN138@z900_progr
  00ec2	33 c0		 xor	 eax, eax
  00ec4	85 c0		 test	 eax, eax
  00ec6	75 20		 jne	 SHORT $LN139@z900_progr
  00ec8	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  00ecd	74 19		 je	 SHORT $LN139@z900_progr
  00ecf	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  00ed4	74 12		 je	 SHORT $LN139@z900_progr
  00ed6	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  00edb	74 0b		 je	 SHORT $LN139@z900_progr
  00edd	83 7c 24 78 12	 cmp	 DWORD PTR code$[rsp], 18
  00ee2	0f 85 b6 00 00
	00		 jne	 $LN138@z900_progr
$LN139@z900_progr:

; 911  :             || code == PGM_PROTECTION_EXCEPTION
; 912  :             || code == PGM_ADDRESSING_EXCEPTION
; 913  :             || code == PGM_SPECIFICATION_EXCEPTION
; 914  :             || code == PGM_TRANSLATION_SPECIFICATION_EXCEPTION
; 915  :            )
; 916  :     )
; 917  :     {
; 918  :         realregs->psw.IA += ilc;

  00ee8	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00ef0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00ef5	48 03 81 88 00
	00 00		 add	 rax, QWORD PTR [rcx+136]
  00efc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00f01	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 919  :         realregs->psw.IA &= ADDRESS_MAXWRAP( realregs );

  00f08	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00f0d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00f12	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00f19	48 8b 80 88 00
	00 00		 mov	 rax, QWORD PTR [rax+136]
  00f20	48 23 c1	 and	 rax, rcx
  00f23	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00f28	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN57@z900_progr:

; 920  : 
; 921  :         PTT_PGM( "PGM IA+ilc", realregs->psw.IA, realregs->instinvalid, ilc );

  00f2f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00f36	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00f39	48 83 e0 20	 and	 rax, 32			; 00000020H
  00f3d	48 85 c0	 test	 rax, rax
  00f40	74 56		 je	 SHORT $LN140@z900_progr
  00f42	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00f4a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00f4f	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00f55	c1 e9 03	 shr	 ecx, 3
  00f58	83 e1 01	 and	 ecx, 1
  00f5b	8b c9		 mov	 ecx, ecx
  00f5d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00f66	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f6b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196122
  00f72	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f77	44 8b c9	 mov	 r9d, ecx
  00f7a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00f7f	4c 8b 80 88 00
	00 00		 mov	 r8, QWORD PTR [rax+136]
  00f86	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196123
  00f8d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00f92	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN140@z900_progr:
  00f98	33 c0		 xor	 eax, eax
  00f9a	85 c0		 test	 eax, eax
  00f9c	75 91		 jne	 SHORT $LN57@z900_progr
$LN138@z900_progr:

; 922  :     }
; 923  : 
; 924  :     /* Store the interrupt code in the PSW */
; 925  :     realregs->psw.intcode = pcode;

  00f9e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00fa3	0f b7 8c 24 18
	02 00 00	 movzx	 ecx, WORD PTR pcode$[rsp]
  00fab	66 89 88 98 00
	00 00		 mov	 WORD PTR [rax+152], cx

; 926  : 
; 927  :     /* Call debugger if active */
; 928  :     HDC2( debug_program_interrupt, regs, pcode );

  00fb2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_program_interrupt
  00fb9	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00fbd	74 22		 je	 SHORT $LN243@z900_progr
  00fbf	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  00fc6	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_program_interrupt
  00fd5	ff 10		 call	 QWORD PTR [rax]
  00fd7	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv596[rsp], rax
  00fdf	eb 0c		 jmp	 SHORT $LN244@z900_progr
$LN243@z900_progr:
  00fe1	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR tv596[rsp], 0
$LN244@z900_progr:

; 929  : 
; 930  :     realregs->instinvalid = 0;

  00fed	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00ff2	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00ff8	83 e0 f7	 and	 eax, -9			; fffffff7H
  00ffb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01000	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN60@z900_progr:

; 931  :     PTT_PGM( "PGM inval=0", 0, 0, 0 );

  01006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0100d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01010	48 83 e0 20	 and	 rax, 32			; 00000020H
  01014	48 85 c0	 test	 rax, rax
  01017	74 36		 je	 SHORT $LN141@z900_progr
  01019	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01022	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0102b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196125
  01032	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01037	45 33 c9	 xor	 r9d, r9d
  0103a	45 33 c0	 xor	 r8d, r8d
  0103d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196126
  01044	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN141@z900_progr:
  0104f	33 c0		 xor	 eax, eax
  01051	85 c0		 test	 eax, eax
  01053	75 b1		 jne	 SHORT $LN60@z900_progr

; 932  : 
; 933  : #if defined( FEATURE_SIE )
; 934  : 
; 935  :     /*---------------------------------------------------------*/
; 936  :     /* If this is a host exception in SIE state then leave SIE */
; 937  :     /*---------------------------------------------------------*/
; 938  :     if (realregs->sie_active)

  01055	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0105a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01060	83 e0 01	 and	 eax, 1
  01063	85 c0		 test	 eax, eax
  01065	74 62		 je	 SHORT $LN142@z900_progr
$LN63@z900_progr:

; 939  :     {
; 940  :         PTT_PGM( "PGM >sie_exit", SIE_HOST_PGM_INT, 0, 0 );

  01067	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0106e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01071	48 83 e0 20	 and	 rax, 32			; 00000020H
  01075	48 85 c0	 test	 rax, rax
  01078	74 3a		 je	 SHORT $LN143@z900_progr
  0107a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01083	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0108c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196129
  01093	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01098	45 33 c9	 xor	 r9d, r9d
  0109b	49 c7 c0 fd ff
	ff ff		 mov	 r8, -3
  010a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196130
  010a9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  010ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN143@z900_progr:
  010b4	33 c0		 xor	 eax, eax
  010b6	85 c0		 test	 eax, eax
  010b8	75 ad		 jne	 SHORT $LN63@z900_progr

; 941  :         ARCH_DEP( sie_exit )( realregs, SIE_HOST_PGM_INT );

  010ba	ba fd ff ff ff	 mov	 edx, -3
  010bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  010c4	e8 00 00 00 00	 call	 z900_sie_exit
$LN142@z900_progr:

; 942  :     }
; 943  : #endif
; 944  : 
; 945  :     /* Absolute address of prefix page */
; 946  :     px = realregs->PX;

  010c9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  010ce	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  010d2	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR px$[rsp], rax

; 947  : 
; 948  :     /* If under SIE use translated to host absolute prefix */
; 949  : #if defined( _FEATURE_SIE )
; 950  :     if (SIE_MODE( regs ))

  010da	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010e2	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  010e8	d1 e8		 shr	 eax, 1
  010ea	83 e0 01	 and	 eax, 1
  010ed	85 c0		 test	 eax, eax
  010ef	74 17		 je	 SHORT $LN144@z900_progr

; 951  :         px = regs->sie_px;

  010f1	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010f9	48 8b 80 90 08
	00 00		 mov	 rax, QWORD PTR [rax+2192]
  01100	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR px$[rsp], rax
$LN144@z900_progr:

; 952  : #endif
; 953  : 
; 954  : #if defined( _FEATURE_SIE )
; 955  :     /*---------------------------------------------------------------*/
; 956  :     /*   If we're in SIE mode, then we need to determine whether     */
; 957  :     /*   we must, or must not, intercept this program interrupt,     */
; 958  :     /*   and by intercept, we mean pass it on to the SIE host so     */
; 959  :     /*   that it (not the guest!) can decide what action to take.    */
; 960  :     /*---------------------------------------------------------------*/
; 961  :     if (0
; 962  : 
; 963  :         /* If not in SIE mode, then we (duh!) must not intercept it  */
; 964  :         || !SIE_MODE( regs )
; 965  : 
; 966  :         /* Interception is mandatory for the following exceptions,
; 967  :            so if ANY of the below conditions are false, then we MUST
; 968  :            intercept this program interrupt.
; 969  : 
; 970  :            The below tests/checks are for "not this condition" where
; 971  :            the "condition" is the condition which we MUST intercept.
; 972  :            Thus if any of them fail, then we MUST intercept.
; 973  : 
; 974  :            Only if ALL of them are true (only if no condition exists
; 975  :            that REQUIRES an intercept) should we then NOT intercept.
; 976  :         */
; 977  :         || (1

  01108	33 c0		 xor	 eax, eax
  0110a	85 c0		 test	 eax, eax
  0110c	0f 85 c1 01 00
	00		 jne	 $LN147@z900_progr
  01112	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0111a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01120	d1 e8		 shr	 eax, 1
  01122	83 e0 01	 and	 eax, 1
  01125	85 c0		 test	 eax, eax
  01127	0f 84 a6 01 00
	00		 je	 $LN147@z900_progr
  0112d	33 c0		 xor	 eax, eax
  0112f	83 f8 01	 cmp	 eax, 1
  01132	0f 84 44 02 00
	00		 je	 $LN145@z900_progr
  01138	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  0113d	0f 84 39 02 00
	00		 je	 $LN145@z900_progr
  01143	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  01148	0f 84 2e 02 00
	00		 je	 $LN145@z900_progr
  0114e	83 7c 24 78 13	 cmp	 DWORD PTR code$[rsp], 19
  01153	0f 84 23 02 00
	00		 je	 $LN145@z900_progr
  01159	83 7c 24 78 07	 cmp	 DWORD PTR code$[rsp], 7
  0115e	75 75		 jne	 SHORT $LN148@z900_progr
  01160	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01168	83 b8 08 07 00
	00 01		 cmp	 DWORD PTR [rax+1800], 1
  0116f	74 11		 je	 SHORT $LN149@z900_progr
  01171	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01179	83 b8 08 07 00
	00 02		 cmp	 DWORD PTR [rax+1800], 2
  01180	75 53		 jne	 SHORT $LN148@z900_progr
$LN149@z900_progr:
  01182	b8 08 00 00 00	 mov	 eax, 8
  01187	48 6b c0 01	 imul	 rax, rax, 1
  0118b	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01193	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0119b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  011a1	48 85 c0	 test	 rax, rax
  011a4	74 2f		 je	 SHORT $LN148@z900_progr
  011a6	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011ae	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  011b5	b9 08 00 00 00	 mov	 ecx, 8
  011ba	48 6b c9 01	 imul	 rcx, rcx, 1
  011be	48 8b 84 08 00
	06 00 00	 mov	 rax, QWORD PTR [rax+rcx+1536]
  011c6	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  011cc	48 85 c0	 test	 rax, rax
  011cf	0f 84 a7 01 00
	00		 je	 $LN145@z900_progr
$LN148@z900_progr:
  011d5	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011dd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  011e4	b9 01 00 00 00	 mov	 ecx, 1
  011e9	48 6b c9 00	 imul	 rcx, rcx, 0
  011ed	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  011f2	83 e0 20	 and	 eax, 32			; 00000020H
  011f5	85 c0		 test	 eax, eax
  011f7	0f 85 7f 01 00
	00		 jne	 $LN145@z900_progr
  011fd	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  01202	75 41		 jne	 SHORT $LN150@z900_progr
  01204	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0120c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01213	b9 01 00 00 00	 mov	 ecx, 1
  01218	48 6b c9 02	 imul	 rcx, rcx, 2
  0121c	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  01221	83 e0 20	 and	 eax, 32			; 00000020H
  01224	85 c0		 test	 eax, eax
  01226	0f 84 50 01 00
	00		 je	 $LN145@z900_progr
  0122c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01231	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01237	c1 e8 06	 shr	 eax, 6
  0123a	83 e0 01	 and	 eax, 1
  0123d	85 c0		 test	 eax, eax
  0123f	0f 85 37 01 00
	00		 jne	 $LN145@z900_progr
$LN150@z900_progr:
  01245	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  0124c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01251	85 c0		 test	 eax, eax
  01253	74 1e		 je	 SHORT $LN151@z900_progr
  01255	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0125d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01264	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01268	83 e0 01	 and	 eax, 1
  0126b	85 c0		 test	 eax, eax
  0126d	0f 85 09 01 00
	00		 jne	 $LN145@z900_progr
$LN151@z900_progr:
  01273	83 7c 24 78 01	 cmp	 DWORD PTR code$[rsp], 1
  01278	75 2a		 jne	 SHORT $LN152@z900_progr
  0127a	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01282	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  01289	b9 01 00 00 00	 mov	 ecx, 1
  0128e	48 6b c9 00	 imul	 rcx, rcx, 0
  01292	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  01297	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0129c	85 c0		 test	 eax, eax
  0129e	0f 85 d8 00 00
	00		 jne	 $LN145@z900_progr
$LN152@z900_progr:
  012a4	83 7c 24 78 02	 cmp	 DWORD PTR code$[rsp], 2
  012a9	75 28		 jne	 SHORT $LN153@z900_progr
  012ab	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  012b3	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  012ba	b9 01 00 00 00	 mov	 ecx, 1
  012bf	48 6b c9 00	 imul	 rcx, rcx, 0
  012c3	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  012c8	83 e0 40	 and	 eax, 64			; 00000040H
  012cb	85 c0		 test	 eax, eax
  012cd	0f 85 a9 00 00
	00		 jne	 $LN145@z900_progr
$LN153@z900_progr:
$LN147@z900_progr:

; 978  : 
; 979  :             && code != PGM_ADDRESSING_EXCEPTION
; 980  :             && code != PGM_SPECIFICATION_EXCEPTION
; 981  :             && code != PGM_SPECIAL_OPERATION_EXCEPTION
; 982  : 
; 983  : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 984  :             && code != PGM_VECTOR_OPERATION_EXCEPTION
; 985  : #endif
; 986  : #ifdef FEATURE_BASIC_FP_EXTENSIONS
; 987  :             && !(code == PGM_DATA_EXCEPTION && (regs->dxc == 1 || regs->dxc == 2) && (regs->CR(0) & CR0_AFP) && !(HOSTREGS->CR(0) & CR0_AFP))
; 988  : #endif
; 989  :             && !SIE_FEAT_BIT_ON( regs, IC0, PGMALL )
; 990  : 
; 991  : #if !defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 992  :             && code != PGM_PROTECTION_EXCEPTION
; 993  : #else
; 994  :             && !(code == PGM_PROTECTION_EXCEPTION           && (!SIE_FEAT_BIT_ON( regs, EC2, PROTEX ) || realregs->hostint ))
; 995  : #endif
; 996  : #if defined( _FEATURE_PER2 )
; 997  :             && !((pcode & PGM_PER_EVENT)                    && SIE_FEAT_BIT_ON( regs, M, GPE ))
; 998  : #endif
; 999  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 1000 :             && !(code == PGM_ALEN_TRANSLATION_EXCEPTION     && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1001 :             && !(code == PGM_ALE_SEQUENCE_EXCEPTION         && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1002 :             && !(code == PGM_EXTENDED_AUTHORITY_EXCEPTION   && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1003 : #endif
; 1004 :             && !(code == PGM_OPERATION_EXCEPTION            && SIE_FEAT_BIT_ON( regs, IC0, OPEREX ))
; 1005 :             && !(code == PGM_PRIVILEGED_OPERATION_EXCEPTION && SIE_FEAT_BIT_ON( regs, IC0, PRIVOP ))
; 1006 :            )
; 1007 :     )
; 1008 :     {
; 1009 : #endif /*defined(_FEATURE_SIE)*/
; 1010 : 
; 1011 :         intercept = false;

  012d3	c6 44 24 7c 00	 mov	 BYTE PTR intercept$[rsp], 0
$LN66@z900_progr:

; 1012 :         PTT_PGM( "PGM !icept", intercept, 0, 0 );

  012d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  012df	48 8b 00	 mov	 rax, QWORD PTR [rax]
  012e2	48 83 e0 20	 and	 rax, 32			; 00000020H
  012e6	48 85 c0	 test	 rax, rax
  012e9	74 3b		 je	 SHORT $LN154@z900_progr
  012eb	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  012f0	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  012f9	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01302	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196142
  01309	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0130e	45 33 c9	 xor	 r9d, r9d
  01311	44 8b c0	 mov	 r8d, eax
  01314	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196143
  0131b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01320	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN154@z900_progr:
  01326	33 c0		 xor	 eax, eax
  01328	85 c0		 test	 eax, eax
  0132a	75 ac		 jne	 SHORT $LN66@z900_progr

; 1013 : 
; 1014 :         /* Set the main storage reference and change bits */
; 1015 :         ARCH_DEP( or_storage_key )( px, (STORKEY_REF | STORKEY_CHANGE) );

  0132c	b2 06		 mov	 dl, 6
  0132e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR px$[rsp]
  01336	e8 00 00 00 00	 call	 z900_or_storage_key

; 1016 : 
; 1017 :         /* Point to PSA in main storage */
; 1018 :         psa = (void*)(regs->mainstor + px);

  0133b	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01343	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  0134a	48 03 84 24 d0
	00 00 00	 add	 rax, QWORD PTR px$[rsp]
  01352	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1019 : 
; 1020 : #if defined( _FEATURE_SIE )
; 1021 : 
; 1022 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1023 :         /** FIXME : SEE ISW20090110-1 */
; 1024 :         if (code == PGM_MONITOR_EVENT)

  0135a	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  0135f	75 16		 jne	 SHORT $LN155@z900_progr

; 1025 :         {
; 1026 :             zmoncode = psa->moncode;

  01361	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01369	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  0136f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR zmoncode$[rsp], rax
$LN155@z900_progr:

; 1027 :         }
; 1028 : #endif
; 1029 :     }

  01377	e9 2b 01 00 00	 jmp	 $LN146@z900_progr
$LN145@z900_progr:

; 1030 :     else /* The SIE host must deal with this program interrupt */
; 1031 :     {
; 1032 :         intercept = true;

  0137c	c6 44 24 7c 01	 mov	 BYTE PTR intercept$[rsp], 1
$LN69@z900_progr:

; 1033 :         PTT_PGM( "PGM icept", intercept, 0, 0 );

  01381	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01388	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0138b	48 83 e0 20	 and	 rax, 32			; 00000020H
  0138f	48 85 c0	 test	 rax, rax
  01392	74 3b		 je	 SHORT $LN156@z900_progr
  01394	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01399	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  013a2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  013ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196146
  013b2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  013b7	45 33 c9	 xor	 r9d, r9d
  013ba	44 8b c0	 mov	 r8d, eax
  013bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196147
  013c4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  013c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN156@z900_progr:
  013cf	33 c0		 xor	 eax, eax
  013d1	85 c0		 test	 eax, eax
  013d3	75 ac		 jne	 SHORT $LN69@z900_progr

; 1034 : 
; 1035 :         /* This is a guest interruption interception so point to
; 1036 :            the interruption parm area in the state descriptor
; 1037 :            rather then the PSA (except for Operation Exception)
; 1038 :         */
; 1039 :         if (code != PGM_OPERATION_EXCEPTION)

  013d5	83 7c 24 78 01	 cmp	 DWORD PTR code$[rsp], 1
  013da	0f 84 99 00 00
	00		 je	 $LN157@z900_progr

; 1040 :         {
; 1041 :             psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_IP_PSA_OFFSET);

  013e0	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013e8	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  013ef	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  013f6	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  013fe	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  01405	48 8d 44 08 40	 lea	 rax, QWORD PTR [rax+rcx+64]
  0140a	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1042 : 
; 1043 :             /* Set the main storage reference and change bits */
; 1044 :             ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  01412	b2 06		 mov	 dl, 6
  01414	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0141c	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  01423	e8 00 00 00 00	 call	 z900_or_storage_key

; 1045 : 
; 1046 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1047 :             /** FIXME : SEE ISW20090110-1 */
; 1048 :             if (code == PGM_MONITOR_EVENT)

  01428	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  0142d	75 48		 jne	 SHORT $LN159@z900_progr

; 1049 :             {
; 1050 :                 PSA* _psa;
; 1051 :                 _psa = (void *)(HOSTREGS->mainstor + SIE_STATE( regs ) + SIE_II_PSA_OFFSET);

  0142f	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01437	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0143e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01445	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0144d	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  01454	48 8d 44 08 30	 lea	 rax, QWORD PTR [rax+rcx+48]
  01459	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR _psa$6[rsp], rax

; 1052 :                 zmoncode = _psa->ioid;

  01461	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR _psa$6[rsp]
  01469	48 05 b8 00 00
	00		 add	 rax, 184		; 000000b8H
  0146f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR zmoncode$[rsp], rax
$LN159@z900_progr:

; 1053 :             }
; 1054 : #endif
; 1055 :         }

  01477	eb 2e		 jmp	 SHORT $LN158@z900_progr
$LN157@z900_progr:

; 1056 :         else
; 1057 :         {
; 1058 :             /* Point to PSA in main storage */
; 1059 :             psa = (void*)(regs->mainstor + px);

  01479	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01481	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01488	48 03 84 24 d0
	00 00 00	 add	 rax, QWORD PTR px$[rsp]
  01490	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1060 : 
; 1061 :             /* Set the main storage reference and change bits */
; 1062 :             ARCH_DEP( or_storage_key )( px, (STORKEY_REF | STORKEY_CHANGE) );

  01498	b2 06		 mov	 dl, 6
  0149a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR px$[rsp]
  014a2	e8 00 00 00 00	 call	 z900_or_storage_key
$LN158@z900_progr:
$LN146@z900_progr:

; 1063 :         }
; 1064 :     }
; 1065 : #endif /*defined(_FEATURE_SIE)*/
; 1066 : 
; 1067 : #if defined( _FEATURE_PER )
; 1068 :     /* Handle PER or concurrent PER event */
; 1069 : 
; 1070 :     /* Throw out Stor Alter PER if merged with nullified/suppressed rupt */
; 1071 :     if (1
; 1072 :         &&  IS_IC_PER_SA(    realregs )
; 1073 :         && !IS_IC_PER_STURA( realregs )
; 1074 :         && (realregs->ip[0] != 0x0E)
; 1075 :         && !(0

  014a7	33 c0		 xor	 eax, eax
  014a9	83 f8 01	 cmp	 eax, 1
  014ac	0f 84 a0 00 00
	00		 je	 $LN160@z900_progr
  014b2	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  014b7	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  014ba	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  014bf	85 c0		 test	 eax, eax
  014c1	0f 84 8b 00 00
	00		 je	 $LN160@z900_progr
  014c7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  014cc	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  014cf	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  014d4	85 c0		 test	 eax, eax
  014d6	75 7a		 jne	 SHORT $LN160@z900_progr
  014d8	b8 01 00 00 00	 mov	 eax, 1
  014dd	48 6b c0 00	 imul	 rax, rax, 0
  014e1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  014e6	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  014ea	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  014ee	83 f8 0e	 cmp	 eax, 14
  014f1	74 5f		 je	 SHORT $LN160@z900_progr
  014f3	33 c0		 xor	 eax, eax
  014f5	85 c0		 test	 eax, eax
  014f7	75 59		 jne	 SHORT $LN160@z900_progr
  014f9	83 7c 24 78 00	 cmp	 DWORD PTR code$[rsp], 0
  014fe	74 52		 je	 SHORT $LN160@z900_progr
  01500	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  01505	74 4b		 je	 SHORT $LN160@z900_progr
  01507	83 7c 24 78 08	 cmp	 DWORD PTR code$[rsp], 8
  0150c	74 44		 je	 SHORT $LN160@z900_progr
  0150e	83 7c 24 78 0a	 cmp	 DWORD PTR code$[rsp], 10
  01513	74 3d		 je	 SHORT $LN160@z900_progr
  01515	83 7c 24 78 0c	 cmp	 DWORD PTR code$[rsp], 12
  0151a	74 36		 je	 SHORT $LN160@z900_progr
  0151c	83 7c 24 78 0d	 cmp	 DWORD PTR code$[rsp], 13
  01521	74 2f		 je	 SHORT $LN160@z900_progr
  01523	83 7c 24 78 0e	 cmp	 DWORD PTR code$[rsp], 14
  01528	74 28		 je	 SHORT $LN160@z900_progr
  0152a	83 7c 24 78 1c	 cmp	 DWORD PTR code$[rsp], 28
  0152f	74 21		 je	 SHORT $LN160@z900_progr
  01531	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  01536	74 1a		 je	 SHORT $LN160@z900_progr
$LN72@z900_progr:

; 1076 :              || code == 0x00
; 1077 :              || code == PGM_SPECIFICATION_EXCEPTION
; 1078 :              || code == PGM_FIXED_POINT_OVERFLOW_EXCEPTION
; 1079 :              || code == PGM_DECIMAL_OVERFLOW_EXCEPTION
; 1080 :              || code == PGM_EXPONENT_OVERFLOW_EXCEPTION
; 1081 :              || code == PGM_EXPONENT_UNDERFLOW_EXCEPTION
; 1082 :              || code == PGM_SIGNIFICANCE_EXCEPTION
; 1083 :              || code == PGM_SPACE_SWITCH_EVENT
; 1084 :              || code == PGM_MONITOR_EVENT
; 1085 :            )
; 1086 :     )
; 1087 :     {
; 1088 :         OFF_IC_PER_SA( realregs );

  01538	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0153d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01540	0f ba f0 15	 btr	 eax, 21
  01544	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01549	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0154c	33 c0		 xor	 eax, eax
  0154e	85 c0		 test	 eax, eax
  01550	75 e6		 jne	 SHORT $LN72@z900_progr
$LN160@z900_progr:

; 1089 :     }
; 1090 : 
; 1091 :     if (OPEN_IC_PER( realregs ))

  01552	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01557	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0155c	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0155f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01562	23 c1		 and	 eax, ecx
  01564	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  01569	85 c0		 test	 eax, eax
  0156b	0f 84 29 0a 00
	00		 je	 $LN161@z900_progr

; 1092 :     {
; 1093 :         if (CPU_STEPPING_OR_TRACING( realregs, ilc ))

  01571	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01576	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0157c	c1 e8 10	 shr	 eax, 16
  0157f	83 e0 01	 and	 eax, 1
  01582	85 c0		 test	 eax, eax
  01584	74 0d		 je	 SHORT $LN247@z900_progr
  01586	c7 84 24 c8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv821[rsp], 1
  01591	eb 0b		 jmp	 SHORT $LN248@z900_progr
$LN247@z900_progr:
  01593	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv821[rsp], 0
$LN248@z900_progr:
  0159e	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR tv821[rsp], 0
  015a6	0f 84 b0 08 00
	00		 je	 $LN163@z900_progr
  015ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  015b3	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  015b9	c1 e8 0a	 shr	 eax, 10
  015bc	83 e0 01	 and	 eax, 1
  015bf	85 c0		 test	 eax, eax
  015c1	0f 84 4b 03 00
	00		 je	 $LN165@z900_progr
  015c7	33 c0		 xor	 eax, eax
  015c9	85 c0		 test	 eax, eax
  015cb	0f 85 17 01 00
	00		 jne	 $LN166@z900_progr
  015d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  015d8	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  015de	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  015e3	85 c0		 test	 eax, eax
  015e5	0f 84 fd 00 00
	00		 je	 $LN166@z900_progr
  015eb	33 c0		 xor	 eax, eax
  015ed	83 f8 01	 cmp	 eax, 1
  015f0	0f 84 1c 03 00
	00		 je	 $LN165@z900_progr
  015f6	33 c0		 xor	 eax, eax
  015f8	85 c0		 test	 eax, eax
  015fa	75 34		 jne	 SHORT $LN167@z900_progr
  015fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01603	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01609	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0160e	85 c0		 test	 eax, eax
  01610	74 1e		 je	 SHORT $LN167@z900_progr
  01612	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01617	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0161e	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  01624	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  0162a	0f 85 e2 02 00
	00		 jne	 $LN165@z900_progr
$LN167@z900_progr:
  01630	33 c0		 xor	 eax, eax
  01632	85 c0		 test	 eax, eax
  01634	75 34		 jne	 SHORT $LN168@z900_progr
  01636	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0163d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01643	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  01648	85 c0		 test	 eax, eax
  0164a	74 1e		 je	 SHORT $LN168@z900_progr
  0164c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01651	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01658	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  0165e	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  01664	0f 8c a8 02 00
	00		 jl	 $LN165@z900_progr
$LN168@z900_progr:
  0166a	33 c0		 xor	 eax, eax
  0166c	85 c0		 test	 eax, eax
  0166e	75 78		 jne	 SHORT $LN169@z900_progr
  01670	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01677	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0167d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  01682	85 c0		 test	 eax, eax
  01684	74 20		 je	 SHORT $LN170@z900_progr
  01686	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0168b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01692	85 c0		 test	 eax, eax
  01694	74 10		 je	 SHORT $LN170@z900_progr
  01696	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0169b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  016a2	85 c0		 test	 eax, eax
  016a4	75 42		 jne	 SHORT $LN169@z900_progr
$LN170@z900_progr:
  016a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  016ad	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  016b3	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  016b8	85 c0		 test	 eax, eax
  016ba	0f 84 52 02 00
	00		 je	 $LN165@z900_progr
  016c0	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  016c5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  016cc	85 c0		 test	 eax, eax
  016ce	0f 84 3e 02 00
	00		 je	 $LN165@z900_progr
  016d4	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  016d9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  016e0	85 c0		 test	 eax, eax
  016e2	0f 85 2a 02 00
	00		 jne	 $LN165@z900_progr
$LN169@z900_progr:
$LN166@z900_progr:
  016e8	b8 08 00 00 00	 mov	 eax, 8
  016ed	48 6b c0 00	 imul	 rax, rax, 0
  016f1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  016f8	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  01701	75 1f		 jne	 SHORT $LN171@z900_progr
  01703	b8 08 00 00 00	 mov	 eax, 8
  01708	48 6b c0 01	 imul	 rax, rax, 1
  0170c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01713	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0171c	0f 84 7e 05 00
	00		 je	 $LN164@z900_progr
$LN171@z900_progr:
  01722	b8 08 00 00 00	 mov	 eax, 8
  01727	48 6b c0 00	 imul	 rax, rax, 0
  0172b	b9 08 00 00 00	 mov	 ecx, 8
  01730	48 6b c9 01	 imul	 rcx, rcx, 1
  01734	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0173b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  01742	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  0174a	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  01752	0f 87 c2 00 00
	00		 ja	 $LN172@z900_progr
  01758	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0175d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01762	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01769	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0176d	48 2b c1	 sub	 rax, rcx
  01770	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01775	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0177c	48 03 c8	 add	 rcx, rax
  0177f	48 8b c1	 mov	 rax, rcx
  01782	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01789	f7 d9		 neg	 ecx
  0178b	48 63 c9	 movsxd	 rcx, ecx
  0178e	48 03 c1	 add	 rax, rcx
  01791	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01796	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0179d	b9 08 00 00 00	 mov	 ecx, 8
  017a2	48 6b c9 00	 imul	 rcx, rcx, 0
  017a6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  017ad	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  017b5	72 63		 jb	 SHORT $LN172@z900_progr
  017b7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  017bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  017c1	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  017c8	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  017cc	48 2b c1	 sub	 rax, rcx
  017cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  017d4	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  017db	48 03 c8	 add	 rcx, rax
  017de	48 8b c1	 mov	 rax, rcx
  017e1	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  017e8	f7 d9		 neg	 ecx
  017ea	48 63 c9	 movsxd	 rcx, ecx
  017ed	48 03 c1	 add	 rax, rcx
  017f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  017f5	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  017fc	b9 08 00 00 00	 mov	 ecx, 8
  01801	48 6b c9 01	 imul	 rcx, rcx, 1
  01805	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0180c	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  01814	0f 86 86 04 00
	00		 jbe	 $LN164@z900_progr
$LN172@z900_progr:
  0181a	b8 08 00 00 00	 mov	 eax, 8
  0181f	48 6b c0 00	 imul	 rax, rax, 0
  01823	b9 08 00 00 00	 mov	 ecx, 8
  01828	48 6b c9 01	 imul	 rcx, rcx, 1
  0182c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01833	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0183a	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  01842	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  0184a	0f 86 c2 00 00
	00		 jbe	 $LN173@z900_progr
  01850	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01855	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0185a	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01861	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01865	48 2b c1	 sub	 rax, rcx
  01868	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0186d	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  01874	48 03 c8	 add	 rcx, rax
  01877	48 8b c1	 mov	 rax, rcx
  0187a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01881	f7 d9		 neg	 ecx
  01883	48 63 c9	 movsxd	 rcx, ecx
  01886	48 03 c1	 add	 rax, rcx
  01889	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0188e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01895	b9 08 00 00 00	 mov	 ecx, 8
  0189a	48 6b c9 01	 imul	 rcx, rcx, 1
  0189e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  018a5	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  018ad	72 63		 jb	 SHORT $LN173@z900_progr
  018af	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  018b4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  018b9	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  018c0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  018c4	48 2b c1	 sub	 rax, rcx
  018c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  018cc	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  018d3	48 03 c8	 add	 rcx, rax
  018d6	48 8b c1	 mov	 rax, rcx
  018d9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  018e0	f7 d9		 neg	 ecx
  018e2	48 63 c9	 movsxd	 rcx, ecx
  018e5	48 03 c1	 add	 rax, rcx
  018e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  018ed	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  018f4	b9 08 00 00 00	 mov	 ecx, 8
  018f9	48 6b c9 00	 imul	 rcx, rcx, 0
  018fd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01904	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0190c	0f 86 8e 03 00
	00		 jbe	 $LN164@z900_progr
$LN173@z900_progr:
$LN165@z900_progr:
  01912	33 c0		 xor	 eax, eax
  01914	83 f8 01	 cmp	 eax, 1
  01917	0f 84 3f 05 00
	00		 je	 $LN163@z900_progr
  0191d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01924	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0192a	c1 e8 08	 shr	 eax, 8
  0192d	83 e0 01	 and	 eax, 1
  01930	85 c0		 test	 eax, eax
  01932	0f 84 24 05 00
	00		 je	 $LN163@z900_progr
  01938	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0193d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01943	c1 e8 0f	 shr	 eax, 15
  01946	83 e0 01	 and	 eax, 1
  01949	85 c0		 test	 eax, eax
  0194b	0f 84 0b 05 00
	00		 je	 $LN163@z900_progr
  01951	33 c0		 xor	 eax, eax
  01953	85 c0		 test	 eax, eax
  01955	0f 85 17 01 00
	00		 jne	 $LN174@z900_progr
  0195b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01962	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01968	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0196d	85 c0		 test	 eax, eax
  0196f	0f 84 fd 00 00
	00		 je	 $LN174@z900_progr
  01975	33 c0		 xor	 eax, eax
  01977	83 f8 01	 cmp	 eax, 1
  0197a	0f 84 dc 04 00
	00		 je	 $LN163@z900_progr
  01980	33 c0		 xor	 eax, eax
  01982	85 c0		 test	 eax, eax
  01984	75 34		 jne	 SHORT $LN175@z900_progr
  01986	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0198d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01993	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  01998	85 c0		 test	 eax, eax
  0199a	74 1e		 je	 SHORT $LN175@z900_progr
  0199c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  019a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  019a8	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  019ae	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  019b4	0f 85 a2 04 00
	00		 jne	 $LN163@z900_progr
$LN175@z900_progr:
  019ba	33 c0		 xor	 eax, eax
  019bc	85 c0		 test	 eax, eax
  019be	75 34		 jne	 SHORT $LN176@z900_progr
  019c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  019c7	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  019cd	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  019d2	85 c0		 test	 eax, eax
  019d4	74 1e		 je	 SHORT $LN176@z900_progr
  019d6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  019db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  019e2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  019e8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  019ee	0f 8c 68 04 00
	00		 jl	 $LN163@z900_progr
$LN176@z900_progr:
  019f4	33 c0		 xor	 eax, eax
  019f6	85 c0		 test	 eax, eax
  019f8	75 78		 jne	 SHORT $LN177@z900_progr
  019fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01a01	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01a07	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  01a0c	85 c0		 test	 eax, eax
  01a0e	74 20		 je	 SHORT $LN178@z900_progr
  01a10	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01a15	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01a1c	85 c0		 test	 eax, eax
  01a1e	74 10		 je	 SHORT $LN178@z900_progr
  01a20	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01a25	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01a2c	85 c0		 test	 eax, eax
  01a2e	75 42		 jne	 SHORT $LN177@z900_progr
$LN178@z900_progr:
  01a30	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01a37	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01a3d	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  01a42	85 c0		 test	 eax, eax
  01a44	0f 84 12 04 00
	00		 je	 $LN163@z900_progr
  01a4a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01a4f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01a56	85 c0		 test	 eax, eax
  01a58	0f 84 fe 03 00
	00		 je	 $LN163@z900_progr
  01a5e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01a63	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01a6a	85 c0		 test	 eax, eax
  01a6c	0f 85 ea 03 00
	00		 jne	 $LN163@z900_progr
$LN177@z900_progr:
$LN174@z900_progr:
  01a72	b8 08 00 00 00	 mov	 eax, 8
  01a77	48 6b c0 00	 imul	 rax, rax, 0
  01a7b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01a82	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  01a8b	75 1f		 jne	 SHORT $LN180@z900_progr
  01a8d	b8 08 00 00 00	 mov	 eax, 8
  01a92	48 6b c0 01	 imul	 rax, rax, 1
  01a96	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01a9d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  01aa6	0f 84 f4 01 00
	00		 je	 $LN179@z900_progr
$LN180@z900_progr:
  01aac	b8 08 00 00 00	 mov	 eax, 8
  01ab1	48 6b c0 00	 imul	 rax, rax, 0
  01ab5	b9 08 00 00 00	 mov	 ecx, 8
  01aba	48 6b c9 01	 imul	 rcx, rcx, 1
  01abe	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01ac5	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  01acc	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  01ad4	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  01adc	0f 87 c2 00 00
	00		 ja	 $LN181@z900_progr
  01ae2	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01ae7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01aec	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01af3	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01af7	48 2b c1	 sub	 rax, rcx
  01afa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01aff	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  01b06	48 03 c8	 add	 rcx, rax
  01b09	48 8b c1	 mov	 rax, rcx
  01b0c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01b13	f7 d9		 neg	 ecx
  01b15	48 63 c9	 movsxd	 rcx, ecx
  01b18	48 03 c1	 add	 rax, rcx
  01b1b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b20	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01b27	b9 08 00 00 00	 mov	 ecx, 8
  01b2c	48 6b c9 00	 imul	 rcx, rcx, 0
  01b30	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01b37	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  01b3f	72 63		 jb	 SHORT $LN181@z900_progr
  01b41	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01b46	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b4b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01b52	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01b56	48 2b c1	 sub	 rax, rcx
  01b59	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b5e	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  01b65	48 03 c8	 add	 rcx, rax
  01b68	48 8b c1	 mov	 rax, rcx
  01b6b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01b72	f7 d9		 neg	 ecx
  01b74	48 63 c9	 movsxd	 rcx, ecx
  01b77	48 03 c1	 add	 rax, rcx
  01b7a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b7f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01b86	b9 08 00 00 00	 mov	 ecx, 8
  01b8b	48 6b c9 01	 imul	 rcx, rcx, 1
  01b8f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01b96	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  01b9e	0f 86 fc 00 00
	00		 jbe	 $LN179@z900_progr
$LN181@z900_progr:
  01ba4	b8 08 00 00 00	 mov	 eax, 8
  01ba9	48 6b c0 00	 imul	 rax, rax, 0
  01bad	b9 08 00 00 00	 mov	 ecx, 8
  01bb2	48 6b c9 01	 imul	 rcx, rcx, 1
  01bb6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01bbd	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  01bc4	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  01bcc	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  01bd4	0f 86 82 02 00
	00		 jbe	 $LN163@z900_progr
  01bda	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01bdf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01be4	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01beb	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01bef	48 2b c1	 sub	 rax, rcx
  01bf2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01bf7	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  01bfe	48 03 c8	 add	 rcx, rax
  01c01	48 8b c1	 mov	 rax, rcx
  01c04	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01c0b	f7 d9		 neg	 ecx
  01c0d	48 63 c9	 movsxd	 rcx, ecx
  01c10	48 03 c1	 add	 rax, rcx
  01c13	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c18	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01c1f	b9 08 00 00 00	 mov	 ecx, 8
  01c24	48 6b c9 01	 imul	 rcx, rcx, 1
  01c28	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01c2f	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  01c37	0f 82 1f 02 00
	00		 jb	 $LN163@z900_progr
  01c3d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01c42	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c47	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  01c4e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  01c52	48 2b c1	 sub	 rax, rcx
  01c55	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c5a	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  01c61	48 03 c8	 add	 rcx, rax
  01c64	48 8b c1	 mov	 rax, rcx
  01c67	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01c6e	f7 d9		 neg	 ecx
  01c70	48 63 c9	 movsxd	 rcx, ecx
  01c73	48 03 c1	 add	 rax, rcx
  01c76	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c7b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01c82	b9 08 00 00 00	 mov	 ecx, 8
  01c87	48 6b c9 00	 imul	 rcx, rcx, 0
  01c8b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01c92	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  01c9a	0f 87 bc 01 00
	00		 ja	 $LN163@z900_progr
$LN179@z900_progr:
$LN164@z900_progr:

; 1094 :         {
; 1095 :             BYTE perc = IS_IC_PER( realregs ) >> 16;

  01ca0	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01ca5	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01ca8	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  01cad	c1 e8 10	 shr	 eax, 16
  01cb0	88 84 24 84 00
	00 00		 mov	 BYTE PTR perc$1[rsp], al

; 1096 : 
; 1097 :             if (regs->insttrace && sysblk.traceFILE)

  01cb7	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01cbf	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01cc5	c1 e8 0f	 shr	 eax, 15
  01cc8	83 e0 01	 and	 eax, 1
  01ccb	85 c0		 test	 eax, eax
  01ccd	74 61		 je	 SHORT $LN182@z900_progr
  01ccf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01cd6	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01cde	74 50		 je	 SHORT $LN182@z900_progr

; 1098 :                 tf_0802( regs,

  01ce0	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR perc$1[rsp]
  01ce8	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR ilc$[rsp]
  01cf0	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  01cf5	48 8b 92 88 00
	00 00		 mov	 rdx, QWORD PTR [rdx+136]
  01cfc	48 2b d1	 sub	 rdx, rcx
  01cff	48 8b ca	 mov	 rcx, rdx
  01d02	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  01d07	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  01d0e	44 0f b7 c8	 movzx	 r9d, ax
  01d12	44 8b 84 24 18
	02 00 00	 mov	 r8d, DWORD PTR pcode$[rsp]
  01d1a	48 8b d1	 mov	 rdx, rcx
  01d1d	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d25	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0802
  01d2b	e9 2c 01 00 00	 jmp	 $LN183@z900_progr
$LN182@z900_progr:

; 1099 :                         (realregs->psw.IA - ilc) & ADDRESS_MAXWRAP( realregs ),
; 1100 :                          pcode, perc );
; 1101 :             else
; 1102 :             {
; 1103 :                 char percname[32];
; 1104 :                 perc2name( perc, percname, sizeof( percname ));

  01d30	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  01d36	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR percname$9[rsp]
  01d3e	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR perc$1[rsp]
  01d46	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perc2name

; 1105 : 
; 1106 :                 // "Processor %s%02X: PER event: code %4.4X perc %2.2X=%s addr "F_VADR
; 1107 :                 WRMSG( HHC00802, "I", PTYPSTR( regs->cpuad ), regs->cpuad,

  01d4c	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  01d54	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01d59	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  01d60	48 2b c8	 sub	 rcx, rax
  01d63	48 8b c1	 mov	 rax, rcx
  01d66	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01d6b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  01d72	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv1095[rsp], rax
  01d7a	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR perc$1[rsp]
  01d82	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv1098[rsp], ecx
  01d89	48 8b 94 24 10
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01d91	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  01d98	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv1102[rsp], edx
  01d9f	4c 8b 84 24 10
	02 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01da7	45 0f b7 80 3c
	08 00 00	 movzx	 r8d, WORD PTR [r8+2108]
  01daf	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_sysblk
  01db6	43 0f b6 8c 01
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r9+r8+2888]
  01dbf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01dc5	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv1104[rsp], rax
  01dcd	b9 01 00 00 00	 mov	 ecx, 1
  01dd2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01dd8	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv1095[rsp]
  01de0	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01de5	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR percname$9[rsp]
  01ded	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01df2	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv1098[rsp]
  01df9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01dfd	8b 8c 24 18 02
	00 00		 mov	 ecx, DWORD PTR pcode$[rsp]
  01e04	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01e08	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv1102[rsp]
  01e0f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01e13	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv1104[rsp]
  01e1b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01e20	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196175
  01e27	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196176
  01e33	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e38	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e3d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01e43	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196177
  01e4a	ba 55 04 00 00	 mov	 edx, 1109		; 00000455H
  01e4f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196178
  01e56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN183@z900_progr:
$LN163@z900_progr:

; 1108 :                     pcode, perc, percname,
; 1109 :                     (realregs->psw.IA - ilc) & ADDRESS_MAXWRAP( realregs ));
; 1110 :             }
; 1111 :         }
; 1112 : 
; 1113 :         realregs->perc |= OPEN_IC_PER( realregs ) >> ((32 - IC_CR9_SHIFT) - 16);

  01e5c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01e61	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01e66	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01e69	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01e6c	23 c1		 and	 eax, ecx
  01e6e	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  01e73	c1 e8 08	 shr	 eax, 8
  01e76	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01e7b	0f b7 89 d0 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2256]
  01e82	0b c8		 or	 ecx, eax
  01e84	8b c1		 mov	 eax, ecx
  01e86	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01e8b	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 1114 : 
; 1115 :         /* Positions 14 and 15 contain zeros
; 1116 :            if a storage alteration event was not indicated
; 1117 :         */
; 1118 :         if (0
; 1119 :             || !OPEN_IC_PER_SA(    realregs )
; 1120 :             ||  OPEN_IC_PER_STURA( realregs )

  01e92	33 c0		 xor	 eax, eax
  01e94	85 c0		 test	 eax, eax
  01e96	75 36		 jne	 SHORT $LN185@z900_progr
  01e98	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01e9d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01ea2	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01ea5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01ea8	23 c1		 and	 eax, ecx
  01eaa	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01eaf	85 c0		 test	 eax, eax
  01eb1	74 1b		 je	 SHORT $LN185@z900_progr
  01eb3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01eb8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01ebd	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01ec0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01ec3	23 c1		 and	 eax, ecx
  01ec5	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  01eca	85 c0		 test	 eax, eax
  01ecc	74 1d		 je	 SHORT $LN184@z900_progr
$LN185@z900_progr:

; 1121 :         )
; 1122 :             realregs->perc &= 0xFFFC;

  01ece	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01ed3	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  01eda	25 fc ff 00 00	 and	 eax, 65532		; 0000fffcH
  01edf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01ee4	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax
$LN184@z900_progr:

; 1123 : 
; 1124 :         STORE_HW( psa->perint, realregs->perc   );

  01eeb	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01ef0	0f b7 88 d0 08
	00 00		 movzx	 ecx, WORD PTR [rax+2256]
  01ef7	e8 00 00 00 00	 call	 _byteswap_ushort
  01efc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01f04	48 81 c1 96 00
	00 00		 add	 rcx, 150		; 00000096H
  01f0b	0f b7 d0	 movzx	 edx, ax
  01f0e	e8 00 00 00 00	 call	 store_hw_noswap

; 1125 :         STORE_W(  psa->peradr, realregs->peradr );

  01f13	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01f18	48 8b 88 d8 08
	00 00		 mov	 rcx, QWORD PTR [rax+2264]
  01f1f	e8 00 00 00 00	 call	 _byteswap_uint64
  01f24	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01f2c	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  01f33	48 8b d0	 mov	 rdx, rax
  01f36	e8 00 00 00 00	 call	 store_dw_noswap

; 1126 : 
; 1127 :         if (IS_IC_PER_SA( realregs ) && ACCESS_REGISTER_MODE( &realregs->psw ))

  01f3b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01f40	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01f43	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01f48	85 c0		 test	 eax, eax
  01f4a	74 28		 je	 SHORT $LN186@z900_progr
  01f4c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01f51	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  01f55	83 f8 40	 cmp	 eax, 64			; 00000040H
  01f58	75 1a		 jne	 SHORT $LN186@z900_progr

; 1128 :             psa->perarid = realregs->peraid;

  01f5a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01f62	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01f67	0f b6 89 e0 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2272]
  01f6e	88 88 a1 00 00
	00		 mov	 BYTE PTR [rax+161], cl
$LN186@z900_progr:

; 1129 : 
; 1130 : #if defined( _FEATURE_SIE )
; 1131 :         /* Reset PER pending indication */
; 1132 :         if (!intercept)

  01f74	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01f79	85 c0		 test	 eax, eax
  01f7b	75 1b		 jne	 SHORT $LN187@z900_progr
$LN75@z900_progr:

; 1133 :             OFF_IC_PER( realregs );

  01f7d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01f82	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01f85	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  01f8a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01f8f	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01f92	33 c0		 xor	 eax, eax
  01f94	85 c0		 test	 eax, eax
  01f96	75 e5		 jne	 SHORT $LN75@z900_progr
$LN187@z900_progr:

; 1134 : #endif
; 1135 :     }

  01f98	eb 12		 jmp	 SHORT $LN162@z900_progr
$LN161@z900_progr:

; 1136 :     else
; 1137 :     {
; 1138 :         pcode &= ~(PGM_PER_EVENT);

  01f9a	8b 84 24 18 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  01fa1	0f ba f0 07	 btr	 eax, 7
  01fa5	89 84 24 18 02
	00 00		 mov	 DWORD PTR pcode$[rsp], eax
$LN162@z900_progr:
$LN78@z900_progr:

; 1139 :     }
; 1140 : #endif /* defined( _FEATURE_PER ) */
; 1141 : 
; 1142 : #if defined( FEATURE_BCMODE )
; 1143 :     /* For ECMODE, store extended interrupt information in PSA */
; 1144 :     if (ECMODE( &realregs->psw ))
; 1145 : #endif
; 1146 :     {
; 1147 :         PTT_PGM( "PGM ec", 0, 0, 0 );

  01fac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01fb3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01fb6	48 83 e0 20	 and	 rax, 32			; 00000020H
  01fba	48 85 c0	 test	 rax, rax
  01fbd	74 36		 je	 SHORT $LN188@z900_progr
  01fbf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01fc8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01fd1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196184
  01fd8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01fdd	45 33 c9	 xor	 r9d, r9d
  01fe0	45 33 c0	 xor	 r8d, r8d
  01fe3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196185
  01fea	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01fef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN188@z900_progr:
  01ff5	33 c0		 xor	 eax, eax
  01ff7	85 c0		 test	 eax, eax
  01ff9	75 b1		 jne	 SHORT $LN78@z900_progr

; 1148 : 
; 1149 :         /* Store the program interrupt code at PSA+X'8C' */
; 1150 :         psa->pgmint[0] = 0;

  01ffb	b8 01 00 00 00	 mov	 eax, 1
  02000	48 6b c0 00	 imul	 rax, rax, 0
  02004	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0200c	c6 84 01 8c 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+140], 0

; 1151 :         psa->pgmint[1] = ilc;

  02014	b8 01 00 00 00	 mov	 eax, 1
  02019	48 6b c0 01	 imul	 rax, rax, 1
  0201d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  02025	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR ilc$[rsp]
  0202d	88 94 01 8c 00
	00 00		 mov	 BYTE PTR [rcx+rax+140], dl

; 1152 : 
; 1153 :         STORE_HW( psa->pgmint + 2, pcode );

  02034	0f b7 8c 24 18
	02 00 00	 movzx	 ecx, WORD PTR pcode$[rsp]
  0203c	e8 00 00 00 00	 call	 _byteswap_ushort
  02041	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  02049	48 81 c1 8e 00
	00 00		 add	 rcx, 142		; 0000008eH
  02050	0f b7 d0	 movzx	 edx, ax
  02053	e8 00 00 00 00	 call	 store_hw_noswap

; 1154 : 
; 1155 :         /* Store the exception access identification at PSA+160 */
; 1156 :         if (0
; 1157 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1158 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1159 : 
; 1160 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1161 :             || code == PGM_ASCE_TYPE_EXCEPTION
; 1162 :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 1163 :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 1164 :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 1165 : #endif
; 1166 :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 1167 :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 1168 :             || code == PGM_ASTE_VALIDITY_EXCEPTION
; 1169 :             || code == PGM_ASTE_SEQUENCE_EXCEPTION
; 1170 :             || code == PGM_ASTE_INSTANCE_EXCEPTION
; 1171 :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 1172 : 
; 1173 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1174 :             || code == PGM_PROTECTION_EXCEPTION

  02058	33 c0		 xor	 eax, eax
  0205a	85 c0		 test	 eax, eax
  0205c	75 5b		 jne	 SHORT $LN190@z900_progr
  0205e	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  02063	74 54		 je	 SHORT $LN190@z900_progr
  02065	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  0206a	74 4d		 je	 SHORT $LN190@z900_progr
  0206c	83 7c 24 78 38	 cmp	 DWORD PTR code$[rsp], 56 ; 00000038H
  02071	74 46		 je	 SHORT $LN190@z900_progr
  02073	83 7c 24 78 39	 cmp	 DWORD PTR code$[rsp], 57 ; 00000039H
  02078	74 3f		 je	 SHORT $LN190@z900_progr
  0207a	83 7c 24 78 3a	 cmp	 DWORD PTR code$[rsp], 58 ; 0000003aH
  0207f	74 38		 je	 SHORT $LN190@z900_progr
  02081	83 7c 24 78 3b	 cmp	 DWORD PTR code$[rsp], 59 ; 0000003bH
  02086	74 31		 je	 SHORT $LN190@z900_progr
  02088	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  0208d	74 2a		 je	 SHORT $LN190@z900_progr
  0208f	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  02094	74 23		 je	 SHORT $LN190@z900_progr
  02096	83 7c 24 78 2b	 cmp	 DWORD PTR code$[rsp], 43 ; 0000002bH
  0209b	74 1c		 je	 SHORT $LN190@z900_progr
  0209d	83 7c 24 78 2c	 cmp	 DWORD PTR code$[rsp], 44 ; 0000002cH
  020a2	74 15		 je	 SHORT $LN190@z900_progr
  020a4	83 7c 24 78 2f	 cmp	 DWORD PTR code$[rsp], 47 ; 0000002fH
  020a9	74 0e		 je	 SHORT $LN190@z900_progr
  020ab	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  020b0	74 07		 je	 SHORT $LN190@z900_progr
  020b2	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  020b7	75 5e		 jne	 SHORT $LN189@z900_progr
$LN190@z900_progr:

; 1175 : #endif
; 1176 :         )
; 1177 :         {
; 1178 :             psa->excarid = regs->excarid;

  020b9	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  020c1	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020c9	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  020d0	88 88 a0 00 00
	00		 mov	 BYTE PTR [rax+160], cl

; 1179 :             // FIXME: this conditional will ALWAYS be true!!
; 1180 :             if (regs->TEA | TEA_MVPG)

  020d6	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  020de	48 8b 80 18 07
	00 00		 mov	 rax, QWORD PTR [rax+1816]
  020e5	48 83 c8 04	 or	 rax, 4
  020e9	48 85 c0	 test	 rax, rax
  020ec	74 1d		 je	 SHORT $LN191@z900_progr

; 1181 :                 psa->opndrid = regs->opndrid;

  020ee	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  020f6	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  020fe	0f b6 89 3f 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2111]
  02105	88 88 a2 00 00
	00		 mov	 BYTE PTR [rax+162], cl
$LN191@z900_progr:

; 1182 :             realregs->opndrid = 0;

  0210b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02110	c6 80 3f 08 00
	00 00		 mov	 BYTE PTR [rax+2111], 0
$LN189@z900_progr:

; 1183 :         }
; 1184 : 
; 1185 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1186 :         /* Store the translation exception address at PSA+168 */
; 1187 :         if (0
; 1188 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1189 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1190 :             || code == PGM_ASCE_TYPE_EXCEPTION
; 1191 :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 1192 :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 1193 :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 1194 : 
; 1195 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1196 :             || code == PGM_PROTECTION_EXCEPTION

  02117	33 c0		 xor	 eax, eax
  02119	85 c0		 test	 eax, eax
  0211b	75 31		 jne	 SHORT $LN193@z900_progr
  0211d	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  02122	74 2a		 je	 SHORT $LN193@z900_progr
  02124	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  02129	74 23		 je	 SHORT $LN193@z900_progr
  0212b	83 7c 24 78 38	 cmp	 DWORD PTR code$[rsp], 56 ; 00000038H
  02130	74 1c		 je	 SHORT $LN193@z900_progr
  02132	83 7c 24 78 39	 cmp	 DWORD PTR code$[rsp], 57 ; 00000039H
  02137	74 15		 je	 SHORT $LN193@z900_progr
  02139	83 7c 24 78 3a	 cmp	 DWORD PTR code$[rsp], 58 ; 0000003aH
  0213e	74 0e		 je	 SHORT $LN193@z900_progr
  02140	83 7c 24 78 3b	 cmp	 DWORD PTR code$[rsp], 59 ; 0000003bH
  02145	74 07		 je	 SHORT $LN193@z900_progr
  02147	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  0214c	75 2b		 jne	 SHORT $LN192@z900_progr
$LN193@z900_progr:

; 1197 : #endif
; 1198 :         )
; 1199 :         {
; 1200 :             STORE_DW( psa->TEA_G, regs->TEA );

  0214e	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02156	48 8b 88 18 07
	00 00		 mov	 rcx, QWORD PTR [rax+1816]
  0215d	e8 00 00 00 00	 call	 _byteswap_uint64
  02162	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0216a	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  02171	48 8b d0	 mov	 rdx, rax
  02174	e8 00 00 00 00	 call	 store_dw_noswap
$LN192@z900_progr:

; 1201 :         }
; 1202 : 
; 1203 :         /* For z, store translation exception address at PSA+172 */
; 1204 :         if (0
; 1205 :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 1206 :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 1207 :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 1208 :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 1209 :             || code == PGM_SPACE_SWITCH_EVENT
; 1210 :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 1211 :             || code == PGM_LFX_TRANSLATION_EXCEPTION
; 1212 :             || code == PGM_LSX_TRANSLATION_EXCEPTION
; 1213 :             || code == PGM_LSTE_SEQUENCE_EXCEPTION
; 1214 :             || code == PGM_EX_TRANSLATION_EXCEPTION

  02179	33 c0		 xor	 eax, eax
  0217b	85 c0		 test	 eax, eax
  0217d	75 46		 jne	 SHORT $LN195@z900_progr
  0217f	83 7c 24 78 20	 cmp	 DWORD PTR code$[rsp], 32 ; 00000020H
  02184	74 3f		 je	 SHORT $LN195@z900_progr
  02186	83 7c 24 78 21	 cmp	 DWORD PTR code$[rsp], 33 ; 00000021H
  0218b	74 38		 je	 SHORT $LN195@z900_progr
  0218d	83 7c 24 78 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  02192	74 31		 je	 SHORT $LN195@z900_progr
  02194	83 7c 24 78 25	 cmp	 DWORD PTR code$[rsp], 37 ; 00000025H
  02199	74 2a		 je	 SHORT $LN195@z900_progr
  0219b	83 7c 24 78 1c	 cmp	 DWORD PTR code$[rsp], 28
  021a0	74 23		 je	 SHORT $LN195@z900_progr
  021a2	83 7c 24 78 22	 cmp	 DWORD PTR code$[rsp], 34 ; 00000022H
  021a7	74 1c		 je	 SHORT $LN195@z900_progr
  021a9	83 7c 24 78 26	 cmp	 DWORD PTR code$[rsp], 38 ; 00000026H
  021ae	74 15		 je	 SHORT $LN195@z900_progr
  021b0	83 7c 24 78 27	 cmp	 DWORD PTR code$[rsp], 39 ; 00000027H
  021b5	74 0e		 je	 SHORT $LN195@z900_progr
  021b7	83 7c 24 78 2e	 cmp	 DWORD PTR code$[rsp], 46 ; 0000002eH
  021bc	74 07		 je	 SHORT $LN195@z900_progr
  021be	83 7c 24 78 23	 cmp	 DWORD PTR code$[rsp], 35 ; 00000023H
  021c3	75 29		 jne	 SHORT $LN194@z900_progr
$LN195@z900_progr:

; 1215 :         )
; 1216 :         {
; 1217 :             STORE_FW( psa->TEA_L, regs->TEA );

  021c5	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021cd	8b 88 18 07 00
	00		 mov	 ecx, DWORD PTR [rax+1816]
  021d3	e8 00 00 00 00	 call	 _byteswap_ulong
  021d8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  021e0	48 81 c1 ac 00
	00 00		 add	 rcx, 172		; 000000acH
  021e7	8b d0		 mov	 edx, eax
  021e9	e8 00 00 00 00	 call	 store_fw_noswap
$LN194@z900_progr:

; 1218 :         }
; 1219 : 
; 1220 : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1221 : 
; 1222 :         /* For 370/390, store translation exception address at PSA+144 */
; 1223 :         if (0
; 1224 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1225 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1226 :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 1227 :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 1228 :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 1229 :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 1230 :             || code == PGM_SPACE_SWITCH_EVENT
; 1231 :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 1232 :             || code == PGM_EX_TRANSLATION_EXCEPTION
; 1233 : 
; 1234 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1235 :             || code == PGM_PROTECTION_EXCEPTION
; 1236 : #endif
; 1237 :         )
; 1238 :         {
; 1239 :             STORE_FW( psa->tea, regs->TEA );
; 1240 :         }
; 1241 : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1242 : 
; 1243 :         realregs->TEA = 0;

  021ee	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  021f3	48 c7 80 18 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1816], 0

; 1244 : 
; 1245 :         /* Store Data exception code in PSA */
; 1246 :         if (code == PGM_DATA_EXCEPTION)

  021fe	83 7c 24 78 07	 cmp	 DWORD PTR code$[rsp], 7
  02203	0f 85 a4 00 00
	00		 jne	 $LN196@z900_progr

; 1247 :         {
; 1248 :             STORE_FW( psa->DXC, regs->dxc );

  02209	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02211	8b 88 08 07 00
	00		 mov	 ecx, DWORD PTR [rax+1800]
  02217	e8 00 00 00 00	 call	 _byteswap_ulong
  0221c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  02224	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  0222b	8b d0		 mov	 edx, eax
  0222d	e8 00 00 00 00	 call	 store_fw_noswap

; 1249 : 
; 1250 : #if defined( FEATURE_BASIC_FP_EXTENSIONS )
; 1251 :             /* Load data exception code into FPC register byte 2 */
; 1252 :             if (regs->CR(0) & CR0_AFP)

  02232	b8 08 00 00 00	 mov	 eax, 8
  02237	48 6b c0 01	 imul	 rax, rax, 1
  0223b	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02243	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  0224b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  02251	48 85 c0	 test	 rax, rax
  02254	74 57		 je	 SHORT $LN197@z900_progr

; 1253 :             {
; 1254 :                 regs->fpc &= ~(FPC_DXC);

  02256	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0225e	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  02264	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  02269	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02271	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1255 :                 regs->fpc |= ((regs->dxc << 8)) & FPC_DXC;

  02277	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0227f	8b 80 08 07 00
	00		 mov	 eax, DWORD PTR [rax+1800]
  02285	c1 e0 08	 shl	 eax, 8
  02288	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0228d	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  02295	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  0229b	0b c8		 or	 ecx, eax
  0229d	8b c1		 mov	 eax, ecx
  0229f	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  022a7	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN197@z900_progr:
$LN196@z900_progr:

; 1256 :             }
; 1257 : #endif
; 1258 :         }
; 1259 : 
; 1260 :         /* Store the monitor class and event code */
; 1261 :         if (code == PGM_MONITOR_EVENT)

  022ad	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  022b2	75 4f		 jne	 SHORT $LN198@z900_progr

; 1262 :         {
; 1263 :             STORE_HW( psa->monclass, regs->monclass );

  022b4	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022bc	0f b7 88 3a 08
	00 00		 movzx	 ecx, WORD PTR [rax+2106]
  022c3	e8 00 00 00 00	 call	 _byteswap_ushort
  022c8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  022d0	48 81 c1 94 00
	00 00		 add	 rcx, 148		; 00000094H
  022d7	0f b7 d0	 movzx	 edx, ax
  022da	e8 00 00 00 00	 call	 store_hw_noswap

; 1264 : 
; 1265 :             /* Store the monitor code word at PSA+156 */
; 1266 :             /* or doubleword at PSA+176               */
; 1267 :             /* ISW20090110-1 ZSIEMCFIX                */
; 1268 :             /* In the event of a z/Arch guest being   */
; 1269 :             /* intercepted during a succesful Monitor */
; 1270 :             /* call, the monitor code is not stored   */
; 1271 :             /* at psa->moncode (which is beyond sie2bk->ip */
; 1272 :             /* but rather at the same location as an  */
; 1273 :             /* I/O interrupt would store the SSID     */
; 1274 :             /*    zmoncode points to this location    */
; 1275 :             /*  **** FIXME **** FIXME  *** FIXME ***  */
; 1276 :             /* ---- The determination of the location */
; 1277 :             /*      of the z/Sie Intercept moncode    */
; 1278 :             /*      should be made more flexible      */
; 1279 :             /*      and should be put somewhere in    */
; 1280 :             /*      esa390.h                          */
; 1281 :             /*  **** FIXME **** FIXME  *** FIXME ***  */
; 1282 : 
; 1283 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1284 :             STORE_DW( zmoncode, regs->MONCODE );

  022df	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  022e7	48 8b 88 10 07
	00 00		 mov	 rcx, QWORD PTR [rax+1808]
  022ee	e8 00 00 00 00	 call	 _byteswap_uint64
  022f3	48 8b d0	 mov	 rdx, rax
  022f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR zmoncode$[rsp]
  022fe	e8 00 00 00 00	 call	 store_dw_noswap
$LN198@z900_progr:

; 1285 : #else
; 1286 :             STORE_W( psa->moncode, regs->MONCODE );
; 1287 : #endif
; 1288 :         }
; 1289 : 
; 1290 : #if defined( FEATURE_PER3 )
; 1291 :         /* Store the breaking event address register in the PSA */
; 1292 :         STORE_W( psa->bea, regs->bear );

  02303	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0230b	48 8b 88 18 02
	00 00		 mov	 rcx, QWORD PTR [rax+536]
  02312	e8 00 00 00 00	 call	 _byteswap_uint64
  02317	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0231f	48 81 c1 10 01
	00 00		 add	 rcx, 272		; 00000110H
  02326	48 8b d0	 mov	 rdx, rax
  02329	e8 00 00 00 00	 call	 store_dw_noswap
$LN81@z900_progr:

; 1293 :         PTT_PGM( "PGM bear", regs->bear, 0, 0 );

  0232e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02335	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02338	48 83 e0 20	 and	 rax, 32			; 00000020H
  0233c	48 85 c0	 test	 rax, rax
  0233f	74 42		 je	 SHORT $LN199@z900_progr
  02341	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0234a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02353	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196197
  0235a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0235f	45 33 c9	 xor	 r9d, r9d
  02362	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0236a	4c 8b 80 18 02
	00 00		 mov	 r8, QWORD PTR [rax+536]
  02371	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196198
  02378	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0237d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN199@z900_progr:
  02383	33 c0		 xor	 eax, eax
  02385	85 c0		 test	 eax, eax
  02387	75 a5		 jne	 SHORT $LN81@z900_progr

; 1294 : #endif
; 1295 : 
; 1296 :     } /* end if(ECMODE) */
; 1297 : 
; 1298 : #if defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 1299 :     realregs->hostint = 0;

  02389	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0238e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  02394	83 e0 bf	 and	 eax, -65		; ffffffbfH
  02397	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0239c	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1300 : #endif
; 1301 : 
; 1302 :     /* Normal (non-intercepted) program interrupt? */
; 1303 : #if defined( _FEATURE_SIE )
; 1304 :     if (!intercept)

  023a2	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  023a7	85 c0		 test	 eax, eax
  023a9	0f 85 36 04 00
	00		 jne	 $LN200@z900_progr

; 1305 : #endif
; 1306 :     {
; 1307 :         PSW pgmold, pgmnew;
; 1308 :         int pgmintloop = 0;

  023af	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR pgmintloop$3[rsp], 0

; 1309 :         int detect_pgmintloop = FACILITY_ENABLED( HERC_DETECT_PGMINTLOOP, realregs );

  023ba	b8 01 00 00 00	 mov	 eax, 1
  023bf	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  023c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  023c8	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  023d0	83 e0 40	 and	 eax, 64			; 00000040H
  023d3	89 84 24 98 00
	00 00		 mov	 DWORD PTR detect_pgmintloop$2[rsp], eax

; 1310 : 
; 1311 :         /* Store current PSW at PSA+X'28' or PSA+X'150' for ESAME */
; 1312 :         ARCH_DEP( store_psw )( realregs, psa->pgmold );

  023da	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  023e2	48 05 50 01 00
	00		 add	 rax, 336		; 00000150H
  023e8	48 8b d0	 mov	 rdx, rax
  023eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  023f0	e8 00 00 00 00	 call	 z900_store_psw

; 1313 : 
; 1314 :         /* Save program old psw */
; 1315 :         if (detect_pgmintloop)

  023f5	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR detect_pgmintloop$2[rsp], 0
  023fd	74 35		 je	 SHORT $LN201@z900_progr

; 1316 :         {
; 1317 :             memcpy( &pgmold, &realregs->psw, sizeof( PSW ));

  023ff	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR pgmold$7[rsp]
  02407	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0240c	48 8b f8	 mov	 rdi, rax
  0240f	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  02413	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  02418	f3 a4		 rep movsb

; 1318 :             pgmold.cc      = 0;

  0241a	c6 84 24 34 01
	00 00 00	 mov	 BYTE PTR pgmold$7[rsp+4], 0

; 1319 :             pgmold.intcode = 0;

  02422	33 c0		 xor	 eax, eax
  02424	66 89 84 24 50
	01 00 00	 mov	 WORD PTR pgmold$7[rsp+32], ax

; 1320 :             pgmold.ilc     = 0;

  0242c	c6 84 24 52 01
	00 00 00	 mov	 BYTE PTR pgmold$7[rsp+34], 0
$LN201@z900_progr:

; 1321 :         }
; 1322 : 
; 1323 :         /* Load new PSW from PSA+X'68' or PSA+X'1D0' for ESAME */
; 1324 :         if ((code = ARCH_DEP( load_psw )( realregs, psa->pgmnew )))

  02434	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  0243c	48 05 d0 01 00
	00		 add	 rax, 464		; 000001d0H
  02442	48 8b d0	 mov	 rdx, rax
  02445	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0244a	e8 00 00 00 00	 call	 z900_load_psw
  0244f	89 44 24 78	 mov	 DWORD PTR code$[rsp], eax
  02453	83 7c 24 78 00	 cmp	 DWORD PTR code$[rsp], 0
  02458	0f 84 f2 00 00
	00		 je	 $LN202@z900_progr

; 1325 :         {
; 1326 :             /* The load psw failed */
; 1327 : #if defined( _FEATURE_SIE )
; 1328 :             if (SIE_MODE( realregs ))

  0245e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02463	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  02469	d1 e8		 shr	 eax, 1
  0246b	83 e0 01	 and	 eax, 1
  0246e	85 c0		 test	 eax, eax
  02470	0f 84 c7 00 00
	00		 je	 $LN204@z900_progr
$LN84@z900_progr:

; 1329 :             {
; 1330 :                 PTT_PGM( "*PGM *lpsw", code, 0, 0 );

  02476	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0247d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02480	48 83 e0 20	 and	 rax, 32			; 00000020H
  02484	48 85 c0	 test	 rax, rax
  02487	74 3b		 je	 SHORT $LN206@z900_progr
  02489	48 63 44 24 78	 movsxd	 rax, DWORD PTR code$[rsp]
  0248e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02497	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  024a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196206
  024a7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  024ac	45 33 c9	 xor	 r9d, r9d
  024af	4c 8b c0	 mov	 r8, rax
  024b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196207
  024b9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  024be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN206@z900_progr:
  024c4	33 c0		 xor	 eax, eax
  024c6	85 c0		 test	 eax, eax
  024c8	75 ac		 jne	 SHORT $LN84@z900_progr
$LN87@z900_progr:

; 1331 :                 PTT_PGM( "PGM progjmp", pcode, 0, 0 );

  024ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  024d1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  024d4	48 83 e0 20	 and	 rax, 32			; 00000020H
  024d8	48 85 c0	 test	 rax, rax
  024db	74 3e		 je	 SHORT $LN207@z900_progr
  024dd	48 63 84 24 18
	02 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  024e5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  024ee	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  024f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196209
  024fe	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02503	45 33 c9	 xor	 r9d, r9d
  02506	4c 8b c0	 mov	 r8, rax
  02509	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196210
  02510	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02515	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN207@z900_progr:
  0251b	33 c0		 xor	 eax, eax
  0251d	85 c0		 test	 eax, eax
  0251f	75 a9		 jne	 SHORT $LN87@z900_progr

; 1332 :                 longjmp( realregs->progjmp, pcode );

  02521	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02526	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0252c	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  02533	48 8b c8	 mov	 rcx, rax
  02536	e8 00 00 00 00	 call	 longjmp

; 1333 :             }

  0253b	eb 0e		 jmp	 SHORT $LN205@z900_progr
$LN204@z900_progr:

; 1334 :             else
; 1335 : #endif
; 1336 :             {
; 1337 :                 /* Invalid pgmnew: ==> program interrupt loop */
; 1338 :                 pgmintloop = detect_pgmintloop;

  0253d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR detect_pgmintloop$2[rsp]
  02544	89 84 24 9c 00
	00 00		 mov	 DWORD PTR pgmintloop$3[rsp], eax
$LN205@z900_progr:

; 1339 :             }
; 1340 :         }

  0254b	e9 87 00 00 00	 jmp	 $LN203@z900_progr
$LN202@z900_progr:

; 1341 :         else if (detect_pgmintloop)

  02550	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR detect_pgmintloop$2[rsp], 0
  02558	74 7d		 je	 SHORT $LN208@z900_progr

; 1342 :         {
; 1343 :             /* Save program new psw */
; 1344 :             memcpy( &pgmnew, &realregs->psw, sizeof( PSW ));

  0255a	48 8d 84 24 58
	01 00 00	 lea	 rax, QWORD PTR pgmnew$8[rsp]
  02562	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  02567	48 8b f8	 mov	 rdi, rax
  0256a	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  0256e	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  02573	f3 a4		 rep movsb

; 1345 :             pgmnew.cc      = 0;

  02575	c6 84 24 5c 01
	00 00 00	 mov	 BYTE PTR pgmnew$8[rsp+4], 0

; 1346 :             pgmnew.intcode = 0;

  0257d	33 c0		 xor	 eax, eax
  0257f	66 89 84 24 78
	01 00 00	 mov	 WORD PTR pgmnew$8[rsp+32], ax

; 1347 :             pgmnew.ilc     = 0;

  02587	c6 84 24 7a 01
	00 00 00	 mov	 BYTE PTR pgmnew$8[rsp+34], 0

; 1348 : 
; 1349 :             /* Adjust pgmold instruction address */
; 1350 :             pgmold.ia.D -= ilc;

  0258f	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  02597	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pgmold$7[rsp+16]
  0259f	48 2b c8	 sub	 rcx, rax
  025a2	48 8b c1	 mov	 rax, rcx
  025a5	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR pgmold$7[rsp+16], rax

; 1351 : 
; 1352 :             /* Check for program interrupt loop (old==new) */
; 1353 :             if (memcmp( &pgmold, &pgmnew, sizeof( PSW )) == 0)

  025ad	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  025b3	48 8d 94 24 58
	01 00 00	 lea	 rdx, QWORD PTR pgmnew$8[rsp]
  025bb	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR pgmold$7[rsp]
  025c3	e8 00 00 00 00	 call	 memcmp
  025c8	85 c0		 test	 eax, eax
  025ca	75 0b		 jne	 SHORT $LN209@z900_progr

; 1354 :                 pgmintloop = 1;

  025cc	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR pgmintloop$3[rsp], 1
$LN209@z900_progr:
$LN208@z900_progr:
$LN203@z900_progr:

; 1355 :         }
; 1356 : 
; 1357 :         if (pgmintloop)

  025d7	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR pgmintloop$3[rsp], 0
  025df	0f 84 41 01 00
	00		 je	 $LN210@z900_progr

; 1358 :         {
; 1359 :             char buf[64];
; 1360 :             STR_PSW( realregs, buf );

  025e5	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  025eb	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR buf$10[rsp]
  025f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  025f8	e8 00 00 00 00	 call	 str_psw

; 1361 : 
; 1362 :             if (regs->insttrace && sysblk.traceFILE)

  025fd	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  02605	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0260b	c1 e8 0f	 shr	 eax, 15
  0260e	83 e0 01	 and	 eax, 1
  02611	85 c0		 test	 eax, eax
  02613	74 24		 je	 SHORT $LN211@z900_progr
  02615	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0261c	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  02624	74 13		 je	 SHORT $LN211@z900_progr

; 1363 :                 tf_0803( realregs, buf );

  02626	48 8d 94 24 a0
	01 00 00	 lea	 rdx, QWORD PTR buf$10[rsp]
  0262e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  02633	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0803
$LN211@z900_progr:

; 1364 : 
; 1365 :             // "Processor %s%02X: program interrupt loop PSW %s"
; 1366 :             WRMSG( HHC00803, "I", PTYPSTR( realregs->cpuad ),

  02639	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0263e	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  02645	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv1421[rsp], eax
  0264c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  02651	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  02658	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0265f	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  02667	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0266d	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv1423[rsp], rax
  02675	b9 01 00 00 00	 mov	 ecx, 1
  0267a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02680	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR buf$10[rsp]
  02688	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0268d	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv1421[rsp]
  02694	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02698	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv1423[rsp]
  026a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  026a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196215
  026ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  026b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196216
  026b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  026bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  026c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  026c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196217
  026cf	ba 57 05 00 00	 mov	 edx, 1367		; 00000557H
  026d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196218
  026db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1367 :                 realregs->cpuad, buf );
; 1368 : 
; 1369 :             OBTAIN_INTLOCK( realregs );

  026e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196219
  026e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  026ed	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1370 :             {
; 1371 :                 realregs->cpustate = CPUSTATE_STOPPING;

  026f2	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  026f7	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN90@z900_progr:

; 1372 :                 ON_IC_INTERRUPT( realregs );

  026fb	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02700	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  02703	0f ba e8 1f	 bts	 eax, 31
  02707	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0270c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  0270f	33 c0		 xor	 eax, eax
  02711	85 c0		 test	 eax, eax
  02713	75 e6		 jne	 SHORT $LN90@z900_progr

; 1373 :             }
; 1374 :             RELEASE_INTLOCK( realregs );

  02715	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196220
  0271c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  02721	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN210@z900_progr:
$LN93@z900_progr:

; 1375 :         }
; 1376 : 
; 1377 :         /*-----------------------------------------------------------*/
; 1378 :         /*  Normal non-intercepted program interrupt: return to      */
; 1379 :         /*  either the run_cpu or run_sie loop and start executing   */
; 1380 :         /*  instructions again, but at Program New PSW instead.      */
; 1381 :         /*-----------------------------------------------------------*/
; 1382 : 
; 1383 :         PTT_PGM( "PGM !icept", intercept, 0, 0 );

  02726	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0272d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02730	48 83 e0 20	 and	 rax, 32			; 00000020H
  02734	48 85 c0	 test	 rax, rax
  02737	74 3b		 je	 SHORT $LN212@z900_progr
  02739	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  0273e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02747	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02750	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196222
  02757	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0275c	45 33 c9	 xor	 r9d, r9d
  0275f	44 8b c0	 mov	 r8d, eax
  02762	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196223
  02769	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0276e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN212@z900_progr:
  02774	33 c0		 xor	 eax, eax
  02776	85 c0		 test	 eax, eax
  02778	75 ac		 jne	 SHORT $LN93@z900_progr
$LN96@z900_progr:

; 1384 :         PTT_PGM( "PGM progjmp", SIE_NO_INTERCEPT, 0, 0 );

  0277a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02781	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02784	48 83 e0 20	 and	 rax, 32			; 00000020H
  02788	48 85 c0	 test	 rax, rax
  0278b	74 3a		 je	 SHORT $LN213@z900_progr
  0278d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02796	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0279f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG196225
  027a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  027ab	45 33 c9	 xor	 r9d, r9d
  027ae	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  027b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196226
  027bc	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  027c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN213@z900_progr:
  027c7	33 c0		 xor	 eax, eax
  027c9	85 c0		 test	 eax, eax
  027cb	75 ad		 jne	 SHORT $LN96@z900_progr

; 1385 :         longjmp( realregs->progjmp, SIE_NO_INTERCEPT );

  027cd	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  027d2	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  027d8	ba ff ff ff ff	 mov	 edx, -1
  027dd	48 8b c8	 mov	 rcx, rax
  027e0	e8 00 00 00 00	 call	 longjmp
$LN200@z900_progr:
$LN99@z900_progr:

; 1386 :     }
; 1387 : 
; 1388 : #if defined( _FEATURE_SIE )
; 1389 :     /*---------------------------------------------------------------*/
; 1390 :     /*  We're in SIE mode and SIE host MUST intercept this program   */
; 1391 :     /*  interrupt. Jump back to the run_sie loop with the interrupt  */
; 1392 :     /*  code so it can break out of its instruction execution loop   */
; 1393 :     /*  and exit from run_sie back to sie_exit so the interrupt can  */
; 1394 :     /*  be passed on to the SIE host for handling.                   */
; 1395 :     /*---------------------------------------------------------------*/
; 1396 : 
; 1397 :     PTT_PGM( "PGM icept", intercept, 0, 0 );

  027e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  027ec	48 8b 00	 mov	 rax, QWORD PTR [rax]
  027ef	48 83 e0 20	 and	 rax, 32			; 00000020H
  027f3	48 85 c0	 test	 rax, rax
  027f6	74 3b		 je	 SHORT $LN214@z900_progr
  027f8	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  027fd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02806	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0280f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196228
  02816	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0281b	45 33 c9	 xor	 r9d, r9d
  0281e	44 8b c0	 mov	 r8d, eax
  02821	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196229
  02828	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0282d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN214@z900_progr:
  02833	33 c0		 xor	 eax, eax
  02835	85 c0		 test	 eax, eax
  02837	75 ac		 jne	 SHORT $LN99@z900_progr
$LN102@z900_progr:

; 1398 :     PTT_PGM( "PGM progjmp", pcode, 0, 0 );

  02839	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02840	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02843	48 83 e0 20	 and	 rax, 32			; 00000020H
  02847	48 85 c0	 test	 rax, rax
  0284a	74 3e		 je	 SHORT $LN215@z900_progr
  0284c	48 63 84 24 18
	02 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  02854	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0285d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02866	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196231
  0286d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02872	45 33 c9	 xor	 r9d, r9d
  02875	4c 8b c0	 mov	 r8, rax
  02878	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196232
  0287f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02884	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN215@z900_progr:
  0288a	33 c0		 xor	 eax, eax
  0288c	85 c0		 test	 eax, eax
  0288e	75 a9		 jne	 SHORT $LN102@z900_progr

; 1399 :     longjmp( realregs->progjmp, pcode );

  02890	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02895	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0289b	8b 94 24 18 02
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  028a2	48 8b c8	 mov	 rcx, rax
  028a5	e8 00 00 00 00	 call	 longjmp
$LN216@z900_progr:

; 1400 : #endif
; 1401 : 
; 1402 : } /* end function ARCH_DEP( program_interrupt ) */

  028aa	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  028b2	48 33 cc	 xor	 rcx, rsp
  028b5	e8 00 00 00 00	 call	 __security_check_cookie
  028ba	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  028c1	5f		 pop	 rdi
  028c2	5e		 pop	 rsi
  028c3	c3		 ret	 0
z900_program_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
realregs$ = 112
code$ = 120
intercept$ = 124
ilc$ = 128
perc$1 = 132
psa$ = 136
sie_ilc$ = 144
tv365 = 148
detect_pgmintloop$2 = 152
pgmintloop$3 = 156
tv250 = 160
tv252 = 164
tv254 = 168
tv268 = 172
tv276 = 176
tv282 = 180
tv284 = 184
tv721 = 188
tv233 = 192
tv241 = 196
px$ = 200
tv1350 = 208
tv1026 = 212
tv1029 = 216
tv1033 = 220
tv134 = 224
p$4 = 232
tv518 = 240
tv1035 = 248
tv1352 = 256
pgmold$5 = 264
pgmnew$6 = 304
percname$7 = 344
buf$8 = 384
__$ArrayPad$ = 448
regs$ = 496
pcode$ = 504
s390_program_interrupt PROC

; 635  : {

$LN219:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec d8 01
	00 00		 sub	 rsp, 472		; 000001d8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 636  : PSA    *psa;                            /* -> Prefixed storage area  */
; 637  : REGS   *realregs;                       /* True regs structure       */
; 638  : RADR    px;                             /* host real address of pfx  */
; 639  : int     code;                           /* pcode without PER ind.    */
; 640  : int     ilc;                            /* instruction length        */
; 641  : 
; 642  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 643  :                                         /* FIXME : SEE ISW20090110-1 */
; 644  : void   *zmoncode = NULL;                /* mon call SIE intercept;
; 645  :                                            special reloc for z/Arch  */
; 646  :                                         /* FIXME : zmoncode not being
; 647  :                                            initialized here raises a
; 648  :                                            potentially non-initialized
; 649  :                                            warning in GCC.. can't find
; 650  :                                            why. ISW 2009/02/04       */
; 651  : #endif
; 652  : #if defined( FEATURE_SIE )
; 653  : int     sie_ilc=0;                      /* SIE instruction length    */

  00024	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sie_ilc$[rsp], 0

; 654  : #endif
; 655  : #if defined( _FEATURE_SIE )
; 656  : bool    intercept;                      /* False for virtual pgmint  */
; 657  :                                         /* (True for host interrupt?)*/
; 658  : #endif
; 659  : 
; 660  :     /* If called with ghost registers (ie from hercules command
; 661  :        then ignore all interrupt handling and report the error
; 662  :        to the caller */
; 663  :     if (regs->ghostregs)

  0002f	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003d	c1 e8 0d	 shr	 eax, 13
  00040	83 e0 01	 and	 eax, 1
  00043	85 c0		 test	 eax, eax
  00045	74 1d		 je	 SHORT $LN85@s390_progr

; 664  :         longjmp( regs->progjmp, pcode );

  00047	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00055	8b 94 24 f8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  0005c	48 8b c8	 mov	 rcx, rax
  0005f	e8 00 00 00 00	 call	 longjmp
$LN85@s390_progr:
$LN4@s390_progr:

; 665  : 
; 666  :     PTT_PGM("PGM", pcode, regs->TEA, regs->psw.IA );

  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 83 e0 20	 and	 rax, 32			; 00000020H
  00072	48 85 c0	 test	 rax, rax
  00075	74 56		 je	 SHORT $LN86@s390_progr
  00077	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00085	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  00093	48 63 94 24 f8
	01 00 00	 movsxd	 rdx, DWORD PTR pcode$[rsp]
  0009b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181676
  000b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b5	44 8b c9	 mov	 r9d, ecx
  000b8	4c 8b c2	 mov	 r8, rdx
  000bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181677
  000c2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN86@s390_progr:
  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 91		 jne	 SHORT $LN4@s390_progr

; 667  : 
; 668  :     /* program_interrupt() may be called with a shadow copy of the
; 669  :        regs structure, realregs is the pointer to the real structure
; 670  :        which must be used when loading/storing the psw, or backing up
; 671  :        the instruction address in case of nullification
; 672  :     */
; 673  : #if defined( _FEATURE_SIE )
; 674  :         realregs = SIE_MODE( regs )

  000d3	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000db	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e1	d1 e8		 shr	 eax, 1
  000e3	83 e0 01	 and	 eax, 1
  000e6	85 c0		 test	 eax, eax
  000e8	74 2f		 je	 SHORT $LN189@s390_progr
  000ea	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f2	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000f9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00100	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00108	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0010f	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv134[rsp], rax
  00117	eb 2d		 jmp	 SHORT $LN190@s390_progr
$LN189@s390_progr:
  00119	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00121	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00128	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00137	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0013e	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv134[rsp], rax
$LN190@s390_progr:
  00146	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv134[rsp]
  0014e	48 89 44 24 70	 mov	 QWORD PTR realregs$[rsp], rax
$LN7@s390_progr:

; 675  :                  ? GUEST( sysblk.regs[ regs->cpuad ])
; 676  :                  : HOST(  sysblk.regs[ regs->cpuad ]);
; 677  : #else
; 678  :     realregs = HOST( sysblk.regs[ regs->cpuad ]);
; 679  : #endif
; 680  : 
; 681  :     PTT_PGM( "PGM (r)h,g,a", realregs->host, realregs->guest, realregs->sie_active );

  00153	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0015a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0015d	48 83 e0 20	 and	 rax, 32			; 00000020H
  00161	48 85 c0	 test	 rax, rax
  00164	74 68		 je	 SHORT $LN87@s390_progr
  00166	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0016b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00171	83 e0 01	 and	 eax, 1
  00174	8b c0		 mov	 eax, eax
  00176	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0017b	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00181	c1 e9 08	 shr	 ecx, 8
  00184	83 e1 01	 and	 ecx, 1
  00187	8b c9		 mov	 ecx, ecx
  00189	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  0018e	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  00194	c1 ea 07	 shr	 edx, 7
  00197	83 e2 01	 and	 edx, 1
  0019a	8b d2		 mov	 edx, edx
  0019c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181679
  001b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b6	44 8b c9	 mov	 r9d, ecx
  001b9	44 8b c2	 mov	 r8d, edx
  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181680
  001c3	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN87@s390_progr:
  001ce	33 c0		 xor	 eax, eax
  001d0	85 c0		 test	 eax, eax
  001d2	0f 85 7b ff ff
	ff		 jne	 $LN7@s390_progr

; 682  : 
; 683  :     /* Prevent machine check when in (almost) interrupt loop */
; 684  :     realregs->instcount++;

  001d8	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  001dd	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  001e3	ff c0		 inc	 eax
  001e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  001ea	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 685  :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  001f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f7	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  001fd	ba 01 00 00 00	 mov	 edx, 1
  00202	48 8b c8	 mov	 rcx, rax
  00205	e8 00 00 00 00	 call	 atomic_update64

; 686  : 
; 687  :     /* Release any locks */
; 688  :     if (IS_INTLOCK_HELD( realregs ))

  0020a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00211	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00218	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0021d	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00224	3b c1		 cmp	 eax, ecx
  00226	75 11		 jne	 SHORT $LN88@s390_progr

; 689  :         RELEASE_INTLOCK( realregs );

  00228	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181682
  0022f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00234	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN88@s390_progr:

; 690  : 
; 691  :     /* Unlock the main storage lock if held */
; 692  :     if (sysblk.mainowner == realregs->cpuad)

  00239	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00240	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00247	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0024c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00253	3b c1		 cmp	 eax, ecx
  00255	75 61		 jne	 SHORT $LN89@s390_progr
$LN10@s390_progr:

; 693  :         RELEASE_MAINLOCK_UNCONDITIONAL( realregs );

  00257	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0025c	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00260	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  00267	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0026c	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00273	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0027a	3b c1		 cmp	 eax, ecx
  0027c	75 34		 jne	 SHORT $LN90@s390_progr
  0027e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00283	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00287	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  0028c	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  00293	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00298	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0029c	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  002a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181685
  002a9	48 8b c8	 mov	 rcx, rax
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN90@s390_progr:
  002b2	33 c0		 xor	 eax, eax
  002b4	85 c0		 test	 eax, eax
  002b6	75 9f		 jne	 SHORT $LN10@s390_progr
$LN89@s390_progr:
$LN13@s390_progr:

; 694  : 
; 695  :     /* Ensure psw.IA is set and aia invalidated */
; 696  :     INVALIDATE_AIA(realregs);

  002b8	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002bd	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  002c5	74 4f		 je	 SHORT $LN91@s390_progr
  002c7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002cc	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  002d2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  002d7	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  002dc	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  002e3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002e7	48 2b ca	 sub	 rcx, rdx
  002ea	48 03 c1	 add	 rax, rcx
  002ed	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  002f2	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  002f8	48 23 c1	 and	 rax, rcx
  002fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00300	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00306	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0030b	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN91@s390_progr:
  00316	33 c0		 xor	 eax, eax
  00318	85 c0		 test	 eax, eax
  0031a	75 9c		 jne	 SHORT $LN13@s390_progr

; 697  : 
; 698  : #if defined( FEATURE_SIE )
; 699  :     if (realregs->sie_active)

  0031c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00321	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00327	83 e0 01	 and	 eax, 1
  0032a	85 c0		 test	 eax, eax
  0032c	74 11		 je	 SHORT $LN92@s390_progr

; 700  :         ARCH_DEP( invalidate_guest_aia )( GUEST( realregs ));

  0032e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00333	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  0033a	e8 00 00 00 00	 call	 s390_invalidate_guest_aia
$LN92@s390_progr:

; 701  : #endif
; 702  : 
; 703  :     /* Fix PSW and get instruction length (ilc) */
; 704  :     ilc = ARCH_DEP( fix_program_interrupt_PSW )( realregs );

  0033f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00344	e8 00 00 00 00	 call	 s390_fix_program_interrupt_PSW
  00349	89 84 24 80 00
	00 00		 mov	 DWORD PTR ilc$[rsp], eax
$LN16@s390_progr:

; 705  : 
; 706  :     PTT_PGM( "PGM ilc", 0, 0, ilc );

  00350	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00357	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0035a	48 83 e0 20	 and	 rax, 32			; 00000020H
  0035e	48 85 c0	 test	 rax, rax
  00361	74 3a		 je	 SHORT $LN93@s390_progr
  00363	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0036b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00374	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00379	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181689
  00380	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00385	45 33 c9	 xor	 r9d, r9d
  00388	45 33 c0	 xor	 r8d, r8d
  0038b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181690
  00392	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN93@s390_progr:
  0039d	33 c0		 xor	 eax, eax
  0039f	85 c0		 test	 eax, eax
  003a1	75 ad		 jne	 SHORT $LN16@s390_progr

; 707  : 
; 708  : #if defined( FEATURE_SIE )
; 709  :     if (realregs->sie_active)

  003a3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  003a8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003ae	83 e0 01	 and	 eax, 1
  003b1	85 c0		 test	 eax, eax
  003b3	0f 84 63 02 00
	00		 je	 $LN94@s390_progr

; 710  :     {
; 711  :         sie_ilc = GUEST( realregs )->psw.zeroilc ? 0 : REAL_ILC( GUEST( realregs ));

  003b9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  003be	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003c5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003cb	c1 e8 02	 shr	 eax, 2
  003ce	83 e0 01	 and	 eax, 1
  003d1	85 c0		 test	 eax, eax
  003d3	74 10		 je	 SHORT $LN201@s390_progr
  003d5	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv254[rsp], 0
  003e0	e9 c8 00 00 00	 jmp	 $LN202@s390_progr
$LN201@s390_progr:
  003e5	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  003ea	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  003f1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003f7	83 e0 01	 and	 eax, 1
  003fa	85 c0		 test	 eax, eax
  003fc	75 0d		 jne	 SHORT $LN191@s390_progr
  003fe	c7 84 24 c0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv233[rsp], 1
  00409	eb 0b		 jmp	 SHORT $LN192@s390_progr
$LN191@s390_progr:
  0040b	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv233[rsp], 0
$LN192@s390_progr:
  00416	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR tv233[rsp], 0
  0041e	74 0d		 je	 SHORT $LN195@s390_progr
  00420	c7 84 24 c4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv241[rsp], 1
  0042b	eb 0b		 jmp	 SHORT $LN196@s390_progr
$LN195@s390_progr:
  0042d	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv241[rsp], 0
$LN196@s390_progr:
  00438	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR tv241[rsp], 0
  00440	74 1c		 je	 SHORT $LN199@s390_progr
  00442	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00447	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0044e	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00455	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv252[rsp], eax
  0045c	eb 41		 jmp	 SHORT $LN200@s390_progr
$LN199@s390_progr:
  0045e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00463	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0046a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00470	d1 e8		 shr	 eax, 1
  00472	83 e0 01	 and	 eax, 1
  00475	85 c0		 test	 eax, eax
  00477	74 0d		 je	 SHORT $LN197@s390_progr
  00479	c7 84 24 a0 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv250[rsp], 6
  00484	eb 0b		 jmp	 SHORT $LN198@s390_progr
$LN197@s390_progr:
  00486	c7 84 24 a0 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv250[rsp], 4
$LN198@s390_progr:
  00491	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv250[rsp]
  00498	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv252[rsp], eax
$LN200@s390_progr:
  0049f	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv252[rsp]
  004a6	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv254[rsp], eax
$LN202@s390_progr:
  004ad	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv254[rsp]
  004b4	89 84 24 90 00
	00 00		 mov	 DWORD PTR sie_ilc$[rsp], eax

; 712  :         if (GUEST( realregs )->psw.ilc == 0 && !GUEST( realregs )->psw.zeroilc)

  004bb	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  004c0	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004c7	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  004ce	85 c0		 test	 eax, eax
  004d0	0f 85 f3 00 00
	00		 jne	 $LN95@s390_progr
  004d6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  004db	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  004e2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004e8	c1 e8 02	 shr	 eax, 2
  004eb	83 e0 01	 and	 eax, 1
  004ee	85 c0		 test	 eax, eax
  004f0	0f 85 d3 00 00
	00		 jne	 $LN95@s390_progr

; 713  :         {
; 714  :             sie_ilc = likely( !GUEST( realregs )->execflag) ? 2 : GUEST( realregs )->exrl ? 6 : 4;

  004f6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  004fb	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00502	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00508	83 e0 01	 and	 eax, 1
  0050b	85 c0		 test	 eax, eax
  0050d	75 0d		 jne	 SHORT $LN203@s390_progr
  0050f	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv268[rsp], 1
  0051a	eb 0b		 jmp	 SHORT $LN204@s390_progr
$LN203@s390_progr:
  0051c	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv268[rsp], 0
$LN204@s390_progr:
  00527	83 bc 24 ac 00
	00 00 00	 cmp	 DWORD PTR tv268[rsp], 0
  0052f	74 0d		 je	 SHORT $LN207@s390_progr
  00531	c7 84 24 b0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv276[rsp], 1
  0053c	eb 0b		 jmp	 SHORT $LN208@s390_progr
$LN207@s390_progr:
  0053e	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv276[rsp], 0
$LN208@s390_progr:
  00549	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR tv276[rsp], 0
  00551	74 0d		 je	 SHORT $LN211@s390_progr
  00553	c7 84 24 b8 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv284[rsp], 2
  0055e	eb 41		 jmp	 SHORT $LN212@s390_progr
$LN211@s390_progr:
  00560	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00565	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0056c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00572	d1 e8		 shr	 eax, 1
  00574	83 e0 01	 and	 eax, 1
  00577	85 c0		 test	 eax, eax
  00579	74 0d		 je	 SHORT $LN209@s390_progr
  0057b	c7 84 24 b4 00
	00 00 06 00 00
	00		 mov	 DWORD PTR tv282[rsp], 6
  00586	eb 0b		 jmp	 SHORT $LN210@s390_progr
$LN209@s390_progr:
  00588	c7 84 24 b4 00
	00 00 04 00 00
	00		 mov	 DWORD PTR tv282[rsp], 4
$LN210@s390_progr:
  00593	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv282[rsp]
  0059a	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv284[rsp], eax
$LN212@s390_progr:
  005a1	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv284[rsp]
  005a8	89 84 24 90 00
	00 00		 mov	 DWORD PTR sie_ilc$[rsp], eax

; 715  :             GUEST( realregs )->psw.ilc  = sie_ilc;

  005af	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  005b4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  005bb	0f b6 8c 24 90
	00 00 00	 movzx	 ecx, BYTE PTR sie_ilc$[rsp]
  005c3	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl
$LN95@s390_progr:
$LN19@s390_progr:

; 716  :         }
; 717  : 
; 718  :         PTT_PGM( "PGM sie_ilc", 0, 0, sie_ilc );

  005c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005d0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005d3	48 83 e0 20	 and	 rax, 32			; 00000020H
  005d7	48 85 c0	 test	 rax, rax
  005da	74 3a		 je	 SHORT $LN96@s390_progr
  005dc	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR sie_ilc$[rsp]
  005e4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005ed	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  005f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181694
  005f9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005fe	45 33 c9	 xor	 r9d, r9d
  00601	45 33 c0	 xor	 r8d, r8d
  00604	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181695
  0060b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00610	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN96@s390_progr:
  00616	33 c0		 xor	 eax, eax
  00618	85 c0		 test	 eax, eax
  0061a	75 ad		 jne	 SHORT $LN19@s390_progr
$LN94@s390_progr:

; 719  :     }
; 720  : #endif
; 721  : 
; 722  :     /* Trace the program interrupt right away */
; 723  :     ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );

  0061c	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR ilc$[rsp]
  00624	8b 94 24 f8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  0062b	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00633	e8 00 00 00 00	 call	 s390_trace_program_interrupt

; 724  : 
; 725  :     /* Remove PER indication from program interrupt code
; 726  :        such that interrupt code specific tests may be done.
; 727  :        The PER indication will be stored in the PER handling
; 728  :        code */
; 729  :     code = pcode & ~PGM_PER_EVENT;

  00638	8b 84 24 f8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  0063f	0f ba f0 07	 btr	 eax, 7
  00643	89 44 24 78	 mov	 DWORD PTR code$[rsp], eax
$LN22@s390_progr:

; 730  : 
; 731  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 732  : 
; 733  :     /* If transaction is active, check if interrupt can be filtered */
; 734  :     if (realregs->txf_tnd)
; 735  :     {
; 736  :         /* Indicate TXF related program interrupt */
; 737  :         pcode |= PGM_TXF_EVENT;
; 738  : 
; 739  :         /* Always reset the NTSTG indicator on any program interrupt */
; 740  :         regs->txf_NTSTG = false;
; 741  : 
; 742  :         /* Save the program interrupt and data exception codes */
; 743  :         realregs->txf_piid   = pcode;
; 744  :         realregs->txf_piid  |= (ilc << 16);
; 745  : 
; 746  :         realregs->txf_dxc_vxc =
; 747  :         (0
; 748  :             || pcode == PGM_DATA_EXCEPTION
; 749  :             || pcode == PGM_VECTOR_PROCESSING_EXCEPTION
; 750  :         )
; 751  :         ?  realregs->dxc : 0;
; 752  : 
; 753  :         PTT_TXF( "TXF PIID", realregs->txf_piid, realregs->txf_dxc_vxc, 0 );
; 754  : 
; 755  :         /* 'txf_do_pi_filtering' does not return for filterable
; 756  :             program interrupts. It returns only if the program
; 757  :             interrupt is unfilterable, and when it returns, the
; 758  :             active transaction has already been aborted.
; 759  :         */
; 760  :         PTT_TXF( "TXF PROG?", (code & 0xFF), realregs->txf_contran, realregs->txf_tnd );
; 761  :         ARCH_DEP( txf_do_pi_filtering )( realregs, pcode );
; 762  : 
; 763  :         if (realregs->txf_tnd ) // (sanity check)
; 764  :             CRASH();            // (sanity check)
; 765  : 
; 766  :         PTT_TXF( "*TXF UPROG!", (code & 0xFF), 0, 0 );
; 767  : 
; 768  :         /* Set flag for sie_exit */
; 769  :         realregs->txf_UPGM_abort = true;
; 770  :     }
; 771  :     else /* (no transaction is CURRENTLY active) */
; 772  :     {
; 773  :         /* While no transaction is CURRENTLY active, it's possible
; 774  :            that a previously active transaction was aborted BEFORE
; 775  :            we were called, so we need to check for that.
; 776  :         */
; 777  :         if ((code & 0xFF) == PGM_TRANSACTION_CONSTRAINT_EXCEPTION)
; 778  :         {
; 779  :             /* Indicate TXF related program interrupt */
; 780  :             pcode |= PGM_TXF_EVENT;
; 781  : 
; 782  :             PTT_TXF( "*TXF 218!", pcode, 0, 0 );
; 783  : 
; 784  :             /* Set flag for sie_exit */
; 785  :             realregs->txf_UPGM_abort = true;
; 786  :         }
; 787  :     }
; 788  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 789  : 
; 790  :     /* Set 'execflag' to 0 in case EXecuted instruction program-checked */
; 791  : 
; 792  :     PTT_PGM( "PGM execflag", realregs->execflag, realregs->sie_active, 0 );

  00647	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0064e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00651	48 83 e0 20	 and	 rax, 32			; 00000020H
  00655	48 85 c0	 test	 rax, rax
  00658	74 56		 je	 SHORT $LN97@s390_progr
  0065a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0065f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00665	83 e0 01	 and	 eax, 1
  00668	8b c0		 mov	 eax, eax
  0066a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0066f	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00675	83 e1 01	 and	 ecx, 1
  00678	8b c9		 mov	 ecx, ecx
  0067a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00683	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0068c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181697
  00693	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00698	44 8b c8	 mov	 r9d, eax
  0069b	44 8b c1	 mov	 r8d, ecx
  0069e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181698
  006a5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  006aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN97@s390_progr:
  006b0	33 c0		 xor	 eax, eax
  006b2	85 c0		 test	 eax, eax
  006b4	75 91		 jne	 SHORT $LN22@s390_progr

; 793  :     realregs->execflag = 0;

  006b6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  006bb	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006c1	83 e0 fe	 and	 eax, -2			; fffffffeH
  006c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  006c9	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 794  : 
; 795  : #if defined( FEATURE_SIE )
; 796  :     if (realregs->sie_active)

  006cf	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  006d4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  006da	83 e0 01	 and	 eax, 1
  006dd	85 c0		 test	 eax, eax
  006df	74 27		 je	 SHORT $LN98@s390_progr

; 797  :         GUEST( realregs )->execflag = 0;

  006e1	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  006e6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  006ed	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006f3	83 e0 fe	 and	 eax, -2			; fffffffeH
  006f6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  006fb	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00702	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN98@s390_progr:
$LN25@s390_progr:

; 798  : #endif
; 799  :     PTT_PGM( "PGM execflag", realregs->execflag, realregs->sie_active, 0 );

  00708	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0070f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00712	48 83 e0 20	 and	 rax, 32			; 00000020H
  00716	48 85 c0	 test	 rax, rax
  00719	74 56		 je	 SHORT $LN99@s390_progr
  0071b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00720	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00726	83 e0 01	 and	 eax, 1
  00729	8b c0		 mov	 eax, eax
  0072b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00730	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00736	83 e1 01	 and	 ecx, 1
  00739	8b c9		 mov	 ecx, ecx
  0073b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00744	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0074d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181701
  00754	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00759	44 8b c8	 mov	 r9d, eax
  0075c	44 8b c1	 mov	 r8d, ecx
  0075f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181702
  00766	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0076b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN99@s390_progr:
  00771	33 c0		 xor	 eax, eax
  00773	85 c0		 test	 eax, eax
  00775	75 91		 jne	 SHORT $LN25@s390_progr

; 800  : 
; 801  :     /* If this is a concurrent PER event
; 802  :        then we must add the PER bit to the interrupts code */
; 803  :     if (OPEN_IC_PER (realregs ))

  00777	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0077c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00781	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00784	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00787	23 c1		 and	 eax, ecx
  00789	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0078e	85 c0		 test	 eax, eax
  00790	74 12		 je	 SHORT $LN100@s390_progr

; 804  :         pcode |= PGM_PER_EVENT;

  00792	8b 84 24 f8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  00799	0f ba e8 07	 bts	 eax, 7
  0079d	89 84 24 f8 01
	00 00		 mov	 DWORD PTR pcode$[rsp], eax
$LN100@s390_progr:

; 805  : 
; 806  :     /* Perform serialization and checkpoint synchronization */
; 807  :     PERFORM_SERIALIZATION( realregs );

  007a4	0f ae f0	 mfence
$LN28@s390_progr:

; 808  :     PERFORM_CHKPT_SYNC( realregs );

  007a7	33 c0		 xor	 eax, eax
  007a9	85 c0		 test	 eax, eax
  007ab	75 fa		 jne	 SHORT $LN28@s390_progr

; 809  : 
; 810  : #if defined( FEATURE_SIE )
; 811  :     /* Host protection and addressing exceptions
; 812  :        must be reflected to the guest */
; 813  :     if (1
; 814  :         && realregs->sie_active
; 815  :         && (0

  007ad	33 c0		 xor	 eax, eax
  007af	83 f8 01	 cmp	 eax, 1
  007b2	0f 84 83 01 00
	00		 je	 $LN101@s390_progr
  007b8	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  007bd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  007c3	83 e0 01	 and	 eax, 1
  007c6	85 c0		 test	 eax, eax
  007c8	0f 84 6d 01 00
	00		 je	 $LN101@s390_progr
  007ce	33 c0		 xor	 eax, eax
  007d0	85 c0		 test	 eax, eax
  007d2	75 2e		 jne	 SHORT $LN102@s390_progr
  007d4	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  007d9	74 27		 je	 SHORT $LN102@s390_progr
  007db	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  007e0	74 20		 je	 SHORT $LN102@s390_progr
  007e2	83 7c 24 78 28	 cmp	 DWORD PTR code$[rsp], 40 ; 00000028H
  007e7	74 19		 je	 SHORT $LN102@s390_progr
  007e9	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  007ee	74 12		 je	 SHORT $LN102@s390_progr
  007f0	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  007f5	74 0b		 je	 SHORT $LN102@s390_progr
  007f7	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  007fc	0f 85 39 01 00
	00		 jne	 $LN101@s390_progr
$LN102@s390_progr:

; 816  :             || code == PGM_PROTECTION_EXCEPTION
; 817  :             || code == PGM_ADDRESSING_EXCEPTION
; 818  : 
; 819  : #if defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 820  :             || code == PGM_ALET_SPECIFICATION_EXCEPTION
; 821  :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 822  :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 823  :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 824  : #endif
; 825  :            )
; 826  :     )
; 827  :     {
; 828  :         /* Pass this interrupt to the guest */
; 829  : #if defined( SIE_DEBUG )
; 830  :         LOGMSG( "program_int() passing to guest code=%4.4X\n", pcode );
; 831  : #endif
; 832  :         switch (GUEST( realregs )->arch_mode)

  00802	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00807	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  0080e	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00811	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv365[rsp], eax
  00818	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv365[rsp], 0
  00820	74 16		 je	 SHORT $LN103@s390_progr
  00822	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR tv365[rsp], 1
  0082a	74 2b		 je	 SHORT $LN104@s390_progr
  0082c	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR tv365[rsp], 2
  00834	74 40		 je	 SHORT $LN105@s390_progr
  00836	eb 5e		 jmp	 SHORT $LN106@s390_progr
$LN103@s390_progr:

; 833  :         {
; 834  :         case ARCH_370_IDX: GUEST( realregs )->TEA_370 = realregs->TEA; break;

  00838	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0083d	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00844	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00849	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  0084f	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  00855	eb 5c		 jmp	 SHORT $LN29@s390_progr
$LN104@s390_progr:

; 835  :         case ARCH_390_IDX: GUEST( realregs )->TEA_390 = realregs->TEA; break;

  00857	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0085c	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00863	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00868	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  0086e	89 88 18 07 00
	00		 mov	 DWORD PTR [rax+1816], ecx
  00874	eb 3d		 jmp	 SHORT $LN29@s390_progr
$LN105@s390_progr:

; 836  :         case ARCH_900_IDX: GUEST( realregs )->TEA_900 = realregs->TEA; break;

  00876	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0087b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00882	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00887	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  0088d	48 89 88 18 07
	00 00		 mov	 QWORD PTR [rax+1816], rcx
  00894	eb 1d		 jmp	 SHORT $LN29@s390_progr
$LN106@s390_progr:
$LN33@s390_progr:

; 837  :         default: CRASH();

  00896	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$4[rsp], 0
  008a2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR p$4[rsp]
  008aa	c6 00 00	 mov	 BYTE PTR [rax], 0
  008ad	33 c0		 xor	 eax, eax
  008af	85 c0		 test	 eax, eax
  008b1	75 e3		 jne	 SHORT $LN33@s390_progr
$LN29@s390_progr:

; 838  :         }
; 839  : 
; 840  :         GUEST( realregs )->excarid = realregs->excarid;

  008b3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  008b8	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008bf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  008c4	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  008cb	88 88 3e 08 00
	00		 mov	 BYTE PTR [rax+2110], cl

; 841  :         GUEST( realregs )->opndrid = realregs->opndrid;

  008d1	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  008d6	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  008e2	0f b6 89 3f 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2111]
  008e9	88 88 3f 08 00
	00		 mov	 BYTE PTR [rax+2111], cl

; 842  : 
; 843  : #if defined(_FEATURE_PROTECTION_INTERCEPTION_CONTROL)
; 844  :         GUEST( realregs )->hostint = 1;

  008ef	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  008f4	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  008fb	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00901	83 c8 40	 or	 eax, 64			; 00000040H
  00904	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00909	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00910	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 845  : #endif
; 846  :         GUEST( realregs )->program_interrupt( GUEST( realregs ), pcode );

  00916	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0091b	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00922	8b 94 24 f8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  00929	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0092e	48 8b 89 70 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2160]
  00935	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN101@s390_progr:
$LN36@s390_progr:

; 847  :     }
; 848  : #endif /* defined( FEATURE_SIE ) */
; 849  : 
; 850  :     /* Back up the PSW for exceptions which cause nullification,
; 851  :        unless the exception occurred during instruction fetch
; 852  :     */
; 853  :     PTT_PGM( "PGM psw.IA", realregs->psw.IA, realregs->instinvalid, ilc );

  0093b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00942	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00945	48 83 e0 20	 and	 rax, 32			; 00000020H
  00949	48 85 c0	 test	 rax, rax
  0094c	74 58		 je	 SHORT $LN107@s390_progr
  0094e	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00956	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0095b	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00961	c1 e9 03	 shr	 ecx, 3
  00964	83 e1 01	 and	 ecx, 1
  00967	8b c9		 mov	 ecx, ecx
  00969	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  0096e	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  00974	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0097d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00982	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181711
  00989	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0098e	44 8b c9	 mov	 r9d, ecx
  00991	44 8b c2	 mov	 r8d, edx
  00994	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181712
  0099b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  009a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN107@s390_progr:
  009a6	33 c0		 xor	 eax, eax
  009a8	85 c0		 test	 eax, eax
  009aa	75 8f		 jne	 SHORT $LN36@s390_progr

; 854  :     if (1
; 855  :         && !realregs->instinvalid
; 856  :         && (0

  009ac	33 c0		 xor	 eax, eax
  009ae	83 f8 01	 cmp	 eax, 1
  009b1	0f 84 e4 01 00
	00		 je	 $LN108@s390_progr
  009b7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  009bc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009c2	c1 e8 03	 shr	 eax, 3
  009c5	83 e0 01	 and	 eax, 1
  009c8	85 c0		 test	 eax, eax
  009ca	0f 85 cb 01 00
	00		 jne	 $LN108@s390_progr
  009d0	33 c0		 xor	 eax, eax
  009d2	85 c0		 test	 eax, eax
  009d4	0f 85 c4 00 00
	00		 jne	 $LN109@s390_progr
  009da	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  009df	0f 84 b9 00 00
	00		 je	 $LN109@s390_progr
  009e5	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  009ea	0f 84 ae 00 00
	00		 je	 $LN109@s390_progr
  009f0	83 7c 24 78 16	 cmp	 DWORD PTR code$[rsp], 22
  009f5	0f 84 a3 00 00
	00		 je	 $LN109@s390_progr
  009fb	83 7c 24 78 20	 cmp	 DWORD PTR code$[rsp], 32 ; 00000020H
  00a00	0f 84 98 00 00
	00		 je	 $LN109@s390_progr
  00a06	83 7c 24 78 21	 cmp	 DWORD PTR code$[rsp], 33 ; 00000021H
  00a0b	0f 84 8d 00 00
	00		 je	 $LN109@s390_progr
  00a11	83 7c 24 78 22	 cmp	 DWORD PTR code$[rsp], 34 ; 00000022H
  00a16	0f 84 82 00 00
	00		 je	 $LN109@s390_progr
  00a1c	83 7c 24 78 26	 cmp	 DWORD PTR code$[rsp], 38 ; 00000026H
  00a21	74 7b		 je	 SHORT $LN109@s390_progr
  00a23	83 7c 24 78 27	 cmp	 DWORD PTR code$[rsp], 39 ; 00000027H
  00a28	74 74		 je	 SHORT $LN109@s390_progr
  00a2a	83 7c 24 78 2e	 cmp	 DWORD PTR code$[rsp], 46 ; 0000002eH
  00a2f	74 6d		 je	 SHORT $LN109@s390_progr
  00a31	83 7c 24 78 23	 cmp	 DWORD PTR code$[rsp], 35 ; 00000023H
  00a36	74 66		 je	 SHORT $LN109@s390_progr
  00a38	83 7c 24 78 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  00a3d	74 5f		 je	 SHORT $LN109@s390_progr
  00a3f	83 7c 24 78 25	 cmp	 DWORD PTR code$[rsp], 37 ; 00000025H
  00a44	74 58		 je	 SHORT $LN109@s390_progr
  00a46	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  00a4b	74 51		 je	 SHORT $LN109@s390_progr
  00a4d	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  00a52	74 4a		 je	 SHORT $LN109@s390_progr
  00a54	83 7c 24 78 2b	 cmp	 DWORD PTR code$[rsp], 43 ; 0000002bH
  00a59	74 43		 je	 SHORT $LN109@s390_progr
  00a5b	83 7c 24 78 2c	 cmp	 DWORD PTR code$[rsp], 44 ; 0000002cH
  00a60	74 3c		 je	 SHORT $LN109@s390_progr
  00a62	83 7c 24 78 2f	 cmp	 DWORD PTR code$[rsp], 47 ; 0000002fH
  00a67	74 35		 je	 SHORT $LN109@s390_progr
  00a69	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  00a6e	74 2e		 je	 SHORT $LN109@s390_progr
  00a70	83 7c 24 78 30	 cmp	 DWORD PTR code$[rsp], 48 ; 00000030H
  00a75	74 27		 je	 SHORT $LN109@s390_progr
  00a77	83 7c 24 78 31	 cmp	 DWORD PTR code$[rsp], 49 ; 00000031H
  00a7c	74 20		 je	 SHORT $LN109@s390_progr
  00a7e	83 7c 24 78 32	 cmp	 DWORD PTR code$[rsp], 50 ; 00000032H
  00a83	74 19		 je	 SHORT $LN109@s390_progr
  00a85	83 7c 24 78 33	 cmp	 DWORD PTR code$[rsp], 51 ; 00000033H
  00a8a	74 12		 je	 SHORT $LN109@s390_progr
  00a8c	83 7c 24 78 34	 cmp	 DWORD PTR code$[rsp], 52 ; 00000034H
  00a91	74 0b		 je	 SHORT $LN109@s390_progr
  00a93	83 7c 24 78 19	 cmp	 DWORD PTR code$[rsp], 25
  00a98	0f 85 fd 00 00
	00		 jne	 $LN108@s390_progr
$LN109@s390_progr:

; 857  :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 858  :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 859  : 
; 860  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 861  :             || code == PGM_ASCE_TYPE_EXCEPTION
; 862  :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 863  :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 864  :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 865  : #endif
; 866  :             || code == PGM_TRACE_TABLE_EXCEPTION
; 867  :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 868  :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 869  :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 870  :             || code == PGM_LFX_TRANSLATION_EXCEPTION
; 871  :             || code == PGM_LSX_TRANSLATION_EXCEPTION
; 872  :             || code == PGM_LSTE_SEQUENCE_EXCEPTION
; 873  :             || code == PGM_EX_TRANSLATION_EXCEPTION
; 874  :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 875  :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 876  :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 877  :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 878  :             || code == PGM_ASTE_VALIDITY_EXCEPTION
; 879  :             || code == PGM_ASTE_SEQUENCE_EXCEPTION
; 880  :             || code == PGM_ASTE_INSTANCE_EXCEPTION
; 881  :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 882  :             || code == PGM_STACK_FULL_EXCEPTION
; 883  :             || code == PGM_STACK_EMPTY_EXCEPTION
; 884  :             || code == PGM_STACK_SPECIFICATION_EXCEPTION
; 885  :             || code == PGM_STACK_TYPE_EXCEPTION
; 886  :             || code == PGM_STACK_OPERATION_EXCEPTION
; 887  :             || code == PGM_VECTOR_OPERATION_EXCEPTION
; 888  :            )
; 889  :     )
; 890  :     {
; 891  :         realregs->psw.IA -= ilc;

  00a9e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00aa3	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00aaa	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00ab0	2b c1		 sub	 eax, ecx
  00ab2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00ab7	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 892  :         realregs->psw.IA &= ADDRESS_MAXWRAP(realregs);

  00abd	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00ac2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00ac7	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00acd	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00ad3	23 c1		 and	 eax, ecx
  00ad5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00ada	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN39@s390_progr:

; 893  : 
; 894  :         PTT_PGM( "PGM IA-ilc", realregs->psw.IA, realregs->instinvalid, ilc );

  00ae0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00ae7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00aea	48 83 e0 20	 and	 rax, 32			; 00000020H
  00aee	48 85 c0	 test	 rax, rax
  00af1	74 58		 je	 SHORT $LN110@s390_progr
  00af3	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00afb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00b00	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00b06	c1 e9 03	 shr	 ecx, 3
  00b09	83 e1 01	 and	 ecx, 1
  00b0c	8b c9		 mov	 ecx, ecx
  00b0e	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00b13	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  00b19	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b22	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b27	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181716
  00b2e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b33	44 8b c9	 mov	 r9d, ecx
  00b36	44 8b c2	 mov	 r8d, edx
  00b39	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181717
  00b40	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00b45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN110@s390_progr:
  00b4b	33 c0		 xor	 eax, eax
  00b4d	85 c0		 test	 eax, eax
  00b4f	75 8f		 jne	 SHORT $LN39@s390_progr

; 895  : 
; 896  : #if defined( FEATURE_SIE )
; 897  :         /* When in SIE mode the guest instruction
; 898  :            causing this host exception must also be nullified
; 899  :         */
; 900  :         if (realregs->sie_active && !GUEST( realregs )->instinvalid)

  00b51	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00b56	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00b5c	83 e0 01	 and	 eax, 1
  00b5f	85 c0		 test	 eax, eax
  00b61	74 38		 je	 SHORT $LN111@s390_progr
  00b63	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00b68	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00b6f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b75	c1 e8 03	 shr	 eax, 3
  00b78	83 e0 01	 and	 eax, 1
  00b7b	85 c0		 test	 eax, eax
  00b7d	75 1c		 jne	 SHORT $LN111@s390_progr

; 901  :             ARCH_DEP( update_guest_psw_ia )( GUEST( realregs ), -sie_ilc );

  00b7f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR sie_ilc$[rsp]
  00b86	f7 d8		 neg	 eax
  00b88	8b d0		 mov	 edx, eax
  00b8a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00b8f	48 8b 88 70 08
	00 00		 mov	 rcx, QWORD PTR [rax+2160]
  00b96	e8 00 00 00 00	 call	 s390_update_guest_psw_ia
$LN111@s390_progr:
$LN108@s390_progr:

; 902  : #endif
; 903  :     }
; 904  : 
; 905  :     /* The OLD PSW must be incremented
; 906  :        on the following exceptions during instfetch
; 907  :     */
; 908  :     if (1
; 909  :         && realregs->instinvalid
; 910  :         && (0

  00b9b	33 c0		 xor	 eax, eax
  00b9d	83 f8 01	 cmp	 eax, 1
  00ba0	0f 84 f0 00 00
	00		 je	 $LN112@s390_progr
  00ba6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00bab	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00bb1	c1 e8 03	 shr	 eax, 3
  00bb4	83 e0 01	 and	 eax, 1
  00bb7	85 c0		 test	 eax, eax
  00bb9	0f 84 d7 00 00
	00		 je	 $LN112@s390_progr
  00bbf	33 c0		 xor	 eax, eax
  00bc1	85 c0		 test	 eax, eax
  00bc3	75 20		 jne	 SHORT $LN113@s390_progr
  00bc5	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  00bca	74 19		 je	 SHORT $LN113@s390_progr
  00bcc	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  00bd1	74 12		 je	 SHORT $LN113@s390_progr
  00bd3	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  00bd8	74 0b		 je	 SHORT $LN113@s390_progr
  00bda	83 7c 24 78 12	 cmp	 DWORD PTR code$[rsp], 18
  00bdf	0f 85 b1 00 00
	00		 jne	 $LN112@s390_progr
$LN113@s390_progr:

; 911  :             || code == PGM_PROTECTION_EXCEPTION
; 912  :             || code == PGM_ADDRESSING_EXCEPTION
; 913  :             || code == PGM_SPECIFICATION_EXCEPTION
; 914  :             || code == PGM_TRANSLATION_SPECIFICATION_EXCEPTION
; 915  :            )
; 916  :     )
; 917  :     {
; 918  :         realregs->psw.IA += ilc;

  00be5	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00bea	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00bf0	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR ilc$[rsp]
  00bf7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00bfc	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 919  :         realregs->psw.IA &= ADDRESS_MAXWRAP( realregs );

  00c02	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00c07	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00c0c	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00c12	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00c18	23 c1		 and	 eax, ecx
  00c1a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00c1f	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN42@s390_progr:

; 920  : 
; 921  :         PTT_PGM( "PGM IA+ilc", realregs->psw.IA, realregs->instinvalid, ilc );

  00c25	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00c2c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c2f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00c33	48 85 c0	 test	 rax, rax
  00c36	74 58		 je	 SHORT $LN114@s390_progr
  00c38	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00c40	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00c45	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00c4b	c1 e9 03	 shr	 ecx, 3
  00c4e	83 e1 01	 and	 ecx, 1
  00c51	8b c9		 mov	 ecx, ecx
  00c53	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00c58	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  00c5e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00c67	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00c6c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181722
  00c73	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c78	44 8b c9	 mov	 r9d, ecx
  00c7b	44 8b c2	 mov	 r8d, edx
  00c7e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181723
  00c85	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00c8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN114@s390_progr:
  00c90	33 c0		 xor	 eax, eax
  00c92	85 c0		 test	 eax, eax
  00c94	75 8f		 jne	 SHORT $LN42@s390_progr
$LN112@s390_progr:

; 922  :     }
; 923  : 
; 924  :     /* Store the interrupt code in the PSW */
; 925  :     realregs->psw.intcode = pcode;

  00c96	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00c9b	0f b7 8c 24 f8
	01 00 00	 movzx	 ecx, WORD PTR pcode$[rsp]
  00ca3	66 89 88 98 00
	00 00		 mov	 WORD PTR [rax+152], cx

; 926  : 
; 927  :     /* Call debugger if active */
; 928  :     HDC2( debug_program_interrupt, regs, pcode );

  00caa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_program_interrupt
  00cb1	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00cb5	74 22		 je	 SHORT $LN213@s390_progr
  00cb7	8b 94 24 f8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  00cbe	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cc6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_program_interrupt
  00ccd	ff 10		 call	 QWORD PTR [rax]
  00ccf	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv518[rsp], rax
  00cd7	eb 0c		 jmp	 SHORT $LN214@s390_progr
$LN213@s390_progr:
  00cd9	48 c7 84 24 f0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv518[rsp], 0
$LN214@s390_progr:

; 929  : 
; 930  :     realregs->instinvalid = 0;

  00ce5	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00cea	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00cf0	83 e0 f7	 and	 eax, -9			; fffffff7H
  00cf3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00cf8	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN45@s390_progr:

; 931  :     PTT_PGM( "PGM inval=0", 0, 0, 0 );

  00cfe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00d05	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d08	48 83 e0 20	 and	 rax, 32			; 00000020H
  00d0c	48 85 c0	 test	 rax, rax
  00d0f	74 36		 je	 SHORT $LN115@s390_progr
  00d11	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00d1a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00d23	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181725
  00d2a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d2f	45 33 c9	 xor	 r9d, r9d
  00d32	45 33 c0	 xor	 r8d, r8d
  00d35	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181726
  00d3c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d41	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN115@s390_progr:
  00d47	33 c0		 xor	 eax, eax
  00d49	85 c0		 test	 eax, eax
  00d4b	75 b1		 jne	 SHORT $LN45@s390_progr

; 932  : 
; 933  : #if defined( FEATURE_SIE )
; 934  : 
; 935  :     /*---------------------------------------------------------*/
; 936  :     /* If this is a host exception in SIE state then leave SIE */
; 937  :     /*---------------------------------------------------------*/
; 938  :     if (realregs->sie_active)

  00d4d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00d52	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00d58	83 e0 01	 and	 eax, 1
  00d5b	85 c0		 test	 eax, eax
  00d5d	74 62		 je	 SHORT $LN116@s390_progr
$LN48@s390_progr:

; 939  :     {
; 940  :         PTT_PGM( "PGM >sie_exit", SIE_HOST_PGM_INT, 0, 0 );

  00d5f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00d66	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00d69	48 83 e0 20	 and	 rax, 32			; 00000020H
  00d6d	48 85 c0	 test	 rax, rax
  00d70	74 3a		 je	 SHORT $LN117@s390_progr
  00d72	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00d7b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00d84	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181729
  00d8b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d90	45 33 c9	 xor	 r9d, r9d
  00d93	49 c7 c0 fd ff
	ff ff		 mov	 r8, -3
  00d9a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181730
  00da1	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00da6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN117@s390_progr:
  00dac	33 c0		 xor	 eax, eax
  00dae	85 c0		 test	 eax, eax
  00db0	75 ad		 jne	 SHORT $LN48@s390_progr

; 941  :         ARCH_DEP( sie_exit )( realregs, SIE_HOST_PGM_INT );

  00db2	ba fd ff ff ff	 mov	 edx, -3
  00db7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00dbc	e8 00 00 00 00	 call	 s390_sie_exit
$LN116@s390_progr:

; 942  :     }
; 943  : #endif
; 944  : 
; 945  :     /* Absolute address of prefix page */
; 946  :     px = realregs->PX;

  00dc1	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00dc6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00dc9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR px$[rsp], rax

; 947  : 
; 948  :     /* If under SIE use translated to host absolute prefix */
; 949  : #if defined( _FEATURE_SIE )
; 950  :     if (SIE_MODE( regs ))

  00dd1	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dd9	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00ddf	d1 e8		 shr	 eax, 1
  00de1	83 e0 01	 and	 eax, 1
  00de4	85 c0		 test	 eax, eax
  00de6	74 17		 je	 SHORT $LN118@s390_progr

; 951  :         px = regs->sie_px;

  00de8	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00df0	48 8b 80 90 08
	00 00		 mov	 rax, QWORD PTR [rax+2192]
  00df7	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR px$[rsp], rax
$LN118@s390_progr:

; 952  : #endif
; 953  : 
; 954  : #if defined( _FEATURE_SIE )
; 955  :     /*---------------------------------------------------------------*/
; 956  :     /*   If we're in SIE mode, then we need to determine whether     */
; 957  :     /*   we must, or must not, intercept this program interrupt,     */
; 958  :     /*   and by intercept, we mean pass it on to the SIE host so     */
; 959  :     /*   that it (not the guest!) can decide what action to take.    */
; 960  :     /*---------------------------------------------------------------*/
; 961  :     if (0
; 962  : 
; 963  :         /* If not in SIE mode, then we (duh!) must not intercept it  */
; 964  :         || !SIE_MODE( regs )
; 965  : 
; 966  :         /* Interception is mandatory for the following exceptions,
; 967  :            so if ANY of the below conditions are false, then we MUST
; 968  :            intercept this program interrupt.
; 969  : 
; 970  :            The below tests/checks are for "not this condition" where
; 971  :            the "condition" is the condition which we MUST intercept.
; 972  :            Thus if any of them fail, then we MUST intercept.
; 973  : 
; 974  :            Only if ALL of them are true (only if no condition exists
; 975  :            that REQUIRES an intercept) should we then NOT intercept.
; 976  :         */
; 977  :         || (1

  00dff	33 c0		 xor	 eax, eax
  00e01	85 c0		 test	 eax, eax
  00e03	0f 85 2a 02 00
	00		 jne	 $LN121@s390_progr
  00e09	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e11	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00e17	d1 e8		 shr	 eax, 1
  00e19	83 e0 01	 and	 eax, 1
  00e1c	85 c0		 test	 eax, eax
  00e1e	0f 84 0f 02 00
	00		 je	 $LN121@s390_progr
  00e24	33 c0		 xor	 eax, eax
  00e26	83 f8 01	 cmp	 eax, 1
  00e29	0f 84 90 02 00
	00		 je	 $LN119@s390_progr
  00e2f	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  00e34	0f 84 85 02 00
	00		 je	 $LN119@s390_progr
  00e3a	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  00e3f	0f 84 7a 02 00
	00		 je	 $LN119@s390_progr
  00e45	83 7c 24 78 13	 cmp	 DWORD PTR code$[rsp], 19
  00e4a	0f 84 6f 02 00
	00		 je	 $LN119@s390_progr
  00e50	83 7c 24 78 07	 cmp	 DWORD PTR code$[rsp], 7
  00e55	75 6f		 jne	 SHORT $LN122@s390_progr
  00e57	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e5f	83 b8 08 07 00
	00 01		 cmp	 DWORD PTR [rax+1800], 1
  00e66	74 11		 je	 SHORT $LN123@s390_progr
  00e68	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e70	83 b8 08 07 00
	00 02		 cmp	 DWORD PTR [rax+1800], 2
  00e77	75 4d		 jne	 SHORT $LN122@s390_progr
$LN123@s390_progr:
  00e79	b8 08 00 00 00	 mov	 eax, 8
  00e7e	48 6b c0 01	 imul	 rax, rax, 1
  00e82	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e8a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00e91	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00e96	85 c0		 test	 eax, eax
  00e98	74 2c		 je	 SHORT $LN122@s390_progr
  00e9a	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ea2	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00ea9	b9 08 00 00 00	 mov	 ecx, 8
  00eae	48 6b c9 01	 imul	 rcx, rcx, 1
  00eb2	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00eb9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00ebe	85 c0		 test	 eax, eax
  00ec0	0f 84 f9 01 00
	00		 je	 $LN119@s390_progr
$LN122@s390_progr:
  00ec6	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ece	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00ed5	b9 01 00 00 00	 mov	 ecx, 1
  00eda	48 6b c9 00	 imul	 rcx, rcx, 0
  00ede	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  00ee3	83 e0 20	 and	 eax, 32			; 00000020H
  00ee6	85 c0		 test	 eax, eax
  00ee8	0f 85 d1 01 00
	00		 jne	 $LN119@s390_progr
  00eee	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  00ef3	75 41		 jne	 SHORT $LN124@s390_progr
  00ef5	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00efd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f04	b9 01 00 00 00	 mov	 ecx, 1
  00f09	48 6b c9 02	 imul	 rcx, rcx, 2
  00f0d	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  00f12	83 e0 20	 and	 eax, 32			; 00000020H
  00f15	85 c0		 test	 eax, eax
  00f17	0f 84 a2 01 00
	00		 je	 $LN119@s390_progr
  00f1d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00f22	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00f28	c1 e8 06	 shr	 eax, 6
  00f2b	83 e0 01	 and	 eax, 1
  00f2e	85 c0		 test	 eax, eax
  00f30	0f 85 89 01 00
	00		 jne	 $LN119@s390_progr
$LN124@s390_progr:
  00f36	8b 84 24 f8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  00f3d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f42	85 c0		 test	 eax, eax
  00f44	74 1e		 je	 SHORT $LN125@s390_progr
  00f46	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f4e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f55	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00f59	83 e0 01	 and	 eax, 1
  00f5c	85 c0		 test	 eax, eax
  00f5e	0f 85 5b 01 00
	00		 jne	 $LN119@s390_progr
$LN125@s390_progr:
  00f64	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  00f69	75 1e		 jne	 SHORT $LN126@s390_progr
  00f6b	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f73	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f7a	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00f7e	83 e0 01	 and	 eax, 1
  00f81	85 c0		 test	 eax, eax
  00f83	0f 85 36 01 00
	00		 jne	 $LN119@s390_progr
$LN126@s390_progr:
  00f89	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  00f8e	75 1e		 jne	 SHORT $LN127@s390_progr
  00f90	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f98	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00f9f	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00fa3	83 e0 01	 and	 eax, 1
  00fa6	85 c0		 test	 eax, eax
  00fa8	0f 85 11 01 00
	00		 jne	 $LN119@s390_progr
$LN127@s390_progr:
  00fae	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  00fb3	75 1e		 jne	 SHORT $LN128@s390_progr
  00fb5	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fbd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00fc4	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00fc8	83 e0 01	 and	 eax, 1
  00fcb	85 c0		 test	 eax, eax
  00fcd	0f 85 ec 00 00
	00		 jne	 $LN119@s390_progr
$LN128@s390_progr:
  00fd3	83 7c 24 78 01	 cmp	 DWORD PTR code$[rsp], 1
  00fd8	75 2a		 jne	 SHORT $LN129@s390_progr
  00fda	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00fe2	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00fe9	b9 01 00 00 00	 mov	 ecx, 1
  00fee	48 6b c9 00	 imul	 rcx, rcx, 0
  00ff2	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  00ff7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00ffc	85 c0		 test	 eax, eax
  00ffe	0f 85 bb 00 00
	00		 jne	 $LN119@s390_progr
$LN129@s390_progr:
  01004	83 7c 24 78 02	 cmp	 DWORD PTR code$[rsp], 2
  01009	75 28		 jne	 SHORT $LN130@s390_progr
  0100b	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01013	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0101a	b9 01 00 00 00	 mov	 ecx, 1
  0101f	48 6b c9 00	 imul	 rcx, rcx, 0
  01023	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  01028	83 e0 40	 and	 eax, 64			; 00000040H
  0102b	85 c0		 test	 eax, eax
  0102d	0f 85 8c 00 00
	00		 jne	 $LN119@s390_progr
$LN130@s390_progr:
$LN121@s390_progr:

; 978  : 
; 979  :             && code != PGM_ADDRESSING_EXCEPTION
; 980  :             && code != PGM_SPECIFICATION_EXCEPTION
; 981  :             && code != PGM_SPECIAL_OPERATION_EXCEPTION
; 982  : 
; 983  : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 984  :             && code != PGM_VECTOR_OPERATION_EXCEPTION
; 985  : #endif
; 986  : #ifdef FEATURE_BASIC_FP_EXTENSIONS
; 987  :             && !(code == PGM_DATA_EXCEPTION && (regs->dxc == 1 || regs->dxc == 2) && (regs->CR(0) & CR0_AFP) && !(HOSTREGS->CR(0) & CR0_AFP))
; 988  : #endif
; 989  :             && !SIE_FEAT_BIT_ON( regs, IC0, PGMALL )
; 990  : 
; 991  : #if !defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 992  :             && code != PGM_PROTECTION_EXCEPTION
; 993  : #else
; 994  :             && !(code == PGM_PROTECTION_EXCEPTION           && (!SIE_FEAT_BIT_ON( regs, EC2, PROTEX ) || realregs->hostint ))
; 995  : #endif
; 996  : #if defined( _FEATURE_PER2 )
; 997  :             && !((pcode & PGM_PER_EVENT)                    && SIE_FEAT_BIT_ON( regs, M, GPE ))
; 998  : #endif
; 999  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 1000 :             && !(code == PGM_ALEN_TRANSLATION_EXCEPTION     && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1001 :             && !(code == PGM_ALE_SEQUENCE_EXCEPTION         && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1002 :             && !(code == PGM_EXTENDED_AUTHORITY_EXCEPTION   && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1003 : #endif
; 1004 :             && !(code == PGM_OPERATION_EXCEPTION            && SIE_FEAT_BIT_ON( regs, IC0, OPEREX ))
; 1005 :             && !(code == PGM_PRIVILEGED_OPERATION_EXCEPTION && SIE_FEAT_BIT_ON( regs, IC0, PRIVOP ))
; 1006 :            )
; 1007 :     )
; 1008 :     {
; 1009 : #endif /*defined(_FEATURE_SIE)*/
; 1010 : 
; 1011 :         intercept = false;

  01033	c6 44 24 7c 00	 mov	 BYTE PTR intercept$[rsp], 0
$LN51@s390_progr:

; 1012 :         PTT_PGM( "PGM !icept", intercept, 0, 0 );

  01038	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0103f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01042	48 83 e0 20	 and	 rax, 32			; 00000020H
  01046	48 85 c0	 test	 rax, rax
  01049	74 3b		 je	 SHORT $LN131@s390_progr
  0104b	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01050	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01059	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181745
  01069	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0106e	45 33 c9	 xor	 r9d, r9d
  01071	44 8b c0	 mov	 r8d, eax
  01074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181746
  0107b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN131@s390_progr:
  01086	33 c0		 xor	 eax, eax
  01088	85 c0		 test	 eax, eax
  0108a	75 ac		 jne	 SHORT $LN51@s390_progr

; 1013 : 
; 1014 :         /* Set the main storage reference and change bits */
; 1015 :         ARCH_DEP( or_storage_key )( px, (STORKEY_REF | STORKEY_CHANGE) );

  0108c	b2 06		 mov	 dl, 6
  0108e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR px$[rsp]
  01096	e8 00 00 00 00	 call	 s390_or_storage_key

; 1016 : 
; 1017 :         /* Point to PSA in main storage */
; 1018 :         psa = (void*)(regs->mainstor + px);

  0109b	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010a3	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  010aa	48 03 84 24 c8
	00 00 00	 add	 rax, QWORD PTR px$[rsp]
  010b2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1019 : 
; 1020 : #if defined( _FEATURE_SIE )
; 1021 : 
; 1022 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1023 :         /** FIXME : SEE ISW20090110-1 */
; 1024 :         if (code == PGM_MONITOR_EVENT)
; 1025 :         {
; 1026 :             zmoncode = psa->moncode;
; 1027 :         }
; 1028 : #endif
; 1029 :     }

  010ba	e9 d8 00 00 00	 jmp	 $LN120@s390_progr
$LN119@s390_progr:

; 1030 :     else /* The SIE host must deal with this program interrupt */
; 1031 :     {
; 1032 :         intercept = true;

  010bf	c6 44 24 7c 01	 mov	 BYTE PTR intercept$[rsp], 1
$LN54@s390_progr:

; 1033 :         PTT_PGM( "PGM icept", intercept, 0, 0 );

  010c4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  010cb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  010ce	48 83 e0 20	 and	 rax, 32			; 00000020H
  010d2	48 85 c0	 test	 rax, rax
  010d5	74 3b		 je	 SHORT $LN132@s390_progr
  010d7	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  010dc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  010e5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  010ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181748
  010f5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  010fa	45 33 c9	 xor	 r9d, r9d
  010fd	44 8b c0	 mov	 r8d, eax
  01100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181749
  01107	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0110c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN132@s390_progr:
  01112	33 c0		 xor	 eax, eax
  01114	85 c0		 test	 eax, eax
  01116	75 ac		 jne	 SHORT $LN54@s390_progr

; 1034 : 
; 1035 :         /* This is a guest interruption interception so point to
; 1036 :            the interruption parm area in the state descriptor
; 1037 :            rather then the PSA (except for Operation Exception)
; 1038 :         */
; 1039 :         if (code != PGM_OPERATION_EXCEPTION)

  01118	83 7c 24 78 01	 cmp	 DWORD PTR code$[rsp], 1
  0111d	74 4a		 je	 SHORT $LN133@s390_progr

; 1040 :         {
; 1041 :             psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_IP_PSA_OFFSET);

  0111f	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01127	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0112e	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01135	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0113d	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  01144	48 8d 44 08 40	 lea	 rax, QWORD PTR [rax+rcx+64]
  01149	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1042 : 
; 1043 :             /* Set the main storage reference and change bits */
; 1044 :             ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  01151	b2 06		 mov	 dl, 6
  01153	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0115b	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  01162	e8 00 00 00 00	 call	 s390_or_storage_key

; 1045 : 
; 1046 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1047 :             /** FIXME : SEE ISW20090110-1 */
; 1048 :             if (code == PGM_MONITOR_EVENT)
; 1049 :             {
; 1050 :                 PSA* _psa;
; 1051 :                 _psa = (void *)(HOSTREGS->mainstor + SIE_STATE( regs ) + SIE_II_PSA_OFFSET);
; 1052 :                 zmoncode = _psa->ioid;
; 1053 :             }
; 1054 : #endif
; 1055 :         }

  01167	eb 2e		 jmp	 SHORT $LN134@s390_progr
$LN133@s390_progr:

; 1056 :         else
; 1057 :         {
; 1058 :             /* Point to PSA in main storage */
; 1059 :             psa = (void*)(regs->mainstor + px);

  01169	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01171	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  01178	48 03 84 24 c8
	00 00 00	 add	 rax, QWORD PTR px$[rsp]
  01180	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1060 : 
; 1061 :             /* Set the main storage reference and change bits */
; 1062 :             ARCH_DEP( or_storage_key )( px, (STORKEY_REF | STORKEY_CHANGE) );

  01188	b2 06		 mov	 dl, 6
  0118a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR px$[rsp]
  01192	e8 00 00 00 00	 call	 s390_or_storage_key
$LN134@s390_progr:
$LN120@s390_progr:

; 1063 :         }
; 1064 :     }
; 1065 : #endif /*defined(_FEATURE_SIE)*/
; 1066 : 
; 1067 : #if defined( _FEATURE_PER )
; 1068 :     /* Handle PER or concurrent PER event */
; 1069 : 
; 1070 :     /* Throw out Stor Alter PER if merged with nullified/suppressed rupt */
; 1071 :     if (1
; 1072 :         &&  IS_IC_PER_SA(    realregs )
; 1073 :         && !IS_IC_PER_STURA( realregs )
; 1074 :         && (realregs->ip[0] != 0x0E)
; 1075 :         && !(0

  01197	33 c0		 xor	 eax, eax
  01199	83 f8 01	 cmp	 eax, 1
  0119c	0f 84 a0 00 00
	00		 je	 $LN135@s390_progr
  011a2	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  011a7	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  011aa	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  011af	85 c0		 test	 eax, eax
  011b1	0f 84 8b 00 00
	00		 je	 $LN135@s390_progr
  011b7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  011bc	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  011bf	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  011c4	85 c0		 test	 eax, eax
  011c6	75 7a		 jne	 SHORT $LN135@s390_progr
  011c8	b8 01 00 00 00	 mov	 eax, 1
  011cd	48 6b c0 00	 imul	 rax, rax, 0
  011d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  011d6	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  011da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  011de	83 f8 0e	 cmp	 eax, 14
  011e1	74 5f		 je	 SHORT $LN135@s390_progr
  011e3	33 c0		 xor	 eax, eax
  011e5	85 c0		 test	 eax, eax
  011e7	75 59		 jne	 SHORT $LN135@s390_progr
  011e9	83 7c 24 78 00	 cmp	 DWORD PTR code$[rsp], 0
  011ee	74 52		 je	 SHORT $LN135@s390_progr
  011f0	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  011f5	74 4b		 je	 SHORT $LN135@s390_progr
  011f7	83 7c 24 78 08	 cmp	 DWORD PTR code$[rsp], 8
  011fc	74 44		 je	 SHORT $LN135@s390_progr
  011fe	83 7c 24 78 0a	 cmp	 DWORD PTR code$[rsp], 10
  01203	74 3d		 je	 SHORT $LN135@s390_progr
  01205	83 7c 24 78 0c	 cmp	 DWORD PTR code$[rsp], 12
  0120a	74 36		 je	 SHORT $LN135@s390_progr
  0120c	83 7c 24 78 0d	 cmp	 DWORD PTR code$[rsp], 13
  01211	74 2f		 je	 SHORT $LN135@s390_progr
  01213	83 7c 24 78 0e	 cmp	 DWORD PTR code$[rsp], 14
  01218	74 28		 je	 SHORT $LN135@s390_progr
  0121a	83 7c 24 78 1c	 cmp	 DWORD PTR code$[rsp], 28
  0121f	74 21		 je	 SHORT $LN135@s390_progr
  01221	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  01226	74 1a		 je	 SHORT $LN135@s390_progr
$LN57@s390_progr:

; 1076 :              || code == 0x00
; 1077 :              || code == PGM_SPECIFICATION_EXCEPTION
; 1078 :              || code == PGM_FIXED_POINT_OVERFLOW_EXCEPTION
; 1079 :              || code == PGM_DECIMAL_OVERFLOW_EXCEPTION
; 1080 :              || code == PGM_EXPONENT_OVERFLOW_EXCEPTION
; 1081 :              || code == PGM_EXPONENT_UNDERFLOW_EXCEPTION
; 1082 :              || code == PGM_SIGNIFICANCE_EXCEPTION
; 1083 :              || code == PGM_SPACE_SWITCH_EVENT
; 1084 :              || code == PGM_MONITOR_EVENT
; 1085 :            )
; 1086 :     )
; 1087 :     {
; 1088 :         OFF_IC_PER_SA( realregs );

  01228	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0122d	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01230	0f ba f0 15	 btr	 eax, 21
  01234	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01239	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0123c	33 c0		 xor	 eax, eax
  0123e	85 c0		 test	 eax, eax
  01240	75 e6		 jne	 SHORT $LN57@s390_progr
$LN135@s390_progr:

; 1089 :     }
; 1090 : 
; 1091 :     if (OPEN_IC_PER( realregs ))

  01242	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01247	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0124c	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0124f	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01252	23 c1		 and	 eax, ecx
  01254	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  01259	85 c0		 test	 eax, eax
  0125b	0f 84 17 0a 00
	00		 je	 $LN136@s390_progr

; 1092 :     {
; 1093 :         if (CPU_STEPPING_OR_TRACING( realregs, ilc ))

  01261	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01266	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0126c	c1 e8 10	 shr	 eax, 16
  0126f	83 e0 01	 and	 eax, 1
  01272	85 c0		 test	 eax, eax
  01274	74 0d		 je	 SHORT $LN217@s390_progr
  01276	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv721[rsp], 1
  01281	eb 0b		 jmp	 SHORT $LN218@s390_progr
$LN217@s390_progr:
  01283	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv721[rsp], 0
$LN218@s390_progr:
  0128e	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR tv721[rsp], 0
  01296	0f 84 a0 08 00
	00		 je	 $LN138@s390_progr
  0129c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012a3	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  012a9	c1 e8 0a	 shr	 eax, 10
  012ac	83 e0 01	 and	 eax, 1
  012af	85 c0		 test	 eax, eax
  012b1	0f 84 4b 03 00
	00		 je	 $LN140@s390_progr
  012b7	33 c0		 xor	 eax, eax
  012b9	85 c0		 test	 eax, eax
  012bb	0f 85 17 01 00
	00		 jne	 $LN141@s390_progr
  012c1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012c8	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  012ce	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  012d3	85 c0		 test	 eax, eax
  012d5	0f 84 fd 00 00
	00		 je	 $LN141@s390_progr
  012db	33 c0		 xor	 eax, eax
  012dd	83 f8 01	 cmp	 eax, 1
  012e0	0f 84 1c 03 00
	00		 je	 $LN140@s390_progr
  012e6	33 c0		 xor	 eax, eax
  012e8	85 c0		 test	 eax, eax
  012ea	75 34		 jne	 SHORT $LN142@s390_progr
  012ec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  012f3	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  012f9	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  012fe	85 c0		 test	 eax, eax
  01300	74 1e		 je	 SHORT $LN142@s390_progr
  01302	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01307	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0130e	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  01314	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  0131a	0f 85 e2 02 00
	00		 jne	 $LN140@s390_progr
$LN142@s390_progr:
  01320	33 c0		 xor	 eax, eax
  01322	85 c0		 test	 eax, eax
  01324	75 34		 jne	 SHORT $LN143@s390_progr
  01326	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0132d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01333	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  01338	85 c0		 test	 eax, eax
  0133a	74 1e		 je	 SHORT $LN143@s390_progr
  0133c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01341	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01348	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  0134e	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  01354	0f 8c a8 02 00
	00		 jl	 $LN140@s390_progr
$LN143@s390_progr:
  0135a	33 c0		 xor	 eax, eax
  0135c	85 c0		 test	 eax, eax
  0135e	75 78		 jne	 SHORT $LN144@s390_progr
  01360	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01367	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0136d	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  01372	85 c0		 test	 eax, eax
  01374	74 20		 je	 SHORT $LN145@s390_progr
  01376	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0137b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01382	85 c0		 test	 eax, eax
  01384	74 10		 je	 SHORT $LN145@s390_progr
  01386	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0138b	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01392	85 c0		 test	 eax, eax
  01394	75 42		 jne	 SHORT $LN144@s390_progr
$LN145@s390_progr:
  01396	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0139d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  013a3	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  013a8	85 c0		 test	 eax, eax
  013aa	0f 84 52 02 00
	00		 je	 $LN140@s390_progr
  013b0	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  013b5	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  013bc	85 c0		 test	 eax, eax
  013be	0f 84 3e 02 00
	00		 je	 $LN140@s390_progr
  013c4	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  013c9	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  013d0	85 c0		 test	 eax, eax
  013d2	0f 85 2a 02 00
	00		 jne	 $LN140@s390_progr
$LN144@s390_progr:
$LN141@s390_progr:
  013d8	b8 08 00 00 00	 mov	 eax, 8
  013dd	48 6b c0 00	 imul	 rax, rax, 0
  013e1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  013e8	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  013f1	75 1f		 jne	 SHORT $LN146@s390_progr
  013f3	b8 08 00 00 00	 mov	 eax, 8
  013f8	48 6b c0 01	 imul	 rax, rax, 1
  013fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01403	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0140c	0f 84 7e 05 00
	00		 je	 $LN139@s390_progr
$LN146@s390_progr:
  01412	b8 08 00 00 00	 mov	 eax, 8
  01417	48 6b c0 00	 imul	 rax, rax, 0
  0141b	b9 08 00 00 00	 mov	 ecx, 8
  01420	48 6b c9 01	 imul	 rcx, rcx, 1
  01424	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0142b	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  01432	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  0143a	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  01442	0f 87 c2 00 00
	00		 ja	 $LN147@s390_progr
  01448	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0144d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  01453	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01458	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  0145d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01464	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01468	48 2b ca	 sub	 rcx, rdx
  0146b	48 03 c1	 add	 rax, rcx
  0146e	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01475	f7 d9		 neg	 ecx
  01477	48 63 c9	 movsxd	 rcx, ecx
  0147a	48 03 c1	 add	 rax, rcx
  0147d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01482	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01488	48 23 c1	 and	 rax, rcx
  0148b	8b c0		 mov	 eax, eax
  0148d	b9 08 00 00 00	 mov	 ecx, 8
  01492	48 6b c9 00	 imul	 rcx, rcx, 0
  01496	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0149d	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  014a5	72 63		 jb	 SHORT $LN147@s390_progr
  014a7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  014ac	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  014b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  014b7	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  014bc	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  014c3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  014c7	48 2b ca	 sub	 rcx, rdx
  014ca	48 03 c1	 add	 rax, rcx
  014cd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  014d4	f7 d9		 neg	 ecx
  014d6	48 63 c9	 movsxd	 rcx, ecx
  014d9	48 03 c1	 add	 rax, rcx
  014dc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  014e1	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  014e7	48 23 c1	 and	 rax, rcx
  014ea	8b c0		 mov	 eax, eax
  014ec	b9 08 00 00 00	 mov	 ecx, 8
  014f1	48 6b c9 01	 imul	 rcx, rcx, 1
  014f5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  014fc	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  01504	0f 86 86 04 00
	00		 jbe	 $LN139@s390_progr
$LN147@s390_progr:
  0150a	b8 08 00 00 00	 mov	 eax, 8
  0150f	48 6b c0 00	 imul	 rax, rax, 0
  01513	b9 08 00 00 00	 mov	 ecx, 8
  01518	48 6b c9 01	 imul	 rcx, rcx, 1
  0151c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01523	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0152a	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  01532	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  0153a	0f 86 c2 00 00
	00		 jbe	 $LN148@s390_progr
  01540	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01545	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0154b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01550	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  01555	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0155c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01560	48 2b ca	 sub	 rcx, rdx
  01563	48 03 c1	 add	 rax, rcx
  01566	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0156d	f7 d9		 neg	 ecx
  0156f	48 63 c9	 movsxd	 rcx, ecx
  01572	48 03 c1	 add	 rax, rcx
  01575	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0157a	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01580	48 23 c1	 and	 rax, rcx
  01583	8b c0		 mov	 eax, eax
  01585	b9 08 00 00 00	 mov	 ecx, 8
  0158a	48 6b c9 01	 imul	 rcx, rcx, 1
  0158e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01595	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0159d	72 63		 jb	 SHORT $LN148@s390_progr
  0159f	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  015a4	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  015aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  015af	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  015b4	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  015bb	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  015bf	48 2b ca	 sub	 rcx, rdx
  015c2	48 03 c1	 add	 rax, rcx
  015c5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  015cc	f7 d9		 neg	 ecx
  015ce	48 63 c9	 movsxd	 rcx, ecx
  015d1	48 03 c1	 add	 rax, rcx
  015d4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  015d9	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  015df	48 23 c1	 and	 rax, rcx
  015e2	8b c0		 mov	 eax, eax
  015e4	b9 08 00 00 00	 mov	 ecx, 8
  015e9	48 6b c9 00	 imul	 rcx, rcx, 0
  015ed	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  015f4	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  015fc	0f 86 8e 03 00
	00		 jbe	 $LN139@s390_progr
$LN148@s390_progr:
$LN140@s390_progr:
  01602	33 c0		 xor	 eax, eax
  01604	83 f8 01	 cmp	 eax, 1
  01607	0f 84 2f 05 00
	00		 je	 $LN138@s390_progr
  0160d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01614	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0161a	c1 e8 08	 shr	 eax, 8
  0161d	83 e0 01	 and	 eax, 1
  01620	85 c0		 test	 eax, eax
  01622	0f 84 14 05 00
	00		 je	 $LN138@s390_progr
  01628	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0162d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01633	c1 e8 0f	 shr	 eax, 15
  01636	83 e0 01	 and	 eax, 1
  01639	85 c0		 test	 eax, eax
  0163b	0f 84 fb 04 00
	00		 je	 $LN138@s390_progr
  01641	33 c0		 xor	 eax, eax
  01643	85 c0		 test	 eax, eax
  01645	0f 85 17 01 00
	00		 jne	 $LN149@s390_progr
  0164b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01652	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01658	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0165d	85 c0		 test	 eax, eax
  0165f	0f 84 fd 00 00
	00		 je	 $LN149@s390_progr
  01665	33 c0		 xor	 eax, eax
  01667	83 f8 01	 cmp	 eax, 1
  0166a	0f 84 cc 04 00
	00		 je	 $LN138@s390_progr
  01670	33 c0		 xor	 eax, eax
  01672	85 c0		 test	 eax, eax
  01674	75 34		 jne	 SHORT $LN150@s390_progr
  01676	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0167d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01683	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  01688	85 c0		 test	 eax, eax
  0168a	74 1e		 je	 SHORT $LN150@s390_progr
  0168c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01691	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01698	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0169e	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  016a4	0f 85 92 04 00
	00		 jne	 $LN138@s390_progr
$LN150@s390_progr:
  016aa	33 c0		 xor	 eax, eax
  016ac	85 c0		 test	 eax, eax
  016ae	75 34		 jne	 SHORT $LN151@s390_progr
  016b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  016b7	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  016bd	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  016c2	85 c0		 test	 eax, eax
  016c4	74 1e		 je	 SHORT $LN151@s390_progr
  016c6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  016cb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  016d2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  016d8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  016de	0f 8c 58 04 00
	00		 jl	 $LN138@s390_progr
$LN151@s390_progr:
  016e4	33 c0		 xor	 eax, eax
  016e6	85 c0		 test	 eax, eax
  016e8	75 78		 jne	 SHORT $LN152@s390_progr
  016ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  016f1	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  016f7	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  016fc	85 c0		 test	 eax, eax
  016fe	74 20		 je	 SHORT $LN153@s390_progr
  01700	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01705	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0170c	85 c0		 test	 eax, eax
  0170e	74 10		 je	 SHORT $LN153@s390_progr
  01710	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01715	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0171c	85 c0		 test	 eax, eax
  0171e	75 42		 jne	 SHORT $LN152@s390_progr
$LN153@s390_progr:
  01720	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01727	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0172d	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  01732	85 c0		 test	 eax, eax
  01734	0f 84 02 04 00
	00		 je	 $LN138@s390_progr
  0173a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0173f	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01746	85 c0		 test	 eax, eax
  01748	0f 84 ee 03 00
	00		 je	 $LN138@s390_progr
  0174e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01753	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0175a	85 c0		 test	 eax, eax
  0175c	0f 85 da 03 00
	00		 jne	 $LN138@s390_progr
$LN152@s390_progr:
$LN149@s390_progr:
  01762	b8 08 00 00 00	 mov	 eax, 8
  01767	48 6b c0 00	 imul	 rax, rax, 0
  0176b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01772	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0177b	75 1f		 jne	 SHORT $LN155@s390_progr
  0177d	b8 08 00 00 00	 mov	 eax, 8
  01782	48 6b c0 01	 imul	 rax, rax, 1
  01786	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0178d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  01796	0f 84 f4 01 00
	00		 je	 $LN154@s390_progr
$LN155@s390_progr:
  0179c	b8 08 00 00 00	 mov	 eax, 8
  017a1	48 6b c0 00	 imul	 rax, rax, 0
  017a5	b9 08 00 00 00	 mov	 ecx, 8
  017aa	48 6b c9 01	 imul	 rcx, rcx, 1
  017ae	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  017b5	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  017bc	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  017c4	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  017cc	0f 87 c2 00 00
	00		 ja	 $LN156@s390_progr
  017d2	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  017d7	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  017dd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  017e2	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  017e7	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  017ee	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  017f2	48 2b ca	 sub	 rcx, rdx
  017f5	48 03 c1	 add	 rax, rcx
  017f8	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  017ff	f7 d9		 neg	 ecx
  01801	48 63 c9	 movsxd	 rcx, ecx
  01804	48 03 c1	 add	 rax, rcx
  01807	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0180c	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01812	48 23 c1	 and	 rax, rcx
  01815	8b c0		 mov	 eax, eax
  01817	b9 08 00 00 00	 mov	 ecx, 8
  0181c	48 6b c9 00	 imul	 rcx, rcx, 0
  01820	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01827	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0182f	72 63		 jb	 SHORT $LN156@s390_progr
  01831	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01836	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0183c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01841	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  01846	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0184d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01851	48 2b ca	 sub	 rcx, rdx
  01854	48 03 c1	 add	 rax, rcx
  01857	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0185e	f7 d9		 neg	 ecx
  01860	48 63 c9	 movsxd	 rcx, ecx
  01863	48 03 c1	 add	 rax, rcx
  01866	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0186b	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  01871	48 23 c1	 and	 rax, rcx
  01874	8b c0		 mov	 eax, eax
  01876	b9 08 00 00 00	 mov	 ecx, 8
  0187b	48 6b c9 01	 imul	 rcx, rcx, 1
  0187f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01886	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0188e	0f 86 fc 00 00
	00		 jbe	 $LN154@s390_progr
$LN156@s390_progr:
  01894	b8 08 00 00 00	 mov	 eax, 8
  01899	48 6b c0 00	 imul	 rax, rax, 0
  0189d	b9 08 00 00 00	 mov	 ecx, 8
  018a2	48 6b c9 01	 imul	 rcx, rcx, 1
  018a6	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  018ad	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  018b4	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  018bc	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  018c4	0f 86 72 02 00
	00		 jbe	 $LN138@s390_progr
  018ca	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  018cf	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  018d5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  018da	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  018df	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  018e6	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  018ea	48 2b ca	 sub	 rcx, rdx
  018ed	48 03 c1	 add	 rax, rcx
  018f0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  018f7	f7 d9		 neg	 ecx
  018f9	48 63 c9	 movsxd	 rcx, ecx
  018fc	48 03 c1	 add	 rax, rcx
  018ff	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01904	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0190a	48 23 c1	 and	 rax, rcx
  0190d	8b c0		 mov	 eax, eax
  0190f	b9 08 00 00 00	 mov	 ecx, 8
  01914	48 6b c9 01	 imul	 rcx, rcx, 1
  01918	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0191f	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  01927	0f 82 0f 02 00
	00		 jb	 $LN138@s390_progr
  0192d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01932	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  01938	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0193d	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  01942	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01949	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0194d	48 2b ca	 sub	 rcx, rdx
  01950	48 03 c1	 add	 rax, rcx
  01953	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0195a	f7 d9		 neg	 ecx
  0195c	48 63 c9	 movsxd	 rcx, ecx
  0195f	48 03 c1	 add	 rax, rcx
  01962	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01967	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0196d	48 23 c1	 and	 rax, rcx
  01970	8b c0		 mov	 eax, eax
  01972	b9 08 00 00 00	 mov	 ecx, 8
  01977	48 6b c9 00	 imul	 rcx, rcx, 0
  0197b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01982	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0198a	0f 87 ac 01 00
	00		 ja	 $LN138@s390_progr
$LN154@s390_progr:
$LN139@s390_progr:

; 1094 :         {
; 1095 :             BYTE perc = IS_IC_PER( realregs ) >> 16;

  01990	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01995	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01998	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0199d	c1 e8 10	 shr	 eax, 16
  019a0	88 84 24 84 00
	00 00		 mov	 BYTE PTR perc$1[rsp], al

; 1096 : 
; 1097 :             if (regs->insttrace && sysblk.traceFILE)

  019a7	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  019af	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  019b5	c1 e8 0f	 shr	 eax, 15
  019b8	83 e0 01	 and	 eax, 1
  019bb	85 c0		 test	 eax, eax
  019bd	74 5b		 je	 SHORT $LN157@s390_progr
  019bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  019c6	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  019ce	74 4a		 je	 SHORT $LN157@s390_progr

; 1098 :                 tf_0802( regs,

  019d0	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR perc$1[rsp]
  019d8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  019dd	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR ilc$[rsp]
  019e4	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  019ea	2b ca		 sub	 ecx, edx
  019ec	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  019f1	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  019f7	8b c9		 mov	 ecx, ecx
  019f9	44 0f b7 c8	 movzx	 r9d, ax
  019fd	44 8b 84 24 f8
	01 00 00	 mov	 r8d, DWORD PTR pcode$[rsp]
  01a05	8b d1		 mov	 edx, ecx
  01a07	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01a0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0802
  01a15	e9 22 01 00 00	 jmp	 $LN158@s390_progr
$LN157@s390_progr:

; 1099 :                         (realregs->psw.IA - ilc) & ADDRESS_MAXWRAP( realregs ),
; 1100 :                          pcode, perc );
; 1101 :             else
; 1102 :             {
; 1103 :                 char percname[32];
; 1104 :                 perc2name( perc, percname, sizeof( percname ));

  01a1a	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  01a20	48 8d 94 24 58
	01 00 00	 lea	 rdx, QWORD PTR percname$7[rsp]
  01a28	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR perc$1[rsp]
  01a30	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perc2name

; 1105 : 
; 1106 :                 // "Processor %s%02X: PER event: code %4.4X perc %2.2X=%s addr "F_VADR
; 1107 :                 WRMSG( HHC00802, "I", PTYPSTR( regs->cpuad ), regs->cpuad,

  01a36	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01a3b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01a42	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  01a48	2b c1		 sub	 eax, ecx
  01a4a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01a4f	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  01a55	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv1026[rsp], eax
  01a5c	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR perc$1[rsp]
  01a64	89 8c 24 d8 00
	00 00		 mov	 DWORD PTR tv1029[rsp], ecx
  01a6b	48 8b 94 24 f0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01a73	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  01a7a	89 94 24 dc 00
	00 00		 mov	 DWORD PTR tv1033[rsp], edx
  01a81	4c 8b 84 24 f0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  01a89	45 0f b7 80 3c
	08 00 00	 movzx	 r8d, WORD PTR [r8+2108]
  01a91	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_sysblk
  01a98	43 0f b6 8c 01
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r9+r8+2888]
  01aa1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01aa7	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv1035[rsp], rax
  01aaf	b9 01 00 00 00	 mov	 ecx, 1
  01ab4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01aba	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv1026[rsp]
  01ac1	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  01ac5	48 8d 8c 24 58
	01 00 00	 lea	 rcx, QWORD PTR percname$7[rsp]
  01acd	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01ad2	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv1029[rsp]
  01ad9	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01add	8b 8c 24 f8 01
	00 00		 mov	 ecx, DWORD PTR pcode$[rsp]
  01ae4	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01ae8	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv1033[rsp]
  01aef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01af3	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv1035[rsp]
  01afb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01b00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181776
  01b07	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01b0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181777
  01b13	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01b18	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01b1d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01b23	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181778
  01b2a	ba 55 04 00 00	 mov	 edx, 1109		; 00000455H
  01b2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181779
  01b36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN158@s390_progr:
$LN138@s390_progr:

; 1108 :                     pcode, perc, percname,
; 1109 :                     (realregs->psw.IA - ilc) & ADDRESS_MAXWRAP( realregs ));
; 1110 :             }
; 1111 :         }
; 1112 : 
; 1113 :         realregs->perc |= OPEN_IC_PER( realregs ) >> ((32 - IC_CR9_SHIFT) - 16);

  01b3c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01b41	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b46	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01b49	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b4c	23 c1		 and	 eax, ecx
  01b4e	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  01b53	c1 e8 08	 shr	 eax, 8
  01b56	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b5b	0f b7 89 d0 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2256]
  01b62	0b c8		 or	 ecx, eax
  01b64	8b c1		 mov	 eax, ecx
  01b66	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b6b	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 1114 : 
; 1115 :         /* Positions 14 and 15 contain zeros
; 1116 :            if a storage alteration event was not indicated
; 1117 :         */
; 1118 :         if (0
; 1119 :             || !OPEN_IC_PER_SA(    realregs )
; 1120 :             ||  OPEN_IC_PER_STURA( realregs )

  01b72	33 c0		 xor	 eax, eax
  01b74	85 c0		 test	 eax, eax
  01b76	75 36		 jne	 SHORT $LN160@s390_progr
  01b78	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01b7d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b82	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01b85	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01b88	23 c1		 and	 eax, ecx
  01b8a	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01b8f	85 c0		 test	 eax, eax
  01b91	74 1b		 je	 SHORT $LN160@s390_progr
  01b93	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01b98	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b9d	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01ba0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01ba3	23 c1		 and	 eax, ecx
  01ba5	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  01baa	85 c0		 test	 eax, eax
  01bac	74 1d		 je	 SHORT $LN159@s390_progr
$LN160@s390_progr:

; 1121 :         )
; 1122 :             realregs->perc &= 0xFFFC;

  01bae	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01bb3	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  01bba	25 fc ff 00 00	 and	 eax, 65532		; 0000fffcH
  01bbf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01bc4	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax
$LN159@s390_progr:

; 1123 : 
; 1124 :         STORE_HW( psa->perint, realregs->perc   );

  01bcb	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01bd0	0f b7 88 d0 08
	00 00		 movzx	 ecx, WORD PTR [rax+2256]
  01bd7	e8 00 00 00 00	 call	 _byteswap_ushort
  01bdc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01be4	48 81 c1 96 00
	00 00		 add	 rcx, 150		; 00000096H
  01beb	0f b7 d0	 movzx	 edx, ax
  01bee	e8 00 00 00 00	 call	 store_hw_noswap

; 1125 :         STORE_W(  psa->peradr, realregs->peradr );

  01bf3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01bf8	8b 88 d8 08 00
	00		 mov	 ecx, DWORD PTR [rax+2264]
  01bfe	e8 00 00 00 00	 call	 _byteswap_ulong
  01c03	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01c0b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  01c12	8b d0		 mov	 edx, eax
  01c14	e8 00 00 00 00	 call	 store_fw_noswap

; 1126 : 
; 1127 :         if (IS_IC_PER_SA( realregs ) && ACCESS_REGISTER_MODE( &realregs->psw ))

  01c19	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01c1e	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01c21	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01c26	85 c0		 test	 eax, eax
  01c28	74 28		 je	 SHORT $LN161@s390_progr
  01c2a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01c2f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  01c33	83 f8 40	 cmp	 eax, 64			; 00000040H
  01c36	75 1a		 jne	 SHORT $LN161@s390_progr

; 1128 :             psa->perarid = realregs->peraid;

  01c38	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01c40	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c45	0f b6 89 e0 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2272]
  01c4c	88 88 a1 00 00
	00		 mov	 BYTE PTR [rax+161], cl
$LN161@s390_progr:

; 1129 : 
; 1130 : #if defined( _FEATURE_SIE )
; 1131 :         /* Reset PER pending indication */
; 1132 :         if (!intercept)

  01c52	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01c57	85 c0		 test	 eax, eax
  01c59	75 1b		 jne	 SHORT $LN162@s390_progr
$LN60@s390_progr:

; 1133 :             OFF_IC_PER( realregs );

  01c5b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01c60	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01c63	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  01c68	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c6d	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01c70	33 c0		 xor	 eax, eax
  01c72	85 c0		 test	 eax, eax
  01c74	75 e5		 jne	 SHORT $LN60@s390_progr
$LN162@s390_progr:

; 1134 : #endif
; 1135 :     }

  01c76	eb 12		 jmp	 SHORT $LN137@s390_progr
$LN136@s390_progr:

; 1136 :     else
; 1137 :     {
; 1138 :         pcode &= ~(PGM_PER_EVENT);

  01c78	8b 84 24 f8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  01c7f	0f ba f0 07	 btr	 eax, 7
  01c83	89 84 24 f8 01
	00 00		 mov	 DWORD PTR pcode$[rsp], eax
$LN137@s390_progr:
$LN63@s390_progr:

; 1139 :     }
; 1140 : #endif /* defined( _FEATURE_PER ) */
; 1141 : 
; 1142 : #if defined( FEATURE_BCMODE )
; 1143 :     /* For ECMODE, store extended interrupt information in PSA */
; 1144 :     if (ECMODE( &realregs->psw ))
; 1145 : #endif
; 1146 :     {
; 1147 :         PTT_PGM( "PGM ec", 0, 0, 0 );

  01c8a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01c91	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01c94	48 83 e0 20	 and	 rax, 32			; 00000020H
  01c98	48 85 c0	 test	 rax, rax
  01c9b	74 36		 je	 SHORT $LN163@s390_progr
  01c9d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01ca6	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01caf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181785
  01cb6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01cbb	45 33 c9	 xor	 r9d, r9d
  01cbe	45 33 c0	 xor	 r8d, r8d
  01cc1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181786
  01cc8	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01ccd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN163@s390_progr:
  01cd3	33 c0		 xor	 eax, eax
  01cd5	85 c0		 test	 eax, eax
  01cd7	75 b1		 jne	 SHORT $LN63@s390_progr

; 1148 : 
; 1149 :         /* Store the program interrupt code at PSA+X'8C' */
; 1150 :         psa->pgmint[0] = 0;

  01cd9	b8 01 00 00 00	 mov	 eax, 1
  01cde	48 6b c0 00	 imul	 rax, rax, 0
  01ce2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01cea	c6 84 01 8c 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+140], 0

; 1151 :         psa->pgmint[1] = ilc;

  01cf2	b8 01 00 00 00	 mov	 eax, 1
  01cf7	48 6b c0 01	 imul	 rax, rax, 1
  01cfb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01d03	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR ilc$[rsp]
  01d0b	88 94 01 8c 00
	00 00		 mov	 BYTE PTR [rcx+rax+140], dl

; 1152 : 
; 1153 :         STORE_HW( psa->pgmint + 2, pcode );

  01d12	0f b7 8c 24 f8
	01 00 00	 movzx	 ecx, WORD PTR pcode$[rsp]
  01d1a	e8 00 00 00 00	 call	 _byteswap_ushort
  01d1f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01d27	48 81 c1 8e 00
	00 00		 add	 rcx, 142		; 0000008eH
  01d2e	0f b7 d0	 movzx	 edx, ax
  01d31	e8 00 00 00 00	 call	 store_hw_noswap

; 1154 : 
; 1155 :         /* Store the exception access identification at PSA+160 */
; 1156 :         if (0
; 1157 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1158 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1159 : 
; 1160 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1161 :             || code == PGM_ASCE_TYPE_EXCEPTION
; 1162 :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 1163 :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 1164 :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 1165 : #endif
; 1166 :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 1167 :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 1168 :             || code == PGM_ASTE_VALIDITY_EXCEPTION
; 1169 :             || code == PGM_ASTE_SEQUENCE_EXCEPTION
; 1170 :             || code == PGM_ASTE_INSTANCE_EXCEPTION
; 1171 :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 1172 : 
; 1173 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1174 :             || code == PGM_PROTECTION_EXCEPTION

  01d36	33 c0		 xor	 eax, eax
  01d38	85 c0		 test	 eax, eax
  01d3a	75 3f		 jne	 SHORT $LN165@s390_progr
  01d3c	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  01d41	74 38		 je	 SHORT $LN165@s390_progr
  01d43	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  01d48	74 31		 je	 SHORT $LN165@s390_progr
  01d4a	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  01d4f	74 2a		 je	 SHORT $LN165@s390_progr
  01d51	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  01d56	74 23		 je	 SHORT $LN165@s390_progr
  01d58	83 7c 24 78 2b	 cmp	 DWORD PTR code$[rsp], 43 ; 0000002bH
  01d5d	74 1c		 je	 SHORT $LN165@s390_progr
  01d5f	83 7c 24 78 2c	 cmp	 DWORD PTR code$[rsp], 44 ; 0000002cH
  01d64	74 15		 je	 SHORT $LN165@s390_progr
  01d66	83 7c 24 78 2f	 cmp	 DWORD PTR code$[rsp], 47 ; 0000002fH
  01d6b	74 0e		 je	 SHORT $LN165@s390_progr
  01d6d	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  01d72	74 07		 je	 SHORT $LN165@s390_progr
  01d74	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  01d79	75 5b		 jne	 SHORT $LN164@s390_progr
$LN165@s390_progr:

; 1175 : #endif
; 1176 :         )
; 1177 :         {
; 1178 :             psa->excarid = regs->excarid;

  01d7b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01d83	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01d8b	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  01d92	88 88 a0 00 00
	00		 mov	 BYTE PTR [rax+160], cl

; 1179 :             // FIXME: this conditional will ALWAYS be true!!
; 1180 :             if (regs->TEA | TEA_MVPG)

  01d98	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01da0	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  01da6	83 c8 04	 or	 eax, 4
  01da9	85 c0		 test	 eax, eax
  01dab	74 1d		 je	 SHORT $LN166@s390_progr

; 1181 :                 psa->opndrid = regs->opndrid;

  01dad	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01db5	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01dbd	0f b6 89 3f 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2111]
  01dc4	88 88 a2 00 00
	00		 mov	 BYTE PTR [rax+162], cl
$LN166@s390_progr:

; 1182 :             realregs->opndrid = 0;

  01dca	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01dcf	c6 80 3f 08 00
	00 00		 mov	 BYTE PTR [rax+2111], 0
$LN164@s390_progr:

; 1183 :         }
; 1184 : 
; 1185 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1186 :         /* Store the translation exception address at PSA+168 */
; 1187 :         if (0
; 1188 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1189 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1190 :             || code == PGM_ASCE_TYPE_EXCEPTION
; 1191 :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 1192 :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 1193 :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 1194 : 
; 1195 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1196 :             || code == PGM_PROTECTION_EXCEPTION
; 1197 : #endif
; 1198 :         )
; 1199 :         {
; 1200 :             STORE_DW( psa->TEA_G, regs->TEA );
; 1201 :         }
; 1202 : 
; 1203 :         /* For z, store translation exception address at PSA+172 */
; 1204 :         if (0
; 1205 :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 1206 :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 1207 :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 1208 :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 1209 :             || code == PGM_SPACE_SWITCH_EVENT
; 1210 :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 1211 :             || code == PGM_LFX_TRANSLATION_EXCEPTION
; 1212 :             || code == PGM_LSX_TRANSLATION_EXCEPTION
; 1213 :             || code == PGM_LSTE_SEQUENCE_EXCEPTION
; 1214 :             || code == PGM_EX_TRANSLATION_EXCEPTION
; 1215 :         )
; 1216 :         {
; 1217 :             STORE_FW( psa->TEA_L, regs->TEA );
; 1218 :         }
; 1219 : 
; 1220 : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1221 : 
; 1222 :         /* For 370/390, store translation exception address at PSA+144 */
; 1223 :         if (0
; 1224 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1225 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1226 :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 1227 :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 1228 :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 1229 :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 1230 :             || code == PGM_SPACE_SWITCH_EVENT
; 1231 :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 1232 :             || code == PGM_EX_TRANSLATION_EXCEPTION
; 1233 : 
; 1234 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1235 :             || code == PGM_PROTECTION_EXCEPTION

  01dd6	33 c0		 xor	 eax, eax
  01dd8	85 c0		 test	 eax, eax
  01dda	75 46		 jne	 SHORT $LN168@s390_progr
  01ddc	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  01de1	74 3f		 je	 SHORT $LN168@s390_progr
  01de3	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  01de8	74 38		 je	 SHORT $LN168@s390_progr
  01dea	83 7c 24 78 20	 cmp	 DWORD PTR code$[rsp], 32 ; 00000020H
  01def	74 31		 je	 SHORT $LN168@s390_progr
  01df1	83 7c 24 78 21	 cmp	 DWORD PTR code$[rsp], 33 ; 00000021H
  01df6	74 2a		 je	 SHORT $LN168@s390_progr
  01df8	83 7c 24 78 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  01dfd	74 23		 je	 SHORT $LN168@s390_progr
  01dff	83 7c 24 78 25	 cmp	 DWORD PTR code$[rsp], 37 ; 00000025H
  01e04	74 1c		 je	 SHORT $LN168@s390_progr
  01e06	83 7c 24 78 1c	 cmp	 DWORD PTR code$[rsp], 28
  01e0b	74 15		 je	 SHORT $LN168@s390_progr
  01e0d	83 7c 24 78 22	 cmp	 DWORD PTR code$[rsp], 34 ; 00000022H
  01e12	74 0e		 je	 SHORT $LN168@s390_progr
  01e14	83 7c 24 78 23	 cmp	 DWORD PTR code$[rsp], 35 ; 00000023H
  01e19	74 07		 je	 SHORT $LN168@s390_progr
  01e1b	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  01e20	75 29		 jne	 SHORT $LN167@s390_progr
$LN168@s390_progr:

; 1236 : #endif
; 1237 :         )
; 1238 :         {
; 1239 :             STORE_FW( psa->tea, regs->TEA );

  01e22	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e2a	8b 88 18 07 00
	00		 mov	 ecx, DWORD PTR [rax+1816]
  01e30	e8 00 00 00 00	 call	 _byteswap_ulong
  01e35	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01e3d	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  01e44	8b d0		 mov	 edx, eax
  01e46	e8 00 00 00 00	 call	 store_fw_noswap
$LN167@s390_progr:

; 1240 :         }
; 1241 : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1242 : 
; 1243 :         realregs->TEA = 0;

  01e4b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01e50	c7 80 18 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1816], 0

; 1244 : 
; 1245 :         /* Store Data exception code in PSA */
; 1246 :         if (code == PGM_DATA_EXCEPTION)

  01e5a	83 7c 24 78 07	 cmp	 DWORD PTR code$[rsp], 7
  01e5f	0f 85 a1 00 00
	00		 jne	 $LN169@s390_progr

; 1247 :         {
; 1248 :             STORE_FW( psa->DXC, regs->dxc );

  01e65	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01e6d	8b 88 08 07 00
	00		 mov	 ecx, DWORD PTR [rax+1800]
  01e73	e8 00 00 00 00	 call	 _byteswap_ulong
  01e78	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01e80	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  01e87	8b d0		 mov	 edx, eax
  01e89	e8 00 00 00 00	 call	 store_fw_noswap

; 1249 : 
; 1250 : #if defined( FEATURE_BASIC_FP_EXTENSIONS )
; 1251 :             /* Load data exception code into FPC register byte 2 */
; 1252 :             if (regs->CR(0) & CR0_AFP)

  01e8e	b8 08 00 00 00	 mov	 eax, 8
  01e93	48 6b c0 01	 imul	 rax, rax, 1
  01e97	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01e9f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  01ea6	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  01eab	85 c0		 test	 eax, eax
  01ead	74 57		 je	 SHORT $LN170@s390_progr

; 1253 :             {
; 1254 :                 regs->fpc &= ~(FPC_DXC);

  01eaf	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01eb7	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  01ebd	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  01ec2	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01eca	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1255 :                 regs->fpc |= ((regs->dxc << 8)) & FPC_DXC;

  01ed0	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01ed8	8b 80 08 07 00
	00		 mov	 eax, DWORD PTR [rax+1800]
  01ede	c1 e0 08	 shl	 eax, 8
  01ee1	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  01ee6	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01eee	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  01ef4	0b c8		 or	 ecx, eax
  01ef6	8b c1		 mov	 eax, ecx
  01ef8	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01f00	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN170@s390_progr:
$LN169@s390_progr:

; 1256 :             }
; 1257 : #endif
; 1258 :         }
; 1259 : 
; 1260 :         /* Store the monitor class and event code */
; 1261 :         if (code == PGM_MONITOR_EVENT)

  01f06	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  01f0b	75 54		 jne	 SHORT $LN171@s390_progr

; 1262 :         {
; 1263 :             STORE_HW( psa->monclass, regs->monclass );

  01f0d	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f15	0f b7 88 3a 08
	00 00		 movzx	 ecx, WORD PTR [rax+2106]
  01f1c	e8 00 00 00 00	 call	 _byteswap_ushort
  01f21	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01f29	48 81 c1 94 00
	00 00		 add	 rcx, 148		; 00000094H
  01f30	0f b7 d0	 movzx	 edx, ax
  01f33	e8 00 00 00 00	 call	 store_hw_noswap

; 1264 : 
; 1265 :             /* Store the monitor code word at PSA+156 */
; 1266 :             /* or doubleword at PSA+176               */
; 1267 :             /* ISW20090110-1 ZSIEMCFIX                */
; 1268 :             /* In the event of a z/Arch guest being   */
; 1269 :             /* intercepted during a succesful Monitor */
; 1270 :             /* call, the monitor code is not stored   */
; 1271 :             /* at psa->moncode (which is beyond sie2bk->ip */
; 1272 :             /* but rather at the same location as an  */
; 1273 :             /* I/O interrupt would store the SSID     */
; 1274 :             /*    zmoncode points to this location    */
; 1275 :             /*  **** FIXME **** FIXME  *** FIXME ***  */
; 1276 :             /* ---- The determination of the location */
; 1277 :             /*      of the z/Sie Intercept moncode    */
; 1278 :             /*      should be made more flexible      */
; 1279 :             /*      and should be put somewhere in    */
; 1280 :             /*      esa390.h                          */
; 1281 :             /*  **** FIXME **** FIXME  *** FIXME ***  */
; 1282 : 
; 1283 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1284 :             STORE_DW( zmoncode, regs->MONCODE );
; 1285 : #else
; 1286 :             STORE_W( psa->moncode, regs->MONCODE );

  01f38	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01f40	8b 88 10 07 00
	00		 mov	 ecx, DWORD PTR [rax+1808]
  01f46	e8 00 00 00 00	 call	 _byteswap_ulong
  01f4b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01f53	48 81 c1 9c 00
	00 00		 add	 rcx, 156		; 0000009cH
  01f5a	8b d0		 mov	 edx, eax
  01f5c	e8 00 00 00 00	 call	 store_fw_noswap
$LN171@s390_progr:

; 1287 : #endif
; 1288 :         }
; 1289 : 
; 1290 : #if defined( FEATURE_PER3 )
; 1291 :         /* Store the breaking event address register in the PSA */
; 1292 :         STORE_W( psa->bea, regs->bear );
; 1293 :         PTT_PGM( "PGM bear", regs->bear, 0, 0 );
; 1294 : #endif
; 1295 : 
; 1296 :     } /* end if(ECMODE) */
; 1297 : 
; 1298 : #if defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 1299 :     realregs->hostint = 0;

  01f61	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01f66	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01f6c	83 e0 bf	 and	 eax, -65		; ffffffbfH
  01f6f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01f74	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1300 : #endif
; 1301 : 
; 1302 :     /* Normal (non-intercepted) program interrupt? */
; 1303 : #if defined( _FEATURE_SIE )
; 1304 :     if (!intercept)

  01f7a	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01f7f	85 c0		 test	 eax, eax
  01f81	0f 85 32 04 00
	00		 jne	 $LN172@s390_progr

; 1305 : #endif
; 1306 :     {
; 1307 :         PSW pgmold, pgmnew;
; 1308 :         int pgmintloop = 0;

  01f87	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR pgmintloop$3[rsp], 0

; 1309 :         int detect_pgmintloop = FACILITY_ENABLED( HERC_DETECT_PGMINTLOOP, realregs );

  01f92	b8 01 00 00 00	 mov	 eax, 1
  01f97	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  01f9b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01fa0	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  01fa8	83 e0 40	 and	 eax, 64			; 00000040H
  01fab	89 84 24 98 00
	00 00		 mov	 DWORD PTR detect_pgmintloop$2[rsp], eax

; 1310 : 
; 1311 :         /* Store current PSW at PSA+X'28' or PSA+X'150' for ESAME */
; 1312 :         ARCH_DEP( store_psw )( realregs, psa->pgmold );

  01fb2	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01fba	48 83 c0 28	 add	 rax, 40			; 00000028H
  01fbe	48 8b d0	 mov	 rdx, rax
  01fc1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01fc6	e8 00 00 00 00	 call	 s390_store_psw

; 1313 : 
; 1314 :         /* Save program old psw */
; 1315 :         if (detect_pgmintloop)

  01fcb	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR detect_pgmintloop$2[rsp], 0
  01fd3	74 35		 je	 SHORT $LN173@s390_progr

; 1316 :         {
; 1317 :             memcpy( &pgmold, &realregs->psw, sizeof( PSW ));

  01fd5	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR pgmold$5[rsp]
  01fdd	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01fe2	48 8b f8	 mov	 rdi, rax
  01fe5	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  01fe9	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  01fee	f3 a4		 rep movsb

; 1318 :             pgmold.cc      = 0;

  01ff0	c6 84 24 0c 01
	00 00 00	 mov	 BYTE PTR pgmold$5[rsp+4], 0

; 1319 :             pgmold.intcode = 0;

  01ff8	33 c0		 xor	 eax, eax
  01ffa	66 89 84 24 28
	01 00 00	 mov	 WORD PTR pgmold$5[rsp+32], ax

; 1320 :             pgmold.ilc     = 0;

  02002	c6 84 24 2a 01
	00 00 00	 mov	 BYTE PTR pgmold$5[rsp+34], 0
$LN173@s390_progr:

; 1321 :         }
; 1322 : 
; 1323 :         /* Load new PSW from PSA+X'68' or PSA+X'1D0' for ESAME */
; 1324 :         if ((code = ARCH_DEP( load_psw )( realregs, psa->pgmnew )))

  0200a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  02012	48 83 c0 68	 add	 rax, 104		; 00000068H
  02016	48 8b d0	 mov	 rdx, rax
  02019	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0201e	e8 00 00 00 00	 call	 s390_load_psw
  02023	89 44 24 78	 mov	 DWORD PTR code$[rsp], eax
  02027	83 7c 24 78 00	 cmp	 DWORD PTR code$[rsp], 0
  0202c	0f 84 f2 00 00
	00		 je	 $LN174@s390_progr

; 1325 :         {
; 1326 :             /* The load psw failed */
; 1327 : #if defined( _FEATURE_SIE )
; 1328 :             if (SIE_MODE( realregs ))

  02032	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02037	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0203d	d1 e8		 shr	 eax, 1
  0203f	83 e0 01	 and	 eax, 1
  02042	85 c0		 test	 eax, eax
  02044	0f 84 c7 00 00
	00		 je	 $LN176@s390_progr
$LN66@s390_progr:

; 1329 :             {
; 1330 :                 PTT_PGM( "*PGM *lpsw", code, 0, 0 );

  0204a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02051	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02054	48 83 e0 20	 and	 rax, 32			; 00000020H
  02058	48 85 c0	 test	 rax, rax
  0205b	74 3b		 je	 SHORT $LN178@s390_progr
  0205d	48 63 44 24 78	 movsxd	 rax, DWORD PTR code$[rsp]
  02062	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0206b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181802
  0207b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02080	45 33 c9	 xor	 r9d, r9d
  02083	4c 8b c0	 mov	 r8, rax
  02086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181803
  0208d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN178@s390_progr:
  02098	33 c0		 xor	 eax, eax
  0209a	85 c0		 test	 eax, eax
  0209c	75 ac		 jne	 SHORT $LN66@s390_progr
$LN69@s390_progr:

; 1331 :                 PTT_PGM( "PGM progjmp", pcode, 0, 0 );

  0209e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  020a5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  020a8	48 83 e0 20	 and	 rax, 32			; 00000020H
  020ac	48 85 c0	 test	 rax, rax
  020af	74 3e		 je	 SHORT $LN179@s390_progr
  020b1	48 63 84 24 f8
	01 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  020b9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  020c2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  020cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181805
  020d2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  020d7	45 33 c9	 xor	 r9d, r9d
  020da	4c 8b c0	 mov	 r8, rax
  020dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181806
  020e4	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  020e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN179@s390_progr:
  020ef	33 c0		 xor	 eax, eax
  020f1	85 c0		 test	 eax, eax
  020f3	75 a9		 jne	 SHORT $LN69@s390_progr

; 1332 :                 longjmp( realregs->progjmp, pcode );

  020f5	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  020fa	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  02100	8b 94 24 f8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  02107	48 8b c8	 mov	 rcx, rax
  0210a	e8 00 00 00 00	 call	 longjmp

; 1333 :             }

  0210f	eb 0e		 jmp	 SHORT $LN177@s390_progr
$LN176@s390_progr:

; 1334 :             else
; 1335 : #endif
; 1336 :             {
; 1337 :                 /* Invalid pgmnew: ==> program interrupt loop */
; 1338 :                 pgmintloop = detect_pgmintloop;

  02111	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR detect_pgmintloop$2[rsp]
  02118	89 84 24 9c 00
	00 00		 mov	 DWORD PTR pgmintloop$3[rsp], eax
$LN177@s390_progr:

; 1339 :             }
; 1340 :         }

  0211f	e9 87 00 00 00	 jmp	 $LN175@s390_progr
$LN174@s390_progr:

; 1341 :         else if (detect_pgmintloop)

  02124	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR detect_pgmintloop$2[rsp], 0
  0212c	74 7d		 je	 SHORT $LN180@s390_progr

; 1342 :         {
; 1343 :             /* Save program new psw */
; 1344 :             memcpy( &pgmnew, &realregs->psw, sizeof( PSW ));

  0212e	48 8d 84 24 30
	01 00 00	 lea	 rax, QWORD PTR pgmnew$6[rsp]
  02136	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0213b	48 8b f8	 mov	 rdi, rax
  0213e	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  02142	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  02147	f3 a4		 rep movsb

; 1345 :             pgmnew.cc      = 0;

  02149	c6 84 24 34 01
	00 00 00	 mov	 BYTE PTR pgmnew$6[rsp+4], 0

; 1346 :             pgmnew.intcode = 0;

  02151	33 c0		 xor	 eax, eax
  02153	66 89 84 24 50
	01 00 00	 mov	 WORD PTR pgmnew$6[rsp+32], ax

; 1347 :             pgmnew.ilc     = 0;

  0215b	c6 84 24 52 01
	00 00 00	 mov	 BYTE PTR pgmnew$6[rsp+34], 0

; 1348 : 
; 1349 :             /* Adjust pgmold instruction address */
; 1350 :             pgmold.ia.D -= ilc;

  02163	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0216b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR pgmold$5[rsp+16]
  02173	48 2b c8	 sub	 rcx, rax
  02176	48 8b c1	 mov	 rax, rcx
  02179	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR pgmold$5[rsp+16], rax

; 1351 : 
; 1352 :             /* Check for program interrupt loop (old==new) */
; 1353 :             if (memcmp( &pgmold, &pgmnew, sizeof( PSW )) == 0)

  02181	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  02187	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR pgmnew$6[rsp]
  0218f	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR pgmold$5[rsp]
  02197	e8 00 00 00 00	 call	 memcmp
  0219c	85 c0		 test	 eax, eax
  0219e	75 0b		 jne	 SHORT $LN181@s390_progr

; 1354 :                 pgmintloop = 1;

  021a0	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR pgmintloop$3[rsp], 1
$LN181@s390_progr:
$LN180@s390_progr:
$LN175@s390_progr:

; 1355 :         }
; 1356 : 
; 1357 :         if (pgmintloop)

  021ab	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR pgmintloop$3[rsp], 0
  021b3	0f 84 41 01 00
	00		 je	 $LN182@s390_progr

; 1358 :         {
; 1359 :             char buf[64];
; 1360 :             STR_PSW( realregs, buf );

  021b9	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  021bf	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR buf$8[rsp]
  021c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  021cc	e8 00 00 00 00	 call	 str_psw

; 1361 : 
; 1362 :             if (regs->insttrace && sysblk.traceFILE)

  021d1	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  021d9	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  021df	c1 e8 0f	 shr	 eax, 15
  021e2	83 e0 01	 and	 eax, 1
  021e5	85 c0		 test	 eax, eax
  021e7	74 24		 je	 SHORT $LN183@s390_progr
  021e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  021f0	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  021f8	74 13		 je	 SHORT $LN183@s390_progr

; 1363 :                 tf_0803( realregs, buf );

  021fa	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR buf$8[rsp]
  02202	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  02207	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0803
$LN183@s390_progr:

; 1364 : 
; 1365 :             // "Processor %s%02X: program interrupt loop PSW %s"
; 1366 :             WRMSG( HHC00803, "I", PTYPSTR( realregs->cpuad ),

  0220d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02212	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  02219	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv1350[rsp], eax
  02220	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  02225	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0222c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  02233	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0223b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  02241	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv1352[rsp], rax
  02249	b9 01 00 00 00	 mov	 ecx, 1
  0224e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02254	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR buf$8[rsp]
  0225c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  02261	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv1350[rsp]
  02268	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0226c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv1352[rsp]
  02274	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  02279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181811
  02280	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  02285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181812
  0228c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02291	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02296	41 b9 03 00 00
	00		 mov	 r9d, 3
  0229c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181813
  022a3	ba 57 05 00 00	 mov	 edx, 1367		; 00000557H
  022a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181814
  022af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1367 :                 realregs->cpuad, buf );
; 1368 : 
; 1369 :             OBTAIN_INTLOCK( realregs );

  022b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181815
  022bc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  022c1	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1370 :             {
; 1371 :                 realregs->cpustate = CPUSTATE_STOPPING;

  022c6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  022cb	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN72@s390_progr:

; 1372 :                 ON_IC_INTERRUPT( realregs );

  022cf	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  022d4	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  022d7	0f ba e8 1f	 bts	 eax, 31
  022db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  022e0	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  022e3	33 c0		 xor	 eax, eax
  022e5	85 c0		 test	 eax, eax
  022e7	75 e6		 jne	 SHORT $LN72@s390_progr

; 1373 :             }
; 1374 :             RELEASE_INTLOCK( realregs );

  022e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181816
  022f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  022f5	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN182@s390_progr:
$LN75@s390_progr:

; 1375 :         }
; 1376 : 
; 1377 :         /*-----------------------------------------------------------*/
; 1378 :         /*  Normal non-intercepted program interrupt: return to      */
; 1379 :         /*  either the run_cpu or run_sie loop and start executing   */
; 1380 :         /*  instructions again, but at Program New PSW instead.      */
; 1381 :         /*-----------------------------------------------------------*/
; 1382 : 
; 1383 :         PTT_PGM( "PGM !icept", intercept, 0, 0 );

  022fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02301	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02304	48 83 e0 20	 and	 rax, 32			; 00000020H
  02308	48 85 c0	 test	 rax, rax
  0230b	74 3b		 je	 SHORT $LN184@s390_progr
  0230d	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  02312	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0231b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181818
  0232b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02330	45 33 c9	 xor	 r9d, r9d
  02333	44 8b c0	 mov	 r8d, eax
  02336	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181819
  0233d	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN184@s390_progr:
  02348	33 c0		 xor	 eax, eax
  0234a	85 c0		 test	 eax, eax
  0234c	75 ac		 jne	 SHORT $LN75@s390_progr
$LN78@s390_progr:

; 1384 :         PTT_PGM( "PGM progjmp", SIE_NO_INTERCEPT, 0, 0 );

  0234e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02355	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02358	48 83 e0 20	 and	 rax, 32			; 00000020H
  0235c	48 85 c0	 test	 rax, rax
  0235f	74 3a		 je	 SHORT $LN185@s390_progr
  02361	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0236a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02373	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG181821
  0237a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0237f	45 33 c9	 xor	 r9d, r9d
  02382	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  02389	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181822
  02390	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02395	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN185@s390_progr:
  0239b	33 c0		 xor	 eax, eax
  0239d	85 c0		 test	 eax, eax
  0239f	75 ad		 jne	 SHORT $LN78@s390_progr

; 1385 :         longjmp( realregs->progjmp, SIE_NO_INTERCEPT );

  023a1	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  023a6	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  023ac	ba ff ff ff ff	 mov	 edx, -1
  023b1	48 8b c8	 mov	 rcx, rax
  023b4	e8 00 00 00 00	 call	 longjmp
$LN172@s390_progr:
$LN81@s390_progr:

; 1386 :     }
; 1387 : 
; 1388 : #if defined( _FEATURE_SIE )
; 1389 :     /*---------------------------------------------------------------*/
; 1390 :     /*  We're in SIE mode and SIE host MUST intercept this program   */
; 1391 :     /*  interrupt. Jump back to the run_sie loop with the interrupt  */
; 1392 :     /*  code so it can break out of its instruction execution loop   */
; 1393 :     /*  and exit from run_sie back to sie_exit so the interrupt can  */
; 1394 :     /*  be passed on to the SIE host for handling.                   */
; 1395 :     /*---------------------------------------------------------------*/
; 1396 : 
; 1397 :     PTT_PGM( "PGM icept", intercept, 0, 0 );

  023b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  023c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  023c3	48 83 e0 20	 and	 rax, 32			; 00000020H
  023c7	48 85 c0	 test	 rax, rax
  023ca	74 3b		 je	 SHORT $LN186@s390_progr
  023cc	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  023d1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  023da	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  023e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181824
  023ea	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  023ef	45 33 c9	 xor	 r9d, r9d
  023f2	44 8b c0	 mov	 r8d, eax
  023f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181825
  023fc	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN186@s390_progr:
  02407	33 c0		 xor	 eax, eax
  02409	85 c0		 test	 eax, eax
  0240b	75 ac		 jne	 SHORT $LN81@s390_progr
$LN84@s390_progr:

; 1398 :     PTT_PGM( "PGM progjmp", pcode, 0, 0 );

  0240d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02414	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02417	48 83 e0 20	 and	 rax, 32			; 00000020H
  0241b	48 85 c0	 test	 rax, rax
  0241e	74 3e		 je	 SHORT $LN187@s390_progr
  02420	48 63 84 24 f8
	01 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  02428	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02431	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0243a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181827
  02441	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02446	45 33 c9	 xor	 r9d, r9d
  02449	4c 8b c0	 mov	 r8, rax
  0244c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG181828
  02453	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  02458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN187@s390_progr:
  0245e	33 c0		 xor	 eax, eax
  02460	85 c0		 test	 eax, eax
  02462	75 a9		 jne	 SHORT $LN84@s390_progr

; 1399 :     longjmp( realregs->progjmp, pcode );

  02464	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  02469	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0246f	8b 94 24 f8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  02476	48 8b c8	 mov	 rcx, rax
  02479	e8 00 00 00 00	 call	 longjmp
$LN188@s390_progr:

; 1400 : #endif
; 1401 : 
; 1402 : } /* end function ARCH_DEP( program_interrupt ) */

  0247e	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02486	48 33 cc	 xor	 rcx, rsp
  02489	e8 00 00 00 00	 call	 __security_check_cookie
  0248e	48 81 c4 d8 01
	00 00		 add	 rsp, 472		; 000001d8H
  02495	5f		 pop	 rdi
  02496	5e		 pop	 rsi
  02497	c3		 ret	 0
s390_program_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
realregs$ = 112
code$ = 120
intercept$ = 124
ilc$ = 128
perc$1 = 132
psa$ = 136
detect_pgmintloop$2 = 144
pgmintloop$3 = 148
tv539 = 152
px$ = 160
tv826 = 168
tv829 = 172
tv833 = 176
tv1152 = 180
tv134 = 184
tv369 = 192
tv835 = 200
tv1154 = 208
pgmold$4 = 216
pgmnew$5 = 256
percname$6 = 296
buf$7 = 336
__$ArrayPad$ = 400
regs$ = 448
pcode$ = 456
s370_program_interrupt PROC

; 635  : {

$LN170:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 636  : PSA    *psa;                            /* -> Prefixed storage area  */
; 637  : REGS   *realregs;                       /* True regs structure       */
; 638  : RADR    px;                             /* host real address of pfx  */
; 639  : int     code;                           /* pcode without PER ind.    */
; 640  : int     ilc;                            /* instruction length        */
; 641  : 
; 642  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 643  :                                         /* FIXME : SEE ISW20090110-1 */
; 644  : void   *zmoncode = NULL;                /* mon call SIE intercept;
; 645  :                                            special reloc for z/Arch  */
; 646  :                                         /* FIXME : zmoncode not being
; 647  :                                            initialized here raises a
; 648  :                                            potentially non-initialized
; 649  :                                            warning in GCC.. can't find
; 650  :                                            why. ISW 2009/02/04       */
; 651  : #endif
; 652  : #if defined( FEATURE_SIE )
; 653  : int     sie_ilc=0;                      /* SIE instruction length    */
; 654  : #endif
; 655  : #if defined( _FEATURE_SIE )
; 656  : bool    intercept;                      /* False for virtual pgmint  */
; 657  :                                         /* (True for host interrupt?)*/
; 658  : #endif
; 659  : 
; 660  :     /* If called with ghost registers (ie from hercules command
; 661  :        then ignore all interrupt handling and report the error
; 662  :        to the caller */
; 663  :     if (regs->ghostregs)

  00024	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00032	c1 e8 0d	 shr	 eax, 13
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 1d		 je	 SHORT $LN74@s370_progr

; 664  :         longjmp( regs->progjmp, pcode );

  0003c	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00044	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  0004a	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  00051	48 8b c8	 mov	 rcx, rax
  00054	e8 00 00 00 00	 call	 longjmp
$LN74@s370_progr:
$LN4@s370_progr:

; 665  : 
; 666  :     PTT_PGM("PGM", pcode, regs->TEA, regs->psw.IA );

  00059	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00060	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00063	48 83 e0 20	 and	 rax, 32			; 00000020H
  00067	48 85 c0	 test	 rax, rax
  0006a	74 56		 je	 SHORT $LN75@s370_progr
  0006c	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0007a	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	8b 89 18 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1816]
  00088	48 63 94 24 c8
	01 00 00	 movsxd	 rdx, DWORD PTR pcode$[rsp]
  00090	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00099	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170315
  000a5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000aa	44 8b c9	 mov	 r9d, ecx
  000ad	4c 8b c2	 mov	 r8, rdx
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170316
  000b7	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN75@s370_progr:
  000c2	33 c0		 xor	 eax, eax
  000c4	85 c0		 test	 eax, eax
  000c6	75 91		 jne	 SHORT $LN4@s370_progr

; 667  : 
; 668  :     /* program_interrupt() may be called with a shadow copy of the
; 669  :        regs structure, realregs is the pointer to the real structure
; 670  :        which must be used when loading/storing the psw, or backing up
; 671  :        the instruction address in case of nullification
; 672  :     */
; 673  : #if defined( _FEATURE_SIE )
; 674  :         realregs = SIE_MODE( regs )

  000c8	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000d6	d1 e8		 shr	 eax, 1
  000d8	83 e0 01	 and	 eax, 1
  000db	85 c0		 test	 eax, eax
  000dd	74 2f		 je	 SHORT $LN162@s370_progr
  000df	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e7	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000f5	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000fd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00104	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv134[rsp], rax
  0010c	eb 2d		 jmp	 SHORT $LN163@s370_progr
$LN162@s370_progr:
  0010e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00116	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0011d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00124	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0012c	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00133	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv134[rsp], rax
$LN163@s370_progr:
  0013b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv134[rsp]
  00143	48 89 44 24 70	 mov	 QWORD PTR realregs$[rsp], rax
$LN7@s370_progr:

; 675  :                  ? GUEST( sysblk.regs[ regs->cpuad ])
; 676  :                  : HOST(  sysblk.regs[ regs->cpuad ]);
; 677  : #else
; 678  :     realregs = HOST( sysblk.regs[ regs->cpuad ]);
; 679  : #endif
; 680  : 
; 681  :     PTT_PGM( "PGM (r)h,g,a", realregs->host, realregs->guest, realregs->sie_active );

  00148	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0014f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00152	48 83 e0 20	 and	 rax, 32			; 00000020H
  00156	48 85 c0	 test	 rax, rax
  00159	74 68		 je	 SHORT $LN76@s370_progr
  0015b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00160	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00166	83 e0 01	 and	 eax, 1
  00169	8b c0		 mov	 eax, eax
  0016b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00170	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00176	c1 e9 08	 shr	 ecx, 8
  00179	83 e1 01	 and	 ecx, 1
  0017c	8b c9		 mov	 ecx, ecx
  0017e	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00183	8b 92 28 07 00
	00		 mov	 edx, DWORD PTR [rdx+1832]
  00189	c1 ea 07	 shr	 edx, 7
  0018c	83 e2 01	 and	 edx, 1
  0018f	8b d2		 mov	 edx, edx
  00191	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0019a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0019f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170318
  001a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ab	44 8b c9	 mov	 r9d, ecx
  001ae	44 8b c2	 mov	 r8d, edx
  001b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170319
  001b8	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN76@s370_progr:
  001c3	33 c0		 xor	 eax, eax
  001c5	85 c0		 test	 eax, eax
  001c7	0f 85 7b ff ff
	ff		 jne	 $LN7@s370_progr

; 682  : 
; 683  :     /* Prevent machine check when in (almost) interrupt loop */
; 684  :     realregs->instcount++;

  001cd	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  001d2	8b 80 98 07 00
	00		 mov	 eax, DWORD PTR [rax+1944]
  001d8	ff c0		 inc	 eax
  001da	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  001df	89 81 98 07 00
	00		 mov	 DWORD PTR [rcx+1944], eax

; 685  :     UPDATE_SYSBLK_INSTCOUNT( 1 );

  001e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001ec	48 05 80 14 00
	00		 add	 rax, 5248		; 00001480H
  001f2	ba 01 00 00 00	 mov	 edx, 1
  001f7	48 8b c8	 mov	 rcx, rax
  001fa	e8 00 00 00 00	 call	 atomic_update64

; 686  : 
; 687  :     /* Release any locks */
; 688  :     if (IS_INTLOCK_HELD( realregs ))

  001ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00206	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  0020d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00212	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00219	3b c1		 cmp	 eax, ecx
  0021b	75 11		 jne	 SHORT $LN77@s370_progr

; 689  :         RELEASE_INTLOCK( realregs );

  0021d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170321
  00224	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00229	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN77@s370_progr:

; 690  : 
; 691  :     /* Unlock the main storage lock if held */
; 692  :     if (sysblk.mainowner == realregs->cpuad)

  0022e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00235	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  0023c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00241	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00248	3b c1		 cmp	 eax, ecx
  0024a	75 61		 jne	 SHORT $LN78@s370_progr
$LN10@s370_progr:

; 693  :         RELEASE_MAINLOCK_UNCONDITIONAL( realregs );

  0024c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00251	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00255	0f b7 80 60 10
	00 00		 movzx	 eax, WORD PTR [rax+4192]
  0025c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00261	48 8b 89 68 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2152]
  00268	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  0026f	3b c1		 cmp	 eax, ecx
  00271	75 34		 jne	 SHORT $LN79@s370_progr
  00273	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00278	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  0027c	b9 ff ff 00 00	 mov	 ecx, 65535		; 0000ffffH
  00281	66 89 88 60 10
	00 00		 mov	 WORD PTR [rax+4192], cx
  00288	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0028d	48 8b 40 40	 mov	 rax, QWORD PTR [rax+64]
  00291	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00297	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170324
  0029e	48 8b c8	 mov	 rcx, rax
  002a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN79@s370_progr:
  002a7	33 c0		 xor	 eax, eax
  002a9	85 c0		 test	 eax, eax
  002ab	75 9f		 jne	 SHORT $LN10@s370_progr
$LN78@s370_progr:
$LN13@s370_progr:

; 694  : 
; 695  :     /* Ensure psw.IA is set and aia invalidated */
; 696  :     INVALIDATE_AIA(realregs);

  002ad	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002b2	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  002ba	74 47		 je	 SHORT $LN80@s370_progr
  002bc	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002c1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  002c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  002cc	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  002d1	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  002d8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002dc	48 2b ca	 sub	 rcx, rdx
  002df	48 03 c1	 add	 rax, rcx
  002e2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  002e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  002ed	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  002f3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  002f8	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN80@s370_progr:
  00303	33 c0		 xor	 eax, eax
  00305	85 c0		 test	 eax, eax
  00307	75 a4		 jne	 SHORT $LN13@s370_progr

; 697  : 
; 698  : #if defined( FEATURE_SIE )
; 699  :     if (realregs->sie_active)
; 700  :         ARCH_DEP( invalidate_guest_aia )( GUEST( realregs ));
; 701  : #endif
; 702  : 
; 703  :     /* Fix PSW and get instruction length (ilc) */
; 704  :     ilc = ARCH_DEP( fix_program_interrupt_PSW )( realregs );

  00309	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0030e	e8 00 00 00 00	 call	 s370_fix_program_interrupt_PSW
  00313	89 84 24 80 00
	00 00		 mov	 DWORD PTR ilc$[rsp], eax
$LN16@s370_progr:

; 705  : 
; 706  :     PTT_PGM( "PGM ilc", 0, 0, ilc );

  0031a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00321	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00324	48 83 e0 20	 and	 rax, 32			; 00000020H
  00328	48 85 c0	 test	 rax, rax
  0032b	74 3a		 je	 SHORT $LN81@s370_progr
  0032d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00335	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0033e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00343	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170327
  0034a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034f	45 33 c9	 xor	 r9d, r9d
  00352	45 33 c0	 xor	 r8d, r8d
  00355	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170328
  0035c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN81@s370_progr:
  00367	33 c0		 xor	 eax, eax
  00369	85 c0		 test	 eax, eax
  0036b	75 ad		 jne	 SHORT $LN16@s370_progr

; 707  : 
; 708  : #if defined( FEATURE_SIE )
; 709  :     if (realregs->sie_active)
; 710  :     {
; 711  :         sie_ilc = GUEST( realregs )->psw.zeroilc ? 0 : REAL_ILC( GUEST( realregs ));
; 712  :         if (GUEST( realregs )->psw.ilc == 0 && !GUEST( realregs )->psw.zeroilc)
; 713  :         {
; 714  :             sie_ilc = likely( !GUEST( realregs )->execflag) ? 2 : GUEST( realregs )->exrl ? 6 : 4;
; 715  :             GUEST( realregs )->psw.ilc  = sie_ilc;
; 716  :         }
; 717  : 
; 718  :         PTT_PGM( "PGM sie_ilc", 0, 0, sie_ilc );
; 719  :     }
; 720  : #endif
; 721  : 
; 722  :     /* Trace the program interrupt right away */
; 723  :     ARCH_DEP( trace_program_interrupt )( regs, pcode, ilc );

  0036d	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR ilc$[rsp]
  00375	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  0037c	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	e8 00 00 00 00	 call	 s370_trace_program_interrupt

; 724  : 
; 725  :     /* Remove PER indication from program interrupt code
; 726  :        such that interrupt code specific tests may be done.
; 727  :        The PER indication will be stored in the PER handling
; 728  :        code */
; 729  :     code = pcode & ~PGM_PER_EVENT;

  00389	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  00390	0f ba f0 07	 btr	 eax, 7
  00394	89 44 24 78	 mov	 DWORD PTR code$[rsp], eax
$LN19@s370_progr:

; 730  : 
; 731  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 732  : 
; 733  :     /* If transaction is active, check if interrupt can be filtered */
; 734  :     if (realregs->txf_tnd)
; 735  :     {
; 736  :         /* Indicate TXF related program interrupt */
; 737  :         pcode |= PGM_TXF_EVENT;
; 738  : 
; 739  :         /* Always reset the NTSTG indicator on any program interrupt */
; 740  :         regs->txf_NTSTG = false;
; 741  : 
; 742  :         /* Save the program interrupt and data exception codes */
; 743  :         realregs->txf_piid   = pcode;
; 744  :         realregs->txf_piid  |= (ilc << 16);
; 745  : 
; 746  :         realregs->txf_dxc_vxc =
; 747  :         (0
; 748  :             || pcode == PGM_DATA_EXCEPTION
; 749  :             || pcode == PGM_VECTOR_PROCESSING_EXCEPTION
; 750  :         )
; 751  :         ?  realregs->dxc : 0;
; 752  : 
; 753  :         PTT_TXF( "TXF PIID", realregs->txf_piid, realregs->txf_dxc_vxc, 0 );
; 754  : 
; 755  :         /* 'txf_do_pi_filtering' does not return for filterable
; 756  :             program interrupts. It returns only if the program
; 757  :             interrupt is unfilterable, and when it returns, the
; 758  :             active transaction has already been aborted.
; 759  :         */
; 760  :         PTT_TXF( "TXF PROG?", (code & 0xFF), realregs->txf_contran, realregs->txf_tnd );
; 761  :         ARCH_DEP( txf_do_pi_filtering )( realregs, pcode );
; 762  : 
; 763  :         if (realregs->txf_tnd ) // (sanity check)
; 764  :             CRASH();            // (sanity check)
; 765  : 
; 766  :         PTT_TXF( "*TXF UPROG!", (code & 0xFF), 0, 0 );
; 767  : 
; 768  :         /* Set flag for sie_exit */
; 769  :         realregs->txf_UPGM_abort = true;
; 770  :     }
; 771  :     else /* (no transaction is CURRENTLY active) */
; 772  :     {
; 773  :         /* While no transaction is CURRENTLY active, it's possible
; 774  :            that a previously active transaction was aborted BEFORE
; 775  :            we were called, so we need to check for that.
; 776  :         */
; 777  :         if ((code & 0xFF) == PGM_TRANSACTION_CONSTRAINT_EXCEPTION)
; 778  :         {
; 779  :             /* Indicate TXF related program interrupt */
; 780  :             pcode |= PGM_TXF_EVENT;
; 781  : 
; 782  :             PTT_TXF( "*TXF 218!", pcode, 0, 0 );
; 783  : 
; 784  :             /* Set flag for sie_exit */
; 785  :             realregs->txf_UPGM_abort = true;
; 786  :         }
; 787  :     }
; 788  : #endif /* defined( FEATURE_073_TRANSACT_EXEC_FACILITY ) */
; 789  : 
; 790  :     /* Set 'execflag' to 0 in case EXecuted instruction program-checked */
; 791  : 
; 792  :     PTT_PGM( "PGM execflag", realregs->execflag, realregs->sie_active, 0 );

  00398	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0039f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a2	48 83 e0 20	 and	 rax, 32			; 00000020H
  003a6	48 85 c0	 test	 rax, rax
  003a9	74 56		 je	 SHORT $LN82@s370_progr
  003ab	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  003b0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003b6	83 e0 01	 and	 eax, 1
  003b9	8b c0		 mov	 eax, eax
  003bb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  003c0	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  003c6	83 e1 01	 and	 ecx, 1
  003c9	8b c9		 mov	 ecx, ecx
  003cb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003d4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170330
  003e4	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003e9	44 8b c8	 mov	 r9d, eax
  003ec	44 8b c1	 mov	 r8d, ecx
  003ef	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170331
  003f6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN82@s370_progr:
  00401	33 c0		 xor	 eax, eax
  00403	85 c0		 test	 eax, eax
  00405	75 91		 jne	 SHORT $LN19@s370_progr

; 793  :     realregs->execflag = 0;

  00407	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0040c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00412	83 e0 fe	 and	 eax, -2			; fffffffeH
  00415	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0041a	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN22@s370_progr:

; 794  : 
; 795  : #if defined( FEATURE_SIE )
; 796  :     if (realregs->sie_active)
; 797  :         GUEST( realregs )->execflag = 0;
; 798  : #endif
; 799  :     PTT_PGM( "PGM execflag", realregs->execflag, realregs->sie_active, 0 );

  00420	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00427	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0042a	48 83 e0 20	 and	 rax, 32			; 00000020H
  0042e	48 85 c0	 test	 rax, rax
  00431	74 56		 je	 SHORT $LN83@s370_progr
  00433	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00438	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0043e	83 e0 01	 and	 eax, 1
  00441	8b c0		 mov	 eax, eax
  00443	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00448	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0044e	83 e1 01	 and	 ecx, 1
  00451	8b c9		 mov	 ecx, ecx
  00453	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0045c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00465	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170333
  0046c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00471	44 8b c8	 mov	 r9d, eax
  00474	44 8b c1	 mov	 r8d, ecx
  00477	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170334
  0047e	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN83@s370_progr:
  00489	33 c0		 xor	 eax, eax
  0048b	85 c0		 test	 eax, eax
  0048d	75 91		 jne	 SHORT $LN22@s370_progr

; 800  : 
; 801  :     /* If this is a concurrent PER event
; 802  :        then we must add the PER bit to the interrupts code */
; 803  :     if (OPEN_IC_PER (realregs ))

  0048f	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00494	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00499	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0049c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0049f	23 c1		 and	 eax, ecx
  004a1	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  004a6	85 c0		 test	 eax, eax
  004a8	74 12		 je	 SHORT $LN84@s370_progr

; 804  :         pcode |= PGM_PER_EVENT;

  004aa	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  004b1	0f ba e8 07	 bts	 eax, 7
  004b5	89 84 24 c8 01
	00 00		 mov	 DWORD PTR pcode$[rsp], eax
$LN84@s370_progr:

; 805  : 
; 806  :     /* Perform serialization and checkpoint synchronization */
; 807  :     PERFORM_SERIALIZATION( realregs );

  004bc	0f ae f0	 mfence
$LN25@s370_progr:

; 808  :     PERFORM_CHKPT_SYNC( realregs );

  004bf	33 c0		 xor	 eax, eax
  004c1	85 c0		 test	 eax, eax
  004c3	75 fa		 jne	 SHORT $LN25@s370_progr
$LN28@s370_progr:

; 809  : 
; 810  : #if defined( FEATURE_SIE )
; 811  :     /* Host protection and addressing exceptions
; 812  :        must be reflected to the guest */
; 813  :     if (1
; 814  :         && realregs->sie_active
; 815  :         && (0
; 816  :             || code == PGM_PROTECTION_EXCEPTION
; 817  :             || code == PGM_ADDRESSING_EXCEPTION
; 818  : 
; 819  : #if defined( _FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 820  :             || code == PGM_ALET_SPECIFICATION_EXCEPTION
; 821  :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 822  :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 823  :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 824  : #endif
; 825  :            )
; 826  :     )
; 827  :     {
; 828  :         /* Pass this interrupt to the guest */
; 829  : #if defined( SIE_DEBUG )
; 830  :         LOGMSG( "program_int() passing to guest code=%4.4X\n", pcode );
; 831  : #endif
; 832  :         switch (GUEST( realregs )->arch_mode)
; 833  :         {
; 834  :         case ARCH_370_IDX: GUEST( realregs )->TEA_370 = realregs->TEA; break;
; 835  :         case ARCH_390_IDX: GUEST( realregs )->TEA_390 = realregs->TEA; break;
; 836  :         case ARCH_900_IDX: GUEST( realregs )->TEA_900 = realregs->TEA; break;
; 837  :         default: CRASH();
; 838  :         }
; 839  : 
; 840  :         GUEST( realregs )->excarid = realregs->excarid;
; 841  :         GUEST( realregs )->opndrid = realregs->opndrid;
; 842  : 
; 843  : #if defined(_FEATURE_PROTECTION_INTERCEPTION_CONTROL)
; 844  :         GUEST( realregs )->hostint = 1;
; 845  : #endif
; 846  :         GUEST( realregs )->program_interrupt( GUEST( realregs ), pcode );
; 847  :     }
; 848  : #endif /* defined( FEATURE_SIE ) */
; 849  : 
; 850  :     /* Back up the PSW for exceptions which cause nullification,
; 851  :        unless the exception occurred during instruction fetch
; 852  :     */
; 853  :     PTT_PGM( "PGM psw.IA", realregs->psw.IA, realregs->instinvalid, ilc );

  004c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004cf	48 83 e0 20	 and	 rax, 32			; 00000020H
  004d3	48 85 c0	 test	 rax, rax
  004d6	74 58		 je	 SHORT $LN85@s370_progr
  004d8	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  004e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  004e5	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  004eb	c1 e9 03	 shr	 ecx, 3
  004ee	83 e1 01	 and	 ecx, 1
  004f1	8b c9		 mov	 ecx, ecx
  004f3	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  004f8	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  004fe	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00507	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0050c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170337
  00513	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00518	44 8b c9	 mov	 r9d, ecx
  0051b	44 8b c2	 mov	 r8d, edx
  0051e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170338
  00525	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0052a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN85@s370_progr:
  00530	33 c0		 xor	 eax, eax
  00532	85 c0		 test	 eax, eax
  00534	75 8f		 jne	 SHORT $LN28@s370_progr

; 854  :     if (1
; 855  :         && !realregs->instinvalid
; 856  :         && (0

  00536	33 c0		 xor	 eax, eax
  00538	83 f8 01	 cmp	 eax, 1
  0053b	0f 84 92 01 00
	00		 je	 $LN86@s370_progr
  00541	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00546	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0054c	c1 e8 03	 shr	 eax, 3
  0054f	83 e0 01	 and	 eax, 1
  00552	85 c0		 test	 eax, eax
  00554	0f 85 79 01 00
	00		 jne	 $LN86@s370_progr
  0055a	33 c0		 xor	 eax, eax
  0055c	85 c0		 test	 eax, eax
  0055e	0f 85 c4 00 00
	00		 jne	 $LN87@s370_progr
  00564	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  00569	0f 84 b9 00 00
	00		 je	 $LN87@s370_progr
  0056f	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  00574	0f 84 ae 00 00
	00		 je	 $LN87@s370_progr
  0057a	83 7c 24 78 16	 cmp	 DWORD PTR code$[rsp], 22
  0057f	0f 84 a3 00 00
	00		 je	 $LN87@s370_progr
  00585	83 7c 24 78 20	 cmp	 DWORD PTR code$[rsp], 32 ; 00000020H
  0058a	0f 84 98 00 00
	00		 je	 $LN87@s370_progr
  00590	83 7c 24 78 21	 cmp	 DWORD PTR code$[rsp], 33 ; 00000021H
  00595	0f 84 8d 00 00
	00		 je	 $LN87@s370_progr
  0059b	83 7c 24 78 22	 cmp	 DWORD PTR code$[rsp], 34 ; 00000022H
  005a0	0f 84 82 00 00
	00		 je	 $LN87@s370_progr
  005a6	83 7c 24 78 26	 cmp	 DWORD PTR code$[rsp], 38 ; 00000026H
  005ab	74 7b		 je	 SHORT $LN87@s370_progr
  005ad	83 7c 24 78 27	 cmp	 DWORD PTR code$[rsp], 39 ; 00000027H
  005b2	74 74		 je	 SHORT $LN87@s370_progr
  005b4	83 7c 24 78 2e	 cmp	 DWORD PTR code$[rsp], 46 ; 0000002eH
  005b9	74 6d		 je	 SHORT $LN87@s370_progr
  005bb	83 7c 24 78 23	 cmp	 DWORD PTR code$[rsp], 35 ; 00000023H
  005c0	74 66		 je	 SHORT $LN87@s370_progr
  005c2	83 7c 24 78 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  005c7	74 5f		 je	 SHORT $LN87@s370_progr
  005c9	83 7c 24 78 25	 cmp	 DWORD PTR code$[rsp], 37 ; 00000025H
  005ce	74 58		 je	 SHORT $LN87@s370_progr
  005d0	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  005d5	74 51		 je	 SHORT $LN87@s370_progr
  005d7	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  005dc	74 4a		 je	 SHORT $LN87@s370_progr
  005de	83 7c 24 78 2b	 cmp	 DWORD PTR code$[rsp], 43 ; 0000002bH
  005e3	74 43		 je	 SHORT $LN87@s370_progr
  005e5	83 7c 24 78 2c	 cmp	 DWORD PTR code$[rsp], 44 ; 0000002cH
  005ea	74 3c		 je	 SHORT $LN87@s370_progr
  005ec	83 7c 24 78 2f	 cmp	 DWORD PTR code$[rsp], 47 ; 0000002fH
  005f1	74 35		 je	 SHORT $LN87@s370_progr
  005f3	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  005f8	74 2e		 je	 SHORT $LN87@s370_progr
  005fa	83 7c 24 78 30	 cmp	 DWORD PTR code$[rsp], 48 ; 00000030H
  005ff	74 27		 je	 SHORT $LN87@s370_progr
  00601	83 7c 24 78 31	 cmp	 DWORD PTR code$[rsp], 49 ; 00000031H
  00606	74 20		 je	 SHORT $LN87@s370_progr
  00608	83 7c 24 78 32	 cmp	 DWORD PTR code$[rsp], 50 ; 00000032H
  0060d	74 19		 je	 SHORT $LN87@s370_progr
  0060f	83 7c 24 78 33	 cmp	 DWORD PTR code$[rsp], 51 ; 00000033H
  00614	74 12		 je	 SHORT $LN87@s370_progr
  00616	83 7c 24 78 34	 cmp	 DWORD PTR code$[rsp], 52 ; 00000034H
  0061b	74 0b		 je	 SHORT $LN87@s370_progr
  0061d	83 7c 24 78 19	 cmp	 DWORD PTR code$[rsp], 25
  00622	0f 85 ab 00 00
	00		 jne	 $LN86@s370_progr
$LN87@s370_progr:

; 857  :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 858  :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 859  : 
; 860  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 861  :             || code == PGM_ASCE_TYPE_EXCEPTION
; 862  :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 863  :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 864  :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 865  : #endif
; 866  :             || code == PGM_TRACE_TABLE_EXCEPTION
; 867  :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 868  :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 869  :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 870  :             || code == PGM_LFX_TRANSLATION_EXCEPTION
; 871  :             || code == PGM_LSX_TRANSLATION_EXCEPTION
; 872  :             || code == PGM_LSTE_SEQUENCE_EXCEPTION
; 873  :             || code == PGM_EX_TRANSLATION_EXCEPTION
; 874  :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 875  :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 876  :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 877  :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 878  :             || code == PGM_ASTE_VALIDITY_EXCEPTION
; 879  :             || code == PGM_ASTE_SEQUENCE_EXCEPTION
; 880  :             || code == PGM_ASTE_INSTANCE_EXCEPTION
; 881  :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION
; 882  :             || code == PGM_STACK_FULL_EXCEPTION
; 883  :             || code == PGM_STACK_EMPTY_EXCEPTION
; 884  :             || code == PGM_STACK_SPECIFICATION_EXCEPTION
; 885  :             || code == PGM_STACK_TYPE_EXCEPTION
; 886  :             || code == PGM_STACK_OPERATION_EXCEPTION
; 887  :             || code == PGM_VECTOR_OPERATION_EXCEPTION
; 888  :            )
; 889  :     )
; 890  :     {
; 891  :         realregs->psw.IA -= ilc;

  00628	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0062d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00634	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0063a	2b c1		 sub	 eax, ecx
  0063c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00641	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 892  :         realregs->psw.IA &= ADDRESS_MAXWRAP(realregs);

  00647	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0064c	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00652	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00657	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0065c	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN31@s370_progr:

; 893  : 
; 894  :         PTT_PGM( "PGM IA-ilc", realregs->psw.IA, realregs->instinvalid, ilc );

  00662	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00669	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0066c	48 83 e0 20	 and	 rax, 32			; 00000020H
  00670	48 85 c0	 test	 rax, rax
  00673	74 58		 je	 SHORT $LN88@s370_progr
  00675	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0067d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00682	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00688	c1 e9 03	 shr	 ecx, 3
  0068b	83 e1 01	 and	 ecx, 1
  0068e	8b c9		 mov	 ecx, ecx
  00690	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00695	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  0069b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  006a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170342
  006b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006b5	44 8b c9	 mov	 r9d, ecx
  006b8	44 8b c2	 mov	 r8d, edx
  006bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170343
  006c2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  006c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN88@s370_progr:
  006cd	33 c0		 xor	 eax, eax
  006cf	85 c0		 test	 eax, eax
  006d1	75 8f		 jne	 SHORT $LN31@s370_progr
$LN86@s370_progr:

; 895  : 
; 896  : #if defined( FEATURE_SIE )
; 897  :         /* When in SIE mode the guest instruction
; 898  :            causing this host exception must also be nullified
; 899  :         */
; 900  :         if (realregs->sie_active && !GUEST( realregs )->instinvalid)
; 901  :             ARCH_DEP( update_guest_psw_ia )( GUEST( realregs ), -sie_ilc );
; 902  : #endif
; 903  :     }
; 904  : 
; 905  :     /* The OLD PSW must be incremented
; 906  :        on the following exceptions during instfetch
; 907  :     */
; 908  :     if (1
; 909  :         && realregs->instinvalid
; 910  :         && (0

  006d3	33 c0		 xor	 eax, eax
  006d5	83 f8 01	 cmp	 eax, 1
  006d8	0f 84 e8 00 00
	00		 je	 $LN89@s370_progr
  006de	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  006e3	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006e9	c1 e8 03	 shr	 eax, 3
  006ec	83 e0 01	 and	 eax, 1
  006ef	85 c0		 test	 eax, eax
  006f1	0f 84 cf 00 00
	00		 je	 $LN89@s370_progr
  006f7	33 c0		 xor	 eax, eax
  006f9	85 c0		 test	 eax, eax
  006fb	75 20		 jne	 SHORT $LN90@s370_progr
  006fd	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  00702	74 19		 je	 SHORT $LN90@s370_progr
  00704	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  00709	74 12		 je	 SHORT $LN90@s370_progr
  0070b	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  00710	74 0b		 je	 SHORT $LN90@s370_progr
  00712	83 7c 24 78 12	 cmp	 DWORD PTR code$[rsp], 18
  00717	0f 85 a9 00 00
	00		 jne	 $LN89@s370_progr
$LN90@s370_progr:

; 911  :             || code == PGM_PROTECTION_EXCEPTION
; 912  :             || code == PGM_ADDRESSING_EXCEPTION
; 913  :             || code == PGM_SPECIFICATION_EXCEPTION
; 914  :             || code == PGM_TRANSLATION_SPECIFICATION_EXCEPTION
; 915  :            )
; 916  :     )
; 917  :     {
; 918  :         realregs->psw.IA += ilc;

  0071d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00722	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00728	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR ilc$[rsp]
  0072f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00734	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 919  :         realregs->psw.IA &= ADDRESS_MAXWRAP( realregs );

  0073a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0073f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00745	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0074a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0074f	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN34@s370_progr:

; 920  : 
; 921  :         PTT_PGM( "PGM IA+ilc", realregs->psw.IA, realregs->instinvalid, ilc );

  00755	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0075c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0075f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00763	48 85 c0	 test	 rax, rax
  00766	74 58		 je	 SHORT $LN91@s370_progr
  00768	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00770	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00775	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0077b	c1 e9 03	 shr	 ecx, 3
  0077e	83 e1 01	 and	 ecx, 1
  00781	8b c9		 mov	 ecx, ecx
  00783	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00788	8b 92 88 00 00
	00		 mov	 edx, DWORD PTR [rdx+136]
  0078e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00797	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0079c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170347
  007a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007a8	44 8b c9	 mov	 r9d, ecx
  007ab	44 8b c2	 mov	 r8d, edx
  007ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170348
  007b5	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  007ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN91@s370_progr:
  007c0	33 c0		 xor	 eax, eax
  007c2	85 c0		 test	 eax, eax
  007c4	75 8f		 jne	 SHORT $LN34@s370_progr
$LN89@s370_progr:

; 922  :     }
; 923  : 
; 924  :     /* Store the interrupt code in the PSW */
; 925  :     realregs->psw.intcode = pcode;

  007c6	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  007cb	0f b7 8c 24 c8
	01 00 00	 movzx	 ecx, WORD PTR pcode$[rsp]
  007d3	66 89 88 98 00
	00 00		 mov	 WORD PTR [rax+152], cx

; 926  : 
; 927  :     /* Call debugger if active */
; 928  :     HDC2( debug_program_interrupt, regs, pcode );

  007da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_program_interrupt
  007e1	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  007e5	74 22		 je	 SHORT $LN164@s370_progr
  007e7	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  007ee	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_program_interrupt
  007fd	ff 10		 call	 QWORD PTR [rax]
  007ff	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv369[rsp], rax
  00807	eb 0c		 jmp	 SHORT $LN165@s370_progr
$LN164@s370_progr:
  00809	48 c7 84 24 c0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv369[rsp], 0
$LN165@s370_progr:

; 929  : 
; 930  :     realregs->instinvalid = 0;

  00815	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0081a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00820	83 e0 f7	 and	 eax, -9			; fffffff7H
  00823	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00828	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN37@s370_progr:

; 931  :     PTT_PGM( "PGM inval=0", 0, 0, 0 );

  0082e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00835	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00838	48 83 e0 20	 and	 rax, 32			; 00000020H
  0083c	48 85 c0	 test	 rax, rax
  0083f	74 36		 je	 SHORT $LN92@s370_progr
  00841	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0084a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00853	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170350
  0085a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0085f	45 33 c9	 xor	 r9d, r9d
  00862	45 33 c0	 xor	 r8d, r8d
  00865	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170351
  0086c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00871	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN92@s370_progr:
  00877	33 c0		 xor	 eax, eax
  00879	85 c0		 test	 eax, eax
  0087b	75 b1		 jne	 SHORT $LN37@s370_progr

; 932  : 
; 933  : #if defined( FEATURE_SIE )
; 934  : 
; 935  :     /*---------------------------------------------------------*/
; 936  :     /* If this is a host exception in SIE state then leave SIE */
; 937  :     /*---------------------------------------------------------*/
; 938  :     if (realregs->sie_active)
; 939  :     {
; 940  :         PTT_PGM( "PGM >sie_exit", SIE_HOST_PGM_INT, 0, 0 );
; 941  :         ARCH_DEP( sie_exit )( realregs, SIE_HOST_PGM_INT );
; 942  :     }
; 943  : #endif
; 944  : 
; 945  :     /* Absolute address of prefix page */
; 946  :     px = realregs->PX;

  0087d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00882	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00885	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR px$[rsp], rax

; 947  : 
; 948  :     /* If under SIE use translated to host absolute prefix */
; 949  : #if defined( _FEATURE_SIE )
; 950  :     if (SIE_MODE( regs ))

  0088d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00895	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0089b	d1 e8		 shr	 eax, 1
  0089d	83 e0 01	 and	 eax, 1
  008a0	85 c0		 test	 eax, eax
  008a2	74 17		 je	 SHORT $LN93@s370_progr

; 951  :         px = regs->sie_px;

  008a4	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ac	48 8b 80 90 08
	00 00		 mov	 rax, QWORD PTR [rax+2192]
  008b3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR px$[rsp], rax
$LN93@s370_progr:

; 952  : #endif
; 953  : 
; 954  : #if defined( _FEATURE_SIE )
; 955  :     /*---------------------------------------------------------------*/
; 956  :     /*   If we're in SIE mode, then we need to determine whether     */
; 957  :     /*   we must, or must not, intercept this program interrupt,     */
; 958  :     /*   and by intercept, we mean pass it on to the SIE host so     */
; 959  :     /*   that it (not the guest!) can decide what action to take.    */
; 960  :     /*---------------------------------------------------------------*/
; 961  :     if (0
; 962  : 
; 963  :         /* If not in SIE mode, then we (duh!) must not intercept it  */
; 964  :         || !SIE_MODE( regs )
; 965  : 
; 966  :         /* Interception is mandatory for the following exceptions,
; 967  :            so if ANY of the below conditions are false, then we MUST
; 968  :            intercept this program interrupt.
; 969  : 
; 970  :            The below tests/checks are for "not this condition" where
; 971  :            the "condition" is the condition which we MUST intercept.
; 972  :            Thus if any of them fail, then we MUST intercept.
; 973  : 
; 974  :            Only if ALL of them are true (only if no condition exists
; 975  :            that REQUIRES an intercept) should we then NOT intercept.
; 976  :         */
; 977  :         || (1

  008bb	33 c0		 xor	 eax, eax
  008bd	85 c0		 test	 eax, eax
  008bf	0f 85 bb 01 00
	00		 jne	 $LN96@s370_progr
  008c5	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008cd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  008d3	d1 e8		 shr	 eax, 1
  008d5	83 e0 01	 and	 eax, 1
  008d8	85 c0		 test	 eax, eax
  008da	0f 84 a0 01 00
	00		 je	 $LN96@s370_progr
  008e0	33 c0		 xor	 eax, eax
  008e2	83 f8 01	 cmp	 eax, 1
  008e5	0f 84 21 02 00
	00		 je	 $LN94@s370_progr
  008eb	83 7c 24 78 05	 cmp	 DWORD PTR code$[rsp], 5
  008f0	0f 84 16 02 00
	00		 je	 $LN94@s370_progr
  008f6	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  008fb	0f 84 0b 02 00
	00		 je	 $LN94@s370_progr
  00901	83 7c 24 78 13	 cmp	 DWORD PTR code$[rsp], 19
  00906	0f 84 00 02 00
	00		 je	 $LN94@s370_progr
  0090c	83 7c 24 78 07	 cmp	 DWORD PTR code$[rsp], 7
  00911	75 6f		 jne	 SHORT $LN97@s370_progr
  00913	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0091b	83 b8 08 07 00
	00 01		 cmp	 DWORD PTR [rax+1800], 1
  00922	74 11		 je	 SHORT $LN98@s370_progr
  00924	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0092c	83 b8 08 07 00
	00 02		 cmp	 DWORD PTR [rax+1800], 2
  00933	75 4d		 jne	 SHORT $LN97@s370_progr
$LN98@s370_progr:
  00935	b8 08 00 00 00	 mov	 eax, 8
  0093a	48 6b c0 01	 imul	 rax, rax, 1
  0093e	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00946	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0094d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00952	85 c0		 test	 eax, eax
  00954	74 2c		 je	 SHORT $LN97@s370_progr
  00956	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0095e	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00965	b9 08 00 00 00	 mov	 ecx, 8
  0096a	48 6b c9 01	 imul	 rcx, rcx, 1
  0096e	8b 84 08 00 06
	00 00		 mov	 eax, DWORD PTR [rax+rcx+1536]
  00975	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0097a	85 c0		 test	 eax, eax
  0097c	0f 84 8a 01 00
	00		 je	 $LN94@s370_progr
$LN97@s370_progr:
  00982	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0098a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00991	b9 01 00 00 00	 mov	 ecx, 1
  00996	48 6b c9 00	 imul	 rcx, rcx, 0
  0099a	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  0099f	83 e0 20	 and	 eax, 32			; 00000020H
  009a2	85 c0		 test	 eax, eax
  009a4	0f 85 62 01 00
	00		 jne	 $LN94@s370_progr
  009aa	83 7c 24 78 04	 cmp	 DWORD PTR code$[rsp], 4
  009af	75 41		 jne	 SHORT $LN99@s370_progr
  009b1	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009b9	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009c0	b9 01 00 00 00	 mov	 ecx, 1
  009c5	48 6b c9 02	 imul	 rcx, rcx, 2
  009c9	0f b6 44 08 4c	 movzx	 eax, BYTE PTR [rax+rcx+76]
  009ce	83 e0 20	 and	 eax, 32			; 00000020H
  009d1	85 c0		 test	 eax, eax
  009d3	0f 84 33 01 00
	00		 je	 $LN94@s370_progr
  009d9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  009de	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  009e4	c1 e8 06	 shr	 eax, 6
  009e7	83 e0 01	 and	 eax, 1
  009ea	85 c0		 test	 eax, eax
  009ec	0f 85 1a 01 00
	00		 jne	 $LN94@s370_progr
$LN99@s370_progr:
  009f2	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  009f9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  009fe	85 c0		 test	 eax, eax
  00a00	74 1e		 je	 SHORT $LN100@s370_progr
  00a02	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0a	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a11	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00a15	83 e0 01	 and	 eax, 1
  00a18	85 c0		 test	 eax, eax
  00a1a	0f 85 ec 00 00
	00		 jne	 $LN94@s370_progr
$LN100@s370_progr:
  00a20	83 7c 24 78 01	 cmp	 DWORD PTR code$[rsp], 1
  00a25	75 2a		 jne	 SHORT $LN101@s370_progr
  00a27	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a2f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a36	b9 01 00 00 00	 mov	 ecx, 1
  00a3b	48 6b c9 00	 imul	 rcx, rcx, 0
  00a3f	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  00a44	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00a49	85 c0		 test	 eax, eax
  00a4b	0f 85 bb 00 00
	00		 jne	 $LN94@s370_progr
$LN101@s370_progr:
  00a51	83 7c 24 78 02	 cmp	 DWORD PTR code$[rsp], 2
  00a56	75 28		 jne	 SHORT $LN102@s370_progr
  00a58	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a60	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a67	b9 01 00 00 00	 mov	 ecx, 1
  00a6c	48 6b c9 00	 imul	 rcx, rcx, 0
  00a70	0f b6 44 08 48	 movzx	 eax, BYTE PTR [rax+rcx+72]
  00a75	83 e0 40	 and	 eax, 64			; 00000040H
  00a78	85 c0		 test	 eax, eax
  00a7a	0f 85 8c 00 00
	00		 jne	 $LN94@s370_progr
$LN102@s370_progr:
$LN96@s370_progr:

; 978  : 
; 979  :             && code != PGM_ADDRESSING_EXCEPTION
; 980  :             && code != PGM_SPECIFICATION_EXCEPTION
; 981  :             && code != PGM_SPECIAL_OPERATION_EXCEPTION
; 982  : 
; 983  : #if defined( FEATURE_S370_S390_VECTOR_FACILITY )
; 984  :             && code != PGM_VECTOR_OPERATION_EXCEPTION
; 985  : #endif
; 986  : #ifdef FEATURE_BASIC_FP_EXTENSIONS
; 987  :             && !(code == PGM_DATA_EXCEPTION && (regs->dxc == 1 || regs->dxc == 2) && (regs->CR(0) & CR0_AFP) && !(HOSTREGS->CR(0) & CR0_AFP))
; 988  : #endif
; 989  :             && !SIE_FEAT_BIT_ON( regs, IC0, PGMALL )
; 990  : 
; 991  : #if !defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 992  :             && code != PGM_PROTECTION_EXCEPTION
; 993  : #else
; 994  :             && !(code == PGM_PROTECTION_EXCEPTION           && (!SIE_FEAT_BIT_ON( regs, EC2, PROTEX ) || realregs->hostint ))
; 995  : #endif
; 996  : #if defined( _FEATURE_PER2 )
; 997  :             && !((pcode & PGM_PER_EVENT)                    && SIE_FEAT_BIT_ON( regs, M, GPE ))
; 998  : #endif
; 999  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 1000 :             && !(code == PGM_ALEN_TRANSLATION_EXCEPTION     && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1001 :             && !(code == PGM_ALE_SEQUENCE_EXCEPTION         && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1002 :             && !(code == PGM_EXTENDED_AUTHORITY_EXCEPTION   && SIE_FEAT_BIT_ON( regs, MX, XC ))
; 1003 : #endif
; 1004 :             && !(code == PGM_OPERATION_EXCEPTION            && SIE_FEAT_BIT_ON( regs, IC0, OPEREX ))
; 1005 :             && !(code == PGM_PRIVILEGED_OPERATION_EXCEPTION && SIE_FEAT_BIT_ON( regs, IC0, PRIVOP ))
; 1006 :            )
; 1007 :     )
; 1008 :     {
; 1009 : #endif /*defined(_FEATURE_SIE)*/
; 1010 : 
; 1011 :         intercept = false;

  00a80	c6 44 24 7c 00	 mov	 BYTE PTR intercept$[rsp], 0
$LN40@s370_progr:

; 1012 :         PTT_PGM( "PGM !icept", intercept, 0, 0 );

  00a85	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00a8c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00a8f	48 83 e0 20	 and	 rax, 32			; 00000020H
  00a93	48 85 c0	 test	 rax, rax
  00a96	74 3b		 je	 SHORT $LN103@s370_progr
  00a98	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  00a9d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00aa6	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00aaf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170363
  00ab6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00abb	45 33 c9	 xor	 r9d, r9d
  00abe	44 8b c0	 mov	 r8d, eax
  00ac1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170364
  00ac8	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00acd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN103@s370_progr:
  00ad3	33 c0		 xor	 eax, eax
  00ad5	85 c0		 test	 eax, eax
  00ad7	75 ac		 jne	 SHORT $LN40@s370_progr

; 1013 : 
; 1014 :         /* Set the main storage reference and change bits */
; 1015 :         ARCH_DEP( or_storage_key )( px, (STORKEY_REF | STORKEY_CHANGE) );

  00ad9	b2 06		 mov	 dl, 6
  00adb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR px$[rsp]
  00ae3	e8 00 00 00 00	 call	 s370_or_storage_key

; 1016 : 
; 1017 :         /* Point to PSA in main storage */
; 1018 :         psa = (void*)(regs->mainstor + px);

  00ae8	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00af0	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00af7	48 03 84 24 a0
	00 00 00	 add	 rax, QWORD PTR px$[rsp]
  00aff	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1019 : 
; 1020 : #if defined( _FEATURE_SIE )
; 1021 : 
; 1022 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1023 :         /** FIXME : SEE ISW20090110-1 */
; 1024 :         if (code == PGM_MONITOR_EVENT)
; 1025 :         {
; 1026 :             zmoncode = psa->moncode;
; 1027 :         }
; 1028 : #endif
; 1029 :     }

  00b07	e9 d8 00 00 00	 jmp	 $LN95@s370_progr
$LN94@s370_progr:

; 1030 :     else /* The SIE host must deal with this program interrupt */
; 1031 :     {
; 1032 :         intercept = true;

  00b0c	c6 44 24 7c 01	 mov	 BYTE PTR intercept$[rsp], 1
$LN43@s370_progr:

; 1033 :         PTT_PGM( "PGM icept", intercept, 0, 0 );

  00b11	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00b18	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b1b	48 83 e0 20	 and	 rax, 32			; 00000020H
  00b1f	48 85 c0	 test	 rax, rax
  00b22	74 3b		 je	 SHORT $LN104@s370_progr
  00b24	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  00b29	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b32	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00b3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170366
  00b42	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00b47	45 33 c9	 xor	 r9d, r9d
  00b4a	44 8b c0	 mov	 r8d, eax
  00b4d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170367
  00b54	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00b59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN104@s370_progr:
  00b5f	33 c0		 xor	 eax, eax
  00b61	85 c0		 test	 eax, eax
  00b63	75 ac		 jne	 SHORT $LN43@s370_progr

; 1034 : 
; 1035 :         /* This is a guest interruption interception so point to
; 1036 :            the interruption parm area in the state descriptor
; 1037 :            rather then the PSA (except for Operation Exception)
; 1038 :         */
; 1039 :         if (code != PGM_OPERATION_EXCEPTION)

  00b65	83 7c 24 78 01	 cmp	 DWORD PTR code$[rsp], 1
  00b6a	74 4a		 je	 SHORT $LN105@s370_progr

; 1040 :         {
; 1041 :             psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_IP_PSA_OFFSET);

  00b6c	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b74	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00b7b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00b82	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b8a	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  00b91	48 8d 44 08 40	 lea	 rax, QWORD PTR [rax+rcx+64]
  00b96	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1042 : 
; 1043 :             /* Set the main storage reference and change bits */
; 1044 :             ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  00b9e	b2 06		 mov	 dl, 6
  00ba0	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba8	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  00baf	e8 00 00 00 00	 call	 s370_or_storage_key

; 1045 : 
; 1046 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1047 :             /** FIXME : SEE ISW20090110-1 */
; 1048 :             if (code == PGM_MONITOR_EVENT)
; 1049 :             {
; 1050 :                 PSA* _psa;
; 1051 :                 _psa = (void *)(HOSTREGS->mainstor + SIE_STATE( regs ) + SIE_II_PSA_OFFSET);
; 1052 :                 zmoncode = _psa->ioid;
; 1053 :             }
; 1054 : #endif
; 1055 :         }

  00bb4	eb 2e		 jmp	 SHORT $LN106@s370_progr
$LN105@s370_progr:

; 1056 :         else
; 1057 :         {
; 1058 :             /* Point to PSA in main storage */
; 1059 :             psa = (void*)(regs->mainstor + px);

  00bb6	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bbe	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00bc5	48 03 84 24 a0
	00 00 00	 add	 rax, QWORD PTR px$[rsp]
  00bcd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1060 : 
; 1061 :             /* Set the main storage reference and change bits */
; 1062 :             ARCH_DEP( or_storage_key )( px, (STORKEY_REF | STORKEY_CHANGE) );

  00bd5	b2 06		 mov	 dl, 6
  00bd7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR px$[rsp]
  00bdf	e8 00 00 00 00	 call	 s370_or_storage_key
$LN106@s370_progr:
$LN95@s370_progr:

; 1063 :         }
; 1064 :     }
; 1065 : #endif /*defined(_FEATURE_SIE)*/
; 1066 : 
; 1067 : #if defined( _FEATURE_PER )
; 1068 :     /* Handle PER or concurrent PER event */
; 1069 : 
; 1070 :     /* Throw out Stor Alter PER if merged with nullified/suppressed rupt */
; 1071 :     if (1
; 1072 :         &&  IS_IC_PER_SA(    realregs )
; 1073 :         && !IS_IC_PER_STURA( realregs )
; 1074 :         && (realregs->ip[0] != 0x0E)
; 1075 :         && !(0

  00be4	33 c0		 xor	 eax, eax
  00be6	83 f8 01	 cmp	 eax, 1
  00be9	0f 84 a0 00 00
	00		 je	 $LN107@s370_progr
  00bef	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00bf4	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00bf7	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00bfc	85 c0		 test	 eax, eax
  00bfe	0f 84 8b 00 00
	00		 je	 $LN107@s370_progr
  00c04	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00c09	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00c0c	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00c11	85 c0		 test	 eax, eax
  00c13	75 7a		 jne	 SHORT $LN107@s370_progr
  00c15	b8 01 00 00 00	 mov	 eax, 1
  00c1a	48 6b c0 00	 imul	 rax, rax, 0
  00c1e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00c23	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00c27	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00c2b	83 f8 0e	 cmp	 eax, 14
  00c2e	74 5f		 je	 SHORT $LN107@s370_progr
  00c30	33 c0		 xor	 eax, eax
  00c32	85 c0		 test	 eax, eax
  00c34	75 59		 jne	 SHORT $LN107@s370_progr
  00c36	83 7c 24 78 00	 cmp	 DWORD PTR code$[rsp], 0
  00c3b	74 52		 je	 SHORT $LN107@s370_progr
  00c3d	83 7c 24 78 06	 cmp	 DWORD PTR code$[rsp], 6
  00c42	74 4b		 je	 SHORT $LN107@s370_progr
  00c44	83 7c 24 78 08	 cmp	 DWORD PTR code$[rsp], 8
  00c49	74 44		 je	 SHORT $LN107@s370_progr
  00c4b	83 7c 24 78 0a	 cmp	 DWORD PTR code$[rsp], 10
  00c50	74 3d		 je	 SHORT $LN107@s370_progr
  00c52	83 7c 24 78 0c	 cmp	 DWORD PTR code$[rsp], 12
  00c57	74 36		 je	 SHORT $LN107@s370_progr
  00c59	83 7c 24 78 0d	 cmp	 DWORD PTR code$[rsp], 13
  00c5e	74 2f		 je	 SHORT $LN107@s370_progr
  00c60	83 7c 24 78 0e	 cmp	 DWORD PTR code$[rsp], 14
  00c65	74 28		 je	 SHORT $LN107@s370_progr
  00c67	83 7c 24 78 1c	 cmp	 DWORD PTR code$[rsp], 28
  00c6c	74 21		 je	 SHORT $LN107@s370_progr
  00c6e	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  00c73	74 1a		 je	 SHORT $LN107@s370_progr
$LN46@s370_progr:

; 1076 :              || code == 0x00
; 1077 :              || code == PGM_SPECIFICATION_EXCEPTION
; 1078 :              || code == PGM_FIXED_POINT_OVERFLOW_EXCEPTION
; 1079 :              || code == PGM_DECIMAL_OVERFLOW_EXCEPTION
; 1080 :              || code == PGM_EXPONENT_OVERFLOW_EXCEPTION
; 1081 :              || code == PGM_EXPONENT_UNDERFLOW_EXCEPTION
; 1082 :              || code == PGM_SIGNIFICANCE_EXCEPTION
; 1083 :              || code == PGM_SPACE_SWITCH_EVENT
; 1084 :              || code == PGM_MONITOR_EVENT
; 1085 :            )
; 1086 :     )
; 1087 :     {
; 1088 :         OFF_IC_PER_SA( realregs );

  00c75	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00c7a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00c7d	0f ba f0 15	 btr	 eax, 21
  00c81	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00c86	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00c89	33 c0		 xor	 eax, eax
  00c8b	85 c0		 test	 eax, eax
  00c8d	75 e6		 jne	 SHORT $LN46@s370_progr
$LN107@s370_progr:

; 1089 :     }
; 1090 : 
; 1091 :     if (OPEN_IC_PER( realregs ))

  00c8f	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00c94	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00c99	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  00c9c	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00c9f	23 c1		 and	 eax, ecx
  00ca1	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00ca6	85 c0		 test	 eax, eax
  00ca8	0f 84 cc 09 00
	00		 je	 $LN108@s370_progr

; 1092 :     {
; 1093 :         if (CPU_STEPPING_OR_TRACING( realregs, ilc ))

  00cae	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00cb3	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00cb9	c1 e8 10	 shr	 eax, 16
  00cbc	83 e0 01	 and	 eax, 1
  00cbf	85 c0		 test	 eax, eax
  00cc1	74 0d		 je	 SHORT $LN168@s370_progr
  00cc3	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv539[rsp], 1
  00cce	eb 0b		 jmp	 SHORT $LN169@s370_progr
$LN168@s370_progr:
  00cd0	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv539[rsp], 0
$LN169@s370_progr:
  00cdb	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv539[rsp], 0
  00ce3	0f 84 55 08 00
	00		 je	 $LN110@s370_progr
  00ce9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00cf0	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00cf6	c1 e8 0a	 shr	 eax, 10
  00cf9	83 e0 01	 and	 eax, 1
  00cfc	85 c0		 test	 eax, eax
  00cfe	0f 84 2b 03 00
	00		 je	 $LN112@s370_progr
  00d04	33 c0		 xor	 eax, eax
  00d06	85 c0		 test	 eax, eax
  00d08	0f 85 17 01 00
	00		 jne	 $LN113@s370_progr
  00d0e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d15	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00d1b	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00d20	85 c0		 test	 eax, eax
  00d22	0f 84 fd 00 00
	00		 je	 $LN113@s370_progr
  00d28	33 c0		 xor	 eax, eax
  00d2a	83 f8 01	 cmp	 eax, 1
  00d2d	0f 84 fc 02 00
	00		 je	 $LN112@s370_progr
  00d33	33 c0		 xor	 eax, eax
  00d35	85 c0		 test	 eax, eax
  00d37	75 34		 jne	 SHORT $LN114@s370_progr
  00d39	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d40	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00d46	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00d4b	85 c0		 test	 eax, eax
  00d4d	74 1e		 je	 SHORT $LN114@s370_progr
  00d4f	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00d54	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d5b	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00d61	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00d67	0f 85 c2 02 00
	00		 jne	 $LN112@s370_progr
$LN114@s370_progr:
  00d6d	33 c0		 xor	 eax, eax
  00d6f	85 c0		 test	 eax, eax
  00d71	75 34		 jne	 SHORT $LN115@s370_progr
  00d73	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00d7a	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00d80	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00d85	85 c0		 test	 eax, eax
  00d87	74 1e		 je	 SHORT $LN115@s370_progr
  00d89	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00d8e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00d95	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00d9b	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00da1	0f 8c 88 02 00
	00		 jl	 $LN112@s370_progr
$LN115@s370_progr:
  00da7	33 c0		 xor	 eax, eax
  00da9	85 c0		 test	 eax, eax
  00dab	75 78		 jne	 SHORT $LN116@s370_progr
  00dad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00db4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00dba	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00dbf	85 c0		 test	 eax, eax
  00dc1	74 20		 je	 SHORT $LN117@s370_progr
  00dc3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00dc8	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00dcf	85 c0		 test	 eax, eax
  00dd1	74 10		 je	 SHORT $LN117@s370_progr
  00dd3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00dd8	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00ddf	85 c0		 test	 eax, eax
  00de1	75 42		 jne	 SHORT $LN116@s370_progr
$LN117@s370_progr:
  00de3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00dea	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00df0	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00df5	85 c0		 test	 eax, eax
  00df7	0f 84 32 02 00
	00		 je	 $LN112@s370_progr
  00dfd	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00e02	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00e09	85 c0		 test	 eax, eax
  00e0b	0f 84 1e 02 00
	00		 je	 $LN112@s370_progr
  00e11	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00e16	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00e1d	85 c0		 test	 eax, eax
  00e1f	0f 85 0a 02 00
	00		 jne	 $LN112@s370_progr
$LN116@s370_progr:
$LN113@s370_progr:
  00e25	b8 08 00 00 00	 mov	 eax, 8
  00e2a	48 6b c0 00	 imul	 rax, rax, 0
  00e2e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e35	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00e3e	75 1f		 jne	 SHORT $LN118@s370_progr
  00e40	b8 08 00 00 00	 mov	 eax, 8
  00e45	48 6b c0 01	 imul	 rax, rax, 1
  00e49	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00e50	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00e59	0f 84 3e 05 00
	00		 je	 $LN111@s370_progr
$LN118@s370_progr:
  00e5f	b8 08 00 00 00	 mov	 eax, 8
  00e64	48 6b c0 00	 imul	 rax, rax, 0
  00e68	b9 08 00 00 00	 mov	 ecx, 8
  00e6d	48 6b c9 01	 imul	 rcx, rcx, 1
  00e71	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00e78	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00e7f	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  00e87	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00e8f	0f 87 b2 00 00
	00		 ja	 $LN119@s370_progr
  00e95	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00e9a	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00ea0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00ea5	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00eaa	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00eb1	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00eb5	48 2b ca	 sub	 rcx, rdx
  00eb8	48 03 c1	 add	 rax, rcx
  00ebb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00ec2	f7 d9		 neg	 ecx
  00ec4	48 63 c9	 movsxd	 rcx, ecx
  00ec7	48 03 c1	 add	 rax, rcx
  00eca	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00ed0	8b c0		 mov	 eax, eax
  00ed2	b9 08 00 00 00	 mov	 ecx, 8
  00ed7	48 6b c9 00	 imul	 rcx, rcx, 0
  00edb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00ee2	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00eea	72 5b		 jb	 SHORT $LN119@s370_progr
  00eec	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00ef1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00ef7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00efc	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00f01	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00f08	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00f0c	48 2b ca	 sub	 rcx, rdx
  00f0f	48 03 c1	 add	 rax, rcx
  00f12	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00f19	f7 d9		 neg	 ecx
  00f1b	48 63 c9	 movsxd	 rcx, ecx
  00f1e	48 03 c1	 add	 rax, rcx
  00f21	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00f27	8b c0		 mov	 eax, eax
  00f29	b9 08 00 00 00	 mov	 ecx, 8
  00f2e	48 6b c9 01	 imul	 rcx, rcx, 1
  00f32	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00f39	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00f41	0f 86 56 04 00
	00		 jbe	 $LN111@s370_progr
$LN119@s370_progr:
  00f47	b8 08 00 00 00	 mov	 eax, 8
  00f4c	48 6b c0 00	 imul	 rax, rax, 0
  00f50	b9 08 00 00 00	 mov	 ecx, 8
  00f55	48 6b c9 01	 imul	 rcx, rcx, 1
  00f59	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00f60	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00f67	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  00f6f	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00f77	0f 86 b2 00 00
	00		 jbe	 $LN120@s370_progr
  00f7d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00f82	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00f88	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00f8d	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00f92	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00f99	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00f9d	48 2b ca	 sub	 rcx, rdx
  00fa0	48 03 c1	 add	 rax, rcx
  00fa3	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00faa	f7 d9		 neg	 ecx
  00fac	48 63 c9	 movsxd	 rcx, ecx
  00faf	48 03 c1	 add	 rax, rcx
  00fb2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00fb8	8b c0		 mov	 eax, eax
  00fba	b9 08 00 00 00	 mov	 ecx, 8
  00fbf	48 6b c9 01	 imul	 rcx, rcx, 1
  00fc3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00fca	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00fd2	72 5b		 jb	 SHORT $LN120@s370_progr
  00fd4	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  00fd9	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00fdf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  00fe4	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  00fe9	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00ff0	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00ff4	48 2b ca	 sub	 rcx, rdx
  00ff7	48 03 c1	 add	 rax, rcx
  00ffa	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01001	f7 d9		 neg	 ecx
  01003	48 63 c9	 movsxd	 rcx, ecx
  01006	48 03 c1	 add	 rax, rcx
  01009	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0100f	8b c0		 mov	 eax, eax
  01011	b9 08 00 00 00	 mov	 ecx, 8
  01016	48 6b c9 00	 imul	 rcx, rcx, 0
  0101a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01021	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  01029	0f 86 6e 03 00
	00		 jbe	 $LN111@s370_progr
$LN120@s370_progr:
$LN112@s370_progr:
  0102f	33 c0		 xor	 eax, eax
  01031	83 f8 01	 cmp	 eax, 1
  01034	0f 84 04 05 00
	00		 je	 $LN110@s370_progr
  0103a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01041	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  01047	c1 e8 08	 shr	 eax, 8
  0104a	83 e0 01	 and	 eax, 1
  0104d	85 c0		 test	 eax, eax
  0104f	0f 84 e9 04 00
	00		 je	 $LN110@s370_progr
  01055	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0105a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01060	c1 e8 0f	 shr	 eax, 15
  01063	83 e0 01	 and	 eax, 1
  01066	85 c0		 test	 eax, eax
  01068	0f 84 d0 04 00
	00		 je	 $LN110@s370_progr
  0106e	33 c0		 xor	 eax, eax
  01070	85 c0		 test	 eax, eax
  01072	0f 85 17 01 00
	00		 jne	 $LN121@s370_progr
  01078	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0107f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01085	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0108a	85 c0		 test	 eax, eax
  0108c	0f 84 fd 00 00
	00		 je	 $LN121@s370_progr
  01092	33 c0		 xor	 eax, eax
  01094	83 f8 01	 cmp	 eax, 1
  01097	0f 84 a1 04 00
	00		 je	 $LN110@s370_progr
  0109d	33 c0		 xor	 eax, eax
  0109f	85 c0		 test	 eax, eax
  010a1	75 34		 jne	 SHORT $LN122@s370_progr
  010a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010aa	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010b0	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  010b5	85 c0		 test	 eax, eax
  010b7	74 1e		 je	 SHORT $LN122@s370_progr
  010b9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  010be	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  010c5	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  010cb	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  010d1	0f 85 67 04 00
	00		 jne	 $LN110@s370_progr
$LN122@s370_progr:
  010d7	33 c0		 xor	 eax, eax
  010d9	85 c0		 test	 eax, eax
  010db	75 34		 jne	 SHORT $LN123@s370_progr
  010dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010e4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  010ea	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  010ef	85 c0		 test	 eax, eax
  010f1	74 1e		 je	 SHORT $LN123@s370_progr
  010f3	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  010f8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  010ff	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  01105	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0110b	0f 8c 2d 04 00
	00		 jl	 $LN110@s370_progr
$LN123@s370_progr:
  01111	33 c0		 xor	 eax, eax
  01113	85 c0		 test	 eax, eax
  01115	75 78		 jne	 SHORT $LN124@s370_progr
  01117	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0111e	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  01124	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  01129	85 c0		 test	 eax, eax
  0112b	74 20		 je	 SHORT $LN125@s370_progr
  0112d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01132	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01139	85 c0		 test	 eax, eax
  0113b	74 10		 je	 SHORT $LN125@s370_progr
  0113d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01142	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01149	85 c0		 test	 eax, eax
  0114b	75 42		 jne	 SHORT $LN124@s370_progr
$LN125@s370_progr:
  0114d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01154	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0115a	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0115f	85 c0		 test	 eax, eax
  01161	0f 84 d7 03 00
	00		 je	 $LN110@s370_progr
  01167	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0116c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  01173	85 c0		 test	 eax, eax
  01175	0f 84 c3 03 00
	00		 je	 $LN110@s370_progr
  0117b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01180	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  01187	85 c0		 test	 eax, eax
  01189	0f 85 af 03 00
	00		 jne	 $LN110@s370_progr
$LN124@s370_progr:
$LN121@s370_progr:
  0118f	b8 08 00 00 00	 mov	 eax, 8
  01194	48 6b c0 00	 imul	 rax, rax, 0
  01198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0119f	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  011a8	75 1f		 jne	 SHORT $LN127@s370_progr
  011aa	b8 08 00 00 00	 mov	 eax, 8
  011af	48 6b c0 01	 imul	 rax, rax, 1
  011b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  011ba	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  011c3	0f 84 d4 01 00
	00		 je	 $LN126@s370_progr
$LN127@s370_progr:
  011c9	b8 08 00 00 00	 mov	 eax, 8
  011ce	48 6b c0 00	 imul	 rax, rax, 0
  011d2	b9 08 00 00 00	 mov	 ecx, 8
  011d7	48 6b c9 01	 imul	 rcx, rcx, 1
  011db	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  011e2	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  011e9	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  011f1	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  011f9	0f 87 b2 00 00
	00		 ja	 $LN128@s370_progr
  011ff	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01204	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0120a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0120f	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  01214	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0121b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0121f	48 2b ca	 sub	 rcx, rdx
  01222	48 03 c1	 add	 rax, rcx
  01225	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0122c	f7 d9		 neg	 ecx
  0122e	48 63 c9	 movsxd	 rcx, ecx
  01231	48 03 c1	 add	 rax, rcx
  01234	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0123a	8b c0		 mov	 eax, eax
  0123c	b9 08 00 00 00	 mov	 ecx, 8
  01241	48 6b c9 00	 imul	 rcx, rcx, 0
  01245	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0124c	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  01254	72 5b		 jb	 SHORT $LN128@s370_progr
  01256	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0125b	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  01261	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01266	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  0126b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01272	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01276	48 2b ca	 sub	 rcx, rdx
  01279	48 03 c1	 add	 rax, rcx
  0127c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01283	f7 d9		 neg	 ecx
  01285	48 63 c9	 movsxd	 rcx, ecx
  01288	48 03 c1	 add	 rax, rcx
  0128b	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  01291	8b c0		 mov	 eax, eax
  01293	b9 08 00 00 00	 mov	 ecx, 8
  01298	48 6b c9 01	 imul	 rcx, rcx, 1
  0129c	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  012a3	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  012ab	0f 86 ec 00 00
	00		 jbe	 $LN126@s370_progr
$LN128@s370_progr:
  012b1	b8 08 00 00 00	 mov	 eax, 8
  012b6	48 6b c0 00	 imul	 rax, rax, 0
  012ba	b9 08 00 00 00	 mov	 ecx, 8
  012bf	48 6b c9 01	 imul	 rcx, rcx, 1
  012c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  012ca	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  012d1	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  012d9	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  012e1	0f 86 57 02 00
	00		 jbe	 $LN110@s370_progr
  012e7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  012ec	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  012f2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  012f7	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  012fc	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01303	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01307	48 2b ca	 sub	 rcx, rdx
  0130a	48 03 c1	 add	 rax, rcx
  0130d	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  01314	f7 d9		 neg	 ecx
  01316	48 63 c9	 movsxd	 rcx, ecx
  01319	48 03 c1	 add	 rax, rcx
  0131c	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  01322	8b c0		 mov	 eax, eax
  01324	b9 08 00 00 00	 mov	 ecx, 8
  01329	48 6b c9 01	 imul	 rcx, rcx, 1
  0132d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01334	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0133c	0f 82 fc 01 00
	00		 jb	 $LN110@s370_progr
  01342	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01347	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0134d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01352	48 8b 54 24 70	 mov	 rdx, QWORD PTR realregs$[rsp]
  01357	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0135e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  01362	48 2b ca	 sub	 rcx, rdx
  01365	48 03 c1	 add	 rax, rcx
  01368	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0136f	f7 d9		 neg	 ecx
  01371	48 63 c9	 movsxd	 rcx, ecx
  01374	48 03 c1	 add	 rax, rcx
  01377	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0137d	8b c0		 mov	 eax, eax
  0137f	b9 08 00 00 00	 mov	 ecx, 8
  01384	48 6b c9 00	 imul	 rcx, rcx, 0
  01388	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0138f	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  01397	0f 87 a1 01 00
	00		 ja	 $LN110@s370_progr
$LN126@s370_progr:
$LN111@s370_progr:

; 1094 :         {
; 1095 :             BYTE perc = IS_IC_PER( realregs ) >> 16;

  0139d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  013a2	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  013a5	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  013aa	c1 e8 10	 shr	 eax, 16
  013ad	88 84 24 84 00
	00 00		 mov	 BYTE PTR perc$1[rsp], al

; 1096 : 
; 1097 :             if (regs->insttrace && sysblk.traceFILE)

  013b4	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  013bc	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  013c2	c1 e8 0f	 shr	 eax, 15
  013c5	83 e0 01	 and	 eax, 1
  013c8	85 c0		 test	 eax, eax
  013ca	74 56		 je	 SHORT $LN129@s370_progr
  013cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  013d3	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  013db	74 45		 je	 SHORT $LN129@s370_progr

; 1098 :                 tf_0802( regs,

  013dd	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR perc$1[rsp]
  013e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  013ea	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR ilc$[rsp]
  013f1	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  013f7	2b ca		 sub	 ecx, edx
  013f9	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  013ff	8b c9		 mov	 ecx, ecx
  01401	44 0f b7 c8	 movzx	 r9d, ax
  01405	44 8b 84 24 c8
	01 00 00	 mov	 r8d, DWORD PTR pcode$[rsp]
  0140d	8b d1		 mov	 edx, ecx
  0140f	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01417	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0802
  0141d	e9 1c 01 00 00	 jmp	 $LN130@s370_progr
$LN129@s370_progr:

; 1099 :                         (realregs->psw.IA - ilc) & ADDRESS_MAXWRAP( realregs ),
; 1100 :                          pcode, perc );
; 1101 :             else
; 1102 :             {
; 1103 :                 char percname[32];
; 1104 :                 perc2name( perc, percname, sizeof( percname ));

  01422	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  01428	48 8d 94 24 28
	01 00 00	 lea	 rdx, QWORD PTR percname$6[rsp]
  01430	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR perc$1[rsp]
  01438	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_perc2name

; 1105 : 
; 1106 :                 // "Processor %s%02X: PER event: code %4.4X perc %2.2X=%s addr "F_VADR
; 1107 :                 WRMSG( HHC00802, "I", PTYPSTR( regs->cpuad ), regs->cpuad,

  0143e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01443	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0144a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  01450	2b c1		 sub	 eax, ecx
  01452	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  01457	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv826[rsp], eax
  0145e	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR perc$1[rsp]
  01466	89 8c 24 ac 00
	00 00		 mov	 DWORD PTR tv829[rsp], ecx
  0146d	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01475	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  0147c	89 94 24 b0 00
	00 00		 mov	 DWORD PTR tv833[rsp], edx
  01483	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0148b	45 0f b7 80 3c
	08 00 00	 movzx	 r8d, WORD PTR [r8+2108]
  01493	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR __imp_sysblk
  0149a	43 0f b6 8c 01
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r9+r8+2888]
  014a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  014a9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv835[rsp], rax
  014b1	b9 01 00 00 00	 mov	 ecx, 1
  014b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  014bc	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv826[rsp]
  014c3	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  014c7	48 8d 8c 24 28
	01 00 00	 lea	 rcx, QWORD PTR percname$6[rsp]
  014cf	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  014d4	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv829[rsp]
  014db	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  014df	8b 8c 24 c8 01
	00 00		 mov	 ecx, DWORD PTR pcode$[rsp]
  014e6	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  014ea	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv833[rsp]
  014f1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  014f5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv835[rsp]
  014fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01502	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170394
  01509	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0150e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170395
  01515	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0151a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0151f	41 b9 03 00 00
	00		 mov	 r9d, 3
  01525	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170396
  0152c	ba 55 04 00 00	 mov	 edx, 1109		; 00000455H
  01531	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170397
  01538	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN130@s370_progr:
$LN110@s370_progr:

; 1108 :                     pcode, perc, percname,
; 1109 :                     (realregs->psw.IA - ilc) & ADDRESS_MAXWRAP( realregs ));
; 1110 :             }
; 1111 :         }
; 1112 : 
; 1113 :         realregs->perc |= OPEN_IC_PER( realregs ) >> ((32 - IC_CR9_SHIFT) - 16);

  0153e	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01543	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01548	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  0154b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0154e	23 c1		 and	 eax, ecx
  01550	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  01555	c1 e8 08	 shr	 eax, 8
  01558	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0155d	0f b7 89 d0 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2256]
  01564	0b c8		 or	 ecx, eax
  01566	8b c1		 mov	 eax, ecx
  01568	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0156d	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax

; 1114 : 
; 1115 :         /* Positions 14 and 15 contain zeros
; 1116 :            if a storage alteration event was not indicated
; 1117 :         */
; 1118 :         if (0
; 1119 :             || !OPEN_IC_PER_SA(    realregs )
; 1120 :             ||  OPEN_IC_PER_STURA( realregs )

  01574	33 c0		 xor	 eax, eax
  01576	85 c0		 test	 eax, eax
  01578	75 36		 jne	 SHORT $LN132@s370_progr
  0157a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0157f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01584	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  01587	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0158a	23 c1		 and	 eax, ecx
  0158c	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01591	85 c0		 test	 eax, eax
  01593	74 1b		 je	 SHORT $LN132@s370_progr
  01595	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0159a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0159f	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  015a2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  015a5	23 c1		 and	 eax, ecx
  015a7	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  015ac	85 c0		 test	 eax, eax
  015ae	74 1d		 je	 SHORT $LN131@s370_progr
$LN132@s370_progr:

; 1121 :         )
; 1122 :             realregs->perc &= 0xFFFC;

  015b0	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  015b5	0f b7 80 d0 08
	00 00		 movzx	 eax, WORD PTR [rax+2256]
  015bc	25 fc ff 00 00	 and	 eax, 65532		; 0000fffcH
  015c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  015c6	66 89 81 d0 08
	00 00		 mov	 WORD PTR [rcx+2256], ax
$LN131@s370_progr:

; 1123 : 
; 1124 :         STORE_HW( psa->perint, realregs->perc   );

  015cd	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  015d2	0f b7 88 d0 08
	00 00		 movzx	 ecx, WORD PTR [rax+2256]
  015d9	e8 00 00 00 00	 call	 _byteswap_ushort
  015de	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  015e6	48 81 c1 96 00
	00 00		 add	 rcx, 150		; 00000096H
  015ed	0f b7 d0	 movzx	 edx, ax
  015f0	e8 00 00 00 00	 call	 store_hw_noswap

; 1125 :         STORE_W(  psa->peradr, realregs->peradr );

  015f5	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  015fa	8b 88 d8 08 00
	00		 mov	 ecx, DWORD PTR [rax+2264]
  01600	e8 00 00 00 00	 call	 _byteswap_ulong
  01605	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0160d	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  01614	8b d0		 mov	 edx, eax
  01616	e8 00 00 00 00	 call	 store_fw_noswap

; 1126 : 
; 1127 :         if (IS_IC_PER_SA( realregs ) && ACCESS_REGISTER_MODE( &realregs->psw ))

  0161b	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01620	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01623	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01628	85 c0		 test	 eax, eax
  0162a	74 28		 je	 SHORT $LN133@s370_progr
  0162c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01631	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  01635	83 f8 40	 cmp	 eax, 64			; 00000040H
  01638	75 1a		 jne	 SHORT $LN133@s370_progr

; 1128 :             psa->perarid = realregs->peraid;

  0163a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01642	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01647	0f b6 89 e0 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2272]
  0164e	88 88 a1 00 00
	00		 mov	 BYTE PTR [rax+161], cl
$LN133@s370_progr:

; 1129 : 
; 1130 : #if defined( _FEATURE_SIE )
; 1131 :         /* Reset PER pending indication */
; 1132 :         if (!intercept)

  01654	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01659	85 c0		 test	 eax, eax
  0165b	75 1b		 jne	 SHORT $LN134@s370_progr
$LN49@s370_progr:

; 1133 :             OFF_IC_PER( realregs );

  0165d	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01662	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  01665	25 ff ff 00 ff	 and	 eax, -16711681		; ff00ffffH
  0166a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0166f	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  01672	33 c0		 xor	 eax, eax
  01674	85 c0		 test	 eax, eax
  01676	75 e5		 jne	 SHORT $LN49@s370_progr
$LN134@s370_progr:

; 1134 : #endif
; 1135 :     }

  01678	eb 12		 jmp	 SHORT $LN109@s370_progr
$LN108@s370_progr:

; 1136 :     else
; 1137 :     {
; 1138 :         pcode &= ~(PGM_PER_EVENT);

  0167a	8b 84 24 c8 01
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  01681	0f ba f0 07	 btr	 eax, 7
  01685	89 84 24 c8 01
	00 00		 mov	 DWORD PTR pcode$[rsp], eax
$LN109@s370_progr:

; 1139 :     }
; 1140 : #endif /* defined( _FEATURE_PER ) */
; 1141 : 
; 1142 : #if defined( FEATURE_BCMODE )
; 1143 :     /* For ECMODE, store extended interrupt information in PSA */
; 1144 :     if (ECMODE( &realregs->psw ))

  0168c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01691	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  01695	83 e0 08	 and	 eax, 8
  01698	85 c0		 test	 eax, eax
  0169a	0f 84 c9 02 00
	00		 je	 $LN135@s370_progr
$LN52@s370_progr:

; 1145 : #endif
; 1146 :     {
; 1147 :         PTT_PGM( "PGM ec", 0, 0, 0 );

  016a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  016a7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  016aa	48 83 e0 20	 and	 rax, 32			; 00000020H
  016ae	48 85 c0	 test	 rax, rax
  016b1	74 36		 je	 SHORT $LN136@s370_progr
  016b3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  016bc	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  016c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170404
  016cc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016d1	45 33 c9	 xor	 r9d, r9d
  016d4	45 33 c0	 xor	 r8d, r8d
  016d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170405
  016de	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  016e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN136@s370_progr:
  016e9	33 c0		 xor	 eax, eax
  016eb	85 c0		 test	 eax, eax
  016ed	75 b1		 jne	 SHORT $LN52@s370_progr

; 1148 : 
; 1149 :         /* Store the program interrupt code at PSA+X'8C' */
; 1150 :         psa->pgmint[0] = 0;

  016ef	b8 01 00 00 00	 mov	 eax, 1
  016f4	48 6b c0 00	 imul	 rax, rax, 0
  016f8	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01700	c6 84 01 8c 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+140], 0

; 1151 :         psa->pgmint[1] = ilc;

  01708	b8 01 00 00 00	 mov	 eax, 1
  0170d	48 6b c0 01	 imul	 rax, rax, 1
  01711	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01719	0f b6 94 24 80
	00 00 00	 movzx	 edx, BYTE PTR ilc$[rsp]
  01721	88 94 01 8c 00
	00 00		 mov	 BYTE PTR [rcx+rax+140], dl

; 1152 : 
; 1153 :         STORE_HW( psa->pgmint + 2, pcode );

  01728	0f b7 8c 24 c8
	01 00 00	 movzx	 ecx, WORD PTR pcode$[rsp]
  01730	e8 00 00 00 00	 call	 _byteswap_ushort
  01735	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0173d	48 81 c1 8e 00
	00 00		 add	 rcx, 142		; 0000008eH
  01744	0f b7 d0	 movzx	 edx, ax
  01747	e8 00 00 00 00	 call	 store_hw_noswap

; 1154 : 
; 1155 :         /* Store the exception access identification at PSA+160 */
; 1156 :         if (0
; 1157 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1158 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1159 : 
; 1160 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1161 :             || code == PGM_ASCE_TYPE_EXCEPTION
; 1162 :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 1163 :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 1164 :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 1165 : #endif
; 1166 :             || code == PGM_ALEN_TRANSLATION_EXCEPTION
; 1167 :             || code == PGM_ALE_SEQUENCE_EXCEPTION
; 1168 :             || code == PGM_ASTE_VALIDITY_EXCEPTION
; 1169 :             || code == PGM_ASTE_SEQUENCE_EXCEPTION
; 1170 :             || code == PGM_ASTE_INSTANCE_EXCEPTION
; 1171 :             || code == PGM_EXTENDED_AUTHORITY_EXCEPTION

  0174c	33 c0		 xor	 eax, eax
  0174e	85 c0		 test	 eax, eax
  01750	75 38		 jne	 SHORT $LN138@s370_progr
  01752	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  01757	74 31		 je	 SHORT $LN138@s370_progr
  01759	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  0175e	74 2a		 je	 SHORT $LN138@s370_progr
  01760	83 7c 24 78 29	 cmp	 DWORD PTR code$[rsp], 41 ; 00000029H
  01765	74 23		 je	 SHORT $LN138@s370_progr
  01767	83 7c 24 78 2a	 cmp	 DWORD PTR code$[rsp], 42 ; 0000002aH
  0176c	74 1c		 je	 SHORT $LN138@s370_progr
  0176e	83 7c 24 78 2b	 cmp	 DWORD PTR code$[rsp], 43 ; 0000002bH
  01773	74 15		 je	 SHORT $LN138@s370_progr
  01775	83 7c 24 78 2c	 cmp	 DWORD PTR code$[rsp], 44 ; 0000002cH
  0177a	74 0e		 je	 SHORT $LN138@s370_progr
  0177c	83 7c 24 78 2f	 cmp	 DWORD PTR code$[rsp], 47 ; 0000002fH
  01781	74 07		 je	 SHORT $LN138@s370_progr
  01783	83 7c 24 78 2d	 cmp	 DWORD PTR code$[rsp], 45 ; 0000002dH
  01788	75 5b		 jne	 SHORT $LN137@s370_progr
$LN138@s370_progr:

; 1172 : 
; 1173 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1174 :             || code == PGM_PROTECTION_EXCEPTION
; 1175 : #endif
; 1176 :         )
; 1177 :         {
; 1178 :             psa->excarid = regs->excarid;

  0178a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01792	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0179a	0f b6 89 3e 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2110]
  017a1	88 88 a0 00 00
	00		 mov	 BYTE PTR [rax+160], cl

; 1179 :             // FIXME: this conditional will ALWAYS be true!!
; 1180 :             if (regs->TEA | TEA_MVPG)

  017a7	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  017af	8b 80 18 07 00
	00		 mov	 eax, DWORD PTR [rax+1816]
  017b5	83 c8 04	 or	 eax, 4
  017b8	85 c0		 test	 eax, eax
  017ba	74 1d		 je	 SHORT $LN139@s370_progr

; 1181 :                 psa->opndrid = regs->opndrid;

  017bc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  017c4	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  017cc	0f b6 89 3f 08
	00 00		 movzx	 ecx, BYTE PTR [rcx+2111]
  017d3	88 88 a2 00 00
	00		 mov	 BYTE PTR [rax+162], cl
$LN139@s370_progr:

; 1182 :             realregs->opndrid = 0;

  017d9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  017de	c6 80 3f 08 00
	00 00		 mov	 BYTE PTR [rax+2111], 0
$LN137@s370_progr:

; 1183 :         }
; 1184 : 
; 1185 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1186 :         /* Store the translation exception address at PSA+168 */
; 1187 :         if (0
; 1188 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1189 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1190 :             || code == PGM_ASCE_TYPE_EXCEPTION
; 1191 :             || code == PGM_REGION_FIRST_TRANSLATION_EXCEPTION
; 1192 :             || code == PGM_REGION_SECOND_TRANSLATION_EXCEPTION
; 1193 :             || code == PGM_REGION_THIRD_TRANSLATION_EXCEPTION
; 1194 : 
; 1195 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1196 :             || code == PGM_PROTECTION_EXCEPTION
; 1197 : #endif
; 1198 :         )
; 1199 :         {
; 1200 :             STORE_DW( psa->TEA_G, regs->TEA );
; 1201 :         }
; 1202 : 
; 1203 :         /* For z, store translation exception address at PSA+172 */
; 1204 :         if (0
; 1205 :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 1206 :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 1207 :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 1208 :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 1209 :             || code == PGM_SPACE_SWITCH_EVENT
; 1210 :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 1211 :             || code == PGM_LFX_TRANSLATION_EXCEPTION
; 1212 :             || code == PGM_LSX_TRANSLATION_EXCEPTION
; 1213 :             || code == PGM_LSTE_SEQUENCE_EXCEPTION
; 1214 :             || code == PGM_EX_TRANSLATION_EXCEPTION
; 1215 :         )
; 1216 :         {
; 1217 :             STORE_FW( psa->TEA_L, regs->TEA );
; 1218 :         }
; 1219 : 
; 1220 : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1221 : 
; 1222 :         /* For 370/390, store translation exception address at PSA+144 */
; 1223 :         if (0
; 1224 :             || code == PGM_PAGE_TRANSLATION_EXCEPTION
; 1225 :             || code == PGM_SEGMENT_TRANSLATION_EXCEPTION
; 1226 :             || code == PGM_AFX_TRANSLATION_EXCEPTION
; 1227 :             || code == PGM_ASX_TRANSLATION_EXCEPTION
; 1228 :             || code == PGM_PRIMARY_AUTHORITY_EXCEPTION
; 1229 :             || code == PGM_SECONDARY_AUTHORITY_EXCEPTION
; 1230 :             || code == PGM_SPACE_SWITCH_EVENT
; 1231 :             || code == PGM_LX_TRANSLATION_EXCEPTION
; 1232 :             || code == PGM_EX_TRANSLATION_EXCEPTION

  017e5	33 c0		 xor	 eax, eax
  017e7	85 c0		 test	 eax, eax
  017e9	75 3f		 jne	 SHORT $LN141@s370_progr
  017eb	83 7c 24 78 11	 cmp	 DWORD PTR code$[rsp], 17
  017f0	74 38		 je	 SHORT $LN141@s370_progr
  017f2	83 7c 24 78 10	 cmp	 DWORD PTR code$[rsp], 16
  017f7	74 31		 je	 SHORT $LN141@s370_progr
  017f9	83 7c 24 78 20	 cmp	 DWORD PTR code$[rsp], 32 ; 00000020H
  017fe	74 2a		 je	 SHORT $LN141@s370_progr
  01800	83 7c 24 78 21	 cmp	 DWORD PTR code$[rsp], 33 ; 00000021H
  01805	74 23		 je	 SHORT $LN141@s370_progr
  01807	83 7c 24 78 24	 cmp	 DWORD PTR code$[rsp], 36 ; 00000024H
  0180c	74 1c		 je	 SHORT $LN141@s370_progr
  0180e	83 7c 24 78 25	 cmp	 DWORD PTR code$[rsp], 37 ; 00000025H
  01813	74 15		 je	 SHORT $LN141@s370_progr
  01815	83 7c 24 78 1c	 cmp	 DWORD PTR code$[rsp], 28
  0181a	74 0e		 je	 SHORT $LN141@s370_progr
  0181c	83 7c 24 78 22	 cmp	 DWORD PTR code$[rsp], 34 ; 00000022H
  01821	74 07		 je	 SHORT $LN141@s370_progr
  01823	83 7c 24 78 23	 cmp	 DWORD PTR code$[rsp], 35 ; 00000023H
  01828	75 29		 jne	 SHORT $LN140@s370_progr
$LN141@s370_progr:

; 1233 : 
; 1234 : #if defined( FEATURE_SUPPRESSION_ON_PROTECTION )
; 1235 :             || code == PGM_PROTECTION_EXCEPTION
; 1236 : #endif
; 1237 :         )
; 1238 :         {
; 1239 :             STORE_FW( psa->tea, regs->TEA );

  0182a	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01832	8b 88 18 07 00
	00		 mov	 ecx, DWORD PTR [rax+1816]
  01838	e8 00 00 00 00	 call	 _byteswap_ulong
  0183d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01845	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  0184c	8b d0		 mov	 edx, eax
  0184e	e8 00 00 00 00	 call	 store_fw_noswap
$LN140@s370_progr:

; 1240 :         }
; 1241 : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 1242 : 
; 1243 :         realregs->TEA = 0;

  01853	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01858	c7 80 18 07 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1816], 0

; 1244 : 
; 1245 :         /* Store Data exception code in PSA */
; 1246 :         if (code == PGM_DATA_EXCEPTION)

  01862	83 7c 24 78 07	 cmp	 DWORD PTR code$[rsp], 7
  01867	0f 85 a1 00 00
	00		 jne	 $LN142@s370_progr

; 1247 :         {
; 1248 :             STORE_FW( psa->DXC, regs->dxc );

  0186d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01875	8b 88 08 07 00
	00		 mov	 ecx, DWORD PTR [rax+1800]
  0187b	e8 00 00 00 00	 call	 _byteswap_ulong
  01880	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01888	48 81 c1 90 00
	00 00		 add	 rcx, 144		; 00000090H
  0188f	8b d0		 mov	 edx, eax
  01891	e8 00 00 00 00	 call	 store_fw_noswap

; 1249 : 
; 1250 : #if defined( FEATURE_BASIC_FP_EXTENSIONS )
; 1251 :             /* Load data exception code into FPC register byte 2 */
; 1252 :             if (regs->CR(0) & CR0_AFP)

  01896	b8 08 00 00 00	 mov	 eax, 8
  0189b	48 6b c0 01	 imul	 rax, rax, 1
  0189f	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018a7	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  018ae	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  018b3	85 c0		 test	 eax, eax
  018b5	74 57		 je	 SHORT $LN143@s370_progr

; 1253 :             {
; 1254 :                 regs->fpc &= ~(FPC_DXC);

  018b7	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018bf	8b 80 c0 03 00
	00		 mov	 eax, DWORD PTR [rax+960]
  018c5	25 ff 00 ff ff	 and	 eax, -65281		; ffff00ffH
  018ca	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018d2	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax

; 1255 :                 regs->fpc |= ((regs->dxc << 8)) & FPC_DXC;

  018d8	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  018e0	8b 80 08 07 00
	00		 mov	 eax, DWORD PTR [rax+1800]
  018e6	c1 e0 08	 shl	 eax, 8
  018e9	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  018ee	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  018f6	8b 89 c0 03 00
	00		 mov	 ecx, DWORD PTR [rcx+960]
  018fc	0b c8		 or	 ecx, eax
  018fe	8b c1		 mov	 eax, ecx
  01900	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01908	89 81 c0 03 00
	00		 mov	 DWORD PTR [rcx+960], eax
$LN143@s370_progr:
$LN142@s370_progr:

; 1256 :             }
; 1257 : #endif
; 1258 :         }
; 1259 : 
; 1260 :         /* Store the monitor class and event code */
; 1261 :         if (code == PGM_MONITOR_EVENT)

  0190e	83 7c 24 78 40	 cmp	 DWORD PTR code$[rsp], 64 ; 00000040H
  01913	75 54		 jne	 SHORT $LN144@s370_progr

; 1262 :         {
; 1263 :             STORE_HW( psa->monclass, regs->monclass );

  01915	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0191d	0f b7 88 3a 08
	00 00		 movzx	 ecx, WORD PTR [rax+2106]
  01924	e8 00 00 00 00	 call	 _byteswap_ushort
  01929	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  01931	48 81 c1 94 00
	00 00		 add	 rcx, 148		; 00000094H
  01938	0f b7 d0	 movzx	 edx, ax
  0193b	e8 00 00 00 00	 call	 store_hw_noswap

; 1264 : 
; 1265 :             /* Store the monitor code word at PSA+156 */
; 1266 :             /* or doubleword at PSA+176               */
; 1267 :             /* ISW20090110-1 ZSIEMCFIX                */
; 1268 :             /* In the event of a z/Arch guest being   */
; 1269 :             /* intercepted during a succesful Monitor */
; 1270 :             /* call, the monitor code is not stored   */
; 1271 :             /* at psa->moncode (which is beyond sie2bk->ip */
; 1272 :             /* but rather at the same location as an  */
; 1273 :             /* I/O interrupt would store the SSID     */
; 1274 :             /*    zmoncode points to this location    */
; 1275 :             /*  **** FIXME **** FIXME  *** FIXME ***  */
; 1276 :             /* ---- The determination of the location */
; 1277 :             /*      of the z/Sie Intercept moncode    */
; 1278 :             /*      should be made more flexible      */
; 1279 :             /*      and should be put somewhere in    */
; 1280 :             /*      esa390.h                          */
; 1281 :             /*  **** FIXME **** FIXME  *** FIXME ***  */
; 1282 : 
; 1283 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 1284 :             STORE_DW( zmoncode, regs->MONCODE );
; 1285 : #else
; 1286 :             STORE_W( psa->moncode, regs->MONCODE );

  01940	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01948	8b 88 10 07 00
	00		 mov	 ecx, DWORD PTR [rax+1808]
  0194e	e8 00 00 00 00	 call	 _byteswap_ulong
  01953	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0195b	48 81 c1 9c 00
	00 00		 add	 rcx, 156		; 0000009cH
  01962	8b d0		 mov	 edx, eax
  01964	e8 00 00 00 00	 call	 store_fw_noswap
$LN144@s370_progr:
$LN135@s370_progr:

; 1287 : #endif
; 1288 :         }
; 1289 : 
; 1290 : #if defined( FEATURE_PER3 )
; 1291 :         /* Store the breaking event address register in the PSA */
; 1292 :         STORE_W( psa->bea, regs->bear );
; 1293 :         PTT_PGM( "PGM bear", regs->bear, 0, 0 );
; 1294 : #endif
; 1295 : 
; 1296 :     } /* end if(ECMODE) */
; 1297 : 
; 1298 : #if defined( _FEATURE_PROTECTION_INTERCEPTION_CONTROL )
; 1299 :     realregs->hostint = 0;

  01969	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  0196e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01974	83 e0 bf	 and	 eax, -65		; ffffffbfH
  01977	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  0197c	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 1300 : #endif
; 1301 : 
; 1302 :     /* Normal (non-intercepted) program interrupt? */
; 1303 : #if defined( _FEATURE_SIE )
; 1304 :     if (!intercept)

  01982	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01987	85 c0		 test	 eax, eax
  01989	0f 85 32 04 00
	00		 jne	 $LN145@s370_progr

; 1305 : #endif
; 1306 :     {
; 1307 :         PSW pgmold, pgmnew;
; 1308 :         int pgmintloop = 0;

  0198f	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR pgmintloop$3[rsp], 0

; 1309 :         int detect_pgmintloop = FACILITY_ENABLED( HERC_DETECT_PGMINTLOOP, realregs );

  0199a	b8 01 00 00 00	 mov	 eax, 1
  0199f	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  019a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  019a8	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  019b0	83 e0 40	 and	 eax, 64			; 00000040H
  019b3	89 84 24 90 00
	00 00		 mov	 DWORD PTR detect_pgmintloop$2[rsp], eax

; 1310 : 
; 1311 :         /* Store current PSW at PSA+X'28' or PSA+X'150' for ESAME */
; 1312 :         ARCH_DEP( store_psw )( realregs, psa->pgmold );

  019ba	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  019c2	48 83 c0 28	 add	 rax, 40			; 00000028H
  019c6	48 8b d0	 mov	 rdx, rax
  019c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  019ce	e8 00 00 00 00	 call	 s370_store_psw

; 1313 : 
; 1314 :         /* Save program old psw */
; 1315 :         if (detect_pgmintloop)

  019d3	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR detect_pgmintloop$2[rsp], 0
  019db	74 35		 je	 SHORT $LN146@s370_progr

; 1316 :         {
; 1317 :             memcpy( &pgmold, &realregs->psw, sizeof( PSW ));

  019dd	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR pgmold$4[rsp]
  019e5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  019ea	48 8b f8	 mov	 rdi, rax
  019ed	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  019f1	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  019f6	f3 a4		 rep movsb

; 1318 :             pgmold.cc      = 0;

  019f8	c6 84 24 dc 00
	00 00 00	 mov	 BYTE PTR pgmold$4[rsp+4], 0

; 1319 :             pgmold.intcode = 0;

  01a00	33 c0		 xor	 eax, eax
  01a02	66 89 84 24 f8
	00 00 00	 mov	 WORD PTR pgmold$4[rsp+32], ax

; 1320 :             pgmold.ilc     = 0;

  01a0a	c6 84 24 fa 00
	00 00 00	 mov	 BYTE PTR pgmold$4[rsp+34], 0
$LN146@s370_progr:

; 1321 :         }
; 1322 : 
; 1323 :         /* Load new PSW from PSA+X'68' or PSA+X'1D0' for ESAME */
; 1324 :         if ((code = ARCH_DEP( load_psw )( realregs, psa->pgmnew )))

  01a12	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  01a1a	48 83 c0 68	 add	 rax, 104		; 00000068H
  01a1e	48 8b d0	 mov	 rdx, rax
  01a21	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01a26	e8 00 00 00 00	 call	 s370_load_psw
  01a2b	89 44 24 78	 mov	 DWORD PTR code$[rsp], eax
  01a2f	83 7c 24 78 00	 cmp	 DWORD PTR code$[rsp], 0
  01a34	0f 84 f2 00 00
	00		 je	 $LN147@s370_progr

; 1325 :         {
; 1326 :             /* The load psw failed */
; 1327 : #if defined( _FEATURE_SIE )
; 1328 :             if (SIE_MODE( realregs ))

  01a3a	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01a3f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  01a45	d1 e8		 shr	 eax, 1
  01a47	83 e0 01	 and	 eax, 1
  01a4a	85 c0		 test	 eax, eax
  01a4c	0f 84 c7 00 00
	00		 je	 $LN149@s370_progr
$LN55@s370_progr:

; 1329 :             {
; 1330 :                 PTT_PGM( "*PGM *lpsw", code, 0, 0 );

  01a52	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01a59	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01a5c	48 83 e0 20	 and	 rax, 32			; 00000020H
  01a60	48 85 c0	 test	 rax, rax
  01a63	74 3b		 je	 SHORT $LN151@s370_progr
  01a65	48 63 44 24 78	 movsxd	 rax, DWORD PTR code$[rsp]
  01a6a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01a73	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01a7c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170421
  01a83	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01a88	45 33 c9	 xor	 r9d, r9d
  01a8b	4c 8b c0	 mov	 r8, rax
  01a8e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170422
  01a95	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01a9a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN151@s370_progr:
  01aa0	33 c0		 xor	 eax, eax
  01aa2	85 c0		 test	 eax, eax
  01aa4	75 ac		 jne	 SHORT $LN55@s370_progr
$LN58@s370_progr:

; 1331 :                 PTT_PGM( "PGM progjmp", pcode, 0, 0 );

  01aa6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01aad	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01ab0	48 83 e0 20	 and	 rax, 32			; 00000020H
  01ab4	48 85 c0	 test	 rax, rax
  01ab7	74 3e		 je	 SHORT $LN152@s370_progr
  01ab9	48 63 84 24 c8
	01 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  01ac1	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01aca	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01ad3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170424
  01ada	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01adf	45 33 c9	 xor	 r9d, r9d
  01ae2	4c 8b c0	 mov	 r8, rax
  01ae5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170425
  01aec	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01af1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN152@s370_progr:
  01af7	33 c0		 xor	 eax, eax
  01af9	85 c0		 test	 eax, eax
  01afb	75 a9		 jne	 SHORT $LN58@s370_progr

; 1332 :                 longjmp( realregs->progjmp, pcode );

  01afd	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01b02	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  01b08	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  01b0f	48 8b c8	 mov	 rcx, rax
  01b12	e8 00 00 00 00	 call	 longjmp

; 1333 :             }

  01b17	eb 0e		 jmp	 SHORT $LN150@s370_progr
$LN149@s370_progr:

; 1334 :             else
; 1335 : #endif
; 1336 :             {
; 1337 :                 /* Invalid pgmnew: ==> program interrupt loop */
; 1338 :                 pgmintloop = detect_pgmintloop;

  01b19	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR detect_pgmintloop$2[rsp]
  01b20	89 84 24 94 00
	00 00		 mov	 DWORD PTR pgmintloop$3[rsp], eax
$LN150@s370_progr:

; 1339 :             }
; 1340 :         }

  01b27	e9 87 00 00 00	 jmp	 $LN148@s370_progr
$LN147@s370_progr:

; 1341 :         else if (detect_pgmintloop)

  01b2c	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR detect_pgmintloop$2[rsp], 0
  01b34	74 7d		 je	 SHORT $LN153@s370_progr

; 1342 :         {
; 1343 :             /* Save program new psw */
; 1344 :             memcpy( &pgmnew, &realregs->psw, sizeof( PSW ));

  01b36	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR pgmnew$5[rsp]
  01b3e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01b43	48 8b f8	 mov	 rdi, rax
  01b46	48 8d 71 78	 lea	 rsi, QWORD PTR [rcx+120]
  01b4a	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  01b4f	f3 a4		 rep movsb

; 1345 :             pgmnew.cc      = 0;

  01b51	c6 84 24 04 01
	00 00 00	 mov	 BYTE PTR pgmnew$5[rsp+4], 0

; 1346 :             pgmnew.intcode = 0;

  01b59	33 c0		 xor	 eax, eax
  01b5b	66 89 84 24 20
	01 00 00	 mov	 WORD PTR pgmnew$5[rsp+32], ax

; 1347 :             pgmnew.ilc     = 0;

  01b63	c6 84 24 22 01
	00 00 00	 mov	 BYTE PTR pgmnew$5[rsp+34], 0

; 1348 : 
; 1349 :             /* Adjust pgmold instruction address */
; 1350 :             pgmold.ia.D -= ilc;

  01b6b	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  01b73	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pgmold$4[rsp+16]
  01b7b	48 2b c8	 sub	 rcx, rax
  01b7e	48 8b c1	 mov	 rax, rcx
  01b81	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pgmold$4[rsp+16], rax

; 1351 : 
; 1352 :             /* Check for program interrupt loop (old==new) */
; 1353 :             if (memcmp( &pgmold, &pgmnew, sizeof( PSW )) == 0)

  01b89	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  01b8f	48 8d 94 24 00
	01 00 00	 lea	 rdx, QWORD PTR pgmnew$5[rsp]
  01b97	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR pgmold$4[rsp]
  01b9f	e8 00 00 00 00	 call	 memcmp
  01ba4	85 c0		 test	 eax, eax
  01ba6	75 0b		 jne	 SHORT $LN154@s370_progr

; 1354 :                 pgmintloop = 1;

  01ba8	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR pgmintloop$3[rsp], 1
$LN154@s370_progr:
$LN153@s370_progr:
$LN148@s370_progr:

; 1355 :         }
; 1356 : 
; 1357 :         if (pgmintloop)

  01bb3	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR pgmintloop$3[rsp], 0
  01bbb	0f 84 41 01 00
	00		 je	 $LN155@s370_progr

; 1358 :         {
; 1359 :             char buf[64];
; 1360 :             STR_PSW( realregs, buf );

  01bc1	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  01bc7	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR buf$7[rsp]
  01bcf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01bd4	e8 00 00 00 00	 call	 str_psw

; 1361 : 
; 1362 :             if (regs->insttrace && sysblk.traceFILE)

  01bd9	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01be1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01be7	c1 e8 0f	 shr	 eax, 15
  01bea	83 e0 01	 and	 eax, 1
  01bed	85 c0		 test	 eax, eax
  01bef	74 24		 je	 SHORT $LN156@s370_progr
  01bf1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01bf8	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  01c00	74 13		 je	 SHORT $LN156@s370_progr

; 1363 :                 tf_0803( realregs, buf );

  01c02	48 8d 94 24 50
	01 00 00	 lea	 rdx, QWORD PTR buf$7[rsp]
  01c0a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0803
$LN156@s370_progr:

; 1364 : 
; 1365 :             // "Processor %s%02X: program interrupt loop PSW %s"
; 1366 :             WRMSG( HHC00803, "I", PTYPSTR( realregs->cpuad ),

  01c15	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01c1a	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  01c21	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv1152[rsp], eax
  01c28	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01c2d	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  01c34	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  01c3b	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  01c43	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  01c49	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv1154[rsp], rax
  01c51	b9 01 00 00 00	 mov	 ecx, 1
  01c56	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01c5c	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$7[rsp]
  01c64	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01c69	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv1152[rsp]
  01c70	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01c74	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv1154[rsp]
  01c7c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  01c81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170430
  01c88	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01c8d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170431
  01c94	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01c99	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01c9e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01ca4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170432
  01cab	ba 57 05 00 00	 mov	 edx, 1367		; 00000557H
  01cb0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170433
  01cb7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1367 :                 realregs->cpuad, buf );
; 1368 : 
; 1369 :             OBTAIN_INTLOCK( realregs );

  01cbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170434
  01cc4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01cc9	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 1370 :             {
; 1371 :                 realregs->cpustate = CPUSTATE_STOPPING;

  01cce	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01cd3	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN61@s370_progr:

; 1372 :                 ON_IC_INTERRUPT( realregs );

  01cd7	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01cdc	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01cdf	0f ba e8 1f	 bts	 eax, 31
  01ce3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01ce8	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  01ceb	33 c0		 xor	 eax, eax
  01ced	85 c0		 test	 eax, eax
  01cef	75 e6		 jne	 SHORT $LN61@s370_progr

; 1373 :             }
; 1374 :             RELEASE_INTLOCK( realregs );

  01cf1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170435
  01cf8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR realregs$[rsp]
  01cfd	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN155@s370_progr:
$LN64@s370_progr:

; 1375 :         }
; 1376 : 
; 1377 :         /*-----------------------------------------------------------*/
; 1378 :         /*  Normal non-intercepted program interrupt: return to      */
; 1379 :         /*  either the run_cpu or run_sie loop and start executing   */
; 1380 :         /*  instructions again, but at Program New PSW instead.      */
; 1381 :         /*-----------------------------------------------------------*/
; 1382 : 
; 1383 :         PTT_PGM( "PGM !icept", intercept, 0, 0 );

  01d02	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01d09	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01d0c	48 83 e0 20	 and	 rax, 32			; 00000020H
  01d10	48 85 c0	 test	 rax, rax
  01d13	74 3b		 je	 SHORT $LN157@s370_progr
  01d15	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01d1a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01d23	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01d2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170437
  01d33	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01d38	45 33 c9	 xor	 r9d, r9d
  01d3b	44 8b c0	 mov	 r8d, eax
  01d3e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170438
  01d45	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01d4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN157@s370_progr:
  01d50	33 c0		 xor	 eax, eax
  01d52	85 c0		 test	 eax, eax
  01d54	75 ac		 jne	 SHORT $LN64@s370_progr
$LN67@s370_progr:

; 1384 :         PTT_PGM( "PGM progjmp", SIE_NO_INTERCEPT, 0, 0 );

  01d56	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01d5d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01d60	48 83 e0 20	 and	 rax, 32			; 00000020H
  01d64	48 85 c0	 test	 rax, rax
  01d67	74 3a		 je	 SHORT $LN158@s370_progr
  01d69	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01d72	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01d7b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170440
  01d82	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d87	45 33 c9	 xor	 r9d, r9d
  01d8a	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  01d91	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170441
  01d98	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01d9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN158@s370_progr:
  01da3	33 c0		 xor	 eax, eax
  01da5	85 c0		 test	 eax, eax
  01da7	75 ad		 jne	 SHORT $LN67@s370_progr

; 1385 :         longjmp( realregs->progjmp, SIE_NO_INTERCEPT );

  01da9	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01dae	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  01db4	ba ff ff ff ff	 mov	 edx, -1
  01db9	48 8b c8	 mov	 rcx, rax
  01dbc	e8 00 00 00 00	 call	 longjmp
$LN145@s370_progr:
$LN70@s370_progr:

; 1386 :     }
; 1387 : 
; 1388 : #if defined( _FEATURE_SIE )
; 1389 :     /*---------------------------------------------------------------*/
; 1390 :     /*  We're in SIE mode and SIE host MUST intercept this program   */
; 1391 :     /*  interrupt. Jump back to the run_sie loop with the interrupt  */
; 1392 :     /*  code so it can break out of its instruction execution loop   */
; 1393 :     /*  and exit from run_sie back to sie_exit so the interrupt can  */
; 1394 :     /*  be passed on to the SIE host for handling.                   */
; 1395 :     /*---------------------------------------------------------------*/
; 1396 : 
; 1397 :     PTT_PGM( "PGM icept", intercept, 0, 0 );

  01dc1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01dc8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01dcb	48 83 e0 20	 and	 rax, 32			; 00000020H
  01dcf	48 85 c0	 test	 rax, rax
  01dd2	74 3b		 je	 SHORT $LN159@s370_progr
  01dd4	0f b6 44 24 7c	 movzx	 eax, BYTE PTR intercept$[rsp]
  01dd9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01de2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01deb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170443
  01df2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01df7	45 33 c9	 xor	 r9d, r9d
  01dfa	44 8b c0	 mov	 r8d, eax
  01dfd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170444
  01e04	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01e09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN159@s370_progr:
  01e0f	33 c0		 xor	 eax, eax
  01e11	85 c0		 test	 eax, eax
  01e13	75 ac		 jne	 SHORT $LN70@s370_progr
$LN73@s370_progr:

; 1398 :     PTT_PGM( "PGM progjmp", pcode, 0, 0 );

  01e15	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01e1c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01e1f	48 83 e0 20	 and	 rax, 32			; 00000020H
  01e23	48 85 c0	 test	 rax, rax
  01e26	74 3e		 je	 SHORT $LN160@s370_progr
  01e28	48 63 84 24 c8
	01 00 00	 movsxd	 rax, DWORD PTR pcode$[rsp]
  01e30	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01e39	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01e42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170446
  01e49	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01e4e	45 33 c9	 xor	 r9d, r9d
  01e51	4c 8b c0	 mov	 r8, rax
  01e54	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170447
  01e5b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  01e60	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN160@s370_progr:
  01e66	33 c0		 xor	 eax, eax
  01e68	85 c0		 test	 eax, eax
  01e6a	75 a9		 jne	 SHORT $LN73@s370_progr

; 1399 :     longjmp( realregs->progjmp, pcode );

  01e6c	48 8b 44 24 70	 mov	 rax, QWORD PTR realregs$[rsp]
  01e71	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  01e77	8b 94 24 c8 01
	00 00		 mov	 edx, DWORD PTR pcode$[rsp]
  01e7e	48 8b c8	 mov	 rcx, rax
  01e81	e8 00 00 00 00	 call	 longjmp
$LN161@s370_progr:

; 1400 : #endif
; 1401 : 
; 1402 : } /* end function ARCH_DEP( program_interrupt ) */

  01e86	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01e8e	48 33 cc	 xor	 rcx, rsp
  01e91	e8 00 00 00 00	 call	 __security_check_cookie
  01e96	48 81 c4 a8 01
	00 00		 add	 rsp, 424		; 000001a8H
  01e9d	5f		 pop	 rdi
  01e9e	5e		 pop	 rsi
  01e9f	c3		 ret	 0
s370_program_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
started$ = 80
stopped$ = 81
cpu$ = 84
i$1 = 88
i$2 = 92
mask$3 = 96
mask$4 = 104
do_automatic_tracing PROC

; 2716 : {

$LN29:
  00000	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2717 :     static U64  inst_count;         // (current sysblk.instcount)
; 2718 :     static U64  missed_by;          // (how far past trigger we went)
; 2719 :     static U64  too_much;           // (num extra instructions traced)
; 2720 : 
; 2721 :     bool started = false, stopped = false;

  00004	c6 44 24 50 00	 mov	 BYTE PTR started$[rsp], 0
  00009	c6 44 24 51 00	 mov	 BYTE PTR stopped$[rsp], 0

; 2722 :     int cpu;
; 2723 : 
; 2724 :     /* Return immediately if automatic tracing not enabled or active */
; 2725 :     if (!sysblk.auto_trace_amt)

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	48 83 b8 f0 12
	00 00 00	 cmp	 QWORD PTR [rax+4848], 0
  0001d	75 05		 jne	 SHORT $LN17@do_automat

; 2726 :         return;

  0001f	e9 2c 04 00 00	 jmp	 $LN1@do_automat
$LN17@do_automat:

; 2727 : 
; 2728 :     OBTAIN_INTLOCK( NULL );

  00024	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197121
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2729 :     {
; 2730 :         static U64  beg_count  = 0;     // (when auto-tracing began)
; 2731 : 
; 2732 :         static U64  auto_trace_beg;     // (instrcount to begin tracing)
; 2733 :         static U64  auto_trace_amt;     // (amt of instruction to trace)
; 2734 : 
; 2735 :         static U64  traced_amt;         // (amt instr. traced so far)
; 2736 : 
; 2737 :         /* Check again under control of INTLOCK */
; 2738 :         if (!sysblk.auto_trace_amt)

  00032	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00039	48 83 b8 f0 12
	00 00 00	 cmp	 QWORD PTR [rax+4848], 0
  00041	75 13		 jne	 SHORT $LN18@do_automat

; 2739 :         {
; 2740 :             RELEASE_INTLOCK( NULL );

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197123
  0004a	33 c9		 xor	 ecx, ecx
  0004c	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2741 :             return;

  00051	e9 fa 03 00 00	 jmp	 $LN1@do_automat
$LN18@do_automat:

; 2742 :         }
; 2743 : 
; 2744 :         auto_trace_beg  = sysblk.auto_trace_beg;

  00056	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005d	48 8b 80 e8 12
	00 00		 mov	 rax, QWORD PTR [rax+4840]
  00064	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?auto_trace_beg@?2??do_automatic_tracing@@9@9, rax

; 2745 :         auto_trace_amt  = sysblk.auto_trace_amt;

  0006b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00072	48 8b 80 f0 12
	00 00		 mov	 rax, QWORD PTR [rax+4848]
  00079	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?auto_trace_amt@?2??do_automatic_tracing@@9@9, rax

; 2746 :         inst_count      = sysblk.instcount;

  00080	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00087	48 8b 80 80 14
	00 00		 mov	 rax, QWORD PTR [rax+5248]
  0008e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?inst_count@?1??do_automatic_tracing@@9@9, rax

; 2747 : 
; 2748 :         /* Should Automatic Tracing be started? */
; 2749 :         if (1
; 2750 :             && !beg_count                       // (hasn't begun yet?)
; 2751 :             && inst_count >= auto_trace_beg     // (but it should be?)

  00095	33 c0		 xor	 eax, eax
  00097	83 f8 01	 cmp	 eax, 1
  0009a	0f 84 0d 01 00
	00		 je	 $LN19@do_automat
  000a0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?beg_count@?2??do_automatic_tracing@@9@9, 0
  000a8	0f 85 ff 00 00
	00		 jne	 $LN19@do_automat
  000ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?auto_trace_beg@?2??do_automatic_tracing@@9@9
  000b5	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?inst_count@?1??do_automatic_tracing@@9@9, rax
  000bc	0f 82 eb 00 00
	00		 jb	 $LN19@do_automat

; 2752 :         )
; 2753 :         {
; 2754 :             started = true;                     // (remember started)

  000c2	c6 44 24 50 01	 mov	 BYTE PTR started$[rsp], 1

; 2755 :             beg_count = inst_count;             // (when it was begun)

  000c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?inst_count@?1??do_automatic_tracing@@9@9
  000ce	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?beg_count@?2??do_automatic_tracing@@9@9, rax

; 2756 :             missed_by = (inst_count - auto_trace_beg);

  000d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?auto_trace_beg@?2??do_automatic_tracing@@9@9
  000dc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst_count@?1??do_automatic_tracing@@9@9
  000e3	48 2b c8	 sub	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?missed_by@?1??do_automatic_tracing@@9@9, rax

; 2757 :             sysblk.insttrace = true;            // (activate tracing)

  000f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000fd	0f ba e8 08	 bts	 eax, 8
  00101	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00108	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 2758 :             sysblk.auto_trace_beg = 0;          // (prevent re-trigger)

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00115	48 c7 80 e8 12
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4840], 0
$LN4@do_automat:

; 2759 :             SET_IC_TRACE;                       // (force interrupt)

  00120	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00127	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0012e	48 89 44 24 60	 mov	 QWORD PTR mask$3[rsp], rax
  00133	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  0013b	eb 0a		 jmp	 SHORT $LN7@do_automat
$LN5@do_automat:
  0013d	8b 44 24 58	 mov	 eax, DWORD PTR i$1[rsp]
  00141	ff c0		 inc	 eax
  00143	89 44 24 58	 mov	 DWORD PTR i$1[rsp], eax
$LN7@do_automat:
  00147	48 83 7c 24 60
	00		 cmp	 QWORD PTR mask$3[rsp], 0
  0014d	74 4f		 je	 SHORT $LN6@do_automat
  0014f	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$3[rsp]
  00154	48 83 e0 01	 and	 rax, 1
  00158	48 85 c0	 test	 rax, rax
  0015b	74 32		 je	 SHORT $LN21@do_automat
  0015d	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$1[rsp]
  00162	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00169	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00171	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00174	0f ba e8 1f	 bts	 eax, 31
  00178	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0017d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00184	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0018c	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN21@do_automat:
  0018f	48 8b 44 24 60	 mov	 rax, QWORD PTR mask$3[rsp]
  00194	48 d1 e8	 shr	 rax, 1
  00197	48 89 44 24 60	 mov	 QWORD PTR mask$3[rsp], rax
  0019c	eb 9f		 jmp	 SHORT $LN5@do_automat
$LN6@do_automat:
  0019e	33 c0		 xor	 eax, eax
  001a0	85 c0		 test	 eax, eax
  001a2	0f 85 78 ff ff
	ff		 jne	 $LN4@do_automat

; 2760 :         }

  001a8	e9 2b 01 00 00	 jmp	 $LN20@do_automat
$LN19@do_automat:

; 2761 : 
; 2762 :         /* Should Automatic Tracing be stopped? */
; 2763 :         else if (1
; 2764 :             && beg_count
; 2765 :             && (traced_amt = (inst_count - beg_count)) >= auto_trace_amt

  001ad	33 c0		 xor	 eax, eax
  001af	83 f8 01	 cmp	 eax, 1
  001b2	0f 84 20 01 00
	00		 je	 $LN22@do_automat
  001b8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?beg_count@?2??do_automatic_tracing@@9@9, 0
  001c0	0f 84 12 01 00
	00		 je	 $LN22@do_automat
  001c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?beg_count@?2??do_automatic_tracing@@9@9
  001cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst_count@?1??do_automatic_tracing@@9@9
  001d4	48 2b c8	 sub	 rcx, rax
  001d7	48 8b c1	 mov	 rax, rcx
  001da	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?traced_amt@?2??do_automatic_tracing@@9@9, rax
  001e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?auto_trace_amt@?2??do_automatic_tracing@@9@9
  001e8	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?traced_amt@?2??do_automatic_tracing@@9@9, rax
  001ef	0f 82 e3 00 00
	00		 jb	 $LN22@do_automat

; 2766 :         )
; 2767 :         {
; 2768 :             stopped = true;                     // (remember stopped)

  001f5	c6 44 24 51 01	 mov	 BYTE PTR stopped$[rsp], 1

; 2769 :             beg_count = 0;                      // (reset for next time)

  001fa	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ?beg_count@?2??do_automatic_tracing@@9@9, 0

; 2770 :             too_much = (traced_amt - auto_trace_amt);

  00205	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?auto_trace_amt@?2??do_automatic_tracing@@9@9
  0020c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?traced_amt@?2??do_automatic_tracing@@9@9
  00213	48 2b c8	 sub	 rcx, rax
  00216	48 8b c1	 mov	 rax, rcx
  00219	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?too_much@?1??do_automatic_tracing@@9@9, rax

; 2771 :             sysblk.insttrace = false;           // (deactivate tracing)

  00220	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00227	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0022d	0f ba f0 08	 btr	 eax, 8
  00231	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00238	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 2772 :             sysblk.auto_trace_amt = 0;          // (prevent re-trigger)

  0023e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00245	48 c7 80 f0 12
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4848], 0
$LN10@do_automat:

; 2773 :             SET_IC_TRACE;                       // (force interrupt)

  00250	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00257	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0025e	48 89 44 24 68	 mov	 QWORD PTR mask$4[rsp], rax
  00263	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0
  0026b	eb 0a		 jmp	 SHORT $LN13@do_automat
$LN11@do_automat:
  0026d	8b 44 24 5c	 mov	 eax, DWORD PTR i$2[rsp]
  00271	ff c0		 inc	 eax
  00273	89 44 24 5c	 mov	 DWORD PTR i$2[rsp], eax
$LN13@do_automat:
  00277	48 83 7c 24 68
	00		 cmp	 QWORD PTR mask$4[rsp], 0
  0027d	74 4f		 je	 SHORT $LN12@do_automat
  0027f	48 8b 44 24 68	 mov	 rax, QWORD PTR mask$4[rsp]
  00284	48 83 e0 01	 and	 rax, 1
  00288	48 85 c0	 test	 rax, rax
  0028b	74 32		 je	 SHORT $LN23@do_automat
  0028d	48 63 44 24 5c	 movsxd	 rax, DWORD PTR i$2[rsp]
  00292	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00299	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  002a1	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002a4	0f ba e8 1f	 bts	 eax, 31
  002a8	48 63 4c 24 5c	 movsxd	 rcx, DWORD PTR i$2[rsp]
  002ad	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002b4	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  002bc	89 41 48	 mov	 DWORD PTR [rcx+72], eax
$LN23@do_automat:
  002bf	48 8b 44 24 68	 mov	 rax, QWORD PTR mask$4[rsp]
  002c4	48 d1 e8	 shr	 rax, 1
  002c7	48 89 44 24 68	 mov	 QWORD PTR mask$4[rsp], rax
  002cc	eb 9f		 jmp	 SHORT $LN11@do_automat
$LN12@do_automat:
  002ce	33 c0		 xor	 eax, eax
  002d0	85 c0		 test	 eax, eax
  002d2	0f 85 78 ff ff
	ff		 jne	 $LN10@do_automat
$LN22@do_automat:
$LN20@do_automat:

; 2774 :         }
; 2775 : 
; 2776 :         /* Enable/disable CPU tracing based on overall trace status */
; 2777 :         for (cpu=0; cpu < sysblk.maxcpu; cpu++)

  002d8	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
  002e0	eb 0a		 jmp	 SHORT $LN16@do_automat
$LN14@do_automat:
  002e2	8b 44 24 54	 mov	 eax, DWORD PTR cpu$[rsp]
  002e6	ff c0		 inc	 eax
  002e8	89 44 24 54	 mov	 DWORD PTR cpu$[rsp], eax
$LN16@do_automat:
  002ec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f3	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002f9	39 44 24 54	 cmp	 DWORD PTR cpu$[rsp], eax
  002fd	7d 71		 jge	 SHORT $LN15@do_automat

; 2778 :         {
; 2779 :             if (IS_CPU_ONLINE( cpu ))

  002ff	48 63 44 24 54	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00304	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0030b	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00314	74 55		 je	 SHORT $LN24@do_automat

; 2780 :                 sysblk.regs[ cpu ]->insttrace = sysblk.insttrace;

  00316	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0031d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00323	c1 e8 08	 shr	 eax, 8
  00326	83 e0 01	 and	 eax, 1
  00329	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  0032e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00335	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  0033d	83 e0 01	 and	 eax, 1
  00340	c1 e0 0f	 shl	 eax, 15
  00343	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00349	0f ba f1 0f	 btr	 ecx, 15
  0034d	0b c8		 or	 ecx, eax
  0034f	8b c1		 mov	 eax, ecx
  00351	48 63 4c 24 54	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  00356	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0035d	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00365	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN24@do_automat:

; 2781 :         }

  0036b	e9 72 ff ff ff	 jmp	 $LN14@do_automat
$LN15@do_automat:

; 2782 :     }
; 2783 :     RELEASE_INTLOCK( NULL );

  00370	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG197130
  00377	33 c9		 xor	 ecx, ecx
  00379	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2784 : 
; 2785 :     if (started)

  0037e	0f b6 44 24 50	 movzx	 eax, BYTE PTR started$[rsp]
  00383	85 c0		 test	 eax, eax
  00385	74 61		 je	 SHORT $LN25@do_automat

; 2786 :     {
; 2787 :         // "Automatic tracing started at instrcount %"PRIu64" (BEG+%"PRIu64")"
; 2788 :         WRMSG( HHC02370, "I", inst_count, missed_by );

  00387	b9 01 00 00 00	 mov	 ecx, 1
  0038c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00392	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?missed_by@?1??do_automatic_tracing@@9@9
  00399	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0039e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst_count@?1??do_automatic_tracing@@9@9
  003a5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197133
  003b1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197134
  003bd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c7	41 b9 03 00 00
	00		 mov	 r9d, 3
  003cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG197135
  003d4	ba e4 0a 00 00	 mov	 edx, 2788		; 00000ae4H
  003d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197136
  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2789 :     }

  003e6	eb 68		 jmp	 SHORT $LN26@do_automat
$LN25@do_automat:

; 2790 :     else if (stopped)

  003e8	0f b6 44 24 51	 movzx	 eax, BYTE PTR stopped$[rsp]
  003ed	85 c0		 test	 eax, eax
  003ef	74 5f		 je	 SHORT $LN27@do_automat

; 2791 :     {
; 2792 :         // "Automatic tracing stopped at instrcount %"PRIu64" (AMT+%"PRIu64")"
; 2793 :         WRMSG( HHC02371, "I", inst_count, too_much );

  003f1	b9 01 00 00 00	 mov	 ecx, 1
  003f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003fc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?too_much@?1??do_automatic_tracing@@9@9
  00403	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00408	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?inst_count@?1??do_automatic_tracing@@9@9
  0040f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00414	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197138
  0041b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00420	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197139
  00427	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0042c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00431	41 b9 03 00 00
	00		 mov	 r9d, 3
  00437	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG197140
  0043e	ba e9 0a 00 00	 mov	 edx, 2793		; 00000ae9H
  00443	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG197141
  0044a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN27@do_automat:
$LN26@do_automat:
$LN1@do_automat:

; 2794 :     }
; 2795 : }

  00450	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00454	c3		 ret	 0
do_automatic_tracing ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv198 = 160
tv202 = 164
qword$ = 168
__$ArrayPad$ = 184
arch_mode$ = 272
regs$ = 280
buf$ = 288
buflen$ = 296
str_arch_psw PROC

; 2686 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	53		 push	 rbx
  00014	55		 push	 rbp
  00015	56		 push	 rsi
  00016	57		 push	 rdi
  00017	41 54		 push	 r12
  00019	41 55		 push	 r13
  0001b	41 56		 push	 r14
  0001d	41 57		 push	 r15
  0001f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2687 :     QWORD   qword   = {0};                /* quadword work area      */

  00038	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR qword$[rsp]
  00040	48 8b f8	 mov	 rdi, rax
  00043	33 c0		 xor	 eax, eax
  00045	b9 10 00 00 00	 mov	 ecx, 16
  0004a	f3 aa		 rep stosb

; 2688 : 
; 2689 :     copy_psw( regs, qword );

  0004c	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR qword$[rsp]
  00054	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005c	e8 00 00 00 00	 call	 copy_psw

; 2690 : 
; 2691 :     if (arch_mode != ARCH_900_IDX)

  00061	83 bc 24 10 01
	00 00 02	 cmp	 DWORD PTR arch_mode$[rsp], 2
  00069	0f 84 d7 00 00
	00		 je	 $LN2@str_arch_p

; 2692 :     {
; 2693 :         snprintf( buf, buflen,

  0006f	b8 01 00 00 00	 mov	 eax, 1
  00074	48 6b c0 07	 imul	 rax, rax, 7
  00078	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR qword$[rsp+rax]
  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	48 6b c9 06	 imul	 rcx, rcx, 6
  00089	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR qword$[rsp+rcx]
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	48 6b d2 05	 imul	 rdx, rdx, 5
  0009a	0f b6 94 14 a8
	00 00 00	 movzx	 edx, BYTE PTR qword$[rsp+rdx]
  000a2	bf 01 00 00 00	 mov	 edi, 1
  000a7	48 6b ff 04	 imul	 rdi, rdi, 4
  000ab	0f b6 bc 3c a8
	00 00 00	 movzx	 edi, BYTE PTR qword$[rsp+rdi]
  000b3	41 b8 01 00 00
	00		 mov	 r8d, 1
  000b9	4d 6b c0 03	 imul	 r8, r8, 3
  000bd	46 0f b6 84 04
	a8 00 00 00	 movzx	 r8d, BYTE PTR qword$[rsp+r8]
  000c6	41 b9 01 00 00
	00		 mov	 r9d, 1
  000cc	4d 6b c9 02	 imul	 r9, r9, 2
  000d0	46 0f b6 8c 0c
	a8 00 00 00	 movzx	 r9d, BYTE PTR qword$[rsp+r9]
  000d9	41 ba 01 00 00
	00		 mov	 r10d, 1
  000df	4d 6b d2 01	 imul	 r10, r10, 1
  000e3	46 0f b6 94 14
	a8 00 00 00	 movzx	 r10d, BYTE PTR qword$[rsp+r10]
  000ec	41 bb 01 00 00
	00		 mov	 r11d, 1
  000f2	4d 6b db 00	 imul	 r11, r11, 0
  000f6	46 0f b6 9c 1c
	a8 00 00 00	 movzx	 r11d, BYTE PTR qword$[rsp+r11]
  000ff	48 63 9c 24 28
	01 00 00	 movsxd	 rbx, DWORD PTR buflen$[rsp]
  00107	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0010b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0010f	89 54 24 40	 mov	 DWORD PTR [rsp+64], edx
  00113	89 7c 24 38	 mov	 DWORD PTR [rsp+56], edi
  00117	44 89 44 24 30	 mov	 DWORD PTR [rsp+48], r8d
  0011c	44 89 4c 24 28	 mov	 DWORD PTR [rsp+40], r9d
  00121	44 89 54 24 20	 mov	 DWORD PTR [rsp+32], r10d
  00126	45 8b cb	 mov	 r9d, r11d
  00129	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG197075
  00130	48 8b d3	 mov	 rdx, rbx
  00133	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2694 :             "%2.2X%2.2X%2.2X%2.2X %2.2X%2.2X%2.2X%2.2X",
; 2695 :             qword[0], qword[1], qword[2], qword[3],
; 2696 :             qword[4], qword[5], qword[6], qword[7] );
; 2697 :     }

  00141	e9 af 01 00 00	 jmp	 $LN3@str_arch_p
$LN2@str_arch_p:

; 2698 :     else
; 2699 :     {
; 2700 :         snprintf( buf, buflen,

  00146	b8 01 00 00 00	 mov	 eax, 1
  0014b	48 6b c0 0f	 imul	 rax, rax, 15
  0014f	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR qword$[rsp+rax]
  00157	b9 01 00 00 00	 mov	 ecx, 1
  0015c	48 6b c9 0e	 imul	 rcx, rcx, 14
  00160	0f b6 8c 0c a8
	00 00 00	 movzx	 ecx, BYTE PTR qword$[rsp+rcx]
  00168	ba 01 00 00 00	 mov	 edx, 1
  0016d	48 6b d2 0d	 imul	 rdx, rdx, 13
  00171	0f b6 94 14 a8
	00 00 00	 movzx	 edx, BYTE PTR qword$[rsp+rdx]
  00179	bb 01 00 00 00	 mov	 ebx, 1
  0017e	48 6b db 0c	 imul	 rbx, rbx, 12
  00182	0f b6 9c 1c a8
	00 00 00	 movzx	 ebx, BYTE PTR qword$[rsp+rbx]
  0018a	bf 01 00 00 00	 mov	 edi, 1
  0018f	48 6b ff 0b	 imul	 rdi, rdi, 11
  00193	0f b6 bc 3c a8
	00 00 00	 movzx	 edi, BYTE PTR qword$[rsp+rdi]
  0019b	41 b8 01 00 00
	00		 mov	 r8d, 1
  001a1	4d 6b c0 0a	 imul	 r8, r8, 10
  001a5	46 0f b6 84 04
	a8 00 00 00	 movzx	 r8d, BYTE PTR qword$[rsp+r8]
  001ae	41 b9 01 00 00
	00		 mov	 r9d, 1
  001b4	4d 6b c9 09	 imul	 r9, r9, 9
  001b8	46 0f b6 8c 0c
	a8 00 00 00	 movzx	 r9d, BYTE PTR qword$[rsp+r9]
  001c1	41 ba 01 00 00
	00		 mov	 r10d, 1
  001c7	4d 6b d2 08	 imul	 r10, r10, 8
  001cb	46 0f b6 94 14
	a8 00 00 00	 movzx	 r10d, BYTE PTR qword$[rsp+r10]
  001d4	41 bb 01 00 00
	00		 mov	 r11d, 1
  001da	4d 6b db 07	 imul	 r11, r11, 7
  001de	46 0f b6 9c 1c
	a8 00 00 00	 movzx	 r11d, BYTE PTR qword$[rsp+r11]
  001e7	be 01 00 00 00	 mov	 esi, 1
  001ec	48 6b f6 06	 imul	 rsi, rsi, 6
  001f0	0f b6 b4 34 a8
	00 00 00	 movzx	 esi, BYTE PTR qword$[rsp+rsi]
  001f8	bd 01 00 00 00	 mov	 ebp, 1
  001fd	48 6b ed 05	 imul	 rbp, rbp, 5
  00201	0f b6 ac 2c a8
	00 00 00	 movzx	 ebp, BYTE PTR qword$[rsp+rbp]
  00209	41 be 01 00 00
	00		 mov	 r14d, 1
  0020f	4d 6b f6 04	 imul	 r14, r14, 4
  00213	46 0f b6 b4 34
	a8 00 00 00	 movzx	 r14d, BYTE PTR qword$[rsp+r14]
  0021c	41 bf 01 00 00
	00		 mov	 r15d, 1
  00222	4d 6b ff 03	 imul	 r15, r15, 3
  00226	46 0f b6 bc 3c
	a8 00 00 00	 movzx	 r15d, BYTE PTR qword$[rsp+r15]
  0022f	41 bc 01 00 00
	00		 mov	 r12d, 1
  00235	4d 6b e4 02	 imul	 r12, r12, 2
  00239	46 0f b6 a4 24
	a8 00 00 00	 movzx	 r12d, BYTE PTR qword$[rsp+r12]
  00242	41 bd 01 00 00
	00		 mov	 r13d, 1
  00248	4d 6b ed 01	 imul	 r13, r13, 1
  0024c	46 0f b6 ac 2c
	a8 00 00 00	 movzx	 r13d, BYTE PTR qword$[rsp+r13]
  00255	44 89 ac 24 a0
	00 00 00	 mov	 DWORD PTR tv198[rsp], r13d
  0025d	41 bd 01 00 00
	00		 mov	 r13d, 1
  00263	4d 6b ed 00	 imul	 r13, r13, 0
  00267	46 0f b6 ac 2c
	a8 00 00 00	 movzx	 r13d, BYTE PTR qword$[rsp+r13]
  00270	44 89 ac 24 a4
	00 00 00	 mov	 DWORD PTR tv202[rsp], r13d
  00278	4c 63 ac 24 28
	01 00 00	 movsxd	 r13, DWORD PTR buflen$[rsp]
  00280	89 84 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], eax
  00287	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  0028e	89 94 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], edx
  00295	89 5c 24 78	 mov	 DWORD PTR [rsp+120], ebx
  00299	89 7c 24 70	 mov	 DWORD PTR [rsp+112], edi
  0029d	44 89 44 24 68	 mov	 DWORD PTR [rsp+104], r8d
  002a2	44 89 4c 24 60	 mov	 DWORD PTR [rsp+96], r9d
  002a7	44 89 54 24 58	 mov	 DWORD PTR [rsp+88], r10d
  002ac	44 89 5c 24 50	 mov	 DWORD PTR [rsp+80], r11d
  002b1	89 74 24 48	 mov	 DWORD PTR [rsp+72], esi
  002b5	89 6c 24 40	 mov	 DWORD PTR [rsp+64], ebp
  002b9	44 89 74 24 38	 mov	 DWORD PTR [rsp+56], r14d
  002be	44 89 7c 24 30	 mov	 DWORD PTR [rsp+48], r15d
  002c3	44 89 64 24 28	 mov	 DWORD PTR [rsp+40], r12d
  002c8	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv198[rsp]
  002cf	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002d3	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv202[rsp]
  002da	44 8b c8	 mov	 r9d, eax
  002dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG197076
  002e4	49 8b d5	 mov	 rdx, r13
  002e7	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN3@str_arch_p:

; 2701 :             "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X "
; 2702 :             "%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X%2.2X",
; 2703 :             qword[ 0], qword[ 1], qword[ 2], qword[ 3],
; 2704 :             qword[ 4], qword[ 5], qword[ 6], qword[ 7],
; 2705 :             qword[ 8], qword[ 9], qword[10], qword[11],
; 2706 :             qword[12], qword[13], qword[14], qword[15] );
; 2707 :     }
; 2708 : 
; 2709 :     return buf;

  002f5	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR buf$[rsp]

; 2710 : }

  002fd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00305	48 33 cc	 xor	 rcx, rsp
  00308	e8 00 00 00 00	 call	 __security_check_cookie
  0030d	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00314	41 5f		 pop	 r15
  00316	41 5e		 pop	 r14
  00318	41 5d		 pop	 r13
  0031a	41 5c		 pop	 r12
  0031c	5f		 pop	 rdi
  0031d	5e		 pop	 rsi
  0031e	5d		 pop	 rbp
  0031f	5b		 pop	 rbx
  00320	c3		 ret	 0
str_arch_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 48
buf$ = 56
buflen$ = 64
str_psw	PROC

; 2678 : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2679 :     return str_arch_psw( regs->arch_mode, regs, buf, buflen );

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR buflen$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR buf$[rsp]
  0001d	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00027	8b 48 64	 mov	 ecx, DWORD PTR [rax+100]
  0002a	e8 00 00 00 00	 call	 str_arch_psw

; 2680 : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
str_psw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv70 = 32
arch_mode$ = 36
regs$ = 64
buf$ = 72
buflen$ = 80
display_psw PROC

; 2666 : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2667 :     /* Use the architecture mode from SYSBLK if load indicator
; 2668 :        shows IPL in process, otherwise use archmode from REGS */
; 2669 :     int arch_mode = (regs->loadstate) ? sysblk.arch_mode

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00018	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001e	c1 e8 0c	 shr	 eax, 12
  00021	83 e0 01	 and	 eax, 1
  00024	85 c0		 test	 eax, eax
  00026	74 13		 je	 SHORT $LN3@display_ps
  00028	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002f	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00035	89 44 24 20	 mov	 DWORD PTR tv70[rsp], eax
  00039	eb 0c		 jmp	 SHORT $LN4@display_ps
$LN3@display_ps:
  0003b	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00040	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  00043	89 44 24 20	 mov	 DWORD PTR tv70[rsp], eax
$LN4@display_ps:
  00047	8b 44 24 20	 mov	 eax, DWORD PTR tv70[rsp]
  0004b	89 44 24 24	 mov	 DWORD PTR arch_mode$[rsp], eax

; 2670 :                                       :  regs->arch_mode;
; 2671 :     return strlen( str_arch_psw( arch_mode, regs, buf, buflen ));

  0004f	44 8b 4c 24 50	 mov	 r9d, DWORD PTR buflen$[rsp]
  00054	4c 8b 44 24 48	 mov	 r8, QWORD PTR buf$[rsp]
  00059	48 8b 54 24 40	 mov	 rdx, QWORD PTR regs$[rsp]
  0005e	8b 4c 24 24	 mov	 ecx, DWORD PTR arch_mode$[rsp]
  00062	e8 00 00 00 00	 call	 str_arch_psw
  00067	48 8b c8	 mov	 rcx, rax
  0006a	e8 00 00 00 00	 call	 strlen

; 2672 : }

  0006f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00073	c3		 ret	 0
display_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv75 = 0
arch_mode$ = 4
p$1 = 8
cregs$ = 128
__$ArrayPad$ = 90368
regs$ = 90576
addr$ = 90584
copy_psw PROC

; 2624 : {

$LN14:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	55		 push	 rbp
  0000b	56		 push	 rsi
  0000c	57		 push	 rdi
  0000d	b8 b0 61 01 00	 mov	 eax, 90544		; 000161b0H
  00012	e8 00 00 00 00	 call	 __chkstk
  00017	48 2b e0	 sub	 rsp, rax
  0001a	48 8d ac 24 a0
	00 00 00	 lea	 rbp, QWORD PTR [rsp+160]
  00022	48 83 e5 80	 and	 rbp, -128		; ffffffffffffff80H
  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002d	48 33 c4	 xor	 rax, rsp
  00030	48 89 85 00 61
	01 00		 mov	 QWORD PTR __$ArrayPad$[rbp], rax

; 2625 : REGS cregs;
; 2626 : int  arch_mode;
; 2627 : 
; 2628 :     memcpy(&cregs, regs, sysblk.regs_copy_len);

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003e	48 63 80 90 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5264]
  00045	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR cregs$[rbp]
  0004c	48 8b f9	 mov	 rdi, rcx
  0004f	48 8b b4 24 d0
	61 01 00	 mov	 rsi, QWORD PTR regs$[rsp]
  00057	48 8b c8	 mov	 rcx, rax
  0005a	f3 a4		 rep movsb

; 2629 : 
; 2630 :     /* Use the architecture mode from SYSBLK if load indicator
; 2631 :        shows IPL in process, otherwise use archmode from REGS */
; 2632 :     if (cregs.loadstate)

  0005c	8b 85 a8 07 00
	00		 mov	 eax, DWORD PTR cregs$[rbp+1832]
  00062	c1 e8 0c	 shr	 eax, 12
  00065	83 e0 01	 and	 eax, 1
  00068	85 c0		 test	 eax, eax
  0006a	74 12		 je	 SHORT $LN7@copy_psw

; 2633 :     {
; 2634 :         arch_mode = sysblk.arch_mode;

  0006c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00073	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00079	89 45 04	 mov	 DWORD PTR arch_mode$[rbp], eax

; 2635 :     }

  0007c	eb 09		 jmp	 SHORT $LN8@copy_psw
$LN7@copy_psw:

; 2636 :     else
; 2637 :     {
; 2638 :         arch_mode = cregs.arch_mode;

  0007e	8b 85 e4 00 00
	00		 mov	 eax, DWORD PTR cregs$[rbp+100]
  00084	89 45 04	 mov	 DWORD PTR arch_mode$[rbp], eax
$LN8@copy_psw:

; 2639 :     }
; 2640 : 
; 2641 :     /* Call the appropriate store_psw routine based on archmode */
; 2642 :     switch(arch_mode) {

  00087	8b 45 04	 mov	 eax, DWORD PTR arch_mode$[rbp]
  0008a	89 45 00	 mov	 DWORD PTR tv75[rbp], eax
  0008d	83 7d 00 00	 cmp	 DWORD PTR tv75[rbp], 0
  00091	74 0e		 je	 SHORT $LN9@copy_psw
  00093	83 7d 00 01	 cmp	 DWORD PTR tv75[rbp], 1
  00097	74 1e		 je	 SHORT $LN10@copy_psw
  00099	83 7d 00 02	 cmp	 DWORD PTR tv75[rbp], 2
  0009d	74 2e		 je	 SHORT $LN11@copy_psw
  0009f	eb 42		 jmp	 SHORT $LN12@copy_psw
$LN9@copy_psw:

; 2643 : #if defined(_370)
; 2644 :         case ARCH_370_IDX:
; 2645 :             s370_store_psw(&cregs, addr);

  000a1	48 8b 94 24 d8
	61 01 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000a9	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR cregs$[rbp]
  000b0	e8 00 00 00 00	 call	 s370_store_psw

; 2646 :             break;

  000b5	eb 41		 jmp	 SHORT $LN2@copy_psw
$LN10@copy_psw:

; 2647 : #endif
; 2648 : #if defined(_390)
; 2649 :         case ARCH_390_IDX:
; 2650 :             s390_store_psw(&cregs, addr);

  000b7	48 8b 94 24 d8
	61 01 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000bf	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR cregs$[rbp]
  000c6	e8 00 00 00 00	 call	 s390_store_psw

; 2651 :             break;

  000cb	eb 2b		 jmp	 SHORT $LN2@copy_psw
$LN11@copy_psw:

; 2652 : #endif
; 2653 : #if defined(_900)
; 2654 :         case ARCH_900_IDX:
; 2655 :             z900_store_psw(&cregs, addr);

  000cd	48 8b 94 24 d8
	61 01 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000d5	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR cregs$[rbp]
  000dc	e8 00 00 00 00	 call	 z900_store_psw

; 2656 :             break;

  000e1	eb 15		 jmp	 SHORT $LN2@copy_psw
$LN12@copy_psw:
$LN6@copy_psw:

; 2657 : #endif
; 2658 :         default: CRASH();

  000e3	48 c7 45 08 00
	00 00 00	 mov	 QWORD PTR p$1[rbp], 0
  000eb	48 8b 45 08	 mov	 rax, QWORD PTR p$1[rbp]
  000ef	c6 00 00	 mov	 BYTE PTR [rax], 0
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 eb		 jne	 SHORT $LN6@copy_psw
$LN2@copy_psw:

; 2659 :     }
; 2660 : } /* end function copy_psw */

  000f8	48 8b 8d 00 61
	01 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp]
  000ff	48 33 cc	 xor	 rcx, rsp
  00102	e8 00 00 00 00	 call	 __security_check_cookie
  00107	48 81 c4 b0 61
	01 00		 add	 rsp, 90544		; 000161b0H
  0010e	5f		 pop	 rdi
  0010f	5e		 pop	 rsi
  00110	5d		 pop	 rbp
  00111	c3		 ret	 0
copy_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
cpu$ = 80
i$1 = 84
rc$ = 88
tv149 = 92
tv154 = 96
tv202 = 100
tv207 = 104
regs$ = 112
tv86 = 120
tv220 = 128
thread_name$ = 136
__$ArrayPad$ = 152
ptr$ = 176
cpu_thread PROC

; 2324 : {

$LN17:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2325 : REGS *regs = NULL;

  0001e	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR regs$[rsp], 0

; 2326 : int   cpu  = *(int*)ptr;

  00027	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ptr$[rsp]
  0002f	8b 00		 mov	 eax, DWORD PTR [rax]
  00031	89 44 24 50	 mov	 DWORD PTR cpu$[rsp], eax

; 2327 : char  thread_name[16];
; 2328 : int   rc;
; 2329 : 
; 2330 :     OBTAIN_INTLOCK(NULL);

  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196902
  0003c	33 c9		 xor	 ecx, ecx
  0003e	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2331 : 
; 2332 :     /* Increment number of CPUs online */
; 2333 :     sysblk.cpus++;

  00043	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004a	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [rax+260]
  00050	ff c0		 inc	 eax
  00052	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00059	89 81 04 01 00
	00		 mov	 DWORD PTR [rcx+260], eax

; 2334 : 
; 2335 :     /* Set hi CPU */
; 2336 :     if (cpu >= sysblk.hicpu)

  0005f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00066	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  0006c	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  00070	7c 13		 jl	 SHORT $LN11@cpu_thread

; 2337 :         sysblk.hicpu = cpu + 1;

  00072	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  00076	ff c0		 inc	 eax
  00078	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0007f	89 81 08 01 00
	00		 mov	 DWORD PTR [rcx+264], eax
$LN11@cpu_thread:

; 2338 : 
; 2339 :     /* Start the TOD clock and CPU timer thread */
; 2340 :     if (!sysblk.todtid)

  00085	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008c	83 b8 90 0b 00
	00 00		 cmp	 DWORD PTR [rax+2960], 0
  00093	0f 85 c6 00 00
	00		 jne	 $LN12@cpu_thread

; 2341 :     {
; 2342 :         rc = create_thread( &sysblk.todtid, DETACHED,

  00099	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a0	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ad	48 81 c1 90 0b
	00 00		 add	 rcx, 2960		; 00000b90H
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196905
  000bb	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196906
  000c7	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000cc	45 33 c9	 xor	 r9d, r9d
  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:timer_thread
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  000df	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax

; 2343 :              timer_thread, NULL, TIMER_THREAD_NAME );
; 2344 :         if (rc)

  000e3	83 7c 24 58 00	 cmp	 DWORD PTR rc$[rsp], 0
  000e8	74 75		 je	 SHORT $LN13@cpu_thread

; 2345 :         {
; 2346 :             // "Error in function create_thread(): %s"
; 2347 :             WRMSG( HHC00102, "E", strerror( rc ));

  000ea	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$[rsp]
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000f4	48 89 44 24 78	 mov	 QWORD PTR tv86[rsp], rax
  000f9	b9 01 00 00 00	 mov	 ecx, 1
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00104	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv86[rsp]
  00109	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0010e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196908
  00115	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196909
  00121	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00126	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00131	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196910
  00138	ba 2b 09 00 00	 mov	 edx, 2347		; 0000092bH
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196911
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2348 :             RELEASE_INTLOCK( NULL );

  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196912
  00151	33 c9		 xor	 ecx, ecx
  00153	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2349 :             return NULL;

  00158	33 c0		 xor	 eax, eax
  0015a	e9 92 02 00 00	 jmp	 $LN1@cpu_thread
$LN13@cpu_thread:
$LN12@cpu_thread:

; 2350 :         }
; 2351 :     }
; 2352 : 
; 2353 :     /* Set CPU thread priority */
; 2354 :     set_thread_priority( sysblk.cpuprio);

  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00165	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196913
  0016c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00173	8b 91 6c 13 00
	00		 mov	 edx, DWORD PTR [rcx+4972]
  00179	8b c8		 mov	 ecx, eax
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 2355 : 
; 2356 :     /* Display thread started message on control panel */
; 2357 : 
; 2358 :     MSGBUF( thread_name, "Processor %s%02X", PTYPSTR( cpu ), cpu );

  00181	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00186	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0018d	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0019b	8b 4c 24 50	 mov	 ecx, DWORD PTR cpu$[rsp]
  0019f	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  001a3	4c 8b c8	 mov	 r9, rax
  001a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196914
  001ad	ba 10 00 00 00	 mov	 edx, 16
  001b2	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2359 :     LOG_THREAD_BEGIN( thread_name  );

  001c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  001c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196915
  001cd	8b c8		 mov	 ecx, eax
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  001d5	89 44 24 5c	 mov	 DWORD PTR tv149[rsp], eax
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  001df	89 44 24 60	 mov	 DWORD PTR tv154[rsp], eax
  001e3	b9 01 00 00 00	 mov	 ecx, 1
  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ee	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  001f6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001fb	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv149[rsp]
  001ff	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00203	8b 4c 24 60	 mov	 ecx, DWORD PTR tv154[rsp]
  00207	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0020b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196916
  00212	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196917
  0021e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00223	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00228	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196918
  00235	ba 37 09 00 00	 mov	 edx, 2359		; 00000937H
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196919
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@cpu_thread:

; 2360 :     SET_THREAD_NAME( thread_name );

  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  0024d	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR thread_name$[rsp]
  00255	8b c8		 mov	 ecx, eax
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  0025d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00263	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR thread_name$[rsp]
  0026b	8b c8		 mov	 ecx, eax
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  00273	33 c0		 xor	 eax, eax
  00275	85 c0		 test	 eax, eax
  00277	75 ce		 jne	 SHORT $LN4@cpu_thread
$LN7@cpu_thread:

; 2361 : 
; 2362 :     /* Execute the program in specified mode */
; 2363 :     do {
; 2364 :         regs = run_cpu[sysblk.arch_mode] (cpu, regs);

  00279	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00280	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:run_cpu
  0028e	48 89 8c 24 80
	00 00 00	 mov	 QWORD PTR tv220[rsp], rcx
  00296	48 8b 54 24 70	 mov	 rdx, QWORD PTR regs$[rsp]
  0029b	8b 4c 24 50	 mov	 ecx, DWORD PTR cpu$[rsp]
  0029f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR tv220[rsp]
  002a7	41 ff 14 c0	 call	 QWORD PTR [r8+rax*8]
  002ab	48 89 44 24 70	 mov	 QWORD PTR regs$[rsp], rax

; 2365 :     } while (regs);

  002b0	48 83 7c 24 70
	00		 cmp	 QWORD PTR regs$[rsp], 0
  002b6	75 c1		 jne	 SHORT $LN7@cpu_thread

; 2366 : 
; 2367 :     /* Decrement number of CPUs online */
; 2368 :     sysblk.cpus--;

  002b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002bf	8b 80 04 01 00
	00		 mov	 eax, DWORD PTR [rax+260]
  002c5	ff c8		 dec	 eax
  002c7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002ce	89 81 04 01 00
	00		 mov	 DWORD PTR [rcx+260], eax

; 2369 : 
; 2370 :     /* Reset hi cpu */
; 2371 :     if (cpu + 1 >= sysblk.hicpu)

  002d4	8b 44 24 50	 mov	 eax, DWORD PTR cpu$[rsp]
  002d8	ff c0		 inc	 eax
  002da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002e1	3b 81 08 01 00
	00		 cmp	 eax, DWORD PTR [rcx+264]
  002e7	7c 54		 jl	 SHORT $LN14@cpu_thread

; 2372 :     {
; 2373 :         int i;
; 2374 :         for (i = sysblk.maxcpu - 1; i >= 0; i--)

  002e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f0	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  002f6	ff c8		 dec	 eax
  002f8	89 44 24 54	 mov	 DWORD PTR i$1[rsp], eax
  002fc	eb 0a		 jmp	 SHORT $LN10@cpu_thread
$LN8@cpu_thread:
  002fe	8b 44 24 54	 mov	 eax, DWORD PTR i$1[rsp]
  00302	ff c8		 dec	 eax
  00304	89 44 24 54	 mov	 DWORD PTR i$1[rsp], eax
$LN10@cpu_thread:
  00308	83 7c 24 54 00	 cmp	 DWORD PTR i$1[rsp], 0
  0030d	7c 1b		 jl	 SHORT $LN9@cpu_thread

; 2375 :             if (IS_CPU_ONLINE(i))

  0030f	48 63 44 24 54	 movsxd	 rax, DWORD PTR i$1[rsp]
  00314	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0031b	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00324	74 02		 je	 SHORT $LN15@cpu_thread

; 2376 :                 break;

  00326	eb 02		 jmp	 SHORT $LN9@cpu_thread
$LN15@cpu_thread:
  00328	eb d4		 jmp	 SHORT $LN8@cpu_thread
$LN9@cpu_thread:

; 2377 :         sysblk.hicpu = i + 1;

  0032a	8b 44 24 54	 mov	 eax, DWORD PTR i$1[rsp]
  0032e	ff c0		 inc	 eax
  00330	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00337	89 81 08 01 00
	00		 mov	 DWORD PTR [rcx+264], eax
$LN14@cpu_thread:

; 2378 :     }
; 2379 : 
; 2380 :     /* Signal cpu has terminated */
; 2381 :     signal_condition (&sysblk.cpucond);

  0033d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00344	48 05 40 01 00
	00		 add	 rax, 320		; 00000140H
  0034a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196922
  00351	48 8b c8	 mov	 rcx, rax
  00354	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 2382 : 
; 2383 :     /* Display thread ended message on control panel */
; 2384 :     LOG_THREAD_END( thread_name );

  0035a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00360	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196923
  00367	8b c8		 mov	 ecx, eax
  00369	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  0036f	89 44 24 64	 mov	 DWORD PTR tv202[rsp], eax
  00373	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00379	89 44 24 68	 mov	 DWORD PTR tv207[rsp], eax
  0037d	b9 01 00 00 00	 mov	 ecx, 1
  00382	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00388	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR thread_name$[rsp]
  00390	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00395	8b 4c 24 64	 mov	 ecx, DWORD PTR tv202[rsp]
  00399	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0039d	8b 4c 24 68	 mov	 ecx, DWORD PTR tv207[rsp]
  003a1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196924
  003ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196925
  003b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196926
  003cf	ba 50 09 00 00	 mov	 edx, 2384		; 00000950H
  003d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196927
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2385 : 
; 2386 :     RELEASE_INTLOCK(NULL);

  003e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196928
  003e8	33 c9		 xor	 ecx, ecx
  003ea	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2387 : 
; 2388 :     return NULL;

  003ef	33 c0		 xor	 eax, eax
$LN1@cpu_thread:

; 2389 : } /* end function cpu_thread */

  003f1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003f9	48 33 cc	 xor	 rcx, rsp
  003fc	e8 00 00 00 00	 call	 __security_check_cookie
  00401	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00408	c3		 ret	 0
cpu_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
code$ = 128
tv132 = 132
ip$ = 136
tv478 = 144
tv420 = 152
tv422 = 160
tv526 = 168
tv472 = 176
tv480 = 184
dxcstr$ = 192
sie_mode_str$ = 200
sie_debug_arch$ = 216
txf_why$ = 256
__$ArrayPad$ = 512
regs$ = 544
pcode$ = 552
ilc$ = 560
s370_trace_program_interrupt PROC

; 447  : {

$LN44:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	57		 push	 rdi
  0000f	48 81 ec 10 02
	00 00		 sub	 rsp, 528		; 00000210H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 448  :     char sie_mode_str    [ 10]  = {0};  // maybe "SIE: "

  00028	48 8d 84 24 c8
	00 00 00	 lea	 rax, QWORD PTR sie_mode_str$[rsp]
  00030	48 8b f8	 mov	 rdi, rax
  00033	33 c0		 xor	 eax, eax
  00035	b9 0a 00 00 00	 mov	 ecx, 10
  0003a	f3 aa		 rep stosb

; 449  :     char sie_debug_arch  [ 32]  = {0};  // "370", "390" or "900" if defined( SIE_DEBUG )

  0003c	48 8d 84 24 d8
	00 00 00	 lea	 rax, QWORD PTR sie_debug_arch$[rsp]
  00044	48 8b f8	 mov	 rdi, rax
  00047	33 c0		 xor	 eax, eax
  00049	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004e	f3 aa		 rep stosb

; 450  :     char txf_why         [256]  = {0};  // TXF "why" string if txf pgmint

  00050	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR txf_why$[rsp]
  00058	48 8b f8	 mov	 rdi, rax
  0005b	33 c0		 xor	 eax, eax
  0005d	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00062	f3 aa		 rep stosb

; 451  :     char dxcstr          [  8]  = {0};  // data exception code if PGM_DATA_EXCEPTION

  00064	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR dxcstr$[rsp]
  0006c	48 8b f8	 mov	 rdi, rax
  0006f	33 c0		 xor	 eax, eax
  00071	b9 08 00 00 00	 mov	 ecx, 8
  00076	f3 aa		 rep stosb

; 452  : 
; 453  :     BYTE* ip;      /* ptr to instr that program checked or NULL  */
; 454  : 
; 455  :     /* Just the low byte of program interrupt code itself please */
; 456  :     int code = (pcode & 0xFF);

  00078	8b 84 24 28 02
	00 00		 mov	 eax, DWORD PTR pcode$[rsp]
  0007f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00084	89 84 24 80 00
	00 00		 mov	 DWORD PTR code$[rsp], eax

; 457  : 
; 458  :     /* If the program interrupt code is zero, or if it's not, if the
; 459  :        code isn't one they're interested in seeing (as determiend by
; 460  :        OSTAILOR/pgmtrace) AND instruction tracing is NOT active, then
; 461  :        there's nothing for us to do.
; 462  :     */
; 463  :     if (0
; 464  :         || !code
; 465  :         || (1

  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	0f 85 be 07 00
	00		 jne	 $LN9@s370_trace
  00095	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR code$[rsp], 0
  0009d	0f 84 b0 07 00
	00		 je	 $LN9@s370_trace
  000a3	33 c0		 xor	 eax, eax
  000a5	83 f8 01	 cmp	 eax, 1
  000a8	0f 84 aa 07 00
	00		 je	 $LN8@s370_trace
  000ae	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR code$[rsp]
  000b5	ff c8		 dec	 eax
  000b7	83 e0 3f	 and	 eax, 63			; 0000003fH
  000ba	b9 01 00 00 00	 mov	 ecx, 1
  000bf	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv526[rsp], rcx
  000c7	0f b6 c8	 movzx	 ecx, al
  000ca	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv526[rsp]
  000d2	48 d3 e0	 shl	 rax, cl
  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000dc	48 8b 89 48 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4936]
  000e3	48 23 c8	 and	 rcx, rax
  000e6	48 8b c1	 mov	 rax, rcx
  000e9	48 85 c0	 test	 rax, rax
  000ec	0f 85 66 07 00
	00		 jne	 $LN8@s370_trace
  000f2	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00100	c1 e8 10	 shr	 eax, 16
  00103	83 e0 01	 and	 eax, 1
  00106	85 c0		 test	 eax, eax
  00108	74 0d		 je	 SHORT $LN38@s370_trace
  0010a	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv132[rsp], 1
  00115	eb 0b		 jmp	 SHORT $LN39@s370_trace
$LN38@s370_trace:
  00117	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN39@s370_trace:
  00122	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR tv132[rsp], 0
  0012a	0f 84 23 07 00
	00		 je	 $LN10@s370_trace
  00130	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00137	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0013d	c1 e8 0a	 shr	 eax, 10
  00140	83 e0 01	 and	 eax, 1
  00143	85 c0		 test	 eax, eax
  00145	0f 84 65 03 00
	00		 je	 $LN11@s370_trace
  0014b	33 c0		 xor	 eax, eax
  0014d	85 c0		 test	 eax, eax
  0014f	0f 85 2d 01 00
	00		 jne	 $LN12@s370_trace
  00155	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00162	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00167	85 c0		 test	 eax, eax
  00169	0f 84 13 01 00
	00		 je	 $LN12@s370_trace
  0016f	33 c0		 xor	 eax, eax
  00171	83 f8 01	 cmp	 eax, 1
  00174	0f 84 36 03 00
	00		 je	 $LN11@s370_trace
  0017a	33 c0		 xor	 eax, eax
  0017c	85 c0		 test	 eax, eax
  0017e	75 37		 jne	 SHORT $LN13@s370_trace
  00180	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00187	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0018d	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00192	85 c0		 test	 eax, eax
  00194	74 21		 je	 SHORT $LN13@s370_trace
  00196	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a5	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  001ab	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  001b1	0f 85 f9 02 00
	00		 jne	 $LN11@s370_trace
$LN13@s370_trace:
  001b7	33 c0		 xor	 eax, eax
  001b9	85 c0		 test	 eax, eax
  001bb	75 37		 jne	 SHORT $LN14@s370_trace
  001bd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c4	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  001ca	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  001cf	85 c0		 test	 eax, eax
  001d1	74 21		 je	 SHORT $LN14@s370_trace
  001d3	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001e2	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  001e8	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  001ee	0f 8c bc 02 00
	00		 jl	 $LN11@s370_trace
$LN14@s370_trace:
  001f4	33 c0		 xor	 eax, eax
  001f6	85 c0		 test	 eax, eax
  001f8	0f 85 84 00 00
	00		 jne	 $LN15@s370_trace
  001fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00205	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0020b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00210	85 c0		 test	 eax, eax
  00212	74 26		 je	 SHORT $LN16@s370_trace
  00214	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00223	85 c0		 test	 eax, eax
  00225	74 13		 je	 SHORT $LN16@s370_trace
  00227	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00236	85 c0		 test	 eax, eax
  00238	75 48		 jne	 SHORT $LN15@s370_trace
$LN16@s370_trace:
  0023a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00241	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00247	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0024c	85 c0		 test	 eax, eax
  0024e	0f 84 5c 02 00
	00		 je	 $LN11@s370_trace
  00254	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00263	85 c0		 test	 eax, eax
  00265	0f 84 45 02 00
	00		 je	 $LN11@s370_trace
  0026b	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00273	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0027a	85 c0		 test	 eax, eax
  0027c	0f 85 2e 02 00
	00		 jne	 $LN11@s370_trace
$LN15@s370_trace:
$LN12@s370_trace:
  00282	b8 08 00 00 00	 mov	 eax, 8
  00287	48 6b c0 00	 imul	 rax, rax, 0
  0028b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00292	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0029b	75 1f		 jne	 SHORT $LN17@s370_trace
  0029d	b8 08 00 00 00	 mov	 eax, 8
  002a2	48 6b c0 01	 imul	 rax, rax, 1
  002a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002ad	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  002b6	0f 84 9c 05 00
	00		 je	 $LN8@s370_trace
$LN17@s370_trace:
  002bc	b8 08 00 00 00	 mov	 eax, 8
  002c1	48 6b c0 00	 imul	 rax, rax, 0
  002c5	b9 08 00 00 00	 mov	 ecx, 8
  002ca	48 6b c9 01	 imul	 rcx, rcx, 1
  002ce	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002d5	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  002dc	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  002e4	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  002ec	0f 87 c4 00 00
	00		 ja	 $LN18@s370_trace
  002f2	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fa	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00300	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00308	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00310	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00317	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0031b	48 2b ca	 sub	 rcx, rdx
  0031e	48 03 c1	 add	 rax, rcx
  00321	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00328	f7 d9		 neg	 ecx
  0032a	48 63 c9	 movsxd	 rcx, ecx
  0032d	48 03 c1	 add	 rax, rcx
  00330	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00336	8b c0		 mov	 eax, eax
  00338	b9 08 00 00 00	 mov	 ecx, 8
  0033d	48 6b c9 00	 imul	 rcx, rcx, 0
  00341	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00348	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00350	72 64		 jb	 SHORT $LN18@s370_trace
  00352	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035a	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00360	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00368	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00370	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00377	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0037b	48 2b ca	 sub	 rcx, rdx
  0037e	48 03 c1	 add	 rax, rcx
  00381	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00388	f7 d9		 neg	 ecx
  0038a	48 63 c9	 movsxd	 rcx, ecx
  0038d	48 03 c1	 add	 rax, rcx
  00390	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00396	8b c0		 mov	 eax, eax
  00398	b9 08 00 00 00	 mov	 ecx, 8
  0039d	48 6b c9 01	 imul	 rcx, rcx, 1
  003a1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003a8	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  003b0	0f 86 a2 04 00
	00		 jbe	 $LN8@s370_trace
$LN18@s370_trace:
  003b6	b8 08 00 00 00	 mov	 eax, 8
  003bb	48 6b c0 00	 imul	 rax, rax, 0
  003bf	b9 08 00 00 00	 mov	 ecx, 8
  003c4	48 6b c9 01	 imul	 rcx, rcx, 1
  003c8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  003cf	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  003d6	48 8b 8c 0f c8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4808]
  003de	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  003e6	0f 86 c4 00 00
	00		 jbe	 $LN19@s370_trace
  003ec	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f4	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  003fa	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0040a	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00411	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00415	48 2b ca	 sub	 rcx, rdx
  00418	48 03 c1	 add	 rax, rcx
  0041b	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00422	f7 d9		 neg	 ecx
  00424	48 63 c9	 movsxd	 rcx, ecx
  00427	48 03 c1	 add	 rax, rcx
  0042a	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00430	8b c0		 mov	 eax, eax
  00432	b9 08 00 00 00	 mov	 ecx, 8
  00437	48 6b c9 01	 imul	 rcx, rcx, 1
  0043b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00442	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0044a	72 64		 jb	 SHORT $LN19@s370_trace
  0044c	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00454	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0045a	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00462	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0046a	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00471	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00475	48 2b ca	 sub	 rcx, rdx
  00478	48 03 c1	 add	 rax, rcx
  0047b	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00482	f7 d9		 neg	 ecx
  00484	48 63 c9	 movsxd	 rcx, ecx
  00487	48 03 c1	 add	 rax, rcx
  0048a	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00490	8b c0		 mov	 eax, eax
  00492	b9 08 00 00 00	 mov	 ecx, 8
  00497	48 6b c9 00	 imul	 rcx, rcx, 0
  0049b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004a2	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  004aa	0f 86 a8 03 00
	00		 jbe	 $LN8@s370_trace
$LN19@s370_trace:
$LN11@s370_trace:
  004b0	33 c0		 xor	 eax, eax
  004b2	83 f8 01	 cmp	 eax, 1
  004b5	0f 84 98 03 00
	00		 je	 $LN20@s370_trace
  004bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004c2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  004c8	c1 e8 08	 shr	 eax, 8
  004cb	83 e0 01	 and	 eax, 1
  004ce	85 c0		 test	 eax, eax
  004d0	0f 84 7d 03 00
	00		 je	 $LN20@s370_trace
  004d6	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004de	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  004e4	c1 e8 0f	 shr	 eax, 15
  004e7	83 e0 01	 and	 eax, 1
  004ea	85 c0		 test	 eax, eax
  004ec	0f 84 61 03 00
	00		 je	 $LN20@s370_trace
  004f2	33 c0		 xor	 eax, eax
  004f4	85 c0		 test	 eax, eax
  004f6	0f 85 2d 01 00
	00		 jne	 $LN21@s370_trace
  004fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00503	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00509	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0050e	85 c0		 test	 eax, eax
  00510	0f 84 13 01 00
	00		 je	 $LN21@s370_trace
  00516	33 c0		 xor	 eax, eax
  00518	83 f8 01	 cmp	 eax, 1
  0051b	0f 84 32 03 00
	00		 je	 $LN20@s370_trace
  00521	33 c0		 xor	 eax, eax
  00523	85 c0		 test	 eax, eax
  00525	75 37		 jne	 SHORT $LN22@s370_trace
  00527	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0052e	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00534	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00539	85 c0		 test	 eax, eax
  0053b	74 21		 je	 SHORT $LN22@s370_trace
  0053d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00545	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0054c	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00552	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00558	0f 85 f5 02 00
	00		 jne	 $LN20@s370_trace
$LN22@s370_trace:
  0055e	33 c0		 xor	 eax, eax
  00560	85 c0		 test	 eax, eax
  00562	75 37		 jne	 SHORT $LN23@s370_trace
  00564	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0056b	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00571	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  00576	85 c0		 test	 eax, eax
  00578	74 21		 je	 SHORT $LN23@s370_trace
  0057a	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00582	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00589	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  0058f	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  00595	0f 8c b8 02 00
	00		 jl	 $LN20@s370_trace
$LN23@s370_trace:
  0059b	33 c0		 xor	 eax, eax
  0059d	85 c0		 test	 eax, eax
  0059f	0f 85 84 00 00
	00		 jne	 $LN24@s370_trace
  005a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005ac	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005b2	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  005b7	85 c0		 test	 eax, eax
  005b9	74 26		 je	 SHORT $LN25@s370_trace
  005bb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c3	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  005ca	85 c0		 test	 eax, eax
  005cc	74 13		 je	 SHORT $LN25@s370_trace
  005ce	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d6	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  005dd	85 c0		 test	 eax, eax
  005df	75 48		 jne	 SHORT $LN24@s370_trace
$LN25@s370_trace:
  005e1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005e8	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  005ee	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  005f3	85 c0		 test	 eax, eax
  005f5	0f 84 58 02 00
	00		 je	 $LN20@s370_trace
  005fb	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00603	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0060a	85 c0		 test	 eax, eax
  0060c	0f 84 41 02 00
	00		 je	 $LN20@s370_trace
  00612	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0061a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00621	85 c0		 test	 eax, eax
  00623	0f 85 2a 02 00
	00		 jne	 $LN20@s370_trace
$LN24@s370_trace:
$LN21@s370_trace:
  00629	b8 08 00 00 00	 mov	 eax, 8
  0062e	48 6b c0 00	 imul	 rax, rax, 0
  00632	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00639	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00642	75 1f		 jne	 SHORT $LN26@s370_trace
  00644	b8 08 00 00 00	 mov	 eax, 8
  00649	48 6b c0 01	 imul	 rax, rax, 1
  0064d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00654	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0065d	0f 84 f5 01 00
	00		 je	 $LN8@s370_trace
$LN26@s370_trace:
  00663	b8 08 00 00 00	 mov	 eax, 8
  00668	48 6b c0 00	 imul	 rax, rax, 0
  0066c	b9 08 00 00 00	 mov	 ecx, 8
  00671	48 6b c9 01	 imul	 rcx, rcx, 1
  00675	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0067c	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00683	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  0068b	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  00693	0f 87 c4 00 00
	00		 ja	 $LN27@s370_trace
  00699	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  006a7	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006af	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006b7	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  006be	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  006c2	48 2b ca	 sub	 rcx, rdx
  006c5	48 03 c1	 add	 rax, rcx
  006c8	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  006cf	f7 d9		 neg	 ecx
  006d1	48 63 c9	 movsxd	 rcx, ecx
  006d4	48 03 c1	 add	 rax, rcx
  006d7	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  006dd	8b c0		 mov	 eax, eax
  006df	b9 08 00 00 00	 mov	 ecx, 8
  006e4	48 6b c9 00	 imul	 rcx, rcx, 0
  006e8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006ef	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  006f7	72 64		 jb	 SHORT $LN27@s370_trace
  006f9	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00701	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00707	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0070f	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00717	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0071e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00722	48 2b ca	 sub	 rcx, rdx
  00725	48 03 c1	 add	 rax, rcx
  00728	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  0072f	f7 d9		 neg	 ecx
  00731	48 63 c9	 movsxd	 rcx, ecx
  00734	48 03 c1	 add	 rax, rcx
  00737	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0073d	8b c0		 mov	 eax, eax
  0073f	b9 08 00 00 00	 mov	 ecx, 8
  00744	48 6b c9 01	 imul	 rcx, rcx, 1
  00748	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0074f	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00757	0f 86 fb 00 00
	00		 jbe	 $LN8@s370_trace
$LN27@s370_trace:
  0075d	b8 08 00 00 00	 mov	 eax, 8
  00762	48 6b c0 00	 imul	 rax, rax, 0
  00766	b9 08 00 00 00	 mov	 ecx, 8
  0076b	48 6b c9 01	 imul	 rcx, rcx, 1
  0076f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00776	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  0077d	48 8b 8c 0f d8
	12 00 00	 mov	 rcx, QWORD PTR [rdi+rcx+4824]
  00785	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  0078d	0f 86 c0 00 00
	00		 jbe	 $LN28@s370_trace
  00793	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079b	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  007a1	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a9	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007b1	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  007b8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  007bc	48 2b ca	 sub	 rcx, rdx
  007bf	48 03 c1	 add	 rax, rcx
  007c2	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  007c9	f7 d9		 neg	 ecx
  007cb	48 63 c9	 movsxd	 rcx, ecx
  007ce	48 03 c1	 add	 rax, rcx
  007d1	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  007d7	8b c0		 mov	 eax, eax
  007d9	b9 08 00 00 00	 mov	 ecx, 8
  007de	48 6b c9 01	 imul	 rcx, rcx, 1
  007e2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007e9	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  007f1	72 60		 jb	 SHORT $LN28@s370_trace
  007f3	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007fb	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00801	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00809	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00811	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00818	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0081c	48 2b ca	 sub	 rcx, rdx
  0081f	48 03 c1	 add	 rax, rcx
  00822	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00829	f7 d9		 neg	 ecx
  0082b	48 63 c9	 movsxd	 rcx, ecx
  0082e	48 03 c1	 add	 rax, rcx
  00831	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00837	8b c0		 mov	 eax, eax
  00839	b9 08 00 00 00	 mov	 ecx, 8
  0083e	48 6b c9 00	 imul	 rcx, rcx, 0
  00842	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00849	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00851	76 05		 jbe	 SHORT $LN8@s370_trace
$LN28@s370_trace:
$LN20@s370_trace:
$LN10@s370_trace:
$LN9@s370_trace:

; 466  :             && !(sysblk.pgminttr & ((U64) 1 << ((code - 1) & 0x3F)))
; 467  :             && !CPU_STEPPING_OR_TRACING( regs, ilc )
; 468  :            )
; 469  :     )
; 470  :     {
; 471  :         return;     // (nothing to do; quick exit)

  00853	e9 9a 03 00 00	 jmp	 $LN1@s370_trace
$LN8@s370_trace:
$LN4@s370_trace:

; 472  :     }
; 473  : 
; 474  :     /*
; 475  :        First things first: backup the 'ip' by the 'ilc' value to point
; 476  :        to the actual instruction that actually program checked.
; 477  : 
; 478  :        If 'instinvalid' is set it means an instruction fetch error
; 479  :        occurred so we shouldn't rely on the value of regs->ip.
; 480  : 
; 481  :        Otherwise if the instruction that program checked (i.e. after
; 482  :        backing up 'ip' by 'ilc' amount) appears to be in the previous
; 483  :        mainstor page (meaning the instruction itself crossed a page
; 484  :        boundary), use the the copy of the instruction that was saved
; 485  :        in regs->inst for our instruction pointer instead.
; 486  : 
; 487  :        If neither condition is true (the most common case) then we
; 488  :        simply use current regs->ip value backed up by the ilc amount.
; 489  :     */
; 490  :     PTT_PGM( "tr PGM int", regs->ip, regs->aip, ilc );

  00858	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0085f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00862	48 83 e0 20	 and	 rax, 32			; 00000020H
  00866	48 85 c0	 test	 rax, rax
  00869	74 4f		 je	 SHORT $LN29@s370_trace
  0086b	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00873	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0087c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00881	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169945
  00888	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0088d	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00895	4c 8b 88 00 02
	00 00		 mov	 r9, QWORD PTR [rax+512]
  0089c	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a4	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  008a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169946
  008af	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  008b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@s370_trace:
  008ba	33 c0		 xor	 eax, eax
  008bc	85 c0		 test	 eax, eax
  008be	75 98		 jne	 SHORT $LN4@s370_trace

; 491  :     ip =

  008c0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  008ce	c1 e8 03	 shr	 eax, 3
  008d1	83 e0 01	 and	 eax, 1
  008d4	85 c0		 test	 eax, eax
  008d6	74 0e		 je	 SHORT $LN42@s370_trace
  008d8	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv422[rsp], 0
  008e4	eb 75		 jmp	 SHORT $LN43@s370_trace
$LN42@s370_trace:
  008e6	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  008ee	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f6	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  008fa	48 2b c8	 sub	 rcx, rax
  008fd	48 8b c1	 mov	 rax, rcx
  00900	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00908	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  0090f	73 18		 jae	 SHORT $LN40@s370_trace
  00911	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00919	48 05 f1 08 00
	00		 add	 rax, 2289		; 000008f1H
  0091f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv420[rsp], rax
  00927	eb 22		 jmp	 SHORT $LN41@s370_trace
$LN40@s370_trace:
  00929	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00931	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00939	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0093d	48 2b c8	 sub	 rcx, rax
  00940	48 8b c1	 mov	 rax, rcx
  00943	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv420[rsp], rax
$LN41@s370_trace:
  0094b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv420[rsp]
  00953	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv422[rsp], rax
$LN43@s370_trace:
  0095b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv422[rsp]
  00963	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ip$[rsp], rax
$LN7@s370_trace:

; 492  :     (
; 493  :         /* Instruction fetch error? (least likely) */
; 494  :         regs->instinvalid ? NULL
; 495  : 
; 496  :         /* Instruction crossed page boundary? (unlikely) */
; 497  :         : ((regs->ip - ilc) < regs->aip) ? regs->inst
; 498  : 
; 499  :         /* Instruction still on same page (most likely) */
; 500  :         :  (regs->ip - ilc)
; 501  :     );
; 502  :     PTT_PGM( "tr PGM int", ip, regs->aip, ilc );

  0096b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00972	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00975	48 83 e0 20	 and	 rax, 32			; 00000020H
  00979	48 85 c0	 test	 rax, rax
  0097c	74 4b		 je	 SHORT $LN30@s370_trace
  0097e	48 63 84 24 30
	02 00 00	 movsxd	 rax, DWORD PTR ilc$[rsp]
  00986	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0098f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00994	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169948
  0099b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009a0	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009a8	4c 8b 88 00 02
	00 00		 mov	 r9, QWORD PTR [rax+512]
  009af	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR ip$[rsp]
  009b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169949
  009be	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  009c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN30@s370_trace:
  009c9	33 c0		 xor	 eax, eax
  009cb	85 c0		 test	 eax, eax
  009cd	75 9c		 jne	 SHORT $LN7@s370_trace

; 503  : 
; 504  : #if defined( OPTION_FOOTPRINT_BUFFER )
; 505  :     if (!(sysblk.insttrace || sysblk.instbreak))
; 506  :     {
; 507  :         U32  n;
; 508  :         for (n = sysblk.footprptr[ regs->cpuad ] + 1;
; 509  :             n != sysblk.footprptr[ regs->cpuad ];
; 510  :             n++, n &= OPTION_FOOTPRINT_BUFFER - 1
; 511  :         )
; 512  :         {
; 513  :             ARCH_DEP( display_inst )(
; 514  :                 &sysblk.footprregs[ regs->cpuad ][n],
; 515  :                  sysblk.footprregs[ regs->cpuad ][n].inst );
; 516  :         }
; 517  :     }
; 518  : #endif
; 519  : 
; 520  :     /* Suppress LRA Special Operation Exception tracing if requested */
; 521  :     if (1
; 522  :         && code == PGM_SPECIAL_OPERATION_EXCEPTION
; 523  :         && ip && ip[0] == 0xB1    // LRA
; 524  :         && sysblk.nolrasoe        // suppression enabled

  009cf	33 c0		 xor	 eax, eax
  009d1	83 f8 01	 cmp	 eax, 1
  009d4	74 4d		 je	 SHORT $LN31@s370_trace
  009d6	83 bc 24 80 00
	00 00 13	 cmp	 DWORD PTR code$[rsp], 19
  009de	75 43		 jne	 SHORT $LN31@s370_trace
  009e0	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR ip$[rsp], 0
  009e9	74 38		 je	 SHORT $LN31@s370_trace
  009eb	b8 01 00 00 00	 mov	 eax, 1
  009f0	48 6b c0 00	 imul	 rax, rax, 0
  009f4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ip$[rsp]
  009fc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a00	3d b1 00 00 00	 cmp	 eax, 177		; 000000b1H
  00a05	75 1c		 jne	 SHORT $LN31@s370_trace
  00a07	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a0e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00a14	c1 e8 18	 shr	 eax, 24
  00a17	83 e0 01	 and	 eax, 1
  00a1a	85 c0		 test	 eax, eax
  00a1c	74 05		 je	 SHORT $LN31@s370_trace

; 525  :     )
; 526  :     {
; 527  :         return;     // (nothing to do; quick exit)

  00a1e	e9 cf 01 00 00	 jmp	 $LN1@s370_trace
$LN31@s370_trace:

; 528  :     }
; 529  : 
; 530  :     /* Trace this program interrupt... */
; 531  : 
; 532  : #if defined( _FEATURE_SIE )
; 533  :     if (SIE_MODE( regs ))

  00a23	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a2b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a31	d1 e8		 shr	 eax, 1
  00a33	83 e0 01	 and	 eax, 1
  00a36	85 c0		 test	 eax, eax
  00a38	74 1b		 je	 SHORT $LN32@s370_trace

; 534  :       STRLCPY( sie_mode_str, "SIE: " );

  00a3a	41 b8 0a 00 00
	00		 mov	 r8d, 10
  00a40	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169952
  00a47	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR sie_mode_str$[rsp]
  00a4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN32@s370_trace:

; 535  : #endif
; 536  : 
; 537  : #if defined( SIE_DEBUG )
; 538  :     STRLCPY( sie_debug_arch, QSTR( _GEN_ARCH ));
; 539  :     STRLCAT( sie_debug_arch, " " );
; 540  : #endif
; 541  : 
; 542  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 543  :     if (1
; 544  :         && pcode & PGM_TXF_EVENT
; 545  :         && regs->txf_why
; 546  :     )
; 547  :         txf_why_str( txf_why, sizeof( txf_why ), regs->txf_why );
; 548  : #endif
; 549  : 
; 550  :     if (code == PGM_DATA_EXCEPTION)

  00a55	83 bc 24 80 00
	00 00 07	 cmp	 DWORD PTR code$[rsp], 7
  00a5d	75 29		 jne	 SHORT $LN33@s370_trace

; 551  :        MSGBUF( dxcstr, " DXC=%2.2X", regs->dxc );

  00a5f	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a67	44 8b 88 08 07
	00 00		 mov	 r9d, DWORD PTR [rax+1800]
  00a6e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169954
  00a75	ba 08 00 00 00	 mov	 edx, 8
  00a7a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dxcstr$[rsp]
  00a82	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN33@s370_trace:

; 552  : 
; 553  :     if (regs->insttrace && sysblk.traceFILE)

  00a88	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a90	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00a96	c1 e8 0f	 shr	 eax, 15
  00a99	83 e0 01	 and	 eax, 1
  00a9c	85 c0		 test	 eax, eax
  00a9e	74 30		 je	 SHORT $LN34@s370_trace
  00aa0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00aa7	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00aaf	74 1f		 je	 SHORT $LN34@s370_trace

; 554  :         tf_0801( regs, pcode, ilc );

  00ab1	44 0f b6 84 24
	30 02 00 00	 movzx	 r8d, BYTE PTR ilc$[rsp]
  00aba	0f b7 94 24 28
	02 00 00	 movzx	 edx, WORD PTR pcode$[rsp]
  00ac2	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0801
$LN34@s370_trace:

; 555  : 
; 556  :     // "Processor %s%02X: %s%s %s interruption code %4.4X ilc %d%s%s"
; 557  :     WRMSG( HHC00801, "I",

  00ad0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR code$[rsp]
  00ad7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PIC2Name
  00add	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv472[rsp], rax
  00ae5	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aed	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00af4	89 8c 24 90 00
	00 00		 mov	 DWORD PTR tv478[rsp], ecx
  00afb	48 8b 94 24 20
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b03	0f b7 92 3c 08
	00 00		 movzx	 edx, WORD PTR [rdx+2108]
  00b0a	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  00b11	0f b6 8c 17 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdi+rdx+2888]
  00b19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00b1f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv480[rsp], rax
  00b27	b9 01 00 00 00	 mov	 ecx, 1
  00b2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b32	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR txf_why$[rsp]
  00b3a	48 89 4c 24 78	 mov	 QWORD PTR [rsp+120], rcx
  00b3f	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR dxcstr$[rsp]
  00b47	48 89 4c 24 70	 mov	 QWORD PTR [rsp+112], rcx
  00b4c	8b 8c 24 30 02
	00 00		 mov	 ecx, DWORD PTR ilc$[rsp]
  00b53	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00b57	8b 8c 24 28 02
	00 00		 mov	 ecx, DWORD PTR pcode$[rsp]
  00b5e	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00b62	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv472[rsp]
  00b6a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00b6f	48 8d 8c 24 d8
	00 00 00	 lea	 rcx, QWORD PTR sie_debug_arch$[rsp]
  00b77	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00b7c	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR sie_mode_str$[rsp]
  00b84	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00b89	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv478[rsp]
  00b90	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00b94	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv480[rsp]
  00b9c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ba1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169956
  00ba8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00bad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169957
  00bb4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bb9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bbe	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bc4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169958
  00bcb	ba 31 02 00 00	 mov	 edx, 561		; 00000231H
  00bd0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169959
  00bd7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 558  :         PTYPSTR( regs->cpuad ), regs->cpuad,
; 559  :         sie_mode_str, sie_debug_arch,
; 560  :         PIC2Name( code ), pcode,
; 561  :         ilc, dxcstr, txf_why );
; 562  : 
; 563  :     // HHC02324 "PSW=... INST=...  OPCODE  operands   name"
; 564  :     ARCH_DEP( display_pgmint_inst )( regs, ip );

  00bdd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR ip$[rsp]
  00be5	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bed	e8 00 00 00 00	 call	 s370_display_pgmint_inst
$LN1@s370_trace:

; 565  : 
; 566  : } /* end function ARCH_DEP( trace_program_interrupt ) */

  00bf2	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00bfa	48 33 cc	 xor	 rcx, rsp
  00bfd	e8 00 00 00 00	 call	 __security_check_cookie
  00c02	48 81 c4 10 02
	00 00		 add	 rsp, 528		; 00000210H
  00c09	5f		 pop	 rdi
  00c0a	c3		 ret	 0
s370_trace_program_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
ilc$ = 64
tv70 = 68
tv77 = 72
tv84 = 76
tv86 = 80
tv88 = 84
tv142 = 88
tv147 = 92
tv149 = 96
regs$ = 128
s370_fix_program_interrupt_PSW PROC

; 572  : {

$LN38:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 573  :     /* Determine the instruction length code (ilc).
; 574  : 
; 575  :        The 'zeroilc' flag is set when the Instruction Length Code
; 576  :        should be reported as zero (such as when instruction-fetching
; 577  :        nullification PER option is set in CR9 or when the load PSW
; 578  :        instruction results in an invalid PSW being loaded).
; 579  : 
; 580  :        The PSW 'ilc' value can also be specifically set to '0' when
; 581  :        a BALR, BASR or BASSM program checks during 'trace_br' call.
; 582  :     */
; 583  :     int ilc =

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00011	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00017	c1 e8 02	 shr	 eax, 2
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	74 0d		 je	 SHORT $LN30@s370_fix_p
  00021	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
  00029	e9 95 00 00 00	 jmp	 $LN31@s370_fix_p
$LN30@s370_fix_p:
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003c	83 e0 01	 and	 eax, 1
  0003f	85 c0		 test	 eax, eax
  00041	75 0a		 jne	 SHORT $LN20@s370_fix_p
  00043	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0004b	eb 08		 jmp	 SHORT $LN21@s370_fix_p
$LN20@s370_fix_p:
  0004d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN21@s370_fix_p:
  00055	83 7c 24 44 00	 cmp	 DWORD PTR tv70[rsp], 0
  0005a	74 0a		 je	 SHORT $LN24@s370_fix_p
  0005c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  00064	eb 08		 jmp	 SHORT $LN25@s370_fix_p
$LN24@s370_fix_p:
  00066	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN25@s370_fix_p:
  0006e	83 7c 24 48 00	 cmp	 DWORD PTR tv77[rsp], 0
  00073	74 15		 je	 SHORT $LN28@s370_fix_p
  00075	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00084	89 44 24 50	 mov	 DWORD PTR tv86[rsp], eax
  00088	eb 31		 jmp	 SHORT $LN29@s370_fix_p
$LN28@s370_fix_p:
  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00092	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00098	d1 e8		 shr	 eax, 1
  0009a	83 e0 01	 and	 eax, 1
  0009d	85 c0		 test	 eax, eax
  0009f	74 0a		 je	 SHORT $LN26@s370_fix_p
  000a1	c7 44 24 4c 06
	00 00 00	 mov	 DWORD PTR tv84[rsp], 6
  000a9	eb 08		 jmp	 SHORT $LN27@s370_fix_p
$LN26@s370_fix_p:
  000ab	c7 44 24 4c 04
	00 00 00	 mov	 DWORD PTR tv84[rsp], 4
$LN27@s370_fix_p:
  000b3	8b 44 24 4c	 mov	 eax, DWORD PTR tv84[rsp]
  000b7	89 44 24 50	 mov	 DWORD PTR tv86[rsp], eax
$LN29@s370_fix_p:
  000bb	8b 44 24 50	 mov	 eax, DWORD PTR tv86[rsp]
  000bf	89 44 24 54	 mov	 DWORD PTR tv88[rsp], eax
$LN31@s370_fix_p:
  000c3	8b 44 24 54	 mov	 eax, DWORD PTR tv88[rsp]
  000c7	89 44 24 40	 mov	 DWORD PTR ilc$[rsp], eax
$LN4@s370_fix_p:

; 584  :     (
; 585  :         /* If zeroilc flag is set, then we MUST use zero for the ilc */
; 586  :         regs->psw.zeroilc ? 0
; 587  : 
; 588  :         /* Otherwise use either the ilc value set in the PSW or the
; 589  :            length of the EX/EXRL instruction is the instruction is
; 590  :            being executed.
; 591  :         */
; 592  :         : REAL_ILC( regs )
; 593  :     );
; 594  :     PTT_PGM( "fxpiPSW ilc", 0, 0, ilc );

  000cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000d2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d5	48 83 e0 20	 and	 rax, 32			; 00000020H
  000d9	48 85 c0	 test	 rax, rax
  000dc	74 37		 je	 SHORT $LN14@s370_fix_p
  000de	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  000e3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ec	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000f1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170001
  000f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000fd	45 33 c9	 xor	 r9d, r9d
  00100	45 33 c0	 xor	 r8d, r8d
  00103	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170002
  0010a	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@s370_fix_p:
  00115	33 c0		 xor	 eax, eax
  00117	85 c0		 test	 eax, eax
  00119	75 b0		 jne	 SHORT $LN4@s370_fix_p

; 595  : 
; 596  :     /* If our resulting ilc is still 0 but the zeroilc flag is NOT set,
; 597  :        then we're left with no choice but to GUESS the 'ilc' value
; 598  :        based on whether the instruction was being executed or not.
; 599  :     */
; 600  :     if (regs->psw.ilc == 0 && !regs->psw.zeroilc)

  0011b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00123	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  0012a	85 c0		 test	 eax, eax
  0012c	0f 85 ab 01 00
	00		 jne	 $LN15@s370_fix_p
  00132	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00140	c1 e8 02	 shr	 eax, 2
  00143	83 e0 01	 and	 eax, 1
  00146	85 c0		 test	 eax, eax
  00148	0f 85 8f 01 00
	00		 jne	 $LN15@s370_fix_p

; 601  :     {
; 602  :         ilc = (!regs->execflag ? 2 : (regs->exrl ? 6 : 4));

  0014e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00156	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0015c	83 e0 01	 and	 eax, 1
  0015f	85 c0		 test	 eax, eax
  00161	75 0a		 jne	 SHORT $LN32@s370_fix_p
  00163	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv142[rsp], 1
  0016b	eb 08		 jmp	 SHORT $LN33@s370_fix_p
$LN32@s370_fix_p:
  0016d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN33@s370_fix_p:
  00175	83 7c 24 58 00	 cmp	 DWORD PTR tv142[rsp], 0
  0017a	74 0a		 je	 SHORT $LN36@s370_fix_p
  0017c	c7 44 24 60 02
	00 00 00	 mov	 DWORD PTR tv149[rsp], 2
  00184	eb 31		 jmp	 SHORT $LN37@s370_fix_p
$LN36@s370_fix_p:
  00186	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00194	d1 e8		 shr	 eax, 1
  00196	83 e0 01	 and	 eax, 1
  00199	85 c0		 test	 eax, eax
  0019b	74 0a		 je	 SHORT $LN34@s370_fix_p
  0019d	c7 44 24 5c 06
	00 00 00	 mov	 DWORD PTR tv147[rsp], 6
  001a5	eb 08		 jmp	 SHORT $LN35@s370_fix_p
$LN34@s370_fix_p:
  001a7	c7 44 24 5c 04
	00 00 00	 mov	 DWORD PTR tv147[rsp], 4
$LN35@s370_fix_p:
  001af	8b 44 24 5c	 mov	 eax, DWORD PTR tv147[rsp]
  001b3	89 44 24 60	 mov	 DWORD PTR tv149[rsp], eax
$LN37@s370_fix_p:
  001b7	8b 44 24 60	 mov	 eax, DWORD PTR tv149[rsp]
  001bb	89 44 24 40	 mov	 DWORD PTR ilc$[rsp], eax
$LN7@s370_fix_p:

; 603  : 
; 604  :         PTT_PGM( "fxpiPSW ilc", regs->ip, regs->psw.IA, ilc );

  001bf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001c9	48 83 e0 20	 and	 rax, 32			; 00000020H
  001cd	48 85 c0	 test	 rax, rax
  001d0	74 4e		 je	 SHORT $LN16@s370_fix_p
  001d2	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  001d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  001e5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001ee	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170005
  001fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ff	44 8b c9	 mov	 r9d, ecx
  00202	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020a	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  0020e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170006
  00215	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_fix_p:
  00220	33 c0		 xor	 eax, eax
  00222	85 c0		 test	 eax, eax
  00224	75 99		 jne	 SHORT $LN7@s370_fix_p

; 605  : 
; 606  :         /* Now ADVANCE the 'ip' mainstor instruction pointer and
; 607  :            psw 'IA' instruction address by that ilc amount so that
; 608  :            the 'trace_program_interrupt' can then back them both up
; 609  :            by the same amount to point to the actual instruction
; 610  :            that actually program checked.
; 611  :         */
; 612  :         regs->psw.ilc  = ilc;  // (guessed value)

  00226	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022e	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR ilc$[rsp]
  00233	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl

; 613  :         regs->ip      += ilc;  // (so trace_program_interrupt can undo)

  00239	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0023e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  0024a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00252	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax

; 614  :         regs->psw.IA  += ilc;  // (so trace_program_interrupt can undo)

  00256	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025e	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00264	03 44 24 40	 add	 eax, DWORD PTR ilc$[rsp]
  00268	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN10@s370_fix_p:

; 615  : 
; 616  :         PTT_PGM( "fxpiPSW ilc", regs->ip, regs->psw.IA, ilc );

  00276	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0027d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00280	48 83 e0 20	 and	 rax, 32			; 00000020H
  00284	48 85 c0	 test	 rax, rax
  00287	74 4e		 je	 SHORT $LN17@s370_fix_p
  00289	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  0028e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00296	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  0029c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170008
  002b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b6	44 8b c9	 mov	 r9d, ecx
  002b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c1	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  002c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170009
  002cc	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN17@s370_fix_p:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	75 99		 jne	 SHORT $LN10@s370_fix_p
$LN15@s370_fix_p:
$LN13@s370_fix_p:

; 617  :     }
; 618  : 
; 619  :     /* Return ilc value to be passed to 'trace_program_interrupt' */
; 620  : 
; 621  :     PTT_PGM( "fxpiPSW ret", 0, 0, ilc );

  002dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  002e4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002e7	48 83 e0 20	 and	 rax, 32			; 00000020H
  002eb	48 85 c0	 test	 rax, rax
  002ee	74 37		 je	 SHORT $LN18@s370_fix_p
  002f0	48 63 44 24 40	 movsxd	 rax, DWORD PTR ilc$[rsp]
  002f5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002fe	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00303	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170011
  0030a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030f	45 33 c9	 xor	 r9d, r9d
  00312	45 33 c0	 xor	 r8d, r8d
  00315	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170012
  0031c	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s370_fix_p:
  00327	33 c0		 xor	 eax, eax
  00329	85 c0		 test	 eax, eax
  0032b	75 b0		 jne	 SHORT $LN13@s370_fix_p

; 622  :     return ilc;

  0032d	8b 44 24 40	 mov	 eax, DWORD PTR ilc$[rsp]

; 623  : }

  00331	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00335	c3		 ret	 0
s370_fix_program_interrupt_PSW ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv191 = 64
tv211 = 68
regs$ = 96
offset$ = 104
s370_SuccessfulRelativeBranch PROC

; 400  : {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 401  :     /* Set BEAR to branch instruction. Note: for branch instructions
; 402  :        regs->ip is not updated to point to the next instruction and
; 403  :        thus is still pointing to the branch instruction itself.
; 404  :     */
; 405  :     SET_BEAR_REG( regs, regs->ip );
; 406  : 
; 407  :     /* Branch target still within same page as branch instruction? */
; 408  :     if (1
; 409  :         && !regs->permode
; 410  :         && !regs->execflag
; 411  :         &&  offset > -4096
; 412  :         &&  offset < +4096
; 413  :         && (regs->ip + offset) >= regs->aip
; 414  :         && (regs->ip + offset) <  regs->aie

  0000e	33 c0		 xor	 eax, eax
  00010	83 f8 01	 cmp	 eax, 1
  00013	0f 84 04 01 00
	00		 je	 $LN17@s370_Succe
  00019	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0001e	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00024	c1 e8 02	 shr	 eax, 2
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	0f 85 eb 00 00
	00		 jne	 $LN17@s370_Succe
  00032	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0003d	83 e0 01	 and	 eax, 1
  00040	85 c0		 test	 eax, eax
  00042	0f 85 d5 00 00
	00		 jne	 $LN17@s370_Succe
  00048	48 81 7c 24 68
	00 f0 ff ff	 cmp	 QWORD PTR offset$[rsp], -4096 ; fffffffffffff000H
  00051	0f 8e c6 00 00
	00		 jle	 $LN17@s370_Succe
  00057	48 81 7c 24 68
	00 10 00 00	 cmp	 QWORD PTR offset$[rsp], 4096 ; 00001000H
  00060	0f 8d b7 00 00
	00		 jge	 $LN17@s370_Succe
  00066	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0006f	48 03 44 24 68	 add	 rax, QWORD PTR offset$[rsp]
  00074	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	48 3b 81 00 02
	00 00		 cmp	 rax, QWORD PTR [rcx+512]
  00080	0f 82 97 00 00
	00		 jb	 $LN17@s370_Succe
  00086	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0008f	48 03 44 24 68	 add	 rax, QWORD PTR offset$[rsp]
  00094	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	48 3b 81 08 02
	00 00		 cmp	 rax, QWORD PTR [rcx+520]
  000a0	73 7b		 jae	 SHORT $LN17@s370_Succe

; 415  :     )
; 416  :     {
; 417  :         /* Branch directly to the new instruction */
; 418  :         regs->ip = regs->ip + offset;

  000a2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000ab	48 03 44 24 68	 add	 rax, QWORD PTR offset$[rsp]
  000b0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN4@s370_Succe:

; 419  :         PTT_INF( "rbranch <", regs->ip, offset, regs->aip );

  000b9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000c0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000c3	48 83 e0 08	 and	 rax, 8
  000c7	48 85 c0	 test	 rax, rax
  000ca	74 46		 je	 SHORT $LN18@s370_Succe
  000cc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000d5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000da	48 8b 80 00 02
	00 00		 mov	 rax, QWORD PTR [rax+512]
  000e1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169855
  000ed	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f2	4c 8b 4c 24 68	 mov	 r9, QWORD PTR offset$[rsp]
  000f7	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	4c 8b 40 68	 mov	 r8, QWORD PTR [rax+104]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169856
  00107	b9 08 00 00 00	 mov	 ecx, 8
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s370_Succe:
  00112	33 c0		 xor	 eax, eax
  00114	85 c0		 test	 eax, eax
  00116	75 a1		 jne	 SHORT $LN4@s370_Succe

; 420  :         return;

  00118	e9 e7 01 00 00	 jmp	 $LN1@s370_Succe
$LN17@s370_Succe:
$LN7@s370_Succe:

; 421  :     }
; 422  : 
; 423  :     /* Branch target is in another page: point the PSW to the target
; 424  :        instruction and force a new "regs->ip" value to get set by
; 425  :        forcing a full instruction fetch from the new target address.
; 426  :     */
; 427  :     PTT_INF( "rbranch >", regs->psw.IA, offset, regs->execflag );

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00124	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00127	48 83 e0 08	 and	 rax, 8
  0012b	48 85 c0	 test	 rax, rax
  0012e	74 4f		 je	 SHORT $LN19@s370_Succe
  00130	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00135	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0013b	83 e0 01	 and	 eax, 1
  0013e	8b c0		 mov	 eax, eax
  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  0014b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00154	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00159	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169858
  00160	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00165	4c 8b 4c 24 68	 mov	 r9, QWORD PTR offset$[rsp]
  0016a	44 8b c1	 mov	 r8d, ecx
  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169859
  00174	b9 08 00 00 00	 mov	 ecx, 8
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@s370_Succe:
  0017f	33 c0		 xor	 eax, eax
  00181	85 c0		 test	 eax, eax
  00183	75 98		 jne	 SHORT $LN7@s370_Succe

; 428  : 
; 429  :     /* Point PSW to target instruction */
; 430  :     if (!regs->execflag)

  00185	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00190	83 e0 01	 and	 eax, 1
  00193	85 c0		 test	 eax, eax
  00195	75 47		 jne	 SHORT $LN20@s370_Succe

; 431  :         regs->psw.IA = PSW_IA_FROM_IP( regs, offset );

  00197	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0019c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  001a2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  001ac	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  001b3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  001b7	48 2b ca	 sub	 rcx, rdx
  001ba	48 8b 54 24 68	 mov	 rdx, QWORD PTR offset$[rsp]
  001bf	48 03 d0	 add	 rdx, rax
  001c2	48 8b c2	 mov	 rax, rdx
  001c5	48 03 c8	 add	 rcx, rax
  001c8	48 8b c1	 mov	 rax, rcx
  001cb	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  001d1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001d6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  001dc	eb 36		 jmp	 SHORT $LN21@s370_Succe
$LN20@s370_Succe:

; 432  :     else
; 433  :     {
; 434  :         regs->psw.IA = regs->ET + offset;

  001de	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001e3	8b 80 20 07 00
	00		 mov	 eax, DWORD PTR [rax+1824]
  001e9	48 03 44 24 68	 add	 rax, QWORD PTR offset$[rsp]
  001ee	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 435  :         regs->psw.IA &= ADDRESS_MAXWRAP( regs );

  001f9	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001fe	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00204	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00209	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0020e	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN21@s370_Succe:

; 436  :     }
; 437  :     regs->aie = INVALID_AIE;            /* Force a fresh 'instfetch' */

  00214	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00219	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN10@s370_Succe:

; 438  : 
; 439  :     PTT_INF( "rbranch >", regs->psw.IA, offset, regs->execflag );

  00224	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0022b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0022e	48 83 e0 08	 and	 rax, 8
  00232	48 85 c0	 test	 rax, rax
  00235	74 4f		 je	 SHORT $LN22@s370_Succe
  00237	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0023c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00242	83 e0 01	 and	 eax, 1
  00245	8b c0		 mov	 eax, eax
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0024c	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  00252	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0025b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00260	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169863
  00267	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026c	4c 8b 4c 24 68	 mov	 r9, QWORD PTR offset$[rsp]
  00271	44 8b c1	 mov	 r8d, ecx
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169864
  0027b	b9 08 00 00 00	 mov	 ecx, 8
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@s370_Succe:
  00286	33 c0		 xor	 eax, eax
  00288	85 c0		 test	 eax, eax
  0028a	75 98		 jne	 SHORT $LN10@s370_Succe
$LN13@s370_Succe:

; 440  :     PER_SB( regs, regs->psw.IA );

  0028c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00291	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00297	c1 e8 02	 shr	 eax, 2
  0029a	83 e0 01	 and	 eax, 1
  0029d	85 c0		 test	 eax, eax
  0029f	74 0a		 je	 SHORT $LN27@s370_Succe
  002a1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv191[rsp], 1
  002a9	eb 08		 jmp	 SHORT $LN28@s370_Succe
$LN27@s370_Succe:
  002ab	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv191[rsp], 0
$LN28@s370_Succe:
  002b3	83 7c 24 40 00	 cmp	 DWORD PTR tv191[rsp], 0
  002b8	74 1b		 je	 SHORT $LN29@s370_Succe
  002ba	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  002bf	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002c2	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  002c7	85 c0		 test	 eax, eax
  002c9	74 0a		 je	 SHORT $LN29@s370_Succe
  002cb	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv211[rsp], 1
  002d3	eb 08		 jmp	 SHORT $LN35@s370_Succe
$LN29@s370_Succe:
  002d5	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv211[rsp], 0
$LN35@s370_Succe:
  002dd	83 7c 24 44 00	 cmp	 DWORD PTR tv211[rsp], 0
  002e2	74 1a		 je	 SHORT $LN23@s370_Succe
$LN16@s370_Succe:
  002e4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  002e9	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  002ec	0f ba e8 17	 bts	 eax, 23
  002f0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002f5	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  002f8	33 c0		 xor	 eax, eax
  002fa	85 c0		 test	 eax, eax
  002fc	75 e6		 jne	 SHORT $LN16@s370_Succe
$LN23@s370_Succe:
  002fe	33 c0		 xor	 eax, eax
  00300	85 c0		 test	 eax, eax
  00302	75 88		 jne	 SHORT $LN13@s370_Succe
$LN1@s370_Succe:

; 441  : }

  00304	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00308	c3		 ret	 0
s370_SuccessfulRelativeBranch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv153 = 64
tv173 = 68
regs$ = 96
vaddr$ = 104
s370_SuccessfulBranch PROC

; 363  : {

$LN30:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 364  :     vaddr &= ADDRESS_MAXWRAP( regs );

  0000d	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  00011	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00016	89 44 24 68	 mov	 DWORD PTR vaddr$[rsp], eax

; 365  : 
; 366  :     /* Set BEAR to branch instruction. Note: for branch instructions
; 367  :        regs->ip is not updated to point to the next instruction and
; 368  :        thus is still pointing to the branch instruction itself.
; 369  :     */
; 370  :     SET_BEAR_REG( regs, regs->ip );
; 371  : 
; 372  :     /* Branch target still within same page as branch instruction? */
; 373  :     if (1
; 374  :         && !regs->permode
; 375  :         && !regs->execflag
; 376  :         && (vaddr & (PAGEFRAME_PAGEMASK | 0x01)) == regs->AIV

  0001a	33 c0		 xor	 eax, eax
  0001c	83 f8 01	 cmp	 eax, 1
  0001f	0f 84 db 00 00
	00		 je	 $LN14@s370_Succe
  00025	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0002a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00030	c1 e8 02	 shr	 eax, 2
  00033	83 e0 01	 and	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	0f 85 c2 00 00
	00		 jne	 $LN14@s370_Succe
  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00043	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00049	83 e0 01	 and	 eax, 1
  0004c	85 c0		 test	 eax, eax
  0004e	0f 85 ac 00 00
	00		 jne	 $LN14@s370_Succe
  00054	8b 44 24 68	 mov	 eax, DWORD PTR vaddr$[rsp]
  00058	25 01 f8 ff 7f	 and	 eax, 2147481601		; 7ffff801H
  0005d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	3b 81 10 02 00
	00		 cmp	 eax, DWORD PTR [rcx+528]
  00068	0f 85 92 00 00
	00		 jne	 $LN14@s370_Succe

; 377  :     )
; 378  :     {
; 379  :         /* Branch directly to the new instruction */
; 380  :         regs->ip = regs->aip + (vaddr - regs->AIV);

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00073	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00079	8b 4c 24 68	 mov	 ecx, DWORD PTR vaddr$[rsp]
  0007d	2b c8		 sub	 ecx, eax
  0007f	8b c1		 mov	 eax, ecx
  00081	8b c0		 mov	 eax, eax
  00083	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	48 03 81 00 02
	00 00		 add	 rax, QWORD PTR [rcx+512]
  0008f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN4@s370_Succe:

; 381  :         PTT_INF( "branch", vaddr, regs->AIV, regs->ip );

  00098	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0009f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a2	48 83 e0 08	 and	 rax, 8
  000a6	48 85 c0	 test	 rax, rax
  000a9	74 4a		 je	 SHORT $LN15@s370_Succe
  000ab	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000b0	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  000b6	8b 4c 24 68	 mov	 ecx, DWORD PTR vaddr$[rsp]
  000ba	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000c3	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  000c8	48 8b 52 68	 mov	 rdx, QWORD PTR [rdx+104]
  000cc	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  000d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169802
  000d8	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000dd	44 8b c8	 mov	 r9d, eax
  000e0	44 8b c1	 mov	 r8d, ecx
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169803
  000ea	b9 08 00 00 00	 mov	 ecx, 8
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@s370_Succe:
  000f5	33 c0		 xor	 eax, eax
  000f7	85 c0		 test	 eax, eax
  000f9	75 9d		 jne	 SHORT $LN4@s370_Succe

; 382  :         return;

  000fb	e9 f5 00 00 00	 jmp	 $LN1@s370_Succe
$LN14@s370_Succe:

; 383  :     }
; 384  : 
; 385  :     /* Branch target is in another page: point the PSW to the target
; 386  :        instruction and force a new "regs->ip" value to get set by
; 387  :        forcing a full instruction fetch from the new target address.
; 388  :     */
; 389  :     regs->psw.IA = vaddr;               /* Point PSW to target instr */

  00100	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00105	8b 4c 24 68	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00109	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx

; 390  :     regs->aie = INVALID_AIE;            /* Force a fresh 'instfetch' */

  0010f	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00114	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN7@s370_Succe:

; 391  : 
; 392  :     PTT_INF( "branch", vaddr, regs->AIV, 0 );

  0011f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00126	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00129	48 83 e0 08	 and	 rax, 8
  0012d	48 85 c0	 test	 rax, rax
  00130	74 45		 je	 SHORT $LN16@s370_Succe
  00132	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00137	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0013d	8b 4c 24 68	 mov	 ecx, DWORD PTR vaddr$[rsp]
  00141	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0014a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00153	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169805
  0015a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0015f	44 8b c8	 mov	 r9d, eax
  00162	44 8b c1	 mov	 r8d, ecx
  00165	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169806
  0016c	b9 08 00 00 00	 mov	 ecx, 8
  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s370_Succe:
  00177	33 c0		 xor	 eax, eax
  00179	85 c0		 test	 eax, eax
  0017b	75 a2		 jne	 SHORT $LN7@s370_Succe
$LN10@s370_Succe:

; 393  :     PER_SB( regs, regs->psw.IA );

  0017d	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00188	c1 e8 02	 shr	 eax, 2
  0018b	83 e0 01	 and	 eax, 1
  0018e	85 c0		 test	 eax, eax
  00190	74 0a		 je	 SHORT $LN21@s370_Succe
  00192	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  0019a	eb 08		 jmp	 SHORT $LN22@s370_Succe
$LN21@s370_Succe:
  0019c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN22@s370_Succe:
  001a4	83 7c 24 40 00	 cmp	 DWORD PTR tv153[rsp], 0
  001a9	74 1b		 je	 SHORT $LN23@s370_Succe
  001ab	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001b0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  001b3	25 00 00 80 00	 and	 eax, 8388608		; 00800000H
  001b8	85 c0		 test	 eax, eax
  001ba	74 0a		 je	 SHORT $LN23@s370_Succe
  001bc	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv173[rsp], 1
  001c4	eb 08		 jmp	 SHORT $LN29@s370_Succe
$LN23@s370_Succe:
  001c6	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv173[rsp], 0
$LN29@s370_Succe:
  001ce	83 7c 24 44 00	 cmp	 DWORD PTR tv173[rsp], 0
  001d3	74 1a		 je	 SHORT $LN17@s370_Succe
$LN13@s370_Succe:
  001d5	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001da	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  001dd	0f ba e8 17	 bts	 eax, 23
  001e1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001e6	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  001e9	33 c0		 xor	 eax, eax
  001eb	85 c0		 test	 eax, eax
  001ed	75 e6		 jne	 SHORT $LN13@s370_Succe
$LN17@s370_Succe:
  001ef	33 c0		 xor	 eax, eax
  001f1	85 c0		 test	 eax, eax
  001f3	75 88		 jne	 SHORT $LN10@s370_Succe
$LN1@s370_Succe:

; 394  : }

  001f5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001f9	c3		 ret	 0
s370_SuccessfulBranch ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
tv70 = 32
tv77 = 36
tv84 = 40
tv86 = 44
regs$ = 64
arch$ = 72
bc$ = 80
make_psw64 PROC

; 2801 : {

$LN13:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2802 :     return do_make_psw64( &regs->psw, REAL_ILC( regs ), arch, bc );

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00017	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001d	83 e0 01	 and	 eax, 1
  00020	85 c0		 test	 eax, eax
  00022	75 0a		 jne	 SHORT $LN3@make_psw64
  00024	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002c	eb 08		 jmp	 SHORT $LN4@make_psw64
$LN3@make_psw64:
  0002e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN4@make_psw64:
  00036	83 7c 24 20 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003b	74 0a		 je	 SHORT $LN7@make_psw64
  0003d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  00045	eb 08		 jmp	 SHORT $LN8@make_psw64
$LN7@make_psw64:
  00047	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN8@make_psw64:
  0004f	83 7c 24 24 00	 cmp	 DWORD PTR tv77[rsp], 0
  00054	74 12		 je	 SHORT $LN11@make_psw64
  00056	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	0f b6 80 9a 00
	00 00		 movzx	 eax, BYTE PTR [rax+154]
  00062	89 44 24 2c	 mov	 DWORD PTR tv86[rsp], eax
  00066	eb 2e		 jmp	 SHORT $LN12@make_psw64
$LN11@make_psw64:
  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00073	d1 e8		 shr	 eax, 1
  00075	83 e0 01	 and	 eax, 1
  00078	85 c0		 test	 eax, eax
  0007a	74 0a		 je	 SHORT $LN9@make_psw64
  0007c	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR tv84[rsp], 6
  00084	eb 08		 jmp	 SHORT $LN10@make_psw64
$LN9@make_psw64:
  00086	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv84[rsp], 4
$LN10@make_psw64:
  0008e	8b 44 24 28	 mov	 eax, DWORD PTR tv84[rsp]
  00092	89 44 24 2c	 mov	 DWORD PTR tv86[rsp], eax
$LN12@make_psw64:
  00096	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	48 83 c0 78	 add	 rax, 120		; 00000078H
  0009f	44 0f b6 4c 24
	50		 movzx	 r9d, BYTE PTR bc$[rsp]
  000a5	44 8b 44 24 48	 mov	 r8d, DWORD PTR arch$[rsp]
  000aa	0f b6 54 24 2c	 movzx	 edx, BYTE PTR tv86[rsp]
  000af	48 8b c8	 mov	 rcx, rax
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_do_make_psw64

; 2803 : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	c3		 ret	 0
make_psw64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
i$ = 32
p$1 = 40
regs$ = 64
s370_checkstop_all_cpus PROC

; 79   : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 80   :     int  i;
; 81   : 
; 82   :     if (!IS_INTLOCK_HELD( regs ))

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	0f b7 80 62 10
	00 00		 movzx	 eax, WORD PTR [rax+4194]
  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0001c	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00023	3b c1		 cmp	 eax, ecx
  00025	74 17		 je	 SHORT $LN11@s370_check
$LN4@s370_check:

; 83   :         CRASH();

  00027	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00030	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00035	c6 00 00	 mov	 BYTE PTR [rax], 0
  00038	33 c0		 xor	 eax, eax
  0003a	85 c0		 test	 eax, eax
  0003c	75 e9		 jne	 SHORT $LN4@s370_check
$LN11@s370_check:

; 84   : 
; 85   :     for (i=0; i < sysblk.maxcpu; i++)

  0003e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00046	eb 0a		 jmp	 SHORT $LN7@s370_check
$LN5@s370_check:
  00048	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_check:
  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0005f	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00063	0f 8d a7 00 00
	00		 jge	 $LN6@s370_check

; 86   :     {
; 87   :         if (IS_CPU_ONLINE(i))

  00069	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0006e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00075	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0007e	0f 84 87 00 00
	00		 je	 $LN12@s370_check

; 88   :         {
; 89   :             sysblk.regs[i]->cpustate = CPUSTATE_STOPPING;

  00084	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00089	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00090	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00098	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2

; 90   :             sysblk.regs[i]->checkstop = 1;

  0009c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a8	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000b0	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  000b6	83 c8 20	 or	 eax, 32			; 00000020H
  000b9	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000be	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000c5	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  000cd	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN10@s370_check:

; 91   :             ON_IC_INTERRUPT( sysblk.regs[i] );

  000d3	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000df	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  000e7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000ea	0f ba e8 1f	 bts	 eax, 31
  000ee	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000fa	48 8b 8c ca 98
	0b 00 00	 mov	 rcx, QWORD PTR [rdx+rcx*8+2968]
  00102	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 c8		 jne	 SHORT $LN10@s370_check
$LN12@s370_check:

; 92   :         }
; 93   :     }

  0010b	e9 38 ff ff ff	 jmp	 $LN5@s370_check
$LN6@s370_check:

; 94   :     WAKEUP_CPUS_MASK( sysblk.waiting_mask );

  00110	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169563
  00117	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0011e	48 8b 88 b8 12
	00 00		 mov	 rcx, QWORD PTR [rax+4792]
  00125	e8 00 00 00 00	 call	 wakeup_cpus_mask

; 95   : }

  0012a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0012e	c3		 ret	 0
s370_checkstop_all_cpus ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
ioid$ = 160
icode$ = 164
csw$1 = 168
psa$ = 176
tv176 = 184
rc$ = 188
iointid$ = 192
ioparm$ = 196
tv436 = 200
tv440 = 204
tv444 = 208
tv448 = 212
tv452 = 216
tv456 = 220
tv469 = 224
tv137 = 232
pfx$ = 240
dev$ = 248
tv474 = 256
csw$ = 264
__$ArrayPad$ = 272
regs$ = 336
s370_perform_io_interrupt PROC

; 1458 : {

$LN43:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 56		 push	 r14
  0000b	48 81 ec 20 01
	00 00		 sub	 rsp, 288		; 00000120H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1459 : int     rc;                             /* Return code               */
; 1460 : int     icode;                          /* Intercept code            */
; 1461 : PSA    *psa;                            /* -> Prefixed storage area  */
; 1462 : U32     ioparm;                         /* I/O interruption parameter*/
; 1463 : U32     ioid;                           /* I/O interruption address  */
; 1464 : U32     iointid;                        /* I/O interruption ident    */
; 1465 : RADR    pfx;                            /* Prefix                    */
; 1466 : DBLWRD  csw;                            /* CSW for S/370 channels    */
; 1467 : DEVBLK *dev;                            /* dev presenting interrupt  */
; 1468 : 
; 1469 :     /* Test and clear pending I/O interrupt */
; 1470 :     icode = ARCH_DEP( present_io_interrupt )( regs, &ioid, &ioparm, &iointid, csw, &dev );

  00024	48 8d 84 24 f8
	00 00 00	 lea	 rax, QWORD PTR dev$[rsp]
  0002c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00031	48 8d 84 24 08
	01 00 00	 lea	 rax, QWORD PTR csw$[rsp]
  00039	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003e	4c 8d 8c 24 c0
	00 00 00	 lea	 r9, QWORD PTR iointid$[rsp]
  00046	4c 8d 84 24 c4
	00 00 00	 lea	 r8, QWORD PTR ioparm$[rsp]
  0004e	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR ioid$[rsp]
  00056	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	e8 00 00 00 00	 call	 s370_present_io_interrupt
  00063	89 84 24 a4 00
	00 00		 mov	 DWORD PTR icode$[rsp], eax

; 1471 : 
; 1472 :     /* Exit if no interrupt was presented */
; 1473 :     if (icode == 0) return;

  0006a	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR icode$[rsp], 0
  00072	75 05		 jne	 SHORT $LN5@s370_perfo
  00074	e9 0f 0c 00 00	 jmp	 $LN1@s370_perfo
$LN5@s370_perfo:
$LN4@s370_perfo:

; 1474 : 
; 1475 :     PTT_IO("*IOINT",ioid,ioparm,iointid);

  00079	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00080	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00083	48 25 00 02 00
	00		 and	 rax, 512		; 00000200H
  00089	48 85 c0	 test	 rax, rax
  0008c	74 47		 je	 SHORT $LN6@s370_perfo
  0008e	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR iointid$[rsp]
  00095	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR ioparm$[rsp]
  0009c	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR ioid$[rsp]
  000a3	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170523
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	44 8b c9	 mov	 r9d, ecx
  000c0	44 8b c2	 mov	 r8d, edx
  000c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170524
  000ca	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN6@s370_perfo:
  000d5	33 c0		 xor	 eax, eax
  000d7	85 c0		 test	 eax, eax
  000d9	75 9e		 jne	 SHORT $LN4@s370_perfo

; 1476 : 
; 1477 : #if defined(_FEATURE_IO_ASSIST)
; 1478 :     if(SIE_MODE(regs) && icode != SIE_NO_INTERCEPT)

  000db	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000e9	d1 e8		 shr	 eax, 1
  000eb	83 e0 01	 and	 eax, 1
  000ee	85 c0		 test	 eax, eax
  000f0	74 57		 je	 SHORT $LN7@s370_perfo
  000f2	83 bc 24 a4 00
	00 00 ff	 cmp	 DWORD PTR icode$[rsp], -1
  000fa	74 4d		 je	 SHORT $LN7@s370_perfo

; 1479 :     {
; 1480 :         /* Point to SIE copy of PSA in state descriptor */
; 1481 :         psa = (void*)(HOSTREGS->mainstor + SIE_STATE(regs) + SIE_II_PSA_OFFSET);

  000fc	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00104	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0010b	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  00112	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	48 8b 89 80 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2176]
  00121	48 8d 44 08 30	 lea	 rax, QWORD PTR [rax+rcx+48]
  00126	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1482 :         ARCH_DEP( or_storage_key )( SIE_STATE( regs ), (STORKEY_REF | STORKEY_CHANGE) );

  0012e	b2 06		 mov	 dl, 6
  00130	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00138	48 8b 88 80 08
	00 00		 mov	 rcx, QWORD PTR [rax+2176]
  0013f	e8 00 00 00 00	 call	 s370_or_storage_key

; 1483 :     }

  00144	e9 81 00 00 00	 jmp	 $LN8@s370_perfo
$LN7@s370_perfo:

; 1484 :     else
; 1485 : #endif
; 1486 :     {
; 1487 :         /* Point to PSA in main storage */
; 1488 :         pfx =

  00149	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00151	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00157	d1 e8		 shr	 eax, 1
  00159	83 e0 01	 and	 eax, 1
  0015c	85 c0		 test	 eax, eax
  0015e	74 19		 je	 SHORT $LN37@s370_perfo
  00160	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00168	48 8b 80 90 08
	00 00		 mov	 rax, QWORD PTR [rax+2192]
  0016f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv137[rsp], rax
  00177	eb 13		 jmp	 SHORT $LN38@s370_perfo
$LN37@s370_perfo:
  00179	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00184	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv137[rsp], rax
$LN38@s370_perfo:
  0018c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv137[rsp]
  00194	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR pfx$[rsp], rax

; 1489 : #if defined(_FEATURE_SIE)
; 1490 :               SIE_MODE(regs) ? regs->sie_px :
; 1491 : #endif
; 1492 :               regs->PX;
; 1493 :         psa = (void*)(regs->mainstor + pfx);

  0019c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a4	48 8b 80 48 08
	00 00		 mov	 rax, QWORD PTR [rax+2120]
  001ab	48 03 84 24 f0
	00 00 00	 add	 rax, QWORD PTR pfx$[rsp]
  001b3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR psa$[rsp], rax

; 1494 :         ARCH_DEP( or_storage_key )( pfx, (STORKEY_REF | STORKEY_CHANGE) );

  001bb	b2 06		 mov	 dl, 6
  001bd	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR pfx$[rsp]
  001c5	e8 00 00 00 00	 call	 s370_or_storage_key
$LN8@s370_perfo:

; 1495 :     }
; 1496 : 
; 1497 : #ifdef FEATURE_S370_CHANNEL
; 1498 :     /* CSW has already been stored at PSA+X'40' */
; 1499 : 
; 1500 :     if (sysblk.arch_mode == ARCH_370_IDX &&

  001ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001d1	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  001d8	75 71		 jne	 SHORT $LN9@s370_perfo
  001da	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e2	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  001e6	83 e0 08	 and	 eax, 8
  001e9	85 c0		 test	 eax, eax
  001eb	74 5e		 je	 SHORT $LN9@s370_perfo

; 1501 :         ECMODE(&regs->psw))
; 1502 :     {
; 1503 :         /* For ECMODE, store the I/O device address at PSA+X'B8' */
; 1504 :         STORE_FW(psa->ioid,

  001ed	b8 01 00 00 00	 mov	 eax, 1
  001f2	48 6b c0 00	 imul	 rax, rax, 0
  001f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  001fe	0f b6 84 01 b8
	00 00 00	 movzx	 eax, BYTE PTR [rcx+rax+184]
  00206	c1 e0 08	 shl	 eax, 8
  00209	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ioid$[rsp]
  00210	c1 e9 10	 shr	 ecx, 16
  00213	d1 e9		 shr	 ecx, 1
  00215	83 e1 07	 and	 ecx, 7
  00218	0b c1		 or	 eax, ecx
  0021a	c1 e0 10	 shl	 eax, 16
  0021d	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ioid$[rsp]
  00224	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0022a	0b c1		 or	 eax, ecx
  0022c	8b c8		 mov	 ecx, eax
  0022e	e8 00 00 00 00	 call	 _byteswap_ulong
  00233	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR psa$[rsp]
  0023b	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00242	8b d0		 mov	 edx, eax
  00244	e8 00 00 00 00	 call	 store_fw_noswap

; 1505 :                  ((((U32)psa->ioid[0] << 8) |
; 1506 :                    ((U32)SSID_TO_LCSS(ioid >> 16) & 0x07)) << 16) |
; 1507 :                  (ioid & 0x0000FFFFUL));
; 1508 :     }

  00249	eb 17		 jmp	 SHORT $LN10@s370_perfo
$LN9@s370_perfo:

; 1509 :     else
; 1510 :     {
; 1511 :         /* Set the interrupt code to the I/O device address */
; 1512 :         regs->psw.intcode = ioid;

  0024b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00253	0f b7 8c 24 a0
	00 00 00	 movzx	 ecx, WORD PTR ioid$[rsp]
  0025b	66 89 88 98 00
	00 00		 mov	 WORD PTR [rax+152], cx
$LN10@s370_perfo:

; 1513 :     }
; 1514 : 
; 1515 :     /* Trace the I/O interrupt */
; 1516 :     if (CPU_STEPPING_OR_TRACING( regs, 0 ) || dev->ccwtrace)

  00262	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026a	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00270	c1 e8 10	 shr	 eax, 16
  00273	83 e0 01	 and	 eax, 1
  00276	85 c0		 test	 eax, eax
  00278	74 0d		 je	 SHORT $LN41@s370_perfo
  0027a	c7 84 24 b8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv176[rsp], 1
  00285	eb 0b		 jmp	 SHORT $LN42@s370_perfo
$LN41@s370_perfo:
  00287	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv176[rsp], 0
$LN42@s370_perfo:
  00292	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR tv176[rsp], 0
  0029a	0f 84 ab 06 00
	00		 je	 $LN13@s370_perfo
  002a0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002a7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002ad	c1 e8 0a	 shr	 eax, 10
  002b0	83 e0 01	 and	 eax, 1
  002b3	85 c0		 test	 eax, eax
  002b5	0f 84 29 03 00
	00		 je	 $LN14@s370_perfo
  002bb	33 c0		 xor	 eax, eax
  002bd	85 c0		 test	 eax, eax
  002bf	0f 85 2d 01 00
	00		 jne	 $LN15@s370_perfo
  002c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002cc	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  002d2	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002d7	85 c0		 test	 eax, eax
  002d9	0f 84 13 01 00
	00		 je	 $LN15@s370_perfo
  002df	33 c0		 xor	 eax, eax
  002e1	83 f8 01	 cmp	 eax, 1
  002e4	0f 84 fa 02 00
	00		 je	 $LN14@s370_perfo
  002ea	33 c0		 xor	 eax, eax
  002ec	85 c0		 test	 eax, eax
  002ee	75 37		 jne	 SHORT $LN16@s370_perfo
  002f0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f7	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  002fd	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00302	85 c0		 test	 eax, eax
  00304	74 21		 je	 SHORT $LN16@s370_perfo
  00306	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00315	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0031b	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00321	0f 85 bd 02 00
	00		 jne	 $LN14@s370_perfo
$LN16@s370_perfo:
  00327	33 c0		 xor	 eax, eax
  00329	85 c0		 test	 eax, eax
  0032b	75 37		 jne	 SHORT $LN17@s370_perfo
  0032d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00334	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0033a	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0033f	85 c0		 test	 eax, eax
  00341	74 21		 je	 SHORT $LN17@s370_perfo
  00343	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00352	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00358	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0035e	0f 8c 80 02 00
	00		 jl	 $LN14@s370_perfo
$LN17@s370_perfo:
  00364	33 c0		 xor	 eax, eax
  00366	85 c0		 test	 eax, eax
  00368	0f 85 84 00 00
	00		 jne	 $LN18@s370_perfo
  0036e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00375	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0037b	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00380	85 c0		 test	 eax, eax
  00382	74 26		 je	 SHORT $LN19@s370_perfo
  00384	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038c	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00393	85 c0		 test	 eax, eax
  00395	74 13		 je	 SHORT $LN19@s370_perfo
  00397	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  003a6	85 c0		 test	 eax, eax
  003a8	75 48		 jne	 SHORT $LN18@s370_perfo
$LN19@s370_perfo:
  003aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b1	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  003b7	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  003bc	85 c0		 test	 eax, eax
  003be	0f 84 20 02 00
	00		 je	 $LN14@s370_perfo
  003c4	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003cc	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  003d3	85 c0		 test	 eax, eax
  003d5	0f 84 09 02 00
	00		 je	 $LN14@s370_perfo
  003db	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e3	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  003ea	85 c0		 test	 eax, eax
  003ec	0f 85 f2 01 00
	00		 jne	 $LN14@s370_perfo
$LN18@s370_perfo:
$LN15@s370_perfo:
  003f2	b8 08 00 00 00	 mov	 eax, 8
  003f7	48 6b c0 00	 imul	 rax, rax, 0
  003fb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00402	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  0040b	75 1f		 jne	 SHORT $LN20@s370_perfo
  0040d	b8 08 00 00 00	 mov	 eax, 8
  00412	48 6b c0 01	 imul	 rax, rax, 1
  00416	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0041d	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00426	0f 84 3b 05 00
	00		 je	 $LN12@s370_perfo
$LN20@s370_perfo:
  0042c	b8 08 00 00 00	 mov	 eax, 8
  00431	48 6b c0 00	 imul	 rax, rax, 0
  00435	b9 08 00 00 00	 mov	 ecx, 8
  0043a	48 6b c9 01	 imul	 rcx, rcx, 1
  0043e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00445	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  0044c	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  00454	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  0045c	0f 87 a6 00 00
	00		 ja	 $LN21@s370_perfo
  00462	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0046a	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00470	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00478	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00480	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00487	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0048b	48 2b ca	 sub	 rcx, rdx
  0048e	48 03 c1	 add	 rax, rcx
  00491	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00497	8b c0		 mov	 eax, eax
  00499	b9 08 00 00 00	 mov	 ecx, 8
  0049e	48 6b c9 00	 imul	 rcx, rcx, 0
  004a2	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004a9	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  004b1	72 55		 jb	 SHORT $LN21@s370_perfo
  004b3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004bb	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  004c1	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c9	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004d1	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  004d8	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  004dc	48 2b ca	 sub	 rcx, rdx
  004df	48 03 c1	 add	 rax, rcx
  004e2	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  004e8	8b c0		 mov	 eax, eax
  004ea	b9 08 00 00 00	 mov	 ecx, 8
  004ef	48 6b c9 01	 imul	 rcx, rcx, 1
  004f3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  004fa	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00502	0f 86 5f 04 00
	00		 jbe	 $LN12@s370_perfo
$LN21@s370_perfo:
  00508	b8 08 00 00 00	 mov	 eax, 8
  0050d	48 6b c0 00	 imul	 rax, rax, 0
  00511	b9 08 00 00 00	 mov	 ecx, 8
  00516	48 6b c9 01	 imul	 rcx, rcx, 1
  0051a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00521	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00528	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  00530	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00538	0f 86 a6 00 00
	00		 jbe	 $LN22@s370_perfo
  0053e	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00546	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0054c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00554	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0055c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00563	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00567	48 2b ca	 sub	 rcx, rdx
  0056a	48 03 c1	 add	 rax, rcx
  0056d	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00573	8b c0		 mov	 eax, eax
  00575	b9 08 00 00 00	 mov	 ecx, 8
  0057a	48 6b c9 01	 imul	 rcx, rcx, 1
  0057e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00585	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0058d	72 55		 jb	 SHORT $LN22@s370_perfo
  0058f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00597	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0059d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a5	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005ad	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  005b4	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  005b8	48 2b ca	 sub	 rcx, rdx
  005bb	48 03 c1	 add	 rax, rcx
  005be	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  005c4	8b c0		 mov	 eax, eax
  005c6	b9 08 00 00 00	 mov	 ecx, 8
  005cb	48 6b c9 00	 imul	 rcx, rcx, 0
  005cf	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005d6	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  005de	0f 86 83 03 00
	00		 jbe	 $LN12@s370_perfo
$LN22@s370_perfo:
$LN14@s370_perfo:
  005e4	33 c0		 xor	 eax, eax
  005e6	83 f8 01	 cmp	 eax, 1
  005e9	0f 84 5c 03 00
	00		 je	 $LN23@s370_perfo
  005ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005f6	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  005fc	c1 e8 08	 shr	 eax, 8
  005ff	83 e0 01	 and	 eax, 1
  00602	85 c0		 test	 eax, eax
  00604	0f 84 41 03 00
	00		 je	 $LN23@s370_perfo
  0060a	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00612	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00618	c1 e8 0f	 shr	 eax, 15
  0061b	83 e0 01	 and	 eax, 1
  0061e	85 c0		 test	 eax, eax
  00620	0f 84 25 03 00
	00		 je	 $LN23@s370_perfo
  00626	33 c0		 xor	 eax, eax
  00628	85 c0		 test	 eax, eax
  0062a	0f 85 2d 01 00
	00		 jne	 $LN24@s370_perfo
  00630	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00637	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0063d	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00642	85 c0		 test	 eax, eax
  00644	0f 84 13 01 00
	00		 je	 $LN24@s370_perfo
  0064a	33 c0		 xor	 eax, eax
  0064c	83 f8 01	 cmp	 eax, 1
  0064f	0f 84 f6 02 00
	00		 je	 $LN23@s370_perfo
  00655	33 c0		 xor	 eax, eax
  00657	85 c0		 test	 eax, eax
  00659	75 37		 jne	 SHORT $LN25@s370_perfo
  0065b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00662	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00668	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0066d	85 c0		 test	 eax, eax
  0066f	74 21		 je	 SHORT $LN25@s370_perfo
  00671	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00679	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00680	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  00686	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  0068c	0f 85 b9 02 00
	00		 jne	 $LN23@s370_perfo
$LN25@s370_perfo:
  00692	33 c0		 xor	 eax, eax
  00694	85 c0		 test	 eax, eax
  00696	75 37		 jne	 SHORT $LN26@s370_perfo
  00698	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0069f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006a5	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  006aa	85 c0		 test	 eax, eax
  006ac	74 21		 je	 SHORT $LN26@s370_perfo
  006ae	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006bd	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  006c3	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  006c9	0f 8c 7c 02 00
	00		 jl	 $LN23@s370_perfo
$LN26@s370_perfo:
  006cf	33 c0		 xor	 eax, eax
  006d1	85 c0		 test	 eax, eax
  006d3	0f 85 84 00 00
	00		 jne	 $LN27@s370_perfo
  006d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006e0	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006e6	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  006eb	85 c0		 test	 eax, eax
  006ed	74 26		 je	 SHORT $LN28@s370_perfo
  006ef	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f7	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  006fe	85 c0		 test	 eax, eax
  00700	74 13		 je	 SHORT $LN28@s370_perfo
  00702	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070a	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00711	85 c0		 test	 eax, eax
  00713	75 48		 jne	 SHORT $LN27@s370_perfo
$LN28@s370_perfo:
  00715	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0071c	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00722	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00727	85 c0		 test	 eax, eax
  00729	0f 84 1c 02 00
	00		 je	 $LN23@s370_perfo
  0072f	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00737	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0073e	85 c0		 test	 eax, eax
  00740	0f 84 05 02 00
	00		 je	 $LN23@s370_perfo
  00746	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074e	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00755	85 c0		 test	 eax, eax
  00757	0f 85 ee 01 00
	00		 jne	 $LN23@s370_perfo
$LN27@s370_perfo:
$LN24@s370_perfo:
  0075d	b8 08 00 00 00	 mov	 eax, 8
  00762	48 6b c0 00	 imul	 rax, rax, 0
  00766	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0076d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00776	75 1f		 jne	 SHORT $LN29@s370_perfo
  00778	b8 08 00 00 00	 mov	 eax, 8
  0077d	48 6b c0 01	 imul	 rax, rax, 1
  00781	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00788	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00791	0f 84 d0 01 00
	00		 je	 $LN12@s370_perfo
$LN29@s370_perfo:
  00797	b8 08 00 00 00	 mov	 eax, 8
  0079c	48 6b c0 00	 imul	 rax, rax, 0
  007a0	b9 08 00 00 00	 mov	 ecx, 8
  007a5	48 6b c9 01	 imul	 rcx, rcx, 1
  007a9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  007b0	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  007b7	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  007bf	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  007c7	0f 87 a6 00 00
	00		 ja	 $LN30@s370_perfo
  007cd	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007d5	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  007db	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007e3	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007eb	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  007f2	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  007f6	48 2b ca	 sub	 rcx, rdx
  007f9	48 03 c1	 add	 rax, rcx
  007fc	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00802	8b c0		 mov	 eax, eax
  00804	b9 08 00 00 00	 mov	 ecx, 8
  00809	48 6b c9 00	 imul	 rcx, rcx, 0
  0080d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00814	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0081c	72 55		 jb	 SHORT $LN30@s370_perfo
  0081e	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00826	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0082c	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00834	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0083c	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00843	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00847	48 2b ca	 sub	 rcx, rdx
  0084a	48 03 c1	 add	 rax, rcx
  0084d	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00853	8b c0		 mov	 eax, eax
  00855	b9 08 00 00 00	 mov	 ecx, 8
  0085a	48 6b c9 01	 imul	 rcx, rcx, 1
  0085e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00865	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0086d	0f 86 f4 00 00
	00		 jbe	 $LN12@s370_perfo
$LN30@s370_perfo:
  00873	b8 08 00 00 00	 mov	 eax, 8
  00878	48 6b c0 00	 imul	 rax, rax, 0
  0087c	b9 08 00 00 00	 mov	 ecx, 8
  00881	48 6b c9 01	 imul	 rcx, rcx, 1
  00885	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0088c	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00893	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  0089b	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  008a3	0f 86 a2 00 00
	00		 jbe	 $LN31@s370_perfo
  008a9	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b1	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  008b7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008bf	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008c7	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  008ce	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  008d2	48 2b ca	 sub	 rcx, rdx
  008d5	48 03 c1	 add	 rax, rcx
  008d8	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  008de	8b c0		 mov	 eax, eax
  008e0	b9 08 00 00 00	 mov	 ecx, 8
  008e5	48 6b c9 01	 imul	 rcx, rcx, 1
  008e9	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  008f0	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  008f8	72 51		 jb	 SHORT $LN31@s370_perfo
  008fa	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00902	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00908	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00910	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00918	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0091f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00923	48 2b ca	 sub	 rcx, rdx
  00926	48 03 c1	 add	 rax, rcx
  00929	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0092f	8b c0		 mov	 eax, eax
  00931	b9 08 00 00 00	 mov	 ecx, 8
  00936	48 6b c9 00	 imul	 rcx, rcx, 0
  0093a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00941	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00949	76 1c		 jbe	 SHORT $LN12@s370_perfo
$LN31@s370_perfo:
$LN23@s370_perfo:
$LN13@s370_perfo:
  0094b	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00953	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00959	c1 e8 0f	 shr	 eax, 15
  0095c	83 e0 01	 and	 eax, 1
  0095f	85 c0		 test	 eax, eax
  00961	0f 84 6c 02 00
	00		 je	 $LN11@s370_perfo
$LN12@s370_perfo:

; 1517 :     {
; 1518 :         BYTE* csw = psa->csw;

  00967	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  0096f	48 83 c0 40	 add	 rax, 64			; 00000040H
  00973	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR csw$1[rsp], rax

; 1519 : 
; 1520 :         if (regs->insttrace && sysblk.traceFILE)

  0097b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00983	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00989	c1 e8 0f	 shr	 eax, 15
  0098c	83 e0 01	 and	 eax, 1
  0098f	85 c0		 test	 eax, eax
  00991	74 48		 je	 SHORT $LN32@s370_perfo
  00993	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0099a	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  009a2	74 37		 je	 SHORT $LN32@s370_perfo

; 1521 :             tf_0804( regs, csw, ioid, SSID_TO_LCSS(ioid >> 16) & 0x07 );

  009a4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR ioid$[rsp]
  009ab	c1 e8 10	 shr	 eax, 16
  009ae	d1 e8		 shr	 eax, 1
  009b0	83 e0 07	 and	 eax, 7
  009b3	44 0f b6 c8	 movzx	 r9d, al
  009b7	44 0f b7 84 24
	a0 00 00 00	 movzx	 r8d, WORD PTR ioid$[rsp]
  009c0	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR csw$1[rsp]
  009c8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0804
  009d6	e9 f8 01 00 00	 jmp	 $LN33@s370_perfo
$LN32@s370_perfo:

; 1522 :         else
; 1523 :         {
; 1524 :             // "Processor %s%02X: I/O interrupt code %1.1X:%4.4X CSW %2.2X...
; 1525 :             WRMSG( HHC00804, "I", PTYPSTR( regs->cpuad ), regs->cpuad,

  009db	b8 01 00 00 00	 mov	 eax, 1
  009e0	48 6b c0 07	 imul	 rax, rax, 7
  009e4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR csw$1[rsp]
  009ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  009f0	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv436[rsp], eax
  009f7	b9 01 00 00 00	 mov	 ecx, 1
  009fc	48 6b c9 06	 imul	 rcx, rcx, 6
  00a00	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR csw$1[rsp]
  00a08	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00a0c	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv440[rsp], ecx
  00a13	ba 01 00 00 00	 mov	 edx, 1
  00a18	48 6b d2 05	 imul	 rdx, rdx, 5
  00a1c	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR csw$1[rsp]
  00a24	41 0f b6 14 10	 movzx	 edx, BYTE PTR [r8+rdx]
  00a29	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv444[rsp], edx
  00a30	41 b8 01 00 00
	00		 mov	 r8d, 1
  00a36	4d 6b c0 04	 imul	 r8, r8, 4
  00a3a	4c 8b 8c 24 a8
	00 00 00	 mov	 r9, QWORD PTR csw$1[rsp]
  00a42	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00a47	44 89 84 24 d4
	00 00 00	 mov	 DWORD PTR tv448[rsp], r8d
  00a4f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00a55	4d 6b c9 03	 imul	 r9, r9, 3
  00a59	4c 8b 94 24 a8
	00 00 00	 mov	 r10, QWORD PTR csw$1[rsp]
  00a61	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00a66	44 89 8c 24 d8
	00 00 00	 mov	 DWORD PTR tv452[rsp], r9d
  00a6e	41 ba 01 00 00
	00		 mov	 r10d, 1
  00a74	4d 6b d2 02	 imul	 r10, r10, 2
  00a78	4c 8b 9c 24 a8
	00 00 00	 mov	 r11, QWORD PTR csw$1[rsp]
  00a80	47 0f b6 14 13	 movzx	 r10d, BYTE PTR [r11+r10]
  00a85	44 89 94 24 dc
	00 00 00	 mov	 DWORD PTR tv456[rsp], r10d
  00a8d	41 bb 01 00 00
	00		 mov	 r11d, 1
  00a93	4d 6b db 01	 imul	 r11, r11, 1
  00a97	48 8b 9c 24 a8
	00 00 00	 mov	 rbx, QWORD PTR csw$1[rsp]
  00a9f	42 0f b6 1c 1b	 movzx	 ebx, BYTE PTR [rbx+r11]
  00aa4	41 bb 01 00 00
	00		 mov	 r11d, 1
  00aaa	4d 6b db 00	 imul	 r11, r11, 0
  00aae	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR csw$1[rsp]
  00ab6	42 0f b6 3c 1f	 movzx	 edi, BYTE PTR [rdi+r11]
  00abb	44 8b 9c 24 a0
	00 00 00	 mov	 r11d, DWORD PTR ioid$[rsp]
  00ac3	41 c1 eb 10	 shr	 r11d, 16
  00ac7	41 d1 eb	 shr	 r11d, 1
  00aca	41 83 e3 07	 and	 r11d, 7
  00ace	44 89 9c 24 e0
	00 00 00	 mov	 DWORD PTR tv469[rsp], r11d
  00ad6	48 8b b4 24 50
	01 00 00	 mov	 rsi, QWORD PTR regs$[rsp]
  00ade	0f b7 b6 3c 08
	00 00		 movzx	 esi, WORD PTR [rsi+2108]
  00ae5	48 8b ac 24 50
	01 00 00	 mov	 rbp, QWORD PTR regs$[rsp]
  00aed	0f b7 ad 3c 08
	00 00		 movzx	 ebp, WORD PTR [rbp+2108]
  00af4	4c 8b 35 00 00
	00 00		 mov	 r14, QWORD PTR __imp_sysblk
  00afb	41 0f b6 8c 2e
	48 0b 00 00	 movzx	 ecx, BYTE PTR [r14+rbp+2888]
  00b04	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00b0a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv474[rsp], rax
  00b12	b9 01 00 00 00	 mov	 ecx, 1
  00b17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00b1d	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv436[rsp]
  00b24	89 8c 24 90 00
	00 00		 mov	 DWORD PTR [rsp+144], ecx
  00b2b	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv440[rsp]
  00b32	89 8c 24 88 00
	00 00		 mov	 DWORD PTR [rsp+136], ecx
  00b39	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv444[rsp]
  00b40	89 8c 24 80 00
	00 00		 mov	 DWORD PTR [rsp+128], ecx
  00b47	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv448[rsp]
  00b4e	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  00b52	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv452[rsp]
  00b59	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  00b5d	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv456[rsp]
  00b64	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00b68	89 5c 24 60	 mov	 DWORD PTR [rsp+96], ebx
  00b6c	89 7c 24 58	 mov	 DWORD PTR [rsp+88], edi
  00b70	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR ioid$[rsp]
  00b77	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00b7b	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv469[rsp]
  00b82	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00b86	89 74 24 40	 mov	 DWORD PTR [rsp+64], esi
  00b8a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv474[rsp]
  00b92	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00b97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170552
  00b9e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ba3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170553
  00baa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00baf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bb4	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170554
  00bc1	ba f8 05 00 00	 mov	 edx, 1528		; 000005f8H
  00bc6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170555
  00bcd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN33@s370_perfo:
$LN11@s370_perfo:

; 1526 :                     SSID_TO_LCSS( ioid >> 16 ) & 0x07, ioid,
; 1527 :                     csw[0], csw[1], csw[2], csw[3],
; 1528 :                     csw[4], csw[5], csw[6], csw[7] );
; 1529 :         }
; 1530 :     }
; 1531 : #endif /*FEATURE_S370_CHANNEL*/
; 1532 : 
; 1533 : #ifdef FEATURE_CHANNEL_SUBSYSTEM
; 1534 :     /* Store X'0001' + subchannel number at PSA+X'B8' */
; 1535 :     STORE_FW(psa->ioid, ioid);
; 1536 : 
; 1537 :     /* Store the I/O interruption parameter at PSA+X'BC' */
; 1538 :     STORE_FW(psa->ioparm, ioparm);
; 1539 : 
; 1540 : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) || defined( _FEATURE_IO_ASSIST )
; 1541 :     /* Store the I/O interruption identification word at PSA+X'C0' */
; 1542 :     STORE_FW(psa->iointid, iointid);
; 1543 : #endif
; 1544 : 
; 1545 :     /* Trace the I/O interrupt */
; 1546 :     if (CPU_STEPPING_OR_TRACING( regs, 0 ) || dev->ccwtrace)
; 1547 :     {
; 1548 :         if (regs->insttrace && sysblk.traceFILE)
; 1549 :             tf_0806( regs, ioid, ioparm, iointid );
; 1550 :         else
; 1551 :         {
; 1552 : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) && !defined( _FEATURE_IO_ASSIST )
; 1553 :             // "Processor %s%02X: I/O interrupt code %8.8X parm %8.8X"
; 1554 :             WRMSG (HHC00805, "I", PTYPSTR(regs->cpuad), regs->cpuad, ioid, ioparm);
; 1555 : #else
; 1556 :             // "Processor %s%02X: I/O interrupt code %8.8X parm %8.8X id %8.8X"
; 1557 :             WRMSG (HHC00806, "I", PTYPSTR(regs->cpuad), regs->cpuad, ioid, ioparm, iointid);
; 1558 : #endif
; 1559 :         }
; 1560 :     }
; 1561 : #endif /* FEATURE_CHANNEL_SUBSYSTEM */
; 1562 : 
; 1563 : #if defined( _FEATURE_IO_ASSIST )
; 1564 :     if (icode == SIE_NO_INTERCEPT)

  00bd3	83 bc 24 a4 00
	00 00 ff	 cmp	 DWORD PTR icode$[rsp], -1
  00bdb	75 7a		 jne	 SHORT $LN34@s370_perfo

; 1565 : #endif
; 1566 :     {
; 1567 : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 1568 :         /* Abort any active transaction and then return back to here
; 1569 :            to continue with I/O interrupt processing */
; 1570 :         if (regs->txf_tnd)
; 1571 :         {
; 1572 :             PTT_TXF( "*TXF IO", 0, regs->txf_contran, regs->txf_tnd );
; 1573 :             regs->txf_why |= TXF_WHY_IO_INT;
; 1574 :             ABORT_TRANS( regs, ABORT_RETRY_RETURN, TAC_IO );
; 1575 :         }
; 1576 : #endif
; 1577 :         /* Store current PSW at PSA+X'38' or PSA+X'170' for ESAME */
; 1578 :         ARCH_DEP(store_psw) ( regs, psa->iopold );

  00bdd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  00be5	48 83 c0 38	 add	 rax, 56			; 00000038H
  00be9	48 8b d0	 mov	 rdx, rax
  00bec	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bf4	e8 00 00 00 00	 call	 s370_store_psw

; 1579 : 
; 1580 :         /* Load new PSW from PSA+X'78' or PSA+X'1F0' for ESAME */
; 1581 :         rc = ARCH_DEP(load_psw) ( regs, psa->iopnew );

  00bf9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR psa$[rsp]
  00c01	48 83 c0 78	 add	 rax, 120		; 00000078H
  00c05	48 8b d0	 mov	 rdx, rax
  00c08	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c10	e8 00 00 00 00	 call	 s370_load_psw
  00c15	89 84 24 bc 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1582 : 
; 1583 :         if ( rc )

  00c1c	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  00c24	74 31		 je	 SHORT $LN35@s370_perfo

; 1584 :         {
; 1585 :             RELEASE_INTLOCK(regs);

  00c26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170558
  00c2d	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c35	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1586 :             regs->program_interrupt (regs, rc);

  00c3a	8b 94 24 bc 00
	00 00		 mov	 edx, DWORD PTR rc$[rsp]
  00c41	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c49	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c51	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN35@s370_perfo:
$LN34@s370_perfo:

; 1587 :         }
; 1588 :     }
; 1589 : 
; 1590 :     RELEASE_INTLOCK(regs);

  00c57	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170559
  00c5e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c66	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 1591 : 
; 1592 :     longjmp(regs->progjmp, icode);

  00c6b	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c73	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  00c79	8b 94 24 a4 00
	00 00		 mov	 edx, DWORD PTR icode$[rsp]
  00c80	48 8b c8	 mov	 rcx, rax
  00c83	e8 00 00 00 00	 call	 longjmp
$LN1@s370_perfo:
$LN36@s370_perfo:

; 1593 : 
; 1594 : } /* end function perform_io_interrupt */

  00c88	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00c90	48 33 cc	 xor	 rcx, rsp
  00c93	e8 00 00 00 00	 call	 __security_check_cookie
  00c98	48 81 c4 20 01
	00 00		 add	 rsp, 288		; 00000120H
  00c9f	41 5e		 pop	 r14
  00ca1	5f		 pop	 rdi
  00ca2	5e		 pop	 rsi
  00ca3	5d		 pop	 rbp
  00ca4	5b		 pop	 rbx
  00ca5	c3		 ret	 0
s370_perform_io_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
i$ = 48
tv229 = 52
tv310 = 56
p$1 = 64
blknam$2 = 72
__$ArrayPad$ = 88
cpu$ = 112
regs$ = 120
hostregs$ = 128
cpu_init PROC

; 2395 : {

$LN27:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	57		 push	 rdi
  0000f	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2396 : int i;
; 2397 : 
; 2398 :     obtain_lock (&sysblk.cpulock[cpu]);

  00022	48 63 44 24 70	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00027	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002e	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00036	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196963
  0003d	48 8b c8	 mov	 rcx, rax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2399 : 
; 2400 :     /* initialize eye-catchers */
; 2401 :     {
; 2402 :         char    blknam[ sizeof( regs->blknam )];
; 2403 :         MSGBUF( blknam, "%-4.4s_%s%02X", HDL_NAME_REGS, PTYPSTR( cpu ), cpu );

  00046	48 63 44 24 70	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0004b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00052	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00060	8b 4c 24 70	 mov	 ecx, DWORD PTR cpu$[rsp]
  00064	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196964
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196965
  0007b	ba 10 00 00 00	 mov	 edx, 16
  00080	48 8d 4c 24 48	 lea	 rcx, QWORD PTR blknam$2[rsp]
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN4@cpu_init:
$LN7@cpu_init:

; 2404 :         INIT_BLOCK_HEADER_TRAILER_WITH_CUSTOM_NAME( regs, REGS, blknam );

  0008b	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 05 60 60 01
	00		 add	 rax, 90208		; 00016060H
  00096	48 8b f8	 mov	 rdi, rax
  00099	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0009e	b9 10 00 00 00	 mov	 ecx, 16
  000a3	f3 aa		 rep stosb
  000a5	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000aa	48 8b 7c 24 78	 mov	 rdi, QWORD PTR regs$[rsp]
  000af	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000b4	b9 10 00 00 00	 mov	 ecx, 16
  000b9	f3 aa		 rep stosb
  000bb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000c0	48 05 60 60 01
	00		 add	 rax, 90208		; 00016060H
  000c6	41 b8 10 00 00
	00		 mov	 r8d, 16
  000cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196966
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000dc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  000e1	48 05 60 60 01
	00		 add	 rax, 90208		; 00016060H
  000e7	41 b8 10 00 00
	00		 mov	 r8d, 16
  000ed	48 8d 54 24 48	 lea	 rdx, QWORD PTR blknam$2[rsp]
  000f2	48 8b c8	 mov	 rcx, rax
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
  000fb	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00100	41 b8 10 00 00
	00		 mov	 r8d, 16
  00106	48 8d 54 24 48	 lea	 rdx, QWORD PTR blknam$2[rsp]
  0010b	48 8b c8	 mov	 rcx, rax
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00114	33 c0		 xor	 eax, eax
  00116	85 c0		 test	 eax, eax
  00118	0f 85 6d ff ff
	ff		 jne	 $LN7@cpu_init
  0011e	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00123	48 83 c0 10	 add	 rax, 16
  00127	48 8b f8	 mov	 rdi, rax
  0012a	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0012f	b9 10 00 00 00	 mov	 ecx, 16
  00134	f3 aa		 rep stosb
  00136	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 83 c0 10	 add	 rax, 16
  0013f	41 b8 10 00 00
	00		 mov	 r8d, 16
  00145	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196967
  0014c	48 8b c8	 mov	 rcx, rax
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00155	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	e8 00 00 00 00	 call	 _byteswap_uint64
  0015f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00164	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00168	b9 80 60 01 00	 mov	 ecx, 90240		; 00016080H
  0016d	e8 00 00 00 00	 call	 _byteswap_ulong
  00172	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	89 41 28	 mov	 DWORD PTR [rcx+40], eax
  0017a	33 c0		 xor	 eax, eax
  0017c	85 c0		 test	 eax, eax
  0017e	0f 85 07 ff ff
	ff		 jne	 $LN4@cpu_init

; 2405 :     }
; 2406 : 
; 2407 :     regs->cpuad = cpu;

  00184	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00189	0f b7 4c 24 70	 movzx	 ecx, WORD PTR cpu$[rsp]
  0018e	66 89 88 3c 08
	00 00		 mov	 WORD PTR [rax+2108], cx

; 2408 :     regs->cpubit = CPU_BIT(cpu);

  00195	8b 44 24 70	 mov	 eax, DWORD PTR cpu$[rsp]
  00199	b9 01 00 00 00	 mov	 ecx, 1
  0019e	48 89 4c 24 38	 mov	 QWORD PTR tv310[rsp], rcx
  001a3	0f b6 c8	 movzx	 ecx, al
  001a6	48 8b 44 24 38	 mov	 rax, QWORD PTR tv310[rsp]
  001ab	48 d3 e0	 shl	 rax, cl
  001ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 89 41 50	 mov	 QWORD PTR [rcx+80], rax

; 2409 : 
; 2410 :     /* Save CPU creation time without epoch set, as epoch may change. When using
; 2411 :      * the field, subtract the current epoch from any time being used in
; 2412 :      * relation to the creation time to yield the correct result.
; 2413 :      */
; 2414 :     if (sysblk.cpucreateTOD[cpu] == 0)

  001b7	48 63 44 24 70	 movsxd	 rax, DWORD PTR cpu$[rsp]
  001bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001c3	48 83 bc c1 48
	07 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+1864], 0
  001cc	75 19		 jne	 SHORT $LN19@cpu_init

; 2415 :         sysblk.cpucreateTOD[cpu] = host_tod(); /* tod_epoch is zero at this point */

  001ce	e8 00 00 00 00	 call	 host_tod
  001d3	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR cpu$[rsp]
  001d8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001df	48 89 84 ca 48
	07 00 00	 mov	 QWORD PTR [rdx+rcx*8+1864], rax
$LN19@cpu_init:

; 2416 : 
; 2417 :     regs->arch_mode = sysblk.arch_mode;

  001e7	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f3	8b 89 88 00 00
	00		 mov	 ecx, DWORD PTR [rcx+136]
  001f9	89 48 64	 mov	 DWORD PTR [rax+100], ecx

; 2418 :     regs->mainstor  = sysblk.mainstor;

  001fc	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00201	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00208	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  0020f	48 89 88 48 08
	00 00		 mov	 QWORD PTR [rax+2120], rcx

; 2419 :     regs->sysblk    = &sysblk;

  00216	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0021b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00222	48 89 48 40	 mov	 QWORD PTR [rax+64], rcx

; 2420 :     regs->storkeys  = sysblk.storkeys;

  00226	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0022b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00232	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00239	48 89 88 50 08
	00 00		 mov	 QWORD PTR [rax+2128], rcx

; 2421 :     regs->mainlim   = sysblk.mainsize - 1;

  00240	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00247	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0024e	48 ff c8	 dec	 rax
  00251	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00256	48 89 81 58 08
	00 00		 mov	 QWORD PTR [rcx+2136], rax

; 2422 :     regs->tod_epoch = get_tod_epoch();

  0025d	e8 00 00 00 00	 call	 get_tod_epoch
  00262	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00267	48 89 81 40 07
	00 00		 mov	 QWORD PTR [rcx+1856], rax

; 2423 : 
; 2424 :     /* Set initial CPU ID by REGS context.  Note that this
; 2425 :        must only be done AFTER regs->arch_mode has been set.
; 2426 :     */
; 2427 :     setCpuIdregs( regs, -1, -1, -1, -1, true );

  0026e	c6 44 24 28 01	 mov	 BYTE PTR [rsp+40], 1
  00273	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  0027b	41 b9 ff ff ff
	ff		 mov	 r9d, -1
  00281	66 41 b8 ff ff	 mov	 r8w, -1
  00286	ba ff ff ff ff	 mov	 edx, -1
  0028b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00290	e8 00 00 00 00	 call	 setCpuIdregs

; 2428 : 
; 2429 :     initialize_condition (&regs->intcond);

  00295	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	48 05 80 0c 00
	00		 add	 rax, 3200		; 00000c80H
  002a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196969
  002a7	48 8b c8	 mov	 rcx, rax
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 2430 :     regs->cpulock = &sysblk.cpulock[cpu];

  002b0	48 63 44 24 70	 movsxd	 rax, DWORD PTR cpu$[rsp]
  002b5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002bc	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  002c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	48 89 81 88 0c
	00 00		 mov	 QWORD PTR [rcx+3208], rax

; 2431 : 
; 2432 : #if defined( _FEATURE_S370_S390_VECTOR_FACILITY )
; 2433 :     regs->vf = &sysblk.vf[cpu];
; 2434 :     regs->vf->online = (cpu < sysblk.numvec);
; 2435 : #endif
; 2436 :     initial_cpu_reset(regs);

  002d0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  002d5	e8 00 00 00 00	 call	 initial_cpu_reset

; 2437 : 
; 2438 :     /*****************************************************************/
; 2439 :     /*       Refer to the PROGRAMMING NOTE in hstructs.h             */
; 2440 :     /*****************************************************************/
; 2441 :     /*                                                               */
; 2442 :     /* If 'hostregs' passed as NULL, then 'regs' points to host regs.*/
; 2443 :     /* Otherwise, 'regs' points to guest regs and 'hostregs' points  */
; 2444 :     /* to host regs.                                                 */
; 2445 :     /*                                                               */
; 2446 :     /* The flag 'guest' is only 1 in guest regs and 'host' is only 1 */
; 2447 :     /* in host regs. 'hostregs' always points to host regs in both,  */
; 2448 :     /* and 'guestregs' always points to guest regs in both.          */
; 2449 :     /*                                                               */
; 2450 :     /* HOWEVER, guest regs only exists when SIE is active/running.   */
; 2451 :     /* If SIE is NOT active/running, then 'guestregs' is NULL.       */
; 2452 :     /*                                                               */
; 2453 :     /* 'sie_active' is only 1 in host regs,  never in guest regs.    */
; 2454 :     /* 'sie_mode'   is only 1 in guest regs, never in host regs.     */
; 2455 :     /*                                                               */
; 2456 :     /*****************************************************************/
; 2457 :     /*       Refer to the PROGRAMMING NOTE in hstructs.h             */
; 2458 :     /*****************************************************************/
; 2459 : 
; 2460 :     if (!hostregs)

  002da	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR hostregs$[rsp], 0
  002e3	0f 85 bc 00 00
	00		 jne	 $LN20@cpu_init

; 2461 :     {
; 2462 :         /* regs points to host regs */
; 2463 :         regs->cpustate = CPUSTATE_STOPPING;

  002e9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002ee	c6 40 60 02	 mov	 BYTE PTR [rax+96], 2
$LN10@cpu_init:

; 2464 :         ON_IC_INTERRUPT(regs);

  002f2	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  002f7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  002fa	0f ba e8 1f	 bts	 eax, 31
  002fe	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00303	89 41 48	 mov	 DWORD PTR [rcx+72], eax
  00306	33 c0		 xor	 eax, eax
  00308	85 c0		 test	 eax, eax
  0030a	75 e6		 jne	 SHORT $LN10@cpu_init

; 2465 :         HOSTREGS = regs;

  0030c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00311	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00316	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 2466 :         regs->host = 1;

  0031d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00322	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00328	0f ba e8 07	 bts	 eax, 7
  0032c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2467 :         sysblk.regs[cpu] = regs;

  00337	48 63 44 24 70	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0033c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00343	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00348	48 89 94 c1 98
	0b 00 00	 mov	 QWORD PTR [rcx+rax*8+2968], rdx

; 2468 :         sysblk.config_mask |= regs->cpubit;

  00350	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00357	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0035c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00360	48 8b 80 a8 12
	00 00		 mov	 rax, QWORD PTR [rax+4776]
  00367	48 0b c1	 or	 rax, rcx
  0036a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00371	48 89 81 a8 12
	00 00		 mov	 QWORD PTR [rcx+4776], rax

; 2469 :         sysblk.started_mask |= regs->cpubit;

  00378	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0037f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00388	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  0038f	48 0b c1	 or	 rax, rcx
  00392	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00399	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2470 :     }

  003a0	e9 8e 00 00 00	 jmp	 $LN21@cpu_init
$LN20@cpu_init:

; 2471 :     else // SIE mode
; 2472 :     {
; 2473 :         /* regs     points to guest regs.
; 2474 :            hostregs points to host  regs.
; 2475 :         */
; 2476 :         GUEST(hostregs) = regs;

  003a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR hostregs$[rsp]
  003ad	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003b2	48 89 88 70 08
	00 00		 mov	 QWORD PTR [rax+2160], rcx

; 2477 :         HOSTREGS = hostregs;

  003b9	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hostregs$[rsp]
  003c6	48 89 88 68 08
	00 00		 mov	 QWORD PTR [rax+2152], rcx

; 2478 :         GUESTREGS = regs;

  003cd	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003d2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003d7	48 89 88 70 08
	00 00		 mov	 QWORD PTR [rax+2160], rcx

; 2479 :         regs->guest = 1;

  003de	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003e3	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  003e9	0f ba e8 08	 bts	 eax, 8
  003ed	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  003f2	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2480 :         regs->sie_mode = 1;

  003f8	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00403	83 c8 02	 or	 eax, 2
  00406	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0040b	89 81 c8 08 00
	00		 mov	 DWORD PTR [rcx+2248], eax

; 2481 :         regs->opinterv = 0;

  00411	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00416	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0041c	83 e0 ef	 and	 eax, -17		; ffffffefH
  0041f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00424	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2482 :         regs->cpustate = CPUSTATE_STARTED;

  0042a	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  0042f	c6 40 60 01	 mov	 BYTE PTR [rax+96], 1
$LN21@cpu_init:

; 2483 :     }
; 2484 : 
; 2485 :     /* Initialize accelerated lookup fields */
; 2486 :     switch (regs->arch_mode)

  00433	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00438	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  0043b	89 44 24 34	 mov	 DWORD PTR tv229[rsp], eax
  0043f	83 7c 24 34 00	 cmp	 DWORD PTR tv229[rsp], 0
  00444	74 10		 je	 SHORT $LN22@cpu_init
  00446	83 7c 24 34 01	 cmp	 DWORD PTR tv229[rsp], 1
  0044b	74 26		 je	 SHORT $LN23@cpu_init
  0044d	83 7c 24 34 02	 cmp	 DWORD PTR tv229[rsp], 2
  00452	74 3c		 je	 SHORT $LN24@cpu_init
  00454	eb 56		 jmp	 SHORT $LN25@cpu_init
$LN22@cpu_init:

; 2487 :     {
; 2488 : #if defined(_370)
; 2489 :         case ARCH_370_IDX:
; 2490 :             regs->CR_G( CR_ASD_REAL ) = TLB_REAL_ASD_L;

  00456	b8 08 00 00 00	 mov	 eax, 8
  0045b	48 6b c0 00	 imul	 rax, rax, 0
  0045f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00464	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00469	48 89 94 01 00
	06 00 00	 mov	 QWORD PTR [rcx+rax+1536], rdx

; 2491 :             break;

  00471	eb 50		 jmp	 SHORT $LN11@cpu_init
$LN23@cpu_init:

; 2492 : #endif
; 2493 : #if defined(_390)
; 2494 :         case ARCH_390_IDX:
; 2495 :             regs->CR_G( CR_ASD_REAL ) = TLB_REAL_ASD_L;

  00473	b8 08 00 00 00	 mov	 eax, 8
  00478	48 6b c0 00	 imul	 rax, rax, 0
  0047c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00481	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00486	48 89 94 01 00
	06 00 00	 mov	 QWORD PTR [rcx+rax+1536], rdx

; 2496 :             break;

  0048e	eb 33		 jmp	 SHORT $LN11@cpu_init
$LN24@cpu_init:

; 2497 : #endif
; 2498 : #if defined(_900)
; 2499 :         case ARCH_900_IDX:
; 2500 :             regs->CR_G( CR_ASD_REAL ) = TLB_REAL_ASD_G;

  00490	b8 08 00 00 00	 mov	 eax, 8
  00495	48 6b c0 00	 imul	 rax, rax, 0
  00499	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0049e	48 c7 84 01 00
	06 00 00 ff ff
	ff ff		 mov	 QWORD PTR [rcx+rax+1536], -1

; 2501 :             break;

  004aa	eb 17		 jmp	 SHORT $LN11@cpu_init
$LN25@cpu_init:
$LN15@cpu_init:

; 2502 : #endif
; 2503 :         default: CRASH();

  004ac	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  004b5	48 8b 44 24 40	 mov	 rax, QWORD PTR p$1[rsp]
  004ba	c6 00 00	 mov	 BYTE PTR [rax], 0
  004bd	33 c0		 xor	 eax, eax
  004bf	85 c0		 test	 eax, eax
  004c1	75 e9		 jne	 SHORT $LN15@cpu_init
$LN11@cpu_init:

; 2504 :     }
; 2505 : 
; 2506 :     for (i=0; i < 16; i++)

  004c3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004cb	eb 0a		 jmp	 SHORT $LN18@cpu_init
$LN16@cpu_init:
  004cd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004d1	ff c0		 inc	 eax
  004d3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN18@cpu_init:
  004d7	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  004dc	7d 1b		 jge	 SHORT $LN17@cpu_init

; 2507 :         regs->AEA_AR( i )               = CR_ASD_REAL;

  004de	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004e2	83 c0 05	 add	 eax, 5
  004e5	48 98		 cdqe
  004e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  004ec	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  004f7	eb d4		 jmp	 SHORT $LN16@cpu_init
$LN17@cpu_init:

; 2508 :     regs->AEA_AR( USE_INST_SPACE      ) = CR_ASD_REAL;

  004f9	b8 04 00 00 00	 mov	 eax, 4
  004fe	48 6b c0 04	 imul	 rax, rax, 4
  00502	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00507	c7 84 01 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax+3220], -1

; 2509 :     regs->AEA_AR( USE_REAL_ADDR       ) = CR_ASD_REAL;

  00512	b8 04 00 00 00	 mov	 eax, 4
  00517	48 6b c0 03	 imul	 rax, rax, 3
  0051b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00520	c7 84 01 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax+3220], -1

; 2510 :     regs->AEA_AR( USE_PRIMARY_SPACE   ) = 1;

  0052b	b8 04 00 00 00	 mov	 eax, 4
  00530	48 6b c0 02	 imul	 rax, rax, 2
  00534	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00539	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1

; 2511 :     regs->AEA_AR( USE_SECONDARY_SPACE ) = 7;

  00544	b8 04 00 00 00	 mov	 eax, 4
  00549	48 6b c0 01	 imul	 rax, rax, 1
  0054d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00552	c7 84 01 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 7

; 2512 :     regs->AEA_AR( USE_HOME_SPACE      ) = 13;

  0055d	b8 04 00 00 00	 mov	 eax, 4
  00562	48 6b c0 00	 imul	 rax, rax, 0
  00566	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0056b	c7 84 01 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 13

; 2513 : 
; 2514 :     /* Initialize opcode table pointers */
; 2515 :     init_regs_runtime_opcode_pointers( regs );

  00576	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0057b	e8 00 00 00 00	 call	 init_regs_runtime_opcode_pointers

; 2516 : 
; 2517 :     regs->configured = 1;

  00580	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00585	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0058b	0f ba e8 0b	 bts	 eax, 11
  0058f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00594	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2518 : 
; 2519 :     release_lock (&sysblk.cpulock[cpu]);

  0059a	48 63 44 24 70	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0059f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  005a6	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  005ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196976
  005b5	48 8b c8	 mov	 rcx, rax
  005b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2520 : 
; 2521 :     return 0;

  005be	33 c0		 xor	 eax, eax

; 2522 : }

  005c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c5	48 33 cc	 xor	 rcx, rsp
  005c8	e8 00 00 00 00	 call	 __security_check_cookie
  005cd	48 83 c4 60	 add	 rsp, 96			; 00000060H
  005d1	5f		 pop	 rdi
  005d2	c3		 ret	 0
cpu_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
shouldtrace$ = 32
tv209 = 36
tv211 = 40
tv322 = 44
hostregs$1 = 48
saved_timer$2 = 56
regs$ = 96
dest$ = 104
z900_process_trace PROC

; 2172 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2173 :     bool shouldtrace = false;           /* true == Trace instruction */

  0000f	c6 44 24 20 00	 mov	 BYTE PTR shouldtrace$[rsp], 0

; 2174 : 
; 2175 :     /* Test for trace */
; 2176 :     shouldtrace = CPU_TRACING( regs, 0 );

  00014	33 c0		 xor	 eax, eax
  00016	83 f8 01	 cmp	 eax, 1
  00019	0f 84 49 03 00
	00		 je	 $LN11@z900_proce
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00026	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002c	c1 e8 08	 shr	 eax, 8
  0002f	83 e0 01	 and	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	0f 84 2e 03 00
	00		 je	 $LN11@z900_proce
  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00045	c1 e8 0f	 shr	 eax, 15
  00048	83 e0 01	 and	 eax, 1
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 15 03 00
	00		 je	 $LN11@z900_proce
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	0f 85 17 01 00
	00		 jne	 $LN12@z900_proce
  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00064	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0006a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 fd 00 00
	00		 je	 $LN12@z900_proce
  00077	33 c0		 xor	 eax, eax
  00079	83 f8 01	 cmp	 eax, 1
  0007c	0f 84 e6 02 00
	00		 je	 $LN14@z900_proce
  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 34		 jne	 SHORT $LN13@z900_proce
  00088	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00095	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009a	85 c0		 test	 eax, eax
  0009c	74 1e		 je	 SHORT $LN13@z900_proce
  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000aa	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  000b0	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  000b6	0f 85 ac 02 00
	00		 jne	 $LN14@z900_proce
$LN13@z900_proce:
  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 34		 jne	 SHORT $LN15@z900_proce
  000c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  000cf	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000d4	85 c0		 test	 eax, eax
  000d6	74 1e		 je	 SHORT $LN15@z900_proce
  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e4	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  000ea	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  000f0	0f 8c 72 02 00
	00		 jl	 $LN14@z900_proce
$LN15@z900_proce:
  000f6	33 c0		 xor	 eax, eax
  000f8	85 c0		 test	 eax, eax
  000fa	75 78		 jne	 SHORT $LN17@z900_proce
  000fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00103	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00109	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0010e	85 c0		 test	 eax, eax
  00110	74 20		 je	 SHORT $LN16@z900_proce
  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00117	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN16@z900_proce
  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00127	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0012e	85 c0		 test	 eax, eax
  00130	75 42		 jne	 SHORT $LN17@z900_proce
$LN16@z900_proce:
  00132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00139	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0013f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00144	85 c0		 test	 eax, eax
  00146	0f 84 1c 02 00
	00		 je	 $LN18@z900_proce
  0014c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00151	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00158	85 c0		 test	 eax, eax
  0015a	0f 84 08 02 00
	00		 je	 $LN18@z900_proce
  00160	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00165	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0016c	85 c0		 test	 eax, eax
  0016e	0f 85 f4 01 00
	00		 jne	 $LN11@z900_proce
$LN12@z900_proce:
$LN17@z900_proce:
  00174	b8 08 00 00 00	 mov	 eax, 8
  00179	48 6b c0 00	 imul	 rax, rax, 0
  0017d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00184	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0018d	75 1f		 jne	 SHORT $LN19@z900_proce
  0018f	b8 08 00 00 00	 mov	 eax, 8
  00194	48 6b c0 01	 imul	 rax, rax, 1
  00198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0019f	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  001a8	0f 84 b0 01 00
	00		 je	 $LN21@z900_proce
$LN19@z900_proce:
  001ae	b8 08 00 00 00	 mov	 eax, 8
  001b3	48 6b c0 00	 imul	 rax, rax, 0
  001b7	b9 08 00 00 00	 mov	 ecx, 8
  001bc	48 6b c9 01	 imul	 rcx, rcx, 1
  001c0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001c7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  001ce	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  001d6	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  001de	0f 87 a4 00 00
	00		 ja	 $LN20@z900_proce
  001e4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001e9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001ee	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  001f5	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001f9	48 2b c1	 sub	 rax, rcx
  001fc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00208	48 03 c8	 add	 rcx, rax
  0020b	48 8b c1	 mov	 rax, rcx
  0020e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0021a	b9 08 00 00 00	 mov	 ecx, 8
  0021f	48 6b c9 00	 imul	 rcx, rcx, 0
  00223	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0022a	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00232	72 54		 jb	 SHORT $LN20@z900_proce
  00234	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00239	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00245	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00249	48 2b c1	 sub	 rax, rcx
  0024c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00258	48 03 c8	 add	 rcx, rax
  0025b	48 8b c1	 mov	 rax, rcx
  0025e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00263	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0026a	b9 08 00 00 00	 mov	 ecx, 8
  0026f	48 6b c9 01	 imul	 rcx, rcx, 1
  00273	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0027a	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00282	0f 86 d6 00 00
	00		 jbe	 $LN21@z900_proce
$LN20@z900_proce:
  00288	b8 08 00 00 00	 mov	 eax, 8
  0028d	48 6b c0 00	 imul	 rax, rax, 0
  00291	b9 08 00 00 00	 mov	 ecx, 8
  00296	48 6b c9 01	 imul	 rcx, rcx, 1
  0029a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002a1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  002a8	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  002b0	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  002b8	0f 86 aa 00 00
	00		 jbe	 $LN22@z900_proce
  002be	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  002c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  002cf	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002d3	48 2b c1	 sub	 rax, rcx
  002d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  002e2	48 03 c8	 add	 rcx, rax
  002e5	48 8b c1	 mov	 rax, rcx
  002e8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002ed	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002f4	b9 08 00 00 00	 mov	 ecx, 8
  002f9	48 6b c9 01	 imul	 rcx, rcx, 1
  002fd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00304	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0030c	72 5a		 jb	 SHORT $LN22@z900_proce
  0030e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00313	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00318	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0031f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00323	48 2b c1	 sub	 rax, rcx
  00326	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0032b	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00332	48 03 c8	 add	 rcx, rax
  00335	48 8b c1	 mov	 rax, rcx
  00338	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0033d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00344	b9 08 00 00 00	 mov	 ecx, 8
  00349	48 6b c9 00	 imul	 rcx, rcx, 0
  0034d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00354	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0035c	77 0a		 ja	 SHORT $LN11@z900_proce
$LN21@z900_proce:
  0035e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv209[rsp], 1
  00366	eb 08		 jmp	 SHORT $LN23@z900_proce
$LN11@z900_proce:
$LN22@z900_proce:
$LN14@z900_proce:
$LN18@z900_proce:
  00368	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
$LN23@z900_proce:
  00370	83 7c 24 24 00	 cmp	 DWORD PTR tv209[rsp], 0
  00375	75 0a		 jne	 SHORT $LN24@z900_proce
  00377	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv211[rsp], 0
  0037f	eb 08		 jmp	 SHORT $LN25@z900_proce
$LN24@z900_proce:
  00381	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv211[rsp], 1
$LN25@z900_proce:
  00389	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv211[rsp]
  0038e	88 44 24 20	 mov	 BYTE PTR shouldtrace$[rsp], al

; 2177 : 
; 2178 :     /* Test for step */
; 2179 :     regs->stepping = CPU_STEPPING( regs, 0 );

  00392	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00399	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0039f	c1 e8 0a	 shr	 eax, 10
  003a2	83 e0 01	 and	 eax, 1
  003a5	85 c0		 test	 eax, eax
  003a7	0f 84 15 03 00
	00		 je	 $LN33@z900_proce
  003ad	33 c0		 xor	 eax, eax
  003af	85 c0		 test	 eax, eax
  003b1	0f 85 17 01 00
	00		 jne	 $LN26@z900_proce
  003b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003be	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  003c4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003c9	85 c0		 test	 eax, eax
  003cb	0f 84 fd 00 00
	00		 je	 $LN26@z900_proce
  003d1	33 c0		 xor	 eax, eax
  003d3	83 f8 01	 cmp	 eax, 1
  003d6	0f 84 e6 02 00
	00		 je	 $LN28@z900_proce
  003dc	33 c0		 xor	 eax, eax
  003de	85 c0		 test	 eax, eax
  003e0	75 34		 jne	 SHORT $LN27@z900_proce
  003e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003e9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  003ef	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  003f4	85 c0		 test	 eax, eax
  003f6	74 1e		 je	 SHORT $LN27@z900_proce
  003f8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00404	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0040a	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00410	0f 85 ac 02 00
	00		 jne	 $LN28@z900_proce
$LN27@z900_proce:
  00416	33 c0		 xor	 eax, eax
  00418	85 c0		 test	 eax, eax
  0041a	75 34		 jne	 SHORT $LN29@z900_proce
  0041c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00423	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00429	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0042e	85 c0		 test	 eax, eax
  00430	74 1e		 je	 SHORT $LN29@z900_proce
  00432	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00437	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0043e	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00444	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0044a	0f 8c 72 02 00
	00		 jl	 $LN28@z900_proce
$LN29@z900_proce:
  00450	33 c0		 xor	 eax, eax
  00452	85 c0		 test	 eax, eax
  00454	75 78		 jne	 SHORT $LN31@z900_proce
  00456	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0045d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00463	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00468	85 c0		 test	 eax, eax
  0046a	74 20		 je	 SHORT $LN30@z900_proce
  0046c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00471	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00478	85 c0		 test	 eax, eax
  0047a	74 10		 je	 SHORT $LN30@z900_proce
  0047c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00481	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00488	85 c0		 test	 eax, eax
  0048a	75 42		 jne	 SHORT $LN31@z900_proce
$LN30@z900_proce:
  0048c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00493	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00499	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0049e	85 c0		 test	 eax, eax
  004a0	0f 84 1c 02 00
	00		 je	 $LN32@z900_proce
  004a6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  004ab	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  004b2	85 c0		 test	 eax, eax
  004b4	0f 84 08 02 00
	00		 je	 $LN32@z900_proce
  004ba	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  004bf	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  004c6	85 c0		 test	 eax, eax
  004c8	0f 85 f4 01 00
	00		 jne	 $LN33@z900_proce
$LN26@z900_proce:
$LN31@z900_proce:
  004ce	b8 08 00 00 00	 mov	 eax, 8
  004d3	48 6b c0 00	 imul	 rax, rax, 0
  004d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004de	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  004e7	75 1f		 jne	 SHORT $LN34@z900_proce
  004e9	b8 08 00 00 00	 mov	 eax, 8
  004ee	48 6b c0 01	 imul	 rax, rax, 1
  004f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004f9	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00502	0f 84 b0 01 00
	00		 je	 $LN36@z900_proce
$LN34@z900_proce:
  00508	b8 08 00 00 00	 mov	 eax, 8
  0050d	48 6b c0 00	 imul	 rax, rax, 0
  00511	b9 08 00 00 00	 mov	 ecx, 8
  00516	48 6b c9 01	 imul	 rcx, rcx, 1
  0051a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00521	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00528	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  00530	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00538	0f 87 a4 00 00
	00		 ja	 $LN35@z900_proce
  0053e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00543	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00548	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0054f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00553	48 2b c1	 sub	 rax, rcx
  00556	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0055b	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00562	48 03 c8	 add	 rcx, rax
  00565	48 8b c1	 mov	 rax, rcx
  00568	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0056d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00574	b9 08 00 00 00	 mov	 ecx, 8
  00579	48 6b c9 00	 imul	 rcx, rcx, 0
  0057d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00584	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0058c	72 54		 jb	 SHORT $LN35@z900_proce
  0058e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00593	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00598	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0059f	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  005a3	48 2b c1	 sub	 rax, rcx
  005a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  005ab	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  005b2	48 03 c8	 add	 rcx, rax
  005b5	48 8b c1	 mov	 rax, rcx
  005b8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  005bd	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  005c4	b9 08 00 00 00	 mov	 ecx, 8
  005c9	48 6b c9 01	 imul	 rcx, rcx, 1
  005cd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005d4	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  005dc	0f 86 d6 00 00
	00		 jbe	 $LN36@z900_proce
$LN35@z900_proce:
  005e2	b8 08 00 00 00	 mov	 eax, 8
  005e7	48 6b c0 00	 imul	 rax, rax, 0
  005eb	b9 08 00 00 00	 mov	 ecx, 8
  005f0	48 6b c9 01	 imul	 rcx, rcx, 1
  005f4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005fb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00602	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  0060a	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00612	0f 86 aa 00 00
	00		 jbe	 $LN37@z900_proce
  00618	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0061d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00622	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00629	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0062d	48 2b c1	 sub	 rax, rcx
  00630	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00635	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0063c	48 03 c8	 add	 rcx, rax
  0063f	48 8b c1	 mov	 rax, rcx
  00642	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00647	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0064e	b9 08 00 00 00	 mov	 ecx, 8
  00653	48 6b c9 01	 imul	 rcx, rcx, 1
  00657	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0065e	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00666	72 5a		 jb	 SHORT $LN37@z900_proce
  00668	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0066d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00672	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00679	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0067d	48 2b c1	 sub	 rax, rcx
  00680	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00685	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  0068c	48 03 c8	 add	 rcx, rax
  0068f	48 8b c1	 mov	 rax, rcx
  00692	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00697	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0069e	b9 08 00 00 00	 mov	 ecx, 8
  006a3	48 6b c9 00	 imul	 rcx, rcx, 0
  006a7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006ae	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  006b6	77 0a		 ja	 SHORT $LN33@z900_proce
$LN36@z900_proce:
  006b8	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv322[rsp], 1
  006c0	eb 08		 jmp	 SHORT $LN38@z900_proce
$LN33@z900_proce:
$LN37@z900_proce:
$LN28@z900_proce:
$LN32@z900_proce:
  006c2	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv322[rsp], 0
$LN38@z900_proce:
  006ca	8b 44 24 2c	 mov	 eax, DWORD PTR tv322[rsp]
  006ce	83 e0 01	 and	 eax, 1
  006d1	c1 e0 11	 shl	 eax, 17
  006d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006d9	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  006df	0f ba f1 11	 btr	 ecx, 17
  006e3	0b c8		 or	 ecx, eax
  006e5	8b c1		 mov	 eax, ecx
  006e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006ec	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2180 : 
; 2181 :     if (regs->stepping)

  006f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006f7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006fd	c1 e8 11	 shr	 eax, 17
  00700	83 e0 01	 and	 eax, 1
  00703	85 c0		 test	 eax, eax
  00705	74 54		 je	 SHORT $LN4@z900_proce

; 2182 :     {
; 2183 :         if (sysblk.breakasid)

  00707	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070e	0f b7 80 c0 12
	00 00		 movzx	 eax, WORD PTR [rax+4800]
  00715	85 c0		 test	 eax, eax
  00717	74 42		 je	 SHORT $LN5@z900_proce

; 2184 :         {
; 2185 :             if (regs->CR_LHL(4) != sysblk.breakasid)

  00719	b8 08 00 00 00	 mov	 eax, 8
  0071e	48 6b c0 05	 imul	 rax, rax, 5
  00722	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00727	0f b7 84 01 00
	06 00 00	 movzx	 eax, WORD PTR [rcx+rax+1536]
  0072f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00736	0f b7 89 c0 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4800]
  0073d	3b c1		 cmp	 eax, ecx
  0073f	74 1a		 je	 SHORT $LN6@z900_proce

; 2186 :                 regs->stepping = false;

  00741	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00746	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0074c	0f ba f0 11	 btr	 eax, 17
  00750	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00755	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN6@z900_proce:
$LN5@z900_proce:
$LN4@z900_proce:

; 2187 :         }
; 2188 :     }
; 2189 : 
; 2190 :     /* Display the instruction */
; 2191 :     if (shouldtrace || regs->stepping)

  0075b	0f b6 44 24 20	 movzx	 eax, BYTE PTR shouldtrace$[rsp]
  00760	85 c0		 test	 eax, eax
  00762	75 15		 jne	 SHORT $LN8@z900_proce
  00764	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00769	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0076f	c1 e8 11	 shr	 eax, 17
  00772	83 e0 01	 and	 eax, 1
  00775	85 c0		 test	 eax, eax
  00777	74 0f		 je	 SHORT $LN7@z900_proce
$LN8@z900_proce:

; 2192 :         ARCH_DEP( display_inst )( regs, dest );

  00779	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest$[rsp]
  0077e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00783	e8 00 00 00 00	 call	 z900_display_inst
$LN7@z900_proce:

; 2193 : 
; 2194 :     /* Stop the CPU if instruction stepping */
; 2195 :     if (regs->stepping)

  00788	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0078d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00793	c1 e8 11	 shr	 eax, 17
  00796	83 e0 01	 and	 eax, 1
  00799	85 c0		 test	 eax, eax
  0079b	0f 84 e7 01 00
	00		 je	 $LN9@z900_proce

; 2196 :     {
; 2197 :         REGS* hostregs = HOSTREGS;

  007a1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007a6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  007ad	48 89 44 24 30	 mov	 QWORD PTR hostregs$1[rsp], rax

; 2198 :         S64 saved_timer[2] = {0};

  007b2	48 8d 44 24 38	 lea	 rax, QWORD PTR saved_timer$2[rsp]
  007b7	48 8b f8	 mov	 rdi, rax
  007ba	33 c0		 xor	 eax, eax
  007bc	b9 10 00 00 00	 mov	 ecx, 16
  007c1	f3 aa		 rep stosb

; 2199 : 
; 2200 :         OBTAIN_INTLOCK( hostregs );

  007c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196866
  007ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  007cf	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2201 :         {
; 2202 :             hostregs->waittod = host_tod();

  007d4	e8 00 00 00 00	 call	 host_tod
  007d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  007de	48 89 81 b8 07
	00 00		 mov	 QWORD PTR [rcx+1976], rax

; 2203 : 
; 2204 :             /* The CPU timer is not decremented for a CPU that is in
; 2205 :                the manual state (e.g. stopped in single step mode) */
; 2206 : 
; 2207 :             saved_timer[0] = get_cpu_timer( regs     );

  007e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007ea	e8 00 00 00 00	 call	 get_cpu_timer
  007ef	b9 08 00 00 00	 mov	 ecx, 8
  007f4	48 6b c9 00	 imul	 rcx, rcx, 0
  007f8	48 89 44 0c 38	 mov	 QWORD PTR saved_timer$2[rsp+rcx], rax

; 2208 :             saved_timer[1] = get_cpu_timer( hostregs );

  007fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00802	e8 00 00 00 00	 call	 get_cpu_timer
  00807	b9 08 00 00 00	 mov	 ecx, 8
  0080c	48 6b c9 01	 imul	 rcx, rcx, 1
  00810	48 89 44 0c 38	 mov	 QWORD PTR saved_timer$2[rsp+rcx], rax

; 2209 : 
; 2210 :             hostregs->cpustate = CPUSTATE_STOPPED;

  00815	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0081a	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3

; 2211 :             sysblk.started_mask &= ~hostregs->cpubit;

  0081e	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  00823	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00827	48 f7 d0	 not	 rax
  0082a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00831	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  00838	48 23 c8	 and	 rcx, rax
  0083b	48 8b c1	 mov	 rax, rcx
  0083e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00845	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2212 :             hostregs->stepwait = 1;

  0084c	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  00851	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00857	0f ba e8 12	 bts	 eax, 18
  0085b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00860	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2213 :             sysblk.intowner = LOCK_OWNER_NONE;

  00866	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0086b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00872	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN2@z900_proce:

; 2214 : 
; 2215 :             while (hostregs->cpustate == CPUSTATE_STOPPED)

  00879	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0087e	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00882	83 f8 03	 cmp	 eax, 3
  00885	75 2b		 jne	 SHORT $LN3@z900_proce

; 2216 :             {
; 2217 :                 wait_condition( &hostregs->intcond, &sysblk.intlock );

  00887	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0088e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00894	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00899	48 81 c1 80 0c
	00 00		 add	 rcx, 3200		; 00000c80H
  008a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196867
  008a7	48 8b d0	 mov	 rdx, rax
  008aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 2218 :             }

  008b0	eb c7		 jmp	 SHORT $LN2@z900_proce
$LN3@z900_proce:

; 2219 : 
; 2220 :             sysblk.intowner = hostregs->cpuad;

  008b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008be	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  008c5	66 89 88 62 10
	00 00		 mov	 WORD PTR [rax+4194], cx

; 2221 :             hostregs->stepwait = 0;

  008cc	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  008d1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  008d7	0f ba f0 12	 btr	 eax, 18
  008db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008e0	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2222 :             sysblk.started_mask |= hostregs->cpubit;

  008e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008f2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  008f6	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  008fd	48 0b c1	 or	 rax, rcx
  00900	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00907	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2223 : 
; 2224 :             set_cpu_timer( regs,     saved_timer[0] );

  0090e	b8 08 00 00 00	 mov	 eax, 8
  00913	48 6b c0 00	 imul	 rax, rax, 0
  00917	48 8b 54 04 38	 mov	 rdx, QWORD PTR saved_timer$2[rsp+rax]
  0091c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00921	e8 00 00 00 00	 call	 set_cpu_timer

; 2225 :             set_cpu_timer( hostregs, saved_timer[1] );

  00926	b8 08 00 00 00	 mov	 eax, 8
  0092b	48 6b c0 01	 imul	 rax, rax, 1
  0092f	48 8b 54 04 38	 mov	 rdx, QWORD PTR saved_timer$2[rsp+rax]
  00934	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00939	e8 00 00 00 00	 call	 set_cpu_timer

; 2226 : 
; 2227 :             hostregs->waittime += host_tod() - hostregs->waittod;

  0093e	e8 00 00 00 00	 call	 host_tod
  00943	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00948	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  0094f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00954	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  0095b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00960	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 2228 :             hostregs->waittod = 0;

  00967	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0096c	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 2229 :         }
; 2230 :         RELEASE_INTLOCK( hostregs );

  00977	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196868
  0097e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00983	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN9@z900_proce:

; 2231 :     }
; 2232 : } /* process_trace */

  00988	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0098c	5f		 pop	 rdi
  0098d	c3		 ret	 0
z900_process_trace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 48
addr$ = 56
z900_store_psw PROC

; 101  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 102  :     /* Ensure psw.IA is set */
; 103  :     if (!regs->psw.zeroilc)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00019	c1 e8 02	 shr	 eax, 2
  0001c	83 e0 01	 and	 eax, 1
  0001f	85 c0		 test	 eax, eax
  00021	75 57		 jne	 SHORT $LN5@z900_store
$LN4@z900_store:

; 104  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00028	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00030	74 42		 je	 SHORT $LN6@z900_store
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0003c	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00043	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00047	48 2b c1	 sub	 rax, rcx
  0004a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00056	48 03 c8	 add	 rcx, rax
  00059	48 8b c1	 mov	 rax, rcx
  0005c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00068	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN6@z900_store:
  00074	33 c0		 xor	 eax, eax
  00076	85 c0		 test	 eax, eax
  00078	75 a9		 jne	 SHORT $LN4@z900_store
$LN5@z900_store:

; 105  : 
; 106  : #if defined( FEATURE_BCMODE )
; 107  :     if (ECMODE( &regs->psw ))
; 108  : #endif
; 109  :         // 390 or 370 EC-mode
; 110  : 
; 111  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 112  :         STORE_DW( addr, make_psw64( regs, 390, false ));
; 113  : #endif
; 114  : 
; 115  : #if defined( FEATURE_BCMODE )
; 116  : 
; 117  :     else    // 370 BC-mode
; 118  : 
; 119  :         STORE_DW( addr, make_psw64( regs, 370, true ));
; 120  : 
; 121  : #elif defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 122  : 
; 123  :     // 64-bit z/Architecture mode
; 124  : 
; 125  :     STORE_DW( addr + 0, make_psw64( regs, 900, false ));

  0007a	45 33 c0	 xor	 r8d, r8d
  0007d	ba 84 03 00 00	 mov	 edx, 900		; 00000384H
  00082	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	e8 00 00 00 00	 call	 make_psw64
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 _byteswap_uint64
  00094	48 8b d0	 mov	 rdx, rax
  00097	48 8b 4c 24 38	 mov	 rcx, QWORD PTR addr$[rsp]
  0009c	e8 00 00 00 00	 call	 store_dw_noswap

; 126  :     STORE_DW( addr + 8, regs->psw.IA_G );

  000a1	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000a6	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  000ad	e8 00 00 00 00	 call	 _byteswap_uint64
  000b2	48 8b 4c 24 38	 mov	 rcx, QWORD PTR addr$[rsp]
  000b7	48 83 c1 08	 add	 rcx, 8
  000bb	48 8b d0	 mov	 rdx, rax
  000be	e8 00 00 00 00	 call	 store_dw_noswap

; 127  : 
; 128  : #endif
; 129  : } /* end function ARCH_DEP(store_psw) */

  000c3	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000c7	c3		 ret	 0
z900_store_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
i$1 = 80
oldmode$2 = 84
tv478 = 88
tv131 = 92
tv161 = 96
tv179 = 100
tv198 = 104
tv203 = 108
tv246 = 112
tv287 = 116
tv407 = 120
tv427 = 124
tv412 = 128
tv452 = 132
tv472 = 136
tv457 = 140
tv588 = 144
tv369 = 148
inst_cr$3 = 152
tv143 = 160
tv173 = 168
tv290 = 176
tv371 = 184
buf$4 = 192
__$ArrayPad$ = 232
regs$ = 256
addr$ = 264
z900_load_psw PROC

; 136  : {

$LN111:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_load_:

; 137  :     INVALIDATE_AIA(regs);

  00023	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00033	74 64		 je	 SHORT $LN43@z900_load_
  00035	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  0004c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00050	48 2b c1	 sub	 rax, rcx
  00053	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00062	48 03 c8	 add	 rcx, rax
  00065	48 8b c1	 mov	 rax, rcx
  00068	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00077	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007f	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00086	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008e	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN43@z900_load_:
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 84		 jne	 SHORT $LN4@z900_load_

; 138  : 
; 139  :     regs->psw.zeroilc = 1;

  0009f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000ad	83 c8 04	 or	 eax, 4
  000b0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 140  : 
; 141  :     regs->psw.sysmask = addr[0];

  000be	b8 01 00 00 00	 mov	 eax, 1
  000c3	48 6b c0 00	 imul	 rax, rax, 0
  000c7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cf	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000d7	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  000db	88 41 78	 mov	 BYTE PTR [rcx+120], al

; 142  :     regs->psw.pkey    = (addr[1] & 0xF0);

  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	48 6b c0 01	 imul	 rax, rax, 1
  000e7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000ef	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f3	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000f8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	88 41 79	 mov	 BYTE PTR [rcx+121], al

; 143  :     regs->psw.states  = (addr[1] & 0x0F);

  00103	b8 01 00 00 00	 mov	 eax, 1
  00108	48 6b c0 01	 imul	 rax, rax, 1
  0010c	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00114	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00118	83 e0 0f	 and	 eax, 15
  0011b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	88 41 7a	 mov	 BYTE PTR [rcx+122], al
$LN7@z900_load_:

; 144  : 
; 145  : #if defined(FEATURE_BCMODE)
; 146  :     if ( ECMODE(&regs->psw) ) {
; 147  : #endif /*defined(FEATURE_BCMODE)*/
; 148  : 
; 149  :         SET_IC_ECMODE_MASK(regs);

  00126	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00132	83 e0 02	 and	 eax, 2
  00135	85 c0		 test	 eax, eax
  00137	74 0a		 je	 SHORT $LN73@z900_load_
  00139	c7 44 24 5c 00
	00 00 40	 mov	 DWORD PTR tv131[rsp], 1073741824 ; 40000000H
  00141	eb 08		 jmp	 SHORT $LN74@z900_load_
$LN73@z900_load_:
  00143	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN74@z900_load_:
  0014b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00153	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00157	83 e0 04	 and	 eax, 4
  0015a	85 c0		 test	 eax, eax
  0015c	74 29		 je	 SHORT $LN75@z900_load_
  0015e	b8 08 00 00 00	 mov	 eax, 8
  00163	48 6b c0 0f	 imul	 rax, rax, 15
  00167	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00177	48 25 00 00 00
	1f		 and	 rax, 520093696		; 1f000000H
  0017d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv143[rsp], rax
  00185	eb 0c		 jmp	 SHORT $LN76@z900_load_
$LN75@z900_load_:
  00187	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv143[rsp], 0
$LN76@z900_load_:
  00193	33 c0		 xor	 eax, eax
  00195	85 c0		 test	 eax, eax
  00197	75 4e		 jne	 SHORT $LN77@z900_load_
  00199	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a1	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001a5	83 e0 40	 and	 eax, 64			; 00000040H
  001a8	85 c0		 test	 eax, eax
  001aa	75 3b		 jne	 SHORT $LN77@z900_load_
  001ac	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ba	d1 e8		 shr	 eax, 1
  001bc	83 e0 01	 and	 eax, 1
  001bf	85 c0		 test	 eax, eax
  001c1	74 1a		 je	 SHORT $LN78@z900_load_
  001c3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cb	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  001d2	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001d6	83 e0 01	 and	 eax, 1
  001d9	85 c0		 test	 eax, eax
  001db	75 0a		 jne	 SHORT $LN77@z900_load_
$LN78@z900_load_:
  001dd	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
  001e5	eb 14		 jmp	 SHORT $LN79@z900_load_
$LN77@z900_load_:
  001e7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  001f2	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  001f7	89 44 24 60	 mov	 DWORD PTR tv161[rsp], eax
$LN79@z900_load_:
  001fb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00203	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00207	83 e0 01	 and	 eax, 1
  0020a	85 c0		 test	 eax, eax
  0020c	74 29		 je	 SHORT $LN80@z900_load_
  0020e	b8 08 00 00 00	 mov	 eax, 8
  00213	48 6b c0 01	 imul	 rax, rax, 1
  00217	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021f	48 8b 84 01 00
	06 00 00	 mov	 rax, QWORD PTR [rcx+rax+1536]
  00227	48 25 f0 fe 00
	00		 and	 rax, 65264		; 0000fef0H
  0022d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  00235	eb 0c		 jmp	 SHORT $LN81@z900_load_
$LN80@z900_load_:
  00237	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv173[rsp], 0
$LN81@z900_load_:
  00243	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0024f	83 e0 02	 and	 eax, 2
  00252	85 c0		 test	 eax, eax
  00254	74 0a		 je	 SHORT $LN82@z900_load_
  00256	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  0025e	eb 08		 jmp	 SHORT $LN83@z900_load_
$LN82@z900_load_:
  00260	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN83@z900_load_:
  00268	8b 44 24 5c	 mov	 eax, DWORD PTR tv131[rsp]
  0026c	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  00271	8b c0		 mov	 eax, eax
  00273	48 0b 84 24 a0
	00 00 00	 or	 rax, QWORD PTR tv143[rsp]
  0027b	8b 4c 24 60	 mov	 ecx, DWORD PTR tv161[rsp]
  0027f	48 0b c1	 or	 rax, rcx
  00282	48 0b 84 24 a8
	00 00 00	 or	 rax, QWORD PTR tv173[rsp]
  0028a	8b 4c 24 64	 mov	 ecx, DWORD PTR tv179[rsp]
  0028e	48 0b c1	 or	 rax, rcx
  00291	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00299	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  0029c	33 c0		 xor	 eax, eax
  0029e	85 c0		 test	 eax, eax
  002a0	75 4e		 jne	 SHORT $LN84@z900_load_
  002a2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002aa	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  002ae	83 e0 40	 and	 eax, 64			; 00000040H
  002b1	85 c0		 test	 eax, eax
  002b3	75 3b		 jne	 SHORT $LN84@z900_load_
  002b5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002c3	d1 e8		 shr	 eax, 1
  002c5	83 e0 01	 and	 eax, 1
  002c8	85 c0		 test	 eax, eax
  002ca	74 1a		 je	 SHORT $LN85@z900_load_
  002cc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d4	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  002db	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002df	83 e0 01	 and	 eax, 1
  002e2	85 c0		 test	 eax, eax
  002e4	75 0a		 jne	 SHORT $LN84@z900_load_
$LN85@z900_load_:
  002e6	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
  002ee	eb 08		 jmp	 SHORT $LN86@z900_load_
$LN84@z900_load_:
  002f0	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv198[rsp], 1
$LN86@z900_load_:
  002f8	8b 44 24 68	 mov	 eax, DWORD PTR tv198[rsp]
  002fc	83 e0 01	 and	 eax, 1
  002ff	c1 e0 02	 shl	 eax, 2
  00302	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030a	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00310	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00313	0b c8		 or	 ecx, eax
  00315	89 4c 24 6c	 mov	 DWORD PTR tv203[rsp], ecx
  00319	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00321	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv203[rsp]
  00325	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  0032b	8b 44 24 6c	 mov	 eax, DWORD PTR tv203[rsp]
  0032f	c1 e8 02	 shr	 eax, 2
  00332	83 e0 01	 and	 eax, 1
  00335	85 c0		 test	 eax, eax
  00337	74 7c		 je	 SHORT $LN44@z900_load_
$LN10@z900_load_:
  00339	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00341	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00349	74 64		 je	 SHORT $LN45@z900_load_
  0034b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00353	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035b	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00362	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00366	48 2b c1	 sub	 rax, rcx
  00369	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00371	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00378	48 03 c8	 add	 rcx, rax
  0037b	48 8b c1	 mov	 rax, rcx
  0037e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00386	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0038d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00395	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  0039c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a4	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN45@z900_load_:
  003af	33 c0		 xor	 eax, eax
  003b1	85 c0		 test	 eax, eax
  003b3	75 84		 jne	 SHORT $LN10@z900_load_
$LN44@z900_load_:
  003b5	33 c0		 xor	 eax, eax
  003b7	85 c0		 test	 eax, eax
  003b9	0f 85 67 fd ff
	ff		 jne	 $LN7@z900_load_

; 150  : 
; 151  :         /* Processing for EC mode PSW */
; 152  :         regs->psw.intcode  = 0;

  003bf	33 c0		 xor	 eax, eax
  003c1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 153  :         regs->psw.asc      = (addr[2] & 0xC0);

  003d0	b8 01 00 00 00	 mov	 eax, 1
  003d5	48 6b c0 02	 imul	 rax, rax, 2
  003d9	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  003e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e5	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  003ea	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f2	88 41 7b	 mov	 BYTE PTR [rcx+123], al

; 154  :         regs->psw.cc       = (addr[2] & 0x30) >> 4;

  003f5	b8 01 00 00 00	 mov	 eax, 1
  003fa	48 6b c0 02	 imul	 rax, rax, 2
  003fe	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00406	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0040a	83 e0 30	 and	 eax, 48			; 00000030H
  0040d	c1 f8 04	 sar	 eax, 4
  00410	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00418	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 155  :         regs->psw.progmask = (addr[2] & 0x0F);

  0041b	b8 01 00 00 00	 mov	 eax, 1
  00420	48 6b c0 02	 imul	 rax, rax, 2
  00424	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0042c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00430	83 e0 0f	 and	 eax, 15
  00433	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043b	88 41 7d	 mov	 BYTE PTR [rcx+125], al

; 156  :         regs->psw.amode    = (addr[4] & 0x80) ? 1 : 0;

  0043e	b8 01 00 00 00	 mov	 eax, 1
  00443	48 6b c0 04	 imul	 rax, rax, 4
  00447	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0044f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00453	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00458	85 c0		 test	 eax, eax
  0045a	74 0a		 je	 SHORT $LN87@z900_load_
  0045c	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv246[rsp], 1
  00464	eb 08		 jmp	 SHORT $LN88@z900_load_
$LN87@z900_load_:
  00466	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv246[rsp], 0
$LN88@z900_load_:
  0046e	8b 44 24 70	 mov	 eax, DWORD PTR tv246[rsp]
  00472	83 e0 01	 and	 eax, 1
  00475	d1 e0		 shl	 eax, 1
  00477	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047f	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  00485	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00488	0b c8		 or	 ecx, eax
  0048a	8b c1		 mov	 eax, ecx
  0048c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00494	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 157  : 
; 158  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 159  :         regs->psw.zerobyte = addr[3] & 0xFE;

  0049a	b8 01 00 00 00	 mov	 eax, 1
  0049f	48 6b c0 03	 imul	 rax, rax, 3
  004a3	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  004ab	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004af	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  004b4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bc	88 41 7e	 mov	 BYTE PTR [rcx+126], al

; 160  :         regs->psw.amode64  = addr[3] & 0x01;

  004bf	b8 01 00 00 00	 mov	 eax, 1
  004c4	48 6b c0 03	 imul	 rax, rax, 3
  004c8	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  004d0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004d4	83 e0 01	 and	 eax, 1
  004d7	83 e0 01	 and	 eax, 1
  004da	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e2	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  004e8	83 e1 fe	 and	 ecx, -2			; fffffffeH
  004eb	0b c8		 or	 ecx, eax
  004ed	8b c1		 mov	 eax, ecx
  004ef	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f7	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 161  :         regs->psw.zeroword = fetch_fw(addr+4) & 0x7FFFFFFF;

  004fd	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00505	48 83 c0 04	 add	 rax, 4
  00509	48 8b c8	 mov	 rcx, rax
  0050c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00511	8b c8		 mov	 ecx, eax
  00513	e8 00 00 00 00	 call	 _byteswap_ulong
  00518	0f ba f0 1f	 btr	 eax, 31
  0051c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00524	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 162  :         regs->psw.IA       = fetch_dw (addr + 8);

  0052a	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00532	48 83 c0 08	 add	 rax, 8
  00536	48 8b c8	 mov	 rcx, rax
  00539	e8 00 00 00 00	 call	 fetch_dw_noswap
  0053e	48 8b c8	 mov	 rcx, rax
  00541	e8 00 00 00 00	 call	 _byteswap_uint64
  00546	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054e	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax

; 163  :         regs->psw.AMASK    = regs->psw.amode64 ? AMASK64

  00555	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00563	83 e0 01	 and	 eax, 1
  00566	85 c0		 test	 eax, eax
  00568	74 0e		 je	 SHORT $LN91@z900_load_
  0056a	48 c7 84 24 b0
	00 00 00 ff ff
	ff ff		 mov	 QWORD PTR tv290[rsp], -1
  00576	eb 36		 jmp	 SHORT $LN92@z900_load_
$LN91@z900_load_:
  00578	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00580	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00586	d1 e8		 shr	 eax, 1
  00588	83 e0 01	 and	 eax, 1
  0058b	85 c0		 test	 eax, eax
  0058d	74 0a		 je	 SHORT $LN89@z900_load_
  0058f	c7 44 24 74 ff
	ff ff 7f	 mov	 DWORD PTR tv287[rsp], 2147483647 ; 7fffffffH
  00597	eb 08		 jmp	 SHORT $LN90@z900_load_
$LN89@z900_load_:
  00599	c7 44 24 74 ff
	ff ff 00	 mov	 DWORD PTR tv287[rsp], 16777215 ; 00ffffffH
$LN90@z900_load_:
  005a1	48 63 44 24 74	 movsxd	 rax, DWORD PTR tv287[rsp]
  005a6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv290[rsp], rax
$LN92@z900_load_:
  005ae	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv290[rsp]
  005be	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx

; 164  :                            : regs->psw.amode   ? AMASK31 : AMASK24;
; 165  : #else
; 166  :         regs->psw.zerobyte = addr[3];
; 167  :         regs->psw.amode64  = 0;
; 168  :         regs->psw.IA       = fetch_fw(addr + 4) & 0x7FFFFFFF;
; 169  :         regs->psw.AMASK    = regs->psw.amode ? AMASK31 : AMASK24;
; 170  : #endif
; 171  : 
; 172  :         /* Bits 0 and 2-4 of system mask must be zero */
; 173  :         if ((addr[0] & 0xB8) != 0)

  005c5	b8 01 00 00 00	 mov	 eax, 1
  005ca	48 6b c0 00	 imul	 rax, rax, 0
  005ce	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  005d6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005da	25 b8 00 00 00	 and	 eax, 184		; 000000b8H
  005df	85 c0		 test	 eax, eax
  005e1	74 0a		 je	 SHORT $LN46@z900_load_

; 174  :             return PGM_SPECIFICATION_EXCEPTION;

  005e3	b8 06 00 00 00	 mov	 eax, 6
  005e8	e9 09 09 00 00	 jmp	 $LN1@z900_load_
$LN46@z900_load_:

; 175  : 
; 176  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 177  :         /* For ESAME, bit 12 must be zero */
; 178  :         if (NOTESAME(&regs->psw))

  005ed	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f5	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  005f9	83 e0 08	 and	 eax, 8
  005fc	85 c0		 test	 eax, eax
  005fe	74 0a		 je	 SHORT $LN47@z900_load_

; 179  :             return PGM_SPECIFICATION_EXCEPTION;

  00600	b8 06 00 00 00	 mov	 eax, 6
  00605	e9 ec 08 00 00	 jmp	 $LN1@z900_load_
$LN47@z900_load_:

; 180  : 
; 181  :         /* Bits 24-30 must be zero */
; 182  :         if (regs->psw.zerobyte)

  0060a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00612	0f b6 40 7e	 movzx	 eax, BYTE PTR [rax+126]
  00616	85 c0		 test	 eax, eax
  00618	74 0a		 je	 SHORT $LN48@z900_load_

; 183  :             return PGM_SPECIFICATION_EXCEPTION;

  0061a	b8 06 00 00 00	 mov	 eax, 6
  0061f	e9 d2 08 00 00	 jmp	 $LN1@z900_load_
$LN48@z900_load_:

; 184  : 
; 185  :         /* Bits 33-63 must be zero */
; 186  :         if ( regs->psw.zeroword )

  00624	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062c	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00633	74 0a		 je	 SHORT $LN49@z900_load_

; 187  :             return PGM_SPECIFICATION_EXCEPTION;

  00635	b8 06 00 00 00	 mov	 eax, 6
  0063a	e9 b7 08 00 00	 jmp	 $LN1@z900_load_
$LN49@z900_load_:

; 188  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 189  :         /* Bits 24-31 must be zero */
; 190  :         if ( regs->psw.zerobyte )
; 191  :             return PGM_SPECIFICATION_EXCEPTION;
; 192  : 
; 193  :         /* For ESA/390, bit 12 must be one */
; 194  :         if (!ECMODE(&regs->psw))
; 195  :             return PGM_SPECIFICATION_EXCEPTION;
; 196  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 197  : 
; 198  : #ifndef FEATURE_DUAL_ADDRESS_SPACE
; 199  :         /* If DAS feature not installed then bit 16 must be zero */
; 200  :         if (SPACE_BIT(&regs->psw))
; 201  :             return PGM_SPECIFICATION_EXCEPTION;
; 202  : #endif
; 203  : 
; 204  : #ifndef FEATURE_ACCESS_REGISTERS
; 205  :         /* If not ESA/370 or ESA/390 then bit 17 must be zero */
; 206  :         if (AR_BIT(&regs->psw))
; 207  :             return PGM_SPECIFICATION_EXCEPTION;
; 208  : #endif
; 209  : 
; 210  :         /* Check validity of amode and instruction address */
; 211  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 212  :         /* For ESAME, bit 32 cannot be zero if bit 31 is one */
; 213  :         if (regs->psw.amode64 && !regs->psw.amode)

  0063f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00647	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0064d	83 e0 01	 and	 eax, 1
  00650	85 c0		 test	 eax, eax
  00652	74 21		 je	 SHORT $LN50@z900_load_
  00654	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00662	d1 e8		 shr	 eax, 1
  00664	83 e0 01	 and	 eax, 1
  00667	85 c0		 test	 eax, eax
  00669	75 0a		 jne	 SHORT $LN50@z900_load_

; 214  :             return PGM_SPECIFICATION_EXCEPTION;

  0066b	b8 06 00 00 00	 mov	 eax, 6
  00670	e9 81 08 00 00	 jmp	 $LN1@z900_load_
$LN50@z900_load_:

; 215  : 
; 216  :         /* If bit 32 is zero then IA cannot exceed 24 bits */
; 217  :         if (!regs->psw.amode && regs->psw.IA > 0x00FFFFFF)

  00675	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0067d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00683	d1 e8		 shr	 eax, 1
  00685	83 e0 01	 and	 eax, 1
  00688	85 c0		 test	 eax, eax
  0068a	75 1f		 jne	 SHORT $LN51@z900_load_
  0068c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00694	48 81 b8 88 00
	00 00 ff ff ff
	00		 cmp	 QWORD PTR [rax+136], 16777215 ; 00ffffffH
  0069f	76 0a		 jbe	 SHORT $LN51@z900_load_

; 218  :             return PGM_SPECIFICATION_EXCEPTION;

  006a1	b8 06 00 00 00	 mov	 eax, 6
  006a6	e9 4b 08 00 00	 jmp	 $LN1@z900_load_
$LN51@z900_load_:

; 219  : 
; 220  :         /* If bit 31 is zero then IA cannot exceed 31 bits */
; 221  :         if (!regs->psw.amode64 && regs->psw.IA > 0x7FFFFFFF)

  006ab	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006b9	83 e0 01	 and	 eax, 1
  006bc	85 c0		 test	 eax, eax
  006be	75 1f		 jne	 SHORT $LN52@z900_load_
  006c0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c8	48 81 b8 88 00
	00 00 ff ff ff
	7f		 cmp	 QWORD PTR [rax+136], 2147483647 ; 7fffffffH
  006d3	76 0a		 jbe	 SHORT $LN52@z900_load_

; 222  :             return PGM_SPECIFICATION_EXCEPTION;

  006d5	b8 06 00 00 00	 mov	 eax, 6
  006da	e9 17 08 00 00	 jmp	 $LN1@z900_load_
$LN52@z900_load_:

; 223  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 224  :   #ifdef FEATURE_BIMODAL_ADDRESSING
; 225  :         /* For 370-XA, ESA/370, and ESA/390,
; 226  :            if amode=24, bits 33-39 must be zero */
; 227  :         if (!regs->psw.amode && regs->psw.IA > 0x00FFFFFF)
; 228  :             return PGM_SPECIFICATION_EXCEPTION;
; 229  :   #else
; 230  :         /* For S/370, bits 32-39 must be zero */
; 231  :         if (addr[4] != 0x00)
; 232  :             return PGM_SPECIFICATION_EXCEPTION;
; 233  :   #endif
; 234  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 235  : 
; 236  : #if defined( FEATURE_BCMODE )
; 237  :     } else {
; 238  : 
; 239  :         SET_IC_BCMODE_MASK(regs);
; 240  : 
; 241  :         /* Processing for S/370 BC mode PSW */
; 242  :         regs->psw.intcode = fetch_hw (addr + 2);
; 243  :         regs->psw.cc = (addr[4] & 0x30) >> 4;
; 244  :         regs->psw.progmask = (addr[4] & 0x0F);
; 245  : 
; 246  :         FETCH_FW(regs->psw.IA, addr + 4);
; 247  :         regs->psw.IA &= 0x00FFFFFF;
; 248  :         regs->psw.AMASK = AMASK24;
; 249  : 
; 250  :         regs->psw.zerobyte = 0;
; 251  :         regs->psw.asc = 0;
; 252  :         regs->psw.amode64 = regs->psw.amode = 0;
; 253  :     }
; 254  : #endif /* defined( FEATURE_BCMODE ) */
; 255  : 
; 256  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 257  :     /* Bits 5 and 16 must be zero in XC mode */
; 258  :     if( SIE_STATE_BIT_ON(regs, MX, XC)
; 259  :       && ( (regs->psw.sysmask & PSW_DATMODE) || SPACE_BIT(&regs->psw)) )
; 260  :         return PGM_SPECIFICATION_EXCEPTION;
; 261  : #endif
; 262  : 
; 263  :     regs->psw.zeroilc = 0;

  006df	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006ed	83 e0 fb	 and	 eax, -5			; fffffffbH
  006f0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006f8	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 264  : 
; 265  :     /* Check for wait state PSW */
; 266  :     if (1
; 267  :         && WAITSTATE( &regs->psw )
; 268  :         && CPU_STEPPING_OR_TRACING_ALL
; 269  :         && !TXF_INSTR_TRACING()

  006fe	33 c0		 xor	 eax, eax
  00700	83 f8 01	 cmp	 eax, 1
  00703	0f 84 d1 01 00
	00		 je	 $LN53@z900_load_
  00709	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00711	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00715	83 e0 02	 and	 eax, 2
  00718	85 c0		 test	 eax, eax
  0071a	0f 84 ba 01 00
	00		 je	 $LN53@z900_load_
  00720	b8 08 00 00 00	 mov	 eax, 8
  00725	48 6b c0 00	 imul	 rax, rax, 0
  00729	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00730	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00739	75 32		 jne	 SHORT $LN55@z900_load_
  0073b	b8 08 00 00 00	 mov	 eax, 8
  00740	48 6b c0 01	 imul	 rax, rax, 1
  00744	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0074b	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00754	75 17		 jne	 SHORT $LN55@z900_load_
  00756	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0075d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00763	c1 e8 0a	 shr	 eax, 10
  00766	83 e0 01	 and	 eax, 1
  00769	85 c0		 test	 eax, eax
  0076b	75 4e		 jne	 SHORT $LN54@z900_load_
$LN55@z900_load_:
  0076d	b8 08 00 00 00	 mov	 eax, 8
  00772	48 6b c0 00	 imul	 rax, rax, 0
  00776	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0077d	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00786	0f 85 4e 01 00
	00		 jne	 $LN53@z900_load_
  0078c	b8 08 00 00 00	 mov	 eax, 8
  00791	48 6b c0 01	 imul	 rax, rax, 1
  00795	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0079c	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  007a5	0f 85 2f 01 00
	00		 jne	 $LN53@z900_load_
  007ab	e8 00 00 00 00	 call	 insttrace_all
  007b0	0f b6 c0	 movzx	 eax, al
  007b3	85 c0		 test	 eax, eax
  007b5	0f 84 1f 01 00
	00		 je	 $LN53@z900_load_
$LN54@z900_load_:
  007bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007c2	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  007c8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  007cd	85 c0		 test	 eax, eax
  007cf	0f 85 05 01 00
	00		 jne	 $LN53@z900_load_

; 270  :     )
; 271  :     {
; 272  :         if (regs->insttrace && sysblk.traceFILE)

  007d5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007dd	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  007e3	c1 e8 0f	 shr	 eax, 15
  007e6	83 e0 01	 and	 eax, 1
  007e9	85 c0		 test	 eax, eax
  007eb	74 24		 je	 SHORT $LN56@z900_load_
  007ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007f4	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  007fc	74 13		 je	 SHORT $LN56@z900_load_

; 273  :             tf_0800( regs );

  007fe	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00806	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0800
  0080c	e9 c9 00 00 00	 jmp	 $LN57@z900_load_
$LN56@z900_load_:

; 274  :         else
; 275  :         {
; 276  :             char buf[40];
; 277  :             STR_PSW( regs, buf );

  00811	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00817	48 8d 94 24 c0
	00 00 00	 lea	 rdx, QWORD PTR buf$4[rsp]
  0081f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00827	e8 00 00 00 00	 call	 str_psw

; 278  :             // "Processor %s%02X: loaded wait state PSW %s"
; 279  :             WRMSG( HHC00800, "I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );

  0082c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00834	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0083b	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv369[rsp], eax
  00842	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0084a	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00851	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00858	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00860	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00866	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv371[rsp], rax
  0086e	b9 01 00 00 00	 mov	 ecx, 1
  00873	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00879	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  00881	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00886	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv369[rsp]
  0088d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00891	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv371[rsp]
  00899	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0089e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195335
  008a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195336
  008b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  008c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG195337
  008c8	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  008cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG195338
  008d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN57@z900_load_:
$LN53@z900_load_:
$LN13@z900_load_:

; 280  :         }
; 281  :     }
; 282  : 
; 283  :     TEST_SET_AEA_MODE(regs);

  008da	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e2	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  008e6	83 e0 04	 and	 eax, 4
  008e9	85 c0		 test	 eax, eax
  008eb	75 63		 jne	 SHORT $LN95@z900_load_
  008ed	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008f5	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  008fb	d1 e8		 shr	 eax, 1
  008fd	83 e0 01	 and	 eax, 1
  00900	85 c0		 test	 eax, eax
  00902	74 37		 je	 SHORT $LN93@z900_load_
  00904	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0090c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00913	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00917	83 e0 01	 and	 eax, 1
  0091a	85 c0		 test	 eax, eax
  0091c	74 1d		 je	 SHORT $LN93@z900_load_
  0091e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00926	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0092a	83 e0 40	 and	 eax, 64			; 00000040H
  0092d	85 c0		 test	 eax, eax
  0092f	74 0a		 je	 SHORT $LN93@z900_load_
  00931	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR tv407[rsp], 2
  00939	eb 08		 jmp	 SHORT $LN94@z900_load_
$LN93@z900_load_:
  0093b	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv407[rsp], 0
$LN94@z900_load_:
  00943	8b 44 24 78	 mov	 eax, DWORD PTR tv407[rsp]
  00947	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv412[rsp], eax
  0094e	eb 18		 jmp	 SHORT $LN96@z900_load_
$LN95@z900_load_:
  00950	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00958	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0095c	c1 f8 06	 sar	 eax, 6
  0095f	ff c0		 inc	 eax
  00961	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv412[rsp], eax
$LN96@z900_load_:
  00968	33 c0		 xor	 eax, eax
  0096a	85 c0		 test	 eax, eax
  0096c	75 4e		 jne	 SHORT $LN97@z900_load_
  0096e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00976	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0097a	83 e0 40	 and	 eax, 64			; 00000040H
  0097d	85 c0		 test	 eax, eax
  0097f	75 3b		 jne	 SHORT $LN97@z900_load_
  00981	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00989	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0098f	d1 e8		 shr	 eax, 1
  00991	83 e0 01	 and	 eax, 1
  00994	85 c0		 test	 eax, eax
  00996	74 1a		 je	 SHORT $LN98@z900_load_
  00998	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009a0	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  009a7	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  009ab	83 e0 01	 and	 eax, 1
  009ae	85 c0		 test	 eax, eax
  009b0	75 0a		 jne	 SHORT $LN97@z900_load_
$LN98@z900_load_:
  009b2	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv427[rsp], 0
  009ba	eb 08		 jmp	 SHORT $LN99@z900_load_
$LN97@z900_load_:
  009bc	c7 44 24 7c 40
	00 00 00	 mov	 DWORD PTR tv427[rsp], 64 ; 00000040H
$LN99@z900_load_:
  009c4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009cc	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  009d3	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv427[rsp]
  009d7	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR tv412[rsp]
  009de	0b d1		 or	 edx, ecx
  009e0	8b ca		 mov	 ecx, edx
  009e2	3b c1		 cmp	 eax, ecx
  009e4	0f 84 00 05 00
	00		 je	 $LN58@z900_load_
$LN16@z900_load_:
  009ea	b8 04 00 00 00	 mov	 eax, 4
  009ef	48 6b c0 04	 imul	 rax, rax, 4
  009f3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009fb	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00a02	89 84 24 98 00
	00 00		 mov	 DWORD PTR inst_cr$3[rsp], eax
  00a09	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a11	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00a18	88 44 24 54	 mov	 BYTE PTR oldmode$2[rsp], al
  00a1c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a24	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00a28	83 e0 04	 and	 eax, 4
  00a2b	85 c0		 test	 eax, eax
  00a2d	75 6c		 jne	 SHORT $LN102@z900_load_
  00a2f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a37	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a3d	d1 e8		 shr	 eax, 1
  00a3f	83 e0 01	 and	 eax, 1
  00a42	85 c0		 test	 eax, eax
  00a44	74 3a		 je	 SHORT $LN100@z900_load_
  00a46	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a4e	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a55	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00a59	83 e0 01	 and	 eax, 1
  00a5c	85 c0		 test	 eax, eax
  00a5e	74 20		 je	 SHORT $LN100@z900_load_
  00a60	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a68	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00a6c	83 e0 40	 and	 eax, 64			; 00000040H
  00a6f	85 c0		 test	 eax, eax
  00a71	74 0d		 je	 SHORT $LN100@z900_load_
  00a73	c7 84 24 84 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv452[rsp], 2
  00a7e	eb 0b		 jmp	 SHORT $LN101@z900_load_
$LN100@z900_load_:
  00a80	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv452[rsp], 0
$LN101@z900_load_:
  00a8b	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv452[rsp]
  00a92	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv457[rsp], eax
  00a99	eb 18		 jmp	 SHORT $LN103@z900_load_
$LN102@z900_load_:
  00a9b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa3	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00aa7	c1 f8 06	 sar	 eax, 6
  00aaa	ff c0		 inc	 eax
  00aac	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv457[rsp], eax
$LN103@z900_load_:
  00ab3	33 c0		 xor	 eax, eax
  00ab5	85 c0		 test	 eax, eax
  00ab7	75 51		 jne	 SHORT $LN104@z900_load_
  00ab9	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ac1	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00ac5	83 e0 40	 and	 eax, 64			; 00000040H
  00ac8	85 c0		 test	 eax, eax
  00aca	75 3e		 jne	 SHORT $LN104@z900_load_
  00acc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ad4	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00ada	d1 e8		 shr	 eax, 1
  00adc	83 e0 01	 and	 eax, 1
  00adf	85 c0		 test	 eax, eax
  00ae1	74 1a		 je	 SHORT $LN105@z900_load_
  00ae3	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aeb	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00af2	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00af6	83 e0 01	 and	 eax, 1
  00af9	85 c0		 test	 eax, eax
  00afb	75 0d		 jne	 SHORT $LN104@z900_load_
$LN105@z900_load_:
  00afd	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv472[rsp], 0
  00b08	eb 0b		 jmp	 SHORT $LN106@z900_load_
$LN104@z900_load_:
  00b0a	c7 84 24 88 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv472[rsp], 64 ; 00000040H
$LN106@z900_load_:
  00b15	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv472[rsp]
  00b1c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv457[rsp]
  00b23	0b c8		 or	 ecx, eax
  00b25	8b c1		 mov	 eax, ecx
  00b27	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b2f	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00b35	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b3d	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00b44	83 e0 0f	 and	 eax, 15
  00b47	89 44 24 58	 mov	 DWORD PTR tv478[rsp], eax
  00b4b	83 7c 24 58 01	 cmp	 DWORD PTR tv478[rsp], 1
  00b50	74 22		 je	 SHORT $LN59@z900_load_
  00b52	83 7c 24 58 02	 cmp	 DWORD PTR tv478[rsp], 2
  00b57	74 59		 je	 SHORT $LN60@z900_load_
  00b59	83 7c 24 58 03	 cmp	 DWORD PTR tv478[rsp], 3
  00b5e	0f 84 11 01 00
	00		 je	 $LN64@z900_load_
  00b64	83 7c 24 58 04	 cmp	 DWORD PTR tv478[rsp], 4
  00b69	0f 84 5d 01 00
	00		 je	 $LN65@z900_load_
  00b6f	e9 93 01 00 00	 jmp	 $LN66@z900_load_
$LN59@z900_load_:
  00b74	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00b7c	eb 0a		 jmp	 SHORT $LN21@z900_load_
$LN19@z900_load_:
  00b7e	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00b82	ff c0		 inc	 eax
  00b84	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN21@z900_load_:
  00b88	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00b8d	7d 1e		 jge	 SHORT $LN20@z900_load_
  00b8f	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00b93	83 c0 05	 add	 eax, 5
  00b96	48 98		 cdqe
  00b98	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ba0	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00bab	eb d1		 jmp	 SHORT $LN19@z900_load_
$LN20@z900_load_:
  00bad	e9 8e 01 00 00	 jmp	 $LN17@z900_load_
$LN60@z900_load_:
  00bb2	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00bba	eb 0a		 jmp	 SHORT $LN24@z900_load_
$LN22@z900_load_:
  00bbc	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00bc0	ff c0		 inc	 eax
  00bc2	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN24@z900_load_:
  00bc6	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00bcb	7d 1e		 jge	 SHORT $LN23@z900_load_
  00bcd	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00bd1	83 c0 05	 add	 eax, 5
  00bd4	48 98		 cdqe
  00bd6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bde	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00be9	eb d1		 jmp	 SHORT $LN22@z900_load_
$LN23@z900_load_:
  00beb	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00bf3	eb 0a		 jmp	 SHORT $LN27@z900_load_
$LN25@z900_load_:
  00bf5	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00bf9	ff c0		 inc	 eax
  00bfb	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN27@z900_load_:
  00bff	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00c04	7d 6a		 jge	 SHORT $LN26@z900_load_
  00c06	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00c0b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c13	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00c1b	75 1e		 jne	 SHORT $LN61@z900_load_
  00c1d	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00c21	83 c0 05	 add	 eax, 5
  00c24	48 98		 cdqe
  00c26	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c2e	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00c39	eb 33		 jmp	 SHORT $LN62@z900_load_
$LN61@z900_load_:
  00c3b	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00c40	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c48	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00c50	74 1c		 je	 SHORT $LN63@z900_load_
  00c52	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00c56	83 c0 05	 add	 eax, 5
  00c59	48 98		 cdqe
  00c5b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c63	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN63@z900_load_:
$LN62@z900_load_:
  00c6e	eb 85		 jmp	 SHORT $LN25@z900_load_
$LN26@z900_load_:
  00c70	e9 cb 00 00 00	 jmp	 $LN17@z900_load_
$LN64@z900_load_:
  00c75	b8 04 00 00 00	 mov	 eax, 4
  00c7a	48 6b c0 04	 imul	 rax, rax, 4
  00c7e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c86	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00c91	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00c99	eb 0a		 jmp	 SHORT $LN30@z900_load_
$LN28@z900_load_:
  00c9b	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00c9f	ff c0		 inc	 eax
  00ca1	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN30@z900_load_:
  00ca5	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00caa	7d 1e		 jge	 SHORT $LN29@z900_load_
  00cac	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00cb0	83 c0 05	 add	 eax, 5
  00cb3	48 98		 cdqe
  00cb5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cbd	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00cc8	eb d1		 jmp	 SHORT $LN28@z900_load_
$LN29@z900_load_:
  00cca	eb 74		 jmp	 SHORT $LN17@z900_load_
$LN65@z900_load_:
  00ccc	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00cd4	eb 0a		 jmp	 SHORT $LN33@z900_load_
$LN31@z900_load_:
  00cd6	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00cda	ff c0		 inc	 eax
  00cdc	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN33@z900_load_:
  00ce0	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00ce5	7d 1e		 jge	 SHORT $LN32@z900_load_
  00ce7	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00ceb	83 c0 05	 add	 eax, 5
  00cee	48 98		 cdqe
  00cf0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cf8	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  00d03	eb d1		 jmp	 SHORT $LN31@z900_load_
$LN32@z900_load_:
  00d05	eb 39		 jmp	 SHORT $LN17@z900_load_
$LN66@z900_load_:
  00d07	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00d0f	eb 0a		 jmp	 SHORT $LN36@z900_load_
$LN34@z900_load_:
  00d11	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00d15	ff c0		 inc	 eax
  00d17	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN36@z900_load_:
  00d1b	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00d20	7d 1e		 jge	 SHORT $LN35@z900_load_
  00d22	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00d26	83 c0 05	 add	 eax, 5
  00d29	48 98		 cdqe
  00d2b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d33	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  00d3e	eb d1		 jmp	 SHORT $LN34@z900_load_
$LN35@z900_load_:
$LN17@z900_load_:
  00d40	b8 04 00 00 00	 mov	 eax, 4
  00d45	48 6b c0 04	 imul	 rax, rax, 4
  00d49	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d51	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00d58	39 84 24 98 00
	00 00		 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00d5f	74 7c		 je	 SHORT $LN67@z900_load_
$LN39@z900_load_:
  00d61	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d69	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00d71	74 64		 je	 SHORT $LN68@z900_load_
  00d73	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d7b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d83	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00d8a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00d8e	48 2b c1	 sub	 rax, rcx
  00d91	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d99	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00da0	48 03 c8	 add	 rcx, rax
  00da3	48 8b c1	 mov	 rax, rcx
  00da6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dae	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00db5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00dbd	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00dc4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dcc	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN68@z900_load_:
  00dd7	33 c0		 xor	 eax, eax
  00dd9	85 c0		 test	 eax, eax
  00ddb	75 84		 jne	 SHORT $LN39@z900_load_
$LN67@z900_load_:
  00ddd	0f b6 44 24 54	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  00de2	83 e0 40	 and	 eax, 64			; 00000040H
  00de5	85 c0		 test	 eax, eax
  00de7	0f 85 f3 00 00
	00		 jne	 $LN69@z900_load_
  00ded	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00df5	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00dfc	83 e0 40	 and	 eax, 64			; 00000040H
  00dff	85 c0		 test	 eax, eax
  00e01	0f 84 d9 00 00
	00		 je	 $LN69@z900_load_
$LN42@z900_load_:
  00e07	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e0f	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00e17	74 64		 je	 SHORT $LN70@z900_load_
  00e19	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e21	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e29	48 8b 89 00 02
	00 00		 mov	 rcx, QWORD PTR [rcx+512]
  00e30	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00e34	48 2b c1	 sub	 rax, rcx
  00e37	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e3f	48 8b 89 10 02
	00 00		 mov	 rcx, QWORD PTR [rcx+528]
  00e46	48 03 c8	 add	 rcx, rax
  00e49	48 8b c1	 mov	 rax, rcx
  00e4c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e54	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00e5b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e63	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
  00e6a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e72	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN70@z900_load_:
  00e7d	33 c0		 xor	 eax, eax
  00e7f	85 c0		 test	 eax, eax
  00e81	75 84		 jne	 SHORT $LN42@z900_load_
  00e83	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e8b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00e91	c1 e8 02	 shr	 eax, 2
  00e94	83 e0 01	 and	 eax, 1
  00e97	85 c0		 test	 eax, eax
  00e99	74 0d		 je	 SHORT $LN109@z900_load_
  00e9b	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv588[rsp], 1
  00ea6	eb 0b		 jmp	 SHORT $LN110@z900_load_
$LN109@z900_load_:
  00ea8	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv588[rsp], 0
$LN110@z900_load_:
  00eb3	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR tv588[rsp], 0
  00ebb	74 23		 je	 SHORT $LN71@z900_load_
  00ebd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ec5	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00ec8	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00ecd	85 c0		 test	 eax, eax
  00ecf	74 0f		 je	 SHORT $LN71@z900_load_
  00ed1	b2 fc		 mov	 dl, 252			; 000000fcH
  00ed3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00edb	e8 00 00 00 00	 call	 z900_invalidate_tlb
$LN71@z900_load_:
$LN69@z900_load_:
  00ee0	33 c0		 xor	 eax, eax
  00ee2	85 c0		 test	 eax, eax
  00ee4	0f 85 00 fb ff
	ff		 jne	 $LN16@z900_load_
$LN58@z900_load_:
  00eea	33 c0		 xor	 eax, eax
  00eec	85 c0		 test	 eax, eax
  00eee	0f 85 e6 f9 ff
	ff		 jne	 $LN13@z900_load_

; 284  : 
; 285  :     return 0;

  00ef4	33 c0		 xor	 eax, eax
$LN1@z900_load_:

; 286  : } /* end function ARCH_DEP(load_psw) */

  00ef6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00efe	48 33 cc	 xor	 rcx, rsp
  00f01	e8 00 00 00 00	 call	 __security_check_cookie
  00f06	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00f0d	c3		 ret	 0
z900_load_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
shouldtrace$ = 32
tv225 = 36
tv227 = 40
tv354 = 44
hostregs$1 = 48
saved_timer$2 = 56
regs$ = 96
dest$ = 104
s390_process_trace PROC

; 2172 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2173 :     bool shouldtrace = false;           /* true == Trace instruction */

  0000f	c6 44 24 20 00	 mov	 BYTE PTR shouldtrace$[rsp], 0

; 2174 : 
; 2175 :     /* Test for trace */
; 2176 :     shouldtrace = CPU_TRACING( regs, 0 );

  00014	33 c0		 xor	 eax, eax
  00016	83 f8 01	 cmp	 eax, 1
  00019	0f 84 49 03 00
	00		 je	 $LN11@s390_proce
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00026	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002c	c1 e8 08	 shr	 eax, 8
  0002f	83 e0 01	 and	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	0f 84 2e 03 00
	00		 je	 $LN11@s390_proce
  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00045	c1 e8 0f	 shr	 eax, 15
  00048	83 e0 01	 and	 eax, 1
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 15 03 00
	00		 je	 $LN11@s390_proce
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	0f 85 17 01 00
	00		 jne	 $LN12@s390_proce
  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00064	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0006a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 fd 00 00
	00		 je	 $LN12@s390_proce
  00077	33 c0		 xor	 eax, eax
  00079	83 f8 01	 cmp	 eax, 1
  0007c	0f 84 e6 02 00
	00		 je	 $LN14@s390_proce
  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 34		 jne	 SHORT $LN13@s390_proce
  00088	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00095	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009a	85 c0		 test	 eax, eax
  0009c	74 1e		 je	 SHORT $LN13@s390_proce
  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000aa	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  000b0	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  000b6	0f 85 ac 02 00
	00		 jne	 $LN14@s390_proce
$LN13@s390_proce:
  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 34		 jne	 SHORT $LN15@s390_proce
  000c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  000cf	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000d4	85 c0		 test	 eax, eax
  000d6	74 1e		 je	 SHORT $LN15@s390_proce
  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e4	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  000ea	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  000f0	0f 8c 72 02 00
	00		 jl	 $LN14@s390_proce
$LN15@s390_proce:
  000f6	33 c0		 xor	 eax, eax
  000f8	85 c0		 test	 eax, eax
  000fa	75 78		 jne	 SHORT $LN17@s390_proce
  000fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00103	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00109	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0010e	85 c0		 test	 eax, eax
  00110	74 20		 je	 SHORT $LN16@s390_proce
  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00117	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN16@s390_proce
  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00127	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0012e	85 c0		 test	 eax, eax
  00130	75 42		 jne	 SHORT $LN17@s390_proce
$LN16@s390_proce:
  00132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00139	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0013f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00144	85 c0		 test	 eax, eax
  00146	0f 84 1c 02 00
	00		 je	 $LN18@s390_proce
  0014c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00151	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00158	85 c0		 test	 eax, eax
  0015a	0f 84 08 02 00
	00		 je	 $LN18@s390_proce
  00160	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00165	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0016c	85 c0		 test	 eax, eax
  0016e	0f 85 f4 01 00
	00		 jne	 $LN11@s390_proce
$LN12@s390_proce:
$LN17@s390_proce:
  00174	b8 08 00 00 00	 mov	 eax, 8
  00179	48 6b c0 00	 imul	 rax, rax, 0
  0017d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00184	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0018d	75 1f		 jne	 SHORT $LN19@s390_proce
  0018f	b8 08 00 00 00	 mov	 eax, 8
  00194	48 6b c0 01	 imul	 rax, rax, 1
  00198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0019f	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  001a8	0f 84 b0 01 00
	00		 je	 $LN21@s390_proce
$LN19@s390_proce:
  001ae	b8 08 00 00 00	 mov	 eax, 8
  001b3	48 6b c0 00	 imul	 rax, rax, 0
  001b7	b9 08 00 00 00	 mov	 ecx, 8
  001bc	48 6b c9 01	 imul	 rcx, rcx, 1
  001c0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001c7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  001ce	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  001d6	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  001de	0f 87 a4 00 00
	00		 ja	 $LN20@s390_proce
  001e4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001e9	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  001ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001f4	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  001f9	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00200	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00204	48 2b ca	 sub	 rcx, rdx
  00207	48 03 c1	 add	 rax, rcx
  0020a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00215	48 23 c1	 and	 rax, rcx
  00218	8b c0		 mov	 eax, eax
  0021a	b9 08 00 00 00	 mov	 ecx, 8
  0021f	48 6b c9 00	 imul	 rcx, rcx, 0
  00223	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0022a	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00232	72 54		 jb	 SHORT $LN20@s390_proce
  00234	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00239	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0023f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00244	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00249	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00250	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00254	48 2b ca	 sub	 rcx, rdx
  00257	48 03 c1	 add	 rax, rcx
  0025a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0025f	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00265	48 23 c1	 and	 rax, rcx
  00268	8b c0		 mov	 eax, eax
  0026a	b9 08 00 00 00	 mov	 ecx, 8
  0026f	48 6b c9 01	 imul	 rcx, rcx, 1
  00273	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0027a	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00282	0f 86 d6 00 00
	00		 jbe	 $LN21@s390_proce
$LN20@s390_proce:
  00288	b8 08 00 00 00	 mov	 eax, 8
  0028d	48 6b c0 00	 imul	 rax, rax, 0
  00291	b9 08 00 00 00	 mov	 ecx, 8
  00296	48 6b c9 01	 imul	 rcx, rcx, 1
  0029a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002a1	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  002a8	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  002b0	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  002b8	0f 86 aa 00 00
	00		 jbe	 $LN22@s390_proce
  002be	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  002c3	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  002c9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002ce	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  002d3	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  002da	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002de	48 2b ca	 sub	 rcx, rdx
  002e1	48 03 c1	 add	 rax, rcx
  002e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  002ef	48 23 c1	 and	 rax, rcx
  002f2	8b c0		 mov	 eax, eax
  002f4	b9 08 00 00 00	 mov	 ecx, 8
  002f9	48 6b c9 01	 imul	 rcx, rcx, 1
  002fd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00304	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0030c	72 5a		 jb	 SHORT $LN22@s390_proce
  0030e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00313	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00319	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00323	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0032a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0032e	48 2b ca	 sub	 rcx, rdx
  00331	48 03 c1	 add	 rax, rcx
  00334	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00339	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0033f	48 23 c1	 and	 rax, rcx
  00342	8b c0		 mov	 eax, eax
  00344	b9 08 00 00 00	 mov	 ecx, 8
  00349	48 6b c9 00	 imul	 rcx, rcx, 0
  0034d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00354	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0035c	77 0a		 ja	 SHORT $LN11@s390_proce
$LN21@s390_proce:
  0035e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv225[rsp], 1
  00366	eb 08		 jmp	 SHORT $LN23@s390_proce
$LN11@s390_proce:
$LN22@s390_proce:
$LN14@s390_proce:
$LN18@s390_proce:
  00368	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv225[rsp], 0
$LN23@s390_proce:
  00370	83 7c 24 24 00	 cmp	 DWORD PTR tv225[rsp], 0
  00375	75 0a		 jne	 SHORT $LN24@s390_proce
  00377	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv227[rsp], 0
  0037f	eb 08		 jmp	 SHORT $LN25@s390_proce
$LN24@s390_proce:
  00381	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv227[rsp], 1
$LN25@s390_proce:
  00389	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv227[rsp]
  0038e	88 44 24 20	 mov	 BYTE PTR shouldtrace$[rsp], al

; 2177 : 
; 2178 :     /* Test for step */
; 2179 :     regs->stepping = CPU_STEPPING( regs, 0 );

  00392	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00399	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0039f	c1 e8 0a	 shr	 eax, 10
  003a2	83 e0 01	 and	 eax, 1
  003a5	85 c0		 test	 eax, eax
  003a7	0f 84 15 03 00
	00		 je	 $LN33@s390_proce
  003ad	33 c0		 xor	 eax, eax
  003af	85 c0		 test	 eax, eax
  003b1	0f 85 17 01 00
	00		 jne	 $LN26@s390_proce
  003b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003be	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  003c4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003c9	85 c0		 test	 eax, eax
  003cb	0f 84 fd 00 00
	00		 je	 $LN26@s390_proce
  003d1	33 c0		 xor	 eax, eax
  003d3	83 f8 01	 cmp	 eax, 1
  003d6	0f 84 e6 02 00
	00		 je	 $LN28@s390_proce
  003dc	33 c0		 xor	 eax, eax
  003de	85 c0		 test	 eax, eax
  003e0	75 34		 jne	 SHORT $LN27@s390_proce
  003e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003e9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  003ef	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  003f4	85 c0		 test	 eax, eax
  003f6	74 1e		 je	 SHORT $LN27@s390_proce
  003f8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003fd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00404	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  0040a	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  00410	0f 85 ac 02 00
	00		 jne	 $LN28@s390_proce
$LN27@s390_proce:
  00416	33 c0		 xor	 eax, eax
  00418	85 c0		 test	 eax, eax
  0041a	75 34		 jne	 SHORT $LN29@s390_proce
  0041c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00423	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00429	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0042e	85 c0		 test	 eax, eax
  00430	74 1e		 je	 SHORT $LN29@s390_proce
  00432	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00437	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0043e	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00444	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0044a	0f 8c 72 02 00
	00		 jl	 $LN28@s390_proce
$LN29@s390_proce:
  00450	33 c0		 xor	 eax, eax
  00452	85 c0		 test	 eax, eax
  00454	75 78		 jne	 SHORT $LN31@s390_proce
  00456	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0045d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00463	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00468	85 c0		 test	 eax, eax
  0046a	74 20		 je	 SHORT $LN30@s390_proce
  0046c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00471	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00478	85 c0		 test	 eax, eax
  0047a	74 10		 je	 SHORT $LN30@s390_proce
  0047c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00481	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00488	85 c0		 test	 eax, eax
  0048a	75 42		 jne	 SHORT $LN31@s390_proce
$LN30@s390_proce:
  0048c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00493	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00499	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0049e	85 c0		 test	 eax, eax
  004a0	0f 84 1c 02 00
	00		 je	 $LN32@s390_proce
  004a6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  004ab	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  004b2	85 c0		 test	 eax, eax
  004b4	0f 84 08 02 00
	00		 je	 $LN32@s390_proce
  004ba	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  004bf	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  004c6	85 c0		 test	 eax, eax
  004c8	0f 85 f4 01 00
	00		 jne	 $LN33@s390_proce
$LN26@s390_proce:
$LN31@s390_proce:
  004ce	b8 08 00 00 00	 mov	 eax, 8
  004d3	48 6b c0 00	 imul	 rax, rax, 0
  004d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004de	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  004e7	75 1f		 jne	 SHORT $LN34@s390_proce
  004e9	b8 08 00 00 00	 mov	 eax, 8
  004ee	48 6b c0 01	 imul	 rax, rax, 1
  004f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004f9	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00502	0f 84 b0 01 00
	00		 je	 $LN36@s390_proce
$LN34@s390_proce:
  00508	b8 08 00 00 00	 mov	 eax, 8
  0050d	48 6b c0 00	 imul	 rax, rax, 0
  00511	b9 08 00 00 00	 mov	 ecx, 8
  00516	48 6b c9 01	 imul	 rcx, rcx, 1
  0051a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00521	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00528	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  00530	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00538	0f 87 a4 00 00
	00		 ja	 $LN35@s390_proce
  0053e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00543	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00549	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0054e	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00553	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0055a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0055e	48 2b ca	 sub	 rcx, rdx
  00561	48 03 c1	 add	 rax, rcx
  00564	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00569	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  0056f	48 23 c1	 and	 rax, rcx
  00572	8b c0		 mov	 eax, eax
  00574	b9 08 00 00 00	 mov	 ecx, 8
  00579	48 6b c9 00	 imul	 rcx, rcx, 0
  0057d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00584	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0058c	72 54		 jb	 SHORT $LN35@s390_proce
  0058e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00593	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00599	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0059e	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  005a3	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  005aa	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  005ae	48 2b ca	 sub	 rcx, rdx
  005b1	48 03 c1	 add	 rax, rcx
  005b4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  005b9	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  005bf	48 23 c1	 and	 rax, rcx
  005c2	8b c0		 mov	 eax, eax
  005c4	b9 08 00 00 00	 mov	 ecx, 8
  005c9	48 6b c9 01	 imul	 rcx, rcx, 1
  005cd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005d4	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  005dc	0f 86 d6 00 00
	00		 jbe	 $LN36@s390_proce
$LN35@s390_proce:
  005e2	b8 08 00 00 00	 mov	 eax, 8
  005e7	48 6b c0 00	 imul	 rax, rax, 0
  005eb	b9 08 00 00 00	 mov	 ecx, 8
  005f0	48 6b c9 01	 imul	 rcx, rcx, 1
  005f4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005fb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00602	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  0060a	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00612	0f 86 aa 00 00
	00		 jbe	 $LN37@s390_proce
  00618	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0061d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00623	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00628	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0062d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00634	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00638	48 2b ca	 sub	 rcx, rdx
  0063b	48 03 c1	 add	 rax, rcx
  0063e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00643	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00649	48 23 c1	 and	 rax, rcx
  0064c	8b c0		 mov	 eax, eax
  0064e	b9 08 00 00 00	 mov	 ecx, 8
  00653	48 6b c9 01	 imul	 rcx, rcx, 1
  00657	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0065e	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00666	72 5a		 jb	 SHORT $LN37@s390_proce
  00668	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0066d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00673	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00678	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0067d	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00684	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00688	48 2b ca	 sub	 rcx, rdx
  0068b	48 03 c1	 add	 rax, rcx
  0068e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00693	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00699	48 23 c1	 and	 rax, rcx
  0069c	8b c0		 mov	 eax, eax
  0069e	b9 08 00 00 00	 mov	 ecx, 8
  006a3	48 6b c9 00	 imul	 rcx, rcx, 0
  006a7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  006ae	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  006b6	77 0a		 ja	 SHORT $LN33@s390_proce
$LN36@s390_proce:
  006b8	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv354[rsp], 1
  006c0	eb 08		 jmp	 SHORT $LN38@s390_proce
$LN33@s390_proce:
$LN37@s390_proce:
$LN28@s390_proce:
$LN32@s390_proce:
  006c2	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv354[rsp], 0
$LN38@s390_proce:
  006ca	8b 44 24 2c	 mov	 eax, DWORD PTR tv354[rsp]
  006ce	83 e0 01	 and	 eax, 1
  006d1	c1 e0 11	 shl	 eax, 17
  006d4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006d9	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  006df	0f ba f1 11	 btr	 ecx, 17
  006e3	0b c8		 or	 ecx, eax
  006e5	8b c1		 mov	 eax, ecx
  006e7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006ec	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2180 : 
; 2181 :     if (regs->stepping)

  006f2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006f7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006fd	c1 e8 11	 shr	 eax, 17
  00700	83 e0 01	 and	 eax, 1
  00703	85 c0		 test	 eax, eax
  00705	74 54		 je	 SHORT $LN4@s390_proce

; 2182 :     {
; 2183 :         if (sysblk.breakasid)

  00707	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0070e	0f b7 80 c0 12
	00 00		 movzx	 eax, WORD PTR [rax+4800]
  00715	85 c0		 test	 eax, eax
  00717	74 42		 je	 SHORT $LN5@s390_proce

; 2184 :         {
; 2185 :             if (regs->CR_LHL(4) != sysblk.breakasid)

  00719	b8 08 00 00 00	 mov	 eax, 8
  0071e	48 6b c0 05	 imul	 rax, rax, 5
  00722	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00727	0f b7 84 01 00
	06 00 00	 movzx	 eax, WORD PTR [rcx+rax+1536]
  0072f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00736	0f b7 89 c0 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4800]
  0073d	3b c1		 cmp	 eax, ecx
  0073f	74 1a		 je	 SHORT $LN6@s390_proce

; 2186 :                 regs->stepping = false;

  00741	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00746	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0074c	0f ba f0 11	 btr	 eax, 17
  00750	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00755	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN6@s390_proce:
$LN5@s390_proce:
$LN4@s390_proce:

; 2187 :         }
; 2188 :     }
; 2189 : 
; 2190 :     /* Display the instruction */
; 2191 :     if (shouldtrace || regs->stepping)

  0075b	0f b6 44 24 20	 movzx	 eax, BYTE PTR shouldtrace$[rsp]
  00760	85 c0		 test	 eax, eax
  00762	75 15		 jne	 SHORT $LN8@s390_proce
  00764	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00769	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0076f	c1 e8 11	 shr	 eax, 17
  00772	83 e0 01	 and	 eax, 1
  00775	85 c0		 test	 eax, eax
  00777	74 0f		 je	 SHORT $LN7@s390_proce
$LN8@s390_proce:

; 2192 :         ARCH_DEP( display_inst )( regs, dest );

  00779	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest$[rsp]
  0077e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00783	e8 00 00 00 00	 call	 s390_display_inst
$LN7@s390_proce:

; 2193 : 
; 2194 :     /* Stop the CPU if instruction stepping */
; 2195 :     if (regs->stepping)

  00788	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0078d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00793	c1 e8 11	 shr	 eax, 17
  00796	83 e0 01	 and	 eax, 1
  00799	85 c0		 test	 eax, eax
  0079b	0f 84 e7 01 00
	00		 je	 $LN9@s390_proce

; 2196 :     {
; 2197 :         REGS* hostregs = HOSTREGS;

  007a1	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  007a6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  007ad	48 89 44 24 30	 mov	 QWORD PTR hostregs$1[rsp], rax

; 2198 :         S64 saved_timer[2] = {0};

  007b2	48 8d 44 24 38	 lea	 rax, QWORD PTR saved_timer$2[rsp]
  007b7	48 8b f8	 mov	 rdi, rax
  007ba	33 c0		 xor	 eax, eax
  007bc	b9 10 00 00 00	 mov	 ecx, 16
  007c1	f3 aa		 rep stosb

; 2199 : 
; 2200 :         OBTAIN_INTLOCK( hostregs );

  007c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182279
  007ca	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  007cf	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2201 :         {
; 2202 :             hostregs->waittod = host_tod();

  007d4	e8 00 00 00 00	 call	 host_tod
  007d9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  007de	48 89 81 b8 07
	00 00		 mov	 QWORD PTR [rcx+1976], rax

; 2203 : 
; 2204 :             /* The CPU timer is not decremented for a CPU that is in
; 2205 :                the manual state (e.g. stopped in single step mode) */
; 2206 : 
; 2207 :             saved_timer[0] = get_cpu_timer( regs     );

  007e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007ea	e8 00 00 00 00	 call	 get_cpu_timer
  007ef	b9 08 00 00 00	 mov	 ecx, 8
  007f4	48 6b c9 00	 imul	 rcx, rcx, 0
  007f8	48 89 44 0c 38	 mov	 QWORD PTR saved_timer$2[rsp+rcx], rax

; 2208 :             saved_timer[1] = get_cpu_timer( hostregs );

  007fd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00802	e8 00 00 00 00	 call	 get_cpu_timer
  00807	b9 08 00 00 00	 mov	 ecx, 8
  0080c	48 6b c9 01	 imul	 rcx, rcx, 1
  00810	48 89 44 0c 38	 mov	 QWORD PTR saved_timer$2[rsp+rcx], rax

; 2209 : 
; 2210 :             hostregs->cpustate = CPUSTATE_STOPPED;

  00815	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0081a	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3

; 2211 :             sysblk.started_mask &= ~hostregs->cpubit;

  0081e	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  00823	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00827	48 f7 d0	 not	 rax
  0082a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00831	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  00838	48 23 c8	 and	 rcx, rax
  0083b	48 8b c1	 mov	 rax, rcx
  0083e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00845	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2212 :             hostregs->stepwait = 1;

  0084c	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  00851	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00857	0f ba e8 12	 bts	 eax, 18
  0085b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00860	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2213 :             sysblk.intowner = LOCK_OWNER_NONE;

  00866	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0086b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00872	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN2@s390_proce:

; 2214 : 
; 2215 :             while (hostregs->cpustate == CPUSTATE_STOPPED)

  00879	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0087e	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00882	83 f8 03	 cmp	 eax, 3
  00885	75 2b		 jne	 SHORT $LN3@s390_proce

; 2216 :             {
; 2217 :                 wait_condition( &hostregs->intcond, &sysblk.intlock );

  00887	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0088e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00894	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00899	48 81 c1 80 0c
	00 00		 add	 rcx, 3200		; 00000c80H
  008a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG182280
  008a7	48 8b d0	 mov	 rdx, rax
  008aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 2218 :             }

  008b0	eb c7		 jmp	 SHORT $LN2@s390_proce
$LN3@s390_proce:

; 2219 : 
; 2220 :             sysblk.intowner = hostregs->cpuad;

  008b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008b9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008be	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  008c5	66 89 88 62 10
	00 00		 mov	 WORD PTR [rax+4194], cx

; 2221 :             hostregs->stepwait = 0;

  008cc	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  008d1	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  008d7	0f ba f0 12	 btr	 eax, 18
  008db	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008e0	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2222 :             sysblk.started_mask |= hostregs->cpubit;

  008e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008ed	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008f2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  008f6	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  008fd	48 0b c1	 or	 rax, rcx
  00900	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00907	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2223 : 
; 2224 :             set_cpu_timer( regs,     saved_timer[0] );

  0090e	b8 08 00 00 00	 mov	 eax, 8
  00913	48 6b c0 00	 imul	 rax, rax, 0
  00917	48 8b 54 04 38	 mov	 rdx, QWORD PTR saved_timer$2[rsp+rax]
  0091c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00921	e8 00 00 00 00	 call	 set_cpu_timer

; 2225 :             set_cpu_timer( hostregs, saved_timer[1] );

  00926	b8 08 00 00 00	 mov	 eax, 8
  0092b	48 6b c0 01	 imul	 rax, rax, 1
  0092f	48 8b 54 04 38	 mov	 rdx, QWORD PTR saved_timer$2[rsp+rax]
  00934	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00939	e8 00 00 00 00	 call	 set_cpu_timer

; 2226 : 
; 2227 :             hostregs->waittime += host_tod() - hostregs->waittod;

  0093e	e8 00 00 00 00	 call	 host_tod
  00943	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00948	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  0094f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00954	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  0095b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00960	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 2228 :             hostregs->waittod = 0;

  00967	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0096c	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 2229 :         }
; 2230 :         RELEASE_INTLOCK( hostregs );

  00977	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG182281
  0097e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00983	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN9@s390_proce:

; 2231 :     }
; 2232 : } /* process_trace */

  00988	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0098c	5f		 pop	 rdi
  0098d	c3		 ret	 0
s390_process_trace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 48
addr$ = 56
s390_store_psw PROC

; 101  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 102  :     /* Ensure psw.IA is set */
; 103  :     if (!regs->psw.zeroilc)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00019	c1 e8 02	 shr	 eax, 2
  0001c	83 e0 01	 and	 eax, 1
  0001f	85 c0		 test	 eax, eax
  00021	75 54		 jne	 SHORT $LN5@s390_store
$LN4@s390_store:

; 104  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00028	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00030	74 3f		 je	 SHORT $LN6@s390_store
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00047	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0004e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00052	48 2b ca	 sub	 rcx, rdx
  00055	48 03 c1	 add	 rax, rcx
  00058	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00063	48 23 c1	 and	 rax, rcx
  00066	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN6@s390_store:
  00071	33 c0		 xor	 eax, eax
  00073	85 c0		 test	 eax, eax
  00075	75 ac		 jne	 SHORT $LN4@s390_store
$LN5@s390_store:

; 105  : 
; 106  : #if defined( FEATURE_BCMODE )
; 107  :     if (ECMODE( &regs->psw ))
; 108  : #endif
; 109  :         // 390 or 370 EC-mode
; 110  : 
; 111  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 112  :         STORE_DW( addr, make_psw64( regs, 390, false ));

  00077	45 33 c0	 xor	 r8d, r8d
  0007a	ba 86 01 00 00	 mov	 edx, 390		; 00000186H
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00084	e8 00 00 00 00	 call	 make_psw64
  00089	48 8b c8	 mov	 rcx, rax
  0008c	e8 00 00 00 00	 call	 _byteswap_uint64
  00091	48 8b d0	 mov	 rdx, rax
  00094	48 8b 4c 24 38	 mov	 rcx, QWORD PTR addr$[rsp]
  00099	e8 00 00 00 00	 call	 store_dw_noswap

; 113  : #endif
; 114  : 
; 115  : #if defined( FEATURE_BCMODE )
; 116  : 
; 117  :     else    // 370 BC-mode
; 118  : 
; 119  :         STORE_DW( addr, make_psw64( regs, 370, true ));
; 120  : 
; 121  : #elif defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 122  : 
; 123  :     // 64-bit z/Architecture mode
; 124  : 
; 125  :     STORE_DW( addr + 0, make_psw64( regs, 900, false ));
; 126  :     STORE_DW( addr + 8, regs->psw.IA_G );
; 127  : 
; 128  : #endif
; 129  : } /* end function ARCH_DEP(store_psw) */

  0009e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a2	c3		 ret	 0
s390_store_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
i$1 = 80
oldmode$2 = 84
tv463 = 88
tv134 = 92
tv145 = 96
tv163 = 100
tv174 = 104
tv180 = 108
tv197 = 112
tv202 = 116
tv248 = 120
tv272 = 124
tv392 = 128
tv412 = 132
tv397 = 136
tv437 = 140
tv457 = 144
tv442 = 148
tv579 = 152
tv354 = 156
inst_cr$3 = 160
tv356 = 168
buf$4 = 176
__$ArrayPad$ = 216
regs$ = 240
addr$ = 248
s390_load_psw PROC

; 136  : {

$LN108:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s390_load_:

; 137  :     INVALIDATE_AIA(regs);

  00023	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00033	74 61		 je	 SHORT $LN43@s390_load_
  00035	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00043	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004b	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00053	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0005a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0005e	48 2b ca	 sub	 rcx, rdx
  00061	48 03 c1	 add	 rax, rcx
  00064	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00072	48 23 c1	 and	 rax, rcx
  00075	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00083	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN43@s390_load_:
  00096	33 c0		 xor	 eax, eax
  00098	85 c0		 test	 eax, eax
  0009a	75 87		 jne	 SHORT $LN4@s390_load_

; 138  : 
; 139  :     regs->psw.zeroilc = 1;

  0009c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000aa	83 c8 04	 or	 eax, 4
  000ad	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 140  : 
; 141  :     regs->psw.sysmask = addr[0];

  000bb	b8 01 00 00 00	 mov	 eax, 1
  000c0	48 6b c0 00	 imul	 rax, rax, 0
  000c4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000d4	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  000d8	88 41 78	 mov	 BYTE PTR [rcx+120], al

; 142  :     regs->psw.pkey    = (addr[1] & 0xF0);

  000db	b8 01 00 00 00	 mov	 eax, 1
  000e0	48 6b c0 01	 imul	 rax, rax, 1
  000e4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f0	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000f5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fd	88 41 79	 mov	 BYTE PTR [rcx+121], al

; 143  :     regs->psw.states  = (addr[1] & 0x0F);

  00100	b8 01 00 00 00	 mov	 eax, 1
  00105	48 6b c0 01	 imul	 rax, rax, 1
  00109	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00111	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00115	83 e0 0f	 and	 eax, 15
  00118	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00120	88 41 7a	 mov	 BYTE PTR [rcx+122], al
$LN7@s390_load_:

; 144  : 
; 145  : #if defined(FEATURE_BCMODE)
; 146  :     if ( ECMODE(&regs->psw) ) {
; 147  : #endif /*defined(FEATURE_BCMODE)*/
; 148  : 
; 149  :         SET_IC_ECMODE_MASK(regs);

  00123	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0012f	83 e0 02	 and	 eax, 2
  00132	85 c0		 test	 eax, eax
  00134	74 0a		 je	 SHORT $LN72@s390_load_
  00136	c7 44 24 5c 00
	00 00 40	 mov	 DWORD PTR tv134[rsp], 1073741824 ; 40000000H
  0013e	eb 08		 jmp	 SHORT $LN73@s390_load_
$LN72@s390_load_:
  00140	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv134[rsp], 0
$LN73@s390_load_:
  00148	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00150	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00154	83 e0 04	 and	 eax, 4
  00157	85 c0		 test	 eax, eax
  00159	74 23		 je	 SHORT $LN74@s390_load_
  0015b	b8 08 00 00 00	 mov	 eax, 8
  00160	48 6b c0 0f	 imul	 rax, rax, 15
  00164	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00173	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00178	89 44 24 60	 mov	 DWORD PTR tv145[rsp], eax
  0017c	eb 08		 jmp	 SHORT $LN75@s390_load_
$LN74@s390_load_:
  0017e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN75@s390_load_:
  00186	33 c0		 xor	 eax, eax
  00188	85 c0		 test	 eax, eax
  0018a	75 4e		 jne	 SHORT $LN76@s390_load_
  0018c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00194	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00198	83 e0 40	 and	 eax, 64			; 00000040H
  0019b	85 c0		 test	 eax, eax
  0019d	75 3b		 jne	 SHORT $LN76@s390_load_
  0019f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001ad	d1 e8		 shr	 eax, 1
  001af	83 e0 01	 and	 eax, 1
  001b2	85 c0		 test	 eax, eax
  001b4	74 1a		 je	 SHORT $LN77@s390_load_
  001b6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001be	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  001c5	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001c9	83 e0 01	 and	 eax, 1
  001cc	85 c0		 test	 eax, eax
  001ce	75 0a		 jne	 SHORT $LN76@s390_load_
$LN77@s390_load_:
  001d0	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv163[rsp], 0
  001d8	eb 14		 jmp	 SHORT $LN78@s390_load_
$LN76@s390_load_:
  001da	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e2	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  001e5	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  001ea	89 44 24 64	 mov	 DWORD PTR tv163[rsp], eax
$LN78@s390_load_:
  001ee	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001fa	83 e0 01	 and	 eax, 1
  001fd	85 c0		 test	 eax, eax
  001ff	74 23		 je	 SHORT $LN79@s390_load_
  00201	b8 08 00 00 00	 mov	 eax, 8
  00206	48 6b c0 01	 imul	 rax, rax, 1
  0020a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00219	25 f0 fe 00 00	 and	 eax, 65264		; 0000fef0H
  0021e	89 44 24 68	 mov	 DWORD PTR tv174[rsp], eax
  00222	eb 08		 jmp	 SHORT $LN80@s390_load_
$LN79@s390_load_:
  00224	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN80@s390_load_:
  0022c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00234	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00238	83 e0 02	 and	 eax, 2
  0023b	85 c0		 test	 eax, eax
  0023d	74 0a		 je	 SHORT $LN81@s390_load_
  0023f	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  00247	eb 08		 jmp	 SHORT $LN82@s390_load_
$LN81@s390_load_:
  00249	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN82@s390_load_:
  00251	8b 44 24 5c	 mov	 eax, DWORD PTR tv134[rsp]
  00255	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  0025a	0b 44 24 60	 or	 eax, DWORD PTR tv145[rsp]
  0025e	0b 44 24 64	 or	 eax, DWORD PTR tv163[rsp]
  00262	0b 44 24 68	 or	 eax, DWORD PTR tv174[rsp]
  00266	0b 44 24 6c	 or	 eax, DWORD PTR tv180[rsp]
  0026a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00275	33 c0		 xor	 eax, eax
  00277	85 c0		 test	 eax, eax
  00279	75 4e		 jne	 SHORT $LN83@s390_load_
  0027b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00283	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00287	83 e0 40	 and	 eax, 64			; 00000040H
  0028a	85 c0		 test	 eax, eax
  0028c	75 3b		 jne	 SHORT $LN83@s390_load_
  0028e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00296	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0029c	d1 e8		 shr	 eax, 1
  0029e	83 e0 01	 and	 eax, 1
  002a1	85 c0		 test	 eax, eax
  002a3	74 1a		 je	 SHORT $LN84@s390_load_
  002a5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  002b4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  002b8	83 e0 01	 and	 eax, 1
  002bb	85 c0		 test	 eax, eax
  002bd	75 0a		 jne	 SHORT $LN83@s390_load_
$LN84@s390_load_:
  002bf	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv197[rsp], 0
  002c7	eb 08		 jmp	 SHORT $LN85@s390_load_
$LN83@s390_load_:
  002c9	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv197[rsp], 1
$LN85@s390_load_:
  002d1	8b 44 24 70	 mov	 eax, DWORD PTR tv197[rsp]
  002d5	83 e0 01	 and	 eax, 1
  002d8	c1 e0 02	 shl	 eax, 2
  002db	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  002e9	83 e1 fb	 and	 ecx, -5			; fffffffbH
  002ec	0b c8		 or	 ecx, eax
  002ee	89 4c 24 74	 mov	 DWORD PTR tv202[rsp], ecx
  002f2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002fa	8b 4c 24 74	 mov	 ecx, DWORD PTR tv202[rsp]
  002fe	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  00304	8b 44 24 74	 mov	 eax, DWORD PTR tv202[rsp]
  00308	c1 e8 02	 shr	 eax, 2
  0030b	83 e0 01	 and	 eax, 1
  0030e	85 c0		 test	 eax, eax
  00310	74 79		 je	 SHORT $LN44@s390_load_
$LN10@s390_load_:
  00312	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00322	74 61		 je	 SHORT $LN45@s390_load_
  00324	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0032c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00332	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033a	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00342	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00349	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0034d	48 2b ca	 sub	 rcx, rdx
  00350	48 03 c1	 add	 rax, rcx
  00353	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035b	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00361	48 23 c1	 and	 rax, rcx
  00364	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036c	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00372	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037a	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN45@s390_load_:
  00385	33 c0		 xor	 eax, eax
  00387	85 c0		 test	 eax, eax
  00389	75 87		 jne	 SHORT $LN10@s390_load_
$LN44@s390_load_:
  0038b	33 c0		 xor	 eax, eax
  0038d	85 c0		 test	 eax, eax
  0038f	0f 85 8e fd ff
	ff		 jne	 $LN7@s390_load_

; 150  : 
; 151  :         /* Processing for EC mode PSW */
; 152  :         regs->psw.intcode  = 0;

  00395	33 c0		 xor	 eax, eax
  00397	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039f	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 153  :         regs->psw.asc      = (addr[2] & 0xC0);

  003a6	b8 01 00 00 00	 mov	 eax, 1
  003ab	48 6b c0 02	 imul	 rax, rax, 2
  003af	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  003b7	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003bb	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  003c0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c8	88 41 7b	 mov	 BYTE PTR [rcx+123], al

; 154  :         regs->psw.cc       = (addr[2] & 0x30) >> 4;

  003cb	b8 01 00 00 00	 mov	 eax, 1
  003d0	48 6b c0 02	 imul	 rax, rax, 2
  003d4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  003dc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003e0	83 e0 30	 and	 eax, 48			; 00000030H
  003e3	c1 f8 04	 sar	 eax, 4
  003e6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 155  :         regs->psw.progmask = (addr[2] & 0x0F);

  003f1	b8 01 00 00 00	 mov	 eax, 1
  003f6	48 6b c0 02	 imul	 rax, rax, 2
  003fa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00402	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00406	83 e0 0f	 and	 eax, 15
  00409	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00411	88 41 7d	 mov	 BYTE PTR [rcx+125], al

; 156  :         regs->psw.amode    = (addr[4] & 0x80) ? 1 : 0;

  00414	b8 01 00 00 00	 mov	 eax, 1
  00419	48 6b c0 04	 imul	 rax, rax, 4
  0041d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00425	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00429	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0042e	85 c0		 test	 eax, eax
  00430	74 0a		 je	 SHORT $LN86@s390_load_
  00432	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv248[rsp], 1
  0043a	eb 08		 jmp	 SHORT $LN87@s390_load_
$LN86@s390_load_:
  0043c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv248[rsp], 0
$LN87@s390_load_:
  00444	8b 44 24 78	 mov	 eax, DWORD PTR tv248[rsp]
  00448	83 e0 01	 and	 eax, 1
  0044b	d1 e0		 shl	 eax, 1
  0044d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00455	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  0045b	83 e1 fd	 and	 ecx, -3			; fffffffdH
  0045e	0b c8		 or	 ecx, eax
  00460	8b c1		 mov	 eax, ecx
  00462	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 157  : 
; 158  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 159  :         regs->psw.zerobyte = addr[3] & 0xFE;
; 160  :         regs->psw.amode64  = addr[3] & 0x01;
; 161  :         regs->psw.zeroword = fetch_fw(addr+4) & 0x7FFFFFFF;
; 162  :         regs->psw.IA       = fetch_dw (addr + 8);
; 163  :         regs->psw.AMASK    = regs->psw.amode64 ? AMASK64
; 164  :                            : regs->psw.amode   ? AMASK31 : AMASK24;
; 165  : #else
; 166  :         regs->psw.zerobyte = addr[3];

  00470	b8 01 00 00 00	 mov	 eax, 1
  00475	48 6b c0 03	 imul	 rax, rax, 3
  00479	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00481	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00489	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  0048d	88 41 7e	 mov	 BYTE PTR [rcx+126], al

; 167  :         regs->psw.amode64  = 0;

  00490	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00498	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0049e	83 e0 fe	 and	 eax, -2			; fffffffeH
  004a1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a9	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 168  :         regs->psw.IA       = fetch_fw(addr + 4) & 0x7FFFFFFF;

  004af	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  004b7	48 83 c0 04	 add	 rax, 4
  004bb	48 8b c8	 mov	 rcx, rax
  004be	e8 00 00 00 00	 call	 fetch_fw_noswap
  004c3	8b c8		 mov	 ecx, eax
  004c5	e8 00 00 00 00	 call	 _byteswap_ulong
  004ca	0f ba f0 1f	 btr	 eax, 31
  004ce	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d6	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 169  :         regs->psw.AMASK    = regs->psw.amode ? AMASK31 : AMASK24;

  004dc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004ea	d1 e8		 shr	 eax, 1
  004ec	83 e0 01	 and	 eax, 1
  004ef	85 c0		 test	 eax, eax
  004f1	74 0a		 je	 SHORT $LN88@s390_load_
  004f3	c7 44 24 7c ff
	ff ff 7f	 mov	 DWORD PTR tv272[rsp], 2147483647 ; 7fffffffH
  004fb	eb 08		 jmp	 SHORT $LN89@s390_load_
$LN88@s390_load_:
  004fd	c7 44 24 7c ff
	ff ff 00	 mov	 DWORD PTR tv272[rsp], 16777215 ; 00ffffffH
$LN89@s390_load_:
  00505	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050d	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv272[rsp]
  00511	89 88 90 00 00
	00		 mov	 DWORD PTR [rax+144], ecx

; 170  : #endif
; 171  : 
; 172  :         /* Bits 0 and 2-4 of system mask must be zero */
; 173  :         if ((addr[0] & 0xB8) != 0)

  00517	b8 01 00 00 00	 mov	 eax, 1
  0051c	48 6b c0 00	 imul	 rax, rax, 0
  00520	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00528	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0052c	25 b8 00 00 00	 and	 eax, 184		; 000000b8H
  00531	85 c0		 test	 eax, eax
  00533	74 0a		 je	 SHORT $LN46@s390_load_

; 174  :             return PGM_SPECIFICATION_EXCEPTION;

  00535	b8 06 00 00 00	 mov	 eax, 6
  0053a	e9 f2 08 00 00	 jmp	 $LN1@s390_load_
$LN46@s390_load_:

; 175  : 
; 176  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 177  :         /* For ESAME, bit 12 must be zero */
; 178  :         if (NOTESAME(&regs->psw))
; 179  :             return PGM_SPECIFICATION_EXCEPTION;
; 180  : 
; 181  :         /* Bits 24-30 must be zero */
; 182  :         if (regs->psw.zerobyte)
; 183  :             return PGM_SPECIFICATION_EXCEPTION;
; 184  : 
; 185  :         /* Bits 33-63 must be zero */
; 186  :         if ( regs->psw.zeroword )
; 187  :             return PGM_SPECIFICATION_EXCEPTION;
; 188  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 189  :         /* Bits 24-31 must be zero */
; 190  :         if ( regs->psw.zerobyte )

  0053f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00547	0f b6 40 7e	 movzx	 eax, BYTE PTR [rax+126]
  0054b	85 c0		 test	 eax, eax
  0054d	74 0a		 je	 SHORT $LN47@s390_load_

; 191  :             return PGM_SPECIFICATION_EXCEPTION;

  0054f	b8 06 00 00 00	 mov	 eax, 6
  00554	e9 d8 08 00 00	 jmp	 $LN1@s390_load_
$LN47@s390_load_:

; 192  : 
; 193  :         /* For ESA/390, bit 12 must be one */
; 194  :         if (!ECMODE(&regs->psw))

  00559	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00561	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00565	83 e0 08	 and	 eax, 8
  00568	85 c0		 test	 eax, eax
  0056a	75 0a		 jne	 SHORT $LN48@s390_load_

; 195  :             return PGM_SPECIFICATION_EXCEPTION;

  0056c	b8 06 00 00 00	 mov	 eax, 6
  00571	e9 bb 08 00 00	 jmp	 $LN1@s390_load_
$LN48@s390_load_:

; 196  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 197  : 
; 198  : #ifndef FEATURE_DUAL_ADDRESS_SPACE
; 199  :         /* If DAS feature not installed then bit 16 must be zero */
; 200  :         if (SPACE_BIT(&regs->psw))
; 201  :             return PGM_SPECIFICATION_EXCEPTION;
; 202  : #endif
; 203  : 
; 204  : #ifndef FEATURE_ACCESS_REGISTERS
; 205  :         /* If not ESA/370 or ESA/390 then bit 17 must be zero */
; 206  :         if (AR_BIT(&regs->psw))
; 207  :             return PGM_SPECIFICATION_EXCEPTION;
; 208  : #endif
; 209  : 
; 210  :         /* Check validity of amode and instruction address */
; 211  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 212  :         /* For ESAME, bit 32 cannot be zero if bit 31 is one */
; 213  :         if (regs->psw.amode64 && !regs->psw.amode)
; 214  :             return PGM_SPECIFICATION_EXCEPTION;
; 215  : 
; 216  :         /* If bit 32 is zero then IA cannot exceed 24 bits */
; 217  :         if (!regs->psw.amode && regs->psw.IA > 0x00FFFFFF)
; 218  :             return PGM_SPECIFICATION_EXCEPTION;
; 219  : 
; 220  :         /* If bit 31 is zero then IA cannot exceed 31 bits */
; 221  :         if (!regs->psw.amode64 && regs->psw.IA > 0x7FFFFFFF)
; 222  :             return PGM_SPECIFICATION_EXCEPTION;
; 223  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 224  :   #ifdef FEATURE_BIMODAL_ADDRESSING
; 225  :         /* For 370-XA, ESA/370, and ESA/390,
; 226  :            if amode=24, bits 33-39 must be zero */
; 227  :         if (!regs->psw.amode && regs->psw.IA > 0x00FFFFFF)

  00576	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00584	d1 e8		 shr	 eax, 1
  00586	83 e0 01	 and	 eax, 1
  00589	85 c0		 test	 eax, eax
  0058b	75 1e		 jne	 SHORT $LN49@s390_load_
  0058d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00595	81 b8 88 00 00
	00 ff ff ff 00	 cmp	 DWORD PTR [rax+136], 16777215 ; 00ffffffH
  0059f	76 0a		 jbe	 SHORT $LN49@s390_load_

; 228  :             return PGM_SPECIFICATION_EXCEPTION;

  005a1	b8 06 00 00 00	 mov	 eax, 6
  005a6	e9 86 08 00 00	 jmp	 $LN1@s390_load_
$LN49@s390_load_:

; 229  :   #else
; 230  :         /* For S/370, bits 32-39 must be zero */
; 231  :         if (addr[4] != 0x00)
; 232  :             return PGM_SPECIFICATION_EXCEPTION;
; 233  :   #endif
; 234  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 235  : 
; 236  : #if defined( FEATURE_BCMODE )
; 237  :     } else {
; 238  : 
; 239  :         SET_IC_BCMODE_MASK(regs);
; 240  : 
; 241  :         /* Processing for S/370 BC mode PSW */
; 242  :         regs->psw.intcode = fetch_hw (addr + 2);
; 243  :         regs->psw.cc = (addr[4] & 0x30) >> 4;
; 244  :         regs->psw.progmask = (addr[4] & 0x0F);
; 245  : 
; 246  :         FETCH_FW(regs->psw.IA, addr + 4);
; 247  :         regs->psw.IA &= 0x00FFFFFF;
; 248  :         regs->psw.AMASK = AMASK24;
; 249  : 
; 250  :         regs->psw.zerobyte = 0;
; 251  :         regs->psw.asc = 0;
; 252  :         regs->psw.amode64 = regs->psw.amode = 0;
; 253  :     }
; 254  : #endif /* defined( FEATURE_BCMODE ) */
; 255  : 
; 256  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 257  :     /* Bits 5 and 16 must be zero in XC mode */
; 258  :     if( SIE_STATE_BIT_ON(regs, MX, XC)
; 259  :       && ( (regs->psw.sysmask & PSW_DATMODE) || SPACE_BIT(&regs->psw)) )

  005ab	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b3	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  005b9	d1 e8		 shr	 eax, 1
  005bb	83 e0 01	 and	 eax, 1
  005be	85 c0		 test	 eax, eax
  005c0	74 4c		 je	 SHORT $LN50@s390_load_
  005c2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ca	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  005d1	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  005d5	83 e0 01	 and	 eax, 1
  005d8	85 c0		 test	 eax, eax
  005da	74 32		 je	 SHORT $LN50@s390_load_
  005dc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e4	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  005e8	83 e0 04	 and	 eax, 4
  005eb	85 c0		 test	 eax, eax
  005ed	75 15		 jne	 SHORT $LN51@s390_load_
  005ef	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005fb	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00600	85 c0		 test	 eax, eax
  00602	74 0a		 je	 SHORT $LN50@s390_load_
$LN51@s390_load_:

; 260  :         return PGM_SPECIFICATION_EXCEPTION;

  00604	b8 06 00 00 00	 mov	 eax, 6
  00609	e9 23 08 00 00	 jmp	 $LN1@s390_load_
$LN50@s390_load_:

; 261  : #endif
; 262  : 
; 263  :     regs->psw.zeroilc = 0;

  0060e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00616	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0061c	83 e0 fb	 and	 eax, -5			; fffffffbH
  0061f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00627	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 264  : 
; 265  :     /* Check for wait state PSW */
; 266  :     if (1
; 267  :         && WAITSTATE( &regs->psw )
; 268  :         && CPU_STEPPING_OR_TRACING_ALL
; 269  :         && !TXF_INSTR_TRACING()

  0062d	33 c0		 xor	 eax, eax
  0062f	83 f8 01	 cmp	 eax, 1
  00632	0f 84 d1 01 00
	00		 je	 $LN52@s390_load_
  00638	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00640	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00644	83 e0 02	 and	 eax, 2
  00647	85 c0		 test	 eax, eax
  00649	0f 84 ba 01 00
	00		 je	 $LN52@s390_load_
  0064f	b8 08 00 00 00	 mov	 eax, 8
  00654	48 6b c0 00	 imul	 rax, rax, 0
  00658	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0065f	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00668	75 32		 jne	 SHORT $LN54@s390_load_
  0066a	b8 08 00 00 00	 mov	 eax, 8
  0066f	48 6b c0 01	 imul	 rax, rax, 1
  00673	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0067a	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00683	75 17		 jne	 SHORT $LN54@s390_load_
  00685	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0068c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00692	c1 e8 0a	 shr	 eax, 10
  00695	83 e0 01	 and	 eax, 1
  00698	85 c0		 test	 eax, eax
  0069a	75 4e		 jne	 SHORT $LN53@s390_load_
$LN54@s390_load_:
  0069c	b8 08 00 00 00	 mov	 eax, 8
  006a1	48 6b c0 00	 imul	 rax, rax, 0
  006a5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006ac	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  006b5	0f 85 4e 01 00
	00		 jne	 $LN52@s390_load_
  006bb	b8 08 00 00 00	 mov	 eax, 8
  006c0	48 6b c0 01	 imul	 rax, rax, 1
  006c4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006cb	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  006d4	0f 85 2f 01 00
	00		 jne	 $LN52@s390_load_
  006da	e8 00 00 00 00	 call	 insttrace_all
  006df	0f b6 c0	 movzx	 eax, al
  006e2	85 c0		 test	 eax, eax
  006e4	0f 84 1f 01 00
	00		 je	 $LN52@s390_load_
$LN53@s390_load_:
  006ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006f1	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  006f7	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  006fc	85 c0		 test	 eax, eax
  006fe	0f 85 05 01 00
	00		 jne	 $LN52@s390_load_

; 270  :     )
; 271  :     {
; 272  :         if (regs->insttrace && sysblk.traceFILE)

  00704	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070c	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00712	c1 e8 0f	 shr	 eax, 15
  00715	83 e0 01	 and	 eax, 1
  00718	85 c0		 test	 eax, eax
  0071a	74 24		 je	 SHORT $LN55@s390_load_
  0071c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00723	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0072b	74 13		 je	 SHORT $LN55@s390_load_

; 273  :             tf_0800( regs );

  0072d	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00735	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0800
  0073b	e9 c9 00 00 00	 jmp	 $LN56@s390_load_
$LN55@s390_load_:

; 274  :         else
; 275  :         {
; 276  :             char buf[40];
; 277  :             STR_PSW( regs, buf );

  00740	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00746	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buf$4[rsp]
  0074e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00756	e8 00 00 00 00	 call	 str_psw

; 278  :             // "Processor %s%02X: loaded wait state PSW %s"
; 279  :             WRMSG( HHC00800, "I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );

  0075b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00763	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  0076a	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv354[rsp], eax
  00771	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00779	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00780	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00787	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  0078f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00795	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
  0079d	b9 01 00 00 00	 mov	 ecx, 1
  007a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007a8	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  007b0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007b5	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv354[rsp]
  007bc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  007c0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv356[rsp]
  007c8	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  007cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181083
  007d4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181084
  007e0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007ea	41 b9 03 00 00
	00		 mov	 r9d, 3
  007f0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG181085
  007f7	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  007fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG181086
  00803	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@s390_load_:
$LN52@s390_load_:
$LN13@s390_load_:

; 280  :         }
; 281  :     }
; 282  : 
; 283  :     TEST_SET_AEA_MODE(regs);

  00809	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00811	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00815	83 e0 04	 and	 eax, 4
  00818	85 c0		 test	 eax, eax
  0081a	75 6c		 jne	 SHORT $LN92@s390_load_
  0081c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00824	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0082a	d1 e8		 shr	 eax, 1
  0082c	83 e0 01	 and	 eax, 1
  0082f	85 c0		 test	 eax, eax
  00831	74 3a		 je	 SHORT $LN90@s390_load_
  00833	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0083b	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00842	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00846	83 e0 01	 and	 eax, 1
  00849	85 c0		 test	 eax, eax
  0084b	74 20		 je	 SHORT $LN90@s390_load_
  0084d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00855	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00859	83 e0 40	 and	 eax, 64			; 00000040H
  0085c	85 c0		 test	 eax, eax
  0085e	74 0d		 je	 SHORT $LN90@s390_load_
  00860	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv392[rsp], 2
  0086b	eb 0b		 jmp	 SHORT $LN91@s390_load_
$LN90@s390_load_:
  0086d	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv392[rsp], 0
$LN91@s390_load_:
  00878	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv392[rsp]
  0087f	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv397[rsp], eax
  00886	eb 18		 jmp	 SHORT $LN93@s390_load_
$LN92@s390_load_:
  00888	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00890	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00894	c1 f8 06	 sar	 eax, 6
  00897	ff c0		 inc	 eax
  00899	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv397[rsp], eax
$LN93@s390_load_:
  008a0	33 c0		 xor	 eax, eax
  008a2	85 c0		 test	 eax, eax
  008a4	75 51		 jne	 SHORT $LN94@s390_load_
  008a6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ae	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  008b2	83 e0 40	 and	 eax, 64			; 00000040H
  008b5	85 c0		 test	 eax, eax
  008b7	75 3e		 jne	 SHORT $LN94@s390_load_
  008b9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c1	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  008c7	d1 e8		 shr	 eax, 1
  008c9	83 e0 01	 and	 eax, 1
  008cc	85 c0		 test	 eax, eax
  008ce	74 1a		 je	 SHORT $LN95@s390_load_
  008d0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d8	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  008df	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  008e3	83 e0 01	 and	 eax, 1
  008e6	85 c0		 test	 eax, eax
  008e8	75 0d		 jne	 SHORT $LN94@s390_load_
$LN95@s390_load_:
  008ea	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv412[rsp], 0
  008f5	eb 0b		 jmp	 SHORT $LN96@s390_load_
$LN94@s390_load_:
  008f7	c7 84 24 84 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv412[rsp], 64 ; 00000040H
$LN96@s390_load_:
  00902	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0090a	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00911	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv412[rsp]
  00918	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR tv397[rsp]
  0091f	0b d1		 or	 edx, ecx
  00921	8b ca		 mov	 ecx, edx
  00923	3b c1		 cmp	 eax, ecx
  00925	0f 84 fa 04 00
	00		 je	 $LN57@s390_load_
$LN16@s390_load_:
  0092b	b8 04 00 00 00	 mov	 eax, 4
  00930	48 6b c0 04	 imul	 rax, rax, 4
  00934	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093c	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00943	89 84 24 a0 00
	00 00		 mov	 DWORD PTR inst_cr$3[rsp], eax
  0094a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00952	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00959	88 44 24 54	 mov	 BYTE PTR oldmode$2[rsp], al
  0095d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00965	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00969	83 e0 04	 and	 eax, 4
  0096c	85 c0		 test	 eax, eax
  0096e	75 6c		 jne	 SHORT $LN99@s390_load_
  00970	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00978	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0097e	d1 e8		 shr	 eax, 1
  00980	83 e0 01	 and	 eax, 1
  00983	85 c0		 test	 eax, eax
  00985	74 3a		 je	 SHORT $LN97@s390_load_
  00987	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0098f	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00996	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  0099a	83 e0 01	 and	 eax, 1
  0099d	85 c0		 test	 eax, eax
  0099f	74 20		 je	 SHORT $LN97@s390_load_
  009a1	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009a9	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  009ad	83 e0 40	 and	 eax, 64			; 00000040H
  009b0	85 c0		 test	 eax, eax
  009b2	74 0d		 je	 SHORT $LN97@s390_load_
  009b4	c7 84 24 8c 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv437[rsp], 2
  009bf	eb 0b		 jmp	 SHORT $LN98@s390_load_
$LN97@s390_load_:
  009c1	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv437[rsp], 0
$LN98@s390_load_:
  009cc	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv437[rsp]
  009d3	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv442[rsp], eax
  009da	eb 18		 jmp	 SHORT $LN100@s390_load_
$LN99@s390_load_:
  009dc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  009e8	c1 f8 06	 sar	 eax, 6
  009eb	ff c0		 inc	 eax
  009ed	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv442[rsp], eax
$LN100@s390_load_:
  009f4	33 c0		 xor	 eax, eax
  009f6	85 c0		 test	 eax, eax
  009f8	75 51		 jne	 SHORT $LN101@s390_load_
  009fa	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a02	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00a06	83 e0 40	 and	 eax, 64			; 00000040H
  00a09	85 c0		 test	 eax, eax
  00a0b	75 3e		 jne	 SHORT $LN101@s390_load_
  00a0d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a15	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00a1b	d1 e8		 shr	 eax, 1
  00a1d	83 e0 01	 and	 eax, 1
  00a20	85 c0		 test	 eax, eax
  00a22	74 1a		 je	 SHORT $LN102@s390_load_
  00a24	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a2c	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00a33	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00a37	83 e0 01	 and	 eax, 1
  00a3a	85 c0		 test	 eax, eax
  00a3c	75 0d		 jne	 SHORT $LN101@s390_load_
$LN102@s390_load_:
  00a3e	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv457[rsp], 0
  00a49	eb 0b		 jmp	 SHORT $LN103@s390_load_
$LN101@s390_load_:
  00a4b	c7 84 24 90 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv457[rsp], 64 ; 00000040H
$LN103@s390_load_:
  00a56	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv457[rsp]
  00a5d	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv442[rsp]
  00a64	0b c8		 or	 ecx, eax
  00a66	8b c1		 mov	 eax, ecx
  00a68	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a70	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00a76	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a7e	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00a85	83 e0 0f	 and	 eax, 15
  00a88	89 44 24 58	 mov	 DWORD PTR tv463[rsp], eax
  00a8c	83 7c 24 58 01	 cmp	 DWORD PTR tv463[rsp], 1
  00a91	74 22		 je	 SHORT $LN58@s390_load_
  00a93	83 7c 24 58 02	 cmp	 DWORD PTR tv463[rsp], 2
  00a98	74 59		 je	 SHORT $LN59@s390_load_
  00a9a	83 7c 24 58 03	 cmp	 DWORD PTR tv463[rsp], 3
  00a9f	0f 84 11 01 00
	00		 je	 $LN63@s390_load_
  00aa5	83 7c 24 58 04	 cmp	 DWORD PTR tv463[rsp], 4
  00aaa	0f 84 5d 01 00
	00		 je	 $LN64@s390_load_
  00ab0	e9 93 01 00 00	 jmp	 $LN65@s390_load_
$LN58@s390_load_:
  00ab5	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00abd	eb 0a		 jmp	 SHORT $LN21@s390_load_
$LN19@s390_load_:
  00abf	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00ac3	ff c0		 inc	 eax
  00ac5	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN21@s390_load_:
  00ac9	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00ace	7d 1e		 jge	 SHORT $LN20@s390_load_
  00ad0	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00ad4	83 c0 05	 add	 eax, 5
  00ad7	48 98		 cdqe
  00ad9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ae1	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00aec	eb d1		 jmp	 SHORT $LN19@s390_load_
$LN20@s390_load_:
  00aee	e9 8e 01 00 00	 jmp	 $LN17@s390_load_
$LN59@s390_load_:
  00af3	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00afb	eb 0a		 jmp	 SHORT $LN24@s390_load_
$LN22@s390_load_:
  00afd	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00b01	ff c0		 inc	 eax
  00b03	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN24@s390_load_:
  00b07	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00b0c	7d 1e		 jge	 SHORT $LN23@s390_load_
  00b0e	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00b12	83 c0 05	 add	 eax, 5
  00b15	48 98		 cdqe
  00b17	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b1f	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00b2a	eb d1		 jmp	 SHORT $LN22@s390_load_
$LN23@s390_load_:
  00b2c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00b34	eb 0a		 jmp	 SHORT $LN27@s390_load_
$LN25@s390_load_:
  00b36	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00b3a	ff c0		 inc	 eax
  00b3c	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN27@s390_load_:
  00b40	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00b45	7d 6a		 jge	 SHORT $LN26@s390_load_
  00b47	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00b4c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b54	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00b5c	75 1e		 jne	 SHORT $LN60@s390_load_
  00b5e	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00b62	83 c0 05	 add	 eax, 5
  00b65	48 98		 cdqe
  00b67	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b6f	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00b7a	eb 33		 jmp	 SHORT $LN61@s390_load_
$LN60@s390_load_:
  00b7c	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$1[rsp]
  00b81	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b89	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00b91	74 1c		 je	 SHORT $LN62@s390_load_
  00b93	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00b97	83 c0 05	 add	 eax, 5
  00b9a	48 98		 cdqe
  00b9c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ba4	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN62@s390_load_:
$LN61@s390_load_:
  00baf	eb 85		 jmp	 SHORT $LN25@s390_load_
$LN26@s390_load_:
  00bb1	e9 cb 00 00 00	 jmp	 $LN17@s390_load_
$LN63@s390_load_:
  00bb6	b8 04 00 00 00	 mov	 eax, 4
  00bbb	48 6b c0 04	 imul	 rax, rax, 4
  00bbf	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bc7	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00bd2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00bda	eb 0a		 jmp	 SHORT $LN30@s390_load_
$LN28@s390_load_:
  00bdc	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00be0	ff c0		 inc	 eax
  00be2	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN30@s390_load_:
  00be6	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00beb	7d 1e		 jge	 SHORT $LN29@s390_load_
  00bed	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00bf1	83 c0 05	 add	 eax, 5
  00bf4	48 98		 cdqe
  00bf6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bfe	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00c09	eb d1		 jmp	 SHORT $LN28@s390_load_
$LN29@s390_load_:
  00c0b	eb 74		 jmp	 SHORT $LN17@s390_load_
$LN64@s390_load_:
  00c0d	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00c15	eb 0a		 jmp	 SHORT $LN33@s390_load_
$LN31@s390_load_:
  00c17	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00c1b	ff c0		 inc	 eax
  00c1d	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN33@s390_load_:
  00c21	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00c26	7d 1e		 jge	 SHORT $LN32@s390_load_
  00c28	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00c2c	83 c0 05	 add	 eax, 5
  00c2f	48 98		 cdqe
  00c31	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c39	c7 84 81 94 0c
	00 00 0d 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 13
  00c44	eb d1		 jmp	 SHORT $LN31@s390_load_
$LN32@s390_load_:
  00c46	eb 39		 jmp	 SHORT $LN17@s390_load_
$LN65@s390_load_:
  00c48	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00c50	eb 0a		 jmp	 SHORT $LN36@s390_load_
$LN34@s390_load_:
  00c52	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00c56	ff c0		 inc	 eax
  00c58	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN36@s390_load_:
  00c5c	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00c61	7d 1e		 jge	 SHORT $LN35@s390_load_
  00c63	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00c67	83 c0 05	 add	 eax, 5
  00c6a	48 98		 cdqe
  00c6c	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c74	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  00c7f	eb d1		 jmp	 SHORT $LN34@s390_load_
$LN35@s390_load_:
$LN17@s390_load_:
  00c81	b8 04 00 00 00	 mov	 eax, 4
  00c86	48 6b c0 04	 imul	 rax, rax, 4
  00c8a	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c92	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00c99	39 84 24 a0 00
	00 00		 cmp	 DWORD PTR inst_cr$3[rsp], eax
  00ca0	74 79		 je	 SHORT $LN66@s390_load_
$LN39@s390_load_:
  00ca2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00caa	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00cb2	74 61		 je	 SHORT $LN67@s390_load_
  00cb4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cbc	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00cc2	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cca	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00cd2	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00cd9	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00cdd	48 2b ca	 sub	 rcx, rdx
  00ce0	48 03 c1	 add	 rax, rcx
  00ce3	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ceb	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00cf1	48 23 c1	 and	 rax, rcx
  00cf4	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cfc	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00d02	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d0a	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN67@s390_load_:
  00d15	33 c0		 xor	 eax, eax
  00d17	85 c0		 test	 eax, eax
  00d19	75 87		 jne	 SHORT $LN39@s390_load_
$LN66@s390_load_:
  00d1b	0f b6 44 24 54	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  00d20	83 e0 40	 and	 eax, 64			; 00000040H
  00d23	85 c0		 test	 eax, eax
  00d25	0f 85 f0 00 00
	00		 jne	 $LN68@s390_load_
  00d2b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d33	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00d3a	83 e0 40	 and	 eax, 64			; 00000040H
  00d3d	85 c0		 test	 eax, eax
  00d3f	0f 84 d6 00 00
	00		 je	 $LN68@s390_load_
$LN42@s390_load_:
  00d45	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d4d	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00d55	74 61		 je	 SHORT $LN69@s390_load_
  00d57	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d5f	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00d65	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d6d	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d75	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00d7c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00d80	48 2b ca	 sub	 rcx, rdx
  00d83	48 03 c1	 add	 rax, rcx
  00d86	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d8e	8b 89 90 00 00
	00		 mov	 ecx, DWORD PTR [rcx+144]
  00d94	48 23 c1	 and	 rax, rcx
  00d97	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d9f	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00da5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dad	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN69@s390_load_:
  00db8	33 c0		 xor	 eax, eax
  00dba	85 c0		 test	 eax, eax
  00dbc	75 87		 jne	 SHORT $LN42@s390_load_
  00dbe	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dc6	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00dcc	c1 e8 02	 shr	 eax, 2
  00dcf	83 e0 01	 and	 eax, 1
  00dd2	85 c0		 test	 eax, eax
  00dd4	74 0d		 je	 SHORT $LN106@s390_load_
  00dd6	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv579[rsp], 1
  00de1	eb 0b		 jmp	 SHORT $LN107@s390_load_
$LN106@s390_load_:
  00de3	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv579[rsp], 0
$LN107@s390_load_:
  00dee	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv579[rsp], 0
  00df6	74 23		 je	 SHORT $LN70@s390_load_
  00df8	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e00	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00e03	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  00e08	85 c0		 test	 eax, eax
  00e0a	74 0f		 je	 SHORT $LN70@s390_load_
  00e0c	b2 fc		 mov	 dl, 252			; 000000fcH
  00e0e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e16	e8 00 00 00 00	 call	 s390_invalidate_tlb
$LN70@s390_load_:
$LN68@s390_load_:
  00e1b	33 c0		 xor	 eax, eax
  00e1d	85 c0		 test	 eax, eax
  00e1f	0f 85 06 fb ff
	ff		 jne	 $LN16@s390_load_
$LN57@s390_load_:
  00e25	33 c0		 xor	 eax, eax
  00e27	85 c0		 test	 eax, eax
  00e29	0f 85 da f9 ff
	ff		 jne	 $LN13@s390_load_

; 284  : 
; 285  :     return 0;

  00e2f	33 c0		 xor	 eax, eax
$LN1@s390_load_:

; 286  : } /* end function ARCH_DEP(load_psw) */

  00e31	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00e39	48 33 cc	 xor	 rcx, rsp
  00e3c	e8 00 00 00 00	 call	 __security_check_cookie
  00e41	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00e48	c3		 ret	 0
s390_load_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
shouldtrace$ = 32
tv217 = 36
tv219 = 40
tv338 = 44
hostregs$1 = 48
saved_timer$2 = 56
regs$ = 96
dest$ = 104
s370_process_trace PROC

; 2172 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 2173 :     bool shouldtrace = false;           /* true == Trace instruction */

  0000f	c6 44 24 20 00	 mov	 BYTE PTR shouldtrace$[rsp], 0

; 2174 : 
; 2175 :     /* Test for trace */
; 2176 :     shouldtrace = CPU_TRACING( regs, 0 );

  00014	33 c0		 xor	 eax, eax
  00016	83 f8 01	 cmp	 eax, 1
  00019	0f 84 29 03 00
	00		 je	 $LN11@s370_proce
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00026	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002c	c1 e8 08	 shr	 eax, 8
  0002f	83 e0 01	 and	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	0f 84 0e 03 00
	00		 je	 $LN11@s370_proce
  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00045	c1 e8 0f	 shr	 eax, 15
  00048	83 e0 01	 and	 eax, 1
  0004b	85 c0		 test	 eax, eax
  0004d	0f 84 f5 02 00
	00		 je	 $LN11@s370_proce
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	0f 85 17 01 00
	00		 jne	 $LN12@s370_proce
  0005d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00064	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0006a	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0006f	85 c0		 test	 eax, eax
  00071	0f 84 fd 00 00
	00		 je	 $LN12@s370_proce
  00077	33 c0		 xor	 eax, eax
  00079	83 f8 01	 cmp	 eax, 1
  0007c	0f 84 c6 02 00
	00		 je	 $LN14@s370_proce
  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 34		 jne	 SHORT $LN13@s370_proce
  00088	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008f	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00095	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  0009a	85 c0		 test	 eax, eax
  0009c	74 1e		 je	 SHORT $LN13@s370_proce
  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000aa	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  000b0	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  000b6	0f 85 8c 02 00
	00		 jne	 $LN14@s370_proce
$LN13@s370_proce:
  000bc	33 c0		 xor	 eax, eax
  000be	85 c0		 test	 eax, eax
  000c0	75 34		 jne	 SHORT $LN15@s370_proce
  000c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000c9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  000cf	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  000d4	85 c0		 test	 eax, eax
  000d6	74 1e		 je	 SHORT $LN15@s370_proce
  000d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  000dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e4	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  000ea	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  000f0	0f 8c 52 02 00
	00		 jl	 $LN14@s370_proce
$LN15@s370_proce:
  000f6	33 c0		 xor	 eax, eax
  000f8	85 c0		 test	 eax, eax
  000fa	75 78		 jne	 SHORT $LN17@s370_proce
  000fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00103	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00109	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  0010e	85 c0		 test	 eax, eax
  00110	74 20		 je	 SHORT $LN16@s370_proce
  00112	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00117	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN16@s370_proce
  00122	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00127	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0012e	85 c0		 test	 eax, eax
  00130	75 42		 jne	 SHORT $LN17@s370_proce
$LN16@s370_proce:
  00132	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00139	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  0013f	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  00144	85 c0		 test	 eax, eax
  00146	0f 84 fc 01 00
	00		 je	 $LN18@s370_proce
  0014c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00151	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00158	85 c0		 test	 eax, eax
  0015a	0f 84 e8 01 00
	00		 je	 $LN18@s370_proce
  00160	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00165	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  0016c	85 c0		 test	 eax, eax
  0016e	0f 85 d4 01 00
	00		 jne	 $LN11@s370_proce
$LN12@s370_proce:
$LN17@s370_proce:
  00174	b8 08 00 00 00	 mov	 eax, 8
  00179	48 6b c0 00	 imul	 rax, rax, 0
  0017d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00184	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  0018d	75 1f		 jne	 SHORT $LN19@s370_proce
  0018f	b8 08 00 00 00	 mov	 eax, 8
  00194	48 6b c0 01	 imul	 rax, rax, 1
  00198	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0019f	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  001a8	0f 84 90 01 00
	00		 je	 $LN21@s370_proce
$LN19@s370_proce:
  001ae	b8 08 00 00 00	 mov	 eax, 8
  001b3	48 6b c0 00	 imul	 rax, rax, 0
  001b7	b9 08 00 00 00	 mov	 ecx, 8
  001bc	48 6b c9 01	 imul	 rcx, rcx, 1
  001c0	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  001c7	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  001ce	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  001d6	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  001de	0f 87 94 00 00
	00		 ja	 $LN20@s370_proce
  001e4	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  001e9	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  001ef	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  001f4	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  001f9	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00200	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00204	48 2b ca	 sub	 rcx, rdx
  00207	48 03 c1	 add	 rax, rcx
  0020a	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00210	8b c0		 mov	 eax, eax
  00212	b9 08 00 00 00	 mov	 ecx, 8
  00217	48 6b c9 00	 imul	 rcx, rcx, 0
  0021b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00222	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0022a	72 4c		 jb	 SHORT $LN20@s370_proce
  0022c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00231	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00237	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0023c	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00241	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00248	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0024c	48 2b ca	 sub	 rcx, rdx
  0024f	48 03 c1	 add	 rax, rcx
  00252	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00258	8b c0		 mov	 eax, eax
  0025a	b9 08 00 00 00	 mov	 ecx, 8
  0025f	48 6b c9 01	 imul	 rcx, rcx, 1
  00263	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0026a	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  00272	0f 86 c6 00 00
	00		 jbe	 $LN21@s370_proce
$LN20@s370_proce:
  00278	b8 08 00 00 00	 mov	 eax, 8
  0027d	48 6b c0 00	 imul	 rax, rax, 0
  00281	b9 08 00 00 00	 mov	 ecx, 8
  00286	48 6b c9 01	 imul	 rcx, rcx, 1
  0028a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00291	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00298	49 8b 8c 08 d8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4824]
  002a0	48 39 8c 02 d8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4824], rcx
  002a8	0f 86 9a 00 00
	00		 jbe	 $LN22@s370_proce
  002ae	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  002b3	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  002b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  002be	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  002c3	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  002ca	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  002ce	48 2b ca	 sub	 rcx, rdx
  002d1	48 03 c1	 add	 rax, rcx
  002d4	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  002da	8b c0		 mov	 eax, eax
  002dc	b9 08 00 00 00	 mov	 ecx, 8
  002e1	48 6b c9 01	 imul	 rcx, rcx, 1
  002e5	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  002ec	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  002f4	72 52		 jb	 SHORT $LN22@s370_proce
  002f6	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  002fb	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00301	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00306	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0030b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00312	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00316	48 2b ca	 sub	 rcx, rdx
  00319	48 03 c1	 add	 rax, rcx
  0031c	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00322	8b c0		 mov	 eax, eax
  00324	b9 08 00 00 00	 mov	 ecx, 8
  00329	48 6b c9 00	 imul	 rcx, rcx, 0
  0032d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00334	48 3b 84 0a d8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4824]
  0033c	77 0a		 ja	 SHORT $LN11@s370_proce
$LN21@s370_proce:
  0033e	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv217[rsp], 1
  00346	eb 08		 jmp	 SHORT $LN23@s370_proce
$LN11@s370_proce:
$LN22@s370_proce:
$LN14@s370_proce:
$LN18@s370_proce:
  00348	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv217[rsp], 0
$LN23@s370_proce:
  00350	83 7c 24 24 00	 cmp	 DWORD PTR tv217[rsp], 0
  00355	75 0a		 jne	 SHORT $LN24@s370_proce
  00357	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
  0035f	eb 08		 jmp	 SHORT $LN25@s370_proce
$LN24@s370_proce:
  00361	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv219[rsp], 1
$LN25@s370_proce:
  00369	0f b6 44 24 28	 movzx	 eax, BYTE PTR tv219[rsp]
  0036e	88 44 24 20	 mov	 BYTE PTR shouldtrace$[rsp], al

; 2177 : 
; 2178 :     /* Test for step */
; 2179 :     regs->stepping = CPU_STEPPING( regs, 0 );

  00372	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00379	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0037f	c1 e8 0a	 shr	 eax, 10
  00382	83 e0 01	 and	 eax, 1
  00385	85 c0		 test	 eax, eax
  00387	0f 84 f5 02 00
	00		 je	 $LN33@s370_proce
  0038d	33 c0		 xor	 eax, eax
  0038f	85 c0		 test	 eax, eax
  00391	0f 85 17 01 00
	00		 jne	 $LN26@s370_proce
  00397	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0039e	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  003a4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  003a9	85 c0		 test	 eax, eax
  003ab	0f 84 fd 00 00
	00		 je	 $LN26@s370_proce
  003b1	33 c0		 xor	 eax, eax
  003b3	83 f8 01	 cmp	 eax, 1
  003b6	0f 84 c6 02 00
	00		 je	 $LN28@s370_proce
  003bc	33 c0		 xor	 eax, eax
  003be	85 c0		 test	 eax, eax
  003c0	75 34		 jne	 SHORT $LN27@s370_proce
  003c2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003c9	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  003cf	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  003d4	85 c0		 test	 eax, eax
  003d6	74 1e		 je	 SHORT $LN27@s370_proce
  003d8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  003dd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003e4	8b 89 60 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1376]
  003ea	39 88 b0 af 00
	00		 cmp	 DWORD PTR [rax+44976], ecx
  003f0	0f 85 8c 02 00
	00		 jne	 $LN28@s370_proce
$LN27@s370_proce:
  003f6	33 c0		 xor	 eax, eax
  003f8	85 c0		 test	 eax, eax
  003fa	75 34		 jne	 SHORT $LN29@s370_proce
  003fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00403	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00409	25 00 00 08 00	 and	 eax, 524288		; 00080000H
  0040e	85 c0		 test	 eax, eax
  00410	74 1e		 je	 SHORT $LN29@s370_proce
  00412	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00417	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0041e	8b 89 58 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1368]
  00424	39 88 b4 af 00
	00		 cmp	 DWORD PTR [rax+44980], ecx
  0042a	0f 8c 52 02 00
	00		 jl	 $LN28@s370_proce
$LN29@s370_proce:
  00430	33 c0		 xor	 eax, eax
  00432	85 c0		 test	 eax, eax
  00434	75 78		 jne	 SHORT $LN31@s370_proce
  00436	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0043d	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00443	25 00 00 00 08	 and	 eax, 134217728		; 08000000H
  00448	85 c0		 test	 eax, eax
  0044a	74 20		 je	 SHORT $LN30@s370_proce
  0044c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00451	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00458	85 c0		 test	 eax, eax
  0045a	74 10		 je	 SHORT $LN30@s370_proce
  0045c	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00461	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  00468	85 c0		 test	 eax, eax
  0046a	75 42		 jne	 SHORT $LN31@s370_proce
$LN30@s370_proce:
  0046c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00473	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00479	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0047e	85 c0		 test	 eax, eax
  00480	0f 84 fc 01 00
	00		 je	 $LN32@s370_proce
  00486	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0048b	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00492	85 c0		 test	 eax, eax
  00494	0f 84 e8 01 00
	00		 je	 $LN32@s370_proce
  0049a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0049f	0f b6 80 4c 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3660]
  004a6	85 c0		 test	 eax, eax
  004a8	0f 85 d4 01 00
	00		 jne	 $LN33@s370_proce
$LN26@s370_proce:
$LN31@s370_proce:
  004ae	b8 08 00 00 00	 mov	 eax, 8
  004b3	48 6b c0 00	 imul	 rax, rax, 0
  004b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004be	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  004c7	75 1f		 jne	 SHORT $LN34@s370_proce
  004c9	b8 08 00 00 00	 mov	 eax, 8
  004ce	48 6b c0 01	 imul	 rax, rax, 1
  004d2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004d9	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  004e2	0f 84 90 01 00
	00		 je	 $LN36@s370_proce
$LN34@s370_proce:
  004e8	b8 08 00 00 00	 mov	 eax, 8
  004ed	48 6b c0 00	 imul	 rax, rax, 0
  004f1	b9 08 00 00 00	 mov	 ecx, 8
  004f6	48 6b c9 01	 imul	 rcx, rcx, 1
  004fa	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00501	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  00508	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  00510	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  00518	0f 87 94 00 00
	00		 ja	 $LN35@s370_proce
  0051e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00523	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00529	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  0052e	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00533	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0053a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0053e	48 2b ca	 sub	 rcx, rdx
  00541	48 03 c1	 add	 rax, rcx
  00544	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0054a	8b c0		 mov	 eax, eax
  0054c	b9 08 00 00 00	 mov	 ecx, 8
  00551	48 6b c9 00	 imul	 rcx, rcx, 0
  00555	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0055c	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00564	72 4c		 jb	 SHORT $LN35@s370_proce
  00566	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0056b	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00571	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00576	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  0057b	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00582	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00586	48 2b ca	 sub	 rcx, rdx
  00589	48 03 c1	 add	 rax, rcx
  0058c	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00592	8b c0		 mov	 eax, eax
  00594	b9 08 00 00 00	 mov	 ecx, 8
  00599	48 6b c9 01	 imul	 rcx, rcx, 1
  0059d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005a4	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  005ac	0f 86 c6 00 00
	00		 jbe	 $LN36@s370_proce
$LN35@s370_proce:
  005b2	b8 08 00 00 00	 mov	 eax, 8
  005b7	48 6b c0 00	 imul	 rax, rax, 0
  005bb	b9 08 00 00 00	 mov	 ecx, 8
  005c0	48 6b c9 01	 imul	 rcx, rcx, 1
  005c4	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  005cb	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR __imp_sysblk
  005d2	49 8b 8c 08 c8
	12 00 00	 mov	 rcx, QWORD PTR [r8+rcx+4808]
  005da	48 39 8c 02 c8
	12 00 00	 cmp	 QWORD PTR [rdx+rax+4808], rcx
  005e2	0f 86 9a 00 00
	00		 jbe	 $LN37@s370_proce
  005e8	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  005ed	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  005f3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  005f8	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  005fd	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00604	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00608	48 2b ca	 sub	 rcx, rdx
  0060b	48 03 c1	 add	 rax, rcx
  0060e	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  00614	8b c0		 mov	 eax, eax
  00616	b9 08 00 00 00	 mov	 ecx, 8
  0061b	48 6b c9 01	 imul	 rcx, rcx, 1
  0061f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00626	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  0062e	72 52		 jb	 SHORT $LN37@s370_proce
  00630	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00635	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0063b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00640	48 8b 54 24 60	 mov	 rdx, QWORD PTR regs$[rsp]
  00645	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0064c	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00650	48 2b ca	 sub	 rcx, rdx
  00653	48 03 c1	 add	 rax, rcx
  00656	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0065c	8b c0		 mov	 eax, eax
  0065e	b9 08 00 00 00	 mov	 ecx, 8
  00663	48 6b c9 00	 imul	 rcx, rcx, 0
  00667	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0066e	48 3b 84 0a c8
	12 00 00	 cmp	 rax, QWORD PTR [rdx+rcx+4808]
  00676	77 0a		 ja	 SHORT $LN33@s370_proce
$LN36@s370_proce:
  00678	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv338[rsp], 1
  00680	eb 08		 jmp	 SHORT $LN38@s370_proce
$LN33@s370_proce:
$LN37@s370_proce:
$LN28@s370_proce:
$LN32@s370_proce:
  00682	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
$LN38@s370_proce:
  0068a	8b 44 24 2c	 mov	 eax, DWORD PTR tv338[rsp]
  0068e	83 e0 01	 and	 eax, 1
  00691	c1 e0 11	 shl	 eax, 17
  00694	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00699	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0069f	0f ba f1 11	 btr	 ecx, 17
  006a3	0b c8		 or	 ecx, eax
  006a5	8b c1		 mov	 eax, ecx
  006a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006ac	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2180 : 
; 2181 :     if (regs->stepping)

  006b2	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  006b7	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  006bd	c1 e8 11	 shr	 eax, 17
  006c0	83 e0 01	 and	 eax, 1
  006c3	85 c0		 test	 eax, eax
  006c5	74 54		 je	 SHORT $LN4@s370_proce

; 2182 :     {
; 2183 :         if (sysblk.breakasid)

  006c7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006ce	0f b7 80 c0 12
	00 00		 movzx	 eax, WORD PTR [rax+4800]
  006d5	85 c0		 test	 eax, eax
  006d7	74 42		 je	 SHORT $LN5@s370_proce

; 2184 :         {
; 2185 :             if (regs->CR_LHL(4) != sysblk.breakasid)

  006d9	b8 08 00 00 00	 mov	 eax, 8
  006de	48 6b c0 05	 imul	 rax, rax, 5
  006e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  006e7	0f b7 84 01 00
	06 00 00	 movzx	 eax, WORD PTR [rcx+rax+1536]
  006ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  006f6	0f b7 89 c0 12
	00 00		 movzx	 ecx, WORD PTR [rcx+4800]
  006fd	3b c1		 cmp	 eax, ecx
  006ff	74 1a		 je	 SHORT $LN6@s370_proce

; 2186 :                 regs->stepping = false;

  00701	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00706	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0070c	0f ba f0 11	 btr	 eax, 17
  00710	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00715	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax
$LN6@s370_proce:
$LN5@s370_proce:
$LN4@s370_proce:

; 2187 :         }
; 2188 :     }
; 2189 : 
; 2190 :     /* Display the instruction */
; 2191 :     if (shouldtrace || regs->stepping)

  0071b	0f b6 44 24 20	 movzx	 eax, BYTE PTR shouldtrace$[rsp]
  00720	85 c0		 test	 eax, eax
  00722	75 15		 jne	 SHORT $LN8@s370_proce
  00724	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00729	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0072f	c1 e8 11	 shr	 eax, 17
  00732	83 e0 01	 and	 eax, 1
  00735	85 c0		 test	 eax, eax
  00737	74 0f		 je	 SHORT $LN7@s370_proce
$LN8@s370_proce:

; 2192 :         ARCH_DEP( display_inst )( regs, dest );

  00739	48 8b 54 24 68	 mov	 rdx, QWORD PTR dest$[rsp]
  0073e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  00743	e8 00 00 00 00	 call	 s370_display_inst
$LN7@s370_proce:

; 2193 : 
; 2194 :     /* Stop the CPU if instruction stepping */
; 2195 :     if (regs->stepping)

  00748	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0074d	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00753	c1 e8 11	 shr	 eax, 17
  00756	83 e0 01	 and	 eax, 1
  00759	85 c0		 test	 eax, eax
  0075b	0f 84 e7 01 00
	00		 je	 $LN9@s370_proce

; 2196 :     {
; 2197 :         REGS* hostregs = HOSTREGS;

  00761	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00766	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0076d	48 89 44 24 30	 mov	 QWORD PTR hostregs$1[rsp], rax

; 2198 :         S64 saved_timer[2] = {0};

  00772	48 8d 44 24 38	 lea	 rax, QWORD PTR saved_timer$2[rsp]
  00777	48 8b f8	 mov	 rdi, rax
  0077a	33 c0		 xor	 eax, eax
  0077c	b9 10 00 00 00	 mov	 ecx, 16
  00781	f3 aa		 rep stosb

; 2199 : 
; 2200 :         OBTAIN_INTLOCK( hostregs );

  00783	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170904
  0078a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  0078f	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 2201 :         {
; 2202 :             hostregs->waittod = host_tod();

  00794	e8 00 00 00 00	 call	 host_tod
  00799	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  0079e	48 89 81 b8 07
	00 00		 mov	 QWORD PTR [rcx+1976], rax

; 2203 : 
; 2204 :             /* The CPU timer is not decremented for a CPU that is in
; 2205 :                the manual state (e.g. stopped in single step mode) */
; 2206 : 
; 2207 :             saved_timer[0] = get_cpu_timer( regs     );

  007a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  007aa	e8 00 00 00 00	 call	 get_cpu_timer
  007af	b9 08 00 00 00	 mov	 ecx, 8
  007b4	48 6b c9 00	 imul	 rcx, rcx, 0
  007b8	48 89 44 0c 38	 mov	 QWORD PTR saved_timer$2[rsp+rcx], rax

; 2208 :             saved_timer[1] = get_cpu_timer( hostregs );

  007bd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  007c2	e8 00 00 00 00	 call	 get_cpu_timer
  007c7	b9 08 00 00 00	 mov	 ecx, 8
  007cc	48 6b c9 01	 imul	 rcx, rcx, 1
  007d0	48 89 44 0c 38	 mov	 QWORD PTR saved_timer$2[rsp+rcx], rax

; 2209 : 
; 2210 :             hostregs->cpustate = CPUSTATE_STOPPED;

  007d5	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  007da	c6 40 60 03	 mov	 BYTE PTR [rax+96], 3

; 2211 :             sysblk.started_mask &= ~hostregs->cpubit;

  007de	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  007e3	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  007e7	48 f7 d0	 not	 rax
  007ea	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007f1	48 8b 89 b0 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4784]
  007f8	48 23 c8	 and	 rcx, rax
  007fb	48 8b c1	 mov	 rax, rcx
  007fe	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00805	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2212 :             hostregs->stepwait = 1;

  0080c	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  00811	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00817	0f ba e8 12	 bts	 eax, 18
  0081b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00820	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2213 :             sysblk.intowner = LOCK_OWNER_NONE;

  00826	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  0082b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00832	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN2@s370_proce:

; 2214 : 
; 2215 :             while (hostregs->cpustate == CPUSTATE_STOPPED)

  00839	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0083e	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00842	83 f8 03	 cmp	 eax, 3
  00845	75 2b		 jne	 SHORT $LN3@s370_proce

; 2216 :             {
; 2217 :                 wait_condition( &hostregs->intcond, &sysblk.intlock );

  00847	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0084e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00854	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00859	48 81 c1 80 0c
	00 00		 add	 rcx, 3200		; 00000c80H
  00860	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170905
  00867	48 8b d0	 mov	 rdx, rax
  0086a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 2218 :             }

  00870	eb c7		 jmp	 SHORT $LN2@s370_proce
$LN3@s370_proce:

; 2219 : 
; 2220 :             sysblk.intowner = hostregs->cpuad;

  00872	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00879	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  0087e	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00885	66 89 88 62 10
	00 00		 mov	 WORD PTR [rax+4194], cx

; 2221 :             hostregs->stepwait = 0;

  0088c	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  00891	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00897	0f ba f0 12	 btr	 eax, 18
  0089b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008a0	89 81 28 07 00
	00		 mov	 DWORD PTR [rcx+1832], eax

; 2222 :             sysblk.started_mask |= hostregs->cpubit;

  008a6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008ad	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008b2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  008b6	48 8b 80 b0 12
	00 00		 mov	 rax, QWORD PTR [rax+4784]
  008bd	48 0b c1	 or	 rax, rcx
  008c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  008c7	48 89 81 b0 12
	00 00		 mov	 QWORD PTR [rcx+4784], rax

; 2223 : 
; 2224 :             set_cpu_timer( regs,     saved_timer[0] );

  008ce	b8 08 00 00 00	 mov	 eax, 8
  008d3	48 6b c0 00	 imul	 rax, rax, 0
  008d7	48 8b 54 04 38	 mov	 rdx, QWORD PTR saved_timer$2[rsp+rax]
  008dc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR regs$[rsp]
  008e1	e8 00 00 00 00	 call	 set_cpu_timer

; 2225 :             set_cpu_timer( hostregs, saved_timer[1] );

  008e6	b8 08 00 00 00	 mov	 eax, 8
  008eb	48 6b c0 01	 imul	 rax, rax, 1
  008ef	48 8b 54 04 38	 mov	 rdx, QWORD PTR saved_timer$2[rsp+rax]
  008f4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  008f9	e8 00 00 00 00	 call	 set_cpu_timer

; 2226 : 
; 2227 :             hostregs->waittime += host_tod() - hostregs->waittod;

  008fe	e8 00 00 00 00	 call	 host_tod
  00903	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00908	48 2b 81 b8 07
	00 00		 sub	 rax, QWORD PTR [rcx+1976]
  0090f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00914	48 03 81 c0 07
	00 00		 add	 rax, QWORD PTR [rcx+1984]
  0091b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00920	48 89 81 c0 07
	00 00		 mov	 QWORD PTR [rcx+1984], rax

; 2228 :             hostregs->waittod = 0;

  00927	48 8b 44 24 30	 mov	 rax, QWORD PTR hostregs$1[rsp]
  0092c	48 c7 80 b8 07
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1976], 0

; 2229 :         }
; 2230 :         RELEASE_INTLOCK( hostregs );

  00937	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170906
  0093e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR hostregs$1[rsp]
  00943	e8 00 00 00 00	 call	 Release_Interrupt_Lock
$LN9@s370_proce:

; 2231 :     }
; 2232 : } /* process_trace */

  00948	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0094c	5f		 pop	 rdi
  0094d	c3		 ret	 0
s370_process_trace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
i$1 = 80
oldmode$2 = 84
tv185 = 88
tv136 = 92
tv147 = 96
tv169 = 100
tv188 = 104
tv194 = 108
tv215 = 112
tv220 = 116
tv264 = 120
tv288 = 124
tv363 = 128
tv314 = 132
tv325 = 136
tv347 = 140
tv366 = 144
tv372 = 148
tv393 = 152
tv398 = 156
tv541 = 160
tv565 = 164
tv546 = 168
tv594 = 172
tv618 = 176
tv599 = 180
tv624 = 184
tv698 = 188
tv499 = 192
inst_cr$3 = 196
tv501 = 200
buf$4 = 208
__$ArrayPad$ = 248
regs$ = 272
addr$ = 280
s370_load_psw PROC

; 136  : {

$LN127:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 08 01
	00 00		 sub	 rsp, 264		; 00000108H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s370_load_:

; 137  :     INVALIDATE_AIA(regs);

  00023	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002b	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00033	74 56		 je	 SHORT $LN40@s370_load_
  00035	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00043	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004b	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00053	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0005a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0005e	48 2b ca	 sub	 rcx, rdx
  00061	48 03 c1	 add	 rax, rcx
  00064	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0006a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00078	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN40@s370_load_:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 92		 jne	 SHORT $LN4@s370_load_

; 138  : 
; 139  :     regs->psw.zeroilc = 1;

  00091	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00099	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0009f	83 c8 04	 or	 eax, 4
  000a2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000aa	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 140  : 
; 141  :     regs->psw.sysmask = addr[0];

  000b0	b8 01 00 00 00	 mov	 eax, 1
  000b5	48 6b c0 00	 imul	 rax, rax, 0
  000b9	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000c9	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  000cd	88 41 78	 mov	 BYTE PTR [rcx+120], al

; 142  :     regs->psw.pkey    = (addr[1] & 0xF0);

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	48 6b c0 01	 imul	 rax, rax, 1
  000d9	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e5	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000ea	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	88 41 79	 mov	 BYTE PTR [rcx+121], al

; 143  :     regs->psw.states  = (addr[1] & 0x0F);

  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 01	 imul	 rax, rax, 1
  000fe	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00106	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0010a	83 e0 0f	 and	 eax, 15
  0010d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00115	88 41 7a	 mov	 BYTE PTR [rcx+122], al

; 144  : 
; 145  : #if defined(FEATURE_BCMODE)
; 146  :     if ( ECMODE(&regs->psw) ) {

  00118	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00120	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00124	83 e0 08	 and	 eax, 8
  00127	85 c0		 test	 eax, eax
  00129	0f 84 ea 04 00
	00		 je	 $LN41@s370_load_
$LN7@s370_load_:

; 147  : #endif /*defined(FEATURE_BCMODE)*/
; 148  : 
; 149  :         SET_IC_ECMODE_MASK(regs);

  0012f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00137	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0013b	83 e0 02	 and	 eax, 2
  0013e	85 c0		 test	 eax, eax
  00140	74 0a		 je	 SHORT $LN67@s370_load_
  00142	c7 44 24 5c 00
	00 00 40	 mov	 DWORD PTR tv136[rsp], 1073741824 ; 40000000H
  0014a	eb 08		 jmp	 SHORT $LN68@s370_load_
$LN67@s370_load_:
  0014c	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN68@s370_load_:
  00154	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015c	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00160	83 e0 04	 and	 eax, 4
  00163	85 c0		 test	 eax, eax
  00165	74 23		 je	 SHORT $LN69@s370_load_
  00167	b8 08 00 00 00	 mov	 eax, 8
  0016c	48 6b c0 0f	 imul	 rax, rax, 15
  00170	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0017f	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00184	89 44 24 60	 mov	 DWORD PTR tv147[rsp], eax
  00188	eb 08		 jmp	 SHORT $LN70@s370_load_
$LN69@s370_load_:
  0018a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN70@s370_load_:
  00192	33 c0		 xor	 eax, eax
  00194	85 c0		 test	 eax, eax
  00196	75 61		 jne	 SHORT $LN72@s370_load_
  00198	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a0	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  001a4	83 e0 08	 and	 eax, 8
  001a7	85 c0		 test	 eax, eax
  001a9	74 13		 je	 SHORT $LN71@s370_load_
  001ab	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b3	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001b7	83 e0 40	 and	 eax, 64			; 00000040H
  001ba	85 c0		 test	 eax, eax
  001bc	75 3b		 jne	 SHORT $LN72@s370_load_
$LN71@s370_load_:
  001be	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  001cc	d1 e8		 shr	 eax, 1
  001ce	83 e0 01	 and	 eax, 1
  001d1	85 c0		 test	 eax, eax
  001d3	74 1a		 je	 SHORT $LN73@s370_load_
  001d5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dd	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  001e4	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  001e8	83 e0 01	 and	 eax, 1
  001eb	85 c0		 test	 eax, eax
  001ed	75 0a		 jne	 SHORT $LN72@s370_load_
$LN73@s370_load_:
  001ef	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
  001f7	eb 14		 jmp	 SHORT $LN74@s370_load_
$LN72@s370_load_:
  001f9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00201	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  00204	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00209	89 44 24 64	 mov	 DWORD PTR tv169[rsp], eax
$LN74@s370_load_:
  0020d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00215	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00219	83 e0 01	 and	 eax, 1
  0021c	85 c0		 test	 eax, eax
  0021e	74 5a		 je	 SHORT $LN77@s370_load_
  00220	b8 08 00 00 00	 mov	 eax, 8
  00225	48 6b c0 01	 imul	 rax, rax, 1
  00229	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00238	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0023d	85 c0		 test	 eax, eax
  0023f	74 0a		 je	 SHORT $LN75@s370_load_
  00241	c7 44 24 58 00
	01 00 00	 mov	 DWORD PTR tv185[rsp], 256 ; 00000100H
  00249	eb 08		 jmp	 SHORT $LN76@s370_load_
$LN75@s370_load_:
  0024b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN76@s370_load_:
  00253	b8 08 00 00 00	 mov	 eax, 8
  00258	48 6b c0 01	 imul	 rax, rax, 1
  0025c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0026b	25 f0 fe 00 00	 and	 eax, 65264		; 0000fef0H
  00270	0b 44 24 58	 or	 eax, DWORD PTR tv185[rsp]
  00274	89 44 24 68	 mov	 DWORD PTR tv188[rsp], eax
  00278	eb 08		 jmp	 SHORT $LN78@s370_load_
$LN77@s370_load_:
  0027a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN78@s370_load_:
  00282	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0028e	83 e0 02	 and	 eax, 2
  00291	85 c0		 test	 eax, eax
  00293	74 0a		 je	 SHORT $LN79@s370_load_
  00295	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  0029d	eb 08		 jmp	 SHORT $LN80@s370_load_
$LN79@s370_load_:
  0029f	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN80@s370_load_:
  002a7	8b 44 24 5c	 mov	 eax, DWORD PTR tv136[rsp]
  002ab	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  002b0	0b 44 24 60	 or	 eax, DWORD PTR tv147[rsp]
  002b4	0b 44 24 64	 or	 eax, DWORD PTR tv169[rsp]
  002b8	0b 44 24 68	 or	 eax, DWORD PTR tv188[rsp]
  002bc	0b 44 24 6c	 or	 eax, DWORD PTR tv194[rsp]
  002c0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  002cb	33 c0		 xor	 eax, eax
  002cd	85 c0		 test	 eax, eax
  002cf	75 61		 jne	 SHORT $LN82@s370_load_
  002d1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d9	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  002dd	83 e0 08	 and	 eax, 8
  002e0	85 c0		 test	 eax, eax
  002e2	74 13		 je	 SHORT $LN81@s370_load_
  002e4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ec	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  002f0	83 e0 40	 and	 eax, 64			; 00000040H
  002f3	85 c0		 test	 eax, eax
  002f5	75 3b		 jne	 SHORT $LN82@s370_load_
$LN81@s370_load_:
  002f7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ff	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00305	d1 e8		 shr	 eax, 1
  00307	83 e0 01	 and	 eax, 1
  0030a	85 c0		 test	 eax, eax
  0030c	74 1a		 je	 SHORT $LN83@s370_load_
  0030e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00316	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0031d	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00321	83 e0 01	 and	 eax, 1
  00324	85 c0		 test	 eax, eax
  00326	75 0a		 jne	 SHORT $LN82@s370_load_
$LN83@s370_load_:
  00328	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
  00330	eb 08		 jmp	 SHORT $LN84@s370_load_
$LN82@s370_load_:
  00332	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
$LN84@s370_load_:
  0033a	8b 44 24 70	 mov	 eax, DWORD PTR tv215[rsp]
  0033e	83 e0 01	 and	 eax, 1
  00341	c1 e0 02	 shl	 eax, 2
  00344	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  00352	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00355	0b c8		 or	 ecx, eax
  00357	89 4c 24 74	 mov	 DWORD PTR tv220[rsp], ecx
  0035b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00363	8b 4c 24 74	 mov	 ecx, DWORD PTR tv220[rsp]
  00367	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  0036d	8b 44 24 74	 mov	 eax, DWORD PTR tv220[rsp]
  00371	c1 e8 02	 shr	 eax, 2
  00374	83 e0 01	 and	 eax, 1
  00377	85 c0		 test	 eax, eax
  00379	74 6e		 je	 SHORT $LN43@s370_load_
$LN10@s370_load_:
  0037b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00383	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0038b	74 56		 je	 SHORT $LN44@s370_load_
  0038d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00395	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0039b	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a3	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003ab	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  003b2	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  003b6	48 2b ca	 sub	 rcx, rdx
  003b9	48 03 c1	 add	 rax, rcx
  003bc	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  003c2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ca	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  003d0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d8	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN44@s370_load_:
  003e3	33 c0		 xor	 eax, eax
  003e5	85 c0		 test	 eax, eax
  003e7	75 92		 jne	 SHORT $LN10@s370_load_
$LN43@s370_load_:
  003e9	33 c0		 xor	 eax, eax
  003eb	85 c0		 test	 eax, eax
  003ed	0f 85 3c fd ff
	ff		 jne	 $LN7@s370_load_

; 150  : 
; 151  :         /* Processing for EC mode PSW */
; 152  :         regs->psw.intcode  = 0;

  003f3	33 c0		 xor	 eax, eax
  003f5	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fd	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 153  :         regs->psw.asc      = (addr[2] & 0xC0);

  00404	b8 01 00 00 00	 mov	 eax, 1
  00409	48 6b c0 02	 imul	 rax, rax, 2
  0040d	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00415	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00419	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0041e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00426	88 41 7b	 mov	 BYTE PTR [rcx+123], al

; 154  :         regs->psw.cc       = (addr[2] & 0x30) >> 4;

  00429	b8 01 00 00 00	 mov	 eax, 1
  0042e	48 6b c0 02	 imul	 rax, rax, 2
  00432	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0043a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0043e	83 e0 30	 and	 eax, 48			; 00000030H
  00441	c1 f8 04	 sar	 eax, 4
  00444	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044c	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 155  :         regs->psw.progmask = (addr[2] & 0x0F);

  0044f	b8 01 00 00 00	 mov	 eax, 1
  00454	48 6b c0 02	 imul	 rax, rax, 2
  00458	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00460	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00464	83 e0 0f	 and	 eax, 15
  00467	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046f	88 41 7d	 mov	 BYTE PTR [rcx+125], al

; 156  :         regs->psw.amode    = (addr[4] & 0x80) ? 1 : 0;

  00472	b8 01 00 00 00	 mov	 eax, 1
  00477	48 6b c0 04	 imul	 rax, rax, 4
  0047b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00483	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00487	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0048c	85 c0		 test	 eax, eax
  0048e	74 0a		 je	 SHORT $LN85@s370_load_
  00490	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv264[rsp], 1
  00498	eb 08		 jmp	 SHORT $LN86@s370_load_
$LN85@s370_load_:
  0049a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv264[rsp], 0
$LN86@s370_load_:
  004a2	8b 44 24 78	 mov	 eax, DWORD PTR tv264[rsp]
  004a6	83 e0 01	 and	 eax, 1
  004a9	d1 e0		 shl	 eax, 1
  004ab	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b3	8b 89 80 00 00
	00		 mov	 ecx, DWORD PTR [rcx+128]
  004b9	83 e1 fd	 and	 ecx, -3			; fffffffdH
  004bc	0b c8		 or	 ecx, eax
  004be	8b c1		 mov	 eax, ecx
  004c0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c8	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 157  : 
; 158  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 159  :         regs->psw.zerobyte = addr[3] & 0xFE;
; 160  :         regs->psw.amode64  = addr[3] & 0x01;
; 161  :         regs->psw.zeroword = fetch_fw(addr+4) & 0x7FFFFFFF;
; 162  :         regs->psw.IA       = fetch_dw (addr + 8);
; 163  :         regs->psw.AMASK    = regs->psw.amode64 ? AMASK64
; 164  :                            : regs->psw.amode   ? AMASK31 : AMASK24;
; 165  : #else
; 166  :         regs->psw.zerobyte = addr[3];

  004ce	b8 01 00 00 00	 mov	 eax, 1
  004d3	48 6b c0 03	 imul	 rax, rax, 3
  004d7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004df	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  004e7	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  004eb	88 41 7e	 mov	 BYTE PTR [rcx+126], al

; 167  :         regs->psw.amode64  = 0;

  004ee	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004fc	83 e0 fe	 and	 eax, -2			; fffffffeH
  004ff	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00507	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 168  :         regs->psw.IA       = fetch_fw(addr + 4) & 0x7FFFFFFF;

  0050d	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00515	48 83 c0 04	 add	 rax, 4
  00519	48 8b c8	 mov	 rcx, rax
  0051c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00521	8b c8		 mov	 ecx, eax
  00523	e8 00 00 00 00	 call	 _byteswap_ulong
  00528	0f ba f0 1f	 btr	 eax, 31
  0052c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00534	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 169  :         regs->psw.AMASK    = regs->psw.amode ? AMASK31 : AMASK24;

  0053a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00542	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00548	d1 e8		 shr	 eax, 1
  0054a	83 e0 01	 and	 eax, 1
  0054d	85 c0		 test	 eax, eax
  0054f	74 0a		 je	 SHORT $LN87@s370_load_
  00551	c7 44 24 7c ff
	ff ff 7f	 mov	 DWORD PTR tv288[rsp], 2147483647 ; 7fffffffH
  00559	eb 08		 jmp	 SHORT $LN88@s370_load_
$LN87@s370_load_:
  0055b	c7 44 24 7c ff
	ff ff 00	 mov	 DWORD PTR tv288[rsp], 16777215 ; 00ffffffH
$LN88@s370_load_:
  00563	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056b	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv288[rsp]
  0056f	89 88 90 00 00
	00		 mov	 DWORD PTR [rax+144], ecx

; 170  : #endif
; 171  : 
; 172  :         /* Bits 0 and 2-4 of system mask must be zero */
; 173  :         if ((addr[0] & 0xB8) != 0)

  00575	b8 01 00 00 00	 mov	 eax, 1
  0057a	48 6b c0 00	 imul	 rax, rax, 0
  0057e	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00586	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0058a	25 b8 00 00 00	 and	 eax, 184		; 000000b8H
  0058f	85 c0		 test	 eax, eax
  00591	74 0a		 je	 SHORT $LN45@s370_load_

; 174  :             return PGM_SPECIFICATION_EXCEPTION;

  00593	b8 06 00 00 00	 mov	 eax, 6
  00598	e9 fe 0b 00 00	 jmp	 $LN1@s370_load_
$LN45@s370_load_:

; 175  : 
; 176  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 177  :         /* For ESAME, bit 12 must be zero */
; 178  :         if (NOTESAME(&regs->psw))
; 179  :             return PGM_SPECIFICATION_EXCEPTION;
; 180  : 
; 181  :         /* Bits 24-30 must be zero */
; 182  :         if (regs->psw.zerobyte)
; 183  :             return PGM_SPECIFICATION_EXCEPTION;
; 184  : 
; 185  :         /* Bits 33-63 must be zero */
; 186  :         if ( regs->psw.zeroword )
; 187  :             return PGM_SPECIFICATION_EXCEPTION;
; 188  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 189  :         /* Bits 24-31 must be zero */
; 190  :         if ( regs->psw.zerobyte )

  0059d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a5	0f b6 40 7e	 movzx	 eax, BYTE PTR [rax+126]
  005a9	85 c0		 test	 eax, eax
  005ab	74 0a		 je	 SHORT $LN46@s370_load_

; 191  :             return PGM_SPECIFICATION_EXCEPTION;

  005ad	b8 06 00 00 00	 mov	 eax, 6
  005b2	e9 e4 0b 00 00	 jmp	 $LN1@s370_load_
$LN46@s370_load_:

; 192  : 
; 193  :         /* For ESA/390, bit 12 must be one */
; 194  :         if (!ECMODE(&regs->psw))

  005b7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bf	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  005c3	83 e0 08	 and	 eax, 8
  005c6	85 c0		 test	 eax, eax
  005c8	75 0a		 jne	 SHORT $LN47@s370_load_

; 195  :             return PGM_SPECIFICATION_EXCEPTION;

  005ca	b8 06 00 00 00	 mov	 eax, 6
  005cf	e9 c7 0b 00 00	 jmp	 $LN1@s370_load_
$LN47@s370_load_:

; 196  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 197  : 
; 198  : #ifndef FEATURE_DUAL_ADDRESS_SPACE
; 199  :         /* If DAS feature not installed then bit 16 must be zero */
; 200  :         if (SPACE_BIT(&regs->psw))
; 201  :             return PGM_SPECIFICATION_EXCEPTION;
; 202  : #endif
; 203  : 
; 204  : #ifndef FEATURE_ACCESS_REGISTERS
; 205  :         /* If not ESA/370 or ESA/390 then bit 17 must be zero */
; 206  :         if (AR_BIT(&regs->psw))

  005d4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005dc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005e0	83 e0 40	 and	 eax, 64			; 00000040H
  005e3	85 c0		 test	 eax, eax
  005e5	74 0a		 je	 SHORT $LN48@s370_load_

; 207  :             return PGM_SPECIFICATION_EXCEPTION;

  005e7	b8 06 00 00 00	 mov	 eax, 6
  005ec	e9 aa 0b 00 00	 jmp	 $LN1@s370_load_
$LN48@s370_load_:

; 208  : #endif
; 209  : 
; 210  :         /* Check validity of amode and instruction address */
; 211  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 212  :         /* For ESAME, bit 32 cannot be zero if bit 31 is one */
; 213  :         if (regs->psw.amode64 && !regs->psw.amode)
; 214  :             return PGM_SPECIFICATION_EXCEPTION;
; 215  : 
; 216  :         /* If bit 32 is zero then IA cannot exceed 24 bits */
; 217  :         if (!regs->psw.amode && regs->psw.IA > 0x00FFFFFF)
; 218  :             return PGM_SPECIFICATION_EXCEPTION;
; 219  : 
; 220  :         /* If bit 31 is zero then IA cannot exceed 31 bits */
; 221  :         if (!regs->psw.amode64 && regs->psw.IA > 0x7FFFFFFF)
; 222  :             return PGM_SPECIFICATION_EXCEPTION;
; 223  : #else /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 224  :   #ifdef FEATURE_BIMODAL_ADDRESSING
; 225  :         /* For 370-XA, ESA/370, and ESA/390,
; 226  :            if amode=24, bits 33-39 must be zero */
; 227  :         if (!regs->psw.amode && regs->psw.IA > 0x00FFFFFF)
; 228  :             return PGM_SPECIFICATION_EXCEPTION;
; 229  :   #else
; 230  :         /* For S/370, bits 32-39 must be zero */
; 231  :         if (addr[4] != 0x00)

  005f1	b8 01 00 00 00	 mov	 eax, 1
  005f6	48 6b c0 04	 imul	 rax, rax, 4
  005fa	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00602	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00606	85 c0		 test	 eax, eax
  00608	74 0a		 je	 SHORT $LN49@s370_load_

; 232  :             return PGM_SPECIFICATION_EXCEPTION;

  0060a	b8 06 00 00 00	 mov	 eax, 6
  0060f	e9 87 0b 00 00	 jmp	 $LN1@s370_load_
$LN49@s370_load_:

; 233  :   #endif
; 234  : #endif /* !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY ) */
; 235  : 
; 236  : #if defined( FEATURE_BCMODE )
; 237  :     } else {

  00614	e9 34 04 00 00	 jmp	 $LN42@s370_load_
$LN41@s370_load_:
$LN13@s370_load_:

; 238  : 
; 239  :         SET_IC_BCMODE_MASK(regs);

  00619	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00621	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00625	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  0062a	85 c0		 test	 eax, eax
  0062c	74 0d		 je	 SHORT $LN89@s370_load_
  0062e	c7 84 24 84 00
	00 00 00 00 00
	40		 mov	 DWORD PTR tv314[rsp], 1073741824 ; 40000000H
  00639	eb 0b		 jmp	 SHORT $LN90@s370_load_
$LN89@s370_load_:
  0063b	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv314[rsp], 0
$LN90@s370_load_:
  00646	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0064e	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00652	83 e0 04	 and	 eax, 4
  00655	85 c0		 test	 eax, eax
  00657	74 26		 je	 SHORT $LN91@s370_load_
  00659	b8 08 00 00 00	 mov	 eax, 8
  0065e	48 6b c0 0f	 imul	 rax, rax, 15
  00662	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066a	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00671	25 00 00 00 1f	 and	 eax, 520093696		; 1f000000H
  00676	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv325[rsp], eax
  0067d	eb 0b		 jmp	 SHORT $LN92@s370_load_
$LN91@s370_load_:
  0067f	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv325[rsp], 0
$LN92@s370_load_:
  0068a	33 c0		 xor	 eax, eax
  0068c	85 c0		 test	 eax, eax
  0068e	75 64		 jne	 SHORT $LN94@s370_load_
  00690	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00698	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0069c	83 e0 08	 and	 eax, 8
  0069f	85 c0		 test	 eax, eax
  006a1	74 13		 je	 SHORT $LN93@s370_load_
  006a3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ab	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  006af	83 e0 40	 and	 eax, 64			; 00000040H
  006b2	85 c0		 test	 eax, eax
  006b4	75 3e		 jne	 SHORT $LN94@s370_load_
$LN93@s370_load_:
  006b6	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006be	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  006c4	d1 e8		 shr	 eax, 1
  006c6	83 e0 01	 and	 eax, 1
  006c9	85 c0		 test	 eax, eax
  006cb	74 1a		 je	 SHORT $LN95@s370_load_
  006cd	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d5	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  006dc	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  006e0	83 e0 01	 and	 eax, 1
  006e3	85 c0		 test	 eax, eax
  006e5	75 0d		 jne	 SHORT $LN94@s370_load_
$LN95@s370_load_:
  006e7	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv347[rsp], 0
  006f2	eb 17		 jmp	 SHORT $LN96@s370_load_
$LN94@s370_load_:
  006f4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fc	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  006ff	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00704	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv347[rsp], eax
$LN96@s370_load_:
  0070b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00713	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00717	83 e0 01	 and	 eax, 1
  0071a	85 c0		 test	 eax, eax
  0071c	74 66		 je	 SHORT $LN99@s370_load_
  0071e	b8 08 00 00 00	 mov	 eax, 8
  00723	48 6b c0 01	 imul	 rax, rax, 1
  00727	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0072f	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  00736	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0073b	85 c0		 test	 eax, eax
  0073d	74 0d		 je	 SHORT $LN97@s370_load_
  0073f	c7 84 24 80 00
	00 00 00 01 00
	00		 mov	 DWORD PTR tv363[rsp], 256 ; 00000100H
  0074a	eb 0b		 jmp	 SHORT $LN98@s370_load_
$LN97@s370_load_:
  0074c	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv363[rsp], 0
$LN98@s370_load_:
  00757	b8 08 00 00 00	 mov	 eax, 8
  0075c	48 6b c0 01	 imul	 rax, rax, 1
  00760	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00768	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0076f	25 f0 fe 00 00	 and	 eax, 65264		; 0000fef0H
  00774	0b 84 24 80 00
	00 00		 or	 eax, DWORD PTR tv363[rsp]
  0077b	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv366[rsp], eax
  00782	eb 0b		 jmp	 SHORT $LN100@s370_load_
$LN99@s370_load_:
  00784	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv366[rsp], 0
$LN100@s370_load_:
  0078f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00797	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0079b	83 e0 02	 and	 eax, 2
  0079e	85 c0		 test	 eax, eax
  007a0	74 0d		 je	 SHORT $LN101@s370_load_
  007a2	c7 84 24 94 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv372[rsp], 1
  007ad	eb 0b		 jmp	 SHORT $LN102@s370_load_
$LN101@s370_load_:
  007af	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv372[rsp], 0
$LN102@s370_load_:
  007ba	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv314[rsp]
  007c1	0d 0a 00 00 80	 or	 eax, -2147483638	; 8000000aH
  007c6	0b 84 24 88 00
	00 00		 or	 eax, DWORD PTR tv325[rsp]
  007cd	0b 84 24 8c 00
	00 00		 or	 eax, DWORD PTR tv347[rsp]
  007d4	0b 84 24 90 00
	00 00		 or	 eax, DWORD PTR tv366[rsp]
  007db	0b 84 24 94 00
	00 00		 or	 eax, DWORD PTR tv372[rsp]
  007e2	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ea	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  007ed	33 c0		 xor	 eax, eax
  007ef	85 c0		 test	 eax, eax
  007f1	75 64		 jne	 SHORT $LN104@s370_load_
  007f3	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007fb	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  007ff	83 e0 08	 and	 eax, 8
  00802	85 c0		 test	 eax, eax
  00804	74 13		 je	 SHORT $LN103@s370_load_
  00806	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00812	83 e0 40	 and	 eax, 64			; 00000040H
  00815	85 c0		 test	 eax, eax
  00817	75 3e		 jne	 SHORT $LN104@s370_load_
$LN103@s370_load_:
  00819	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00821	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00827	d1 e8		 shr	 eax, 1
  00829	83 e0 01	 and	 eax, 1
  0082c	85 c0		 test	 eax, eax
  0082e	74 1a		 je	 SHORT $LN105@s370_load_
  00830	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00838	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  0083f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00843	83 e0 01	 and	 eax, 1
  00846	85 c0		 test	 eax, eax
  00848	75 0d		 jne	 SHORT $LN104@s370_load_
$LN105@s370_load_:
  0084a	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv393[rsp], 0
  00855	eb 0b		 jmp	 SHORT $LN106@s370_load_
$LN104@s370_load_:
  00857	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv393[rsp], 1
$LN106@s370_load_:
  00862	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv393[rsp]
  00869	83 e0 01	 and	 eax, 1
  0086c	c1 e0 02	 shl	 eax, 2
  0086f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00877	8b 89 28 07 00
	00		 mov	 ecx, DWORD PTR [rcx+1832]
  0087d	83 e1 fb	 and	 ecx, -5			; fffffffbH
  00880	0b c8		 or	 ecx, eax
  00882	89 8c 24 9c 00
	00 00		 mov	 DWORD PTR tv398[rsp], ecx
  00889	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00891	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv398[rsp]
  00898	89 88 28 07 00
	00		 mov	 DWORD PTR [rax+1832], ecx
  0089e	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv398[rsp]
  008a5	c1 e8 02	 shr	 eax, 2
  008a8	83 e0 01	 and	 eax, 1
  008ab	85 c0		 test	 eax, eax
  008ad	74 6e		 je	 SHORT $LN50@s370_load_
$LN16@s370_load_:
  008af	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b7	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  008bf	74 56		 je	 SHORT $LN51@s370_load_
  008c1	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c9	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  008cf	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d7	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008df	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  008e6	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  008ea	48 2b ca	 sub	 rcx, rdx
  008ed	48 03 c1	 add	 rax, rcx
  008f0	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  008f6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008fe	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  00904	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0090c	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN51@s370_load_:
  00917	33 c0		 xor	 eax, eax
  00919	85 c0		 test	 eax, eax
  0091b	75 92		 jne	 SHORT $LN16@s370_load_
$LN50@s370_load_:
  0091d	33 c0		 xor	 eax, eax
  0091f	85 c0		 test	 eax, eax
  00921	0f 85 f2 fc ff
	ff		 jne	 $LN13@s370_load_

; 240  : 
; 241  :         /* Processing for S/370 BC mode PSW */
; 242  :         regs->psw.intcode = fetch_hw (addr + 2);

  00927	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0092f	48 83 c0 02	 add	 rax, 2
  00933	48 8b c8	 mov	 rcx, rax
  00936	e8 00 00 00 00	 call	 fetch_hw_noswap
  0093b	0f b7 c8	 movzx	 ecx, ax
  0093e	e8 00 00 00 00	 call	 _byteswap_ushort
  00943	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0094b	66 89 81 98 00
	00 00		 mov	 WORD PTR [rcx+152], ax

; 243  :         regs->psw.cc = (addr[4] & 0x30) >> 4;

  00952	b8 01 00 00 00	 mov	 eax, 1
  00957	48 6b c0 04	 imul	 rax, rax, 4
  0095b	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00963	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00967	83 e0 30	 and	 eax, 48			; 00000030H
  0096a	c1 f8 04	 sar	 eax, 4
  0096d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00975	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 244  :         regs->psw.progmask = (addr[4] & 0x0F);

  00978	b8 01 00 00 00	 mov	 eax, 1
  0097d	48 6b c0 04	 imul	 rax, rax, 4
  00981	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00989	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0098d	83 e0 0f	 and	 eax, 15
  00990	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00998	88 41 7d	 mov	 BYTE PTR [rcx+125], al

; 245  : 
; 246  :         FETCH_FW(regs->psw.IA, addr + 4);

  0099b	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  009a3	48 83 c0 04	 add	 rax, 4
  009a7	48 8b c8	 mov	 rcx, rax
  009aa	e8 00 00 00 00	 call	 fetch_fw_noswap
  009af	8b c8		 mov	 ecx, eax
  009b1	e8 00 00 00 00	 call	 _byteswap_ulong
  009b6	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009be	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 247  :         regs->psw.IA &= 0x00FFFFFF;

  009c4	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009cc	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  009d2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  009d7	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009df	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax

; 248  :         regs->psw.AMASK = AMASK24;

  009e5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009ed	c7 80 90 00 00
	00 ff ff ff 00	 mov	 DWORD PTR [rax+144], 16777215 ; 00ffffffH

; 249  : 
; 250  :         regs->psw.zerobyte = 0;

  009f7	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009ff	c6 40 7e 00	 mov	 BYTE PTR [rax+126], 0

; 251  :         regs->psw.asc = 0;

  00a03	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0b	c6 40 7b 00	 mov	 BYTE PTR [rax+123], 0

; 252  :         regs->psw.amode64 = regs->psw.amode = 0;

  00a0f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a17	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a1d	83 e0 fd	 and	 eax, -3			; fffffffdH
  00a20	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a28	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax
  00a2e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a36	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a3c	83 e0 fe	 and	 eax, -2			; fffffffeH
  00a3f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a47	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax
$LN42@s370_load_:

; 253  :     }
; 254  : #endif /* defined( FEATURE_BCMODE ) */
; 255  : 
; 256  : #if defined( FEATURE_MULTIPLE_CONTROLLED_DATA_SPACE )
; 257  :     /* Bits 5 and 16 must be zero in XC mode */
; 258  :     if( SIE_STATE_BIT_ON(regs, MX, XC)
; 259  :       && ( (regs->psw.sysmask & PSW_DATMODE) || SPACE_BIT(&regs->psw)) )
; 260  :         return PGM_SPECIFICATION_EXCEPTION;
; 261  : #endif
; 262  : 
; 263  :     regs->psw.zeroilc = 0;

  00a4d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a55	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a5b	83 e0 fb	 and	 eax, -5			; fffffffbH
  00a5e	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a66	89 81 80 00 00
	00		 mov	 DWORD PTR [rcx+128], eax

; 264  : 
; 265  :     /* Check for wait state PSW */
; 266  :     if (1
; 267  :         && WAITSTATE( &regs->psw )
; 268  :         && CPU_STEPPING_OR_TRACING_ALL
; 269  :         && !TXF_INSTR_TRACING()

  00a6c	33 c0		 xor	 eax, eax
  00a6e	83 f8 01	 cmp	 eax, 1
  00a71	0f 84 d1 01 00
	00		 je	 $LN52@s370_load_
  00a77	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a7f	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00a83	83 e0 02	 and	 eax, 2
  00a86	85 c0		 test	 eax, eax
  00a88	0f 84 ba 01 00
	00		 je	 $LN52@s370_load_
  00a8e	b8 08 00 00 00	 mov	 eax, 8
  00a93	48 6b c0 00	 imul	 rax, rax, 0
  00a97	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a9e	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00aa7	75 32		 jne	 SHORT $LN54@s370_load_
  00aa9	b8 08 00 00 00	 mov	 eax, 8
  00aae	48 6b c0 01	 imul	 rax, rax, 1
  00ab2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00ab9	48 83 bc 01 c8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4808], 0
  00ac2	75 17		 jne	 SHORT $LN54@s370_load_
  00ac4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00acb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00ad1	c1 e8 0a	 shr	 eax, 10
  00ad4	83 e0 01	 and	 eax, 1
  00ad7	85 c0		 test	 eax, eax
  00ad9	75 4e		 jne	 SHORT $LN53@s370_load_
$LN54@s370_load_:
  00adb	b8 08 00 00 00	 mov	 eax, 8
  00ae0	48 6b c0 00	 imul	 rax, rax, 0
  00ae4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00aeb	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00af4	0f 85 4e 01 00
	00		 jne	 $LN52@s370_load_
  00afa	b8 08 00 00 00	 mov	 eax, 8
  00aff	48 6b c0 01	 imul	 rax, rax, 1
  00b03	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00b0a	48 83 bc 01 d8
	12 00 00 00	 cmp	 QWORD PTR [rcx+rax+4824], 0
  00b13	0f 85 2f 01 00
	00		 jne	 $LN52@s370_load_
  00b19	e8 00 00 00 00	 call	 insttrace_all
  00b1e	0f b6 c0	 movzx	 eax, al
  00b21	85 c0		 test	 eax, eax
  00b23	0f 84 1f 01 00
	00		 je	 $LN52@s370_load_
$LN53@s370_load_:
  00b29	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b30	8b 80 4c 05 00
	00		 mov	 eax, DWORD PTR [rax+1356]
  00b36	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00b3b	85 c0		 test	 eax, eax
  00b3d	0f 85 05 01 00
	00		 jne	 $LN52@s370_load_

; 270  :     )
; 271  :     {
; 272  :         if (regs->insttrace && sysblk.traceFILE)

  00b43	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b4b	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  00b51	c1 e8 0f	 shr	 eax, 15
  00b54	83 e0 01	 and	 eax, 1
  00b57	85 c0		 test	 eax, eax
  00b59	74 24		 je	 SHORT $LN55@s370_load_
  00b5b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b62	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b6a	74 13		 je	 SHORT $LN55@s370_load_

; 273  :             tf_0800( regs );

  00b6c	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b74	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0800
  00b7a	e9 c9 00 00 00	 jmp	 $LN56@s370_load_
$LN55@s370_load_:

; 274  :         else
; 275  :         {
; 276  :             char buf[40];
; 277  :             STR_PSW( regs, buf );

  00b7f	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00b85	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buf$4[rsp]
  00b8d	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b95	e8 00 00 00 00	 call	 str_psw

; 278  :             // "Processor %s%02X: loaded wait state PSW %s"
; 279  :             WRMSG( HHC00800, "I", PTYPSTR( regs->cpuad ), regs->cpuad, buf );

  00b9a	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ba2	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  00ba9	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv499[rsp], eax
  00bb0	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bb8	0f b7 89 3c 08
	00 00		 movzx	 ecx, WORD PTR [rcx+2108]
  00bbf	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00bc6	0f b6 8c 0a 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+2888]
  00bce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00bd4	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv501[rsp], rax
  00bdc	b9 01 00 00 00	 mov	 ecx, 1
  00be1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00be7	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR buf$4[rsp]
  00bef	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00bf4	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv499[rsp]
  00bfb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bff	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv501[rsp]
  00c07	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169754
  00c13	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169755
  00c1f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c24	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c29	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c2f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169756
  00c36	ba 17 01 00 00	 mov	 edx, 279		; 00000117H
  00c3b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169757
  00c42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN56@s370_load_:
$LN52@s370_load_:
$LN19@s370_load_:

; 280  :         }
; 281  :     }
; 282  : 
; 283  :     TEST_SET_AEA_MODE(regs);

  00c48	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c50	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00c54	83 e0 08	 and	 eax, 8
  00c57	85 c0		 test	 eax, eax
  00c59	74 2d		 je	 SHORT $LN107@s370_load_
  00c5b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c63	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00c67	83 e0 04	 and	 eax, 4
  00c6a	85 c0		 test	 eax, eax
  00c6c	74 1a		 je	 SHORT $LN107@s370_load_
  00c6e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c76	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00c7a	c1 f8 06	 sar	 eax, 6
  00c7d	ff c0		 inc	 eax
  00c7f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv546[rsp], eax
  00c86	eb 6a		 jmp	 SHORT $LN110@s370_load_
$LN107@s370_load_:
  00c88	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c90	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00c96	d1 e8		 shr	 eax, 1
  00c98	83 e0 01	 and	 eax, 1
  00c9b	85 c0		 test	 eax, eax
  00c9d	74 3a		 je	 SHORT $LN108@s370_load_
  00c9f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00cae	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00cb2	83 e0 01	 and	 eax, 1
  00cb5	85 c0		 test	 eax, eax
  00cb7	74 20		 je	 SHORT $LN108@s370_load_
  00cb9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cc1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00cc5	83 e0 40	 and	 eax, 64			; 00000040H
  00cc8	85 c0		 test	 eax, eax
  00cca	74 0d		 je	 SHORT $LN108@s370_load_
  00ccc	c7 84 24 a0 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv541[rsp], 2
  00cd7	eb 0b		 jmp	 SHORT $LN109@s370_load_
$LN108@s370_load_:
  00cd9	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv541[rsp], 0
$LN109@s370_load_:
  00ce4	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv541[rsp]
  00ceb	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv546[rsp], eax
$LN110@s370_load_:
  00cf2	33 c0		 xor	 eax, eax
  00cf4	85 c0		 test	 eax, eax
  00cf6	75 64		 jne	 SHORT $LN112@s370_load_
  00cf8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d00	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00d04	83 e0 08	 and	 eax, 8
  00d07	85 c0		 test	 eax, eax
  00d09	74 13		 je	 SHORT $LN111@s370_load_
  00d0b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d13	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00d17	83 e0 40	 and	 eax, 64			; 00000040H
  00d1a	85 c0		 test	 eax, eax
  00d1c	75 3e		 jne	 SHORT $LN112@s370_load_
$LN111@s370_load_:
  00d1e	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d26	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00d2c	d1 e8		 shr	 eax, 1
  00d2e	83 e0 01	 and	 eax, 1
  00d31	85 c0		 test	 eax, eax
  00d33	74 1a		 je	 SHORT $LN113@s370_load_
  00d35	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d3d	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00d44	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00d48	83 e0 01	 and	 eax, 1
  00d4b	85 c0		 test	 eax, eax
  00d4d	75 0d		 jne	 SHORT $LN112@s370_load_
$LN113@s370_load_:
  00d4f	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv565[rsp], 0
  00d5a	eb 0b		 jmp	 SHORT $LN114@s370_load_
$LN112@s370_load_:
  00d5c	c7 84 24 a4 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv565[rsp], 64 ; 00000040H
$LN114@s370_load_:
  00d67	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d6f	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00d76	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv565[rsp]
  00d7d	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR tv546[rsp]
  00d84	0b d1		 or	 edx, ecx
  00d86	8b ca		 mov	 ecx, edx
  00d88	3b c1		 cmp	 eax, ecx
  00d8a	0f 84 ff 03 00
	00		 je	 $LN57@s370_load_
$LN22@s370_load_:
  00d90	b8 04 00 00 00	 mov	 eax, 4
  00d95	48 6b c0 04	 imul	 rax, rax, 4
  00d99	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00da1	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  00da8	89 84 24 c4 00
	00 00		 mov	 DWORD PTR inst_cr$3[rsp], eax
  00daf	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00db7	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00dbe	88 44 24 54	 mov	 BYTE PTR oldmode$2[rsp], al
  00dc2	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00dca	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00dce	83 e0 08	 and	 eax, 8
  00dd1	85 c0		 test	 eax, eax
  00dd3	74 2d		 je	 SHORT $LN115@s370_load_
  00dd5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ddd	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00de1	83 e0 04	 and	 eax, 4
  00de4	85 c0		 test	 eax, eax
  00de6	74 1a		 je	 SHORT $LN115@s370_load_
  00de8	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00df0	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00df4	c1 f8 06	 sar	 eax, 6
  00df7	ff c0		 inc	 eax
  00df9	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv599[rsp], eax
  00e00	eb 6a		 jmp	 SHORT $LN118@s370_load_
$LN115@s370_load_:
  00e02	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e0a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00e10	d1 e8		 shr	 eax, 1
  00e12	83 e0 01	 and	 eax, 1
  00e15	85 c0		 test	 eax, eax
  00e17	74 3a		 je	 SHORT $LN116@s370_load_
  00e19	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e21	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00e28	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00e2c	83 e0 01	 and	 eax, 1
  00e2f	85 c0		 test	 eax, eax
  00e31	74 20		 je	 SHORT $LN116@s370_load_
  00e33	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e3b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00e3f	83 e0 40	 and	 eax, 64			; 00000040H
  00e42	85 c0		 test	 eax, eax
  00e44	74 0d		 je	 SHORT $LN116@s370_load_
  00e46	c7 84 24 ac 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv594[rsp], 2
  00e51	eb 0b		 jmp	 SHORT $LN117@s370_load_
$LN116@s370_load_:
  00e53	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv594[rsp], 0
$LN117@s370_load_:
  00e5e	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv594[rsp]
  00e65	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv599[rsp], eax
$LN118@s370_load_:
  00e6c	33 c0		 xor	 eax, eax
  00e6e	85 c0		 test	 eax, eax
  00e70	75 64		 jne	 SHORT $LN120@s370_load_
  00e72	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e7a	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00e7e	83 e0 08	 and	 eax, 8
  00e81	85 c0		 test	 eax, eax
  00e83	74 13		 je	 SHORT $LN119@s370_load_
  00e85	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e8d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00e91	83 e0 40	 and	 eax, 64			; 00000040H
  00e94	85 c0		 test	 eax, eax
  00e96	75 3e		 jne	 SHORT $LN120@s370_load_
$LN119@s370_load_:
  00e98	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ea0	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00ea6	d1 e8		 shr	 eax, 1
  00ea8	83 e0 01	 and	 eax, 1
  00eab	85 c0		 test	 eax, eax
  00ead	74 1a		 je	 SHORT $LN121@s370_load_
  00eaf	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00eb7	48 8b 80 88 08
	00 00		 mov	 rax, QWORD PTR [rax+2184]
  00ebe	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00ec2	83 e0 01	 and	 eax, 1
  00ec5	85 c0		 test	 eax, eax
  00ec7	75 0d		 jne	 SHORT $LN120@s370_load_
$LN121@s370_load_:
  00ec9	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv618[rsp], 0
  00ed4	eb 0b		 jmp	 SHORT $LN122@s370_load_
$LN120@s370_load_:
  00ed6	c7 84 24 b0 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv618[rsp], 64 ; 00000040H
$LN122@s370_load_:
  00ee1	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv618[rsp]
  00ee8	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv599[rsp]
  00eef	0b c8		 or	 ecx, eax
  00ef1	8b c1		 mov	 eax, ecx
  00ef3	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00efb	88 81 90 0c 00
	00		 mov	 BYTE PTR [rcx+3216], al
  00f01	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00f09	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  00f10	83 e0 0f	 and	 eax, 15
  00f13	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv624[rsp], eax
  00f1a	83 bc 24 b8 00
	00 00 01	 cmp	 DWORD PTR tv624[rsp], 1
  00f22	74 0f		 je	 SHORT $LN58@s370_load_
  00f24	83 bc 24 b8 00
	00 00 03	 cmp	 DWORD PTR tv624[rsp], 3
  00f2c	74 43		 je	 SHORT $LN59@s370_load_
  00f2e	e9 95 00 00 00	 jmp	 $LN60@s370_load_
$LN58@s370_load_:
  00f33	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00f3b	eb 0a		 jmp	 SHORT $LN27@s370_load_
$LN25@s370_load_:
  00f3d	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00f41	ff c0		 inc	 eax
  00f43	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN27@s370_load_:
  00f47	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00f4c	7d 1e		 jge	 SHORT $LN26@s370_load_
  00f4e	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00f52	83 c0 05	 add	 eax, 5
  00f55	48 98		 cdqe
  00f57	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f5f	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00f6a	eb d1		 jmp	 SHORT $LN25@s370_load_
$LN26@s370_load_:
  00f6c	e9 90 00 00 00	 jmp	 $LN23@s370_load_
$LN59@s370_load_:
  00f71	b8 04 00 00 00	 mov	 eax, 4
  00f76	48 6b c0 04	 imul	 rax, rax, 4
  00f7a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f82	c7 84 01 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+3220], 1
  00f8d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00f95	eb 0a		 jmp	 SHORT $LN30@s370_load_
$LN28@s370_load_:
  00f97	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00f9b	ff c0		 inc	 eax
  00f9d	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN30@s370_load_:
  00fa1	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00fa6	7d 1e		 jge	 SHORT $LN29@s370_load_
  00fa8	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00fac	83 c0 05	 add	 eax, 5
  00faf	48 98		 cdqe
  00fb1	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00fb9	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00fc4	eb d1		 jmp	 SHORT $LN28@s370_load_
$LN29@s370_load_:
  00fc6	eb 39		 jmp	 SHORT $LN23@s370_load_
$LN60@s370_load_:
  00fc8	c7 44 24 50 ff
	ff ff ff	 mov	 DWORD PTR i$1[rsp], -1
  00fd0	eb 0a		 jmp	 SHORT $LN33@s370_load_
$LN31@s370_load_:
  00fd2	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00fd6	ff c0		 inc	 eax
  00fd8	89 44 24 50	 mov	 DWORD PTR i$1[rsp], eax
$LN33@s370_load_:
  00fdc	83 7c 24 50 10	 cmp	 DWORD PTR i$1[rsp], 16
  00fe1	7d 1e		 jge	 SHORT $LN32@s370_load_
  00fe3	8b 44 24 50	 mov	 eax, DWORD PTR i$1[rsp]
  00fe7	83 c0 05	 add	 eax, 5
  00fea	48 98		 cdqe
  00fec	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ff4	c7 84 81 94 0c
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [rcx+rax*4+3220], -1
  00fff	eb d1		 jmp	 SHORT $LN31@s370_load_
$LN32@s370_load_:
$LN23@s370_load_:
  01001	b8 04 00 00 00	 mov	 eax, 4
  01006	48 6b c0 04	 imul	 rax, rax, 4
  0100a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01012	8b 84 01 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax+3220]
  01019	39 84 24 c4 00
	00 00		 cmp	 DWORD PTR inst_cr$3[rsp], eax
  01020	74 6e		 je	 SHORT $LN61@s370_load_
$LN36@s370_load_:
  01022	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0102a	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  01032	74 56		 je	 SHORT $LN62@s370_load_
  01034	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0103c	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  01042	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0104a	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  01052	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  01059	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0105d	48 2b ca	 sub	 rcx, rdx
  01060	48 03 c1	 add	 rax, rcx
  01063	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  01069	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01071	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  01077	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0107f	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN62@s370_load_:
  0108a	33 c0		 xor	 eax, eax
  0108c	85 c0		 test	 eax, eax
  0108e	75 92		 jne	 SHORT $LN36@s370_load_
$LN61@s370_load_:
  01090	0f b6 44 24 54	 movzx	 eax, BYTE PTR oldmode$2[rsp]
  01095	83 e0 40	 and	 eax, 64			; 00000040H
  01098	85 c0		 test	 eax, eax
  0109a	0f 85 e5 00 00
	00		 jne	 $LN63@s370_load_
  010a0	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010a8	0f b6 80 90 0c
	00 00		 movzx	 eax, BYTE PTR [rax+3216]
  010af	83 e0 40	 and	 eax, 64			; 00000040H
  010b2	85 c0		 test	 eax, eax
  010b4	0f 84 cb 00 00
	00		 je	 $LN63@s370_load_
$LN39@s370_load_:
  010ba	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010c2	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  010ca	74 56		 je	 SHORT $LN64@s370_load_
  010cc	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  010d4	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  010da	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010e2	48 8b 94 24 10
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  010ea	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  010f1	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  010f5	48 2b ca	 sub	 rcx, rdx
  010f8	48 03 c1	 add	 rax, rcx
  010fb	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  01101	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01109	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
  0110f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01117	48 c7 80 08 02
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+520], 0
$LN64@s370_load_:
  01122	33 c0		 xor	 eax, eax
  01124	85 c0		 test	 eax, eax
  01126	75 92		 jne	 SHORT $LN39@s370_load_
  01128	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  01130	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  01136	c1 e8 02	 shr	 eax, 2
  01139	83 e0 01	 and	 eax, 1
  0113c	85 c0		 test	 eax, eax
  0113e	74 0d		 je	 SHORT $LN125@s370_load_
  01140	c7 84 24 bc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv698[rsp], 1
  0114b	eb 0b		 jmp	 SHORT $LN126@s370_load_
$LN125@s370_load_:
  0114d	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv698[rsp], 0
$LN126@s370_load_:
  01158	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR tv698[rsp], 0
  01160	74 23		 je	 SHORT $LN65@s370_load_
  01162	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0116a	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0116d	25 00 00 20 00	 and	 eax, 2097152		; 00200000H
  01172	85 c0		 test	 eax, eax
  01174	74 0f		 je	 SHORT $LN65@s370_load_
  01176	b2 fc		 mov	 dl, 252			; 000000fcH
  01178	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01180	e8 00 00 00 00	 call	 s370_invalidate_tlb
$LN65@s370_load_:
$LN63@s370_load_:
  01185	33 c0		 xor	 eax, eax
  01187	85 c0		 test	 eax, eax
  01189	0f 85 01 fc ff
	ff		 jne	 $LN22@s370_load_
$LN57@s370_load_:
  0118f	33 c0		 xor	 eax, eax
  01191	85 c0		 test	 eax, eax
  01193	0f 85 af fa ff
	ff		 jne	 $LN19@s370_load_

; 284  : 
; 285  :     return 0;

  01199	33 c0		 xor	 eax, eax
$LN1@s370_load_:

; 286  : } /* end function ARCH_DEP(load_psw) */

  0119b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  011a3	48 33 cc	 xor	 rcx, rsp
  011a6	e8 00 00 00 00	 call	 __security_check_cookie
  011ab	48 81 c4 08 01
	00 00		 add	 rsp, 264		; 00000108H
  011b2	c3		 ret	 0
s370_load_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cpu.c
_TEXT	SEGMENT
regs$ = 48
addr$ = 56
s370_store_psw PROC

; 101  : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 102  :     /* Ensure psw.IA is set */
; 103  :     if (!regs->psw.zeroilc)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00013	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00019	c1 e8 02	 shr	 eax, 2
  0001c	83 e0 01	 and	 eax, 1
  0001f	85 c0		 test	 eax, eax
  00021	75 4c		 jne	 SHORT $LN5@s370_store
$LN4@s370_store:

; 104  :         MAYBE_SET_PSW_IA_FROM_IP( regs );

  00023	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00028	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  00030	74 37		 je	 SHORT $LN6@s370_store
  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00037	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	48 8b 54 24 30	 mov	 rdx, QWORD PTR regs$[rsp]
  00047	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  0004e	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00052	48 2b ca	 sub	 rcx, rdx
  00055	48 03 c1	 add	 rax, rcx
  00058	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  0005e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN6@s370_store:
  00069	33 c0		 xor	 eax, eax
  0006b	85 c0		 test	 eax, eax
  0006d	75 b4		 jne	 SHORT $LN4@s370_store
$LN5@s370_store:

; 105  : 
; 106  : #if defined( FEATURE_BCMODE )
; 107  :     if (ECMODE( &regs->psw ))

  0006f	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00074	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  00078	83 e0 08	 and	 eax, 8
  0007b	85 c0		 test	 eax, eax
  0007d	74 29		 je	 SHORT $LN7@s370_store

; 108  : #endif
; 109  :         // 390 or 370 EC-mode
; 110  : 
; 111  : #if !defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 112  :         STORE_DW( addr, make_psw64( regs, 390, false ));

  0007f	45 33 c0	 xor	 r8d, r8d
  00082	ba 86 01 00 00	 mov	 edx, 390		; 00000186H
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	e8 00 00 00 00	 call	 make_psw64
  00091	48 8b c8	 mov	 rcx, rax
  00094	e8 00 00 00 00	 call	 _byteswap_uint64
  00099	48 8b d0	 mov	 rdx, rax
  0009c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR addr$[rsp]
  000a1	e8 00 00 00 00	 call	 store_dw_noswap
  000a6	eb 27		 jmp	 SHORT $LN8@s370_store
$LN7@s370_store:

; 113  : #endif
; 114  : 
; 115  : #if defined( FEATURE_BCMODE )
; 116  : 
; 117  :     else    // 370 BC-mode
; 118  : 
; 119  :         STORE_DW( addr, make_psw64( regs, 370, true ));

  000a8	41 b0 01	 mov	 r8b, 1
  000ab	ba 72 01 00 00	 mov	 edx, 370		; 00000172H
  000b0	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	e8 00 00 00 00	 call	 make_psw64
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	e8 00 00 00 00	 call	 _byteswap_uint64
  000c2	48 8b d0	 mov	 rdx, rax
  000c5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR addr$[rsp]
  000ca	e8 00 00 00 00	 call	 store_dw_noswap
$LN8@s370_store:

; 120  : 
; 121  : #elif defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 122  : 
; 123  :     // 64-bit z/Architecture mode
; 124  : 
; 125  :     STORE_DW( addr + 0, make_psw64( regs, 900, false ));
; 126  :     STORE_DW( addr + 8, regs->psw.IA_G );
; 127  : 
; 128  : #endif
; 129  : } /* end function ARCH_DEP(store_psw) */

  000cf	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d3	c3		 ret	 0
s370_store_psw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
result$ = 32
temp$ = 40
time$1 = 48
__$ArrayPad$ = 64
host_tod PROC

; 565  : {

  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000b	48 33 c4	 xor	 rax, rsp
  0000e	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 566  :   register TOD  result;
; 567  :   register U64  temp;
; 568  : 
; 569  :   /* Use the same clock source as host_ETOD().
; 570  :      Refer to host_ETOD() in clock.c for additional comments.
; 571  :    */
; 572  : 
; 573  : #if !defined( _MSVC_ ) && !defined( CLOCK_REALTIME )
; 574  :   {
; 575  :     struct timeval time;
; 576  :     gettimeofday( &time, NULL );    /* Get current host time         */
; 577  :     result = time.tv_usec << 4;     /* Adjust microseconds to bit-59 */
; 578  :     temp   = time.tv_sec;           /* Load seconds                  */
; 579  :   }
; 580  : #else
; 581  :   {
; 582  :     struct timespec time;
; 583  :     clock_gettime( CLOCK_REALTIME, &time );

  00013	48 8d 54 24 30	 lea	 rdx, QWORD PTR time$1[rsp]
  00018	33 c9		 xor	 ecx, ecx
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock_gettime

; 584  :     result  = time.tv_nsec;         /* Adjust nanoseconds to bit-59  */

  00020	48 63 44 24 38	 movsxd	 rax, DWORD PTR time$1[rsp+8]
  00025	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 585  :     result <<= 1;                   /* and divide by 1000

  0002a	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0002f	48 d1 e0	 shl	 rax, 1
  00032	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 586  :                                        (bit-shift compressed)        */
; 587  :     result  /= 125;                 /* ...                           */

  00037	33 d2		 xor	 edx, edx
  00039	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]
  0003e	b9 7d 00 00 00	 mov	 ecx, 125		; 0000007dH
  00043	48 f7 f1	 div	 rcx
  00046	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 588  :     temp     = time.tv_sec;         /* Load seconds                  */

  0004b	48 8b 44 24 30	 mov	 rax, QWORD PTR time$1[rsp]
  00050	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 589  :    }
; 590  : #endif /* !defined( _MSVC_ ) && !defined( CLOCK_REALTIME ) */
; 591  : 
; 592  :   temp   *= ETOD_SEC;               /* Convert seconds to ETOD fmt   */

  00055	48 69 44 24 28
	00 24 f4 00	 imul	 rax, QWORD PTR temp$[rsp], 16000000 ; 00f42400H
  0005e	48 89 44 24 28	 mov	 QWORD PTR temp$[rsp], rax

; 593  :   result += temp;                   /* Add seconds                   */

  00063	48 8b 44 24 28	 mov	 rax, QWORD PTR temp$[rsp]
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  0006d	48 03 c8	 add	 rcx, rax
  00070	48 8b c1	 mov	 rax, rcx
  00073	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 594  :   result += ETOD_1970;              /* Adjust to epoch 1970          */

  00078	48 b8 00 00 ca
	8b 04 91 7d 00	 mov	 rax, 35343820800000000	; 007d91048bca0000H
  00082	48 8b 4c 24 20	 mov	 rcx, QWORD PTR result$[rsp]
  00087	48 03 c8	 add	 rcx, rax
  0008a	48 8b c1	 mov	 rax, rcx
  0008d	48 89 44 24 20	 mov	 QWORD PTR result$[rsp], rax

; 595  :   return ( result );

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR result$[rsp]

; 596  : }

  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009c	48 33 cc	 xor	 rcx, rsp
  0009f	e8 00 00 00 00	 call	 __security_check_cookie
  000a4	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a8	c3		 ret	 0
host_tod ENDP
_TEXT	ENDS
END
