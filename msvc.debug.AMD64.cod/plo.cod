; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	s390_plo_cl
PUBLIC	s390_plo_clg
PUBLIC	s390_plo_cs
PUBLIC	s390_plo_csg
PUBLIC	s390_plo_dcs
PUBLIC	s390_plo_dcsg
PUBLIC	s390_plo_csst
PUBLIC	s390_plo_csstg
PUBLIC	s390_plo_csdst
PUBLIC	s390_plo_csdstg
PUBLIC	s390_plo_cstst
PUBLIC	s390_plo_cststg
PUBLIC	s390_maddr_l
PUBLIC	s390_vstore4_full
PUBLIC	s390_vstore8_full
PUBLIC	s390_vfetch4_full
PUBLIC	s390_vfetch8_full
PUBLIC	s390_vstore4
PUBLIC	s390_vstore8
PUBLIC	s390_vfetch4
PUBLIC	s390_vfetch8
PUBLIC	s390_validate_operand
PUBLIC	z900_plo_cl
PUBLIC	z900_plo_clg
PUBLIC	z900_plo_clgr
PUBLIC	z900_plo_clx
PUBLIC	z900_plo_cs
PUBLIC	z900_plo_csg
PUBLIC	z900_plo_csgr
PUBLIC	z900_plo_csx
PUBLIC	z900_plo_dcs
PUBLIC	z900_plo_dcsg
PUBLIC	z900_plo_dcsgr
PUBLIC	z900_plo_dcsx
PUBLIC	z900_plo_csst
PUBLIC	z900_plo_csstg
PUBLIC	z900_plo_csstgr
PUBLIC	z900_plo_csstx
PUBLIC	z900_plo_csdst
PUBLIC	z900_plo_csdstg
PUBLIC	z900_plo_csdstgr
PUBLIC	z900_plo_csdstx
PUBLIC	z900_plo_cstst
PUBLIC	z900_plo_cststg
PUBLIC	z900_plo_cststgr
PUBLIC	z900_plo_cststx
PUBLIC	z900_maddr_l
PUBLIC	z900_vstore4_full
PUBLIC	z900_vstore8_full
PUBLIC	z900_vfetch4_full
PUBLIC	z900_vfetch8_full
PUBLIC	z900_vstorec
PUBLIC	z900_vstore4
PUBLIC	z900_vstore8
PUBLIC	z900_vfetchc
PUBLIC	z900_vfetch4
PUBLIC	z900_vfetch8
PUBLIC	z900_validate_operand
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	txf_maddr_l:PROC
EXTRN	s390_program_interrupt:PROC
EXTRN	z900_program_interrupt:PROC
EXTRN	s390_logical_to_main_l:PROC
EXTRN	z900_logical_to_main_l:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$s390_plo_cl DD imagerel $LN7
	DD	imagerel $LN7+211
	DD	imagerel $unwind$s390_plo_cl
$pdata$s390_plo_clg DD imagerel $LN21
	DD	imagerel $LN21+754
	DD	imagerel $unwind$s390_plo_clg
$pdata$s390_plo_cs DD imagerel $LN16
	DD	imagerel $LN16+225
	DD	imagerel $unwind$s390_plo_cs
$pdata$s390_plo_csg DD imagerel $LN13
	DD	imagerel $LN13+327
	DD	imagerel $unwind$s390_plo_csg
$pdata$s390_plo_dcs DD imagerel $LN11
	DD	imagerel $LN11+462
	DD	imagerel $unwind$s390_plo_dcs
$pdata$s390_plo_dcsg DD imagerel $LN23
	DD	imagerel $LN23+1112
	DD	imagerel $unwind$s390_plo_dcsg
$pdata$s390_plo_csst DD imagerel $LN8
	DD	imagerel $LN8+356
	DD	imagerel $unwind$s390_plo_csst
$pdata$s390_plo_csstg DD imagerel $LN21
	DD	imagerel $LN21+924
	DD	imagerel $unwind$s390_plo_csstg
$pdata$s390_plo_csdst DD imagerel $LN38
	DD	imagerel $LN38+1608
	DD	imagerel $unwind$s390_plo_csdst
$pdata$s390_plo_csdstg DD imagerel $LN40
	DD	imagerel $LN40+1775
	DD	imagerel $unwind$s390_plo_csdstg
$pdata$s390_plo_cstst DD imagerel $LN57
	DD	imagerel $LN57+2407
	DD	imagerel $unwind$s390_plo_cstst
$pdata$s390_plo_cststg DD imagerel $LN59
	DD	imagerel $LN59+2609
	DD	imagerel $unwind$s390_plo_cststg
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+474
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+321
	DD	imagerel $unwind$s390_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+364
	DD	imagerel $unwind$s390_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+296
	DD	imagerel $unwind$s390_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+200
	DD	imagerel $unwind$s390_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+168
	DD	imagerel $unwind$s390_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+186
	DD	imagerel $unwind$s390_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+151
	DD	imagerel $unwind$s390_vfetch8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_plo_cl DD imagerel $LN7
	DD	imagerel $LN7+219
	DD	imagerel $unwind$z900_plo_cl
$pdata$z900_plo_clg DD imagerel $LN21
	DD	imagerel $LN21+824
	DD	imagerel $unwind$z900_plo_clg
$pdata$z900_plo_clgr DD imagerel $LN7
	DD	imagerel $LN7+227
	DD	imagerel $unwind$z900_plo_clgr
$pdata$z900_plo_clx DD imagerel $LN21
	DD	imagerel $LN21+901
	DD	imagerel $unwind$z900_plo_clx
$pdata$z900_plo_cs DD imagerel $LN16
	DD	imagerel $LN16+230
	DD	imagerel $unwind$z900_plo_cs
$pdata$z900_plo_csg DD imagerel $LN13
	DD	imagerel $LN13+347
	DD	imagerel $unwind$z900_plo_csg
$pdata$z900_plo_csgr DD imagerel $LN16
	DD	imagerel $LN16+236
	DD	imagerel $unwind$z900_plo_csgr
$pdata$z900_plo_csx DD imagerel $LN13
	DD	imagerel $LN13+418
	DD	imagerel $unwind$z900_plo_csx
$pdata$z900_plo_dcs DD imagerel $LN11
	DD	imagerel $LN11+473
	DD	imagerel $unwind$z900_plo_dcs
$pdata$z900_plo_dcsg DD imagerel $LN23
	DD	imagerel $LN23+1164
	DD	imagerel $unwind$z900_plo_dcsg
$pdata$z900_plo_dcsgr DD imagerel $LN11
	DD	imagerel $LN11+485
	DD	imagerel $unwind$z900_plo_dcsgr
$pdata$z900_plo_dcsx DD imagerel $LN23
	DD	imagerel $LN23+1274
	DD	imagerel $unwind$z900_plo_dcsx
$pdata$z900_plo_csst DD imagerel $LN8
	DD	imagerel $LN8+366
	DD	imagerel $unwind$z900_plo_csst
$pdata$z900_plo_csstg DD imagerel $LN21
	DD	imagerel $LN21+967
	DD	imagerel $unwind$z900_plo_csstg
$pdata$z900_plo_csstgr DD imagerel $LN8
	DD	imagerel $LN8+373
	DD	imagerel $unwind$z900_plo_csstgr
$pdata$z900_plo_csstx DD imagerel $LN21
	DD	imagerel $LN21+1056
	DD	imagerel $unwind$z900_plo_csstx
$pdata$z900_plo_csdst DD imagerel $LN38
	DD	imagerel $LN38+1683
	DD	imagerel $unwind$z900_plo_csdst
$pdata$z900_plo_csdstg DD imagerel $LN40
	DD	imagerel $LN40+1841
	DD	imagerel $unwind$z900_plo_csdstg
$pdata$z900_plo_csdstgr DD imagerel $LN38
	DD	imagerel $LN38+1693
	DD	imagerel $unwind$z900_plo_csdstgr
$pdata$z900_plo_csdstx DD imagerel $LN40
	DD	imagerel $LN40+1924
	DD	imagerel $unwind$z900_plo_csdstx
$pdata$z900_plo_cstst DD imagerel $LN57
	DD	imagerel $LN57+2619
	DD	imagerel $unwind$z900_plo_cstst
$pdata$z900_plo_cststg DD imagerel $LN59
	DD	imagerel $LN59+2704
	DD	imagerel $unwind$z900_plo_cststg
$pdata$z900_plo_cststgr DD imagerel $LN57
	DD	imagerel $LN57+2637
	DD	imagerel $unwind$z900_plo_cststgr
$pdata$z900_plo_cststx DD imagerel $LN59
	DD	imagerel $LN59+2802
	DD	imagerel $unwind$z900_plo_cststx
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+657
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4_full DD imagerel $LN3
	DD	imagerel $LN3+332
	DD	imagerel $unwind$z900_vstore4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8_full DD imagerel $LN3
	DD	imagerel $LN3+375
	DD	imagerel $unwind$z900_vstore8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch4_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8_full DD imagerel $LN3
	DD	imagerel $LN3+307
	DD	imagerel $unwind$z900_vfetch8_full
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore4 DD imagerel $LN12
	DD	imagerel $LN12+209
	DD	imagerel $unwind$z900_vstore4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstore8 DD imagerel $LN9
	DD	imagerel $LN9+174
	DD	imagerel $unwind$z900_vstore8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch4 DD imagerel $LN11
	DD	imagerel $LN11+195
	DD	imagerel $unwind$z900_vfetch4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetch8 DD imagerel $LN8
	DD	imagerel $LN8+157
	DD	imagerel $unwind$z900_vfetch8
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4 DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8 DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch8_full DD 032319H
	DD	07010c214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01eH
	DW	011fH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetch4_full DD 032319H
	DD	07010a214H
	DD	0600fH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	024H
	DW	0163H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore8_full DD 032919H
	DD	07016c21aH
	DD	06015H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstore4_full DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_plo_cststx
	DD	023H
	DD	0adaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_plo_csdstx
	DD	023H
	DD	076cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_plo_csstx
	DD	023H
	DD	0408H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_plo_dcsx
	DD	023H
	DD	04e2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_plo_csx
	DD	020H
	DD	0190H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_plo_clx
	DD	023H
	DD	0370H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch8 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4 DD 011101H
	DD	08211H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore8 DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4 DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch8_full DD 032219H
	DD	0700fc213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	050H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	01dH
	DW	0114H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetch4_full DD 032219H
	DD	0700fa213H
	DD	0600eH
	DD	imagerel __GSHandlerCheck
	DD	048H
xdata	ENDS
;	COMDAT voltbl
voltbl	SEGMENT
_volmd	DW	023H
	DW	0158H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore8_full DD 032819H
	DD	07015c219H
	DD	06014H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstore4_full DD 031801H
	DD	07014a218H
	DD	06013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
xdata	SEGMENT
$unwind$s390_plo_cl DD 011601H
	DD	06216H
$unwind$s390_plo_clg DD 011601H
	DD	08216H
$unwind$s390_plo_cs DD 011601H
	DD	06216H
$unwind$s390_plo_csg DD 011601H
	DD	08216H
$unwind$s390_plo_dcs DD 011601H
	DD	08216H
$unwind$s390_plo_dcsg DD 011601H
	DD	0e216H
$unwind$s390_plo_csst DD 011601H
	DD	08216H
$unwind$s390_plo_csstg DD 011601H
	DD	0c216H
$unwind$s390_plo_csdst DD 011601H
	DD	0a216H
$unwind$s390_plo_csdstg DD 011601H
	DD	0e216H
$unwind$s390_plo_cstst DD 011601H
	DD	0c216H
$unwind$s390_plo_cststg DD 021901H
	DD	0110119H
$unwind$z900_plo_cl DD 011601H
	DD	06216H
$unwind$z900_plo_clg DD 011601H
	DD	0a216H
$unwind$z900_plo_clgr DD 011601H
	DD	06216H
$unwind$z900_plo_clx DD 022819H
	DD	0110119H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$z900_plo_cs DD 011601H
	DD	06216H
$unwind$z900_plo_csg DD 011601H
	DD	08216H
$unwind$z900_plo_csgr DD 011601H
	DD	06216H
$unwind$z900_plo_csx DD 012519H
	DD	0e216H
	DD	imagerel __GSHandlerCheck
	DD	060H
$unwind$z900_plo_dcs DD 011601H
	DD	08216H
$unwind$z900_plo_dcsg DD 011601H
	DD	0e216H
$unwind$z900_plo_dcsgr DD 011601H
	DD	08216H
$unwind$z900_plo_dcsx DD 022b19H
	DD	0170119H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_plo_csst DD 011601H
	DD	08216H
$unwind$z900_plo_csstg DD 011601H
	DD	0c216H
$unwind$z900_plo_csstgr DD 011601H
	DD	08216H
$unwind$z900_plo_csstx DD 022b19H
	DD	0130119H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$z900_plo_csdst DD 011601H
	DD	0c216H
$unwind$z900_plo_csdstg DD 011601H
	DD	0e216H
$unwind$z900_plo_csdstgr DD 011601H
	DD	0c216H
$unwind$z900_plo_csdstx DD 022b19H
	DD	0150119H
	DD	imagerel __GSHandlerCheck
	DD	098H
$unwind$z900_plo_cstst DD 011601H
	DD	0e216H
$unwind$z900_plo_cststg DD 021901H
	DD	0130119H
$unwind$z900_plo_cststgr DD 021901H
	DD	0110119H
$unwind$z900_plo_cststx DD 022b19H
	DD	0190119H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0001d	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00023	77 0a		 ja	 SHORT $LN6@z900_vfetc
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vfetc
$LN6@z900_vfetc:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@z900_vfetc:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003c	74 47		 je	 SHORT $LN2@z900_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00043	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00047	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00053	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0005d	ba 08 00 00 00	 mov	 edx, 8
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00067	e8 00 00 00 00	 call	 z900_maddr_l
  0006c	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  00071	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00076	e8 00 00 00 00	 call	 fetch_dw_noswap
  0007b	48 8b c8	 mov	 rcx, rax
  0007e	e8 00 00 00 00	 call	 _byteswap_uint64
  00083	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00085	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  0008a	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_vfetch8_full
$LN1@z900_vfetc:

; 737  : }

  00098	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009c	c3		 ret	 0
z900_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
z900_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00012	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00017	48 83 e0 03	 and	 rax, 3
  0001b	48 85 c0	 test	 rax, rax
  0001e	75 0a		 jne	 SHORT $LN5@z900_vfetc
  00020	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00028	eb 08		 jmp	 SHORT $LN6@z900_vfetc
$LN5@z900_vfetc:
  0002a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@z900_vfetc:
  00032	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00037	74 0a		 je	 SHORT $LN9@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN10@z900_vfetc
$LN9@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00050	75 13		 jne	 SHORT $LN3@z900_vfetc
  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  00057	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0005d	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00063	77 46		 ja	 SHORT $LN2@z900_vfetc
$LN3@z900_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00065	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006e	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00072	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0007a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  0007f	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00084	ba 04 00 00 00	 mov	 edx, 4
  00089	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00098	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  0009d	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a2	8b c8		 mov	 ecx, eax
  000a4	e8 00 00 00 00	 call	 _byteswap_ulong
  000a9	eb 13		 jmp	 SHORT $LN1@z900_vfetc
$LN2@z900_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000ab	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000b0	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  000b9	e8 00 00 00 00	 call	 z900_vfetch4_full
$LN1@z900_vfetc:

; 705  : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001d	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00023	48 3d f8 0f 00
	00		 cmp	 rax, 4088		; 00000ff8H
  00029	77 0a		 ja	 SHORT $LN7@z900_vstor
  0002b	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00033	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00035	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@z900_vstor:
  0003d	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00042	74 4c		 je	 SHORT $LN2@z900_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00044	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00049	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0004d	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00051	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00059	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005e	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00063	ba 08 00 00 00	 mov	 edx, 8
  00068	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  0006d	e8 00 00 00 00	 call	 z900_maddr_l
  00072	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0007c	e8 00 00 00 00	 call	 _byteswap_uint64
  00081	48 8b d0	 mov	 rdx, rax
  00084	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00089	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  0008e	eb 19		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  00090	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0009a	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  000a4	e8 00 00 00 00	 call	 z900_vstore8_full
$LN3@z900_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ad	c3		 ret	 0
z900_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
z900_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0001c	48 83 e0 03	 and	 rax, 3
  00020	48 85 c0	 test	 rax, rax
  00023	75 0a		 jne	 SHORT $LN6@z900_vstor
  00025	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  0002d	eb 08		 jmp	 SHORT $LN7@z900_vstor
$LN6@z900_vstor:
  0002f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@z900_vstor:
  00037	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  0003c	74 0a		 je	 SHORT $LN10@z900_vstor
  0003e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00046	eb 08		 jmp	 SHORT $LN11@z900_vstor
$LN10@z900_vstor:
  00048	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@z900_vstor:
  00050	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00055	75 13		 jne	 SHORT $LN4@z900_vstor
  00057	48 8b 44 24 58	 mov	 rax, QWORD PTR addr$[rsp]
  0005c	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00062	48 3d fc 0f 00
	00		 cmp	 rax, 4092		; 00000ffcH
  00068	77 4a		 ja	 SHORT $LN2@z900_vstor
$LN4@z900_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  0006a	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00073	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00077	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0007f	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00084	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00089	ba 04 00 00 00	 mov	 edx, 4
  0008e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR addr$[rsp]
  00093	e8 00 00 00 00	 call	 z900_maddr_l
  00098	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  0009d	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000a1	e8 00 00 00 00	 call	 _byteswap_ulong
  000a6	8b d0		 mov	 edx, eax
  000a8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000ad	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000b2	eb 18		 jmp	 SHORT $LN3@z900_vstor
$LN2@z900_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000b4	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b9	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000be	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  000c3	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000c7	e8 00 00 00 00	 call	 z900_vstore4_full
$LN3@z900_vstor:

; 571  : }

  000cc	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000d0	c3		 ret	 0
z900_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  0002b	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00031	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00040	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00045	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004d	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00051	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00055	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005d	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00065	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006d	48 8b d0	 mov	 rdx, rax
  00070	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 z900_maddr_l
  0007d	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  00082	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00087	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0008c	48 8b f9	 mov	 rdi, rcx
  0008f	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00094	48 8b c8	 mov	 rcx, rax
  00097	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00099	b8 08 00 00 00	 mov	 eax, 8
  0009e	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a2	48 98		 cdqe
  000a4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b1	48 03 d1	 add	 rdx, rcx
  000b4	48 8b ca	 mov	 rcx, rdx
  000b7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000bf	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c6	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ce	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d2	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d6	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000de	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e6	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ee	48 8b d0	 mov	 rdx, rax
  000f1	e8 00 00 00 00	 call	 z900_maddr_l
  000f6	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000fb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  00105	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00108	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  0010d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00112	e8 00 00 00 00	 call	 fetch_dw_noswap
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
z900_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00023	48 8b 44 24 70	 mov	 rax, QWORD PTR addr$[rsp]
  00028	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	48 2b c8	 sub	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00042	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004e	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00052	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0005a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00062	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00067	48 8b d0	 mov	 rdx, rax
  0006a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR addr$[rsp]
  0006f	e8 00 00 00 00	 call	 z900_maddr_l
  00074	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00079	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0007e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00083	48 8b f9	 mov	 rdi, rcx
  00086	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  00090	b8 04 00 00 00	 mov	 eax, 4
  00095	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00099	48 98		 cdqe
  0009b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 70	 mov	 rdx, QWORD PTR addr$[rsp]
  000a5	48 03 d1	 add	 rdx, rcx
  000a8	48 8b ca	 mov	 rcx, rdx
  000ab	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b3	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000ba	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c6	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ca	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000da	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000df	48 8b d0	 mov	 rdx, rax
  000e2	e8 00 00 00 00	 call	 z900_maddr_l
  000e7	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000f5	48 98		 cdqe
  000f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000fc	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00101	48 8b f9	 mov	 rdi, rcx
  00104	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00109	48 8b c8	 mov	 rcx, rax
  0010c	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  0010e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00113	e8 00 00 00 00	 call	 fetch_fw_noswap
  00118	8b c8		 mov	 ecx, eax
  0011a	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  0011f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00124	48 33 cc	 xor	 rcx, rsp
  00127	e8 00 00 00 00	 call	 __security_check_cookie
  0012c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
z900_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
z900_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00029	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00031	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00037	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  0003c	48 2b c8	 sub	 rcx, rax
  0003f	48 8b c1	 mov	 rax, rcx
  00042	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00046	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0004b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00057	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0005b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00063	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0006b	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0007e	e8 00 00 00 00	 call	 z900_maddr_l
  00083	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00088	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00097	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  0009c	b8 08 00 00 00	 mov	 eax, 8
  000a1	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000a5	48 98		 cdqe
  000a7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000ac	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  000b4	48 03 d1	 add	 rdx, rcx
  000b7	48 8b ca	 mov	 rcx, rdx
  000ba	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000c9	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000d5	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000d9	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000e1	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e9	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f1	48 8b d0	 mov	 rdx, rax
  000f4	e8 00 00 00 00	 call	 z900_maddr_l
  000f9	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000fe	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00103	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00106	83 c8 06	 or	 eax, 6
  00109	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  0010e	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00110	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  00118	e8 00 00 00 00	 call	 _byteswap_uint64
  0011d	48 8b d0	 mov	 rdx, rax
  00120	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00125	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0012a	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0012f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00134	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00139	48 8b f1	 mov	 rsi, rcx
  0013c	48 8b c8	 mov	 rcx, rax
  0013f	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00141	b8 08 00 00 00	 mov	 eax, 8
  00146	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0014a	48 98		 cdqe
  0014c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00151	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00156	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0015b	48 8b f1	 mov	 rsi, rcx
  0015e	48 8b c8	 mov	 rcx, rax
  00161	f3 a4		 rep movsb

; 384  : }

  00163	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00168	48 33 cc	 xor	 rcx, rsp
  0016b	e8 00 00 00 00	 call	 __security_check_cookie
  00170	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00174	5f		 pop	 rdi
  00175	5e		 pop	 rsi
  00176	c3		 ret	 0
z900_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
z900_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00019	48 8b 44 24 78	 mov	 rax, QWORD PTR addr$[rsp]
  0001e	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00024	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00029	48 2b c8	 sub	 rcx, rax
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00033	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00038	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00044	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00048	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00050	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00058	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 8b 4c 24 78	 mov	 rcx, QWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 z900_maddr_l
  0006d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  00072	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00081	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00086	b8 04 00 00 00	 mov	 eax, 4
  0008b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0008f	48 98		 cdqe
  00091	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00096	48 8b 54 24 78	 mov	 rdx, QWORD PTR addr$[rsp]
  0009b	48 03 d1	 add	 rdx, rcx
  0009e	48 8b ca	 mov	 rcx, rdx
  000a1	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  000b0	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bc	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000c0	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000c8	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000d0	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000d8	48 8b d0	 mov	 rdx, rax
  000db	e8 00 00 00 00	 call	 z900_maddr_l
  000e0	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000e5	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000ea	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000ed	83 c8 06	 or	 eax, 6
  000f0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000f5	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000f7	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000fb	e8 00 00 00 00	 call	 _byteswap_ulong
  00100	8b d0		 mov	 edx, eax
  00102	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  0010c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00111	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  00116	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0011b	48 8b f1	 mov	 rsi, rcx
  0011e	48 8b c8	 mov	 rcx, rax
  00121	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00123	b8 04 00 00 00	 mov	 eax, 4
  00128	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0012c	48 98		 cdqe
  0012e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00133	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  00138	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  0013d	48 8b f1	 mov	 rsi, rcx
  00140	48 8b c8	 mov	 rcx, rax
  00143	f3 a4		 rep movsb

; 350  : }

  00145	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00149	5f		 pop	 rdi
  0014a	5e		 pop	 rsi
  0014b	c3		 ret	 0
z900_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 36		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	e8 00 00 00 00	 call	 z900_logical_to_main_l
  001d8	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001dd	b8 01 00 00 00	 mov	 eax, 1
  001e2	48 6b c0 09	 imul	 rax, rax, 9
  001e6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f3	83 e0 40	 and	 eax, 64			; 00000040H
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 89 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001fe	33 c0		 xor	 eax, eax
  00200	85 c0		 test	 eax, eax
  00202	75 26		 jne	 SHORT $LN13@z900_maddr
  00204	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020a	74 1e		 je	 SHORT $LN13@z900_maddr
  0020c	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00211	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00218	85 c0		 test	 eax, eax
  0021a	74 0e		 je	 SHORT $LN13@z900_maddr
  0021c	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00221	74 07		 je	 SHORT $LN13@z900_maddr
  00223	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00228	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022a	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0022f	eb 5b		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00231	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00236	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023d	85 c0		 test	 eax, eax
  0023f	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00241	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024d	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00252	eb 38		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00254	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00259	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00265	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00269	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026e	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00273	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00278	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027d	e8 00 00 00 00	 call	 txf_maddr_l
  00282	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00287	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00290	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op8alet$ = 52
op4alet$ = 56
op6addr$ = 64
op8addr$ = 72
op4addr$ = 80
op2$ = 88
op1c$ = 104
op3$ = 120
op5$ = 136
op7$ = 152
op1r$ = 168
__$ArrayPad$ = 184
r1$ = 208
r3$ = 216
effective_addr2$ = 224
b2$ = 232
effective_addr4$ = 240
b4$ = 248
regs$ = 256
z900_plo_cststx PROC

; 1525 : {

$LN59:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1526 : BYTE op1c[16],
; 1527 :      op1r[16],
; 1528 :      op2[16],
; 1529 :      op3[16],
; 1530 :      op5[16],
; 1531 :      op7[16];
; 1532 : U32 op4alet = 0,

  0002b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1533 :     op6alet = 0,

  00033	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 1534 :     op8alet = 0;

  0003b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op8alet$[rsp], 0
$LN4@z900_plo_c:

; 1535 : VADR op4addr,
; 1536 :     op6addr,
; 1537 :     op8addr;
; 1538 : 
; 1539 :     UNREFERENCED(r1);

  00043	33 c0		 xor	 eax, eax
  00045	85 c0		 test	 eax, eax
  00047	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 1540 : 
; 1541 :     QW_CHECK(effective_addr2, regs);

  00049	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00051	48 83 e0 0f	 and	 rax, 15
  00055	48 85 c0	 test	 rax, rax
  00058	74 1b		 je	 SHORT $LN20@z900_plo_c
  0005a	ba 06 00 00 00	 mov	 edx, 6
  0005f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00067	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@z900_plo_c:

; 1542 :     DW_CHECK(effective_addr4, regs);

  00075	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0007d	48 83 e0 07	 and	 rax, 7
  00081	48 85 c0	 test	 rax, rax
  00084	74 1b		 je	 SHORT $LN21@z900_plo_c
  00086	ba 06 00 00 00	 mov	 edx, 6
  0008b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN21@z900_plo_c:

; 1543 : 
; 1544 :     ARCH_DEP(vfetchc)(op1c, 16-1, effective_addr4 + 0, b4, regs);

  000a1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ae	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  000b6	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  000be	b2 0f		 mov	 dl, 15
  000c0	48 8d 4c 24 68	 lea	 rcx, QWORD PTR op1c$[rsp]
  000c5	e8 00 00 00 00	 call	 z900_vfetchc

; 1545 :     ARCH_DEP(vfetchc)(op2, 16-1, effective_addr2, b2, regs);

  000ca	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d7	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  000df	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  000e7	b2 0f		 mov	 dl, 15
  000e9	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op2$[rsp]
  000ee	e8 00 00 00 00	 call	 z900_vfetchc

; 1546 : 
; 1547 :     if(memcmp(op1c,op2,16) == 0)

  000f3	41 b8 10 00 00
	00		 mov	 r8d, 16
  000f9	48 8d 54 24 58	 lea	 rdx, QWORD PTR op2$[rsp]
  000fe	48 8d 4c 24 68	 lea	 rcx, QWORD PTR op1c$[rsp]
  00103	e8 00 00 00 00	 call	 memcmp
  00108	85 c0		 test	 eax, eax
  0010a	0f 85 9c 09 00
	00		 jne	 $LN22@z900_plo_c

; 1548 :     {
; 1549 :         ARCH_DEP(wfetchc)(op1r, 16-1, effective_addr4 + 16, b4, regs);

  00110	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00118	48 83 c0 10	 add	 rax, 16
  0011c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0012b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00133	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00138	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00140	4c 8b c0	 mov	 r8, rax
  00143	b2 0f		 mov	 dl, 15
  00145	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR op1r$[rsp]
  0014d	e8 00 00 00 00	 call	 z900_vfetchc

; 1550 :         ARCH_DEP(wfetchc)(op3, 16-1, effective_addr4 + 48, b4, regs);

  00152	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0015a	48 83 c0 30	 add	 rax, 48			; 00000030H
  0015e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00166	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0016d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0017a	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00182	4c 8b c0	 mov	 r8, rax
  00185	b2 0f		 mov	 dl, 15
  00187	48 8d 4c 24 78	 lea	 rcx, QWORD PTR op3$[rsp]
  0018c	e8 00 00 00 00	 call	 z900_vfetchc

; 1551 :         ARCH_DEP(wfetchc)(op5, 16-1, effective_addr4 + 80, b4, regs);

  00191	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00199	48 83 c0 50	 add	 rax, 80			; 00000050H
  0019d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001ac	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001b9	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  001c1	4c 8b c0	 mov	 r8, rax
  001c4	b2 0f		 mov	 dl, 15
  001c6	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR op5$[rsp]
  001ce	e8 00 00 00 00	 call	 z900_vfetchc

; 1552 :         ARCH_DEP(wfetchc)(op7, 16-1, effective_addr4 + 112, b4, regs);

  001d3	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001db	48 83 c0 70	 add	 rax, 112		; 00000070H
  001df	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001ee	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001fb	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00203	4c 8b c0	 mov	 r8, rax
  00206	b2 0f		 mov	 dl, 15
  00208	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR op7$[rsp]
  00210	e8 00 00 00 00	 call	 z900_vfetchc

; 1553 : 
; 1554 :         /* Verify access to 2nd operand */
; 1555 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 16-1,

  00215	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00222	41 b9 01 00 00
	00		 mov	 r9d, 1
  00228	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0022e	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  00235	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0023d	e8 00 00 00 00	 call	 z900_validate_operand

; 1556 :             ACCTYPE_WRITE_SKP, regs);
; 1557 : 
; 1558 :         /* When in ar mode, ar3 is used to access the
; 1559 :            operand. The alet is fetched from the pl */
; 1560 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00242	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024a	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0024e	83 e0 04	 and	 eax, 4
  00251	85 c0		 test	 eax, eax
  00253	0f 84 b2 01 00
	00		 je	 $LN24@z900_plo_c
  00259	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00261	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00265	83 f8 40	 cmp	 eax, 64			; 00000040H
  00268	0f 85 9d 01 00
	00		 jne	 $LN24@z900_plo_c

; 1561 :         {
; 1562 :             if(r3 == 0)

  0026e	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00276	75 12		 jne	 SHORT $LN25@z900_plo_c

; 1563 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00278	ba 06 00 00 00	 mov	 edx, 6
  0027d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 z900_program_interrupt
$LN25@z900_plo_c:

; 1564 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  0028a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00292	48 83 c0 44	 add	 rax, 68			; 00000044H
  00296	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002a5	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ad	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002b4	48 8b c8	 mov	 rcx, rax
  002b7	e8 00 00 00 00	 call	 z900_vfetch4
  002bc	89 44 24 38	 mov	 DWORD PTR op4alet$[rsp], eax

; 1565 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  002c0	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002c8	48 83 c0 64	 add	 rax, 100		; 00000064H
  002cc	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002db	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002e3	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002ea	48 8b c8	 mov	 rcx, rax
  002ed	e8 00 00 00 00	 call	 z900_vfetch4
  002f2	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 1566 :             op8alet = ARCH_DEP(wfetch4)(effective_addr4 + 132, b4, regs);

  002f6	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002fe	48 05 84 00 00
	00		 add	 rax, 132		; 00000084H
  00304	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00313	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0031b	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00322	48 8b c8	 mov	 rcx, rax
  00325	e8 00 00 00 00	 call	 z900_vfetch4
  0032a	89 44 24 34	 mov	 DWORD PTR op8alet$[rsp], eax

; 1567 :             regs->AR(r3) = op8alet;

  0032e	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00336	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033e	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  00342	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 1568 :             SET_AEA_AR(regs, r3);

  00349	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00351	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00355	83 f8 40	 cmp	 eax, 64			; 00000040H
  00358	0f 85 a3 00 00
	00		 jne	 $LN26@z900_plo_c
  0035e	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00366	0f 8e 95 00 00
	00		 jle	 $LN26@z900_plo_c
  0036c	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00374	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037c	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00384	75 21		 jne	 SHORT $LN27@z900_plo_c
  00386	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0038d	83 c0 05	 add	 eax, 5
  00390	48 98		 cdqe
  00392	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039a	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  003a5	eb 5a		 jmp	 SHORT $LN28@z900_plo_c
$LN27@z900_plo_c:
  003a7	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  003af	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b7	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  003bf	75 21		 jne	 SHORT $LN29@z900_plo_c
  003c1	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  003c8	83 c0 05	 add	 eax, 5
  003cb	48 98		 cdqe
  003cd	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  003e0	eb 1f		 jmp	 SHORT $LN30@z900_plo_c
$LN29@z900_plo_c:
  003e2	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  003e9	83 c0 05	 add	 eax, 5
  003ec	48 98		 cdqe
  003ee	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f6	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN30@z900_plo_c:
$LN28@z900_plo_c:
$LN26@z900_plo_c:
  00401	33 c0		 xor	 eax, eax
  00403	85 c0		 test	 eax, eax
  00405	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN24@z900_plo_c:

; 1569 :         }
; 1570 : 
; 1571 :         /* Load address of operand 4 */
; 1572 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  0040b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00413	48 83 c0 48	 add	 rax, 72			; 00000048H
  00417	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00426	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0042e	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00435	48 8b c8	 mov	 rcx, rax
  00438	e8 00 00 00 00	 call	 z900_vfetch8
  0043d	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1573 :         op4addr &= ADDRESS_MAXWRAP(regs);

  00442	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00451	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op4addr$[rsp]
  00456	48 23 c8	 and	 rcx, rax
  00459	48 8b c1	 mov	 rax, rcx
  0045c	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1574 :         QW_CHECK(op4addr, regs);

  00461	48 8b 44 24 50	 mov	 rax, QWORD PTR op4addr$[rsp]
  00466	48 83 e0 0f	 and	 rax, 15
  0046a	48 85 c0	 test	 rax, rax
  0046d	74 1b		 je	 SHORT $LN31@z900_plo_c
  0046f	ba 06 00 00 00	 mov	 edx, 6
  00474	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00484	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@z900_plo_c:

; 1575 : 
; 1576 :         /* Load address of operand 6 */
; 1577 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  0048a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00492	48 83 c0 68	 add	 rax, 104		; 00000068H
  00496	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004a5	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004ad	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  004b4	48 8b c8	 mov	 rcx, rax
  004b7	e8 00 00 00 00	 call	 z900_vfetch8
  004bc	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1578 :         op6addr &= ADDRESS_MAXWRAP(regs);

  004c1	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004d0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  004d5	48 23 c8	 and	 rcx, rax
  004d8	48 8b c1	 mov	 rax, rcx
  004db	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1579 :         QW_CHECK(op6addr, regs);

  004e0	48 8b 44 24 40	 mov	 rax, QWORD PTR op6addr$[rsp]
  004e5	48 83 e0 0f	 and	 rax, 15
  004e9	48 85 c0	 test	 rax, rax
  004ec	74 1b		 je	 SHORT $LN32@z900_plo_c
  004ee	ba 06 00 00 00	 mov	 edx, 6
  004f3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004fb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00503	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN32@z900_plo_c:

; 1580 : 
; 1581 :         /* Load address of operand 8 */
; 1582 :         op8addr = ARCH_DEP(wfetch8)(effective_addr4 + 136, b4, regs);

  00509	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00511	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00517	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00526	4c 8b 84 24 00
	01 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0052e	8b 94 24 f8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00535	48 8b c8	 mov	 rcx, rax
  00538	e8 00 00 00 00	 call	 z900_vfetch8
  0053d	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1583 :         op8addr &= ADDRESS_MAXWRAP(regs);

  00542	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00551	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  00556	48 23 c8	 and	 rcx, rax
  00559	48 8b c1	 mov	 rax, rcx
  0055c	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1584 :         QW_CHECK(op8addr, regs);

  00561	48 8b 44 24 48	 mov	 rax, QWORD PTR op8addr$[rsp]
  00566	48 83 e0 0f	 and	 rax, 15
  0056a	48 85 c0	 test	 rax, rax
  0056d	74 1b		 je	 SHORT $LN33@z900_plo_c
  0056f	ba 06 00 00 00	 mov	 edx, 6
  00574	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00584	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@z900_plo_c:

; 1585 : 
; 1586 :         /* Verify access to 8th operand */
; 1587 :         ARCH_DEP(validate_operand) (op8addr, r3, 16-1,ACCTYPE_WRITE_SKP, regs);

  0058a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00592	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00597	41 b9 01 00 00
	00		 mov	 r9d, 1
  0059d	41 b8 0f 00 00
	00		 mov	 r8d, 15
  005a3	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  005aa	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  005af	e8 00 00 00 00	 call	 z900_validate_operand

; 1588 : 
; 1589 :         /* Verify access to 6th operand */
; 1590 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  005b4	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bc	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  005c0	83 e0 04	 and	 eax, 4
  005c3	85 c0		 test	 eax, eax
  005c5	0f 84 f2 00 00
	00		 je	 $LN34@z900_plo_c
  005cb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d3	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005d7	83 f8 40	 cmp	 eax, 64			; 00000040H
  005da	0f 85 dd 00 00
	00		 jne	 $LN34@z900_plo_c

; 1591 :         {
; 1592 :             regs->AR(r3) = op6alet;

  005e0	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005e8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f0	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  005f4	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 1593 :             SET_AEA_AR(regs, r3);

  005fb	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00603	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00607	83 f8 40	 cmp	 eax, 64			; 00000040H
  0060a	0f 85 a3 00 00
	00		 jne	 $LN35@z900_plo_c
  00610	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00618	0f 8e 95 00 00
	00		 jle	 $LN35@z900_plo_c
  0061e	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00626	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062e	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00636	75 21		 jne	 SHORT $LN36@z900_plo_c
  00638	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0063f	83 c0 05	 add	 eax, 5
  00642	48 98		 cdqe
  00644	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0064c	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00657	eb 5a		 jmp	 SHORT $LN37@z900_plo_c
$LN36@z900_plo_c:
  00659	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00661	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00669	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00671	75 21		 jne	 SHORT $LN38@z900_plo_c
  00673	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0067a	83 c0 05	 add	 eax, 5
  0067d	48 98		 cdqe
  0067f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00687	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00692	eb 1f		 jmp	 SHORT $LN39@z900_plo_c
$LN38@z900_plo_c:
  00694	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0069b	83 c0 05	 add	 eax, 5
  0069e	48 98		 cdqe
  006a0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a8	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN39@z900_plo_c:
$LN37@z900_plo_c:
$LN35@z900_plo_c:
  006b3	33 c0		 xor	 eax, eax
  006b5	85 c0		 test	 eax, eax
  006b7	0f 85 3e ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN34@z900_plo_c:

; 1594 :         }
; 1595 :         ARCH_DEP(validate_operand) (op6addr, r3, 16-1, ACCTYPE_WRITE_SKP, regs);

  006bd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ca	41 b9 01 00 00
	00		 mov	 r9d, 1
  006d0	41 b8 0f 00 00
	00		 mov	 r8d, 15
  006d6	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  006dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  006e2	e8 00 00 00 00	 call	 z900_validate_operand

; 1596 : 
; 1597 :         /* Store 3th op at 4th op */
; 1598 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  006e7	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ef	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  006f3	83 e0 04	 and	 eax, 4
  006f6	85 c0		 test	 eax, eax
  006f8	0f 84 f2 00 00
	00		 je	 $LN40@z900_plo_c
  006fe	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00706	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0070a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0070d	0f 85 dd 00 00
	00		 jne	 $LN40@z900_plo_c

; 1599 :         {
; 1600 :             regs->AR(r3) = op4alet;

  00713	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0071b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00723	8b 54 24 38	 mov	 edx, DWORD PTR op4alet$[rsp]
  00727	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@z900_plo_c:

; 1601 :             SET_AEA_AR(regs, r3);

  0072e	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00736	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0073a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0073d	0f 85 a3 00 00
	00		 jne	 $LN41@z900_plo_c
  00743	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  0074b	0f 8e 95 00 00
	00		 jle	 $LN41@z900_plo_c
  00751	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00759	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00761	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00769	75 21		 jne	 SHORT $LN42@z900_plo_c
  0076b	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00772	83 c0 05	 add	 eax, 5
  00775	48 98		 cdqe
  00777	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077f	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0078a	eb 5a		 jmp	 SHORT $LN43@z900_plo_c
$LN42@z900_plo_c:
  0078c	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00794	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079c	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  007a4	75 21		 jne	 SHORT $LN44@z900_plo_c
  007a6	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  007ad	83 c0 05	 add	 eax, 5
  007b0	48 98		 cdqe
  007b2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ba	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  007c5	eb 1f		 jmp	 SHORT $LN45@z900_plo_c
$LN44@z900_plo_c:
  007c7	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  007ce	83 c0 05	 add	 eax, 5
  007d1	48 98		 cdqe
  007d3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007db	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN45@z900_plo_c:
$LN43@z900_plo_c:
$LN41@z900_plo_c:
  007e6	33 c0		 xor	 eax, eax
  007e8	85 c0		 test	 eax, eax
  007ea	0f 85 3e ff ff
	ff		 jne	 $LN13@z900_plo_c
$LN40@z900_plo_c:

; 1602 :         }
; 1603 :         ARCH_DEP(vstorec)(op3, 16-1, op4addr, r3, regs);

  007f0	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007fd	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  00805	4c 8b 44 24 50	 mov	 r8, QWORD PTR op4addr$[rsp]
  0080a	b2 0f		 mov	 dl, 15
  0080c	48 8d 4c 24 78	 lea	 rcx, QWORD PTR op3$[rsp]
  00811	e8 00 00 00 00	 call	 z900_vstorec

; 1604 : 
; 1605 :         /* Store 5th op at 6th op */
; 1606 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00816	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081e	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00822	83 e0 04	 and	 eax, 4
  00825	85 c0		 test	 eax, eax
  00827	0f 84 f2 00 00
	00		 je	 $LN46@z900_plo_c
  0082d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00835	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00839	83 f8 40	 cmp	 eax, 64			; 00000040H
  0083c	0f 85 dd 00 00
	00		 jne	 $LN46@z900_plo_c

; 1607 :         {
; 1608 :             regs->AR(r3) = op6alet;

  00842	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0084a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00852	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  00856	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN16@z900_plo_c:

; 1609 :             SET_AEA_AR(regs, r3);

  0085d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00865	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00869	83 f8 40	 cmp	 eax, 64			; 00000040H
  0086c	0f 85 a3 00 00
	00		 jne	 $LN47@z900_plo_c
  00872	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  0087a	0f 8e 95 00 00
	00		 jle	 $LN47@z900_plo_c
  00880	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00888	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00890	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00898	75 21		 jne	 SHORT $LN48@z900_plo_c
  0089a	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  008a1	83 c0 05	 add	 eax, 5
  008a4	48 98		 cdqe
  008a6	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ae	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  008b9	eb 5a		 jmp	 SHORT $LN49@z900_plo_c
$LN48@z900_plo_c:
  008bb	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  008c3	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008cb	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  008d3	75 21		 jne	 SHORT $LN50@z900_plo_c
  008d5	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  008dc	83 c0 05	 add	 eax, 5
  008df	48 98		 cdqe
  008e1	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e9	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  008f4	eb 1f		 jmp	 SHORT $LN51@z900_plo_c
$LN50@z900_plo_c:
  008f6	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  008fd	83 c0 05	 add	 eax, 5
  00900	48 98		 cdqe
  00902	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0090a	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN51@z900_plo_c:
$LN49@z900_plo_c:
$LN47@z900_plo_c:
  00915	33 c0		 xor	 eax, eax
  00917	85 c0		 test	 eax, eax
  00919	0f 85 3e ff ff
	ff		 jne	 $LN16@z900_plo_c
$LN46@z900_plo_c:

; 1610 :         }
; 1611 :         ARCH_DEP(vstorec)(op5, 16-1, op6addr, r3, regs);

  0091f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00927	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0092c	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  00934	4c 8b 44 24 40	 mov	 r8, QWORD PTR op6addr$[rsp]
  00939	b2 0f		 mov	 dl, 15
  0093b	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR op5$[rsp]
  00943	e8 00 00 00 00	 call	 z900_vstorec

; 1612 : 
; 1613 :         /* Store 7th op at 8th op */
; 1614 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00948	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00950	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00954	83 e0 04	 and	 eax, 4
  00957	85 c0		 test	 eax, eax
  00959	0f 84 f2 00 00
	00		 je	 $LN52@z900_plo_c
  0095f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00967	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0096b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0096e	0f 85 dd 00 00
	00		 jne	 $LN52@z900_plo_c

; 1615 :         {
; 1616 :             regs->AR(r3) = op8alet;

  00974	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0097c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00984	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  00988	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN19@z900_plo_c:

; 1617 :             SET_AEA_AR(regs, r3);

  0098f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00997	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0099b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0099e	0f 85 a3 00 00
	00		 jne	 $LN53@z900_plo_c
  009a4	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  009ac	0f 8e 95 00 00
	00		 jle	 $LN53@z900_plo_c
  009b2	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  009ba	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c2	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  009ca	75 21		 jne	 SHORT $LN54@z900_plo_c
  009cc	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  009d3	83 c0 05	 add	 eax, 5
  009d6	48 98		 cdqe
  009d8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009e0	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  009eb	eb 5a		 jmp	 SHORT $LN55@z900_plo_c
$LN54@z900_plo_c:
  009ed	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  009f5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009fd	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00a05	75 21		 jne	 SHORT $LN56@z900_plo_c
  00a07	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00a0e	83 c0 05	 add	 eax, 5
  00a11	48 98		 cdqe
  00a13	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a1b	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00a26	eb 1f		 jmp	 SHORT $LN57@z900_plo_c
$LN56@z900_plo_c:
  00a28	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00a2f	83 c0 05	 add	 eax, 5
  00a32	48 98		 cdqe
  00a34	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a3c	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN57@z900_plo_c:
$LN55@z900_plo_c:
$LN53@z900_plo_c:
  00a47	33 c0		 xor	 eax, eax
  00a49	85 c0		 test	 eax, eax
  00a4b	0f 85 3e ff ff
	ff		 jne	 $LN19@z900_plo_c
$LN52@z900_plo_c:

; 1618 :         }
; 1619 :         ARCH_DEP(vstorec)(op7, 16-1, op8addr, r3, regs);

  00a51	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a59	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a5e	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  00a66	4c 8b 44 24 48	 mov	 r8, QWORD PTR op8addr$[rsp]
  00a6b	b2 0f		 mov	 dl, 15
  00a6d	48 8d 8c 24 98
	00 00 00	 lea	 rcx, QWORD PTR op7$[rsp]
  00a75	e8 00 00 00 00	 call	 z900_vstorec

; 1620 : 
; 1621 :         /* Store 1st op replacement value at 2nd op */
; 1622 :         ARCH_DEP(vstorec)(op1r, 16-1, effective_addr2, b2, regs);

  00a7a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a82	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a87	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  00a8f	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00a97	b2 0f		 mov	 dl, 15
  00a99	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR op1r$[rsp]
  00aa1	e8 00 00 00 00	 call	 z900_vstorec

; 1623 : 
; 1624 :         return 0;

  00aa6	33 c0		 xor	 eax, eax
  00aa8	eb 30		 jmp	 SHORT $LN1@z900_plo_c

; 1625 :     }

  00aaa	eb 2e		 jmp	 SHORT $LN23@z900_plo_c
$LN22@z900_plo_c:

; 1626 :     else
; 1627 :     {
; 1628 :         ARCH_DEP(vstorec)(op2, 16-1, effective_addr4 + 0, b4, regs);

  00aac	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ab4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ab9	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00ac1	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  00ac9	b2 0f		 mov	 dl, 15
  00acb	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op2$[rsp]
  00ad0	e8 00 00 00 00	 call	 z900_vstorec

; 1629 : 
; 1630 :         return 1;

  00ad5	b8 01 00 00 00	 mov	 eax, 1
$LN23@z900_plo_c:
$LN1@z900_plo_c:

; 1631 :     }
; 1632 : }

  00ada	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ae2	48 33 cc	 xor	 rcx, rsp
  00ae5	e8 00 00 00 00	 call	 __security_check_cookie
  00aea	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00af1	c3		 ret	 0
z900_plo_cststx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op8alet$ = 52
op4alet$ = 56
op6addr$ = 64
op8addr$ = 72
op4addr$ = 80
op2$ = 88
op3$ = 96
op5$ = 104
op7$ = 112
r1$ = 144
r3$ = 152
effective_addr2$ = 160
b2$ = 168
effective_addr4$ = 176
b4$ = 184
regs$ = 192
z900_plo_cststgr PROC

; 1416 : {

$LN57:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1417 : U64 op2,
; 1418 :     op3,
; 1419 :     op5,
; 1420 :     op7;
; 1421 : U32 op4alet = 0,

  00019	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1422 :     op6alet = 0,

  00021	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 1423 :     op8alet = 0;

  00029	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op8alet$[rsp], 0

; 1424 : VADR op4addr,
; 1425 :     op6addr,
; 1426 :     op8addr;
; 1427 : 
; 1428 :     ODD_CHECK(r1, regs);

  00031	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00038	83 e0 01	 and	 eax, 1
  0003b	85 c0		 test	 eax, eax
  0003d	74 1b		 je	 SHORT $LN17@z900_plo_c
  0003f	ba 06 00 00 00	 mov	 edx, 6
  00044	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00054	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_plo_c:

; 1429 :     DW_CHECK(effective_addr2, regs);

  0005a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00062	48 83 e0 07	 and	 rax, 7
  00066	48 85 c0	 test	 rax, rax
  00069	74 1b		 je	 SHORT $LN18@z900_plo_c
  0006b	ba 06 00 00 00	 mov	 edx, 6
  00070	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00080	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@z900_plo_c:

; 1430 :     DW_CHECK(effective_addr4, regs);

  00086	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0008e	48 83 e0 07	 and	 rax, 7
  00092	48 85 c0	 test	 rax, rax
  00095	74 1b		 je	 SHORT $LN19@z900_plo_c
  00097	ba 06 00 00 00	 mov	 edx, 6
  0009c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ac	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_c:

; 1431 : 
; 1432 :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000b2	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ba	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000c1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c9	e8 00 00 00 00	 call	 z900_vfetch8
  000ce	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 1433 : 
; 1434 :     if(regs->GR_G(r1) == op2)

  000d3	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  000db	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  000e8	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  000f0	0f 85 2d 09 00
	00		 jne	 $LN20@z900_plo_c

; 1435 :     {
; 1436 :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  000f6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000fe	48 83 c0 38	 add	 rax, 56			; 00000038H
  00102	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00111	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00119	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00120	48 8b c8	 mov	 rcx, rax
  00123	e8 00 00 00 00	 call	 z900_vfetch8
  00128	48 89 44 24 60	 mov	 QWORD PTR op3$[rsp], rax

; 1437 :         op5 = ARCH_DEP(wfetch8)(effective_addr4 + 88, b4, regs);

  0012d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00135	48 83 c0 58	 add	 rax, 88			; 00000058H
  00139	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00148	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00150	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00157	48 8b c8	 mov	 rcx, rax
  0015a	e8 00 00 00 00	 call	 z900_vfetch8
  0015f	48 89 44 24 68	 mov	 QWORD PTR op5$[rsp], rax

; 1438 :         op7 = ARCH_DEP(wfetch8)(effective_addr4 + 120, b4, regs);

  00164	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0016c	48 83 c0 78	 add	 rax, 120		; 00000078H
  00170	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0017f	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00187	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0018e	48 8b c8	 mov	 rcx, rax
  00191	e8 00 00 00 00	 call	 z900_vfetch8
  00196	48 89 44 24 70	 mov	 QWORD PTR op7$[rsp], rax

; 1439 : 
; 1440 :         /* Verify access to 2nd operand */
; 1441 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  0019b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a8	41 b9 01 00 00
	00		 mov	 r9d, 1
  001ae	41 b8 07 00 00
	00		 mov	 r8d, 7
  001b4	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  001bb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001c3	e8 00 00 00 00	 call	 z900_validate_operand

; 1442 :             ACCTYPE_WRITE_SKP, regs);
; 1443 : 
; 1444 :         /* When in ar mode, ar3 is used to access the
; 1445 :            operand. The alet is fetched from the pl */
; 1446 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001c8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d0	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001d4	83 e0 04	 and	 eax, 4
  001d7	85 c0		 test	 eax, eax
  001d9	0f 84 b2 01 00
	00		 je	 $LN22@z900_plo_c
  001df	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001eb	83 f8 40	 cmp	 eax, 64			; 00000040H
  001ee	0f 85 9d 01 00
	00		 jne	 $LN22@z900_plo_c

; 1447 :         {
; 1448 :             if(r3 == 0)

  001f4	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001fc	75 12		 jne	 SHORT $LN23@z900_plo_c

; 1449 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001fe	ba 06 00 00 00	 mov	 edx, 6
  00203	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN23@z900_plo_c:

; 1450 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  00210	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00218	48 83 c0 44	 add	 rax, 68			; 00000044H
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00224	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0022b	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00233	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0023a	48 8b c8	 mov	 rcx, rax
  0023d	e8 00 00 00 00	 call	 z900_vfetch4
  00242	89 44 24 38	 mov	 DWORD PTR op4alet$[rsp], eax

; 1451 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  00246	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0024e	48 83 c0 64	 add	 rax, 100		; 00000064H
  00252	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00261	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00269	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00270	48 8b c8	 mov	 rcx, rax
  00273	e8 00 00 00 00	 call	 z900_vfetch4
  00278	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 1452 :             op8alet = ARCH_DEP(wfetch4)(effective_addr4 + 132, b4, regs);

  0027c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00284	48 05 84 00 00
	00		 add	 rax, 132		; 00000084H
  0028a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00292	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00299	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002a1	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002a8	48 8b c8	 mov	 rcx, rax
  002ab	e8 00 00 00 00	 call	 z900_vfetch4
  002b0	89 44 24 34	 mov	 DWORD PTR op8alet$[rsp], eax

; 1453 :             regs->AR(r3) = op8alet;

  002b4	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002bc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c4	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  002c8	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN4@z900_plo_c:

; 1454 :             SET_AEA_AR(regs, r3);

  002cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  002db	83 f8 40	 cmp	 eax, 64			; 00000040H
  002de	0f 85 a3 00 00
	00		 jne	 $LN24@z900_plo_c
  002e4	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  002ec	0f 8e 95 00 00
	00		 jle	 $LN24@z900_plo_c
  002f2	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002fa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00302	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0030a	75 21		 jne	 SHORT $LN25@z900_plo_c
  0030c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00313	83 c0 05	 add	 eax, 5
  00316	48 98		 cdqe
  00318	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0032b	eb 5a		 jmp	 SHORT $LN26@z900_plo_c
$LN25@z900_plo_c:
  0032d	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00335	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033d	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00345	75 21		 jne	 SHORT $LN27@z900_plo_c
  00347	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0034e	83 c0 05	 add	 eax, 5
  00351	48 98		 cdqe
  00353	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035b	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00366	eb 1f		 jmp	 SHORT $LN28@z900_plo_c
$LN27@z900_plo_c:
  00368	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0036f	83 c0 05	 add	 eax, 5
  00372	48 98		 cdqe
  00374	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037c	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN28@z900_plo_c:
$LN26@z900_plo_c:
$LN24@z900_plo_c:
  00387	33 c0		 xor	 eax, eax
  00389	85 c0		 test	 eax, eax
  0038b	0f 85 3e ff ff
	ff		 jne	 $LN4@z900_plo_c
$LN22@z900_plo_c:

; 1455 :         }
; 1456 : 
; 1457 :         /* Load address of operand 4 */
; 1458 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  00391	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00399	48 83 c0 48	 add	 rax, 72			; 00000048H
  0039d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003ac	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003b4	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003bb	48 8b c8	 mov	 rcx, rax
  003be	e8 00 00 00 00	 call	 z900_vfetch8
  003c3	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1459 :         op4addr &= ADDRESS_MAXWRAP(regs);

  003c8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003d7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op4addr$[rsp]
  003dc	48 23 c8	 and	 rcx, rax
  003df	48 8b c1	 mov	 rax, rcx
  003e2	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1460 :         DW_CHECK(op4addr, regs);

  003e7	48 8b 44 24 50	 mov	 rax, QWORD PTR op4addr$[rsp]
  003ec	48 83 e0 07	 and	 rax, 7
  003f0	48 85 c0	 test	 rax, rax
  003f3	74 1b		 je	 SHORT $LN29@z900_plo_c
  003f5	ba 06 00 00 00	 mov	 edx, 6
  003fa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@z900_plo_c:

; 1461 : 
; 1462 :         /* Load address of operand 6 */
; 1463 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  00410	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00418	48 83 c0 68	 add	 rax, 104		; 00000068H
  0041c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00424	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0042b	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00433	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0043a	48 8b c8	 mov	 rcx, rax
  0043d	e8 00 00 00 00	 call	 z900_vfetch8
  00442	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1464 :         op6addr &= ADDRESS_MAXWRAP(regs);

  00447	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00456	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  0045b	48 23 c8	 and	 rcx, rax
  0045e	48 8b c1	 mov	 rax, rcx
  00461	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1465 :         DW_CHECK(op6addr, regs);

  00466	48 8b 44 24 40	 mov	 rax, QWORD PTR op6addr$[rsp]
  0046b	48 83 e0 07	 and	 rax, 7
  0046f	48 85 c0	 test	 rax, rax
  00472	74 1b		 je	 SHORT $LN30@z900_plo_c
  00474	ba 06 00 00 00	 mov	 edx, 6
  00479	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00481	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00489	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@z900_plo_c:

; 1466 : 
; 1467 :         /* Load address of operand 8 */
; 1468 :         op8addr = ARCH_DEP(wfetch8)(effective_addr4 + 136, b4, regs);

  0048f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00497	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0049d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a5	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004ac	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004b4	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  004bb	48 8b c8	 mov	 rcx, rax
  004be	e8 00 00 00 00	 call	 z900_vfetch8
  004c3	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1469 :         op8addr &= ADDRESS_MAXWRAP(regs);

  004c8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004d7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  004dc	48 23 c8	 and	 rcx, rax
  004df	48 8b c1	 mov	 rax, rcx
  004e2	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1470 :         DW_CHECK(op8addr, regs);

  004e7	48 8b 44 24 48	 mov	 rax, QWORD PTR op8addr$[rsp]
  004ec	48 83 e0 07	 and	 rax, 7
  004f0	48 85 c0	 test	 rax, rax
  004f3	74 1b		 je	 SHORT $LN31@z900_plo_c
  004f5	ba 06 00 00 00	 mov	 edx, 6
  004fa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00502	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@z900_plo_c:

; 1471 : 
; 1472 :         /* Verify access to 8th operand */
; 1473 :         ARCH_DEP(validate_operand) (op8addr, r3, 8-1,ACCTYPE_WRITE_SKP, regs);

  00510	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00518	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0051d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00523	41 b8 07 00 00
	00		 mov	 r8d, 7
  00529	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00530	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  00535	e8 00 00 00 00	 call	 z900_validate_operand

; 1474 : 
; 1475 :         /* Verify access to 6th operand */
; 1476 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0053a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00542	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00546	83 e0 04	 and	 eax, 4
  00549	85 c0		 test	 eax, eax
  0054b	0f 84 f2 00 00
	00		 je	 $LN32@z900_plo_c
  00551	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00559	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0055d	83 f8 40	 cmp	 eax, 64			; 00000040H
  00560	0f 85 dd 00 00
	00		 jne	 $LN32@z900_plo_c

; 1477 :         {
; 1478 :             regs->AR(r3) = op6alet;

  00566	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0056e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00576	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  0057a	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 1479 :             SET_AEA_AR(regs, r3);

  00581	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00589	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0058d	83 f8 40	 cmp	 eax, 64			; 00000040H
  00590	0f 85 a3 00 00
	00		 jne	 $LN33@z900_plo_c
  00596	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  0059e	0f 8e 95 00 00
	00		 jle	 $LN33@z900_plo_c
  005a4	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005ac	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b4	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  005bc	75 21		 jne	 SHORT $LN34@z900_plo_c
  005be	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  005c5	83 c0 05	 add	 eax, 5
  005c8	48 98		 cdqe
  005ca	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d2	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  005dd	eb 5a		 jmp	 SHORT $LN35@z900_plo_c
$LN34@z900_plo_c:
  005df	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005e7	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ef	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  005f7	75 21		 jne	 SHORT $LN36@z900_plo_c
  005f9	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00600	83 c0 05	 add	 eax, 5
  00603	48 98		 cdqe
  00605	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060d	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00618	eb 1f		 jmp	 SHORT $LN37@z900_plo_c
$LN36@z900_plo_c:
  0061a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00621	83 c0 05	 add	 eax, 5
  00624	48 98		 cdqe
  00626	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062e	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN37@z900_plo_c:
$LN35@z900_plo_c:
$LN33@z900_plo_c:
  00639	33 c0		 xor	 eax, eax
  0063b	85 c0		 test	 eax, eax
  0063d	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN32@z900_plo_c:

; 1480 :         }
; 1481 :         ARCH_DEP(validate_operand) (op6addr, r3, 8-1,ACCTYPE_WRITE_SKP, regs);

  00643	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0064b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00650	41 b9 01 00 00
	00		 mov	 r9d, 1
  00656	41 b8 07 00 00
	00		 mov	 r8d, 7
  0065c	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00663	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00668	e8 00 00 00 00	 call	 z900_validate_operand

; 1482 : 
; 1483 :         /* Store 3rd op at 4th op */
; 1484 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0066d	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00675	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00679	83 e0 04	 and	 eax, 4
  0067c	85 c0		 test	 eax, eax
  0067e	0f 84 f2 00 00
	00		 je	 $LN38@z900_plo_c
  00684	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0068c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00690	83 f8 40	 cmp	 eax, 64			; 00000040H
  00693	0f 85 dd 00 00
	00		 jne	 $LN38@z900_plo_c

; 1485 :         {
; 1486 :             regs->AR(r3) = op4alet;

  00699	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  006a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a9	8b 54 24 38	 mov	 edx, DWORD PTR op4alet$[rsp]
  006ad	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 1487 :             SET_AEA_AR(regs, r3);

  006b4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006bc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  006c0	83 f8 40	 cmp	 eax, 64			; 00000040H
  006c3	0f 85 a3 00 00
	00		 jne	 $LN39@z900_plo_c
  006c9	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  006d1	0f 8e 95 00 00
	00		 jle	 $LN39@z900_plo_c
  006d7	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  006df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e7	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  006ef	75 21		 jne	 SHORT $LN40@z900_plo_c
  006f1	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  006f8	83 c0 05	 add	 eax, 5
  006fb	48 98		 cdqe
  006fd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00705	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00710	eb 5a		 jmp	 SHORT $LN41@z900_plo_c
$LN40@z900_plo_c:
  00712	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0071a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00722	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0072a	75 21		 jne	 SHORT $LN42@z900_plo_c
  0072c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00733	83 c0 05	 add	 eax, 5
  00736	48 98		 cdqe
  00738	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00740	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0074b	eb 1f		 jmp	 SHORT $LN43@z900_plo_c
$LN42@z900_plo_c:
  0074d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00754	83 c0 05	 add	 eax, 5
  00757	48 98		 cdqe
  00759	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00761	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN43@z900_plo_c:
$LN41@z900_plo_c:
$LN39@z900_plo_c:
  0076c	33 c0		 xor	 eax, eax
  0076e	85 c0		 test	 eax, eax
  00770	0f 85 3e ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN38@z900_plo_c:

; 1488 :         }
; 1489 :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  00776	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0077e	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00786	48 8b 54 24 50	 mov	 rdx, QWORD PTR op4addr$[rsp]
  0078b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op3$[rsp]
  00790	e8 00 00 00 00	 call	 z900_vstore8

; 1490 : 
; 1491 :         /* Store 5th op at 6th op */
; 1492 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00795	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  007a1	83 e0 04	 and	 eax, 4
  007a4	85 c0		 test	 eax, eax
  007a6	0f 84 f2 00 00
	00		 je	 $LN44@z900_plo_c
  007ac	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007b8	83 f8 40	 cmp	 eax, 64			; 00000040H
  007bb	0f 85 dd 00 00
	00		 jne	 $LN44@z900_plo_c

; 1493 :         {
; 1494 :             regs->AR(r3) = op6alet;

  007c1	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  007c9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007d1	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  007d5	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@z900_plo_c:

; 1495 :             SET_AEA_AR(regs, r3);

  007dc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007e8	83 f8 40	 cmp	 eax, 64			; 00000040H
  007eb	0f 85 a3 00 00
	00		 jne	 $LN45@z900_plo_c
  007f1	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  007f9	0f 8e 95 00 00
	00		 jle	 $LN45@z900_plo_c
  007ff	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00807	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080f	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00817	75 21		 jne	 SHORT $LN46@z900_plo_c
  00819	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00820	83 c0 05	 add	 eax, 5
  00823	48 98		 cdqe
  00825	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0082d	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00838	eb 5a		 jmp	 SHORT $LN47@z900_plo_c
$LN46@z900_plo_c:
  0083a	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00842	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0084a	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00852	75 21		 jne	 SHORT $LN48@z900_plo_c
  00854	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0085b	83 c0 05	 add	 eax, 5
  0085e	48 98		 cdqe
  00860	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00868	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00873	eb 1f		 jmp	 SHORT $LN49@z900_plo_c
$LN48@z900_plo_c:
  00875	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0087c	83 c0 05	 add	 eax, 5
  0087f	48 98		 cdqe
  00881	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00889	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN49@z900_plo_c:
$LN47@z900_plo_c:
$LN45@z900_plo_c:
  00894	33 c0		 xor	 eax, eax
  00896	85 c0		 test	 eax, eax
  00898	0f 85 3e ff ff
	ff		 jne	 $LN13@z900_plo_c
$LN44@z900_plo_c:

; 1496 :         }
; 1497 :         ARCH_DEP(vstore8)(op5, op6addr, r3, regs);

  0089e	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008a6	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  008ae	48 8b 54 24 40	 mov	 rdx, QWORD PTR op6addr$[rsp]
  008b3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op5$[rsp]
  008b8	e8 00 00 00 00	 call	 z900_vstore8

; 1498 : 
; 1499 :         /* Store 7th op at 8th op */
; 1500 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  008bd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c5	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  008c9	83 e0 04	 and	 eax, 4
  008cc	85 c0		 test	 eax, eax
  008ce	0f 84 f2 00 00
	00		 je	 $LN50@z900_plo_c
  008d4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008dc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  008e0	83 f8 40	 cmp	 eax, 64			; 00000040H
  008e3	0f 85 dd 00 00
	00		 jne	 $LN50@z900_plo_c

; 1501 :         {
; 1502 :             regs->AR(r3) = op8alet;

  008e9	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  008f1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f9	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  008fd	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN16@z900_plo_c:

; 1503 :             SET_AEA_AR(regs, r3);

  00904	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0090c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00910	83 f8 40	 cmp	 eax, 64			; 00000040H
  00913	0f 85 a3 00 00
	00		 jne	 $LN51@z900_plo_c
  00919	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00921	0f 8e 95 00 00
	00		 jle	 $LN51@z900_plo_c
  00927	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0092f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00937	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0093f	75 21		 jne	 SHORT $LN52@z900_plo_c
  00941	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00948	83 c0 05	 add	 eax, 5
  0094b	48 98		 cdqe
  0094d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00955	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00960	eb 5a		 jmp	 SHORT $LN53@z900_plo_c
$LN52@z900_plo_c:
  00962	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0096a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00972	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0097a	75 21		 jne	 SHORT $LN54@z900_plo_c
  0097c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00983	83 c0 05	 add	 eax, 5
  00986	48 98		 cdqe
  00988	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00990	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0099b	eb 1f		 jmp	 SHORT $LN55@z900_plo_c
$LN54@z900_plo_c:
  0099d	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  009a4	83 c0 05	 add	 eax, 5
  009a7	48 98		 cdqe
  009a9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009b1	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN55@z900_plo_c:
$LN53@z900_plo_c:
$LN51@z900_plo_c:
  009bc	33 c0		 xor	 eax, eax
  009be	85 c0		 test	 eax, eax
  009c0	0f 85 3e ff ff
	ff		 jne	 $LN16@z900_plo_c
$LN50@z900_plo_c:

; 1504 :         }
; 1505 :         ARCH_DEP(vstore8)(op7, op8addr, r3, regs);

  009c6	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009ce	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  009d6	48 8b 54 24 48	 mov	 rdx, QWORD PTR op8addr$[rsp]
  009db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op7$[rsp]
  009e0	e8 00 00 00 00	 call	 z900_vstore8

; 1506 : 
; 1507 :         /* Store 1st op replacement at 2nd op */
; 1508 :         ARCH_DEP(vstore8)(regs->GR_G(r1+1), effective_addr2, b2, regs);

  009e5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  009ec	ff c0		 inc	 eax
  009ee	48 98		 cdqe
  009f0	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009f8	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  00a00	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00a08	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a10	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00a18	e8 00 00 00 00	 call	 z900_vstore8

; 1509 : 
; 1510 :         return 0;

  00a1d	33 c0		 xor	 eax, eax
  00a1f	eb 24		 jmp	 SHORT $LN1@z900_plo_c

; 1511 :     }

  00a21	eb 22		 jmp	 SHORT $LN21@z900_plo_c
$LN20@z900_plo_c:

; 1512 :     else
; 1513 :     {
; 1514 :         regs->GR_G(r1) = op2;

  00a23	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00a2b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a33	48 8b 54 24 58	 mov	 rdx, QWORD PTR op2$[rsp]
  00a38	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 1515 : 
; 1516 :         return 1;

  00a40	b8 01 00 00 00	 mov	 eax, 1
$LN21@z900_plo_c:
$LN1@z900_plo_c:

; 1517 :     }
; 1518 : }

  00a45	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00a4c	c3		 ret	 0
z900_plo_cststgr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op8alet$ = 52
op4alet$ = 56
op6addr$ = 64
op8addr$ = 72
op4addr$ = 80
op2$ = 88
op1c$ = 96
op3$ = 104
op5$ = 112
op7$ = 120
op1r$ = 128
r1$ = 160
r3$ = 168
effective_addr2$ = 176
b2$ = 184
effective_addr4$ = 192
b4$ = 200
regs$ = 208
z900_plo_cststg PROC

; 1291 : {

$LN59:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1292 : U64 op1c,
; 1293 :     op1r,
; 1294 :     op2,
; 1295 :     op3,
; 1296 :     op5,
; 1297 :     op7;
; 1298 : U32 op4alet = 0,

  00019	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1299 :     op6alet = 0,

  00021	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 1300 :     op8alet = 0;

  00029	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op8alet$[rsp], 0
$LN4@z900_plo_c:

; 1301 : VADR op4addr,
; 1302 :     op6addr,
; 1303 :     op8addr;
; 1304 : 
; 1305 :     UNREFERENCED(r1);

  00031	33 c0		 xor	 eax, eax
  00033	85 c0		 test	 eax, eax
  00035	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 1306 : 
; 1307 :     DW_CHECK(effective_addr2, regs);

  00037	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0003f	48 83 e0 07	 and	 rax, 7
  00043	48 85 c0	 test	 rax, rax
  00046	74 1b		 je	 SHORT $LN20@z900_plo_c
  00048	ba 06 00 00 00	 mov	 edx, 6
  0004d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00055	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@z900_plo_c:

; 1308 :     DW_CHECK(effective_addr4, regs);

  00063	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0006b	48 83 e0 07	 and	 rax, 7
  0006f	48 85 c0	 test	 rax, rax
  00072	74 1b		 je	 SHORT $LN21@z900_plo_c
  00074	ba 06 00 00 00	 mov	 edx, 6
  00079	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00089	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN21@z900_plo_c:

; 1309 : 
; 1310 :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  0008f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00097	48 83 c0 08	 add	 rax, 8
  0009b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000aa	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000b2	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000b9	48 8b c8	 mov	 rcx, rax
  000bc	e8 00 00 00 00	 call	 z900_vfetch8
  000c1	48 89 44 24 60	 mov	 QWORD PTR op1c$[rsp], rax

; 1311 :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000c6	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ce	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000dd	e8 00 00 00 00	 call	 z900_vfetch8
  000e2	48 89 44 24 58	 mov	 QWORD PTR op2$[rsp], rax

; 1312 : 
; 1313 :     if(op1c == op2)

  000e7	48 8b 44 24 58	 mov	 rax, QWORD PTR op2$[rsp]
  000ec	48 39 44 24 60	 cmp	 QWORD PTR op1c$[rsp], rax
  000f1	0f 85 54 09 00
	00		 jne	 $LN22@z900_plo_c

; 1314 :     {
; 1315 :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000f7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000ff	48 83 c0 18	 add	 rax, 24
  00103	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00112	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0011a	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00121	48 8b c8	 mov	 rcx, rax
  00124	e8 00 00 00 00	 call	 z900_vfetch8
  00129	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR op1r$[rsp], rax

; 1316 :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  00131	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00139	48 83 c0 38	 add	 rax, 56			; 00000038H
  0013d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0014c	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00154	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0015b	48 8b c8	 mov	 rcx, rax
  0015e	e8 00 00 00 00	 call	 z900_vfetch8
  00163	48 89 44 24 68	 mov	 QWORD PTR op3$[rsp], rax

; 1317 :         op5 = ARCH_DEP(wfetch8)(effective_addr4 + 88, b4, regs);

  00168	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00170	48 83 c0 58	 add	 rax, 88			; 00000058H
  00174	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00183	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018b	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00192	48 8b c8	 mov	 rcx, rax
  00195	e8 00 00 00 00	 call	 z900_vfetch8
  0019a	48 89 44 24 70	 mov	 QWORD PTR op5$[rsp], rax

; 1318 :         op7 = ARCH_DEP(wfetch8)(effective_addr4 + 120, b4, regs);

  0019f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001a7	48 83 c0 78	 add	 rax, 120		; 00000078H
  001ab	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001ba	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c2	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001c9	48 8b c8	 mov	 rcx, rax
  001cc	e8 00 00 00 00	 call	 z900_vfetch8
  001d1	48 89 44 24 78	 mov	 QWORD PTR op7$[rsp], rax

; 1319 : 
; 1320 :         /* Verify access to 2nd operand */
; 1321 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  001d6	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001de	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e3	41 b9 01 00 00
	00		 mov	 r9d, 1
  001e9	41 b8 07 00 00
	00		 mov	 r8d, 7
  001ef	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  001f6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001fe	e8 00 00 00 00	 call	 z900_validate_operand

; 1322 :             ACCTYPE_WRITE_SKP, regs);
; 1323 : 
; 1324 :         /* When in ar mode, ar3 is used to access the
; 1325 :            operand. The alet is fetched from the pl */
; 1326 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00203	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0020b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0020f	83 e0 04	 and	 eax, 4
  00212	85 c0		 test	 eax, eax
  00214	0f 84 b2 01 00
	00		 je	 $LN24@z900_plo_c
  0021a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00222	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00226	83 f8 40	 cmp	 eax, 64			; 00000040H
  00229	0f 85 9d 01 00
	00		 jne	 $LN24@z900_plo_c

; 1327 :         {
; 1328 :             if(r3 == 0)

  0022f	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00237	75 12		 jne	 SHORT $LN25@z900_plo_c

; 1329 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00239	ba 06 00 00 00	 mov	 edx, 6
  0023e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	e8 00 00 00 00	 call	 z900_program_interrupt
$LN25@z900_plo_c:

; 1330 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  0024b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00253	48 83 c0 44	 add	 rax, 68			; 00000044H
  00257	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00266	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0026e	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00275	48 8b c8	 mov	 rcx, rax
  00278	e8 00 00 00 00	 call	 z900_vfetch4
  0027d	89 44 24 38	 mov	 DWORD PTR op4alet$[rsp], eax

; 1331 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  00281	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00289	48 83 c0 64	 add	 rax, 100		; 00000064H
  0028d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00295	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0029c	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002a4	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002ab	48 8b c8	 mov	 rcx, rax
  002ae	e8 00 00 00 00	 call	 z900_vfetch4
  002b3	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 1332 :             op8alet = ARCH_DEP(wfetch4)(effective_addr4 + 132, b4, regs);

  002b7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002bf	48 05 84 00 00
	00		 add	 rax, 132		; 00000084H
  002c5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002d4	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002dc	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002e3	48 8b c8	 mov	 rcx, rax
  002e6	e8 00 00 00 00	 call	 z900_vfetch4
  002eb	89 44 24 34	 mov	 DWORD PTR op8alet$[rsp], eax

; 1333 :             regs->AR(r3) = op8alet;

  002ef	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002f7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ff	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  00303	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 1334 :             SET_AEA_AR(regs, r3);

  0030a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00312	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00316	83 f8 40	 cmp	 eax, 64			; 00000040H
  00319	0f 85 a3 00 00
	00		 jne	 $LN26@z900_plo_c
  0031f	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00327	0f 8e 95 00 00
	00		 jle	 $LN26@z900_plo_c
  0032d	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00335	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033d	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00345	75 21		 jne	 SHORT $LN27@z900_plo_c
  00347	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0034e	83 c0 05	 add	 eax, 5
  00351	48 98		 cdqe
  00353	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035b	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00366	eb 5a		 jmp	 SHORT $LN28@z900_plo_c
$LN27@z900_plo_c:
  00368	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00370	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00380	75 21		 jne	 SHORT $LN29@z900_plo_c
  00382	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00389	83 c0 05	 add	 eax, 5
  0038c	48 98		 cdqe
  0038e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00396	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  003a1	eb 1f		 jmp	 SHORT $LN30@z900_plo_c
$LN29@z900_plo_c:
  003a3	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  003aa	83 c0 05	 add	 eax, 5
  003ad	48 98		 cdqe
  003af	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b7	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN30@z900_plo_c:
$LN28@z900_plo_c:
$LN26@z900_plo_c:
  003c2	33 c0		 xor	 eax, eax
  003c4	85 c0		 test	 eax, eax
  003c6	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN24@z900_plo_c:

; 1335 :         }
; 1336 : 
; 1337 :         /* Load address of operand 4 */
; 1338 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1339 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  003cc	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  003d4	48 83 c0 48	 add	 rax, 72			; 00000048H
  003d8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e0	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003e7	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ef	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003f6	48 8b c8	 mov	 rcx, rax
  003f9	e8 00 00 00 00	 call	 z900_vfetch8
  003fe	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1340 : #else
; 1341 :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);
; 1342 : #endif
; 1343 :         op4addr &= ADDRESS_MAXWRAP(regs);

  00403	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00412	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op4addr$[rsp]
  00417	48 23 c8	 and	 rcx, rax
  0041a	48 8b c1	 mov	 rax, rcx
  0041d	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1344 :         DW_CHECK(op4addr, regs);

  00422	48 8b 44 24 50	 mov	 rax, QWORD PTR op4addr$[rsp]
  00427	48 83 e0 07	 and	 rax, 7
  0042b	48 85 c0	 test	 rax, rax
  0042e	74 1b		 je	 SHORT $LN31@z900_plo_c
  00430	ba 06 00 00 00	 mov	 edx, 6
  00435	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00445	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@z900_plo_c:

; 1345 : 
; 1346 :         /* Load address of operand 6 */
; 1347 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1348 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  0044b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00453	48 83 c0 68	 add	 rax, 104		; 00000068H
  00457	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00466	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0046e	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00475	48 8b c8	 mov	 rcx, rax
  00478	e8 00 00 00 00	 call	 z900_vfetch8
  0047d	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1349 : #else
; 1350 :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);
; 1351 : #endif
; 1352 :         op6addr &= ADDRESS_MAXWRAP(regs);

  00482	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00491	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00496	48 23 c8	 and	 rcx, rax
  00499	48 8b c1	 mov	 rax, rcx
  0049c	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1353 :         DW_CHECK(op6addr, regs);

  004a1	48 8b 44 24 40	 mov	 rax, QWORD PTR op6addr$[rsp]
  004a6	48 83 e0 07	 and	 rax, 7
  004aa	48 85 c0	 test	 rax, rax
  004ad	74 1b		 je	 SHORT $LN32@z900_plo_c
  004af	ba 06 00 00 00	 mov	 edx, 6
  004b4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c4	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN32@z900_plo_c:

; 1354 : 
; 1355 :         /* Load address of operand 8 */
; 1356 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1357 :         op8addr = ARCH_DEP(wfetch8)(effective_addr4 + 136, b4, regs);

  004ca	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  004d2	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  004d8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e0	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004e7	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004ef	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  004f6	48 8b c8	 mov	 rcx, rax
  004f9	e8 00 00 00 00	 call	 z900_vfetch8
  004fe	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1358 : #else
; 1359 :         op8addr = ARCH_DEP(wfetch4)(effective_addr4 + 140, b4, regs);
; 1360 : #endif
; 1361 :         op8addr &= ADDRESS_MAXWRAP(regs);

  00503	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00512	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  00517	48 23 c8	 and	 rcx, rax
  0051a	48 8b c1	 mov	 rax, rcx
  0051d	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1362 :         DW_CHECK(op8addr, regs);

  00522	48 8b 44 24 48	 mov	 rax, QWORD PTR op8addr$[rsp]
  00527	48 83 e0 07	 and	 rax, 7
  0052b	48 85 c0	 test	 rax, rax
  0052e	74 1b		 je	 SHORT $LN33@z900_plo_c
  00530	ba 06 00 00 00	 mov	 edx, 6
  00535	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0053d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00545	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@z900_plo_c:

; 1363 : 
; 1364 :         /* Verify access to 8th operand */
; 1365 :         ARCH_DEP(validate_operand) (op8addr, r3, 8-1,ACCTYPE_WRITE_SKP, regs);

  0054b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00553	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00558	41 b9 01 00 00
	00		 mov	 r9d, 1
  0055e	41 b8 07 00 00
	00		 mov	 r8d, 7
  00564	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0056b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  00570	e8 00 00 00 00	 call	 z900_validate_operand

; 1366 : 
; 1367 :         /* Verify access to 6th operand */
; 1368 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00575	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057d	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00581	83 e0 04	 and	 eax, 4
  00584	85 c0		 test	 eax, eax
  00586	0f 84 f2 00 00
	00		 je	 $LN34@z900_plo_c
  0058c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00594	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00598	83 f8 40	 cmp	 eax, 64			; 00000040H
  0059b	0f 85 dd 00 00
	00		 jne	 $LN34@z900_plo_c

; 1369 :         {
; 1370 :             regs->AR(r3) = op6alet;

  005a1	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005a9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b1	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  005b5	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 1371 :             SET_AEA_AR(regs, r3);

  005bc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005c8	83 f8 40	 cmp	 eax, 64			; 00000040H
  005cb	0f 85 a3 00 00
	00		 jne	 $LN35@z900_plo_c
  005d1	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  005d9	0f 8e 95 00 00
	00		 jle	 $LN35@z900_plo_c
  005df	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005e7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ef	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  005f7	75 21		 jne	 SHORT $LN36@z900_plo_c
  005f9	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00600	83 c0 05	 add	 eax, 5
  00603	48 98		 cdqe
  00605	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060d	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00618	eb 5a		 jmp	 SHORT $LN37@z900_plo_c
$LN36@z900_plo_c:
  0061a	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00622	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062a	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00632	75 21		 jne	 SHORT $LN38@z900_plo_c
  00634	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0063b	83 c0 05	 add	 eax, 5
  0063e	48 98		 cdqe
  00640	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00648	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00653	eb 1f		 jmp	 SHORT $LN39@z900_plo_c
$LN38@z900_plo_c:
  00655	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0065c	83 c0 05	 add	 eax, 5
  0065f	48 98		 cdqe
  00661	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00669	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN39@z900_plo_c:
$LN37@z900_plo_c:
$LN35@z900_plo_c:
  00674	33 c0		 xor	 eax, eax
  00676	85 c0		 test	 eax, eax
  00678	0f 85 3e ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN34@z900_plo_c:

; 1372 :         }
; 1373 :         ARCH_DEP(validate_operand) (op6addr, r3, 8-1,ACCTYPE_WRITE_SKP, regs);

  0067e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00686	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00691	41 b8 07 00 00
	00		 mov	 r8d, 7
  00697	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0069e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  006a3	e8 00 00 00 00	 call	 z900_validate_operand

; 1374 : 
; 1375 :         /* Store 3th op at 4th op */
; 1376 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  006a8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b0	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  006b4	83 e0 04	 and	 eax, 4
  006b7	85 c0		 test	 eax, eax
  006b9	0f 84 f2 00 00
	00		 je	 $LN40@z900_plo_c
  006bf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  006cb	83 f8 40	 cmp	 eax, 64			; 00000040H
  006ce	0f 85 dd 00 00
	00		 jne	 $LN40@z900_plo_c

; 1377 :         {
; 1378 :             regs->AR(r3) = op4alet;

  006d4	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  006dc	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e4	8b 54 24 38	 mov	 edx, DWORD PTR op4alet$[rsp]
  006e8	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@z900_plo_c:

; 1379 :             SET_AEA_AR(regs, r3);

  006ef	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  006fb	83 f8 40	 cmp	 eax, 64			; 00000040H
  006fe	0f 85 a3 00 00
	00		 jne	 $LN41@z900_plo_c
  00704	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  0070c	0f 8e 95 00 00
	00		 jle	 $LN41@z900_plo_c
  00712	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0071a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00722	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0072a	75 21		 jne	 SHORT $LN42@z900_plo_c
  0072c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00733	83 c0 05	 add	 eax, 5
  00736	48 98		 cdqe
  00738	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00740	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0074b	eb 5a		 jmp	 SHORT $LN43@z900_plo_c
$LN42@z900_plo_c:
  0074d	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00755	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075d	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00765	75 21		 jne	 SHORT $LN44@z900_plo_c
  00767	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0076e	83 c0 05	 add	 eax, 5
  00771	48 98		 cdqe
  00773	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077b	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00786	eb 1f		 jmp	 SHORT $LN45@z900_plo_c
$LN44@z900_plo_c:
  00788	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0078f	83 c0 05	 add	 eax, 5
  00792	48 98		 cdqe
  00794	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079c	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN45@z900_plo_c:
$LN43@z900_plo_c:
$LN41@z900_plo_c:
  007a7	33 c0		 xor	 eax, eax
  007a9	85 c0		 test	 eax, eax
  007ab	0f 85 3e ff ff
	ff		 jne	 $LN13@z900_plo_c
$LN40@z900_plo_c:

; 1380 :         }
; 1381 :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  007b1	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  007b9	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  007c1	48 8b 54 24 50	 mov	 rdx, QWORD PTR op4addr$[rsp]
  007c6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op3$[rsp]
  007cb	e8 00 00 00 00	 call	 z900_vstore8

; 1382 : 
; 1383 :         /* Store 5th op at 6th op */
; 1384 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  007d0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007d8	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  007dc	83 e0 04	 and	 eax, 4
  007df	85 c0		 test	 eax, eax
  007e1	0f 84 f2 00 00
	00		 je	 $LN46@z900_plo_c
  007e7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ef	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007f3	83 f8 40	 cmp	 eax, 64			; 00000040H
  007f6	0f 85 dd 00 00
	00		 jne	 $LN46@z900_plo_c

; 1385 :         {
; 1386 :             regs->AR(r3) = op6alet;

  007fc	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00804	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080c	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  00810	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN16@z900_plo_c:

; 1387 :             SET_AEA_AR(regs, r3);

  00817	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00823	83 f8 40	 cmp	 eax, 64			; 00000040H
  00826	0f 85 a3 00 00
	00		 jne	 $LN47@z900_plo_c
  0082c	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00834	0f 8e 95 00 00
	00		 jle	 $LN47@z900_plo_c
  0083a	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00842	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0084a	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00852	75 21		 jne	 SHORT $LN48@z900_plo_c
  00854	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0085b	83 c0 05	 add	 eax, 5
  0085e	48 98		 cdqe
  00860	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00868	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00873	eb 5a		 jmp	 SHORT $LN49@z900_plo_c
$LN48@z900_plo_c:
  00875	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0087d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00885	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0088d	75 21		 jne	 SHORT $LN50@z900_plo_c
  0088f	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00896	83 c0 05	 add	 eax, 5
  00899	48 98		 cdqe
  0089b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008a3	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  008ae	eb 1f		 jmp	 SHORT $LN51@z900_plo_c
$LN50@z900_plo_c:
  008b0	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  008b7	83 c0 05	 add	 eax, 5
  008ba	48 98		 cdqe
  008bc	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008c4	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN51@z900_plo_c:
$LN49@z900_plo_c:
$LN47@z900_plo_c:
  008cf	33 c0		 xor	 eax, eax
  008d1	85 c0		 test	 eax, eax
  008d3	0f 85 3e ff ff
	ff		 jne	 $LN16@z900_plo_c
$LN46@z900_plo_c:

; 1388 :         }
; 1389 :         ARCH_DEP(vstore8)(op5, op6addr, r3, regs);

  008d9	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008e1	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  008e9	48 8b 54 24 40	 mov	 rdx, QWORD PTR op6addr$[rsp]
  008ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op5$[rsp]
  008f3	e8 00 00 00 00	 call	 z900_vstore8

; 1390 : 
; 1391 :         /* Store 7th op at 8th op */
; 1392 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  008f8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00900	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00904	83 e0 04	 and	 eax, 4
  00907	85 c0		 test	 eax, eax
  00909	0f 84 f2 00 00
	00		 je	 $LN52@z900_plo_c
  0090f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00917	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0091b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0091e	0f 85 dd 00 00
	00		 jne	 $LN52@z900_plo_c

; 1393 :         {
; 1394 :             regs->AR(r3) = op8alet;

  00924	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0092c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00934	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  00938	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN19@z900_plo_c:

; 1395 :             SET_AEA_AR(regs, r3);

  0093f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00947	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0094b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0094e	0f 85 a3 00 00
	00		 jne	 $LN53@z900_plo_c
  00954	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  0095c	0f 8e 95 00 00
	00		 jle	 $LN53@z900_plo_c
  00962	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0096a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00972	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0097a	75 21		 jne	 SHORT $LN54@z900_plo_c
  0097c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00983	83 c0 05	 add	 eax, 5
  00986	48 98		 cdqe
  00988	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00990	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0099b	eb 5a		 jmp	 SHORT $LN55@z900_plo_c
$LN54@z900_plo_c:
  0099d	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  009a5	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ad	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  009b5	75 21		 jne	 SHORT $LN56@z900_plo_c
  009b7	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  009be	83 c0 05	 add	 eax, 5
  009c1	48 98		 cdqe
  009c3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009cb	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  009d6	eb 1f		 jmp	 SHORT $LN57@z900_plo_c
$LN56@z900_plo_c:
  009d8	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  009df	83 c0 05	 add	 eax, 5
  009e2	48 98		 cdqe
  009e4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009ec	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN57@z900_plo_c:
$LN55@z900_plo_c:
$LN53@z900_plo_c:
  009f7	33 c0		 xor	 eax, eax
  009f9	85 c0		 test	 eax, eax
  009fb	0f 85 3e ff ff
	ff		 jne	 $LN19@z900_plo_c
$LN52@z900_plo_c:

; 1396 :         }
; 1397 :         ARCH_DEP(vstore8)(op7, op8addr, r3, regs);

  00a01	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a09	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00a11	48 8b 54 24 48	 mov	 rdx, QWORD PTR op8addr$[rsp]
  00a16	48 8b 4c 24 78	 mov	 rcx, QWORD PTR op7$[rsp]
  00a1b	e8 00 00 00 00	 call	 z900_vstore8

; 1398 : 
; 1399 :         /* Store 1st op replacement value at 2nd op */
; 1400 :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  00a20	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a28	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  00a30	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00a38	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR op1r$[rsp]
  00a40	e8 00 00 00 00	 call	 z900_vstore8

; 1401 : 
; 1402 :         return 0;

  00a45	33 c0		 xor	 eax, eax
  00a47	eb 3f		 jmp	 SHORT $LN1@z900_plo_c

; 1403 :     }

  00a49	eb 3d		 jmp	 SHORT $LN23@z900_plo_c
$LN22@z900_plo_c:

; 1404 :     else
; 1405 :     {
; 1406 :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  00a4b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00a53	48 83 c0 08	 add	 rax, 8
  00a57	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a5f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00a66	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a6e	44 8b 84 24 c8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  00a76	48 8b d0	 mov	 rdx, rax
  00a79	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op2$[rsp]
  00a7e	e8 00 00 00 00	 call	 z900_vstore8

; 1407 : 
; 1408 :         return 1;

  00a83	b8 01 00 00 00	 mov	 eax, 1
$LN23@z900_plo_c:
$LN1@z900_plo_c:

; 1409 :     }
; 1410 : }

  00a88	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00a8f	c3		 ret	 0
z900_plo_cststg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op8alet$ = 52
op4alet$ = 56
op2$ = 60
op6addr$ = 64
op8addr$ = 72
op4addr$ = 80
op3$ = 88
op5$ = 92
op7$ = 96
r1$ = 128
r3$ = 136
effective_addr2$ = 144
b2$ = 152
effective_addr4$ = 160
b4$ = 168
regs$ = 176
z900_plo_cstst PROC

; 1173 : {

$LN57:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1174 : U32 op2,
; 1175 :     op3,
; 1176 :     op4alet = 0,

  00016	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1177 :     op5,
; 1178 :     op6alet = 0,

  0001e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 1179 :     op7,
; 1180 :     op8alet = 0;

  00026	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op8alet$[rsp], 0

; 1181 : VADR op4addr,
; 1182 :     op6addr,
; 1183 :     op8addr;
; 1184 : 
; 1185 :     ODD_CHECK(r1, regs);

  0002e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	74 1b		 je	 SHORT $LN17@z900_plo_c
  0003c	ba 06 00 00 00	 mov	 edx, 6
  00041	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00049	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00051	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@z900_plo_c:

; 1186 :     FW_CHECK(effective_addr2, regs);

  00057	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0005f	48 83 e0 03	 and	 rax, 3
  00063	48 85 c0	 test	 rax, rax
  00066	74 1b		 je	 SHORT $LN18@z900_plo_c
  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@z900_plo_c:

; 1187 :     FW_CHECK(effective_addr4, regs);

  00083	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0008b	48 83 e0 03	 and	 rax, 3
  0008f	48 85 c0	 test	 rax, rax
  00092	74 1b		 je	 SHORT $LN19@z900_plo_c
  00094	ba 06 00 00 00	 mov	 edx, 6
  00099	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a9	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_c:

; 1188 : 
; 1189 :     op2 = ARCH_DEP(vfetch4)(effective_addr2, b2, regs);

  000af	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000b7	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000c6	e8 00 00 00 00	 call	 z900_vfetch4
  000cb	89 44 24 3c	 mov	 DWORD PTR op2$[rsp], eax

; 1190 :     op3 = ARCH_DEP(wfetch4)(effective_addr4 + 60, b4, regs);

  000cf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000d7	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  000db	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ea	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000f2	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000f9	48 8b c8	 mov	 rcx, rax
  000fc	e8 00 00 00 00	 call	 z900_vfetch4
  00101	89 44 24 58	 mov	 DWORD PTR op3$[rsp], eax

; 1191 :     op5 = ARCH_DEP(wfetch4)(effective_addr4 + 92, b4, regs);

  00105	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0010d	48 83 c0 5c	 add	 rax, 92			; 0000005cH
  00111	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00119	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00120	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00128	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0012f	48 8b c8	 mov	 rcx, rax
  00132	e8 00 00 00 00	 call	 z900_vfetch4
  00137	89 44 24 5c	 mov	 DWORD PTR op5$[rsp], eax

; 1192 :     op7 = ARCH_DEP(wfetch4)(effective_addr4 + 124, b4, regs);

  0013b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00143	48 83 c0 7c	 add	 rax, 124		; 0000007cH
  00147	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00156	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0015e	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00165	48 8b c8	 mov	 rcx, rax
  00168	e8 00 00 00 00	 call	 z900_vfetch4
  0016d	89 44 24 60	 mov	 DWORD PTR op7$[rsp], eax

; 1193 : 
; 1194 :     if(regs->GR_L(r1) == op2)

  00171	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00179	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00181	8b 54 24 3c	 mov	 edx, DWORD PTR op2$[rsp]
  00185	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  0018c	0f 85 84 08 00
	00		 jne	 $LN20@z900_plo_c

; 1195 :     {
; 1196 :         /* Verify access to 2nd operand */
; 1197 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  00192	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019f	41 b9 01 00 00
	00		 mov	 r9d, 1
  001a5	41 b8 03 00 00
	00		 mov	 r8d, 3
  001ab	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  001b2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001ba	e8 00 00 00 00	 call	 z900_validate_operand

; 1198 :             ACCTYPE_WRITE_SKP, regs);
; 1199 : 
; 1200 :         /* When in ar mode, ar3 is used to access the
; 1201 :            operand. The alet is fetched from the pl */
; 1202 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001bf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001cb	83 e0 04	 and	 eax, 4
  001ce	85 c0		 test	 eax, eax
  001d0	0f 84 b2 01 00
	00		 je	 $LN22@z900_plo_c
  001d6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001de	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001e2	83 f8 40	 cmp	 eax, 64			; 00000040H
  001e5	0f 85 9d 01 00
	00		 jne	 $LN22@z900_plo_c

; 1203 :         {
; 1204 :             if(r3 == 0)

  001eb	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001f3	75 12		 jne	 SHORT $LN23@z900_plo_c

; 1205 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001f5	ba 06 00 00 00	 mov	 edx, 6
  001fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00202	e8 00 00 00 00	 call	 z900_program_interrupt
$LN23@z900_plo_c:

; 1206 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  00207	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0020f	48 83 c0 44	 add	 rax, 68			; 00000044H
  00213	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00222	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0022a	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00231	48 8b c8	 mov	 rcx, rax
  00234	e8 00 00 00 00	 call	 z900_vfetch4
  00239	89 44 24 38	 mov	 DWORD PTR op4alet$[rsp], eax

; 1207 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  0023d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00245	48 83 c0 64	 add	 rax, 100		; 00000064H
  00249	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00258	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00260	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00267	48 8b c8	 mov	 rcx, rax
  0026a	e8 00 00 00 00	 call	 z900_vfetch4
  0026f	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 1208 :             op8alet = ARCH_DEP(wfetch4)(effective_addr4 + 132, b4, regs);

  00273	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0027b	48 05 84 00 00
	00		 add	 rax, 132		; 00000084H
  00281	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00289	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00290	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00298	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0029f	48 8b c8	 mov	 rcx, rax
  002a2	e8 00 00 00 00	 call	 z900_vfetch4
  002a7	89 44 24 34	 mov	 DWORD PTR op8alet$[rsp], eax

; 1209 :             regs->AR(r3) = op8alet;

  002ab	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002b3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bb	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  002bf	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN4@z900_plo_c:

; 1210 :             SET_AEA_AR(regs, r3);

  002c6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ce	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  002d2	83 f8 40	 cmp	 eax, 64			; 00000040H
  002d5	0f 85 a3 00 00
	00		 jne	 $LN24@z900_plo_c
  002db	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  002e3	0f 8e 95 00 00
	00		 jle	 $LN24@z900_plo_c
  002e9	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f9	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00301	75 21		 jne	 SHORT $LN25@z900_plo_c
  00303	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0030a	83 c0 05	 add	 eax, 5
  0030d	48 98		 cdqe
  0030f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00317	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00322	eb 5a		 jmp	 SHORT $LN26@z900_plo_c
$LN25@z900_plo_c:
  00324	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0032c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00334	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0033c	75 21		 jne	 SHORT $LN27@z900_plo_c
  0033e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00345	83 c0 05	 add	 eax, 5
  00348	48 98		 cdqe
  0034a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0035d	eb 1f		 jmp	 SHORT $LN28@z900_plo_c
$LN27@z900_plo_c:
  0035f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00366	83 c0 05	 add	 eax, 5
  00369	48 98		 cdqe
  0036b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00373	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN28@z900_plo_c:
$LN26@z900_plo_c:
$LN24@z900_plo_c:
  0037e	33 c0		 xor	 eax, eax
  00380	85 c0		 test	 eax, eax
  00382	0f 85 3e ff ff
	ff		 jne	 $LN4@z900_plo_c
$LN22@z900_plo_c:

; 1211 :         }
; 1212 : 
; 1213 :         /* Load address of operand 4 */
; 1214 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1215 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  00388	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00390	48 83 c0 48	 add	 rax, 72			; 00000048H
  00394	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003a3	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ab	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003b2	48 8b c8	 mov	 rcx, rax
  003b5	e8 00 00 00 00	 call	 z900_vfetch8
  003ba	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1216 : #else
; 1217 :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);
; 1218 : #endif
; 1219 :         op4addr &= ADDRESS_MAXWRAP(regs);

  003bf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op4addr$[rsp]
  003d3	48 23 c8	 and	 rcx, rax
  003d6	48 8b c1	 mov	 rax, rcx
  003d9	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 1220 :         FW_CHECK(op4addr, regs);

  003de	48 8b 44 24 50	 mov	 rax, QWORD PTR op4addr$[rsp]
  003e3	48 83 e0 03	 and	 rax, 3
  003e7	48 85 c0	 test	 rax, rax
  003ea	74 1b		 je	 SHORT $LN29@z900_plo_c
  003ec	ba 06 00 00 00	 mov	 edx, 6
  003f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00401	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@z900_plo_c:

; 1221 : 
; 1222 :         /* Load address of operand 6 */
; 1223 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1224 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  00407	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0040f	48 83 c0 68	 add	 rax, 104		; 00000068H
  00413	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00422	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0042a	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00431	48 8b c8	 mov	 rcx, rax
  00434	e8 00 00 00 00	 call	 z900_vfetch8
  00439	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1225 : #else
; 1226 :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);
; 1227 : #endif
; 1228 :         op6addr &= ADDRESS_MAXWRAP(regs);

  0043e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00446	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0044d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00452	48 23 c8	 and	 rcx, rax
  00455	48 8b c1	 mov	 rax, rcx
  00458	48 89 44 24 40	 mov	 QWORD PTR op6addr$[rsp], rax

; 1229 :         FW_CHECK(op6addr, regs);

  0045d	48 8b 44 24 40	 mov	 rax, QWORD PTR op6addr$[rsp]
  00462	48 83 e0 03	 and	 rax, 3
  00466	48 85 c0	 test	 rax, rax
  00469	74 1b		 je	 SHORT $LN30@z900_plo_c
  0046b	ba 06 00 00 00	 mov	 edx, 6
  00470	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00478	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00480	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@z900_plo_c:

; 1230 : 
; 1231 :         /* Load address of operand 8 */
; 1232 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1233 :         op8addr = ARCH_DEP(wfetch8)(effective_addr4 + 136, b4, regs);

  00486	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0048e	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00494	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  004a3	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004ab	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  004b2	48 8b c8	 mov	 rcx, rax
  004b5	e8 00 00 00 00	 call	 z900_vfetch8
  004ba	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1234 : #else
; 1235 :         op8addr = ARCH_DEP(wfetch4)(effective_addr4 + 140, b4, regs);
; 1236 : #endif
; 1237 :         op8addr &= ADDRESS_MAXWRAP(regs);

  004bf	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  004d3	48 23 c8	 and	 rcx, rax
  004d6	48 8b c1	 mov	 rax, rcx
  004d9	48 89 44 24 48	 mov	 QWORD PTR op8addr$[rsp], rax

; 1238 :         FW_CHECK(op8addr, regs);

  004de	48 8b 44 24 48	 mov	 rax, QWORD PTR op8addr$[rsp]
  004e3	48 83 e0 03	 and	 rax, 3
  004e7	48 85 c0	 test	 rax, rax
  004ea	74 1b		 je	 SHORT $LN31@z900_plo_c
  004ec	ba 06 00 00 00	 mov	 edx, 6
  004f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00501	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@z900_plo_c:

; 1239 : 
; 1240 :         /* Verify access to 8th operand */
; 1241 :         ARCH_DEP(validate_operand) (op8addr, r3, 4-1,ACCTYPE_WRITE_SKP, regs);

  00507	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00514	41 b9 01 00 00
	00		 mov	 r9d, 1
  0051a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00520	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00527	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op8addr$[rsp]
  0052c	e8 00 00 00 00	 call	 z900_validate_operand

; 1242 : 
; 1243 :         /* Verify access to 6th operand */
; 1244 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00531	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00539	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0053d	83 e0 04	 and	 eax, 4
  00540	85 c0		 test	 eax, eax
  00542	0f 84 f2 00 00
	00		 je	 $LN32@z900_plo_c
  00548	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00550	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00554	83 f8 40	 cmp	 eax, 64			; 00000040H
  00557	0f 85 dd 00 00
	00		 jne	 $LN32@z900_plo_c

; 1245 :         {
; 1246 :             regs->AR(r3) = op6alet;

  0055d	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00565	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056d	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  00571	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 1247 :             SET_AEA_AR(regs, r3);

  00578	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00580	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00584	83 f8 40	 cmp	 eax, 64			; 00000040H
  00587	0f 85 a3 00 00
	00		 jne	 $LN33@z900_plo_c
  0058d	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00595	0f 8e 95 00 00
	00		 jle	 $LN33@z900_plo_c
  0059b	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005a3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ab	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  005b3	75 21		 jne	 SHORT $LN34@z900_plo_c
  005b5	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  005bc	83 c0 05	 add	 eax, 5
  005bf	48 98		 cdqe
  005c1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c9	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  005d4	eb 5a		 jmp	 SHORT $LN35@z900_plo_c
$LN34@z900_plo_c:
  005d6	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005de	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e6	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  005ee	75 21		 jne	 SHORT $LN36@z900_plo_c
  005f0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  005f7	83 c0 05	 add	 eax, 5
  005fa	48 98		 cdqe
  005fc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00604	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0060f	eb 1f		 jmp	 SHORT $LN37@z900_plo_c
$LN36@z900_plo_c:
  00611	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00618	83 c0 05	 add	 eax, 5
  0061b	48 98		 cdqe
  0061d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00625	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN37@z900_plo_c:
$LN35@z900_plo_c:
$LN33@z900_plo_c:
  00630	33 c0		 xor	 eax, eax
  00632	85 c0		 test	 eax, eax
  00634	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN32@z900_plo_c:

; 1248 :         }
; 1249 :         ARCH_DEP(validate_operand) (op6addr, r3, 4-1, ACCTYPE_WRITE_SKP, regs);

  0063a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00642	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00647	41 b9 01 00 00
	00		 mov	 r9d, 1
  0064d	41 b8 03 00 00
	00		 mov	 r8d, 3
  00653	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0065a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op6addr$[rsp]
  0065f	e8 00 00 00 00	 call	 z900_validate_operand

; 1250 : 
; 1251 :         /* Store 3rd op at 4th op */
; 1252 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00664	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0066c	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00670	83 e0 04	 and	 eax, 4
  00673	85 c0		 test	 eax, eax
  00675	0f 84 f2 00 00
	00		 je	 $LN38@z900_plo_c
  0067b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00683	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00687	83 f8 40	 cmp	 eax, 64			; 00000040H
  0068a	0f 85 dd 00 00
	00		 jne	 $LN38@z900_plo_c

; 1253 :         {
; 1254 :             regs->AR(r3) = op4alet;

  00690	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00698	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a0	8b 54 24 38	 mov	 edx, DWORD PTR op4alet$[rsp]
  006a4	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 1255 :             SET_AEA_AR(regs, r3);

  006ab	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b3	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  006b7	83 f8 40	 cmp	 eax, 64			; 00000040H
  006ba	0f 85 a3 00 00
	00		 jne	 $LN39@z900_plo_c
  006c0	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  006c8	0f 8e 95 00 00
	00		 jle	 $LN39@z900_plo_c
  006ce	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  006d6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006de	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  006e6	75 21		 jne	 SHORT $LN40@z900_plo_c
  006e8	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  006ef	83 c0 05	 add	 eax, 5
  006f2	48 98		 cdqe
  006f4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006fc	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00707	eb 5a		 jmp	 SHORT $LN41@z900_plo_c
$LN40@z900_plo_c:
  00709	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00711	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00719	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00721	75 21		 jne	 SHORT $LN42@z900_plo_c
  00723	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0072a	83 c0 05	 add	 eax, 5
  0072d	48 98		 cdqe
  0072f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00737	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00742	eb 1f		 jmp	 SHORT $LN43@z900_plo_c
$LN42@z900_plo_c:
  00744	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0074b	83 c0 05	 add	 eax, 5
  0074e	48 98		 cdqe
  00750	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00758	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN43@z900_plo_c:
$LN41@z900_plo_c:
$LN39@z900_plo_c:
  00763	33 c0		 xor	 eax, eax
  00765	85 c0		 test	 eax, eax
  00767	0f 85 3e ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN38@z900_plo_c:

; 1256 :         }
; 1257 :         ARCH_DEP(vstore4)(op3, op4addr, r3, regs);

  0076d	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00775	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  0077d	48 8b 54 24 50	 mov	 rdx, QWORD PTR op4addr$[rsp]
  00782	8b 4c 24 58	 mov	 ecx, DWORD PTR op3$[rsp]
  00786	e8 00 00 00 00	 call	 z900_vstore4

; 1258 : 
; 1259 :         /* Store 5th op at 6th op */
; 1260 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0078b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00793	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00797	83 e0 04	 and	 eax, 4
  0079a	85 c0		 test	 eax, eax
  0079c	0f 84 f2 00 00
	00		 je	 $LN44@z900_plo_c
  007a2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007aa	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007ae	83 f8 40	 cmp	 eax, 64			; 00000040H
  007b1	0f 85 dd 00 00
	00		 jne	 $LN44@z900_plo_c

; 1261 :         {
; 1262 :             regs->AR(r3) = op6alet;

  007b7	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  007bf	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c7	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  007cb	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@z900_plo_c:

; 1263 :             SET_AEA_AR(regs, r3);

  007d2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007da	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007de	83 f8 40	 cmp	 eax, 64			; 00000040H
  007e1	0f 85 a3 00 00
	00		 jne	 $LN45@z900_plo_c
  007e7	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  007ef	0f 8e 95 00 00
	00		 jle	 $LN45@z900_plo_c
  007f5	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  007fd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00805	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0080d	75 21		 jne	 SHORT $LN46@z900_plo_c
  0080f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00816	83 c0 05	 add	 eax, 5
  00819	48 98		 cdqe
  0081b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00823	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0082e	eb 5a		 jmp	 SHORT $LN47@z900_plo_c
$LN46@z900_plo_c:
  00830	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00838	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00840	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00848	75 21		 jne	 SHORT $LN48@z900_plo_c
  0084a	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00851	83 c0 05	 add	 eax, 5
  00854	48 98		 cdqe
  00856	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0085e	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00869	eb 1f		 jmp	 SHORT $LN49@z900_plo_c
$LN48@z900_plo_c:
  0086b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00872	83 c0 05	 add	 eax, 5
  00875	48 98		 cdqe
  00877	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0087f	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN49@z900_plo_c:
$LN47@z900_plo_c:
$LN45@z900_plo_c:
  0088a	33 c0		 xor	 eax, eax
  0088c	85 c0		 test	 eax, eax
  0088e	0f 85 3e ff ff
	ff		 jne	 $LN13@z900_plo_c
$LN44@z900_plo_c:

; 1264 :         }
; 1265 :         ARCH_DEP(vstore4)(op5, op6addr, r3, regs);

  00894	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0089c	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  008a4	48 8b 54 24 40	 mov	 rdx, QWORD PTR op6addr$[rsp]
  008a9	8b 4c 24 5c	 mov	 ecx, DWORD PTR op5$[rsp]
  008ad	e8 00 00 00 00	 call	 z900_vstore4

; 1266 : 
; 1267 :         /* Store 7th op at 8th op */
; 1268 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  008b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ba	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  008be	83 e0 04	 and	 eax, 4
  008c1	85 c0		 test	 eax, eax
  008c3	0f 84 f2 00 00
	00		 je	 $LN50@z900_plo_c
  008c9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008d1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  008d5	83 f8 40	 cmp	 eax, 64			; 00000040H
  008d8	0f 85 dd 00 00
	00		 jne	 $LN50@z900_plo_c

; 1269 :         {
; 1270 :             regs->AR(r3) = op8alet;

  008de	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  008e6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ee	8b 54 24 34	 mov	 edx, DWORD PTR op8alet$[rsp]
  008f2	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN16@z900_plo_c:

; 1271 :             SET_AEA_AR(regs, r3);

  008f9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00901	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00905	83 f8 40	 cmp	 eax, 64			; 00000040H
  00908	0f 85 a3 00 00
	00		 jne	 $LN51@z900_plo_c
  0090e	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00916	0f 8e 95 00 00
	00		 jle	 $LN51@z900_plo_c
  0091c	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00924	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0092c	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00934	75 21		 jne	 SHORT $LN52@z900_plo_c
  00936	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0093d	83 c0 05	 add	 eax, 5
  00940	48 98		 cdqe
  00942	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0094a	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00955	eb 5a		 jmp	 SHORT $LN53@z900_plo_c
$LN52@z900_plo_c:
  00957	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0095f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00967	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0096f	75 21		 jne	 SHORT $LN54@z900_plo_c
  00971	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00978	83 c0 05	 add	 eax, 5
  0097b	48 98		 cdqe
  0097d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00985	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00990	eb 1f		 jmp	 SHORT $LN55@z900_plo_c
$LN54@z900_plo_c:
  00992	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00999	83 c0 05	 add	 eax, 5
  0099c	48 98		 cdqe
  0099e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a6	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN55@z900_plo_c:
$LN53@z900_plo_c:
$LN51@z900_plo_c:
  009b1	33 c0		 xor	 eax, eax
  009b3	85 c0		 test	 eax, eax
  009b5	0f 85 3e ff ff
	ff		 jne	 $LN16@z900_plo_c
$LN50@z900_plo_c:

; 1272 :         }
; 1273 :         ARCH_DEP(vstore4)(op7, op8addr, r3, regs);

  009bb	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009c3	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  009cb	48 8b 54 24 48	 mov	 rdx, QWORD PTR op8addr$[rsp]
  009d0	8b 4c 24 60	 mov	 ecx, DWORD PTR op7$[rsp]
  009d4	e8 00 00 00 00	 call	 z900_vstore4

; 1274 : 
; 1275 :         /* Store 1st op replacement at 2nd op */
; 1276 :         ARCH_DEP(vstore4)(regs->GR_L(r1+1), effective_addr2, b2, regs);

  009d9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR r1$[rsp]
  009e0	ff c0		 inc	 eax
  009e2	48 98		 cdqe
  009e4	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009ec	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  009f4	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  009fc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a04	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00a0b	e8 00 00 00 00	 call	 z900_vstore4

; 1277 : 
; 1278 :         return 0;

  00a10	33 c0		 xor	 eax, eax
  00a12	eb 22		 jmp	 SHORT $LN1@z900_plo_c

; 1279 :     }

  00a14	eb 20		 jmp	 SHORT $LN21@z900_plo_c
$LN20@z900_plo_c:

; 1280 :     else
; 1281 :     {
; 1282 :         regs->GR_L(r1) = op2;

  00a16	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00a1e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a26	8b 54 24 3c	 mov	 edx, DWORD PTR op2$[rsp]
  00a2a	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1283 : 
; 1284 :         return 1;

  00a31	b8 01 00 00 00	 mov	 eax, 1
$LN21@z900_plo_c:
$LN1@z900_plo_c:

; 1285 :     }
; 1286 : }

  00a36	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00a3a	c3		 ret	 0
z900_plo_cstst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op4alet$ = 52
op6addr$ = 56
op4addr$ = 64
op2$ = 72
op1c$ = 88
op3$ = 104
op5$ = 120
op1r$ = 136
__$ArrayPad$ = 152
r1$ = 176
r3$ = 184
effective_addr2$ = 192
b2$ = 200
effective_addr4$ = 208
b4$ = 216
regs$ = 224
z900_plo_csdstx PROC

; 1086 : {

$LN40:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1087 : BYTE op1c[16],
; 1088 :      op1r[16],
; 1089 :      op2[16],
; 1090 :      op3[16],
; 1091 :      op5[16];
; 1092 : U32 op4alet = 0,

  0002b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1093 :     op6alet = 0;

  00033	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0
$LN4@z900_plo_c:

; 1094 : VADR op4addr,
; 1095 :     op6addr;
; 1096 : 
; 1097 :     UNREFERENCED(r1);

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 1098 : 
; 1099 :     QW_CHECK(effective_addr2, regs);

  00041	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00049	48 83 e0 0f	 and	 rax, 15
  0004d	48 85 c0	 test	 rax, rax
  00050	74 1b		 je	 SHORT $LN14@z900_plo_c
  00052	ba 06 00 00 00	 mov	 edx, 6
  00057	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_plo_c:

; 1100 :     DW_CHECK(effective_addr4, regs);

  0006d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00075	48 83 e0 07	 and	 rax, 7
  00079	48 85 c0	 test	 rax, rax
  0007c	74 1b		 je	 SHORT $LN15@z900_plo_c
  0007e	ba 06 00 00 00	 mov	 edx, 6
  00083	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00093	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_plo_c:

; 1101 : 
; 1102 :     ARCH_DEP(vfetchc)(op1c, 16-1, effective_addr4 + 0, b4, regs);

  00099	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a6	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  000ae	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  000b6	b2 0f		 mov	 dl, 15
  000b8	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1c$[rsp]
  000bd	e8 00 00 00 00	 call	 z900_vfetchc

; 1103 :     ARCH_DEP(vfetchc)(op2, 16-1, effective_addr2, b2, regs);

  000c2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cf	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  000d7	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  000df	b2 0f		 mov	 dl, 15
  000e1	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  000e6	e8 00 00 00 00	 call	 z900_vfetchc

; 1104 : 
; 1105 :     if(memcmp(op1c,op2,16) == 0)

  000eb	41 b8 10 00 00
	00		 mov	 r8d, 16
  000f1	48 8d 54 24 48	 lea	 rdx, QWORD PTR op2$[rsp]
  000f6	48 8d 4c 24 58	 lea	 rcx, QWORD PTR op1c$[rsp]
  000fb	e8 00 00 00 00	 call	 memcmp
  00100	85 c0		 test	 eax, eax
  00102	0f 85 36 06 00
	00		 jne	 $LN16@z900_plo_c

; 1106 :     {
; 1107 :         ARCH_DEP(wfetchc)(op1r, 16-1, effective_addr4 + 16, b4, regs);

  00108	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00110	48 83 c0 10	 add	 rax, 16
  00114	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00123	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00130	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00138	4c 8b c0	 mov	 r8, rax
  0013b	b2 0f		 mov	 dl, 15
  0013d	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR op1r$[rsp]
  00145	e8 00 00 00 00	 call	 z900_vfetchc

; 1108 :         ARCH_DEP(wfetchc)(op3, 16-1, effective_addr4 + 48, b4, regs);

  0014a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00152	48 83 c0 30	 add	 rax, 48			; 00000030H
  00156	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00165	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00172	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  0017a	4c 8b c0	 mov	 r8, rax
  0017d	b2 0f		 mov	 dl, 15
  0017f	48 8d 4c 24 68	 lea	 rcx, QWORD PTR op3$[rsp]
  00184	e8 00 00 00 00	 call	 z900_vfetchc

; 1109 :         ARCH_DEP(wfetchc)(op5, 16-1, effective_addr4 + 80, b4, regs);

  00189	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00191	48 83 c0 50	 add	 rax, 80			; 00000050H
  00195	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001a4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ac	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001b1	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  001b9	4c 8b c0	 mov	 r8, rax
  001bc	b2 0f		 mov	 dl, 15
  001be	48 8d 4c 24 78	 lea	 rcx, QWORD PTR op5$[rsp]
  001c3	e8 00 00 00 00	 call	 z900_vfetchc

; 1110 : 
; 1111 :         /* Verify access to 2nd operand */
; 1112 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 16-1,

  001c8	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d5	41 b9 01 00 00
	00		 mov	 r9d, 1
  001db	41 b8 0f 00 00
	00		 mov	 r8d, 15
  001e1	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  001e8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001f0	e8 00 00 00 00	 call	 z900_validate_operand

; 1113 :             ACCTYPE_WRITE_SKP, regs);
; 1114 : 
; 1115 :         /* When in ar mode, ar3 is used to access the
; 1116 :            operand. The alet is fetched from the pl */
; 1117 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001f5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00201	83 e0 04	 and	 eax, 4
  00204	85 c0		 test	 eax, eax
  00206	0f 84 7a 01 00
	00		 je	 $LN18@z900_plo_c
  0020c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00214	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00218	83 f8 40	 cmp	 eax, 64			; 00000040H
  0021b	0f 85 65 01 00
	00		 jne	 $LN18@z900_plo_c

; 1118 :         {
; 1119 :             if(r3 == 0)

  00221	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00229	75 12		 jne	 SHORT $LN19@z900_plo_c

; 1120 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0022b	ba 06 00 00 00	 mov	 edx, 6
  00230	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00238	e8 00 00 00 00	 call	 z900_program_interrupt
$LN19@z900_plo_c:

; 1121 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  0023d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00245	48 83 c0 44	 add	 rax, 68			; 00000044H
  00249	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00258	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00260	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00267	48 8b c8	 mov	 rcx, rax
  0026a	e8 00 00 00 00	 call	 z900_vfetch4
  0026f	89 44 24 34	 mov	 DWORD PTR op4alet$[rsp], eax

; 1122 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  00273	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0027b	48 83 c0 64	 add	 rax, 100		; 00000064H
  0027f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00287	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0028e	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00296	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0029d	48 8b c8	 mov	 rcx, rax
  002a0	e8 00 00 00 00	 call	 z900_vfetch4
  002a5	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 1123 :             regs->AR(r3) = op6alet;

  002a9	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002b1	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  002bd	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 1124 :             SET_AEA_AR(regs, r3);

  002c4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002cc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  002d0	83 f8 40	 cmp	 eax, 64			; 00000040H
  002d3	0f 85 a3 00 00
	00		 jne	 $LN20@z900_plo_c
  002d9	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  002e1	0f 8e 95 00 00
	00		 jle	 $LN20@z900_plo_c
  002e7	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002ef	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  002ff	75 21		 jne	 SHORT $LN21@z900_plo_c
  00301	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00308	83 c0 05	 add	 eax, 5
  0030b	48 98		 cdqe
  0030d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00315	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00320	eb 5a		 jmp	 SHORT $LN22@z900_plo_c
$LN21@z900_plo_c:
  00322	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0032a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00332	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0033a	75 21		 jne	 SHORT $LN23@z900_plo_c
  0033c	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00343	83 c0 05	 add	 eax, 5
  00346	48 98		 cdqe
  00348	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00350	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0035b	eb 1f		 jmp	 SHORT $LN24@z900_plo_c
$LN23@z900_plo_c:
  0035d	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00364	83 c0 05	 add	 eax, 5
  00367	48 98		 cdqe
  00369	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00371	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN24@z900_plo_c:
$LN22@z900_plo_c:
$LN20@z900_plo_c:
  0037c	33 c0		 xor	 eax, eax
  0037e	85 c0		 test	 eax, eax
  00380	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN18@z900_plo_c:

; 1125 :         }
; 1126 : 
; 1127 :         /* Load address of operand 4 */
; 1128 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  00386	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0038e	48 83 c0 48	 add	 rax, 72			; 00000048H
  00392	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003a1	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003a9	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003b0	48 8b c8	 mov	 rcx, rax
  003b3	e8 00 00 00 00	 call	 z900_vfetch8
  003b8	48 89 44 24 40	 mov	 QWORD PTR op4addr$[rsp], rax

; 1129 :         op4addr &= ADDRESS_MAXWRAP(regs);

  003bd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003cc	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op4addr$[rsp]
  003d1	48 23 c8	 and	 rcx, rax
  003d4	48 8b c1	 mov	 rax, rcx
  003d7	48 89 44 24 40	 mov	 QWORD PTR op4addr$[rsp], rax

; 1130 :         QW_CHECK(op4addr, regs);

  003dc	48 8b 44 24 40	 mov	 rax, QWORD PTR op4addr$[rsp]
  003e1	48 83 e0 0f	 and	 rax, 15
  003e5	48 85 c0	 test	 rax, rax
  003e8	74 1b		 je	 SHORT $LN25@z900_plo_c
  003ea	ba 06 00 00 00	 mov	 edx, 6
  003ef	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ff	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@z900_plo_c:

; 1131 : 
; 1132 :         /* Load address of operand 6 */
; 1133 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  00405	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0040d	48 83 c0 68	 add	 rax, 104		; 00000068H
  00411	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00419	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00420	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00428	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0042f	48 8b c8	 mov	 rcx, rax
  00432	e8 00 00 00 00	 call	 z900_vfetch8
  00437	48 89 44 24 38	 mov	 QWORD PTR op6addr$[rsp], rax

; 1134 :         op6addr &= ADDRESS_MAXWRAP(regs);

  0043c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00444	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0044b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00450	48 23 c8	 and	 rcx, rax
  00453	48 8b c1	 mov	 rax, rcx
  00456	48 89 44 24 38	 mov	 QWORD PTR op6addr$[rsp], rax

; 1135 :         QW_CHECK(op6addr, regs);

  0045b	48 8b 44 24 38	 mov	 rax, QWORD PTR op6addr$[rsp]
  00460	48 83 e0 0f	 and	 rax, 15
  00464	48 85 c0	 test	 rax, rax
  00467	74 1b		 je	 SHORT $LN26@z900_plo_c
  00469	ba 06 00 00 00	 mov	 edx, 6
  0046e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00476	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN26@z900_plo_c:

; 1136 : 
; 1137 :         /* Verify access to 6th operand */
; 1138 :         ARCH_DEP(validate_operand) (op6addr, r3, 16-1,ACCTYPE_WRITE_SKP, regs);

  00484	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00491	41 b9 01 00 00
	00		 mov	 r9d, 1
  00497	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0049d	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  004a4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op6addr$[rsp]
  004a9	e8 00 00 00 00	 call	 z900_validate_operand

; 1139 : 
; 1140 :         /* Store 3th op at 4th op */
; 1141 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  004ae	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  004ba	83 e0 04	 and	 eax, 4
  004bd	85 c0		 test	 eax, eax
  004bf	0f 84 f2 00 00
	00		 je	 $LN27@z900_plo_c
  004c5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004cd	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  004d1	83 f8 40	 cmp	 eax, 64			; 00000040H
  004d4	0f 85 dd 00 00
	00		 jne	 $LN27@z900_plo_c

; 1142 :         {
; 1143 :             regs->AR(r3) = op4alet;

  004da	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004e2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ea	8b 54 24 34	 mov	 edx, DWORD PTR op4alet$[rsp]
  004ee	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 1144 :             SET_AEA_AR(regs, r3);

  004f5	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004fd	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00501	83 f8 40	 cmp	 eax, 64			; 00000040H
  00504	0f 85 a3 00 00
	00		 jne	 $LN28@z900_plo_c
  0050a	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00512	0f 8e 95 00 00
	00		 jle	 $LN28@z900_plo_c
  00518	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00520	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00528	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00530	75 21		 jne	 SHORT $LN29@z900_plo_c
  00532	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00539	83 c0 05	 add	 eax, 5
  0053c	48 98		 cdqe
  0053e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00546	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00551	eb 5a		 jmp	 SHORT $LN30@z900_plo_c
$LN29@z900_plo_c:
  00553	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0055b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00563	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0056b	75 21		 jne	 SHORT $LN31@z900_plo_c
  0056d	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00574	83 c0 05	 add	 eax, 5
  00577	48 98		 cdqe
  00579	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00581	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0058c	eb 1f		 jmp	 SHORT $LN32@z900_plo_c
$LN31@z900_plo_c:
  0058e	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00595	83 c0 05	 add	 eax, 5
  00598	48 98		 cdqe
  0059a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a2	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN32@z900_plo_c:
$LN30@z900_plo_c:
$LN28@z900_plo_c:
  005ad	33 c0		 xor	 eax, eax
  005af	85 c0		 test	 eax, eax
  005b1	0f 85 3e ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN27@z900_plo_c:

; 1145 :         }
; 1146 :         ARCH_DEP(vstorec)(op3, 16-1, op4addr, r3, regs);

  005b7	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c4	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  005cc	4c 8b 44 24 40	 mov	 r8, QWORD PTR op4addr$[rsp]
  005d1	b2 0f		 mov	 dl, 15
  005d3	48 8d 4c 24 68	 lea	 rcx, QWORD PTR op3$[rsp]
  005d8	e8 00 00 00 00	 call	 z900_vstorec

; 1147 : 
; 1148 :         /* Store 5th op at 6th op */
; 1149 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  005dd	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e5	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  005e9	83 e0 04	 and	 eax, 4
  005ec	85 c0		 test	 eax, eax
  005ee	0f 84 f2 00 00
	00		 je	 $LN33@z900_plo_c
  005f4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005fc	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00600	83 f8 40	 cmp	 eax, 64			; 00000040H
  00603	0f 85 dd 00 00
	00		 jne	 $LN33@z900_plo_c

; 1150 :         {
; 1151 :             regs->AR(r3) = op6alet;

  00609	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00611	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00619	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  0061d	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@z900_plo_c:

; 1152 :             SET_AEA_AR(regs, r3);

  00624	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00630	83 f8 40	 cmp	 eax, 64			; 00000040H
  00633	0f 85 a3 00 00
	00		 jne	 $LN34@z900_plo_c
  00639	83 bc 24 b8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00641	0f 8e 95 00 00
	00		 jle	 $LN34@z900_plo_c
  00647	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0064f	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00657	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0065f	75 21		 jne	 SHORT $LN35@z900_plo_c
  00661	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00668	83 c0 05	 add	 eax, 5
  0066b	48 98		 cdqe
  0066d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00675	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00680	eb 5a		 jmp	 SHORT $LN36@z900_plo_c
$LN35@z900_plo_c:
  00682	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0068a	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00692	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0069a	75 21		 jne	 SHORT $LN37@z900_plo_c
  0069c	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  006a3	83 c0 05	 add	 eax, 5
  006a6	48 98		 cdqe
  006a8	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b0	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  006bb	eb 1f		 jmp	 SHORT $LN38@z900_plo_c
$LN37@z900_plo_c:
  006bd	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  006c4	83 c0 05	 add	 eax, 5
  006c7	48 98		 cdqe
  006c9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006d1	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN38@z900_plo_c:
$LN36@z900_plo_c:
$LN34@z900_plo_c:
  006dc	33 c0		 xor	 eax, eax
  006de	85 c0		 test	 eax, eax
  006e0	0f 85 3e ff ff
	ff		 jne	 $LN13@z900_plo_c
$LN33@z900_plo_c:

; 1153 :         }
; 1154 :         ARCH_DEP(vstorec)(op5, 16-1, op6addr, r3, regs);

  006e6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f3	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  006fb	4c 8b 44 24 38	 mov	 r8, QWORD PTR op6addr$[rsp]
  00700	b2 0f		 mov	 dl, 15
  00702	48 8d 4c 24 78	 lea	 rcx, QWORD PTR op5$[rsp]
  00707	e8 00 00 00 00	 call	 z900_vstorec

; 1155 : 
; 1156 :         /* Store 1st op replacement at 2nd op */
; 1157 :         ARCH_DEP(vstorec)(op1r, 16-1, effective_addr2, b2, regs);

  0070c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00714	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00719	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  00721	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00729	b2 0f		 mov	 dl, 15
  0072b	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR op1r$[rsp]
  00733	e8 00 00 00 00	 call	 z900_vstorec

; 1158 : 
; 1159 :         return 0;

  00738	33 c0		 xor	 eax, eax
  0073a	eb 30		 jmp	 SHORT $LN1@z900_plo_c

; 1160 :     }

  0073c	eb 2e		 jmp	 SHORT $LN17@z900_plo_c
$LN16@z900_plo_c:

; 1161 :     else
; 1162 :     {
; 1163 :         ARCH_DEP(vstorec)(op2, 16-1, effective_addr4 + 0, b4, regs);

  0073e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00746	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0074b	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00753	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  0075b	b2 0f		 mov	 dl, 15
  0075d	48 8d 4c 24 48	 lea	 rcx, QWORD PTR op2$[rsp]
  00762	e8 00 00 00 00	 call	 z900_vstorec

; 1164 : 
; 1165 :         return 1;

  00767	b8 01 00 00 00	 mov	 eax, 1
$LN17@z900_plo_c:
$LN1@z900_plo_c:

; 1166 :     }
; 1167 : }

  0076c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00774	48 33 cc	 xor	 rcx, rsp
  00777	e8 00 00 00 00	 call	 __security_check_cookie
  0077c	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00783	c3		 ret	 0
z900_plo_csdstx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op4alet$ = 52
op6addr$ = 56
op4addr$ = 64
op2$ = 72
op3$ = 80
op5$ = 88
r1$ = 112
r3$ = 120
effective_addr2$ = 128
b2$ = 136
effective_addr4$ = 144
b4$ = 152
regs$ = 160
z900_plo_csdstgr PROC

; 1003 : {

$LN38:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1004 : U64 op2,
; 1005 :     op3,
; 1006 :     op5;
; 1007 : U32 op4alet = 0,

  00016	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1008 :     op6alet = 0;

  0001e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 1009 : VADR op4addr,
; 1010 :     op6addr;
; 1011 : 
; 1012 :     ODD_CHECK(r1, regs);

  00026	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 1b		 je	 SHORT $LN11@z900_plo_c
  00031	ba 06 00 00 00	 mov	 edx, 6
  00036	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00046	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_plo_c:

; 1013 :     DW_CHECK(effective_addr2, regs);

  0004c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00054	48 83 e0 07	 and	 rax, 7
  00058	48 85 c0	 test	 rax, rax
  0005b	74 1b		 je	 SHORT $LN12@z900_plo_c
  0005d	ba 06 00 00 00	 mov	 edx, 6
  00062	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00072	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_plo_c:

; 1014 :     DW_CHECK(effective_addr4, regs);

  00078	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00080	48 83 e0 07	 and	 rax, 7
  00084	48 85 c0	 test	 rax, rax
  00087	74 1b		 je	 SHORT $LN13@z900_plo_c
  00089	ba 06 00 00 00	 mov	 edx, 6
  0008e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_plo_c:

; 1015 : 
; 1016 :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000a4	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000bb	e8 00 00 00 00	 call	 z900_vfetch8
  000c0	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 1017 : 
; 1018 :     if(regs->GR_G(r1) == op2)

  000c5	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d2	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  000d7	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  000df	0f 85 94 05 00
	00		 jne	 $LN14@z900_plo_c

; 1019 :     {
; 1020 :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  000e5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000ed	48 83 c0 38	 add	 rax, 56			; 00000038H
  000f1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f9	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00100	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00108	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0010f	48 8b c8	 mov	 rcx, rax
  00112	e8 00 00 00 00	 call	 z900_vfetch8
  00117	48 89 44 24 50	 mov	 QWORD PTR op3$[rsp], rax

; 1021 :         op5 = ARCH_DEP(wfetch8)(effective_addr4 + 88, b4, regs);

  0011c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00124	48 83 c0 58	 add	 rax, 88			; 00000058H
  00128	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00137	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013f	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00146	48 8b c8	 mov	 rcx, rax
  00149	e8 00 00 00 00	 call	 z900_vfetch8
  0014e	48 89 44 24 58	 mov	 QWORD PTR op5$[rsp], rax

; 1022 : 
; 1023 :         /* Verify access to 2nd operand */
; 1024 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  00153	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00160	41 b9 01 00 00
	00		 mov	 r9d, 1
  00166	41 b8 07 00 00
	00		 mov	 r8d, 7
  0016c	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  00173	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0017b	e8 00 00 00 00	 call	 z900_validate_operand

; 1025 :             ACCTYPE_WRITE_SKP, regs);
; 1026 : 
; 1027 :         /* When in ar mode, ar3 is used to access the
; 1028 :            operand. The alet is fetched from the pl */
; 1029 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00180	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00188	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0018c	83 e0 04	 and	 eax, 4
  0018f	85 c0		 test	 eax, eax
  00191	0f 84 62 01 00
	00		 je	 $LN16@z900_plo_c
  00197	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001a3	83 f8 40	 cmp	 eax, 64			; 00000040H
  001a6	0f 85 4d 01 00
	00		 jne	 $LN16@z900_plo_c

; 1030 :         {
; 1031 :             if(r3 == 0)

  001ac	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  001b1	75 12		 jne	 SHORT $LN17@z900_plo_c

; 1032 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001b3	ba 06 00 00 00	 mov	 edx, 6
  001b8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c0	e8 00 00 00 00	 call	 z900_program_interrupt
$LN17@z900_plo_c:

; 1033 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001cd	48 83 c0 44	 add	 rax, 68			; 00000044H
  001d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001e0	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e8	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001ef	48 8b c8	 mov	 rcx, rax
  001f2	e8 00 00 00 00	 call	 z900_vfetch4
  001f7	89 44 24 34	 mov	 DWORD PTR op4alet$[rsp], eax

; 1034 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  001fb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00203	48 83 c0 64	 add	 rax, 100		; 00000064H
  00207	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00216	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0021e	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00225	48 8b c8	 mov	 rcx, rax
  00228	e8 00 00 00 00	 call	 z900_vfetch4
  0022d	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 1035 :             regs->AR(r3) = op6alet;

  00231	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00236	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  00242	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN4@z900_plo_c:

; 1036 :             SET_AEA_AR(regs, r3);

  00249	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00251	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00255	83 f8 40	 cmp	 eax, 64			; 00000040H
  00258	0f 85 91 00 00
	00		 jne	 $LN18@z900_plo_c
  0025e	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  00263	0f 8e 86 00 00
	00		 jle	 $LN18@z900_plo_c
  00269	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0026e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00276	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0027e	75 1e		 jne	 SHORT $LN19@z900_plo_c
  00280	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00284	83 c0 05	 add	 eax, 5
  00287	48 98		 cdqe
  00289	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00291	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0029c	eb 51		 jmp	 SHORT $LN20@z900_plo_c
$LN19@z900_plo_c:
  0029e	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  002a3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ab	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  002b3	75 1e		 jne	 SHORT $LN21@z900_plo_c
  002b5	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  002b9	83 c0 05	 add	 eax, 5
  002bc	48 98		 cdqe
  002be	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c6	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  002d1	eb 1c		 jmp	 SHORT $LN22@z900_plo_c
$LN21@z900_plo_c:
  002d3	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  002d7	83 c0 05	 add	 eax, 5
  002da	48 98		 cdqe
  002dc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e4	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN22@z900_plo_c:
$LN20@z900_plo_c:
$LN18@z900_plo_c:
  002ef	33 c0		 xor	 eax, eax
  002f1	85 c0		 test	 eax, eax
  002f3	0f 85 50 ff ff
	ff		 jne	 $LN4@z900_plo_c
$LN16@z900_plo_c:

; 1037 :         }
; 1038 : 
; 1039 :         /* Load address of operand 4 */
; 1040 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  002f9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00301	48 83 c0 48	 add	 rax, 72			; 00000048H
  00305	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00314	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0031c	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00323	48 8b c8	 mov	 rcx, rax
  00326	e8 00 00 00 00	 call	 z900_vfetch8
  0032b	48 89 44 24 40	 mov	 QWORD PTR op4addr$[rsp], rax

; 1041 :         op4addr &= ADDRESS_MAXWRAP(regs);

  00330	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00338	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0033f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op4addr$[rsp]
  00344	48 23 c8	 and	 rcx, rax
  00347	48 8b c1	 mov	 rax, rcx
  0034a	48 89 44 24 40	 mov	 QWORD PTR op4addr$[rsp], rax

; 1042 :         DW_CHECK(op4addr, regs);

  0034f	48 8b 44 24 40	 mov	 rax, QWORD PTR op4addr$[rsp]
  00354	48 83 e0 07	 and	 rax, 7
  00358	48 85 c0	 test	 rax, rax
  0035b	74 1b		 je	 SHORT $LN23@z900_plo_c
  0035d	ba 06 00 00 00	 mov	 edx, 6
  00362	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00372	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN23@z900_plo_c:

; 1043 : 
; 1044 :         /* Load address of operand 6 */
; 1045 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  00378	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00380	48 83 c0 68	 add	 rax, 104		; 00000068H
  00384	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00393	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0039b	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003a2	48 8b c8	 mov	 rcx, rax
  003a5	e8 00 00 00 00	 call	 z900_vfetch8
  003aa	48 89 44 24 38	 mov	 QWORD PTR op6addr$[rsp], rax

; 1046 :         op6addr &= ADDRESS_MAXWRAP(regs);

  003af	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003be	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op6addr$[rsp]
  003c3	48 23 c8	 and	 rcx, rax
  003c6	48 8b c1	 mov	 rax, rcx
  003c9	48 89 44 24 38	 mov	 QWORD PTR op6addr$[rsp], rax

; 1047 :         DW_CHECK(op6addr, regs);

  003ce	48 8b 44 24 38	 mov	 rax, QWORD PTR op6addr$[rsp]
  003d3	48 83 e0 07	 and	 rax, 7
  003d7	48 85 c0	 test	 rax, rax
  003da	74 1b		 je	 SHORT $LN24@z900_plo_c
  003dc	ba 06 00 00 00	 mov	 edx, 6
  003e1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@z900_plo_c:

; 1048 : 
; 1049 :         /* Verify access to 6th operand */
; 1050 :         ARCH_DEP(validate_operand) (op6addr, r3, 8-1,ACCTYPE_WRITE_SKP, regs);

  003f7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00404	41 b9 01 00 00
	00		 mov	 r9d, 1
  0040a	41 b8 07 00 00
	00		 mov	 r8d, 7
  00410	8b 54 24 78	 mov	 edx, DWORD PTR r3$[rsp]
  00414	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00419	e8 00 00 00 00	 call	 z900_validate_operand

; 1051 : 
; 1052 :         /* Store 3th op at 4th op */
; 1053 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0041e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00426	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0042a	83 e0 04	 and	 eax, 4
  0042d	85 c0		 test	 eax, eax
  0042f	0f 84 dd 00 00
	00		 je	 $LN25@z900_plo_c
  00435	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043d	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00441	83 f8 40	 cmp	 eax, 64			; 00000040H
  00444	0f 85 c8 00 00
	00		 jne	 $LN25@z900_plo_c

; 1054 :         {
; 1055 :             regs->AR(r3) = op4alet;

  0044a	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0044f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00457	8b 54 24 34	 mov	 edx, DWORD PTR op4alet$[rsp]
  0045b	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 1056 :             SET_AEA_AR(regs, r3);

  00462	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0046a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0046e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00471	0f 85 91 00 00
	00		 jne	 $LN26@z900_plo_c
  00477	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  0047c	0f 8e 86 00 00
	00		 jle	 $LN26@z900_plo_c
  00482	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00487	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048f	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00497	75 1e		 jne	 SHORT $LN27@z900_plo_c
  00499	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0049d	83 c0 05	 add	 eax, 5
  004a0	48 98		 cdqe
  004a2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004aa	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  004b5	eb 51		 jmp	 SHORT $LN28@z900_plo_c
$LN27@z900_plo_c:
  004b7	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  004bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c4	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  004cc	75 1e		 jne	 SHORT $LN29@z900_plo_c
  004ce	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  004d2	83 c0 05	 add	 eax, 5
  004d5	48 98		 cdqe
  004d7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004df	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  004ea	eb 1c		 jmp	 SHORT $LN30@z900_plo_c
$LN29@z900_plo_c:
  004ec	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  004f0	83 c0 05	 add	 eax, 5
  004f3	48 98		 cdqe
  004f5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004fd	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN30@z900_plo_c:
$LN28@z900_plo_c:
$LN26@z900_plo_c:
  00508	33 c0		 xor	 eax, eax
  0050a	85 c0		 test	 eax, eax
  0050c	0f 85 50 ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN25@z900_plo_c:

; 1057 :         }
; 1058 :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  00512	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0051a	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  0051f	48 8b 54 24 40	 mov	 rdx, QWORD PTR op4addr$[rsp]
  00524	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op3$[rsp]
  00529	e8 00 00 00 00	 call	 z900_vstore8

; 1059 : 
; 1060 :         /* Store 5th op at 6th op */
; 1061 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0052e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00536	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0053a	83 e0 04	 and	 eax, 4
  0053d	85 c0		 test	 eax, eax
  0053f	0f 84 dd 00 00
	00		 je	 $LN31@z900_plo_c
  00545	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054d	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00551	83 f8 40	 cmp	 eax, 64			; 00000040H
  00554	0f 85 c8 00 00
	00		 jne	 $LN31@z900_plo_c

; 1062 :         {
; 1063 :             regs->AR(r3) = op6alet;

  0055a	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0055f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00567	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  0056b	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 1064 :             SET_AEA_AR(regs, r3);

  00572	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0057e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00581	0f 85 91 00 00
	00		 jne	 $LN32@z900_plo_c
  00587	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  0058c	0f 8e 86 00 00
	00		 jle	 $LN32@z900_plo_c
  00592	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00597	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059f	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  005a7	75 1e		 jne	 SHORT $LN33@z900_plo_c
  005a9	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  005ad	83 c0 05	 add	 eax, 5
  005b0	48 98		 cdqe
  005b2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ba	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  005c5	eb 51		 jmp	 SHORT $LN34@z900_plo_c
$LN33@z900_plo_c:
  005c7	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  005cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d4	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  005dc	75 1e		 jne	 SHORT $LN35@z900_plo_c
  005de	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  005e2	83 c0 05	 add	 eax, 5
  005e5	48 98		 cdqe
  005e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ef	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  005fa	eb 1c		 jmp	 SHORT $LN36@z900_plo_c
$LN35@z900_plo_c:
  005fc	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00600	83 c0 05	 add	 eax, 5
  00603	48 98		 cdqe
  00605	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060d	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN36@z900_plo_c:
$LN34@z900_plo_c:
$LN32@z900_plo_c:
  00618	33 c0		 xor	 eax, eax
  0061a	85 c0		 test	 eax, eax
  0061c	0f 85 50 ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN31@z900_plo_c:

; 1065 :         }
; 1066 :         ARCH_DEP(vstore8)(op5, op6addr, r3, regs);

  00622	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0062a	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  0062f	48 8b 54 24 38	 mov	 rdx, QWORD PTR op6addr$[rsp]
  00634	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op5$[rsp]
  00639	e8 00 00 00 00	 call	 z900_vstore8

; 1067 : 
; 1068 :         /* Store 1st op at 2nd op */
; 1069 :         ARCH_DEP(vstore8)(regs->GR_G(r1+1), effective_addr2, b2, regs);

  0063e	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  00642	ff c0		 inc	 eax
  00644	48 98		 cdqe
  00646	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0064e	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  00656	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0065e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00666	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  0066e	e8 00 00 00 00	 call	 z900_vstore8

; 1070 : 
; 1071 :         return 0;

  00673	33 c0		 xor	 eax, eax
  00675	eb 21		 jmp	 SHORT $LN1@z900_plo_c

; 1072 :     }

  00677	eb 1f		 jmp	 SHORT $LN15@z900_plo_c
$LN14@z900_plo_c:

; 1073 :     else
; 1074 :     {
; 1075 :         regs->GR_G(r1) = op2;

  00679	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  0067e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00686	48 8b 54 24 48	 mov	 rdx, QWORD PTR op2$[rsp]
  0068b	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 1076 : 
; 1077 :         return 1;

  00693	b8 01 00 00 00	 mov	 eax, 1
$LN15@z900_plo_c:
$LN1@z900_plo_c:

; 1078 :     }
; 1079 : }

  00698	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0069c	c3		 ret	 0
z900_plo_csdstgr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op4alet$ = 52
op6addr$ = 56
op4addr$ = 64
op2$ = 72
op1c$ = 80
op3$ = 88
op5$ = 96
op1r$ = 104
r1$ = 128
r3$ = 136
effective_addr2$ = 144
b2$ = 152
effective_addr4$ = 160
b4$ = 168
regs$ = 176
z900_plo_csdstg PROC

; 908  : {

$LN40:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 909  : U64 op1c,
; 910  :     op1r,
; 911  :     op2,
; 912  :     op3,
; 913  :     op5;
; 914  : U32 op4alet = 0,

  00016	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 915  :     op6alet = 0;

  0001e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0
$LN4@z900_plo_c:

; 916  : VADR op4addr,
; 917  :     op6addr;
; 918  : 
; 919  :     UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 920  : 
; 921  :     DW_CHECK(effective_addr2, regs);

  0002c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00034	48 83 e0 07	 and	 rax, 7
  00038	48 85 c0	 test	 rax, rax
  0003b	74 1b		 je	 SHORT $LN14@z900_plo_c
  0003d	ba 06 00 00 00	 mov	 edx, 6
  00042	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00052	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@z900_plo_c:

; 922  :     DW_CHECK(effective_addr4, regs);

  00058	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00060	48 83 e0 07	 and	 rax, 7
  00064	48 85 c0	 test	 rax, rax
  00067	74 1b		 je	 SHORT $LN15@z900_plo_c
  00069	ba 06 00 00 00	 mov	 edx, 6
  0006e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@z900_plo_c:

; 923  : 
; 924  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  00084	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0008c	48 83 c0 08	 add	 rax, 8
  00090	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0009f	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a7	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	e8 00 00 00 00	 call	 z900_vfetch8
  000b6	48 89 44 24 50	 mov	 QWORD PTR op1c$[rsp], rax

; 925  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000bb	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c3	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000d2	e8 00 00 00 00	 call	 z900_vfetch8
  000d7	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 926  : 
; 927  :     if(op1c == op2)

  000dc	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  000e1	48 39 44 24 50	 cmp	 QWORD PTR op1c$[rsp], rax
  000e6	0f 85 03 06 00
	00		 jne	 $LN16@z900_plo_c

; 928  :     {
; 929  :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000ec	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000f4	48 83 c0 18	 add	 rax, 24
  000f8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00107	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0010f	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00116	48 8b c8	 mov	 rcx, rax
  00119	e8 00 00 00 00	 call	 z900_vfetch8
  0011e	48 89 44 24 68	 mov	 QWORD PTR op1r$[rsp], rax

; 930  :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  00123	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0012b	48 83 c0 38	 add	 rax, 56			; 00000038H
  0012f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00137	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0013e	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00146	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0014d	48 8b c8	 mov	 rcx, rax
  00150	e8 00 00 00 00	 call	 z900_vfetch8
  00155	48 89 44 24 58	 mov	 QWORD PTR op3$[rsp], rax

; 931  :         op5 = ARCH_DEP(wfetch8)(effective_addr4 + 88, b4, regs);

  0015a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00162	48 83 c0 58	 add	 rax, 88			; 00000058H
  00166	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00175	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0017d	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00184	48 8b c8	 mov	 rcx, rax
  00187	e8 00 00 00 00	 call	 z900_vfetch8
  0018c	48 89 44 24 60	 mov	 QWORD PTR op5$[rsp], rax

; 932  : 
; 933  :         /* Verify access to 2nd operand */
; 934  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  00191	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00199	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019e	41 b9 01 00 00
	00		 mov	 r9d, 1
  001a4	41 b8 07 00 00
	00		 mov	 r8d, 7
  001aa	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  001b1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001b9	e8 00 00 00 00	 call	 z900_validate_operand

; 935  :             ACCTYPE_WRITE_SKP, regs);
; 936  : 
; 937  :         /* When in ar mode, ar3 is used to access the
; 938  :            operand. The alet is fetched from the pl */
; 939  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001be	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c6	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001ca	83 e0 04	 and	 eax, 4
  001cd	85 c0		 test	 eax, eax
  001cf	0f 84 7a 01 00
	00		 je	 $LN18@z900_plo_c
  001d5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001dd	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001e1	83 f8 40	 cmp	 eax, 64			; 00000040H
  001e4	0f 85 65 01 00
	00		 jne	 $LN18@z900_plo_c

; 940  :         {
; 941  :             if(r3 == 0)

  001ea	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001f2	75 12		 jne	 SHORT $LN19@z900_plo_c

; 942  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001f4	ba 06 00 00 00	 mov	 edx, 6
  001f9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	e8 00 00 00 00	 call	 z900_program_interrupt
$LN19@z900_plo_c:

; 943  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  00206	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0020e	48 83 c0 44	 add	 rax, 68			; 00000044H
  00212	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00221	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00229	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00230	48 8b c8	 mov	 rcx, rax
  00233	e8 00 00 00 00	 call	 z900_vfetch4
  00238	89 44 24 34	 mov	 DWORD PTR op4alet$[rsp], eax

; 944  :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  0023c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00244	48 83 c0 64	 add	 rax, 100		; 00000064H
  00248	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00250	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00257	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0025f	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00266	48 8b c8	 mov	 rcx, rax
  00269	e8 00 00 00 00	 call	 z900_vfetch4
  0026e	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 945  :             regs->AR(r3) = op6alet;

  00272	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0027a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  00286	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 946  :             SET_AEA_AR(regs, r3);

  0028d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00295	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00299	83 f8 40	 cmp	 eax, 64			; 00000040H
  0029c	0f 85 a3 00 00
	00		 jne	 $LN20@z900_plo_c
  002a2	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  002aa	0f 8e 95 00 00
	00		 jle	 $LN20@z900_plo_c
  002b0	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002b8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c0	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  002c8	75 21		 jne	 SHORT $LN21@z900_plo_c
  002ca	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002d1	83 c0 05	 add	 eax, 5
  002d4	48 98		 cdqe
  002d6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002de	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  002e9	eb 5a		 jmp	 SHORT $LN22@z900_plo_c
$LN21@z900_plo_c:
  002eb	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00303	75 21		 jne	 SHORT $LN23@z900_plo_c
  00305	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0030c	83 c0 05	 add	 eax, 5
  0030f	48 98		 cdqe
  00311	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00319	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00324	eb 1f		 jmp	 SHORT $LN24@z900_plo_c
$LN23@z900_plo_c:
  00326	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0032d	83 c0 05	 add	 eax, 5
  00330	48 98		 cdqe
  00332	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033a	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN24@z900_plo_c:
$LN22@z900_plo_c:
$LN20@z900_plo_c:
  00345	33 c0		 xor	 eax, eax
  00347	85 c0		 test	 eax, eax
  00349	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN18@z900_plo_c:

; 947  :         }
; 948  : 
; 949  :         /* Load address of operand 4 */
; 950  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 951  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  0034f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00357	48 83 c0 48	 add	 rax, 72			; 00000048H
  0035b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00363	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0036a	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00372	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00379	48 8b c8	 mov	 rcx, rax
  0037c	e8 00 00 00 00	 call	 z900_vfetch8
  00381	48 89 44 24 40	 mov	 QWORD PTR op4addr$[rsp], rax

; 952  : #else
; 953  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);
; 954  : #endif
; 955  :         op4addr &= ADDRESS_MAXWRAP(regs);

  00386	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00395	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op4addr$[rsp]
  0039a	48 23 c8	 and	 rcx, rax
  0039d	48 8b c1	 mov	 rax, rcx
  003a0	48 89 44 24 40	 mov	 QWORD PTR op4addr$[rsp], rax

; 956  :         DW_CHECK(op4addr, regs);

  003a5	48 8b 44 24 40	 mov	 rax, QWORD PTR op4addr$[rsp]
  003aa	48 83 e0 07	 and	 rax, 7
  003ae	48 85 c0	 test	 rax, rax
  003b1	74 1b		 je	 SHORT $LN25@z900_plo_c
  003b3	ba 06 00 00 00	 mov	 edx, 6
  003b8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c8	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@z900_plo_c:

; 957  : 
; 958  :         /* Load address of operand 6 */
; 959  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 960  :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  003ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  003d6	48 83 c0 68	 add	 rax, 104		; 00000068H
  003da	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e2	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003e9	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f1	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003f8	48 8b c8	 mov	 rcx, rax
  003fb	e8 00 00 00 00	 call	 z900_vfetch8
  00400	48 89 44 24 38	 mov	 QWORD PTR op6addr$[rsp], rax

; 961  : #else
; 962  :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);
; 963  : #endif
; 964  :         op6addr &= ADDRESS_MAXWRAP(regs);

  00405	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00414	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00419	48 23 c8	 and	 rcx, rax
  0041c	48 8b c1	 mov	 rax, rcx
  0041f	48 89 44 24 38	 mov	 QWORD PTR op6addr$[rsp], rax

; 965  :         DW_CHECK(op6addr, regs);

  00424	48 8b 44 24 38	 mov	 rax, QWORD PTR op6addr$[rsp]
  00429	48 83 e0 07	 and	 rax, 7
  0042d	48 85 c0	 test	 rax, rax
  00430	74 1b		 je	 SHORT $LN26@z900_plo_c
  00432	ba 06 00 00 00	 mov	 edx, 6
  00437	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00447	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN26@z900_plo_c:

; 966  : 
; 967  :         /* Verify access to 6th operand */
; 968  :         ARCH_DEP(validate_operand) (op6addr, r3, 8-1, ACCTYPE_WRITE_SKP, regs);

  0044d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00455	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0045a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00460	41 b8 07 00 00
	00		 mov	 r8d, 7
  00466	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0046d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00472	e8 00 00 00 00	 call	 z900_validate_operand

; 969  : 
; 970  :         /* Store 3th op at 4th op */
; 971  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00477	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047f	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00483	83 e0 04	 and	 eax, 4
  00486	85 c0		 test	 eax, eax
  00488	0f 84 f2 00 00
	00		 je	 $LN27@z900_plo_c
  0048e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00496	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0049a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0049d	0f 85 dd 00 00
	00		 jne	 $LN27@z900_plo_c

; 972  :         {
; 973  :             regs->AR(r3) = op4alet;

  004a3	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004ab	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b3	8b 54 24 34	 mov	 edx, DWORD PTR op4alet$[rsp]
  004b7	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 974  :             SET_AEA_AR(regs, r3);

  004be	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c6	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  004ca	83 f8 40	 cmp	 eax, 64			; 00000040H
  004cd	0f 85 a3 00 00
	00		 jne	 $LN28@z900_plo_c
  004d3	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  004db	0f 8e 95 00 00
	00		 jle	 $LN28@z900_plo_c
  004e1	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004e9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f1	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  004f9	75 21		 jne	 SHORT $LN29@z900_plo_c
  004fb	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00502	83 c0 05	 add	 eax, 5
  00505	48 98		 cdqe
  00507	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050f	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0051a	eb 5a		 jmp	 SHORT $LN30@z900_plo_c
$LN29@z900_plo_c:
  0051c	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00524	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052c	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00534	75 21		 jne	 SHORT $LN31@z900_plo_c
  00536	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0053d	83 c0 05	 add	 eax, 5
  00540	48 98		 cdqe
  00542	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054a	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00555	eb 1f		 jmp	 SHORT $LN32@z900_plo_c
$LN31@z900_plo_c:
  00557	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0055e	83 c0 05	 add	 eax, 5
  00561	48 98		 cdqe
  00563	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056b	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN32@z900_plo_c:
$LN30@z900_plo_c:
$LN28@z900_plo_c:
  00576	33 c0		 xor	 eax, eax
  00578	85 c0		 test	 eax, eax
  0057a	0f 85 3e ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN27@z900_plo_c:

; 975  :         }
; 976  :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  00580	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00588	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00590	48 8b 54 24 40	 mov	 rdx, QWORD PTR op4addr$[rsp]
  00595	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op3$[rsp]
  0059a	e8 00 00 00 00	 call	 z900_vstore8

; 977  : 
; 978  :         /* Store 5th op at 6th op */
; 979  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0059f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a7	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  005ab	83 e0 04	 and	 eax, 4
  005ae	85 c0		 test	 eax, eax
  005b0	0f 84 f2 00 00
	00		 je	 $LN33@z900_plo_c
  005b6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005be	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005c2	83 f8 40	 cmp	 eax, 64			; 00000040H
  005c5	0f 85 dd 00 00
	00		 jne	 $LN33@z900_plo_c

; 980  :         {
; 981  :             regs->AR(r3) = op6alet;

  005cb	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005db	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  005df	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@z900_plo_c:

; 982  :             SET_AEA_AR(regs, r3);

  005e6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ee	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005f2	83 f8 40	 cmp	 eax, 64			; 00000040H
  005f5	0f 85 a3 00 00
	00		 jne	 $LN34@z900_plo_c
  005fb	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00603	0f 8e 95 00 00
	00		 jle	 $LN34@z900_plo_c
  00609	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00611	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00619	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00621	75 21		 jne	 SHORT $LN35@z900_plo_c
  00623	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0062a	83 c0 05	 add	 eax, 5
  0062d	48 98		 cdqe
  0062f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00637	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00642	eb 5a		 jmp	 SHORT $LN36@z900_plo_c
$LN35@z900_plo_c:
  00644	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0064c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00654	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0065c	75 21		 jne	 SHORT $LN37@z900_plo_c
  0065e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00665	83 c0 05	 add	 eax, 5
  00668	48 98		 cdqe
  0066a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00672	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0067d	eb 1f		 jmp	 SHORT $LN38@z900_plo_c
$LN37@z900_plo_c:
  0067f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00686	83 c0 05	 add	 eax, 5
  00689	48 98		 cdqe
  0068b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00693	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN38@z900_plo_c:
$LN36@z900_plo_c:
$LN34@z900_plo_c:
  0069e	33 c0		 xor	 eax, eax
  006a0	85 c0		 test	 eax, eax
  006a2	0f 85 3e ff ff
	ff		 jne	 $LN13@z900_plo_c
$LN33@z900_plo_c:

; 983  :         }
; 984  :         ARCH_DEP(vstore8)(op5, op6addr, r3, regs);

  006a8	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006b0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  006b8	48 8b 54 24 38	 mov	 rdx, QWORD PTR op6addr$[rsp]
  006bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op5$[rsp]
  006c2	e8 00 00 00 00	 call	 z900_vstore8

; 985  : 
; 986  :         /* Store 1st op replacement at 2nd op */
; 987  :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  006c7	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006cf	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  006d7	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  006df	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op1r$[rsp]
  006e4	e8 00 00 00 00	 call	 z900_vstore8

; 988  : 
; 989  :         return 0;

  006e9	33 c0		 xor	 eax, eax
  006eb	eb 3f		 jmp	 SHORT $LN1@z900_plo_c

; 990  :     }

  006ed	eb 3d		 jmp	 SHORT $LN17@z900_plo_c
$LN16@z900_plo_c:

; 991  :     else
; 992  :     {
; 993  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  006ef	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  006f7	48 83 c0 08	 add	 rax, 8
  006fb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00703	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0070a	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00712	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  0071a	48 8b d0	 mov	 rdx, rax
  0071d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00722	e8 00 00 00 00	 call	 z900_vstore8

; 994  : 
; 995  :         return 1;

  00727	b8 01 00 00 00	 mov	 eax, 1
$LN17@z900_plo_c:
$LN1@z900_plo_c:

; 996  :     }
; 997  : }

  0072c	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00730	c3		 ret	 0
z900_plo_csdstg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6alet$ = 48
op4alet$ = 52
op2$ = 56
op3$ = 60
op5$ = 64
op6addr$ = 72
op4addr$ = 80
r1$ = 112
r3$ = 120
effective_addr2$ = 128
b2$ = 136
effective_addr4$ = 144
b4$ = 152
regs$ = 160
z900_plo_csdst PROC

; 819  : {

$LN38:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 820  : U32 op2,
; 821  :     op3,
; 822  :     op4alet = 0,

  00016	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 823  :     op5,
; 824  :     op6alet = 0;

  0001e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 825  : VADR op4addr,
; 826  :     op6addr;
; 827  : 
; 828  :     ODD_CHECK(r1, regs);

  00026	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 1b		 je	 SHORT $LN11@z900_plo_c
  00031	ba 06 00 00 00	 mov	 edx, 6
  00036	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00046	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_plo_c:

; 829  :     FW_CHECK(effective_addr2, regs);

  0004c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00054	48 83 e0 03	 and	 rax, 3
  00058	48 85 c0	 test	 rax, rax
  0005b	74 1b		 je	 SHORT $LN12@z900_plo_c
  0005d	ba 06 00 00 00	 mov	 edx, 6
  00062	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00072	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_plo_c:

; 830  :     FW_CHECK(effective_addr4, regs);

  00078	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00080	48 83 e0 03	 and	 rax, 3
  00084	48 85 c0	 test	 rax, rax
  00087	74 1b		 je	 SHORT $LN13@z900_plo_c
  00089	ba 06 00 00 00	 mov	 edx, 6
  0008e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0009e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_plo_c:

; 831  : 
; 832  :     op2 = ARCH_DEP(vfetch4)(effective_addr2, b2, regs);

  000a4	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ac	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000bb	e8 00 00 00 00	 call	 z900_vfetch4
  000c0	89 44 24 38	 mov	 DWORD PTR op2$[rsp], eax

; 833  :     op3 = ARCH_DEP(wfetch4)(effective_addr4 + 60, b4, regs);

  000c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000cc	48 83 c0 3c	 add	 rax, 60			; 0000003cH
  000d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000df	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000e7	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	e8 00 00 00 00	 call	 z900_vfetch4
  000f6	89 44 24 3c	 mov	 DWORD PTR op3$[rsp], eax

; 834  :     op5 = ARCH_DEP(wfetch4)(effective_addr4 + 92, b4, regs);

  000fa	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00102	48 83 c0 5c	 add	 rax, 92			; 0000005cH
  00106	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00115	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0011d	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00124	48 8b c8	 mov	 rcx, rax
  00127	e8 00 00 00 00	 call	 z900_vfetch4
  0012c	89 44 24 40	 mov	 DWORD PTR op5$[rsp], eax

; 835  : 
; 836  :     if(regs->GR_L(r1) == op2)

  00130	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  00135	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00141	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00148	0f 85 23 05 00
	00		 jne	 $LN14@z900_plo_c

; 837  :     {
; 838  : 
; 839  :         /* Verify access to 2nd operand */
; 840  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  0014e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00156	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00161	41 b8 03 00 00
	00		 mov	 r8d, 3
  00167	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0016e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00176	e8 00 00 00 00	 call	 z900_validate_operand

; 841  :             ACCTYPE_WRITE_SKP, regs);
; 842  : 
; 843  :         /* When in ar mode, ar3 is used to access the
; 844  :            operand. The alet is fetched from the pl */
; 845  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0017b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00183	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00187	83 e0 04	 and	 eax, 4
  0018a	85 c0		 test	 eax, eax
  0018c	0f 84 62 01 00
	00		 je	 $LN16@z900_plo_c
  00192	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0019e	83 f8 40	 cmp	 eax, 64			; 00000040H
  001a1	0f 85 4d 01 00
	00		 jne	 $LN16@z900_plo_c

; 846  :         {
; 847  :             if(r3 == 0)

  001a7	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  001ac	75 12		 jne	 SHORT $LN17@z900_plo_c

; 848  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001ae	ba 06 00 00 00	 mov	 edx, 6
  001b3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bb	e8 00 00 00 00	 call	 z900_program_interrupt
$LN17@z900_plo_c:

; 849  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001c0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001c8	48 83 c0 44	 add	 rax, 68			; 00000044H
  001cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001db	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e3	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	e8 00 00 00 00	 call	 z900_vfetch4
  001f2	89 44 24 34	 mov	 DWORD PTR op4alet$[rsp], eax

; 850  :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  001f6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001fe	48 83 c0 64	 add	 rax, 100		; 00000064H
  00202	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00211	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00219	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00220	48 8b c8	 mov	 rcx, rax
  00223	e8 00 00 00 00	 call	 z900_vfetch4
  00228	89 44 24 30	 mov	 DWORD PTR op6alet$[rsp], eax

; 851  :             regs->AR(r3) = op6alet;

  0022c	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00231	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  0023d	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN4@z900_plo_c:

; 852  :             SET_AEA_AR(regs, r3);

  00244	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00250	83 f8 40	 cmp	 eax, 64			; 00000040H
  00253	0f 85 91 00 00
	00		 jne	 $LN18@z900_plo_c
  00259	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  0025e	0f 8e 86 00 00
	00		 jle	 $LN18@z900_plo_c
  00264	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00269	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00271	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00279	75 1e		 jne	 SHORT $LN19@z900_plo_c
  0027b	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0027f	83 c0 05	 add	 eax, 5
  00282	48 98		 cdqe
  00284	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00297	eb 51		 jmp	 SHORT $LN20@z900_plo_c
$LN19@z900_plo_c:
  00299	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0029e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a6	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  002ae	75 1e		 jne	 SHORT $LN21@z900_plo_c
  002b0	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  002b4	83 c0 05	 add	 eax, 5
  002b7	48 98		 cdqe
  002b9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c1	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  002cc	eb 1c		 jmp	 SHORT $LN22@z900_plo_c
$LN21@z900_plo_c:
  002ce	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  002d2	83 c0 05	 add	 eax, 5
  002d5	48 98		 cdqe
  002d7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN22@z900_plo_c:
$LN20@z900_plo_c:
$LN18@z900_plo_c:
  002ea	33 c0		 xor	 eax, eax
  002ec	85 c0		 test	 eax, eax
  002ee	0f 85 50 ff ff
	ff		 jne	 $LN4@z900_plo_c
$LN16@z900_plo_c:

; 853  :         }
; 854  : 
; 855  :         /* Load address of operand 4 */
; 856  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 857  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  002f4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002fc	48 83 c0 48	 add	 rax, 72			; 00000048H
  00300	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00308	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0030f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00317	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0031e	48 8b c8	 mov	 rcx, rax
  00321	e8 00 00 00 00	 call	 z900_vfetch8
  00326	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 858  : #else
; 859  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);
; 860  : #endif
; 861  :         op4addr &= ADDRESS_MAXWRAP(regs);

  0032b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00333	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0033a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op4addr$[rsp]
  0033f	48 23 c8	 and	 rcx, rax
  00342	48 8b c1	 mov	 rax, rcx
  00345	48 89 44 24 50	 mov	 QWORD PTR op4addr$[rsp], rax

; 862  :         FW_CHECK(op4addr, regs);

  0034a	48 8b 44 24 50	 mov	 rax, QWORD PTR op4addr$[rsp]
  0034f	48 83 e0 03	 and	 rax, 3
  00353	48 85 c0	 test	 rax, rax
  00356	74 1b		 je	 SHORT $LN23@z900_plo_c
  00358	ba 06 00 00 00	 mov	 edx, 6
  0035d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00365	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN23@z900_plo_c:

; 863  : 
; 864  :         /* Load address of operand 6 */
; 865  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 866  :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);

  00373	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0037b	48 83 c0 68	 add	 rax, 104		; 00000068H
  0037f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00387	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0038e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00396	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0039d	48 8b c8	 mov	 rcx, rax
  003a0	e8 00 00 00 00	 call	 z900_vfetch8
  003a5	48 89 44 24 48	 mov	 QWORD PTR op6addr$[rsp], rax

; 867  : #else
; 868  :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);
; 869  : #endif
; 870  :         op6addr &= ADDRESS_MAXWRAP(regs);

  003aa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b2	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003b9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op6addr$[rsp]
  003be	48 23 c8	 and	 rcx, rax
  003c1	48 8b c1	 mov	 rax, rcx
  003c4	48 89 44 24 48	 mov	 QWORD PTR op6addr$[rsp], rax

; 871  :         FW_CHECK(op6addr, regs);

  003c9	48 8b 44 24 48	 mov	 rax, QWORD PTR op6addr$[rsp]
  003ce	48 83 e0 03	 and	 rax, 3
  003d2	48 85 c0	 test	 rax, rax
  003d5	74 1b		 je	 SHORT $LN24@z900_plo_c
  003d7	ba 06 00 00 00	 mov	 edx, 6
  003dc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ec	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@z900_plo_c:

; 872  : 
; 873  :         /* Verify access to 6th operand */
; 874  :         ARCH_DEP(validate_operand) (op6addr, r3, 4-1,ACCTYPE_WRITE_SKP, regs);

  003f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ff	41 b9 01 00 00
	00		 mov	 r9d, 1
  00405	41 b8 03 00 00
	00		 mov	 r8d, 3
  0040b	8b 54 24 78	 mov	 edx, DWORD PTR r3$[rsp]
  0040f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op6addr$[rsp]
  00414	e8 00 00 00 00	 call	 z900_validate_operand

; 875  : 
; 876  :         /* Store 3th op at 4th op */
; 877  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00419	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00421	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00425	83 e0 04	 and	 eax, 4
  00428	85 c0		 test	 eax, eax
  0042a	0f 84 dd 00 00
	00		 je	 $LN25@z900_plo_c
  00430	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00438	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0043c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0043f	0f 85 c8 00 00
	00		 jne	 $LN25@z900_plo_c

; 878  :         {
; 879  :             regs->AR(r3) = op4alet;

  00445	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0044a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00452	8b 54 24 34	 mov	 edx, DWORD PTR op4alet$[rsp]
  00456	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 880  :             SET_AEA_AR(regs, r3);

  0045d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00465	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00469	83 f8 40	 cmp	 eax, 64			; 00000040H
  0046c	0f 85 91 00 00
	00		 jne	 $LN26@z900_plo_c
  00472	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  00477	0f 8e 86 00 00
	00		 jle	 $LN26@z900_plo_c
  0047d	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00482	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048a	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00492	75 1e		 jne	 SHORT $LN27@z900_plo_c
  00494	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00498	83 c0 05	 add	 eax, 5
  0049b	48 98		 cdqe
  0049d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a5	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  004b0	eb 51		 jmp	 SHORT $LN28@z900_plo_c
$LN27@z900_plo_c:
  004b2	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  004b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bf	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  004c7	75 1e		 jne	 SHORT $LN29@z900_plo_c
  004c9	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  004cd	83 c0 05	 add	 eax, 5
  004d0	48 98		 cdqe
  004d2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004da	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  004e5	eb 1c		 jmp	 SHORT $LN30@z900_plo_c
$LN29@z900_plo_c:
  004e7	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  004eb	83 c0 05	 add	 eax, 5
  004ee	48 98		 cdqe
  004f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f8	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN30@z900_plo_c:
$LN28@z900_plo_c:
$LN26@z900_plo_c:
  00503	33 c0		 xor	 eax, eax
  00505	85 c0		 test	 eax, eax
  00507	0f 85 50 ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN25@z900_plo_c:

; 881  :         }
; 882  :         ARCH_DEP(vstore4)(op3, op4addr, r3, regs);

  0050d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00515	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  0051a	48 8b 54 24 50	 mov	 rdx, QWORD PTR op4addr$[rsp]
  0051f	8b 4c 24 3c	 mov	 ecx, DWORD PTR op3$[rsp]
  00523	e8 00 00 00 00	 call	 z900_vstore4

; 883  : 
; 884  :         /* Store 5th op at 6th op */
; 885  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00528	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00530	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00534	83 e0 04	 and	 eax, 4
  00537	85 c0		 test	 eax, eax
  00539	0f 84 dd 00 00
	00		 je	 $LN31@z900_plo_c
  0053f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00547	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0054b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0054e	0f 85 c8 00 00
	00		 jne	 $LN31@z900_plo_c

; 886  :         {
; 887  :             regs->AR(r3) = op6alet;

  00554	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00559	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00561	8b 54 24 30	 mov	 edx, DWORD PTR op6alet$[rsp]
  00565	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@z900_plo_c:

; 888  :             SET_AEA_AR(regs, r3);

  0056c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00574	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00578	83 f8 40	 cmp	 eax, 64			; 00000040H
  0057b	0f 85 91 00 00
	00		 jne	 $LN32@z900_plo_c
  00581	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  00586	0f 8e 86 00 00
	00		 jle	 $LN32@z900_plo_c
  0058c	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00591	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00599	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  005a1	75 1e		 jne	 SHORT $LN33@z900_plo_c
  005a3	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  005a7	83 c0 05	 add	 eax, 5
  005aa	48 98		 cdqe
  005ac	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b4	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  005bf	eb 51		 jmp	 SHORT $LN34@z900_plo_c
$LN33@z900_plo_c:
  005c1	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  005c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ce	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  005d6	75 1e		 jne	 SHORT $LN35@z900_plo_c
  005d8	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  005dc	83 c0 05	 add	 eax, 5
  005df	48 98		 cdqe
  005e1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e9	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  005f4	eb 1c		 jmp	 SHORT $LN36@z900_plo_c
$LN35@z900_plo_c:
  005f6	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  005fa	83 c0 05	 add	 eax, 5
  005fd	48 98		 cdqe
  005ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00607	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN36@z900_plo_c:
$LN34@z900_plo_c:
$LN32@z900_plo_c:
  00612	33 c0		 xor	 eax, eax
  00614	85 c0		 test	 eax, eax
  00616	0f 85 50 ff ff
	ff		 jne	 $LN10@z900_plo_c
$LN31@z900_plo_c:

; 889  :         }
; 890  :         ARCH_DEP(vstore4)(op5, op6addr, r3, regs);

  0061c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00624	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  00629	48 8b 54 24 48	 mov	 rdx, QWORD PTR op6addr$[rsp]
  0062e	8b 4c 24 40	 mov	 ecx, DWORD PTR op5$[rsp]
  00632	e8 00 00 00 00	 call	 z900_vstore4

; 891  : 
; 892  :         /* Store 1st op at 2nd op */
; 893  :         ARCH_DEP(vstore4)(regs->GR_L(r1+1), effective_addr2, b2, regs);

  00637	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  0063b	ff c0		 inc	 eax
  0063d	48 98		 cdqe
  0063f	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00647	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  0064f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00657	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0065f	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00666	e8 00 00 00 00	 call	 z900_vstore4

; 894  : 
; 895  :         return 0;

  0066b	33 c0		 xor	 eax, eax
  0066d	eb 1f		 jmp	 SHORT $LN1@z900_plo_c

; 896  :     }

  0066f	eb 1d		 jmp	 SHORT $LN15@z900_plo_c
$LN14@z900_plo_c:

; 897  :     else
; 898  :     {
; 899  :         regs->GR_L(r1) = op2;

  00671	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  00676	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067e	8b 54 24 38	 mov	 edx, DWORD PTR op2$[rsp]
  00682	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 900  : 
; 901  :         return 1;

  00689	b8 01 00 00 00	 mov	 eax, 1
$LN15@z900_plo_c:
$LN1@z900_plo_c:

; 902  :     }
; 903  : }

  0068e	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00692	c3		 ret	 0
z900_plo_csdst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4alet$ = 48
op4addr$ = 56
op2$ = 64
op1c$ = 80
op3$ = 96
op1r$ = 112
__$ArrayPad$ = 128
r1$ = 160
r3$ = 168
effective_addr2$ = 176
b2$ = 184
effective_addr4$ = 192
b4$ = 200
regs$ = 208
z900_plo_csstx PROC

; 759  : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 760  : BYTE op1c[16],
; 761  :      op1r[16],
; 762  :      op2[16],
; 763  :      op3[16];
; 764  : U32 op4alet = 0;

  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@z900_plo_c:

; 765  : VADR op4addr;
; 766  : 
; 767  :     UNREFERENCED(r1);

  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 768  : 
; 769  :     QW_CHECK(effective_addr2, regs);

  00039	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00041	48 83 e0 0f	 and	 rax, 15
  00045	48 85 c0	 test	 rax, rax
  00048	74 1b		 je	 SHORT $LN8@z900_plo_c
  0004a	ba 06 00 00 00	 mov	 edx, 6
  0004f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_c:

; 770  :     DW_CHECK(effective_addr4, regs);

  00065	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0006d	48 83 e0 07	 and	 rax, 7
  00071	48 85 c0	 test	 rax, rax
  00074	74 1b		 je	 SHORT $LN9@z900_plo_c
  00076	ba 06 00 00 00	 mov	 edx, 6
  0007b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_c:

; 771  : 
; 772  :     ARCH_DEP(vfetchc) ( op1c, 16-1, effective_addr4 + 0, b4, regs );

  00091	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  000a6	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  000ae	b2 0f		 mov	 dl, 15
  000b0	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1c$[rsp]
  000b5	e8 00 00 00 00	 call	 z900_vfetchc

; 773  :     ARCH_DEP(vfetchc) ( op2, 16-1, effective_addr2, b2, regs );

  000ba	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c7	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  000cf	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  000d7	b2 0f		 mov	 dl, 15
  000d9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  000de	e8 00 00 00 00	 call	 z900_vfetchc

; 774  : 
; 775  :     if(memcmp(op1c,op2,16) == 0)

  000e3	41 b8 10 00 00
	00		 mov	 r8d, 16
  000e9	48 8d 54 24 40	 lea	 rdx, QWORD PTR op2$[rsp]
  000ee	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1c$[rsp]
  000f3	e8 00 00 00 00	 call	 memcmp
  000f8	85 c0		 test	 eax, eax
  000fa	0f 85 da 02 00
	00		 jne	 $LN10@z900_plo_c

; 776  :     {
; 777  :         ARCH_DEP(wfetchc) ( op1r, 16-1, effective_addr4 + 16, b4, regs );

  00100	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00108	48 83 c0 10	 add	 rax, 16
  0010c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0011b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00123	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00128	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00130	4c 8b c0	 mov	 r8, rax
  00133	b2 0f		 mov	 dl, 15
  00135	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op1r$[rsp]
  0013a	e8 00 00 00 00	 call	 z900_vfetchc

; 778  :         ARCH_DEP(wfetchc) ( op3, 16-1, effective_addr4 + 48, b4, regs );

  0013f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00147	48 83 c0 30	 add	 rax, 48			; 00000030H
  0014b	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00153	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0015a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00162	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00167	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  0016f	4c 8b c0	 mov	 r8, rax
  00172	b2 0f		 mov	 dl, 15
  00174	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op3$[rsp]
  00179	e8 00 00 00 00	 call	 z900_vfetchc

; 779  : 
; 780  :         /* Verify access to 2nd operand */
; 781  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 16-1,

  0017e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00186	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00191	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00197	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0019e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  001a6	e8 00 00 00 00	 call	 z900_validate_operand

; 782  :             ACCTYPE_WRITE_SKP, regs);
; 783  : 
; 784  :         /* When in ar mode, ar3 is used to access the
; 785  :            operand. The alet is fetched from the pl */
; 786  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001ab	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001b3	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001b7	83 e0 04	 and	 eax, 4
  001ba	85 c0		 test	 eax, eax
  001bc	0f 84 44 01 00
	00		 je	 $LN12@z900_plo_c
  001c2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ca	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001ce	83 f8 40	 cmp	 eax, 64			; 00000040H
  001d1	0f 85 2f 01 00
	00		 jne	 $LN12@z900_plo_c

; 787  :         {
; 788  :             if(r3 == 0)

  001d7	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001df	75 12		 jne	 SHORT $LN13@z900_plo_c

; 789  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001e1	ba 06 00 00 00	 mov	 edx, 6
  001e6	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ee	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_plo_c:

; 790  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001f3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001fb	48 83 c0 44	 add	 rax, 68			; 00000044H
  001ff	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0020e	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00216	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0021d	48 8b c8	 mov	 rcx, rax
  00220	e8 00 00 00 00	 call	 z900_vfetch4
  00225	89 44 24 30	 mov	 DWORD PTR op4alet$[rsp], eax

; 791  :             regs->AR(r3) = op4alet;

  00229	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00231	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	8b 54 24 30	 mov	 edx, DWORD PTR op4alet$[rsp]
  0023d	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 792  :             SET_AEA_AR(regs, r3);

  00244	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00250	83 f8 40	 cmp	 eax, 64			; 00000040H
  00253	0f 85 a3 00 00
	00		 jne	 $LN14@z900_plo_c
  00259	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00261	0f 8e 95 00 00
	00		 jle	 $LN14@z900_plo_c
  00267	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0026f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00277	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0027f	75 21		 jne	 SHORT $LN15@z900_plo_c
  00281	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00288	83 c0 05	 add	 eax, 5
  0028b	48 98		 cdqe
  0028d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00295	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  002a0	eb 5a		 jmp	 SHORT $LN16@z900_plo_c
$LN15@z900_plo_c:
  002a2	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002aa	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b2	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  002ba	75 21		 jne	 SHORT $LN17@z900_plo_c
  002bc	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002c3	83 c0 05	 add	 eax, 5
  002c6	48 98		 cdqe
  002c8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d0	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  002db	eb 1f		 jmp	 SHORT $LN18@z900_plo_c
$LN17@z900_plo_c:
  002dd	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002e4	83 c0 05	 add	 eax, 5
  002e7	48 98		 cdqe
  002e9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f1	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@z900_plo_c:
$LN16@z900_plo_c:
$LN14@z900_plo_c:
  002fc	33 c0		 xor	 eax, eax
  002fe	85 c0		 test	 eax, eax
  00300	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN12@z900_plo_c:

; 793  :         }
; 794  : 
; 795  :         /* Load address of operand 4 */
; 796  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  00306	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0030e	48 83 c0 48	 add	 rax, 72			; 00000048H
  00312	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00321	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00329	8b 94 24 c8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00330	48 8b c8	 mov	 rcx, rax
  00333	e8 00 00 00 00	 call	 z900_vfetch8
  00338	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 797  :         op4addr &= ADDRESS_MAXWRAP(regs);

  0033d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00345	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0034c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op4addr$[rsp]
  00351	48 23 c8	 and	 rcx, rax
  00354	48 8b c1	 mov	 rax, rcx
  00357	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 798  :         QW_CHECK(op4addr, regs);

  0035c	48 8b 44 24 38	 mov	 rax, QWORD PTR op4addr$[rsp]
  00361	48 83 e0 0f	 and	 rax, 15
  00365	48 85 c0	 test	 rax, rax
  00368	74 1b		 je	 SHORT $LN19@z900_plo_c
  0036a	ba 06 00 00 00	 mov	 edx, 6
  0036f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00377	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_c:

; 799  : 
; 800  :         ARCH_DEP(vstorec)(op3, 16-1, op4addr, r3, regs);

  00385	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00392	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  0039a	4c 8b 44 24 38	 mov	 r8, QWORD PTR op4addr$[rsp]
  0039f	b2 0f		 mov	 dl, 15
  003a1	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op3$[rsp]
  003a6	e8 00 00 00 00	 call	 z900_vstorec

; 801  :         ARCH_DEP(vstorec)(op1r, 16-1, effective_addr2, b2, regs);

  003ab	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b8	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  003c0	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  003c8	b2 0f		 mov	 dl, 15
  003ca	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op1r$[rsp]
  003cf	e8 00 00 00 00	 call	 z900_vstorec

; 802  : 
; 803  :         return 0;

  003d4	33 c0		 xor	 eax, eax
  003d6	eb 30		 jmp	 SHORT $LN1@z900_plo_c

; 804  :     }

  003d8	eb 2e		 jmp	 SHORT $LN11@z900_plo_c
$LN10@z900_plo_c:

; 805  :     else
; 806  :     {
; 807  :         /* Store 2nd op at 1st op comare value */
; 808  :         ARCH_DEP(vstorec)(op2, 16-1, effective_addr4 + 0, b4, regs);

  003da	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e7	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  003ef	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  003f7	b2 0f		 mov	 dl, 15
  003f9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  003fe	e8 00 00 00 00	 call	 z900_vstorec

; 809  : 
; 810  :         return 1;

  00403	b8 01 00 00 00	 mov	 eax, 1
$LN11@z900_plo_c:
$LN1@z900_plo_c:

; 811  :     }
; 812  : 
; 813  : }

  00408	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00410	48 33 cc	 xor	 rcx, rsp
  00413	e8 00 00 00 00	 call	 __security_check_cookie
  00418	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0041f	c3		 ret	 0
z900_plo_csstx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 48
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
z900_plo_csstgr PROC

; 722  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 723  : U64 op2;
; 724  : 
; 725  :     ODD_CHECK(r1, regs);

  00016	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN2@z900_plo_c
  00021	ba 06 00 00 00	 mov	 edx, 6
  00026	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_plo_c:

; 726  :     DW_CHECK(effective_addr2, regs);

  0003c	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00041	48 83 e0 07	 and	 rax, 7
  00045	48 85 c0	 test	 rax, rax
  00048	74 1b		 je	 SHORT $LN3@z900_plo_c
  0004a	ba 06 00 00 00	 mov	 edx, 6
  0004f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN3@z900_plo_c:

; 727  :     DW_CHECK(effective_addr4, regs);

  00065	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0006a	48 83 e0 07	 and	 rax, 7
  0006e	48 85 c0	 test	 rax, rax
  00071	74 1b		 je	 SHORT $LN4@z900_plo_c
  00073	ba 06 00 00 00	 mov	 edx, 6
  00078	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@z900_plo_c:

; 728  : 
; 729  :     /* Load second operand from operand address  */
; 730  :     op2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  0008e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00096	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0009f	e8 00 00 00 00	 call	 z900_vfetch8
  000a4	48 89 44 24 30	 mov	 QWORD PTR op2$[rsp], rax

; 731  : 
; 732  :     /* Compare operand with register contents */
; 733  :     if ( regs->GR_G(r1) == op2)

  000a9	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b6	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  000bb	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  000c3	0f 85 88 00 00
	00		 jne	 $LN5@z900_plo_c

; 734  :     {
; 735  :         /* Verify access to 2nd operand */
; 736  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  000c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	41 b9 01 00 00
	00		 mov	 r9d, 1
  000dc	41 b8 07 00 00
	00		 mov	 r8d, 7
  000e2	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  000e6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000eb	e8 00 00 00 00	 call	 z900_validate_operand

; 737  :             ACCTYPE_WRITE_SKP, regs);
; 738  : 
; 739  :         /* If equal, store replacement and set cc=0 */
; 740  :         ARCH_DEP(vstore8) ( regs->GR_G(r3), effective_addr4, b4, regs );

  000f0	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  000f5	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000fd	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  00102	48 8b 54 24 70	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  00107	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00117	e8 00 00 00 00	 call	 z900_vstore8

; 741  :         ARCH_DEP(vstore8) ( regs->GR_G(r1+1), effective_addr2, b2, regs );

  0011c	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00120	ff c0		 inc	 eax
  00122	48 98		 cdqe
  00124	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0012c	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  00131	48 8b 54 24 60	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00136	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013e	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00146	e8 00 00 00 00	 call	 z900_vstore8

; 742  : 
; 743  :         return 0;

  0014b	33 c0		 xor	 eax, eax
  0014d	eb 21		 jmp	 SHORT $LN1@z900_plo_c

; 744  :     }

  0014f	eb 1f		 jmp	 SHORT $LN6@z900_plo_c
$LN5@z900_plo_c:

; 745  :     else
; 746  :     {
; 747  :         regs->GR_G(r1) = op2;

  00151	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00156	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015e	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  00163	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 748  : 
; 749  :         return 1;

  0016b	b8 01 00 00 00	 mov	 eax, 1
$LN6@z900_plo_c:
$LN1@z900_plo_c:

; 750  :     }
; 751  : 
; 752  : }

  00170	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00174	c3		 ret	 0
z900_plo_csstgr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4alet$ = 48
op4addr$ = 56
op2$ = 64
op1c$ = 72
op3$ = 80
op1r$ = 88
r1$ = 112
r3$ = 120
effective_addr2$ = 128
b2$ = 136
effective_addr4$ = 144
b4$ = 152
regs$ = 160
z900_plo_csstg PROC

; 658  : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 659  : U64 op1c,
; 660  :     op1r,
; 661  :     op2,
; 662  :     op3;
; 663  : U32 op4alet = 0;

  00016	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@z900_plo_c:

; 664  : VADR op4addr;
; 665  : 
; 666  :     UNREFERENCED(r1);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 667  : 
; 668  :     DW_CHECK(effective_addr2, regs);

  00024	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0002c	48 83 e0 07	 and	 rax, 7
  00030	48 85 c0	 test	 rax, rax
  00033	74 1b		 je	 SHORT $LN8@z900_plo_c
  00035	ba 06 00 00 00	 mov	 edx, 6
  0003a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_c:

; 669  :     DW_CHECK(effective_addr4, regs);

  00050	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00058	48 83 e0 07	 and	 rax, 7
  0005c	48 85 c0	 test	 rax, rax
  0005f	74 1b		 je	 SHORT $LN9@z900_plo_c
  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00076	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_c:

; 670  : 
; 671  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  0007c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00084	48 83 c0 08	 add	 rax, 8
  00088	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00097	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 z900_vfetch8
  000ae	48 89 44 24 48	 mov	 QWORD PTR op1c$[rsp], rax

; 672  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000b3	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000bb	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000c2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ca	e8 00 00 00 00	 call	 z900_vfetch8
  000cf	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 673  : 
; 674  :     if(op1c == op2)

  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR op2$[rsp]
  000d9	48 39 44 24 48	 cmp	 QWORD PTR op1c$[rsp], rax
  000de	0f 85 a1 02 00
	00		 jne	 $LN10@z900_plo_c

; 675  :     {
; 676  :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000ec	48 83 c0 18	 add	 rax, 24
  000f0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000ff	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00107	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0010e	48 8b c8	 mov	 rcx, rax
  00111	e8 00 00 00 00	 call	 z900_vfetch8
  00116	48 89 44 24 58	 mov	 QWORD PTR op1r$[rsp], rax

; 677  :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  0011b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00123	48 83 c0 38	 add	 rax, 56			; 00000038H
  00127	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00136	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013e	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00145	48 8b c8	 mov	 rcx, rax
  00148	e8 00 00 00 00	 call	 z900_vfetch8
  0014d	48 89 44 24 50	 mov	 QWORD PTR op3$[rsp], rax

; 678  : 
; 679  :         /* Verify access to 2nd operand */
; 680  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  00152	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00165	41 b8 07 00 00
	00		 mov	 r8d, 7
  0016b	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  00172	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0017a	e8 00 00 00 00	 call	 z900_validate_operand

; 681  :             ACCTYPE_WRITE_SKP, regs);
; 682  : 
; 683  :         /* When in ar mode, ar3 is used to access the
; 684  :            operand. The alet is fetched from the pl */
; 685  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0017f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00187	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0018b	83 e0 04	 and	 eax, 4
  0018e	85 c0		 test	 eax, eax
  00190	0f 84 2c 01 00
	00		 je	 $LN12@z900_plo_c
  00196	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001a2	83 f8 40	 cmp	 eax, 64			; 00000040H
  001a5	0f 85 17 01 00
	00		 jne	 $LN12@z900_plo_c

; 686  :         {
; 687  :             if(r3 == 0)

  001ab	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  001b0	75 12		 jne	 SHORT $LN13@z900_plo_c

; 688  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001b2	ba 06 00 00 00	 mov	 edx, 6
  001b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bf	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_plo_c:

; 689  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001c4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001cc	48 83 c0 44	 add	 rax, 68			; 00000044H
  001d0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d8	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001df	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001e7	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	e8 00 00 00 00	 call	 z900_vfetch4
  001f6	89 44 24 30	 mov	 DWORD PTR op4alet$[rsp], eax

; 690  :             regs->AR(r3) = op4alet;

  001fa	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  001ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00207	8b 54 24 30	 mov	 edx, DWORD PTR op4alet$[rsp]
  0020b	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 691  :             SET_AEA_AR(regs, r3);

  00212	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0021e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00221	0f 85 91 00 00
	00		 jne	 $LN14@z900_plo_c
  00227	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  0022c	0f 8e 86 00 00
	00		 jle	 $LN14@z900_plo_c
  00232	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00237	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00247	75 1e		 jne	 SHORT $LN15@z900_plo_c
  00249	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0024d	83 c0 05	 add	 eax, 5
  00250	48 98		 cdqe
  00252	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025a	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00265	eb 51		 jmp	 SHORT $LN16@z900_plo_c
$LN15@z900_plo_c:
  00267	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0026c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00274	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0027c	75 1e		 jne	 SHORT $LN17@z900_plo_c
  0027e	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00282	83 c0 05	 add	 eax, 5
  00285	48 98		 cdqe
  00287	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0029a	eb 1c		 jmp	 SHORT $LN18@z900_plo_c
$LN17@z900_plo_c:
  0029c	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  002a0	83 c0 05	 add	 eax, 5
  002a3	48 98		 cdqe
  002a5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ad	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@z900_plo_c:
$LN16@z900_plo_c:
$LN14@z900_plo_c:
  002b8	33 c0		 xor	 eax, eax
  002ba	85 c0		 test	 eax, eax
  002bc	0f 85 50 ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN12@z900_plo_c:

; 692  :         }
; 693  : 
; 694  :         /* Load address of operand 4 */
; 695  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 696  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  002c2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002ca	48 83 c0 48	 add	 rax, 72			; 00000048H
  002ce	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002dd	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002e5	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002ec	48 8b c8	 mov	 rcx, rax
  002ef	e8 00 00 00 00	 call	 z900_vfetch8
  002f4	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 697  : #else
; 698  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);
; 699  : #endif
; 700  :         op4addr &= ADDRESS_MAXWRAP(regs);

  002f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00301	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00308	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op4addr$[rsp]
  0030d	48 23 c8	 and	 rcx, rax
  00310	48 8b c1	 mov	 rax, rcx
  00313	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 701  :         DW_CHECK(op4addr, regs);

  00318	48 8b 44 24 38	 mov	 rax, QWORD PTR op4addr$[rsp]
  0031d	48 83 e0 07	 and	 rax, 7
  00321	48 85 c0	 test	 rax, rax
  00324	74 1b		 je	 SHORT $LN19@z900_plo_c
  00326	ba 06 00 00 00	 mov	 edx, 6
  0032b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00333	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_c:

; 702  : 
; 703  :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  00341	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00349	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  0034e	48 8b 54 24 38	 mov	 rdx, QWORD PTR op4addr$[rsp]
  00353	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op3$[rsp]
  00358	e8 00 00 00 00	 call	 z900_vstore8

; 704  :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  0035d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00365	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  0036d	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00375	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op1r$[rsp]
  0037a	e8 00 00 00 00	 call	 z900_vstore8

; 705  : 
; 706  :         return 0;

  0037f	33 c0		 xor	 eax, eax
  00381	eb 3f		 jmp	 SHORT $LN1@z900_plo_c

; 707  :     }

  00383	eb 3d		 jmp	 SHORT $LN11@z900_plo_c
$LN10@z900_plo_c:

; 708  :     else
; 709  :     {
; 710  :         /* Store 2nd op at 1st op comare value */
; 711  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  00385	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0038d	48 83 c0 08	 add	 rax, 8
  00391	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00399	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003a0	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003a8	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  003b0	48 8b d0	 mov	 rdx, rax
  003b3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  003b8	e8 00 00 00 00	 call	 z900_vstore8

; 712  : 
; 713  :         return 1;

  003bd	b8 01 00 00 00	 mov	 eax, 1
$LN11@z900_plo_c:
$LN1@z900_plo_c:

; 714  :     }
; 715  : 
; 716  : }

  003c2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  003c6	c3		 ret	 0
z900_plo_csstg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 48
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
z900_plo_csst PROC

; 623  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 624  : U32 op2;
; 625  : 
; 626  :     ODD_CHECK(r1, regs);

  00016	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN2@z900_plo_c
  00021	ba 06 00 00 00	 mov	 edx, 6
  00026	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_plo_c:

; 627  :     FW_CHECK(effective_addr2, regs);

  0003c	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00041	48 83 e0 03	 and	 rax, 3
  00045	48 85 c0	 test	 rax, rax
  00048	74 1b		 je	 SHORT $LN3@z900_plo_c
  0004a	ba 06 00 00 00	 mov	 edx, 6
  0004f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN3@z900_plo_c:

; 628  :     FW_CHECK(effective_addr4, regs);

  00065	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0006a	48 83 e0 03	 and	 rax, 3
  0006e	48 85 c0	 test	 rax, rax
  00071	74 1b		 je	 SHORT $LN4@z900_plo_c
  00073	ba 06 00 00 00	 mov	 edx, 6
  00078	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@z900_plo_c:

; 629  : 
; 630  :     /* Load second operand from operand address  */
; 631  :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  0008e	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00096	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  0009a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0009f	e8 00 00 00 00	 call	 z900_vfetch4
  000a4	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 632  : 
; 633  :     /* Compare operand with register contents */
; 634  :     if ( regs->GR_L(r1) == op2)

  000a8	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000ad	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  000b9	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  000c0	0f 85 86 00 00
	00		 jne	 $LN5@z900_plo_c

; 635  :     {
; 636  :         /* Verify access to 2nd operand */
; 637  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  000c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d9	41 b8 03 00 00
	00		 mov	 r8d, 3
  000df	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  000e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000e8	e8 00 00 00 00	 call	 z900_validate_operand

; 638  :             ACCTYPE_WRITE_SKP, regs);
; 639  : 
; 640  :         /* If equal, store replacement and set cc=0 */
; 641  :         ARCH_DEP(vstore4) ( regs->GR_L(r3), effective_addr4, b4, regs );

  000ed	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  000f2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000fa	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  000ff	48 8b 54 24 70	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  00104	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00113	e8 00 00 00 00	 call	 z900_vstore4

; 642  :         ARCH_DEP(vstore4) ( regs->GR_L(r1+1), effective_addr2, b2, regs );

  00118	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0011c	ff c0		 inc	 eax
  0011e	48 98		 cdqe
  00120	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00128	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  0012d	48 8b 54 24 60	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  00132	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013a	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00141	e8 00 00 00 00	 call	 z900_vstore4

; 643  : 
; 644  :         return 0;

  00146	33 c0		 xor	 eax, eax
  00148	eb 1f		 jmp	 SHORT $LN1@z900_plo_c

; 645  :     }

  0014a	eb 1d		 jmp	 SHORT $LN6@z900_plo_c
$LN5@z900_plo_c:

; 646  :     else
; 647  :     {
; 648  :         regs->GR_L(r1) = op2;

  0014c	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00151	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  0015d	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 649  : 
; 650  :         return 1;

  00164	b8 01 00 00 00	 mov	 eax, 1
$LN6@z900_plo_c:
$LN1@z900_plo_c:

; 651  :     }
; 652  : 
; 653  : }

  00169	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016d	c3		 ret	 0
z900_plo_csst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4alet$ = 48
op4addr$ = 56
op2$ = 64
op4$ = 80
op1c$ = 96
op3c$ = 112
op3r$ = 128
op1r$ = 144
__$ArrayPad$ = 160
r1$ = 192
r3$ = 200
effective_addr2$ = 208
b2$ = 216
effective_addr4$ = 224
b4$ = 232
regs$ = 240
z900_plo_dcsx PROC

; 539  : {

$LN23:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 540  : BYTE op1c[16],
; 541  :      op1r[16],
; 542  :      op2[16],
; 543  :      op3c[16],
; 544  :      op3r[16],
; 545  :      op4[16];
; 546  : U32 op4alet = 0;

  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@z900_plo_d:

; 547  : VADR op4addr;
; 548  : 
; 549  :     UNREFERENCED(r1);

  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 fa		 jne	 SHORT $LN4@z900_plo_d

; 550  : 
; 551  :     QW_CHECK(effective_addr2, regs);

  00039	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00041	48 83 e0 0f	 and	 rax, 15
  00045	48 85 c0	 test	 rax, rax
  00048	74 1b		 je	 SHORT $LN8@z900_plo_d
  0004a	ba 06 00 00 00	 mov	 edx, 6
  0004f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_d:

; 552  :     DW_CHECK(effective_addr4, regs);

  00065	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0006d	48 83 e0 07	 and	 rax, 7
  00071	48 85 c0	 test	 rax, rax
  00074	74 1b		 je	 SHORT $LN9@z900_plo_d
  00076	ba 06 00 00 00	 mov	 edx, 6
  0007b	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_d:

; 553  : 
; 554  :     /* load 1st op compare value from the pl */
; 555  :     ARCH_DEP(vfetchc) ( op1c, 16-1, effective_addr4 + 0, b4, regs );

  00091	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00099	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009e	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  000a6	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  000ae	b2 0f		 mov	 dl, 15
  000b0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1c$[rsp]
  000b5	e8 00 00 00 00	 call	 z900_vfetchc

; 556  : 
; 557  :     /* load 2nd operand */
; 558  :     ARCH_DEP(vfetchc) ( op2, 16-1, effective_addr2, b2, regs );

  000ba	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c7	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  000cf	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  000d7	b2 0f		 mov	 dl, 15
  000d9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  000de	e8 00 00 00 00	 call	 z900_vfetchc

; 559  : 
; 560  :     if(memcmp(op1c,op2,16) != 0)

  000e3	41 b8 10 00 00
	00		 mov	 r8d, 16
  000e9	48 8d 54 24 40	 lea	 rdx, QWORD PTR op2$[rsp]
  000ee	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op1c$[rsp]
  000f3	e8 00 00 00 00	 call	 memcmp
  000f8	85 c0		 test	 eax, eax
  000fa	74 38		 je	 SHORT $LN10@z900_plo_d

; 561  :     {
; 562  :         /* replace the 1st op compare value with 2nd op */
; 563  :         ARCH_DEP(vstorec) ( op2, 16-1, effective_addr4 + 0, b4, regs );

  000fc	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00104	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00109	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00111	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  00119	b2 0f		 mov	 dl, 15
  0011b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  00120	e8 00 00 00 00	 call	 z900_vstorec

; 564  : 
; 565  :         return 1;

  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	e9 b3 03 00 00	 jmp	 $LN1@z900_plo_d

; 566  :     }

  0012f	e9 ae 03 00 00	 jmp	 $LN11@z900_plo_d
$LN10@z900_plo_d:

; 567  :     else
; 568  :     {
; 569  :         /* Load 3rd op compare value */
; 570  :         ARCH_DEP(wfetchc) ( op3c, 16-1, effective_addr4 + 32, b4, regs );

  00134	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0013c	48 83 c0 20	 add	 rax, 32			; 00000020H
  00140	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0014f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0015c	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00164	4c 8b c0	 mov	 r8, rax
  00167	b2 0f		 mov	 dl, 15
  00169	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op3c$[rsp]
  0016e	e8 00 00 00 00	 call	 z900_vfetchc

; 571  : 
; 572  :         /* When in ar mode, ar3 is used to access the
; 573  :            operand. The alet is fetched from the pl */
; 574  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00173	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0017f	83 e0 04	 and	 eax, 4
  00182	85 c0		 test	 eax, eax
  00184	0f 84 44 01 00
	00		 je	 $LN12@z900_plo_d
  0018a	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00192	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00196	83 f8 40	 cmp	 eax, 64			; 00000040H
  00199	0f 85 2f 01 00
	00		 jne	 $LN12@z900_plo_d

; 575  :         {
; 576  :             if(r3 == 0)

  0019f	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001a7	75 12		 jne	 SHORT $LN13@z900_plo_d

; 577  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001a9	ba 06 00 00 00	 mov	 edx, 6
  001ae	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b6	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_plo_d:

; 578  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001bb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001c3	48 83 c0 44	 add	 rax, 68			; 00000044H
  001c7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cf	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001d6	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001de	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001e5	48 8b c8	 mov	 rcx, rax
  001e8	e8 00 00 00 00	 call	 z900_vfetch4
  001ed	89 44 24 30	 mov	 DWORD PTR op4alet$[rsp], eax

; 579  :             regs->AR(r3) = op4alet;

  001f1	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  001f9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00201	8b 54 24 30	 mov	 edx, DWORD PTR op4alet$[rsp]
  00205	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_d:

; 580  :             SET_AEA_AR(regs, r3);

  0020c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00214	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00218	83 f8 40	 cmp	 eax, 64			; 00000040H
  0021b	0f 85 a3 00 00
	00		 jne	 $LN14@z900_plo_d
  00221	83 bc 24 c8 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00229	0f 8e 95 00 00
	00		 jle	 $LN14@z900_plo_d
  0022f	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00237	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023f	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00247	75 21		 jne	 SHORT $LN15@z900_plo_d
  00249	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00250	83 c0 05	 add	 eax, 5
  00253	48 98		 cdqe
  00255	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00268	eb 5a		 jmp	 SHORT $LN16@z900_plo_d
$LN15@z900_plo_d:
  0026a	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00272	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027a	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00282	75 21		 jne	 SHORT $LN17@z900_plo_d
  00284	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0028b	83 c0 05	 add	 eax, 5
  0028e	48 98		 cdqe
  00290	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00298	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  002a3	eb 1f		 jmp	 SHORT $LN18@z900_plo_d
$LN17@z900_plo_d:
  002a5	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002ac	83 c0 05	 add	 eax, 5
  002af	48 98		 cdqe
  002b1	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b9	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@z900_plo_d:
$LN16@z900_plo_d:
$LN14@z900_plo_d:
  002c4	33 c0		 xor	 eax, eax
  002c6	85 c0		 test	 eax, eax
  002c8	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_d
$LN12@z900_plo_d:

; 581  :         }
; 582  : 
; 583  :         /* Load address of operand 4 */
; 584  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  002ce	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002d6	48 83 c0 48	 add	 rax, 72			; 00000048H
  002da	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002e9	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002f1	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002f8	48 8b c8	 mov	 rcx, rax
  002fb	e8 00 00 00 00	 call	 z900_vfetch8
  00300	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 585  :         op4addr &= ADDRESS_MAXWRAP(regs);

  00305	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00314	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op4addr$[rsp]
  00319	48 23 c8	 and	 rcx, rax
  0031c	48 8b c1	 mov	 rax, rcx
  0031f	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 586  :         QW_CHECK(op4addr, regs);

  00324	48 8b 44 24 38	 mov	 rax, QWORD PTR op4addr$[rsp]
  00329	48 83 e0 0f	 and	 rax, 15
  0032d	48 85 c0	 test	 rax, rax
  00330	74 1b		 je	 SHORT $LN19@z900_plo_d
  00332	ba 06 00 00 00	 mov	 edx, 6
  00337	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033f	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00347	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_d:

; 587  : 
; 588  :         /* Load operand 4, using ar3 when in ar mode */
; 589  :         ARCH_DEP(vfetchc) ( op4, 16-1, op4addr, r3, regs );

  0034d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00355	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0035a	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  00362	4c 8b 44 24 38	 mov	 r8, QWORD PTR op4addr$[rsp]
  00367	b2 0f		 mov	 dl, 15
  00369	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op4$[rsp]
  0036e	e8 00 00 00 00	 call	 z900_vfetchc

; 590  : 
; 591  :         if(memcmp(op3c,op4,16) != 0)

  00373	41 b8 10 00 00
	00		 mov	 r8d, 16
  00379	48 8d 54 24 50	 lea	 rdx, QWORD PTR op4$[rsp]
  0037e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR op3c$[rsp]
  00383	e8 00 00 00 00	 call	 memcmp
  00388	85 c0		 test	 eax, eax
  0038a	74 4e		 je	 SHORT $LN20@z900_plo_d

; 592  :         {
; 593  :             ARCH_DEP(wstorec) ( op4, 16-1, effective_addr4 + 32, b4, regs );

  0038c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00394	48 83 c0 20	 add	 rax, 32			; 00000020H
  00398	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a0	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003a7	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003af	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003b4	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  003bc	4c 8b c0	 mov	 r8, rax
  003bf	b2 0f		 mov	 dl, 15
  003c1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op4$[rsp]
  003c6	e8 00 00 00 00	 call	 z900_vstorec

; 594  : 
; 595  :             return 2;

  003cb	b8 02 00 00 00	 mov	 eax, 2
  003d0	e9 0d 01 00 00	 jmp	 $LN1@z900_plo_d

; 596  :         }

  003d5	e9 08 01 00 00	 jmp	 $LN21@z900_plo_d
$LN20@z900_plo_d:

; 597  :         else
; 598  :         {
; 599  :             /* load replacement values */
; 600  :             ARCH_DEP(wfetchc) ( op1r, 16-1, effective_addr4 + 16, b4, regs );

  003da	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  003e2	48 83 c0 10	 add	 rax, 16
  003e6	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003f5	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fd	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00402	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  0040a	4c 8b c0	 mov	 r8, rax
  0040d	b2 0f		 mov	 dl, 15
  0040f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op1r$[rsp]
  00417	e8 00 00 00 00	 call	 z900_vfetchc

; 601  :             ARCH_DEP(wfetchc) ( op3r, 16-1, effective_addr4 + 48, b4, regs );

  0041c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00424	48 83 c0 30	 add	 rax, 48			; 00000030H
  00428	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00430	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00437	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00444	44 8b 8c 24 e8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  0044c	4c 8b c0	 mov	 r8, rax
  0044f	b2 0f		 mov	 dl, 15
  00451	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op3r$[rsp]
  00459	e8 00 00 00 00	 call	 z900_vfetchc

; 602  : 
; 603  :             /* Verify access to 2nd operand */
; 604  :             ARCH_DEP(validate_operand) (effective_addr2, b2, 16-1,

  0045e	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00466	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0046b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00471	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00477	8b 94 24 d8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0047e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00486	e8 00 00 00 00	 call	 z900_validate_operand

; 605  :                 ACCTYPE_WRITE_SKP, regs);
; 606  : 
; 607  :             /* Store 3rd op replacement at 4th op */
; 608  :             ARCH_DEP(vstorec) ( op3r, 16-1, op4addr, r3, regs);

  0048b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00493	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00498	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  004a0	4c 8b 44 24 38	 mov	 r8, QWORD PTR op4addr$[rsp]
  004a5	b2 0f		 mov	 dl, 15
  004a7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR op3r$[rsp]
  004af	e8 00 00 00 00	 call	 z900_vstorec

; 609  : 
; 610  :             /* Store 1st op replacement at 2nd op */
; 611  :             ARCH_DEP(vstorec) ( op1r, 16-1, effective_addr2, b2, regs);

  004b4	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c1	44 8b 8c 24 d8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  004c9	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  004d1	b2 0f		 mov	 dl, 15
  004d3	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR op1r$[rsp]
  004db	e8 00 00 00 00	 call	 z900_vstorec

; 612  : 
; 613  :             return 0;

  004e0	33 c0		 xor	 eax, eax
$LN21@z900_plo_d:
$LN11@z900_plo_d:
$LN1@z900_plo_d:

; 614  :         }
; 615  :     }
; 616  : 
; 617  : }

  004e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004ea	48 33 cc	 xor	 rcx, rsp
  004ed	e8 00 00 00 00	 call	 __security_check_cookie
  004f2	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  004f9	c3		 ret	 0
z900_plo_dcsx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 48
op4$ = 56
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
z900_plo_dcsgr PROC

; 489  : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 490  : U64 op2,
; 491  :     op4;
; 492  : 
; 493  :     ODD2_CHECK(r1, r3, regs);

  00016	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	75 0b		 jne	 SHORT $LN3@z900_plo_d
  00021	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  00025	83 e0 01	 and	 eax, 1
  00028	85 c0		 test	 eax, eax
  0002a	74 1b		 je	 SHORT $LN2@z900_plo_d
$LN3@z900_plo_d:
  0002c	ba 06 00 00 00	 mov	 edx, 6
  00031	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00041	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_plo_d:

; 494  :     DW_CHECK(effective_addr2, regs);

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0004c	48 83 e0 07	 and	 rax, 7
  00050	48 85 c0	 test	 rax, rax
  00053	74 1b		 je	 SHORT $LN4@z900_plo_d
  00055	ba 06 00 00 00	 mov	 edx, 6
  0005a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@z900_plo_d:

; 495  :     DW_CHECK(effective_addr4, regs);

  00070	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00075	48 83 e0 07	 and	 rax, 7
  00079	48 85 c0	 test	 rax, rax
  0007c	74 1b		 je	 SHORT $LN5@z900_plo_d
  0007e	ba 06 00 00 00	 mov	 edx, 6
  00083	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00093	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN5@z900_plo_d:

; 496  : 
; 497  :     /* Load second operands from operand addresses  */
; 498  :     op2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  00099	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a1	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  000a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	e8 00 00 00 00	 call	 z900_vfetch8
  000af	48 89 44 24 30	 mov	 QWORD PTR op2$[rsp], rax

; 499  : 
; 500  :     if(regs->GR_G(r1) != op2)

  000b4	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c1	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  000c6	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  000ce	74 29		 je	 SHORT $LN6@z900_plo_d

; 501  :     {
; 502  :         regs->GR_G(r1) = op2;

  000d0	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 8b 54 24 30	 mov	 rdx, QWORD PTR op2$[rsp]
  000e2	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 503  : 
; 504  :         return 1;

  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	e9 ec 00 00 00	 jmp	 $LN1@z900_plo_d

; 505  :     }

  000f4	e9 e7 00 00 00	 jmp	 $LN7@z900_plo_d
$LN6@z900_plo_d:

; 506  :     else
; 507  :     {
; 508  :         op4 = ARCH_DEP(vfetch8) ( effective_addr4, b4, regs );

  000f9	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  00105	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_vfetch8
  0010f	48 89 44 24 38	 mov	 QWORD PTR op4$[rsp], rax

; 509  : 
; 510  :         /* Compare operand with register contents */
; 511  :         if (regs->GR_G(r3) != op4)

  00114	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  00119	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00121	48 8b 54 24 38	 mov	 rdx, QWORD PTR op4$[rsp]
  00126	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  0012e	74 29		 je	 SHORT $LN8@z900_plo_d

; 512  :         {
; 513  :             /* If unequal, load r3 from op and set cc=2 */
; 514  :             regs->GR_G(r3) = op4;

  00130	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  00135	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	48 8b 54 24 38	 mov	 rdx, QWORD PTR op4$[rsp]
  00142	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 515  : 
; 516  :             return 2;

  0014a	b8 02 00 00 00	 mov	 eax, 2
  0014f	e9 8c 00 00 00	 jmp	 $LN1@z900_plo_d

; 517  :         }

  00154	e9 87 00 00 00	 jmp	 $LN9@z900_plo_d
$LN8@z900_plo_d:

; 518  :         else
; 519  :         {
; 520  :             /* Verify access to 2nd operand */
; 521  :             ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  00159	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00161	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00166	41 b9 01 00 00
	00		 mov	 r9d, 1
  0016c	41 b8 03 00 00
	00		 mov	 r8d, 3
  00172	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  00176	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0017b	e8 00 00 00 00	 call	 z900_validate_operand

; 522  :                 ACCTYPE_WRITE_SKP, regs);
; 523  : 
; 524  :             /* If equal, store replacement and set cc=0 */
; 525  :             ARCH_DEP(vstore8) ( regs->GR_G(r3+1), effective_addr4, b4, regs );

  00180	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  00184	ff c0		 inc	 eax
  00186	48 98		 cdqe
  00188	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00190	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  00195	48 8b 54 24 70	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  0019a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a2	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  001aa	e8 00 00 00 00	 call	 z900_vstore8

; 526  :             ARCH_DEP(vstore8) ( regs->GR_G(r1+1), effective_addr2, b2, regs );

  001af	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  001b3	ff c0		 inc	 eax
  001b5	48 98		 cdqe
  001b7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001bf	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  001c4	48 8b 54 24 60	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001c9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d1	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  001d9	e8 00 00 00 00	 call	 z900_vstore8

; 527  : 
; 528  :             return 0;

  001de	33 c0		 xor	 eax, eax
$LN9@z900_plo_d:
$LN7@z900_plo_d:
$LN1@z900_plo_d:

; 529  :         }
; 530  :     }
; 531  : 
; 532  : }

  001e0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001e4	c3		 ret	 0
z900_plo_dcsgr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4alet$ = 48
op4addr$ = 56
op2$ = 64
op4$ = 72
op1c$ = 80
op3c$ = 88
op3r$ = 96
op1r$ = 104
r1$ = 128
r3$ = 136
effective_addr2$ = 144
b2$ = 152
effective_addr4$ = 160
b4$ = 168
regs$ = 176
z900_plo_dcsg PROC

; 401  : {

$LN23:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 402  : U64 op1c,
; 403  :     op1r,
; 404  :     op2,
; 405  :     op3c,
; 406  :     op3r,
; 407  :     op4;
; 408  : U32 op4alet = 0;

  00016	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@z900_plo_d:

; 409  : VADR op4addr;
; 410  : 
; 411  :     UNREFERENCED(r1);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@z900_plo_d

; 412  : 
; 413  :     DW_CHECK(effective_addr2, regs);

  00024	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0002c	48 83 e0 07	 and	 rax, 7
  00030	48 85 c0	 test	 rax, rax
  00033	74 1b		 je	 SHORT $LN8@z900_plo_d
  00035	ba 06 00 00 00	 mov	 edx, 6
  0003a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_d:

; 414  :     DW_CHECK(effective_addr4, regs);

  00050	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00058	48 83 e0 07	 and	 rax, 7
  0005c	48 85 c0	 test	 rax, rax
  0005f	74 1b		 je	 SHORT $LN9@z900_plo_d
  00061	ba 06 00 00 00	 mov	 edx, 6
  00066	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00076	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_d:

; 415  : 
; 416  :     /* load 1st op compare value from the pl */
; 417  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  0007c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00084	48 83 c0 08	 add	 rax, 8
  00088	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00097	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0009f	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000a6	48 8b c8	 mov	 rcx, rax
  000a9	e8 00 00 00 00	 call	 z900_vfetch8
  000ae	48 89 44 24 50	 mov	 QWORD PTR op1c$[rsp], rax

; 418  : 
; 419  :     /* load 2nd operand */
; 420  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000b3	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000bb	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000ca	e8 00 00 00 00	 call	 z900_vfetch8
  000cf	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 421  : 
; 422  :     if(op1c != op2)

  000d4	48 8b 44 24 40	 mov	 rax, QWORD PTR op2$[rsp]
  000d9	48 39 44 24 50	 cmp	 QWORD PTR op1c$[rsp], rax
  000de	74 47		 je	 SHORT $LN10@z900_plo_d

; 423  :     {
; 424  :         /* replace the 1st op compare value with 2nd op */
; 425  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  000e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000e8	48 83 c0 08	 add	 rax, 8
  000ec	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000fb	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00103	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  0010b	48 8b d0	 mov	 rdx, rax
  0010e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  00113	e8 00 00 00 00	 call	 z900_vstore8

; 426  : 
; 427  :         return 1;

  00118	b8 01 00 00 00	 mov	 eax, 1
  0011d	e9 65 03 00 00	 jmp	 $LN1@z900_plo_d

; 428  :     }

  00122	e9 60 03 00 00	 jmp	 $LN11@z900_plo_d
$LN10@z900_plo_d:

; 429  :     else
; 430  :     {
; 431  :         /* Load 3rd op compare value */
; 432  :         op3c = ARCH_DEP(wfetch8)(effective_addr4 + 40, b4, regs);

  00127	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0012f	48 83 c0 28	 add	 rax, 40			; 00000028H
  00133	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00142	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0014a	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00151	48 8b c8	 mov	 rcx, rax
  00154	e8 00 00 00 00	 call	 z900_vfetch8
  00159	48 89 44 24 58	 mov	 QWORD PTR op3c$[rsp], rax

; 433  : 
; 434  :         /* When in ar mode, ar3 is used to access the
; 435  :            operand. The alet is fetched from the pl */
; 436  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0015e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0016a	83 e0 04	 and	 eax, 4
  0016d	85 c0		 test	 eax, eax
  0016f	0f 84 44 01 00
	00		 je	 $LN12@z900_plo_d
  00175	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017d	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00181	83 f8 40	 cmp	 eax, 64			; 00000040H
  00184	0f 85 2f 01 00
	00		 jne	 $LN12@z900_plo_d

; 437  :         {
; 438  :             if(r3 == 0)

  0018a	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00192	75 12		 jne	 SHORT $LN13@z900_plo_d

; 439  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00194	ba 06 00 00 00	 mov	 edx, 6
  00199	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a1	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_plo_d:

; 440  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  001ae	48 83 c0 44	 add	 rax, 68			; 00000044H
  001b2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ba	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001c1	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c9	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001d0	48 8b c8	 mov	 rcx, rax
  001d3	e8 00 00 00 00	 call	 z900_vfetch4
  001d8	89 44 24 30	 mov	 DWORD PTR op4alet$[rsp], eax

; 441  :             regs->AR(r3) = op4alet;

  001dc	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  001e4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ec	8b 54 24 30	 mov	 edx, DWORD PTR op4alet$[rsp]
  001f0	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_d:

; 442  :             SET_AEA_AR(regs, r3);

  001f7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00203	83 f8 40	 cmp	 eax, 64			; 00000040H
  00206	0f 85 a3 00 00
	00		 jne	 $LN14@z900_plo_d
  0020c	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00214	0f 8e 95 00 00
	00		 jle	 $LN14@z900_plo_d
  0021a	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00222	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022a	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00232	75 21		 jne	 SHORT $LN15@z900_plo_d
  00234	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0023b	83 c0 05	 add	 eax, 5
  0023e	48 98		 cdqe
  00240	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00253	eb 5a		 jmp	 SHORT $LN16@z900_plo_d
$LN15@z900_plo_d:
  00255	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0025d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0026d	75 21		 jne	 SHORT $LN17@z900_plo_d
  0026f	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00276	83 c0 05	 add	 eax, 5
  00279	48 98		 cdqe
  0027b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0028e	eb 1f		 jmp	 SHORT $LN18@z900_plo_d
$LN17@z900_plo_d:
  00290	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00297	83 c0 05	 add	 eax, 5
  0029a	48 98		 cdqe
  0029c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a4	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@z900_plo_d:
$LN16@z900_plo_d:
$LN14@z900_plo_d:
  002af	33 c0		 xor	 eax, eax
  002b1	85 c0		 test	 eax, eax
  002b3	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_d
$LN12@z900_plo_d:

; 443  :         }
; 444  : 
; 445  :         /* Load address of operand 4 */
; 446  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 447  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  002b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002c1	48 83 c0 48	 add	 rax, 72			; 00000048H
  002c5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cd	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002d4	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002dc	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002e3	48 8b c8	 mov	 rcx, rax
  002e6	e8 00 00 00 00	 call	 z900_vfetch8
  002eb	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 448  : #else
; 449  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);
; 450  : #endif
; 451  :         op4addr &= ADDRESS_MAXWRAP(regs);

  002f0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f8	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op4addr$[rsp]
  00304	48 23 c8	 and	 rcx, rax
  00307	48 8b c1	 mov	 rax, rcx
  0030a	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 452  :         DW_CHECK(op4addr, regs);

  0030f	48 8b 44 24 38	 mov	 rax, QWORD PTR op4addr$[rsp]
  00314	48 83 e0 07	 and	 rax, 7
  00318	48 85 c0	 test	 rax, rax
  0031b	74 1b		 je	 SHORT $LN19@z900_plo_d
  0031d	ba 06 00 00 00	 mov	 edx, 6
  00322	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00332	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_d:

; 453  : 
; 454  :         /* Load operand 4, using ar3 when in ar mode */
; 455  :         op4 = ARCH_DEP(vfetch8)(op4addr, r3, regs);

  00338	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00340	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00347	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op4addr$[rsp]
  0034c	e8 00 00 00 00	 call	 z900_vfetch8
  00351	48 89 44 24 48	 mov	 QWORD PTR op4$[rsp], rax

; 456  : 
; 457  :         if(op3c != op4)

  00356	48 8b 44 24 48	 mov	 rax, QWORD PTR op4$[rsp]
  0035b	48 39 44 24 58	 cmp	 QWORD PTR op3c$[rsp], rax
  00360	74 47		 je	 SHORT $LN20@z900_plo_d

; 458  :         {
; 459  :             ARCH_DEP(wstore8)(op4, effective_addr4 + 40, b4, regs);

  00362	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0036a	48 83 c0 28	 add	 rax, 40			; 00000028H
  0036e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00376	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0037d	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00385	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  0038d	48 8b d0	 mov	 rdx, rax
  00390	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op4$[rsp]
  00395	e8 00 00 00 00	 call	 z900_vstore8

; 460  : 
; 461  :             return 2;

  0039a	b8 02 00 00 00	 mov	 eax, 2
  0039f	e9 e3 00 00 00	 jmp	 $LN1@z900_plo_d

; 462  :         }

  003a4	e9 de 00 00 00	 jmp	 $LN21@z900_plo_d
$LN20@z900_plo_d:

; 463  :         else
; 464  :         {
; 465  :             /* load replacement values */
; 466  :             op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  003a9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  003b1	48 83 c0 18	 add	 rax, 24
  003b5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bd	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003c4	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003cc	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003d3	48 8b c8	 mov	 rcx, rax
  003d6	e8 00 00 00 00	 call	 z900_vfetch8
  003db	48 89 44 24 68	 mov	 QWORD PTR op1r$[rsp], rax

; 467  :             op3r = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  003e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  003e8	48 83 c0 38	 add	 rax, 56			; 00000038H
  003ec	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  003fb	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00403	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0040a	48 8b c8	 mov	 rcx, rax
  0040d	e8 00 00 00 00	 call	 z900_vfetch8
  00412	48 89 44 24 60	 mov	 QWORD PTR op3r$[rsp], rax

; 468  : 
; 469  :             /* Verify access to 2nd operand */
; 470  :             ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  00417	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00424	41 b9 01 00 00
	00		 mov	 r9d, 1
  0042a	41 b8 07 00 00
	00		 mov	 r8d, 7
  00430	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  00437	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0043f	e8 00 00 00 00	 call	 z900_validate_operand

; 471  :                 ACCTYPE_WRITE_SKP, regs);
; 472  : 
; 473  :             /* Store 3rd op replacement at 4th op */
; 474  :             ARCH_DEP(vstore8)(op3r, op4addr, r3, regs);

  00444	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0044c	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00454	48 8b 54 24 38	 mov	 rdx, QWORD PTR op4addr$[rsp]
  00459	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op3r$[rsp]
  0045e	e8 00 00 00 00	 call	 z900_vstore8

; 475  : 
; 476  :             /* Store 1st op replacement at 2nd op */
; 477  :             ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  00463	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0046b	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  00473	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0047b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op1r$[rsp]
  00480	e8 00 00 00 00	 call	 z900_vstore8

; 478  : 
; 479  :             return 0;

  00485	33 c0		 xor	 eax, eax
$LN21@z900_plo_d:
$LN11@z900_plo_d:
$LN1@z900_plo_d:

; 480  :         }
; 481  :     }
; 482  : 
; 483  : }

  00487	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0048b	c3		 ret	 0
z900_plo_dcsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 48
op4$ = 52
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
z900_plo_dcs PROC

; 353  : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 354  : U32 op2,
; 355  :     op4;
; 356  : 
; 357  :     ODD2_CHECK(r1, r3, regs);

  00016	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	75 0b		 jne	 SHORT $LN3@z900_plo_d
  00021	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  00025	83 e0 01	 and	 eax, 1
  00028	85 c0		 test	 eax, eax
  0002a	74 1b		 je	 SHORT $LN2@z900_plo_d
$LN3@z900_plo_d:
  0002c	ba 06 00 00 00	 mov	 edx, 6
  00031	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00041	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_plo_d:

; 358  :     FW_CHECK(effective_addr2, regs);

  00047	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0004c	48 83 e0 03	 and	 rax, 3
  00050	48 85 c0	 test	 rax, rax
  00053	74 1b		 je	 SHORT $LN4@z900_plo_d
  00055	ba 06 00 00 00	 mov	 edx, 6
  0005a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@z900_plo_d:

; 359  :     FW_CHECK(effective_addr4, regs);

  00070	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00075	48 83 e0 03	 and	 rax, 3
  00079	48 85 c0	 test	 rax, rax
  0007c	74 1b		 je	 SHORT $LN5@z900_plo_d
  0007e	ba 06 00 00 00	 mov	 edx, 6
  00083	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00093	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN5@z900_plo_d:

; 360  : 
; 361  :     /* Load second operands from operand addresses  */
; 362  :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00099	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a1	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  000a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000aa	e8 00 00 00 00	 call	 z900_vfetch4
  000af	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 363  : 
; 364  :     if(regs->GR_L(r1) != op2)

  000b3	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c0	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  000c4	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  000cb	74 27		 je	 SHORT $LN6@z900_plo_d

; 365  :     {
; 366  :         regs->GR_L(r1) = op2;

  000cd	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000d2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000da	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  000de	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 367  : 
; 368  :         return 1;

  000e5	b8 01 00 00 00	 mov	 eax, 1
  000ea	e9 e5 00 00 00	 jmp	 $LN1@z900_plo_d

; 369  :     }

  000ef	e9 e0 00 00 00	 jmp	 $LN7@z900_plo_d
$LN6@z900_plo_d:

; 370  :     else
; 371  :     {
; 372  :         op4 = ARCH_DEP(vfetch4) ( effective_addr4, b4, regs );

  000f4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000fc	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  00100	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00105	e8 00 00 00 00	 call	 z900_vfetch4
  0010a	89 44 24 34	 mov	 DWORD PTR op4$[rsp], eax

; 373  : 
; 374  :         /* Compare operand with register contents */
; 375  :         if (regs->GR_L(r3) != op4)

  0010e	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  00113	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	8b 54 24 34	 mov	 edx, DWORD PTR op4$[rsp]
  0011f	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00126	74 27		 je	 SHORT $LN8@z900_plo_d

; 376  :         {
; 377  :             /* If unequal, load r3 from op and set cc=2 */
; 378  :             regs->GR_L(r3) = op4;

  00128	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  0012d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00135	8b 54 24 34	 mov	 edx, DWORD PTR op4$[rsp]
  00139	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 379  : 
; 380  :             return 2;

  00140	b8 02 00 00 00	 mov	 eax, 2
  00145	e9 8a 00 00 00	 jmp	 $LN1@z900_plo_d

; 381  :         }

  0014a	e9 85 00 00 00	 jmp	 $LN9@z900_plo_d
$LN8@z900_plo_d:

; 382  :         else
; 383  :         {
; 384  :             /* Verify access to 2nd operand */
; 385  :             ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  0014f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0015c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00162	41 b8 03 00 00
	00		 mov	 r8d, 3
  00168	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  0016c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00171	e8 00 00 00 00	 call	 z900_validate_operand

; 386  :                 ACCTYPE_WRITE_SKP, regs);
; 387  : 
; 388  :             /* If equal, store replacement and set cc=0 */
; 389  :             ARCH_DEP(vstore4) ( regs->GR_L(r3+1), effective_addr4, b4, regs );

  00176	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  0017a	ff c0		 inc	 eax
  0017c	48 98		 cdqe
  0017e	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00186	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  0018b	48 8b 54 24 70	 mov	 rdx, QWORD PTR effective_addr4$[rsp]
  00190	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0019f	e8 00 00 00 00	 call	 z900_vstore4

; 390  :             ARCH_DEP(vstore4) ( regs->GR_L(r1+1), effective_addr2, b2, regs );

  001a4	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  001a8	ff c0		 inc	 eax
  001aa	48 98		 cdqe
  001ac	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b4	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  001b9	48 8b 54 24 60	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  001be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c6	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  001cd	e8 00 00 00 00	 call	 z900_vstore4

; 391  : 
; 392  :             return 0;

  001d2	33 c0		 xor	 eax, eax
$LN9@z900_plo_d:
$LN7@z900_plo_d:
$LN1@z900_plo_d:

; 393  :         }
; 394  :     }
; 395  : 
; 396  : }

  001d4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001d8	c3		 ret	 0
z900_plo_dcs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 48
op1c$ = 64
op1r$ = 80
__$ArrayPad$ = 96
r1$ = 128
r3$ = 136
effective_addr2$ = 144
b2$ = 152
effective_addr4$ = 160
b4$ = 168
regs$ = 176
z900_plo_csx PROC

; 313  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_plo_c:

; 314  : BYTE op1c[16],
; 315  :      op1r[16],
; 316  :      op2[16];
; 317  : 
; 318  :     UNREFERENCED(r1);

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN4@z900_plo_c
$LN7@z900_plo_c:

; 319  :     UNREFERENCED(r3);

  0002b	33 c0		 xor	 eax, eax
  0002d	85 c0		 test	 eax, eax
  0002f	75 fa		 jne	 SHORT $LN7@z900_plo_c

; 320  : 
; 321  :     DW_CHECK(effective_addr4, regs);

  00031	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00039	48 83 e0 07	 and	 rax, 7
  0003d	48 85 c0	 test	 rax, rax
  00040	74 1b		 je	 SHORT $LN8@z900_plo_c
  00042	ba 06 00 00 00	 mov	 edx, 6
  00047	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00057	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_c:

; 322  :     QW_CHECK(effective_addr2, regs);

  0005d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00065	48 83 e0 0f	 and	 rax, 15
  00069	48 85 c0	 test	 rax, rax
  0006c	74 1b		 je	 SHORT $LN9@z900_plo_c
  0006e	ba 06 00 00 00	 mov	 edx, 6
  00073	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00083	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_c:

; 323  : 
; 324  :     /* Load first op compare value */
; 325  :     ARCH_DEP(vfetchc) ( op1c, 16-1, effective_addr4 + 0, b4, regs );

  00089	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00091	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00096	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  0009e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  000a6	b2 0f		 mov	 dl, 15
  000a8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1c$[rsp]
  000ad	e8 00 00 00 00	 call	 z900_vfetchc

; 326  : 
; 327  :     /* Load 2nd operand */
; 328  :     ARCH_DEP(vfetchc) ( op2, 16-1, effective_addr2, b2, regs );

  000b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ba	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bf	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  000c7	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  000cf	b2 0f		 mov	 dl, 15
  000d1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  000d6	e8 00 00 00 00	 call	 z900_vfetchc

; 329  : 
; 330  :     if(memcmp(op1c,op2,16) == 0)

  000db	41 b8 10 00 00
	00		 mov	 r8d, 16
  000e1	48 8d 54 24 30	 lea	 rdx, QWORD PTR op2$[rsp]
  000e6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op1c$[rsp]
  000eb	e8 00 00 00 00	 call	 memcmp
  000f0	85 c0		 test	 eax, eax
  000f2	75 6e		 jne	 SHORT $LN10@z900_plo_c

; 331  :     {
; 332  :         /* Load 1st op replacement value */
; 333  :         ARCH_DEP(wfetchc) ( op1r, 16-1, effective_addr4 + 16, b4, regs );

  000f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000fc	48 83 c0 10	 add	 rax, 16
  00100	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00108	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0010f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00117	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0011c	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00124	4c 8b c0	 mov	 r8, rax
  00127	b2 0f		 mov	 dl, 15
  00129	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1r$[rsp]
  0012e	e8 00 00 00 00	 call	 z900_vfetchc

; 334  : 
; 335  :         /* Store at 2nd operand location */
; 336  :         ARCH_DEP(vstorec) ( op1r, 16-1, effective_addr2, b2, regs );

  00133	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00140	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  00148	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  00150	b2 0f		 mov	 dl, 15
  00152	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1r$[rsp]
  00157	e8 00 00 00 00	 call	 z900_vstorec

; 337  : 
; 338  :         return 0;

  0015c	33 c0		 xor	 eax, eax
  0015e	eb 30		 jmp	 SHORT $LN1@z900_plo_c

; 339  :     }

  00160	eb 2e		 jmp	 SHORT $LN11@z900_plo_c
$LN10@z900_plo_c:

; 340  :     else
; 341  :     {
; 342  :         /* Replace 1st op comp value by 2nd op */
; 343  :         ARCH_DEP(vstorec) ( op2, 16-1, effective_addr4 + 0, b4, regs );

  00162	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016f	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00177	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  0017f	b2 0f		 mov	 dl, 15
  00181	48 8d 4c 24 30	 lea	 rcx, QWORD PTR op2$[rsp]
  00186	e8 00 00 00 00	 call	 z900_vstorec

; 344  : 
; 345  :         return 1;

  0018b	b8 01 00 00 00	 mov	 eax, 1
$LN11@z900_plo_c:
$LN1@z900_plo_c:

; 346  :     }
; 347  : }

  00190	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00195	48 33 cc	 xor	 rcx, rsp
  00198	e8 00 00 00 00	 call	 __security_check_cookie
  0019d	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001a1	c3		 ret	 0
z900_plo_csx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
r1$ = 64
r3$ = 72
effective_addr2$ = 80
b2$ = 88
effective_addr4$ = 96
b4$ = 104
regs$ = 112
z900_plo_csgr PROC

; 277  : {

$LN16:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_plo_c:

; 278  : U64 op2;
; 279  : 
; 280  :     UNREFERENCED(r3);

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@z900_plo_c
$LN7@z900_plo_c:

; 281  :     UNREFERENCED(effective_addr4);

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@z900_plo_c
$LN10@z900_plo_c:

; 282  :     UNREFERENCED(b4);

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 fa		 jne	 SHORT $LN10@z900_plo_c

; 283  : 
; 284  :     ODD_CHECK(r1, regs);

  00028	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	85 c0		 test	 eax, eax
  00031	74 15		 je	 SHORT $LN11@z900_plo_c
  00033	ba 06 00 00 00	 mov	 edx, 6
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00042	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_plo_c:

; 285  :     DW_CHECK(effective_addr2, regs);

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0004d	48 83 e0 07	 and	 rax, 7
  00051	48 85 c0	 test	 rax, rax
  00054	74 15		 je	 SHORT $LN12@z900_plo_c
  00056	ba 06 00 00 00	 mov	 edx, 6
  0005b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00065	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_plo_c:

; 286  : 
; 287  :     /* Load second operand from operand address  */
; 288  :     op2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  0006b	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00070	8b 54 24 58	 mov	 edx, DWORD PTR b2$[rsp]
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00079	e8 00 00 00 00	 call	 z900_vfetch8
  0007e	48 89 44 24 20	 mov	 QWORD PTR op2$[rsp], rax

; 289  : 
; 290  :     /* Compare operand with R1 register contents */
; 291  :     if ( regs->GR_G(r1) == op2 )

  00083	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00088	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	48 8b 54 24 20	 mov	 rdx, QWORD PTR op2$[rsp]
  00092	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  0009a	75 2f		 jne	 SHORT $LN13@z900_plo_c

; 292  :     {
; 293  :         /* If equal, store R1+1 at operand loc and set cc=0 */
; 294  :         ARCH_DEP(vstore8) ( regs->GR_G(r1+1), effective_addr2, b2, regs );

  0009c	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a9	44 8b 44 24 58	 mov	 r8d, DWORD PTR b2$[rsp]
  000ae	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  000b3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  000c0	e8 00 00 00 00	 call	 z900_vstore8

; 295  : 
; 296  :         return 0;

  000c5	33 c0		 xor	 eax, eax
  000c7	eb 1e		 jmp	 SHORT $LN1@z900_plo_c

; 297  :     }

  000c9	eb 1c		 jmp	 SHORT $LN14@z900_plo_c
$LN13@z900_plo_c:

; 298  :     else
; 299  :     {
; 300  :         /* If unequal, load R1 from operand and set cc=1 */
; 301  :         regs->GR_G(r1) = op2;

  000cb	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000d5	48 8b 54 24 20	 mov	 rdx, QWORD PTR op2$[rsp]
  000da	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 302  : 
; 303  :         return 1;

  000e2	b8 01 00 00 00	 mov	 eax, 1
$LN14@z900_plo_c:
$LN1@z900_plo_c:

; 304  :     }
; 305  : 
; 306  : }

  000e7	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000eb	c3		 ret	 0
z900_plo_csgr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
op1c$ = 40
op1r$ = 48
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
z900_plo_csg PROC

; 237  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900_plo_c:

; 238  : U64 op1c,
; 239  :     op1r,
; 240  :     op2;
; 241  : 
; 242  :     UNREFERENCED(r1);

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@z900_plo_c
$LN7@z900_plo_c:

; 243  :     UNREFERENCED(r3);

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@z900_plo_c

; 244  : 
; 245  :     DW_CHECK(effective_addr4, regs);

  00022	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00027	48 83 e0 07	 and	 rax, 7
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 1b		 je	 SHORT $LN8@z900_plo_c
  00030	ba 06 00 00 00	 mov	 edx, 6
  00035	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00045	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_c:

; 246  :     DW_CHECK(effective_addr2, regs);

  0004b	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00050	48 83 e0 07	 and	 rax, 7
  00054	48 85 c0	 test	 rax, rax
  00057	74 1b		 je	 SHORT $LN9@z900_plo_c
  00059	ba 06 00 00 00	 mov	 edx, 6
  0005e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00066	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_c:

; 247  : 
; 248  :     /* Load first op compare value */
; 249  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  00074	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00079	48 83 c0 08	 add	 rax, 8
  0007d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0008c	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00094	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 z900_vfetch8
  000a0	48 89 44 24 28	 mov	 QWORD PTR op1c$[rsp], rax

; 250  : 
; 251  :     /* Load 2nd operand */
; 252  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000a5	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ad	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  000b1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  000b6	e8 00 00 00 00	 call	 z900_vfetch8
  000bb	48 89 44 24 20	 mov	 QWORD PTR op2$[rsp], rax

; 253  : 
; 254  :     if(op1c == op2)

  000c0	48 8b 44 24 20	 mov	 rax, QWORD PTR op2$[rsp]
  000c5	48 39 44 24 28	 cmp	 QWORD PTR op1c$[rsp], rax
  000ca	75 53		 jne	 SHORT $LN10@z900_plo_c

; 255  :     {
; 256  :         /* Load 1st op replacement value */
; 257  :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  000d1	48 83 c0 18	 add	 rax, 24
  000d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000dd	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000e4	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ec	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  000f0	48 8b c8	 mov	 rcx, rax
  000f3	e8 00 00 00 00	 call	 z900_vfetch8
  000f8	48 89 44 24 30	 mov	 QWORD PTR op1r$[rsp], rax

; 258  : 
; 259  :         /* Store at 2nd operand location */
; 260  :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  000fd	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00105	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  0010a	48 8b 54 24 60	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  0010f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1r$[rsp]
  00114	e8 00 00 00 00	 call	 z900_vstore8

; 261  : 
; 262  :         return 0;

  00119	33 c0		 xor	 eax, eax
  0011b	eb 39		 jmp	 SHORT $LN1@z900_plo_c

; 263  :     }

  0011d	eb 37		 jmp	 SHORT $LN11@z900_plo_c
$LN10@z900_plo_c:

; 264  :     else
; 265  :     {
; 266  :         /* Replace 1st op comp value by 2nd op */
; 267  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  0011f	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00124	48 83 c0 08	 add	 rax, 8
  00128	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00137	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0013f	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  00144	48 8b d0	 mov	 rdx, rax
  00147	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op2$[rsp]
  0014c	e8 00 00 00 00	 call	 z900_vstore8

; 268  : 
; 269  :         return 1;

  00151	b8 01 00 00 00	 mov	 eax, 1
$LN11@z900_plo_c:
$LN1@z900_plo_c:

; 270  :     }
; 271  : }

  00156	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015a	c3		 ret	 0
z900_plo_csg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
r1$ = 64
r3$ = 72
effective_addr2$ = 80
b2$ = 88
effective_addr4$ = 96
b4$ = 104
regs$ = 112
z900_plo_cs PROC

; 203  : {

$LN16:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@z900_plo_c:

; 204  : U32 op2;
; 205  : 
; 206  :     UNREFERENCED(r3);

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@z900_plo_c
$LN7@z900_plo_c:

; 207  :     UNREFERENCED(effective_addr4);

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@z900_plo_c
$LN10@z900_plo_c:

; 208  :     UNREFERENCED(b4);

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 fa		 jne	 SHORT $LN10@z900_plo_c

; 209  : 
; 210  :     ODD_CHECK(r1, regs);

  00028	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	85 c0		 test	 eax, eax
  00031	74 15		 je	 SHORT $LN11@z900_plo_c
  00033	ba 06 00 00 00	 mov	 edx, 6
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00042	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@z900_plo_c:

; 211  :     FW_CHECK(effective_addr2, regs);

  00048	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0004d	48 83 e0 03	 and	 rax, 3
  00051	48 85 c0	 test	 rax, rax
  00054	74 15		 je	 SHORT $LN12@z900_plo_c
  00056	ba 06 00 00 00	 mov	 edx, 6
  0005b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00065	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@z900_plo_c:

; 212  : 
; 213  :     /* Load second operand from operand address  */
; 214  :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  0006b	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00070	8b 54 24 58	 mov	 edx, DWORD PTR b2$[rsp]
  00074	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  00079	e8 00 00 00 00	 call	 z900_vfetch4
  0007e	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 215  : 
; 216  :     /* Compare operand with R1 register contents */
; 217  :     if ( regs->GR_L(r1) == op2 )

  00082	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00087	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008c	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  00090	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00097	75 2e		 jne	 SHORT $LN13@z900_plo_c

; 218  :     {
; 219  :         /* If equal, store R1+1 at operand loc and set cc=0 */
; 220  :         ARCH_DEP(vstore4) ( regs->GR_L(r1+1), effective_addr2, b2, regs );

  00099	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a6	44 8b 44 24 58	 mov	 r8d, DWORD PTR b2$[rsp]
  000ab	48 8b 54 24 50	 mov	 rdx, QWORD PTR effective_addr2$[rsp]
  000b0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000b5	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  000bc	e8 00 00 00 00	 call	 z900_vstore4

; 221  : 
; 222  :         return 0;

  000c1	33 c0		 xor	 eax, eax
  000c3	eb 1c		 jmp	 SHORT $LN1@z900_plo_c

; 223  :     }

  000c5	eb 1a		 jmp	 SHORT $LN14@z900_plo_c
$LN13@z900_plo_c:

; 224  :     else
; 225  :     {
; 226  :         /* If unequal, load R1 from operand and set cc=1 */
; 227  :         regs->GR_L(r1) = op2;

  000c7	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000d1	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  000d5	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 228  : 
; 229  :         return 1;

  000dc	b8 01 00 00 00	 mov	 eax, 1
$LN14@z900_plo_c:
$LN1@z900_plo_c:

; 230  :     }
; 231  : 
; 232  : }

  000e1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e5	c3		 ret	 0
z900_plo_cs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4alet$ = 48
op4addr$ = 56
op2$ = 64
op1c$ = 80
op4$ = 96
__$ArrayPad$ = 112
r1$ = 144
r3$ = 152
effective_addr2$ = 160
b2$ = 168
effective_addr4$ = 176
b4$ = 184
regs$ = 192
z900_plo_clx PROC

; 146  : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 147  : BYTE op1c[16],
; 148  :      op2[16],
; 149  :      op4[16];
; 150  : U32 op4alet = 0;

  00028	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@z900_plo_c:

; 151  : VADR op4addr;
; 152  : 
; 153  :     UNREFERENCED(r1);

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 154  : 
; 155  :     DW_CHECK(effective_addr4, regs);

  00036	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0003e	48 83 e0 07	 and	 rax, 7
  00042	48 85 c0	 test	 rax, rax
  00045	74 1b		 je	 SHORT $LN8@z900_plo_c
  00047	ba 06 00 00 00	 mov	 edx, 6
  0004c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_c:

; 156  :     QW_CHECK(effective_addr2, regs);

  00062	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0006a	48 83 e0 0f	 and	 rax, 15
  0006e	48 85 c0	 test	 rax, rax
  00071	74 1b		 je	 SHORT $LN9@z900_plo_c
  00073	ba 06 00 00 00	 mov	 edx, 6
  00078	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00080	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00088	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_c:

; 157  : 
; 158  :     /* load second operand */
; 159  :     ARCH_DEP(vfetchc) ( op2, 16-1, effective_addr2, b2, regs );

  0008e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00096	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009b	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR b2$[rsp]
  000a3	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR effective_addr2$[rsp]
  000ab	b2 0f		 mov	 dl, 15
  000ad	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  000b2	e8 00 00 00 00	 call	 z900_vfetchc

; 160  : 
; 161  :     /* load 1st op. compare value */
; 162  :     ARCH_DEP(vfetchc) ( op1c, 16-1, effective_addr4 + 0, b4, regs );

  000b7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c4	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  000cc	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  000d4	b2 0f		 mov	 dl, 15
  000d6	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1c$[rsp]
  000db	e8 00 00 00 00	 call	 z900_vfetchc

; 163  : 
; 164  :     if(memcmp(op1c,op2,16) == 0)

  000e0	41 b8 10 00 00
	00		 mov	 r8d, 16
  000e6	48 8d 54 24 40	 lea	 rdx, QWORD PTR op2$[rsp]
  000eb	48 8d 4c 24 50	 lea	 rcx, QWORD PTR op1c$[rsp]
  000f0	e8 00 00 00 00	 call	 memcmp
  000f5	85 c0		 test	 eax, eax
  000f7	0f 85 45 02 00
	00		 jne	 $LN10@z900_plo_c

; 165  :     {
; 166  :         /* When in ar mode, ar3 is used to access the
; 167  :            operand. The alet is fetched from the pl */
; 168  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  000fd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00105	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00109	83 e0 04	 and	 eax, 4
  0010c	85 c0		 test	 eax, eax
  0010e	0f 84 44 01 00
	00		 je	 $LN12@z900_plo_c
  00114	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00120	83 f8 40	 cmp	 eax, 64			; 00000040H
  00123	0f 85 2f 01 00
	00		 jne	 $LN12@z900_plo_c

; 169  :         {
; 170  :             if(r3 == 0)

  00129	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00131	75 12		 jne	 SHORT $LN13@z900_plo_c

; 171  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00133	ba 06 00 00 00	 mov	 edx, 6
  00138	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_plo_c:

; 172  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  00145	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0014d	48 83 c0 44	 add	 rax, 68			; 00000044H
  00151	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00160	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00168	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0016f	48 8b c8	 mov	 rcx, rax
  00172	e8 00 00 00 00	 call	 z900_vfetch4
  00177	89 44 24 30	 mov	 DWORD PTR op4alet$[rsp], eax

; 173  :             regs->AR(r3) = op4alet;

  0017b	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00183	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	8b 54 24 30	 mov	 edx, DWORD PTR op4alet$[rsp]
  0018f	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 174  :             SET_AEA_AR(regs, r3);

  00196	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019e	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001a2	83 f8 40	 cmp	 eax, 64			; 00000040H
  001a5	0f 85 a3 00 00
	00		 jne	 $LN14@z900_plo_c
  001ab	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001b3	0f 8e 95 00 00
	00		 jle	 $LN14@z900_plo_c
  001b9	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  001c1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c9	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  001d1	75 21		 jne	 SHORT $LN15@z900_plo_c
  001d3	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  001da	83 c0 05	 add	 eax, 5
  001dd	48 98		 cdqe
  001df	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e7	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  001f2	eb 5a		 jmp	 SHORT $LN16@z900_plo_c
$LN15@z900_plo_c:
  001f4	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  001fc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00204	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0020c	75 21		 jne	 SHORT $LN17@z900_plo_c
  0020e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00215	83 c0 05	 add	 eax, 5
  00218	48 98		 cdqe
  0021a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00222	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0022d	eb 1f		 jmp	 SHORT $LN18@z900_plo_c
$LN17@z900_plo_c:
  0022f	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00236	83 c0 05	 add	 eax, 5
  00239	48 98		 cdqe
  0023b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00243	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@z900_plo_c:
$LN16@z900_plo_c:
$LN14@z900_plo_c:
  0024e	33 c0		 xor	 eax, eax
  00250	85 c0		 test	 eax, eax
  00252	0f 85 3e ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN12@z900_plo_c:

; 175  :         }
; 176  : 
; 177  :         /* Load address of operand 4 */
; 178  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  00258	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00260	48 83 c0 48	 add	 rax, 72			; 00000048H
  00264	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00273	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0027b	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00282	48 8b c8	 mov	 rcx, rax
  00285	e8 00 00 00 00	 call	 z900_vfetch8
  0028a	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 179  :         op4addr &= ADDRESS_MAXWRAP(regs);

  0028f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00297	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0029e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op4addr$[rsp]
  002a3	48 23 c8	 and	 rcx, rax
  002a6	48 8b c1	 mov	 rax, rcx
  002a9	48 89 44 24 38	 mov	 QWORD PTR op4addr$[rsp], rax

; 180  :         QW_CHECK(op4addr, regs);

  002ae	48 8b 44 24 38	 mov	 rax, QWORD PTR op4addr$[rsp]
  002b3	48 83 e0 0f	 and	 rax, 15
  002b7	48 85 c0	 test	 rax, rax
  002ba	74 1b		 je	 SHORT $LN19@z900_plo_c
  002bc	ba 06 00 00 00	 mov	 edx, 6
  002c1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d1	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_c:

; 181  : 
; 182  :         /* Load operand 4, using ar3 when in ar mode */
; 183  :         ARCH_DEP(vfetchc) ( op4, 16-1, op4addr, r3, regs );

  002d7	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002df	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e4	44 8b 8c 24 98
	00 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  002ec	4c 8b 44 24 38	 mov	 r8, QWORD PTR op4addr$[rsp]
  002f1	b2 0f		 mov	 dl, 15
  002f3	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op4$[rsp]
  002f8	e8 00 00 00 00	 call	 z900_vfetchc

; 184  : 
; 185  :         /* replace the 3rd operand with the 4th operand */
; 186  :         ARCH_DEP(wstorec) ( op4, 16-1, effective_addr4 + 32, b4, regs );

  002fd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00305	48 83 c0 20	 add	 rax, 32			; 00000020H
  00309	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00318	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00325	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  0032d	4c 8b c0	 mov	 r8, rax
  00330	b2 0f		 mov	 dl, 15
  00332	48 8d 4c 24 60	 lea	 rcx, QWORD PTR op4$[rsp]
  00337	e8 00 00 00 00	 call	 z900_vstorec

; 187  : 
; 188  :         return 0;

  0033c	33 c0		 xor	 eax, eax
  0033e	eb 30		 jmp	 SHORT $LN1@z900_plo_c

; 189  :     }

  00340	eb 2e		 jmp	 SHORT $LN11@z900_plo_c
$LN10@z900_plo_c:

; 190  :     else
; 191  :     {
; 192  :         /* replace the first op compare value with 2nd op */
; 193  :         ARCH_DEP(vstorec) ( op2, 16-1, effective_addr4 + 0, b4, regs );

  00342	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034f	44 8b 8c 24 b8
	00 00 00	 mov	 r9d, DWORD PTR b4$[rsp]
  00357	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR effective_addr4$[rsp]
  0035f	b2 0f		 mov	 dl, 15
  00361	48 8d 4c 24 40	 lea	 rcx, QWORD PTR op2$[rsp]
  00366	e8 00 00 00 00	 call	 z900_vstorec

; 194  : 
; 195  :         return 1;

  0036b	b8 01 00 00 00	 mov	 eax, 1
$LN11@z900_plo_c:
$LN1@z900_plo_c:

; 196  :     }
; 197  : }

  00370	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00375	48 33 cc	 xor	 rcx, rsp
  00378	e8 00 00 00 00	 call	 __security_check_cookie
  0037d	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00384	c3		 ret	 0
z900_plo_clx ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
op4$ = 40
r1$ = 64
r3$ = 72
effective_addr2$ = 80
b2$ = 88
effective_addr4$ = 96
b4$ = 104
regs$ = 112
z900_plo_clgr PROC

; 114  : {

$LN7:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 115  : U64 op2,
; 116  :     op4;
; 117  : 
; 118  :     DW_CHECK(effective_addr2, regs);

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0001b	48 83 e0 07	 and	 rax, 7
  0001f	48 85 c0	 test	 rax, rax
  00022	74 15		 je	 SHORT $LN2@z900_plo_c
  00024	ba 06 00 00 00	 mov	 edx, 6
  00029	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00033	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_plo_c:

; 119  :     DW_CHECK(effective_addr4, regs);

  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0003e	48 83 e0 07	 and	 rax, 7
  00042	48 85 c0	 test	 rax, rax
  00045	74 15		 je	 SHORT $LN3@z900_plo_c
  00047	ba 06 00 00 00	 mov	 edx, 6
  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00056	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN3@z900_plo_c:

; 120  : 
; 121  :     /* Load second operand from operand address  */
; 122  :     op2 = ARCH_DEP(vfetch8) ( effective_addr2, b2, regs );

  0005c	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00061	8b 54 24 58	 mov	 edx, DWORD PTR b2$[rsp]
  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006a	e8 00 00 00 00	 call	 z900_vfetch8
  0006f	48 89 44 24 20	 mov	 QWORD PTR op2$[rsp], rax

; 123  : 
; 124  :     if(regs->GR_G(r1) == op2)

  00074	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00079	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0007e	48 8b 54 24 20	 mov	 rdx, QWORD PTR op2$[rsp]
  00083	48 39 94 c1 80
	02 00 00	 cmp	 QWORD PTR [rcx+rax*8+640], rdx
  0008b	75 35		 jne	 SHORT $LN4@z900_plo_c

; 125  :     {
; 126  : 
; 127  :         op4 = ARCH_DEP(vfetch8) ( effective_addr4, b4, regs );

  0008d	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00092	8b 54 24 68	 mov	 edx, DWORD PTR b4$[rsp]
  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  0009b	e8 00 00 00 00	 call	 z900_vfetch8
  000a0	48 89 44 24 28	 mov	 QWORD PTR op4$[rsp], rax

; 128  :         regs->GR_G(r3) = op4;

  000a5	48 63 44 24 48	 movsxd	 rax, DWORD PTR r3$[rsp]
  000aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000af	48 8b 54 24 28	 mov	 rdx, QWORD PTR op4$[rsp]
  000b4	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 129  : 
; 130  :         return 0;

  000bc	33 c0		 xor	 eax, eax
  000be	eb 1e		 jmp	 SHORT $LN1@z900_plo_c

; 131  :     }

  000c0	eb 1c		 jmp	 SHORT $LN5@z900_plo_c
$LN4@z900_plo_c:

; 132  :     else
; 133  :     {
; 134  :         regs->GR_G(r1) = op2;

  000c2	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	48 8b 54 24 20	 mov	 rdx, QWORD PTR op2$[rsp]
  000d1	48 89 94 c1 80
	02 00 00	 mov	 QWORD PTR [rcx+rax*8+640], rdx

; 135  : 
; 136  :         return 1;

  000d9	b8 01 00 00 00	 mov	 eax, 1
$LN5@z900_plo_c:
$LN1@z900_plo_c:

; 137  :     }
; 138  : 
; 139  : }

  000de	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e2	c3		 ret	 0
z900_plo_clgr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4alet$ = 32
op4addr$ = 40
op2$ = 48
op1c$ = 56
op4$ = 64
r1$ = 96
r3$ = 104
effective_addr2$ = 112
b2$ = 120
effective_addr4$ = 128
b4$ = 136
regs$ = 144
z900_plo_clg PROC

; 53   : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 54   : U64 op1c,
; 55   :     op2,
; 56   :     op4;
; 57   : U32 op4alet = 0;

  00016	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@z900_plo_c:

; 58   : VADR op4addr;
; 59   : 
; 60   :     UNREFERENCED(r1);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@z900_plo_c

; 61   : 
; 62   :     DW_CHECK(effective_addr4, regs);

  00024	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0002c	48 83 e0 07	 and	 rax, 7
  00030	48 85 c0	 test	 rax, rax
  00033	74 1b		 je	 SHORT $LN8@z900_plo_c
  00035	ba 06 00 00 00	 mov	 edx, 6
  0003a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@z900_plo_c:

; 63   :     DW_CHECK(effective_addr2, regs);

  00050	48 8b 44 24 70	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  00055	48 83 e0 07	 and	 rax, 7
  00059	48 85 c0	 test	 rax, rax
  0005c	74 1b		 je	 SHORT $LN9@z900_plo_c
  0005e	ba 06 00 00 00	 mov	 edx, 6
  00063	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00073	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@z900_plo_c:

; 64   : 
; 65   :     /* load second operand */
; 66   :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  00079	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00081	8b 54 24 78	 mov	 edx, DWORD PTR b2$[rsp]
  00085	48 8b 4c 24 70	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0008a	e8 00 00 00 00	 call	 z900_vfetch8
  0008f	48 89 44 24 30	 mov	 QWORD PTR op2$[rsp], rax

; 67   : 
; 68   :     /* load 1st op. compare value */
; 69   :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  00094	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0009c	48 83 c0 08	 add	 rax, 8
  000a0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  000af	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000b7	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000be	48 8b c8	 mov	 rcx, rax
  000c1	e8 00 00 00 00	 call	 z900_vfetch8
  000c6	48 89 44 24 38	 mov	 QWORD PTR op1c$[rsp], rax

; 70   : 
; 71   :     if(op1c == op2)

  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR op2$[rsp]
  000d0	48 39 44 24 38	 cmp	 QWORD PTR op1c$[rsp], rax
  000d5	0f 85 1b 02 00
	00		 jne	 $LN10@z900_plo_c

; 72   :     {
; 73   :         /* When in ar mode, ar3 is used to access the
; 74   :            operand. The alet is fetched from the pl */
; 75   :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  000db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000e7	83 e0 04	 and	 eax, 4
  000ea	85 c0		 test	 eax, eax
  000ec	0f 84 2c 01 00
	00		 je	 $LN12@z900_plo_c
  000f2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fa	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  000fe	83 f8 40	 cmp	 eax, 64			; 00000040H
  00101	0f 85 17 01 00
	00		 jne	 $LN12@z900_plo_c

; 76   :         {
; 77   :             if(r3 == 0)

  00107	83 7c 24 68 00	 cmp	 DWORD PTR r3$[rsp], 0
  0010c	75 12		 jne	 SHORT $LN13@z900_plo_c

; 78   :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0010e	ba 06 00 00 00	 mov	 edx, 6
  00113	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	e8 00 00 00 00	 call	 z900_program_interrupt
$LN13@z900_plo_c:

; 79   :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  00120	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00128	48 83 c0 44	 add	 rax, 68			; 00000044H
  0012c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0013b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00143	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0014a	48 8b c8	 mov	 rcx, rax
  0014d	e8 00 00 00 00	 call	 z900_vfetch4
  00152	89 44 24 20	 mov	 DWORD PTR op4alet$[rsp], eax

; 80   :             regs->AR(r3) = op4alet;

  00156	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  0015b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00163	8b 54 24 20	 mov	 edx, DWORD PTR op4alet$[rsp]
  00167	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@z900_plo_c:

; 81   :             SET_AEA_AR(regs, r3);

  0016e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00176	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0017a	83 f8 40	 cmp	 eax, 64			; 00000040H
  0017d	0f 85 91 00 00
	00		 jne	 $LN14@z900_plo_c
  00183	83 7c 24 68 00	 cmp	 DWORD PTR r3$[rsp], 0
  00188	0f 8e 86 00 00
	00		 jle	 $LN14@z900_plo_c
  0018e	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00193	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019b	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  001a3	75 1e		 jne	 SHORT $LN15@z900_plo_c
  001a5	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  001a9	83 c0 05	 add	 eax, 5
  001ac	48 98		 cdqe
  001ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b6	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  001c1	eb 51		 jmp	 SHORT $LN16@z900_plo_c
$LN15@z900_plo_c:
  001c3	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  001c8	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  001d8	75 1e		 jne	 SHORT $LN17@z900_plo_c
  001da	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  001de	83 c0 05	 add	 eax, 5
  001e1	48 98		 cdqe
  001e3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  001f6	eb 1c		 jmp	 SHORT $LN18@z900_plo_c
$LN17@z900_plo_c:
  001f8	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  001fc	83 c0 05	 add	 eax, 5
  001ff	48 98		 cdqe
  00201	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00209	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@z900_plo_c:
$LN16@z900_plo_c:
$LN14@z900_plo_c:
  00214	33 c0		 xor	 eax, eax
  00216	85 c0		 test	 eax, eax
  00218	0f 85 50 ff ff
	ff		 jne	 $LN7@z900_plo_c
$LN12@z900_plo_c:

; 82   :         }
; 83   : 
; 84   :         /* Load address of operand 4 */
; 85   : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 86   :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  00226	48 83 c0 48	 add	 rax, 72			; 00000048H
  0022a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00239	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00241	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00248	48 8b c8	 mov	 rcx, rax
  0024b	e8 00 00 00 00	 call	 z900_vfetch8
  00250	48 89 44 24 28	 mov	 QWORD PTR op4addr$[rsp], rax

; 87   : #else
; 88   :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);
; 89   : #endif
; 90   :         op4addr &= ADDRESS_MAXWRAP(regs);

  00255	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00264	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op4addr$[rsp]
  00269	48 23 c8	 and	 rcx, rax
  0026c	48 8b c1	 mov	 rax, rcx
  0026f	48 89 44 24 28	 mov	 QWORD PTR op4addr$[rsp], rax

; 91   :         DW_CHECK(op4addr, regs);

  00274	48 8b 44 24 28	 mov	 rax, QWORD PTR op4addr$[rsp]
  00279	48 83 e0 07	 and	 rax, 7
  0027d	48 85 c0	 test	 rax, rax
  00280	74 1b		 je	 SHORT $LN19@z900_plo_c
  00282	ba 06 00 00 00	 mov	 edx, 6
  00287	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00297	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@z900_plo_c:

; 92   : 
; 93   :         /* Load operand 4, using ar3 when in ar mode */
; 94   :         op4 = ARCH_DEP(vfetch8)(op4addr, r3, regs);

  0029d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002a5	8b 54 24 68	 mov	 edx, DWORD PTR r3$[rsp]
  002a9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op4addr$[rsp]
  002ae	e8 00 00 00 00	 call	 z900_vfetch8
  002b3	48 89 44 24 40	 mov	 QWORD PTR op4$[rsp], rax

; 95   : 
; 96   :         /* replace the 3rd operand with the 4th operand */
; 97   :         ARCH_DEP(wstore8)(op4, effective_addr4 + 40, b4, regs);

  002b8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002c0	48 83 c0 28	 add	 rax, 40			; 00000028H
  002c4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  002d3	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002db	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  002e3	48 8b d0	 mov	 rdx, rax
  002e6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op4$[rsp]
  002eb	e8 00 00 00 00	 call	 z900_vstore8

; 98   : 
; 99   :         return 0;

  002f0	33 c0		 xor	 eax, eax
  002f2	eb 3f		 jmp	 SHORT $LN1@z900_plo_c

; 100  :     }

  002f4	eb 3d		 jmp	 SHORT $LN11@z900_plo_c
$LN10@z900_plo_c:

; 101  :     else
; 102  :     {
; 103  :         /* replace the first op compare value with 2nd op */
; 104  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  002f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  002fe	48 83 c0 08	 add	 rax, 8
  00302	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030a	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00311	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00319	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  00321	48 8b d0	 mov	 rdx, rax
  00324	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op2$[rsp]
  00329	e8 00 00 00 00	 call	 z900_vstore8

; 105  : 
; 106  :         return 1;

  0032e	b8 01 00 00 00	 mov	 eax, 1
$LN11@z900_plo_c:
$LN1@z900_plo_c:

; 107  :     }
; 108  : }

  00333	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00337	c3		 ret	 0
z900_plo_clg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
op4$ = 36
r1$ = 64
r3$ = 72
effective_addr2$ = 80
b2$ = 88
effective_addr4$ = 96
b4$ = 104
regs$ = 112
z900_plo_cl PROC

; 23   : {

$LN7:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 24   : U32 op2,
; 25   :     op4;
; 26   : 
; 27   :     FW_CHECK(effective_addr2, regs);

  00016	48 8b 44 24 50	 mov	 rax, QWORD PTR effective_addr2$[rsp]
  0001b	48 83 e0 03	 and	 rax, 3
  0001f	48 85 c0	 test	 rax, rax
  00022	74 15		 je	 SHORT $LN2@z900_plo_c
  00024	ba 06 00 00 00	 mov	 edx, 6
  00029	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00033	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@z900_plo_c:

; 28   :     FW_CHECK(effective_addr4, regs);

  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR effective_addr4$[rsp]
  0003e	48 83 e0 03	 and	 rax, 3
  00042	48 85 c0	 test	 rax, rax
  00045	74 15		 je	 SHORT $LN3@z900_plo_c
  00047	ba 06 00 00 00	 mov	 edx, 6
  0004c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00056	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN3@z900_plo_c:

; 29   : 
; 30   :     /* Load second operand from operand address  */
; 31   :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  0005c	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00061	8b 54 24 58	 mov	 edx, DWORD PTR b2$[rsp]
  00065	48 8b 4c 24 50	 mov	 rcx, QWORD PTR effective_addr2$[rsp]
  0006a	e8 00 00 00 00	 call	 z900_vfetch4
  0006f	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 32   : 
; 33   :     if(regs->GR_L(r1) == op2)

  00073	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00078	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  00081	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00088	75 32		 jne	 SHORT $LN4@z900_plo_c

; 34   :     {
; 35   : 
; 36   :         op4 = ARCH_DEP(vfetch4) ( effective_addr4, b4, regs );

  0008a	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	8b 54 24 68	 mov	 edx, DWORD PTR b4$[rsp]
  00093	48 8b 4c 24 60	 mov	 rcx, QWORD PTR effective_addr4$[rsp]
  00098	e8 00 00 00 00	 call	 z900_vfetch4
  0009d	89 44 24 24	 mov	 DWORD PTR op4$[rsp], eax

; 37   :         regs->GR_L(r3) = op4;

  000a1	48 63 44 24 48	 movsxd	 rax, DWORD PTR r3$[rsp]
  000a6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ab	8b 54 24 24	 mov	 edx, DWORD PTR op4$[rsp]
  000af	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 38   : 
; 39   :         return 0;

  000b6	33 c0		 xor	 eax, eax
  000b8	eb 1c		 jmp	 SHORT $LN1@z900_plo_c

; 40   :     }

  000ba	eb 1a		 jmp	 SHORT $LN5@z900_plo_c
$LN4@z900_plo_c:

; 41   :     else
; 42   :     {
; 43   :         regs->GR_L(r1) = op2;

  000bc	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000c1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  000ca	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 44   : 
; 45   :         return 1;

  000d1	b8 01 00 00 00	 mov	 eax, 1
$LN5@z900_plo_c:
$LN1@z900_plo_c:

; 46   :     }
; 47   : 
; 48   : }

  000d6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000da	c3		 ret	 0
z900_plo_cl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch8 PROC					; COMDAT

; 711  : {

$LN8:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 712  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 713  :     if(likely(!((VADR_L)addr & 0x07)))
; 714  :     {
; 715  :         /* doubleword aligned fetch */
; 716  :         U64 *mn;
; 717  :         ITIMER_SYNC( addr, 8-1, regs );
; 718  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 719  :         if (regs->cpubit == regs->sysblk->started_mask)
; 720  :             return CSWAP64( *mn );
; 721  :         return fetch_dw( mn );
; 722  :     }
; 723  :     else
; 724  : #endif
; 725  :     {
; 726  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0001a	3d f8 0f 00 00	 cmp	 eax, 4088		; 00000ff8H
  0001f	77 0a		 ja	 SHORT $LN6@s390_vfetc
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vfetc
$LN6@s390_vfetc:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN7@s390_vfetc:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  00038	74 46		 je	 SHORT $LN2@s390_vfetc

; 727  :         {
; 728  :             /* unaligned, non-crossing doubleword fetch */
; 729  :             BYTE *mn;
; 730  :             ITIMER_SYNC( addr, 8-1, regs );
; 731  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003a	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  0003f	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00043	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00047	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0004f	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00054	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00059	ba 08 00 00 00	 mov	 edx, 8
  0005e	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 732  :             return fetch_dw( mn );

  0006c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00071	e8 00 00 00 00	 call	 fetch_dw_noswap
  00076	48 8b c8	 mov	 rcx, rax
  00079	e8 00 00 00 00	 call	 _byteswap_uint64
  0007e	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 733  :         }
; 734  :     }
; 735  :     /* page crossing doubleword fetch */
; 736  :     return ARCH_DEP( vfetch8_full )( addr, arn, regs );

  00080	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  00085	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  00089	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0008d	e8 00 00 00 00	 call	 s390_vfetch8_full
$LN1@s390_vfetc:

; 737  : }

  00092	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00096	c3		 ret	 0
s390_vfetch8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
addr$ = 80
arn$ = 88
regs$ = 96
s390_vfetch4 PROC					; COMDAT

; 695  : {

$LN11:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 696  :     if ((likely(!((VADR_L)addr & 0x03))
; 697  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3) )))

  00011	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00015	83 e0 03	 and	 eax, 3
  00018	85 c0		 test	 eax, eax
  0001a	75 0a		 jne	 SHORT $LN5@s390_vfetc
  0001c	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN6@s390_vfetc
$LN5@s390_vfetc:
  00026	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN6@s390_vfetc:
  0002e	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00033	74 0a		 je	 SHORT $LN9@s390_vfetc
  00035	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  0003d	eb 08		 jmp	 SHORT $LN10@s390_vfetc
$LN9@s390_vfetc:
  0003f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN10@s390_vfetc:
  00047	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  0004c	75 10		 jne	 SHORT $LN3@s390_vfetc
  0004e	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00052	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00057	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  0005c	77 45		 ja	 SHORT $LN2@s390_vfetc
$LN3@s390_vfetc:

; 698  :     {
; 699  :         BYTE *mn;
; 700  :         ITIMER_SYNC( addr, 4-1, regs );
; 701  :         mn = MADDRL( addr, 4,arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0005e	48 8b 44 24 60	 mov	 rax, QWORD PTR regs$[rsp]
  00063	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00067	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 4c 24 60	 mov	 r9, QWORD PTR regs$[rsp]
  00078	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  0007d	ba 04 00 00 00	 mov	 edx, 4
  00082	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  00086	e8 00 00 00 00	 call	 s390_maddr_l
  0008b	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 702  :         return fetch_fw( mn );

  00090	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00095	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009a	8b c8		 mov	 ecx, eax
  0009c	e8 00 00 00 00	 call	 _byteswap_ulong
  000a1	eb 12		 jmp	 SHORT $LN1@s390_vfetc
$LN2@s390_vfetc:

; 703  :     }
; 704  :     return ARCH_DEP( vfetch4_full )( addr, arn, regs );

  000a3	4c 8b 44 24 60	 mov	 r8, QWORD PTR regs$[rsp]
  000a8	8b 54 24 58	 mov	 edx, DWORD PTR arn$[rsp]
  000ac	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000b0	e8 00 00 00 00	 call	 s390_vfetch4_full
$LN1@s390_vfetc:

; 705  : }

  000b5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b9	c3		 ret	 0
s390_vfetch4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore8
_TEXT	SEGMENT
tv70 = 48
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore8 PROC					; COMDAT

; 577  : {

$LN9:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 578  : #if defined( OPTION_SINGLE_CPU_DW ) && defined( ASSIST_STORE_DW )
; 579  :     /* Check alignement. If aligned then we are guaranteed
; 580  :        not to cross a page boundary */
; 581  :     if (likely(!((VADR_L)addr & 0x07)))
; 582  :     {
; 583  :         /* Most common case : Aligned */
; 584  :         U64 *mn;
; 585  :         mn = (U64*)MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );
; 586  :         if (regs->cpubit == regs->sysblk->started_mask)
; 587  :             *mn = CSWAP64( value );
; 588  :         else
; 589  :             STORE_DW( mn, value );
; 590  :     }
; 591  :     else
; 592  : #endif
; 593  :     {
; 594  :         /* We're not aligned. So we have to check whether we are
; 595  :            crossing a page boundary. This cannot be the same
; 596  :            code as above because casting U64* to a non aligned
; 597  :            pointer may break on those architectures mandating
; 598  :            strict alignement */
; 599  :         if (likely(((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-7)))

  00017	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001b	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00020	3d f8 0f 00 00	 cmp	 eax, 4088		; 00000ff8H
  00025	77 0a		 ja	 SHORT $LN7@s390_vstor
  00027	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0002f	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00031	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN8@s390_vstor:
  00039	83 7c 24 30 00	 cmp	 DWORD PTR tv70[rsp], 0
  0003e	74 4b		 je	 SHORT $LN2@s390_vstor

; 600  :         {
; 601  :             /* Non aligned but not crossing page boundary */
; 602  :             BYTE *mn;
; 603  :             mn = MADDRL( addr, 8, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00040	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00045	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00049	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  0004d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00055	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0005a	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  0005f	ba 08 00 00 00	 mov	 edx, 8
  00064	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  00068	e8 00 00 00 00	 call	 s390_maddr_l
  0006d	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 604  :             /* invoking STORE_DW ensures endianness correctness */
; 605  :             STORE_DW( mn, value );

  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  00077	e8 00 00 00 00	 call	 _byteswap_uint64
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  00084	e8 00 00 00 00	 call	 store_dw_noswap

; 606  :         }

  00089	eb 18		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 607  :         else
; 608  :             /* Crossing page boundary */
; 609  :             ARCH_DEP( vstore8_full )( value, addr, arn, regs );

  0008b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  00090	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00095	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  00099	48 8b 4c 24 50	 mov	 rcx, QWORD PTR value$[rsp]
  0009e	e8 00 00 00 00	 call	 s390_vstore8_full
$LN3@s390_vstor:

; 610  :     }
; 611  :     ITIMER_UPDATE( addr, 8-1, regs );
; 612  : }

  000a3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a7	c3		 ret	 0
s390_vstore8 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4
_TEXT	SEGMENT
tv66 = 48
tv72 = 52
mn$1 = 56
value$ = 80
addr$ = 88
arn$ = 96
regs$ = 104
s390_vstore4 PROC					; COMDAT

; 559  : {

$LN12:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 560  :     /* Most common case : Aligned & not crossing page boundary */
; 561  :     if (likely(!((VADR_L)addr & 0x03))
; 562  :         || (((VADR_L)addr & PAGEFRAME_BYTEMASK) <= (PAGEFRAME_BYTEMASK-3)))

  00016	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	75 0a		 jne	 SHORT $LN6@s390_vstor
  00021	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@s390_vstor
$LN6@s390_vstor:
  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN7@s390_vstor:
  00033	83 7c 24 30 00	 cmp	 DWORD PTR tv66[rsp], 0
  00038	74 0a		 je	 SHORT $LN10@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN11@s390_vstor
$LN10@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN11@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv72[rsp], 0
  00051	75 10		 jne	 SHORT $LN4@s390_vstor
  00053	8b 44 24 58	 mov	 eax, DWORD PTR addr$[rsp]
  00057	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0005c	3d fc 0f 00 00	 cmp	 eax, 4092		; 00000ffcH
  00061	77 49		 ja	 SHORT $LN2@s390_vstor
$LN4@s390_vstor:

; 563  :     {
; 564  :         BYTE *mn;
; 565  :         mn = MADDRL( addr, 4, arn, regs, ACCTYPE_WRITE, regs->psw.pkey );

  00063	48 8b 44 24 68	 mov	 rax, QWORD PTR regs$[rsp]
  00068	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0006c	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00070	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00078	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  0007d	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  00082	ba 04 00 00 00	 mov	 edx, 4
  00087	8b 4c 24 58	 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR mn$1[rsp], rax

; 566  :         STORE_FW( mn, value );

  00095	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  00099	e8 00 00 00 00	 call	 _byteswap_ulong
  0009e	8b d0		 mov	 edx, eax
  000a0	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$1[rsp]
  000a5	e8 00 00 00 00	 call	 store_fw_noswap

; 567  :         ITIMER_UPDATE( addr, 4-1, regs );
; 568  :     }

  000aa	eb 17		 jmp	 SHORT $LN3@s390_vstor
$LN2@s390_vstor:

; 569  :     else
; 570  :         ARCH_DEP( vstore4_full )( value, addr, arn, regs );

  000ac	4c 8b 4c 24 68	 mov	 r9, QWORD PTR regs$[rsp]
  000b1	44 8b 44 24 60	 mov	 r8d, DWORD PTR arn$[rsp]
  000b6	8b 54 24 58	 mov	 edx, DWORD PTR addr$[rsp]
  000ba	8b 4c 24 50	 mov	 ecx, DWORD PTR value$[rsp]
  000be	e8 00 00 00 00	 call	 s390_vstore4_full
$LN3@s390_vstor:

; 571  : }

  000c3	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c7	c3		 ret	 0
s390_vstore4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch8_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 80
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetch8_full PROC					; COMDAT

; 457  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 458  : BYTE   *mn;                             /* Main storage addresses    */
; 459  : int     len;                            /* Length to end of page     */
; 460  : BYTE    temp[16];                       /* Copy destination          */
; 461  : 
; 462  :     /* Get absolute address of first byte of operand */
; 463  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00029	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002e	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00033	2b c8		 sub	 ecx, eax
  00035	8b c1		 mov	 eax, ecx
  00037	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 464  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  0003b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00040	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00048	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0004c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00050	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00058	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00060	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00068	48 8b d0	 mov	 rdx, rax
  0006b	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00072	e8 00 00 00 00	 call	 s390_maddr_l
  00077	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 465  :     memcpy( temp, mn, len);

  0007c	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00081	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00086	48 8b f9	 mov	 rdi, rcx
  00089	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	f3 a4		 rep movsb

; 466  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8 - len, arn, regs,

  00093	b8 08 00 00 00	 mov	 eax, 8
  00098	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009c	48 98		 cdqe
  0009e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a2	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000a9	03 d1		 add	 edx, ecx
  000ab	8b ca		 mov	 ecx, edx
  000ad	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b5	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000bb	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c3	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000c7	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000cb	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000d3	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000db	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e3	48 8b d0	 mov	 rdx, rax
  000e6	e8 00 00 00 00	 call	 s390_maddr_l
  000eb	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 467  :                  ACCTYPE_READ, regs->psw.pkey );
; 468  :     memcpy( temp+len, mn, 8 );

  000f0	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  000f5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR mn$[rsp]
  000fa	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000fd	48 89 4c 04 40	 mov	 QWORD PTR temp$[rsp+rax], rcx

; 469  :     return fetch_dw( temp );

  00102	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00107	e8 00 00 00 00	 call	 fetch_dw_noswap
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 _byteswap_uint64

; 470  : }

  00114	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetch4_full
_TEXT	SEGMENT
len$ = 48
mn$ = 56
temp$ = 64
__$ArrayPad$ = 72
addr$ = 112
arn$ = 120
regs$ = 128
s390_vfetch4_full PROC					; COMDAT

; 428  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 429  : BYTE   *mn;                             /* Main storage addresses    */
; 430  : int     len;                            /* Length to end of page     */
; 431  : BYTE    temp[8];                        /* Copy destination          */
; 432  : 
; 433  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR addr$[rsp]
  00026	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0002b	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00030	2b c8		 sub	 ecx, eax
  00032	8b c1		 mov	 eax, ecx
  00034	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 434  :     mn = MADDRL( addr, len, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00038	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  0003d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00045	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00049	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0004d	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0005d	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  00062	48 8b d0	 mov	 rdx, rax
  00065	8b 4c 24 70	 mov	 ecx, DWORD PTR addr$[rsp]
  00069	e8 00 00 00 00	 call	 s390_maddr_l
  0006e	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 435  :     memcpy( temp, mn, len);

  00073	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00078	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  0007d	48 8b f9	 mov	 rdi, rcx
  00080	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  00085	48 8b c8	 mov	 rcx, rax
  00088	f3 a4		 rep movsb

; 436  :     mn = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4 - len, arn, regs,

  0008a	b8 04 00 00 00	 mov	 eax, 4
  0008f	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00093	48 98		 cdqe
  00095	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00099	8b 54 24 70	 mov	 edx, DWORD PTR addr$[rsp]
  0009d	03 d1		 add	 edx, ecx
  0009f	8b ca		 mov	 ecx, edx
  000a1	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000a9	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000af	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b7	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000bb	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000bf	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000c7	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000cf	44 8b 44 24 78	 mov	 r8d, DWORD PTR arn$[rsp]
  000d4	48 8b d0	 mov	 rdx, rax
  000d7	e8 00 00 00 00	 call	 s390_maddr_l
  000dc	48 89 44 24 38	 mov	 QWORD PTR mn$[rsp], rax

; 437  :                   ACCTYPE_READ, regs->psw.pkey );
; 438  :     memcpy( temp+len, mn, 4 - len);

  000e1	b8 04 00 00 00	 mov	 eax, 4
  000e6	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  000ea	48 98		 cdqe
  000ec	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  000f1	48 8d 4c 0c 40	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  000f6	48 8b f9	 mov	 rdi, rcx
  000f9	48 8b 74 24 38	 mov	 rsi, QWORD PTR mn$[rsp]
  000fe	48 8b c8	 mov	 rcx, rax
  00101	f3 a4		 rep movsb

; 439  :     return fetch_fw( temp );

  00103	48 8d 4c 24 40	 lea	 rcx, QWORD PTR temp$[rsp]
  00108	e8 00 00 00 00	 call	 fetch_fw_noswap
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 _byteswap_ulong

; 440  : }

  00114	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00119	48 33 cc	 xor	 rcx, rsp
  0011c	e8 00 00 00 00	 call	 __security_check_cookie
  00121	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00125	5f		 pop	 rdi
  00126	5e		 pop	 rsi
  00127	c3		 ret	 0
s390_vfetch4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore8_full
_TEXT	SEGMENT
len$ = 48
sk$ = 56
main1$ = 64
main2$ = 72
temp$ = 80
__$ArrayPad$ = 88
value$ = 128
addr$ = 136
arn$ = 144
regs$ = 152
s390_vstore8_full PROC					; COMDAT

; 369  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 370  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 371  : BYTE   *sk;                             /* Storage key addresses     */
; 372  : int     len;                            /* Length to end of page     */
; 373  : BYTE    temp[8];                        /* Copied value              */
; 374  : 
; 375  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00028	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  0002f	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00034	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00039	2b c8		 sub	 ecx, eax
  0003b	8b c1		 mov	 eax, ecx
  0003d	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 376  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  00041	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00046	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00052	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00056	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0005e	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00066	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0006e	48 8b d0	 mov	 rdx, rax
  00071	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00078	e8 00 00 00 00	 call	 s390_maddr_l
  0007d	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 377  :     sk = regs->dat.storkey;

  00082	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00091	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 378  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 8-len, arn, regs,

  00096	b8 08 00 00 00	 mov	 eax, 8
  0009b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0009f	48 98		 cdqe
  000a1	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a5	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  000ac	03 d1		 add	 edx, ecx
  000ae	8b ca		 mov	 ecx, edx
  000b0	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000b8	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000be	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c6	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000ca	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000ce	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000d6	4c 8b 8c 24 98
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000de	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000e6	48 8b d0	 mov	 rdx, rax
  000e9	e8 00 00 00 00	 call	 s390_maddr_l
  000ee	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 379  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 380  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000f3	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000f8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000fb	83 c8 06	 or	 eax, 6
  000fe	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  00103	88 01		 mov	 BYTE PTR [rcx], al

; 381  :     STORE_DW( temp, value );

  00105	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR value$[rsp]
  0010d	e8 00 00 00 00	 call	 _byteswap_uint64
  00112	48 8b d0	 mov	 rdx, rax
  00115	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  0011a	e8 00 00 00 00	 call	 store_dw_noswap

; 382  :     memcpy( main1, temp,       len );

  0011f	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00124	48 8d 4c 24 50	 lea	 rcx, QWORD PTR temp$[rsp]
  00129	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  0012e	48 8b f1	 mov	 rsi, rcx
  00131	48 8b c8	 mov	 rcx, rax
  00134	f3 a4		 rep movsb

; 383  :     memcpy( main2, temp+len, 8-len );

  00136	b8 08 00 00 00	 mov	 eax, 8
  0013b	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  0013f	48 98		 cdqe
  00141	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00146	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0014b	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00150	48 8b f1	 mov	 rsi, rcx
  00153	48 8b c8	 mov	 rcx, rax
  00156	f3 a4		 rep movsb

; 384  : }

  00158	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015d	48 33 cc	 xor	 rcx, rsp
  00160	e8 00 00 00 00	 call	 __security_check_cookie
  00165	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00169	5f		 pop	 rdi
  0016a	5e		 pop	 rsi
  0016b	c3		 ret	 0
s390_vstore8_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstore4_full
_TEXT	SEGMENT
len$ = 48
temp$ = 52
sk$ = 56
main1$ = 64
main2$ = 72
value$ = 112
addr$ = 120
arn$ = 128
regs$ = 136
s390_vstore4_full PROC					; COMDAT

; 335  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	56		 push	 rsi
  00013	57		 push	 rdi
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 336  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 337  : BYTE   *sk;                             /* Storage key addresses     */
; 338  : int     len;                            /* Length to end of page     */
; 339  : BYTE    temp[4];                        /* Copied value              */
; 340  : 
; 341  :     len = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  00018	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0001c	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00021	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00026	2b c8		 sub	 ecx, eax
  00028	8b c1		 mov	 eax, ecx
  0002a	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 342  :     main1 = MADDRL( addr, len, arn, regs, ACCTYPE_WRITE_SKP, regs->psw.pkey );

  0002e	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00033	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0003f	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00043	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0004b	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00053	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0005b	48 8b d0	 mov	 rdx, rax
  0005e	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  00062	e8 00 00 00 00	 call	 s390_maddr_l
  00067	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 343  :     sk = regs->dat.storkey;

  0006c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00074	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0007b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 344  :     main2 = MADDRL( (addr + len) & ADDRESS_MAXWRAP( regs ), 4-len, arn, regs,

  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00089	48 98		 cdqe
  0008b	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  0008f	8b 54 24 78	 mov	 edx, DWORD PTR addr$[rsp]
  00093	03 d1		 add	 edx, ecx
  00095	8b ca		 mov	 ecx, edx
  00097	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0009f	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  000a5	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000ad	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  000b1	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  000b5	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  000bd	4c 8b 8c 24 88
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000c5	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000cd	48 8b d0	 mov	 rdx, rax
  000d0	e8 00 00 00 00	 call	 s390_maddr_l
  000d5	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 345  :                     ACCTYPE_WRITE, regs->psw.pkey );
; 346  :     *sk |= (STORKEY_REF | STORKEY_CHANGE);

  000da	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  000df	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000e2	83 c8 06	 or	 eax, 6
  000e5	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  000ea	88 01		 mov	 BYTE PTR [rcx], al

; 347  :     STORE_FW( temp, value );

  000ec	8b 4c 24 70	 mov	 ecx, DWORD PTR value$[rsp]
  000f0	e8 00 00 00 00	 call	 _byteswap_ulong
  000f5	8b d0		 mov	 edx, eax
  000f7	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  000fc	e8 00 00 00 00	 call	 store_fw_noswap

; 348  :     memcpy( main1, temp,       len );

  00101	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00106	48 8d 4c 24 34	 lea	 rcx, QWORD PTR temp$[rsp]
  0010b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR main1$[rsp]
  00110	48 8b f1	 mov	 rsi, rcx
  00113	48 8b c8	 mov	 rcx, rax
  00116	f3 a4		 rep movsb

; 349  :     memcpy( main2, temp+len, 4-len );

  00118	b8 04 00 00 00	 mov	 eax, 4
  0011d	2b 44 24 30	 sub	 eax, DWORD PTR len$[rsp]
  00121	48 98		 cdqe
  00123	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len$[rsp]
  00128	48 8d 4c 0c 34	 lea	 rcx, QWORD PTR temp$[rsp+rcx]
  0012d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main2$[rsp]
  00132	48 8b f1	 mov	 rsi, rcx
  00135	48 8b c8	 mov	 rcx, rax
  00138	f3 a4		 rep movsb

; 350  : }

  0013a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0013e	5f		 pop	 rdi
  0013f	5e		 pop	 rsi
  00140	c3		 ret	 0
s390_vstore4_full ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 35		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	e8 00 00 00 00	 call	 s390_logical_to_main_l
  001cb	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d0	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d5	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001d9	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6addr$ = 48
op8addr$ = 52
op4addr$ = 56
op6alet$ = 60
op8alet$ = 64
op4alet$ = 68
op2$ = 72
op1c$ = 80
op3$ = 88
op5$ = 96
op7$ = 104
op1r$ = 112
r1$ = 144
r3$ = 152
effective_addr2$ = 160
b2$ = 168
effective_addr4$ = 176
b4$ = 184
regs$ = 192
s390_plo_cststg PROC

; 1291 : {

$LN59:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 1292 : U64 op1c,
; 1293 :     op1r,
; 1294 :     op2,
; 1295 :     op3,
; 1296 :     op5,
; 1297 :     op7;
; 1298 : U32 op4alet = 0,

  00019	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1299 :     op6alet = 0,

  00021	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 1300 :     op8alet = 0;

  00029	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR op8alet$[rsp], 0
$LN4@s390_plo_c:

; 1301 : VADR op4addr,
; 1302 :     op6addr,
; 1303 :     op8addr;
; 1304 : 
; 1305 :     UNREFERENCED(r1);

  00031	33 c0		 xor	 eax, eax
  00033	85 c0		 test	 eax, eax
  00035	75 fa		 jne	 SHORT $LN4@s390_plo_c

; 1306 : 
; 1307 :     DW_CHECK(effective_addr2, regs);

  00037	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0003e	83 e0 07	 and	 eax, 7
  00041	85 c0		 test	 eax, eax
  00043	74 1b		 je	 SHORT $LN20@s390_plo_c
  00045	ba 06 00 00 00	 mov	 edx, 6
  0004a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN20@s390_plo_c:

; 1308 :     DW_CHECK(effective_addr4, regs);

  00060	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00067	83 e0 07	 and	 eax, 7
  0006a	85 c0		 test	 eax, eax
  0006c	74 1b		 je	 SHORT $LN21@s390_plo_c
  0006e	ba 06 00 00 00	 mov	 edx, 6
  00073	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00083	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN21@s390_plo_c:

; 1309 : 
; 1310 :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  00089	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00090	83 c0 08	 add	 eax, 8
  00093	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000a1	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a9	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000b0	8b c8		 mov	 ecx, eax
  000b2	e8 00 00 00 00	 call	 s390_vfetch8
  000b7	48 89 44 24 50	 mov	 QWORD PTR op1c$[rsp], rax

; 1311 :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000bc	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000c4	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000cb	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000d2	e8 00 00 00 00	 call	 s390_vfetch8
  000d7	48 89 44 24 48	 mov	 QWORD PTR op2$[rsp], rax

; 1312 : 
; 1313 :     if(op1c == op2)

  000dc	48 8b 44 24 48	 mov	 rax, QWORD PTR op2$[rsp]
  000e1	48 39 44 24 50	 cmp	 QWORD PTR op1c$[rsp], rax
  000e6	0f 85 04 09 00
	00		 jne	 $LN22@s390_plo_c

; 1314 :     {
; 1315 :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000ec	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000f3	83 c0 18	 add	 eax, 24
  000f6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fe	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00104	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0010c	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00113	8b c8		 mov	 ecx, eax
  00115	e8 00 00 00 00	 call	 s390_vfetch8
  0011a	48 89 44 24 70	 mov	 QWORD PTR op1r$[rsp], rax

; 1316 :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  0011f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00126	83 c0 38	 add	 eax, 56			; 00000038H
  00129	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00131	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00137	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0013f	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00146	8b c8		 mov	 ecx, eax
  00148	e8 00 00 00 00	 call	 s390_vfetch8
  0014d	48 89 44 24 58	 mov	 QWORD PTR op3$[rsp], rax

; 1317 :         op5 = ARCH_DEP(wfetch8)(effective_addr4 + 88, b4, regs);

  00152	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00159	83 c0 58	 add	 eax, 88			; 00000058H
  0015c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00164	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0016a	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00172	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00179	8b c8		 mov	 ecx, eax
  0017b	e8 00 00 00 00	 call	 s390_vfetch8
  00180	48 89 44 24 60	 mov	 QWORD PTR op5$[rsp], rax

; 1318 :         op7 = ARCH_DEP(wfetch8)(effective_addr4 + 120, b4, regs);

  00185	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0018c	83 c0 78	 add	 eax, 120		; 00000078H
  0018f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00197	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0019d	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001a5	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001ac	8b c8		 mov	 ecx, eax
  001ae	e8 00 00 00 00	 call	 s390_vfetch8
  001b3	48 89 44 24 68	 mov	 QWORD PTR op7$[rsp], rax

; 1319 : 
; 1320 :         /* Verify access to 2nd operand */
; 1321 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  001b8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c5	41 b9 01 00 00
	00		 mov	 r9d, 1
  001cb	41 b8 07 00 00
	00		 mov	 r8d, 7
  001d1	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  001d8	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001df	e8 00 00 00 00	 call	 s390_validate_operand

; 1322 :             ACCTYPE_WRITE_SKP, regs);
; 1323 : 
; 1324 :         /* When in ar mode, ar3 is used to access the
; 1325 :            operand. The alet is fetched from the pl */
; 1326 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001e4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001f0	83 e0 04	 and	 eax, 4
  001f3	85 c0		 test	 eax, eax
  001f5	0f 84 a6 01 00
	00		 je	 $LN24@s390_plo_c
  001fb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00203	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00207	83 f8 40	 cmp	 eax, 64			; 00000040H
  0020a	0f 85 91 01 00
	00		 jne	 $LN24@s390_plo_c

; 1327 :         {
; 1328 :             if(r3 == 0)

  00210	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00218	75 12		 jne	 SHORT $LN25@s390_plo_c

; 1329 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0021a	ba 06 00 00 00	 mov	 edx, 6
  0021f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00227	e8 00 00 00 00	 call	 s390_program_interrupt
$LN25@s390_plo_c:

; 1330 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  0022c	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00233	83 c0 44	 add	 eax, 68			; 00000044H
  00236	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00244	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0024c	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00253	8b c8		 mov	 ecx, eax
  00255	e8 00 00 00 00	 call	 s390_vfetch4
  0025a	89 44 24 44	 mov	 DWORD PTR op4alet$[rsp], eax

; 1331 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  0025e	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00265	83 c0 64	 add	 eax, 100		; 00000064H
  00268	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00276	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0027e	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00285	8b c8		 mov	 ecx, eax
  00287	e8 00 00 00 00	 call	 s390_vfetch4
  0028c	89 44 24 3c	 mov	 DWORD PTR op6alet$[rsp], eax

; 1332 :             op8alet = ARCH_DEP(wfetch4)(effective_addr4 + 132, b4, regs);

  00290	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00297	05 84 00 00 00	 add	 eax, 132		; 00000084H
  0029c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a4	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  002aa	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002b2	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002b9	8b c8		 mov	 ecx, eax
  002bb	e8 00 00 00 00	 call	 s390_vfetch4
  002c0	89 44 24 40	 mov	 DWORD PTR op8alet$[rsp], eax

; 1333 :             regs->AR(r3) = op8alet;

  002c4	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002cc	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d4	8b 54 24 40	 mov	 edx, DWORD PTR op8alet$[rsp]
  002d8	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@s390_plo_c:

; 1334 :             SET_AEA_AR(regs, r3);

  002df	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  002eb	83 f8 40	 cmp	 eax, 64			; 00000040H
  002ee	0f 85 a3 00 00
	00		 jne	 $LN26@s390_plo_c
  002f4	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  002fc	0f 8e 95 00 00
	00		 jle	 $LN26@s390_plo_c
  00302	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0030a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00312	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0031a	75 21		 jne	 SHORT $LN27@s390_plo_c
  0031c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00323	83 c0 05	 add	 eax, 5
  00326	48 98		 cdqe
  00328	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00330	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0033b	eb 5a		 jmp	 SHORT $LN28@s390_plo_c
$LN27@s390_plo_c:
  0033d	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00345	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034d	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00355	75 21		 jne	 SHORT $LN29@s390_plo_c
  00357	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0035e	83 c0 05	 add	 eax, 5
  00361	48 98		 cdqe
  00363	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036b	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00376	eb 1f		 jmp	 SHORT $LN30@s390_plo_c
$LN29@s390_plo_c:
  00378	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0037f	83 c0 05	 add	 eax, 5
  00382	48 98		 cdqe
  00384	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0038c	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN30@s390_plo_c:
$LN28@s390_plo_c:
$LN26@s390_plo_c:
  00397	33 c0		 xor	 eax, eax
  00399	85 c0		 test	 eax, eax
  0039b	0f 85 3e ff ff
	ff		 jne	 $LN7@s390_plo_c
$LN24@s390_plo_c:

; 1335 :         }
; 1336 : 
; 1337 :         /* Load address of operand 4 */
; 1338 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1339 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);
; 1340 : #else
; 1341 :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);

  003a1	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  003a8	83 c0 4c	 add	 eax, 76			; 0000004cH
  003ab	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b3	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  003b9	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c1	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003c8	8b c8		 mov	 ecx, eax
  003ca	e8 00 00 00 00	 call	 s390_vfetch4
  003cf	89 44 24 38	 mov	 DWORD PTR op4addr$[rsp], eax

; 1342 : #endif
; 1343 :         op4addr &= ADDRESS_MAXWRAP(regs);

  003d3	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003db	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003e1	8b 4c 24 38	 mov	 ecx, DWORD PTR op4addr$[rsp]
  003e5	23 c8		 and	 ecx, eax
  003e7	8b c1		 mov	 eax, ecx
  003e9	89 44 24 38	 mov	 DWORD PTR op4addr$[rsp], eax

; 1344 :         DW_CHECK(op4addr, regs);

  003ed	8b 44 24 38	 mov	 eax, DWORD PTR op4addr$[rsp]
  003f1	83 e0 07	 and	 eax, 7
  003f4	85 c0		 test	 eax, eax
  003f6	74 1b		 je	 SHORT $LN31@s390_plo_c
  003f8	ba 06 00 00 00	 mov	 edx, 6
  003fd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00405	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@s390_plo_c:

; 1345 : 
; 1346 :         /* Load address of operand 6 */
; 1347 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1348 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);
; 1349 : #else
; 1350 :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);

  00413	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0041a	83 c0 6c	 add	 eax, 108		; 0000006cH
  0041d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00425	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0042b	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00433	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0043a	8b c8		 mov	 ecx, eax
  0043c	e8 00 00 00 00	 call	 s390_vfetch4
  00441	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 1351 : #endif
; 1352 :         op6addr &= ADDRESS_MAXWRAP(regs);

  00445	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044d	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00453	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  00457	23 c8		 and	 ecx, eax
  00459	8b c1		 mov	 eax, ecx
  0045b	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 1353 :         DW_CHECK(op6addr, regs);

  0045f	8b 44 24 30	 mov	 eax, DWORD PTR op6addr$[rsp]
  00463	83 e0 07	 and	 eax, 7
  00466	85 c0		 test	 eax, eax
  00468	74 1b		 je	 SHORT $LN32@s390_plo_c
  0046a	ba 06 00 00 00	 mov	 edx, 6
  0046f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00477	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN32@s390_plo_c:

; 1354 : 
; 1355 :         /* Load address of operand 8 */
; 1356 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1357 :         op8addr = ARCH_DEP(wfetch8)(effective_addr4 + 136, b4, regs);
; 1358 : #else
; 1359 :         op8addr = ARCH_DEP(wfetch4)(effective_addr4 + 140, b4, regs);

  00485	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0048c	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  00491	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00499	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0049f	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004a7	8b 94 24 b8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  004ae	8b c8		 mov	 ecx, eax
  004b0	e8 00 00 00 00	 call	 s390_vfetch4
  004b5	89 44 24 34	 mov	 DWORD PTR op8addr$[rsp], eax

; 1360 : #endif
; 1361 :         op8addr &= ADDRESS_MAXWRAP(regs);

  004b9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c1	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  004c7	8b 4c 24 34	 mov	 ecx, DWORD PTR op8addr$[rsp]
  004cb	23 c8		 and	 ecx, eax
  004cd	8b c1		 mov	 eax, ecx
  004cf	89 44 24 34	 mov	 DWORD PTR op8addr$[rsp], eax

; 1362 :         DW_CHECK(op8addr, regs);

  004d3	8b 44 24 34	 mov	 eax, DWORD PTR op8addr$[rsp]
  004d7	83 e0 07	 and	 eax, 7
  004da	85 c0		 test	 eax, eax
  004dc	74 1b		 je	 SHORT $LN33@s390_plo_c
  004de	ba 06 00 00 00	 mov	 edx, 6
  004e3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004eb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004f3	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN33@s390_plo_c:

; 1363 : 
; 1364 :         /* Verify access to 8th operand */
; 1365 :         ARCH_DEP(validate_operand) (op8addr, r3, 8-1,ACCTYPE_WRITE_SKP, regs);

  004f9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00501	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00506	41 b9 01 00 00
	00		 mov	 r9d, 1
  0050c	41 b8 07 00 00
	00		 mov	 r8d, 7
  00512	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00519	8b 4c 24 34	 mov	 ecx, DWORD PTR op8addr$[rsp]
  0051d	e8 00 00 00 00	 call	 s390_validate_operand

; 1366 : 
; 1367 :         /* Verify access to 6th operand */
; 1368 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00522	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052a	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0052e	83 e0 04	 and	 eax, 4
  00531	85 c0		 test	 eax, eax
  00533	0f 84 f2 00 00
	00		 je	 $LN34@s390_plo_c
  00539	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00541	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00545	83 f8 40	 cmp	 eax, 64			; 00000040H
  00548	0f 85 dd 00 00
	00		 jne	 $LN34@s390_plo_c

; 1369 :         {
; 1370 :             regs->AR(r3) = op6alet;

  0054e	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00556	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055e	8b 54 24 3c	 mov	 edx, DWORD PTR op6alet$[rsp]
  00562	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@s390_plo_c:

; 1371 :             SET_AEA_AR(regs, r3);

  00569	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00575	83 f8 40	 cmp	 eax, 64			; 00000040H
  00578	0f 85 a3 00 00
	00		 jne	 $LN35@s390_plo_c
  0057e	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00586	0f 8e 95 00 00
	00		 jle	 $LN35@s390_plo_c
  0058c	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00594	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059c	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  005a4	75 21		 jne	 SHORT $LN36@s390_plo_c
  005a6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  005ad	83 c0 05	 add	 eax, 5
  005b0	48 98		 cdqe
  005b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ba	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  005c5	eb 5a		 jmp	 SHORT $LN37@s390_plo_c
$LN36@s390_plo_c:
  005c7	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005cf	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d7	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  005df	75 21		 jne	 SHORT $LN38@s390_plo_c
  005e1	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  005e8	83 c0 05	 add	 eax, 5
  005eb	48 98		 cdqe
  005ed	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f5	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00600	eb 1f		 jmp	 SHORT $LN39@s390_plo_c
$LN38@s390_plo_c:
  00602	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00609	83 c0 05	 add	 eax, 5
  0060c	48 98		 cdqe
  0060e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00616	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN39@s390_plo_c:
$LN37@s390_plo_c:
$LN35@s390_plo_c:
  00621	33 c0		 xor	 eax, eax
  00623	85 c0		 test	 eax, eax
  00625	0f 85 3e ff ff
	ff		 jne	 $LN10@s390_plo_c
$LN34@s390_plo_c:

; 1372 :         }
; 1373 :         ARCH_DEP(validate_operand) (op6addr, r3, 8-1,ACCTYPE_WRITE_SKP, regs);

  0062b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00633	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00638	41 b9 01 00 00
	00		 mov	 r9d, 1
  0063e	41 b8 07 00 00
	00		 mov	 r8d, 7
  00644	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  0064b	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  0064f	e8 00 00 00 00	 call	 s390_validate_operand

; 1374 : 
; 1375 :         /* Store 3th op at 4th op */
; 1376 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00654	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0065c	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00660	83 e0 04	 and	 eax, 4
  00663	85 c0		 test	 eax, eax
  00665	0f 84 f2 00 00
	00		 je	 $LN40@s390_plo_c
  0066b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00673	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00677	83 f8 40	 cmp	 eax, 64			; 00000040H
  0067a	0f 85 dd 00 00
	00		 jne	 $LN40@s390_plo_c

; 1377 :         {
; 1378 :             regs->AR(r3) = op4alet;

  00680	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00688	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00690	8b 54 24 44	 mov	 edx, DWORD PTR op4alet$[rsp]
  00694	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@s390_plo_c:

; 1379 :             SET_AEA_AR(regs, r3);

  0069b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a3	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  006a7	83 f8 40	 cmp	 eax, 64			; 00000040H
  006aa	0f 85 a3 00 00
	00		 jne	 $LN41@s390_plo_c
  006b0	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  006b8	0f 8e 95 00 00
	00		 jle	 $LN41@s390_plo_c
  006be	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  006c6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ce	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  006d6	75 21		 jne	 SHORT $LN42@s390_plo_c
  006d8	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  006df	83 c0 05	 add	 eax, 5
  006e2	48 98		 cdqe
  006e4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ec	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  006f7	eb 5a		 jmp	 SHORT $LN43@s390_plo_c
$LN42@s390_plo_c:
  006f9	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00701	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00709	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00711	75 21		 jne	 SHORT $LN44@s390_plo_c
  00713	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0071a	83 c0 05	 add	 eax, 5
  0071d	48 98		 cdqe
  0071f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00727	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00732	eb 1f		 jmp	 SHORT $LN45@s390_plo_c
$LN44@s390_plo_c:
  00734	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0073b	83 c0 05	 add	 eax, 5
  0073e	48 98		 cdqe
  00740	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00748	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN45@s390_plo_c:
$LN43@s390_plo_c:
$LN41@s390_plo_c:
  00753	33 c0		 xor	 eax, eax
  00755	85 c0		 test	 eax, eax
  00757	0f 85 3e ff ff
	ff		 jne	 $LN13@s390_plo_c
$LN40@s390_plo_c:

; 1380 :         }
; 1381 :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  0075d	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00765	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  0076d	8b 54 24 38	 mov	 edx, DWORD PTR op4addr$[rsp]
  00771	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op3$[rsp]
  00776	e8 00 00 00 00	 call	 s390_vstore8

; 1382 : 
; 1383 :         /* Store 5th op at 6th op */
; 1384 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0077b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00787	83 e0 04	 and	 eax, 4
  0078a	85 c0		 test	 eax, eax
  0078c	0f 84 f2 00 00
	00		 je	 $LN46@s390_plo_c
  00792	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0079a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0079e	83 f8 40	 cmp	 eax, 64			; 00000040H
  007a1	0f 85 dd 00 00
	00		 jne	 $LN46@s390_plo_c

; 1385 :         {
; 1386 :             regs->AR(r3) = op6alet;

  007a7	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  007af	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b7	8b 54 24 3c	 mov	 edx, DWORD PTR op6alet$[rsp]
  007bb	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN16@s390_plo_c:

; 1387 :             SET_AEA_AR(regs, r3);

  007c2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ca	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  007ce	83 f8 40	 cmp	 eax, 64			; 00000040H
  007d1	0f 85 a3 00 00
	00		 jne	 $LN47@s390_plo_c
  007d7	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  007df	0f 8e 95 00 00
	00		 jle	 $LN47@s390_plo_c
  007e5	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  007ed	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f5	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  007fd	75 21		 jne	 SHORT $LN48@s390_plo_c
  007ff	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00806	83 c0 05	 add	 eax, 5
  00809	48 98		 cdqe
  0080b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00813	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0081e	eb 5a		 jmp	 SHORT $LN49@s390_plo_c
$LN48@s390_plo_c:
  00820	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00828	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00830	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00838	75 21		 jne	 SHORT $LN50@s390_plo_c
  0083a	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00841	83 c0 05	 add	 eax, 5
  00844	48 98		 cdqe
  00846	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0084e	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00859	eb 1f		 jmp	 SHORT $LN51@s390_plo_c
$LN50@s390_plo_c:
  0085b	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00862	83 c0 05	 add	 eax, 5
  00865	48 98		 cdqe
  00867	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0086f	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN51@s390_plo_c:
$LN49@s390_plo_c:
$LN47@s390_plo_c:
  0087a	33 c0		 xor	 eax, eax
  0087c	85 c0		 test	 eax, eax
  0087e	0f 85 3e ff ff
	ff		 jne	 $LN16@s390_plo_c
$LN46@s390_plo_c:

; 1388 :         }
; 1389 :         ARCH_DEP(vstore8)(op5, op6addr, r3, regs);

  00884	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0088c	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00894	8b 54 24 30	 mov	 edx, DWORD PTR op6addr$[rsp]
  00898	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op5$[rsp]
  0089d	e8 00 00 00 00	 call	 s390_vstore8

; 1390 : 
; 1391 :         /* Store 7th op at 8th op */
; 1392 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  008a2	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008aa	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  008ae	83 e0 04	 and	 eax, 4
  008b1	85 c0		 test	 eax, eax
  008b3	0f 84 f2 00 00
	00		 je	 $LN52@s390_plo_c
  008b9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  008c5	83 f8 40	 cmp	 eax, 64			; 00000040H
  008c8	0f 85 dd 00 00
	00		 jne	 $LN52@s390_plo_c

; 1393 :         {
; 1394 :             regs->AR(r3) = op8alet;

  008ce	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  008d6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008de	8b 54 24 40	 mov	 edx, DWORD PTR op8alet$[rsp]
  008e2	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN19@s390_plo_c:

; 1395 :             SET_AEA_AR(regs, r3);

  008e9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008f1	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  008f5	83 f8 40	 cmp	 eax, 64			; 00000040H
  008f8	0f 85 a3 00 00
	00		 jne	 $LN53@s390_plo_c
  008fe	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  00906	0f 8e 95 00 00
	00		 jle	 $LN53@s390_plo_c
  0090c	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00914	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091c	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00924	75 21		 jne	 SHORT $LN54@s390_plo_c
  00926	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0092d	83 c0 05	 add	 eax, 5
  00930	48 98		 cdqe
  00932	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093a	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00945	eb 5a		 jmp	 SHORT $LN55@s390_plo_c
$LN54@s390_plo_c:
  00947	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0094f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00957	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0095f	75 21		 jne	 SHORT $LN56@s390_plo_c
  00961	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00968	83 c0 05	 add	 eax, 5
  0096b	48 98		 cdqe
  0096d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00975	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00980	eb 1f		 jmp	 SHORT $LN57@s390_plo_c
$LN56@s390_plo_c:
  00982	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00989	83 c0 05	 add	 eax, 5
  0098c	48 98		 cdqe
  0098e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00996	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN57@s390_plo_c:
$LN55@s390_plo_c:
$LN53@s390_plo_c:
  009a1	33 c0		 xor	 eax, eax
  009a3	85 c0		 test	 eax, eax
  009a5	0f 85 3e ff ff
	ff		 jne	 $LN19@s390_plo_c
$LN52@s390_plo_c:

; 1396 :         }
; 1397 :         ARCH_DEP(vstore8)(op7, op8addr, r3, regs);

  009ab	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009b3	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  009bb	8b 54 24 34	 mov	 edx, DWORD PTR op8addr$[rsp]
  009bf	48 8b 4c 24 68	 mov	 rcx, QWORD PTR op7$[rsp]
  009c4	e8 00 00 00 00	 call	 s390_vstore8

; 1398 : 
; 1399 :         /* Store 1st op replacement value at 2nd op */
; 1400 :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  009c9	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  009d1	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  009d9	8b 94 24 a0 00
	00 00		 mov	 edx, DWORD PTR effective_addr2$[rsp]
  009e0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR op1r$[rsp]
  009e5	e8 00 00 00 00	 call	 s390_vstore8

; 1401 : 
; 1402 :         return 0;

  009ea	33 c0		 xor	 eax, eax
  009ec	eb 3b		 jmp	 SHORT $LN1@s390_plo_c

; 1403 :     }

  009ee	eb 39		 jmp	 SHORT $LN23@s390_plo_c
$LN22@s390_plo_c:

; 1404 :     else
; 1405 :     {
; 1406 :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  009f0	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  009f7	83 c0 08	 add	 eax, 8
  009fa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a02	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00a08	4c 8b 8c 24 c0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00a10	44 8b 84 24 b8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  00a18	8b d0		 mov	 edx, eax
  00a1a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op2$[rsp]
  00a1f	e8 00 00 00 00	 call	 s390_vstore8

; 1407 : 
; 1408 :         return 1;

  00a24	b8 01 00 00 00	 mov	 eax, 1
$LN23@s390_plo_c:
$LN1@s390_plo_c:

; 1409 :     }
; 1410 : }

  00a29	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00a30	c3		 ret	 0
s390_plo_cststg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6addr$ = 48
op8addr$ = 52
op4addr$ = 56
op6alet$ = 60
op8alet$ = 64
op4alet$ = 68
op2$ = 72
op3$ = 76
op5$ = 80
op7$ = 84
r1$ = 112
r3$ = 120
effective_addr2$ = 128
b2$ = 136
effective_addr4$ = 144
b4$ = 152
regs$ = 160
s390_plo_cstst PROC

; 1173 : {

$LN57:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1174 : U32 op2,
; 1175 :     op3,
; 1176 :     op4alet = 0,

  00016	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 1177 :     op5,
; 1178 :     op6alet = 0,

  0001e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 1179 :     op7,
; 1180 :     op8alet = 0;

  00026	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR op8alet$[rsp], 0

; 1181 : VADR op4addr,
; 1182 :     op6addr,
; 1183 :     op8addr;
; 1184 : 
; 1185 :     ODD_CHECK(r1, regs);

  0002e	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  00032	83 e0 01	 and	 eax, 1
  00035	85 c0		 test	 eax, eax
  00037	74 1b		 je	 SHORT $LN17@s390_plo_c
  00039	ba 06 00 00 00	 mov	 edx, 6
  0003e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00046	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN17@s390_plo_c:

; 1186 :     FW_CHECK(effective_addr2, regs);

  00054	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0005b	83 e0 03	 and	 eax, 3
  0005e	85 c0		 test	 eax, eax
  00060	74 1b		 je	 SHORT $LN18@s390_plo_c
  00062	ba 06 00 00 00	 mov	 edx, 6
  00067	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00077	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN18@s390_plo_c:

; 1187 :     FW_CHECK(effective_addr4, regs);

  0007d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00084	83 e0 03	 and	 eax, 3
  00087	85 c0		 test	 eax, eax
  00089	74 1b		 je	 SHORT $LN19@s390_plo_c
  0008b	ba 06 00 00 00	 mov	 edx, 6
  00090	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00098	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_plo_c:

; 1188 : 
; 1189 :     op2 = ARCH_DEP(vfetch4)(effective_addr2, b2, regs);

  000a6	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000ae	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000b5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bc	e8 00 00 00 00	 call	 s390_vfetch4
  000c1	89 44 24 48	 mov	 DWORD PTR op2$[rsp], eax

; 1190 :     op3 = ARCH_DEP(wfetch4)(effective_addr4 + 60, b4, regs);

  000c5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000cc	83 c0 3c	 add	 eax, 60			; 0000003cH
  000cf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d7	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000dd	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000e5	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000ec	8b c8		 mov	 ecx, eax
  000ee	e8 00 00 00 00	 call	 s390_vfetch4
  000f3	89 44 24 4c	 mov	 DWORD PTR op3$[rsp], eax

; 1191 :     op5 = ARCH_DEP(wfetch4)(effective_addr4 + 92, b4, regs);

  000f7	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000fe	83 c0 5c	 add	 eax, 92			; 0000005cH
  00101	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0010f	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00117	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0011e	8b c8		 mov	 ecx, eax
  00120	e8 00 00 00 00	 call	 s390_vfetch4
  00125	89 44 24 50	 mov	 DWORD PTR op5$[rsp], eax

; 1192 :     op7 = ARCH_DEP(wfetch4)(effective_addr4 + 124, b4, regs);

  00129	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00130	83 c0 7c	 add	 eax, 124		; 0000007cH
  00133	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013b	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00141	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00149	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00150	8b c8		 mov	 ecx, eax
  00152	e8 00 00 00 00	 call	 s390_vfetch4
  00157	89 44 24 54	 mov	 DWORD PTR op7$[rsp], eax

; 1193 : 
; 1194 :     if(regs->GR_L(r1) == op2)

  0015b	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  00160	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00168	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  0016c	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00173	0f 85 cc 07 00
	00		 jne	 $LN20@s390_plo_c

; 1195 :     {
; 1196 :         /* Verify access to 2nd operand */
; 1197 :         ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  00179	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00181	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00186	41 b9 01 00 00
	00		 mov	 r9d, 1
  0018c	41 b8 03 00 00
	00		 mov	 r8d, 3
  00192	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  00199	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001a0	e8 00 00 00 00	 call	 s390_validate_operand

; 1198 :             ACCTYPE_WRITE_SKP, regs);
; 1199 : 
; 1200 :         /* When in ar mode, ar3 is used to access the
; 1201 :            operand. The alet is fetched from the pl */
; 1202 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001a5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ad	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001b1	83 e0 04	 and	 eax, 4
  001b4	85 c0		 test	 eax, eax
  001b6	0f 84 8e 01 00
	00		 je	 $LN22@s390_plo_c
  001bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c4	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001c8	83 f8 40	 cmp	 eax, 64			; 00000040H
  001cb	0f 85 79 01 00
	00		 jne	 $LN22@s390_plo_c

; 1203 :         {
; 1204 :             if(r3 == 0)

  001d1	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  001d6	75 12		 jne	 SHORT $LN23@s390_plo_c

; 1205 :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001d8	ba 06 00 00 00	 mov	 edx, 6
  001dd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	e8 00 00 00 00	 call	 s390_program_interrupt
$LN23@s390_plo_c:

; 1206 :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001ea	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  001f1	83 c0 44	 add	 eax, 68			; 00000044H
  001f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fc	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00202	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020a	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00211	8b c8		 mov	 ecx, eax
  00213	e8 00 00 00 00	 call	 s390_vfetch4
  00218	89 44 24 44	 mov	 DWORD PTR op4alet$[rsp], eax

; 1207 :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  0021c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00223	83 c0 64	 add	 eax, 100		; 00000064H
  00226	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022e	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00234	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0023c	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00243	8b c8		 mov	 ecx, eax
  00245	e8 00 00 00 00	 call	 s390_vfetch4
  0024a	89 44 24 3c	 mov	 DWORD PTR op6alet$[rsp], eax

; 1208 :             op8alet = ARCH_DEP(wfetch4)(effective_addr4 + 132, b4, regs);

  0024e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00255	05 84 00 00 00	 add	 eax, 132		; 00000084H
  0025a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00262	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00268	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00270	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00277	8b c8		 mov	 ecx, eax
  00279	e8 00 00 00 00	 call	 s390_vfetch4
  0027e	89 44 24 40	 mov	 DWORD PTR op8alet$[rsp], eax

; 1209 :             regs->AR(r3) = op8alet;

  00282	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00287	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028f	8b 54 24 40	 mov	 edx, DWORD PTR op8alet$[rsp]
  00293	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN4@s390_plo_c:

; 1210 :             SET_AEA_AR(regs, r3);

  0029a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a2	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  002a6	83 f8 40	 cmp	 eax, 64			; 00000040H
  002a9	0f 85 91 00 00
	00		 jne	 $LN24@s390_plo_c
  002af	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  002b4	0f 8e 86 00 00
	00		 jle	 $LN24@s390_plo_c
  002ba	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  002bf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c7	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  002cf	75 1e		 jne	 SHORT $LN25@s390_plo_c
  002d1	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  002d5	83 c0 05	 add	 eax, 5
  002d8	48 98		 cdqe
  002da	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  002ed	eb 51		 jmp	 SHORT $LN26@s390_plo_c
$LN25@s390_plo_c:
  002ef	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  002f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fc	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00304	75 1e		 jne	 SHORT $LN27@s390_plo_c
  00306	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0030a	83 c0 05	 add	 eax, 5
  0030d	48 98		 cdqe
  0030f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00317	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00322	eb 1c		 jmp	 SHORT $LN28@s390_plo_c
$LN27@s390_plo_c:
  00324	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00328	83 c0 05	 add	 eax, 5
  0032b	48 98		 cdqe
  0032d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00335	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN28@s390_plo_c:
$LN26@s390_plo_c:
$LN24@s390_plo_c:
  00340	33 c0		 xor	 eax, eax
  00342	85 c0		 test	 eax, eax
  00344	0f 85 50 ff ff
	ff		 jne	 $LN4@s390_plo_c
$LN22@s390_plo_c:

; 1211 :         }
; 1212 : 
; 1213 :         /* Load address of operand 4 */
; 1214 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1215 :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);
; 1216 : #else
; 1217 :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);

  0034a	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00351	83 c0 4c	 add	 eax, 76			; 0000004cH
  00354	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035c	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00362	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0036a	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00371	8b c8		 mov	 ecx, eax
  00373	e8 00 00 00 00	 call	 s390_vfetch4
  00378	89 44 24 38	 mov	 DWORD PTR op4addr$[rsp], eax

; 1218 : #endif
; 1219 :         op4addr &= ADDRESS_MAXWRAP(regs);

  0037c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00384	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0038a	8b 4c 24 38	 mov	 ecx, DWORD PTR op4addr$[rsp]
  0038e	23 c8		 and	 ecx, eax
  00390	8b c1		 mov	 eax, ecx
  00392	89 44 24 38	 mov	 DWORD PTR op4addr$[rsp], eax

; 1220 :         FW_CHECK(op4addr, regs);

  00396	8b 44 24 38	 mov	 eax, DWORD PTR op4addr$[rsp]
  0039a	83 e0 03	 and	 eax, 3
  0039d	85 c0		 test	 eax, eax
  0039f	74 1b		 je	 SHORT $LN29@s390_plo_c
  003a1	ba 06 00 00 00	 mov	 edx, 6
  003a6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b6	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN29@s390_plo_c:

; 1221 : 
; 1222 :         /* Load address of operand 6 */
; 1223 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1224 :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);
; 1225 : #else
; 1226 :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);

  003bc	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  003c3	83 c0 6c	 add	 eax, 108		; 0000006cH
  003c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  003d4	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003dc	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003e3	8b c8		 mov	 ecx, eax
  003e5	e8 00 00 00 00	 call	 s390_vfetch4
  003ea	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 1227 : #endif
; 1228 :         op6addr &= ADDRESS_MAXWRAP(regs);

  003ee	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f6	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003fc	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  00400	23 c8		 and	 ecx, eax
  00402	8b c1		 mov	 eax, ecx
  00404	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 1229 :         FW_CHECK(op6addr, regs);

  00408	8b 44 24 30	 mov	 eax, DWORD PTR op6addr$[rsp]
  0040c	83 e0 03	 and	 eax, 3
  0040f	85 c0		 test	 eax, eax
  00411	74 1b		 je	 SHORT $LN30@s390_plo_c
  00413	ba 06 00 00 00	 mov	 edx, 6
  00418	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00420	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00428	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN30@s390_plo_c:

; 1230 : 
; 1231 :         /* Load address of operand 8 */
; 1232 : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 1233 :         op8addr = ARCH_DEP(wfetch8)(effective_addr4 + 136, b4, regs);
; 1234 : #else
; 1235 :         op8addr = ARCH_DEP(wfetch4)(effective_addr4 + 140, b4, regs);

  0042e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00435	05 8c 00 00 00	 add	 eax, 140		; 0000008cH
  0043a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00442	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00448	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00450	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00457	8b c8		 mov	 ecx, eax
  00459	e8 00 00 00 00	 call	 s390_vfetch4
  0045e	89 44 24 34	 mov	 DWORD PTR op8addr$[rsp], eax

; 1236 : #endif
; 1237 :         op8addr &= ADDRESS_MAXWRAP(regs);

  00462	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0046a	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  00470	8b 4c 24 34	 mov	 ecx, DWORD PTR op8addr$[rsp]
  00474	23 c8		 and	 ecx, eax
  00476	8b c1		 mov	 eax, ecx
  00478	89 44 24 34	 mov	 DWORD PTR op8addr$[rsp], eax

; 1238 :         FW_CHECK(op8addr, regs);

  0047c	8b 44 24 34	 mov	 eax, DWORD PTR op8addr$[rsp]
  00480	83 e0 03	 and	 eax, 3
  00483	85 c0		 test	 eax, eax
  00485	74 1b		 je	 SHORT $LN31@s390_plo_c
  00487	ba 06 00 00 00	 mov	 edx, 6
  0048c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00494	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0049c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN31@s390_plo_c:

; 1239 : 
; 1240 :         /* Verify access to 8th operand */
; 1241 :         ARCH_DEP(validate_operand) (op8addr, r3, 4-1,ACCTYPE_WRITE_SKP, regs);

  004a2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004af	41 b9 01 00 00
	00		 mov	 r9d, 1
  004b5	41 b8 03 00 00
	00		 mov	 r8d, 3
  004bb	8b 54 24 78	 mov	 edx, DWORD PTR r3$[rsp]
  004bf	8b 4c 24 34	 mov	 ecx, DWORD PTR op8addr$[rsp]
  004c3	e8 00 00 00 00	 call	 s390_validate_operand

; 1242 : 
; 1243 :         /* Verify access to 6th operand */
; 1244 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  004c8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d0	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  004d4	83 e0 04	 and	 eax, 4
  004d7	85 c0		 test	 eax, eax
  004d9	0f 84 dd 00 00
	00		 je	 $LN32@s390_plo_c
  004df	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e7	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  004eb	83 f8 40	 cmp	 eax, 64			; 00000040H
  004ee	0f 85 c8 00 00
	00		 jne	 $LN32@s390_plo_c

; 1245 :         {
; 1246 :             regs->AR(r3) = op6alet;

  004f4	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  004f9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00501	8b 54 24 3c	 mov	 edx, DWORD PTR op6alet$[rsp]
  00505	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@s390_plo_c:

; 1247 :             SET_AEA_AR(regs, r3);

  0050c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00514	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00518	83 f8 40	 cmp	 eax, 64			; 00000040H
  0051b	0f 85 91 00 00
	00		 jne	 $LN33@s390_plo_c
  00521	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  00526	0f 8e 86 00 00
	00		 jle	 $LN33@s390_plo_c
  0052c	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00531	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00539	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00541	75 1e		 jne	 SHORT $LN34@s390_plo_c
  00543	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00547	83 c0 05	 add	 eax, 5
  0054a	48 98		 cdqe
  0054c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00554	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0055f	eb 51		 jmp	 SHORT $LN35@s390_plo_c
$LN34@s390_plo_c:
  00561	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00566	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056e	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00576	75 1e		 jne	 SHORT $LN36@s390_plo_c
  00578	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0057c	83 c0 05	 add	 eax, 5
  0057f	48 98		 cdqe
  00581	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00589	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00594	eb 1c		 jmp	 SHORT $LN37@s390_plo_c
$LN36@s390_plo_c:
  00596	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0059a	83 c0 05	 add	 eax, 5
  0059d	48 98		 cdqe
  0059f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a7	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN37@s390_plo_c:
$LN35@s390_plo_c:
$LN33@s390_plo_c:
  005b2	33 c0		 xor	 eax, eax
  005b4	85 c0		 test	 eax, eax
  005b6	0f 85 50 ff ff
	ff		 jne	 $LN7@s390_plo_c
$LN32@s390_plo_c:

; 1248 :         }
; 1249 :         ARCH_DEP(validate_operand) (op6addr, r3, 4-1, ACCTYPE_WRITE_SKP, regs);

  005bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c9	41 b9 01 00 00
	00		 mov	 r9d, 1
  005cf	41 b8 03 00 00
	00		 mov	 r8d, 3
  005d5	8b 54 24 78	 mov	 edx, DWORD PTR r3$[rsp]
  005d9	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  005dd	e8 00 00 00 00	 call	 s390_validate_operand

; 1250 : 
; 1251 :         /* Store 3rd op at 4th op */
; 1252 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  005e2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ea	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  005ee	83 e0 04	 and	 eax, 4
  005f1	85 c0		 test	 eax, eax
  005f3	0f 84 dd 00 00
	00		 je	 $LN38@s390_plo_c
  005f9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00601	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00605	83 f8 40	 cmp	 eax, 64			; 00000040H
  00608	0f 85 c8 00 00
	00		 jne	 $LN38@s390_plo_c

; 1253 :         {
; 1254 :             regs->AR(r3) = op4alet;

  0060e	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00613	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061b	8b 54 24 44	 mov	 edx, DWORD PTR op4alet$[rsp]
  0061f	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@s390_plo_c:

; 1255 :             SET_AEA_AR(regs, r3);

  00626	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062e	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00632	83 f8 40	 cmp	 eax, 64			; 00000040H
  00635	0f 85 91 00 00
	00		 jne	 $LN39@s390_plo_c
  0063b	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  00640	0f 8e 86 00 00
	00		 jle	 $LN39@s390_plo_c
  00646	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0064b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00653	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0065b	75 1e		 jne	 SHORT $LN40@s390_plo_c
  0065d	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00661	83 c0 05	 add	 eax, 5
  00664	48 98		 cdqe
  00666	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066e	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00679	eb 51		 jmp	 SHORT $LN41@s390_plo_c
$LN40@s390_plo_c:
  0067b	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00680	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00688	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00690	75 1e		 jne	 SHORT $LN42@s390_plo_c
  00692	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00696	83 c0 05	 add	 eax, 5
  00699	48 98		 cdqe
  0069b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a3	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  006ae	eb 1c		 jmp	 SHORT $LN43@s390_plo_c
$LN42@s390_plo_c:
  006b0	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  006b4	83 c0 05	 add	 eax, 5
  006b7	48 98		 cdqe
  006b9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c1	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN43@s390_plo_c:
$LN41@s390_plo_c:
$LN39@s390_plo_c:
  006cc	33 c0		 xor	 eax, eax
  006ce	85 c0		 test	 eax, eax
  006d0	0f 85 50 ff ff
	ff		 jne	 $LN10@s390_plo_c
$LN38@s390_plo_c:

; 1256 :         }
; 1257 :         ARCH_DEP(vstore4)(op3, op4addr, r3, regs);

  006d6	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006de	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  006e3	8b 54 24 38	 mov	 edx, DWORD PTR op4addr$[rsp]
  006e7	8b 4c 24 4c	 mov	 ecx, DWORD PTR op3$[rsp]
  006eb	e8 00 00 00 00	 call	 s390_vstore4

; 1258 : 
; 1259 :         /* Store 5th op at 6th op */
; 1260 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  006f0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f8	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  006fc	83 e0 04	 and	 eax, 4
  006ff	85 c0		 test	 eax, eax
  00701	0f 84 dd 00 00
	00		 je	 $LN44@s390_plo_c
  00707	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0070f	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00713	83 f8 40	 cmp	 eax, 64			; 00000040H
  00716	0f 85 c8 00 00
	00		 jne	 $LN44@s390_plo_c

; 1261 :         {
; 1262 :             regs->AR(r3) = op6alet;

  0071c	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00721	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00729	8b 54 24 3c	 mov	 edx, DWORD PTR op6alet$[rsp]
  0072d	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@s390_plo_c:

; 1263 :             SET_AEA_AR(regs, r3);

  00734	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0073c	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00740	83 f8 40	 cmp	 eax, 64			; 00000040H
  00743	0f 85 91 00 00
	00		 jne	 $LN45@s390_plo_c
  00749	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  0074e	0f 8e 86 00 00
	00		 jle	 $LN45@s390_plo_c
  00754	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00759	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00761	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00769	75 1e		 jne	 SHORT $LN46@s390_plo_c
  0076b	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0076f	83 c0 05	 add	 eax, 5
  00772	48 98		 cdqe
  00774	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077c	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00787	eb 51		 jmp	 SHORT $LN47@s390_plo_c
$LN46@s390_plo_c:
  00789	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0078e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00796	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  0079e	75 1e		 jne	 SHORT $LN48@s390_plo_c
  007a0	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  007a4	83 c0 05	 add	 eax, 5
  007a7	48 98		 cdqe
  007a9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b1	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  007bc	eb 1c		 jmp	 SHORT $LN49@s390_plo_c
$LN48@s390_plo_c:
  007be	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  007c2	83 c0 05	 add	 eax, 5
  007c5	48 98		 cdqe
  007c7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cf	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN49@s390_plo_c:
$LN47@s390_plo_c:
$LN45@s390_plo_c:
  007da	33 c0		 xor	 eax, eax
  007dc	85 c0		 test	 eax, eax
  007de	0f 85 50 ff ff
	ff		 jne	 $LN13@s390_plo_c
$LN44@s390_plo_c:

; 1264 :         }
; 1265 :         ARCH_DEP(vstore4)(op5, op6addr, r3, regs);

  007e4	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  007ec	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  007f1	8b 54 24 30	 mov	 edx, DWORD PTR op6addr$[rsp]
  007f5	8b 4c 24 50	 mov	 ecx, DWORD PTR op5$[rsp]
  007f9	e8 00 00 00 00	 call	 s390_vstore4

; 1266 : 
; 1267 :         /* Store 7th op at 8th op */
; 1268 :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  007fe	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00806	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0080a	83 e0 04	 and	 eax, 4
  0080d	85 c0		 test	 eax, eax
  0080f	0f 84 dd 00 00
	00		 je	 $LN50@s390_plo_c
  00815	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081d	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00821	83 f8 40	 cmp	 eax, 64			; 00000040H
  00824	0f 85 c8 00 00
	00		 jne	 $LN50@s390_plo_c

; 1269 :         {
; 1270 :             regs->AR(r3) = op8alet;

  0082a	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0082f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00837	8b 54 24 40	 mov	 edx, DWORD PTR op8alet$[rsp]
  0083b	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN16@s390_plo_c:

; 1271 :             SET_AEA_AR(regs, r3);

  00842	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0084a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0084e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00851	0f 85 91 00 00
	00		 jne	 $LN51@s390_plo_c
  00857	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  0085c	0f 8e 86 00 00
	00		 jle	 $LN51@s390_plo_c
  00862	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00867	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0086f	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00877	75 1e		 jne	 SHORT $LN52@s390_plo_c
  00879	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0087d	83 c0 05	 add	 eax, 5
  00880	48 98		 cdqe
  00882	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0088a	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00895	eb 51		 jmp	 SHORT $LN53@s390_plo_c
$LN52@s390_plo_c:
  00897	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0089c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008a4	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  008ac	75 1e		 jne	 SHORT $LN54@s390_plo_c
  008ae	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  008b2	83 c0 05	 add	 eax, 5
  008b5	48 98		 cdqe
  008b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008bf	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  008ca	eb 1c		 jmp	 SHORT $LN55@s390_plo_c
$LN54@s390_plo_c:
  008cc	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  008d0	83 c0 05	 add	 eax, 5
  008d3	48 98		 cdqe
  008d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008dd	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN55@s390_plo_c:
$LN53@s390_plo_c:
$LN51@s390_plo_c:
  008e8	33 c0		 xor	 eax, eax
  008ea	85 c0		 test	 eax, eax
  008ec	0f 85 50 ff ff
	ff		 jne	 $LN16@s390_plo_c
$LN50@s390_plo_c:

; 1272 :         }
; 1273 :         ARCH_DEP(vstore4)(op7, op8addr, r3, regs);

  008f2	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  008fa	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  008ff	8b 54 24 34	 mov	 edx, DWORD PTR op8addr$[rsp]
  00903	8b 4c 24 54	 mov	 ecx, DWORD PTR op7$[rsp]
  00907	e8 00 00 00 00	 call	 s390_vstore4

; 1274 : 
; 1275 :         /* Store 1st op replacement at 2nd op */
; 1276 :         ARCH_DEP(vstore4)(regs->GR_L(r1+1), effective_addr2, b2, regs);

  0090c	8b 44 24 70	 mov	 eax, DWORD PTR r1$[rsp]
  00910	ff c0		 inc	 eax
  00912	48 98		 cdqe
  00914	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0091c	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  00924	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0092b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00933	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0093a	e8 00 00 00 00	 call	 s390_vstore4

; 1277 : 
; 1278 :         return 0;

  0093f	33 c0		 xor	 eax, eax
  00941	eb 1f		 jmp	 SHORT $LN1@s390_plo_c

; 1279 :     }

  00943	eb 1d		 jmp	 SHORT $LN21@s390_plo_c
$LN20@s390_plo_c:

; 1280 :     else
; 1281 :     {
; 1282 :         regs->GR_L(r1) = op2;

  00945	48 63 44 24 70	 movsxd	 rax, DWORD PTR r1$[rsp]
  0094a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00952	8b 54 24 48	 mov	 edx, DWORD PTR op2$[rsp]
  00956	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 1283 : 
; 1284 :         return 1;

  0095d	b8 01 00 00 00	 mov	 eax, 1
$LN21@s390_plo_c:
$LN1@s390_plo_c:

; 1285 :     }
; 1286 : }

  00962	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00966	c3		 ret	 0
s390_plo_cstst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6addr$ = 48
op4addr$ = 52
op6alet$ = 56
op4alet$ = 60
op2$ = 64
op1c$ = 72
op3$ = 80
op5$ = 88
op1r$ = 96
r1$ = 128
r3$ = 136
effective_addr2$ = 144
b2$ = 152
effective_addr4$ = 160
b4$ = 168
regs$ = 176
s390_plo_csdstg PROC

; 908  : {

$LN40:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 909  : U64 op1c,
; 910  :     op1r,
; 911  :     op2,
; 912  :     op3,
; 913  :     op5;
; 914  : U32 op4alet = 0,

  00016	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 915  :     op6alet = 0;

  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0
$LN4@s390_plo_c:

; 916  : VADR op4addr,
; 917  :     op6addr;
; 918  : 
; 919  :     UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@s390_plo_c

; 920  : 
; 921  :     DW_CHECK(effective_addr2, regs);

  0002c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00033	83 e0 07	 and	 eax, 7
  00036	85 c0		 test	 eax, eax
  00038	74 1b		 je	 SHORT $LN14@s390_plo_c
  0003a	ba 06 00 00 00	 mov	 edx, 6
  0003f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00047	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004f	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN14@s390_plo_c:

; 922  :     DW_CHECK(effective_addr4, regs);

  00055	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0005c	83 e0 07	 and	 eax, 7
  0005f	85 c0		 test	 eax, eax
  00061	74 1b		 je	 SHORT $LN15@s390_plo_c
  00063	ba 06 00 00 00	 mov	 edx, 6
  00068	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00078	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN15@s390_plo_c:

; 923  : 
; 924  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  0007e	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00085	83 c0 08	 add	 eax, 8
  00088	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00096	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0009e	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000a5	8b c8		 mov	 ecx, eax
  000a7	e8 00 00 00 00	 call	 s390_vfetch8
  000ac	48 89 44 24 48	 mov	 QWORD PTR op1c$[rsp], rax

; 925  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000b1	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000b9	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000c0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000c7	e8 00 00 00 00	 call	 s390_vfetch8
  000cc	48 89 44 24 40	 mov	 QWORD PTR op2$[rsp], rax

; 926  : 
; 927  :     if(op1c == op2)

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR op2$[rsp]
  000d6	48 39 44 24 48	 cmp	 QWORD PTR op1c$[rsp], rax
  000db	0f 85 d0 05 00
	00		 jne	 $LN16@s390_plo_c

; 928  :     {
; 929  :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000e1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000e8	83 c0 18	 add	 eax, 24
  000eb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f3	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000f9	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00101	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00108	8b c8		 mov	 ecx, eax
  0010a	e8 00 00 00 00	 call	 s390_vfetch8
  0010f	48 89 44 24 60	 mov	 QWORD PTR op1r$[rsp], rax

; 930  :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  00114	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0011b	83 c0 38	 add	 eax, 56			; 00000038H
  0011e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00126	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0012c	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00134	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0013b	8b c8		 mov	 ecx, eax
  0013d	e8 00 00 00 00	 call	 s390_vfetch8
  00142	48 89 44 24 50	 mov	 QWORD PTR op3$[rsp], rax

; 931  :         op5 = ARCH_DEP(wfetch8)(effective_addr4 + 88, b4, regs);

  00147	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0014e	83 c0 58	 add	 eax, 88			; 00000058H
  00151	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00159	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0015f	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00167	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0016e	8b c8		 mov	 ecx, eax
  00170	e8 00 00 00 00	 call	 s390_vfetch8
  00175	48 89 44 24 58	 mov	 QWORD PTR op5$[rsp], rax

; 932  : 
; 933  :         /* Verify access to 2nd operand */
; 934  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  0017a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00182	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00187	41 b9 01 00 00
	00		 mov	 r9d, 1
  0018d	41 b8 07 00 00
	00		 mov	 r8d, 7
  00193	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0019a	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  001a1	e8 00 00 00 00	 call	 s390_validate_operand

; 935  :             ACCTYPE_WRITE_SKP, regs);
; 936  : 
; 937  :         /* When in ar mode, ar3 is used to access the
; 938  :            operand. The alet is fetched from the pl */
; 939  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  001a6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  001b2	83 e0 04	 and	 eax, 4
  001b5	85 c0		 test	 eax, eax
  001b7	0f 84 72 01 00
	00		 je	 $LN18@s390_plo_c
  001bd	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c5	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001c9	83 f8 40	 cmp	 eax, 64			; 00000040H
  001cc	0f 85 5d 01 00
	00		 jne	 $LN18@s390_plo_c

; 940  :         {
; 941  :             if(r3 == 0)

  001d2	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001da	75 12		 jne	 SHORT $LN19@s390_plo_c

; 942  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  001dc	ba 06 00 00 00	 mov	 edx, 6
  001e1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e9	e8 00 00 00 00	 call	 s390_program_interrupt
$LN19@s390_plo_c:

; 943  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001ee	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  001f5	83 c0 44	 add	 eax, 68			; 00000044H
  001f8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00200	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00206	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0020e	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00215	8b c8		 mov	 ecx, eax
  00217	e8 00 00 00 00	 call	 s390_vfetch4
  0021c	89 44 24 3c	 mov	 DWORD PTR op4alet$[rsp], eax

; 944  :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  00220	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00227	83 c0 64	 add	 eax, 100		; 00000064H
  0022a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00238	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00240	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00247	8b c8		 mov	 ecx, eax
  00249	e8 00 00 00 00	 call	 s390_vfetch4
  0024e	89 44 24 38	 mov	 DWORD PTR op6alet$[rsp], eax

; 945  :             regs->AR(r3) = op6alet;

  00252	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0025a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00262	8b 54 24 38	 mov	 edx, DWORD PTR op6alet$[rsp]
  00266	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@s390_plo_c:

; 946  :             SET_AEA_AR(regs, r3);

  0026d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00275	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00279	83 f8 40	 cmp	 eax, 64			; 00000040H
  0027c	0f 85 a3 00 00
	00		 jne	 $LN20@s390_plo_c
  00282	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  0028a	0f 8e 95 00 00
	00		 jle	 $LN20@s390_plo_c
  00290	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00298	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  002a8	75 21		 jne	 SHORT $LN21@s390_plo_c
  002aa	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002b1	83 c0 05	 add	 eax, 5
  002b4	48 98		 cdqe
  002b6	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002be	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  002c9	eb 5a		 jmp	 SHORT $LN22@s390_plo_c
$LN21@s390_plo_c:
  002cb	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002d3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002db	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  002e3	75 21		 jne	 SHORT $LN23@s390_plo_c
  002e5	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002ec	83 c0 05	 add	 eax, 5
  002ef	48 98		 cdqe
  002f1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f9	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00304	eb 1f		 jmp	 SHORT $LN24@s390_plo_c
$LN23@s390_plo_c:
  00306	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0030d	83 c0 05	 add	 eax, 5
  00310	48 98		 cdqe
  00312	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN24@s390_plo_c:
$LN22@s390_plo_c:
$LN20@s390_plo_c:
  00325	33 c0		 xor	 eax, eax
  00327	85 c0		 test	 eax, eax
  00329	0f 85 3e ff ff
	ff		 jne	 $LN7@s390_plo_c
$LN18@s390_plo_c:

; 947  :         }
; 948  : 
; 949  :         /* Load address of operand 4 */
; 950  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 951  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);
; 952  : #else
; 953  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);

  0032f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00336	83 c0 4c	 add	 eax, 76			; 0000004cH
  00339	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00341	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00347	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0034f	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00356	8b c8		 mov	 ecx, eax
  00358	e8 00 00 00 00	 call	 s390_vfetch4
  0035d	89 44 24 34	 mov	 DWORD PTR op4addr$[rsp], eax

; 954  : #endif
; 955  :         op4addr &= ADDRESS_MAXWRAP(regs);

  00361	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00369	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0036f	8b 4c 24 34	 mov	 ecx, DWORD PTR op4addr$[rsp]
  00373	23 c8		 and	 ecx, eax
  00375	8b c1		 mov	 eax, ecx
  00377	89 44 24 34	 mov	 DWORD PTR op4addr$[rsp], eax

; 956  :         DW_CHECK(op4addr, regs);

  0037b	8b 44 24 34	 mov	 eax, DWORD PTR op4addr$[rsp]
  0037f	83 e0 07	 and	 eax, 7
  00382	85 c0		 test	 eax, eax
  00384	74 1b		 je	 SHORT $LN25@s390_plo_c
  00386	ba 06 00 00 00	 mov	 edx, 6
  0038b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00393	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN25@s390_plo_c:

; 957  : 
; 958  :         /* Load address of operand 6 */
; 959  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 960  :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);
; 961  : #else
; 962  :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);

  003a1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  003a8	83 c0 6c	 add	 eax, 108		; 0000006cH
  003ab	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b3	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  003b9	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c1	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003c8	8b c8		 mov	 ecx, eax
  003ca	e8 00 00 00 00	 call	 s390_vfetch4
  003cf	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 963  : #endif
; 964  :         op6addr &= ADDRESS_MAXWRAP(regs);

  003d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003db	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  003e1	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  003e5	23 c8		 and	 ecx, eax
  003e7	8b c1		 mov	 eax, ecx
  003e9	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 965  :         DW_CHECK(op6addr, regs);

  003ed	8b 44 24 30	 mov	 eax, DWORD PTR op6addr$[rsp]
  003f1	83 e0 07	 and	 eax, 7
  003f4	85 c0		 test	 eax, eax
  003f6	74 1b		 je	 SHORT $LN26@s390_plo_c
  003f8	ba 06 00 00 00	 mov	 edx, 6
  003fd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00405	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0040d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN26@s390_plo_c:

; 966  : 
; 967  :         /* Verify access to 6th operand */
; 968  :         ARCH_DEP(validate_operand) (op6addr, r3, 8-1, ACCTYPE_WRITE_SKP, regs);

  00413	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00420	41 b9 01 00 00
	00		 mov	 r9d, 1
  00426	41 b8 07 00 00
	00		 mov	 r8d, 7
  0042c	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00433	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  00437	e8 00 00 00 00	 call	 s390_validate_operand

; 969  : 
; 970  :         /* Store 3th op at 4th op */
; 971  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0043c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00444	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00448	83 e0 04	 and	 eax, 4
  0044b	85 c0		 test	 eax, eax
  0044d	0f 84 f2 00 00
	00		 je	 $LN27@s390_plo_c
  00453	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0045f	83 f8 40	 cmp	 eax, 64			; 00000040H
  00462	0f 85 dd 00 00
	00		 jne	 $LN27@s390_plo_c

; 972  :         {
; 973  :             regs->AR(r3) = op4alet;

  00468	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00470	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00478	8b 54 24 3c	 mov	 edx, DWORD PTR op4alet$[rsp]
  0047c	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@s390_plo_c:

; 974  :             SET_AEA_AR(regs, r3);

  00483	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0048b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0048f	83 f8 40	 cmp	 eax, 64			; 00000040H
  00492	0f 85 a3 00 00
	00		 jne	 $LN28@s390_plo_c
  00498	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  004a0	0f 8e 95 00 00
	00		 jle	 $LN28@s390_plo_c
  004a6	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004ae	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b6	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  004be	75 21		 jne	 SHORT $LN29@s390_plo_c
  004c0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  004c7	83 c0 05	 add	 eax, 5
  004ca	48 98		 cdqe
  004cc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d4	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  004df	eb 5a		 jmp	 SHORT $LN30@s390_plo_c
$LN29@s390_plo_c:
  004e1	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004e9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f1	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  004f9	75 21		 jne	 SHORT $LN31@s390_plo_c
  004fb	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00502	83 c0 05	 add	 eax, 5
  00505	48 98		 cdqe
  00507	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050f	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  0051a	eb 1f		 jmp	 SHORT $LN32@s390_plo_c
$LN31@s390_plo_c:
  0051c	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00523	83 c0 05	 add	 eax, 5
  00526	48 98		 cdqe
  00528	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00530	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN32@s390_plo_c:
$LN30@s390_plo_c:
$LN28@s390_plo_c:
  0053b	33 c0		 xor	 eax, eax
  0053d	85 c0		 test	 eax, eax
  0053f	0f 85 3e ff ff
	ff		 jne	 $LN10@s390_plo_c
$LN27@s390_plo_c:

; 975  :         }
; 976  :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  00545	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0054d	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00555	8b 54 24 34	 mov	 edx, DWORD PTR op4addr$[rsp]
  00559	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op3$[rsp]
  0055e	e8 00 00 00 00	 call	 s390_vstore8

; 977  : 
; 978  :         /* Store 5th op at 6th op */
; 979  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  00563	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0056b	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  0056f	83 e0 04	 and	 eax, 4
  00572	85 c0		 test	 eax, eax
  00574	0f 84 f2 00 00
	00		 je	 $LN33@s390_plo_c
  0057a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00582	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00586	83 f8 40	 cmp	 eax, 64			; 00000040H
  00589	0f 85 dd 00 00
	00		 jne	 $LN33@s390_plo_c

; 980  :         {
; 981  :             regs->AR(r3) = op6alet;

  0058f	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00597	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059f	8b 54 24 38	 mov	 edx, DWORD PTR op6alet$[rsp]
  005a3	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN13@s390_plo_c:

; 982  :             SET_AEA_AR(regs, r3);

  005aa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b2	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  005b6	83 f8 40	 cmp	 eax, 64			; 00000040H
  005b9	0f 85 a3 00 00
	00		 jne	 $LN34@s390_plo_c
  005bf	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  005c7	0f 8e 95 00 00
	00		 jle	 $LN34@s390_plo_c
  005cd	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  005d5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005dd	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  005e5	75 21		 jne	 SHORT $LN35@s390_plo_c
  005e7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  005ee	83 c0 05	 add	 eax, 5
  005f1	48 98		 cdqe
  005f3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005fb	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00606	eb 5a		 jmp	 SHORT $LN36@s390_plo_c
$LN35@s390_plo_c:
  00608	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00610	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00618	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00620	75 21		 jne	 SHORT $LN37@s390_plo_c
  00622	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00629	83 c0 05	 add	 eax, 5
  0062c	48 98		 cdqe
  0062e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00636	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00641	eb 1f		 jmp	 SHORT $LN38@s390_plo_c
$LN37@s390_plo_c:
  00643	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0064a	83 c0 05	 add	 eax, 5
  0064d	48 98		 cdqe
  0064f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00657	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN38@s390_plo_c:
$LN36@s390_plo_c:
$LN34@s390_plo_c:
  00662	33 c0		 xor	 eax, eax
  00664	85 c0		 test	 eax, eax
  00666	0f 85 3e ff ff
	ff		 jne	 $LN13@s390_plo_c
$LN33@s390_plo_c:

; 983  :         }
; 984  :         ARCH_DEP(vstore8)(op5, op6addr, r3, regs);

  0066c	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00674	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  0067c	8b 54 24 30	 mov	 edx, DWORD PTR op6addr$[rsp]
  00680	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op5$[rsp]
  00685	e8 00 00 00 00	 call	 s390_vstore8

; 985  : 
; 986  :         /* Store 1st op replacement at 2nd op */
; 987  :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  0068a	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00692	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  0069a	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR effective_addr2$[rsp]
  006a1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1r$[rsp]
  006a6	e8 00 00 00 00	 call	 s390_vstore8

; 988  : 
; 989  :         return 0;

  006ab	33 c0		 xor	 eax, eax
  006ad	eb 3b		 jmp	 SHORT $LN1@s390_plo_c

; 990  :     }

  006af	eb 39		 jmp	 SHORT $LN17@s390_plo_c
$LN16@s390_plo_c:

; 991  :     else
; 992  :     {
; 993  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  006b1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  006b8	83 c0 08	 add	 eax, 8
  006bb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c3	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  006c9	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  006d1	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  006d9	8b d0		 mov	 edx, eax
  006db	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op2$[rsp]
  006e0	e8 00 00 00 00	 call	 s390_vstore8

; 994  : 
; 995  :         return 1;

  006e5	b8 01 00 00 00	 mov	 eax, 1
$LN17@s390_plo_c:
$LN1@s390_plo_c:

; 996  :     }
; 997  : }

  006ea	48 83 c4 78	 add	 rsp, 120		; 00000078H
  006ee	c3		 ret	 0
s390_plo_csdstg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op6addr$ = 48
op4addr$ = 52
op6alet$ = 56
op4alet$ = 60
op2$ = 64
op3$ = 68
op5$ = 72
r1$ = 96
r3$ = 104
effective_addr2$ = 112
b2$ = 120
effective_addr4$ = 128
b4$ = 136
regs$ = 144
s390_plo_csdst PROC

; 819  : {

$LN38:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 820  : U32 op2,
; 821  :     op3,
; 822  :     op4alet = 0,

  00016	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0

; 823  :     op5,
; 824  :     op6alet = 0;

  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR op6alet$[rsp], 0

; 825  : VADR op4addr,
; 826  :     op6addr;
; 827  : 
; 828  :     ODD_CHECK(r1, regs);

  00026	8b 44 24 60	 mov	 eax, DWORD PTR r1$[rsp]
  0002a	83 e0 01	 and	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 1b		 je	 SHORT $LN11@s390_plo_c
  00031	ba 06 00 00 00	 mov	 edx, 6
  00036	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003e	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00046	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_plo_c:

; 829  :     FW_CHECK(effective_addr2, regs);

  0004c	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00050	83 e0 03	 and	 eax, 3
  00053	85 c0		 test	 eax, eax
  00055	74 1b		 je	 SHORT $LN12@s390_plo_c
  00057	ba 06 00 00 00	 mov	 edx, 6
  0005c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00064	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_plo_c:

; 830  :     FW_CHECK(effective_addr4, regs);

  00072	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00079	83 e0 03	 and	 eax, 3
  0007c	85 c0		 test	 eax, eax
  0007e	74 1b		 je	 SHORT $LN13@s390_plo_c
  00080	ba 06 00 00 00	 mov	 edx, 6
  00085	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00095	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@s390_plo_c:

; 831  : 
; 832  :     op2 = ARCH_DEP(vfetch4)(effective_addr2, b2, regs);

  0009b	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a3	8b 54 24 78	 mov	 edx, DWORD PTR b2$[rsp]
  000a7	8b 4c 24 70	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ab	e8 00 00 00 00	 call	 s390_vfetch4
  000b0	89 44 24 40	 mov	 DWORD PTR op2$[rsp], eax

; 833  :     op3 = ARCH_DEP(wfetch4)(effective_addr4 + 60, b4, regs);

  000b4	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000bb	83 c0 3c	 add	 eax, 60			; 0000003cH
  000be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c6	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000cc	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000d4	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  000db	8b c8		 mov	 ecx, eax
  000dd	e8 00 00 00 00	 call	 s390_vfetch4
  000e2	89 44 24 44	 mov	 DWORD PTR op3$[rsp], eax

; 834  :     op5 = ARCH_DEP(wfetch4)(effective_addr4 + 92, b4, regs);

  000e6	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000ed	83 c0 5c	 add	 eax, 92			; 0000005cH
  000f0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000fe	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00106	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0010d	8b c8		 mov	 ecx, eax
  0010f	e8 00 00 00 00	 call	 s390_vfetch4
  00114	89 44 24 48	 mov	 DWORD PTR op5$[rsp], eax

; 835  : 
; 836  :     if(regs->GR_L(r1) == op2)

  00118	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  0011d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00125	8b 54 24 40	 mov	 edx, DWORD PTR op2$[rsp]
  00129	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00130	0f 85 f0 04 00
	00		 jne	 $LN14@s390_plo_c

; 837  :     {
; 838  : 
; 839  :         /* Verify access to 2nd operand */
; 840  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  00136	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00143	41 b9 01 00 00
	00		 mov	 r9d, 1
  00149	41 b8 03 00 00
	00		 mov	 r8d, 3
  0014f	8b 54 24 78	 mov	 edx, DWORD PTR b2$[rsp]
  00153	8b 4c 24 70	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00157	e8 00 00 00 00	 call	 s390_validate_operand

; 841  :             ACCTYPE_WRITE_SKP, regs);
; 842  : 
; 843  :         /* When in ar mode, ar3 is used to access the
; 844  :            operand. The alet is fetched from the pl */
; 845  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0015c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00164	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00168	83 e0 04	 and	 eax, 4
  0016b	85 c0		 test	 eax, eax
  0016d	0f 84 5a 01 00
	00		 je	 $LN16@s390_plo_c
  00173	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0017b	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0017f	83 f8 40	 cmp	 eax, 64			; 00000040H
  00182	0f 85 45 01 00
	00		 jne	 $LN16@s390_plo_c

; 846  :         {
; 847  :             if(r3 == 0)

  00188	83 7c 24 68 00	 cmp	 DWORD PTR r3$[rsp], 0
  0018d	75 12		 jne	 SHORT $LN17@s390_plo_c

; 848  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0018f	ba 06 00 00 00	 mov	 edx, 6
  00194	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	e8 00 00 00 00	 call	 s390_program_interrupt
$LN17@s390_plo_c:

; 849  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001a1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  001a8	83 c0 44	 add	 eax, 68			; 00000044H
  001ab	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b3	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  001b9	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001c1	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001c8	8b c8		 mov	 ecx, eax
  001ca	e8 00 00 00 00	 call	 s390_vfetch4
  001cf	89 44 24 3c	 mov	 DWORD PTR op4alet$[rsp], eax

; 850  :             op6alet = ARCH_DEP(wfetch4)(effective_addr4 + 100, b4, regs);

  001d3	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  001da	83 c0 64	 add	 eax, 100		; 00000064H
  001dd	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e5	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  001eb	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001f3	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001fa	8b c8		 mov	 ecx, eax
  001fc	e8 00 00 00 00	 call	 s390_vfetch4
  00201	89 44 24 38	 mov	 DWORD PTR op6alet$[rsp], eax

; 851  :             regs->AR(r3) = op6alet;

  00205	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  0020a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	8b 54 24 38	 mov	 edx, DWORD PTR op6alet$[rsp]
  00216	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN4@s390_plo_c:

; 852  :             SET_AEA_AR(regs, r3);

  0021d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00225	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00229	83 f8 40	 cmp	 eax, 64			; 00000040H
  0022c	0f 85 91 00 00
	00		 jne	 $LN18@s390_plo_c
  00232	83 7c 24 68 00	 cmp	 DWORD PTR r3$[rsp], 0
  00237	0f 8e 86 00 00
	00		 jle	 $LN18@s390_plo_c
  0023d	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00242	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024a	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00252	75 1e		 jne	 SHORT $LN19@s390_plo_c
  00254	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  00258	83 c0 05	 add	 eax, 5
  0025b	48 98		 cdqe
  0025d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00265	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  00270	eb 51		 jmp	 SHORT $LN20@s390_plo_c
$LN19@s390_plo_c:
  00272	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00277	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027f	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00287	75 1e		 jne	 SHORT $LN21@s390_plo_c
  00289	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  0028d	83 c0 05	 add	 eax, 5
  00290	48 98		 cdqe
  00292	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029a	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  002a5	eb 1c		 jmp	 SHORT $LN22@s390_plo_c
$LN21@s390_plo_c:
  002a7	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  002ab	83 c0 05	 add	 eax, 5
  002ae	48 98		 cdqe
  002b0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b8	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN22@s390_plo_c:
$LN20@s390_plo_c:
$LN18@s390_plo_c:
  002c3	33 c0		 xor	 eax, eax
  002c5	85 c0		 test	 eax, eax
  002c7	0f 85 50 ff ff
	ff		 jne	 $LN4@s390_plo_c
$LN16@s390_plo_c:

; 853  :         }
; 854  : 
; 855  :         /* Load address of operand 4 */
; 856  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 857  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);
; 858  : #else
; 859  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);

  002cd	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  002d4	83 c0 4c	 add	 eax, 76			; 0000004cH
  002d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  002e5	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ed	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002f4	8b c8		 mov	 ecx, eax
  002f6	e8 00 00 00 00	 call	 s390_vfetch4
  002fb	89 44 24 34	 mov	 DWORD PTR op4addr$[rsp], eax

; 860  : #endif
; 861  :         op4addr &= ADDRESS_MAXWRAP(regs);

  002ff	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00307	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0030d	8b 4c 24 34	 mov	 ecx, DWORD PTR op4addr$[rsp]
  00311	23 c8		 and	 ecx, eax
  00313	8b c1		 mov	 eax, ecx
  00315	89 44 24 34	 mov	 DWORD PTR op4addr$[rsp], eax

; 862  :         FW_CHECK(op4addr, regs);

  00319	8b 44 24 34	 mov	 eax, DWORD PTR op4addr$[rsp]
  0031d	83 e0 03	 and	 eax, 3
  00320	85 c0		 test	 eax, eax
  00322	74 1b		 je	 SHORT $LN23@s390_plo_c
  00324	ba 06 00 00 00	 mov	 edx, 6
  00329	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00339	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN23@s390_plo_c:

; 863  : 
; 864  :         /* Load address of operand 6 */
; 865  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 866  :         op6addr = ARCH_DEP(wfetch8)(effective_addr4 + 104, b4, regs);
; 867  : #else
; 868  :         op6addr = ARCH_DEP(wfetch4)(effective_addr4 + 108, b4, regs);

  0033f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00346	83 c0 6c	 add	 eax, 108		; 0000006cH
  00349	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00351	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00357	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0035f	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00366	8b c8		 mov	 ecx, eax
  00368	e8 00 00 00 00	 call	 s390_vfetch4
  0036d	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 869  : #endif
; 870  :         op6addr &= ADDRESS_MAXWRAP(regs);

  00371	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00379	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0037f	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  00383	23 c8		 and	 ecx, eax
  00385	8b c1		 mov	 eax, ecx
  00387	89 44 24 30	 mov	 DWORD PTR op6addr$[rsp], eax

; 871  :         FW_CHECK(op6addr, regs);

  0038b	8b 44 24 30	 mov	 eax, DWORD PTR op6addr$[rsp]
  0038f	83 e0 03	 and	 eax, 3
  00392	85 c0		 test	 eax, eax
  00394	74 1b		 je	 SHORT $LN24@s390_plo_c
  00396	ba 06 00 00 00	 mov	 edx, 6
  0039b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ab	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN24@s390_plo_c:

; 872  : 
; 873  :         /* Verify access to 6th operand */
; 874  :         ARCH_DEP(validate_operand) (op6addr, r3, 4-1,ACCTYPE_WRITE_SKP, regs);

  003b1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003be	41 b9 01 00 00
	00		 mov	 r9d, 1
  003c4	41 b8 03 00 00
	00		 mov	 r8d, 3
  003ca	8b 54 24 68	 mov	 edx, DWORD PTR r3$[rsp]
  003ce	8b 4c 24 30	 mov	 ecx, DWORD PTR op6addr$[rsp]
  003d2	e8 00 00 00 00	 call	 s390_validate_operand

; 875  : 
; 876  :         /* Store 3th op at 4th op */
; 877  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  003d7	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003df	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  003e3	83 e0 04	 and	 eax, 4
  003e6	85 c0		 test	 eax, eax
  003e8	0f 84 dd 00 00
	00		 je	 $LN25@s390_plo_c
  003ee	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f6	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  003fa	83 f8 40	 cmp	 eax, 64			; 00000040H
  003fd	0f 85 c8 00 00
	00		 jne	 $LN25@s390_plo_c

; 878  :         {
; 879  :             regs->AR(r3) = op4alet;

  00403	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00408	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00410	8b 54 24 3c	 mov	 edx, DWORD PTR op4alet$[rsp]
  00414	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@s390_plo_c:

; 880  :             SET_AEA_AR(regs, r3);

  0041b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00423	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00427	83 f8 40	 cmp	 eax, 64			; 00000040H
  0042a	0f 85 91 00 00
	00		 jne	 $LN26@s390_plo_c
  00430	83 7c 24 68 00	 cmp	 DWORD PTR r3$[rsp], 0
  00435	0f 8e 86 00 00
	00		 jle	 $LN26@s390_plo_c
  0043b	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00440	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00448	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00450	75 1e		 jne	 SHORT $LN27@s390_plo_c
  00452	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  00456	83 c0 05	 add	 eax, 5
  00459	48 98		 cdqe
  0045b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00463	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0046e	eb 51		 jmp	 SHORT $LN28@s390_plo_c
$LN27@s390_plo_c:
  00470	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00475	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047d	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00485	75 1e		 jne	 SHORT $LN29@s390_plo_c
  00487	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  0048b	83 c0 05	 add	 eax, 5
  0048e	48 98		 cdqe
  00490	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00498	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  004a3	eb 1c		 jmp	 SHORT $LN30@s390_plo_c
$LN29@s390_plo_c:
  004a5	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  004a9	83 c0 05	 add	 eax, 5
  004ac	48 98		 cdqe
  004ae	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b6	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN30@s390_plo_c:
$LN28@s390_plo_c:
$LN26@s390_plo_c:
  004c1	33 c0		 xor	 eax, eax
  004c3	85 c0		 test	 eax, eax
  004c5	0f 85 50 ff ff
	ff		 jne	 $LN7@s390_plo_c
$LN25@s390_plo_c:

; 881  :         }
; 882  :         ARCH_DEP(vstore4)(op3, op4addr, r3, regs);

  004cb	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004d3	44 8b 44 24 68	 mov	 r8d, DWORD PTR r3$[rsp]
  004d8	8b 54 24 34	 mov	 edx, DWORD PTR op4addr$[rsp]
  004dc	8b 4c 24 44	 mov	 ecx, DWORD PTR op3$[rsp]
  004e0	e8 00 00 00 00	 call	 s390_vstore4

; 883  : 
; 884  :         /* Store 5th op at 6th op */
; 885  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  004e5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ed	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  004f1	83 e0 04	 and	 eax, 4
  004f4	85 c0		 test	 eax, eax
  004f6	0f 84 dd 00 00
	00		 je	 $LN31@s390_plo_c
  004fc	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00504	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00508	83 f8 40	 cmp	 eax, 64			; 00000040H
  0050b	0f 85 c8 00 00
	00		 jne	 $LN31@s390_plo_c

; 886  :         {
; 887  :             regs->AR(r3) = op6alet;

  00511	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00516	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051e	8b 54 24 38	 mov	 edx, DWORD PTR op6alet$[rsp]
  00522	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN10@s390_plo_c:

; 888  :             SET_AEA_AR(regs, r3);

  00529	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00531	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00535	83 f8 40	 cmp	 eax, 64			; 00000040H
  00538	0f 85 91 00 00
	00		 jne	 $LN32@s390_plo_c
  0053e	83 7c 24 68 00	 cmp	 DWORD PTR r3$[rsp], 0
  00543	0f 8e 86 00 00
	00		 jle	 $LN32@s390_plo_c
  00549	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  0054e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00556	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0055e	75 1e		 jne	 SHORT $LN33@s390_plo_c
  00560	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  00564	83 c0 05	 add	 eax, 5
  00567	48 98		 cdqe
  00569	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00571	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0057c	eb 51		 jmp	 SHORT $LN34@s390_plo_c
$LN33@s390_plo_c:
  0057e	48 63 44 24 68	 movsxd	 rax, DWORD PTR r3$[rsp]
  00583	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0058b	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00593	75 1e		 jne	 SHORT $LN35@s390_plo_c
  00595	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  00599	83 c0 05	 add	 eax, 5
  0059c	48 98		 cdqe
  0059e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a6	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  005b1	eb 1c		 jmp	 SHORT $LN36@s390_plo_c
$LN35@s390_plo_c:
  005b3	8b 44 24 68	 mov	 eax, DWORD PTR r3$[rsp]
  005b7	83 c0 05	 add	 eax, 5
  005ba	48 98		 cdqe
  005bc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c4	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN36@s390_plo_c:
$LN34@s390_plo_c:
$LN32@s390_plo_c:
  005cf	33 c0		 xor	 eax, eax
  005d1	85 c0		 test	 eax, eax
  005d3	0f 85 50 ff ff
	ff		 jne	 $LN10@s390_plo_c
$LN31@s390_plo_c:

; 889  :         }
; 890  :         ARCH_DEP(vstore4)(op5, op6addr, r3, regs);

  005d9	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  005e1	44 8b 44 24 68	 mov	 r8d, DWORD PTR r3$[rsp]
  005e6	8b 54 24 30	 mov	 edx, DWORD PTR op6addr$[rsp]
  005ea	8b 4c 24 48	 mov	 ecx, DWORD PTR op5$[rsp]
  005ee	e8 00 00 00 00	 call	 s390_vstore4

; 891  : 
; 892  :         /* Store 1st op at 2nd op */
; 893  :         ARCH_DEP(vstore4)(regs->GR_L(r1+1), effective_addr2, b2, regs);

  005f3	8b 44 24 60	 mov	 eax, DWORD PTR r1$[rsp]
  005f7	ff c0		 inc	 eax
  005f9	48 98		 cdqe
  005fb	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00603	44 8b 44 24 78	 mov	 r8d, DWORD PTR b2$[rsp]
  00608	8b 54 24 70	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0060c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00614	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0061b	e8 00 00 00 00	 call	 s390_vstore4

; 894  : 
; 895  :         return 0;

  00620	33 c0		 xor	 eax, eax
  00622	eb 1f		 jmp	 SHORT $LN1@s390_plo_c

; 896  :     }

  00624	eb 1d		 jmp	 SHORT $LN15@s390_plo_c
$LN14@s390_plo_c:

; 897  :     else
; 898  :     {
; 899  :         regs->GR_L(r1) = op2;

  00626	48 63 44 24 60	 movsxd	 rax, DWORD PTR r1$[rsp]
  0062b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00633	8b 54 24 40	 mov	 edx, DWORD PTR op2$[rsp]
  00637	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 900  : 
; 901  :         return 1;

  0063e	b8 01 00 00 00	 mov	 eax, 1
$LN15@s390_plo_c:
$LN1@s390_plo_c:

; 902  :     }
; 903  : }

  00643	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00647	c3		 ret	 0
s390_plo_csdst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4addr$ = 48
op4alet$ = 52
op2$ = 56
op1c$ = 64
op3$ = 72
op1r$ = 80
r1$ = 112
r3$ = 120
effective_addr2$ = 128
b2$ = 136
effective_addr4$ = 144
b4$ = 152
regs$ = 160
s390_plo_csstg PROC

; 658  : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 659  : U64 op1c,
; 660  :     op1r,
; 661  :     op2,
; 662  :     op3;
; 663  : U32 op4alet = 0;

  00016	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@s390_plo_c:

; 664  : VADR op4addr;
; 665  : 
; 666  :     UNREFERENCED(r1);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@s390_plo_c

; 667  : 
; 668  :     DW_CHECK(effective_addr2, regs);

  00024	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0002b	83 e0 07	 and	 eax, 7
  0002e	85 c0		 test	 eax, eax
  00030	74 1b		 je	 SHORT $LN8@s390_plo_c
  00032	ba 06 00 00 00	 mov	 edx, 6
  00037	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00047	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_plo_c:

; 669  :     DW_CHECK(effective_addr4, regs);

  0004d	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00054	83 e0 07	 and	 eax, 7
  00057	85 c0		 test	 eax, eax
  00059	74 1b		 je	 SHORT $LN9@s390_plo_c
  0005b	ba 06 00 00 00	 mov	 edx, 6
  00060	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00070	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_plo_c:

; 670  : 
; 671  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  00076	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0007d	83 c0 08	 add	 eax, 8
  00080	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0008e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00096	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 s390_vfetch8
  000a4	48 89 44 24 40	 mov	 QWORD PTR op1c$[rsp], rax

; 672  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000a9	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000b1	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000b8	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bf	e8 00 00 00 00	 call	 s390_vfetch8
  000c4	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 673  : 
; 674  :     if(op1c == op2)

  000c9	48 8b 44 24 38	 mov	 rax, QWORD PTR op2$[rsp]
  000ce	48 39 44 24 40	 cmp	 QWORD PTR op1c$[rsp], rax
  000d3	0f 85 85 02 00
	00		 jne	 $LN10@s390_plo_c

; 675  :     {
; 676  :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000d9	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000e0	83 c0 18	 add	 eax, 24
  000e3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000eb	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000f1	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000f9	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00100	8b c8		 mov	 ecx, eax
  00102	e8 00 00 00 00	 call	 s390_vfetch8
  00107	48 89 44 24 50	 mov	 QWORD PTR op1r$[rsp], rax

; 677  :         op3 = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  0010c	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00113	83 c0 38	 add	 eax, 56			; 00000038H
  00116	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00124	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0012c	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  00133	8b c8		 mov	 ecx, eax
  00135	e8 00 00 00 00	 call	 s390_vfetch8
  0013a	48 89 44 24 48	 mov	 QWORD PTR op3$[rsp], rax

; 678  : 
; 679  :         /* Verify access to 2nd operand */
; 680  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  0013f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00147	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0014c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00152	41 b8 07 00 00
	00		 mov	 r8d, 7
  00158	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  0015f	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00166	e8 00 00 00 00	 call	 s390_validate_operand

; 681  :             ACCTYPE_WRITE_SKP, regs);
; 682  : 
; 683  :         /* When in ar mode, ar3 is used to access the
; 684  :            operand. The alet is fetched from the pl */
; 685  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0016b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00177	83 e0 04	 and	 eax, 4
  0017a	85 c0		 test	 eax, eax
  0017c	0f 84 28 01 00
	00		 je	 $LN12@s390_plo_c
  00182	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0018a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0018e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00191	0f 85 13 01 00
	00		 jne	 $LN12@s390_plo_c

; 686  :         {
; 687  :             if(r3 == 0)

  00197	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  0019c	75 12		 jne	 SHORT $LN13@s390_plo_c

; 688  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0019e	ba 06 00 00 00	 mov	 edx, 6
  001a3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ab	e8 00 00 00 00	 call	 s390_program_interrupt
$LN13@s390_plo_c:

; 689  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  001b0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  001b7	83 c0 44	 add	 eax, 68			; 00000044H
  001ba	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c2	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  001c8	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001d0	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001d7	8b c8		 mov	 ecx, eax
  001d9	e8 00 00 00 00	 call	 s390_vfetch4
  001de	89 44 24 34	 mov	 DWORD PTR op4alet$[rsp], eax

; 690  :             regs->AR(r3) = op4alet;

  001e2	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  001e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ef	8b 54 24 34	 mov	 edx, DWORD PTR op4alet$[rsp]
  001f3	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@s390_plo_c:

; 691  :             SET_AEA_AR(regs, r3);

  001fa	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  00206	83 f8 40	 cmp	 eax, 64			; 00000040H
  00209	0f 85 91 00 00
	00		 jne	 $LN14@s390_plo_c
  0020f	83 7c 24 78 00	 cmp	 DWORD PTR r3$[rsp], 0
  00214	0f 8e 86 00 00
	00		 jle	 $LN14@s390_plo_c
  0021a	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  0021f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00227	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0022f	75 1e		 jne	 SHORT $LN15@s390_plo_c
  00231	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00235	83 c0 05	 add	 eax, 5
  00238	48 98		 cdqe
  0023a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00242	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0024d	eb 51		 jmp	 SHORT $LN16@s390_plo_c
$LN15@s390_plo_c:
  0024f	48 63 44 24 78	 movsxd	 rax, DWORD PTR r3$[rsp]
  00254	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025c	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00264	75 1e		 jne	 SHORT $LN17@s390_plo_c
  00266	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  0026a	83 c0 05	 add	 eax, 5
  0026d	48 98		 cdqe
  0026f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00277	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00282	eb 1c		 jmp	 SHORT $LN18@s390_plo_c
$LN17@s390_plo_c:
  00284	8b 44 24 78	 mov	 eax, DWORD PTR r3$[rsp]
  00288	83 c0 05	 add	 eax, 5
  0028b	48 98		 cdqe
  0028d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00295	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@s390_plo_c:
$LN16@s390_plo_c:
$LN14@s390_plo_c:
  002a0	33 c0		 xor	 eax, eax
  002a2	85 c0		 test	 eax, eax
  002a4	0f 85 50 ff ff
	ff		 jne	 $LN7@s390_plo_c
$LN12@s390_plo_c:

; 692  :         }
; 693  : 
; 694  :         /* Load address of operand 4 */
; 695  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 696  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);
; 697  : #else
; 698  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);

  002aa	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  002b1	83 c0 4c	 add	 eax, 76			; 0000004cH
  002b4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bc	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  002c2	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002ca	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002d1	8b c8		 mov	 ecx, eax
  002d3	e8 00 00 00 00	 call	 s390_vfetch4
  002d8	89 44 24 30	 mov	 DWORD PTR op4addr$[rsp], eax

; 699  : #endif
; 700  :         op4addr &= ADDRESS_MAXWRAP(regs);

  002dc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e4	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  002ea	8b 4c 24 30	 mov	 ecx, DWORD PTR op4addr$[rsp]
  002ee	23 c8		 and	 ecx, eax
  002f0	8b c1		 mov	 eax, ecx
  002f2	89 44 24 30	 mov	 DWORD PTR op4addr$[rsp], eax

; 701  :         DW_CHECK(op4addr, regs);

  002f6	8b 44 24 30	 mov	 eax, DWORD PTR op4addr$[rsp]
  002fa	83 e0 07	 and	 eax, 7
  002fd	85 c0		 test	 eax, eax
  002ff	74 1b		 je	 SHORT $LN19@s390_plo_c
  00301	ba 06 00 00 00	 mov	 edx, 6
  00306	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00316	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_plo_c:

; 702  : 
; 703  :         ARCH_DEP(vstore8)(op3, op4addr, r3, regs);

  0031c	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00324	44 8b 44 24 78	 mov	 r8d, DWORD PTR r3$[rsp]
  00329	8b 54 24 30	 mov	 edx, DWORD PTR op4addr$[rsp]
  0032d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR op3$[rsp]
  00332	e8 00 00 00 00	 call	 s390_vstore8

; 704  :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  00337	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0033f	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  00347	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR effective_addr2$[rsp]
  0034e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR op1r$[rsp]
  00353	e8 00 00 00 00	 call	 s390_vstore8

; 705  : 
; 706  :         return 0;

  00358	33 c0		 xor	 eax, eax
  0035a	eb 3b		 jmp	 SHORT $LN1@s390_plo_c

; 707  :     }

  0035c	eb 39		 jmp	 SHORT $LN11@s390_plo_c
$LN10@s390_plo_c:

; 708  :     else
; 709  :     {
; 710  :         /* Store 2nd op at 1st op comare value */
; 711  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  0035e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00365	83 c0 08	 add	 eax, 8
  00368	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00370	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00376	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0037e	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  00386	8b d0		 mov	 edx, eax
  00388	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  0038d	e8 00 00 00 00	 call	 s390_vstore8

; 712  : 
; 713  :         return 1;

  00392	b8 01 00 00 00	 mov	 eax, 1
$LN11@s390_plo_c:
$LN1@s390_plo_c:

; 714  :     }
; 715  : 
; 716  : }

  00397	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0039b	c3		 ret	 0
s390_plo_csstg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 48
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
s390_plo_csst PROC

; 623  : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 624  : U32 op2;
; 625  : 
; 626  :     ODD_CHECK(r1, regs);

  00016	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	74 1b		 je	 SHORT $LN2@s390_plo_c
  00021	ba 06 00 00 00	 mov	 edx, 6
  00026	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00036	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s390_plo_c:

; 627  :     FW_CHECK(effective_addr2, regs);

  0003c	8b 44 24 60	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  00040	83 e0 03	 and	 eax, 3
  00043	85 c0		 test	 eax, eax
  00045	74 1b		 je	 SHORT $LN3@s390_plo_c
  00047	ba 06 00 00 00	 mov	 edx, 6
  0004c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005c	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN3@s390_plo_c:

; 628  :     FW_CHECK(effective_addr4, regs);

  00062	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00066	83 e0 03	 and	 eax, 3
  00069	85 c0		 test	 eax, eax
  0006b	74 1b		 je	 SHORT $LN4@s390_plo_c
  0006d	ba 06 00 00 00	 mov	 edx, 6
  00072	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00082	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@s390_plo_c:

; 629  : 
; 630  :     /* Load second operand from operand address  */
; 631  :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00088	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00090	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  00094	8b 4c 24 60	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00098	e8 00 00 00 00	 call	 s390_vfetch4
  0009d	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 632  : 
; 633  :     /* Compare operand with register contents */
; 634  :     if ( regs->GR_L(r1) == op2)

  000a1	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000a6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  000b2	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  000b9	0f 85 83 00 00
	00		 jne	 $LN5@s390_plo_c

; 635  :     {
; 636  :         /* Verify access to 2nd operand */
; 637  :         ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  000bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cc	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d2	41 b8 03 00 00
	00		 mov	 r8d, 3
  000d8	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  000dc	8b 4c 24 60	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000e0	e8 00 00 00 00	 call	 s390_validate_operand

; 638  :             ACCTYPE_WRITE_SKP, regs);
; 639  : 
; 640  :         /* If equal, store replacement and set cc=0 */
; 641  :         ARCH_DEP(vstore4) ( regs->GR_L(r3), effective_addr4, b4, regs );

  000e5	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  000ea	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f2	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  000f7	8b 54 24 70	 mov	 edx, DWORD PTR effective_addr4$[rsp]
  000fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00103	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  0010a	e8 00 00 00 00	 call	 s390_vstore4

; 642  :         ARCH_DEP(vstore4) ( regs->GR_L(r1+1), effective_addr2, b2, regs );

  0010f	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  00113	ff c0		 inc	 eax
  00115	48 98		 cdqe
  00117	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0011f	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  00124	8b 54 24 60	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00128	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00130	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00137	e8 00 00 00 00	 call	 s390_vstore4

; 643  : 
; 644  :         return 0;

  0013c	33 c0		 xor	 eax, eax
  0013e	eb 1f		 jmp	 SHORT $LN1@s390_plo_c

; 645  :     }

  00140	eb 1d		 jmp	 SHORT $LN6@s390_plo_c
$LN5@s390_plo_c:

; 646  :     else
; 647  :     {
; 648  :         regs->GR_L(r1) = op2;

  00142	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  00147	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0014f	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  00153	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 649  : 
; 650  :         return 1;

  0015a	b8 01 00 00 00	 mov	 eax, 1
$LN6@s390_plo_c:
$LN1@s390_plo_c:

; 651  :     }
; 652  : 
; 653  : }

  0015f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00163	c3		 ret	 0
s390_plo_csst ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4addr$ = 48
op4alet$ = 52
op2$ = 56
op4$ = 64
op1c$ = 72
op3c$ = 80
op3r$ = 88
op1r$ = 96
r1$ = 128
r3$ = 136
effective_addr2$ = 144
b2$ = 152
effective_addr4$ = 160
b4$ = 168
regs$ = 176
s390_plo_dcsg PROC

; 401  : {

$LN23:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 402  : U64 op1c,
; 403  :     op1r,
; 404  :     op2,
; 405  :     op3c,
; 406  :     op3r,
; 407  :     op4;
; 408  : U32 op4alet = 0;

  00016	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@s390_plo_d:

; 409  : VADR op4addr;
; 410  : 
; 411  :     UNREFERENCED(r1);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@s390_plo_d

; 412  : 
; 413  :     DW_CHECK(effective_addr2, regs);

  00024	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0002b	83 e0 07	 and	 eax, 7
  0002e	85 c0		 test	 eax, eax
  00030	74 1b		 je	 SHORT $LN8@s390_plo_d
  00032	ba 06 00 00 00	 mov	 edx, 6
  00037	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00047	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_plo_d:

; 414  :     DW_CHECK(effective_addr4, regs);

  0004d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00054	83 e0 07	 and	 eax, 7
  00057	85 c0		 test	 eax, eax
  00059	74 1b		 je	 SHORT $LN9@s390_plo_d
  0005b	ba 06 00 00 00	 mov	 edx, 6
  00060	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00070	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_plo_d:

; 415  : 
; 416  :     /* load 1st op compare value from the pl */
; 417  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  00076	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0007d	83 c0 08	 add	 eax, 8
  00080	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0008e	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00096	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 s390_vfetch8
  000a4	48 89 44 24 48	 mov	 QWORD PTR op1c$[rsp], rax

; 418  : 
; 419  :     /* load 2nd operand */
; 420  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  000a9	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000b1	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  000b8	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000bf	e8 00 00 00 00	 call	 s390_vfetch8
  000c4	48 89 44 24 38	 mov	 QWORD PTR op2$[rsp], rax

; 421  : 
; 422  :     if(op1c != op2)

  000c9	48 8b 44 24 38	 mov	 rax, QWORD PTR op2$[rsp]
  000ce	48 39 44 24 48	 cmp	 QWORD PTR op1c$[rsp], rax
  000d3	74 43		 je	 SHORT $LN10@s390_plo_d

; 423  :     {
; 424  :         /* replace the 1st op compare value with 2nd op */
; 425  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  000d5	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000dc	83 c0 08	 add	 eax, 8
  000df	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000ed	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f5	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  000fd	8b d0		 mov	 edx, eax
  000ff	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op2$[rsp]
  00104	e8 00 00 00 00	 call	 s390_vstore8

; 426  : 
; 427  :         return 1;

  00109	b8 01 00 00 00	 mov	 eax, 1
  0010e	e9 40 03 00 00	 jmp	 $LN1@s390_plo_d

; 428  :     }

  00113	e9 3b 03 00 00	 jmp	 $LN11@s390_plo_d
$LN10@s390_plo_d:

; 429  :     else
; 430  :     {
; 431  :         /* Load 3rd op compare value */
; 432  :         op3c = ARCH_DEP(wfetch8)(effective_addr4 + 40, b4, regs);

  00118	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0011f	83 c0 28	 add	 eax, 40			; 00000028H
  00122	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012a	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00130	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00138	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  0013f	8b c8		 mov	 ecx, eax
  00141	e8 00 00 00 00	 call	 s390_vfetch8
  00146	48 89 44 24 50	 mov	 QWORD PTR op3c$[rsp], rax

; 433  : 
; 434  :         /* When in ar mode, ar3 is used to access the
; 435  :            operand. The alet is fetched from the pl */
; 436  :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  0014b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00153	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  00157	83 e0 04	 and	 eax, 4
  0015a	85 c0		 test	 eax, eax
  0015c	0f 84 40 01 00
	00		 je	 $LN12@s390_plo_d
  00162	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016a	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0016e	83 f8 40	 cmp	 eax, 64			; 00000040H
  00171	0f 85 2b 01 00
	00		 jne	 $LN12@s390_plo_d

; 437  :         {
; 438  :             if(r3 == 0)

  00177	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  0017f	75 12		 jne	 SHORT $LN13@s390_plo_d

; 439  :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00181	ba 06 00 00 00	 mov	 edx, 6
  00186	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018e	e8 00 00 00 00	 call	 s390_program_interrupt
$LN13@s390_plo_d:

; 440  :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  00193	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0019a	83 c0 44	 add	 eax, 68			; 00000044H
  0019d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  001ab	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  001b3	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  001ba	8b c8		 mov	 ecx, eax
  001bc	e8 00 00 00 00	 call	 s390_vfetch4
  001c1	89 44 24 34	 mov	 DWORD PTR op4alet$[rsp], eax

; 441  :             regs->AR(r3) = op4alet;

  001c5	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  001cd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d5	8b 54 24 34	 mov	 edx, DWORD PTR op4alet$[rsp]
  001d9	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@s390_plo_d:

; 442  :             SET_AEA_AR(regs, r3);

  001e0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e8	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  001ec	83 f8 40	 cmp	 eax, 64			; 00000040H
  001ef	0f 85 a3 00 00
	00		 jne	 $LN14@s390_plo_d
  001f5	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR r3$[rsp], 0
  001fd	0f 8e 95 00 00
	00		 jle	 $LN14@s390_plo_d
  00203	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0020b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  0021b	75 21		 jne	 SHORT $LN15@s390_plo_d
  0021d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00224	83 c0 05	 add	 eax, 5
  00227	48 98		 cdqe
  00229	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  0023c	eb 5a		 jmp	 SHORT $LN16@s390_plo_d
$LN15@s390_plo_d:
  0023e	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00246	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0024e	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  00256	75 21		 jne	 SHORT $LN17@s390_plo_d
  00258	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  0025f	83 c0 05	 add	 eax, 5
  00262	48 98		 cdqe
  00264	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  00277	eb 1f		 jmp	 SHORT $LN18@s390_plo_d
$LN17@s390_plo_d:
  00279	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00280	83 c0 05	 add	 eax, 5
  00283	48 98		 cdqe
  00285	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028d	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@s390_plo_d:
$LN16@s390_plo_d:
$LN14@s390_plo_d:
  00298	33 c0		 xor	 eax, eax
  0029a	85 c0		 test	 eax, eax
  0029c	0f 85 3e ff ff
	ff		 jne	 $LN7@s390_plo_d
$LN12@s390_plo_d:

; 443  :         }
; 444  : 
; 445  :         /* Load address of operand 4 */
; 446  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 447  :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);
; 448  : #else
; 449  :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);

  002a2	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  002a9	83 c0 4c	 add	 eax, 76			; 0000004cH
  002ac	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  002ba	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  002c2	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  002c9	8b c8		 mov	 ecx, eax
  002cb	e8 00 00 00 00	 call	 s390_vfetch4
  002d0	89 44 24 30	 mov	 DWORD PTR op4addr$[rsp], eax

; 450  : #endif
; 451  :         op4addr &= ADDRESS_MAXWRAP(regs);

  002d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002dc	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  002e2	8b 4c 24 30	 mov	 ecx, DWORD PTR op4addr$[rsp]
  002e6	23 c8		 and	 ecx, eax
  002e8	8b c1		 mov	 eax, ecx
  002ea	89 44 24 30	 mov	 DWORD PTR op4addr$[rsp], eax

; 452  :         DW_CHECK(op4addr, regs);

  002ee	8b 44 24 30	 mov	 eax, DWORD PTR op4addr$[rsp]
  002f2	83 e0 07	 and	 eax, 7
  002f5	85 c0		 test	 eax, eax
  002f7	74 1b		 je	 SHORT $LN19@s390_plo_d
  002f9	ba 06 00 00 00	 mov	 edx, 6
  002fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00306	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0030e	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_plo_d:

; 453  : 
; 454  :         /* Load operand 4, using ar3 when in ar mode */
; 455  :         op4 = ARCH_DEP(vfetch8)(op4addr, r3, regs);

  00314	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0031c	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR r3$[rsp]
  00323	8b 4c 24 30	 mov	 ecx, DWORD PTR op4addr$[rsp]
  00327	e8 00 00 00 00	 call	 s390_vfetch8
  0032c	48 89 44 24 40	 mov	 QWORD PTR op4$[rsp], rax

; 456  : 
; 457  :         if(op3c != op4)

  00331	48 8b 44 24 40	 mov	 rax, QWORD PTR op4$[rsp]
  00336	48 39 44 24 50	 cmp	 QWORD PTR op3c$[rsp], rax
  0033b	74 43		 je	 SHORT $LN20@s390_plo_d

; 458  :         {
; 459  :             ARCH_DEP(wstore8)(op4, effective_addr4 + 40, b4, regs);

  0033d	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00344	83 c0 28	 add	 eax, 40			; 00000028H
  00347	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034f	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00355	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0035d	44 8b 84 24 a8
	00 00 00	 mov	 r8d, DWORD PTR b4$[rsp]
  00365	8b d0		 mov	 edx, eax
  00367	48 8b 4c 24 40	 mov	 rcx, QWORD PTR op4$[rsp]
  0036c	e8 00 00 00 00	 call	 s390_vstore8

; 460  : 
; 461  :             return 2;

  00371	b8 02 00 00 00	 mov	 eax, 2
  00376	e9 d8 00 00 00	 jmp	 $LN1@s390_plo_d

; 462  :         }

  0037b	e9 d3 00 00 00	 jmp	 $LN21@s390_plo_d
$LN20@s390_plo_d:

; 463  :         else
; 464  :         {
; 465  :             /* load replacement values */
; 466  :             op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  00380	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00387	83 c0 18	 add	 eax, 24
  0038a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00392	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00398	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003a0	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003a7	8b c8		 mov	 ecx, eax
  003a9	e8 00 00 00 00	 call	 s390_vfetch8
  003ae	48 89 44 24 60	 mov	 QWORD PTR op1r$[rsp], rax

; 467  :             op3r = ARCH_DEP(wfetch8)(effective_addr4 + 56, b4, regs);

  003b3	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR effective_addr4$[rsp]
  003ba	83 c0 38	 add	 eax, 56			; 00000038H
  003bd	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c5	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  003cb	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d3	8b 94 24 a8 00
	00 00		 mov	 edx, DWORD PTR b4$[rsp]
  003da	8b c8		 mov	 ecx, eax
  003dc	e8 00 00 00 00	 call	 s390_vfetch8
  003e1	48 89 44 24 58	 mov	 QWORD PTR op3r$[rsp], rax

; 468  : 
; 469  :             /* Verify access to 2nd operand */
; 470  :             ARCH_DEP(validate_operand) (effective_addr2, b2, 8-1,

  003e6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003f3	41 b9 01 00 00
	00		 mov	 r9d, 1
  003f9	41 b8 07 00 00
	00		 mov	 r8d, 7
  003ff	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR b2$[rsp]
  00406	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  0040d	e8 00 00 00 00	 call	 s390_validate_operand

; 471  :                 ACCTYPE_WRITE_SKP, regs);
; 472  : 
; 473  :             /* Store 3rd op replacement at 4th op */
; 474  :             ARCH_DEP(vstore8)(op3r, op4addr, r3, regs);

  00412	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0041a	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR r3$[rsp]
  00422	8b 54 24 30	 mov	 edx, DWORD PTR op4addr$[rsp]
  00426	48 8b 4c 24 58	 mov	 rcx, QWORD PTR op3r$[rsp]
  0042b	e8 00 00 00 00	 call	 s390_vstore8

; 475  : 
; 476  :             /* Store 1st op replacement at 2nd op */
; 477  :             ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  00430	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00438	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR b2$[rsp]
  00440	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR effective_addr2$[rsp]
  00447	48 8b 4c 24 60	 mov	 rcx, QWORD PTR op1r$[rsp]
  0044c	e8 00 00 00 00	 call	 s390_vstore8

; 478  : 
; 479  :             return 0;

  00451	33 c0		 xor	 eax, eax
$LN21@s390_plo_d:
$LN11@s390_plo_d:
$LN1@s390_plo_d:

; 480  :         }
; 481  :     }
; 482  : 
; 483  : }

  00453	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00457	c3		 ret	 0
s390_plo_dcsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 48
op4$ = 52
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
s390_plo_dcs PROC

; 353  : {

$LN11:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 354  : U32 op2,
; 355  :     op4;
; 356  : 
; 357  :     ODD2_CHECK(r1, r3, regs);

  00016	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0001a	83 e0 01	 and	 eax, 1
  0001d	85 c0		 test	 eax, eax
  0001f	75 0b		 jne	 SHORT $LN3@s390_plo_d
  00021	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  00025	83 e0 01	 and	 eax, 1
  00028	85 c0		 test	 eax, eax
  0002a	74 1b		 je	 SHORT $LN2@s390_plo_d
$LN3@s390_plo_d:
  0002c	ba 06 00 00 00	 mov	 edx, 6
  00031	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00041	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s390_plo_d:

; 358  :     FW_CHECK(effective_addr2, regs);

  00047	8b 44 24 60	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0004b	83 e0 03	 and	 eax, 3
  0004e	85 c0		 test	 eax, eax
  00050	74 1b		 je	 SHORT $LN4@s390_plo_d
  00052	ba 06 00 00 00	 mov	 edx, 6
  00057	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00067	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN4@s390_plo_d:

; 359  :     FW_CHECK(effective_addr4, regs);

  0006d	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00071	83 e0 03	 and	 eax, 3
  00074	85 c0		 test	 eax, eax
  00076	74 1b		 je	 SHORT $LN5@s390_plo_d
  00078	ba 06 00 00 00	 mov	 edx, 6
  0007d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00085	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0008d	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN5@s390_plo_d:

; 360  : 
; 361  :     /* Load second operands from operand addresses  */
; 362  :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00093	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0009b	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  0009f	8b 4c 24 60	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_vfetch4
  000a8	89 44 24 30	 mov	 DWORD PTR op2$[rsp], eax

; 363  : 
; 364  :     if(regs->GR_L(r1) != op2)

  000ac	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  000bd	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  000c4	74 27		 je	 SHORT $LN6@s390_plo_d

; 365  :     {
; 366  :         regs->GR_L(r1) = op2;

  000c6	48 63 44 24 50	 movsxd	 rax, DWORD PTR r1$[rsp]
  000cb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d3	8b 54 24 30	 mov	 edx, DWORD PTR op2$[rsp]
  000d7	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 367  : 
; 368  :         return 1;

  000de	b8 01 00 00 00	 mov	 eax, 1
  000e3	e9 e1 00 00 00	 jmp	 $LN1@s390_plo_d

; 369  :     }

  000e8	e9 dc 00 00 00	 jmp	 $LN7@s390_plo_d
$LN6@s390_plo_d:

; 370  :     else
; 371  :     {
; 372  :         op4 = ARCH_DEP(vfetch4) ( effective_addr4, b4, regs );

  000ed	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000f5	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  000f9	8b 4c 24 70	 mov	 ecx, DWORD PTR effective_addr4$[rsp]
  000fd	e8 00 00 00 00	 call	 s390_vfetch4
  00102	89 44 24 34	 mov	 DWORD PTR op4$[rsp], eax

; 373  : 
; 374  :         /* Compare operand with register contents */
; 375  :         if (regs->GR_L(r3) != op4)

  00106	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  0010b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	8b 54 24 34	 mov	 edx, DWORD PTR op4$[rsp]
  00117	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  0011e	74 27		 je	 SHORT $LN8@s390_plo_d

; 376  :         {
; 377  :             /* If unequal, load r3 from op and set cc=2 */
; 378  :             regs->GR_L(r3) = op4;

  00120	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  00125	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012d	8b 54 24 34	 mov	 edx, DWORD PTR op4$[rsp]
  00131	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 379  : 
; 380  :             return 2;

  00138	b8 02 00 00 00	 mov	 eax, 2
  0013d	e9 87 00 00 00	 jmp	 $LN1@s390_plo_d

; 381  :         }

  00142	e9 82 00 00 00	 jmp	 $LN9@s390_plo_d
$LN8@s390_plo_d:

; 382  :         else
; 383  :         {
; 384  :             /* Verify access to 2nd operand */
; 385  :             ARCH_DEP(validate_operand) (effective_addr2, b2, 4-1,

  00147	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0014f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00154	41 b9 01 00 00
	00		 mov	 r9d, 1
  0015a	41 b8 03 00 00
	00		 mov	 r8d, 3
  00160	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  00164	8b 4c 24 60	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00168	e8 00 00 00 00	 call	 s390_validate_operand

; 386  :                 ACCTYPE_WRITE_SKP, regs);
; 387  : 
; 388  :             /* If equal, store replacement and set cc=0 */
; 389  :             ARCH_DEP(vstore4) ( regs->GR_L(r3+1), effective_addr4, b4, regs );

  0016d	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  00171	ff c0		 inc	 eax
  00173	48 98		 cdqe
  00175	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  00182	8b 54 24 70	 mov	 edx, DWORD PTR effective_addr4$[rsp]
  00186	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018e	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00195	e8 00 00 00 00	 call	 s390_vstore4

; 390  :             ARCH_DEP(vstore4) ( regs->GR_L(r1+1), effective_addr2, b2, regs );

  0019a	8b 44 24 50	 mov	 eax, DWORD PTR r1$[rsp]
  0019e	ff c0		 inc	 eax
  001a0	48 98		 cdqe
  001a2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001aa	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  001af	8b 54 24 60	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  001b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bb	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  001c2	e8 00 00 00 00	 call	 s390_vstore4

; 391  : 
; 392  :             return 0;

  001c7	33 c0		 xor	 eax, eax
$LN9@s390_plo_d:
$LN7@s390_plo_d:
$LN1@s390_plo_d:

; 393  :         }
; 394  :     }
; 395  : 
; 396  : }

  001c9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001cd	c3		 ret	 0
s390_plo_dcs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
op1c$ = 40
op1r$ = 48
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
s390_plo_csg PROC

; 237  : {

$LN13:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_plo_c:

; 238  : U64 op1c,
; 239  :     op1r,
; 240  :     op2;
; 241  : 
; 242  :     UNREFERENCED(r1);

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@s390_plo_c
$LN7@s390_plo_c:

; 243  :     UNREFERENCED(r3);

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@s390_plo_c

; 244  : 
; 245  :     DW_CHECK(effective_addr4, regs);

  00022	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00026	83 e0 07	 and	 eax, 7
  00029	85 c0		 test	 eax, eax
  0002b	74 1b		 je	 SHORT $LN8@s390_plo_c
  0002d	ba 06 00 00 00	 mov	 edx, 6
  00032	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00042	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_plo_c:

; 246  :     DW_CHECK(effective_addr2, regs);

  00048	8b 44 24 60	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0004c	83 e0 07	 and	 eax, 7
  0004f	85 c0		 test	 eax, eax
  00051	74 1b		 je	 SHORT $LN9@s390_plo_c
  00053	ba 06 00 00 00	 mov	 edx, 6
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00060	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00068	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_plo_c:

; 247  : 
; 248  :     /* Load first op compare value */
; 249  :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  0006e	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00072	83 c0 08	 add	 eax, 8
  00075	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00083	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  0008f	8b c8		 mov	 ecx, eax
  00091	e8 00 00 00 00	 call	 s390_vfetch8
  00096	48 89 44 24 28	 mov	 QWORD PTR op1c$[rsp], rax

; 250  : 
; 251  :     /* Load 2nd operand */
; 252  :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  0009b	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a3	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  000a7	8b 4c 24 60	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  000ab	e8 00 00 00 00	 call	 s390_vfetch8
  000b0	48 89 44 24 20	 mov	 QWORD PTR op2$[rsp], rax

; 253  : 
; 254  :     if(op1c == op2)

  000b5	48 8b 44 24 20	 mov	 rax, QWORD PTR op2$[rsp]
  000ba	48 39 44 24 28	 cmp	 QWORD PTR op1c$[rsp], rax
  000bf	75 4e		 jne	 SHORT $LN10@s390_plo_c

; 255  :     {
; 256  :         /* Load 1st op replacement value */
; 257  :         op1r = ARCH_DEP(wfetch8)(effective_addr4 + 24, b4, regs);

  000c1	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  000c5	83 c0 18	 add	 eax, 24
  000c8	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d0	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  000d6	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000de	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  000e2	8b c8		 mov	 ecx, eax
  000e4	e8 00 00 00 00	 call	 s390_vfetch8
  000e9	48 89 44 24 30	 mov	 QWORD PTR op1r$[rsp], rax

; 258  : 
; 259  :         /* Store at 2nd operand location */
; 260  :         ARCH_DEP(vstore8)(op1r, effective_addr2, b2, regs);

  000ee	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f6	44 8b 44 24 68	 mov	 r8d, DWORD PTR b2$[rsp]
  000fb	8b 54 24 60	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  000ff	48 8b 4c 24 30	 mov	 rcx, QWORD PTR op1r$[rsp]
  00104	e8 00 00 00 00	 call	 s390_vstore8

; 261  : 
; 262  :         return 0;

  00109	33 c0		 xor	 eax, eax
  0010b	eb 35		 jmp	 SHORT $LN1@s390_plo_c

; 263  :     }

  0010d	eb 33		 jmp	 SHORT $LN11@s390_plo_c
$LN10@s390_plo_c:

; 264  :     else
; 265  :     {
; 266  :         /* Replace 1st op comp value by 2nd op */
; 267  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  0010f	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00113	83 c0 08	 add	 eax, 8
  00116	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00124	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0012c	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  00131	8b d0		 mov	 edx, eax
  00133	48 8b 4c 24 20	 mov	 rcx, QWORD PTR op2$[rsp]
  00138	e8 00 00 00 00	 call	 s390_vstore8

; 268  : 
; 269  :         return 1;

  0013d	b8 01 00 00 00	 mov	 eax, 1
$LN11@s390_plo_c:
$LN1@s390_plo_c:

; 270  :     }
; 271  : }

  00142	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00146	c3		 ret	 0
s390_plo_csg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
r1$ = 64
r3$ = 72
effective_addr2$ = 80
b2$ = 88
effective_addr4$ = 96
b4$ = 104
regs$ = 112
s390_plo_cs PROC

; 203  : {

$LN16:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s390_plo_c:

; 204  : U32 op2;
; 205  : 
; 206  :     UNREFERENCED(r3);

  00016	33 c0		 xor	 eax, eax
  00018	85 c0		 test	 eax, eax
  0001a	75 fa		 jne	 SHORT $LN4@s390_plo_c
$LN7@s390_plo_c:

; 207  :     UNREFERENCED(effective_addr4);

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN7@s390_plo_c
$LN10@s390_plo_c:

; 208  :     UNREFERENCED(b4);

  00022	33 c0		 xor	 eax, eax
  00024	85 c0		 test	 eax, eax
  00026	75 fa		 jne	 SHORT $LN10@s390_plo_c

; 209  : 
; 210  :     ODD_CHECK(r1, regs);

  00028	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  0002c	83 e0 01	 and	 eax, 1
  0002f	85 c0		 test	 eax, eax
  00031	74 15		 je	 SHORT $LN11@s390_plo_c
  00033	ba 06 00 00 00	 mov	 edx, 6
  00038	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00042	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN11@s390_plo_c:

; 211  :     FW_CHECK(effective_addr2, regs);

  00048	8b 44 24 50	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0004c	83 e0 03	 and	 eax, 3
  0004f	85 c0		 test	 eax, eax
  00051	74 15		 je	 SHORT $LN12@s390_plo_c
  00053	ba 06 00 00 00	 mov	 edx, 6
  00058	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0005d	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00062	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN12@s390_plo_c:

; 212  : 
; 213  :     /* Load second operand from operand address  */
; 214  :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00068	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  0006d	8b 54 24 58	 mov	 edx, DWORD PTR b2$[rsp]
  00071	8b 4c 24 50	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00075	e8 00 00 00 00	 call	 s390_vfetch4
  0007a	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 215  : 
; 216  :     /* Compare operand with R1 register contents */
; 217  :     if ( regs->GR_L(r1) == op2 )

  0007e	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  0008c	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00093	75 2d		 jne	 SHORT $LN13@s390_plo_c

; 218  :     {
; 219  :         /* If equal, store R1+1 at operand loc and set cc=0 */
; 220  :         ARCH_DEP(vstore4) ( regs->GR_L(r1+1), effective_addr2, b2, regs );

  00095	8b 44 24 40	 mov	 eax, DWORD PTR r1$[rsp]
  00099	ff c0		 inc	 eax
  0009b	48 98		 cdqe
  0009d	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a2	44 8b 44 24 58	 mov	 r8d, DWORD PTR b2$[rsp]
  000a7	8b 54 24 50	 mov	 edx, DWORD PTR effective_addr2$[rsp]
  000ab	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  000b7	e8 00 00 00 00	 call	 s390_vstore4

; 221  : 
; 222  :         return 0;

  000bc	33 c0		 xor	 eax, eax
  000be	eb 1c		 jmp	 SHORT $LN1@s390_plo_c

; 223  :     }

  000c0	eb 1a		 jmp	 SHORT $LN14@s390_plo_c
$LN13@s390_plo_c:

; 224  :     else
; 225  :     {
; 226  :         /* If unequal, load R1 from operand and set cc=1 */
; 227  :         regs->GR_L(r1) = op2;

  000c2	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000c7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000cc	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  000d0	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 228  : 
; 229  :         return 1;

  000d7	b8 01 00 00 00	 mov	 eax, 1
$LN14@s390_plo_c:
$LN1@s390_plo_c:

; 230  :     }
; 231  : 
; 232  : }

  000dc	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e0	c3		 ret	 0
s390_plo_cs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op4addr$ = 32
op4alet$ = 36
op2$ = 40
op1c$ = 48
op4$ = 56
r1$ = 80
r3$ = 88
effective_addr2$ = 96
b2$ = 104
effective_addr4$ = 112
b4$ = 120
regs$ = 128
s390_plo_clg PROC

; 53   : {

$LN21:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 54   : U64 op1c,
; 55   :     op2,
; 56   :     op4;
; 57   : U32 op4alet = 0;

  00016	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR op4alet$[rsp], 0
$LN4@s390_plo_c:

; 58   : VADR op4addr;
; 59   : 
; 60   :     UNREFERENCED(r1);

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN4@s390_plo_c

; 61   : 
; 62   :     DW_CHECK(effective_addr4, regs);

  00024	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00028	83 e0 07	 and	 eax, 7
  0002b	85 c0		 test	 eax, eax
  0002d	74 1b		 je	 SHORT $LN8@s390_plo_c
  0002f	ba 06 00 00 00	 mov	 edx, 6
  00034	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00044	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN8@s390_plo_c:

; 63   :     DW_CHECK(effective_addr2, regs);

  0004a	8b 44 24 60	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0004e	83 e0 07	 and	 eax, 7
  00051	85 c0		 test	 eax, eax
  00053	74 1b		 je	 SHORT $LN9@s390_plo_c
  00055	ba 06 00 00 00	 mov	 edx, 6
  0005a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s390_plo_c:

; 64   : 
; 65   :     /* load second operand */
; 66   :     op2 = ARCH_DEP(vfetch8)(effective_addr2, b2, regs);

  00070	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00078	8b 54 24 68	 mov	 edx, DWORD PTR b2$[rsp]
  0007c	8b 4c 24 60	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00080	e8 00 00 00 00	 call	 s390_vfetch8
  00085	48 89 44 24 28	 mov	 QWORD PTR op2$[rsp], rax

; 67   : 
; 68   :     /* load 1st op. compare value */
; 69   :     op1c = ARCH_DEP(wfetch8)(effective_addr4 + 8, b4, regs);

  0008a	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0008e	83 c0 08	 add	 eax, 8
  00091	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0009f	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  000a7	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  000ab	8b c8		 mov	 ecx, eax
  000ad	e8 00 00 00 00	 call	 s390_vfetch8
  000b2	48 89 44 24 30	 mov	 QWORD PTR op1c$[rsp], rax

; 70   : 
; 71   :     if(op1c == op2)

  000b7	48 8b 44 24 28	 mov	 rax, QWORD PTR op2$[rsp]
  000bc	48 39 44 24 30	 cmp	 QWORD PTR op1c$[rsp], rax
  000c1	0f 85 f3 01 00
	00		 jne	 $LN10@s390_plo_c

; 72   :     {
; 73   :         /* When in ar mode, ar3 is used to access the
; 74   :            operand. The alet is fetched from the pl */
; 75   :         if(!REAL_MODE(&regs->psw) && ACCESS_REGISTER_MODE(&regs->psw))

  000c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cf	0f b6 40 78	 movzx	 eax, BYTE PTR [rax+120]
  000d3	83 e0 04	 and	 eax, 4
  000d6	85 c0		 test	 eax, eax
  000d8	0f 84 22 01 00
	00		 je	 $LN12@s390_plo_c
  000de	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000e6	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  000ea	83 f8 40	 cmp	 eax, 64			; 00000040H
  000ed	0f 85 0d 01 00
	00		 jne	 $LN12@s390_plo_c

; 76   :         {
; 77   :             if(r3 == 0)

  000f3	83 7c 24 58 00	 cmp	 DWORD PTR r3$[rsp], 0
  000f8	75 12		 jne	 SHORT $LN13@s390_plo_c

; 78   :                 ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000fa	ba 06 00 00 00	 mov	 edx, 6
  000ff	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00107	e8 00 00 00 00	 call	 s390_program_interrupt
$LN13@s390_plo_c:

; 79   :             op4alet = ARCH_DEP(wfetch4)(effective_addr4 + 68, b4, regs);

  0010c	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00110	83 c0 44	 add	 eax, 68			; 00000044H
  00113	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011b	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00121	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00129	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  0012d	8b c8		 mov	 ecx, eax
  0012f	e8 00 00 00 00	 call	 s390_vfetch4
  00134	89 44 24 24	 mov	 DWORD PTR op4alet$[rsp], eax

; 80   :             regs->AR(r3) = op4alet;

  00138	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  0013d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00145	8b 54 24 24	 mov	 edx, DWORD PTR op4alet$[rsp]
  00149	89 94 81 00 03
	00 00		 mov	 DWORD PTR [rcx+rax*4+768], edx
$LN7@s390_plo_c:

; 81   :             SET_AEA_AR(regs, r3);

  00150	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00158	0f b6 40 7b	 movzx	 eax, BYTE PTR [rax+123]
  0015c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0015f	0f 85 91 00 00
	00		 jne	 $LN14@s390_plo_c
  00165	83 7c 24 58 00	 cmp	 DWORD PTR r3$[rsp], 0
  0016a	0f 8e 86 00 00
	00		 jle	 $LN14@s390_plo_c
  00170	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  00175	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017d	83 bc 81 00 03
	00 00 00	 cmp	 DWORD PTR [rcx+rax*4+768], 0
  00185	75 1e		 jne	 SHORT $LN15@s390_plo_c
  00187	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  0018b	83 c0 05	 add	 eax, 5
  0018e	48 98		 cdqe
  00190	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00198	c7 84 81 94 0c
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 1
  001a3	eb 51		 jmp	 SHORT $LN16@s390_plo_c
$LN15@s390_plo_c:
  001a5	48 63 44 24 58	 movsxd	 rax, DWORD PTR r3$[rsp]
  001aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	83 bc 81 00 03
	00 00 01	 cmp	 DWORD PTR [rcx+rax*4+768], 1
  001ba	75 1e		 jne	 SHORT $LN17@s390_plo_c
  001bc	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  001c0	83 c0 05	 add	 eax, 5
  001c3	48 98		 cdqe
  001c5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001cd	c7 84 81 94 0c
	00 00 07 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 7
  001d8	eb 1c		 jmp	 SHORT $LN18@s390_plo_c
$LN17@s390_plo_c:
  001da	8b 44 24 58	 mov	 eax, DWORD PTR r3$[rsp]
  001de	83 c0 05	 add	 eax, 5
  001e1	48 98		 cdqe
  001e3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	c7 84 81 94 0c
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+3220], 0
$LN18@s390_plo_c:
$LN16@s390_plo_c:
$LN14@s390_plo_c:
  001f6	33 c0		 xor	 eax, eax
  001f8	85 c0		 test	 eax, eax
  001fa	0f 85 50 ff ff
	ff		 jne	 $LN7@s390_plo_c
$LN12@s390_plo_c:

; 82   :         }
; 83   : 
; 84   :         /* Load address of operand 4 */
; 85   : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 86   :         op4addr = ARCH_DEP(wfetch8)(effective_addr4 + 72, b4, regs);
; 87   : #else
; 88   :         op4addr = ARCH_DEP(wfetch4)(effective_addr4 + 76, b4, regs);

  00200	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  00204	83 c0 4c	 add	 eax, 76			; 0000004cH
  00207	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00215	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0021d	8b 54 24 78	 mov	 edx, DWORD PTR b4$[rsp]
  00221	8b c8		 mov	 ecx, eax
  00223	e8 00 00 00 00	 call	 s390_vfetch4
  00228	89 44 24 20	 mov	 DWORD PTR op4addr$[rsp], eax

; 89   : #endif
; 90   :         op4addr &= ADDRESS_MAXWRAP(regs);

  0022c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00234	8b 80 90 00 00
	00		 mov	 eax, DWORD PTR [rax+144]
  0023a	8b 4c 24 20	 mov	 ecx, DWORD PTR op4addr$[rsp]
  0023e	23 c8		 and	 ecx, eax
  00240	8b c1		 mov	 eax, ecx
  00242	89 44 24 20	 mov	 DWORD PTR op4addr$[rsp], eax

; 91   :         DW_CHECK(op4addr, regs);

  00246	8b 44 24 20	 mov	 eax, DWORD PTR op4addr$[rsp]
  0024a	83 e0 07	 and	 eax, 7
  0024d	85 c0		 test	 eax, eax
  0024f	74 1b		 je	 SHORT $LN19@s390_plo_c
  00251	ba 06 00 00 00	 mov	 edx, 6
  00256	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00266	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN19@s390_plo_c:

; 92   : 
; 93   :         /* Load operand 4, using ar3 when in ar mode */
; 94   :         op4 = ARCH_DEP(vfetch8)(op4addr, r3, regs);

  0026c	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00274	8b 54 24 58	 mov	 edx, DWORD PTR r3$[rsp]
  00278	8b 4c 24 20	 mov	 ecx, DWORD PTR op4addr$[rsp]
  0027c	e8 00 00 00 00	 call	 s390_vfetch8
  00281	48 89 44 24 38	 mov	 QWORD PTR op4$[rsp], rax

; 95   : 
; 96   :         /* replace the 3rd operand with the 4th operand */
; 97   :         ARCH_DEP(wstore8)(op4, effective_addr4 + 40, b4, regs);

  00286	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0028a	83 c0 28	 add	 eax, 40			; 00000028H
  0028d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00295	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  0029b	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002a3	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  002a8	8b d0		 mov	 edx, eax
  002aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR op4$[rsp]
  002af	e8 00 00 00 00	 call	 s390_vstore8

; 98   : 
; 99   :         return 0;

  002b4	33 c0		 xor	 eax, eax
  002b6	eb 35		 jmp	 SHORT $LN1@s390_plo_c

; 100  :     }

  002b8	eb 33		 jmp	 SHORT $LN11@s390_plo_c
$LN10@s390_plo_c:

; 101  :     else
; 102  :     {
; 103  :         /* replace the first op compare value with 2nd op */
; 104  :         ARCH_DEP(wstore8)(op2, effective_addr4 + 8, b4, regs);

  002ba	8b 44 24 70	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  002be	83 c0 08	 add	 eax, 8
  002c1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c9	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  002cf	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  002d7	44 8b 44 24 78	 mov	 r8d, DWORD PTR b4$[rsp]
  002dc	8b d0		 mov	 edx, eax
  002de	48 8b 4c 24 28	 mov	 rcx, QWORD PTR op2$[rsp]
  002e3	e8 00 00 00 00	 call	 s390_vstore8

; 105  : 
; 106  :         return 1;

  002e8	b8 01 00 00 00	 mov	 eax, 1
$LN11@s390_plo_c:
$LN1@s390_plo_c:

; 107  :     }
; 108  : }

  002ed	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002f1	c3		 ret	 0
s390_plo_clg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\plo.c
_TEXT	SEGMENT
op2$ = 32
op4$ = 36
r1$ = 64
r3$ = 72
effective_addr2$ = 80
b2$ = 88
effective_addr4$ = 96
b4$ = 104
regs$ = 112
s390_plo_cl PROC

; 23   : {

$LN7:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 24   : U32 op2,
; 25   :     op4;
; 26   : 
; 27   :     FW_CHECK(effective_addr2, regs);

  00016	8b 44 24 50	 mov	 eax, DWORD PTR effective_addr2$[rsp]
  0001a	83 e0 03	 and	 eax, 3
  0001d	85 c0		 test	 eax, eax
  0001f	74 15		 je	 SHORT $LN2@s390_plo_c
  00021	ba 06 00 00 00	 mov	 edx, 6
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0002b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00030	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN2@s390_plo_c:

; 28   :     FW_CHECK(effective_addr4, regs);

  00036	8b 44 24 60	 mov	 eax, DWORD PTR effective_addr4$[rsp]
  0003a	83 e0 03	 and	 eax, 3
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN3@s390_plo_c
  00041	ba 06 00 00 00	 mov	 edx, 6
  00046	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0004b	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  00050	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN3@s390_plo_c:

; 29   : 
; 30   :     /* Load second operand from operand address  */
; 31   :     op2 = ARCH_DEP(vfetch4) ( effective_addr2, b2, regs );

  00056	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  0005b	8b 54 24 58	 mov	 edx, DWORD PTR b2$[rsp]
  0005f	8b 4c 24 50	 mov	 ecx, DWORD PTR effective_addr2$[rsp]
  00063	e8 00 00 00 00	 call	 s390_vfetch4
  00068	89 44 24 20	 mov	 DWORD PTR op2$[rsp], eax

; 32   : 
; 33   :     if(regs->GR_L(r1) == op2)

  0006c	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  00071	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  0007a	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00081	75 31		 jne	 SHORT $LN4@s390_plo_c

; 34   :     {
; 35   : 
; 36   :         op4 = ARCH_DEP(vfetch4) ( effective_addr4, b4, regs );

  00083	4c 8b 44 24 70	 mov	 r8, QWORD PTR regs$[rsp]
  00088	8b 54 24 68	 mov	 edx, DWORD PTR b4$[rsp]
  0008c	8b 4c 24 60	 mov	 ecx, DWORD PTR effective_addr4$[rsp]
  00090	e8 00 00 00 00	 call	 s390_vfetch4
  00095	89 44 24 24	 mov	 DWORD PTR op4$[rsp], eax

; 37   :         regs->GR_L(r3) = op4;

  00099	48 63 44 24 48	 movsxd	 rax, DWORD PTR r3$[rsp]
  0009e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000a3	8b 54 24 24	 mov	 edx, DWORD PTR op4$[rsp]
  000a7	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 38   : 
; 39   :         return 0;

  000ae	33 c0		 xor	 eax, eax
  000b0	eb 1c		 jmp	 SHORT $LN1@s390_plo_c

; 40   :     }

  000b2	eb 1a		 jmp	 SHORT $LN5@s390_plo_c
$LN4@s390_plo_c:

; 41   :     else
; 42   :     {
; 43   :         regs->GR_L(r1) = op2;

  000b4	48 63 44 24 40	 movsxd	 rax, DWORD PTR r1$[rsp]
  000b9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000be	8b 54 24 20	 mov	 edx, DWORD PTR op2$[rsp]
  000c2	89 94 c1 80 02
	00 00		 mov	 DWORD PTR [rcx+rax*8+640], edx

; 44   : 
; 45   :         return 1;

  000c9	b8 01 00 00 00	 mov	 eax, 1
$LN5@s390_plo_c:
$LN1@s390_plo_c:

; 46   :     }
; 47   : 
; 48   : }

  000ce	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d2	c3		 ret	 0
s390_plo_cl ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
END
