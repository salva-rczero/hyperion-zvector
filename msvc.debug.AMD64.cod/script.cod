; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
$SG189753 DB	'external', 00H
	ORG $+3
$SG189754 DB	'svc', 00H
$SG189755 DB	'program', 00H
$SG189756 DB	'machine', 00H
$SG189757 DB	'io', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	process_config
PUBLIC	UpdSCRCTL
PUBLIC	FreeSCRCTL
PUBLIC	FindSCRCTL
PUBLIC	cscript_cmd
PUBLIC	process_script_file
PUBLIC	script_cmd
PUBLIC	$runtest_cmd
PUBLIC	runtest
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f50624dd2f1a9fc
PUBLIC	__real@403e000000000000
PUBLIC	__real@4072c00000000000
PUBLIC	__real@408f380000000000
PUBLIC	__real@408f400000000000
PUBLIC	__real@412e848000000000
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_atof:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fopen_s:PROC
EXTRN	__imp_feof:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_equal_threads:PROC
EXTRN	__imp_resolve_symbol_string:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_timeval_subtract:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_parse_args:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	start_cmd_cpu:PROC
EXTRN	restart_cmd:PROC
EXTRN	CallHercCmd:PROC
EXTRN	exec_cmd:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_panel_command:QWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
scrlist	DB	010H DUP (?)
scrid	DD	01H DUP (?)
?inc_stmtnum@?1??process_config@@9@9 DD 08H DUP (?)	; `process_config'::`2'::inc_stmtnum
$SG189257 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$process_config DD imagerel $LN46
	DD	imagerel $LN46+4143
	DD	imagerel $unwind$process_config
$pdata$do_special DD imagerel do_special
	DD	imagerel do_special+1501
	DD	imagerel $unwind$do_special
$pdata$set_restart DD imagerel set_restart
	DD	imagerel set_restart+304
	DD	imagerel $unwind$set_restart
$pdata$read_config DD imagerel read_config
	DD	imagerel read_config+1159
	DD	imagerel $unwind$read_config
$pdata$NewSCRCTL DD imagerel NewSCRCTL
	DD	imagerel NewSCRCTL+551
	DD	imagerel $unwind$NewSCRCTL
$pdata$UpdSCRCTL DD imagerel $LN4
	DD	imagerel $LN4+124
	DD	imagerel $unwind$UpdSCRCTL
$pdata$FreeSCRCTL DD imagerel $LN14
	DD	imagerel $LN14+297
	DD	imagerel $unwind$FreeSCRCTL
$pdata$FindSCRCTL DD imagerel $LN17
	DD	imagerel $LN17+356
	DD	imagerel $unwind$FindSCRCTL
$pdata$ListScriptsIds DD imagerel ListScriptsIds
	DD	imagerel ListScriptsIds+480
	DD	imagerel $unwind$ListScriptsIds
$pdata$cscript_cmd DD imagerel $LN26
	DD	imagerel $LN26+1102
	DD	imagerel $unwind$cscript_cmd
$pdata$script_abort DD imagerel script_abort
	DD	imagerel script_abort+228
	DD	imagerel $unwind$script_abort
$pdata$process_script_file DD imagerel $LN42
	DD	imagerel $LN42+2023
	DD	imagerel $unwind$process_script_file
$pdata$script_thread DD imagerel script_thread
	DD	imagerel script_thread+441
	DD	imagerel $unwind$script_thread
$pdata$script_cmd DD imagerel $LN28
	DD	imagerel $LN28+941
	DD	imagerel $unwind$script_cmd
$pdata$$runtest_cmd DD imagerel $LN12
	DD	imagerel $LN12+117
	DD	imagerel $unwind$$runtest_cmd
$pdata$test_abort DD imagerel test_abort
	DD	imagerel test_abort+134
	DD	imagerel $unwind$test_abort
$pdata$runtest DD imagerel $LN53
	DD	imagerel $LN53+2796
	DD	imagerel $unwind$runtest
pdata	ENDS
;	COMDAT __real@412e848000000000
CONST	SEGMENT
__real@412e848000000000 DQ 0412e848000000000r	; 1e+06
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT __real@408f380000000000
CONST	SEGMENT
__real@408f380000000000 DQ 0408f380000000000r	; 999
CONST	ENDS
;	COMDAT __real@4072c00000000000
CONST	SEGMENT
__real@4072c00000000000 DQ 04072c00000000000r	; 300
CONST	ENDS
;	COMDAT __real@403e000000000000
CONST	SEGMENT
__real@403e000000000000 DQ 0403e000000000000r	; 30
CONST	ENDS
;	COMDAT __real@3f50624dd2f1a9fc
CONST	SEGMENT
__real@3f50624dd2f1a9fc DQ 03f50624dd2f1a9fcr	; 0.001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
_DATA	SEGMENT
	ORG $+5
$SG188913 DB	'fgetc()', 00H
$SG188914 DB	'S', 00H
	ORG $+2
$SG188926 DB	'S', 00H
	ORG $+2
$SG188915 DB	'HHC01432%s Config file[%d] %s: error in function %s: %s', 0aH
	DB	00H
	ORG $+3
$SG188930 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG188932 DB	'CUU', 00H
$SG188916 DB	'read_config', 00H
$SG188939 DB	'S', 00H
	ORG $+2
$SG188917 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG188927 DB	'HHC01433%s Config file[%d] %s: line is too long', 0aH, 00H
	ORG $+3
$SG188931 DB	'$(CUU)', 00H
	ORG $+1
$SG188944 DB	'I', 00H
	ORG $+2
$SG188928 DB	'read_config', 00H
$SG189018 DB	'r', 00H
	ORG $+2
$SG188929 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG188933 DB	'$(CCUU)', 00H
$SG188934 DB	'CCUU', 00H
	ORG $+3
$SG188935 DB	'$(DEVN)', 00H
$SG188936 DB	'DEVN', 00H
	ORG $+3
$SG188940 DB	'HHC01433%s Config file[%d] %s: line is too long', 0aH, 00H
	ORG $+3
$SG189021 DB	'S', 00H
	ORG $+2
$SG188941 DB	'read_config', 00H
$SG189028 DB	'#!', 00H
	ORG $+1
$SG188942 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG188945 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG188946 DB	'read_config', 00H
$SG189030 DB	'/*', 00H
	ORG $+1
$SG188947 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189020 DB	'fopen()', 00H
$SG189022 DB	'HHC01432%s Config file[%d] %s: error in function %s: %s', 0aH
	DB	00H
	ORG $+3
$SG189036 DB	'ignore', 00H
	ORG $+1
$SG189039 DB	'I', 00H
	ORG $+2
$SG189023 DB	'process_config', 00H
	ORG $+1
$SG189024 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189034 DB	'exec', 00H
	ORG $+3
$SG189038 DB	'include_errors', 00H
	ORG $+1
$SG189040 DB	'HHC01435%s Config file %s: will ignore include errors', 0aH
	DB	00H
	ORG $+1
$SG189041 DB	'process_config', 00H
	ORG $+1
$SG189042 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189044 DB	'include', 00H
$SG189046 DB	'S', 00H
	ORG $+6
$SG189048 DB	'process_config', 00H
	ORG $+1
$SG189049 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189047 DB	'HHC01436%s Config file[%d] %s: maximum nesting level %d '
	DB	'reached', 0aH, 00H
	ORG $+3
$SG189050 DB	'I', 00H
	ORG $+2
$SG189051 DB	'HHC01437%s Config file[%d] %s: including file %s', 0aH, 00H
	ORG $+2
$SG189054 DB	'r', 00H
	ORG $+2
$SG189052 DB	'process_config', 00H
	ORG $+1
$SG189053 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189058 DB	'W', 00H
	ORG $+2
$SG189062 DB	'S', 00H
	ORG $+2
$SG189059 DB	'HHC01438%s Config file %s: open error ignored file %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG189072 DB	'S', 00H
	ORG $+2
$SG189060 DB	'process_config', 00H
	ORG $+1
$SG189061 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189063 DB	'HHC01439%s Config file %s: open error file %s: %s', 0aH, 00H
	ORG $+1
$SG189077 DB	' ', 00H
	ORG $+2
$SG189064 DB	'process_config', 00H
	ORG $+1
$SG189065 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189069 DB	'%x%c', 00H
	ORG $+3
$SG189073 DB	'HHC01448%s Config file[%d] %s: missing device number or '
	DB	'device type', 0aH, 00H
	ORG $+3
$SG189074 DB	'process_config', 00H
	ORG $+1
$SG189075 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189076 DB	'attach', 00H
	ORG $+1
$SG189079 DB	'device number specification', 00H
$SG189080 DB	'S', 00H
	ORG $+2
$SG189081 DB	'HHC01443%s Config file[%d] %s: %s is not a valid %s', 0aH
	DB	00H
	ORG $+3
$SG189082 DB	'process_config', 00H
	ORG $+1
$SG189083 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189086 DB	'%x%c', 00H
	ORG $+3
$SG189088 DB	'cpuserial', 00H
	ORG $+2
$SG189098 DB	'numcpu', 00H
	ORG $+1
$SG189109 DB	'E', 00H
	ORG $+2
$SG189090 DB	'cpumodel', 00H
	ORG $+3
$SG189113 DB	' ', 00H
	ORG $+2
$SG189092 DB	'mainsize', 00H
	ORG $+3
$SG189115 DB	'E', 00H
	ORG $+2
$SG189094 DB	'xpndsize', 00H
	ORG $+3
$SG189152 DB	'E', 00H
	ORG $+2
$SG189096 DB	'cnslport', 00H
	ORG $+3
$SG189251 DB	'I', 00H
	ORG $+2
$SG189100 DB	'loadparm', 00H
	ORG $+3
$SG189258 DB	'I', 00H
	ORG $+2
$SG189110 DB	'HHC01441%s Config file[%d] %s: error processing statemen'
	DB	't: %s', 0aH, 00H
	ORG $+1
$SG189111 DB	'process_config', 00H
	ORG $+1
$SG189112 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189116 DB	'HHC01441%s Config file[%d] %s: error processing statemen'
	DB	't: %s', 0aH, 00H
	ORG $+1
$SG189117 DB	'process_config', 00H
	ORG $+1
$SG189118 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189142 DB	'NewSCRCTL', 00H
	ORG $+2
$SG189290 DB	'E', 00H
	ORG $+2
$SG189143 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189144 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189146 DB	'NewSCRCTL', 00H
	ORG $+2
$SG189299 DB	'*', 00H
	ORG $+2
$SG189147 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189148 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189153 DB	'HHC00152%s Out of memory', 0aH, 00H
	ORG $+2
$SG189300 DB	'all', 00H
$SG189154 DB	'NewSCRCTL', 00H
	ORG $+2
$SG189303 DB	'E', 00H
	ORG $+2
$SG189155 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189157 DB	'C:\papa\MyGit\hyperion-zvector\script.c:480', 00H
$SG189310 DB	'E', 00H
	ORG $+2
$SG189159 DB	'C:\papa\MyGit\hyperion-zvector\script.c:485', 00H
$SG189327 DB	'E', 00H
	ORG $+2
$SG189167 DB	'C:\papa\MyGit\hyperion-zvector\script.c:495', 00H
$SG189339 DB	'E', 00H
	ORG $+2
$SG189169 DB	'C:\papa\MyGit\hyperion-zvector\script.c:500', 00H
$SG189402 DB	'E', 00H
	ORG $+2
$SG189186 DB	'FreeSCRCTL', 00H
	ORG $+1
$SG189409 DB	'-', 00H
	ORG $+2
$SG189187 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189191 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189188 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189190 DB	'FreeSCRCTL', 00H
	ORG $+5
$SG189194 DB	'C:\papa\MyGit\hyperion-zvector\script.c:511', 00H
$SG189412 DB	'r', 00H
	ORG $+2
$SG189222 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189192 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189195 DB	'C:\papa\MyGit\hyperion-zvector\script.c:513', 00H
$SG189416 DB	'E', 00H
	ORG $+2
$SG189221 DB	'FindSCRCTL', 00H
	ORG $+5
$SG189226 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189223 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189225 DB	'FindSCRCTL', 00H
	ORG $+5
$SG189229 DB	'C:\papa\MyGit\hyperion-zvector\script.c:538', 00H
$SG189420 DB	'E', 00H
	ORG $+2
$SG189253 DB	'ListScriptsIds', 00H
	ORG $+1
$SG189254 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189227 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189232 DB	'C:\papa\MyGit\hyperion-zvector\script.c:550', 00H
$SG189425 DB	'I', 00H
	ORG $+2
$SG189233 DB	'C:\papa\MyGit\hyperion-zvector\script.c:555', 00H
$SG189430 DB	'/*', 00H
	ORG $+1
$SG189248 DB	'C:\papa\MyGit\hyperion-zvector\script.c:567', 00H
$SG189433 DB	'I', 00H
	ORG $+2
$SG189252 DB	'HHC02314%s No scripts currently running', 0aH, 00H
	ORG $+3
$SG189442 DB	'I', 00H
	ORG $+2
$SG189255 DB	'C:\papa\MyGit\hyperion-zvector\script.c:578', 00H
$SG189449 DB	'E', 00H
	ORG $+2
$SG189259 DB	'HHC02315%s Script id:%d, tid:%8.8x, level:%d, name:%s', 0aH
	DB	00H
	ORG $+1
$SG189260 DB	'ListScriptsIds', 00H
	ORG $+1
$SG189261 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189262 DB	'C:\papa\MyGit\hyperion-zvector\script.c:593', 00H
$SG189453 DB	'I', 00H
	ORG $+2
$SG189291 DB	'HHC02446%s Invalid number of arguments', 0aH, 00H
$SG189292 DB	'cscript_cmd', 00H
$SG189548 DB	'E', 00H
	ORG $+2
$SG189293 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189302 DB	': value not numeric', 00H
$SG189556 DB	'E', 00H
	ORG $+2
$SG189304 DB	'HHC02205%s Invalid argument %s%s', 0aH, 00H
	ORG $+2
$SG189448 DB	'read()', 00H
	ORG $+1
$SG189579 DB	'E', 00H
	ORG $+2
$SG189305 DB	'cscript_cmd', 00H
$SG189587 DB	'E', 00H
	ORG $+2
$SG189306 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189307 DB	'C:\papa\MyGit\hyperion-zvector\script.c:651', 00H
$SG189667 DB	'E', 00H
	ORG $+2
$SG189311 DB	'HHC02314%s No scripts currently running', 0aH, 00H
	ORG $+3
$SG189661 DB	'start', 00H
	ORG $+2
$SG189674 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG189678 DB	'%s', 00H
	ORG $+1
$SG189312 DB	'cscript_cmd', 00H
$SG189685 DB	'W', 00H
	ORG $+2
$SG189313 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189314 DB	'C:\papa\MyGit\hyperion-zvector\script.c:657', 00H
$SG189692 DB	'I', 00H
	ORG $+2
$SG189318 DB	'C:\papa\MyGit\hyperion-zvector\script.c:670', 00H
$SG189696 DB	'I', 00H
	ORG $+2
$SG189319 DB	'C:\papa\MyGit\hyperion-zvector\script.c:671', 00H
$SG189705 DB	'E', 00H
	ORG $+2
$SG189324 DB	'C:\papa\MyGit\hyperion-zvector\script.c:688', 00H
$SG189710 DB	'I', 00H
	ORG $+2
$SG189325 DB	'C:\papa\MyGit\hyperion-zvector\script.c:690', 00H
$SG189722 DB	'E', 00H
	ORG $+2
$SG189328 DB	'HHC02316%s Script %s not found', 0aH, 00H
$SG189329 DB	'cscript_cmd', 00H
$SG189726 DB	'I', 00H
	ORG $+2
$SG189330 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189338 DB	'user cancel request', 00H
$SG189731 DB	'I', 00H
	ORG $+2
$SG189340 DB	'HHC02259%s Script %d aborted: %s', 0aH, 00H
	ORG $+2
$SG189735 DB	'I', 00H
	ORG $+2
$SG189341 DB	'script_abort', 00H
	ORG $+3
$SG189342 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189391 DB	'process_script_file', 00H
$SG189807 DB	'E', 00H
	ORG $+2
$SG189392 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189393 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189395 DB	'process_script_file', 00H
$SG189811 DB	'E', 00H
	ORG $+2
$SG189396 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189403 DB	'HHC02259%s Script %d aborted: %s', 0aH, 00H
	ORG $+6
$SG189397 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189401 DB	'script recursion level exceeded', 00H
$SG189404 DB	'process_script_file', 00H
$SG189819 DB	'I', 00H
	ORG $+2
$SG189405 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189410 DB	'<stdin>', 00H
$SG189415 DB	'fopen()', 00H
$SG189417 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG189418 DB	'process_script_file', 00H
$SG189823 DB	'I', 00H
	ORG $+2
$SG189419 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189421 DB	'HHC01405%s Script file %s not found', 0aH, 00H
	ORG $+3
$SG189422 DB	'process_script_file', 00H
$SG189836 DB	'I', 00H
	ORG $+2
$SG189423 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189426 DB	'HHC02260%s Script %d: begin processing file %s', 0aH, 00H
$SG189427 DB	'process_script_file', 00H
$SG189840 DB	'I', 00H
	ORG $+2
$SG189428 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189432 DB	'exec', 00H
	ORG $+3
$SG189434 DB	'HHC02260%s Script %d: begin processing file %s', 0aH, 00H
$SG189435 DB	'process_script_file', 00H
	ORG $+4
$SG189436 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189443 DB	'HHC02264%s Script %d: file %s processing ended', 0aH, 00H
$SG189444 DB	'process_script_file', 00H
	ORG $+4
$SG189445 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189450 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG189451 DB	'process_script_file', 00H
	ORG $+4
$SG189452 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189455 DB	'process_script_file', 00H
	ORG $+4
$SG189454 DB	'HHC02265%s Script %d: file %s aborted due to previous co'
	DB	'nditions', 0aH, 00H
	ORG $+6
$SG189456 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189487 DB	'script_thread', 00H
	ORG $+2
$SG189488 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189492 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189489 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189491 DB	'script_thread', 00H
	ORG $+2
$SG189497 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189493 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189496 DB	'script_thread', 00H
	ORG $+2
$SG189501 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189498 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189500 DB	'script_thread', 00H
	ORG $+2
$SG189534 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189502 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189533 DB	'script_cmd', 00H
	ORG $+5
$SG189538 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189535 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189537 DB	'script_cmd', 00H
	ORG $+5
$SG189551 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189539 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189549 DB	'HHC00152%s Out of memory', 0aH, 00H
	ORG $+6
$SG189550 DB	'script_cmd', 00H
	ORG $+5
$SG189552 DB	'C:\papa\MyGit\hyperion-zvector\script.c:981', 00H
	ORG $+4
$SG189554 DB	'C:\papa\MyGit\hyperion-zvector\script.c:986', 00H
	ORG $+4
$SG189555 DB	'script_thread', 00H
	ORG $+2
$SG189557 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG189558 DB	'script_cmd', 00H
	ORG $+5
$SG189559 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189560 DB	'C:\papa\MyGit\hyperion-zvector\script.c:991', 00H
	ORG $+4
$SG189561 DB	'C:\papa\MyGit\hyperion-zvector\script.c:996', 00H
	ORG $+4
$SG189580 DB	'HHC02337%s runtest is only valid as a scripting command', 0aH
	DB	00H
	ORG $+3
$SG189677 DB	'%lf%c', 00H
	ORG $+6
$SG189581 DB	'$runtest_cmd', 00H
	ORG $+3
$SG189582 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189588 DB	'HHC02331%s Script %d: test: aborted', 0aH, 00H
	ORG $+3
$SG189589 DB	'test_abort', 00H
	ORG $+5
$SG189590 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189591 DB	'stopall', 00H
$SG189592 DB	'sysreset', 00H
	ORG $+3
$SG189792 DB	'pause ', 00H
	ORG $+5
$SG189645 DB	'runtest', 00H
$SG189646 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189649 DB	'runtest', 00H
$SG189647 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189650 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189651 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG189658 DB	'%15s %lf', 00H
	ORG $+7
$SG189664 DB	'restart', 00H
$SG189668 DB	'HHC02341%s Script %d: test: unknown runtest keyword: %s', 0aH
	DB	00H
	ORG $+7
$SG189669 DB	'runtest', 00H
$SG189670 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189686 DB	'HHC02335%s Script %d: test: invalid timeout %s; set to %'
	DB	'd instead', 0aH, 00H
	ORG $+5
$SG189687 DB	'runtest', 00H
$SG189688 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189693 DB	'HHC02336%s Script %d: test: test starting', 0aH, 00H
	ORG $+5
$SG189694 DB	'runtest', 00H
$SG189695 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189697 DB	'HHC02339%s Script %d: test: duration limit: %d.%06d seco'
	DB	'nds', 0aH, 00H
	ORG $+3
$SG189698 DB	'runtest', 00H
$SG189699 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189700 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1154', 00H
	ORG $+3
$SG189701 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1156', 00H
	ORG $+3
$SG189706 DB	'HHC02330%s Script %d: test: [re]start failed', 0aH, 00H
	ORG $+2
$SG189707 DB	'runtest', 00H
$SG189708 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189711 DB	'HHC02333%s Script %d: test: running...', 0aH, 00H
$SG189712 DB	'runtest', 00H
$SG189713 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189714 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1174', 00H
	ORG $+3
$SG189716 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1181', 00H
	ORG $+3
$SG189719 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1217', 00H
	ORG $+3
$SG189720 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1222', 00H
	ORG $+3
$SG189723 DB	'HHC02332%s Script %d: test: timeout', 0aH, 00H
	ORG $+3
$SG189724 DB	'runtest', 00H
$SG189725 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189727 DB	'HHC02338%s Script %d: test: actual duration: %d.%06d sec'
	DB	'onds', 0aH, 00H
	ORG $+2
$SG189728 DB	'runtest', 00H
$SG189729 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189732 DB	'HHC02334%s Script %d: test: test ended', 0aH, 00H
$SG189733 DB	'runtest', 00H
$SG189734 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189736 DB	'HHC02338%s Script %d: test: actual duration: %d.%06d sec'
	DB	'onds', 0aH, 00H
	ORG $+2
$SG189737 DB	'runtest', 00H
$SG189738 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
?psws@?1??set_restart@@9@9 DQ FLAT:$SG189753		; `set_restart'::`2'::psws
	DQ	FLAT:$SG189754
	DQ	FLAT:$SG189755
	DQ	FLAT:$SG189756
	DQ	FLAT:$SG189757
	DQ	0000000000000000H
$SG189795 DB	'runtest', 00H
$SG189806 DB	'syntax error; statement ignored', 00H
$SG189808 DB	'HHC01441%s Config file[%d] %s: error processing statemen'
	DB	't: %s', 0aH, 00H
	ORG $+1
$SG189809 DB	'do_special', 00H
	ORG $+5
$SG189810 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189812 DB	'HHC02261%s Script %d: syntax error; statement ignored: %'
	DB	's', 0aH, 00H
	ORG $+5
$SG189813 DB	'do_special', 00H
	ORG $+5
$SG189814 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189822 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189820 DB	'HHC02318%s Config file[%d] %s: processing paused for %d '
	DB	'milliseconds...', 0aH, 00H
	ORG $+7
$SG189821 DB	'do_special', 00H
	ORG $+5
$SG189824 DB	'HHC02262%s Script %d: processing paused for %d milliseco'
	DB	'nds...', 0aH, 00H
$SG189825 DB	'do_special', 00H
	ORG $+5
$SG189826 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189827 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1369', 00H
	ORG $+3
$SG189829 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1375', 00H
	ORG $+3
$SG189831 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1391', 00H
	ORG $+3
$SG189832 DB	'C:\papa\MyGit\hyperion-zvector\script.c:1393', 00H
	ORG $+3
$SG189837 DB	'HHC02319%s Config file[%d] %s: processing resumed...', 0aH
	DB	00H
	ORG $+2
$SG189838 DB	'do_special', 00H
	ORG $+5
$SG189839 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
$SG189841 DB	'HHC02263%s Script %d: processing resumed...', 0aH, 00H
	ORG $+3
$SG189842 DB	'do_special', 00H
	ORG $+5
$SG189843 DB	'C:\papa\MyGit\hyperion-zvector\script.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:runtest
	DD	021H
	DD	0ad3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:script_thread
	DD	01cH
	DD	01a1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_script_file
	DD	01aH
	DD	07cfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_config
	DD	01cH
	DD	01017H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$process_config DD 022419H
	DD	034870112H
	DD	imagerel __GSHandlerCheck
	DD	01a420H
$unwind$do_special DD 021b01H
	DD	013011bH
$unwind$set_restart DD 030b01H
	DD	07007a20bH
	DD	06006H
$unwind$read_config DD 031c01H
	DD	012011cH
	DD	07015H
$unwind$NewSCRCTL DD 020e01H
	DD	0700ab20eH
$unwind$UpdSCRCTL DD 010e01H
	DD	0420eH
$unwind$FreeSCRCTL DD 010901H
	DD	06209H
$unwind$FindSCRCTL DD 010801H
	DD	06208H
$unwind$ListScriptsIds DD 020701H
	DD	0110107H
$unwind$cscript_cmd DD 021501H
	DD	0110115H
$unwind$script_abort DD 010901H
	DD	0c209H
$unwind$process_script_file DD 022219H
	DD	0bb0110H
	DD	imagerel __GSHandlerCheck
	DD	05c0H
$unwind$script_thread DD 022419H
	DD	040b0112H
	DD	imagerel __GSHandlerCheck
	DD	02040H
$unwind$script_cmd DD 021501H
	DD	0110115H
$unwind$$runtest_cmd DD 011201H
	DD	08212H
$unwind$test_abort DD 010901H
	DD	08209H
$unwind$runtest DD 032919H
	DD	0260117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0120H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
rc$ = 80
elapsed_usecs$ = 84
secs$ = 88
usecs$ = 96
c$1 = 100
p2$ = 104
dostart$ = 112
dur$ = 120
pkw$2 = 128
new_secs$3 = 136
tv233 = 140
tv235 = 144
sleep_usecs$ = 148
tv377 = 152
tv379 = 156
tv408 = 160
tv410 = 164
now$ = 168
pszComment$4 = 176
beg$ = 184
kw$5 = 192
badval$6 = 208
without_comment$7 = 224
__$ArrayPad$ = 288
pCtl$ = 320
cmdline$ = 328
args$ = 336
runtest	PROC

; 1032 : {

$LN53:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 30 01
	00 00		 sub	 rsp, 304		; 00000130H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1033 :     char* p2 = NULL;                /* Resolved symbol string        */

  00029	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR p2$[rsp], 0

; 1034 :     struct timeval beg, now, dur;   /* To calculate remaining time   */
; 1035 :     double secs = DEF_RUNTEST_DUR;  /* Optional timeout in seconds   */

  00032	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@403e000000000000
  0003a	f2 0f 11 44 24
	58		 movsd	 QWORD PTR secs$[rsp], xmm0

; 1036 :     U32 usecs;                      /* Same thing in microseconds    */
; 1037 :     U32 sleep_usecs;                /* Remaining microseconds        */
; 1038 :     U32 elapsed_usecs;              /* To calculate remaining time   */
; 1039 :     int rc;                         /* Return code from timed wait   */
; 1040 :     int dostart = 0;                /* 0 = start test via "restart"  */

  00040	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR dostart$[rsp], 0
$LN4@runtest:

; 1041 :                                     /* 1 = start test via "start"    */
; 1042 :     UNREFERENCED( cmdline );

  00048	33 c0		 xor	 eax, eax
  0004a	85 c0		 test	 eax, eax
  0004c	75 fa		 jne	 SHORT $LN4@runtest
$LN7@runtest:

; 1043 : 
; 1044 :     ASSERT( sysblk.scrtest );       /* How else did we get called?   */

  0004e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00055	83 b8 18 11 00
	00 00		 cmp	 DWORD PTR [rax+4376], 0
  0005c	75 5c		 jne	 SHORT $LN14@runtest
$LN10@runtest:
  0005e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189645
  00065	41 b8 14 04 00
	00		 mov	 r8d, 1044		; 00000414H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189646
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189647
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0007f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00085	85 c0		 test	 eax, eax
  00087	74 20		 je	 SHORT $LN15@runtest
  00089	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189649
  00090	41 b8 14 04 00
	00		 mov	 r8d, 1044		; 00000414H
  00096	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189650
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189651
  000a4	e8 00 00 00 00	 call	 DebuggerTrace
$LN15@runtest:
  000a9	33 c0		 xor	 eax, eax
  000ab	85 c0		 test	 eax, eax
  000ad	75 af		 jne	 SHORT $LN10@runtest
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b5	85 c0		 test	 eax, eax
  000b7	74 01		 je	 SHORT $LN16@runtest
  000b9	cc		 int	 3
$LN16@runtest:
$LN14@runtest:
  000ba	33 c0		 xor	 eax, eax
  000bc	85 c0		 test	 eax, eax
  000be	75 8e		 jne	 SHORT $LN7@runtest

; 1045 : 
; 1046 :     /* Parse optional RUNTEST command arguments. */
; 1047 :     /* Syntax: RUNTEST [RESTART|START] [timeout] */
; 1048 : 
; 1049 :     if (*args && *args != '#')

  000c0	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR args$[rsp]
  000c8	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000cb	85 c0		 test	 eax, eax
  000cd	0f 84 b7 03 00
	00		 je	 $LN17@runtest
  000d3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR args$[rsp]
  000db	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000de	83 f8 23	 cmp	 eax, 35			; 00000023H
  000e1	0f 84 a3 03 00
	00		 je	 $LN17@runtest

; 1050 :     {
; 1051 :         p2 = resolve_symbol_string( args );

  000e7	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  000f5	48 89 44 24 68	 mov	 QWORD PTR p2$[rsp], rax

; 1052 :         if (p2)

  000fa	48 83 7c 24 68
	00		 cmp	 QWORD PTR p2$[rsp], 0
  00100	74 0d		 je	 SHORT $LN18@runtest

; 1053 :             args = p2;

  00102	48 8b 44 24 68	 mov	 rax, QWORD PTR p2$[rsp]
  00107	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR args$[rsp], rax
$LN18@runtest:

; 1054 : 
; 1055 :         if (isalpha( args[0] ))  /* [RESTART|START|<oldpsw>]? */

  0010f	b8 01 00 00 00	 mov	 eax, 1
  00114	48 6b c0 00	 imul	 rax, rax, 0
  00118	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00120	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00124	8b c8		 mov	 ecx, eax
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  0012c	85 c0		 test	 eax, eax
  0012e	0f 84 70 01 00
	00		 je	 $LN19@runtest

; 1056 :         {
; 1057 : #define MAX_KW_LEN 15
; 1058 :             char kw[ MAX_KW_LEN + 1 ] = {0};

  00134	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR kw$5[rsp]
  0013c	48 8b f8	 mov	 rdi, rax
  0013f	33 c0		 xor	 eax, eax
  00141	b9 10 00 00 00	 mov	 ecx, 16
  00146	f3 aa		 rep stosb

; 1059 :             char* pkw = NULL;

  00148	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR pkw$2[rsp], 0

; 1060 : 
; 1061 :             if (sscanf( args, "%"QSTR( MAX_KW_LEN )"s %lf", kw, &secs ))

  00154	4c 8d 4c 24 58	 lea	 r9, QWORD PTR secs$[rsp]
  00159	4c 8d 84 24 c0
	00 00 00	 lea	 r8, QWORD PTR kw$5[rsp]
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189658
  00168	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00170	e8 00 00 00 00	 call	 sscanf
  00175	85 c0		 test	 eax, eax
  00177	74 61		 je	 SHORT $LN20@runtest

; 1062 :             {
; 1063 :                 if (!strcasecmp( kw, "start" ))

  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189661
  00180	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR kw$5[rsp]
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0018e	85 c0		 test	 eax, eax
  00190	75 0a		 jne	 SHORT $LN22@runtest

; 1064 :                     dostart = 1;

  00192	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR dostart$[rsp], 1
  0019a	eb 3c		 jmp	 SHORT $LN23@runtest
$LN22@runtest:

; 1065 :                 else if (!strcasecmp( kw, "restart" ))

  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189664
  001a3	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR kw$5[rsp]
  001ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001b1	85 c0		 test	 eax, eax
  001b3	75 02		 jne	 SHORT $LN24@runtest

; 1066 :                     ;                 /* Do nothing                  */

  001b5	eb 21		 jmp	 SHORT $LN25@runtest
$LN24@runtest:

; 1067 :                 else if (!set_restart(kw))

  001b7	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR kw$5[rsp]
  001bf	e8 00 00 00 00	 call	 set_restart
  001c4	85 c0		 test	 eax, eax
  001c6	75 10		 jne	 SHORT $LN26@runtest

; 1068 :                     pkw = kw;         /* Not valid restart           */

  001c8	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR kw$5[rsp]
  001d0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pkw$2[rsp], rax
$LN26@runtest:
$LN25@runtest:
$LN23@runtest:

; 1069 :             }

  001d8	eb 10		 jmp	 SHORT $LN21@runtest
$LN20@runtest:

; 1070 :             else
; 1071 :                 pkw = args;

  001da	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR args$[rsp]
  001e2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pkw$2[rsp], rax
$LN21@runtest:

; 1072 : 
; 1073 :             if (pkw)

  001ea	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pkw$2[rsp], 0
  001f3	0f 84 88 00 00
	00		 je	 $LN27@runtest

; 1074 :             {
; 1075 :                 // "Script %d: test: unknown runtest keyword: %s"
; 1076 :                 WRMSG( HHC02341, "E", pCtl->scr_id, pkw );

  001f9	b9 01 00 00 00	 mov	 ecx, 1
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00204	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pkw$2[rsp]
  0020c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00211	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00219	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0021c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00220	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189667
  00227	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189668
  00233	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00238	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00243	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189669
  0024a	ba 34 04 00 00	 mov	 edx, 1076		; 00000434H
  0024f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189670
  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1077 :                 if (p2)

  0025c	48 83 7c 24 68
	00		 cmp	 QWORD PTR p2$[rsp], 0
  00262	74 0b		 je	 SHORT $LN28@runtest

; 1078 :                     free( p2 );

  00264	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p2$[rsp]
  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN28@runtest:

; 1079 :                 return test_abort( pCtl );

  0026f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00277	e8 00 00 00 00	 call	 test_abort
  0027c	e9 52 08 00 00	 jmp	 $LN1@runtest
$LN27@runtest:

; 1080 :             }
; 1081 : 
; 1082 :             /* Get past keyword to next argument */
; 1083 :             args += strlen( kw );

  00281	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR kw$5[rsp]
  00289	e8 00 00 00 00	 call	 strlen
  0028e	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  00296	48 03 c8	 add	 rcx, rax
  00299	48 8b c1	 mov	 rax, rcx
  0029c	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR args$[rsp], rax
$LN19@runtest:

; 1084 :         }
; 1085 : 
; 1086 :         if ( args[0] ) /* [timeout]? */

  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	48 6b c0 00	 imul	 rax, rax, 0
  002ad	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR args$[rsp]
  002b5	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  002b9	85 c0		 test	 eax, eax
  002bb	0f 84 b6 01 00
	00		 je	 $LN29@runtest

; 1087 :         {
; 1088 :             char without_comment[64];
; 1089 :             char* pszComment;
; 1090 :             BYTE c;
; 1091 : 
; 1092 :             STRLCPY( without_comment, args );

  002c1	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  002c7	48 8b 94 24 50
	01 00 00	 mov	 rdx, QWORD PTR args$[rsp]
  002cf	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR without_comment$7[rsp]
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1093 : 
; 1094 :             pszComment = strchr( without_comment, '#' );

  002dd	ba 23 00 00 00	 mov	 edx, 35			; 00000023H
  002e2	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR without_comment$7[rsp]
  002ea	e8 00 00 00 00	 call	 strchr
  002ef	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR pszComment$4[rsp], rax

; 1095 : 
; 1096 :             if (pszComment)

  002f7	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR pszComment$4[rsp], 0
  00300	74 0b		 je	 SHORT $LN30@runtest

; 1097 :                *pszComment = 0;

  00302	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR pszComment$4[rsp]
  0030a	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN30@runtest:

; 1098 : 
; 1099 :             RTRIM( without_comment );

  0030d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189674
  00314	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR without_comment$7[rsp]
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 1100 : 
; 1101 :             if (0
; 1102 :                 || (rc = sscanf( without_comment, "%lf%c", &secs, &c )) != 1
; 1103 :                 || secs < MIN_RUNTEST_DUR
; 1104 :                 || secs > MAX_RUNTEST_DUR

  00322	33 c0		 xor	 eax, eax
  00324	85 c0		 test	 eax, eax
  00326	75 4d		 jne	 SHORT $LN32@runtest
  00328	4c 8d 4c 24 64	 lea	 r9, QWORD PTR c$1[rsp]
  0032d	4c 8d 44 24 58	 lea	 r8, QWORD PTR secs$[rsp]
  00332	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189677
  00339	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR without_comment$7[rsp]
  00341	e8 00 00 00 00	 call	 sscanf
  00346	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0034a	83 7c 24 50 01	 cmp	 DWORD PTR rc$[rsp], 1
  0034f	75 24		 jne	 SHORT $LN32@runtest
  00351	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  00359	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR secs$[rsp]
  0035f	77 14		 ja	 SHORT $LN32@runtest
  00361	f2 0f 10 44 24
	58		 movsd	 xmm0, QWORD PTR secs$[rsp]
  00367	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4072c00000000000
  0036f	0f 86 02 01 00
	00		 jbe	 $LN31@runtest
$LN32@runtest:

; 1105 :             )
; 1106 :             {
; 1107 :                 int new_secs;
; 1108 :                 char badval[16];
; 1109 : 
; 1110 :                 MSGBUF( badval, "%s", without_comment );

  00375	4c 8d 8c 24 e0
	00 00 00	 lea	 r9, QWORD PTR without_comment$7[rsp]
  0037d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189678
  00384	ba 10 00 00 00	 mov	 edx, 16
  00389	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR badval$6[rsp]
  00391	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1111 : 
; 1112 :                 if (rc != 1)

  00397	83 7c 24 50 01	 cmp	 DWORD PTR rc$[rsp], 1
  0039c	74 10		 je	 SHORT $LN33@runtest

; 1113 :                     secs = DEF_RUNTEST_DUR;

  0039e	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@403e000000000000
  003a6	f2 0f 11 44 24
	58		 movsd	 QWORD PTR secs$[rsp], xmm0
  003ac	eb 4e		 jmp	 SHORT $LN34@runtest
$LN33@runtest:

; 1114 :                 else
; 1115 :                 if (secs < MIN_RUNTEST_DUR)

  003ae	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  003b6	66 0f 2f 44 24
	58		 comisd	 xmm0, QWORD PTR secs$[rsp]
  003bc	76 10		 jbe	 SHORT $LN35@runtest

; 1116 :                     secs = MIN_RUNTEST_DUR;

  003be	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  003c6	f2 0f 11 44 24
	58		 movsd	 QWORD PTR secs$[rsp], xmm0
  003cc	eb 2e		 jmp	 SHORT $LN36@runtest
$LN35@runtest:

; 1117 :                 else
; 1118 :                 if (secs > MAX_RUNTEST_DUR)

  003ce	f2 0f 10 44 24
	58		 movsd	 xmm0, QWORD PTR secs$[rsp]
  003d4	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4072c00000000000
  003dc	76 10		 jbe	 SHORT $LN37@runtest

; 1119 :                     secs = MAX_RUNTEST_DUR;

  003de	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4072c00000000000
  003e6	f2 0f 11 44 24
	58		 movsd	 QWORD PTR secs$[rsp], xmm0
  003ec	eb 0e		 jmp	 SHORT $LN38@runtest
$LN37@runtest:

; 1120 :                 else 
; 1121 :                     secs = DEF_RUNTEST_DUR;

  003ee	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@403e000000000000
  003f6	f2 0f 11 44 24
	58		 movsd	 QWORD PTR secs$[rsp], xmm0
$LN38@runtest:
$LN36@runtest:
$LN34@runtest:

; 1122 : 
; 1123 :                 // NOTE: fails if secs < 0.5 (new_secs = 0)
; 1124 :                 // but we don't care.
; 1125 :                 new_secs = (int) secs;

  003fc	f2 0f 2c 44 24
	58		 cvttsd2si eax, QWORD PTR secs$[rsp]
  00402	89 84 24 88 00
	00 00		 mov	 DWORD PTR new_secs$3[rsp], eax

; 1126 : 
; 1127 :                 // "Script %d: test: invalid timeout %s; set to %d instead"
; 1128 :                 WRMSG( HHC02335, "W", pCtl->scr_id, badval, new_secs );

  00409	b9 01 00 00 00	 mov	 ecx, 1
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00414	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR new_secs$3[rsp]
  0041b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0041f	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR badval$6[rsp]
  00427	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0042c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00434	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00437	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189685
  00442	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189686
  0044e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00453	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00458	41 b9 03 00 00
	00		 mov	 r9d, 3
  0045e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189687
  00465	ba 68 04 00 00	 mov	 edx, 1128		; 00000468H
  0046a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189688
  00471	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@runtest:
$LN29@runtest:

; 1129 :             }
; 1130 :         }
; 1131 : 
; 1132 :         if (p2)

  00477	48 83 7c 24 68
	00		 cmp	 QWORD PTR p2$[rsp], 0
  0047d	74 0b		 je	 SHORT $LN39@runtest

; 1133 :             free( p2 );

  0047f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR p2$[rsp]
  00484	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN39@runtest:
$LN17@runtest:

; 1134 :     }
; 1135 : 
; 1136 :     /* Apply adjustment factor */
; 1137 :     if (sysblk.scrfactor)

  0048a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00491	f2 0f 10 80 20
	11 00 00	 movsd	 xmm0, QWORD PTR [rax+4384]
  00499	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  004a1	7a 02		 jp	 SHORT $LN52@runtest
  004a3	74 1b		 je	 SHORT $LN40@runtest
$LN52@runtest:

; 1138 :         secs *= sysblk.scrfactor;

  004a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004ac	f2 0f 10 44 24
	58		 movsd	 xmm0, QWORD PTR secs$[rsp]
  004b2	f2 0f 59 80 20
	11 00 00	 mulsd	 xmm0, QWORD PTR [rax+4384]
  004ba	f2 0f 11 44 24
	58		 movsd	 QWORD PTR secs$[rsp], xmm0
$LN40@runtest:

; 1139 : 
; 1140 :     /* Calculate maximum duration */
; 1141 :     usecs = (U32) (secs * 1000000.0);

  004c0	f2 0f 10 44 24
	58		 movsd	 xmm0, QWORD PTR secs$[rsp]
  004c6	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@412e848000000000
  004ce	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  004d3	89 44 24 60	 mov	 DWORD PTR usecs$[rsp], eax

; 1142 : 
; 1143 :     if (MLVL( VERBOSE ))

  004d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004de	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  004e4	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  004e9	85 c0		 test	 eax, eax
  004eb	0f 84 ec 00 00
	00		 je	 $LN41@runtest

; 1144 :     {
; 1145 :         // "Script %d: test: test starting"
; 1146 :         WRMSG( HHC02336, "I", pCtl->scr_id );

  004f1	b9 01 00 00 00	 mov	 ecx, 1
  004f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004fc	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00504	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00507	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0050b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189692
  00512	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00517	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189693
  0051e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00523	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00528	41 b9 03 00 00
	00		 mov	 r9d, 3
  0052e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189694
  00535	ba 7a 04 00 00	 mov	 edx, 1146		; 0000047aH
  0053a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189695
  00541	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1147 :         // "Script %d: test: duration limit: %"PRId32".%06"PRId32" seconds"
; 1148 :         WRMSG( HHC02339, "I", pCtl->scr_id, usecs / 1000000,

  00547	33 d2		 xor	 edx, edx
  00549	8b 44 24 60	 mov	 eax, DWORD PTR usecs$[rsp]
  0054d	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00552	f7 f1		 div	 ecx
  00554	8b c2		 mov	 eax, edx
  00556	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv233[rsp], eax
  0055d	33 d2		 xor	 edx, edx
  0055f	8b 44 24 60	 mov	 eax, DWORD PTR usecs$[rsp]
  00563	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00568	f7 f1		 div	 ecx
  0056a	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv235[rsp], eax
  00571	b9 01 00 00 00	 mov	 ecx, 1
  00576	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0057c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv233[rsp]
  00583	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00587	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv235[rsp]
  0058e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00592	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0059a	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0059d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189696
  005a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189697
  005b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005be	41 b9 03 00 00
	00		 mov	 r9d, 3
  005c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189698
  005cb	ba 7d 04 00 00	 mov	 edx, 1149		; 0000047dH
  005d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189699
  005d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN41@runtest:

; 1149 :                                             usecs % 1000000 );
; 1150 :     }
; 1151 : 
; 1152 :     /* Press the restart or start button to start the test */
; 1153 : 
; 1154 :     obtain_lock( &sysblk.scrlock );

  005dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005e4	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  005ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189700
  005f1	48 8b c8	 mov	 rcx, rax
  005f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1155 :     sysblk.scrtest = 1; /*(reset)*/

  005fa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00601	c7 80 18 11 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4376], 1

; 1156 :     release_lock( &sysblk.scrlock );

  0060b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00612	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00618	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189701
  0061f	48 8b c8	 mov	 rcx, rax
  00622	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1157 : 
; 1158 :     if (dostart)

  00628	83 7c 24 70 00	 cmp	 DWORD PTR dostart$[rsp], 0
  0062d	74 12		 je	 SHORT $LN42@runtest

; 1159 :         rc = start_cmd_cpu( 0, NULL, NULL );

  0062f	45 33 c0	 xor	 r8d, r8d
  00632	33 d2		 xor	 edx, edx
  00634	33 c9		 xor	 ecx, ecx
  00636	e8 00 00 00 00	 call	 start_cmd_cpu
  0063b	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
  0063f	eb 10		 jmp	 SHORT $LN43@runtest
$LN42@runtest:

; 1160 :     else
; 1161 :         rc = restart_cmd( 0, NULL, NULL );

  00641	45 33 c0	 xor	 r8d, r8d
  00644	33 d2		 xor	 edx, edx
  00646	33 c9		 xor	 ecx, ecx
  00648	e8 00 00 00 00	 call	 restart_cmd
  0064d	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN43@runtest:

; 1162 : 
; 1163 :     if (rc)

  00651	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00656	74 68		 je	 SHORT $LN44@runtest

; 1164 :     {
; 1165 :         // "Script %d: test: [re]start failed"
; 1166 :         WRMSG( HHC02330, "E", pCtl->scr_id );

  00658	b9 01 00 00 00	 mov	 ecx, 1
  0065d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00663	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0066b	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0066e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00672	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189705
  00679	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0067e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189706
  00685	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0068a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0068f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00695	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189707
  0069c	ba 8e 04 00 00	 mov	 edx, 1166		; 0000048eH
  006a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189708
  006a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1167 :         return test_abort( pCtl );

  006ae	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  006b6	e8 00 00 00 00	 call	 test_abort
  006bb	e9 13 04 00 00	 jmp	 $LN1@runtest
$LN44@runtest:

; 1168 :     }
; 1169 : 
; 1170 :     if (MLVL( VERBOSE ))

  006c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006c7	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  006cd	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  006d2	85 c0		 test	 eax, eax
  006d4	74 56		 je	 SHORT $LN45@runtest

; 1171 :         // "Script %d: test: running..."
; 1172 :         WRMSG( HHC02333, "I", pCtl->scr_id );

  006d6	b9 01 00 00 00	 mov	 ecx, 1
  006db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006e1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  006e9	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  006ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189710
  006f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189711
  00703	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00708	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0070d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00713	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189712
  0071a	ba 94 04 00 00	 mov	 edx, 1172		; 00000494H
  0071f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189713
  00726	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN45@runtest:

; 1173 : 
; 1174 :     obtain_lock( &sysblk.scrlock );

  0072c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00733	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00739	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189714
  00740	48 8b c8	 mov	 rcx, rax
  00743	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1175 :     gettimeofday( &beg, NULL );

  00749	33 d2		 xor	 edx, edx
  0074b	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR beg$[rsp]
  00753	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday
$LN11@runtest:

; 1176 :     for (;;)
; 1177 :     {
; 1178 :         /* Check for cancelled script */
; 1179 :         if (pCtl && script_abort( pCtl ))

  00759	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR pCtl$[rsp], 0
  00762	74 38		 je	 SHORT $LN46@runtest
  00764	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0076c	e8 00 00 00 00	 call	 script_abort
  00771	85 c0		 test	 eax, eax
  00773	74 27		 je	 SHORT $LN46@runtest

; 1180 :         {
; 1181 :             release_lock( &sysblk.scrlock );

  00775	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0077c	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00782	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189716
  00789	48 8b c8	 mov	 rcx, rax
  0078c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1182 :             return -1;

  00792	b8 ff ff ff ff	 mov	 eax, -1
  00797	e9 37 03 00 00	 jmp	 $LN1@runtest
$LN46@runtest:

; 1183 :         }
; 1184 : 
; 1185 :         /*           Has the test completed yet?
; 1186 :         **
; 1187 :         ** Before test scripts are started the sysblk.scrtest
; 1188 :         ** counter is always reset to '1' to indicate testing
; 1189 :         ** mode is active (see further above). When each CPU
; 1190 :         ** completes its test (by either stopping or loading
; 1191 :         ** a disabled wait PSW) code in cpu.c then increments
; 1192 :         ** sysblk.scrtest. Only when sysblk.scrtest has been
; 1193 :         ** incremented past the number of configured CPUs is
; 1194 :         ** the test then considered to be complete.
; 1195 :         */
; 1196 :         if (sysblk.scrtest > sysblk.cpus)

  0079c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  007aa	8b 89 04 01 00
	00		 mov	 ecx, DWORD PTR [rcx+260]
  007b0	39 88 18 11 00
	00		 cmp	 DWORD PTR [rax+4376], ecx
  007b6	7e 0d		 jle	 SHORT $LN47@runtest

; 1197 :         {
; 1198 :             rc = 0;

  007b8	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 1199 :             break;

  007c0	e9 a2 00 00 00	 jmp	 $LN12@runtest
$LN47@runtest:

; 1200 :         }
; 1201 : 
; 1202 :         /* Calculate how long to continue waiting  */
; 1203 :         gettimeofday( &now, NULL );

  007c5	33 d2		 xor	 edx, edx
  007c7	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  007cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 1204 :         timeval_subtract( &beg, &now, &dur );

  007d5	4c 8d 44 24 78	 lea	 r8, QWORD PTR dur$[rsp]
  007da	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR now$[rsp]
  007e2	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR beg$[rsp]
  007ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeval_subtract

; 1205 :         elapsed_usecs = (dur.tv_sec * 1000000) + dur.tv_usec;

  007f0	69 44 24 78 40
	42 0f 00	 imul	 eax, DWORD PTR dur$[rsp], 1000000 ; 000f4240H
  007f8	03 44 24 7c	 add	 eax, DWORD PTR dur$[rsp+4]
  007fc	89 44 24 54	 mov	 DWORD PTR elapsed_usecs$[rsp], eax

; 1206 : 
; 1207 :         /* Is there any time remaining on the clock? */
; 1208 :         if (elapsed_usecs >= usecs)

  00800	8b 44 24 60	 mov	 eax, DWORD PTR usecs$[rsp]
  00804	39 44 24 54	 cmp	 DWORD PTR elapsed_usecs$[rsp], eax
  00808	72 0a		 jb	 SHORT $LN48@runtest

; 1209 :         {
; 1210 :             rc = ETIMEDOUT;

  0080a	c7 44 24 50 8a
	00 00 00	 mov	 DWORD PTR rc$[rsp], 138	; 0000008aH

; 1211 :             break;

  00812	eb 53		 jmp	 SHORT $LN12@runtest
$LN48@runtest:

; 1212 :         }
; 1213 : 
; 1214 :         /* Sleep until we're woken or we run out of time */
; 1215 :         sleep_usecs = (usecs - elapsed_usecs);

  00814	8b 44 24 54	 mov	 eax, DWORD PTR elapsed_usecs$[rsp]
  00818	8b 4c 24 60	 mov	 ecx, DWORD PTR usecs$[rsp]
  0081c	2b c8		 sub	 ecx, eax
  0081e	8b c1		 mov	 eax, ecx
  00820	89 84 24 94 00
	00 00		 mov	 DWORD PTR sleep_usecs$[rsp], eax

; 1216 :         timed_wait_condition_relative_usecs(

  00827	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0082e	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00834	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0083b	48 81 c1 10 11
	00 00		 add	 rcx, 4368		; 00001110H
  00842	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189719
  00849	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0084e	45 33 c9	 xor	 r9d, r9d
  00851	44 8b 84 24 94
	00 00 00	 mov	 r8d, DWORD PTR sleep_usecs$[rsp]
  00859	48 8b d0	 mov	 rdx, rax
  0085c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl

; 1217 :             &sysblk.scrcond, &sysblk.scrlock, sleep_usecs, NULL );
; 1218 :     }

  00862	e9 f2 fe ff ff	 jmp	 $LN11@runtest
$LN12@runtest:

; 1219 :     gettimeofday( &now, NULL );

  00867	33 d2		 xor	 edx, edx
  00869	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  00871	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 1220 :     timeval_subtract( &beg, &now, &dur );

  00877	4c 8d 44 24 78	 lea	 r8, QWORD PTR dur$[rsp]
  0087c	48 8d 94 24 a8
	00 00 00	 lea	 rdx, QWORD PTR now$[rsp]
  00884	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR beg$[rsp]
  0088c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeval_subtract

; 1221 :     elapsed_usecs = (dur.tv_sec * 1000000) + dur.tv_usec;

  00892	69 44 24 78 40
	42 0f 00	 imul	 eax, DWORD PTR dur$[rsp], 1000000 ; 000f4240H
  0089a	03 44 24 7c	 add	 eax, DWORD PTR dur$[rsp+4]
  0089e	89 44 24 54	 mov	 DWORD PTR elapsed_usecs$[rsp], eax

; 1222 :     release_lock( &sysblk.scrlock );

  008a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008a9	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  008af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189720
  008b6	48 8b c8	 mov	 rcx, rax
  008b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1223 : 
; 1224 :     if (ETIMEDOUT == rc)

  008bf	81 7c 24 50 8a
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 138	; 0000008aH
  008c7	0f 85 fe 00 00
	00		 jne	 $LN49@runtest

; 1225 :     {
; 1226 :         // "Script %d: test: timeout"
; 1227 :         WRMSG( HHC02332, "E", pCtl->scr_id );

  008cd	b9 01 00 00 00	 mov	 ecx, 1
  008d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008d8	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  008e0	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  008e3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189722
  008ee	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189723
  008fa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00904	41 b9 03 00 00
	00		 mov	 r9d, 3
  0090a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189724
  00911	ba cb 04 00 00	 mov	 edx, 1227		; 000004cbH
  00916	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189725
  0091d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1228 :         // "Script %d: test: actual duration: %"PRId32".%06"PRId32" seconds"
; 1229 :         WRMSG( HHC02338, "I", pCtl->scr_id, elapsed_usecs / 1000000,

  00923	33 d2		 xor	 edx, edx
  00925	8b 44 24 54	 mov	 eax, DWORD PTR elapsed_usecs$[rsp]
  00929	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0092e	f7 f1		 div	 ecx
  00930	8b c2		 mov	 eax, edx
  00932	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv377[rsp], eax
  00939	33 d2		 xor	 edx, edx
  0093b	8b 44 24 54	 mov	 eax, DWORD PTR elapsed_usecs$[rsp]
  0093f	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00944	f7 f1		 div	 ecx
  00946	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv379[rsp], eax
  0094d	b9 01 00 00 00	 mov	 ecx, 1
  00952	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00958	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv377[rsp]
  0095f	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00963	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv379[rsp]
  0096a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0096e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00976	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00979	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0097d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189726
  00984	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00989	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189727
  00990	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00995	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0099a	41 b9 03 00 00
	00		 mov	 r9d, 3
  009a0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189728
  009a7	ba ce 04 00 00	 mov	 edx, 1230		; 000004ceH
  009ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189729
  009b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1230 :                                             elapsed_usecs % 1000000 );
; 1231 :         return test_abort( pCtl );

  009b9	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  009c1	e8 00 00 00 00	 call	 test_abort
  009c6	e9 08 01 00 00	 jmp	 $LN1@runtest
$LN49@runtest:

; 1232 :     }
; 1233 : 
; 1234 :     if (MLVL( VERBOSE ))

  009cb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009d2	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  009d8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  009dd	85 c0		 test	 eax, eax
  009df	0f 84 ec 00 00
	00		 je	 $LN50@runtest

; 1235 :     {
; 1236 :         // "Script %d: test: test ended"
; 1237 :         WRMSG( HHC02334, "I", pCtl->scr_id );

  009e5	b9 01 00 00 00	 mov	 ecx, 1
  009ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009f0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  009f8	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  009fb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189731
  00a06	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a0b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189732
  00a12	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a17	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a1c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a22	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189733
  00a29	ba d5 04 00 00	 mov	 edx, 1237		; 000004d5H
  00a2e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189734
  00a35	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1238 :         // "Script %d: test: actual duration: %"PRId32".%06"PRId32" seconds"
; 1239 :         WRMSG( HHC02338, "I", pCtl->scr_id, elapsed_usecs / 1000000,

  00a3b	33 d2		 xor	 edx, edx
  00a3d	8b 44 24 54	 mov	 eax, DWORD PTR elapsed_usecs$[rsp]
  00a41	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00a46	f7 f1		 div	 ecx
  00a48	8b c2		 mov	 eax, edx
  00a4a	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv408[rsp], eax
  00a51	33 d2		 xor	 edx, edx
  00a53	8b 44 24 54	 mov	 eax, DWORD PTR elapsed_usecs$[rsp]
  00a57	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00a5c	f7 f1		 div	 ecx
  00a5e	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv410[rsp], eax
  00a65	b9 01 00 00 00	 mov	 ecx, 1
  00a6a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a70	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv408[rsp]
  00a77	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00a7b	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv410[rsp]
  00a82	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a86	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00a8e	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00a91	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a95	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189735
  00a9c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00aa1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189736
  00aa8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ab2	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ab8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189737
  00abf	ba d8 04 00 00	 mov	 edx, 1240		; 000004d8H
  00ac4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189738
  00acb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN50@runtest:

; 1240 :                                             elapsed_usecs % 1000000 );
; 1241 :     }
; 1242 : 
; 1243 :     return 0;

  00ad1	33 c0		 xor	 eax, eax
$LN1@runtest:

; 1244 : }

  00ad3	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00adb	48 33 cc	 xor	 rcx, rsp
  00ade	e8 00 00 00 00	 call	 __security_check_cookie
  00ae3	48 81 c4 30 01
	00 00		 add	 rsp, 304		; 00000130H
  00aea	5f		 pop	 rdi
  00aeb	c3		 ret	 0
runtest	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
pCtl$ = 80
test_abort PROC

; 1020 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1021 :     // "Script %d: test: aborted"
; 1022 :     WRMSG( HHC02331, "E", pCtl->scr_id );

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00019	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0001c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189587
  00027	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189588
  00033	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00038	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00043	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189589
  0004a	ba fe 03 00 00	 mov	 edx, 1022		; 000003feH
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189590
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1023 :     panel_command( "stopall");

  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189591
  00063	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0006a	ff 10		 call	 QWORD PTR [rax]

; 1024 :     panel_command( "sysreset");

  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189592
  00073	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0007a	ff 10		 call	 QWORD PTR [rax]

; 1025 :     return -1;

  0007c	b8 ff ff ff ff	 mov	 eax, -1

; 1026 : }

  00081	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00085	c3		 ret	 0
test_abort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
argc$ = 80
argv$ = 88
cmdline$ = 96
$runtest_cmd PROC

; 1006 : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@$runtest_c:

; 1007 :     UNREFERENCED( argc );

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@$runtest_c
$LN7@$runtest_c:

; 1008 :     UNREFERENCED( argv );

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN7@$runtest_c
$LN10@$runtest_c:

; 1009 :     UNREFERENCED( cmdline );

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN10@$runtest_c

; 1010 : 
; 1011 :     // "runtest is only valid as a scripting command"
; 1012 :     WRMSG( HHC02337, "E" );

  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189579
  00036	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189580
  00042	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00047	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00052	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189581
  00059	ba f4 03 00 00	 mov	 edx, 1012		; 000003f4H
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189582
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1013 :     return -1;

  0006b	b8 ff ff ff ff	 mov	 eax, -1

; 1014 : }

  00070	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00074	c3		 ret	 0
$runtest_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
rc$ = 64
rc2$1 = 68
i$2 = 72
pCtl$ = 80
tv137 = 88
tv140 = 92
tid$ = 96
scr_cmdline$ = 104
tv175 = 112
argc$ = 144
argv$ = 152
cmdline$ = 160
script_cmd PROC

; 937  : {

$LN28:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 938  :     char*    scr_cmdline = NULL;    /* Copy of original command-line */

  00015	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR scr_cmdline$[rsp], 0

; 939  :     TID      tid   = thread_id();

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00024	89 44 24 60	 mov	 DWORD PTR tid$[rsp], eax

; 940  :     SCRCTL*  pCtl  = NULL;

  00028	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR pCtl$[rsp], 0

; 941  :     int      rc    = 0;

  00031	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN4@script_cmd:

; 942  : 
; 943  :     ASSERT( cmdline && *cmdline );  /* (sanity check) */

  00039	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR cmdline$[rsp], 0
  00042	74 0f		 je	 SHORT $LN12@script_cmd
  00044	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR cmdline$[rsp]
  0004c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0004f	85 c0		 test	 eax, eax
  00051	75 5c		 jne	 SHORT $LN11@script_cmd
$LN12@script_cmd:
$LN7@script_cmd:
  00053	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189533
  0005a	41 b8 af 03 00
	00		 mov	 r8d, 943		; 000003afH
  00060	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189534
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189535
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0007a	85 c0		 test	 eax, eax
  0007c	74 20		 je	 SHORT $LN13@script_cmd
  0007e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189537
  00085	41 b8 af 03 00
	00		 mov	 r8d, 943		; 000003afH
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189538
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189539
  00099	e8 00 00 00 00	 call	 DebuggerTrace
$LN13@script_cmd:
  0009e	33 c0		 xor	 eax, eax
  000a0	85 c0		 test	 eax, eax
  000a2	75 af		 jne	 SHORT $LN7@script_cmd
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000aa	85 c0		 test	 eax, eax
  000ac	74 01		 je	 SHORT $LN14@script_cmd
  000ae	cc		 int	 3
$LN14@script_cmd:
$LN11@script_cmd:
  000af	33 c0		 xor	 eax, eax
  000b1	85 c0		 test	 eax, eax
  000b3	75 84		 jne	 SHORT $LN4@script_cmd

; 944  : 
; 945  :     /* Display all running scripts if no arguments given */
; 946  :     if (argc <= 1)

  000b5	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  000bd	7f 0c		 jg	 SHORT $LN15@script_cmd

; 947  :     {
; 948  :         ListScriptsIds();

  000bf	e8 00 00 00 00	 call	 ListScriptsIds

; 949  :         return 0;

  000c4	33 c0		 xor	 eax, eax
  000c6	e9 da 02 00 00	 jmp	 $LN1@script_cmd
$LN15@script_cmd:

; 950  :     }
; 951  : 
; 952  :     /* Find script processing control entry for this thead */
; 953  :     if ((pCtl = FindSCRCTL( tid )) != NULL)

  000cb	8b 4c 24 60	 mov	 ecx, DWORD PTR tid$[rsp]
  000cf	e8 00 00 00 00	 call	 FindSCRCTL
  000d4	48 89 44 24 50	 mov	 QWORD PTR pCtl$[rsp], rax
  000d9	48 83 7c 24 50
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  000df	0f 84 e3 00 00
	00		 je	 $LN16@script_cmd

; 954  :     {
; 955  :         /* This script command is issued from a script.  It does not */
; 956  :         /* necessarily cause a recursion.                            */
; 957  :         int i, rc2 = 0;

  000e5	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR rc2$1[rsp], 0

; 958  :         for (i=1; !script_abort( pCtl ) && i < argc; i++)

  000ed	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR i$2[rsp], 1
  000f5	eb 0a		 jmp	 SHORT $LN10@script_cmd
$LN8@script_cmd:
  000f7	8b 44 24 48	 mov	 eax, DWORD PTR i$2[rsp]
  000fb	ff c0		 inc	 eax
  000fd	89 44 24 48	 mov	 DWORD PTR i$2[rsp], eax
$LN10@script_cmd:
  00101	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00106	e8 00 00 00 00	 call	 script_abort
  0010b	85 c0		 test	 eax, eax
  0010d	0f 85 ac 00 00
	00		 jne	 $LN9@script_cmd
  00113	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0011a	39 44 24 48	 cmp	 DWORD PTR i$2[rsp], eax
  0011e	0f 8d 9b 00 00
	00		 jge	 $LN9@script_cmd

; 959  :         {
; 960  :             UpdSCRCTL( pCtl, argv[i] );

  00124	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$2[rsp]
  00129	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00131	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00135	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0013a	e8 00 00 00 00	 call	 UpdSCRCTL

; 961  :             rc = process_script_file( argv[i], false );

  0013f	48 63 44 24 48	 movsxd	 rax, DWORD PTR i$2[rsp]
  00144	33 d2		 xor	 edx, edx
  00146	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0014e	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00152	e8 00 00 00 00	 call	 process_script_file
  00157	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax

; 962  :             if (0 <= rc2 && 0 < rc) rc2 = MAX( rc, rc2 );

  0015b	83 7c 24 44 00	 cmp	 DWORD PTR rc2$1[rsp], 0
  00160	7c 2d		 jl	 SHORT $LN17@script_cmd
  00162	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00167	7e 26		 jle	 SHORT $LN17@script_cmd
  00169	8b 44 24 44	 mov	 eax, DWORD PTR rc2$1[rsp]
  0016d	39 44 24 40	 cmp	 DWORD PTR rc$[rsp], eax
  00171	7e 0a		 jle	 SHORT $LN24@script_cmd
  00173	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
  00177	89 44 24 58	 mov	 DWORD PTR tv137[rsp], eax
  0017b	eb 08		 jmp	 SHORT $LN25@script_cmd
$LN24@script_cmd:
  0017d	8b 44 24 44	 mov	 eax, DWORD PTR rc2$1[rsp]
  00181	89 44 24 58	 mov	 DWORD PTR tv137[rsp], eax
$LN25@script_cmd:
  00185	8b 44 24 58	 mov	 eax, DWORD PTR tv137[rsp]
  00189	89 44 24 44	 mov	 DWORD PTR rc2$1[rsp], eax
  0018d	eb 2b		 jmp	 SHORT $LN18@script_cmd
$LN17@script_cmd:

; 963  :             else if (0 > rc) rc2 = MIN( rc, rc2 );

  0018f	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  00194	7d 24		 jge	 SHORT $LN19@script_cmd
  00196	8b 44 24 44	 mov	 eax, DWORD PTR rc2$1[rsp]
  0019a	39 44 24 40	 cmp	 DWORD PTR rc$[rsp], eax
  0019e	7d 0a		 jge	 SHORT $LN26@script_cmd
  001a0	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
  001a4	89 44 24 5c	 mov	 DWORD PTR tv140[rsp], eax
  001a8	eb 08		 jmp	 SHORT $LN27@script_cmd
$LN26@script_cmd:
  001aa	8b 44 24 44	 mov	 eax, DWORD PTR rc2$1[rsp]
  001ae	89 44 24 5c	 mov	 DWORD PTR tv140[rsp], eax
$LN27@script_cmd:
  001b2	8b 44 24 5c	 mov	 eax, DWORD PTR tv140[rsp]
  001b6	89 44 24 44	 mov	 DWORD PTR rc2$1[rsp], eax
$LN19@script_cmd:
$LN18@script_cmd:

; 964  :         }

  001ba	e9 38 ff ff ff	 jmp	 $LN8@script_cmd
$LN9@script_cmd:

; 965  :         return rc2;

  001bf	8b 44 24 44	 mov	 eax, DWORD PTR rc2$1[rsp]
  001c3	e9 dd 01 00 00	 jmp	 $LN1@script_cmd
$LN16@script_cmd:

; 966  :     }
; 967  : 
; 968  :     /* Create control entry and add to list */
; 969  :     if (!(pCtl = NewSCRCTL( 0, argv[1] )))

  001c8	b8 08 00 00 00	 mov	 eax, 8
  001cd	48 6b c0 01	 imul	 rax, rax, 1
  001d1	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001d9	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  001dd	33 c9		 xor	 ecx, ecx
  001df	e8 00 00 00 00	 call	 NewSCRCTL
  001e4	48 89 44 24 50	 mov	 QWORD PTR pCtl$[rsp], rax
  001e9	48 83 7c 24 50
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  001ef	75 0a		 jne	 SHORT $LN20@script_cmd

; 970  :         return -1; /* (error msg already issued) */

  001f1	b8 ff ff ff ff	 mov	 eax, -1
  001f6	e9 aa 01 00 00	 jmp	 $LN1@script_cmd
$LN20@script_cmd:

; 971  : 
; 972  :     /* Create a copy of the command line */
; 973  :     if (!(scr_cmdline = strdup( cmdline )))

  001fb	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00209	48 89 44 24 68	 mov	 QWORD PTR scr_cmdline$[rsp], rax
  0020e	48 83 7c 24 68
	00		 cmp	 QWORD PTR scr_cmdline$[rsp], 0
  00214	75 5b		 jne	 SHORT $LN21@script_cmd

; 974  :     {
; 975  :         // "Out of memory"
; 976  :         WRMSG( HHC00152, "E" );

  00216	b9 01 00 00 00	 mov	 ecx, 1
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189548
  00228	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0022d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189549
  00234	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00239	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0023e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00244	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189550
  0024b	ba d0 03 00 00	 mov	 edx, 976		; 000003d0H
  00250	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189551
  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 977  :         FreeSCRCTL( pCtl );

  0025d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00262	e8 00 00 00 00	 call	 FreeSCRCTL

; 978  :         return -1;

  00267	b8 ff ff ff ff	 mov	 eax, -1
  0026c	e9 34 01 00 00	 jmp	 $LN1@script_cmd
$LN21@script_cmd:

; 979  :     }
; 980  : 
; 981  :     obtain_lock( &sysblk.scrlock );

  00271	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00278	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  0027e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189552
  00285	48 8b c8	 mov	 rcx, rax
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 982  :     pCtl->scr_cmdline = scr_cmdline;

  0028e	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  00293	48 8b 4c 24 68	 mov	 rcx, QWORD PTR scr_cmdline$[rsp]
  00298	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 983  : 
; 984  :     /* Create the associated script processing thread */
; 985  :     if ((rc = create_thread( &pCtl->scr_tid, DETACHED,
; 986  :         script_thread, NULL, SCRIPT_THREAD_NAME )) != 0)

  0029c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002a3	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  002a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  002ae	48 83 c1 10	 add	 rcx, 16
  002b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189554
  002b9	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  002be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189555
  002c5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002ca	45 33 c9	 xor	 r9d, r9d
  002cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:script_thread
  002d4	48 8b d0	 mov	 rdx, rax
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  002dd	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  002e1	83 7c 24 40 00	 cmp	 DWORD PTR rc$[rsp], 0
  002e6	0f 84 9a 00 00
	00		 je	 $LN22@script_cmd

; 987  :     {
; 988  :         pCtl->scr_tid = 0; /* (deactivate) */

  002ec	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  002f1	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 989  :         // "Error in function create_thread(): %s"
; 990  :         WRMSG( HHC00102, "E", strerror( rc ));

  002f8	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$[rsp]
  002fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00302	48 89 44 24 70	 mov	 QWORD PTR tv175[rsp], rax
  00307	b9 01 00 00 00	 mov	 ecx, 1
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00312	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv175[rsp]
  00317	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0031c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189556
  00323	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00328	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189557
  0032f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00334	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00339	41 b9 03 00 00
	00		 mov	 r9d, 3
  0033f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189558
  00346	ba de 03 00 00	 mov	 edx, 990		; 000003deH
  0034b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189559
  00352	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 991  :         release_lock( &sysblk.scrlock );

  00358	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0035f	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00365	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189560
  0036c	48 8b c8	 mov	 rcx, rax
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 992  :         FreeSCRCTL( pCtl );

  00375	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0037a	e8 00 00 00 00	 call	 FreeSCRCTL

; 993  :         return -1;

  0037f	b8 ff ff ff ff	 mov	 eax, -1
  00384	eb 1f		 jmp	 SHORT $LN1@script_cmd
$LN22@script_cmd:

; 994  :     }
; 995  : 
; 996  :     release_lock( &sysblk.scrlock );

  00386	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0038d	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00393	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189561
  0039a	48 8b c8	 mov	 rcx, rax
  0039d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 997  : 
; 998  :     return 0;

  003a3	33 c0		 xor	 eax, eax
$LN1@script_cmd:

; 999  : }

  003a5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  003ac	c3		 ret	 0
script_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
i$ = 32
pCtl$ = 40
argc$ = 48
argv$ = 64
__$ArrayPad$ = 8256
arg$ = 8288
script_thread PROC

; 892  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 58 20 00 00	 mov	 eax, 8280		; 00002058H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 40
	20 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 893  :     char*    argv[MAX_ARGS];            /* Command arguments array   */
; 894  :     int      argc;                      /* Number of cmd arguments   */
; 895  :     int      i;                         /* (work)                    */
; 896  :     SCRCTL*  pCtl  = NULL;

  00024	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pCtl$[rsp], 0
$LN4@script_thr:

; 897  : 
; 898  :     UNREFERENCED(arg);

  0002d	33 c0		 xor	 eax, eax
  0002f	85 c0		 test	 eax, eax
  00031	75 fa		 jne	 SHORT $LN4@script_thr

; 899  : 
; 900  : #ifdef LOGSCRTHREADBEGEND
; 901  :     // "Thread id "TIDPAT", prio %2d, name '%s' started"
; 902  :     LOG_THREAD_BEGIN( SCRIPT_THREAD_NAME );
; 903  : #endif
; 904  : 
; 905  :     /* Retrieve our control entry */
; 906  :     pCtl = FindSCRCTL( thread_id() );

  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 FindSCRCTL
  00040	48 89 44 24 28	 mov	 QWORD PTR pCtl$[rsp], rax
$LN7@script_thr:

; 907  :     ASSERT( pCtl && pCtl->scr_cmdline ); /* (sanity check) */

  00045	48 83 7c 24 28
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  0004b	74 0c		 je	 SHORT $LN21@script_thr
  0004d	48 8b 44 24 28	 mov	 rax, QWORD PTR pCtl$[rsp]
  00052	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00057	75 5c		 jne	 SHORT $LN20@script_thr
$LN21@script_thr:
$LN10@script_thr:
  00059	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189487
  00060	41 b8 8b 03 00
	00		 mov	 r8d, 907		; 0000038bH
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189488
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189489
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00080	85 c0		 test	 eax, eax
  00082	74 20		 je	 SHORT $LN22@script_thr
  00084	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189491
  0008b	41 b8 8b 03 00
	00		 mov	 r8d, 907		; 0000038bH
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189492
  00098	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189493
  0009f	e8 00 00 00 00	 call	 DebuggerTrace
$LN22@script_thr:
  000a4	33 c0		 xor	 eax, eax
  000a6	85 c0		 test	 eax, eax
  000a8	75 af		 jne	 SHORT $LN10@script_thr
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b0	85 c0		 test	 eax, eax
  000b2	74 01		 je	 SHORT $LN23@script_thr
  000b4	cc		 int	 3
$LN23@script_thr:
$LN20@script_thr:
  000b5	33 c0		 xor	 eax, eax
  000b7	85 c0		 test	 eax, eax
  000b9	75 8a		 jne	 SHORT $LN7@script_thr

; 908  : 
; 909  :     /* Parse the command line into its individual arguments...
; 910  :        Note: original command line now sprinkled with nulls */
; 911  :     parse_args( pCtl->scr_cmdline, MAX_ARGS, argv, &argc );

  000bb	4c 8d 4c 24 30	 lea	 r9, QWORD PTR argc$[rsp]
  000c0	4c 8d 44 24 40	 lea	 r8, QWORD PTR argv$[rsp]
  000c5	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  000ca	48 8b 44 24 28	 mov	 rax, QWORD PTR pCtl$[rsp]
  000cf	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_parse_args
$LN13@script_thr:

; 912  :     ASSERT( argc > 1 );   /* (sanity check) */

  000d9	83 7c 24 30 01	 cmp	 DWORD PTR argc$[rsp], 1
  000de	7f 5c		 jg	 SHORT $LN24@script_thr
$LN16@script_thr:
  000e0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189496
  000e7	41 b8 90 03 00
	00		 mov	 r8d, 912		; 00000390H
  000ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189497
  000f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189498
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00107	85 c0		 test	 eax, eax
  00109	74 20		 je	 SHORT $LN25@script_thr
  0010b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189500
  00112	41 b8 90 03 00
	00		 mov	 r8d, 912		; 00000390H
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189501
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189502
  00126	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@script_thr:
  0012b	33 c0		 xor	 eax, eax
  0012d	85 c0		 test	 eax, eax
  0012f	75 af		 jne	 SHORT $LN16@script_thr
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00137	85 c0		 test	 eax, eax
  00139	74 01		 je	 SHORT $LN26@script_thr
  0013b	cc		 int	 3
$LN26@script_thr:
$LN24@script_thr:
  0013c	33 c0		 xor	 eax, eax
  0013e	85 c0		 test	 eax, eax
  00140	75 97		 jne	 SHORT $LN13@script_thr

; 913  : 
; 914  :     /* Process each filename argument on this script command */
; 915  :     for (i=1; !script_abort( pCtl ) && i < argc; i++)

  00142	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0014a	eb 0a		 jmp	 SHORT $LN19@script_thr
$LN17@script_thr:
  0014c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN19@script_thr:
  00156	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0015b	e8 00 00 00 00	 call	 script_abort
  00160	85 c0		 test	 eax, eax
  00162	75 31		 jne	 SHORT $LN18@script_thr
  00164	8b 44 24 30	 mov	 eax, DWORD PTR argc$[rsp]
  00168	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0016c	7d 27		 jge	 SHORT $LN18@script_thr

; 916  :     {
; 917  :         UpdSCRCTL( pCtl, argv[i] );

  0016e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00173	48 8b 54 c4 40	 mov	 rdx, QWORD PTR argv$[rsp+rax*8]
  00178	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0017d	e8 00 00 00 00	 call	 UpdSCRCTL

; 918  :         process_script_file( argv[i], false );

  00182	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00187	33 d2		 xor	 edx, edx
  00189	48 8b 4c c4 40	 mov	 rcx, QWORD PTR argv$[rsp+rax*8]
  0018e	e8 00 00 00 00	 call	 process_script_file

; 919  :     }

  00193	eb b7		 jmp	 SHORT $LN17@script_thr
$LN18@script_thr:

; 920  : 
; 921  :     /* Remove entry from list and exit */
; 922  :     FreeSCRCTL( pCtl );

  00195	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0019a	e8 00 00 00 00	 call	 FreeSCRCTL

; 923  : 
; 924  : #ifdef LOGSCRTHREADBEGEND
; 925  :     // "Thread id "TIDPAT", prio %2d, name '%s' ended"
; 926  :     LOG_THREAD_BEGIN( SCRIPT_THREAD_NAME );
; 927  : #endif
; 928  : 
; 929  :     return NULL;

  0019f	33 c0		 xor	 eax, eax

; 930  : }

  001a1	48 8b 8c 24 40
	20 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001a9	48 33 cc	 xor	 rcx, rsp
  001ac	e8 00 00 00 00	 call	 __security_check_cookie
  001b1	48 81 c4 58 20
	00 00		 add	 rsp, 8280		; 00002058H
  001b8	c3		 ret	 0
script_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
pCtl$ = 80
stmtlen$ = 88
p$ = 96
fp$ = 104
scrname$ = 112
tid$ = 120
stmtnum$ = 124
rc$ = 128
save_errno$1 = 132
tv164 = 136
tv336 = 144
rcmd$2 = 152
script_path$ = 176
stmt$ = 448
__$ArrayPad$ = 1472
script_name$ = 1504
isrcfile$ = 1512
process_script_file PROC

; 726  : {

$LN42:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec d8 05
	00 00		 sub	 rsp, 1496		; 000005d8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 c0
	05 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 727  : SCRCTL* pCtl;                           /* Script processing control */
; 728  : char   *scrname;                        /* Resolved script name      */
; 729  : char    script_path[MAX_PATH];          /* Full path of script file  */
; 730  : FILE   *fp          = NULL;             /* Script FILE pointer       */

  00022	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR fp$[rsp], 0

; 731  : char    stmt[ MAX_SCRIPT_STMT ];        /* script statement buffer   */
; 732  : int     stmtlen     = 0;                /* Length of current stmt    */

  0002b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR stmtlen$[rsp], 0

; 733  : int     stmtnum     = 0;                /* Current stmt line number  */

  00033	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR stmtnum$[rsp], 0

; 734  : TID     tid         = thread_id();      /* Our thread Id             */

  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00041	89 44 24 78	 mov	 DWORD PTR tid$[rsp], eax

; 735  : char   *p;                              /* (work)                    */
; 736  : int     rc;                             /* (work)                    */
; 737  : 
; 738  :     /* Retrieve our control entry */
; 739  :     if (!(pCtl = FindSCRCTL( tid )))

  00045	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  00049	e8 00 00 00 00	 call	 FindSCRCTL
  0004e	48 89 44 24 50	 mov	 QWORD PTR pCtl$[rsp], rax
  00053	48 83 7c 24 50
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  00059	0f 85 c8 00 00
	00		 jne	 $LN20@process_sc
$LN4@process_sc:

; 740  :     {
; 741  :         /* If not found it's probably the Hercules ".RC" file */
; 742  :         ASSERT( isrcfile );

  0005f	0f b6 84 24 e8
	05 00 00	 movzx	 eax, BYTE PTR isrcfile$[rsp]
  00067	85 c0		 test	 eax, eax
  00069	75 5c		 jne	 SHORT $LN21@process_sc
$LN7@process_sc:
  0006b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189391
  00072	41 b8 e6 02 00
	00		 mov	 r8d, 742		; 000002e6H
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189392
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189393
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00092	85 c0		 test	 eax, eax
  00094	74 20		 je	 SHORT $LN22@process_sc
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189395
  0009d	41 b8 e6 02 00
	00		 mov	 r8d, 742		; 000002e6H
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189396
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189397
  000b1	e8 00 00 00 00	 call	 DebuggerTrace
$LN22@process_sc:
  000b6	33 c0		 xor	 eax, eax
  000b8	85 c0		 test	 eax, eax
  000ba	75 af		 jne	 SHORT $LN7@process_sc
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c2	85 c0		 test	 eax, eax
  000c4	74 01		 je	 SHORT $LN23@process_sc
  000c6	cc		 int	 3
$LN23@process_sc:
$LN21@process_sc:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 92		 jne	 SHORT $LN4@process_sc

; 743  : 
; 744  :         /* Create a temporary working control entry */
; 745  :         if (!(pCtl = NewSCRCTL( tid, script_name )))

  000cd	48 8b 94 24 e0
	05 00 00	 mov	 rdx, QWORD PTR script_name$[rsp]
  000d5	8b 4c 24 78	 mov	 ecx, DWORD PTR tid$[rsp]
  000d9	e8 00 00 00 00	 call	 NewSCRCTL
  000de	48 89 44 24 50	 mov	 QWORD PTR pCtl$[rsp], rax
  000e3	48 83 7c 24 50
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  000e9	75 0a		 jne	 SHORT $LN24@process_sc

; 746  :             return -1; /* (error message already issued) */

  000eb	b8 ff ff ff ff	 mov	 eax, -1
  000f0	e9 da 06 00 00	 jmp	 $LN1@process_sc
$LN24@process_sc:

; 747  : 
; 748  :         /* Start over again using our temporary control entry. */
; 749  :         rc = process_script_file( script_name, isrcfile );

  000f5	0f b6 94 24 e8
	05 00 00	 movzx	 edx, BYTE PTR isrcfile$[rsp]
  000fd	48 8b 8c 24 e0
	05 00 00	 mov	 rcx, QWORD PTR script_name$[rsp]
  00105	e8 00 00 00 00	 call	 process_script_file
  0010a	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 750  :         FreeSCRCTL( pCtl );

  00111	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00116	e8 00 00 00 00	 call	 FreeSCRCTL

; 751  :         return rc;

  0011b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rc$[rsp]
  00122	e9 a8 06 00 00	 jmp	 $LN1@process_sc
$LN20@process_sc:

; 752  :     }
; 753  : 
; 754  :     /* Abort script if already at maximum recursion level */
; 755  :     if (pCtl->scr_recursion >= MAX_SCRIPT_DEPTH)

  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  0012c	83 78 28 0a	 cmp	 DWORD PTR [rax+40], 10
  00130	7c 7c		 jl	 SHORT $LN25@process_sc

; 756  :     {
; 757  :         // "Script %d aborted: '%s'"
; 758  :         WRMSG( HHC02259, "E", pCtl->scr_id, "script recursion level exceeded" );

  00132	b9 01 00 00 00	 mov	 ecx, 1
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189401
  00144	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00149	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0014e	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00151	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189402
  0015c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00161	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189403
  00168	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0016d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00172	41 b9 03 00 00
	00		 mov	 r9d, 3
  00178	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189404
  0017f	ba f6 02 00 00	 mov	 edx, 758		; 000002f6H
  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189405
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 759  :         pCtl->scr_flags |= SCR_ABORT;

  00191	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  00196	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00199	83 c8 40	 or	 eax, 64			; 00000040H
  0019c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  001a1	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 760  :         return -1;

  001a4	b8 ff ff ff ff	 mov	 eax, -1
  001a9	e9 21 06 00 00	 jmp	 $LN1@process_sc
$LN25@process_sc:

; 761  :     }
; 762  : 
; 763  :     if (!(scrname = resolve_symbol_string( script_name )))

  001ae	48 8b 8c 24 e0
	05 00 00	 mov	 rcx, QWORD PTR script_name$[rsp]
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  001bc	48 89 44 24 70	 mov	 QWORD PTR scrname$[rsp], rax
  001c1	48 83 7c 24 70
	00		 cmp	 QWORD PTR scrname$[rsp], 0
  001c7	75 13		 jne	 SHORT $LN26@process_sc

; 764  :         scrname = strdup( script_name );

  001c9	48 8b 8c 24 e0
	05 00 00	 mov	 rcx, QWORD PTR script_name$[rsp]
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  001d7	48 89 44 24 70	 mov	 QWORD PTR scrname$[rsp], rax
$LN26@process_sc:

; 765  : 
; 766  :     if (!strcmp(scrname, "-"))    /* Standard input?             */

  001dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189409
  001e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR scrname$[rsp]
  001e8	e8 00 00 00 00	 call	 strcmp
  001ed	85 c0		 test	 eax, eax
  001ef	75 26		 jne	 SHORT $LN27@process_sc

; 767  :     {
; 768  :         fp = stdin;

  001f1	33 c9		 xor	 ecx, ecx
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f9	48 89 44 24 68	 mov	 QWORD PTR fp$[rsp], rax

; 769  :         strcpy(script_path, "<stdin>");

  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189410
  00205	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  0020d	e8 00 00 00 00	 call	 strcpy

; 770  :     }

  00212	e9 49 01 00 00	 jmp	 $LN28@process_sc
$LN27@process_sc:

; 771  :     else
; 772  :     {
; 773  :         /* Open the specified script file */
; 774  :         hostpath( script_path, scrname, sizeof( script_path ));

  00217	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0021d	48 8b 54 24 70	 mov	 rdx, QWORD PTR scrname$[rsp]
  00222	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 775  :         if (!(fp = fopen( script_path, "r" )))

  00230	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189412
  00237	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00245	48 89 44 24 68	 mov	 QWORD PTR fp$[rsp], rax
  0024a	48 83 7c 24 68
	00		 cmp	 QWORD PTR fp$[rsp], 0
  00250	0f 85 0a 01 00
	00		 jne	 $LN29@process_sc

; 776  :         {
; 777  :             /* We  get  here  with the default script file only when */
; 778  :             /* hercules.rc  exists  as  tested in impl.c.  Any error */
; 779  :             /* opening is should be reported to the user.            */
; 780  : 
; 781  :             int save_errno = errno; /* (save error code for caller) */

  00256	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0025c	8b 00		 mov	 eax, DWORD PTR [rax]
  0025e	89 84 24 84 00
	00 00		 mov	 DWORD PTR save_errno$1[rsp], eax

; 782  : 
; 783  :             if (ENOENT != errno)    /* If NOT "File Not found" */

  00265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0026b	83 38 02	 cmp	 DWORD PTR [rax], 2
  0026e	74 78		 je	 SHORT $LN30@process_sc

; 784  :             {
; 785  :                 // "Error in function '%s': '%s'"
; 786  :                 WRMSG( HHC02219, "E", "fopen()", strerror( errno ));

  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00276	8b 08		 mov	 ecx, DWORD PTR [rax]
  00278	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0027e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv164[rsp], rax
  00286	b9 01 00 00 00	 mov	 ecx, 1
  0028b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00291	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv164[rsp]
  00299	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0029e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189415
  002a5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189416
  002b1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189417
  002bd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189418
  002d4	ba 12 03 00 00	 mov	 edx, 786		; 00000312H
  002d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189419
  002e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 787  :             }

  002e6	eb 54		 jmp	 SHORT $LN31@process_sc
$LN30@process_sc:

; 788  :             else
; 789  :             {
; 790  :                 // "Script file '%s' not found"
; 791  :                 WRMSG( HHC01405, "E", script_path );

  002e8	b9 01 00 00 00	 mov	 ecx, 1
  002ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f3	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  002fb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189420
  00307	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189421
  00313	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00318	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00323	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189422
  0032a	ba 17 03 00 00	 mov	 edx, 791		; 00000317H
  0032f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189423
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN31@process_sc:

; 792  :             }
; 793  : 
; 794  :             errno = save_errno;  /* (restore error code for caller) */

  0033c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00342	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR save_errno$1[rsp]
  00349	89 08		 mov	 DWORD PTR [rax], ecx

; 795  :             free( scrname );

  0034b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR scrname$[rsp]
  00350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 796  :             return -1;

  00356	b8 ff ff ff ff	 mov	 eax, -1
  0035b	e9 6f 04 00 00	 jmp	 $LN1@process_sc
$LN29@process_sc:
$LN28@process_sc:

; 797  :         }
; 798  :     }
; 799  : 
; 800  :     pCtl->scr_recursion++;

  00360	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  00365	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00368	ff c0		 inc	 eax
  0036a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0036f	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 801  : 
; 802  :     /* Read the first line into our statement buffer */
; 803  :     if (!script_abort( pCtl ) && !fgets( stmt, MAX_SCRIPT_STMT, fp ))

  00372	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00377	e8 00 00 00 00	 call	 script_abort
  0037c	85 c0		 test	 eax, eax
  0037e	0f 85 82 00 00
	00		 jne	 $LN32@process_sc
  00384	4c 8b 44 24 68	 mov	 r8, QWORD PTR fp$[rsp]
  00389	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0038e	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR stmt$[rsp]
  00396	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  0039c	48 85 c0	 test	 rax, rax
  0039f	75 65		 jne	 SHORT $LN32@process_sc

; 804  :     {
; 805  :         // "Script %d: begin processing file '%s'"
; 806  :         WRMSG( HHC02260, "I", pCtl->scr_id, script_path );

  003a1	b9 01 00 00 00	 mov	 ecx, 1
  003a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003ac	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  003b4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003b9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  003be	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  003c1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189425
  003cc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189426
  003d8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e2	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189427
  003ef	ba 26 03 00 00	 mov	 edx, 806		; 00000326H
  003f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189428
  003fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 807  :         goto script_end;

  00401	e9 fe 01 00 00	 jmp	 $script_end$43
$LN32@process_sc:

; 808  :     }
; 809  : 
; 810  : #if defined(HAVE_OBJECT_REXX) || defined(HAVE_REGINA_REXX)
; 811  : 
; 812  :     /* Skip past blanks to start of command */
; 813  :     for (p = stmt; isspace( *p ); p++)

  00406	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR stmt$[rsp]
  0040e	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
  00413	eb 0d		 jmp	 SHORT $LN10@process_sc
$LN8@process_sc:
  00415	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0041a	48 ff c0	 inc	 rax
  0041d	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
$LN10@process_sc:
  00422	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00427	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0042a	8b c8		 mov	 ecx, eax
  0042c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  00432	85 c0		 test	 eax, eax
  00434	74 02		 je	 SHORT $LN9@process_sc

; 814  :         ; /* (nop; do nothing) */

  00436	eb dd		 jmp	 SHORT $LN8@process_sc
$LN9@process_sc:

; 815  : 
; 816  :     /* Execute REXX script if line begins with "Slash '/' Asterisk '*'" */
; 817  :     if (!script_abort( pCtl ) && !strncmp( p, "/*", 2 ))

  00438	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0043d	e8 00 00 00 00	 call	 script_abort
  00442	85 c0		 test	 eax, eax
  00444	75 7e		 jne	 SHORT $LN33@process_sc
  00446	41 b8 02 00 00
	00		 mov	 r8d, 2
  0044c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189430
  00453	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  00458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0045e	85 c0		 test	 eax, eax
  00460	75 62		 jne	 SHORT $LN33@process_sc

; 818  :     {
; 819  :         char *rcmd[2] = { "exec", NULL };

  00462	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189432
  00469	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR rcmd$2[rsp], rax
  00471	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR rcmd$2[rsp+8], 0

; 820  :         rcmd[1] = script_path;

  0047d	b8 08 00 00 00	 mov	 eax, 8
  00482	48 6b c0 01	 imul	 rax, rax, 1
  00486	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  0048e	48 89 8c 04 98
	00 00 00	 mov	 QWORD PTR rcmd$2[rsp+rax], rcx

; 821  :         fclose( fp ); fp = NULL;

  00496	48 8b 4c 24 68	 mov	 rcx, QWORD PTR fp$[rsp]
  0049b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  004a1	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR fp$[rsp], 0

; 822  :         exec_cmd( 2, rcmd, NULL );  /* (synchronous) */

  004aa	45 33 c0	 xor	 r8d, r8d
  004ad	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR rcmd$2[rsp]
  004b5	b9 02 00 00 00	 mov	 ecx, 2
  004ba	e8 00 00 00 00	 call	 exec_cmd

; 823  :         goto script_end;

  004bf	e9 40 01 00 00	 jmp	 $script_end$43
$LN33@process_sc:

; 824  :     }
; 825  : #endif
; 826  : 
; 827  :     // "Script %d: begin processing file '%s'"
; 828  :     WRMSG( HHC02260, "I", pCtl->scr_id, script_path );

  004c4	b9 01 00 00 00	 mov	 ecx, 1
  004c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004cf	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  004d7	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  004dc	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  004e1	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  004e4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189433
  004ef	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189434
  004fb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00500	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00505	41 b9 03 00 00
	00		 mov	 r9d, 3
  0050b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189435
  00512	ba 3c 03 00 00	 mov	 edx, 828		; 0000033cH
  00517	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189436
  0051e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@process_sc:

; 829  : 
; 830  :     do
; 831  :     {
; 832  :         stmtnum++;

  00524	8b 44 24 7c	 mov	 eax, DWORD PTR stmtnum$[rsp]
  00528	ff c0		 inc	 eax
  0052a	89 44 24 7c	 mov	 DWORD PTR stmtnum$[rsp], eax

; 833  : 
; 834  :         /* Skip past blanks to start of statement */
; 835  :         for (p = stmt; isspace( *p ); p++)

  0052e	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR stmt$[rsp]
  00536	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
  0053b	eb 0d		 jmp	 SHORT $LN16@process_sc
$LN14@process_sc:
  0053d	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00542	48 ff c0	 inc	 rax
  00545	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
$LN16@process_sc:
  0054a	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0054f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00552	8b c8		 mov	 ecx, eax
  00554	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0055a	85 c0		 test	 eax, eax
  0055c	74 02		 je	 SHORT $LN15@process_sc

; 836  :             ; /* (nop; do nothing) */

  0055e	eb dd		 jmp	 SHORT $LN14@process_sc
$LN15@process_sc:

; 837  : 
; 838  :         /* Remove trailing whitespace */
; 839  :         for (stmtlen = (int)strlen(p); stmtlen && isspace(p[stmtlen-1]); stmtlen--);

  00560	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  00565	e8 00 00 00 00	 call	 strlen
  0056a	89 44 24 58	 mov	 DWORD PTR stmtlen$[rsp], eax
  0056e	eb 0a		 jmp	 SHORT $LN19@process_sc
$LN17@process_sc:
  00570	8b 44 24 58	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00574	ff c8		 dec	 eax
  00576	89 44 24 58	 mov	 DWORD PTR stmtlen$[rsp], eax
$LN19@process_sc:
  0057a	83 7c 24 58 00	 cmp	 DWORD PTR stmtlen$[rsp], 0
  0057f	74 1f		 je	 SHORT $LN18@process_sc
  00581	8b 44 24 58	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00585	ff c8		 dec	 eax
  00587	48 98		 cdqe
  00589	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  0058e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00592	8b c8		 mov	 ecx, eax
  00594	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0059a	85 c0		 test	 eax, eax
  0059c	74 02		 je	 SHORT $LN18@process_sc
  0059e	eb d0		 jmp	 SHORT $LN17@process_sc
$LN18@process_sc:

; 840  :         p[stmtlen] = 0;

  005a0	48 63 44 24 58	 movsxd	 rax, DWORD PTR stmtlen$[rsp]
  005a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  005aa	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 841  : 
; 842  :         /* Special handling for 'pause' and other statements */
; 843  :         if (do_special(NULL, NULL, pCtl, p))

  005ae	4c 8b 4c 24 60	 mov	 r9, QWORD PTR p$[rsp]
  005b3	4c 8b 44 24 50	 mov	 r8, QWORD PTR pCtl$[rsp]
  005b8	33 d2		 xor	 edx, edx
  005ba	33 c9		 xor	 ecx, ecx
  005bc	e8 00 00 00 00	 call	 do_special
  005c1	85 c0		 test	 eax, eax
  005c3	74 02		 je	 SHORT $LN34@process_sc

; 844  :             continue;

  005c5	eb 0e		 jmp	 SHORT $LN11@process_sc
$LN34@process_sc:

; 845  : 
; 846  :         /* Process statement as command */
; 847  :         panel_command( p );

  005c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR p$[rsp]
  005cc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  005d3	ff 10		 call	 QWORD PTR [rax]
$LN11@process_sc:

; 848  :     }
; 849  :     while (!script_abort( pCtl ) && fgets( stmt, MAX_SCRIPT_STMT, fp ));

  005d5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  005da	e8 00 00 00 00	 call	 script_abort
  005df	85 c0		 test	 eax, eax
  005e1	75 21		 jne	 SHORT $LN35@process_sc
  005e3	4c 8b 44 24 68	 mov	 r8, QWORD PTR fp$[rsp]
  005e8	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  005ed	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR stmt$[rsp]
  005f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  005fb	48 85 c0	 test	 rax, rax
  005fe	0f 85 20 ff ff
	ff		 jne	 $LN13@process_sc
$LN35@process_sc:
$script_end$43:

; 850  : 
; 851  : script_end:
; 852  : 
; 853  :     /* Issue termination message and close file */
; 854  :     if (fp)

  00604	48 83 7c 24 68
	00		 cmp	 QWORD PTR fp$[rsp], 0
  0060a	0f 84 a0 01 00
	00		 je	 $LN36@process_sc

; 855  :     {
; 856  :         if (feof( fp ))

  00610	48 8b 4c 24 68	 mov	 rcx, QWORD PTR fp$[rsp]
  00615	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_feof
  0061b	85 c0		 test	 eax, eax
  0061d	74 65		 je	 SHORT $LN37@process_sc

; 857  :         {
; 858  :             // "Script %d: file '%s' processing ended"
; 859  :             WRMSG( HHC02264, "I", pCtl->scr_id, script_path );

  0061f	b9 01 00 00 00	 mov	 ecx, 1
  00624	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0062a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  00632	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00637	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0063c	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0063f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00643	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189442
  0064a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0064f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189443
  00656	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0065b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00660	41 b9 03 00 00
	00		 mov	 r9d, 3
  00666	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189444
  0066d	ba 5b 03 00 00	 mov	 edx, 859		; 0000035bH
  00672	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189445
  00679	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 860  :         }

  0067f	e9 21 01 00 00	 jmp	 $LN38@process_sc
$LN37@process_sc:

; 861  :         else /* (canceled, recursion, or i/o error) */
; 862  :         {
; 863  :             if (!(pCtl->scr_flags & SCR_ABORTED))   /* (no msg issued yet?) */

  00684	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  00689	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0068c	83 e0 10	 and	 eax, 16
  0068f	85 c0		 test	 eax, eax
  00691	0f 85 0e 01 00
	00		 jne	 $LN39@process_sc

; 864  :             {
; 865  :                 if (!script_abort( pCtl ))          /* (not abort request?) */

  00697	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0069c	e8 00 00 00 00	 call	 script_abort
  006a1	85 c0		 test	 eax, eax
  006a3	0f 85 89 00 00
	00		 jne	 $LN40@process_sc

; 866  :                 {
; 867  :                     // "Error in function '%s': '%s'"
; 868  :                     WRMSG( HHC02219,"E", "read()", strerror( errno ));

  006a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006af	8b 08		 mov	 ecx, DWORD PTR [rax]
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  006b7	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  006bf	b9 01 00 00 00	 mov	 ecx, 1
  006c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv336[rsp]
  006d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189448
  006de	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189449
  006ea	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189450
  006f6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00700	41 b9 03 00 00
	00		 mov	 r9d, 3
  00706	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189451
  0070d	ba 64 03 00 00	 mov	 edx, 868		; 00000364H
  00712	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189452
  00719	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 869  :                     pCtl->scr_flags |= SCR_ABORT;

  0071f	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  00724	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00727	83 c8 40	 or	 eax, 64			; 00000040H
  0072a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0072f	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN40@process_sc:

; 870  :                 }
; 871  : 
; 872  :                 // "Script %d: file '%s' aborted due to previous conditions"
; 873  :                 WRMSG( HHC02265, "I", pCtl->scr_id, script_path );

  00732	b9 01 00 00 00	 mov	 ecx, 1
  00737	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0073d	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR script_path$[rsp]
  00745	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0074a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0074f	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00752	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00756	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189453
  0075d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00762	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189454
  00769	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0076e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00773	41 b9 03 00 00
	00		 mov	 r9d, 3
  00779	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189455
  00780	ba 69 03 00 00	 mov	 edx, 873		; 00000369H
  00785	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189456
  0078c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 874  :                 pCtl->scr_flags |= SCR_ABORTED;

  00792	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  00797	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0079a	83 c8 10	 or	 eax, 16
  0079d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  007a2	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN39@process_sc:
$LN38@process_sc:

; 875  :             }
; 876  :         }
; 877  :         fclose( fp );

  007a5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR fp$[rsp]
  007aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
$LN36@process_sc:

; 878  :     }
; 879  : 
; 880  :     pCtl->scr_recursion--;

  007b0	48 8b 44 24 50	 mov	 rax, QWORD PTR pCtl$[rsp]
  007b5	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  007b8	ff c8		 dec	 eax
  007ba	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pCtl$[rsp]
  007bf	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 881  :     free( scrname );

  007c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR scrname$[rsp]
  007c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 882  :     return 0;

  007cd	33 c0		 xor	 eax, eax
$LN1@process_sc:

; 883  : }

  007cf	48 8b 8c 24 c0
	05 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007d7	48 33 cc	 xor	 rcx, rsp
  007da	e8 00 00 00 00	 call	 __security_check_cookie
  007df	48 81 c4 d8 05
	00 00		 add	 rsp, 1496		; 000005d8H
  007e6	c3		 ret	 0
process_script_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
tv91 = 80
abort$ = 84
pCtl$ = 112
script_abort PROC

; 706  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 707  :     int abort;
; 708  :     if (pCtl->scr_flags & SCR_CANCEL)           /* cancel requested? */

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR pCtl$[rsp]
  0000e	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00011	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00016	85 c0		 test	 eax, eax
  00018	0f 84 94 00 00
	00		 je	 $LN2@script_abo

; 709  :     {
; 710  :         if (!(pCtl->scr_flags & SCR_CANCELED))  /* no msg given yet? */

  0001e	48 8b 44 24 70	 mov	 rax, QWORD PTR pCtl$[rsp]
  00023	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00026	83 e0 20	 and	 eax, 32			; 00000020H
  00029	85 c0		 test	 eax, eax
  0002b	75 72		 jne	 SHORT $LN3@script_abo

; 711  :         {
; 712  :             // "Script %d aborted: '%s'"
; 713  :             WRMSG( HHC02259, "E", pCtl->scr_id, "user cancel request" );

  0002d	b9 01 00 00 00	 mov	 ecx, 1
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189338
  0003f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00044	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00049	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0004c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189339
  00057	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189340
  00063	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00068	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00073	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189341
  0007a	ba c9 02 00 00	 mov	 edx, 713		; 000002c9H
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189342
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 714  :             pCtl->scr_flags |= SCR_CANCELED;

  0008c	48 8b 44 24 70	 mov	 rax, QWORD PTR pCtl$[rsp]
  00091	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00094	83 c8 20	 or	 eax, 32			; 00000020H
  00097	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0009c	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN3@script_abo:

; 715  :         }
; 716  :         pCtl->scr_flags |= SCR_ABORT;           /* request abort */

  0009f	48 8b 44 24 70	 mov	 rax, QWORD PTR pCtl$[rsp]
  000a4	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000a7	83 c8 40	 or	 eax, 64			; 00000040H
  000aa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pCtl$[rsp]
  000af	89 41 2c	 mov	 DWORD PTR [rcx+44], eax
$LN2@script_abo:

; 717  :     }
; 718  :     abort = (pCtl->scr_flags & SCR_ABORT) ? 1 : 0;

  000b2	48 8b 44 24 70	 mov	 rax, QWORD PTR pCtl$[rsp]
  000b7	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000ba	83 e0 40	 and	 eax, 64			; 00000040H
  000bd	85 c0		 test	 eax, eax
  000bf	74 0a		 je	 SHORT $LN5@script_abo
  000c1	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000c9	eb 08		 jmp	 SHORT $LN6@script_abo
$LN5@script_abo:
  000cb	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN6@script_abo:
  000d3	8b 44 24 50	 mov	 eax, DWORD PTR tv91[rsp]
  000d7	89 44 24 54	 mov	 DWORD PTR abort$[rsp], eax

; 719  :     return abort;

  000db	8b 44 24 54	 mov	 eax, DWORD PTR abort$[rsp]

; 720  : }

  000df	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000e3	c3		 ret	 0
script_abort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
count$ = 80
first$ = 84
all$ = 88
scrid$ = 92
pCtl$ = 96
pLink$ = 104
tv95 = 112
tv189 = 120
argc$ = 144
argv$ = 152
cmdline$ = 160
cscript_cmd PROC

; 600  : {

$LN26:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 601  :     int          first  = FALSE;    /* Cancel first script found     */

  00015	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0

; 602  :     int          all    = FALSE;    /* Cancel all running scripts    */

  0001d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR all$[rsp], 0

; 603  :     int          scrid  = 0;        /* Cancel this specific script   */

  00025	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR scrid$[rsp], 0

; 604  :     int          count  = 0;        /* Counts #of scripts canceled   */

  0002d	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0

; 605  :     LIST_ENTRY*  pLink  = NULL;     /* (work)                        */

  00035	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR pLink$[rsp], 0

; 606  :     SCRCTL*      pCtl   = NULL;     /* (work)                        */

  0003e	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pCtl$[rsp], 0
$LN4@cscript_cm:

; 607  : 
; 608  :     UNREFERENCED( cmdline );

  00047	33 c0		 xor	 eax, eax
  00049	85 c0		 test	 eax, eax
  0004b	75 fa		 jne	 SHORT $LN4@cscript_cm

; 609  : 
; 610  :     /* Optional argument is the identity of the script to cancel
; 611  :        or "*" (or "all") to cancel all running scripts. The default
; 612  :        if no argument is given is to cancel only the first script.
; 613  :     */
; 614  :     if (argc > 2)

  0004d	83 bc 24 90 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00055	7e 51		 jle	 SHORT $LN8@cscript_cm

; 615  :     {
; 616  :         // "Invalid number of arguments"
; 617  :         WRMSG( HHC02446, "E" );

  00057	b9 01 00 00 00	 mov	 ecx, 1
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00062	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189290
  00069	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0006e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189291
  00075	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00085	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189292
  0008c	ba 69 02 00 00	 mov	 edx, 617		; 00000269H
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189293
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 618  :         return -1;

  0009e	b8 ff ff ff ff	 mov	 eax, -1
  000a3	e9 9e 03 00 00	 jmp	 $LN1@cscript_cm
$LN8@cscript_cm:

; 619  :     }
; 620  :     if (argc < 2)

  000a8	83 bc 24 90 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  000b0	7d 15		 jge	 SHORT $LN9@cscript_cm

; 621  :     {
; 622  :         /* Default to first one found */
; 623  :         all = FALSE;

  000b2	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR all$[rsp], 0

; 624  :         first = TRUE;

  000ba	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR first$[rsp], 1

; 625  :     }

  000c2	e9 22 01 00 00	 jmp	 $LN10@cscript_cm
$LN9@cscript_cm:

; 626  :     else /* argc == 2 */
; 627  :     {
; 628  :         /* Cancel all running scripts? */
; 629  :         if (0
; 630  :             || strcasecmp( argv[1], "*"   ) == 0
; 631  :             || strcasecmp( argv[1], "all" ) == 0

  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 4c		 jne	 SHORT $LN13@cscript_cm
  000cd	b8 08 00 00 00	 mov	 eax, 8
  000d2	48 6b c0 01	 imul	 rax, rax, 1
  000d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189299
  000dd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000e5	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000ef	85 c0		 test	 eax, eax
  000f1	74 26		 je	 SHORT $LN13@cscript_cm
  000f3	b8 08 00 00 00	 mov	 eax, 8
  000f8	48 6b c0 01	 imul	 rax, rax, 1
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189300
  00103	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0010b	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00115	85 c0		 test	 eax, eax
  00117	75 15		 jne	 SHORT $LN11@cscript_cm
$LN13@cscript_cm:

; 632  :         )
; 633  :         {
; 634  :             all = TRUE;

  00119	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR all$[rsp], 1

; 635  :             first = FALSE;

  00121	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0

; 636  :         }

  00129	e9 bb 00 00 00	 jmp	 $LN12@cscript_cm
$LN11@cscript_cm:

; 637  :         else /* Specific script */
; 638  :         {
; 639  :             all = FALSE;

  0012e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR all$[rsp], 0

; 640  :             first = FALSE;

  00136	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR first$[rsp], 0

; 641  : 
; 642  :             if ((scrid = atoi( argv[1] )) == 0)

  0013e	b8 08 00 00 00	 mov	 eax, 8
  00143	48 6b c0 01	 imul	 rax, rax, 1
  00147	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0014f	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00159	89 44 24 5c	 mov	 DWORD PTR scrid$[rsp], eax
  0015d	83 7c 24 5c 00	 cmp	 DWORD PTR scrid$[rsp], 0
  00162	0f 85 81 00 00
	00		 jne	 $LN14@cscript_cm

; 643  :             {
; 644  :                 // "Invalid argument '%s'%s"
; 645  :                 WRMSG( HHC02205, "E", argv[1], ": value not numeric" );

  00168	b8 08 00 00 00	 mov	 eax, 8
  0016d	48 6b c0 01	 imul	 rax, rax, 1
  00171	48 89 44 24 70	 mov	 QWORD PTR tv95[rsp], rax
  00176	b9 01 00 00 00	 mov	 ecx, 1
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189302
  00188	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0018d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00195	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv95[rsp]
  0019a	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0019e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189303
  001aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189304
  001b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189305
  001cd	ba 85 02 00 00	 mov	 edx, 645		; 00000285H
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189306
  001d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 646  :                 return -1;

  001df	b8 ff ff ff ff	 mov	 eax, -1
  001e4	e9 5d 02 00 00	 jmp	 $LN1@cscript_cm
$LN14@cscript_cm:
$LN12@cscript_cm:
$LN10@cscript_cm:

; 647  :             }
; 648  :         }
; 649  :     }
; 650  : 
; 651  :     obtain_lock( &sysblk.scrlock );

  001e9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f0	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  001f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189307
  001fd	48 8b c8	 mov	 rcx, rax
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 652  : 
; 653  :     if (!scrlist.Flink || IsListEmpty( &scrlist ))

  00206	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR scrlist, 0
  0020e	74 10		 je	 SHORT $LN16@cscript_cm
  00210	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  00217	48 39 05 00 00
	00 00		 cmp	 QWORD PTR scrlist, rax
  0021e	75 6e		 jne	 SHORT $LN15@cscript_cm
$LN16@cscript_cm:

; 654  :     {
; 655  :         // "No scripts currently running"
; 656  :         WRMSG( HHC02314, "E" );

  00220	b9 01 00 00 00	 mov	 ecx, 1
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189310
  00232	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00237	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189311
  0023e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00243	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00248	41 b9 03 00 00
	00		 mov	 r9d, 3
  0024e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189312
  00255	ba 90 02 00 00	 mov	 edx, 656		; 00000290H
  0025a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189313
  00261	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 657  :         release_lock( &sysblk.scrlock );

  00267	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0026e	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00274	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189314
  0027b	48 8b c8	 mov	 rcx, rax
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 658  :         return -1;

  00284	b8 ff ff ff ff	 mov	 eax, -1
  00289	e9 b8 01 00 00	 jmp	 $LN1@cscript_cm
$LN15@cscript_cm:

; 659  :     }
; 660  : 
; 661  :     /* Search list for the script(s) to cancel... */
; 662  :     for (pLink = scrlist.Flink; pLink != &scrlist; pLink = pLink->Flink)

  0028e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR scrlist
  00295	48 89 44 24 68	 mov	 QWORD PTR pLink$[rsp], rax
  0029a	eb 0d		 jmp	 SHORT $LN7@cscript_cm
$LN5@cscript_cm:
  0029c	48 8b 44 24 68	 mov	 rax, QWORD PTR pLink$[rsp]
  002a1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002a4	48 89 44 24 68	 mov	 QWORD PTR pLink$[rsp], rax
$LN7@cscript_cm:
  002a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  002b0	48 39 44 24 68	 cmp	 QWORD PTR pLink$[rsp], rax
  002b5	0f 84 cf 00 00
	00		 je	 $LN6@cscript_cm

; 663  :     {
; 664  :         pCtl = CONTAINING_RECORD( pLink, SCRCTL, link );

  002bb	48 8b 44 24 68	 mov	 rax, QWORD PTR pLink$[rsp]
  002c0	48 89 44 24 60	 mov	 QWORD PTR pCtl$[rsp], rax

; 665  :         if (!pCtl->scr_tid) continue; /* (inactive) */

  002c5	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  002ca	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  002ce	75 02		 jne	 SHORT $LN17@cscript_cm
  002d0	eb ca		 jmp	 SHORT $LN5@cscript_cm
$LN17@cscript_cm:

; 666  : 
; 667  :         if (first)

  002d2	83 7c 24 54 00	 cmp	 DWORD PTR first$[rsp], 0
  002d7	74 57		 je	 SHORT $LN18@cscript_cm

; 668  :         {
; 669  :             pCtl->scr_flags |= SCR_CANCEL;

  002d9	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  002de	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  002e1	0f ba e8 07	 bts	 eax, 7
  002e5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCtl$[rsp]
  002ea	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 670  :             broadcast_condition( &sysblk.scrcond );

  002ed	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002f4	48 05 10 11 00
	00		 add	 rax, 4368		; 00001110H
  002fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189318
  00301	48 8b c8	 mov	 rcx, rax
  00304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 671  :             release_lock( &sysblk.scrlock );

  0030a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00311	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00317	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189319
  0031e	48 8b c8	 mov	 rcx, rax
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 672  :             return 0;

  00327	33 c0		 xor	 eax, eax
  00329	e9 18 01 00 00	 jmp	 $LN1@cscript_cm

; 673  :         }

  0032e	eb 55		 jmp	 SHORT $LN19@cscript_cm
$LN18@cscript_cm:

; 674  :         else if (all)

  00330	83 7c 24 58 00	 cmp	 DWORD PTR all$[rsp], 0
  00335	74 20		 je	 SHORT $LN20@cscript_cm

; 675  :         {
; 676  :             pCtl->scr_flags |= SCR_CANCEL;

  00337	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  0033c	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0033f	0f ba e8 07	 bts	 eax, 7
  00343	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00348	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 677  :             count++;

  0034b	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  0034f	ff c0		 inc	 eax
  00351	89 44 24 50	 mov	 DWORD PTR count$[rsp], eax

; 678  :         }

  00355	eb 2e		 jmp	 SHORT $LN21@cscript_cm
$LN20@cscript_cm:

; 679  :         else if (pCtl->scr_id == scrid)

  00357	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  0035c	8b 4c 24 5c	 mov	 ecx, DWORD PTR scrid$[rsp]
  00360	39 48 14	 cmp	 DWORD PTR [rax+20], ecx
  00363	75 20		 jne	 SHORT $LN22@cscript_cm

; 680  :         {
; 681  :             pCtl->scr_flags |= SCR_CANCEL;

  00365	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  0036a	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0036d	0f ba e8 07	 bts	 eax, 7
  00371	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00376	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 682  :             count++;

  00379	8b 44 24 50	 mov	 eax, DWORD PTR count$[rsp]
  0037d	ff c0		 inc	 eax
  0037f	89 44 24 50	 mov	 DWORD PTR count$[rsp], eax

; 683  :             break;

  00383	eb 05		 jmp	 SHORT $LN6@cscript_cm
$LN22@cscript_cm:
$LN21@cscript_cm:
$LN19@cscript_cm:

; 684  :         }
; 685  :     }

  00385	e9 12 ff ff ff	 jmp	 $LN5@cscript_cm
$LN6@cscript_cm:

; 686  : 
; 687  :     if (count)

  0038a	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  0038f	74 1d		 je	 SHORT $LN23@cscript_cm

; 688  :         broadcast_condition( &sysblk.scrcond );

  00391	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00398	48 05 10 11 00
	00		 add	 rax, 4368		; 00001110H
  0039e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189324
  003a5	48 8b c8	 mov	 rcx, rax
  003a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN23@cscript_cm:

; 689  : 
; 690  :     release_lock( &sysblk.scrlock );

  003ae	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b5	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  003bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189325
  003c2	48 8b c8	 mov	 rcx, rax
  003c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 691  : 
; 692  :     if (!count)

  003cb	83 7c 24 50 00	 cmp	 DWORD PTR count$[rsp], 0
  003d0	75 72		 jne	 SHORT $LN24@cscript_cm

; 693  :     {
; 694  :         // "Script %s not found"
; 695  :         WRMSG( HHC02316, "E", argv[1] );

  003d2	b8 08 00 00 00	 mov	 eax, 8
  003d7	48 6b c0 01	 imul	 rax, rax, 1
  003db	48 89 44 24 78	 mov	 QWORD PTR tv189[rsp], rax
  003e0	b9 01 00 00 00	 mov	 ecx, 1
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003eb	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003f3	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv189[rsp]
  003f8	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  003fc	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00401	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189327
  00408	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0040d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189328
  00414	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00419	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00424	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189329
  0042b	ba b7 02 00 00	 mov	 edx, 695		; 000002b7H
  00430	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189330
  00437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 696  :         return -1;

  0043d	b8 ff ff ff ff	 mov	 eax, -1
  00442	eb 02		 jmp	 SHORT $LN1@cscript_cm
$LN24@cscript_cm:

; 697  :     }
; 698  : 
; 699  :     return 0;

  00444	33 c0		 xor	 eax, eax
$LN1@cscript_cm:

; 700  : }

  00446	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0044d	c3		 ret	 0
cscript_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
pCtl$ = 96
pLink$ = 104
tv88 = 112
ListScriptsIds PROC

; 563  : {

  00000	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 564  :     LIST_ENTRY*  pLink  = NULL;

  00007	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR pLink$[rsp], 0

; 565  :     SCRCTL*      pCtl   = NULL;

  00010	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR pCtl$[rsp], 0

; 566  : 
; 567  :     obtain_lock( &sysblk.scrlock );

  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00020	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189248
  0002d	48 8b c8	 mov	 rcx, rax
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 568  : 
; 569  :     /* Perform first-time initialization if needed */
; 570  :     if (!scrlist.Flink)

  00036	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR scrlist, 0
  0003e	75 1c		 jne	 SHORT $LN5@ListScript

; 571  :         InitializeListHead( &scrlist );

  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  00047	48 89 05 08 00
	00 00		 mov	 QWORD PTR scrlist+8, rax
  0004e	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR scrlist+8
  00055	48 89 05 00 00
	00 00		 mov	 QWORD PTR scrlist, rax
$LN5@ListScript:

; 572  : 
; 573  :     /* Check for empty list */
; 574  :     if (IsListEmpty( &scrlist ))

  0005c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  00063	48 39 05 00 00
	00 00		 cmp	 QWORD PTR scrlist, rax
  0006a	75 69		 jne	 SHORT $LN6@ListScript

; 575  :     {
; 576  :         // "No scripts currently running"
; 577  :         WRMSG( HHC02314, "I" );

  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189251
  0007e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189252
  0008a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0008f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00094	41 b9 03 00 00
	00		 mov	 r9d, 3
  0009a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189253
  000a1	ba 41 02 00 00	 mov	 edx, 577		; 00000241H
  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189254
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 578  :         release_lock( &sysblk.scrlock );

  000b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ba	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189255
  000c7	48 8b c8	 mov	 rcx, rax
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 579  :         return;

  000d0	e9 03 01 00 00	 jmp	 $LN1@ListScript
$LN6@ListScript:

; 580  :     }
; 581  : 
; 582  :     /* Display all entries in list */
; 583  :     for (pLink = scrlist.Flink; pLink != &scrlist; pLink = pLink->Flink)

  000d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR scrlist
  000dc	48 89 44 24 68	 mov	 QWORD PTR pLink$[rsp], rax
  000e1	eb 0d		 jmp	 SHORT $LN4@ListScript
$LN2@ListScript:
  000e3	48 8b 44 24 68	 mov	 rax, QWORD PTR pLink$[rsp]
  000e8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000eb	48 89 44 24 68	 mov	 QWORD PTR pLink$[rsp], rax
$LN4@ListScript:
  000f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  000f7	48 39 44 24 68	 cmp	 QWORD PTR pLink$[rsp], rax
  000fc	0f 84 b9 00 00
	00		 je	 $LN3@ListScript

; 584  :     {
; 585  :         pCtl = CONTAINING_RECORD( pLink, SCRCTL, link );

  00102	48 8b 44 24 68	 mov	 rax, QWORD PTR pLink$[rsp]
  00107	48 89 44 24 60	 mov	 QWORD PTR pCtl$[rsp], rax

; 586  :         if (!pCtl->scr_tid) continue; /* (inactive) */

  0010c	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  00111	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00115	75 02		 jne	 SHORT $LN7@ListScript
  00117	eb ca		 jmp	 SHORT $LN2@ListScript
$LN7@ListScript:

; 587  :         // "Script id:%d, tid:"TIDPAT", level:%d, name:%s"
; 588  :         WRMSG( HHC02315, "I", pCtl->scr_id,

  00119	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  0011e	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00123	74 10		 je	 SHORT $LN9@ListScript
  00125	48 8b 44 24 60	 mov	 rax, QWORD PTR pCtl$[rsp]
  0012a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0012e	48 89 44 24 70	 mov	 QWORD PTR tv88[rsp], rax
  00133	eb 0c		 jmp	 SHORT $LN10@ListScript
$LN9@ListScript:
  00135	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189257
  0013c	48 89 44 24 70	 mov	 QWORD PTR tv88[rsp], rax
$LN10@ListScript:
  00141	b9 01 00 00 00	 mov	 ecx, 1
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv88[rsp]
  00151	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00156	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0015b	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  0015e	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00167	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0016a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0016e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00173	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00176	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189258
  00181	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189259
  0018d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00192	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00197	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189260
  001a4	ba 4e 02 00 00	 mov	 edx, 590		; 0000024eH
  001a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189261
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 589  :             TID_CAST( pCtl->scr_tid ), pCtl->scr_recursion,
; 590  :             pCtl->scr_name ? pCtl->scr_name : "" );
; 591  :     }

  001b6	e9 28 ff ff ff	 jmp	 $LN2@ListScript
$LN3@ListScript:

; 592  : 
; 593  :     release_lock( &sysblk.scrlock );

  001bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c2	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  001c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189262
  001cf	48 8b c8	 mov	 rcx, rax
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@ListScript:

; 594  : }

  001d8	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  001df	c3		 ret	 0
ListScriptsIds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
pLink$ = 32
pCtl$ = 40
tid$ = 64
FindSCRCTL PROC

; 527  : {

$LN17:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 528  :     /* PROGRAMMING NOTE: the return type is "void*" so external
; 529  :        callers are able to query whether any scripts are running
; 530  :        without requiring them to known what our internal SCRCTL
; 531  :        struct looks like.
; 532  :     */
; 533  :     LIST_ENTRY*  pLink  = NULL;

  00008	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR pLink$[rsp], 0

; 534  :     SCRCTL*      pCtl   = NULL;

  00011	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pCtl$[rsp], 0
$LN4@FindSCRCTL:

; 535  : 
; 536  :     ASSERT( tid );  /* (sanity check) */

  0001a	83 7c 24 40 00	 cmp	 DWORD PTR tid$[rsp], 0
  0001f	75 5c		 jne	 SHORT $LN11@FindSCRCTL
$LN7@FindSCRCTL:
  00021	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189221
  00028	41 b8 18 02 00
	00		 mov	 r8d, 536		; 00000218H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189222
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189223
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00048	85 c0		 test	 eax, eax
  0004a	74 20		 je	 SHORT $LN12@FindSCRCTL
  0004c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189225
  00053	41 b8 18 02 00
	00		 mov	 r8d, 536		; 00000218H
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189226
  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189227
  00067	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@FindSCRCTL:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 af		 jne	 SHORT $LN7@FindSCRCTL
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00078	85 c0		 test	 eax, eax
  0007a	74 01		 je	 SHORT $LN13@FindSCRCTL
  0007c	cc		 int	 3
$LN13@FindSCRCTL:
$LN11@FindSCRCTL:
  0007d	33 c0		 xor	 eax, eax
  0007f	85 c0		 test	 eax, eax
  00081	75 97		 jne	 SHORT $LN4@FindSCRCTL

; 537  : 
; 538  :     obtain_lock( &sysblk.scrlock );

  00083	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0008a	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189229
  00097	48 8b c8	 mov	 rcx, rax
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 539  : 
; 540  :     /* Perform first-time initialization if needed */
; 541  :     if (!scrlist.Flink)

  000a0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR scrlist, 0
  000a8	75 1c		 jne	 SHORT $LN14@FindSCRCTL

; 542  :         InitializeListHead( &scrlist );

  000aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  000b1	48 89 05 08 00
	00 00		 mov	 QWORD PTR scrlist+8, rax
  000b8	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR scrlist+8
  000bf	48 89 05 00 00
	00 00		 mov	 QWORD PTR scrlist, rax
$LN14@FindSCRCTL:

; 543  : 
; 544  :     /* Search the list to locate the desired entry */
; 545  :     for (pLink = scrlist.Flink; pLink != &scrlist; pLink = pLink->Flink)

  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR scrlist
  000cd	48 89 44 24 20	 mov	 QWORD PTR pLink$[rsp], rax
  000d2	eb 0d		 jmp	 SHORT $LN10@FindSCRCTL
$LN8@FindSCRCTL:
  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR pLink$[rsp]
  000d9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000dc	48 89 44 24 20	 mov	 QWORD PTR pLink$[rsp], rax
$LN10@FindSCRCTL:
  000e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  000e8	48 39 44 24 20	 cmp	 QWORD PTR pLink$[rsp], rax
  000ed	74 51		 je	 SHORT $LN9@FindSCRCTL

; 546  :     {
; 547  :         pCtl = CONTAINING_RECORD( pLink, SCRCTL, link );

  000ef	48 8b 44 24 20	 mov	 rax, QWORD PTR pLink$[rsp]
  000f4	48 89 44 24 28	 mov	 QWORD PTR pCtl$[rsp], rax

; 548  :         if (pCtl->scr_tid && equal_threads( pCtl->scr_tid, tid ))

  000f9	48 8b 44 24 28	 mov	 rax, QWORD PTR pCtl$[rsp]
  000fe	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  00102	74 3a		 je	 SHORT $LN15@FindSCRCTL
  00104	8b 54 24 40	 mov	 edx, DWORD PTR tid$[rsp]
  00108	48 8b 44 24 28	 mov	 rax, QWORD PTR pCtl$[rsp]
  0010d	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_equal_threads
  00116	85 c0		 test	 eax, eax
  00118	74 24		 je	 SHORT $LN15@FindSCRCTL

; 549  :         {
; 550  :             release_lock( &sysblk.scrlock );

  0011a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00121	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189232
  0012e	48 8b c8	 mov	 rcx, rax
  00131	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 551  :             return pCtl; /* (found) */

  00137	48 8b 44 24 28	 mov	 rax, QWORD PTR pCtl$[rsp]
  0013c	eb 21		 jmp	 SHORT $LN1@FindSCRCTL
$LN15@FindSCRCTL:

; 552  :         }
; 553  :     }

  0013e	eb 94		 jmp	 SHORT $LN8@FindSCRCTL
$LN9@FindSCRCTL:

; 554  : 
; 555  :     release_lock( &sysblk.scrlock );

  00140	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00147	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  0014d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189233
  00154	48 8b c8	 mov	 rcx, rax
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 556  :     return NULL; /* (not found) */

  0015d	33 c0		 xor	 eax, eax
$LN1@FindSCRCTL:

; 557  : }

  0015f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00163	c3		 ret	 0
FindSCRCTL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
_EX_Flink$1 = 32
_EX_Blink$2 = 40
pCtl$ = 64
FreeSCRCTL PROC

; 507  : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@FreeSCRCTL:

; 508  :     ASSERT( pCtl ); /* (sanity check) */

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  0000f	75 5c		 jne	 SHORT $LN8@FreeSCRCTL
$LN7@FreeSCRCTL:
  00011	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189186
  00018	41 b8 fc 01 00
	00		 mov	 r8d, 508		; 000001fcH
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189187
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189188
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00038	85 c0		 test	 eax, eax
  0003a	74 20		 je	 SHORT $LN9@FreeSCRCTL
  0003c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189190
  00043	41 b8 fc 01 00
	00		 mov	 r8d, 508		; 000001fcH
  00049	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189191
  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189192
  00057	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@FreeSCRCTL:
  0005c	33 c0		 xor	 eax, eax
  0005e	85 c0		 test	 eax, eax
  00060	75 af		 jne	 SHORT $LN7@FreeSCRCTL
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00068	85 c0		 test	 eax, eax
  0006a	74 01		 je	 SHORT $LN10@FreeSCRCTL
  0006c	cc		 int	 3
$LN10@FreeSCRCTL:
$LN8@FreeSCRCTL:
  0006d	33 c0		 xor	 eax, eax
  0006f	85 c0		 test	 eax, eax
  00071	75 96		 jne	 SHORT $LN4@FreeSCRCTL

; 509  : 
; 510  :     /* Remove ENTRY from processing list */
; 511  :     obtain_lock( &sysblk.scrlock );

  00073	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007a	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189194
  00087	48 8b c8	 mov	 rcx, rax
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 512  :     RemoveListEntry( &pCtl->link );

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 89 44 24 20	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  000a2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  000a6	48 89 44 24 28	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  000ab	48 8b 44 24 28	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  000b0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  000b5	48 89 08	 mov	 QWORD PTR [rax], rcx
  000b8	48 8b 44 24 20	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  000bd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  000c2	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 513  :     release_lock( &sysblk.scrlock );

  000c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cd	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  000d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189195
  000da	48 8b c8	 mov	 rcx, rax
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 514  : 
; 515  :     /* Free list entry and return */
; 516  :     if (pCtl->scr_name)

  000e3	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  000e8	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000ed	74 0f		 je	 SHORT $LN11@FreeSCRCTL

; 517  :         free( pCtl->scr_name );

  000ef	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  000f4	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN11@FreeSCRCTL:

; 518  :     if (pCtl->scr_cmdline)

  000fe	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  00103	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00108	74 0f		 je	 SHORT $LN12@FreeSCRCTL

; 519  :         free( pCtl->scr_cmdline );

  0010a	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  0010f	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN12@FreeSCRCTL:

; 520  :     free( pCtl );

  00119	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 521  : }

  00124	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00128	c3		 ret	 0
FreeSCRCTL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
pCtl$ = 48
script_name$ = 56
UpdSCRCTL PROC

; 494  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 495  :     obtain_lock( &sysblk.scrlock );

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00015	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189167
  00022	48 8b c8	 mov	 rcx, rax
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 496  : 
; 497  :     if (pCtl->scr_name) free( pCtl->scr_name );

  0002b	48 8b 44 24 30	 mov	 rax, QWORD PTR pCtl$[rsp]
  00030	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  00035	74 0f		 je	 SHORT $LN2@UpdSCRCTL
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR pCtl$[rsp]
  0003c	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@UpdSCRCTL:

; 498  :     pCtl->scr_name = strdup( script_name );

  00046	48 8b 4c 24 38	 mov	 rcx, QWORD PTR script_name$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00051	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00056	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 499  : 
; 500  :     release_lock( &sysblk.scrlock );

  0005a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00061	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189169
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 501  : }

  00077	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0007b	c3		 ret	 0
UpdSCRCTL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
pCtl$ = 64
_EX_Head$1 = 72
scr_name$ = 80
_EX_Tail$2 = 88
tid$ = 112
script_name$ = 120
NewSCRCTL PROC

; 456  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 83 ec 60	 sub	 rsp, 96			; 00000060H
$LN4@NewSCRCTL:

; 457  :     SCRCTL* pCtl;
; 458  :     char* scr_name;
; 459  :     ASSERT( script_name );

  0000e	48 83 7c 24 78
	00		 cmp	 QWORD PTR script_name$[rsp], 0
  00014	75 5c		 jne	 SHORT $LN8@NewSCRCTL
$LN7@NewSCRCTL:
  00016	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189142
  0001d	41 b8 cb 01 00
	00		 mov	 r8d, 459		; 000001cbH
  00023	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189143
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189144
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003d	85 c0		 test	 eax, eax
  0003f	74 20		 je	 SHORT $LN9@NewSCRCTL
  00041	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG189146
  00048	41 b8 cb 01 00
	00		 mov	 r8d, 459		; 000001cbH
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189147
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189148
  0005c	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@NewSCRCTL:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 af		 jne	 SHORT $LN7@NewSCRCTL
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0006d	85 c0		 test	 eax, eax
  0006f	74 01		 je	 SHORT $LN10@NewSCRCTL
  00071	cc		 int	 3
$LN10@NewSCRCTL:
$LN8@NewSCRCTL:
  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 96		 jne	 SHORT $LN4@NewSCRCTL

; 460  : 
; 461  :     /* Create a new entry */
; 462  :     if (0
; 463  :         || !(pCtl = malloc (sizeof( SCRCTL )))
; 464  :         || !(scr_name = strdup( script_name ))

  00078	33 c0		 xor	 eax, eax
  0007a	85 c0		 test	 eax, eax
  0007c	75 30		 jne	 SHORT $LN12@NewSCRCTL
  0007e	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00089	48 89 44 24 40	 mov	 QWORD PTR pCtl$[rsp], rax
  0008e	48 83 7c 24 40
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  00094	74 18		 je	 SHORT $LN12@NewSCRCTL
  00096	48 8b 4c 24 78	 mov	 rcx, QWORD PTR script_name$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000a1	48 89 44 24 50	 mov	 QWORD PTR scr_name$[rsp], rax
  000a6	48 83 7c 24 50
	00		 cmp	 QWORD PTR scr_name$[rsp], 0
  000ac	75 61		 jne	 SHORT $LN11@NewSCRCTL
$LN12@NewSCRCTL:

; 465  :     )
; 466  :     {
; 467  :         // "Out of memory"
; 468  :         WRMSG( HHC00152, "E" );

  000ae	b9 01 00 00 00	 mov	 ecx, 1
  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189152
  000c0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189153
  000cc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d6	41 b9 03 00 00
	00		 mov	 r9d, 3
  000dc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189154
  000e3	ba d4 01 00 00	 mov	 edx, 468		; 000001d4H
  000e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189155
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 469  :         if (pCtl) free( pCtl );

  000f5	48 83 7c 24 40
	00		 cmp	 QWORD PTR pCtl$[rsp], 0
  000fb	74 0b		 je	 SHORT $LN13@NewSCRCTL
  000fd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN13@NewSCRCTL:

; 470  :         return NULL;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 12 01 00 00	 jmp	 $LN1@NewSCRCTL
$LN11@NewSCRCTL:

; 471  :     }
; 472  : 
; 473  :     /* Initialize the new entry */
; 474  :     memset( pCtl, 0, sizeof( SCRCTL ));

  0010f	48 8b 7c 24 40	 mov	 rdi, QWORD PTR pCtl$[rsp]
  00114	33 c0		 xor	 eax, eax
  00116	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0011b	f3 aa		 rep stosb

; 475  :     InitializeListLink( &pCtl->link );

  0011d	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  00122	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0012a	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  0012f	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 476  :     pCtl->scr_tid = tid; /* (may be zero) */

  00136	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  0013b	8b 4c 24 70	 mov	 ecx, DWORD PTR tid$[rsp]
  0013f	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 477  :     pCtl->scr_name = scr_name;

  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  00147	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scr_name$[rsp]
  0014c	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 478  : 
; 479  :     /* Add the new entry to our list */
; 480  :     obtain_lock( &sysblk.scrlock );

  00150	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00157	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  0015d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189157
  00164	48 8b c8	 mov	 rcx, rax
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 481  :     pCtl->scr_id = ++scrid;

  0016d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR scrid
  00173	ff c0		 inc	 eax
  00175	89 05 00 00 00
	00		 mov	 DWORD PTR scrid, eax
  0017b	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  00180	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR scrid
  00186	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 482  :     if (!scrlist.Flink)

  00189	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR scrlist, 0
  00191	75 1c		 jne	 SHORT $LN14@NewSCRCTL

; 483  :         InitializeListHead( &scrlist );

  00193	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  0019a	48 89 05 08 00
	00 00		 mov	 QWORD PTR scrlist+8, rax
  001a1	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR scrlist+8
  001a8	48 89 05 00 00
	00 00		 mov	 QWORD PTR scrlist, rax
$LN14@NewSCRCTL:

; 484  :     InsertListTail( &scrlist, &pCtl->link );

  001af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:scrlist
  001b6	48 89 44 24 48	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  001bb	48 8b 44 24 48	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  001c0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001c4	48 89 44 24 58	 mov	 QWORD PTR _EX_Tail$2[rsp], rax
  001c9	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  001ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  001d3	48 89 08	 mov	 QWORD PTR [rax], rcx
  001d6	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  001db	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Tail$2[rsp]
  001e0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  001e4	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  001e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Tail$2[rsp]
  001ee	48 89 01	 mov	 QWORD PTR [rcx], rax
  001f1	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
  001f6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  001fb	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 485  :     release_lock( &sysblk.scrlock );

  001ff	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00206	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  0020c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189159
  00213	48 8b c8	 mov	 rcx, rax
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 486  : 
; 487  :     return pCtl;

  0021c	48 8b 44 24 40	 mov	 rax, QWORD PTR pCtl$[rsp]
$LN1@NewSCRCTL:

; 488  : }

  00221	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00225	5f		 pop	 rdi
  00226	c3		 ret	 0
NewSCRCTL ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
stmtlen$ = 96
c$ = 100
lstarted$ = 104
buf1$ = 112
tv69 = 120
tv77 = 128
fname$ = 160
fp$ = 168
buf$ = 176
buflen$ = 184
inc_stmtnum$ = 192
read_config PROC

; 75   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
$LN24@read_confi:
$LN2@read_confi:

; 76   : int     c;                              /* Character work area       */
; 77   : unsigned int     stmtlen;               /* Statement length          */
; 78   : int     lstarted;                       /* Indicate if non-whitespace*/
; 79   :                                         /* has been seen yet in line */
; 80   : char   *buf1;                           /* Pointer to resolved buffer*/
; 81   : 
; 82   :     while (1)

  0001c	33 c0		 xor	 eax, eax
  0001e	83 f8 01	 cmp	 eax, 1
  00021	0f 84 55 04 00
	00		 je	 $LN3@read_confi

; 83   :     {
; 84   :         /* Increment statement number */
; 85   :         (*inc_stmtnum)++;

  00027	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR inc_stmtnum$[rsp]
  0002f	8b 00		 mov	 eax, DWORD PTR [rax]
  00031	ff c0		 inc	 eax
  00033	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inc_stmtnum$[rsp]
  0003b	89 01		 mov	 DWORD PTR [rcx], eax

; 86   : 
; 87   :         /* Read next statement from configuration file */
; 88   :         for (stmtlen = 0, lstarted = 0; ;)

  0003d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR stmtlen$[rsp], 0
  00045	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR lstarted$[rsp], 0
$LN4@read_confi:

; 89   :         {
; 90   :             if (stmtlen == 0)

  0004d	83 7c 24 60 00	 cmp	 DWORD PTR stmtlen$[rsp], 0
  00052	75 1d		 jne	 SHORT $LN7@read_confi

; 91   :                 memset(buf, 0, buflen); // clear work area

  00054	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  0005b	48 89 44 24 78	 mov	 QWORD PTR tv69[rsp], rax
  00060	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR buf$[rsp]
  00068	33 c0		 xor	 eax, eax
  0006a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv69[rsp]
  0006f	f3 aa		 rep stosb
$LN7@read_confi:

; 92   : 
; 93   :             /* Read character from configuration file */
; 94   :             c = fgetc(fp);

  00071	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fp$[rsp]
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  0007f	89 44 24 64	 mov	 DWORD PTR c$[rsp], eax

; 95   : 
; 96   :             /* Check for I/O error */
; 97   :             if (ferror(fp))

  00083	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR fp$[rsp]
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00091	85 c0		 test	 eax, eax
  00093	0f 84 9b 00 00
	00		 je	 $LN8@read_confi

; 98   :             {
; 99   :                 WRMSG(HHC01432, "S", *inc_stmtnum, fname, "fgetc()", strerror(errno));

  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009f	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000a7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
  000af	b9 01 00 00 00	 mov	 ecx, 1
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv77[rsp]
  000c2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188913
  000ce	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000db	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inc_stmtnum$[rsp]
  000e8	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000ea	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188914
  000f5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188915
  00101	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00106	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0010b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00111	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188916
  00118	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188917
  00124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 100  :                 return -1;

  0012a	b8 ff ff ff ff	 mov	 eax, -1
  0012f	e9 4a 03 00 00	 jmp	 $LN1@read_confi
$LN8@read_confi:

; 101  :             }
; 102  : 
; 103  :             /* Check for end of file */
; 104  :             if (stmtlen == 0 && (c == EOF || c == '\x1A'))

  00134	83 7c 24 60 00	 cmp	 DWORD PTR stmtlen$[rsp], 0
  00139	75 18		 jne	 SHORT $LN9@read_confi
  0013b	83 7c 24 64 ff	 cmp	 DWORD PTR c$[rsp], -1
  00140	74 07		 je	 SHORT $LN10@read_confi
  00142	83 7c 24 64 1a	 cmp	 DWORD PTR c$[rsp], 26
  00147	75 0a		 jne	 SHORT $LN9@read_confi
$LN10@read_confi:

; 105  :                 return -1;

  00149	b8 ff ff ff ff	 mov	 eax, -1
  0014e	e9 2b 03 00 00	 jmp	 $LN1@read_confi
$LN9@read_confi:

; 106  : 
; 107  :             /* Check for end of line */
; 108  :             if (c == '\n' || c == EOF || c == '\x1A')

  00153	83 7c 24 64 0a	 cmp	 DWORD PTR c$[rsp], 10
  00158	74 0e		 je	 SHORT $LN12@read_confi
  0015a	83 7c 24 64 ff	 cmp	 DWORD PTR c$[rsp], -1
  0015f	74 07		 je	 SHORT $LN12@read_confi
  00161	83 7c 24 64 1a	 cmp	 DWORD PTR c$[rsp], 26
  00166	75 05		 jne	 SHORT $LN11@read_confi
$LN12@read_confi:

; 109  :                 break;

  00168	e9 d3 00 00 00	 jmp	 $LN5@read_confi
$LN11@read_confi:

; 110  : 
; 111  :             /* Ignore nulls and carriage returns */
; 112  :             if (c == '\0' || c == '\r') continue;

  0016d	83 7c 24 64 00	 cmp	 DWORD PTR c$[rsp], 0
  00172	74 07		 je	 SHORT $LN14@read_confi
  00174	83 7c 24 64 0d	 cmp	 DWORD PTR c$[rsp], 13
  00179	75 05		 jne	 SHORT $LN13@read_confi
$LN14@read_confi:
  0017b	e9 cd fe ff ff	 jmp	 $LN4@read_confi
$LN13@read_confi:

; 113  : 
; 114  :             /* Check if it is a white space and no other character yet */
; 115  :             if(!lstarted && isspace(c)) continue;

  00180	83 7c 24 68 00	 cmp	 DWORD PTR lstarted$[rsp], 0
  00185	75 13		 jne	 SHORT $LN15@read_confi
  00187	8b 4c 24 64	 mov	 ecx, DWORD PTR c$[rsp]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  00191	85 c0		 test	 eax, eax
  00193	74 05		 je	 SHORT $LN15@read_confi
  00195	e9 b3 fe ff ff	 jmp	 $LN4@read_confi
$LN15@read_confi:

; 116  :             lstarted=1;

  0019a	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR lstarted$[rsp], 1

; 117  : 
; 118  :             /* Check that statement does not overflow buffer */
; 119  :             if (stmtlen >= buflen - 1)

  001a2	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  001a9	ff c8		 dec	 eax
  001ab	39 44 24 60	 cmp	 DWORD PTR stmtlen$[rsp], eax
  001af	72 6c		 jb	 SHORT $LN16@read_confi

; 120  :             {
; 121  :                 WRMSG(HHC01433, "S", *inc_stmtnum, fname);

  001b1	b9 01 00 00 00	 mov	 ecx, 1
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001c4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001c9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inc_stmtnum$[rsp]
  001d1	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001d3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188926
  001de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188927
  001ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  001fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188928
  00201	ba 79 00 00 00	 mov	 edx, 121		; 00000079H
  00206	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188929
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 122  :                 return -1;

  00213	b8 ff ff ff ff	 mov	 eax, -1
  00218	e9 61 02 00 00	 jmp	 $LN1@read_confi
$LN16@read_confi:

; 123  :             }
; 124  : 
; 125  :             /* Append character to buffer */
; 126  :             buf[stmtlen++] = c;

  0021d	8b 44 24 60	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00221	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00229	0f b6 54 24 64	 movzx	 edx, BYTE PTR c$[rsp]
  0022e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00231	8b 44 24 60	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00235	ff c0		 inc	 eax
  00237	89 44 24 60	 mov	 DWORD PTR stmtlen$[rsp], eax

; 127  : 
; 128  :         } /* end for(stmtlen) */

  0023b	e9 0d fe ff ff	 jmp	 $LN4@read_confi
$LN5@read_confi:

; 129  : 
; 130  :         /* Null terminate the buffer */
; 131  :         buf[ stmtlen ] = 0;

  00240	8b 44 24 60	 mov	 eax, DWORD PTR stmtlen$[rsp]
  00244	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0024c	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 132  : 
; 133  :         /* Remove trailing whitespace */
; 134  :         RTRIM( buf );

  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188930
  00257	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim

; 135  :         stmtlen = (int) strlen( buf );

  00265	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0026d	e8 00 00 00 00	 call	 strlen
  00272	89 44 24 60	 mov	 DWORD PTR stmtlen$[rsp], eax

; 136  : 
; 137  :         set_symbol("CUU","$(CUU)");

  00276	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188931
  0027d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188932
  00284	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 138  :         set_symbol("CCUU","$(CCUU)");

  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188933
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188934
  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 139  :         set_symbol("DEVN","$(DEVN)");

  0029e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG188935
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188936
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 140  : 
; 141  :         /* Perform variable substitution */
; 142  :         buf1=resolve_symbol_string(buf);

  002b2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  002c0	48 89 44 24 70	 mov	 QWORD PTR buf1$[rsp], rax

; 143  : 
; 144  :         if(buf1!=NULL)

  002c5	48 83 7c 24 70
	00		 cmp	 QWORD PTR buf1$[rsp], 0
  002cb	0f 84 c6 00 00
	00		 je	 $LN17@read_confi

; 145  :         {
; 146  :             if(strlen(buf1)>=buflen)

  002d1	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf1$[rsp]
  002d6	e8 00 00 00 00	 call	 strlen
  002db	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR buflen$[rsp]
  002e2	48 3b c1	 cmp	 rax, rcx
  002e5	72 77		 jb	 SHORT $LN18@read_confi

; 147  :             {
; 148  :                 WRMSG(HHC01433, "S", *inc_stmtnum, fname);

  002e7	b9 01 00 00 00	 mov	 ecx, 1
  002ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  002fa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002ff	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inc_stmtnum$[rsp]
  00307	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00309	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188939
  00314	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188940
  00320	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00325	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0032a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00330	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188941
  00337	ba 94 00 00 00	 mov	 edx, 148		; 00000094H
  0033c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188942
  00343	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 149  :                 free(buf1);

  00349	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf1$[rsp]
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 150  :                 return -1;

  00354	b8 ff ff ff ff	 mov	 eax, -1
  00359	e9 20 01 00 00	 jmp	 $LN1@read_confi
$LN18@read_confi:

; 151  :             }
; 152  :             strlcpy(buf,buf1,buflen);

  0035e	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR buflen$[rsp]
  00365	44 8b c0	 mov	 r8d, eax
  00368	48 8b 54 24 70	 mov	 rdx, QWORD PTR buf1$[rsp]
  0036d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00375	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 153  :             free(buf1);

  0037b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR buf1$[rsp]
  00380	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 154  :             stmtlen = strlen( buf );

  00386	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0038e	e8 00 00 00 00	 call	 strlen
  00393	89 44 24 60	 mov	 DWORD PTR stmtlen$[rsp], eax
$LN17@read_confi:

; 155  :         }
; 156  : 
; 157  :         /* Loud comments should always be logged */
; 158  :         if (stmtlen != 0 && buf[0] == '*')

  00397	83 7c 24 60 00	 cmp	 DWORD PTR stmtlen$[rsp], 0
  0039c	74 6e		 je	 SHORT $LN19@read_confi
  0039e	b8 01 00 00 00	 mov	 eax, 1
  003a3	48 6b c0 00	 imul	 rax, rax, 0
  003a7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  003af	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  003b3	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  003b6	75 54		 jne	 SHORT $LN19@read_confi

; 159  :             WRMSG( HHC01603, "I", buf );  // "%s"

  003b8	b9 01 00 00 00	 mov	 ecx, 1
  003bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  003cb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188944
  003d7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188945
  003e3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003e8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ed	41 b9 03 00 00
	00		 mov	 r9d, 3
  003f3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG188946
  003fa	ba 9f 00 00 00	 mov	 edx, 159		; 0000009fH
  003ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG188947
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@read_confi:

; 160  : 
; 161  :         /* Ignore null statements and comments */
; 162  :         if (stmtlen == 0 || buf[0] == '*' || buf[0] == '#')

  0040c	83 7c 24 60 00	 cmp	 DWORD PTR stmtlen$[rsp], 0
  00411	74 34		 je	 SHORT $LN21@read_confi
  00413	b8 01 00 00 00	 mov	 eax, 1
  00418	48 6b c0 00	 imul	 rax, rax, 0
  0041c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00424	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00428	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0042b	74 1a		 je	 SHORT $LN21@read_confi
  0042d	b8 01 00 00 00	 mov	 eax, 1
  00432	48 6b c0 00	 imul	 rax, rax, 0
  00436	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0043e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00442	83 f8 23	 cmp	 eax, 35			; 00000023H
  00445	75 05		 jne	 SHORT $LN20@read_confi
$LN21@read_confi:

; 163  :            continue;

  00447	e9 d0 fb ff ff	 jmp	 $LN2@read_confi
$LN20@read_confi:

; 164  : 
; 165  :         /* Special handling for 'pause' and other statements */
; 166  :         if (do_special(fname, inc_stmtnum, NULL, buf))

  0044c	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR buf$[rsp]
  00454	45 33 c0	 xor	 r8d, r8d
  00457	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR inc_stmtnum$[rsp]
  0045f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00467	e8 00 00 00 00	 call	 do_special
  0046c	85 c0		 test	 eax, eax
  0046e	74 05		 je	 SHORT $LN22@read_confi

; 167  :             continue;

  00470	e9 a7 fb ff ff	 jmp	 $LN24@read_confi
$LN22@read_confi:

; 168  : 
; 169  :         break;

  00475	eb 05		 jmp	 SHORT $LN3@read_confi

; 170  :     } /* end while */

  00477	e9 a0 fb ff ff	 jmp	 $LN2@read_confi
$LN3@read_confi:

; 171  : 
; 172  :     return 0;

  0047c	33 c0		 xor	 eax, eax
$LN1@read_confi:

; 173  : } /* end function read_config */

  0047e	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  00485	5f		 pop	 rdi
  00486	c3		 ret	 0
read_config ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
i$ = 32
len$1 = 36
len$2 = 40
psa$3 = 48
psa$4 = 56
regs$ = 64
s$ = 112
set_restart PROC

; 1250 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1251 :     int i;
; 1252 :     REGS *regs;
; 1253 : 
; 1254 :     static const char * psws[] =
; 1255 :     {
; 1256 :         /* Maintain in order of assigned locations                   */
; 1257 :         "external", "svc", "program", "machine", "io", 0
; 1258 :     };
; 1259 : 
; 1260 :     for (i = 0; ; i++)

  0000b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00013	eb 0a		 jmp	 SHORT $LN4@set_restar
$LN2@set_restar:
  00015	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00019	ff c0		 inc	 eax
  0001b	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@set_restar:

; 1261 :     {
; 1262 :         if (!psws[i]) return 0;

  0001f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00024	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?psws@?1??set_restart@@9@9
  0002b	48 83 3c c1 00	 cmp	 QWORD PTR [rcx+rax*8], 0
  00030	75 07		 jne	 SHORT $LN5@set_restar
  00032	33 c0		 xor	 eax, eax
  00034	e9 f0 00 00 00	 jmp	 $LN1@set_restar
$LN5@set_restar:

; 1263 :         if (!strcasecmp(s, psws[i])) break;

  00039	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?psws@?1??set_restart@@9@9
  00045	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00049	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00054	85 c0		 test	 eax, eax
  00056	75 02		 jne	 SHORT $LN6@set_restar
  00058	eb 02		 jmp	 SHORT $LN3@set_restar
$LN6@set_restar:

; 1264 :     }

  0005a	eb b9		 jmp	 SHORT $LN2@set_restar
$LN3@set_restar:

; 1265 : 
; 1266 :     regs = sysblk.regs[sysblk.pcpu];

  0005c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00063	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0006a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00071	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00079	48 89 44 24 40	 mov	 QWORD PTR regs$[rsp], rax

; 1267 : 
; 1268 :     if (sysblk.arch_mode == ARCH_900_IDX)

  0007e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00085	83 b8 88 00 00
	00 02		 cmp	 DWORD PTR [rax+136], 2
  0008c	75 50		 jne	 SHORT $LN7@set_restar

; 1269 :     {
; 1270 :         PSA_900 * psa = regs->zpsa;

  0008e	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00093	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  0009a	48 89 44 24 38	 mov	 QWORD PTR psa$4[rsp], rax

; 1271 :         const int len = sizeof(psa->rstnew);

  0009f	c7 44 24 24 10
	00 00 00	 mov	 DWORD PTR len$1[rsp], 16

; 1272 : 
; 1273 :         memcpy(psa->rstnew, psa->extold + i * len, len);

  000a7	48 63 44 24 24	 movsxd	 rax, DWORD PTR len$1[rsp]
  000ac	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000b0	0f af 4c 24 24	 imul	 ecx, DWORD PTR len$1[rsp]
  000b5	48 63 c9	 movsxd	 rcx, ecx
  000b8	48 8b 54 24 38	 mov	 rdx, QWORD PTR psa$4[rsp]
  000bd	48 8d 8c 0a 30
	01 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+304]
  000c5	48 8b 54 24 38	 mov	 rdx, QWORD PTR psa$4[rsp]
  000ca	48 81 c2 a0 01
	00 00		 add	 rdx, 416		; 000001a0H
  000d1	48 8b fa	 mov	 rdi, rdx
  000d4	48 8b f1	 mov	 rsi, rcx
  000d7	48 8b c8	 mov	 rcx, rax
  000da	f3 a4		 rep movsb

; 1274 :     }

  000dc	eb 46		 jmp	 SHORT $LN8@set_restar
$LN7@set_restar:

; 1275 :     else
; 1276 :     {
; 1277 :         PSA_3XX * psa = regs->psa;

  000de	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000e3	48 8b 80 60 08
	00 00		 mov	 rax, QWORD PTR [rax+2144]
  000ea	48 89 44 24 30	 mov	 QWORD PTR psa$3[rsp], rax

; 1278 :         const int len = sizeof(psa->extold);

  000ef	c7 44 24 28 08
	00 00 00	 mov	 DWORD PTR len$2[rsp], 8

; 1279 : 
; 1280 :         memcpy(psa->iplpsw, psa->extold + i * len, len);

  000f7	48 63 44 24 28	 movsxd	 rax, DWORD PTR len$2[rsp]
  000fc	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00100	0f af 4c 24 28	 imul	 ecx, DWORD PTR len$2[rsp]
  00105	48 63 c9	 movsxd	 rcx, ecx
  00108	48 8b 54 24 30	 mov	 rdx, QWORD PTR psa$3[rsp]
  0010d	48 8d 4c 0a 18	 lea	 rcx, QWORD PTR [rdx+rcx+24]
  00112	48 8b 54 24 30	 mov	 rdx, QWORD PTR psa$3[rsp]
  00117	48 8b 7c 24 30	 mov	 rdi, QWORD PTR psa$3[rsp]
  0011c	48 8b f1	 mov	 rsi, rcx
  0011f	48 8b c8	 mov	 rcx, rax
  00122	f3 a4		 rep movsb
$LN8@set_restar:

; 1281 :     }
; 1282 :     return 1;                         /* OK                          */

  00124	b8 01 00 00 00	 mov	 eax, 1
$LN1@set_restar:

; 1283 : }

  00129	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0012d	5f		 pop	 rdi
  0012e	5e		 pop	 rsi
  0012f	c3		 ret	 0
set_restart ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
p2$ = 80
msecs$ = 88
secs$ = 96
elapsed_usecs$ = 104
usecs$ = 108
p3$1 = 112
dur$ = 120
now$ = 128
beg$ = 136
fname$ = 160
inc_stmtnum$ = 168
pCtl$ = 176
p$ = 184
do_special PROC

; 1290 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1291 :     struct timeval beg, now, dur;   /* To calculate remaining time   */
; 1292 :     double secs;                    /* Seconds to pause processing   */
; 1293 :     U32 msecs;                      /* Same thing in milliseconds    */
; 1294 :     U32 usecs;                      /* Same thing in microseconds    */
; 1295 :     U32 elapsed_usecs;              /* To calculate remaining time   */
; 1296 :     char* p2 = p;                   /* Work ptr for stmt parsing     */

  0001b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00023	48 89 44 24 50	 mov	 QWORD PTR p2$[rsp], rax

; 1297 : 
; 1298 :     /* Determine if pause statement, special statement, or neither.  */
; 1299 :     if (strncasecmp( p2, "pause ", 6 ) == 0)

  00028	41 b8 06 00 00
	00		 mov	 r8d, 6
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189792
  00035	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p2$[rsp]
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00040	85 c0		 test	 eax, eax
  00042	75 13		 jne	 SHORT $LN7@do_special

; 1300 :     {
; 1301 :         p2 += 6;

  00044	48 8b 44 24 50	 mov	 rax, QWORD PTR p2$[rsp]
  00049	48 83 c0 06	 add	 rax, 6
  0004d	48 89 44 24 50	 mov	 QWORD PTR p2$[rsp], rax

; 1302 :     }

  00052	e9 c8 00 00 00	 jmp	 $LN8@do_special
$LN7@do_special:

; 1303 :     else
; 1304 :     /* The runtest command is only valid in scripts not config files */
; 1305 :     if (1
; 1306 :         && pCtl
; 1307 :         && sysblk.scrtest
; 1308 :         && strncasecmp( p2, "runtest", 7 ) == 0
; 1309 :         && (*(p2+7) == ' ' || *(p2+7) == '\0')

  00057	33 c0		 xor	 eax, eax
  00059	83 f8 01	 cmp	 eax, 1
  0005c	0f 84 b6 00 00
	00		 je	 $LN9@do_special
  00062	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR pCtl$[rsp], 0
  0006b	0f 84 a7 00 00
	00		 je	 $LN9@do_special
  00071	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00078	83 b8 18 11 00
	00 00		 cmp	 DWORD PTR [rax+4376], 0
  0007f	0f 84 93 00 00
	00		 je	 $LN9@do_special
  00085	41 b8 07 00 00
	00		 mov	 r8d, 7
  0008b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189795
  00092	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p2$[rsp]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0009d	85 c0		 test	 eax, eax
  0009f	75 77		 jne	 SHORT $LN9@do_special
  000a1	48 8b 44 24 50	 mov	 rax, QWORD PTR p2$[rsp]
  000a6	0f be 40 07	 movsx	 eax, BYTE PTR [rax+7]
  000aa	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ad	74 0d		 je	 SHORT $LN11@do_special
  000af	48 8b 44 24 50	 mov	 rax, QWORD PTR p2$[rsp]
  000b4	0f be 40 07	 movsx	 eax, BYTE PTR [rax+7]
  000b8	85 c0		 test	 eax, eax
  000ba	75 5c		 jne	 SHORT $LN9@do_special
$LN11@do_special:

; 1310 :     )
; 1311 :     {
; 1312 :         p2 += 7;

  000bc	48 8b 44 24 50	 mov	 rax, QWORD PTR p2$[rsp]
  000c1	48 83 c0 07	 add	 rax, 7
  000c5	48 89 44 24 50	 mov	 QWORD PTR p2$[rsp], rax

; 1313 :         /* Skip past any blanks to the first argument, if any */
; 1314 :         if (*p2)

  000ca	48 8b 44 24 50	 mov	 rax, QWORD PTR p2$[rsp]
  000cf	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000d2	85 c0		 test	 eax, eax
  000d4	74 1c		 je	 SHORT $LN12@do_special
$LN2@do_special:

; 1315 :             while (*p2 == ' ')

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR p2$[rsp]
  000db	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000de	83 f8 20	 cmp	 eax, 32			; 00000020H
  000e1	75 0f		 jne	 SHORT $LN3@do_special

; 1316 :                 ++p2;

  000e3	48 8b 44 24 50	 mov	 rax, QWORD PTR p2$[rsp]
  000e8	48 ff c0	 inc	 rax
  000eb	48 89 44 24 50	 mov	 QWORD PTR p2$[rsp], rax
  000f0	eb e4		 jmp	 SHORT $LN2@do_special
$LN3@do_special:
$LN12@do_special:

; 1317 :         runtest( pCtl, p, p2 );

  000f2	4c 8b 44 24 50	 mov	 r8, QWORD PTR p2$[rsp]
  000f7	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR p$[rsp]
  000ff	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00107	e8 00 00 00 00	 call	 runtest

; 1318 :         return TRUE;

  0010c	b8 01 00 00 00	 mov	 eax, 1
  00111	e9 bf 04 00 00	 jmp	 $LN1@do_special

; 1319 :     }

  00116	eb 07		 jmp	 SHORT $LN10@do_special
$LN9@do_special:

; 1320 :     else
; 1321 :         return FALSE;

  00118	33 c0		 xor	 eax, eax
  0011a	e9 b6 04 00 00	 jmp	 $LN1@do_special
$LN10@do_special:
$LN8@do_special:

; 1322 : 
; 1323 :     /* Determine maximum pause duration in seconds */
; 1324 :     if (pCtl) /* only if script stmt; cfg file already did this */

  0011f	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR pCtl$[rsp], 0
  00128	74 49		 je	 SHORT $LN13@do_special

; 1325 :     {
; 1326 :         char *p3 = resolve_symbol_string( p2 );

  0012a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p2$[rsp]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  00135	48 89 44 24 70	 mov	 QWORD PTR p3$1[rsp], rax

; 1327 :         if (p3)

  0013a	48 83 7c 24 70
	00		 cmp	 QWORD PTR p3$1[rsp], 0
  00140	74 1e		 je	 SHORT $LN15@do_special

; 1328 :         {
; 1329 :             secs = atof( p3 );

  00142	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p3$1[rsp]
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atof
  0014d	f2 0f 11 44 24
	60		 movsd	 QWORD PTR secs$[rsp], xmm0

; 1330 :             free( p3 );

  00153	48 8b 4c 24 70	 mov	 rcx, QWORD PTR p3$1[rsp]
  00158	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1331 :         }

  0015e	eb 11		 jmp	 SHORT $LN16@do_special
$LN15@do_special:

; 1332 :         else
; 1333 :             secs = atof( p2 );

  00160	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p2$[rsp]
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atof
  0016b	f2 0f 11 44 24
	60		 movsd	 QWORD PTR secs$[rsp], xmm0
$LN16@do_special:

; 1334 :     }

  00171	eb 11		 jmp	 SHORT $LN14@do_special
$LN13@do_special:

; 1335 :     else
; 1336 :         secs = atof( p2 );

  00173	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p2$[rsp]
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atof
  0017e	f2 0f 11 44 24
	60		 movsd	 QWORD PTR secs$[rsp], xmm0
$LN14@do_special:

; 1337 : 
; 1338 :     if (secs < MIN_PAUSE_TIMEOUT || secs > MAX_PAUSE_TIMEOUT)

  00184	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@3f50624dd2f1a9fc
  0018c	66 0f 2f 44 24
	60		 comisd	 xmm0, QWORD PTR secs$[rsp]
  00192	77 14		 ja	 SHORT $LN18@do_special
  00194	f2 0f 10 44 24
	60		 movsd	 xmm0, QWORD PTR secs$[rsp]
  0019a	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@408f380000000000
  001a2	0f 86 e8 00 00
	00		 jbe	 $LN17@do_special
$LN18@do_special:

; 1339 :     {
; 1340 :         if (fname)

  001a8	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  001b1	74 70		 je	 SHORT $LN19@do_special

; 1341 :             // "Config file[%d] %s: error processing statement: %s"
; 1342 :             WRMSG( HHC01441, "E", *inc_stmtnum, fname, "syntax error; statement ignored" );

  001b3	b9 01 00 00 00	 mov	 ecx, 1
  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189806
  001c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001ca	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001d2	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001d7	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR inc_stmtnum$[rsp]
  001df	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001e1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189807
  001ec	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189808
  001f8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001fd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00202	41 b9 03 00 00
	00		 mov	 r9d, 3
  00208	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189809
  0020f	ba 3e 05 00 00	 mov	 edx, 1342		; 0000053eH
  00214	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189810
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00221	eb 63		 jmp	 SHORT $LN20@do_special
$LN19@do_special:

; 1343 :         else
; 1344 :             // "Script %d: syntax error; statement ignored: %s"
; 1345 :             WRMSG( HHC02261, "E", pCtl->scr_id, p );

  00223	b9 01 00 00 00	 mov	 ecx, 1
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0022e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  00236	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0023b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00243	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00246	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0024a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189811
  00251	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189812
  0025d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00262	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00267	41 b9 03 00 00
	00		 mov	 r9d, 3
  0026d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189813
  00274	ba 41 05 00 00	 mov	 edx, 1345		; 00000541H
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189814
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN20@do_special:

; 1346 :         return TRUE;

  00286	b8 01 00 00 00	 mov	 eax, 1
  0028b	e9 45 03 00 00	 jmp	 $LN1@do_special
$LN17@do_special:

; 1347 :     }
; 1348 : 
; 1349 :     /* Apply adjustment factor */
; 1350 :     if (sysblk.scrfactor)

  00290	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00297	f2 0f 10 80 20
	11 00 00	 movsd	 xmm0, QWORD PTR [rax+4384]
  0029f	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@0000000000000000
  002a7	7a 02		 jp	 SHORT $LN31@do_special
  002a9	74 1b		 je	 SHORT $LN21@do_special
$LN31@do_special:

; 1351 :         secs *= sysblk.scrfactor;

  002ab	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002b2	f2 0f 10 44 24
	60		 movsd	 xmm0, QWORD PTR secs$[rsp]
  002b8	f2 0f 59 80 20
	11 00 00	 mulsd	 xmm0, QWORD PTR [rax+4384]
  002c0	f2 0f 11 44 24
	60		 movsd	 QWORD PTR secs$[rsp], xmm0
$LN21@do_special:

; 1352 : 
; 1353 :     /* Convert floating point seconds to other subsecond work values */
; 1354 :     msecs = (U32) (secs * 1000.0);

  002c6	f2 0f 10 44 24
	60		 movsd	 xmm0, QWORD PTR secs$[rsp]
  002cc	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@408f400000000000
  002d4	f2 48 0f 2c c0	 cvttsd2si rax, xmm0
  002d9	89 44 24 58	 mov	 DWORD PTR msecs$[rsp], eax

; 1355 : 
; 1356 :     if (MLVL( VERBOSE ))

  002dd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e4	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  002ea	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  002ef	85 c0		 test	 eax, eax
  002f1	0f 84 d5 00 00
	00		 je	 $LN22@do_special

; 1357 :     {
; 1358 :         if (fname)

  002f7	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  00300	74 6c		 je	 SHORT $LN23@do_special

; 1359 :             // "Config file[%d] %s: processing paused for %d milliseconds..."
; 1360 :             WRMSG( HHC02318, "I", *inc_stmtnum, fname, msecs );

  00302	b9 01 00 00 00	 mov	 ecx, 1
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0030d	8b 4c 24 58	 mov	 ecx, DWORD PTR msecs$[rsp]
  00311	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00315	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0031d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00322	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR inc_stmtnum$[rsp]
  0032a	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0032c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00330	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189819
  00337	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0033c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189820
  00343	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00348	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0034d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00353	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189821
  0035a	ba 50 05 00 00	 mov	 edx, 1360		; 00000550H
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189822
  00366	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0036c	eb 5e		 jmp	 SHORT $LN24@do_special
$LN23@do_special:

; 1361 :         else
; 1362 :             // "Script %d: processing paused for %d milliseconds..."
; 1363 :             WRMSG( HHC02262, "I", pCtl->scr_id, msecs );

  0036e	b9 01 00 00 00	 mov	 ecx, 1
  00373	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00379	8b 4c 24 58	 mov	 ecx, DWORD PTR msecs$[rsp]
  0037d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00381	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  00389	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  0038c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00390	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189823
  00397	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0039c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189824
  003a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189825
  003ba	ba 53 05 00 00	 mov	 edx, 1363		; 00000553H
  003bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189826
  003c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN24@do_special:
$LN22@do_special:

; 1364 :     }
; 1365 : 
; 1366 :     /* Initialize pause start time */
; 1367 :     gettimeofday( &beg, NULL );

  003cc	33 d2		 xor	 edx, edx
  003ce	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR beg$[rsp]
  003d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 1368 : 
; 1369 :     obtain_lock( &sysblk.scrlock );

  003dc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003e3	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  003e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189827
  003f0	48 8b c8	 mov	 rcx, rax
  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN4@do_special:

; 1370 :     for (;;)
; 1371 :     {
; 1372 :         /* Check for cancelled script */
; 1373 :         if (pCtl && script_abort( pCtl ))

  003f9	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR pCtl$[rsp], 0
  00402	74 38		 je	 SHORT $LN25@do_special
  00404	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0040c	e8 00 00 00 00	 call	 script_abort
  00411	85 c0		 test	 eax, eax
  00413	74 27		 je	 SHORT $LN25@do_special

; 1374 :         {
; 1375 :             release_lock( &sysblk.scrlock );

  00415	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0041c	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  00422	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189829
  00429	48 8b c8	 mov	 rcx, rax
  0042c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1376 :             return TRUE;

  00432	b8 01 00 00 00	 mov	 eax, 1
  00437	e9 99 01 00 00	 jmp	 $LN1@do_special
$LN25@do_special:

; 1377 :         }
; 1378 : 
; 1379 :         /* Calculate how long to continue pausing  */
; 1380 :         gettimeofday( &now, NULL );

  0043c	33 d2		 xor	 edx, edx
  0043e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  00446	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 1381 :         timeval_subtract( &beg, &now, &dur );

  0044c	4c 8d 44 24 78	 lea	 r8, QWORD PTR dur$[rsp]
  00451	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR now$[rsp]
  00459	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR beg$[rsp]
  00461	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timeval_subtract

; 1382 :         elapsed_usecs = (dur.tv_sec * 1000000) + dur.tv_usec;

  00467	69 44 24 78 40
	42 0f 00	 imul	 eax, DWORD PTR dur$[rsp], 1000000 ; 000f4240H
  0046f	03 44 24 7c	 add	 eax, DWORD PTR dur$[rsp+4]
  00473	89 44 24 68	 mov	 DWORD PTR elapsed_usecs$[rsp], eax

; 1383 : 
; 1384 :         /* Is there any time remaining on the clock? */
; 1385 :         if (elapsed_usecs >= (msecs * 1000))

  00477	69 44 24 58 e8
	03 00 00	 imul	 eax, DWORD PTR msecs$[rsp], 1000 ; 000003e8H
  0047f	39 44 24 68	 cmp	 DWORD PTR elapsed_usecs$[rsp], eax
  00483	72 02		 jb	 SHORT $LN26@do_special

; 1386 :             break;

  00485	eb 4d		 jmp	 SHORT $LN5@do_special
$LN26@do_special:

; 1387 : 
; 1388 :         /* Sleep until we're woken or we run out of time */
; 1389 :         usecs = ((msecs * 1000) - elapsed_usecs);

  00487	69 44 24 58 e8
	03 00 00	 imul	 eax, DWORD PTR msecs$[rsp], 1000 ; 000003e8H
  0048f	2b 44 24 68	 sub	 eax, DWORD PTR elapsed_usecs$[rsp]
  00493	89 44 24 6c	 mov	 DWORD PTR usecs$[rsp], eax

; 1390 :         timed_wait_condition_relative_usecs(

  00497	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0049e	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  004a4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004ab	48 81 c1 10 11
	00 00		 add	 rcx, 4368		; 00001110H
  004b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189831
  004b9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  004be	45 33 c9	 xor	 r9d, r9d
  004c1	44 8b 44 24 6c	 mov	 r8d, DWORD PTR usecs$[rsp]
  004c6	48 8b d0	 mov	 rdx, rax
  004c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl

; 1391 :             &sysblk.scrcond, &sysblk.scrlock, usecs, NULL );
; 1392 :     }

  004cf	e9 25 ff ff ff	 jmp	 $LN4@do_special
$LN5@do_special:

; 1393 :     release_lock( &sysblk.scrlock );

  004d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004db	48 05 08 11 00
	00		 add	 rax, 4360		; 00001108H
  004e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189832
  004e8	48 8b c8	 mov	 rcx, rax
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1394 : 
; 1395 :     if (MLVL( VERBOSE ))

  004f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  004f8	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  004fe	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00503	85 c0		 test	 eax, eax
  00505	0f 84 c5 00 00
	00		 je	 $LN27@do_special

; 1396 :     {
; 1397 :         if (fname)

  0050b	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  00514	74 64		 je	 SHORT $LN28@do_special

; 1398 :             // "Config file[%d] %s: processing resumed..."
; 1399 :             WRMSG( HHC02319, "I", *inc_stmtnum, fname );

  00516	b9 01 00 00 00	 mov	 ecx, 1
  0051b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00521	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00529	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0052e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR inc_stmtnum$[rsp]
  00536	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00538	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0053c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189836
  00543	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00548	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189837
  0054f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00554	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00559	41 b9 03 00 00
	00		 mov	 r9d, 3
  0055f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189838
  00566	ba 77 05 00 00	 mov	 edx, 1399		; 00000577H
  0056b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189839
  00572	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00578	eb 56		 jmp	 SHORT $LN29@do_special
$LN28@do_special:

; 1400 :         else
; 1401 :             // "Script %d: processing resumed..."
; 1402 :             WRMSG( HHC02263, "I", pCtl->scr_id );

  0057a	b9 01 00 00 00	 mov	 ecx, 1
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00585	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR pCtl$[rsp]
  0058d	8b 49 14	 mov	 ecx, DWORD PTR [rcx+20]
  00590	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00594	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189840
  0059b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189841
  005a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  005b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189842
  005be	ba 7a 05 00 00	 mov	 edx, 1402		; 0000057aH
  005c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189843
  005ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN29@do_special:
$LN27@do_special:

; 1403 :     }
; 1404 : 
; 1405 :     return TRUE;

  005d0	b8 01 00 00 00	 mov	 eax, 1
$LN1@do_special:

; 1406 : }

  005d5	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  005dc	c3		 ret	 0
do_special ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\script.c
_TEXT	SEGMENT
inc_level$ = 96
errorcount$ = 100
c$ = 104
i$ = 108
shell_flg$ = 112
i$1 = 116
addargc$ = 120
attargc$2 = 124
scount$ = 128
rc$ = 132
attargv$3 = 136
inc_ignore_errors$ = 144
rc$4 = 148
tv77 = 152
tv155 = 160
tv672 = 168
tv230 = 176
tv673 = 184
tv251 = 192
tv276 = 200
tv280 = 208
tv293 = 216
tv297 = 224
tv675 = 232
tv389 = 240
tv442 = 248
tv676 = 256
tv446 = 264
tv577 = 272
tv677 = 280
tv581 = 288
tv678 = 296
tv618 = 304
rcmd$5 = 312
exec_cpuserial$6 = 328
exec_cpumodel$7 = 344
exec_mainsize$8 = 360
exec_xpndsize$9 = 376
exec_cnslport$10 = 392
exec_numcpu$11 = 408
exec_loadparm$12 = 424
inc_fp$ = 448
addargv$ = 512
fname$ = 8704
pathname$ = 8976
addcmdline$13 = 9248
attcmdline$14 = 42016
buf$ = 74784
__$ArrayPad$ = 107552
cfg_name$ = 107584
process_config PROC

; 180  : {

$LN46:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 38 a4 01 00	 mov	 eax, 107576		; 0001a438H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 20
	a4 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 181  : char buf[ MAX_CFG_LINELEN ];            /* Config statement buffer   */
; 182  : int  addargc;                           /* Number of additional args */
; 183  : char *addargv[MAX_ARGS];                /* Additional argument array */
; 184  : 
; 185  : #define MAX_INC_LEVEL 8                 /* Maximum nest level        */
; 186  : static int  inc_stmtnum[MAX_INC_LEVEL]; /* statement number          */
; 187  : 
; 188  : int     rc;                             /* Return code               */
; 189  : int     i;                              /* Array subscript           */
; 190  : int     scount;                         /* Statement counter         */
; 191  : int     inc_level;                      /* Current nesting level     */
; 192  : FILE   *inc_fp[MAX_INC_LEVEL];          /* Configuration file pointer*/
; 193  : BYTE    c;                              /* Work area for sscanf      */
; 194  : 
; 195  : int     inc_ignore_errors = 0;          /* 1==ignore include errors  */

  00024	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR inc_ignore_errors$[rsp], 0

; 196  : char    pathname[MAX_PATH];             /* file path in host format  */
; 197  : 
; 198  : char    fname[MAX_PATH];                /* normalized filename       */
; 199  : int     errorcount = 0;

  0002f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR errorcount$[rsp], 0

; 200  : 
; 201  : #if defined(HAVE_OBJECT_REXX) || defined(HAVE_REGINA_REXX)
; 202  : int     shell_flg = FALSE;              /* indicate it is has a shell

  00037	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR shell_flg$[rsp], 0

; 203  :                                            path specified            */
; 204  : #endif
; 205  : 
; 206  :     /* Open the base configuration file */
; 207  :     hostpath(fname, cfg_name, sizeof(fname));

  0003f	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00045	48 8b 94 24 40
	a4 01 00	 mov	 rdx, QWORD PTR cfg_name$[rsp]
  0004d	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 208  : 
; 209  :     inc_level = 0;

  0005b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR inc_level$[rsp], 0

; 210  : #if defined(_MSVC_)
; 211  :     fopen_s( &inc_fp[inc_level], fname, "r");

  00063	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  00068	48 8d 84 c4 c0
	01 00 00	 lea	 rax, QWORD PTR inc_fp$[rsp+rax*8]
  00070	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189018
  00077	48 8d 94 24 00
	22 00 00	 lea	 rdx, QWORD PTR fname$[rsp]
  0007f	48 8b c8	 mov	 rcx, rax
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen_s

; 212  : #else
; 213  :     inc_fp[inc_level] = fopen (fname, "r");
; 214  : #endif
; 215  :     if (inc_fp[inc_level] == NULL)

  00088	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  0008d	48 83 bc c4 c0
	01 00 00 00	 cmp	 QWORD PTR inc_fp$[rsp+rax*8], 0
  00096	0f 85 c8 00 00
	00		 jne	 $LN13@process_co

; 216  :     {
; 217  :         WRMSG(HHC01432, "S", 1, fname, "fopen()", strerror(errno));

  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a2	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000aa	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv77[rsp], rax
  000b2	b9 01 00 00 00	 mov	 ecx, 1
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000bd	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv77[rsp]
  000c5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189020
  000d1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000d6	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  000de	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000e3	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR [rsp+56], 1
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189021
  000f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189022
  000fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00103	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00108	41 b9 03 00 00
	00		 mov	 r9d, 3
  0010e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189023
  00115	ba d9 00 00 00	 mov	 edx, 217		; 000000d9H
  0011a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189024
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 218  :         fflush(stderr);

  00127	b9 02 00 00 00	 mov	 ecx, 2
  0012c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00132	48 8b c8	 mov	 rcx, rax
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 219  :         fflush(stdout);

  0013b	b9 01 00 00 00	 mov	 ecx, 1
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00146	48 8b c8	 mov	 rcx, rax
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 220  :         usleep(100000);

  0014f	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 221  :         return -1;

  0015a	b8 ff ff ff ff	 mov	 eax, -1
  0015f	e9 b3 0e 00 00	 jmp	 $LN1@process_co
$LN13@process_co:

; 222  :     }
; 223  : 
; 224  :     inc_stmtnum[inc_level] = 0;

  00164	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00170	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0

; 225  : 
; 226  :     /*****************************************************************/
; 227  :     /* Parse configuration file system parameter statements...       */
; 228  :     /*****************************************************************/
; 229  : 
; 230  :     for (scount = 0; ; scount++)

  00177	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR scount$[rsp], 0
  00182	eb 10		 jmp	 SHORT $LN4@process_co
$LN2@process_co:
  00184	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR scount$[rsp]
  0018b	ff c0		 inc	 eax
  0018d	89 84 24 80 00
	00 00		 mov	 DWORD PTR scount$[rsp], eax
$LN4@process_co:
$LN5@process_co:

; 231  :     {
; 232  :         /* Read next record from the configuration file */
; 233  :         while (inc_level >= 0 && read_config (fname, inc_fp[inc_level], buf, sizeof(buf), &inc_stmtnum[inc_level]))

  00194	83 7c 24 60 00	 cmp	 DWORD PTR inc_level$[rsp], 0
  00199	7c 70		 jl	 SHORT $LN6@process_co
  0019b	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  001a7	48 8d 04 81	 lea	 rax, QWORD PTR [rcx+rax*4]
  001ab	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR inc_level$[rsp]
  001b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b5	41 b9 00 80 00
	00		 mov	 r9d, 32768		; 00008000H
  001bb	4c 8d 84 24 20
	24 01 00	 lea	 r8, QWORD PTR buf$[rsp]
  001c3	48 8b 94 cc c0
	01 00 00	 mov	 rdx, QWORD PTR inc_fp$[rsp+rcx*8]
  001cb	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  001d3	e8 00 00 00 00	 call	 read_config
  001d8	85 c0		 test	 eax, eax
  001da	74 2f		 je	 SHORT $LN6@process_co

; 234  :         {
; 235  :             fclose (inc_fp[inc_level--]);

  001dc	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  001e1	48 8b 84 c4 c0
	01 00 00	 mov	 rax, QWORD PTR inc_fp$[rsp+rax*8]
  001e9	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  001f1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv155[rsp]
  001f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose
  001ff	8b 44 24 60	 mov	 eax, DWORD PTR inc_level$[rsp]
  00203	ff c8		 dec	 eax
  00205	89 44 24 60	 mov	 DWORD PTR inc_level$[rsp], eax

; 236  :         }

  00209	eb 89		 jmp	 SHORT $LN5@process_co
$LN6@process_co:

; 237  :         if (inc_level < 0)

  0020b	83 7c 24 60 00	 cmp	 DWORD PTR inc_level$[rsp], 0
  00210	7d 07		 jge	 SHORT $LN14@process_co

; 238  :         {
; 239  :             return 0;

  00212	33 c0		 xor	 eax, eax
  00214	e9 fe 0d 00 00	 jmp	 $LN1@process_co
$LN14@process_co:

; 240  :         }
; 241  : 
; 242  :         /* Parse the statement just read */
; 243  :         parse_args (buf, MAX_ARGS, addargv, &addargc);

  00219	4c 8d 4c 24 78	 lea	 r9, QWORD PTR addargc$[rsp]
  0021e	4c 8d 84 24 00
	02 00 00	 lea	 r8, QWORD PTR addargv$[rsp]
  00226	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0022b	48 8d 8c 24 20
	24 01 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00233	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_parse_args

; 244  : 
; 245  : #if defined(HAVE_OBJECT_REXX) || defined(HAVE_REGINA_REXX)
; 246  :         // Test for REXX script. If first card starts with "/*" or
; 247  :         // first card has shell path specification "#!" and second card
; 248  :         // "/*", then we will process as a REXX script.
; 249  : 
; 250  :         if ( inc_level == 0 && inc_stmtnum[0] < 3 )

  00239	83 7c 24 60 00	 cmp	 DWORD PTR inc_level$[rsp], 0
  0023e	0f 85 1f 01 00
	00		 jne	 $LN15@process_co
  00244	b8 04 00 00 00	 mov	 eax, 4
  00249	48 6b c0 00	 imul	 rax, rax, 0
  0024d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00254	83 3c 01 03	 cmp	 DWORD PTR [rcx+rax], 3
  00258	0f 8d 05 01 00
	00		 jge	 $LN15@process_co

; 251  :         {
; 252  :             /* Ignore #! (shell path) card if found */
; 253  :             if ( shell_flg == FALSE   &&
; 254  :                  inc_stmtnum[0] == 1 &&

  0025e	83 7c 24 70 00	 cmp	 DWORD PTR shell_flg$[rsp], 0
  00263	75 46		 jne	 SHORT $LN16@process_co
  00265	b8 04 00 00 00	 mov	 eax, 4
  0026a	48 6b c0 00	 imul	 rax, rax, 0
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00275	83 3c 01 01	 cmp	 DWORD PTR [rcx+rax], 1
  00279	75 30		 jne	 SHORT $LN16@process_co
  0027b	b8 08 00 00 00	 mov	 eax, 8
  00280	48 6b c0 00	 imul	 rax, rax, 0
  00284	41 b8 02 00 00
	00		 mov	 r8d, 2
  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189028
  00291	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  0029f	85 c0		 test	 eax, eax
  002a1	75 08		 jne	 SHORT $LN16@process_co

; 255  :                  !strncmp( addargv[0], "#!", 2 ) )
; 256  :             {
; 257  :                 shell_flg = TRUE;

  002a3	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR shell_flg$[rsp], 1
$LN16@process_co:

; 258  :             }
; 259  :             /* Check for REXX exec being executed */
; 260  :             if ( !strncmp( addargv[0], "/*", 2 ) &&

  002ab	b8 08 00 00 00	 mov	 eax, 8
  002b0	48 6b c0 00	 imul	 rax, rax, 0
  002b4	41 b8 02 00 00
	00		 mov	 r8d, 2
  002ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189030
  002c1	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  002c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  002cf	85 c0		 test	 eax, eax
  002d1	0f 85 8c 00 00
	00		 jne	 $LN17@process_co
  002d7	83 7c 24 70 00	 cmp	 DWORD PTR shell_flg$[rsp], 0
  002dc	75 16		 jne	 SHORT $LN19@process_co
  002de	b8 04 00 00 00	 mov	 eax, 4
  002e3	48 6b c0 00	 imul	 rax, rax, 0
  002e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  002ee	83 3c 01 01	 cmp	 DWORD PTR [rcx+rax], 1
  002f2	74 1d		 je	 SHORT $LN18@process_co
$LN19@process_co:
  002f4	83 7c 24 70 01	 cmp	 DWORD PTR shell_flg$[rsp], 1
  002f9	75 68		 jne	 SHORT $LN17@process_co
  002fb	b8 04 00 00 00	 mov	 eax, 4
  00300	48 6b c0 00	 imul	 rax, rax, 0
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  0030b	83 3c 01 02	 cmp	 DWORD PTR [rcx+rax], 2
  0030f	75 52		 jne	 SHORT $LN17@process_co
$LN18@process_co:

; 261  :                  ( ( shell_flg == FALSE && inc_stmtnum[0] == 1 ) ||
; 262  :                    ( shell_flg == TRUE  && inc_stmtnum[0] == 2 )
; 263  :                  )
; 264  :                )
; 265  :             {
; 266  :                 char *rcmd[2] = { "exec", NULL };

  00311	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189034
  00318	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR rcmd$5[rsp], rax
  00320	48 c7 84 24 40
	01 00 00 00 00
	00 00		 mov	 QWORD PTR rcmd$5[rsp+8], 0

; 267  :                 rcmd[1] = fname;

  0032c	b8 08 00 00 00	 mov	 eax, 8
  00331	48 6b c0 01	 imul	 rax, rax, 1
  00335	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  0033d	48 89 8c 04 38
	01 00 00	 mov	 QWORD PTR rcmd$5[rsp+rax], rcx

; 268  :                 errorcount = exec_cmd( 2, rcmd, NULL );

  00345	45 33 c0	 xor	 r8d, r8d
  00348	48 8d 94 24 38
	01 00 00	 lea	 rdx, QWORD PTR rcmd$5[rsp]
  00350	b9 02 00 00 00	 mov	 ecx, 2
  00355	e8 00 00 00 00	 call	 exec_cmd
  0035a	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax

; 269  :                 goto rexx_done;

  0035e	e9 8f 0c 00 00	 jmp	 $rexx_done$47
$LN17@process_co:
$LN15@process_co:

; 270  :             }
; 271  :         }
; 272  : #endif /* defined(HAVE_OBJECT_REXX) || defined(HAVE_REGINA_REXX)   */
; 273  : 
; 274  :         if  (strcasecmp (addargv[0], "ignore") == 0)

  00363	b8 08 00 00 00	 mov	 eax, 8
  00368	48 6b c0 00	 imul	 rax, rax, 0
  0036c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189036
  00373	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  0037b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00381	85 c0		 test	 eax, eax
  00383	0f 85 86 00 00
	00		 jne	 $LN20@process_co

; 275  :         {
; 276  :             if  (strcasecmp (addargv[1], "include_errors") == 0)

  00389	b8 08 00 00 00	 mov	 eax, 8
  0038e	48 6b c0 01	 imul	 rax, rax, 1
  00392	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189038
  00399	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  003a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003a7	85 c0		 test	 eax, eax
  003a9	75 5f		 jne	 SHORT $LN21@process_co

; 277  :             {
; 278  :                 WRMSG(HHC01435, "I", fname);

  003ab	b9 01 00 00 00	 mov	 ecx, 1
  003b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b6	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  003be	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189039
  003ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189040
  003d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189041
  003ed	ba 16 01 00 00	 mov	 edx, 278		; 00000116H
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189042
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 279  :                 inc_ignore_errors = 1 ;

  003ff	c7 84 24 90 00
	00 00 01 00 00
	00		 mov	 DWORD PTR inc_ignore_errors$[rsp], 1
$LN21@process_co:

; 280  :             }
; 281  : 
; 282  :             continue ;

  0040a	e9 75 fd ff ff	 jmp	 $LN2@process_co
$LN20@process_co:

; 283  :         }
; 284  : 
; 285  :         /* Check for include statement */
; 286  :         if (strcasecmp (addargv[0], "include") == 0)

  0040f	b8 08 00 00 00	 mov	 eax, 8
  00414	48 6b c0 00	 imul	 rax, rax, 0
  00418	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189044
  0041f	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  00427	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0042d	85 c0		 test	 eax, eax
  0042f	0f 85 24 03 00
	00		 jne	 $LN22@process_co

; 287  :         {
; 288  :             if (++inc_level >= MAX_INC_LEVEL)

  00435	8b 44 24 60	 mov	 eax, DWORD PTR inc_level$[rsp]
  00439	ff c0		 inc	 eax
  0043b	89 44 24 60	 mov	 DWORD PTR inc_level$[rsp], eax
  0043f	83 7c 24 60 08	 cmp	 DWORD PTR inc_level$[rsp], 8
  00444	0f 8c 9c 00 00
	00		 jl	 $LN23@process_co

; 289  :             {
; 290  :                 WRMSG(HHC01436, "S", inc_stmtnum[inc_level-1], fname, MAX_INC_LEVEL);

  0044a	8b 44 24 60	 mov	 eax, DWORD PTR inc_level$[rsp]
  0044e	ff c8		 dec	 eax
  00450	48 98		 cdqe
  00452	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv230[rsp], rax
  0045a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00461	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv672[rsp], rcx
  00469	b9 01 00 00 00	 mov	 ecx, 1
  0046e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00474	c7 44 24 48 08
	00 00 00	 mov	 DWORD PTR [rsp+72], 8
  0047c	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00484	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00489	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR tv672[rsp]
  00491	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv230[rsp]
  00499	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  0049c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189046
  004a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189047
  004b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  004c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189048
  004ca	ba 22 01 00 00	 mov	 edx, 290		; 00000122H
  004cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189049
  004d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 291  :                 return -1;

  004dc	b8 ff ff ff ff	 mov	 eax, -1
  004e1	e9 31 0b 00 00	 jmp	 $LN1@process_co
$LN23@process_co:

; 292  :             }
; 293  : 
; 294  :             hostpath(pathname, addargv[1], sizeof(pathname));

  004e6	b8 08 00 00 00	 mov	 eax, 8
  004eb	48 6b c0 01	 imul	 rax, rax, 1
  004ef	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  004f5	48 8b 94 04 00
	02 00 00	 mov	 rdx, QWORD PTR addargv$[rsp+rax]
  004fd	48 8d 8c 24 10
	23 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00505	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 295  :             WRMSG(HHC01437, "I", inc_stmtnum[inc_level-1], fname, pathname);

  0050b	8b 44 24 60	 mov	 eax, DWORD PTR inc_level$[rsp]
  0050f	ff c8		 dec	 eax
  00511	48 98		 cdqe
  00513	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv251[rsp], rax
  0051b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00522	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR tv673[rsp], rcx
  0052a	b9 01 00 00 00	 mov	 ecx, 1
  0052f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00535	48 8d 8c 24 10
	23 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0053d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00542	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  0054a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0054f	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR tv673[rsp]
  00557	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv251[rsp]
  0055f	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00562	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189050
  0056d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00572	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189051
  00579	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0057e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00583	41 b9 03 00 00
	00		 mov	 r9d, 3
  00589	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189052
  00590	ba 27 01 00 00	 mov	 edx, 295		; 00000127H
  00595	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189053
  0059c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 296  : #if defined(_MSVC_)
; 297  :             fopen_s ( &inc_fp[inc_level], pathname, "r");

  005a2	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  005a7	48 8d 84 c4 c0
	01 00 00	 lea	 rax, QWORD PTR inc_fp$[rsp+rax*8]
  005af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189054
  005b6	48 8d 94 24 10
	23 00 00	 lea	 rdx, QWORD PTR pathname$[rsp]
  005be	48 8b c8	 mov	 rcx, rax
  005c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen_s

; 298  : #else
; 299  :             inc_fp[inc_level] = fopen (pathname, "r");
; 300  : #endif
; 301  :             if (inc_fp[inc_level] == NULL)

  005c7	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  005cc	48 83 bc c4 c0
	01 00 00 00	 cmp	 QWORD PTR inc_fp$[rsp+rax*8], 0
  005d5	0f 85 66 01 00
	00		 jne	 $LN24@process_co

; 302  :             {
; 303  :                 inc_level--;

  005db	8b 44 24 60	 mov	 eax, DWORD PTR inc_level$[rsp]
  005df	ff c8		 dec	 eax
  005e1	89 44 24 60	 mov	 DWORD PTR inc_level$[rsp], eax

; 304  :                 if ( inc_ignore_errors == 1 )

  005e5	83 bc 24 90 00
	00 00 01	 cmp	 DWORD PTR inc_ignore_errors$[rsp], 1
  005ed	0f 85 a7 00 00
	00		 jne	 $LN25@process_co

; 305  :                 {
; 306  :                     WRMSG(HHC01438, "W", fname, addargv[1], strerror(errno));

  005f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  005f9	8b 08		 mov	 ecx, DWORD PTR [rax]
  005fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00601	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv276[rsp], rax
  00609	b9 08 00 00 00	 mov	 ecx, 8
  0060e	48 6b c9 01	 imul	 rcx, rcx, 1
  00612	48 89 8c 24 d0
	00 00 00	 mov	 QWORD PTR tv280[rsp], rcx
  0061a	b9 01 00 00 00	 mov	 ecx, 1
  0061f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00625	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv276[rsp]
  0062d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00632	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv280[rsp]
  0063a	48 8b 8c 0c 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rcx]
  00642	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00647	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  0064f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00654	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189058
  0065b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00660	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189059
  00667	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0066c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00671	41 b9 03 00 00
	00		 mov	 r9d, 3
  00677	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189060
  0067e	ba 32 01 00 00	 mov	 edx, 306		; 00000132H
  00683	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189061
  0068a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 307  :                     continue ;

  00690	e9 ef fa ff ff	 jmp	 $LN2@process_co

; 308  :                 }

  00695	e9 a7 00 00 00	 jmp	 $LN26@process_co
$LN25@process_co:

; 309  :                 else
; 310  :                 {
; 311  :                     WRMSG(HHC01439, "S", fname, addargv[1], strerror(errno));

  0069a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006a0	8b 08		 mov	 ecx, DWORD PTR [rax]
  006a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  006a8	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv293[rsp], rax
  006b0	b9 08 00 00 00	 mov	 ecx, 8
  006b5	48 6b c9 01	 imul	 rcx, rcx, 1
  006b9	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv297[rsp], rcx
  006c1	b9 01 00 00 00	 mov	 ecx, 1
  006c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006cc	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv293[rsp]
  006d4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006d9	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv297[rsp]
  006e1	48 8b 8c 0c 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rcx]
  006e9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006ee	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  006f6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189062
  00702	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00707	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189063
  0070e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00713	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00718	41 b9 03 00 00
	00		 mov	 r9d, 3
  0071e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189064
  00725	ba 37 01 00 00	 mov	 edx, 311		; 00000137H
  0072a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189065
  00731	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 312  :                     return -1;

  00737	b8 ff ff ff ff	 mov	 eax, -1
  0073c	e9 d6 08 00 00	 jmp	 $LN1@process_co
$LN26@process_co:
$LN24@process_co:

; 313  :                 }
; 314  :             }
; 315  :             inc_stmtnum[inc_level] = 0;

  00741	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  00746	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  0074d	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0

; 316  :             continue;

  00754	e9 2b fa ff ff	 jmp	 $LN2@process_co
$LN22@process_co:

; 317  :         }
; 318  : 
; 319  :         if ( ( strlen(addargv[0]) <= 4 &&
; 320  :                sscanf(addargv[0], "%"SCNx32"%c", &rc, &c) == 1 )
; 321  :              ||
; 322  :         /* Also, if addargv[0] contains ':' (added by Harold Grovesteen jan2008)  */
; 323  :         /* Added because device statements may now contain channel set or LCSS id */
; 324  :              strchr( addargv[0], ':' )
; 325  :         /* ISW */
; 326  :         /* Also, if addargv[0] contains '-', ',' or '.' */
; 327  :         /* Added because device statements may now be a compound device number specification */
; 328  :              ||
; 329  :              strchr( addargv[0],'-' )
; 330  :              ||
; 331  :              strchr( addargv[0],'.' )
; 332  :              ||

  00759	b8 08 00 00 00	 mov	 eax, 8
  0075e	48 6b c0 00	 imul	 rax, rax, 0
  00762	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  0076a	e8 00 00 00 00	 call	 strlen
  0076f	48 83 f8 04	 cmp	 rax, 4
  00773	77 33		 ja	 SHORT $LN29@process_co
  00775	b8 08 00 00 00	 mov	 eax, 8
  0077a	48 6b c0 00	 imul	 rax, rax, 0
  0077e	4c 8d 4c 24 68	 lea	 r9, QWORD PTR c$[rsp]
  00783	4c 8d 84 24 84
	00 00 00	 lea	 r8, QWORD PTR rc$[rsp]
  0078b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189069
  00792	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  0079a	e8 00 00 00 00	 call	 sscanf
  0079f	83 f8 01	 cmp	 eax, 1
  007a2	0f 84 84 00 00
	00		 je	 $LN28@process_co
$LN29@process_co:
  007a8	b8 08 00 00 00	 mov	 eax, 8
  007ad	48 6b c0 00	 imul	 rax, rax, 0
  007b1	ba 3a 00 00 00	 mov	 edx, 58			; 0000003aH
  007b6	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  007be	e8 00 00 00 00	 call	 strchr
  007c3	48 85 c0	 test	 rax, rax
  007c6	75 64		 jne	 SHORT $LN28@process_co
  007c8	b8 08 00 00 00	 mov	 eax, 8
  007cd	48 6b c0 00	 imul	 rax, rax, 0
  007d1	ba 2d 00 00 00	 mov	 edx, 45			; 0000002dH
  007d6	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  007de	e8 00 00 00 00	 call	 strchr
  007e3	48 85 c0	 test	 rax, rax
  007e6	75 44		 jne	 SHORT $LN28@process_co
  007e8	b8 08 00 00 00	 mov	 eax, 8
  007ed	48 6b c0 00	 imul	 rax, rax, 0
  007f1	ba 2e 00 00 00	 mov	 edx, 46			; 0000002eH
  007f6	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  007fe	e8 00 00 00 00	 call	 strchr
  00803	48 85 c0	 test	 rax, rax
  00806	75 24		 jne	 SHORT $LN28@process_co
  00808	b8 08 00 00 00	 mov	 eax, 8
  0080d	48 6b c0 00	 imul	 rax, rax, 0
  00811	ba 2c 00 00 00	 mov	 edx, 44			; 0000002cH
  00816	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  0081e	e8 00 00 00 00	 call	 strchr
  00823	48 85 c0	 test	 rax, rax
  00826	0f 84 ab 02 00
	00		 je	 $LN27@process_co
$LN28@process_co:

; 333  :              strchr( addargv[0],',' )
; 334  :            ) /* end if */
; 335  :         {
; 336  : #define MAX_CMD_LEN 32768
; 337  :             int   attargc;
; 338  :             char **attargv;
; 339  :             char  attcmdline[MAX_CMD_LEN];
; 340  : 
; 341  :             if ( addargv[0] == NULL || addargv[1] == NULL )

  0082c	b8 08 00 00 00	 mov	 eax, 8
  00831	48 6b c0 00	 imul	 rax, rax, 0
  00835	48 83 bc 04 00
	02 00 00 00	 cmp	 QWORD PTR addargv$[rsp+rax], 0
  0083e	74 18		 je	 SHORT $LN31@process_co
  00840	b8 08 00 00 00	 mov	 eax, 8
  00845	48 6b c0 01	 imul	 rax, rax, 1
  00849	48 83 bc 04 00
	02 00 00 00	 cmp	 QWORD PTR addargv$[rsp+rax], 0
  00852	0f 85 91 00 00
	00		 jne	 $LN30@process_co
$LN31@process_co:

; 342  :             {
; 343  :                 WRMSG(HHC01448, "S", inc_stmtnum[inc_level], fname);

  00858	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  0085d	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv389[rsp], rax
  00865	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  0086c	48 89 8c 24 e8
	00 00 00	 mov	 QWORD PTR tv675[rsp], rcx
  00874	b9 01 00 00 00	 mov	 ecx, 1
  00879	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0087f	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00887	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0088c	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR tv675[rsp]
  00894	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv389[rsp]
  0089c	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  0089f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  008a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189072
  008aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189073
  008b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  008c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189074
  008cd	ba 57 01 00 00	 mov	 edx, 343		; 00000157H
  008d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189075
  008d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 344  :                 return -1;

  008df	b8 ff ff ff ff	 mov	 eax, -1
  008e4	e9 2e 07 00 00	 jmp	 $LN1@process_co
$LN30@process_co:

; 345  :             }
; 346  : 
; 347  :             /* Build attach command to attach device(s) */
; 348  :             attargc = addargc + 1;

  008e9	8b 44 24 78	 mov	 eax, DWORD PTR addargc$[rsp]
  008ed	ff c0		 inc	 eax
  008ef	89 44 24 7c	 mov	 DWORD PTR attargc$2[rsp], eax

; 349  :             attargv = malloc( attargc * sizeof(char *) );

  008f3	48 63 44 24 7c	 movsxd	 rax, DWORD PTR attargc$2[rsp]
  008f8	48 c1 e0 03	 shl	 rax, 3
  008fc	48 8b c8	 mov	 rcx, rax
  008ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00905	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR attargv$3[rsp], rax

; 350  : 
; 351  :             attargv[0] = "attach";

  0090d	b8 08 00 00 00	 mov	 eax, 8
  00912	48 6b c0 00	 imul	 rax, rax, 0
  00916	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR attargv$3[rsp]
  0091e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189076
  00925	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx

; 352  :             STRLCPY( attcmdline, attargv[0] );

  00929	b8 08 00 00 00	 mov	 eax, 8
  0092e	48 6b c0 00	 imul	 rax, rax, 0
  00932	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00938	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR attargv$3[rsp]
  00940	48 8b 14 01	 mov	 rdx, QWORD PTR [rcx+rax]
  00944	48 8d 8c 24 20
	a4 00 00	 lea	 rcx, QWORD PTR attcmdline$14[rsp]
  0094c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 353  :             for ( i = 1; i < attargc; i++ )

  00952	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  0095a	eb 0a		 jmp	 SHORT $LN9@process_co
$LN7@process_co:
  0095c	8b 44 24 6c	 mov	 eax, DWORD PTR i$[rsp]
  00960	ff c0		 inc	 eax
  00962	89 44 24 6c	 mov	 DWORD PTR i$[rsp], eax
$LN9@process_co:
  00966	8b 44 24 7c	 mov	 eax, DWORD PTR attargc$2[rsp]
  0096a	39 44 24 6c	 cmp	 DWORD PTR i$[rsp], eax
  0096e	7d 63		 jge	 SHORT $LN8@process_co

; 354  :             {
; 355  :                 attargv[i] = addargv[i - 1];

  00970	8b 44 24 6c	 mov	 eax, DWORD PTR i$[rsp]
  00974	ff c8		 dec	 eax
  00976	48 98		 cdqe
  00978	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR i$[rsp]
  0097d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR attargv$3[rsp]
  00985	48 8b 84 c4 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax*8]
  0098d	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 356  :                 STRLCAT( attcmdline, " " );

  00991	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00997	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189077
  0099e	48 8d 8c 24 20
	a4 00 00	 lea	 rcx, QWORD PTR attcmdline$14[rsp]
  009a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 357  :                 STRLCAT( attcmdline, attargv[i] );

  009ac	48 63 44 24 6c	 movsxd	 rax, DWORD PTR i$[rsp]
  009b1	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  009b7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR attargv$3[rsp]
  009bf	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  009c3	48 8d 8c 24 20
	a4 00 00	 lea	 rcx, QWORD PTR attcmdline$14[rsp]
  009cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 358  :             }

  009d1	eb 89		 jmp	 SHORT $LN7@process_co
$LN8@process_co:

; 359  : 
; 360  :             rc = CallHercCmd( attargc, attargv, attcmdline );

  009d3	4c 8d 84 24 20
	a4 00 00	 lea	 r8, QWORD PTR attcmdline$14[rsp]
  009db	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR attargv$3[rsp]
  009e3	8b 4c 24 7c	 mov	 ecx, DWORD PTR attargc$2[rsp]
  009e7	e8 00 00 00 00	 call	 CallHercCmd
  009ec	89 84 24 84 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 361  : 
; 362  :             free( attargv );

  009f3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR attargv$3[rsp]
  009fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 363  : 
; 364  :             if ( rc == -2 )

  00a01	83 bc 24 84 00
	00 00 fe	 cmp	 DWORD PTR rc$[rsp], -2
  00a09	0f 85 c3 00 00
	00		 jne	 $LN32@process_co

; 365  :             {
; 366  :                 WRMSG(HHC01443, "S", inc_stmtnum[inc_level], fname, addargv[0], "device number specification");

  00a0f	b8 08 00 00 00	 mov	 eax, 8
  00a14	48 6b c0 00	 imul	 rax, rax, 0
  00a18	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv442[rsp], rax
  00a20	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR inc_level$[rsp]
  00a25	48 89 8c 24 08
	01 00 00	 mov	 QWORD PTR tv446[rsp], rcx
  00a2d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00a34	48 89 94 24 00
	01 00 00	 mov	 QWORD PTR tv676[rsp], rdx
  00a3c	b9 01 00 00 00	 mov	 ecx, 1
  00a41	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189079
  00a4e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00a53	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv442[rsp]
  00a5b	48 8b 8c 0c 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rcx]
  00a63	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a68	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00a70	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00a75	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv676[rsp]
  00a7d	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR tv446[rsp]
  00a85	8b 0c 91	 mov	 ecx, DWORD PTR [rcx+rdx*4]
  00a88	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189080
  00a93	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189081
  00a9f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aa9	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aaf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189082
  00ab6	ba 6e 01 00 00	 mov	 edx, 366		; 0000016eH
  00abb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189083
  00ac2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 367  :                 return -1;

  00ac8	b8 ff ff ff ff	 mov	 eax, -1
  00acd	e9 45 05 00 00	 jmp	 $LN1@process_co
$LN32@process_co:

; 368  :             }
; 369  : 
; 370  :             continue;

  00ad2	e9 ad f6 ff ff	 jmp	 $LN2@process_co
$LN27@process_co:

; 371  :         }
; 372  : 
; 373  :         /* Check for old-style CPU statement */
; 374  :         if (scount == 0 && addargc == 7 && strlen(addargv[0]) == 6
; 375  :             && sscanf(addargv[0], "%"SCNx32"%c", &rc, &c) == 1)

  00ad7	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR scount$[rsp], 0
  00adf	0f 85 bb 03 00
	00		 jne	 $LN33@process_co
  00ae5	83 7c 24 78 07	 cmp	 DWORD PTR addargc$[rsp], 7
  00aea	0f 85 b0 03 00
	00		 jne	 $LN33@process_co
  00af0	b8 08 00 00 00	 mov	 eax, 8
  00af5	48 6b c0 00	 imul	 rax, rax, 0
  00af9	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  00b01	e8 00 00 00 00	 call	 strlen
  00b06	48 83 f8 06	 cmp	 rax, 6
  00b0a	0f 85 90 03 00
	00		 jne	 $LN33@process_co
  00b10	b8 08 00 00 00	 mov	 eax, 8
  00b15	48 6b c0 00	 imul	 rax, rax, 0
  00b19	4c 8d 4c 24 68	 lea	 r9, QWORD PTR c$[rsp]
  00b1e	4c 8d 84 24 84
	00 00 00	 lea	 r8, QWORD PTR rc$[rsp]
  00b26	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189086
  00b2d	48 8b 8c 04 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rax]
  00b35	e8 00 00 00 00	 call	 sscanf
  00b3a	83 f8 01	 cmp	 eax, 1
  00b3d	0f 85 5d 03 00
	00		 jne	 $LN33@process_co

; 376  :         {
; 377  :         char *exec_cpuserial[2] = { "cpuserial", NULL };

  00b43	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189088
  00b4a	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR exec_cpuserial$6[rsp], rax
  00b52	48 c7 84 24 50
	01 00 00 00 00
	00 00		 mov	 QWORD PTR exec_cpuserial$6[rsp+8], 0

; 378  :         char *exec_cpumodel[2]  = { "cpumodel", NULL };

  00b5e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189090
  00b65	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR exec_cpumodel$7[rsp], rax
  00b6d	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR exec_cpumodel$7[rsp+8], 0

; 379  :         char *exec_mainsize[2]  = { "mainsize", NULL };

  00b79	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189092
  00b80	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR exec_mainsize$8[rsp], rax
  00b88	48 c7 84 24 70
	01 00 00 00 00
	00 00		 mov	 QWORD PTR exec_mainsize$8[rsp+8], 0

; 380  :         char *exec_xpndsize[2]  = { "xpndsize", NULL };

  00b94	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189094
  00b9b	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR exec_xpndsize$9[rsp], rax
  00ba3	48 c7 84 24 80
	01 00 00 00 00
	00 00		 mov	 QWORD PTR exec_xpndsize$9[rsp+8], 0

; 381  :         char *exec_cnslport[2]  = { "cnslport", NULL };

  00baf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189096
  00bb6	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR exec_cnslport$10[rsp], rax
  00bbe	48 c7 84 24 90
	01 00 00 00 00
	00 00		 mov	 QWORD PTR exec_cnslport$10[rsp+8], 0

; 382  :         char *exec_numcpu[2]    = { "numcpu", NULL };

  00bca	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189098
  00bd1	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR exec_numcpu$11[rsp], rax
  00bd9	48 c7 84 24 a0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR exec_numcpu$11[rsp+8], 0

; 383  :         char *exec_loadparm[2]  = { "loadparm", NULL };

  00be5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG189100
  00bec	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR exec_loadparm$12[rsp], rax
  00bf4	48 c7 84 24 b0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR exec_loadparm$12[rsp+8], 0

; 384  : 
; 385  :             exec_cpuserial[1] = addargv[0];

  00c00	b8 08 00 00 00	 mov	 eax, 8
  00c05	48 6b c0 00	 imul	 rax, rax, 0
  00c09	b9 08 00 00 00	 mov	 ecx, 8
  00c0e	48 6b c9 01	 imul	 rcx, rcx, 1
  00c12	48 8b 84 04 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax]
  00c1a	48 89 84 0c 48
	01 00 00	 mov	 QWORD PTR exec_cpuserial$6[rsp+rcx], rax

; 386  :             exec_cpumodel[1]  = addargv[1];

  00c22	b8 08 00 00 00	 mov	 eax, 8
  00c27	48 6b c0 01	 imul	 rax, rax, 1
  00c2b	b9 08 00 00 00	 mov	 ecx, 8
  00c30	48 6b c9 01	 imul	 rcx, rcx, 1
  00c34	48 8b 84 04 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax]
  00c3c	48 89 84 0c 58
	01 00 00	 mov	 QWORD PTR exec_cpumodel$7[rsp+rcx], rax

; 387  :             exec_mainsize[1]  = addargv[2];

  00c44	b8 08 00 00 00	 mov	 eax, 8
  00c49	48 6b c0 02	 imul	 rax, rax, 2
  00c4d	b9 08 00 00 00	 mov	 ecx, 8
  00c52	48 6b c9 01	 imul	 rcx, rcx, 1
  00c56	48 8b 84 04 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax]
  00c5e	48 89 84 0c 68
	01 00 00	 mov	 QWORD PTR exec_mainsize$8[rsp+rcx], rax

; 388  :             exec_xpndsize[1]  = addargv[3];

  00c66	b8 08 00 00 00	 mov	 eax, 8
  00c6b	48 6b c0 03	 imul	 rax, rax, 3
  00c6f	b9 08 00 00 00	 mov	 ecx, 8
  00c74	48 6b c9 01	 imul	 rcx, rcx, 1
  00c78	48 8b 84 04 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax]
  00c80	48 89 84 0c 78
	01 00 00	 mov	 QWORD PTR exec_xpndsize$9[rsp+rcx], rax

; 389  :             exec_cnslport[1]  = addargv[4];

  00c88	b8 08 00 00 00	 mov	 eax, 8
  00c8d	48 6b c0 04	 imul	 rax, rax, 4
  00c91	b9 08 00 00 00	 mov	 ecx, 8
  00c96	48 6b c9 01	 imul	 rcx, rcx, 1
  00c9a	48 8b 84 04 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax]
  00ca2	48 89 84 0c 88
	01 00 00	 mov	 QWORD PTR exec_cnslport$10[rsp+rcx], rax

; 390  :             exec_numcpu[1]    = addargv[5];

  00caa	b8 08 00 00 00	 mov	 eax, 8
  00caf	48 6b c0 05	 imul	 rax, rax, 5
  00cb3	b9 08 00 00 00	 mov	 ecx, 8
  00cb8	48 6b c9 01	 imul	 rcx, rcx, 1
  00cbc	48 8b 84 04 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax]
  00cc4	48 89 84 0c 98
	01 00 00	 mov	 QWORD PTR exec_numcpu$11[rsp+rcx], rax

; 391  :             exec_loadparm[1]  = addargv[6];

  00ccc	b8 08 00 00 00	 mov	 eax, 8
  00cd1	48 6b c0 06	 imul	 rax, rax, 6
  00cd5	b9 08 00 00 00	 mov	 ecx, 8
  00cda	48 6b c9 01	 imul	 rcx, rcx, 1
  00cde	48 8b 84 04 00
	02 00 00	 mov	 rax, QWORD PTR addargv$[rsp+rax]
  00ce6	48 89 84 0c a8
	01 00 00	 mov	 QWORD PTR exec_loadparm$12[rsp+rcx], rax

; 392  : 
; 393  :             if(CallHercCmd (2, exec_cpuserial, NULL) < 0 )

  00cee	45 33 c0	 xor	 r8d, r8d
  00cf1	48 8d 94 24 48
	01 00 00	 lea	 rdx, QWORD PTR exec_cpuserial$6[rsp]
  00cf9	b9 02 00 00 00	 mov	 ecx, 2
  00cfe	e8 00 00 00 00	 call	 CallHercCmd
  00d03	85 c0		 test	 eax, eax
  00d05	7d 0a		 jge	 SHORT $LN35@process_co

; 394  :                 errorcount++;

  00d07	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00d0b	ff c0		 inc	 eax
  00d0d	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax
$LN35@process_co:

; 395  :             if(CallHercCmd (2, exec_cpumodel,  NULL) < 0 )

  00d11	45 33 c0	 xor	 r8d, r8d
  00d14	48 8d 94 24 58
	01 00 00	 lea	 rdx, QWORD PTR exec_cpumodel$7[rsp]
  00d1c	b9 02 00 00 00	 mov	 ecx, 2
  00d21	e8 00 00 00 00	 call	 CallHercCmd
  00d26	85 c0		 test	 eax, eax
  00d28	7d 0a		 jge	 SHORT $LN36@process_co

; 396  :                 errorcount++;

  00d2a	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00d2e	ff c0		 inc	 eax
  00d30	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax
$LN36@process_co:

; 397  :             if(CallHercCmd (2, exec_mainsize,  NULL) < 0 )

  00d34	45 33 c0	 xor	 r8d, r8d
  00d37	48 8d 94 24 68
	01 00 00	 lea	 rdx, QWORD PTR exec_mainsize$8[rsp]
  00d3f	b9 02 00 00 00	 mov	 ecx, 2
  00d44	e8 00 00 00 00	 call	 CallHercCmd
  00d49	85 c0		 test	 eax, eax
  00d4b	7d 0a		 jge	 SHORT $LN37@process_co

; 398  :                 errorcount++;

  00d4d	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00d51	ff c0		 inc	 eax
  00d53	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax
$LN37@process_co:

; 399  :             if(CallHercCmd (2, exec_xpndsize,  NULL) < 0 )

  00d57	45 33 c0	 xor	 r8d, r8d
  00d5a	48 8d 94 24 78
	01 00 00	 lea	 rdx, QWORD PTR exec_xpndsize$9[rsp]
  00d62	b9 02 00 00 00	 mov	 ecx, 2
  00d67	e8 00 00 00 00	 call	 CallHercCmd
  00d6c	85 c0		 test	 eax, eax
  00d6e	7d 0a		 jge	 SHORT $LN38@process_co

; 400  :                 errorcount++;

  00d70	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00d74	ff c0		 inc	 eax
  00d76	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax
$LN38@process_co:

; 401  :             if(CallHercCmd (2, exec_cnslport,  NULL) < 0 )

  00d7a	45 33 c0	 xor	 r8d, r8d
  00d7d	48 8d 94 24 88
	01 00 00	 lea	 rdx, QWORD PTR exec_cnslport$10[rsp]
  00d85	b9 02 00 00 00	 mov	 ecx, 2
  00d8a	e8 00 00 00 00	 call	 CallHercCmd
  00d8f	85 c0		 test	 eax, eax
  00d91	7d 0a		 jge	 SHORT $LN39@process_co

; 402  :                 errorcount++;

  00d93	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00d97	ff c0		 inc	 eax
  00d99	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax
$LN39@process_co:

; 403  :             if(CallHercCmd (2, exec_numcpu,    NULL) < 0 )

  00d9d	45 33 c0	 xor	 r8d, r8d
  00da0	48 8d 94 24 98
	01 00 00	 lea	 rdx, QWORD PTR exec_numcpu$11[rsp]
  00da8	b9 02 00 00 00	 mov	 ecx, 2
  00dad	e8 00 00 00 00	 call	 CallHercCmd
  00db2	85 c0		 test	 eax, eax
  00db4	7d 0a		 jge	 SHORT $LN40@process_co

; 404  :                 errorcount++;

  00db6	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00dba	ff c0		 inc	 eax
  00dbc	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax
$LN40@process_co:

; 405  :             if(CallHercCmd (2, exec_loadparm,  NULL) < 0 )

  00dc0	45 33 c0	 xor	 r8d, r8d
  00dc3	48 8d 94 24 a8
	01 00 00	 lea	 rdx, QWORD PTR exec_loadparm$12[rsp]
  00dcb	b9 02 00 00 00	 mov	 ecx, 2
  00dd0	e8 00 00 00 00	 call	 CallHercCmd
  00dd5	85 c0		 test	 eax, eax
  00dd7	7d 0a		 jge	 SHORT $LN41@process_co

; 406  :                 errorcount++;

  00dd9	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00ddd	ff c0		 inc	 eax
  00ddf	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax
$LN41@process_co:

; 407  : 
; 408  :             if(errorcount)

  00de3	83 7c 24 64 00	 cmp	 DWORD PTR errorcount$[rsp], 0
  00de8	0f 84 ad 00 00
	00		 je	 $LN42@process_co

; 409  :                 WRMSG(HHC01441, "E", inc_stmtnum[inc_level], fname, addargv[0]);

  00dee	b8 08 00 00 00	 mov	 eax, 8
  00df3	48 6b c0 00	 imul	 rax, rax, 0
  00df7	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv577[rsp], rax
  00dff	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR inc_level$[rsp]
  00e04	48 89 8c 24 20
	01 00 00	 mov	 QWORD PTR tv581[rsp], rcx
  00e0c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00e13	48 89 94 24 18
	01 00 00	 mov	 QWORD PTR tv677[rsp], rdx
  00e1b	b9 01 00 00 00	 mov	 ecx, 1
  00e20	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e26	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv577[rsp]
  00e2e	48 8b 8c 0c 00
	02 00 00	 mov	 rcx, QWORD PTR addargv$[rsp+rcx]
  00e36	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e3b	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00e43	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e48	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv677[rsp]
  00e50	48 8b 94 24 20
	01 00 00	 mov	 rdx, QWORD PTR tv581[rsp]
  00e58	8b 0c 91	 mov	 ecx, DWORD PTR [rcx+rdx*4]
  00e5b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e5f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189109
  00e66	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e6b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189110
  00e72	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e77	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e7c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e82	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189111
  00e89	ba 99 01 00 00	 mov	 edx, 409		; 00000199H
  00e8e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189112
  00e95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN42@process_co:

; 410  :         }

  00e9b	e9 4d 01 00 00	 jmp	 $LN34@process_co
$LN33@process_co:

; 411  :         else
; 412  :         {
; 413  :             char addcmdline[MAX_CMD_LEN];
; 414  :             int i;
; 415  :             int rc;
; 416  : 
; 417  :             STRLCPY( addcmdline, addargv[0] );

  00ea0	b8 08 00 00 00	 mov	 eax, 8
  00ea5	48 6b c0 00	 imul	 rax, rax, 0
  00ea9	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00eaf	48 8b 94 04 00
	02 00 00	 mov	 rdx, QWORD PTR addargv$[rsp+rax]
  00eb7	48 8d 8c 24 20
	24 00 00	 lea	 rcx, QWORD PTR addcmdline$13[rsp]
  00ebf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 418  :             for( i = 1; i < addargc; i++ )

  00ec5	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00ecd	eb 0a		 jmp	 SHORT $LN12@process_co
$LN10@process_co:
  00ecf	8b 44 24 74	 mov	 eax, DWORD PTR i$1[rsp]
  00ed3	ff c0		 inc	 eax
  00ed5	89 44 24 74	 mov	 DWORD PTR i$1[rsp], eax
$LN12@process_co:
  00ed9	8b 44 24 78	 mov	 eax, DWORD PTR addargc$[rsp]
  00edd	39 44 24 74	 cmp	 DWORD PTR i$1[rsp], eax
  00ee1	7d 3e		 jge	 SHORT $LN11@process_co

; 419  :             {
; 420  :                 STRLCAT( addcmdline, " " );

  00ee3	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00ee9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG189113
  00ef0	48 8d 8c 24 20
	24 00 00	 lea	 rcx, QWORD PTR addcmdline$13[rsp]
  00ef8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 421  :                 STRLCAT( addcmdline, addargv[i] );

  00efe	48 63 44 24 74	 movsxd	 rax, DWORD PTR i$1[rsp]
  00f03	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  00f09	48 8b 94 c4 00
	02 00 00	 mov	 rdx, QWORD PTR addargv$[rsp+rax*8]
  00f11	48 8d 8c 24 20
	24 00 00	 lea	 rcx, QWORD PTR addcmdline$13[rsp]
  00f19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 422  :             }

  00f1f	eb ae		 jmp	 SHORT $LN10@process_co
$LN11@process_co:

; 423  : 
; 424  :             rc = CallHercCmd (addargc, addargv, addcmdline);

  00f21	4c 8d 84 24 20
	24 00 00	 lea	 r8, QWORD PTR addcmdline$13[rsp]
  00f29	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR addargv$[rsp]
  00f31	8b 4c 24 78	 mov	 ecx, DWORD PTR addargc$[rsp]
  00f35	e8 00 00 00 00	 call	 CallHercCmd
  00f3a	89 84 24 94 00
	00 00		 mov	 DWORD PTR rc$4[rsp], eax

; 425  : 
; 426  :             /* rc < 0 abort, rc == 0 OK, rc > warnings */
; 427  : 
; 428  :             if( rc < 0 )

  00f41	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR rc$4[rsp], 0
  00f49	0f 8d 9e 00 00
	00		 jge	 $LN43@process_co

; 429  :             {
; 430  :                 errorcount++;

  00f4f	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
  00f53	ff c0		 inc	 eax
  00f55	89 44 24 64	 mov	 DWORD PTR errorcount$[rsp], eax

; 431  :                 WRMSG(HHC01441, "E", inc_stmtnum[inc_level], fname, addcmdline);

  00f59	48 63 44 24 60	 movsxd	 rax, DWORD PTR inc_level$[rsp]
  00f5e	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv618[rsp], rax
  00f66	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?inc_stmtnum@?1??process_config@@9@9
  00f6d	48 89 8c 24 28
	01 00 00	 mov	 QWORD PTR tv678[rsp], rcx
  00f75	b9 01 00 00 00	 mov	 ecx, 1
  00f7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f80	48 8d 8c 24 20
	24 00 00	 lea	 rcx, QWORD PTR addcmdline$13[rsp]
  00f88	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f8d	48 8d 8c 24 00
	22 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00f95	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00f9a	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR tv678[rsp]
  00fa2	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv618[rsp]
  00faa	8b 0c 8a	 mov	 ecx, DWORD PTR [rdx+rcx*4]
  00fad	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00fb1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189115
  00fb8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fbd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189116
  00fc4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fc9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fce	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fd4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG189117
  00fdb	ba af 01 00 00	 mov	 edx, 431		; 000001afH
  00fe0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG189118
  00fe7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN43@process_co:
$LN34@process_co:

; 432  :             }
; 433  : 
; 434  :         } /* end else (not old-style CPU statement) */
; 435  : 
; 436  :     } /* end for(scount) (end of configuration file statement loop) */

  00fed	e9 92 f1 ff ff	 jmp	 $LN2@process_co
$rexx_done$47:

; 437  : 
; 438  : #if defined(HAVE_OBJECT_REXX) || defined(HAVE_REGINA_REXX)
; 439  : 
; 440  : rexx_done:
; 441  : 
; 442  :     if(!sysblk.msglvl)

  00ff2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ff9	83 b8 80 75 01
	00 00		 cmp	 DWORD PTR [rax+95616], 0
  01000	75 11		 jne	 SHORT $LN44@process_co

; 443  :         sysblk.msglvl = DEFAULT_MLVL;

  01002	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01009	c7 80 80 75 01
	00 00 00 00 c0	 mov	 DWORD PTR [rax+95616], -1073741824 ; c0000000H
$LN44@process_co:

; 444  : 
; 445  :     return errorcount;

  01013	8b 44 24 64	 mov	 eax, DWORD PTR errorcount$[rsp]
$LN1@process_co:

; 446  : 
; 447  : #endif // defined(HAVE_OBJECT_REXX) || defined(HAVE_REGINA_REXX)
; 448  : 
; 449  : } /* end function process_config */

  01017	48 8b 8c 24 20
	a4 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0101f	48 33 cc	 xor	 rcx, rsp
  01022	e8 00 00 00 00	 call	 __security_check_cookie
  01027	48 81 c4 38 a4
	01 00		 add	 rsp, 107576		; 0001a438H
  0102e	c3		 ret	 0
process_config ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
