; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
qeth_immed_commands DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG171311 DB	'QDSIG_RESET', 00H
	ORG $+4
$SG171312 DB	'QDSIG_HALT', 00H
	ORG $+5
$SG171313 DB	'QDSIG_SYNC', 00H
	ORG $+5
$SG171314 DB	'QDSIG_READ', 00H
	ORG $+5
$SG171315 DB	'QDSIG_RDMULT', 00H
	ORG $+3
$SG171316 DB	'QDSIG_WRIT', 00H
	ORG $+5
$SG171317 DB	'QDSIG_WRMULT', 00H
	ORG $+3
$SG171318 DB	'QDSIG_WAKEUP', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?dest_zero@?1??l3_cast_type_ipv6@@9@9	ORG $+16		; `l3_cast_type_ipv6'::`2'::dest_zero
?zeromac@?CA@??qeth_init_handler@@9@9	ORG $+6		; `qeth_init_handler'::`32'::zeromac
	ORG $+2
?zeromac@?1??InitMACAddr@@9@9	ORG $+6			; `InitMACAddr'::`2'::zeromac
	ORG $+2
osa_device_ned DB 0d0H
	DB	01H
	DB	06H
	DB	00H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f3H
	DB	0f2H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	00H
	DB	00H
osa_ctlunit_ned DB 0d0H
	DB	02H
	DB	00H
	DB	00H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f3H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f2H
	DB	00H
	DB	00H
osa_token_ned DB 0f0H
	DB	00H
	DB	06H
	DB	00H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f3H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f2H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f3H
	DB	00H
	DB	00H
osa_general_neq DB 080H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
osa_nd	DB	00H
	DB	00H
	DB	06H
	DB	0ffH
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f3H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f2H
	DB	00H
	DB	00H
osa_nq	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
sense_id_bytes DB 0ffH
	DB	017H
	DB	031H
	DB	01H
	DB	017H
	DB	032H
	DB	01H
	DB	00H
	DB	040H
	DB	0faH
	DB	00H
	DB	080H
	DB	041H
	DB	081H
	DB	00H
	DB	04H
	DB	042H
	DB	082H
	DB	00H
	DB	040H
	DB	043H
	DB	01bH
	DB	010H
	DB	00H
	DB	044H
	DB	01fH
	DB	00H
	DB	00H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_f3_noswap
PUBLIC	store_f3_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_dev_storekey_ptr
PUBLIC	_get_dev_storekey1_ptr
PUBLIC	_get_dev_storekey2_ptr
PUBLIC	s370__get_dev_storage_key
PUBLIC	s370__or_dev_storage_key
PUBLIC	s370_get_dev_4K_storage_key
PUBLIC	s370_or_dev_4K_storage_key
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_resolve_symbols_ep
PUBLIC	hdl_register_symbols_ep
PUBLIC	hdl_define_devtypes_ep
PUBLIC	__real@4070000000000000
PUBLIC	__real@40e0000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	strcat:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp_closesocket:PROC
EXTRN	__imp_htonl:PROC
EXTRN	__imp_inet_addr:PROC
EXTRN	__imp_inet_ntoa:PROC
EXTRN	__imp_ntohl:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_try_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_destroy_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_destroy_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_set_lock_name:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_trimloc:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_socketpair:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_socket_set_blocking_mode:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_FD_ISSET:PROC
EXTRN	__imp_w32_select:PROC
EXTRN	__imp_w32_inet_ntop:PROC
EXTRN	__imp_w32_inet_pton:PROC
EXTRN	__imp_w32_vsnprintf:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	tt32_read:PROC
EXTRN	tt32_write:PROC
EXTRN	tt32_close:PROC
EXTRN	tt32_version_numbers:PROC
EXTRN	display_tt32_stats:PROC
EXTRN	enable_tt32_debug_tracing:PROC
EXTRN	__imp_init_sysblk_netdev:PROC
EXTRN	__imp_group_device:PROC
EXTRN	__imp_FormatSID:PROC
EXTRN	__imp_FormatRCD:PROC
EXTRN	__imp_FormatRNI:PROC
EXTRN	__imp_Queue_IO_Interrupt_QLocked:PROC
EXTRN	__imp_Update_IC_IOPENDING_QLocked:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__imp_mpc_point_puk:PROC
EXTRN	__imp_mpc_point_pus:PROC
EXTRN	__imp_mpc_display_description:PROC
EXTRN	__imp_mpc_display_stuff:PROC
EXTRN	__imp_mpc_display_osa_iea:PROC
EXTRN	__imp_mpc_display_osa_iear:PROC
EXTRN	__imp_mpc_display_osa_th_etc:PROC
EXTRN	TUNTAP_CreateInterface:PROC
EXTRN	TUNTAP_SetDestAddr:PROC
EXTRN	TUNTAP_SetNetMask:PROC
EXTRN	TUNTAP_SetIPAddr6:PROC
EXTRN	TUNTAP_GetMTU:PROC
EXTRN	TUNTAP_SetMTU:PROC
EXTRN	TUNTAP_GetMACAddr:PROC
EXTRN	TUNTAP_SetMACAddr:PROC
EXTRN	TUNTAP_SetFlags:PROC
EXTRN	TT32_AddIPAddr:PROC
EXTRN	TT32_DelIPAddr:PROC
EXTRN	build_herc_iface_mac:PROC
EXTRN	ParseMAC:PROC
EXTRN	FormatMAC:PROC
EXTRN	net_data_trace:PROC
EXTRN	resolve_host:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG171184 DB	01H DUP (?)
	ALIGN	4

configuration_data DB 080H DUP (?)
node_data DB	040H DUP (?)
?buf@?1??qsig2str@@9@9 DB 010H DUP (?)			; `qsig2str'::`2'::buf
?didthis@?1??tt32_multiple_ip_support@@9@9 DB 01H DUP (?) ; `tt32_multiple_ip_support'::`2'::didthis
	ALIGN	4

?multiple_ip_support@?1??tt32_multiple_ip_support@@9@9 DB 01H DUP (?) ; `tt32_multiple_ip_support'::`2'::multiple_ip_support
	ALIGN	4

$SG171783 DB	01H DUP (?)
	ALIGN	4

$SG172215 DB	01H DUP (?)
	ALIGN	4

$SG172979 DB	01H DUP (?)
	ALIGN	4

$SG173030 DB	01H DUP (?)
	ALIGN	4

$SG173895 DB	01H DUP (?)
	ALIGN	4

$SG173896 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_f3_noswap DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$fetch_f3_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$store_f3_noswap DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$store_f3_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Try_Obtain_Interrupt_Lock DD imagerel Try_Obtain_Interrupt_Lock
	DD	imagerel Try_Obtain_Interrupt_Lock+132
	DD	imagerel $unwind$Try_Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_dev_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$_get_dev_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__get_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+140
	DD	imagerel $unwind$s370__get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+192
	DD	imagerel $unwind$s370__or_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$s370_get_dev_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$s370_or_dev_4K_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$dbgtrc DD imagerel dbgtrc
	DD	imagerel dbgtrc+374
	DD	imagerel $unwind$dbgtrc
$pdata$dbgupd DD imagerel dbgupd
	DD	imagerel dbgupd+578
	DD	imagerel $unwind$dbgupd
$pdata$process_cm_enable DD imagerel process_cm_enable
	DD	imagerel process_cm_enable+1145
	DD	imagerel $unwind$process_cm_enable
$pdata$process_cm_setup DD imagerel process_cm_setup
	DD	imagerel process_cm_setup+1277
	DD	imagerel $unwind$process_cm_setup
$pdata$process_cm_takedown DD imagerel process_cm_takedown
	DD	imagerel process_cm_takedown+157
	DD	imagerel $unwind$process_cm_takedown
$pdata$process_cm_disable DD imagerel process_cm_disable
	DD	imagerel process_cm_disable+157
	DD	imagerel $unwind$process_cm_disable
$pdata$process_ulp_enable_extract DD imagerel process_ulp_enable_extract
	DD	imagerel process_ulp_enable_extract+615
	DD	imagerel $unwind$process_ulp_enable_extract
$pdata$process_ulp_enable DD imagerel process_ulp_enable
	DD	imagerel process_ulp_enable+1229
	DD	imagerel $unwind$process_ulp_enable
$pdata$process_ulp_setup DD imagerel process_ulp_setup
	DD	imagerel process_ulp_setup+1488
	DD	imagerel $unwind$process_ulp_setup
$pdata$process_dm_act DD imagerel process_dm_act
	DD	imagerel process_dm_act+981
	DD	imagerel $unwind$process_dm_act
$pdata$process_ulp_takedown DD imagerel process_ulp_takedown
	DD	imagerel process_ulp_takedown+157
	DD	imagerel $unwind$process_ulp_takedown
$pdata$process_ulp_disable DD imagerel process_ulp_disable
	DD	imagerel process_ulp_disable+180
	DD	imagerel $unwind$process_ulp_disable
$pdata$alloc_buffer DD imagerel alloc_buffer
	DD	imagerel alloc_buffer+414
	DD	imagerel $unwind$alloc_buffer
$pdata$add_buffer_to_chain DD imagerel add_buffer_to_chain
	DD	imagerel add_buffer_to_chain+189
	DD	imagerel $unwind$add_buffer_to_chain
$pdata$remove_buffer_from_chain DD imagerel remove_buffer_from_chain
	DD	imagerel remove_buffer_from_chain+167
	DD	imagerel $unwind$remove_buffer_from_chain
$pdata$remove_and_free_any_buffers_on_chain DD imagerel remove_and_free_any_buffers_on_chain
	DD	imagerel remove_and_free_any_buffers_on_chain+165
	DD	imagerel $unwind$remove_and_free_any_buffers_on_chain
$pdata$signal_idx_event DD imagerel signal_idx_event
	DD	imagerel signal_idx_event+85
	DD	imagerel $unwind$signal_idx_event
$pdata$InitMACAddr DD imagerel InitMACAddr
	DD	imagerel InitMACAddr+1484
	DD	imagerel $unwind$InitMACAddr
$pdata$InitMTU DD imagerel InitMTU
	DD	imagerel InitMTU+253
	DD	imagerel $unwind$InitMTU
$pdata$netmask2prefix DD imagerel netmask2prefix
	DD	imagerel netmask2prefix+274
	DD	imagerel $unwind$netmask2prefix
$pdata$prefix2netmask DD imagerel prefix2netmask
	DD	imagerel prefix2netmask+210
	DD	imagerel $unwind$prefix2netmask
$pdata$makepfxmask4 DD imagerel makepfxmask4
	DD	imagerel makepfxmask4+99
	DD	imagerel $unwind$makepfxmask4
$pdata$makepfxmask6 DD imagerel makepfxmask6
	DD	imagerel makepfxmask6+259
	DD	imagerel $unwind$makepfxmask6
$pdata$qeth_init_queues DD imagerel qeth_init_queues
	DD	imagerel qeth_init_queues+41
	DD	imagerel $unwind$qeth_init_queues
$pdata$qeth_init_queue DD imagerel qeth_init_queue
	DD	imagerel qeth_init_queue+576
	DD	imagerel $unwind$qeth_init_queue
$pdata$process_l3_icmpv6_packet DD imagerel process_l3_icmpv6_packet
	DD	imagerel process_l3_icmpv6_packet+966
	DD	imagerel $unwind$process_l3_icmpv6_packet
$pdata$calculate_icmpv6_checksum DD imagerel calculate_icmpv6_checksum
	DD	imagerel calculate_icmpv6_checksum+610
	DD	imagerel $unwind$calculate_icmpv6_checksum
$pdata$qsig2str DD imagerel qsig2str
	DD	imagerel qsig2str+82
	DD	imagerel $unwind$qsig2str
$pdata$qeth_storage_access_check DD imagerel qeth_storage_access_check
	DD	imagerel qeth_storage_access_check+648
	DD	imagerel $unwind$qeth_storage_access_check
$pdata$qeth_storage_access_check_and_update DD imagerel qeth_storage_access_check_and_update
	DD	imagerel qeth_storage_access_check_and_update+105
	DD	imagerel $unwind$qeth_storage_access_check_and_update
$pdata$set_alsi DD imagerel set_alsi
	DD	imagerel set_alsi+173
	DD	imagerel $unwind$set_alsi
$pdata$set_dsci DD imagerel set_dsci
	DD	imagerel set_dsci+251
	DD	imagerel $unwind$set_dsci
$pdata$register_mac DD imagerel register_mac
	DD	imagerel register_mac+1142
	DD	imagerel $unwind$register_mac
$pdata$unregister_mac DD imagerel unregister_mac
	DD	imagerel unregister_mac+1094
	DD	imagerel $unwind$unregister_mac
$pdata$unregister_all_mac DD imagerel unregister_all_mac
	DD	imagerel unregister_all_mac+100
	DD	imagerel $unwind$unregister_all_mac
$pdata$validate_mac DD imagerel validate_mac
	DD	imagerel validate_mac+260
	DD	imagerel $unwind$validate_mac
$pdata$tt32_multiple_ip_support DD imagerel tt32_multiple_ip_support
	DD	imagerel tt32_multiple_ip_support+129
	DD	imagerel $unwind$tt32_multiple_ip_support
$pdata$register_ipv4 DD imagerel register_ipv4
	DD	imagerel register_ipv4+862
	DD	imagerel $unwind$register_ipv4
$pdata$unregister_ipv4 DD imagerel unregister_ipv4
	DD	imagerel unregister_ipv4+809
	DD	imagerel $unwind$unregister_ipv4
$pdata$unregister_all_ipv4 DD imagerel unregister_all_ipv4
	DD	imagerel unregister_all_ipv4+92
	DD	imagerel $unwind$unregister_all_ipv4
$pdata$register_ipv6 DD imagerel register_ipv6
	DD	imagerel register_ipv6+844
	DD	imagerel $unwind$register_ipv6
$pdata$unregister_ipv6 DD imagerel unregister_ipv6
	DD	imagerel unregister_ipv6+777
	DD	imagerel $unwind$unregister_ipv6
$pdata$unregister_all_ipv6 DD imagerel unregister_all_ipv6
	DD	imagerel unregister_all_ipv6+100
	DD	imagerel $unwind$unregister_all_ipv6
$pdata$qeth_select DD imagerel qeth_select
	DD	imagerel qeth_select+332
	DD	imagerel $unwind$qeth_select
$pdata$qeth_read_pipe DD imagerel qeth_read_pipe
	DD	imagerel qeth_read_pipe+312
	DD	imagerel $unwind$qeth_read_pipe
$pdata$qeth_write_pipe DD imagerel qeth_write_pipe
	DD	imagerel qeth_write_pipe+312
	DD	imagerel $unwind$qeth_write_pipe
$pdata$qeth_errnum_msg DD imagerel qeth_errnum_msg
	DD	imagerel qeth_errnum_msg+1175
	DD	imagerel $unwind$qeth_errnum_msg
$pdata$qeth_report_using DD imagerel qeth_report_using
	DD	imagerel qeth_report_using+2523
	DD	imagerel $unwind$qeth_report_using
$pdata$qeth_enable_interface DD imagerel qeth_enable_interface
	DD	imagerel qeth_enable_interface+266
	DD	imagerel $unwind$qeth_enable_interface
$pdata$qeth_disable_interface DD imagerel qeth_disable_interface
	DD	imagerel qeth_disable_interface+266
	DD	imagerel $unwind$qeth_disable_interface
$pdata$qeth_create_interface DD imagerel qeth_create_interface
	DD	imagerel qeth_create_interface+2785
	DD	imagerel $unwind$qeth_create_interface
$pdata$osa_adapter_cmd DD imagerel osa_adapter_cmd
	DD	imagerel osa_adapter_cmd+14600
	DD	imagerel $unwind$osa_adapter_cmd
$pdata$osa_device_cmd DD imagerel osa_device_cmd
	DD	imagerel osa_device_cmd+1554
	DD	imagerel $unwind$osa_device_cmd
$pdata$raise_adapter_interrupt DD imagerel raise_adapter_interrupt
	DD	imagerel raise_adapter_interrupt+402
	DD	imagerel $unwind$raise_adapter_interrupt
$pdata$SBALE_Error DD imagerel SBALE_Error
	DD	imagerel SBALE_Error+577
	DD	imagerel $unwind$SBALE_Error
$pdata$l3_cast_type_ipv4 DD imagerel l3_cast_type_ipv4
	DD	imagerel l3_cast_type_ipv4+234
	DD	imagerel $unwind$l3_cast_type_ipv4
$pdata$l3_cast_type_ipv6 DD imagerel l3_cast_type_ipv6
	DD	imagerel l3_cast_type_ipv6+195
	DD	imagerel $unwind$l3_cast_type_ipv6
$pdata$more_packets DD imagerel more_packets
	DD	imagerel more_packets+169
	DD	imagerel $unwind$more_packets
$pdata$read_packet DD imagerel read_packet
	DD	imagerel read_packet+1107
	DD	imagerel $unwind$read_packet
$pdata$write_packet DD imagerel write_packet
	DD	imagerel write_packet+703
	DD	imagerel $unwind$write_packet
$pdata$copy_fragment_to_storage DD imagerel copy_fragment_to_storage
	DD	imagerel copy_fragment_to_storage+1050
	DD	imagerel $unwind$copy_fragment_to_storage
$pdata$copy_storage_fragments DD imagerel copy_storage_fragments
	DD	imagerel copy_storage_fragments+1036
	DD	imagerel $unwind$copy_storage_fragments
$pdata$copy_packet_to_storage DD imagerel copy_packet_to_storage
	DD	imagerel copy_packet_to_storage+782
	DD	imagerel $unwind$copy_packet_to_storage
$pdata$read_L2_packets DD imagerel read_L2_packets
	DD	imagerel read_L2_packets+1369
	DD	imagerel $unwind$read_L2_packets
$pdata$read_L3_packets DD imagerel read_L3_packets
	DD	imagerel read_L3_packets+1356
	DD	imagerel $unwind$read_L3_packets
$pdata$read_l3r_buffers DD imagerel read_l3r_buffers
	DD	imagerel read_l3r_buffers+1404
	DD	imagerel $unwind$read_l3r_buffers
$pdata$write_buffered_packets DD imagerel write_buffered_packets
	DD	imagerel write_buffered_packets+4237
	DD	imagerel $unwind$write_buffered_packets
$pdata$process_input_queues DD imagerel process_input_queues
	DD	imagerel process_input_queues+2125
	DD	imagerel $unwind$process_input_queues
$pdata$process_output_queues DD imagerel process_output_queues
	DD	imagerel process_output_queues+1262
	DD	imagerel $unwind$process_output_queues
$pdata$qeth_halt_read_device DD imagerel qeth_halt_read_device
	DD	imagerel qeth_halt_read_device+422
	DD	imagerel $unwind$qeth_halt_read_device
$pdata$qeth_halt_data_device DD imagerel qeth_halt_data_device
	DD	imagerel qeth_halt_data_device+567
	DD	imagerel $unwind$qeth_halt_data_device
$pdata$qeth_halt_or_clear DD imagerel qeth_halt_or_clear
	DD	imagerel qeth_halt_or_clear+237
	DD	imagerel $unwind$qeth_halt_or_clear
$pdata$qeth_read_configuration_data DD imagerel qeth_read_configuration_data
	DD	imagerel qeth_read_configuration_data+484
	DD	imagerel $unwind$qeth_read_configuration_data
$pdata$qeth_init_handler DD imagerel qeth_init_handler
	DD	imagerel qeth_init_handler+8328
	DD	imagerel $unwind$qeth_init_handler
$pdata$qeth_query_device DD imagerel qeth_query_device
	DD	imagerel qeth_query_device+1004
	DD	imagerel $unwind$qeth_query_device
$pdata$qeth_close_device DD imagerel qeth_close_device
	DD	imagerel qeth_close_device+1748
	DD	imagerel $unwind$qeth_close_device
$pdata$qeth_set_sci DD imagerel qeth_set_sci
	DD	imagerel qeth_set_sci+399
	DD	imagerel $unwind$qeth_set_sci
$pdata$qeth_ssqd_desc DD imagerel qeth_ssqd_desc
	DD	imagerel qeth_ssqd_desc+410
	DD	imagerel $unwind$qeth_ssqd_desc
$pdata$qeth_execute_ccw DD imagerel qeth_execute_ccw
	DD	imagerel qeth_execute_ccw+10786
	DD	imagerel $unwind$qeth_execute_ccw
$pdata$qeth_initiate_input DD imagerel qeth_initiate_input
	DD	imagerel qeth_initiate_input+969
	DD	imagerel $unwind$qeth_initiate_input
$pdata$qeth_do_initiate_output DD imagerel qeth_do_initiate_output
	DD	imagerel qeth_do_initiate_output+515
	DD	imagerel $unwind$qeth_do_initiate_output
$pdata$qeth_initiate_output DD imagerel qeth_initiate_output
	DD	imagerel qeth_initiate_output+380
	DD	imagerel $unwind$qeth_initiate_output
$pdata$qeth_initiate_output_mult DD imagerel qeth_initiate_output_mult
	DD	imagerel qeth_initiate_output_mult+380
	DD	imagerel $unwind$qeth_initiate_output_mult
$pdata$qeth_do_sync DD imagerel qeth_do_sync
	DD	imagerel qeth_do_sync+480
	DD	imagerel $unwind$qeth_do_sync
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+433
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_register_symbols_ep DD imagerel $LN3
	DD	imagerel $LN3+50
	DD	imagerel $unwind$hdl_register_symbols_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
;	COMDAT __real@40e0000000000000
CONST	SEGMENT
__real@40e0000000000000 DQ 040e0000000000000r	; 32768
CONST	ENDS
;	COMDAT __real@4070000000000000
CONST	SEGMENT
__real@4070000000000000 DQ 04070000000000000r	; 256
CONST	ENDS
_DATA	SEGMENT
	ORG $+3
$SG171147 DB	'HHC03991D %1d:%04X %s: %s', 0aH, 00H
	ORG $+1
$SG171413 DB	'I', 00H
	ORG $+2
$SG171177 DB	'HHC03991D %1d:%04X %s: %s', 0aH, 00H
	ORG $+5
?sigstr@?1??qsig2str@@9@9 DQ FLAT:$SG171311		; `qsig2str'::`2'::sigstr
	DQ	FLAT:$SG171312
	DQ	FLAT:$SG171313
	DQ	FLAT:$SG171314
	DQ	FLAT:$SG171315
	DQ	FLAT:$SG171316
	DQ	FLAT:$SG171317
	DQ	FLAT:$SG171318
$SG171320 DB	'QDSIG_0x%02X', 00H
	ORG $+3
$SG171334 DB	'Address %llx above main storage', 00H
$SG171335 DB	'qeth_storage_access_check', 00H
	ORG $+2
$SG171336 DB	'qeth.c', 00H
	ORG $+1
$SG171418 DB	'E', 00H
	ORG $+2
$SG171340 DB	'Address %llx below limit of %llx', 00H
	ORG $+3
$SG171342 DB	'qeth.c', 00H
	ORG $+1
$SG171444 DB	'I', 00H
	ORG $+2
$SG171341 DB	'qeth_storage_access_check', 00H
	ORG $+2
$SG171347 DB	'qeth.c', 00H
	ORG $+1
$SG171450 DB	'W', 00H
	ORG $+2
$SG171345 DB	'Address %llx above limit of %llx', 00H
	ORG $+3
$SG171356 DB	'qeth.c', 00H
	ORG $+1
$SG171511 DB	'I', 00H
	ORG $+2
$SG171346 DB	'qeth_storage_access_check', 00H
	ORG $+6
$SG171354 DB	'Key mismatch protection exception : requested key : %x, '
	DB	'storage key : %x access type %x', 00H
$SG171355 DB	'qeth_storage_access_check', 00H
	ORG $+2
$SG171416 DB	'qeth.c', 00H
	ORG $+1
$SG171515 DB	'E', 00H
	ORG $+2
$SG171379 DB	'qeth.c:441', 00H
	ORG $+1
$SG171535 DB	'I', 00H
	ORG $+2
$SG171380 DB	'qeth.c:446', 00H
	ORG $+1
$SG171539 DB	'W', 00H
	ORG $+2
$SG171390 DB	'qeth.c:463', 00H
	ORG $+1
$SG171569 DB	'I', 00H
	ORG $+2
$SG171391 DB	'qeth.c:471', 00H
	ORG $+1
$SG171573 DB	'E', 00H
	ORG $+2
$SG171412 DB	'%02x:%02x:%02x:%02x:%02x:%02x', 00H
	ORG $+2
$SG171414 DB	'HHC03801%s %1d:%04X %s: %s: Register guest MAC address %'
	DB	's', 0aH, 00H
	ORG $+1
$SG171591 DB	'I', 00H
	ORG $+2
$SG171415 DB	'register_mac', 00H
	ORG $+3
$SG171417 DB	'%02x:%02x:%02x:%02x:%02x:%02x', 00H
	ORG $+2
$SG171419 DB	'HHC03802%s %1d:%04X %s: %s: Cannot register guest MAC ad'
	DB	'dress %s', 0aH, 00H
	ORG $+2
$SG171421 DB	'qeth.c', 00H
	ORG $+1
$SG171595 DB	'W', 00H
	ORG $+2
$SG171420 DB	'register_mac', 00H
	ORG $+3
$SG171443 DB	'%02x:%02x:%02x:%02x:%02x:%02x', 00H
	ORG $+2
$SG171445 DB	'HHC03803%s %1d:%04X %s: %s: Unregister guest MAC address'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG171446 DB	'unregister_mac', 00H
	ORG $+1
$SG171447 DB	'qeth.c', 00H
	ORG $+1
$SG171449 DB	'%02x:%02x:%02x:%02x:%02x:%02x', 00H
	ORG $+2
$SG171452 DB	'unregister_mac', 00H
	ORG $+1
$SG171453 DB	'qeth.c', 00H
	ORG $+1
$SG171451 DB	'HHC03804%s %1d:%04X %s: %s: Cannot unregister guest MAC '
	DB	'address %s', 0aH, 00H
$SG171760 DB	'E', 00H
	ORG $+2
$SG171512 DB	'HHC03805%s %1d:%04X %s: %s: Register guest IP address %s'
	DB	0aH, 00H
	ORG $+2
$SG171514 DB	'qeth.c', 00H
	ORG $+1
$SG171761 DB	'E', 00H
	ORG $+2
$SG171513 DB	'register_ipv4', 00H
	ORG $+2
$SG171516 DB	'HHC03806%s %1d:%04X %s: %s: Cannot register guest IP add'
	DB	'ress %s', 0aH, 00H
	ORG $+3
$SG171518 DB	'qeth.c', 00H
	ORG $+1
$SG171767 DB	'W', 00H
	ORG $+2
$SG171517 DB	'register_ipv4', 00H
	ORG $+2
$SG171536 DB	'HHC03807%s %1d:%04X %s: %s: Unregister guest IP address '
	DB	'%s', 0aH, 00H
$SG171768 DB	'W', 00H
	ORG $+2
$SG171537 DB	'unregister_ipv4', 00H
$SG171538 DB	'qeth.c', 00H
	ORG $+1
$SG171541 DB	'unregister_ipv4', 00H
$SG171542 DB	'qeth.c', 00H
	ORG $+1
$SG171540 DB	'HHC03808%s %1d:%04X %s: %s: Cannot unregister guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+1
$SG171772 DB	'I', 00H
	ORG $+2
$SG171570 DB	'HHC03805%s %1d:%04X %s: %s: Register guest IP address %s'
	DB	0aH, 00H
	ORG $+2
$SG171572 DB	'qeth.c', 00H
	ORG $+1
$SG171786 DB	'I', 00H
	ORG $+2
$SG171571 DB	'register_ipv6', 00H
	ORG $+2
$SG171574 DB	'HHC03806%s %1d:%04X %s: %s: Cannot register guest IP add'
	DB	'ress %s', 0aH, 00H
	ORG $+3
$SG171576 DB	'qeth.c', 00H
	ORG $+1
$SG171792 DB	'I', 00H
	ORG $+2
$SG171575 DB	'register_ipv6', 00H
	ORG $+2
$SG171592 DB	'HHC03807%s %1d:%04X %s: %s: Unregister guest IP address '
	DB	'%s', 0aH, 00H
$SG171798 DB	'I', 00H
	ORG $+2
$SG171593 DB	'unregister_ipv6', 00H
$SG171594 DB	'qeth.c', 00H
	ORG $+1
$SG171597 DB	'unregister_ipv6', 00H
$SG171598 DB	'qeth.c', 00H
	ORG $+1
$SG171596 DB	'HHC03808%s %1d:%04X %s: %s: Cannot unregister guest IP a'
	DB	'ddress %s', 0aH, 00H
	ORG $+1
$SG171804 DB	'I', 00H
	ORG $+2
$SG171642 DB	'qeth.c:857', 00H
	ORG $+1
$SG171810 DB	'I', 00H
	ORG $+2
$SG171643 DB	'b4 select', 00H
	ORG $+2
$SG171644 DB	'qeth.c', 00H
	ORG $+1
$SG171815 DB	'MTU', 00H
$SG171649 DB	'qeth.c:875', 00H
	ORG $+1
$SG171816 DB	'I', 00H
	ORG $+2
$SG171650 DB	'af select', 00H
	ORG $+2
$SG171764 DB	'qeth.c', 00H
	ORG $+1
$SG171822 DB	'I', 00H
	ORG $+2
$SG171682 DB	'qeth.c:881', 00H
	ORG $+1
$SG171827 DB	'I', 00H
	ORG $+2
$SG171683 DB	'b4 rdpipe', 00H
	ORG $+2
$SG171771 DB	'qeth.c', 00H
	ORG $+1
$SG171844 DB	'E', 00H
	ORG $+2
$SG171688 DB	'qeth.c:893', 00H
	ORG $+1
$SG171858 DB	'E', 00H
	ORG $+2
$SG171689 DB	'af rdpipe', 00H
	ORG $+2
$SG171775 DB	'qeth.c', 00H
	ORG $+1
$SG171916 DB	'E', 00H
	ORG $+2
$SG171722 DB	'qeth.c:899', 00H
	ORG $+1
$SG171917 DB	'TUN', 00H
$SG171723 DB	'b4 wrpipe', 00H
	ORG $+2
$SG171789 DB	'qeth.c', 00H
	ORG $+1
$SG171918 DB	'TAP', 00H
$SG171728 DB	'qeth.c:911', 00H
	ORG $+1
$SG171919 DB	'I', 00H
	ORG $+2
$SG171729 DB	'af wrpipe', 00H
	ORG $+2
$SG171795 DB	'qeth.c', 00H
	ORG $+1
$SG171927 DB	'W', 00H
	ORG $+2
$SG171753 DB	'An unidentified error has occurred', 00H
	ORG $+1
$SG171949 DB	'W', 00H
	ORG $+2
$SG171756 DB	'%s() at %s(%d): ', 00H
	ORG $+3
$SG171801 DB	'qeth.c', 00H
	ORG $+1
$SG171957 DB	'E', 00H
	ORG $+2
$SG171757 DB	'%s%s, rc=%d (0x%08X): %s', 00H
	ORG $+3
$SG171807 DB	'qeth.c', 00H
	ORG $+1
$SG171964 DB	'E', 00H
	ORG $+2
$SG171762 DB	'HHC03996%s %1d:%04X %s: %s: %s', 0aH, 00H
$SG171763 DB	'qeth_errnum_msg', 00H
$SG171769 DB	'HHC03996%s %1d:%04X %s: %s: %s', 0aH, 00H
$SG171770 DB	'qeth_errnum_msg', 00H
$SG171773 DB	'HHC03996%s %1d:%04X %s: %s: %s', 0aH, 00H
$SG171774 DB	'qeth_errnum_msg', 00H
$SG171784 DB	'not ', 00H
	ORG $+3
$SG171785 DB	'MAC address', 00H
$SG171970 DB	'E', 00H
	ORG $+2
$SG171787 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG171976 DB	'E', 00H
	ORG $+2
$SG171788 DB	'qeth_report_using', 00H
	ORG $+2
$SG171813 DB	'qeth.c', 00H
	ORG $+1
$SG171982 DB	'E', 00H
	ORG $+2
$SG171791 DB	'IP address', 00H
	ORG $+1
$SG172175 DB	'W', 00H
	ORG $+2
$SG171793 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG172179 DB	'???', 00H
$SG171794 DB	'qeth_report_using', 00H
	ORG $+2
$SG171819 DB	'qeth.c', 00H
	ORG $+1
$SG172190 DB	'E', 00H
	ORG $+2
$SG171797 DB	'subnet mask', 00H
$SG172201 DB	'W', 00H
	ORG $+2
$SG171799 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG172205 DB	'???', 00H
$SG171800 DB	'qeth_report_using', 00H
	ORG $+2
$SG171825 DB	'qeth.c', 00H
	ORG $+1
$SG172280 DB	'E', 00H
	ORG $+2
$SG171803 DB	'IP address', 00H
	ORG $+1
$SG172357 DB	'E', 00H
	ORG $+2
$SG171805 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG172467 DB	'On', 00H
	ORG $+1
$SG171806 DB	'qeth_report_using', 00H
	ORG $+2
$SG171830 DB	'qeth.c', 00H
	ORG $+1
$SG172468 DB	'Off', 00H
$SG171809 DB	'prefix length', 00H
	ORG $+2
$SG171811 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG172501 DB	'W', 00H
	ORG $+2
$SG171812 DB	'qeth_report_using', 00H
	ORG $+2
$SG171841 DB	'qeth.c', 00H
	ORG $+1
$SG172505 DB	'???', 00H
$SG171817 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG172549 DB	'W', 00H
	ORG $+2
$SG171818 DB	'qeth_report_using', 00H
	ORG $+2
$SG171855 DB	'qeth.c', 00H
	ORG $+1
$SG172603 DB	'E', 00H
	ORG $+2
$SG171821 DB	'drive MAC address', 00H
	ORG $+2
$SG171902 DB	'qeth.c', 00H
	ORG $+1
$SG172706 DB	'E', 00H
	ORG $+2
$SG171823 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG172766 DB	'E', 00H
	ORG $+2
$SG171824 DB	'qeth_report_using', 00H
	ORG $+2
$SG171905 DB	'qeth.c', 00H
	ORG $+1
$SG172929 DB	'ARP', 00H
$SG171826 DB	'drive IP address', 00H
	ORG $+3
$SG171909 DB	'qeth.c', 00H
	ORG $+1
$SG172935 DB	'SNA', 00H
$SG171828 DB	'HHC03997%s %1d:%04X %s: %s: %susing %s %s', 0aH, 00H
	ORG $+1
$SG172937 DB	'D', 00H
	ORG $+2
$SG171829 DB	'qeth_report_using', 00H
	ORG $+2
$SG171913 DB	'qeth.c', 00H
	ORG $+1
$SG172981 DB	'D', 00H
	ORG $+2
$SG171842 DB	'qeth_enable_interface', 00H
	ORG $+2
$SG171843 DB	'qeth_enable_interface() failed', 00H
	ORG $+1
$SG171856 DB	'qeth_disable_interface', 00H
	ORG $+1
$SG171857 DB	'qeth_disable_interface() failed', 00H
$SG171900 DB	'ERROR: TUNTAP Interface already exists!', 00H
$SG171901 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171904 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171908 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171906 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171914 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171910 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171915 DB	'TUNTAP_CreateInterface() failed', 00H
$SG171920 DB	'HHC00901%s %1d:%04X %s: Interface %s, type %s opened', 0aH
	DB	00H
	ORG $+2
$SG171921 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171922 DB	'qeth.c', 00H
	ORG $+1
$SG171924 DB	'qeth.c', 00H
	ORG $+1
$SG171925 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171926 DB	'socket_set_blocking_mode() failed', 00H
	ORG $+2
$SG171930 DB	'qeth.c', 00H
	ORG $+1
$SG173035 DB	'D', 00H
	ORG $+2
$SG171929 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171933 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171931 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171934 DB	'qeth.c', 00H
	ORG $+1
$SG171935 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171938 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171939 DB	'qeth.c', 00H
	ORG $+1
$SG171942 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171940 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171943 DB	'qeth.c', 00H
	ORG $+1
$SG171944 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG171951 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171950 DB	'HHC03809%s %1d:%04X %s: %s: Requested MTU %s too large; '
	DB	'decreasing to %s bytes', 0aH, 00H
$SG171952 DB	'qeth.c', 00H
	ORG $+1
$SG171953 DB	'TUNTAP_SetMTU(%s) failed', 00H
	ORG $+3
$SG171955 DB	'qeth.c', 00H
	ORG $+1
$SG173100 DB	'W', 00H
	ORG $+2
$SG171956 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171961 DB	'TUNTAP_SetMACAddr(%s) failed', 00H
	ORG $+3
$SG171962 DB	'qeth.c', 00H
	ORG $+1
$SG171963 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171967 DB	'TUNTAP_SetDestAddr("%s") failed', 00H
$SG171968 DB	'qeth.c', 00H
	ORG $+1
$SG171969 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171973 DB	'TUNTAP_SetNetMask(%s) failed', 00H
	ORG $+3
$SG171974 DB	'qeth.c', 00H
	ORG $+1
$SG171975 DB	'qeth_create_interface', 00H
	ORG $+2
$SG171979 DB	'TUNTAP_SetIPAddr6(%s) failed', 00H
	ORG $+3
$SG171980 DB	'qeth.c', 00H
	ORG $+1
$SG171981 DB	'qeth_create_interface', 00H
	ORG $+2
$SG172164 DB	'RRH_TYPE_CM', 00H
$SG173105 DB	'D', 00H
	ORG $+2
$SG172166 DB	': PUK_TYPE_ENABLE (CM_ENABLE)', 00H
	ORG $+2
$SG172168 DB	': PUK_TYPE_SETUP (CM_SETUP)', 00H
$SG173110 DB	'D', 00H
	ORG $+2
$SG172170 DB	': PUK_TYPE_TAKEDOWN (CM_TAKEDOWN)', 00H
	ORG $+2
$SG172178 DB	'qeth.c', 00H
	ORG $+1
$SG173134 DB	'W', 00H
	ORG $+2
$SG172172 DB	': PUK_TYPE_DISABLE (CM_DISABLE)', 00H
$SG172174 DB	'Unknown PUK_TYPE_xxx (CM Unknown)', 00H
	ORG $+2
$SG172187 DB	'qeth.c', 00H
	ORG $+1
$SG173139 DB	'D', 00H
	ORG $+2
$SG172176 DB	'HHC03991%s %1d:%04X %s: %s', 0aH, 00H
$SG173156 DB	'ARP', 00H
$SG172177 DB	'osa_adapter_cmd', 00H
$SG172181 DB	'RRH_TYPE_ULP', 00H
	ORG $+3
$SG172183 DB	': PUK_TYPE_ENABLE (ULP_ENABLE)', 00H
	ORG $+1
$SG172188 DB	'osa_adapter_cmd', 00H
$SG172189 DB	'qeth_create_interface() failed', 00H
	ORG $+1
$SG172192 DB	': PUK_TYPE_SETUP (ULP_SETUP)', 00H
	ORG $+3
$SG172194 DB	': PUK_TYPE_ACTIVE (ULP_ACTIVE)', 00H
	ORG $+1
$SG172196 DB	': PUK_TYPE_TAKEDOWN (ULP_TAKEDOWN)', 00H
	ORG $+1
$SG173162 DB	'SNA', 00H
$SG172198 DB	': PUK_TYPE_DISABLE (ULP_DISABLE)', 00H
	ORG $+3
$SG172204 DB	'qeth.c', 00H
	ORG $+1
$SG173164 DB	'D', 00H
	ORG $+2
$SG172200 DB	'Unknown PUK_TYPE_xxx (ULP Unknown)', 00H
	ORG $+1
$SG173176 DB	'D', 00H
	ORG $+2
$SG172202 DB	'HHC03991%s %1d:%04X %s: %s', 0aH, 00H
$SG173312 DB	'W', 00H
	ORG $+2
$SG172203 DB	'osa_adapter_cmd', 00H
$SG172207 DB	'RRH_TYPE_IPA', 00H
	ORG $+3
$SG172211 DB	' (IPv4)', 00H
$SG172214 DB	' (IPv6)', 00H
$SG172217 DB	': IPA_CMD_STARTLAN', 00H
	ORG $+1
$SG173725 DB	'128', 00H
$SG172218 DB	'%s: Request', 00H
$SG173728 DB	'mtu', 00H
$SG172219 DB	'osa_adapter_cmd', 00H
$SG172220 DB	'qeth.c', 00H
	ORG $+1
$SG172222 DB	'osa_adapter_cmd', 00H
$SG172223 DB	'qeth.c', 00H
	ORG $+1
$SG172224 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172226 DB	'osa_adapter_cmd', 00H
$SG172227 DB	'qeth.c', 00H
	ORG $+1
$SG172228 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172231 DB	': IPA_CMD_STOPLAN', 00H
	ORG $+2
$SG172234 DB	'qeth.c', 00H
	ORG $+1
$SG173747 DB	'E', 00H
	ORG $+2
$SG172232 DB	'%s: Request', 00H
$SG173754 DB	'E', 00H
	ORG $+2
$SG172233 DB	'osa_adapter_cmd', 00H
$SG172236 DB	'osa_adapter_cmd', 00H
$SG172237 DB	'qeth.c', 00H
	ORG $+1
$SG172238 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172240 DB	'osa_adapter_cmd', 00H
$SG172241 DB	'qeth.c', 00H
	ORG $+1
$SG172242 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172245 DB	': IPA_CMD_SETVMAC', 00H
	ORG $+2
$SG172248 DB	'qeth.c', 00H
	ORG $+1
$SG173760 DB	'E', 00H
	ORG $+2
$SG172246 DB	'%s: Request', 00H
$SG173769 DB	'E', 00H
	ORG $+2
$SG172247 DB	'osa_adapter_cmd', 00H
$SG172254 DB	'%02x:%02x:%02x:%02x:%02x:%02x', 00H
	ORG $+2
$SG172257 DB	'osa_adapter_cmd', 00H
$SG172258 DB	'qeth.c', 00H
	ORG $+1
$SG172259 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172261 DB	'osa_adapter_cmd', 00H
$SG172262 DB	'qeth.c', 00H
	ORG $+1
$SG172263 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172268 DB	'osa_adapter_cmd', 00H
$SG172269 DB	'qeth.c', 00H
	ORG $+1
$SG172270 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172272 DB	'osa_adapter_cmd', 00H
$SG172273 DB	'qeth.c', 00H
	ORG $+1
$SG172274 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172277 DB	'IPA_CMD_SETVMAC(%s,%s) failed', 00H
	ORG $+2
$SG172278 DB	'qeth.c', 00H
	ORG $+1
$SG172279 DB	'osa_adapter_cmd', 00H
$SG172282 DB	': IPA_CMD_DELVMAC', 00H
	ORG $+2
$SG172285 DB	'qeth.c', 00H
	ORG $+1
$SG173777 DB	'E', 00H
	ORG $+2
$SG172283 DB	'%s: Request', 00H
$SG173785 DB	'32', 00H
	ORG $+1
$SG172284 DB	'osa_adapter_cmd', 00H
$SG172289 DB	': IPA_CMD_SETGMAC', 00H
	ORG $+2
$SG172292 DB	'qeth.c', 00H
	ORG $+1
$SG173790 DB	'E', 00H
	ORG $+2
$SG172290 DB	'%s: Request', 00H
$SG173798 DB	'W', 00H
	ORG $+2
$SG172291 DB	'osa_adapter_cmd', 00H
$SG172298 DB	': IPA_CMD_DELGMAC', 00H
	ORG $+2
$SG172301 DB	'qeth.c', 00H
	ORG $+1
$SG173806 DB	'E', 00H
	ORG $+2
$SG172299 DB	'%s: Request', 00H
$SG173814 DB	'W', 00H
	ORG $+2
$SG172300 DB	'osa_adapter_cmd', 00H
$SG172305 DB	': IPA_CMD_SETVLAN', 00H
	ORG $+2
$SG172308 DB	'qeth.c', 00H
	ORG $+1
$SG173822 DB	'E', 00H
	ORG $+2
$SG172306 DB	'%s: Request', 00H
$SG173832 DB	'E', 00H
	ORG $+2
$SG172307 DB	'osa_adapter_cmd', 00H
$SG172310 DB	': IPA_CMD_DELVLAN', 00H
	ORG $+2
$SG172313 DB	'qeth.c', 00H
	ORG $+1
$SG173838 DB	'mtu', 00H
$SG172311 DB	'%s: Request', 00H
$SG173839 DB	'E', 00H
	ORG $+2
$SG172312 DB	'osa_adapter_cmd', 00H
$SG172315 DB	': IPA_CMD_SETIP', 00H
$SG172316 DB	'%s: Request', 00H
$SG173849 DB	'E', 00H
	ORG $+2
$SG172317 DB	'osa_adapter_cmd', 00H
$SG172318 DB	'qeth.c', 00H
	ORG $+1
$SG172321 DB	'%d.%d.%d.%d', 00H
$SG173876 DB	'OSA', 00H
$SG172322 DB	'%d.%d.%d.%d', 00H
$SG173882 DB	'.', 00H
	ORG $+2
$SG172335 DB	'osa_adapter_cmd', 00H
$SG172336 DB	'qeth.c', 00H
	ORG $+1
$SG172337 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172339 DB	'osa_adapter_cmd', 00H
$SG172340 DB	'qeth.c', 00H
	ORG $+1
$SG172341 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172345 DB	'osa_adapter_cmd', 00H
$SG172346 DB	'qeth.c', 00H
	ORG $+1
$SG172347 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172349 DB	'osa_adapter_cmd', 00H
$SG172350 DB	'qeth.c', 00H
	ORG $+1
$SG172351 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG172354 DB	'TUNTAP_SetDestAddr(%s) failed', 00H
	ORG $+2
$SG172355 DB	'qeth.c', 00H
	ORG $+1
$SG172356 DB	'osa_adapter_cmd', 00H
$SG172366 DB	': IPA_CMD_QIPASSIST', 00H
$SG173885 DB	' ', 00H
	ORG $+2
$SG172367 DB	'%s: Request', 00H
$SG174420 DB	'D', 00H
	ORG $+2
$SG172368 DB	'osa_adapter_cmd', 00H
$SG172369 DB	'qeth.c', 00H
	ORG $+1
$SG172371 DB	' 0x%08X', 00H
$SG172372 DB	': IPA_CMD_SETASSPARMS', 00H
	ORG $+2
$SG172374 DB	': START', 00H
$SG172376 DB	': STOP', 00H
	ORG $+1
$SG172378 DB	': CONFIGURE', 00H
$SG174436 DB	'END', 00H
$SG172380 DB	': ENABLE', 00H
	ORG $+3
$SG172392 DB	'qeth.c', 00H
	ORG $+1
$SG174439 DB	'???', 00H
$SG172382 DB	': CMD_0005', 00H
	ORG $+1
$SG174470 DB	'END', 00H
$SG172384 DB	': CMD_0006', 00H
	ORG $+1
$SG174473 DB	'???', 00H
$SG172386 DB	': CMD_0008', 00H
	ORG $+1
$SG174496 DB	'SID', 00H
$SG172388 DB	' (0x%04X)', 00H
	ORG $+2
$SG172412 DB	'qeth.c', 00H
	ORG $+1
$SG174497 DB	'D', 00H
	ORG $+2
$SG172389 DB	': NOT SUPPORTED', 00H
$SG172390 DB	'%s: Request', 00H
$SG174504 DB	'RCD', 00H
$SG172391 DB	'osa_adapter_cmd', 00H
$SG172409 DB	': IPA_CMD_SETIPM', 00H
	ORG $+3
$SG172417 DB	'qeth.c', 00H
	ORG $+1
$SG174505 DB	'D', 00H
	ORG $+2
$SG172410 DB	'%s: Request', 00H
$SG174515 DB	'SII', 00H
$SG172411 DB	'osa_adapter_cmd', 00H
$SG172414 DB	': IPA_CMD_DELIPM', 00H
	ORG $+3
$SG172422 DB	'qeth.c', 00H
	ORG $+1
$SG174523 DB	'RNI', 00H
$SG172415 DB	'%s: Request', 00H
$SG174524 DB	'D', 00H
	ORG $+2
$SG172416 DB	'osa_adapter_cmd', 00H
$SG172419 DB	': IPA_CMD_SETRTG', 00H
	ORG $+3
$SG172427 DB	'qeth.c', 00H
	ORG $+1
$SG174604 DB	'W', 00H
	ORG $+2
$SG172420 DB	'%s: Request', 00H
$SG174631 DB	'D', 00H
	ORG $+2
$SG172421 DB	'osa_adapter_cmd', 00H
$SG172424 DB	': IPA_CMD_DELIP', 00H
$SG172425 DB	'%s: Request', 00H
$SG175096 DB	'I', 00H
	ORG $+2
$SG172426 DB	'osa_adapter_cmd', 00H
$SG172439 DB	': IPA_CMD_SETADPPARMS', 00H
	ORG $+2
$SG172441 DB	': QUERY', 00H
$SG172443 DB	': SETMAC', 00H
	ORG $+3
$SG172445 DB	': READ', 00H
	ORG $+1
$SG175317 DB	'E', 00H
	ORG $+2
$SG172447 DB	' (0x%08X)', 00H
	ORG $+2
$SG172460 DB	'qeth.c', 00H
	ORG $+1
$SG175451 DB	'%d', 00H
	ORG $+1
$SG172448 DB	': NOT SUPPORTED', 00H
$SG172450 DB	': CARDINFO', 00H
	ORG $+1
$SG175625 DB	'OSA', 00H
$SG172452 DB	': PROMISC', 00H
	ORG $+2
$SG172471 DB	'qeth.c', 00H
	ORG $+1
$SG175626 DB	'OSD', 00H
$SG172454 DB	': SETACCESS', 00H
	ORG $+4
$SG172456 DB	' (0x%08X)', 00H
	ORG $+6
$SG172457 DB	': NOT SUPPORTED', 00H
$SG172458 DB	'%s: Request', 00H
	ORG $+4
$SG172459 DB	'osa_adapter_cmd', 00H
$SG172469 DB	'  IPA_SAP_PROMISC %s', 00H
	ORG $+3
$SG172470 DB	'osa_adapter_cmd', 00H
$SG172475 DB	': IPA_CMD_SETDIAGASS', 00H
	ORG $+3
$SG172476 DB	'%s: Request', 00H
	ORG $+4
$SG172477 DB	'osa_adapter_cmd', 00H
$SG172478 DB	'qeth.c', 00H
	ORG $+1
$SG172480 DB	': IPA_CMD_CREATEADDR', 00H
	ORG $+3
$SG172481 DB	'%s: Request', 00H
	ORG $+4
$SG172482 DB	'osa_adapter_cmd', 00H
$SG172483 DB	'qeth.c', 00H
	ORG $+1
$SG172485 DB	' (0x%02X)', 00H
	ORG $+6
$SG172486 DB	': NOT SUPPORTED', 00H
$SG172487 DB	'%s: Request', 00H
	ORG $+4
$SG172488 DB	'osa_adapter_cmd', 00H
$SG172489 DB	'qeth.c', 00H
	ORG $+1
$SG172500 DB	'Unknown RHH_TYPE_xxx', 00H
	ORG $+3
$SG172502 DB	'HHC03991%s %1d:%04X %s: %s', 0aH, 00H
	ORG $+4
$SG172503 DB	'osa_adapter_cmd', 00H
$SG172504 DB	'qeth.c', 00H
	ORG $+1
$SG172530 DB	'IDX_ACT_TYPE_READ', 00H
	ORG $+6
$SG172531 DB	'%s: Request', 00H
	ORG $+4
$SG172532 DB	'osa_device_cmd', 00H
	ORG $+1
$SG172533 DB	'qeth.c', 00H
	ORG $+1
$SG172535 DB	'IDX_ACT_TYPE_READ: Invalid OSA Port %d', 00H
	ORG $+1
$SG172536 DB	'osa_device_cmd', 00H
	ORG $+1
$SG172537 DB	'qeth.c', 00H
	ORG $+1
$SG172539 DB	'IDX_ACT_TYPE_WRITE', 00H
	ORG $+5
$SG172540 DB	'%s: Request', 00H
	ORG $+4
$SG172541 DB	'osa_device_cmd', 00H
	ORG $+1
$SG172542 DB	'qeth.c', 00H
	ORG $+1
$SG172544 DB	'IDX_ACT_TYPE_WRITE: Invalid OSA Port %d', 00H
$SG172545 DB	'osa_device_cmd', 00H
	ORG $+1
$SG172546 DB	'qeth.c', 00H
	ORG $+1
$SG172548 DB	'Unknown IDX_ACT_TYPE_xxx', 00H
	ORG $+7
$SG172550 DB	'HHC03991%s %1d:%04X %s: %s', 0aH, 00H
	ORG $+4
$SG172551 DB	'osa_device_cmd', 00H
	ORG $+1
$SG172552 DB	'qeth.c', 00H
	ORG $+1
$SG172553 DB	'IEA?', 00H
	ORG $+3
$SG172571 DB	'qeth.c:2522', 00H
	ORG $+4
$SG172572 DB	'qeth.c:2525', 00H
	ORG $+4
$SG172574 DB	'Adapter Interrupt', 00H
	ORG $+6
$SG172575 DB	'raise_adapter_interrupt', 00H
$SG172576 DB	'qeth.c', 00H
	ORG $+1
$SG172577 DB	'qeth.c:2534', 00H
	ORG $+4
$SG172578 DB	'qeth.c:2536', 00H
	ORG $+4
$SG172579 DB	'qeth.c:2539', 00H
	ORG $+4
$SG172580 DB	'qeth.c:2541', 00H
	ORG $+4
$SG172581 DB	'qeth.c:2543', 00H
	ORG $+4
$SG172604 DB	'HHC03985%s %1d:%04X %s: %s', 0aH, 00H
	ORG $+4
$SG172605 DB	'SBALE_Error', 00H
$SG172606 DB	'qeth.c', 00H
	ORG $+5
$SG172698 DB	'qeth.c:2737', 00H
	ORG $+4
$SG172699 DB	'rdpack entr', 00H
	ORG $+4
$SG172704 DB	'qeth.c:2746', 00H
	ORG $+4
$SG172705 DB	'rdpack exit', 00H
	ORG $+4
$SG172707 DB	'HHC00912%s %1d:%04X %s: Error reading from device %s: %d'
	DB	' %s', 0aH, 00H
	ORG $+3
$SG172708 DB	'read_packet', 00H
$SG172709 DB	'qeth.c', 00H
	ORG $+5
$SG172711 DB	'qeth.c:2755', 00H
	ORG $+4
$SG172712 DB	'rdpack exit', 00H
	ORG $+4
$SG172715 DB	'qeth.c:2763', 00H
	ORG $+4
$SG172716 DB	'rdpack exit', 00H
	ORG $+4
$SG172718 DB	'qeth.c:2770', 00H
	ORG $+4
$SG172719 DB	'rdpack exit', 00H
	ORG $+4
$SG172760 DB	'qeth.c:2783', 00H
	ORG $+4
$SG172761 DB	'wrpack entr', 00H
	ORG $+4
$SG172764 DB	'qeth.c:2790', 00H
	ORG $+4
$SG172765 DB	'wrpack exit', 00H
	ORG $+4
$SG172767 DB	'HHC00911%s %1d:%04X %s: Error writing to device %s: %d %'
	DB	's', 0aH, 00H
	ORG $+5
$SG172768 DB	'write_packet', 00H
	ORG $+3
$SG172769 DB	'qeth.c', 00H
	ORG $+1
$SG172771 DB	'qeth.c:2798', 00H
	ORG $+4
$SG172772 DB	'wrpack exit', 00H
$SG172885 DB	'qeth.c', 00H
	ORG $+5
$SG172807 DB	'** QRC_ENOSPC **: SBAL(%d) @ %llx [%02X]: Addr: %llx Len'
	DB	': %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+3
$SG172884 DB	'copy_packet_to_storage', 00H
	ORG $+1
$SG172811 DB	'** QRC_EZEROBLK **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG172923 DB	'IPv4', 00H
	ORG $+3
$SG172813 DB	'** QRC_ESTORCHK **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG172926 DB	'IPv6', 00H
	ORG $+3
$SG172840 DB	'** QRC_EPKSBLEN **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG172932 DB	'RARP', 00H
	ORG $+3
$SG172843 DB	'** QRC_ENOSPC **: SBAL(%d) @ %llx [%02X]: Addr: %llx Len'
	DB	': %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+3
$SG172936 DB	'unknown', 00H
$SG172845 DB	'** QRC_EZEROBLK **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG172939 DB	'read_L2_packets', 00H
$SG172940 DB	'qeth.c', 00H
	ORG $+1
$SG172847 DB	'** QRC_ESTORCHK **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG172883 DB	'Input SBALE(%d): flag: %02X Len: %04X (%d)', 00H
	ORG $+1
$SG172941 DB	'L2 hdr', 00H
	ORG $+5
$SG172938 DB	'HHC00986%s %1d:%04X %s: Receive frame of size %d bytes ('
	DB	'with %s packet) from device %s', 0aH, 00H
$SG172942 DB	'Frame ', 00H
	ORG $+1
$SG172973 DB	' IPv4', 00H
	ORG $+2
$SG172977 DB	' IPv6', 00H
	ORG $+2
$SG172982 DB	'HHC00913%s %1d:%04X %s: Receive%s packet of size %d byte'
	DB	's from device %s', 0aH, 00H
	ORG $+6
$SG172983 DB	'read_L3_packets', 00H
$SG172984 DB	'qeth.c', 00H
	ORG $+1
$SG172985 DB	'Packet', 00H
	ORG $+1
$SG173024 DB	' IPv4', 00H
	ORG $+2
$SG173028 DB	' IPv6', 00H
	ORG $+2
$SG173034 DB	'layer 3 response', 00H
	ORG $+7
$SG173037 DB	'read_l3r_buffers', 00H
	ORG $+7
$SG173036 DB	'HHC00913%s %1d:%04X %s: Receive%s packet of size %d byte'
	DB	's from device %s', 0aH, 00H
	ORG $+2
$SG173038 DB	'qeth.c', 00H
	ORG $+1
$SG173039 DB	'Packet', 00H
	ORG $+5
$SG173095 DB	'** QRC_EZEROBLK **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG173099 DB	'** FIXME ** OSA_HDR spans multiple storage blocks.', 00H
	ORG $+5
$SG173097 DB	'** QRC_ESTORCHK **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG173101 DB	'HHC03983%s %1d:%04X %s: %s', 0aH, 00H
	ORG $+4
$SG173102 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173103 DB	'qeth.c', 00H
	ORG $+1
$SG173107 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173106 DB	'HHC00981%s %1d:%04X %s: Accept data of size %d bytes fro'
	DB	'm guest', 0aH, 00H
	ORG $+3
$SG173108 DB	'qeth.c', 00H
	ORG $+5
$SG173111 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG173112 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173113 DB	'qeth.c', 00H
	ORG $+1
$SG173114 DB	'data', 00H
	ORG $+3
$SG173125 DB	'Output SBALE(%d-%d): Len: %04X (%d)', 00H
	ORG $+4
$SG173120 DB	'** QRC_EPKTYP **: SBAL(%d) @ %llx [%02X]: Addr: %llx Len'
	DB	': %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+3
$SG173126 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173122 DB	'** QRC_EPKSIZ **: SBAL(%d) @ %llx [%02X]: Addr: %llx Len'
	DB	': %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+3
$SG173127 DB	'qeth.c', 00H
	ORG $+1
$SG173133 DB	'L2 frame on tun device', 00H
	ORG $+1
$SG173135 DB	'HHC03811%s %1d:%04X %s: %s: Output dropped: %s', 0aH, 00H
$SG173136 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173137 DB	'qeth.c', 00H
	ORG $+1
$SG173141 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173140 DB	'HHC00980%s %1d:%04X %s: Data of size %d bytes displayed,'
	DB	' data of size %d bytes not displayed', 0aH, 00H
	ORG $+2
$SG173142 DB	'qeth.c', 00H
	ORG $+1
$SG173143 DB	'drop', 00H
	ORG $+3
$SG173150 DB	'IPv4', 00H
	ORG $+3
$SG173153 DB	'IPv6', 00H
	ORG $+3
$SG173159 DB	'RARP', 00H
	ORG $+3
$SG173163 DB	'unknown', 00H
$SG173165 DB	'HHC00985%s %1d:%04X %s: Send frame of size %d bytes (wit'
	DB	'h %s packet) to device %s', 0aH, 00H
	ORG $+5
$SG173166 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173167 DB	'qeth.c', 00H
	ORG $+1
$SG173168 DB	'Frame ', 00H
	ORG $+1
$SG173171 DB	' IPv4', 00H
	ORG $+2
$SG173174 DB	' IPv6', 00H
	ORG $+2
$SG173175 DB	' ????', 00H
	ORG $+2
$SG173178 DB	'write_buffered_packets', 00H
	ORG $+1
$SG173177 DB	'HHC00910%s %1d:%04X %s: Send%s packet of size %d bytes t'
	DB	'o device %s', 0aH, 00H
	ORG $+3
$SG173179 DB	'qeth.c', 00H
	ORG $+1
$SG173180 DB	'Packet', 00H
	ORG $+1
$SG173279 DB	'STORCHK Error SBALA(%llx), Key(%2.2X)', 00H
	ORG $+2
$SG173186 DB	'** QRC_ESBNOEOF **: SBAL(%d) @ %llx [%02X]: Addr: %llx L'
	DB	'en: %d flags[0,3]: %2.2X %2.2X', 00H
	ORG $+1
$SG173273 DB	'qeth.c:3558', 00H
	ORG $+4
$SG173274 DB	'prinq entr', 00H
	ORG $+5
$SG173280 DB	'process_input_queues', 00H
	ORG $+3
$SG173281 DB	'qeth.c', 00H
	ORG $+1
$SG173289 DB	'Input Queue(%d) Buffer(%d)', 00H
	ORG $+5
$SG173290 DB	'process_input_queues', 00H
	ORG $+3
$SG173291 DB	'qeth.c', 00H
	ORG $+1
$SG173293 DB	'qeth.c:3613', 00H
	ORG $+4
$SG173294 DB	'prinq OK', 00H
	ORG $+7
$SG173297 DB	'qeth.c:3621', 00H
	ORG $+4
$SG173298 DB	'*prcinq EOF', 00H
	ORG $+4
$SG173301 DB	'qeth.c:3634', 00H
	ORG $+4
$SG173302 DB	'*prcinq ERR', 00H
	ORG $+4
$SG173308 DB	'qeth.c:3671', 00H
	ORG $+4
$SG173309 DB	'*prcinq drop', 00H
	ORG $+3
$SG173311 DB	'No available buffers', 00H
	ORG $+3
$SG173313 DB	'HHC03810%s %1d:%04X %s: %s: Input dropped: %s', 0aH, 00H
	ORG $+1
$SG173314 DB	'process_input_queues', 00H
	ORG $+3
$SG173315 DB	'qeth.c', 00H
	ORG $+1
$SG173317 DB	'qeth.c:3683', 00H
	ORG $+4
$SG173318 DB	'prinq exit', 00H
	ORG $+5
$SG173385 DB	'qeth.c:3699', 00H
	ORG $+4
$SG173386 DB	'proutq entr', 00H
	ORG $+4
$SG173390 DB	'Output Queue(%d) Buffer(%d)', 00H
	ORG $+4
$SG173391 DB	'process_output_queues', 00H
	ORG $+2
$SG173392 DB	'qeth.c', 00H
	ORG $+1
$SG173395 DB	'STORCHK Error SBALA(%llx), Key(%2.2X)', 00H
	ORG $+2
$SG173396 DB	'process_output_queues', 00H
	ORG $+2
$SG173397 DB	'qeth.c', 00H
	ORG $+1
$SG173401 DB	'qeth.c:3751', 00H
	ORG $+4
$SG173402 DB	'*proutq ERR', 00H
	ORG $+4
$SG173407 DB	'qeth.c:3772', 00H
	ORG $+4
$SG173408 DB	'*proutq EOF', 00H
	ORG $+4
$SG173410 DB	'qeth.c:3774', 00H
	ORG $+4
$SG173411 DB	'proutq exit', 00H
	ORG $+4
$SG173436 DB	'qeth.c:3784', 00H
	ORG $+4
$SG173438 DB	'Halting read device', 00H
	ORG $+4
$SG173439 DB	'qeth_halt_read_device', 00H
	ORG $+2
$SG173440 DB	'qeth.c', 00H
	ORG $+1
$SG173442 DB	'qeth.c:3792', 00H
	ORG $+4
$SG173443 DB	'b4 halt read', 00H
	ORG $+3
$SG173444 DB	'qeth.c:3794', 00H
	ORG $+4
$SG173445 DB	'qeth.c:3795', 00H
	ORG $+4
$SG173447 DB	'qeth.c:3796', 00H
	ORG $+4
$SG173448 DB	'af halt read', 00H
	ORG $+3
$SG173449 DB	'Read device halted', 00H
	ORG $+5
$SG173450 DB	'qeth_halt_read_device', 00H
	ORG $+2
$SG173451 DB	'qeth.c', 00H
	ORG $+1
$SG173452 DB	'qeth.c:3801', 00H
	ORG $+4
$SG173484 DB	'qeth.c:3806', 00H
	ORG $+4
$SG173486 DB	'Halting data device', 00H
	ORG $+4
$SG173487 DB	'qeth_halt_data_device', 00H
	ORG $+2
$SG173488 DB	'qeth.c', 00H
	ORG $+1
$SG173490 DB	'qeth.c:3816', 00H
	ORG $+4
$SG173491 DB	'b4 halt data', 00H
	ORG $+3
$SG173493 DB	'qeth_halt_data_device', 00H
	ORG $+2
$SG173494 DB	'qeth.c', 00H
	ORG $+1
$SG173495 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173497 DB	'qeth_halt_data_device', 00H
	ORG $+2
$SG173498 DB	'qeth.c', 00H
	ORG $+1
$SG173505 DB	'Data device halted', 00H
	ORG $+5
$SG173499 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173501 DB	'qeth.c:3818', 00H
	ORG $+4
$SG173503 DB	'qeth.c:3820', 00H
	ORG $+4
$SG173504 DB	'af halt data', 00H
	ORG $+3
$SG173506 DB	'qeth_halt_data_device', 00H
	ORG $+2
$SG173507 DB	'qeth.c', 00H
	ORG $+1
$SG173508 DB	'qeth.c:3825', 00H
	ORG $+4
$SG173528 DB	'qeth_halt_or_clear: noop!', 00H
	ORG $+6
$SG173529 DB	'qeth_halt_or_clear', 00H
	ORG $+1
$SG173530 DB	'qeth.c', 00H
	ORG $+5
$SG173532 DB	'qeth.c:3846', 00H
	ORG $+4
$SG173533 DB	'*halt noop', 00H
	ORG $+5
$SG173669 DB	'qeth.c:3938', 00H
	ORG $+4
$SG173670 DB	'qeth.c:3939', 00H
	ORG $+4
$SG173671 DB	'qeth.c:3941', 00H
	ORG $+4
$SG173672 DB	'&grp->qlock', 00H
	ORG $+4
$SG173673 DB	'&grp->qlock %1d:%04X', 00H
	ORG $+3
$SG173674 DB	'qeth.c:3945', 00H
	ORG $+4
$SG173675 DB	'&grp->idx.lockbhr', 00H
	ORG $+6
$SG173676 DB	'&grp->idx.lockbhr %1d:%04X', 00H
	ORG $+5
$SG173677 DB	'qeth.c:3949', 00H
	ORG $+4
$SG173678 DB	'&grp->l3r.lockbhr', 00H
	ORG $+6
$SG173679 DB	'&grp->l3r.lockbhr %1d:%04X', 00H
	ORG $+5
$SG173681 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173682 DB	'qeth.c', 00H
	ORG $+5
$SG173683 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173685 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173686 DB	'qeth.c', 00H
	ORG $+5
$SG173690 DB	'qeth_init_handler', 00H
	ORG $+6
$SG173687 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173691 DB	'qeth.c', 00H
	ORG $+1
$SG173692 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173694 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173695 DB	'qeth.c', 00H
	ORG $+5
$SG173699 DB	'qeth_init_handler', 00H
	ORG $+6
$SG173696 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173700 DB	'qeth.c', 00H
	ORG $+1
$SG173701 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173703 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173704 DB	'qeth.c', 00H
	ORG $+1
$SG173709 DB	'iface', 00H
	ORG $+6
$SG173705 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG173712 DB	'hwaddr', 00H
	ORG $+1
$SG173715 DB	'ipaddr', 00H
	ORG $+1
$SG173719 DB	'netmask', 00H
$SG173722 DB	'ipaddr6', 00H
$SG173731 DB	'chpid', 00H
	ORG $+2
$SG173734 DB	'debug', 00H
	ORG $+2
$SG173737 DB	'debugpacket', 00H
	ORG $+4
$SG173740 DB	'debugdata', 00H
	ORG $+6
$SG173743 DB	'debugupdown', 00H
	ORG $+4
$SG173746 DB	'nodebug', 00H
$SG173748 DB	'HHC00918%s %1d:%04X %s: Option %s unknown or specified i'
	DB	'ncorrectly', 0aH, 00H
	ORG $+4
$SG173749 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173750 DB	'qeth.c', 00H
	ORG $+1
$SG173753 DB	'ipaddr', 00H
	ORG $+5
$SG173755 DB	'HHC00917%s %1d:%04X %s: Required parameter ''%s'' missin'
	DB	'g', 0aH, 00H
	ORG $+7
$SG173756 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173757 DB	'qeth.c', 00H
	ORG $+5
$SG173759 DB	'netmask', 00H
$SG173761 DB	'HHC00917%s %1d:%04X %s: Required parameter ''%s'' missin'
	DB	'g', 0aH, 00H
	ORG $+7
$SG173762 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173763 DB	'qeth.c', 00H
	ORG $+1
$SG173768 DB	'hwaddr', 00H
	ORG $+5
$SG173770 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173771 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173772 DB	'qeth.c', 00H
	ORG $+1
$SG173776 DB	'ipaddr', 00H
	ORG $+5
$SG173778 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173779 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173780 DB	'qeth.c', 00H
	ORG $+5
$SG173784 DB	'255.255.255.255', 00H
$SG173789 DB	'netmask', 00H
$SG173791 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173792 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173793 DB	'qeth.c', 00H
	ORG $+5
$SG173796 DB	'netmask', 00H
$SG173797 DB	'prefix length', 00H
	ORG $+2
$SG173799 DB	'HHC03998%s %1d:%04X %s: %s inconsistent with %s', 0aH, 00H
	ORG $+7
$SG173800 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173801 DB	'qeth.c', 00H
	ORG $+1
$SG173805 DB	'ipaddr', 00H
	ORG $+5
$SG173807 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173808 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173809 DB	'qeth.c', 00H
	ORG $+5
$SG173812 DB	'prefix length', 00H
	ORG $+2
$SG173813 DB	'netmask', 00H
$SG173815 DB	'HHC03998%s %1d:%04X %s: %s inconsistent with %s', 0aH, 00H
	ORG $+7
$SG173816 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173817 DB	'qeth.c', 00H
	ORG $+5
$SG173821 DB	'ipaddr6', 00H
$SG173823 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173824 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173825 DB	'qeth.c', 00H
	ORG $+5
$SG173831 DB	'ipaddr6', 00H
$SG173833 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173834 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173835 DB	'qeth.c', 00H
	ORG $+5
$SG173840 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173841 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173842 DB	'qeth.c', 00H
	ORG $+1
$SG173847 DB	'%x%c', 00H
	ORG $+3
$SG173848 DB	'chpid', 00H
	ORG $+6
$SG173850 DB	'HHC00916%s %1d:%04X %s: Option %s value %s invalid', 0aH
	DB	00H
	ORG $+4
$SG173851 DB	'qeth_init_handler', 00H
	ORG $+2
$SG173852 DB	'qeth.c', 00H
	ORG $+5
$SG173887 DB	' dr[%u]', 00H
$SG173888 DB	'%stx[%u] rx[%u]%s ', 00H
	ORG $+5
$SG173890 DB	'*Incomplete ', 00H
	ORG $+3
$SG173893 DB	'IDX ', 00H
	ORG $+3
$SG173894 DB	'debug ', 00H
	ORG $+1
$SG173897 DB	'QDIO %s%s%s%sIO[%llu]', 00H
	ORG $+2
$SG174034 DB	'qeth.c:4438', 00H
	ORG $+4
$SG174035 DB	'b4 clos halt', 00H
	ORG $+3
$SG174040 DB	'qeth.c:4447', 00H
	ORG $+4
$SG174041 DB	'af clos halt', 00H
	ORG $+3
$SG174043 DB	'qeth.c:4449', 00H
	ORG $+4
$SG174044 DB	'b4 clos ttfd', 00H
	ORG $+3
$SG174047 DB	'qeth.c:4454', 00H
	ORG $+4
$SG174048 DB	'af clos ttfd', 00H
	ORG $+3
$SG174050 DB	'qeth.c:4456', 00H
	ORG $+4
$SG174051 DB	'b4 clos pipe', 00H
	ORG $+3
$SG174055 DB	'qeth.c:4461', 00H
	ORG $+4
$SG174056 DB	'af clos pipe', 00H
	ORG $+3
$SG174058 DB	'qeth.c:4463', 00H
	ORG $+4
$SG174059 DB	'b4 clos othr', 00H
	ORG $+3
$SG174061 DB	'qeth.c:4475', 00H
	ORG $+4
$SG174062 DB	'af clos othr', 00H
	ORG $+3
$SG174064 DB	'qeth.c:4477', 00H
	ORG $+4
$SG174065 DB	'b4 clos fbuf', 00H
	ORG $+3
$SG174067 DB	'qeth.c:4479', 00H
	ORG $+4
$SG174068 DB	'af clos fbuf', 00H
	ORG $+3
$SG174069 DB	'qeth.c:4483', 00H
	ORG $+4
$SG174070 DB	'qeth.c:4484', 00H
	ORG $+4
$SG174071 DB	'qeth.c:4485', 00H
	ORG $+4
$SG174073 DB	'qeth.c:4487', 00H
	ORG $+4
$SG174074 DB	'b4 clos fgrp', 00H
	ORG $+3
$SG174076 DB	'qeth.c:4490', 00H
	ORG $+4
$SG174077 DB	'af clos fgrp', 00H
	ORG $+3
$SG174421 DB	'HHC03992%s %1d:%04X %s: Code %02X: Flags %02X: Count %08'
	DB	'X: Chained %02X: PrevCode %02X: CCWseq %d', 0aH, 00H
	ORG $+5
$SG174422 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174423 DB	'qeth.c', 00H
	ORG $+5
$SG174433 DB	'qeth.c:4658', 00H
	ORG $+4
$SG174434 DB	'shut notify', 00H
	ORG $+4
$SG174435 DB	'Shutdown Notify', 00H
$SG174437 DB	'Unrecognised Request', 00H
	ORG $+3
$SG174442 DB	'qeth.c:4716', 00H
	ORG $+4
$SG174443 DB	'read entr', 00H
	ORG $+6
$SG174445 DB	'qeth.c:4721', 00H
	ORG $+4
$SG174446 DB	'b4 rd rmbuf', 00H
	ORG $+4
$SG174448 DB	'qeth.c:4723', 00H
	ORG $+4
$SG174449 DB	'af rd rmbuf', 00H
	ORG $+4
$SG174455 DB	'%s: Response', 00H
	ORG $+3
$SG174456 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174457 DB	'qeth.c', 00H
	ORG $+5
$SG174460 DB	'%s: Response', 00H
	ORG $+3
$SG174461 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174462 DB	'qeth.c', 00H
	ORG $+5
$SG174467 DB	'qeth.c:4768', 00H
	ORG $+4
$SG174468 DB	'shut ack', 00H
	ORG $+7
$SG174469 DB	'Shutdown Acknowledge', 00H
	ORG $+3
$SG174471 DB	'Unrecognised Response', 00H
	ORG $+2
$SG174475 DB	'qeth.c:4801', 00H
	ORG $+4
$SG174477 DB	'qeth.c:4802', 00H
	ORG $+4
$SG174478 DB	'read wait', 00H
	ORG $+6
$SG174479 DB	'qeth.c:4803', 00H
	ORG $+4
$SG174480 DB	'qeth.c:4804', 00H
	ORG $+4
$SG174482 DB	'qeth.c:4810', 00H
	ORG $+4
$SG174484 DB	'qeth.c:4811', 00H
	ORG $+4
$SG174485 DB	'read hlt ack', 00H
	ORG $+3
$SG174486 DB	'qeth.c:4813', 00H
	ORG $+4
$SG174487 DB	'qeth.c:4814', 00H
	ORG $+4
$SG174489 DB	'qeth.c:4817', 00H
	ORG $+4
$SG174490 DB	'read exit', 00H
	ORG $+6
$SG174498 DB	'HHC03995%s %1d:%04X %s: %s:', 0aH, '%s', 0aH, 00H
$SG174499 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174500 DB	'qeth.c', 00H
	ORG $+5
$SG174506 DB	'HHC03995%s %1d:%04X %s: %s:', 0aH, '%s', 0aH, 00H
$SG174507 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174508 DB	'qeth.c', 00H
	ORG $+5
$SG174525 DB	'HHC03995%s %1d:%04X %s: %s:', 0aH, '%s', 0aH, 00H
$SG174526 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174527 DB	'qeth.c', 00H
	ORG $+5
$SG174529 DB	'Establish Queues: Entry', 00H
$SG174530 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174531 DB	'qeth.c', 00H
	ORG $+5
$SG174533 DB	'qeth.c:5058', 00H
	ORG $+4
$SG174534 DB	'eq entry', 00H
	ORG $+7
$SG174536 DB	'QDIO_QDR', 00H
	ORG $+7
$SG174543 DB	'qeth.c:5134', 00H
	ORG $+4
$SG174544 DB	'eq exit', 00H
$SG174546 DB	'qeth.c:5141', 00H
	ORG $+4
$SG174547 DB	'*eq exit', 00H
	ORG $+7
$SG174548 DB	'Establish Queues: Exit', 00H
	ORG $+1
$SG174549 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174550 DB	'qeth.c', 00H
	ORG $+5
$SG174552 DB	'Activate Queues: Entry iqm=%8.8x oqm=%8.8x', 00H
	ORG $+5
$SG174553 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174554 DB	'qeth.c', 00H
	ORG $+5
$SG174556 DB	'qeth.c:5170', 00H
	ORG $+4
$SG174557 DB	'actq entr', 00H
	ORG $+6
$SG174560 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174561 DB	'qeth.c', 00H
	ORG $+5
$SG174564 DB	'qeth_execute_ccw', 00H
	ORG $+7
$SG174562 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174565 DB	'qeth.c', 00H
	ORG $+1
$SG174566 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174570 DB	'Activate Queues: %s received', 00H
	ORG $+3
$SG174571 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174572 DB	'qeth.c', 00H
	ORG $+5
$SG174581 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174582 DB	'qeth.c', 00H
	ORG $+5
$SG174585 DB	'qeth_execute_ccw', 00H
	ORG $+7
$SG174583 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174586 DB	'qeth.c', 00H
	ORG $+1
$SG174587 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174596 DB	'qeth.c:5230', 00H
	ORG $+4
$SG174597 DB	'actq iqPCI', 00H
	ORG $+5
$SG174600 DB	'qeth.c:5240', 00H
	ORG $+4
$SG174601 DB	'*actq drop', 00H
	ORG $+5
$SG174603 DB	'No available queues', 00H
	ORG $+4
$SG174605 DB	'HHC03810%s %1d:%04X %s: %s: Input dropped: %s', 0aH, 00H
	ORG $+1
$SG174606 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174607 DB	'qeth.c', 00H
	ORG $+5
$SG174611 DB	'qeth.c:5263', 00H
	ORG $+4
$SG174612 DB	'actq oqPCI', 00H
	ORG $+5
$SG174614 DB	'qeth.c:5269', 00H
	ORG $+4
$SG174615 DB	'actq break', 00H
	ORG $+5
$SG174617 DB	'qeth.c:5274', 00H
	ORG $+4
$SG174618 DB	'qeth.c:5277', 00H
	ORG $+4
$SG174619 DB	'qeth.c:5279', 00H
	ORG $+4
$SG174620 DB	'Activate Queues: Exit', 00H
	ORG $+2
$SG174621 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174622 DB	'qeth.c', 00H
	ORG $+5
$SG174624 DB	'qeth.c:5283', 00H
	ORG $+4
$SG174625 DB	'actq exit', 00H
	ORG $+6
$SG174627 DB	'Unknown CCW opcode 0x%02X)', 00H
	ORG $+5
$SG174628 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174629 DB	'qeth.c', 00H
	ORG $+5
$SG174632 DB	'HHC03993%s %1d:%04X %s: Status %02X: Residual %08X: More'
	DB	' %02X', 0aH, 00H
	ORG $+1
$SG174633 DB	'qeth_execute_ccw', 00H
	ORG $+3
$SG174634 DB	'qeth.c', 00H
	ORG $+5
$SG174670 DB	'qeth.c:5329', 00H
	ORG $+4
$SG174671 DB	'initq entry', 00H
$SG174674 DB	'Output', 00H
	ORG $+1
$SG174675 DB	'Input', 00H
	ORG $+6
$SG174676 DB	'Initialize %s Queue: qmask(0x%08X)', 00H
	ORG $+5
$SG174677 DB	'qeth_init_queue', 00H
$SG174678 DB	'qeth.c', 00H
	ORG $+1
$SG174680 DB	'qeth.c:5349', 00H
	ORG $+4
$SG174681 DB	'initq exit', 00H
	ORG $+5
$SG174722 DB	'SIGA-r qmask(%8.8x)', 00H
	ORG $+4
$SG174723 DB	'qeth_initiate_input', 00H
$SG174724 DB	'qeth.c', 00H
	ORG $+5
$SG174726 DB	'qeth.c:5364', 00H
	ORG $+4
$SG174727 DB	'b4 SIGA-r', 00H
	ORG $+6
$SG174730 DB	'SIGA-r: ERROR: QDIO not active', 00H
	ORG $+1
$SG174731 DB	'qeth_initiate_input', 00H
$SG174732 DB	'qeth.c', 00H
	ORG $+5
$SG174738 DB	'SIGA-r: sending %s', 00H
	ORG $+5
$SG174739 DB	'qeth_initiate_input', 00H
$SG174740 DB	'qeth.c', 00H
	ORG $+5
$SG174742 DB	'qeth_initiate_input', 00H
$SG174743 DB	'qeth.c', 00H
	ORG $+5
$SG174746 DB	'qeth_initiate_input', 00H
	ORG $+4
$SG174744 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174747 DB	'qeth.c', 00H
	ORG $+1
$SG174748 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174751 DB	'qeth.c:5404', 00H
	ORG $+4
$SG174752 DB	'af SIGA-r', 00H
	ORG $+6
$SG174779 DB	'SIGA-o: sending %s', 00H
	ORG $+5
$SG174780 DB	'qeth_do_initiate_output', 00H
$SG174781 DB	'qeth.c', 00H
	ORG $+1
$SG174783 DB	'qeth_do_initiate_output', 00H
$SG174784 DB	'qeth.c', 00H
	ORG $+1
$SG174785 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174787 DB	'qeth_do_initiate_output', 00H
$SG174788 DB	'qeth.c', 00H
	ORG $+1
$SG174819 DB	'SIGA-w qmask(%8.8x)', 00H
	ORG $+4
$SG174789 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG174820 DB	'qeth_initiate_output', 00H
	ORG $+3
$SG174821 DB	'qeth.c', 00H
	ORG $+1
$SG174823 DB	'qeth.c:5458', 00H
	ORG $+4
$SG174824 DB	'b4 SIGA-w', 00H
	ORG $+6
$SG174826 DB	'SIGA-w: ERROR: QDIO not active', 00H
	ORG $+1
$SG174827 DB	'qeth_initiate_output', 00H
	ORG $+3
$SG174828 DB	'qeth.c', 00H
	ORG $+1
$SG174830 DB	'qeth.c:5463', 00H
	ORG $+4
$SG174831 DB	'af SIGA-w', 00H
	ORG $+6
$SG174860 DB	'SIGA-m qmask(%8.8x)', 00H
	ORG $+4
$SG174861 DB	'qeth_initiate_output_mult', 00H
	ORG $+2
$SG174862 DB	'qeth.c', 00H
	ORG $+5
$SG174864 DB	'qeth.c:5477', 00H
	ORG $+4
$SG174865 DB	'b4 SIGA-m', 00H
	ORG $+6
$SG174867 DB	'SIGA-m: ERROR: QDIO not active', 00H
	ORG $+1
$SG174868 DB	'qeth_initiate_output_mult', 00H
	ORG $+2
$SG174869 DB	'qeth.c', 00H
	ORG $+5
$SG174871 DB	'qeth.c:5482', 00H
	ORG $+4
$SG174872 DB	'af SIGA-m', 00H
	ORG $+6
$SG174901 DB	'SIGA-s dev(%4.4x) oqmask(%8.8x), iqmask(%8.8x)', 00H
	ORG $+1
$SG174902 DB	'qeth_do_sync', 00H
	ORG $+3
$SG174903 DB	'qeth.c', 00H
	ORG $+1
$SG174905 DB	'qeth.c:5504', 00H
	ORG $+4
$SG174906 DB	'b4 SIGA-s', 00H
	ORG $+6
$SG174909 DB	'SIGA-s: ERROR: QDIO not active', 00H
	ORG $+1
$SG174910 DB	'qeth_do_sync', 00H
	ORG $+3
$SG174911 DB	'qeth.c', 00H
	ORG $+1
$SG174913 DB	'qeth.c:5527', 00H
	ORG $+4
$SG174914 DB	'af SIGA-s', 00H
	ORG $+6
$SG174958 DB	'%s: Request', 00H
	ORG $+4
$SG174959 DB	'process_cm_enable', 00H
	ORG $+2
$SG174960 DB	'qeth.c', 00H
	ORG $+5
$SG174963 DB	'process_cm_enable: Expected pus not present', 00H
	ORG $+4
$SG174964 DB	'process_cm_enable', 00H
	ORG $+2
$SG174965 DB	'qeth.c', 00H
	ORG $+5
$SG175013 DB	'%s: Request', 00H
	ORG $+4
$SG175014 DB	'process_cm_setup', 00H
	ORG $+3
$SG175015 DB	'qeth.c', 00H
	ORG $+5
$SG175018 DB	'process_cm_setup: Expected pus not present', 00H
	ORG $+5
$SG175019 DB	'process_cm_setup', 00H
	ORG $+3
$SG175020 DB	'qeth.c', 00H
	ORG $+5
$SG175043 DB	'%s: Request', 00H
	ORG $+4
$SG175044 DB	'process_cm_takedown', 00H
$SG175045 DB	'qeth.c', 00H
	ORG $+5
$SG175067 DB	'%s: Request', 00H
	ORG $+4
$SG175068 DB	'process_cm_disable', 00H
	ORG $+1
$SG175069 DB	'qeth.c', 00H
	ORG $+5
$SG175086 DB	'%s: Request', 00H
	ORG $+4
$SG175087 DB	'process_ulp_enable_extract', 00H
	ORG $+1
$SG175088 DB	'qeth.c', 00H
	ORG $+5
$SG175091 DB	'process_ulp_enable_extract: Expected pus not present', 00H
	ORG $+3
$SG175092 DB	'process_ulp_enable_extract', 00H
	ORG $+1
$SG175093 DB	'qeth.c', 00H
	ORG $+5
$SG175094 DB	'Layer 3', 00H
$SG175095 DB	'Layer 2', 00H
$SG175097 DB	'HHC03800%s %1d:%04X %s: Adapter mode set to %s', 0aH, 00H
$SG175098 DB	'process_ulp_enable_extract', 00H
	ORG $+1
$SG175099 DB	'qeth.c', 00H
	ORG $+5
$SG175150 DB	'process_ulp_enable: Expected pus not present', 00H
	ORG $+3
$SG175151 DB	'process_ulp_enable', 00H
	ORG $+1
$SG175152 DB	'qeth.c', 00H
	ORG $+5
$SG175206 DB	'%s: Request', 00H
	ORG $+4
$SG175207 DB	'process_ulp_setup', 00H
	ORG $+2
$SG175208 DB	'qeth.c', 00H
	ORG $+5
$SG175211 DB	'process_ulp_setup: Expected pus not present', 00H
	ORG $+4
$SG175212 DB	'process_ulp_setup', 00H
	ORG $+2
$SG175213 DB	'qeth.c', 00H
	ORG $+5
$SG175255 DB	'%s: Request', 00H
	ORG $+4
$SG175256 DB	'process_dm_act', 00H
	ORG $+1
$SG175257 DB	'qeth.c', 00H
	ORG $+1
$SG175280 DB	'%s: Request', 00H
	ORG $+4
$SG175281 DB	'process_ulp_takedown', 00H
	ORG $+3
$SG175282 DB	'qeth.c', 00H
	ORG $+1
$SG175301 DB	'%s: Request', 00H
	ORG $+4
$SG175302 DB	'process_ulp_disable', 00H
$SG175303 DB	'qeth.c', 00H
	ORG $+5
$SG175316 DB	'malloc(%n)', 00H
	ORG $+5
$SG175318 DB	'HHC00900%s %1d:%04X %s: Error in function %s: %s', 0aH, 00H
	ORG $+6
$SG175319 DB	'alloc_buffer', 00H
	ORG $+3
$SG175320 DB	'qeth.c', 00H
	ORG $+1
$SG175328 DB	'qeth.c:6285', 00H
	ORG $+4
$SG175331 DB	'qeth.c:6302', 00H
	ORG $+4
$SG175338 DB	'qeth.c:6313', 00H
	ORG $+4
$SG175341 DB	'qeth.c:6333', 00H
	ORG $+4
$SG175353 DB	'qeth.c:6346', 00H
	ORG $+4
$SG175354 DB	'qeth.c:6363', 00H
	ORG $+4
$SG175358 DB	'qeth.c:6372', 00H
	ORG $+4
$SG175359 DB	'qeth.c:6373', 00H
	ORG $+4
$SG175360 DB	'qeth.c:6374', 00H
	ORG $+4
$SG175398 DB	'** WARNING ** TUNTAP_GetMACAddr() failed! Using default.'
	DB	00H
	ORG $+7
$SG175399 DB	'InitMACAddr', 00H
$SG175400 DB	'qeth.c', 00H
	ORG $+5
$SG175402 DB	'InitMACAddr', 00H
$SG175403 DB	'qeth.c', 00H
	ORG $+5
$SG175406 DB	'InitMACAddr', 00H
$SG175407 DB	'qeth.c', 00H
	ORG $+5
$SG175404 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG175412 DB	'%02x:%02x:%02x:%02x:%02x:%02x', 00H
	ORG $+2
$SG175431 DB	'** WARNING ** TUNTAP_GetMTU() failed! Using default.', 00H
	ORG $+3
$SG175408 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG175413 DB	'%02x:%02x:%02x:%02x:%02x:%02x', 00H
	ORG $+2
$SG175432 DB	'InitMTU', 00H
$SG175433 DB	'qeth.c', 00H
	ORG $+1
$SG175434 DB	'1500', 00H
	ORG $+3
$SG175449 DB	'255.255.255.255', 00H
$SG175522 DB	'process_l3_icmpv6_packet', 00H
	ORG $+3
$SG175523 DB	'qeth.c', 00H
	ORG $+1
$SG175527 DB	'qeth.c', 00H
	ORG $+5
$SG175524 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG175526 DB	'process_l3_icmpv6_packet', 00H
	ORG $+3
$SG175601 DB	'DEVBLK', 00H
	ORG $+5
$SG175528 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG175603 DB	'SDL 4.2', 00H
qeth_device_hndinfo DQ FLAT:qeth_init_handler
	DQ	FLAT:qeth_execute_ccw
	DQ	FLAT:qeth_close_device
	DQ	FLAT:qeth_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:qeth_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:qeth_immed_commands
	DQ	FLAT:qeth_initiate_input
	DQ	FLAT:qeth_initiate_output
	DQ	FLAT:qeth_do_sync
	DQ	FLAT:qeth_initiate_output_mult
	DQ	FLAT:qeth_ssqd_desc
	DQ	FLAT:qeth_set_sci
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG175597 DB	'SDL 4.60', 00H
	ORG $+7
$SG175598 DB	'HERCULES', 00H
	ORG $+7
$SG175600 DB	'SDL 4.00', 00H
	ORG $+3
$SG175604 DB	'SYSBLK', 00H
	ORG $+5
$SG175618 DB	'debug_tt32_stats', 00H
	ORG $+7
$SG175619 DB	'debug_tt32_tracing', 00H
	ORG $+1
$SG175624 DB	'QETH', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:qeth_execute_ccw
	DD	02cH
	DD	028ddH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:qeth_query_device
	DD	026H
	DD	03d3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:qeth_init_handler
	DD	021H
	DD	0206eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:qeth_read_configuration_data
	DD	022H
	DD	01caH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_input_queues
	DD	01cH
	DD	0835H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:write_buffered_packets
	DD	025H
	DD	01075H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:read_l3r_buffers
	DD	027H
	DD	0562H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:read_L3_packets
	DD	027H
	DD	0532H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:read_L2_packets
	DD	026H
	DD	0540H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:more_packets
	DD	01cH
	DD	091H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:SBALE_Error
	DD	026H
	DD	0228H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:osa_adapter_cmd
	DD	022H
	DD	0379eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:qeth_create_interface
	DD	01bH
	DD	0ac9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:qeth_report_using
	DD	01bH
	DD	09c3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:qeth_errnum_msg
	DD	026H
	DD	047eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:unregister_ipv6
	DD	021H
	DD	02f0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:register_ipv6
	DD	022H
	DD	0332H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:unregister_ipv4
	DD	021H
	DD	0310H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:register_ipv4
	DD	020H
	DD	0346H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:unregister_mac
	DD	026H
	DD	042dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:register_mac
	DD	027H
	DD	045cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:calculate_icmpv6_checksum
	DD	022H
	DD	024bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:process_l3_icmpv6_packet
	DD	022H
	DD	03acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:netmask2prefix
	DD	018H
	DD	0100H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:InitMACAddr
	DD	01dH
	DD	05b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:alloc_buffer
	DD	01bH
	DD	0185H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dbgupd
	DD	024H
	DD	022aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:dbgtrc
	DD	024H
	DD	015eH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_dev_4K_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_dev_4K_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_dev_storage_key DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__get_dev_storage_key DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_dev_storekey_ptr DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$store_f3_noswap DD 020b01H
	DD	0600a700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_f3_noswap DD 030b01H
	DD	07007220bH
	DD	06006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Try_Obtain_Interrupt_Lock DD 010e01H
	DD	0620eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$dbgtrc DD 022c19H
	DD	031011aH
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$dbgupd DD 022c19H
	DD	031011aH
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$process_cm_enable DD 021b01H
	DD	019011bH
$unwind$process_cm_setup DD 021b01H
	DD	019011bH
$unwind$process_cm_takedown DD 011801H
	DD	0c218H
$unwind$process_cm_disable DD 011801H
	DD	0c218H
$unwind$process_ulp_enable_extract DD 021b01H
	DD	013011bH
$unwind$process_ulp_enable DD 041d01H
	DD	017011dH
	DD	060157016H
$unwind$process_ulp_setup DD 041d01H
	DD	01b011dH
	DD	060157016H
$unwind$process_dm_act DD 021b01H
	DD	015011bH
$unwind$process_ulp_takedown DD 011801H
	DD	0c218H
$unwind$process_ulp_disable DD 011801H
	DD	0c218H
$unwind$alloc_buffer DD 032319H
	DD	0180111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$add_buffer_to_chain DD 010e01H
	DD	0420eH
$unwind$remove_buffer_from_chain DD 010901H
	DD	06209H
$unwind$remove_and_free_any_buffers_on_chain DD 010901H
	DD	06209H
$unwind$signal_idx_event DD 010901H
	DD	04209H
$unwind$InitMACAddr DD 042519H
	DD	0170113H
	DD	0600b700cH
	DD	imagerel __GSHandlerCheck
	DD	0a8H
$unwind$InitMTU DD 010e01H
	DD	0820eH
$unwind$netmask2prefix DD 011d19H
	DD	0a20eH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$prefix2netmask DD 010e01H
	DD	0620eH
$unwind$makepfxmask4 DD 010901H
	DD	06209H
$unwind$makepfxmask6 DD 020f01H
	DD	0700b720fH
$unwind$qeth_init_queues DD 010901H
	DD	04209H
$unwind$qeth_init_queue DD 010d01H
	DD	0c20dH
$unwind$process_l3_icmpv6_packet DD 042a19H
	DD	0130118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$calculate_icmpv6_checksum DD 042719H
	DD	0110118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	070H
$unwind$qsig2str DD 010801H
	DD	04208H
$unwind$qeth_storage_access_check DD 011801H
	DD	08218H
$unwind$qeth_storage_access_check_and_update DD 011801H
	DD	08218H
$unwind$set_alsi DD 010d01H
	DD	0620dH
$unwind$set_dsci DD 010d01H
	DD	0620dH
$unwind$register_mac DD 042f19H
	DD	017011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$unregister_mac DD 032e19H
	DD	016011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$unregister_all_mac DD 020a01H
	DD	07006120aH
$unwind$validate_mac DD 011201H
	DD	06212H
$unwind$tt32_multiple_ip_support DD 010401H
	DD	08204H
$unwind$register_ipv4 DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$unregister_ipv4 DD 032919H
	DD	0180117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$unregister_all_ipv4 DD 020a01H
	DD	07006120aH
$unwind$register_ipv6 DD 042a19H
	DD	0190118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$unregister_ipv6 DD 032919H
	DD	0180117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$unregister_all_ipv6 DD 020a01H
	DD	07006120aH
$unwind$qeth_select DD 011201H
	DD	0a212H
$unwind$qeth_read_pipe DD 010d01H
	DD	0a20dH
$unwind$qeth_write_pipe DD 010d01H
	DD	0a20dH
$unwind$qeth_errnum_msg DD 032e19H
	DD	074011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0390H
$unwind$qeth_report_using DD 022319H
	DD	0250111H
	DD	imagerel __GSHandlerCheck
	DD	0110H
$unwind$qeth_enable_interface DD 010e01H
	DD	0a20eH
$unwind$qeth_disable_interface DD 010e01H
	DD	0a20eH
$unwind$qeth_create_interface DD 022319H
	DD	02b0111H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$osa_adapter_cmd DD 042a19H
	DD	07f0118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	03e0H
$unwind$osa_device_cmd DD 041801H
	DD	0130118H
	DD	060107011H
$unwind$raise_adapter_interrupt DD 010901H
	DD	08209H
$unwind$SBALE_Error DD 032e19H
	DD	032011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$l3_cast_type_ipv4 DD 010e01H
	DD	0620eH
$unwind$l3_cast_type_ipv6 DD 010e01H
	DD	0620eH
$unwind$more_packets DD 022419H
	DD	040b0112H
	DD	imagerel __GSHandlerCheck
	DD	02040H
$unwind$read_packet DD 021101H
	DD	0150111H
$unwind$write_packet DD 021b01H
	DD	015011bH
$unwind$copy_fragment_to_storage DD 031a01H
	DD	07016a21aH
	DD	06015H
$unwind$copy_storage_fragments DD 031a01H
	DD	07016a21aH
	DD	06015H
$unwind$copy_packet_to_storage DD 011801H
	DD	0e218H
$unwind$read_L2_packets DD 032e19H
	DD	01a011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0c8H
$unwind$read_L3_packets DD 042f19H
	DD	01d011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
$unwind$read_l3r_buffers DD 042f19H
	DD	01f011dH
	DD	060157016H
	DD	imagerel __GSHandlerCheck
	DD	0e8H
$unwind$write_buffered_packets DD 022d19H
	DD	02b011bH
	DD	imagerel __GSHandlerCheck
	DD	0148H
$unwind$process_input_queues DD 022419H
	DD	021d0112H
	DD	imagerel __GSHandlerCheck
	DD	010d0H
$unwind$process_output_queues DD 020c01H
	DD	013010cH
$unwind$qeth_halt_read_device DD 010e01H
	DD	0820eH
$unwind$qeth_halt_data_device DD 010e01H
	DD	0a20eH
$unwind$qeth_halt_or_clear DD 010901H
	DD	0a209H
$unwind$qeth_read_configuration_data DD 042a19H
	DD	0190118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$qeth_init_handler DD 042919H
	DD	06d0117H
	DD	0600f7010H
	DD	imagerel __GSHandlerCheck
	DD	0358H
$unwind$qeth_query_device DD 032e19H
	DD	04e011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$qeth_close_device DD 010901H
	DD	0c209H
$unwind$qeth_set_sci DD 010e01H
	DD	0a20eH
$unwind$qeth_ssqd_desc DD 010e01H
	DD	0620eH
$unwind$qeth_execute_ccw DD 043419H
	DD	05df0122H
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	02ee0H
$unwind$qeth_initiate_input DD 010d01H
	DD	0e20dH
$unwind$qeth_do_initiate_output DD 011201H
	DD	0a212H
$unwind$qeth_initiate_output DD 010d01H
	DD	0a20dH
$unwind$qeth_initiate_output_mult DD 010d01H
	DD	0a20dH
$unwind$qeth_do_sync DD 011201H
	DD	0a212H
$unwind$hdl_check_depends_ep DD 030b01H
	DD	07007620bH
	DD	06006H
$unwind$hdl_register_symbols_ep DD 010901H
	DD	04209H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 6880 : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6881 : {
; 6882 :     HDL_DEVICE ( QETH, qeth_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:qeth_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175624
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 6883 :     HDL_DEVICE ( OSA,  qeth_device_hndinfo );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:qeth_device_hndinfo
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175625
  00029	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 6884 :     HDL_DEVICE ( OSD,  qeth_device_hndinfo );

  0002d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:qeth_device_hndinfo
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175626
  0003b	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 6885 : }
; 6886 : END_DEVICE_SECTION

  0003f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00043	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
regsym$ = 48
hdl_register_symbols_ep PROC

; 6864 : HDL_REGISTER_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6865 : {
; 6866 : //               Hercules's          Our
; 6867 : //               registered          overriding
; 6868 : //               entry-point         entry-point
; 6869 : //               name                value
; 6870 : #if defined( WIN32 )
; 6871 :   HDL_REGISTER ( debug_tt32_stats,   display_tt32_stats        );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:display_tt32_stats
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175618
  00017	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 6872 :   HDL_REGISTER ( debug_tt32_tracing, enable_tt32_debug_tracing );

  0001b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:enable_tt32_debug_tracing
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175619
  00029	ff 54 24 30	 call	 QWORD PTR regsym$[rsp]

; 6873 : #else
; 6874 :   UNREFERENCED( regsym );   // (HDL_REGISTER_SECTION parameter)
; 6875 : #endif
; 6876 : }
; 6877 : END_REGISTER_SECTION

  0002d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00031	c3		 ret	 0
hdl_register_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
getsym$ = 8
hdl_resolve_symbols_ep PROC

; 6852 : HDL_RESOLVER_SECTION;

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@hdl_resolv:

; 6853 : {
; 6854 :   #if defined( WIN32 ) && !defined( _MSVC_ ) && !defined( HDL_USE_LIBTOOL )
; 6855 :     #undef sysblk
; 6856 :     HDL_RESOLVE_SYMPTR( psysblk, sysblk );
; 6857 :   #else
; 6858 :     UNREFERENCED( getsym );     // (HDL_RESOLVER_SECTION parameter)

  00005	33 c0		 xor	 eax, eax
  00007	85 c0		 test	 eax, eax
  00009	75 fa		 jne	 SHORT $LN4@hdl_resolv

; 6859 :   #endif
; 6860 : }
; 6861 : END_RESOLVER_SECTION

  0000b	c3		 ret	 0
hdl_resolve_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 80
hdl_check_depends_ep PROC

; 6835 : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 6836 : {
; 6837 :     HDL_DEPENDENCY( HERCULES );

  00013	41 b8 08 00 00
	00		 mov	 r8d, 8
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175597
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175598
  00027	ff 54 24 50	 call	 QWORD PTR depchk$[rsp]
  0002b	85 c0		 test	 eax, eax
  0002d	74 08		 je	 SHORT $LN11@hdl_check_
  0002f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 6838 :     HDL_DEPENDENCY( DEVBLK );

  0003d	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175600
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175601
  00051	ff 54 24 50	 call	 QWORD PTR depchk$[rsp]
  00055	85 c0		 test	 eax, eax
  00057	74 08		 je	 SHORT $LN12@hdl_check_
  00059	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 6839 :     HDL_DEPENDENCY( SYSBLK );

  00067	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175603
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175604
  0007b	ff 54 24 50	 call	 QWORD PTR depchk$[rsp]
  0007f	85 c0		 test	 eax, eax
  00081	74 08		 je	 SHORT $LN13@hdl_check_
  00083	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d6		 jne	 SHORT $LN10@hdl_check_

; 6840 : 
; 6841 :     memcpy( (NED*)&configuration_data[0], &osa_device_ned [0], sizeof( NED ));

  00091	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00096	48 6b c0 00	 imul	 rax, rax, 0
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:osa_device_ned
  000a1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000a6	48 6b d2 00	 imul	 rdx, rdx, 0
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:configuration_data
  000b1	49 8d 3c 10	 lea	 rdi, QWORD PTR [r8+rdx]
  000b5	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000b9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000be	f3 a4		 rep movsb

; 6842 :     memcpy( (NED*)&configuration_data[1], &osa_ctlunit_ned[0], sizeof( NED ));

  000c0	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000c5	48 6b c0 00	 imul	 rax, rax, 0
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:osa_ctlunit_ned
  000d0	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d5	48 6b d2 01	 imul	 rdx, rdx, 1
  000d9	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:configuration_data
  000e0	48 03 fa	 add	 rdi, rdx
  000e3	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000e7	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000ec	f3 a4		 rep movsb

; 6843 :     memcpy( (NED*)&configuration_data[2], &osa_token_ned  [0], sizeof( NED ));

  000ee	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000f3	48 6b c0 00	 imul	 rax, rax, 0
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:osa_token_ned
  000fe	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00103	48 6b d2 02	 imul	 rdx, rdx, 2
  00107	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:configuration_data
  0010e	48 03 fa	 add	 rdi, rdx
  00111	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00115	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0011a	f3 a4		 rep movsb

; 6844 :     memcpy( (NED*)&configuration_data[3], &osa_general_neq[0], sizeof( NEQ ));

  0011c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00121	48 6b c0 00	 imul	 rax, rax, 0
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:osa_general_neq
  0012c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00131	48 6b d2 03	 imul	 rdx, rdx, 3
  00135	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:configuration_data
  0013c	48 03 fa	 add	 rdi, rdx
  0013f	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00143	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00148	f3 a4		 rep movsb

; 6845 : 
; 6846 :     memcpy( (ND*)&node_data[0], &osa_nd[0], sizeof( ND ));

  0014a	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0014f	48 6b c0 00	 imul	 rax, rax, 0
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:osa_nd
  0015a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0015f	48 6b d2 00	 imul	 rdx, rdx, 0
  00163	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:node_data
  0016a	48 03 fa	 add	 rdi, rdx
  0016d	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00171	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00176	f3 a4		 rep movsb

; 6847 :     memcpy( (ND*)&node_data[1], &osa_nq[0], sizeof( NQ ));

  00178	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0017d	48 6b c0 00	 imul	 rax, rax, 0
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:osa_nq
  00188	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0018d	48 6b d2 01	 imul	 rdx, rdx, 1
  00191	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:node_data
  00198	48 03 fa	 add	 rdi, rdx
  0019b	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0019f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001a4	f3 a4		 rep movsb

; 6848 : }
; 6849 : END_DEPENDENCY_SECTION

  001a6	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  001aa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ae	5f		 pop	 rdi
  001af	5e		 pop	 rsi
  001b0	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
rc$ = 64
tv162 = 68
tv168 = 72
dev$ = 96
oqmask$ = 104
iqmask$ = 112
qeth_do_sync PROC

; 5491 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5492 :     int rc = 0;

  00012	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 5493 : 
; 5494 :     /* Return CC1 if the device is not QDIO active */
; 5495 :     if(!(dev->scsw.flag2 & SCSW2_Q))

  0001a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001f	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00026	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002b	85 c0		 test	 eax, eax
  0002d	75 0a		 jne	 SHORT $LN8@qeth_do_sy

; 5496 :         return 1;

  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	e9 a2 01 00 00	 jmp	 $LN1@qeth_do_sy
$LN8@qeth_do_sy:

; 5497 : 
; 5498 :     /* Validate Input and Output Masks */
; 5499 :     oqmask &= ~(0xffffffff >> dev->qdio.o_qcnt);

  00039	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  00044	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00049	89 4c 24 44	 mov	 DWORD PTR tv162[rsp], ecx
  0004d	0f b6 c8	 movzx	 ecx, al
  00050	8b 44 24 44	 mov	 eax, DWORD PTR tv162[rsp]
  00054	d3 e8		 shr	 eax, cl
  00056	f7 d0		 not	 eax
  00058	8b 4c 24 68	 mov	 ecx, DWORD PTR oqmask$[rsp]
  0005c	23 c8		 and	 ecx, eax
  0005e	8b c1		 mov	 eax, ecx
  00060	89 44 24 68	 mov	 DWORD PTR oqmask$[rsp], eax

; 5500 :     iqmask &= ~(0xffffffff >> dev->qdio.i_qcnt);

  00064	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00069	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  0006f	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00074	89 4c 24 48	 mov	 DWORD PTR tv168[rsp], ecx
  00078	0f b6 c8	 movzx	 ecx, al
  0007b	8b 44 24 48	 mov	 eax, DWORD PTR tv168[rsp]
  0007f	d3 e8		 shr	 eax, cl
  00081	f7 d0		 not	 eax
  00083	8b 4c 24 70	 mov	 ecx, DWORD PTR iqmask$[rsp]
  00087	23 c8		 and	 ecx, eax
  00089	8b c1		 mov	 eax, ecx
  0008b	89 44 24 70	 mov	 DWORD PTR iqmask$[rsp], eax

; 5501 : 
; 5502 :     DBGTRC( dev, "SIGA-s dev(%4.4x) oqmask(%8.8x), iqmask(%8.8x)",

  0008f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00094	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00098	8b 4c 24 70	 mov	 ecx, DWORD PTR iqmask$[rsp]
  0009c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000a0	8b 4c 24 68	 mov	 ecx, DWORD PTR oqmask$[rsp]
  000a4	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  000a8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000ac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174901
  000b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b8	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174902
  000c4	ba 7f 15 00 00	 mov	 edx, 5503		; 0000157fH
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174903
  000d0	e8 00 00 00 00	 call	 dbgtrc
$LN4@qeth_do_sy:

; 5503 :         dev->devnum, oqmask, iqmask );
; 5504 :     PTT_QETH_TRACE( "b4 SIGA-s", oqmask, iqmask, dev->devnum );

  000d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000dc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000df	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000e5	48 85 c0	 test	 rax, rax
  000e8	74 43		 je	 SHORT $LN9@qeth_do_sy
  000ea	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000ef	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000f3	8b 4c 24 70	 mov	 ecx, DWORD PTR iqmask$[rsp]
  000f7	8b 54 24 68	 mov	 edx, DWORD PTR oqmask$[rsp]
  000fb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00104	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174905
  00110	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00115	44 8b c9	 mov	 r9d, ecx
  00118	44 8b c2	 mov	 r8d, edx
  0011b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174906
  00122	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@qeth_do_sy:
  0012d	33 c0		 xor	 eax, eax
  0012f	85 c0		 test	 eax, eax
  00131	75 a2		 jne	 SHORT $LN4@qeth_do_sy

; 5505 : 
; 5506 :     /* Return CC1 if the device is not QDIO active */
; 5507 :     if(!(dev->scsw.flag2 & SCSW2_Q))

  00133	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00138	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0013f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00144	85 c0		 test	 eax, eax
  00146	75 31		 jne	 SHORT $LN10@qeth_do_sy

; 5508 :     {
; 5509 :         DBGTRC( dev, "SIGA-s: ERROR: QDIO not active");

  00148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174909
  0014f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00154	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  00159	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174910
  00160	ba 85 15 00 00	 mov	 edx, 5509		; 00001585H
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174911
  0016c	e8 00 00 00 00	 call	 dbgtrc

; 5510 :         rc = 1;

  00171	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1
$LN10@qeth_do_sy:
$LN7@qeth_do_sy:

; 5511 :     }
; 5512 :     else
; 5513 :     {
; 5514 :         /*
; 5515 :         ** The Synchronize Function updates either the adapter's SLSB
; 5516 :         ** or program's SLSB with the other's State Block information.
; 5517 :         ** Buffer states in the program's SLSB indicating control unit
; 5518 :         ** ownership will cause the adapter's SLSB to be updated for
; 5519 :         ** that buffer. Buffers in the adapter's SLSB indicating owner-
; 5520 :         ** ship by the program will cause the program's SLSB to be up-
; 5521 :         ** dated.
; 5522 :         */
; 5523 :         /* FIXME Code missing SIGA-Sync functionality */
; 5524 : //      FIXME("Code missing SIGA-Sync functionality");
; 5525 :     }
; 5526 : 
; 5527 :     PTT_QETH_TRACE( "af SIGA-s", oqmask, iqmask, dev->devnum );

  00179	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00180	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00183	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00189	48 85 c0	 test	 rax, rax
  0018c	74 43		 je	 SHORT $LN12@qeth_do_sy
  0018e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00193	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00197	8b 4c 24 70	 mov	 ecx, DWORD PTR iqmask$[rsp]
  0019b	8b 54 24 68	 mov	 edx, DWORD PTR oqmask$[rsp]
  0019f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001a8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174913
  001b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b9	44 8b c9	 mov	 r9d, ecx
  001bc	44 8b c2	 mov	 r8d, edx
  001bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174914
  001c6	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN12@qeth_do_sy:
  001d1	33 c0		 xor	 eax, eax
  001d3	85 c0		 test	 eax, eax
  001d5	75 a2		 jne	 SHORT $LN7@qeth_do_sy

; 5528 :     return rc;

  001d7	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@qeth_do_sy:

; 5529 : }

  001db	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001df	c3		 ret	 0
qeth_do_sync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
rc$ = 64
grp$ = 72
dev$ = 96
qmask$ = 104
qeth_initiate_output_mult PROC

; 5472 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5473 :     int rc;
; 5474 :     OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	48 89 44 24 48	 mov	 QWORD PTR grp$[rsp], rax

; 5475 :     if (grp->debugmask & DBGQETHSIGA)

  0001f	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00024	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  0002a	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0002f	85 c0		 test	 eax, eax
  00031	74 31		 je	 SHORT $LN8@qeth_initi

; 5476 :         DBGTRC( dev, "SIGA-m qmask(%8.8x)", qmask );

  00033	8b 44 24 68	 mov	 eax, DWORD PTR qmask$[rsp]
  00037	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174860
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174861
  00053	ba 64 15 00 00	 mov	 edx, 5476		; 00001564H
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174862
  0005f	e8 00 00 00 00	 call	 dbgtrc
$LN8@qeth_initi:
$LN4@qeth_initi:

; 5477 :     PTT_QETH_TRACE( "b4 SIGA-m", qmask, dev->qdio.o_qmask, dev->devnum );

  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00074	48 85 c0	 test	 rax, rax
  00077	74 4a		 je	 SHORT $LN9@qeth_initi
  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00082	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00087	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  0008d	8b 54 24 68	 mov	 edx, DWORD PTR qmask$[rsp]
  00091	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0009a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174864
  000a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ab	44 8b c9	 mov	 r9d, ecx
  000ae	44 8b c2	 mov	 r8d, edx
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174865
  000b8	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@qeth_initi:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 9b		 jne	 SHORT $LN4@qeth_initi

; 5478 : 
; 5479 :     if ((rc = qeth_do_initiate_output( dev, qmask, QDSIG_WRMULT )) == 1)

  000c9	41 b0 06	 mov	 r8b, 6
  000cc	8b 54 24 68	 mov	 edx, DWORD PTR qmask$[rsp]
  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000d5	e8 00 00 00 00	 call	 qeth_do_initiate_output
  000da	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  000de	83 7c 24 40 01	 cmp	 DWORD PTR rc$[rsp], 1
  000e3	75 29		 jne	 SHORT $LN10@qeth_initi

; 5480 :         DBGTRC( dev, "SIGA-m: ERROR: QDIO not active");

  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174867
  000ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f1	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  000f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174868
  000fd	ba 68 15 00 00	 mov	 edx, 5480		; 00001568H
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174869
  00109	e8 00 00 00 00	 call	 dbgtrc
$LN10@qeth_initi:
$LN7@qeth_initi:

; 5481 : 
; 5482 :     PTT_QETH_TRACE( "af SIGA-m", qmask, dev->qdio.o_qmask, dev->devnum );

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00115	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00118	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011e	48 85 c0	 test	 rax, rax
  00121	74 4a		 je	 SHORT $LN11@qeth_initi
  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00128	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0012c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00131	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  00137	8b 54 24 68	 mov	 edx, DWORD PTR qmask$[rsp]
  0013b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00144	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174871
  00150	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00155	44 8b c9	 mov	 r9d, ecx
  00158	44 8b c2	 mov	 r8d, edx
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174872
  00162	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@qeth_initi:
  0016d	33 c0		 xor	 eax, eax
  0016f	85 c0		 test	 eax, eax
  00171	75 9b		 jne	 SHORT $LN7@qeth_initi

; 5483 :     return rc;

  00173	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 5484 : }

  00177	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0017b	c3		 ret	 0
qeth_initiate_output_mult ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
rc$ = 64
grp$ = 72
dev$ = 96
qmask$ = 104
qeth_initiate_output PROC

; 5453 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5454 :     int rc;
; 5455 :     OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	48 89 44 24 48	 mov	 QWORD PTR grp$[rsp], rax

; 5456 :     if (grp->debugmask & DBGQETHSIGA)

  0001f	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00024	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  0002a	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0002f	85 c0		 test	 eax, eax
  00031	74 31		 je	 SHORT $LN8@qeth_initi

; 5457 :         DBGTRC( dev, "SIGA-w qmask(%8.8x)", qmask );

  00033	8b 44 24 68	 mov	 eax, DWORD PTR qmask$[rsp]
  00037	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0003b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174819
  00042	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00047	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174820
  00053	ba 51 15 00 00	 mov	 edx, 5457		; 00001551H
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174821
  0005f	e8 00 00 00 00	 call	 dbgtrc
$LN8@qeth_initi:
$LN4@qeth_initi:

; 5458 :     PTT_QETH_TRACE( "b4 SIGA-w", qmask, dev->qdio.o_qmask, dev->devnum );

  00064	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0006b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0006e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00074	48 85 c0	 test	 rax, rax
  00077	74 4a		 je	 SHORT $LN9@qeth_initi
  00079	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0007e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00082	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00087	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  0008d	8b 54 24 68	 mov	 edx, DWORD PTR qmask$[rsp]
  00091	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0009a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174823
  000a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ab	44 8b c9	 mov	 r9d, ecx
  000ae	44 8b c2	 mov	 r8d, edx
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174824
  000b8	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@qeth_initi:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 9b		 jne	 SHORT $LN4@qeth_initi

; 5459 : 
; 5460 :     if ((rc = qeth_do_initiate_output( dev, qmask, QDSIG_WRIT )) == 1)

  000c9	41 b0 05	 mov	 r8b, 5
  000cc	8b 54 24 68	 mov	 edx, DWORD PTR qmask$[rsp]
  000d0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000d5	e8 00 00 00 00	 call	 qeth_do_initiate_output
  000da	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  000de	83 7c 24 40 01	 cmp	 DWORD PTR rc$[rsp], 1
  000e3	75 29		 jne	 SHORT $LN10@qeth_initi

; 5461 :         DBGTRC( dev, "SIGA-w: ERROR: QDIO not active");

  000e5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174826
  000ec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f1	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  000f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174827
  000fd	ba 55 15 00 00	 mov	 edx, 5461		; 00001555H
  00102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174828
  00109	e8 00 00 00 00	 call	 dbgtrc
$LN10@qeth_initi:
$LN7@qeth_initi:

; 5462 : 
; 5463 :     PTT_QETH_TRACE( "af SIGA-w", qmask, dev->qdio.o_qmask, dev->devnum );

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00115	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00118	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011e	48 85 c0	 test	 rax, rax
  00121	74 4a		 je	 SHORT $LN11@qeth_initi
  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00128	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0012c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00131	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  00137	8b 54 24 68	 mov	 edx, DWORD PTR qmask$[rsp]
  0013b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00144	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174830
  00150	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00155	44 8b c9	 mov	 r9d, ecx
  00158	44 8b c2	 mov	 r8d, edx
  0015b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174831
  00162	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@qeth_initi:
  0016d	33 c0		 xor	 eax, eax
  0016f	85 c0		 test	 eax, eax
  00171	75 9b		 jne	 SHORT $LN7@qeth_initi

; 5464 :     return rc;

  00173	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 5465 : }

  00177	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0017b	c3		 ret	 0
qeth_initiate_output ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
n$1 = 48
tv174 = 52
tv184 = 56
grp$ = 64
dev$ = 96
qmask$ = 104
sig$ = 112
qeth_do_initiate_output PROC

; 5413 : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 5414 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00012	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00017	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0001b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001f	48 89 44 24 40	 mov	 QWORD PTR grp$[rsp], rax

; 5415 : 
; 5416 :     /* Return CC1 if the device is not QDIO active */
; 5417 :     if(!(dev->scsw.flag2 & SCSW2_Q))

  00024	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00029	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00030	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00035	85 c0		 test	 eax, eax
  00037	75 0a		 jne	 SHORT $LN11@qeth_do_in

; 5418 :         return 1;

  00039	b8 01 00 00 00	 mov	 eax, 1
  0003e	e9 bb 01 00 00	 jmp	 $LN1@qeth_do_in
$LN11@qeth_do_in:

; 5419 : 
; 5420 :     /* Validate Mask */
; 5421 :     qmask &= ~(0xffffffff >> dev->qdio.o_qcnt);

  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00048	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  0004e	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00053	89 4c 24 34	 mov	 DWORD PTR tv174[rsp], ecx
  00057	0f b6 c8	 movzx	 ecx, al
  0005a	8b 44 24 34	 mov	 eax, DWORD PTR tv174[rsp]
  0005e	d3 e8		 shr	 eax, cl
  00060	f7 d0		 not	 eax
  00062	8b 4c 24 68	 mov	 ecx, DWORD PTR qmask$[rsp]
  00066	23 c8		 and	 ecx, eax
  00068	8b c1		 mov	 eax, ecx
  0006a	89 44 24 68	 mov	 DWORD PTR qmask$[rsp], eax

; 5422 : 
; 5423 :     /* Reset Queue Positions */
; 5424 :     if(qmask != dev->qdio.o_qmask)

  0006e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00073	8b 80 50 14 00
	00		 mov	 eax, DWORD PTR [rax+5200]
  00079	39 44 24 68	 cmp	 DWORD PTR qmask$[rsp], eax
  0007d	0f 84 91 00 00
	00		 je	 $LN12@qeth_do_in

; 5425 :     {
; 5426 :     int n;
; 5427 :         for(n = 0; n < dev->qdio.o_qcnt; n++)

  00083	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  0008b	eb 0a		 jmp	 SHORT $LN4@qeth_do_in
$LN2@qeth_do_in:
  0008d	8b 44 24 30	 mov	 eax, DWORD PTR n$1[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 30	 mov	 DWORD PTR n$1[rsp], eax
$LN4@qeth_do_in:
  00097	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0009c	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  000a2	39 44 24 30	 cmp	 DWORD PTR n$1[rsp], eax
  000a6	7d 40		 jge	 SHORT $LN3@qeth_do_in

; 5428 :             if(!(dev->qdio.o_qmask & (0x80000000 >> n)))

  000a8	8b 44 24 30	 mov	 eax, DWORD PTR n$1[rsp]
  000ac	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  000b1	89 4c 24 38	 mov	 DWORD PTR tv184[rsp], ecx
  000b5	0f b6 c8	 movzx	 ecx, al
  000b8	8b 44 24 38	 mov	 eax, DWORD PTR tv184[rsp]
  000bc	d3 e8		 shr	 eax, cl
  000be	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000c3	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  000c9	23 c8		 and	 ecx, eax
  000cb	8b c1		 mov	 eax, ecx
  000cd	85 c0		 test	 eax, eax
  000cf	75 15		 jne	 SHORT $LN13@qeth_do_in

; 5429 :                 dev->qdio.o_bpos[n] = 0;

  000d1	48 63 44 24 30	 movsxd	 rax, DWORD PTR n$1[rsp]
  000d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000db	c7 84 81 cc 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+5068], 0
$LN13@qeth_do_in:
  000e6	eb a5		 jmp	 SHORT $LN2@qeth_do_in
$LN3@qeth_do_in:

; 5430 :         if(!dev->qdio.o_qmask)

  000e8	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000ed	83 b8 50 14 00
	00 00		 cmp	 DWORD PTR [rax+5200], 0
  000f4	75 0f		 jne	 SHORT $LN14@qeth_do_in

; 5431 :             dev->qdio.o_qpos = 0;

  000f6	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000fb	c7 80 c8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5064], 0
$LN14@qeth_do_in:

; 5432 : 
; 5433 :         /* Update Write Queue Mask */
; 5434 :         dev->qdio.o_qmask = qmask;

  00105	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0010a	8b 4c 24 68	 mov	 ecx, DWORD PTR qmask$[rsp]
  0010e	89 88 50 14 00
	00		 mov	 DWORD PTR [rax+5200], ecx
$LN12@qeth_do_in:

; 5435 :     }
; 5436 : 
; 5437 :     /* Send signal to ACTIVATE QUEUES device thread loop */
; 5438 :     if(dev->qdio.o_qmask)

  00114	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00119	83 b8 50 14 00
	00 00		 cmp	 DWORD PTR [rax+5200], 0
  00120	0f 84 d6 00 00
	00		 je	 $LN15@qeth_do_in

; 5439 :     {
; 5440 :         if (grp->debugmask & DBGQETHSIGA)

  00126	48 8b 44 24 40	 mov	 rax, QWORD PTR grp$[rsp]
  0012b	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00131	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00136	85 c0		 test	 eax, eax
  00138	74 38		 je	 SHORT $LN16@qeth_do_in

; 5441 :             DBGTRC( dev, "SIGA-o: sending %s", qsig2str( sig ));

  0013a	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR sig$[rsp]
  0013f	e8 00 00 00 00	 call	 qsig2str
  00144	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174779
  00150	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00155	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  0015a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174780
  00161	ba 41 15 00 00	 mov	 edx, 5441		; 00001541H
  00166	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174781
  0016d	e8 00 00 00 00	 call	 dbgtrc
$LN16@qeth_do_in:
$LN7@qeth_do_in:

; 5442 :         VERIFY( qeth_write_pipe( grp->ppfd[1], &sig ) == 1);

  00172	b8 04 00 00 00	 mov	 eax, 4
  00177	48 6b c0 01	 imul	 rax, rax, 1
  0017b	48 8d 54 24 70	 lea	 rdx, QWORD PTR sig$[rsp]
  00180	48 8b 4c 24 40	 mov	 rcx, QWORD PTR grp$[rsp]
  00185	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  0018c	e8 00 00 00 00	 call	 qeth_write_pipe
  00191	83 f8 01	 cmp	 eax, 1
  00194	74 5c		 je	 SHORT $LN17@qeth_do_in
$LN10@qeth_do_in:
  00196	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174783
  0019d	41 b8 42 15 00
	00		 mov	 r8d, 5442		; 00001542H
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174784
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174785
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001bd	85 c0		 test	 eax, eax
  001bf	74 20		 je	 SHORT $LN18@qeth_do_in
  001c1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174787
  001c8	41 b8 42 15 00
	00		 mov	 r8d, 5442		; 00001542H
  001ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174788
  001d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174789
  001dc	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@qeth_do_in:
  001e1	33 c0		 xor	 eax, eax
  001e3	85 c0		 test	 eax, eax
  001e5	75 af		 jne	 SHORT $LN10@qeth_do_in
  001e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001ed	85 c0		 test	 eax, eax
  001ef	74 01		 je	 SHORT $LN19@qeth_do_in
  001f1	cc		 int	 3
$LN19@qeth_do_in:
$LN17@qeth_do_in:
  001f2	33 c0		 xor	 eax, eax
  001f4	85 c0		 test	 eax, eax
  001f6	0f 85 76 ff ff
	ff		 jne	 $LN7@qeth_do_in
$LN15@qeth_do_in:

; 5443 :     }
; 5444 : 
; 5445 :     return 0;

  001fc	33 c0		 xor	 eax, eax
$LN1@qeth_do_in:

; 5446 : }

  001fe	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00202	c3		 ret	 0
qeth_do_initiate_output ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
sig$1 = 64
n$2 = 68
tv133 = 72
rc$ = 76
tv235 = 80
tv245 = 84
noselrd$ = 88
grp$ = 96
dev$ = 128
qmask$ = 136
qeth_initiate_input PROC

; 5357 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 5358 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00015	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00019	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001d	48 89 44 24 60	 mov	 QWORD PTR grp$[rsp], rax

; 5359 : int noselrd, rc = 0;

  00022	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 5360 : 
; 5361 :     if (grp->debugmask & DBGQETHSIGA)

  0002a	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0002f	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00035	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0003a	85 c0		 test	 eax, eax
  0003c	74 37		 je	 SHORT $LN17@qeth_initi

; 5362 :         DBGTRC( dev, "SIGA-r qmask(%8.8x)", qmask );

  0003e	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR qmask$[rsp]
  00045	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00049	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174722
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0005d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174723
  00064	ba f2 14 00 00	 mov	 edx, 5362		; 000014f2H
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174724
  00070	e8 00 00 00 00	 call	 dbgtrc
$LN17@qeth_initi:
$LN4@qeth_initi:

; 5363 : 
; 5364 :     PTT_QETH_TRACE( "b4 SIGA-r", qmask, dev->qdio.i_qmask, dev->devnum );

  00075	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0007c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00085	48 85 c0	 test	 rax, rax
  00088	74 53		 je	 SHORT $LN18@qeth_initi
  0008a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00092	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00096	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009e	8b 89 4c 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5196]
  000a4	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR qmask$[rsp]
  000ab	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000b4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174726
  000c0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c5	44 8b c9	 mov	 r9d, ecx
  000c8	44 8b c2	 mov	 r8d, edx
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174727
  000d2	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@qeth_initi:
  000dd	33 c0		 xor	 eax, eax
  000df	85 c0		 test	 eax, eax
  000e1	75 92		 jne	 SHORT $LN4@qeth_initi

; 5365 : 
; 5366 :     /* Return CC1 if the device is not QDIO active */
; 5367 :     if(!(dev->scsw.flag2 & SCSW2_Q))

  000e3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000eb	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  000f2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000f7	85 c0		 test	 eax, eax
  000f9	75 39		 jne	 SHORT $LN19@qeth_initi

; 5368 :     {
; 5369 :         DBGTRC( dev, "SIGA-r: ERROR: QDIO not active" );

  000fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174730
  00102	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00107	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0010f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174731
  00116	ba f9 14 00 00	 mov	 edx, 5369		; 000014f9H
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174732
  00122	e8 00 00 00 00	 call	 dbgtrc

; 5370 :         rc = 1;

  00127	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 5371 :     }

  0012f	e9 1e 02 00 00	 jmp	 $LN20@qeth_initi
$LN19@qeth_initi:

; 5372 :     else
; 5373 :     {
; 5374 :         /* Is there a read select */
; 5375 :         noselrd = !dev->qdio.i_qmask;

  00134	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013c	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  00143	75 0a		 jne	 SHORT $LN31@qeth_initi
  00145	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  0014d	eb 08		 jmp	 SHORT $LN32@qeth_initi
$LN31@qeth_initi:
  0014f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN32@qeth_initi:
  00157	8b 44 24 48	 mov	 eax, DWORD PTR tv133[rsp]
  0015b	89 44 24 58	 mov	 DWORD PTR noselrd$[rsp], eax

; 5376 : 
; 5377 :         /* Validate Mask */
; 5378 :         qmask &= ~(0xffffffff >> dev->qdio.i_qcnt);

  0015f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00167	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  0016d	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00172	89 4c 24 50	 mov	 DWORD PTR tv235[rsp], ecx
  00176	0f b6 c8	 movzx	 ecx, al
  00179	8b 44 24 50	 mov	 eax, DWORD PTR tv235[rsp]
  0017d	d3 e8		 shr	 eax, cl
  0017f	f7 d0		 not	 eax
  00181	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR qmask$[rsp]
  00188	23 c8		 and	 ecx, eax
  0018a	8b c1		 mov	 eax, ecx
  0018c	89 84 24 88 00
	00 00		 mov	 DWORD PTR qmask$[rsp], eax

; 5379 : 
; 5380 :         /* Reset Queue Positions */
; 5381 :         if(qmask != dev->qdio.i_qmask)

  00193	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019b	8b 80 4c 14 00
	00		 mov	 eax, DWORD PTR [rax+5196]
  001a1	39 84 24 88 00
	00 00		 cmp	 DWORD PTR qmask$[rsp], eax
  001a8	0f 84 a6 00 00
	00		 je	 $LN21@qeth_initi

; 5382 :         {
; 5383 :         int n;
; 5384 :             for(n = 0; n < dev->qdio.i_qcnt; n++)

  001ae	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR n$2[rsp], 0
  001b6	eb 0a		 jmp	 SHORT $LN7@qeth_initi
$LN5@qeth_initi:
  001b8	8b 44 24 44	 mov	 eax, DWORD PTR n$2[rsp]
  001bc	ff c0		 inc	 eax
  001be	89 44 24 44	 mov	 DWORD PTR n$2[rsp], eax
$LN7@qeth_initi:
  001c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  001d0	39 44 24 44	 cmp	 DWORD PTR n$2[rsp], eax
  001d4	7d 46		 jge	 SHORT $LN6@qeth_initi

; 5385 :                 if(!(dev->qdio.i_qmask & (0x80000000 >> n)))

  001d6	8b 44 24 44	 mov	 eax, DWORD PTR n$2[rsp]
  001da	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001df	89 4c 24 54	 mov	 DWORD PTR tv245[rsp], ecx
  001e3	0f b6 c8	 movzx	 ecx, al
  001e6	8b 44 24 54	 mov	 eax, DWORD PTR tv245[rsp]
  001ea	d3 e8		 shr	 eax, cl
  001ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f4	8b 89 4c 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5196]
  001fa	23 c8		 and	 ecx, eax
  001fc	8b c1		 mov	 eax, ecx
  001fe	85 c0		 test	 eax, eax
  00200	75 18		 jne	 SHORT $LN22@qeth_initi

; 5386 :                     dev->qdio.i_bpos[n] = 0;

  00202	48 63 44 24 44	 movsxd	 rax, DWORD PTR n$2[rsp]
  00207	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020f	c7 84 81 44 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+4932], 0
$LN22@qeth_initi:
  0021a	eb 9c		 jmp	 SHORT $LN5@qeth_initi
$LN6@qeth_initi:

; 5387 :             if(!dev->qdio.i_qmask)

  0021c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00224	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  0022b	75 12		 jne	 SHORT $LN23@qeth_initi

; 5388 :                 dev->qdio.i_qpos = 0;

  0022d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00235	c7 80 40 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4928], 0
$LN23@qeth_initi:

; 5389 : 
; 5390 :             /* Update Read Queue Mask */
; 5391 :             dev->qdio.i_qmask = qmask;

  0023f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00247	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR qmask$[rsp]
  0024e	89 88 4c 14 00
	00		 mov	 DWORD PTR [rax+5196], ecx
$LN21@qeth_initi:

; 5392 :         }
; 5393 : 
; 5394 :         /* Send signal to ACTIVATE QUEUES device thread loop */
; 5395 :         if(noselrd && dev->qdio.i_qmask)

  00254	83 7c 24 58 00	 cmp	 DWORD PTR noselrd$[rsp], 0
  00259	0f 84 f3 00 00
	00		 je	 $LN24@qeth_initi
  0025f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00267	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  0026e	0f 84 de 00 00
	00		 je	 $LN24@qeth_initi

; 5396 :         {
; 5397 :             BYTE sig = QDSIG_READ;

  00274	c6 44 24 40 03	 mov	 BYTE PTR sig$1[rsp], 3

; 5398 :             if (grp->debugmask & DBGQETHSIGA)

  00279	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0027e	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00284	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00289	85 c0		 test	 eax, eax
  0028b	74 3b		 je	 SHORT $LN25@qeth_initi

; 5399 :                 DBGTRC( dev, "SIGA-r: sending %s", qsig2str( sig ));

  0028d	0f b6 4c 24 40	 movzx	 ecx, BYTE PTR sig$1[rsp]
  00292	e8 00 00 00 00	 call	 qsig2str
  00297	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0029c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174738
  002a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a8	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  002b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174739
  002b7	ba 17 15 00 00	 mov	 edx, 5399		; 00001517H
  002bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174740
  002c3	e8 00 00 00 00	 call	 dbgtrc
$LN25@qeth_initi:
$LN10@qeth_initi:

; 5400 :             VERIFY( qeth_write_pipe( grp->ppfd[1], &sig ) == 1);

  002c8	b8 04 00 00 00	 mov	 eax, 4
  002cd	48 6b c0 01	 imul	 rax, rax, 1
  002d1	48 8d 54 24 40	 lea	 rdx, QWORD PTR sig$1[rsp]
  002d6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  002db	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  002e2	e8 00 00 00 00	 call	 qeth_write_pipe
  002e7	83 f8 01	 cmp	 eax, 1
  002ea	74 5c		 je	 SHORT $LN26@qeth_initi
$LN13@qeth_initi:
  002ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174742
  002f3	41 b8 18 15 00
	00		 mov	 r8d, 5400		; 00001518H
  002f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174743
  00300	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174744
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0030d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00313	85 c0		 test	 eax, eax
  00315	74 20		 je	 SHORT $LN27@qeth_initi
  00317	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174746
  0031e	41 b8 18 15 00
	00		 mov	 r8d, 5400		; 00001518H
  00324	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174747
  0032b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174748
  00332	e8 00 00 00 00	 call	 DebuggerTrace
$LN27@qeth_initi:
  00337	33 c0		 xor	 eax, eax
  00339	85 c0		 test	 eax, eax
  0033b	75 af		 jne	 SHORT $LN13@qeth_initi
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00343	85 c0		 test	 eax, eax
  00345	74 01		 je	 SHORT $LN28@qeth_initi
  00347	cc		 int	 3
$LN28@qeth_initi:
$LN26@qeth_initi:
  00348	33 c0		 xor	 eax, eax
  0034a	85 c0		 test	 eax, eax
  0034c	0f 85 76 ff ff
	ff		 jne	 $LN10@qeth_initi
$LN24@qeth_initi:
$LN20@qeth_initi:
$LN16@qeth_initi:

; 5401 :         }
; 5402 :     }
; 5403 : 
; 5404 :     PTT_QETH_TRACE( "af SIGA-r", qmask, dev->qdio.i_qmask, dev->devnum );

  00352	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00359	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0035c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00362	48 85 c0	 test	 rax, rax
  00365	74 53		 je	 SHORT $LN29@qeth_initi
  00367	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0036f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00373	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0037b	8b 89 4c 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5196]
  00381	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR qmask$[rsp]
  00388	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00391	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00396	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174751
  0039d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a2	44 8b c9	 mov	 r9d, ecx
  003a5	44 8b c2	 mov	 r8d, edx
  003a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174752
  003af	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN29@qeth_initi:
  003ba	33 c0		 xor	 eax, eax
  003bc	85 c0		 test	 eax, eax
  003be	75 92		 jne	 SHORT $LN16@qeth_initi

; 5405 :     return rc;

  003c0	8b 44 24 4c	 mov	 eax, DWORD PTR rc$[rsp]

; 5406 : }

  003c4	48 83 c4 78	 add	 rsp, 120		; 00000078H
  003c8	c3		 ret	 0
qeth_initiate_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$1 = 128
sig$2 = 132
grp$ = 136
num$ = 144
accerr$3 = 148
qdes$4 = 152
qdr$5 = 160
datalen$6 = 168
len$7 = 172
qdr_len$8 = 176
tv1142 = 180
tv151 = 184
datalen$9 = 188
length$10 = 192
bhr$11 = 200
first4$12 = 208
length$13 = 212
first4$14 = 216
len$15 = 220
iir$16 = 224
rc$17 = 228
iodata$18 = 232
tv458 = 240
tv464 = 244
tv481 = 248
tv499 = 252
tv505 = 256
tv622 = 260
tv640 = 264
tv646 = 268
tv663 = 272
tv670 = 276
tv1080 = 280
tv1103 = 284
tv1180 = 288
tv1261 = 292
tv1267 = 296
tv1281 = 300
tv1366 = 304
tv1372 = 308
tv133 = 312
tv139 = 316
tv252 = 320
tv417 = 324
tv434 = 328
qib$19 = 336
tv1356 = 344
tv1359 = 348
tv87 = 352
tv89 = 356
tv92 = 360
tv94 = 364
fd$20 = 368
tv533 = 376
nd$21 = 384
cua$22 = 392
nq$23 = 400
tv996 = 408
tv$24 = 416
th$25 = 424
tv446 = 432
tv487 = 440
tv628 = 448
tv1254 = 456
readset$26 = 464
contentstring$27 = 8672
buf$28 = 8928
buf$29 = 9952
buf$30 = 10976
__$ArrayPad$ = 12000
dev$ = 12048
code$ = 12056
flags$ = 12064
chained$ = 12072
count$ = 12080
prevcode$ = 12088
ccwseq$ = 12096
iobuf$ = 12104
more$ = 12112
unitstat$ = 12120
residual$ = 12128
qeth_execute_ccw PROC

; 4593 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	b8 f8 2e 00 00	 mov	 eax, 12024		; 00002ef8H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 e0
	2e 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4594 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00034	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR grp$[rsp], rax
$LN4@qeth_execu:

; 4595 : U32 num;                                /* Number of bytes to move   */
; 4596 : 
; 4597 :     UNREFERENCED(flags);

  0004c	33 c0		 xor	 eax, eax
  0004e	85 c0		 test	 eax, eax
  00050	75 fa		 jne	 SHORT $LN4@qeth_execu
$LN7@qeth_execu:

; 4598 :     UNREFERENCED(ccwseq);

  00052	33 c0		 xor	 eax, eax
  00054	85 c0		 test	 eax, eax
  00056	75 fa		 jne	 SHORT $LN7@qeth_execu

; 4599 : 
; 4600 :     /* Clear the output */
; 4601 :     *more = 0;

  00058	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00060	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4602 :     *unitstat = 0;

  00063	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0006b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4603 :     *residual = 0;

  0006e	48 8b 84 24 60
	2f 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00076	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4604 : 
; 4605 :     /* Command reject if the device group has not been established */
; 4606 :     if((dev->group->acount != dev->group->members)
; 4607 :       && !(IS_CCW_SENSE(code) || IS_CCW_NOP(code) || (code == OSA_RCD)))

  0007c	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00084	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00088	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00090	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00094	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00096	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  00099	74 55		 je	 SHORT $LN85@qeth_execu
  0009b	0f b6 84 24 18
	2f 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000a3	83 e0 0f	 and	 eax, 15
  000a6	83 f8 04	 cmp	 eax, 4
  000a9	74 45		 je	 SHORT $LN85@qeth_execu
  000ab	0f b6 84 24 18
	2f 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000b3	83 f8 03	 cmp	 eax, 3
  000b6	74 38		 je	 SHORT $LN85@qeth_execu
  000b8	0f b6 84 24 18
	2f 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000c0	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  000c5	74 29		 je	 SHORT $LN85@qeth_execu

; 4608 :     {
; 4609 :         /* Set Intervention required sense, and unit check status */
; 4610 :         dev->sense[0] = SENSE_IR;

  000c7	b8 01 00 00 00	 mov	 eax, 1
  000cc	48 6b c0 00	 imul	 rax, rax, 0
  000d0	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d8	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 4611 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  000e0	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  000e8	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4612 :         return;

  000eb	e9 ed 27 00 00	 jmp	 $LN1@qeth_execu
$LN85@qeth_execu:

; 4613 :     }
; 4614 : 
; 4615 :     /* Display various information, maybe */
; 4616 :     if (grp->debugmask & DBGQETHCCW)

  000f0	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  000f8	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  000fe	83 e0 20	 and	 eax, 32			; 00000020H
  00101	85 c0		 test	 eax, eax
  00103	0f 84 46 01 00
	00		 je	 $LN86@qeth_execu

; 4617 :     {
; 4618 :         // "%1d:%04X %s: Code %02X: Flags %02X: Count %08X: Chained %02X: PrevCode %02X: CCWseq %d"
; 4619 :         WRMSG( HHC03992, "D", LCSS_DEVNUM,

  00109	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00112	74 15		 je	 SHORT $LN186@qeth_execu
  00114	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00120	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv133[rsp], eax
  00127	eb 0b		 jmp	 SHORT $LN187@qeth_execu
$LN186@qeth_execu:
  00129	c7 84 24 38 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv133[rsp], 0
$LN187@qeth_execu:
  00134	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0013d	74 17		 je	 SHORT $LN188@qeth_execu
  0013f	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00147	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0014b	d1 f8		 sar	 eax, 1
  0014d	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv139[rsp], eax
  00154	eb 0b		 jmp	 SHORT $LN189@qeth_execu
$LN188@qeth_execu:
  00156	c7 84 24 3c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv139[rsp], 0
$LN189@qeth_execu:
  00161	0f b6 84 24 38
	2f 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  00169	89 84 24 60 01
	00 00		 mov	 DWORD PTR tv87[rsp], eax
  00170	0f b6 8c 24 28
	2f 00 00	 movzx	 ecx, BYTE PTR chained$[rsp]
  00178	89 8c 24 64 01
	00 00		 mov	 DWORD PTR tv89[rsp], ecx
  0017f	0f b6 94 24 20
	2f 00 00	 movzx	 edx, BYTE PTR flags$[rsp]
  00187	89 94 24 68 01
	00 00		 mov	 DWORD PTR tv92[rsp], edx
  0018e	44 0f b6 84 24
	18 2f 00 00	 movzx	 r8d, BYTE PTR code$[rsp]
  00197	44 89 84 24 6c
	01 00 00	 mov	 DWORD PTR tv94[rsp], r8d
  0019f	b9 01 00 00 00	 mov	 ecx, 1
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001aa	8b 8c 24 40 2f
	00 00		 mov	 ecx, DWORD PTR ccwseq$[rsp]
  001b1	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  001b5	8b 8c 24 60 01
	00 00		 mov	 ecx, DWORD PTR tv87[rsp]
  001bc	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  001c0	8b 8c 24 64 01
	00 00		 mov	 ecx, DWORD PTR tv89[rsp]
  001c7	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  001cb	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  001d2	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  001d6	8b 8c 24 68 01
	00 00		 mov	 ecx, DWORD PTR tv92[rsp]
  001dd	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001e1	8b 8c 24 6c 01
	00 00		 mov	 ecx, DWORD PTR tv94[rsp]
  001e8	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  001ec	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f4	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001f8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001fd	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv133[rsp]
  00204	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00208	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv139[rsp]
  0020f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174420
  0021a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174421
  00226	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0022b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00230	41 b9 03 00 00
	00		 mov	 r9d, 3
  00236	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174422
  0023d	ba 0c 12 00 00	 mov	 edx, 4620		; 0000120cH
  00242	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174423
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN86@qeth_execu:

; 4620 :             dev->typname, code, flags, count, chained, prevcode, ccwseq );
; 4621 :     }
; 4622 : 
; 4623 :     /* Process depending on CCW opcode */
; 4624 :     switch (code) {

  0024f	0f b6 84 24 18
	2f 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00257	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv151[rsp], eax
  0025e	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv151[rsp]
  00265	ff c8		 dec	 eax
  00267	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv151[rsp], eax
  0026e	81 bc 24 b8 00
	00 00 f9 00 00
	00		 cmp	 DWORD PTR tv151[rsp], 249 ; 000000f9H
  00279	0f 87 db 24 00
	00		 ja	 $LN183@qeth_execu
  0027f	48 63 84 24 b8
	00 00 00	 movsxd	 rax, DWORD PTR tv151[rsp]
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0028e	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN236@qeth_execu[rcx+rax]
  00296	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN237@qeth_execu[rcx+rax*4]
  0029d	48 03 c1	 add	 rax, rcx
  002a0	ff e0		 jmp	 rax
$LN87@qeth_execu:

; 4625 : 
; 4626 :     case 0x01:
; 4627 :     /*---------------------------------------------------------------*/
; 4628 :     /* WRITE                                                         */
; 4629 :     /*---------------------------------------------------------------*/
; 4630 :     {
; 4631 :     int      datalen, length;
; 4632 :     U32      first4;
; 4633 :     char     contentstring[256] = {0};

  002a2	48 8d 84 24 e0
	21 00 00	 lea	 rax, QWORD PTR contentstring$27[rsp]
  002aa	48 8b f8	 mov	 rdi, rax
  002ad	33 c0		 xor	 eax, eax
  002af	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  002b4	f3 aa		 rep stosb

; 4634 : 
; 4635 :         /* Prepare the contentstring. */
; 4636 :         dev->dev_data = &contentstring;

  002b6	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002be	48 8d 8c 24 e0
	21 00 00	 lea	 rcx, QWORD PTR contentstring$27[rsp]
  002c6	48 89 88 08 06
	00 00		 mov	 QWORD PTR [rax+1544], rcx

; 4637 : 
; 4638 :         /* Get the first 4-bytes of the data. */
; 4639 :         FETCH_FW( first4, iobuf );

  002cd	48 8b 8c 24 48
	2f 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  002d5	e8 00 00 00 00	 call	 fetch_fw_noswap
  002da	8b c8		 mov	 ecx, eax
  002dc	e8 00 00 00 00	 call	 _byteswap_ulong
  002e1	89 84 24 d0 00
	00 00		 mov	 DWORD PTR first4$12[rsp], eax

; 4640 :         length = datalen = count;

  002e8	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  002ef	89 84 24 bc 00
	00 00		 mov	 DWORD PTR datalen$9[rsp], eax
  002f6	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR datalen$9[rsp]
  002fd	89 84 24 d4 00
	00 00		 mov	 DWORD PTR length$13[rsp], eax

; 4641 : 
; 4642 :         /* Process the request */
; 4643 :         if (first4 == MPC_TH_FIRST4)

  00304	81 bc 24 d0 00
	00 00 00 00 e0
	00		 cmp	 DWORD PTR first4$12[rsp], 14680064 ; 00e00000H
  0030f	75 22		 jne	 SHORT $LN88@qeth_execu

; 4644 :         {
; 4645 :             /* Process the request MPC_TH etc. */
; 4646 :             osa_adapter_cmd(dev,(MPC_TH*)iobuf,datalen);

  00311	44 8b 84 24 bc
	00 00 00	 mov	 r8d, DWORD PTR datalen$9[rsp]
  00319	48 8b 94 24 48
	2f 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00321	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00329	e8 00 00 00 00	 call	 osa_adapter_cmd

; 4647 :         }

  0032e	e9 68 01 00 00	 jmp	 $LN89@qeth_execu
$LN88@qeth_execu:

; 4648 :         else if (first4 == MPC_IEA_FIRST4)

  00333	81 bc 24 d0 00
	00 00 00 80 00
	00		 cmp	 DWORD PTR first4$12[rsp], 32768 ; 00008000H
  0033e	75 22		 jne	 SHORT $LN90@qeth_execu

; 4649 :         {
; 4650 :             /* Process the IEA. */
; 4651 :             osa_device_cmd(dev,(MPC_IEA*)iobuf,datalen);

  00340	44 8b 84 24 bc
	00 00 00	 mov	 r8d, DWORD PTR datalen$9[rsp]
  00348	48 8b 94 24 48
	2f 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00350	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00358	e8 00 00 00 00	 call	 osa_device_cmd

; 4652 :         }

  0035d	e9 39 01 00 00	 jmp	 $LN91@qeth_execu
$LN90@qeth_execu:

; 4653 :         else if (first4 == MPC_END_FIRST4)

  00362	81 bc 24 d0 00
	00 00 00 c0 00
	00		 cmp	 DWORD PTR first4$12[rsp], 49152 ; 0000c000H
  0036d	0f 85 c2 00 00
	00		 jne	 $LN92@qeth_execu

; 4654 :         {
; 4655 :             /* Only ever seen during z/OS shutdown */
; 4656 :             if (grp->debugmask)

  00373	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0037b	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  00382	0f 84 ab 00 00
	00		 je	 $LN94@qeth_execu
$LN12@qeth_execu:

; 4657 :             {
; 4658 :                 PTT_QETH_TRACE( "shut notify", dev->devnum,0,0 );

  00388	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0038f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00392	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00398	48 85 c0	 test	 rax, rax
  0039b	74 42		 je	 SHORT $LN95@qeth_execu
  0039d	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003a9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003b2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174433
  003c2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003c7	45 33 c9	 xor	 r9d, r9d
  003ca	44 8b c0	 mov	 r8d, eax
  003cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174434
  003d4	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  003d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN95@qeth_execu:
  003df	33 c0		 xor	 eax, eax
  003e1	85 c0		 test	 eax, eax
  003e3	75 a3		 jne	 SHORT $LN12@qeth_execu

; 4659 :                 mpc_display_description( dev, "Shutdown Notify" );

  003e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174435
  003ec	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description

; 4660 :                 MPC_DUMP_DATA( "END", iobuf, datalen, FROM_GUEST );

  003fa	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00402	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174436
  00409	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0040e	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00413	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00416	44 8b 84 24 bc
	00 00 00	 mov	 r8d, DWORD PTR datalen$9[rsp]
  0041e	48 8b 94 24 48
	2f 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00426	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042e	e8 00 00 00 00	 call	 net_data_trace
$LN94@qeth_execu:

; 4661 :             }
; 4662 :         }

  00433	eb 66		 jmp	 SHORT $LN93@qeth_execu
$LN92@qeth_execu:

; 4663 :         else
; 4664 :         {
; 4665 :             /* Display the unrecognised data. */
; 4666 :             mpc_display_description( dev, "Unrecognised Request" );

  00435	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174437
  0043c	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description

; 4667 :             if (length >= 256)

  0044a	81 bc 24 d4 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR length$13[rsp], 256 ; 00000100H
  00455	7c 0b		 jl	 SHORT $LN96@qeth_execu

; 4668 :                 length = 256;

  00457	c7 84 24 d4 00
	00 00 00 01 00
	00		 mov	 DWORD PTR length$13[rsp], 256 ; 00000100H
$LN96@qeth_execu:

; 4669 :             MPC_DUMP_DATA( "???", iobuf, length, FROM_GUEST );

  00462	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0046a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174439
  00471	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00476	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0047b	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0047e	44 8b 84 24 d4
	00 00 00	 mov	 r8d, DWORD PTR length$13[rsp]
  00486	48 8b 94 24 48
	2f 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0048e	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00496	e8 00 00 00 00	 call	 net_data_trace
$LN93@qeth_execu:
$LN91@qeth_execu:
$LN89@qeth_execu:

; 4670 :         }
; 4671 : 
; 4672 :         /* Return normal status */
; 4673 :         *unitstat = CSW_CE | CSW_DE;

  0049b	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004a3	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4674 :         *residual = 0;

  004a6	48 8b 84 24 60
	2f 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  004ae	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4675 :         *more = 0;

  004b4	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  004bc	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4676 : 
; 4677 :         /* Finished with the contentstring. */
; 4678 :         dev->dev_data = NULL;

  004bf	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004c7	48 c7 80 08 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1544], 0

; 4679 : 
; 4680 :         break;

  004d2	e9 df 22 00 00	 jmp	 $LN8@qeth_execu
$LN97@qeth_execu:
$LN15@qeth_execu:

; 4681 :     }
; 4682 : 
; 4683 : 
; 4684 :     case 0x02:
; 4685 :     /*---------------------------------------------------------------*/
; 4686 :     /* READ                                                          */
; 4687 :     /*---------------------------------------------------------------*/
; 4688 :     {
; 4689 :     OSA_BHR *bhr;
; 4690 :     BYTE    *iodata;
; 4691 :     U32      datalen, length;
; 4692 :     U32      first4;
; 4693 :         /*
; 4694 :         ** Our purpose is to satisfy the program's request to read
; 4695 :         ** an IDX response. If there is a response queued (chained)
; 4696 :         ** then we return our response thereby satisfying the read,
; 4697 :         ** and exit with normal CSW status.
; 4698 :         **
; 4699 :         ** If we don't have an IDX response queued/chained though,
; 4700 :         ** then how we react depends on whether IDX handshaking is
; 4701 :         ** still active or not.
; 4702 :         **
; 4703 :         ** If IDX is not active (i.e. our dev->qdio.idxstate field
; 4704 :         ** is not MPC_IDX_STATE_ACTIVE) we return with a CSW status
; 4705 :         ** of unit check with status modifier (i.e. the read failed
; 4706 :         ** because there were no response buffers queued/chained to
; 4707 :         ** satisfy their read request with).
; 4708 :         **
; 4709 :         ** Otherwise as long as IDX is still active, we simply wait
; 4710 :         ** until a response is eventually queued (chained) so we can
; 4711 :         ** then use it to satisfy their read request with. That is
; 4712 :         ** to say, we will wait forever for a response to be queued
; 4713 :         ** as long as IDX is still active (we only exit when there
; 4714 :         ** is a response to give them or IDX is no longer active).
; 4715 :         */
; 4716 :         PTT_QETH_TRACE( "read entr", 0,0,0 );

  004d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004de	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004e1	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  004e7	48 85 c0	 test	 rax, rax
  004ea	74 36		 je	 SHORT $LN98@qeth_execu
  004ec	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004f5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  004fe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174442
  00505	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0050a	45 33 c9	 xor	 r9d, r9d
  0050d	45 33 c0	 xor	 r8d, r8d
  00510	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174443
  00517	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0051c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN98@qeth_execu:
  00522	33 c0		 xor	 eax, eax
  00524	85 c0		 test	 eax, eax
  00526	75 af		 jne	 SHORT $LN15@qeth_execu
$LN16@qeth_execu:

; 4717 : 
; 4718 :         while (dev->qdio.idxstate == MPC_IDX_STATE_ACTIVE)

  00528	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00530	83 b8 34 13 00
	00 01		 cmp	 DWORD PTR [rax+4916], 1
  00537	0f 85 2a 05 00
	00		 jne	 $LN17@qeth_execu
$LN20@qeth_execu:

; 4719 :         {
; 4720 :             /* Remove IDX response buffer from chain. */
; 4721 :             PTT_QETH_TRACE( "b4 rd rmbuf", 0,0,0 );

  0053d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00544	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00547	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0054d	48 85 c0	 test	 rax, rax
  00550	74 36		 je	 SHORT $LN99@qeth_execu
  00552	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0055b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00564	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174445
  0056b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00570	45 33 c9	 xor	 r9d, r9d
  00573	45 33 c0	 xor	 r8d, r8d
  00576	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174446
  0057d	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN99@qeth_execu:
  00588	33 c0		 xor	 eax, eax
  0058a	85 c0		 test	 eax, eax
  0058c	75 af		 jne	 SHORT $LN20@qeth_execu

; 4722 :             bhr = remove_buffer_from_chain( &grp->idx );

  0058e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00596	48 83 c0 18	 add	 rax, 24
  0059a	48 8b c8	 mov	 rcx, rax
  0059d	e8 00 00 00 00	 call	 remove_buffer_from_chain
  005a2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR bhr$11[rsp], rax
$LN23@qeth_execu:

; 4723 :             PTT_QETH_TRACE( "af rd rmbuf", bhr,0,0 );

  005aa	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  005b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005b4	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  005ba	48 85 c0	 test	 rax, rax
  005bd	74 3b		 je	 SHORT $LN100@qeth_execu
  005bf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  005c8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  005d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174448
  005d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005dd	45 33 c9	 xor	 r9d, r9d
  005e0	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR bhr$11[rsp]
  005e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174449
  005ef	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  005f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN100@qeth_execu:
  005fa	33 c0		 xor	 eax, eax
  005fc	85 c0		 test	 eax, eax
  005fe	75 aa		 jne	 SHORT $LN23@qeth_execu

; 4724 : 
; 4725 :             if (bhr)

  00600	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR bhr$11[rsp], 0
  00609	0f 84 6c 03 00
	00		 je	 $LN101@qeth_execu

; 4726 :             {
; 4727 :                 /* Point to response data and get its length. */
; 4728 :                 iodata = (BYTE*)bhr + SizeBHR;

  0060f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR bhr$11[rsp]
  00617	48 83 c0 18	 add	 rax, 24
  0061b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR iodata$18[rsp], rax

; 4729 :                 length = datalen = bhr->datalen;

  00623	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR bhr$11[rsp]
  0062b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0062e	89 84 24 a8 00
	00 00		 mov	 DWORD PTR datalen$6[rsp], eax
  00635	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR datalen$6[rsp]
  0063c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR length$10[rsp], eax

; 4730 : 
; 4731 :                 /* Set the residual length and normal status. */
; 4732 :                 if (count >= datalen)

  00643	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR datalen$6[rsp]
  0064a	39 84 24 30 2f
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00651	72 29		 jb	 SHORT $LN102@qeth_execu

; 4733 :                 {
; 4734 :                     *more     = 0;

  00653	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0065b	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4735 :                     *residual = count - datalen;

  0065e	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR datalen$6[rsp]
  00665	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0066c	2b c8		 sub	 ecx, eax
  0066e	8b c1		 mov	 eax, ecx
  00670	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00678	89 01		 mov	 DWORD PTR [rcx], eax

; 4736 :                 }

  0067a	eb 27		 jmp	 SHORT $LN103@qeth_execu
$LN102@qeth_execu:

; 4737 :                 else
; 4738 :                 {
; 4739 :                     datalen   = count;

  0067c	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00683	89 84 24 a8 00
	00 00		 mov	 DWORD PTR datalen$6[rsp], eax

; 4740 :                     *more     = 1;

  0068a	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00692	c6 00 01	 mov	 BYTE PTR [rax], 1

; 4741 :                     *residual = 0;

  00695	48 8b 84 24 60
	2f 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0069d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN103@qeth_execu:

; 4742 :                 }
; 4743 :                 *unitstat = CSW_CE | CSW_DE;

  006a3	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  006ab	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4744 : 
; 4745 :                 /* What type of IDX response is this? */
; 4746 :                 FETCH_FW( first4, iodata );

  006ae	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR iodata$18[rsp]
  006b6	e8 00 00 00 00	 call	 fetch_fw_noswap
  006bb	8b c8		 mov	 ecx, eax
  006bd	e8 00 00 00 00	 call	 _byteswap_ulong
  006c2	89 84 24 d8 00
	00 00		 mov	 DWORD PTR first4$14[rsp], eax

; 4747 : 
; 4748 :                 if (first4 == MPC_TH_FIRST4)

  006c9	81 bc 24 d8 00
	00 00 00 00 e0
	00		 cmp	 DWORD PTR first4$14[rsp], 14680064 ; 00e00000H
  006d4	0f 85 c0 00 00
	00		 jne	 $LN104@qeth_execu

; 4749 :                 {
; 4750 :                     MPC_TH *th = (MPC_TH*)iodata;

  006da	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR iodata$18[rsp]
  006e2	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR th$25[rsp], rax

; 4751 : 
; 4752 :                     /* Set the transmission header sequence number. */
; 4753 :                     STORE_FW( th->seqnum, ++grp->seqnumth );

  006ea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  006f2	8b 80 04 06 00
	00		 mov	 eax, DWORD PTR [rax+1540]
  006f8	ff c0		 inc	 eax
  006fa	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv252[rsp], eax
  00701	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00709	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv252[rsp]
  00710	89 88 04 06 00
	00		 mov	 DWORD PTR [rax+1540], ecx
  00716	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv252[rsp]
  0071d	e8 00 00 00 00	 call	 _byteswap_ulong
  00722	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR th$25[rsp]
  0072a	48 83 c1 04	 add	 rcx, 4
  0072e	8b d0		 mov	 edx, eax
  00730	e8 00 00 00 00	 call	 store_fw_noswap

; 4754 : 
; 4755 :                     /* Display the response MPC_TH etc., maybe. */
; 4756 :                     DBGUPD( dev, 1, iodata, 0, TO_GUEST, "%s: Response", bhr->content );

  00735	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR bhr$11[rsp]
  0073d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00741	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00746	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174455
  0074d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00752	c6 44 24 38 3e	 mov	 BYTE PTR [rsp+56], 62	; 0000003eH
  00757	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00760	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR iodata$18[rsp]
  00768	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0076d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00775	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0077d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174456
  00784	ba 94 12 00 00	 mov	 edx, 4756		; 00001294H
  00789	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174457
  00790	e8 00 00 00 00	 call	 dbgupd

; 4757 :                 }

  00795	e9 a1 01 00 00	 jmp	 $LN105@qeth_execu
$LN104@qeth_execu:

; 4758 :                 else if (first4 == MPC_IEA_FIRST4)

  0079a	81 bc 24 d8 00
	00 00 00 80 00
	00		 cmp	 DWORD PTR first4$14[rsp], 32768 ; 00008000H
  007a5	75 67		 jne	 SHORT $LN106@qeth_execu

; 4759 :                 {
; 4760 :                     /* Display the response MPC_IEAR, maybe. */
; 4761 :                     DBGUPD( dev, 3, iodata, datalen, TO_GUEST, "%s: Response", bhr->content );

  007a7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR bhr$11[rsp]
  007af	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  007b3	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  007b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174460
  007bf	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  007c4	c6 44 24 38 3e	 mov	 BYTE PTR [rsp+56], 62	; 0000003eH
  007c9	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR datalen$6[rsp]
  007d0	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  007d4	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR iodata$18[rsp]
  007dc	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  007e1	c7 44 24 20 03
	00 00 00	 mov	 DWORD PTR [rsp+32], 3
  007e9	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  007f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174461
  007f8	ba 99 12 00 00	 mov	 edx, 4761		; 00001299H
  007fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174462
  00804	e8 00 00 00 00	 call	 dbgupd

; 4762 :                 }

  00809	e9 2d 01 00 00	 jmp	 $LN107@qeth_execu
$LN106@qeth_execu:

; 4763 :                 else if (first4 == MPC_END_FIRST4)

  0080e	81 bc 24 d8 00
	00 00 00 c0 00
	00		 cmp	 DWORD PTR first4$14[rsp], 49152 ; 0000c000H
  00819	0f 85 b6 00 00
	00		 jne	 $LN108@qeth_execu

; 4764 :                 {
; 4765 :                     /* Only ever seen during z/OS shutdown */
; 4766 :                     if (grp->debugmask)

  0081f	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00827	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  0082e	0f 84 9f 00 00
	00		 je	 $LN110@qeth_execu
$LN26@qeth_execu:

; 4767 :                     {
; 4768 :                         PTT_QETH_TRACE( "shut ack", 0,0,0 );

  00834	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0083b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0083e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00844	48 85 c0	 test	 rax, rax
  00847	74 36		 je	 SHORT $LN111@qeth_execu
  00849	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00852	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0085b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174467
  00862	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00867	45 33 c9	 xor	 r9d, r9d
  0086a	45 33 c0	 xor	 r8d, r8d
  0086d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174468
  00874	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00879	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN111@qeth_execu:
  0087f	33 c0		 xor	 eax, eax
  00881	85 c0		 test	 eax, eax
  00883	75 af		 jne	 SHORT $LN26@qeth_execu

; 4769 :                         mpc_display_description( dev, "Shutdown Acknowledge" );

  00885	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174469
  0088c	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00894	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description

; 4770 :                         MPC_DUMP_DATA( "END", iobuf, length, TO_GUEST );

  0089a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  008a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174470
  008a9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008ae	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  008b3	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  008b6	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR length$10[rsp]
  008be	48 8b 94 24 48
	2f 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  008c6	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008ce	e8 00 00 00 00	 call	 net_data_trace
$LN110@qeth_execu:

; 4771 :                     }
; 4772 :                 }

  008d3	eb 66		 jmp	 SHORT $LN109@qeth_execu
$LN108@qeth_execu:

; 4773 :                 else
; 4774 :                 {
; 4775 :                     /* Display the unrecognised data. */
; 4776 :                     mpc_display_description( dev, "Unrecognised Response" );

  008d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174471
  008dc	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_description

; 4777 :                     if (length >= 256)

  008ea	81 bc 24 c0 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR length$10[rsp], 256 ; 00000100H
  008f5	72 0b		 jb	 SHORT $LN112@qeth_execu

; 4778 :                         length = 256;

  008f7	c7 84 24 c0 00
	00 00 00 01 00
	00		 mov	 DWORD PTR length$10[rsp], 256 ; 00000100H
$LN112@qeth_execu:

; 4779 :                     MPC_DUMP_DATA( "???", iodata, length, TO_GUEST );

  00902	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0090a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174473
  00911	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00916	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0091b	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  0091e	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR length$10[rsp]
  00926	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR iodata$18[rsp]
  0092e	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00936	e8 00 00 00 00	 call	 net_data_trace
$LN109@qeth_execu:
$LN107@qeth_execu:
$LN105@qeth_execu:

; 4780 :                 }
; 4781 : 
; 4782 :                 /* Copy IDX response data to i/o buffer. */
; 4783 :                 memcpy( iobuf, iodata, datalen );

  0093b	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR datalen$6[rsp]
  00942	48 8b bc 24 48
	2f 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0094a	48 8b b4 24 e8
	00 00 00	 mov	 rsi, QWORD PTR iodata$18[rsp]
  00952	8b c8		 mov	 ecx, eax
  00954	f3 a4		 rep movsb

; 4784 : 
; 4785 :                 /* Free IDX response buffer. Read is complete. */
; 4786 :                 free( bhr->content );

  00956	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR bhr$11[rsp]
  0095e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00962	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4787 :                 free( bhr );

  00968	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR bhr$11[rsp]
  00970	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4788 :                 break; /*while*/

  00976	e9 ec 00 00 00	 jmp	 $LN17@qeth_execu
$LN101@qeth_execu:

; 4789 :             }
; 4790 : 
; 4791 :             /* There are no IDX response buffers chained. */
; 4792 :             if(dev->qdio.idxstate != MPC_IDX_STATE_ACTIVE)

  0097b	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00983	83 b8 34 13 00
	00 01		 cmp	 DWORD PTR [rax+4916], 1
  0098a	74 29		 je	 SHORT $LN113@qeth_execu

; 4793 :             {
; 4794 :                 /* Return unit check with status modifier. */
; 4795 :                 dev->sense[0] = 0;

  0098c	b8 01 00 00 00	 mov	 eax, 1
  00991	48 6b c0 00	 imul	 rax, rax, 0
  00995	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0099d	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [rcx+rax+868], 0

; 4796 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC | CSW_SM;

  009a5	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  009ad	c6 00 4e	 mov	 BYTE PTR [rax], 78	; 0000004eH

; 4797 :                 break; /*while*/

  009b0	e9 b2 00 00 00	 jmp	 $LN17@qeth_execu
$LN113@qeth_execu:

; 4798 :             }
; 4799 : 
; 4800 :             /* Wait for an IDX response buffer to be chained. */
; 4801 :             obtain_lock(&grp->qlock);

  009b5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  009bd	48 83 c0 10	 add	 rax, 16
  009c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174475
  009c8	48 8b c8	 mov	 rcx, rax
  009cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN29@qeth_execu:

; 4802 :             PTT_QETH_TRACE( "read wait", 0,0,0 );

  009d1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  009d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009db	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  009e1	48 85 c0	 test	 rax, rax
  009e4	74 36		 je	 SHORT $LN114@qeth_execu
  009e6	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  009ef	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  009f8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174477
  009ff	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a04	45 33 c9	 xor	 r9d, r9d
  00a07	45 33 c0	 xor	 r8d, r8d
  00a0a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174478
  00a11	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00a16	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN114@qeth_execu:
  00a1c	33 c0		 xor	 eax, eax
  00a1e	85 c0		 test	 eax, eax
  00a20	75 af		 jne	 SHORT $LN29@qeth_execu

; 4803 :             wait_condition( &grp->qrcond, &grp->qlock );

  00a22	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00a2a	48 83 c0 10	 add	 rax, 16
  00a2e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00a36	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174479
  00a3d	48 8b d0	 mov	 rdx, rax
  00a40	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 4804 :             release_lock(&grp->qlock);

  00a46	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00a4e	48 83 c0 10	 add	 rax, 16
  00a52	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174480
  00a59	48 8b c8	 mov	 rcx, rax
  00a5c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 4805 : 
; 4806 :         } /* end while (dev->qdio.idxstate == MPC_IDX_STATE_ACTIVE) */

  00a62	e9 c1 fa ff ff	 jmp	 $LN16@qeth_execu
$LN17@qeth_execu:

; 4807 : 
; 4808 :         if (dev->qdio.idxstate == MPC_IDX_STATE_HALTING)

  00a67	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a6f	83 b8 34 13 00
	00 02		 cmp	 DWORD PTR [rax+4916], 2
  00a76	0f 85 b3 00 00
	00		 jne	 $LN115@qeth_execu

; 4809 :         {
; 4810 :             obtain_lock( &grp->qlock );

  00a7c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00a84	48 83 c0 10	 add	 rax, 16
  00a88	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174482
  00a8f	48 8b c8	 mov	 rcx, rax
  00a92	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN32@qeth_execu:

; 4811 :             PTT_QETH_TRACE( "read hlt ack", 0,0,0 );

  00a98	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00a9f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00aa2	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00aa8	48 85 c0	 test	 rax, rax
  00aab	74 36		 je	 SHORT $LN116@qeth_execu
  00aad	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00ab6	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00abf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174484
  00ac6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00acb	45 33 c9	 xor	 r9d, r9d
  00ace	45 33 c0	 xor	 r8d, r8d
  00ad1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174485
  00ad8	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00add	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN116@qeth_execu:
  00ae3	33 c0		 xor	 eax, eax
  00ae5	85 c0		 test	 eax, eax
  00ae7	75 af		 jne	 SHORT $LN32@qeth_execu

; 4812 :             dev->qdio.idxstate = MPC_IDX_STATE_INACTIVE;

  00ae9	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00af1	c7 80 34 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4916], 0

; 4813 :             signal_condition( &grp->qrcond );

  00afb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00b03	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174486
  00b0a	48 8b c8	 mov	 rcx, rax
  00b0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 4814 :             release_lock( &grp->qlock );

  00b13	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00b1b	48 83 c0 10	 add	 rax, 16
  00b1f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174487
  00b26	48 8b c8	 mov	 rcx, rax
  00b29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN115@qeth_execu:
$LN35@qeth_execu:

; 4815 :         }
; 4816 : 
; 4817 :         PTT_QETH_TRACE( "read exit", 0,0,0 );

  00b2f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00b36	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00b39	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00b3f	48 85 c0	 test	 rax, rax
  00b42	74 36		 je	 SHORT $LN117@qeth_execu
  00b44	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00b4d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00b56	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174489
  00b5d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00b62	45 33 c9	 xor	 r9d, r9d
  00b65	45 33 c0	 xor	 r8d, r8d
  00b68	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174490
  00b6f	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00b74	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN117@qeth_execu:
  00b7a	33 c0		 xor	 eax, eax
  00b7c	85 c0		 test	 eax, eax
  00b7e	75 af		 jne	 SHORT $LN35@qeth_execu

; 4818 : 
; 4819 :         break; /*switch*/

  00b80	e9 31 1c 00 00	 jmp	 $LN8@qeth_execu
$LN118@qeth_execu:

; 4820 : 
; 4821 :     } /* end case 0x02: READ */
; 4822 : 
; 4823 : 
; 4824 :     case 0x03:
; 4825 :     /*---------------------------------------------------------------*/
; 4826 :     /* CONTROL NO-OPERATION                                          */
; 4827 :     /*---------------------------------------------------------------*/
; 4828 : 
; 4829 :         *residual = 0;

  00b85	48 8b 84 24 60
	2f 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00b8d	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 4830 :         *unitstat = CSW_CE | CSW_DE;

  00b93	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00b9b	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4831 :         break;

  00b9e	e9 13 1c 00 00	 jmp	 $LN8@qeth_execu
$LN119@qeth_execu:

; 4832 : 
; 4833 : 
; 4834 :     case 0x14:
; 4835 :     /*---------------------------------------------------------------*/
; 4836 :     /* SENSE COMMAND BYTE                                            */
; 4837 :     /*---------------------------------------------------------------*/
; 4838 :     {
; 4839 :         /* We currently do not support emulated 3088 CTCA mode */
; 4840 :         dev->sense[0] = SENSE_CR;

  00ba3	b8 01 00 00 00	 mov	 eax, 1
  00ba8	48 6b c0 00	 imul	 rax, rax, 0
  00bac	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bb4	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 4841 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00bbc	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00bc4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4842 :         break;

  00bc7	e9 ea 1b 00 00	 jmp	 $LN8@qeth_execu
$LN120@qeth_execu:

; 4843 :     }
; 4844 : 
; 4845 :     case 0x04:
; 4846 :     /*---------------------------------------------------------------*/
; 4847 :     /* SENSE                                                         */
; 4848 :     /*---------------------------------------------------------------*/
; 4849 : 
; 4850 :         /* Calculate residual byte count */
; 4851 :         num = (count < dev->numsense) ? count : dev->numsense;

  00bcc	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bd4	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00bda	39 84 24 30 2f
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00be1	73 10		 jae	 SHORT $LN190@qeth_execu
  00be3	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00bea	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv417[rsp], eax
  00bf1	eb 15		 jmp	 SHORT $LN191@qeth_execu
$LN190@qeth_execu:
  00bf3	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bfb	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00c01	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv417[rsp], eax
$LN191@qeth_execu:
  00c08	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR tv417[rsp]
  00c0f	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$[rsp], eax

; 4852 :         *residual = count - num;

  00c16	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00c1d	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00c24	2b c8		 sub	 ecx, eax
  00c26	8b c1		 mov	 eax, ecx
  00c28	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00c30	89 01		 mov	 DWORD PTR [rcx], eax

; 4853 : //???   if (count < dev->numsense) *more = 1;
; 4854 : 
; 4855 :         /* Copy device sense bytes to channel I/O buffer */
; 4856 :         memcpy (iobuf, dev->sense, num);

  00c32	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00c39	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c41	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  00c48	48 8b bc 24 48
	2f 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00c50	48 8b f1	 mov	 rsi, rcx
  00c53	8b c8		 mov	 ecx, eax
  00c55	f3 a4		 rep movsb

; 4857 : 
; 4858 :         /* Clear the device sense bytes */
; 4859 :         memset (dev->sense, 0, sizeof(dev->sense));

  00c57	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c5f	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00c65	48 8b f8	 mov	 rdi, rax
  00c68	33 c0		 xor	 eax, eax
  00c6a	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00c6f	f3 aa		 rep stosb

; 4860 : 
; 4861 :         /* Return unit status */
; 4862 :         *unitstat = CSW_CE | CSW_DE;

  00c71	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00c79	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4863 :         break;

  00c7c	e9 35 1b 00 00	 jmp	 $LN8@qeth_execu
$LN121@qeth_execu:

; 4864 : 
; 4865 : 
; 4866 :     case 0xE4:
; 4867 :     /*---------------------------------------------------------------*/
; 4868 :     /* SENSE ID                                                      */
; 4869 :     /*---------------------------------------------------------------*/
; 4870 : 
; 4871 :         /* Calculate residual byte count */
; 4872 :         num = (count < dev->numdevid) ? count : dev->numdevid;

  00c81	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c89	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00c8f	39 84 24 30 2f
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00c96	73 10		 jae	 SHORT $LN192@qeth_execu
  00c98	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00c9f	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv434[rsp], eax
  00ca6	eb 15		 jmp	 SHORT $LN193@qeth_execu
$LN192@qeth_execu:
  00ca8	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cb0	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00cb6	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv434[rsp], eax
$LN193@qeth_execu:
  00cbd	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR tv434[rsp]
  00cc4	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$[rsp], eax

; 4873 :         *residual = count - num;

  00ccb	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00cd2	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00cd9	2b c8		 sub	 ecx, eax
  00cdb	8b c1		 mov	 eax, ecx
  00cdd	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00ce5	89 01		 mov	 DWORD PTR [rcx], eax

; 4874 : //???   if (count < dev->numdevid) *more = 1;
; 4875 : 
; 4876 :         /* Copy device identifier bytes to channel I/O buffer */
; 4877 :         memcpy (iobuf, dev->devid, num);

  00ce7	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00cee	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cf6	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  00cfd	48 8b bc 24 48
	2f 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00d05	48 8b f1	 mov	 rsi, rcx
  00d08	8b c8		 mov	 ecx, eax
  00d0a	f3 a4		 rep movsb

; 4878 : 
; 4879 :         /* Return unit status */
; 4880 :         *unitstat = CSW_CE | CSW_DE;

  00d0c	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00d14	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4881 : 
; 4882 :         /* Display formatted Sense Id information, maybe */
; 4883 :         if (grp->debugmask & DBGQETHUPDOWN)

  00d17	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00d1f	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00d25	83 e0 10	 and	 eax, 16
  00d28	85 c0		 test	 eax, eax
  00d2a	0f 84 0a 01 00
	00		 je	 $LN122@qeth_execu

; 4884 :         {
; 4885 :             char buf[1024];
; 4886 :             // HHC03995 "%1d:%04X %s: %s:\n%s"
; 4887 :             WRMSG(HHC03995, "D", LCSS_DEVNUM,

  00d30	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d39	74 15		 je	 SHORT $LN194@qeth_execu
  00d3b	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d43	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d47	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv458[rsp], eax
  00d4e	eb 0b		 jmp	 SHORT $LN195@qeth_execu
$LN194@qeth_execu:
  00d50	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv458[rsp], 0
$LN195@qeth_execu:
  00d5b	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d64	74 17		 je	 SHORT $LN196@qeth_execu
  00d66	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d6e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d72	d1 f8		 sar	 eax, 1
  00d74	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv464[rsp], eax
  00d7b	eb 0b		 jmp	 SHORT $LN197@qeth_execu
$LN196@qeth_execu:
  00d7d	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv464[rsp], 0
$LN197@qeth_execu:
  00d88	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  00d8e	4c 8d 84 24 e0
	22 00 00	 lea	 r8, QWORD PTR buf$28[rsp]
  00d96	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR num$[rsp]
  00d9d	48 8b 8c 24 48
	2f 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00da5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatSID
  00dab	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv446[rsp], rax
  00db3	b9 01 00 00 00	 mov	 ecx, 1
  00db8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dbe	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv446[rsp]
  00dc6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00dcb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174496
  00dd2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00dd7	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ddf	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00de3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00de8	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv458[rsp]
  00def	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00df3	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv464[rsp]
  00dfa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00dfe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174497
  00e05	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174498
  00e11	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e16	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e1b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e21	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174499
  00e28	ba 18 13 00 00	 mov	 edx, 4888		; 00001318H
  00e2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174500
  00e34	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN122@qeth_execu:

; 4888 :                 dev->typname, "SID", FormatSID( iobuf, num, buf, sizeof( buf )));
; 4889 : //          MPC_DUMP_DATA( "SID", iobuf, num, ' ' );
; 4890 :         }
; 4891 :         break;

  00e3a	e9 77 19 00 00	 jmp	 $LN8@qeth_execu
$LN123@qeth_execu:

; 4892 : 
; 4893 : 
; 4894 :     case OSA_RCD:
; 4895 :     /*---------------------------------------------------------------*/
; 4896 :     /* READ CONFIGURATION DATA                                       */
; 4897 :     /*---------------------------------------------------------------*/
; 4898 :     {
; 4899 :         /* Build the configuration data area */
; 4900 :         U32 len = dev->rcd (dev, iobuf, count);

  00e3f	44 8b 84 24 30
	2f 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  00e47	48 8b 94 24 48
	2f 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00e4f	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e57	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e5f	ff 90 b8 02 00
	00		 call	 QWORD PTR [rax+696]
  00e65	89 84 24 dc 00
	00 00		 mov	 DWORD PTR len$15[rsp], eax

; 4901 : 
; 4902 :         /* Calculate residual byte count */
; 4903 :         num = (count < len ? count : len);

  00e6c	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR len$15[rsp]
  00e73	39 84 24 30 2f
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00e7a	73 10		 jae	 SHORT $LN198@qeth_execu
  00e7c	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00e83	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv481[rsp], eax
  00e8a	eb 0e		 jmp	 SHORT $LN199@qeth_execu
$LN198@qeth_execu:
  00e8c	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR len$15[rsp]
  00e93	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv481[rsp], eax
$LN199@qeth_execu:
  00e9a	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv481[rsp]
  00ea1	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$[rsp], eax

; 4904 :         *residual = count - num;

  00ea8	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  00eaf	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00eb6	2b c8		 sub	 ecx, eax
  00eb8	8b c1		 mov	 eax, ecx
  00eba	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00ec2	89 01		 mov	 DWORD PTR [rcx], eax

; 4905 :         if (count < len) *more = 1;

  00ec4	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR len$15[rsp]
  00ecb	39 84 24 30 2f
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00ed2	73 0b		 jae	 SHORT $LN124@qeth_execu
  00ed4	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00edc	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN124@qeth_execu:

; 4906 : 
; 4907 :         /* Return unit status */
; 4908 :         *unitstat = CSW_CE | CSW_DE;

  00edf	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00ee7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4909 : 
; 4910 :         /* Display formatted Read Configuration Data records, maybe */
; 4911 :         if (grp->debugmask & DBGQETHUPDOWN)

  00eea	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00ef2	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00ef8	83 e0 10	 and	 eax, 16
  00efb	85 c0		 test	 eax, eax
  00efd	0f 84 0a 01 00
	00		 je	 $LN125@qeth_execu

; 4912 :         {
; 4913 :             char buf[1024];
; 4914 :             // HHC03995 "%1d:%04X %s: %s:\n%s"
; 4915 :             WRMSG(HHC03995, "D", LCSS_DEVNUM,

  00f03	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f0c	74 15		 je	 SHORT $LN200@qeth_execu
  00f0e	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f16	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00f1a	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv499[rsp], eax
  00f21	eb 0b		 jmp	 SHORT $LN201@qeth_execu
$LN200@qeth_execu:
  00f23	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv499[rsp], 0
$LN201@qeth_execu:
  00f2e	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f37	74 17		 je	 SHORT $LN202@qeth_execu
  00f39	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f41	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00f45	d1 f8		 sar	 eax, 1
  00f47	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv505[rsp], eax
  00f4e	eb 0b		 jmp	 SHORT $LN203@qeth_execu
$LN202@qeth_execu:
  00f50	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv505[rsp], 0
$LN203@qeth_execu:
  00f5b	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  00f61	4c 8d 84 24 e0
	26 00 00	 lea	 r8, QWORD PTR buf$29[rsp]
  00f69	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR num$[rsp]
  00f70	48 8b 8c 24 48
	2f 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00f78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatRCD
  00f7e	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR tv487[rsp], rax
  00f86	b9 01 00 00 00	 mov	 ecx, 1
  00f8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f91	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv487[rsp]
  00f99	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00f9e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174504
  00fa5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00faa	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fb2	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00fb6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00fbb	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv499[rsp]
  00fc2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00fc6	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv505[rsp]
  00fcd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00fd1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174505
  00fd8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fdd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174506
  00fe4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fe9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fee	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ff4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174507
  00ffb	ba 34 13 00 00	 mov	 edx, 4916		; 00001334H
  01000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174508
  01007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN125@qeth_execu:

; 4916 :                 dev->typname, "RCD", FormatRCD( iobuf, num, buf, sizeof( buf )));
; 4917 : //          MPC_DUMP_DATA( "RCD", iobuf, num, ' ' );
; 4918 :         }
; 4919 :         break;

  0100d	e9 a4 17 00 00	 jmp	 $LN8@qeth_execu
$LN126@qeth_execu:

; 4920 :     }
; 4921 : 
; 4922 : 
; 4923 :     case OSA_SII:
; 4924 :     /*---------------------------------------------------------------*/
; 4925 :     /* SET INTERFACE IDENTIFIER                                      */
; 4926 :     /*---------------------------------------------------------------*/
; 4927 :     {
; 4928 :         // ZZ FIXME: PROGRAMMING NOTE: z/VM appears to always reject
; 4929 :         // this command so for the time being so will we. Since we're
; 4930 :         // not 100% sure about this however (we may later determine
; 4931 :         // that we actually need it), we shall simply disable it via
; 4932 :         // temporary #if statements. Once we know for certain we can
; 4933 :         // then remove the #ifs and keep the only code we need.
; 4934 : 
; 4935 : #if 0   // ZZ FIXME: should we be doing this?
; 4936 : 
; 4937 :         /* z/VM 5.3 always rejects this command so we will too */
; 4938 :         dev->sense[0] = SENSE_CR;
; 4939 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;
; 4940 :         break;
; 4941 : 
; 4942 : #else   // ZZ FIXME: or should we be doing this instead?
; 4943 : 
; 4944 :         U32 iir;                    /* Work area to validate IIR     */
; 4945 :         FETCH_FW(iir,iobuf);        /* Fetch IIR into work area      */

  01012	48 8b 8c 24 48
	2f 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  0101a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0101f	8b c8		 mov	 ecx, eax
  01021	e8 00 00 00 00	 call	 _byteswap_ulong
  01026	89 84 24 e0 00
	00 00		 mov	 DWORD PTR iir$16[rsp], eax

; 4946 : 
; 4947 :         /* Command Reject if the Interface ID Record is invalid.
; 4948 :            Note: we only support one interface with an ID of 0. */
; 4949 :         if ((iir & 0xFFFCFFFF) != 0xB0000000 ||

  0102d	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR iir$16[rsp]
  01034	25 ff ff fc ff	 and	 eax, -196609		; fffcffffH
  01039	3d 00 00 00 b0	 cmp	 eax, -1342177280	; b0000000H
  0103e	75 13		 jne	 SHORT $LN128@qeth_execu
  01040	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR iir$16[rsp]
  01047	25 00 00 03 00	 and	 eax, 196608		; 00030000H
  0104c	3d 00 00 03 00	 cmp	 eax, 196608		; 00030000H
  01051	75 29		 jne	 SHORT $LN127@qeth_execu
$LN128@qeth_execu:

; 4950 :             (iir & 0x00030000) == 0x00030000)
; 4951 :         {
; 4952 :             dev->sense[0] = SENSE_CR;

  01053	b8 01 00 00 00	 mov	 eax, 1
  01058	48 6b c0 00	 imul	 rax, rax, 0
  0105c	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01064	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 4953 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0106c	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01074	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4954 :             break;

  01077	e9 3a 17 00 00	 jmp	 $LN8@qeth_execu
$LN127@qeth_execu:

; 4955 :         }
; 4956 : 
; 4957 :         /* Save the requested Interface ID for later unless it's
; 4958 :            not chained (to a presumably following RNI command) */
; 4959 :         if (chained)

  0107c	0f b6 84 24 28
	2f 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  01084	85 c0		 test	 eax, eax
  01086	74 15		 je	 SHORT $LN129@qeth_execu

; 4960 :             grp->iir = iir;

  01088	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  01090	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR iir$16[rsp]
  01097	89 88 24 06 00
	00		 mov	 DWORD PTR [rax+1572], ecx
$LN129@qeth_execu:

; 4961 : 
; 4962 :         /* Calculate residual byte count */
; 4963 :         num = (count < SII_SIZE) ? count : SII_SIZE;

  0109d	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  010a4	48 83 f8 04	 cmp	 rax, 4
  010a8	73 11		 jae	 SHORT $LN204@qeth_execu
  010aa	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  010b1	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv533[rsp], rax
  010b9	eb 0c		 jmp	 SHORT $LN205@qeth_execu
$LN204@qeth_execu:
  010bb	48 c7 84 24 78
	01 00 00 04 00
	00 00		 mov	 QWORD PTR tv533[rsp], 4
$LN205@qeth_execu:
  010c7	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR tv533[rsp]
  010ce	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$[rsp], eax

; 4964 :         *residual = count - num;

  010d5	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  010dc	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  010e3	2b c8		 sub	 ecx, eax
  010e5	8b c1		 mov	 eax, ecx
  010e7	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  010ef	89 01		 mov	 DWORD PTR [rcx], eax

; 4965 :         if (count < SII_SIZE) *more = 1;

  010f1	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  010f8	48 83 f8 04	 cmp	 rax, 4
  010fc	73 0b		 jae	 SHORT $LN130@qeth_execu
  010fe	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01106	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN130@qeth_execu:

; 4966 : 
; 4967 :         /* Return unit status */
; 4968 :         *unitstat = CSW_CE | CSW_DE;

  01109	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01111	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 4969 : 
; 4970 :         /* Display various information, maybe */
; 4971 :         if (grp->debugmask & DBGQETHUPDOWN) {

  01114	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0111c	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  01122	83 e0 10	 and	 eax, 16
  01125	85 c0		 test	 eax, eax
  01127	74 39		 je	 SHORT $LN131@qeth_execu

; 4972 :             MPC_DUMP_DATA( "SII", iobuf, num, ' ' );

  01129	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01131	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174515
  01138	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0113d	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01142	41 b1 20	 mov	 r9b, 32			; 00000020H
  01145	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR num$[rsp]
  0114d	48 8b 94 24 48
	2f 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  01155	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0115d	e8 00 00 00 00	 call	 net_data_trace
$LN131@qeth_execu:

; 4973 :         }
; 4974 : 
; 4975 :         break;

  01162	e9 4f 16 00 00	 jmp	 $LN8@qeth_execu
$LN132@qeth_execu:

; 4976 : 
; 4977 : #endif // ZZ FIXME
; 4978 :     }
; 4979 : 
; 4980 : 
; 4981 :     case OSA_RNI:
; 4982 :     /*---------------------------------------------------------------*/
; 4983 :     /* READ NODE IDENTIFIER                                          */
; 4984 :     /*---------------------------------------------------------------*/
; 4985 :     {
; 4986 :         U32 len = sizeof(node_data);

  01167	c7 84 24 ac 00
	00 00 40 00 00
	00		 mov	 DWORD PTR len$7[rsp], 64 ; 00000040H

; 4987 :         ND *nd = (ND*)iobuf;            /* Node Descriptor pointer   */

  01172	48 8b 84 24 48
	2f 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  0117a	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR nd$21[rsp], rax

; 4988 :         DEVBLK *cua;                    /* Our Control Unit device   */
; 4989 : 
; 4990 :         /* Command Reject if not chained from Set Interface ID */
; 4991 :         if (!chained || prevcode != OSA_SII)

  01182	0f b6 84 24 28
	2f 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  0118a	85 c0		 test	 eax, eax
  0118c	74 0f		 je	 SHORT $LN134@qeth_execu
  0118e	0f b6 84 24 38
	2f 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  01196	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  0119b	74 29		 je	 SHORT $LN133@qeth_execu
$LN134@qeth_execu:

; 4992 :         {
; 4993 :             dev->sense[0] = SENSE_CR;

  0119d	b8 01 00 00 00	 mov	 eax, 1
  011a2	48 6b c0 00	 imul	 rax, rax, 0
  011a6	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011ae	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 4994 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  011b6	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  011be	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 4995 :             break;

  011c1	e9 f0 15 00 00	 jmp	 $LN8@qeth_execu
$LN133@qeth_execu:

; 4996 :         }
; 4997 : 
; 4998 :         /* The first device in the group is the control unit */
; 4999 :         cua = dev->group->memdev[0];

  011c6	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011ce	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  011d2	b9 08 00 00 00	 mov	 ecx, 8
  011d7	48 6b c9 00	 imul	 rcx, rcx, 0
  011db	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  011e0	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR cua$22[rsp], rax

; 5000 : 
; 5001 :         /* If the Node Selector was zero an ND and one or more
; 5002 :            NQs are returned. Otherwise just the ND is returned. */
; 5003 :         if ((grp->iir & 0x00030000) != 0)

  011e8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  011f0	8b 80 24 06 00
	00		 mov	 eax, DWORD PTR [rax+1572]
  011f6	25 00 00 03 00	 and	 eax, 196608		; 00030000H
  011fb	85 c0		 test	 eax, eax
  011fd	74 0b		 je	 SHORT $LN135@qeth_execu

; 5004 :             len = sizeof(ND);

  011ff	c7 84 24 ac 00
	00 00 20 00 00
	00		 mov	 DWORD PTR len$7[rsp], 32 ; 00000020H
$LN135@qeth_execu:

; 5005 : 
; 5006 :         /* Copy configuration data from tempate */
; 5007 :         memcpy (iobuf, node_data, len);

  0120a	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR len$7[rsp]
  01211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:node_data
  01218	48 8b bc 24 48
	2f 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01220	48 8b f1	 mov	 rsi, rcx
  01223	8b c8		 mov	 ecx, eax
  01225	f3 a4		 rep movsb

; 5008 : 
; 5009 :         /* Insert the CHPID of the node into the Node Descriptor ND */
; 5010 :         nd->tag[0] = dev->pmcw.chpid[0];

  01227	b8 01 00 00 00	 mov	 eax, 1
  0122c	48 6b c0 00	 imul	 rax, rax, 0
  01230	b9 01 00 00 00	 mov	 ecx, 1
  01235	48 6b c9 00	 imul	 rcx, rcx, 0
  01239	48 8b 94 24 80
	01 00 00	 mov	 rdx, QWORD PTR nd$21[rsp]
  01241	48 8b bc 24 10
	2f 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  01249	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  01251	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 5011 : 
; 5012 :         /* Update the Node Qualifier information if they want it */
; 5013 :         if (len > (int)sizeof(ND))

  01255	83 bc 24 ac 00
	00 00 20	 cmp	 DWORD PTR len$7[rsp], 32 ; 00000020H
  0125d	76 68		 jbe	 SHORT $LN136@qeth_execu

; 5014 :         {
; 5015 :             NQ *nq = (NQ*)nd + 1;       /* Point to Node Qualifier */

  0125f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR nd$21[rsp]
  01267	48 83 c0 20	 add	 rax, 32			; 00000020H
  0126b	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR nq$23[rsp], rax

; 5016 : 
; 5017 :             /* Insert the CULA CHPID and device number into the NQ */
; 5018 :             nq->rsrvd[1] = cua->pmcw.chpid[0];

  01273	b8 01 00 00 00	 mov	 eax, 1
  01278	48 6b c0 00	 imul	 rax, rax, 0
  0127c	b9 01 00 00 00	 mov	 ecx, 1
  01281	48 6b c9 01	 imul	 rcx, rcx, 1
  01285	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR nq$23[rsp]
  0128d	48 8b bc 24 88
	01 00 00	 mov	 rdi, QWORD PTR cua$22[rsp]
  01295	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  0129d	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 5019 :             nq->rsrvd[2] = cua->devnum & 0xFF;

  012a1	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR cua$22[rsp]
  012a9	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  012ad	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  012b2	b9 01 00 00 00	 mov	 ecx, 1
  012b7	48 6b c9 02	 imul	 rcx, rcx, 2
  012bb	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR nq$23[rsp]
  012c3	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al
$LN136@qeth_execu:

; 5020 :         }
; 5021 : 
; 5022 :         /* Calculate residual byte count */
; 5023 :         num = (count < len ? count : len);

  012c7	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR len$7[rsp]
  012ce	39 84 24 30 2f
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  012d5	73 10		 jae	 SHORT $LN206@qeth_execu
  012d7	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  012de	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv622[rsp], eax
  012e5	eb 0e		 jmp	 SHORT $LN207@qeth_execu
$LN206@qeth_execu:
  012e7	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR len$7[rsp]
  012ee	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv622[rsp], eax
$LN207@qeth_execu:
  012f5	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv622[rsp]
  012fc	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$[rsp], eax

; 5024 :         *residual = count - num;

  01303	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  0130a	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  01311	2b c8		 sub	 ecx, eax
  01313	8b c1		 mov	 eax, ecx
  01315	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0131d	89 01		 mov	 DWORD PTR [rcx], eax

; 5025 :         if (count < len) *more = 1;

  0131f	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR len$7[rsp]
  01326	39 84 24 30 2f
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0132d	73 0b		 jae	 SHORT $LN137@qeth_execu
  0132f	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01337	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN137@qeth_execu:

; 5026 : 
; 5027 :         /* Return unit status */
; 5028 :         *unitstat = CSW_CE | CSW_DE;

  0133a	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01342	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5029 : 
; 5030 :         /* Display formatted Read Node Information, maybe */
; 5031 :         if (grp->debugmask & DBGQETHUPDOWN)

  01345	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0134d	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  01353	83 e0 10	 and	 eax, 16
  01356	85 c0		 test	 eax, eax
  01358	0f 84 0a 01 00
	00		 je	 $LN138@qeth_execu

; 5032 :         {
; 5033 :             char buf[1024];
; 5034 :             // HHC03995 "%1d:%04X %s: %s:\n%s"
; 5035 :             WRMSG(HHC03995, "D", LCSS_DEVNUM,

  0135e	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01367	74 15		 je	 SHORT $LN208@qeth_execu
  01369	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01371	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01375	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv640[rsp], eax
  0137c	eb 0b		 jmp	 SHORT $LN209@qeth_execu
$LN208@qeth_execu:
  0137e	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv640[rsp], 0
$LN209@qeth_execu:
  01389	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01392	74 17		 je	 SHORT $LN210@qeth_execu
  01394	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0139c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  013a0	d1 f8		 sar	 eax, 1
  013a2	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv646[rsp], eax
  013a9	eb 0b		 jmp	 SHORT $LN211@qeth_execu
$LN210@qeth_execu:
  013ab	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv646[rsp], 0
$LN211@qeth_execu:
  013b6	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  013bc	4c 8d 84 24 e0
	2a 00 00	 lea	 r8, QWORD PTR buf$30[rsp]
  013c4	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR num$[rsp]
  013cb	48 8b 8c 24 48
	2f 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  013d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatRNI
  013d9	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv628[rsp], rax
  013e1	b9 01 00 00 00	 mov	 ecx, 1
  013e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013ec	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR tv628[rsp]
  013f4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  013f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174523
  01400	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01405	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0140d	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01411	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01416	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR tv640[rsp]
  0141d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01421	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv646[rsp]
  01428	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0142c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174524
  01433	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01438	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174525
  0143f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01444	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01449	41 b9 03 00 00
	00		 mov	 r9d, 3
  0144f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174526
  01456	ba ac 13 00 00	 mov	 edx, 5036		; 000013acH
  0145b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174527
  01462	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN138@qeth_execu:

; 5036 :                 dev->typname, "RNI", FormatRNI( iobuf, num, buf, sizeof( buf )));
; 5037 : //          MPC_DUMP_DATA( "RNI", iobuf, num, ' ' );
; 5038 :         }
; 5039 :         break;

  01468	e9 49 13 00 00	 jmp	 $LN8@qeth_execu
$LN139@qeth_execu:

; 5040 :     }
; 5041 : 
; 5042 : 
; 5043 :     case OSA_EQ:
; 5044 :     /*---------------------------------------------------------------*/
; 5045 :     /* ESTABLISH QUEUES                                              */
; 5046 :     /*---------------------------------------------------------------*/
; 5047 :     {
; 5048 :         QDIO_QDR *qdr = (QDIO_QDR*)iobuf;

  0146d	48 8b 84 24 48
	2f 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  01475	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR qdr$5[rsp], rax

; 5049 :         QDIO_QDES0 *qdes;
; 5050 :         int qdr_len;
; 5051 :         int accerr = 0;

  0147d	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR accerr$3[rsp], 0

; 5052 :         int i;
; 5053 : 
; 5054 :         dev->qdio.i_qcnt = qdr->iqdcnt < QDIO_MAXQ ? qdr->iqdcnt : QDIO_MAXQ;

  01488	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  01490	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  01494	83 f8 20	 cmp	 eax, 32			; 00000020H
  01497	7d 15		 jge	 SHORT $LN212@qeth_execu
  01499	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  014a1	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  014a5	89 84 24 10 01
	00 00		 mov	 DWORD PTR tv663[rsp], eax
  014ac	eb 0b		 jmp	 SHORT $LN213@qeth_execu
$LN212@qeth_execu:
  014ae	c7 84 24 10 01
	00 00 20 00 00
	00		 mov	 DWORD PTR tv663[rsp], 32 ; 00000020H
$LN213@qeth_execu:
  014b9	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014c1	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR tv663[rsp]
  014c8	89 88 3c 13 00
	00		 mov	 DWORD PTR [rax+4924], ecx

; 5055 :         dev->qdio.o_qcnt = qdr->oqdcnt < QDIO_MAXQ ? qdr->oqdcnt : QDIO_MAXQ;

  014ce	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  014d6	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  014da	83 f8 20	 cmp	 eax, 32			; 00000020H
  014dd	7d 15		 jge	 SHORT $LN214@qeth_execu
  014df	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  014e7	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  014eb	89 84 24 14 01
	00 00		 mov	 DWORD PTR tv670[rsp], eax
  014f2	eb 0b		 jmp	 SHORT $LN215@qeth_execu
$LN214@qeth_execu:
  014f4	c7 84 24 14 01
	00 00 20 00 00
	00		 mov	 DWORD PTR tv670[rsp], 32 ; 00000020H
$LN215@qeth_execu:
  014ff	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01507	8b 8c 24 14 01
	00 00		 mov	 ecx, DWORD PTR tv670[rsp]
  0150e	89 88 c4 13 00
	00		 mov	 DWORD PTR [rax+5060], ecx

; 5056 : 
; 5057 :         DBGTRC( dev, "Establish Queues: Entry");

  01514	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174529
  0151b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01520	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01528	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174530
  0152f	ba c1 13 00 00	 mov	 edx, 5057		; 000013c1H
  01534	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174531
  0153b	e8 00 00 00 00	 call	 dbgtrc
$LN38@qeth_execu:

; 5058 :         PTT_QETH_TRACE( "eq entry", dev->qdio.i_qcnt, dev->qdio.o_qcnt, 0 );

  01540	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01547	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0154a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  01550	48 85 c0	 test	 rax, rax
  01553	74 54		 je	 SHORT $LN140@qeth_execu
  01555	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0155d	48 63 80 c4 13
	00 00		 movsxd	 rax, DWORD PTR [rax+5060]
  01564	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0156c	48 63 89 3c 13
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4924]
  01573	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0157c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01585	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174533
  0158c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01591	4c 8b c8	 mov	 r9, rax
  01594	4c 8b c1	 mov	 r8, rcx
  01597	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174534
  0159e	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  015a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN140@qeth_execu:
  015a9	33 c0		 xor	 eax, eax
  015ab	85 c0		 test	 eax, eax
  015ad	75 91		 jne	 SHORT $LN38@qeth_execu

; 5059 : 
; 5060 :         /* Calculate length of Queue Descriptor Record */
; 5061 :         qdr_len = 0x40;                            /* From start to descriptors */

  015af	c7 84 24 b0 00
	00 00 40 00 00
	00		 mov	 DWORD PTR qdr_len$8[rsp], 64 ; 00000040H

; 5062 :         qdr_len += (qdr->iqdcnt*(qdr->iqdsz<<2));  /* The input queue descriptors */

  015ba	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  015c2	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  015c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR qdr$5[rsp]
  015ce	0f b6 49 09	 movzx	 ecx, BYTE PTR [rcx+9]
  015d2	c1 e1 02	 shl	 ecx, 2
  015d5	0f af c1	 imul	 eax, ecx
  015d8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR qdr_len$8[rsp]
  015df	03 c8		 add	 ecx, eax
  015e1	8b c1		 mov	 eax, ecx
  015e3	89 84 24 b0 00
	00 00		 mov	 DWORD PTR qdr_len$8[rsp], eax

; 5063 :         qdr_len += (qdr->oqdcnt*(qdr->oqdsz<<2));  /* The output queue descriptors */

  015ea	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  015f2	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  015f6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR qdr$5[rsp]
  015fe	0f b6 49 0b	 movzx	 ecx, BYTE PTR [rcx+11]
  01602	c1 e1 02	 shl	 ecx, 2
  01605	0f af c1	 imul	 eax, ecx
  01608	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR qdr_len$8[rsp]
  0160f	03 c8		 add	 ecx, eax
  01611	8b c1		 mov	 eax, ecx
  01613	89 84 24 b0 00
	00 00		 mov	 DWORD PTR qdr_len$8[rsp], eax

; 5064 : 
; 5065 :         /* Display Queue Descriptor Record, maybe */
; 5066 :         if (grp->debugmask) {

  0161a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  01622	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  01629	74 39		 je	 SHORT $LN141@qeth_execu

; 5067 :             net_data_trace( dev, (BYTE*)qdr, qdr_len, ' ', 'D', "QDIO_QDR", 0 );

  0162b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  01633	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174536
  0163a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0163f	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  01644	41 b1 20	 mov	 r9b, 32			; 00000020H
  01647	44 8b 84 24 b0
	00 00 00	 mov	 r8d, DWORD PTR qdr_len$8[rsp]
  0164f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR qdr$5[rsp]
  01657	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0165f	e8 00 00 00 00	 call	 net_data_trace
$LN141@qeth_execu:

; 5068 :         }
; 5069 : 
; 5070 :         /* Check the Queue Information Block storage */
; 5071 :         FETCH_DW(dev->qdio.qiba,qdr->qiba);

  01664	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  0166c	48 83 c0 30	 add	 rax, 48			; 00000030H
  01670	48 8b c8	 mov	 rcx, rax
  01673	e8 00 00 00 00	 call	 fetch_dw_noswap
  01678	48 8b c8	 mov	 rcx, rax
  0167b	e8 00 00 00 00	 call	 _byteswap_uint64
  01680	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01688	48 89 81 60 1b
	00 00		 mov	 QWORD PTR [rcx+7008], rax

; 5072 :         dev->qdio.qibk = qdr->qkey & 0xF0;

  0168f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  01697	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  0169b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  016a0	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  016a8	88 81 58 1b 00
	00		 mov	 BYTE PTR [rcx+7000], al

; 5073 : 
; 5074 :         if(!(accerr = STORCHK(dev->qdio.qiba,sizeof(QDIO_QIB)-1,dev->qdio.qibk,STORKEY_CHANGE,dev)))

  016ae	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016b6	0f b6 80 58 1b
	00 00		 movzx	 eax, BYTE PTR [rax+7000]
  016bd	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  016c5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  016ca	41 b9 02 00 00
	00		 mov	 r9d, 2
  016d0	44 8b c0	 mov	 r8d, eax
  016d3	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  016d8	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016e0	48 8b 88 60 1b
	00 00		 mov	 rcx, QWORD PTR [rax+7008]
  016e7	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  016ec	89 84 24 94 00
	00 00		 mov	 DWORD PTR accerr$3[rsp], eax
  016f3	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR accerr$3[rsp], 0
  016fb	0f 85 90 00 00
	00		 jne	 $LN142@qeth_execu

; 5075 :         {
; 5076 :         QDIO_QIB *qib = (QDIO_QIB*)(dev->mainstor + dev->qdio.qiba);

  01701	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01709	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  01710	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01718	48 03 81 60 1b
	00 00		 add	 rax, QWORD PTR [rcx+7008]
  0171f	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR qib$19[rsp], rax

; 5077 :             qib->ac |= QIB_AC_PCI; // Incidate PCI on output is supported

  01727	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR qib$19[rsp]
  0172f	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  01733	83 c8 40	 or	 eax, 64			; 00000040H
  01736	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR qib$19[rsp]
  0173e	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 5078 : #if defined( _FEATURE_QEBSM )
; 5079 :             if (FACILITY_ENABLED_DEV( HERC_QEBSM ))

  01741	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01748	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  0174f	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  01753	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0175a	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  01762	b9 01 00 00 00	 mov	 ecx, 1
  01767	48 6b c9 21	 imul	 rcx, rcx, 33		; 00000021H
  0176b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0176f	83 e0 08	 and	 eax, 8
  01772	85 c0		 test	 eax, eax
  01774	74 1b		 je	 SHORT $LN143@qeth_execu

; 5080 :                 qib->rflags |= QIB_RFLAGS_QEBSM;

  01776	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR qib$19[rsp]
  0177e	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  01782	0f ba e8 07	 bts	 eax, 7
  01786	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR qib$19[rsp]
  0178e	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN143@qeth_execu:
$LN142@qeth_execu:

; 5081 : #endif
; 5082 :         }
; 5083 : 
; 5084 :         /* Check input Queue Descriptor Entry storage */
; 5085 :         qdes = qdr->qdf0;

  01791	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  01799	48 83 c0 40	 add	 rax, 64			; 00000040H
  0179d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR qdes$4[rsp], rax

; 5086 : 
; 5087 :         for(i = 0; i < dev->qdio.i_qcnt; i++)

  017a5	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$1[rsp], 0
  017b0	eb 10		 jmp	 SHORT $LN41@qeth_execu
$LN39@qeth_execu:
  017b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  017b9	ff c0		 inc	 eax
  017bb	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
$LN41@qeth_execu:
  017c2	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017ca	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  017d0	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$1[rsp], eax
  017d7	0f 8d 2e 02 00
	00		 jge	 $LN40@qeth_execu

; 5088 :         {
; 5089 :             FETCH_DW( dev->qdio.i_sliba[i],  qdes->sliba );

  017dd	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  017e5	48 8b c8	 mov	 rcx, rax
  017e8	e8 00 00 00 00	 call	 fetch_dw_noswap
  017ed	48 8b c8	 mov	 rcx, rax
  017f0	e8 00 00 00 00	 call	 _byteswap_uint64
  017f5	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  017fd	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01805	48 89 84 ca d8
	14 00 00	 mov	 QWORD PTR [rdx+rcx*8+5336], rax

; 5090 :             FETCH_DW( dev->qdio.i_sla[i],    qdes->sla   );

  0180d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01815	48 83 c0 08	 add	 rax, 8
  01819	48 8b c8	 mov	 rcx, rax
  0181c	e8 00 00 00 00	 call	 fetch_dw_noswap
  01821	48 8b c8	 mov	 rcx, rax
  01824	e8 00 00 00 00	 call	 _byteswap_uint64
  01829	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01831	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01839	48 89 84 ca d8
	15 00 00	 mov	 QWORD PTR [rdx+rcx*8+5592], rax

; 5091 :             FETCH_DW( dev->qdio.i_slsbla[i], qdes->slsba );

  01841	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01849	48 83 c0 10	 add	 rax, 16
  0184d	48 8b c8	 mov	 rcx, rax
  01850	e8 00 00 00 00	 call	 fetch_dw_noswap
  01855	48 8b c8	 mov	 rcx, rax
  01858	e8 00 00 00 00	 call	 _byteswap_uint64
  0185d	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01865	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0186d	48 89 84 ca d8
	16 00 00	 mov	 QWORD PTR [rdx+rcx*8+5848], rax

; 5092 : 
; 5093 :             dev->qdio.i_slibk[i]  = (qdes->keyp1)      & 0xF0;

  01875	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  0187d	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  01881	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01886	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0188e	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01896	88 84 0a 54 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5204], al

; 5094 :             dev->qdio.i_slk[i]    = (qdes->keyp1 << 4) & 0xF0;

  0189d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  018a5	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  018a9	c1 e0 04	 shl	 eax, 4
  018ac	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  018b1	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  018b9	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  018c1	88 84 0a 74 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5236], al

; 5095 :             dev->qdio.i_sbalk[i]  = (qdes->keyp2)      & 0xF0;

  018c8	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  018d0	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  018d4	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  018d9	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  018e1	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  018e9	88 84 0a 94 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5268], al

; 5096 :             dev->qdio.i_slsblk[i] = (qdes->keyp2 << 4) & 0xF0;

  018f0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  018f8	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  018fc	c1 e0 04	 shl	 eax, 4
  018ff	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01904	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0190c	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01914	88 84 0a b4 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5300], al

; 5097 : 
; 5098 :             accerr |= STORCHK( dev->qdio.i_slsbla[i], sizeof(QDIO_SLSB) - 1, dev->qdio.i_slsblk[i], STORKEY_CHANGE, dev );

  0191b	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  01923	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0192b	0f b6 84 01 b4
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5300]
  01933	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0193b	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01943	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01948	41 b9 02 00 00
	00		 mov	 r9d, 2
  0194e	44 8b c0	 mov	 r8d, eax
  01951	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  01956	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0195e	48 8b 8c c8 d8
	16 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+5848]
  01966	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  0196b	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR accerr$3[rsp]
  01972	0b c8		 or	 ecx, eax
  01974	8b c1		 mov	 eax, ecx
  01976	89 84 24 94 00
	00 00		 mov	 DWORD PTR accerr$3[rsp], eax

; 5099 :             accerr |= STORCHK( dev->qdio.i_sla[i],    sizeof(QDIO_SL)   - 1, dev->qdio.i_slk[i],    STORKEY_REF,    dev );

  0197d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  01985	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0198d	0f b6 84 01 74
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5236]
  01995	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0199d	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  019a5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  019aa	41 b9 04 00 00
	00		 mov	 r9d, 4
  019b0	44 8b c0	 mov	 r8d, eax
  019b3	ba ff 03 00 00	 mov	 edx, 1023		; 000003ffH
  019b8	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  019c0	48 8b 8c c8 d8
	15 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+5592]
  019c8	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  019cd	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR accerr$3[rsp]
  019d4	0b c8		 or	 ecx, eax
  019d6	8b c1		 mov	 eax, ecx
  019d8	89 84 24 94 00
	00 00		 mov	 DWORD PTR accerr$3[rsp], eax

; 5100 : 
; 5101 :             qdes = (QDIO_QDES0*) ((BYTE*)qdes+(qdr->iqdsz << 2));

  019df	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  019e7	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  019eb	c1 e0 02	 shl	 eax, 2
  019ee	48 98		 cdqe
  019f0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR qdes$4[rsp]
  019f8	48 03 c8	 add	 rcx, rax
  019fb	48 8b c1	 mov	 rax, rcx
  019fe	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR qdes$4[rsp], rax

; 5102 :         }

  01a06	e9 a7 fd ff ff	 jmp	 $LN39@qeth_execu
$LN40@qeth_execu:

; 5103 : 
; 5104 :         /* Check output Queue Descriptor Entry storage */
; 5105 :         for(i = 0; i < dev->qdio.o_qcnt; i++)

  01a0b	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR i$1[rsp], 0
  01a16	eb 10		 jmp	 SHORT $LN44@qeth_execu
$LN42@qeth_execu:
  01a18	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR i$1[rsp]
  01a1f	ff c0		 inc	 eax
  01a21	89 84 24 80 00
	00 00		 mov	 DWORD PTR i$1[rsp], eax
$LN44@qeth_execu:
  01a28	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01a30	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  01a36	39 84 24 80 00
	00 00		 cmp	 DWORD PTR i$1[rsp], eax
  01a3d	0f 8d 2e 02 00
	00		 jge	 $LN43@qeth_execu

; 5106 :         {
; 5107 :             FETCH_DW( dev->qdio.o_sliba[i],  qdes->sliba );

  01a43	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01a4b	48 8b c8	 mov	 rcx, rax
  01a4e	e8 00 00 00 00	 call	 fetch_dw_noswap
  01a53	48 8b c8	 mov	 rcx, rax
  01a56	e8 00 00 00 00	 call	 _byteswap_uint64
  01a5b	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01a63	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01a6b	48 89 84 ca 58
	18 00 00	 mov	 QWORD PTR [rdx+rcx*8+6232], rax

; 5108 :             FETCH_DW( dev->qdio.o_sla[i],    qdes->sla   );

  01a73	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01a7b	48 83 c0 08	 add	 rax, 8
  01a7f	48 8b c8	 mov	 rcx, rax
  01a82	e8 00 00 00 00	 call	 fetch_dw_noswap
  01a87	48 8b c8	 mov	 rcx, rax
  01a8a	e8 00 00 00 00	 call	 _byteswap_uint64
  01a8f	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01a97	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01a9f	48 89 84 ca 58
	19 00 00	 mov	 QWORD PTR [rdx+rcx*8+6488], rax

; 5109 :             FETCH_DW( dev->qdio.o_slsbla[i], qdes->slsba );

  01aa7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01aaf	48 83 c0 10	 add	 rax, 16
  01ab3	48 8b c8	 mov	 rcx, rax
  01ab6	e8 00 00 00 00	 call	 fetch_dw_noswap
  01abb	48 8b c8	 mov	 rcx, rax
  01abe	e8 00 00 00 00	 call	 _byteswap_uint64
  01ac3	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01acb	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01ad3	48 89 84 ca 58
	1a 00 00	 mov	 QWORD PTR [rdx+rcx*8+6744], rax

; 5110 : 
; 5111 :             dev->qdio.o_slibk[i]  = (qdes->keyp1)      & 0xF0;

  01adb	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01ae3	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  01ae7	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01aec	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01af4	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01afc	88 84 0a d8 17
	00 00		 mov	 BYTE PTR [rdx+rcx+6104], al

; 5112 :             dev->qdio.o_slk[i]    = (qdes->keyp1 << 4) & 0xF0;

  01b03	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01b0b	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  01b0f	c1 e0 04	 shl	 eax, 4
  01b12	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01b17	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01b1f	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01b27	88 84 0a f8 17
	00 00		 mov	 BYTE PTR [rdx+rcx+6136], al

; 5113 :             dev->qdio.o_sbalk[i]  = (qdes->keyp2)      & 0xF0;

  01b2e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01b36	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  01b3a	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01b3f	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01b47	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01b4f	88 84 0a 18 18
	00 00		 mov	 BYTE PTR [rdx+rcx+6168], al

; 5114 :             dev->qdio.o_slsblk[i] = (qdes->keyp2 << 4) & 0xF0;

  01b56	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR qdes$4[rsp]
  01b5e	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  01b62	c1 e0 04	 shl	 eax, 4
  01b65	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01b6a	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01b72	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01b7a	88 84 0a 38 18
	00 00		 mov	 BYTE PTR [rdx+rcx+6200], al

; 5115 : 
; 5116 :             accerr |= STORCHK( dev->qdio.o_slsbla[i], sizeof(QDIO_SLSB) - 1, dev->qdio.o_slsblk[i], STORKEY_CHANGE, dev );

  01b81	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  01b89	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01b91	0f b6 84 01 38
	18 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6200]
  01b99	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01ba1	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01ba9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01bae	41 b9 02 00 00
	00		 mov	 r9d, 2
  01bb4	44 8b c0	 mov	 r8d, eax
  01bb7	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  01bbc	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01bc4	48 8b 8c c8 58
	1a 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+6744]
  01bcc	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  01bd1	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR accerr$3[rsp]
  01bd8	0b c8		 or	 ecx, eax
  01bda	8b c1		 mov	 eax, ecx
  01bdc	89 84 24 94 00
	00 00		 mov	 DWORD PTR accerr$3[rsp], eax

; 5117 :             accerr |= STORCHK( dev->qdio.o_sla[i],    sizeof(QDIO_SL)   - 1, dev->qdio.o_slk[i],    STORKEY_REF,    dev );

  01be3	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR i$1[rsp]
  01beb	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01bf3	0f b6 84 01 f8
	17 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6136]
  01bfb	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01c03	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01c0b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01c10	41 b9 04 00 00
	00		 mov	 r9d, 4
  01c16	44 8b c0	 mov	 r8d, eax
  01c19	ba ff 03 00 00	 mov	 edx, 1023		; 000003ffH
  01c1e	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01c26	48 8b 8c c8 58
	19 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+6488]
  01c2e	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  01c33	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR accerr$3[rsp]
  01c3a	0b c8		 or	 ecx, eax
  01c3c	8b c1		 mov	 eax, ecx
  01c3e	89 84 24 94 00
	00 00		 mov	 DWORD PTR accerr$3[rsp], eax

; 5118 : 
; 5119 :             qdes = (QDIO_QDES0*) ((BYTE*)qdes+(qdr->oqdsz << 2));

  01c45	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR qdr$5[rsp]
  01c4d	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  01c51	c1 e0 02	 shl	 eax, 2
  01c54	48 98		 cdqe
  01c56	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR qdes$4[rsp]
  01c5e	48 03 c8	 add	 rcx, rax
  01c61	48 8b c1	 mov	 rax, rcx
  01c64	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR qdes$4[rsp], rax

; 5120 :         }

  01c6c	e9 a7 fd ff ff	 jmp	 $LN42@qeth_execu
$LN43@qeth_execu:

; 5121 : 
; 5122 :         /* Initialize All Queues */
; 5123 :         qeth_init_queues(dev);

  01c71	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01c79	e8 00 00 00 00	 call	 qeth_init_queues

; 5124 : 
; 5125 :         /* Calculate residual byte count */
; 5126 :         num = (count < sizeof(QDIO_QDR)) ? count : sizeof(QDIO_QDR);

  01c7e	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01c85	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01c8b	73 11		 jae	 SHORT $LN216@qeth_execu
  01c8d	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01c94	48 89 84 24 98
	01 00 00	 mov	 QWORD PTR tv996[rsp], rax
  01c9c	eb 0c		 jmp	 SHORT $LN217@qeth_execu
$LN216@qeth_execu:
  01c9e	48 c7 84 24 98
	01 00 00 00 10
	00 00		 mov	 QWORD PTR tv996[rsp], 4096 ; 00001000H
$LN217@qeth_execu:
  01caa	8b 84 24 98 01
	00 00		 mov	 eax, DWORD PTR tv996[rsp]
  01cb1	89 84 24 90 00
	00 00		 mov	 DWORD PTR num$[rsp], eax

; 5127 :         *residual = count - num;

  01cb8	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR num$[rsp]
  01cbf	8b 8c 24 30 2f
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  01cc6	2b c8		 sub	 ecx, eax
  01cc8	8b c1		 mov	 eax, ecx
  01cca	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01cd2	89 01		 mov	 DWORD PTR [rcx], eax

; 5128 :         if (count < sizeof(QDIO_QDR)) *more = 1;

  01cd4	8b 84 24 30 2f
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01cdb	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01ce1	73 0b		 jae	 SHORT $LN144@qeth_execu
  01ce3	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01ceb	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN144@qeth_execu:

; 5129 : 
; 5130 :         if(!accerr)

  01cee	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR accerr$3[rsp], 0
  01cf6	75 6c		 jne	 SHORT $LN145@qeth_execu

; 5131 :         {
; 5132 :             /* Return unit status */
; 5133 :             *unitstat = CSW_CE | CSW_DE;

  01cf8	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01d00	c6 00 0c	 mov	 BYTE PTR [rax], 12
$LN47@qeth_execu:

; 5134 :             PTT_QETH_TRACE( "eq exit", *unitstat, 0, 0 );

  01d03	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01d0a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01d0d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  01d13	48 85 c0	 test	 rax, rax
  01d16	74 41		 je	 SHORT $LN147@qeth_execu
  01d18	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01d20	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01d23	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01d2c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01d35	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174543
  01d3c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01d41	45 33 c9	 xor	 r9d, r9d
  01d44	44 8b c0	 mov	 r8d, eax
  01d47	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174544
  01d4e	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  01d53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN147@qeth_execu:
  01d59	33 c0		 xor	 eax, eax
  01d5b	85 c0		 test	 eax, eax
  01d5d	75 a4		 jne	 SHORT $LN47@qeth_execu

; 5135 :         }

  01d5f	e9 9d 00 00 00	 jmp	 $LN146@qeth_execu
$LN145@qeth_execu:

; 5136 :         else
; 5137 :         {
; 5138 :             /* Command reject on invalid or inaccessible storage addresses */
; 5139 :             dev->sense[0] = SENSE_CR;

  01d64	b8 01 00 00 00	 mov	 eax, 1
  01d69	48 6b c0 00	 imul	 rax, rax, 0
  01d6d	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01d75	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 5140 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01d7d	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01d85	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN50@qeth_execu:

; 5141 :             PTT_QETH_TRACE( "*eq exit", *unitstat, dev->sense[0], accerr );

  01d88	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01d8f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01d92	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  01d98	48 85 c0	 test	 rax, rax
  01d9b	74 5e		 je	 SHORT $LN148@qeth_execu
  01d9d	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR accerr$3[rsp]
  01da5	b9 01 00 00 00	 mov	 ecx, 1
  01daa	48 6b c9 00	 imul	 rcx, rcx, 0
  01dae	48 8b 94 24 10
	2f 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01db6	0f b6 8c 0a 64
	03 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+868]
  01dbe	48 8b 94 24 58
	2f 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  01dc6	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  01dc9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01dd2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01dd7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174546
  01dde	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01de3	44 8b c9	 mov	 r9d, ecx
  01de6	44 8b c2	 mov	 r8d, edx
  01de9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174547
  01df0	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  01df5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN148@qeth_execu:
  01dfb	33 c0		 xor	 eax, eax
  01dfd	85 c0		 test	 eax, eax
  01dff	75 87		 jne	 SHORT $LN50@qeth_execu
$LN146@qeth_execu:

; 5142 :         }
; 5143 : 
; 5144 :         DBGTRC( dev, "Establish Queues: Exit");

  01e01	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174548
  01e08	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e0d	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01e15	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174549
  01e1c	ba 18 14 00 00	 mov	 edx, 5144		; 00001418H
  01e21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174550
  01e28	e8 00 00 00 00	 call	 dbgtrc

; 5145 :         break;

  01e2d	e9 84 09 00 00	 jmp	 $LN8@qeth_execu
$LN149@qeth_execu:

; 5146 :     }
; 5147 : 
; 5148 : 
; 5149 :     case OSA_AQ:
; 5150 :     /*---------------------------------------------------------------*/
; 5151 :     /* ACTIVATE QUEUES                                               */
; 5152 :     /*---------------------------------------------------------------*/
; 5153 :     {
; 5154 :     fd_set readset;                         /* select read set       */
; 5155 :     struct timeval tv;                      /* select polling        */
; 5156 :     int fd;                                 /* select fd             */
; 5157 :     int rc=0;                               /* select rc (0=timeout) */

  01e32	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$17[rsp], 0

; 5158 :     BYTE sig;                               /* thread pipe signal    */
; 5159 : 
; 5160 :         /*
; 5161 :         ** PROGRAMMING NOTE: we use a relatively short timeout value
; 5162 :         ** for our select so that we can react fairly quickly to the
; 5163 :         ** guest readying (priming) additional output buffers in its
; 5164 :         ** existing Output Queue(s) because a SIGA-w is not required.
; 5165 :         */
; 5166 :         dev->scsw.flag2 |= SCSW2_Q;         /* Indicate QDIO active  */

  01e3d	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e45	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  01e4c	0f ba e8 07	 bts	 eax, 7
  01e50	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01e58	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 5167 :         dev->qtype = QTYPE_DATA;            /* Identify ourselves    */

  01e5e	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e66	c6 80 80 1b 00
	00 03		 mov	 BYTE PTR [rax+7040], 3

; 5168 : 
; 5169 :         DBGTRC( dev, "Activate Queues: Entry iqm=%8.8x oqm=%8.8x",dev->qdio.i_qmask, dev->qdio.o_qmask);

  01e6d	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e75	8b 80 50 14 00
	00		 mov	 eax, DWORD PTR [rax+5200]
  01e7b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01e7f	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e87	8b 80 4c 14 00
	00		 mov	 eax, DWORD PTR [rax+5196]
  01e8d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01e91	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174552
  01e98	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e9d	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01ea5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174553
  01eac	ba 31 14 00 00	 mov	 edx, 5169		; 00001431H
  01eb1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174554
  01eb8	e8 00 00 00 00	 call	 dbgtrc
$LN53@qeth_execu:

; 5170 :         PTT_QETH_TRACE( "actq entr", 0,0,0 );

  01ebd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  01ec4	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01ec7	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  01ecd	48 85 c0	 test	 rax, rax
  01ed0	74 36		 je	 SHORT $LN150@qeth_execu
  01ed2	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01edb	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  01ee4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174556
  01eeb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01ef0	45 33 c9	 xor	 r9d, r9d
  01ef3	45 33 c0	 xor	 r8d, r8d
  01ef6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174557
  01efd	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  01f02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN150@qeth_execu:
  01f08	33 c0		 xor	 eax, eax
  01f0a	85 c0		 test	 eax, eax
  01f0c	75 af		 jne	 SHORT $LN53@qeth_execu
$LN54@qeth_execu:

; 5171 : 
; 5172 :         /* Loop until halt signal is received via notification pipe */
; 5173 :         while (1)

  01f0e	33 c0		 xor	 eax, eax
  01f10	83 f8 01	 cmp	 eax, 1
  01f13	0f 84 d8 06 00
	00		 je	 $LN55@qeth_execu

; 5174 :         {
; 5175 :             /* Prepare to wait for additional packets or pipe signal */
; 5176 :             FD_ZERO( &readset );

  01f19	c7 84 24 d0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR readset$26[rsp], 0

; 5177 :             FD_SET( grp->ppfd[0], &readset );

  01f24	b8 04 00 00 00	 mov	 eax, 4
  01f29	48 6b c0 00	 imul	 rax, rax, 0
  01f2d	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR readset$26[rsp]
  01f35	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  01f3d	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  01f44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 5178 :             FD_SET( grp->ttfd,    &readset );

  01f4a	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR readset$26[rsp]
  01f52	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  01f5a	8b 88 f8 05 00
	00		 mov	 ecx, DWORD PTR [rax+1528]
  01f60	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 5179 :             fd = max( grp->ppfd[0], grp->ttfd );

  01f66	b8 04 00 00 00	 mov	 eax, 4
  01f6b	48 6b c0 00	 imul	 rax, rax, 0
  01f6f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  01f77	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  01f7f	8b 92 f8 05 00
	00		 mov	 edx, DWORD PTR [rdx+1528]
  01f85	39 94 01 fc 05
	00 00		 cmp	 DWORD PTR [rcx+rax+1532], edx
  01f8c	7e 21		 jle	 SHORT $LN218@qeth_execu
  01f8e	b8 04 00 00 00	 mov	 eax, 4
  01f93	48 6b c0 00	 imul	 rax, rax, 0
  01f97	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  01f9f	8b 84 01 fc 05
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1532]
  01fa6	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv1080[rsp], eax
  01fad	eb 15		 jmp	 SHORT $LN219@qeth_execu
$LN218@qeth_execu:
  01faf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  01fb7	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01fbd	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv1080[rsp], eax
$LN219@qeth_execu:
  01fc4	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv1080[rsp]
  01fcb	89 84 24 70 01
	00 00		 mov	 DWORD PTR fd$20[rsp], eax

; 5180 :             tv.tv_sec  = 0;

  01fd2	c7 84 24 a0 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv$24[rsp], 0

; 5181 :             tv.tv_usec = OSA_TIMEOUTUS;         /* Select timeout usecs  */

  01fdd	c7 84 24 a4 01
	00 00 50 c3 00
	00		 mov	 DWORD PTR tv$24[rsp+4], 50000 ; 0000c350H

; 5182 : 
; 5183 :             /* Wait (but only very briefly) for more work to arrive */
; 5184 :             rc = qeth_select( fd+1, &readset, &tv );

  01fe8	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR fd$20[rsp]
  01fef	ff c0		 inc	 eax
  01ff1	4c 8d 84 24 a0
	01 00 00	 lea	 r8, QWORD PTR tv$24[rsp]
  01ff9	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR readset$26[rsp]
  02001	8b c8		 mov	 ecx, eax
  02003	e8 00 00 00 00	 call	 qeth_select
  02008	89 84 24 e4 00
	00 00		 mov	 DWORD PTR rc$17[rsp], eax

; 5185 : 
; 5186 :             /* Read pipe signal if one was sent */
; 5187 :             if (unlikely( rc && FD_ISSET( grp->ppfd[0], &readset )))

  0200f	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR rc$17[rsp], 0
  02017	74 37		 je	 SHORT $LN220@qeth_execu
  02019	b8 04 00 00 00	 mov	 eax, 4
  0201e	48 6b c0 00	 imul	 rax, rax, 0
  02022	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR readset$26[rsp]
  0202a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  02032	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  02039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  0203f	85 c0		 test	 eax, eax
  02041	74 0d		 je	 SHORT $LN220@qeth_execu
  02043	c7 84 24 1c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1103[rsp], 1
  0204e	eb 0b		 jmp	 SHORT $LN223@qeth_execu
$LN220@qeth_execu:
  02050	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1103[rsp], 0
$LN223@qeth_execu:
  0205b	83 bc 24 1c 01
	00 00 00	 cmp	 DWORD PTR tv1103[rsp], 0
  02063	0f 84 10 02 00
	00		 je	 $LN151@qeth_execu

; 5188 :             {
; 5189 :                 sig = QDSIG_RESET;

  02069	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR sig$2[rsp], 0
$LN58@qeth_execu:

; 5190 :                 VERIFY( qeth_read_pipe( grp->ppfd[0], &sig ) == 1);

  02071	b8 04 00 00 00	 mov	 eax, 4
  02076	48 6b c0 00	 imul	 rax, rax, 0
  0207a	48 8d 94 24 84
	00 00 00	 lea	 rdx, QWORD PTR sig$2[rsp]
  02082	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0208a	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  02091	e8 00 00 00 00	 call	 qeth_read_pipe
  02096	83 f8 01	 cmp	 eax, 1
  02099	74 5c		 je	 SHORT $LN152@qeth_execu
$LN61@qeth_execu:
  0209b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174560
  020a2	41 b8 46 14 00
	00		 mov	 r8d, 5190		; 00001446H
  020a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174561
  020af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174562
  020b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  020bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  020c2	85 c0		 test	 eax, eax
  020c4	74 20		 je	 SHORT $LN153@qeth_execu
  020c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174564
  020cd	41 b8 46 14 00
	00		 mov	 r8d, 5190		; 00001446H
  020d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174565
  020da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174566
  020e1	e8 00 00 00 00	 call	 DebuggerTrace
$LN153@qeth_execu:
  020e6	33 c0		 xor	 eax, eax
  020e8	85 c0		 test	 eax, eax
  020ea	75 af		 jne	 SHORT $LN61@qeth_execu
  020ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  020f2	85 c0		 test	 eax, eax
  020f4	74 01		 je	 SHORT $LN154@qeth_execu
  020f6	cc		 int	 3
$LN154@qeth_execu:
$LN152@qeth_execu:
  020f7	33 c0		 xor	 eax, eax
  020f9	85 c0		 test	 eax, eax
  020fb	0f 85 70 ff ff
	ff		 jne	 $LN58@qeth_execu

; 5191 :                 if (QDSIG_HALT == sig || grp->debugmask & DBGQETHQUEUES)

  02101	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR sig$2[rsp]
  02109	83 f8 01	 cmp	 eax, 1
  0210c	74 17		 je	 SHORT $LN156@qeth_execu
  0210e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02116	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  0211c	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  02121	85 c0		 test	 eax, eax
  02123	74 3e		 je	 SHORT $LN155@qeth_execu
$LN156@qeth_execu:

; 5192 :                     DBGTRC( dev, "Activate Queues: %s received", qsig2str( sig ));

  02125	0f b6 8c 24 84
	00 00 00	 movzx	 ecx, BYTE PTR sig$2[rsp]
  0212d	e8 00 00 00 00	 call	 qsig2str
  02132	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  02137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174570
  0213e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02143	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0214b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174571
  02152	ba 48 14 00 00	 mov	 edx, 5192		; 00001448H
  02157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174572
  0215e	e8 00 00 00 00	 call	 dbgtrc
$LN155@qeth_execu:

; 5193 : 
; 5194 :                 /* Exit immediately when requested to do so */
; 5195 :                 if (QDSIG_HALT == sig)

  02163	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR sig$2[rsp]
  0216b	83 f8 01	 cmp	 eax, 1
  0216e	75 05		 jne	 SHORT $LN157@qeth_execu

; 5196 :                     break;

  02170	e9 7c 04 00 00	 jmp	 $LN55@qeth_execu
$LN157@qeth_execu:

; 5197 : 
; 5198 :                 switch (sig)

  02175	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR sig$2[rsp]
  0217d	88 84 24 b4 00
	00 00		 mov	 BYTE PTR tv1142[rsp], al
  02184	80 bc 24 b4 00
	00 00 03	 cmp	 BYTE PTR tv1142[rsp], 3
  0218c	74 2a		 je	 SHORT $LN158@qeth_execu
  0218e	80 bc 24 b4 00
	00 00 04	 cmp	 BYTE PTR tv1142[rsp], 4
  02196	74 37		 je	 SHORT $LN159@qeth_execu
  02198	80 bc 24 b4 00
	00 00 05	 cmp	 BYTE PTR tv1142[rsp], 5
  021a0	74 44		 je	 SHORT $LN160@qeth_execu
  021a2	80 bc 24 b4 00
	00 00 06	 cmp	 BYTE PTR tv1142[rsp], 6
  021aa	74 4e		 je	 SHORT $LN161@qeth_execu
  021ac	80 bc 24 b4 00
	00 00 07	 cmp	 BYTE PTR tv1142[rsp], 7
  021b4	74 58		 je	 SHORT $LN162@qeth_execu
  021b6	eb 58		 jmp	 SHORT $LN163@qeth_execu
$LN158@qeth_execu:

; 5199 :                 {
; 5200 :                 case QDSIG_READ:
; 5201 :                     grp->rdpack = 0;

  021b8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  021c0	c7 80 e8 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1512], 0

; 5202 :                     break;

  021ca	e9 aa 00 00 00	 jmp	 $LN62@qeth_execu
$LN159@qeth_execu:

; 5203 :                 case QDSIG_RDMULT:
; 5204 :                     grp->rdpack = 1;

  021cf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  021d7	c7 80 e8 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1512], 1

; 5205 :                     break;

  021e1	e9 93 00 00 00	 jmp	 $LN62@qeth_execu
$LN160@qeth_execu:

; 5206 :                 case QDSIG_WRIT:
; 5207 :                     grp->wrpack = 0;

  021e6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  021ee	c7 80 ec 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1516], 0

; 5208 :                     break;

  021f8	eb 7f		 jmp	 SHORT $LN62@qeth_execu
$LN161@qeth_execu:

; 5209 :                 case QDSIG_WRMULT:
; 5210 :                     grp->wrpack = 1;

  021fa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02202	c7 80 ec 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1516], 1

; 5211 :                     break;

  0220c	eb 6b		 jmp	 SHORT $LN62@qeth_execu
$LN162@qeth_execu:

; 5212 :                 case QDSIG_WAKEUP:
; 5213 :                     break;

  0220e	eb 69		 jmp	 SHORT $LN62@qeth_execu
$LN163@qeth_execu:
$LN66@qeth_execu:

; 5214 :                 default:
; 5215 :                     ASSERT(0);  /* (should NEVER occur) */

  02210	33 c0		 xor	 eax, eax
  02212	83 f8 01	 cmp	 eax, 1
  02215	74 5c		 je	 SHORT $LN164@qeth_execu
$LN69@qeth_execu:
  02217	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174581
  0221e	41 b8 5f 14 00
	00		 mov	 r8d, 5215		; 0000145fH
  02224	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174582
  0222b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174583
  02232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  02238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0223e	85 c0		 test	 eax, eax
  02240	74 20		 je	 SHORT $LN165@qeth_execu
  02242	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG174585
  02249	41 b8 5f 14 00
	00		 mov	 r8d, 5215		; 0000145fH
  0224f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174586
  02256	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174587
  0225d	e8 00 00 00 00	 call	 DebuggerTrace
$LN165@qeth_execu:
  02262	33 c0		 xor	 eax, eax
  02264	85 c0		 test	 eax, eax
  02266	75 af		 jne	 SHORT $LN69@qeth_execu
  02268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0226e	85 c0		 test	 eax, eax
  02270	74 01		 je	 SHORT $LN166@qeth_execu
  02272	cc		 int	 3
$LN166@qeth_execu:
$LN164@qeth_execu:
  02273	33 c0		 xor	 eax, eax
  02275	85 c0		 test	 eax, eax
  02277	75 97		 jne	 SHORT $LN66@qeth_execu
$LN62@qeth_execu:
$LN151@qeth_execu:

; 5216 :                 }
; 5217 :             }
; 5218 : 
; 5219 :             /* Check if any new packets have arrived */
; 5220 :             if ((rc && FD_ISSET( grp->ttfd, &readset )) || grp->l3r.firstbhr)

  02279	83 bc 24 e4 00
	00 00 00	 cmp	 DWORD PTR rc$17[rsp], 0
  02281	74 20		 je	 SHORT $LN169@qeth_execu
  02283	48 8d 94 24 d0
	01 00 00	 lea	 rdx, QWORD PTR readset$26[rsp]
  0228b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02293	8b 88 f8 05 00
	00		 mov	 ecx, DWORD PTR [rax+1528]
  02299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  0229f	85 c0		 test	 eax, eax
  022a1	75 13		 jne	 SHORT $LN168@qeth_execu
$LN169@qeth_execu:
  022a3	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  022ab	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  022b0	0f 84 71 02 00
	00		 je	 $LN167@qeth_execu
$LN168@qeth_execu:

; 5221 :             {
; 5222 :                 /* Process packets if Queue is available */
; 5223 :                 if (likely( dev->qdio.i_qmask ))

  022b6	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  022be	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  022c5	74 0d		 je	 SHORT $LN224@qeth_execu
  022c7	c7 84 24 20 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1180[rsp], 1
  022d2	eb 0b		 jmp	 SHORT $LN225@qeth_execu
$LN224@qeth_execu:
  022d4	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1180[rsp], 0
$LN225@qeth_execu:
  022df	83 bc 24 20 01
	00 00 00	 cmp	 DWORD PTR tv1180[rsp], 0
  022e7	0f 84 93 00 00
	00		 je	 $LN170@qeth_execu

; 5224 :                 {
; 5225 :                     process_input_queues( dev );

  022ed	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  022f5	e8 00 00 00 00	 call	 process_input_queues

; 5226 : 
; 5227 :                     /* Present "input available" interrupt if needed */
; 5228 :                     if (grp->iqPCI)

  022fa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02302	83 b8 f0 05 00
	00 00		 cmp	 DWORD PTR [rax+1520], 0
  02309	74 70		 je	 SHORT $LN172@qeth_execu
$LN72@qeth_execu:

; 5229 :                     {
; 5230 :                         PTT_QETH_TRACE( "actq iqPCI", 0,0,0 );

  0230b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02312	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02315	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0231b	48 85 c0	 test	 rax, rax
  0231e	74 36		 je	 SHORT $LN173@qeth_execu
  02320	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02329	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02332	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174596
  02339	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0233e	45 33 c9	 xor	 r9d, r9d
  02341	45 33 c0	 xor	 r8d, r8d
  02344	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174597
  0234b	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  02350	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN173@qeth_execu:
  02356	33 c0		 xor	 eax, eax
  02358	85 c0		 test	 eax, eax
  0235a	75 af		 jne	 SHORT $LN72@qeth_execu

; 5231 :                         grp->iqPCI = FALSE;

  0235c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02364	c7 80 f0 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1520], 0

; 5232 :                         raise_adapter_interrupt( dev );

  0236e	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02376	e8 00 00 00 00	 call	 raise_adapter_interrupt
$LN172@qeth_execu:

; 5233 :                     }
; 5234 :                 }

  0237b	e9 a7 01 00 00	 jmp	 $LN171@qeth_execu
$LN170@qeth_execu:

; 5235 :                 else /* (no I/P queues? VERY unlikely!) */
; 5236 :                 {
; 5237 :                     if (QRC_SUCCESS == read_packet( dev, grp ))

  02380	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  02388	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02390	e8 00 00 00 00	 call	 read_packet
  02395	98		 cwde
  02396	85 c0		 test	 eax, eax
  02398	0f 85 89 01 00
	00		 jne	 $LN174@qeth_execu

; 5238 :                     {
; 5239 :                         dev->qdio.dropcnt++;

  0239e	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023a6	8b 80 30 13 00
	00		 mov	 eax, DWORD PTR [rax+4912]
  023ac	ff c0		 inc	 eax
  023ae	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  023b6	89 81 30 13 00
	00		 mov	 DWORD PTR [rcx+4912], eax
$LN75@qeth_execu:

; 5240 :                         PTT_QETH_TRACE( "*actq drop", dev->qdio.i_qmask, 0, 0 );

  023bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  023c3	48 8b 00	 mov	 rax, QWORD PTR [rax]
  023c6	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  023cc	48 85 c0	 test	 rax, rax
  023cf	74 44		 je	 SHORT $LN175@qeth_execu
  023d1	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  023d9	8b 80 4c 14 00
	00		 mov	 eax, DWORD PTR [rax+5196]
  023df	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  023e8	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  023f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174600
  023f8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  023fd	45 33 c9	 xor	 r9d, r9d
  02400	44 8b c0	 mov	 r8d, eax
  02403	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174601
  0240a	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0240f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN175@qeth_execu:
  02415	33 c0		 xor	 eax, eax
  02417	85 c0		 test	 eax, eax
  02419	75 a1		 jne	 SHORT $LN75@qeth_execu

; 5241 :                         if (grp->debugmask & DBGQETHDROP)

  0241b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02423	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  02429	83 e0 40	 and	 eax, 64			; 00000040H
  0242c	85 c0		 test	 eax, eax
  0242e	0f 84 f3 00 00
	00		 je	 $LN176@qeth_execu

; 5242 :                         {
; 5243 :                             // "%1d:%04X %s: %s: Input dropped: %s"
; 5244 :                             WRMSG( HHC03810, "W", LCSS_DEVNUM,

  02434	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0243d	74 15		 je	 SHORT $LN226@qeth_execu
  0243f	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02447	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0244b	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv1261[rsp], eax
  02452	eb 0b		 jmp	 SHORT $LN227@qeth_execu
$LN226@qeth_execu:
  02454	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1261[rsp], 0
$LN227@qeth_execu:
  0245f	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02468	74 17		 je	 SHORT $LN228@qeth_execu
  0246a	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02472	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02476	d1 f8		 sar	 eax, 1
  02478	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1267[rsp], eax
  0247f	eb 0b		 jmp	 SHORT $LN229@qeth_execu
$LN228@qeth_execu:
  02481	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1267[rsp], 0
$LN229@qeth_execu:
  0248c	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02494	48 83 c0 60	 add	 rax, 96			; 00000060H
  02498	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR tv1254[rsp], rax
  024a0	b9 01 00 00 00	 mov	 ecx, 1
  024a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  024ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174603
  024b2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  024b7	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR tv1254[rsp]
  024bf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  024c4	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  024cc	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  024d0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  024d5	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv1261[rsp]
  024dc	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  024e0	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv1267[rsp]
  024e7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  024eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174604
  024f2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  024f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174605
  024fe	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  02503	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02508	41 b9 03 00 00
	00		 mov	 r9d, 3
  0250e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174606
  02515	ba 7d 14 00 00	 mov	 edx, 5245		; 0000147dH
  0251a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174607
  02521	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN176@qeth_execu:
$LN174@qeth_execu:
$LN171@qeth_execu:
$LN167@qeth_execu:

; 5245 :                                 dev->typname, grp->ttifname, "No available queues" );
; 5246 :                         }
; 5247 :                     }
; 5248 :                 }
; 5249 :             }
; 5250 : 
; 5251 :             /* ALWAYS process all Output Queues each time regardless of
; 5252 :                whether the guest has recently executed a SIGA-w or not
; 5253 :                since most guests expect OSA devices to behave that way.
; 5254 :                (SIGA-w are NOT required to cause processing O/P queues)
; 5255 :             */
; 5256 :             if (likely( dev->qdio.o_qmask ))

  02527	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0252f	83 b8 50 14 00
	00 00		 cmp	 DWORD PTR [rax+5200], 0
  02536	74 0d		 je	 SHORT $LN230@qeth_execu
  02538	c7 84 24 2c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1281[rsp], 1
  02543	eb 0b		 jmp	 SHORT $LN231@qeth_execu
$LN230@qeth_execu:
  02545	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1281[rsp], 0
$LN231@qeth_execu:
  02550	83 bc 24 2c 01
	00 00 00	 cmp	 DWORD PTR tv1281[rsp], 0
  02558	0f 84 8e 00 00
	00		 je	 $LN177@qeth_execu

; 5257 :             {
; 5258 :                 process_output_queues(dev);

  0255e	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02566	e8 00 00 00 00	 call	 process_output_queues

; 5259 : 
; 5260 :                 /* Present "output processed" interrupt if needed */
; 5261 :                 if (grp->oqPCI)

  0256b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02573	83 b8 f4 05 00
	00 00		 cmp	 DWORD PTR [rax+1524], 0
  0257a	74 70		 je	 SHORT $LN178@qeth_execu
$LN78@qeth_execu:

; 5262 :                 {
; 5263 :                     PTT_QETH_TRACE( "actq oqPCI", 0,0,0 );

  0257c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02583	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02586	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0258c	48 85 c0	 test	 rax, rax
  0258f	74 36		 je	 SHORT $LN179@qeth_execu
  02591	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0259a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  025a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174611
  025aa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  025af	45 33 c9	 xor	 r9d, r9d
  025b2	45 33 c0	 xor	 r8d, r8d
  025b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174612
  025bc	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  025c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN179@qeth_execu:
  025c7	33 c0		 xor	 eax, eax
  025c9	85 c0		 test	 eax, eax
  025cb	75 af		 jne	 SHORT $LN78@qeth_execu

; 5264 :                     grp->oqPCI = FALSE;

  025cd	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  025d5	c7 80 f4 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1524], 0

; 5265 :                     raise_adapter_interrupt( dev );

  025df	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  025e7	e8 00 00 00 00	 call	 raise_adapter_interrupt
$LN178@qeth_execu:
$LN177@qeth_execu:

; 5266 :                 }
; 5267 :             }
; 5268 :         }

  025ec	e9 1d f9 ff ff	 jmp	 $LN54@qeth_execu
$LN55@qeth_execu:
$LN81@qeth_execu:

; 5269 :         PTT_QETH_TRACE( "actq break", dev->devnum, 0,0 );

  025f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  025f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  025fb	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  02601	48 85 c0	 test	 rax, rax
  02604	74 42		 je	 SHORT $LN180@qeth_execu
  02606	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0260e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  02612	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0261b	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02624	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174614
  0262b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02630	45 33 c9	 xor	 r9d, r9d
  02633	44 8b c0	 mov	 r8d, eax
  02636	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174615
  0263d	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  02642	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN180@qeth_execu:
  02648	33 c0		 xor	 eax, eax
  0264a	85 c0		 test	 eax, eax
  0264c	75 a3		 jne	 SHORT $LN81@qeth_execu

; 5270 : 
; 5271 :         /* Acknowledge halt signal (how else could we reach here?) */
; 5272 :         if (sig == QDSIG_HALT)

  0264e	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR sig$2[rsp]
  02656	83 f8 01	 cmp	 eax, 1
  02659	75 75		 jne	 SHORT $LN181@qeth_execu

; 5273 :         {
; 5274 :             obtain_lock( &grp->qlock );

  0265b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  02663	48 83 c0 10	 add	 rax, 16
  02667	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174617
  0266e	48 8b c8	 mov	 rcx, rax
  02671	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 5275 :             {
; 5276 :                 dev->scsw.flag2 &= ~SCSW2_Q;

  02677	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0267f	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  02686	0f ba f0 07	 btr	 eax, 7
  0268a	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02692	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al

; 5277 :                 signal_condition( &grp->qdcond );

  02698	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  026a0	48 83 c0 08	 add	 rax, 8
  026a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174618
  026ab	48 8b c8	 mov	 rcx, rax
  026ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 5278 :             }
; 5279 :             release_lock( &grp->qlock );

  026b4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  026bc	48 83 c0 10	 add	 rax, 16
  026c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174619
  026c7	48 8b c8	 mov	 rcx, rax
  026ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN181@qeth_execu:

; 5280 :         }
; 5281 : 
; 5282 :         DBGTRC( dev, "Activate Queues: Exit");

  026d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174620
  026d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  026dc	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  026e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174621
  026eb	ba a2 14 00 00	 mov	 edx, 5282		; 000014a2H
  026f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174622
  026f7	e8 00 00 00 00	 call	 dbgtrc
$LN84@qeth_execu:

; 5283 :         PTT_QETH_TRACE( "actq exit", 0,0,0 );

  026fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  02703	48 8b 00	 mov	 rax, QWORD PTR [rax]
  02706	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0270c	48 85 c0	 test	 rax, rax
  0270f	74 36		 je	 SHORT $LN182@qeth_execu
  02711	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0271a	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  02723	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174624
  0272a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0272f	45 33 c9	 xor	 r9d, r9d
  02732	45 33 c0	 xor	 r8d, r8d
  02735	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174625
  0273c	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  02741	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN182@qeth_execu:
  02747	33 c0		 xor	 eax, eax
  02749	85 c0		 test	 eax, eax
  0274b	75 af		 jne	 SHORT $LN84@qeth_execu

; 5284 : 
; 5285 :         /* Return unit status */
; 5286 :         *unitstat = CSW_CE | CSW_DE;

  0274d	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  02755	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 5287 :         break;

  02758	eb 5c		 jmp	 SHORT $LN8@qeth_execu
$LN183@qeth_execu:

; 5288 :     }
; 5289 : 
; 5290 : 
; 5291 :     default:
; 5292 :     /*---------------------------------------------------------------*/
; 5293 :     /* INVALID OPERATION                                             */
; 5294 :     /*---------------------------------------------------------------*/
; 5295 :         DBGTRC(dev, "Unknown CCW opcode 0x%02X)",code);

  0275a	0f b6 84 24 18
	2f 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  02762	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  02766	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174627
  0276d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  02772	4c 8b 8c 24 10
	2f 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0277a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174628
  02781	ba af 14 00 00	 mov	 edx, 5295		; 000014afH
  02786	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174629
  0278d	e8 00 00 00 00	 call	 dbgtrc

; 5296 :         /* Set command reject sense byte, and unit check status */
; 5297 :         dev->sense[0] = SENSE_CR;

  02792	b8 01 00 00 00	 mov	 eax, 1
  02797	48 6b c0 00	 imul	 rax, rax, 0
  0279b	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  027a3	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 5298 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  027ab	48 8b 84 24 58
	2f 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  027b3	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN8@qeth_execu:

; 5299 : 
; 5300 :     } /* end switch(code) */
; 5301 : 
; 5302 :     /* Display various information, maybe */
; 5303 :     if (grp->debugmask & DBGQETHCCW)

  027b6	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  027be	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  027c4	83 e0 20	 and	 eax, 32			; 00000020H
  027c7	85 c0		 test	 eax, eax
  027c9	0f 84 0e 01 00
	00		 je	 $LN184@qeth_execu

; 5304 :     {
; 5305 :         // "%1d:%04X %s: Status %02X: Residual %08X: More %02X"
; 5306 :         WRMSG( HHC03993, "D", LCSS_DEVNUM,

  027cf	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  027d8	74 15		 je	 SHORT $LN232@qeth_execu
  027da	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  027e2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  027e6	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv1366[rsp], eax
  027ed	eb 0b		 jmp	 SHORT $LN233@qeth_execu
$LN232@qeth_execu:
  027ef	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1366[rsp], 0
$LN233@qeth_execu:
  027fa	48 83 bc 24 10
	2f 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  02803	74 17		 je	 SHORT $LN234@qeth_execu
  02805	48 8b 84 24 10
	2f 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0280d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  02811	d1 f8		 sar	 eax, 1
  02813	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv1372[rsp], eax
  0281a	eb 0b		 jmp	 SHORT $LN235@qeth_execu
$LN234@qeth_execu:
  0281c	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1372[rsp], 0
$LN235@qeth_execu:
  02827	48 8b 84 24 50
	2f 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0282f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02832	89 84 24 58 01
	00 00		 mov	 DWORD PTR tv1356[rsp], eax
  02839	48 8b 8c 24 58
	2f 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  02841	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  02844	89 8c 24 5c 01
	00 00		 mov	 DWORD PTR tv1359[rsp], ecx
  0284b	b9 01 00 00 00	 mov	 ecx, 1
  02850	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  02856	8b 8c 24 58 01
	00 00		 mov	 ecx, DWORD PTR tv1356[rsp]
  0285d	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  02861	48 8b 8c 24 60
	2f 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  02869	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0286b	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0286f	8b 8c 24 5c 01
	00 00		 mov	 ecx, DWORD PTR tv1359[rsp]
  02876	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0287a	48 8b 8c 24 10
	2f 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  02882	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  02886	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0288b	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv1366[rsp]
  02892	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  02896	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv1372[rsp]
  0289d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  028a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174631
  028a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  028ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174632
  028b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  028b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  028be	41 b9 03 00 00
	00		 mov	 r9d, 3
  028c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174633
  028cb	ba bb 14 00 00	 mov	 edx, 5307		; 000014bbH
  028d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174634
  028d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN184@qeth_execu:
$LN1@qeth_execu:

; 5307 :             dev->typname, *unitstat, *residual, *more );
; 5308 :     }
; 5309 : 
; 5310 : } /* end function qeth_execute_ccw */

  028dd	48 8b 8c 24 e0
	2e 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  028e5	48 33 cc	 xor	 rcx, rsp
  028e8	e8 00 00 00 00	 call	 __security_check_cookie
  028ed	48 81 c4 f8 2e
	00 00		 add	 rsp, 12024		; 00002ef8H
  028f4	5f		 pop	 rdi
  028f5	5e		 pop	 rsi
  028f6	c3		 ret	 0
  028f7	90		 npad	 1
$LN237@qeth_execu:
  028f8	00 00 00 00	 DD	 $LN87@qeth_execu
  028fc	00 00 00 00	 DD	 $LN97@qeth_execu
  02900	00 00 00 00	 DD	 $LN118@qeth_execu
  02904	00 00 00 00	 DD	 $LN120@qeth_execu
  02908	00 00 00 00	 DD	 $LN119@qeth_execu
  0290c	00 00 00 00	 DD	 $LN139@qeth_execu
  02910	00 00 00 00	 DD	 $LN149@qeth_execu
  02914	00 00 00 00	 DD	 $LN126@qeth_execu
  02918	00 00 00 00	 DD	 $LN132@qeth_execu
  0291c	00 00 00 00	 DD	 $LN121@qeth_execu
  02920	00 00 00 00	 DD	 $LN123@qeth_execu
  02924	00 00 00 00	 DD	 $LN183@qeth_execu
$LN236@qeth_execu:
  02928	00		 DB	 0
  02929	01		 DB	 1
  0292a	02		 DB	 2
  0292b	03		 DB	 3
  0292c	0b		 DB	 11
  0292d	0b		 DB	 11
  0292e	0b		 DB	 11
  0292f	0b		 DB	 11
  02930	0b		 DB	 11
  02931	0b		 DB	 11
  02932	0b		 DB	 11
  02933	0b		 DB	 11
  02934	0b		 DB	 11
  02935	0b		 DB	 11
  02936	0b		 DB	 11
  02937	0b		 DB	 11
  02938	0b		 DB	 11
  02939	0b		 DB	 11
  0293a	0b		 DB	 11
  0293b	04		 DB	 4
  0293c	0b		 DB	 11
  0293d	0b		 DB	 11
  0293e	0b		 DB	 11
  0293f	0b		 DB	 11
  02940	0b		 DB	 11
  02941	0b		 DB	 11
  02942	05		 DB	 5
  02943	0b		 DB	 11
  02944	0b		 DB	 11
  02945	0b		 DB	 11
  02946	06		 DB	 6
  02947	0b		 DB	 11
  02948	0b		 DB	 11
  02949	0b		 DB	 11
  0294a	0b		 DB	 11
  0294b	0b		 DB	 11
  0294c	0b		 DB	 11
  0294d	0b		 DB	 11
  0294e	0b		 DB	 11
  0294f	0b		 DB	 11
  02950	0b		 DB	 11
  02951	0b		 DB	 11
  02952	0b		 DB	 11
  02953	0b		 DB	 11
  02954	0b		 DB	 11
  02955	0b		 DB	 11
  02956	0b		 DB	 11
  02957	0b		 DB	 11
  02958	0b		 DB	 11
  02959	0b		 DB	 11
  0295a	0b		 DB	 11
  0295b	0b		 DB	 11
  0295c	0b		 DB	 11
  0295d	0b		 DB	 11
  0295e	0b		 DB	 11
  0295f	0b		 DB	 11
  02960	0b		 DB	 11
  02961	0b		 DB	 11
  02962	0b		 DB	 11
  02963	0b		 DB	 11
  02964	0b		 DB	 11
  02965	0b		 DB	 11
  02966	0b		 DB	 11
  02967	0b		 DB	 11
  02968	0b		 DB	 11
  02969	0b		 DB	 11
  0296a	0b		 DB	 11
  0296b	0b		 DB	 11
  0296c	0b		 DB	 11
  0296d	0b		 DB	 11
  0296e	0b		 DB	 11
  0296f	0b		 DB	 11
  02970	0b		 DB	 11
  02971	0b		 DB	 11
  02972	0b		 DB	 11
  02973	0b		 DB	 11
  02974	0b		 DB	 11
  02975	0b		 DB	 11
  02976	0b		 DB	 11
  02977	0b		 DB	 11
  02978	0b		 DB	 11
  02979	0b		 DB	 11
  0297a	0b		 DB	 11
  0297b	0b		 DB	 11
  0297c	0b		 DB	 11
  0297d	0b		 DB	 11
  0297e	0b		 DB	 11
  0297f	0b		 DB	 11
  02980	0b		 DB	 11
  02981	0b		 DB	 11
  02982	0b		 DB	 11
  02983	0b		 DB	 11
  02984	0b		 DB	 11
  02985	0b		 DB	 11
  02986	0b		 DB	 11
  02987	0b		 DB	 11
  02988	0b		 DB	 11
  02989	0b		 DB	 11
  0298a	0b		 DB	 11
  0298b	0b		 DB	 11
  0298c	0b		 DB	 11
  0298d	0b		 DB	 11
  0298e	0b		 DB	 11
  0298f	0b		 DB	 11
  02990	0b		 DB	 11
  02991	0b		 DB	 11
  02992	0b		 DB	 11
  02993	0b		 DB	 11
  02994	0b		 DB	 11
  02995	0b		 DB	 11
  02996	0b		 DB	 11
  02997	0b		 DB	 11
  02998	0b		 DB	 11
  02999	0b		 DB	 11
  0299a	0b		 DB	 11
  0299b	0b		 DB	 11
  0299c	0b		 DB	 11
  0299d	0b		 DB	 11
  0299e	0b		 DB	 11
  0299f	0b		 DB	 11
  029a0	0b		 DB	 11
  029a1	0b		 DB	 11
  029a2	0b		 DB	 11
  029a3	0b		 DB	 11
  029a4	0b		 DB	 11
  029a5	0b		 DB	 11
  029a6	0b		 DB	 11
  029a7	0b		 DB	 11
  029a8	07		 DB	 7
  029a9	08		 DB	 8
  029aa	0b		 DB	 11
  029ab	0b		 DB	 11
  029ac	0b		 DB	 11
  029ad	0b		 DB	 11
  029ae	0b		 DB	 11
  029af	0b		 DB	 11
  029b0	0b		 DB	 11
  029b1	0b		 DB	 11
  029b2	0b		 DB	 11
  029b3	0b		 DB	 11
  029b4	0b		 DB	 11
  029b5	0b		 DB	 11
  029b6	0b		 DB	 11
  029b7	0b		 DB	 11
  029b8	0b		 DB	 11
  029b9	0b		 DB	 11
  029ba	0b		 DB	 11
  029bb	0b		 DB	 11
  029bc	0b		 DB	 11
  029bd	0b		 DB	 11
  029be	0b		 DB	 11
  029bf	0b		 DB	 11
  029c0	0b		 DB	 11
  029c1	0b		 DB	 11
  029c2	0b		 DB	 11
  029c3	0b		 DB	 11
  029c4	0b		 DB	 11
  029c5	0b		 DB	 11
  029c6	0b		 DB	 11
  029c7	0b		 DB	 11
  029c8	0b		 DB	 11
  029c9	0b		 DB	 11
  029ca	0b		 DB	 11
  029cb	0b		 DB	 11
  029cc	0b		 DB	 11
  029cd	0b		 DB	 11
  029ce	0b		 DB	 11
  029cf	0b		 DB	 11
  029d0	0b		 DB	 11
  029d1	0b		 DB	 11
  029d2	0b		 DB	 11
  029d3	0b		 DB	 11
  029d4	0b		 DB	 11
  029d5	0b		 DB	 11
  029d6	0b		 DB	 11
  029d7	0b		 DB	 11
  029d8	0b		 DB	 11
  029d9	0b		 DB	 11
  029da	0b		 DB	 11
  029db	0b		 DB	 11
  029dc	0b		 DB	 11
  029dd	0b		 DB	 11
  029de	0b		 DB	 11
  029df	0b		 DB	 11
  029e0	0b		 DB	 11
  029e1	0b		 DB	 11
  029e2	0b		 DB	 11
  029e3	0b		 DB	 11
  029e4	0b		 DB	 11
  029e5	0b		 DB	 11
  029e6	0b		 DB	 11
  029e7	0b		 DB	 11
  029e8	0b		 DB	 11
  029e9	0b		 DB	 11
  029ea	0b		 DB	 11
  029eb	0b		 DB	 11
  029ec	0b		 DB	 11
  029ed	0b		 DB	 11
  029ee	0b		 DB	 11
  029ef	0b		 DB	 11
  029f0	0b		 DB	 11
  029f1	0b		 DB	 11
  029f2	0b		 DB	 11
  029f3	0b		 DB	 11
  029f4	0b		 DB	 11
  029f5	0b		 DB	 11
  029f6	0b		 DB	 11
  029f7	0b		 DB	 11
  029f8	0b		 DB	 11
  029f9	0b		 DB	 11
  029fa	0b		 DB	 11
  029fb	0b		 DB	 11
  029fc	0b		 DB	 11
  029fd	0b		 DB	 11
  029fe	0b		 DB	 11
  029ff	0b		 DB	 11
  02a00	0b		 DB	 11
  02a01	0b		 DB	 11
  02a02	0b		 DB	 11
  02a03	0b		 DB	 11
  02a04	0b		 DB	 11
  02a05	0b		 DB	 11
  02a06	0b		 DB	 11
  02a07	0b		 DB	 11
  02a08	0b		 DB	 11
  02a09	0b		 DB	 11
  02a0a	0b		 DB	 11
  02a0b	09		 DB	 9
  02a0c	0b		 DB	 11
  02a0d	0b		 DB	 11
  02a0e	0b		 DB	 11
  02a0f	0b		 DB	 11
  02a10	0b		 DB	 11
  02a11	0b		 DB	 11
  02a12	0b		 DB	 11
  02a13	0b		 DB	 11
  02a14	0b		 DB	 11
  02a15	0b		 DB	 11
  02a16	0b		 DB	 11
  02a17	0b		 DB	 11
  02a18	0b		 DB	 11
  02a19	0b		 DB	 11
  02a1a	0b		 DB	 11
  02a1b	0b		 DB	 11
  02a1c	0b		 DB	 11
  02a1d	0b		 DB	 11
  02a1e	0b		 DB	 11
  02a1f	0b		 DB	 11
  02a20	0b		 DB	 11
  02a21	0a		 DB	 10
qeth_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
rsp24$ = 32
dev$ = 64
desc$ = 72
qeth_ssqd_desc PROC

; 4551 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4552 :     CHSC_RSP24 *rsp24 = (void *)desc;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR desc$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR rsp24$[rsp], rax

; 4553 : 
; 4554 :     STORE_HW(rsp24->sch, dev->subchan);

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 48 46	 movzx	 ecx, WORD PTR [rax+70]
  00021	e8 00 00 00 00	 call	 _byteswap_ushort
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  0002b	48 83 c1 02	 add	 rcx, 2
  0002f	0f b7 d0	 movzx	 edx, ax
  00032	e8 00 00 00 00	 call	 store_hw_noswap

; 4555 : 
; 4556 :     if(dev->pmcw.flag4 & PMCW4_Q)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00043	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 43 01 00
	00		 je	 $LN2@qeth_ssqd_

; 4557 :     {
; 4558 :         rsp24->flags |= ( CHSC_FLAG_QDIO_CAPABILITY | CHSC_FLAG_VALIDITY );

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00055	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00058	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00062	88 01		 mov	 BYTE PTR [rcx], al

; 4559 : 
; 4560 :         rsp24->qdioac1 |= ( AC1_SIGA_INPUT_NEEDED | AC1_SIGA_OUTPUT_NEEDED );

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00069	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0006d	83 c8 60	 or	 eax, 96			; 00000060H
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00075	88 41 06	 mov	 BYTE PTR [rcx+6], al

; 4561 :         rsp24->qdioac1 |= AC1_AUTOMATIC_SYNC_ON_OUT_PCI;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  0007d	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00081	83 c8 04	 or	 eax, 4
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00089	88 41 06	 mov	 BYTE PTR [rcx+6], al

; 4562 : 
; 4563 : #if defined( _FEATURE_QEBSM )
; 4564 :         if (FACILITY_ENABLED_DEV( HERC_QEBSM ))

  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00093	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  0009a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	48 6b c9 21	 imul	 rcx, rcx, 33		; 00000021H
  000b6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000ba	83 e0 08	 and	 eax, 8
  000bd	85 c0		 test	 eax, eax
  000bf	74 48		 je	 SHORT $LN3@qeth_ssqd_

; 4565 :         {
; 4566 :             STORE_DW(rsp24->sch_token, IOID2TKN((dev->ssid << 16) | dev->subchan));

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000ca	c1 e0 10	 shl	 eax, 16
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d2	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  000d6	0b c1		 or	 eax, ecx
  000d8	f7 d0		 not	 eax
  000da	48 98		 cdqe
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 _byteswap_uint64
  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  000e9	48 83 c1 10	 add	 rcx, 16
  000ed	48 8b d0	 mov	 rdx, rax
  000f0	e8 00 00 00 00	 call	 store_dw_noswap

; 4567 :             rsp24->qdioac1 |= ( AC1_SC_QEBSM_AVAILABLE | AC1_SC_QEBSM_ENABLED );

  000f5	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  000fa	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  000fe	83 c8 03	 or	 eax, 3
  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00106	88 41 06	 mov	 BYTE PTR [rcx+6], al
$LN3@qeth_ssqd_:

; 4568 :         }
; 4569 : #endif
; 4570 : 
; 4571 : #if defined( _FEATURE_QDIO_THININT )
; 4572 :         if (FACILITY_ENABLED_DEV( HERC_QDIO_THININT ))

  00109	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00110	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  00117	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0011b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00122	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	48 6b c9 21	 imul	 rcx, rcx, 33		; 00000021H
  00133	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00137	83 e0 10	 and	 eax, 16
  0013a	85 c0		 test	 eax, eax
  0013c	74 14		 je	 SHORT $LN4@qeth_ssqd_

; 4573 :             rsp24->qdioac1 |= AC1_AUTOMATIC_SYNC_ON_THININT;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00143	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00147	83 c8 08	 or	 eax, 8
  0014a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  0014f	88 41 06	 mov	 BYTE PTR [rcx+6], al
$LN4@qeth_ssqd_:

; 4574 : #endif
; 4575 : 
; 4576 :         rsp24->icnt = QETH_QDIO_READQ;

  00152	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00157	c6 40 09 01	 mov	 BYTE PTR [rax+9], 1

; 4577 :         rsp24->ocnt = QETH_QDIO_WRITEQ;

  0015b	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00160	c6 40 0b 04	 mov	 BYTE PTR [rax+11], 4

; 4578 : 
; 4579 :         rsp24->qdioac1 |= AC1_UNKNOWN80;

  00164	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00169	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0016d	0f ba e8 07	 bts	 eax, 7
  00171	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00176	88 41 06	 mov	 BYTE PTR [rcx+6], al

; 4580 :         STORE_HW(rsp24->qdioac2, QETH_AC2_UNKNOWN4000+QETH_AC2_UNKNOWN2000);

  00179	66 b9 00 60	 mov	 cx, 24576		; 00006000H
  0017d	e8 00 00 00 00	 call	 _byteswap_ushort
  00182	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00187	48 83 c1 0e	 add	 rcx, 14
  0018b	0f b7 d0	 movzx	 edx, ax
  0018e	e8 00 00 00 00	 call	 store_hw_noswap
$LN2@qeth_ssqd_:

; 4581 :     }
; 4582 : 
; 4583 :     return 0;

  00193	33 c0		 xor	 eax, eax

; 4584 : }

  00195	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00199	c3		 ret	 0
qeth_ssqd_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
ks$ = 48
kc$ = 49
opc$ = 52
req21$ = 56
alsi$ = 64
dsci$ = 72
dev$ = 96
desc$ = 104
qeth_set_sci PROC

; 4504 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4505 : CHSC_REQ21 *req21 = (void *)desc;

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR desc$[rsp]
  00013	48 89 44 24 38	 mov	 QWORD PTR req21$[rsp], rax

; 4506 : RADR alsi, dsci;
; 4507 : BYTE ks, kc;
; 4508 : U16 opc;
; 4509 : 
; 4510 :     FETCH_HW(opc,req21->opcode);

  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0001d	48 83 c0 04	 add	 rax, 4
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fetch_hw_noswap
  00029	0f b7 c8	 movzx	 ecx, ax
  0002c	e8 00 00 00 00	 call	 _byteswap_ushort
  00031	66 89 44 24 34	 mov	 WORD PTR opc$[rsp], ax

; 4511 : 
; 4512 :     if(opc)

  00036	0f b7 44 24 34	 movzx	 eax, WORD PTR opc$[rsp]
  0003b	85 c0		 test	 eax, eax
  0003d	74 0a		 je	 SHORT $LN2@qeth_set_s

; 4513 :         return 3; // Invalid operation code

  0003f	b8 03 00 00 00	 mov	 eax, 3
  00044	e9 41 01 00 00	 jmp	 $LN1@qeth_set_s
$LN2@qeth_set_s:

; 4514 : 
; 4515 :     FETCH_DW(alsi, req21->alsi);

  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0004e	48 83 c0 10	 add	 rax, 16
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 fetch_dw_noswap
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 _byteswap_uint64
  00062	48 89 44 24 40	 mov	 QWORD PTR alsi$[rsp], rax

; 4516 :     ks = req21->sk & CHSC_REQ21_KS;

  00067	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0006c	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00070	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00075	88 44 24 30	 mov	 BYTE PTR ks$[rsp], al

; 4517 : 
; 4518 :     FETCH_DW(dsci, req21->dsci);

  00079	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0007e	48 83 c0 18	 add	 rax, 24
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 fetch_dw_noswap
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 _byteswap_uint64
  00092	48 89 44 24 48	 mov	 QWORD PTR dsci$[rsp], rax

; 4519 :     kc = (req21->sk & CHSC_REQ21_KC) << 4;

  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0009c	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  000a0	83 e0 0f	 and	 eax, 15
  000a3	c1 e0 04	 shl	 eax, 4
  000a6	88 44 24 31	 mov	 BYTE PTR kc$[rsp], al

; 4520 : 
; 4521 :     if(alsi && dsci)

  000aa	48 83 7c 24 40
	00		 cmp	 QWORD PTR alsi$[rsp], 0
  000b0	0f 84 81 00 00
	00		 je	 $LN3@qeth_set_s
  000b6	48 83 7c 24 48
	00		 cmp	 QWORD PTR dsci$[rsp], 0
  000bc	74 79		 je	 SHORT $LN3@qeth_set_s

; 4522 :     {
; 4523 :         if(STORCHK(alsi,0,ks,STORKEY_CHANGE,dev)
; 4524 :           || STORCHK(dsci,0,kc,STORKEY_CHANGE,dev))

  000be	0f b6 44 24 30	 movzx	 eax, BYTE PTR ks$[rsp]
  000c3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000c8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000cd	41 b9 02 00 00
	00		 mov	 r9d, 2
  000d3	44 8b c0	 mov	 r8d, eax
  000d6	33 d2		 xor	 edx, edx
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR alsi$[rsp]
  000dd	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  000e2	85 c0		 test	 eax, eax
  000e4	75 28		 jne	 SHORT $LN7@qeth_set_s
  000e6	0f b6 44 24 31	 movzx	 eax, BYTE PTR kc$[rsp]
  000eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000f0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000f5	41 b9 02 00 00
	00		 mov	 r9d, 2
  000fb	44 8b c0	 mov	 r8d, eax
  000fe	33 d2		 xor	 edx, edx
  00100	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dsci$[rsp]
  00105	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  0010a	85 c0		 test	 eax, eax
  0010c	74 18		 je	 SHORT $LN5@qeth_set_s
$LN7@qeth_set_s:

; 4525 :         {
; 4526 :             dev->qdio.thinint = 0;

  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00113	c7 80 38 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4920], 0

; 4527 :             return 3;

  0011d	b8 03 00 00 00	 mov	 eax, 3
  00122	eb 66		 jmp	 SHORT $LN1@qeth_set_s

; 4528 :         }

  00124	eb 0f		 jmp	 SHORT $LN6@qeth_set_s
$LN5@qeth_set_s:

; 4529 :         else
; 4530 :             dev->qdio.thinint = 1;

  00126	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0012b	c7 80 38 13 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4920], 1
$LN6@qeth_set_s:

; 4531 : 
; 4532 :     }

  00135	eb 0f		 jmp	 SHORT $LN4@qeth_set_s
$LN3@qeth_set_s:

; 4533 :     else
; 4534 :         dev->qdio.thinint = 0;

  00137	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0013c	c7 80 38 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4920], 0
$LN4@qeth_set_s:

; 4535 : 
; 4536 :     dev->qdio.alsi = alsi;

  00146	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0014b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR alsi$[rsp]
  00150	48 89 88 68 1b
	00 00		 mov	 QWORD PTR [rax+7016], rcx

; 4537 :     dev->qdio.ks   = ks;

  00157	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0015c	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR ks$[rsp]
  00161	88 88 78 1b 00
	00		 mov	 BYTE PTR [rax+7032], cl

; 4538 : 
; 4539 :     dev->qdio.dsci = dsci;

  00167	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0016c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dsci$[rsp]
  00171	48 89 88 70 1b
	00 00		 mov	 QWORD PTR [rax+7024], rcx

; 4540 :     dev->qdio.kc   = kc;

  00178	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0017d	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR kc$[rsp]
  00182	88 88 79 1b 00
	00		 mov	 BYTE PTR [rax+7033], cl

; 4541 : 
; 4542 :     return 0;

  00188	33 c0		 xor	 eax, eax
$LN1@qeth_set_s:

; 4543 : }

  0018a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0018e	c3		 ret	 0
qeth_set_sci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$1 = 64
ttfd$2 = 68
grp$ = 72
group$ = 80
tv67 = 88
dev$ = 112
qeth_close_device PROC

; 4430 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 4431 : DEVGRP *group = (DEVGRP*)dev->group;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 89 44 24 50	 mov	 QWORD PTR group$[rsp], rax

; 4432 : OSA_GRP *grp = (OSA_GRP*)(group ? group->grp_data : NULL);

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR group$[rsp], 0
  0001d	74 10		 je	 SHORT $LN62@qeth_close
  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR group$[rsp]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 89 44 24 58	 mov	 QWORD PTR tv67[rsp], rax
  0002d	eb 09		 jmp	 SHORT $LN63@qeth_close
$LN62@qeth_close:
  0002f	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tv67[rsp], 0
$LN63@qeth_close:
  00038	48 8b 44 24 58	 mov	 rax, QWORD PTR tv67[rsp]
  0003d	48 89 44 24 48	 mov	 QWORD PTR grp$[rsp], rax

; 4433 : 
; 4434 :     if (!dev->member && dev->group && dev->group->grp_data)

  00042	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00047	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  0004b	0f 85 6d 06 00
	00		 jne	 $LN41@qeth_close
  00051	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00056	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0005b	0f 84 5d 06 00
	00		 je	 $LN41@qeth_close
  00061	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00066	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006a	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0006f	0f 84 49 06 00
	00		 je	 $LN41@qeth_close

; 4435 :     {
; 4436 :         int i, ttfd = grp->ttfd;

  00075	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  0007a	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00080	89 44 24 44	 mov	 DWORD PTR ttfd$2[rsp], eax
$LN4@qeth_close:

; 4437 : 
; 4438 :         PTT_QETH_TRACE( "b4 clos halt", 0,0,0 );

  00084	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00094	48 85 c0	 test	 rax, rax
  00097	74 36		 je	 SHORT $LN43@qeth_close
  00099	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a2	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174034
  000b2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b7	45 33 c9	 xor	 r9d, r9d
  000ba	45 33 c0	 xor	 r8d, r8d
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174035
  000c4	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN43@qeth_close:
  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	75 af		 jne	 SHORT $LN4@qeth_close

; 4439 :         for (i=0; i < dev->group->members; i++)

  000d5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  000dd	eb 0a		 jmp	 SHORT $LN7@qeth_close
$LN5@qeth_close:
  000df	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  000e3	ff c0		 inc	 eax
  000e5	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
$LN7@qeth_close:
  000e9	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000ee	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000f2	8b 00		 mov	 eax, DWORD PTR [rax]
  000f4	39 44 24 40	 cmp	 DWORD PTR i$1[rsp], eax
  000f8	7d 6f		 jge	 SHORT $LN6@qeth_close

; 4440 :         {
; 4441 :             if (QTYPE_READ == group->memdev[i]->qtype)

  000fa	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  000ff	48 8b 4c 24 50	 mov	 rcx, QWORD PTR group$[rsp]
  00104	48 8b 44 c1 10	 mov	 rax, QWORD PTR [rcx+rax*8+16]
  00109	0f b6 80 80 1b
	00 00		 movzx	 eax, BYTE PTR [rax+7040]
  00110	83 f8 01	 cmp	 eax, 1
  00113	75 1b		 jne	 SHORT $LN44@qeth_close

; 4442 :                 qeth_halt_read_device( group->memdev[i], grp );

  00115	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  0011a	48 8b 54 24 48	 mov	 rdx, QWORD PTR grp$[rsp]
  0011f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR group$[rsp]
  00124	48 8b 4c c1 10	 mov	 rcx, QWORD PTR [rcx+rax*8+16]
  00129	e8 00 00 00 00	 call	 qeth_halt_read_device
  0012e	eb 34		 jmp	 SHORT $LN45@qeth_close
$LN44@qeth_close:

; 4443 :             else if (QTYPE_DATA == group->memdev[i]->qtype)

  00130	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00135	48 8b 4c 24 50	 mov	 rcx, QWORD PTR group$[rsp]
  0013a	48 8b 44 c1 10	 mov	 rax, QWORD PTR [rcx+rax*8+16]
  0013f	0f b6 80 80 1b
	00 00		 movzx	 eax, BYTE PTR [rax+7040]
  00146	83 f8 03	 cmp	 eax, 3
  00149	75 19		 jne	 SHORT $LN46@qeth_close

; 4444 :                 qeth_halt_data_device( group->memdev[i], grp );

  0014b	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$1[rsp]
  00150	48 8b 54 24 48	 mov	 rdx, QWORD PTR grp$[rsp]
  00155	48 8b 4c 24 50	 mov	 rcx, QWORD PTR group$[rsp]
  0015a	48 8b 4c c1 10	 mov	 rcx, QWORD PTR [rcx+rax*8+16]
  0015f	e8 00 00 00 00	 call	 qeth_halt_data_device
$LN46@qeth_close:
$LN45@qeth_close:

; 4445 :         }

  00164	e9 76 ff ff ff	 jmp	 $LN5@qeth_close
$LN6@qeth_close:

; 4446 :         usleep( OSA_TIMEOUTUS ); /* give it time to exit */

  00169	b9 50 c3 00 00	 mov	 ecx, 50000		; 0000c350H
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep
$LN10@qeth_close:

; 4447 :         PTT_QETH_TRACE( "af clos halt", 0,0,0 );

  00174	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0017b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0017e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00184	48 85 c0	 test	 rax, rax
  00187	74 36		 je	 SHORT $LN47@qeth_close
  00189	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00192	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0019b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174040
  001a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a7	45 33 c9	 xor	 r9d, r9d
  001aa	45 33 c0	 xor	 r8d, r8d
  001ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174041
  001b4	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@qeth_close:
  001bf	33 c0		 xor	 eax, eax
  001c1	85 c0		 test	 eax, eax
  001c3	75 af		 jne	 SHORT $LN10@qeth_close
$LN13@qeth_close:

; 4448 : 
; 4449 :         PTT_QETH_TRACE( "b4 clos ttfd", 0,0,0 );

  001c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001cc	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001cf	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001d5	48 85 c0	 test	 rax, rax
  001d8	74 36		 je	 SHORT $LN48@qeth_close
  001da	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001e3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  001ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174043
  001f3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001f8	45 33 c9	 xor	 r9d, r9d
  001fb	45 33 c0	 xor	 r8d, r8d
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174044
  00205	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN48@qeth_close:
  00210	33 c0		 xor	 eax, eax
  00212	85 c0		 test	 eax, eax
  00214	75 af		 jne	 SHORT $LN13@qeth_close

; 4450 :         grp->ttfd = -1;

  00216	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  0021b	c7 80 f8 05 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+1528], -1

; 4451 :         dev->fd = -1;

  00225	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 4452 :         if(ttfd > 0)

  00234	83 7c 24 44 00	 cmp	 DWORD PTR ttfd$2[rsp], 0
  00239	7e 09		 jle	 SHORT $LN49@qeth_close

; 4453 :             TUNTAP_Close(ttfd);

  0023b	8b 4c 24 44	 mov	 ecx, DWORD PTR ttfd$2[rsp]
  0023f	e8 00 00 00 00	 call	 tt32_close
$LN49@qeth_close:
$LN16@qeth_close:

; 4454 :         PTT_QETH_TRACE( "af clos ttfd", 0,0,0 );

  00244	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0024b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0024e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00254	48 85 c0	 test	 rax, rax
  00257	74 36		 je	 SHORT $LN50@qeth_close
  00259	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00262	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0026b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174047
  00272	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00277	45 33 c9	 xor	 r9d, r9d
  0027a	45 33 c0	 xor	 r8d, r8d
  0027d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174048
  00284	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN50@qeth_close:
  0028f	33 c0		 xor	 eax, eax
  00291	85 c0		 test	 eax, eax
  00293	75 af		 jne	 SHORT $LN16@qeth_close
$LN19@qeth_close:

; 4455 : 
; 4456 :         PTT_QETH_TRACE( "b4 clos pipe", 0,0,0 );

  00295	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0029c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0029f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  002a5	48 85 c0	 test	 rax, rax
  002a8	74 36		 je	 SHORT $LN51@qeth_close
  002aa	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002b3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  002bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174050
  002c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002c8	45 33 c9	 xor	 r9d, r9d
  002cb	45 33 c0	 xor	 r8d, r8d
  002ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174051
  002d5	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  002da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN51@qeth_close:
  002e0	33 c0		 xor	 eax, eax
  002e2	85 c0		 test	 eax, eax
  002e4	75 af		 jne	 SHORT $LN19@qeth_close

; 4457 :         if(grp->ppfd[0])

  002e6	b8 04 00 00 00	 mov	 eax, 4
  002eb	48 6b c0 00	 imul	 rax, rax, 0
  002ef	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  002f4	83 bc 01 fc 05
	00 00 00	 cmp	 DWORD PTR [rcx+rax+1532], 0
  002fc	74 1f		 je	 SHORT $LN52@qeth_close

; 4458 :             close_pipe(grp->ppfd[0]);

  002fe	b8 04 00 00 00	 mov	 eax, 4
  00303	48 6b c0 00	 imul	 rax, rax, 0
  00307	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  0030c	48 63 84 01 fc
	05 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+1532]
  00314	48 8b c8	 mov	 rcx, rax
  00317	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN52@qeth_close:

; 4459 :         if(grp->ppfd[1])

  0031d	b8 04 00 00 00	 mov	 eax, 4
  00322	48 6b c0 01	 imul	 rax, rax, 1
  00326	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  0032b	83 bc 01 fc 05
	00 00 00	 cmp	 DWORD PTR [rcx+rax+1532], 0
  00333	74 1f		 je	 SHORT $LN53@qeth_close

; 4460 :             close_pipe(grp->ppfd[1]);

  00335	b8 04 00 00 00	 mov	 eax, 4
  0033a	48 6b c0 01	 imul	 rax, rax, 1
  0033e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00343	48 63 84 01 fc
	05 00 00	 movsxd	 rax, DWORD PTR [rcx+rax+1532]
  0034b	48 8b c8	 mov	 rcx, rax
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN53@qeth_close:
$LN22@qeth_close:

; 4461 :         PTT_QETH_TRACE( "af clos pipe", 0,0,0 );

  00354	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0035b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0035e	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00364	48 85 c0	 test	 rax, rax
  00367	74 36		 je	 SHORT $LN54@qeth_close
  00369	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00372	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0037b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174055
  00382	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00387	45 33 c9	 xor	 r9d, r9d
  0038a	45 33 c0	 xor	 r8d, r8d
  0038d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174056
  00394	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN54@qeth_close:
  0039f	33 c0		 xor	 eax, eax
  003a1	85 c0		 test	 eax, eax
  003a3	75 af		 jne	 SHORT $LN22@qeth_close
$LN25@qeth_close:

; 4462 : 
; 4463 :         PTT_QETH_TRACE( "b4 clos othr", 0,0,0 );

  003a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003ac	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003af	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  003b5	48 85 c0	 test	 rax, rax
  003b8	74 36		 je	 SHORT $LN55@qeth_close
  003ba	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003c3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  003cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174058
  003d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d8	45 33 c9	 xor	 r9d, r9d
  003db	45 33 c0	 xor	 r8d, r8d
  003de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174059
  003e5	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  003ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN55@qeth_close:
  003f0	33 c0		 xor	 eax, eax
  003f2	85 c0		 test	 eax, eax
  003f4	75 af		 jne	 SHORT $LN25@qeth_close

; 4464 : 
; 4465 :         free( grp->ttdev    );

  003f6	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  003fb	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  003ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4466 :         free( grp->tthwaddr  );

  00405	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  0040a	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4467 :         free( grp->ttipaddr  );

  00414	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00419	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  00420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4468 :         free( grp->ttpfxlen  );

  00426	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  0042b	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4469 :         free( grp->ttnetmask );

  00438	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  0043d	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4470 :         free( grp->ttipaddr6 );

  0044a	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  0044f	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  00456	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4471 :         free( grp->ttpfxlen6 );

  0045c	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00461	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  00468	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4472 :         free( grp->ttmtu     );

  0046e	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00473	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00477	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4473 :         free( grp->ttchpid   );

  0047d	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00482	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN28@qeth_close:

; 4474 : 
; 4475 :         PTT_QETH_TRACE( "af clos othr", 0,0,0 );

  0048f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00496	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00499	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0049f	48 85 c0	 test	 rax, rax
  004a2	74 36		 je	 SHORT $LN56@qeth_close
  004a4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004ad	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  004b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174061
  004bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c2	45 33 c9	 xor	 r9d, r9d
  004c5	45 33 c0	 xor	 r8d, r8d
  004c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174062
  004cf	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  004d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN56@qeth_close:
  004da	33 c0		 xor	 eax, eax
  004dc	85 c0		 test	 eax, eax
  004de	75 af		 jne	 SHORT $LN28@qeth_close
$LN31@qeth_close:

; 4476 : 
; 4477 :         PTT_QETH_TRACE( "b4 clos fbuf", 0,0,0 );

  004e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  004e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  004ea	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  004f0	48 85 c0	 test	 rax, rax
  004f3	74 36		 je	 SHORT $LN57@qeth_close
  004f5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004fe	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00507	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174064
  0050e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00513	45 33 c9	 xor	 r9d, r9d
  00516	45 33 c0	 xor	 r8d, r8d
  00519	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174065
  00520	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00525	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN57@qeth_close:
  0052b	33 c0		 xor	 eax, eax
  0052d	85 c0		 test	 eax, eax
  0052f	75 af		 jne	 SHORT $LN31@qeth_close

; 4478 :         remove_and_free_any_buffers_on_chain( &grp->idx );

  00531	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00536	48 83 c0 18	 add	 rax, 24
  0053a	48 8b c8	 mov	 rcx, rax
  0053d	e8 00 00 00 00	 call	 remove_and_free_any_buffers_on_chain
$LN34@qeth_close:

; 4479 :         PTT_QETH_TRACE( "af clos fbuf", 0,0,0 );

  00542	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00549	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0054c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00552	48 85 c0	 test	 rax, rax
  00555	74 36		 je	 SHORT $LN58@qeth_close
  00557	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00560	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00569	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174067
  00570	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00575	45 33 c9	 xor	 r9d, r9d
  00578	45 33 c0	 xor	 r8d, r8d
  0057b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174068
  00582	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00587	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN58@qeth_close:
  0058d	33 c0		 xor	 eax, eax
  0058f	85 c0		 test	 eax, eax
  00591	75 af		 jne	 SHORT $LN34@qeth_close

; 4480 : 
; 4481 :         destroy_condition( &grp->qrcond );

  00593	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00598	48 8b c8	 mov	 rcx, rax
  0059b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_condition

; 4482 :         destroy_condition( &grp->qdcond );

  005a1	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  005a6	48 83 c0 08	 add	 rax, 8
  005aa	48 8b c8	 mov	 rcx, rax
  005ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_condition

; 4483 :         destroy_lock( &grp->qlock );

  005b3	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  005b8	48 83 c0 10	 add	 rax, 16
  005bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174069
  005c3	48 8b c8	 mov	 rcx, rax
  005c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 4484 :         destroy_lock( &grp->idx.lockbhr );

  005cc	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  005d1	48 83 c0 18	 add	 rax, 24
  005d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174070
  005dc	48 8b c8	 mov	 rcx, rax
  005df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 4485 :         destroy_lock( &grp->l3r.lockbhr );

  005e5	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  005ea	48 83 c0 38	 add	 rax, 56			; 00000038H
  005ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174071
  005f5	48 8b c8	 mov	 rcx, rax
  005f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock
$LN37@qeth_close:

; 4486 : 
; 4487 :         PTT_QETH_TRACE( "b4 clos fgrp", 0,0,0 );

  005fe	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00605	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00608	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0060e	48 85 c0	 test	 rax, rax
  00611	74 36		 je	 SHORT $LN59@qeth_close
  00613	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0061c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00625	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174073
  0062c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00631	45 33 c9	 xor	 r9d, r9d
  00634	45 33 c0	 xor	 r8d, r8d
  00637	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174074
  0063e	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00643	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN59@qeth_close:
  00649	33 c0		 xor	 eax, eax
  0064b	85 c0		 test	 eax, eax
  0064d	75 af		 jne	 SHORT $LN37@qeth_close

; 4488 :         free( group->grp_data );

  0064f	48 8b 44 24 50	 mov	 rax, QWORD PTR group$[rsp]
  00654	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00658	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4489 :         group->grp_data = NULL;

  0065e	48 8b 44 24 50	 mov	 rax, QWORD PTR group$[rsp]
  00663	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN40@qeth_close:

; 4490 :         PTT_QETH_TRACE( "af clos fgrp", 0,0,0 );

  0066b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00672	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00675	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0067b	48 85 c0	 test	 rax, rax
  0067e	74 36		 je	 SHORT $LN60@qeth_close
  00680	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00689	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00692	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174076
  00699	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0069e	45 33 c9	 xor	 r9d, r9d
  006a1	45 33 c0	 xor	 r8d, r8d
  006a4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174077
  006ab	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  006b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN60@qeth_close:
  006b6	33 c0		 xor	 eax, eax
  006b8	85 c0		 test	 eax, eax
  006ba	75 af		 jne	 SHORT $LN40@qeth_close

; 4491 :     }

  006bc	eb 0f		 jmp	 SHORT $LN42@qeth_close
$LN41@qeth_close:

; 4492 :     else
; 4493 :         dev->fd = -1;

  006be	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006c3	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1
$LN42@qeth_close:

; 4494 : 
; 4495 :     return 0;

  006cd	33 c0		 xor	 eax, eax

; 4496 : } /* end function qeth_close_device */

  006cf	48 83 c4 68	 add	 rsp, 104		; 00000068H
  006d3	c3		 ret	 0
qeth_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 64
$T1 = 72
tv202 = 80
tv204 = 88
active$ = 96
ttifname$2 = 104
incomplete$ = 128
dropped$3 = 144
qdiostat$ = 176
status$ = 256
filename$ = 336
__$ArrayPad$ = 608
dev$ = 640
devclass$ = 648
buflen$ = 656
buffer$ = 664
qeth_query_device PROC

; 4373 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 70 02
	00 00		 sub	 rsp, 624		; 00000270H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4374 : char filename[ PATH_MAX + 1 ];          /* full path or just name    */
; 4375 : 
; 4376 : char qdiostat[80] = {0};

  0002e	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR qdiostat$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00040	f3 aa		 rep stosb

; 4377 : char incomplete[16] = {0};

  00042	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR incomplete$[rsp]
  0004a	48 8b f8	 mov	 rdi, rax
  0004d	33 c0		 xor	 eax, eax
  0004f	b9 10 00 00 00	 mov	 ecx, 16
  00054	f3 aa		 rep stosb

; 4378 : char status[sizeof(qdiostat)] = {0};

  00056	48 8d 84 24 00
	01 00 00	 lea	 rax, QWORD PTR status$[rsp]
  0005e	48 8b f8	 mov	 rdi, rax
  00061	33 c0		 xor	 eax, eax
  00063	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00068	f3 aa		 rep stosb

; 4379 : char active[8] = {0};

  0006a	48 8d 44 24 60	 lea	 rax, QWORD PTR active$[rsp]
  0006f	48 8b f8	 mov	 rdi, rax
  00072	33 c0		 xor	 eax, eax
  00074	b9 08 00 00 00	 mov	 ecx, 8
  00079	f3 aa		 rep stosb

; 4380 : OSA_GRP *grp;
; 4381 : 
; 4382 :     BEGIN_DEVICE_CLASS_QUERY( "OSA", dev, devclass, buflen, buffer );

  0007b	48 83 bc 24 88
	02 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00084	74 12		 je	 SHORT $LN2@qeth_query
  00086	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  0008e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173876
  00095	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@qeth_query:
  00098	48 83 bc 24 80
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000a1	74 20		 je	 SHORT $LN4@qeth_query
  000a3	48 83 bc 24 88
	02 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  000ac	74 15		 je	 SHORT $LN4@qeth_query
  000ae	83 bc 24 90 02
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  000b6	74 0b		 je	 SHORT $LN4@qeth_query
  000b8	48 83 bc 24 98
	02 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  000c1	75 05		 jne	 SHORT $LN3@qeth_query
$LN4@qeth_query:
  000c3	e9 0b 03 00 00	 jmp	 $LN1@qeth_query
$LN3@qeth_query:
  000c8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000cf	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000d5	c1 e8 1a	 shr	 eax, 26
  000d8	83 e0 01	 and	 eax, 1
  000db	85 c0		 test	 eax, eax
  000dd	74 75		 je	 SHORT $LN5@qeth_query
  000df	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000f6	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000fc	48 8b d0	 mov	 rdx, rax
  000ff	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  0010d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173882
  00114	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0011c	e8 00 00 00 00	 call	 strcmp
  00121	85 c0		 test	 eax, eax
  00123	75 2d		 jne	 SHORT $LN7@qeth_query
  00125	b8 01 00 00 00	 mov	 eax, 1
  0012a	48 6b c0 00	 imul	 rax, rax, 0
  0012e	48 89 44 24 48	 mov	 QWORD PTR $T1[rsp], rax
  00133	48 81 7c 24 48
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  0013c	73 02		 jae	 SHORT $LN15@qeth_query
  0013e	eb 05		 jmp	 SHORT $LN16@qeth_query
$LN15@qeth_query:
  00140	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN16@qeth_query:
  00145	48 8b 44 24 48	 mov	 rax, QWORD PTR $T1[rsp]
  0014a	c6 84 04 50 01
	00 00 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@qeth_query:
  00152	eb 25		 jmp	 SHORT $LN6@qeth_query
$LN5@qeth_query:
  00154	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015c	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00162	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00168	48 8b d0	 mov	 rdx, rax
  0016b	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00173	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@qeth_query:

; 4383 : 
; 4384 :     grp = (OSA_GRP*) dev->group->grp_data;

  00179	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00181	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00185	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00189	48 89 44 24 40	 mov	 QWORD PTR grp$[rsp], rax

; 4385 : 
; 4386 :     if (dev->group->acount == dev->group->members)

  0018e	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00196	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0019a	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a2	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001a6	8b 09		 mov	 ecx, DWORD PTR [rcx]
  001a8	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  001ab	0f 85 e6 00 00
	00		 jne	 $LN8@qeth_query

; 4387 :     {
; 4388 :         char ttifname[IFNAMSIZ+2];
; 4389 :         char dropped[17] = {0}; // " dr[%u]"

  001b1	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dropped$3[rsp]
  001b9	48 8b f8	 mov	 rdi, rax
  001bc	33 c0		 xor	 eax, eax
  001be	b9 11 00 00 00	 mov	 ecx, 17
  001c3	f3 aa		 rep stosb

; 4390 : 
; 4391 :         STRLCPY( ttifname, grp->ttifname );

  001c5	48 8b 44 24 40	 mov	 rax, QWORD PTR grp$[rsp]
  001ca	48 83 c0 60	 add	 rax, 96			; 00000060H
  001ce	41 b8 12 00 00
	00		 mov	 r8d, 18
  001d4	48 8b d0	 mov	 rdx, rax
  001d7	48 8d 4c 24 68	 lea	 rcx, QWORD PTR ttifname$2[rsp]
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 4392 :         if (ttifname[0])

  001e2	b8 01 00 00 00	 mov	 eax, 1
  001e7	48 6b c0 00	 imul	 rax, rax, 0
  001eb	0f be 44 04 68	 movsx	 eax, BYTE PTR ttifname$2[rsp+rax]
  001f0	85 c0		 test	 eax, eax
  001f2	74 18		 je	 SHORT $LN9@qeth_query

; 4393 :             STRLCAT( ttifname, " " );

  001f4	41 b8 12 00 00
	00		 mov	 r8d, 18
  001fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173885
  00201	48 8d 4c 24 68	 lea	 rcx, QWORD PTR ttifname$2[rsp]
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN9@qeth_query:

; 4394 : 
; 4395 :         if (grp->debugmask & DBGQETHDROP)

  0020c	48 8b 44 24 40	 mov	 rax, QWORD PTR grp$[rsp]
  00211	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00217	83 e0 40	 and	 eax, 64			; 00000040H
  0021a	85 c0		 test	 eax, eax
  0021c	74 29		 je	 SHORT $LN10@qeth_query

; 4396 :             MSGBUF( dropped, " dr[%u]", dev->qdio.dropcnt );

  0021e	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00226	44 8b 88 30 13
	00 00		 mov	 r9d, DWORD PTR [rax+4912]
  0022d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173887
  00234	ba 11 00 00 00	 mov	 edx, 17
  00239	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR dropped$3[rsp]
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN10@qeth_query:

; 4397 : 
; 4398 :         MSGBUF( qdiostat, "%stx[%u] rx[%u]%s "

  00247	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR dropped$3[rsp]
  0024f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00254	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025c	8b 80 28 13 00
	00		 mov	 eax, DWORD PTR [rax+4904]
  00262	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00266	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026e	8b 80 2c 13 00
	00		 mov	 eax, DWORD PTR [rax+4908]
  00274	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00278	4c 8d 4c 24 68	 lea	 r9, QWORD PTR ttifname$2[rsp]
  0027d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173888
  00284	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  00289	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR qdiostat$[rsp]
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN8@qeth_query:

; 4399 :             , ttifname
; 4400 :             , dev->qdio.txcnt
; 4401 :             , dev->qdio.rxcnt
; 4402 :             , dropped
; 4403 :         );
; 4404 :     }
; 4405 : 
; 4406 :     if (dev->group->acount != dev->group->members)

  00297	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0029f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002a3	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002ab	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  002af	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002b1	39 48 04	 cmp	 DWORD PTR [rax+4], ecx
  002b4	74 1b		 je	 SHORT $LN11@qeth_query

; 4407 :         STRLCPY( incomplete, "*Incomplete " );

  002b6	41 b8 10 00 00
	00		 mov	 r8d, 16
  002bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173890
  002c3	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR incomplete$[rsp]
  002cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN11@qeth_query:

; 4408 : 
; 4409 :     if (dev->scsw.flag2 & SCSW2_Q)

  002d1	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d9	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  002e0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002e5	85 c0		 test	 eax, eax
  002e7	74 1c		 je	 SHORT $LN12@qeth_query

; 4410 :         STRLCPY( status, qdiostat );

  002e9	41 b8 50 00 00
	00		 mov	 r8d, 80			; 00000050H
  002ef	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR qdiostat$[rsp]
  002f7	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR status$[rsp]
  002ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN12@qeth_query:

; 4411 : 
; 4412 :     if (dev->qdio.idxstate == MPC_IDX_STATE_ACTIVE)

  00305	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0030d	83 b8 34 13 00
	00 01		 cmp	 DWORD PTR [rax+4916], 1
  00314	75 18		 jne	 SHORT $LN13@qeth_query

; 4413 :         STRLCPY( active, "IDX " );

  00316	41 b8 08 00 00
	00		 mov	 r8d, 8
  0031c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173893
  00323	48 8d 4c 24 60	 lea	 rcx, QWORD PTR active$[rsp]
  00328	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN13@qeth_query:

; 4414 : 
; 4415 :     snprintf( buffer, buflen, "QDIO %s%s%s%sIO[%"PRIu64"]"

  0032e	48 83 7c 24 40
	00		 cmp	 QWORD PTR grp$[rsp], 0
  00334	74 34		 je	 SHORT $LN19@qeth_query
  00336	48 8b 44 24 40	 mov	 rax, QWORD PTR grp$[rsp]
  0033b	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  00342	74 0e		 je	 SHORT $LN17@qeth_query
  00344	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173894
  0034b	48 89 44 24 50	 mov	 QWORD PTR tv202[rsp], rax
  00350	eb 0c		 jmp	 SHORT $LN18@qeth_query
$LN17@qeth_query:
  00352	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173895
  00359	48 89 44 24 50	 mov	 QWORD PTR tv202[rsp], rax
$LN18@qeth_query:
  0035e	48 8b 44 24 50	 mov	 rax, QWORD PTR tv202[rsp]
  00363	48 89 44 24 58	 mov	 QWORD PTR tv204[rsp], rax
  00368	eb 0c		 jmp	 SHORT $LN20@qeth_query
$LN19@qeth_query:
  0036a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173896
  00371	48 89 44 24 58	 mov	 QWORD PTR tv204[rsp], rax
$LN20@qeth_query:
  00376	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  0037e	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00386	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  0038d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00392	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv204[rsp]
  00397	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0039c	48 8d 4c 24 60	 lea	 rcx, QWORD PTR active$[rsp]
  003a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a6	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR status$[rsp]
  003ae	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003b3	4c 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR incomplete$[rsp]
  003bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173897
  003c2	48 8b d0	 mov	 rdx, rax
  003c5	48 8b 8c 24 98
	02 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  003cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@qeth_query:
$LN14@qeth_query:

; 4416 :         , incomplete
; 4417 :         , status
; 4418 :         , active
; 4419 :         , grp ? (grp->debugmask ? "debug " : "") : ""
; 4420 :         , dev->excps
; 4421 :     );
; 4422 : 
; 4423 : } /* end function qeth_query_device */

  003d3	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003db	48 33 cc	 xor	 rcx, rsp
  003de	e8 00 00 00 00	 call	 __security_check_cookie
  003e3	48 81 c4 70 02
	00 00		 add	 rsp, 624		; 00000270H
  003ea	5f		 pop	 rdi
  003eb	c3		 ret	 0
qeth_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 96
i$ = 104
retcode$ = 108
i$1 = 112
work_rc$2 = 116
c$3 = 120
uMTU$4 = 124
destlink$5 = 128
grouped$ = 132
chpid$6 = 136
tv173 = 140
tv188 = 144
tv194 = 148
tv209 = 152
tv215 = 156
tv541 = 160
tv547 = 164
tv567 = 168
tv573 = 172
tv594 = 176
tv600 = 180
tv639 = 184
tv645 = 188
tv690 = 192
tv696 = 196
tv777 = 200
tv783 = 204
tv819 = 208
tv825 = 212
tv854 = 216
tv860 = 220
tv896 = 224
tv902 = 228
tv947 = 232
tv953 = 236
tv1061 = 240
tv1067 = 244
tv1100 = 248
tv1106 = 252
tv1139 = 256
tv1145 = 260
tv167 = 264
p$7 = 272
pfxlen$8 = 280
mask4$ = 284
groupsize$ = 288
slash$9 = 296
slash$10 = 304
new_ttpfxlen$11 = 312
new_ttnetmask$12 = 320
prfx$13 = 328
prfx$14 = 336
tv532 = 344
cua$15 = 352
hrb$16 = 368
mac$17 = 816
buf$18 = 824
__$ArrayPad$ = 856
dev$ = 896
argc$ = 904
argv$ = 912
qeth_init_handler PROC

; 3894 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 58
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3895 : OSA_GRP *grp;
; 3896 : int groupsize = OSA_GROUP_SIZE;

  00029	c7 84 24 20 01
	00 00 03 00 00
	00		 mov	 DWORD PTR groupsize$[rsp], 3

; 3897 : int grouped = 0;

  00034	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR grouped$[rsp], 0

; 3898 : int i;
; 3899 : int retcode = 0;

  0003f	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR retcode$[rsp], 0

; 3900 : U32 mask4;
; 3901 : 
; 3902 : //  if (dev->numconfdev > groupsize)
; 3903 : //      groupsize = dev->numconfdev;
; 3904 : 
; 3905 :     if (!dev->group)

  00047	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004f	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00054	0f 85 c8 05 00
	00		 jne	 $LN32@qeth_init_

; 3906 :     {
; 3907 :         /* This code is executed for each device in the group. */
; 3908 : 
; 3909 : 
; 3910 :         memset( dev->sense,        0,       sizeof( dev->sense     ));

  0005a	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00062	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  00068	48 8b f8	 mov	 rdi, rax
  0006b	33 c0		 xor	 eax, eax
  0006d	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00072	f3 aa		 rep stosb

; 3911 :         memcpy( dev->devid, sense_id_bytes, sizeof( sense_id_bytes ));

  00074	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sense_id_bytes
  00083	48 8d b8 68 04
	00 00		 lea	 rdi, QWORD PTR [rax+1128]
  0008a	48 8b f1	 mov	 rsi, rcx
  0008d	b9 1c 00 00 00	 mov	 ecx, 28
  00092	f3 a4		 rep movsb

; 3912 : 
; 3913 :         dev->rcd         =  &qeth_read_configuration_data;

  00094	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:qeth_read_configuration_data
  000a3	48 89 88 b8 02
	00 00		 mov	 QWORD PTR [rax+696], rcx

; 3914 :         dev->numsense    =  32;

  000aa	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b2	c7 80 60 03 00
	00 20 00 00 00	 mov	 DWORD PTR [rax+864], 32	; 00000020H

; 3915 :         dev->numdevid    =  sizeof( sense_id_bytes );

  000bc	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c4	c7 80 64 04 00
	00 1c 00 00 00	 mov	 DWORD PTR [rax+1124], 28

; 3916 :         dev->devtype     =  dev->devid[1] << 8 | dev->devid[2];

  000ce	b8 01 00 00 00	 mov	 eax, 1
  000d3	48 6b c0 01	 imul	 rax, rax, 1
  000d7	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000df	0f b6 84 01 68
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1128]
  000e7	c1 e0 08	 shl	 eax, 8
  000ea	b9 01 00 00 00	 mov	 ecx, 1
  000ef	48 6b c9 02	 imul	 rcx, rcx, 2
  000f3	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000fb	0f b6 8c 0a 68
	04 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1128]
  00103	0b c1		 or	 eax, ecx
  00105	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010d	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 3917 :         dev->chptype[0]  =  CHP_TYPE_OSD;

  00111	b8 01 00 00 00	 mov	 eax, 1
  00116	48 6b c0 00	 imul	 rax, rax, 0
  0011a	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00122	c6 84 01 cc 05
	00 00 11	 mov	 BYTE PTR [rcx+rax+1484], 17

; 3918 :         dev->pmcw.flag4 |=  PMCW4_Q;

  0012a	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00132	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00139	0f ba e8 07	 bts	 eax, 7
  0013d	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00145	88 81 f0 02 00
	00		 mov	 BYTE PTR [rcx+752], al

; 3919 :         dev->fd          =  -1;

  0014b	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00153	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 3920 : 
; 3921 :         /* Setting dev->bufsize = 0xFFFF causes, on return to attach_device */
; 3922 :         /* in config.c, storage of size 0xFFFF bytes to be obtained, and    */
; 3923 :         /* the storage address to be placed in dev->buf. The storage is     */
; 3924 :         /* used to receive data from the TUNTAP interface, so 0xFFFF is     */
; 3925 :         /* effectively the largest MTU that could ever be used by QETH.     */
; 3926 : 
; 3927 :         dev->bufsize = 0xFFFF;    /* maximum packet/frame size */

  0015d	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00165	c7 80 d8 01 00
	00 ff ff 00 00	 mov	 DWORD PTR [rax+472], 65535 ; 0000ffffH

; 3928 : 
; 3929 :         if (!(grouped = group_device( dev, groupsize )) && !dev->member)

  0016f	8b 94 24 20 01
	00 00		 mov	 edx, DWORD PTR groupsize$[rsp]
  00176	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_group_device
  00184	89 84 24 84 00
	00 00		 mov	 DWORD PTR grouped$[rsp], eax
  0018b	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR grouped$[rsp], 0
  00193	0f 85 72 04 00
	00		 jne	 $LN34@qeth_init_
  00199	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a1	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  001a5	0f 85 60 04 00
	00		 jne	 $LN34@qeth_init_

; 3930 :         {
; 3931 :             char buf[32];
; 3932 : 
; 3933 :             /* This code is executed for the first device in the group. */
; 3934 : 
; 3935 :             dev->group->grp_data = grp = malloc( sizeof( OSA_GRP ));

  001ab	b9 a8 06 00 00	 mov	 ecx, 1704		; 000006a8H
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001b6	48 89 44 24 60	 mov	 QWORD PTR grp$[rsp], rax
  001bb	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  001cc	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 3936 :             memset( grp, 0, sizeof( OSA_GRP ));

  001d0	48 8b 7c 24 60	 mov	 rdi, QWORD PTR grp$[rsp]
  001d5	33 c0		 xor	 eax, eax
  001d7	b9 a8 06 00 00	 mov	 ecx, 1704		; 000006a8H
  001dc	f3 aa		 rep stosb

; 3937 : 
; 3938 :             initialize_condition( &grp->qrcond );

  001de	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  001e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173669
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 3939 :             initialize_condition( &grp->qdcond );

  001f3	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  001f8	48 83 c0 08	 add	 rax, 8
  001fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173670
  00203	48 8b c8	 mov	 rcx, rax
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 3940 : 
; 3941 :             initialize_lock( &grp->qlock );

  0020c	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00211	48 83 c0 10	 add	 rax, 16
  00215	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173671
  0021c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173672
  00223	48 8b c8	 mov	 rcx, rax
  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 3942 :             MSGBUF( buf,    "&grp->qlock %1d:%04X",       LCSS_DEVNUM );

  0022c	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00235	74 15		 je	 SHORT $LN112@qeth_init_
  00237	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00243	89 84 24 08 01
	00 00		 mov	 DWORD PTR tv167[rsp], eax
  0024a	eb 0b		 jmp	 SHORT $LN113@qeth_init_
$LN112@qeth_init_:
  0024c	c7 84 24 08 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv167[rsp], 0
$LN113@qeth_init_:
  00257	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00260	74 17		 je	 SHORT $LN114@qeth_init_
  00262	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0026a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0026e	d1 f8		 sar	 eax, 1
  00270	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv173[rsp], eax
  00277	eb 0b		 jmp	 SHORT $LN115@qeth_init_
$LN114@qeth_init_:
  00279	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv173[rsp], 0
$LN115@qeth_init_:
  00284	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR tv167[rsp]
  0028b	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0028f	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR tv173[rsp]
  00297	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173673
  0029e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  002a3	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR buf$18[rsp]
  002ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3943 :             set_lock_name(   &grp->qlock, buf );

  002b1	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  002b6	48 83 c0 10	 add	 rax, 16
  002ba	48 8d 94 24 38
	03 00 00	 lea	 rdx, QWORD PTR buf$18[rsp]
  002c2	48 8b c8	 mov	 rcx, rax
  002c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 3944 : 
; 3945 :             initialize_lock( &grp->idx.lockbhr );

  002cb	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  002d0	48 83 c0 18	 add	 rax, 24
  002d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173674
  002db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173675
  002e2	48 8b c8	 mov	 rcx, rax
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 3946 :             MSGBUF( buf,    "&grp->idx.lockbhr %1d:%04X", LCSS_DEVNUM );

  002eb	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002f4	74 15		 je	 SHORT $LN116@qeth_init_
  002f6	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002fe	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00302	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv188[rsp], eax
  00309	eb 0b		 jmp	 SHORT $LN117@qeth_init_
$LN116@qeth_init_:
  0030b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv188[rsp], 0
$LN117@qeth_init_:
  00316	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0031f	74 17		 je	 SHORT $LN118@qeth_init_
  00321	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00329	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0032d	d1 f8		 sar	 eax, 1
  0032f	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  00336	eb 0b		 jmp	 SHORT $LN119@qeth_init_
$LN118@qeth_init_:
  00338	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv194[rsp], 0
$LN119@qeth_init_:
  00343	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv188[rsp]
  0034a	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0034e	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR tv194[rsp]
  00356	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173676
  0035d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00362	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR buf$18[rsp]
  0036a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3947 :             set_lock_name(   &grp->idx.lockbhr, buf );

  00370	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00375	48 83 c0 18	 add	 rax, 24
  00379	48 8d 94 24 38
	03 00 00	 lea	 rdx, QWORD PTR buf$18[rsp]
  00381	48 8b c8	 mov	 rcx, rax
  00384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name

; 3948 : 
; 3949 :             initialize_lock( &grp->l3r.lockbhr );

  0038a	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0038f	48 83 c0 38	 add	 rax, 56			; 00000038H
  00393	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173677
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173678
  003a1	48 8b c8	 mov	 rcx, rax
  003a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock

; 3950 :             MSGBUF( buf,    "&grp->l3r.lockbhr %1d:%04X", LCSS_DEVNUM );

  003aa	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003b3	74 15		 je	 SHORT $LN120@qeth_init_
  003b5	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003bd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003c1	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv209[rsp], eax
  003c8	eb 0b		 jmp	 SHORT $LN121@qeth_init_
$LN120@qeth_init_:
  003ca	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv209[rsp], 0
$LN121@qeth_init_:
  003d5	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003de	74 17		 je	 SHORT $LN122@qeth_init_
  003e0	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003e8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003ec	d1 f8		 sar	 eax, 1
  003ee	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv215[rsp], eax
  003f5	eb 0b		 jmp	 SHORT $LN123@qeth_init_
$LN122@qeth_init_:
  003f7	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv215[rsp], 0
$LN123@qeth_init_:
  00402	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv209[rsp]
  00409	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0040d	44 8b 8c 24 9c
	00 00 00	 mov	 r9d, DWORD PTR tv215[rsp]
  00415	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173679
  0041c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00421	48 8d 8c 24 38
	03 00 00	 lea	 rcx, QWORD PTR buf$18[rsp]
  00429	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 3951 :             set_lock_name(   &grp->l3r.lockbhr, buf );

  0042f	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00434	48 83 c0 38	 add	 rax, 56			; 00000038H
  00438	48 8d 94 24 38
	03 00 00	 lea	 rdx, QWORD PTR buf$18[rsp]
  00440	48 8b c8	 mov	 rcx, rax
  00443	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_lock_name
$LN4@qeth_init_:

; 3952 : 
; 3953 :             /* Create ACTIVATE QUEUES signalling pipe */
; 3954 :             /* Check your return codes, Jan. */
; 3955 : 
; 3956 :             VERIFY( !create_pipe( grp->ppfd ));

  00449	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0044e	48 05 fc 05 00
	00		 add	 rax, 1532		; 000005fcH
  00454	4c 8b c8	 mov	 r9, rax
  00457	45 33 c0	 xor	 r8d, r8d
  0045a	ba 01 00 00 00	 mov	 edx, 1
  0045f	b9 02 00 00 00	 mov	 ecx, 2
  00464	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socketpair
  0046a	85 c0		 test	 eax, eax
  0046c	74 5c		 je	 SHORT $LN36@qeth_init_
$LN7@qeth_init_:
  0046e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173681
  00475	41 b8 74 0f 00
	00		 mov	 r8d, 3956		; 00000f74H
  0047b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173682
  00482	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173683
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0048f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00495	85 c0		 test	 eax, eax
  00497	74 20		 je	 SHORT $LN37@qeth_init_
  00499	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173685
  004a0	41 b8 74 0f 00
	00		 mov	 r8d, 3956		; 00000f74H
  004a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173686
  004ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173687
  004b4	e8 00 00 00 00	 call	 DebuggerTrace
$LN37@qeth_init_:
  004b9	33 c0		 xor	 eax, eax
  004bb	85 c0		 test	 eax, eax
  004bd	75 af		 jne	 SHORT $LN7@qeth_init_
  004bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004c5	85 c0		 test	 eax, eax
  004c7	74 01		 je	 SHORT $LN38@qeth_init_
  004c9	cc		 int	 3
$LN38@qeth_init_:
$LN36@qeth_init_:
  004ca	33 c0		 xor	 eax, eax
  004cc	85 c0		 test	 eax, eax
  004ce	0f 85 75 ff ff
	ff		 jne	 $LN4@qeth_init_
$LN10@qeth_init_:

; 3957 : 
; 3958 :             /* Set NON-Blocking mode (i.e. disable blocking mode) */
; 3959 : 
; 3960 :             VERIFY( socket_set_blocking_mode( grp->ppfd[0], 0 ) == 0);

  004d4	b8 04 00 00 00	 mov	 eax, 4
  004d9	48 6b c0 00	 imul	 rax, rax, 0
  004dd	33 d2		 xor	 edx, edx
  004df	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  004e4	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  004eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode
  004f1	85 c0		 test	 eax, eax
  004f3	74 5c		 je	 SHORT $LN39@qeth_init_
$LN13@qeth_init_:
  004f5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173690
  004fc	41 b8 78 0f 00
	00		 mov	 r8d, 3960		; 00000f78H
  00502	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173691
  00509	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173692
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00516	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0051c	85 c0		 test	 eax, eax
  0051e	74 20		 je	 SHORT $LN40@qeth_init_
  00520	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173694
  00527	41 b8 78 0f 00
	00		 mov	 r8d, 3960		; 00000f78H
  0052d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173695
  00534	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173696
  0053b	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@qeth_init_:
  00540	33 c0		 xor	 eax, eax
  00542	85 c0		 test	 eax, eax
  00544	75 af		 jne	 SHORT $LN13@qeth_init_
  00546	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0054c	85 c0		 test	 eax, eax
  0054e	74 01		 je	 SHORT $LN41@qeth_init_
  00550	cc		 int	 3
$LN41@qeth_init_:
$LN39@qeth_init_:
  00551	33 c0		 xor	 eax, eax
  00553	85 c0		 test	 eax, eax
  00555	0f 85 79 ff ff
	ff		 jne	 $LN10@qeth_init_
$LN16@qeth_init_:

; 3961 :             VERIFY( socket_set_blocking_mode( grp->ppfd[1], 0 ) == 0);

  0055b	b8 04 00 00 00	 mov	 eax, 4
  00560	48 6b c0 01	 imul	 rax, rax, 1
  00564	33 d2		 xor	 edx, edx
  00566	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0056b	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  00572	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode
  00578	85 c0		 test	 eax, eax
  0057a	74 5c		 je	 SHORT $LN42@qeth_init_
$LN19@qeth_init_:
  0057c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173699
  00583	41 b8 79 0f 00
	00		 mov	 r8d, 3961		; 00000f79H
  00589	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173700
  00590	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173701
  00597	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0059d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  005a3	85 c0		 test	 eax, eax
  005a5	74 20		 je	 SHORT $LN43@qeth_init_
  005a7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173703
  005ae	41 b8 79 0f 00
	00		 mov	 r8d, 3961		; 00000f79H
  005b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173704
  005bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173705
  005c2	e8 00 00 00 00	 call	 DebuggerTrace
$LN43@qeth_init_:
  005c7	33 c0		 xor	 eax, eax
  005c9	85 c0		 test	 eax, eax
  005cb	75 af		 jne	 SHORT $LN19@qeth_init_
  005cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  005d3	85 c0		 test	 eax, eax
  005d5	74 01		 je	 SHORT $LN44@qeth_init_
  005d7	cc		 int	 3
$LN44@qeth_init_:
$LN42@qeth_init_:
  005d8	33 c0		 xor	 eax, eax
  005da	85 c0		 test	 eax, eax
  005dc	0f 85 79 ff ff
	ff		 jne	 $LN16@qeth_init_

; 3962 : 
; 3963 :             /* Set defaults */
; 3964 : 
; 3965 :             grp->ttdev = strdup( DEF_NETDEV );

  005e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_sysblk_netdev
  005e8	48 8b c8	 mov	 rcx, rax
  005eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  005f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  005f6	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 3966 :             grp->ttfd  = -1;

  005fa	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  005ff	c7 80 f8 05 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+1528], -1

; 3967 :         }

  00609	eb 15		 jmp	 SHORT $LN35@qeth_init_
$LN34@qeth_init_:

; 3968 :         else
; 3969 :             /* This code is executed for the second and subsequent devices in the group. */
; 3970 :             grp = dev->group->grp_data;

  0060b	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00613	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00617	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0061b	48 89 44 24 60	 mov	 QWORD PTR grp$[rsp], rax
$LN35@qeth_init_:

; 3971 :     }

  00620	eb 15		 jmp	 SHORT $LN33@qeth_init_
$LN32@qeth_init_:

; 3972 :     else
; 3973 :         /* This code is not executed. ??? */
; 3974 :         grp = dev->group->grp_data;

  00622	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0062a	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0062e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00632	48 89 44 24 60	 mov	 QWORD PTR grp$[rsp], rax
$LN33@qeth_init_:

; 3975 : 
; 3976 :     /*-----------------------------------------------------------*/
; 3977 :     /* PROCESS ALL COMMAND LINE OPTIONS HERE.                    */
; 3978 :     /* Each device in the group will execute this loop.          */
; 3979 :     /*-----------------------------------------------------------*/
; 3980 :     /*                                                           */
; 3981 :     /* NOTE: The following configuration statement:              */
; 3982 :     /*                                                           */
; 3983 :     /*    0800-0802 QETH mtu 1492 ipaddr 192.168.2.1 debug       */
; 3984 :     /*                                                           */
; 3985 :     /* results in exactly the same QETH group as the following   */
; 3986 :     /* configuration statements:                                 */
; 3987 :     /*                                                           */
; 3988 :     /*    0802 QETH mtu 1492                                     */
; 3989 :     /*    0800 QETH ipaddr 192.168.2.1                           */
; 3990 :     /*    0801 QETH debug                                        */
; 3991 :     /*                                                           */
; 3992 :     /* This is either a bug or a design feature, depending       */
; 3993 :     /* on your point of view.                                    */
; 3994 :     /*                                                           */
; 3995 :     /*-----------------------------------------------------------*/
; 3996 : 
; 3997 :     /* PROGRAMMING NOTE: argument validation is deferred until the
; 3998 :        group is complete. Thus the below argument processing loop
; 3999 :        just saves the argument values but doesn't validate them. */
; 4000 : 
; 4001 :     for (i=0; i < argc; i++)

  00637	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0063f	eb 0a		 jmp	 SHORT $LN22@qeth_init_
$LN20@qeth_init_:
  00641	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00645	ff c0		 inc	 eax
  00647	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
$LN22@qeth_init_:
  0064b	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00652	39 44 24 68	 cmp	 DWORD PTR i$[rsp], eax
  00656	0f 8d a5 06 00
	00		 jge	 $LN21@qeth_init_

; 4002 :     {
; 4003 :         if (!strcasecmp("iface",argv[i]) && (i+1) < argc)

  0065c	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00661	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00669	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0066d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173709
  00674	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0067a	85 c0		 test	 eax, eax
  0067c	75 52		 jne	 SHORT $LN45@qeth_init_
  0067e	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00682	ff c0		 inc	 eax
  00684	3b 84 24 88 03
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  0068b	7d 43		 jge	 SHORT $LN45@qeth_init_

; 4004 :         {
; 4005 :             free( grp->ttdev );

  0068d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00692	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  00696	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4006 :             grp->ttdev = strdup(argv[++i]);

  0069c	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  006a0	ff c0		 inc	 eax
  006a2	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  006a6	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  006ab	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006b3	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  006b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  006bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  006c2	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 4007 :             continue;

  006c6	e9 76 ff ff ff	 jmp	 $LN20@qeth_init_

; 4008 :         }

  006cb	e9 2c 06 00 00	 jmp	 $LN46@qeth_init_
$LN45@qeth_init_:

; 4009 : #if !defined( OPTION_W32_CTCI )
; 4010 :         else if(!strcasecmp("ifname",argv[i]) && (i+1) < argc)
; 4011 :         {
; 4012 :             STRLCPY( grp->ttifname, argv[++i] );
; 4013 :             continue;
; 4014 :         }
; 4015 : #endif
; 4016 :         else if(!strcasecmp("hwaddr",argv[i]) && (i+1) < argc)

  006d0	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  006d5	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006dd	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  006e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173712
  006e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  006ee	85 c0		 test	 eax, eax
  006f0	75 52		 jne	 SHORT $LN47@qeth_init_
  006f2	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  006f6	ff c0		 inc	 eax
  006f8	3b 84 24 88 03
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  006ff	7d 43		 jge	 SHORT $LN47@qeth_init_

; 4017 :         {
; 4018 :             free( grp->tthwaddr );

  00701	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00706	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0070a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4019 :             grp->tthwaddr = strdup(argv[++i]);

  00710	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00714	ff c0		 inc	 eax
  00716	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  0071a	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0071f	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00727	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0072b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00731	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00736	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 4020 :             continue;

  0073a	e9 02 ff ff ff	 jmp	 $LN20@qeth_init_

; 4021 :         }

  0073f	e9 b8 05 00 00	 jmp	 $LN48@qeth_init_
$LN47@qeth_init_:

; 4022 :         else if(!strcasecmp("ipaddr",argv[i]) && (i+1) < argc)

  00744	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00749	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00751	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00755	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173715
  0075c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00762	85 c0		 test	 eax, eax
  00764	0f 85 e1 00 00
	00		 jne	 $LN49@qeth_init_
  0076a	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  0076e	ff c0		 inc	 eax
  00770	3b 84 24 88 03
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  00777	0f 8d ce 00 00
	00		 jge	 $LN49@qeth_init_

; 4023 :         {
; 4024 :             char  *slash, *prfx;
; 4025 :             slash = strchr( argv[i+1], '/' );  /* Point to slash character */

  0077d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00781	ff c0		 inc	 eax
  00783	48 98		 cdqe
  00785	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0078a	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00792	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00796	e8 00 00 00 00	 call	 strchr
  0079b	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR slash$9[rsp], rax

; 4026 :             if (slash) {                       /* If there is a slash      */

  007a3	48 83 bc 24 28
	01 00 00 00	 cmp	 QWORD PTR slash$9[rsp], 0
  007ac	74 54		 je	 SHORT $LN51@qeth_init_

; 4027 :                 slash[0] = 0;                  /* Replace slash with null  */

  007ae	b8 01 00 00 00	 mov	 eax, 1
  007b3	48 6b c0 00	 imul	 rax, rax, 0
  007b7	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR slash$9[rsp]
  007bf	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 4028 :                 prfx = slash + 1;              /* Point to prefix size     */

  007c3	48 8b 84 24 28
	01 00 00	 mov	 rax, QWORD PTR slash$9[rsp]
  007cb	48 ff c0	 inc	 rax
  007ce	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR prfx$14[rsp], rax

; 4029 :                 free( grp->ttpfxlen );

  007d6	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  007db	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  007e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4030 :                 grp->ttpfxlen = strdup(prfx);

  007e8	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR prfx$14[rsp]
  007f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  007f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  007fb	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN51@qeth_init_:

; 4031 :             }
; 4032 :             free( grp->ttipaddr );

  00802	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00807	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  0080e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4033 :             grp->ttipaddr = strdup(argv[++i]);

  00814	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00818	ff c0		 inc	 eax
  0081a	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  0081e	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00823	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0082b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0082f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00835	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0083a	48 89 81 80 00
	00 00		 mov	 QWORD PTR [rcx+128], rax

; 4034 :             continue;

  00841	e9 fb fd ff ff	 jmp	 $LN20@qeth_init_

; 4035 :         }

  00846	e9 b1 04 00 00	 jmp	 $LN50@qeth_init_
$LN49@qeth_init_:

; 4036 :         else if(!strcasecmp("netmask",argv[i]) && (i+1) < argc)

  0084b	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00850	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00858	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0085c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173719
  00863	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00869	85 c0		 test	 eax, eax
  0086b	75 58		 jne	 SHORT $LN52@qeth_init_
  0086d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00871	ff c0		 inc	 eax
  00873	3b 84 24 88 03
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  0087a	7d 49		 jge	 SHORT $LN52@qeth_init_

; 4037 :         {
; 4038 :             free( grp->ttnetmask );

  0087c	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00881	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  00888	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4039 :             grp->ttnetmask = strdup(argv[++i]);

  0088e	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00892	ff c0		 inc	 eax
  00894	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00898	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  0089d	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008a5	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  008a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  008af	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  008b4	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 4040 :             continue;

  008bb	e9 81 fd ff ff	 jmp	 $LN20@qeth_init_

; 4041 :         }

  008c0	e9 37 04 00 00	 jmp	 $LN53@qeth_init_
$LN52@qeth_init_:

; 4042 : #if defined( ENABLE_IPV6 )
; 4043 :         else if(!strcasecmp("ipaddr6",argv[i]) && (i+1) < argc)

  008c5	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  008ca	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  008d2	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  008d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173722
  008dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  008e3	85 c0		 test	 eax, eax
  008e5	0f 85 f2 00 00
	00		 jne	 $LN54@qeth_init_
  008eb	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  008ef	ff c0		 inc	 eax
  008f1	3b 84 24 88 03
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  008f8	0f 8d df 00 00
	00		 jge	 $LN54@qeth_init_

; 4044 :         {
; 4045 :             char  *slash, *prfx;
; 4046 :             free( grp->ttipaddr6 );

  008fe	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00903	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  0090a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4047 :             free( grp->ttpfxlen6 );

  00910	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00915	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  0091c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4048 :             slash = strchr( argv[i+1], '/' );  /* Point to slash character */

  00922	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00926	ff c0		 inc	 eax
  00928	48 98		 cdqe
  0092a	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0092f	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00937	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0093b	e8 00 00 00 00	 call	 strchr
  00940	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR slash$10[rsp], rax

; 4049 :             if (slash) {                       /* If there is a slash      */

  00948	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR slash$10[rsp], 0
  00951	74 2a		 je	 SHORT $LN56@qeth_init_

; 4050 :                 prfx = slash + 1;              /* Point to prefix size     */

  00953	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR slash$10[rsp]
  0095b	48 ff c0	 inc	 rax
  0095e	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR prfx$13[rsp], rax

; 4051 :                 slash[0] = 0;                  /* Replace slash with null  */

  00966	b8 01 00 00 00	 mov	 eax, 1
  0096b	48 6b c0 00	 imul	 rax, rax, 0
  0096f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR slash$10[rsp]
  00977	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 4052 :             }

  0097b	eb 0f		 jmp	 SHORT $LN57@qeth_init_
$LN56@qeth_init_:

; 4053 :             else {
; 4054 :                 prfx = "128";

  0097d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173725
  00984	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR prfx$13[rsp], rax
$LN57@qeth_init_:

; 4055 :             }
; 4056 :             grp->ttpfxlen6 = strdup(prfx);

  0098c	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR prfx$13[rsp]
  00994	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0099a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0099f	48 89 81 a0 00
	00 00		 mov	 QWORD PTR [rcx+160], rax

; 4057 :             grp->ttipaddr6 = strdup(argv[++i]);

  009a6	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  009aa	ff c0		 inc	 eax
  009ac	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  009b0	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  009b5	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009bd	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  009c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  009c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  009cc	48 89 81 98 00
	00 00		 mov	 QWORD PTR [rcx+152], rax

; 4058 :             continue;

  009d3	e9 69 fc ff ff	 jmp	 $LN20@qeth_init_

; 4059 :         }

  009d8	e9 1f 03 00 00	 jmp	 $LN55@qeth_init_
$LN54@qeth_init_:

; 4060 : #endif /* defined( ENABLE_IPV6 ) */
; 4061 :         else if(!strcasecmp("mtu",argv[i]) && (i+1) < argc)

  009dd	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  009e2	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  009ea	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  009ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173728
  009f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  009fb	85 c0		 test	 eax, eax
  009fd	75 52		 jne	 SHORT $LN58@qeth_init_
  009ff	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a03	ff c0		 inc	 eax
  00a05	3b 84 24 88 03
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  00a0c	7d 43		 jge	 SHORT $LN58@qeth_init_

; 4062 :         {
; 4063 :             free( grp->ttmtu );

  00a0e	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00a13	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00a17	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4064 :             grp->ttmtu = strdup(argv[++i]);

  00a1d	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a21	ff c0		 inc	 eax
  00a23	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00a27	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00a2c	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a34	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00a38	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00a3e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00a43	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 4065 :             continue;

  00a47	e9 f5 fb ff ff	 jmp	 $LN20@qeth_init_

; 4066 :         }

  00a4c	e9 ab 02 00 00	 jmp	 $LN59@qeth_init_
$LN58@qeth_init_:

; 4067 :         else if(!strcasecmp("chpid",argv[i]) && (i+1) < argc)

  00a51	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00a56	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a5e	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00a62	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173731
  00a69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00a6f	85 c0		 test	 eax, eax
  00a71	75 58		 jne	 SHORT $LN60@qeth_init_
  00a73	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a77	ff c0		 inc	 eax
  00a79	3b 84 24 88 03
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  00a80	7d 49		 jge	 SHORT $LN60@qeth_init_

; 4068 :         {
; 4069 :             free( grp->ttchpid );

  00a82	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00a87	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  00a8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4070 :             grp->ttchpid = strdup(argv[++i]);

  00a94	8b 44 24 68	 mov	 eax, DWORD PTR i$[rsp]
  00a98	ff c0		 inc	 eax
  00a9a	89 44 24 68	 mov	 DWORD PTR i$[rsp], eax
  00a9e	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00aa3	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00aab	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00aaf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00ab5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00aba	48 89 81 a8 00
	00 00		 mov	 QWORD PTR [rcx+168], rax

; 4071 :             continue;

  00ac1	e9 7b fb ff ff	 jmp	 $LN20@qeth_init_

; 4072 :         }

  00ac6	e9 31 02 00 00	 jmp	 $LN61@qeth_init_
$LN60@qeth_init_:

; 4073 :         else if (!strcasecmp("debug",argv[i]))

  00acb	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00ad0	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00ad8	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00adc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173734
  00ae3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00ae9	85 c0		 test	 eax, eax
  00aeb	75 19		 jne	 SHORT $LN62@qeth_init_

; 4074 :         {
; 4075 :             grp->debugmask = DBGQETHPACKET+DBGQETHDATA+DBGQETHUPDOWN;

  00aed	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00af2	c7 80 e0 05 00
	00 13 00 00 00	 mov	 DWORD PTR [rax+1504], 19

; 4076 :             continue;

  00afc	e9 40 fb ff ff	 jmp	 $LN20@qeth_init_

; 4077 :         }

  00b01	e9 f6 01 00 00	 jmp	 $LN63@qeth_init_
$LN62@qeth_init_:

; 4078 :         else if (!strcasecmp("debugpacket",argv[i]))

  00b06	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00b0b	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b13	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00b17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173737
  00b1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00b24	85 c0		 test	 eax, eax
  00b26	75 23		 jne	 SHORT $LN64@qeth_init_

; 4079 :         {
; 4080 :             grp->debugmask |= DBGQETHPACKET;

  00b28	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00b2d	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00b33	83 c8 01	 or	 eax, 1
  00b36	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00b3b	89 81 e0 05 00
	00		 mov	 DWORD PTR [rcx+1504], eax

; 4081 :             continue;

  00b41	e9 fb fa ff ff	 jmp	 $LN20@qeth_init_

; 4082 :         }

  00b46	e9 b1 01 00 00	 jmp	 $LN65@qeth_init_
$LN64@qeth_init_:

; 4083 :         else if (!strcasecmp("debugdata",argv[i]))

  00b4b	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00b50	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b58	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00b5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173740
  00b63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00b69	85 c0		 test	 eax, eax
  00b6b	75 23		 jne	 SHORT $LN66@qeth_init_

; 4084 :         {
; 4085 :             grp->debugmask |= DBGQETHDATA;

  00b6d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00b72	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00b78	83 c8 02	 or	 eax, 2
  00b7b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00b80	89 81 e0 05 00
	00		 mov	 DWORD PTR [rcx+1504], eax

; 4086 :             continue;

  00b86	e9 b6 fa ff ff	 jmp	 $LN20@qeth_init_

; 4087 :         }

  00b8b	e9 6c 01 00 00	 jmp	 $LN67@qeth_init_
$LN66@qeth_init_:

; 4088 :         else if (!strcasecmp("debugupdown",argv[i]))

  00b90	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00b95	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b9d	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00ba1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173743
  00ba8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00bae	85 c0		 test	 eax, eax
  00bb0	75 23		 jne	 SHORT $LN68@qeth_init_

; 4089 :         {
; 4090 :             grp->debugmask |= DBGQETHUPDOWN;

  00bb2	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00bb7	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00bbd	83 c8 10	 or	 eax, 16
  00bc0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00bc5	89 81 e0 05 00
	00		 mov	 DWORD PTR [rcx+1504], eax

; 4091 :             continue;

  00bcb	e9 71 fa ff ff	 jmp	 $LN20@qeth_init_

; 4092 :         }

  00bd0	e9 27 01 00 00	 jmp	 $LN69@qeth_init_
$LN68@qeth_init_:

; 4093 :         else if(!strcasecmp("nodebug",argv[i]))

  00bd5	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00bda	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00be2	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00be6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173746
  00bed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00bf3	85 c0		 test	 eax, eax
  00bf5	75 19		 jne	 SHORT $LN70@qeth_init_

; 4094 :         {
; 4095 :             grp->debugmask = 0;

  00bf7	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00bfc	c7 80 e0 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1504], 0

; 4096 :             continue;

  00c06	e9 36 fa ff ff	 jmp	 $LN20@qeth_init_

; 4097 :         }

  00c0b	e9 ec 00 00 00	 jmp	 $LN71@qeth_init_
$LN70@qeth_init_:

; 4098 :         else
; 4099 :         {
; 4100 :             // HHC00918 "%1d:%04X %s: option %s unknown or specified incorrectly"
; 4101 :             WRMSG(HHC00918, "E", LCSS_DEVNUM, dev->typname, argv[i] );

  00c10	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c19	74 15		 je	 SHORT $LN124@qeth_init_
  00c1b	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c23	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c27	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv541[rsp], eax
  00c2e	eb 0b		 jmp	 SHORT $LN125@qeth_init_
$LN124@qeth_init_:
  00c30	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv541[rsp], 0
$LN125@qeth_init_:
  00c3b	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c44	74 17		 je	 SHORT $LN126@qeth_init_
  00c46	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c4e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00c52	d1 f8		 sar	 eax, 1
  00c54	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv547[rsp], eax
  00c5b	eb 0b		 jmp	 SHORT $LN127@qeth_init_
$LN126@qeth_init_:
  00c5d	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv547[rsp], 0
$LN127@qeth_init_:
  00c68	48 63 44 24 68	 movsxd	 rax, DWORD PTR i$[rsp]
  00c6d	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR tv532[rsp], rax
  00c75	b9 01 00 00 00	 mov	 ecx, 1
  00c7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c80	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00c88	48 8b 94 24 58
	01 00 00	 mov	 rdx, QWORD PTR tv532[rsp]
  00c90	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00c94	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00c99	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ca1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00ca5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00caa	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv541[rsp]
  00cb1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cb5	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv547[rsp]
  00cbc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173747
  00cc7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ccc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173748
  00cd3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00cd8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cdd	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ce3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173749
  00cea	ba 05 10 00 00	 mov	 edx, 4101		; 00001005H
  00cef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173750
  00cf6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN71@qeth_init_:
$LN69@qeth_init_:
$LN67@qeth_init_:
$LN65@qeth_init_:
$LN63@qeth_init_:
$LN61@qeth_init_:
$LN59@qeth_init_:
$LN55@qeth_init_:
$LN53@qeth_init_:
$LN50@qeth_init_:
$LN48@qeth_init_:
$LN46@qeth_init_:

; 4102 :         }
; 4103 :     }

  00cfc	e9 40 f9 ff ff	 jmp	 $LN20@qeth_init_
$LN21@qeth_init_:

; 4104 : 
; 4105 :     if (grouped)

  00d01	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR grouped$[rsp], 0
  00d09	0f 84 5b 13 00
	00		 je	 $LN72@qeth_init_

; 4106 :     {
; 4107 :         /* Validate the arguments now that the group is complete. */
; 4108 : 
; 4109 :         DEVBLK  *cua;
; 4110 :         U16      destlink;
; 4111 :         int      i, work_rc, pfxlen, chpid;
; 4112 :         MAC      mac;
; 4113 :         HRB      hrb;
; 4114 :         char     c;
; 4115 :         char    *p;
; 4116 :         static const BYTE zeromac[IFHWADDRLEN] = {0};
; 4117 : 
; 4118 : #if defined( OPTION_W32_CTCI )
; 4119 :         /* The 'ipaddr' and 'netmask' are REQUIRED parameters */
; 4120 :         if (!grp->ttipaddr)

  00d0f	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00d14	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00d1c	0f 85 da 00 00
	00		 jne	 $LN73@qeth_init_

; 4121 :         {
; 4122 :             // "%1d:%04X %s: Required parameter '%s' missing"
; 4123 :             WRMSG( HHC00917, "E", LCSS_DEVNUM, dev->typname, "ipaddr" );

  00d22	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d2b	74 15		 je	 SHORT $LN128@qeth_init_
  00d2d	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d35	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d39	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv567[rsp], eax
  00d40	eb 0b		 jmp	 SHORT $LN129@qeth_init_
$LN128@qeth_init_:
  00d42	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv567[rsp], 0
$LN129@qeth_init_:
  00d4d	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d56	74 17		 je	 SHORT $LN130@qeth_init_
  00d58	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d60	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d64	d1 f8		 sar	 eax, 1
  00d66	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv573[rsp], eax
  00d6d	eb 0b		 jmp	 SHORT $LN131@qeth_init_
$LN130@qeth_init_:
  00d6f	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv573[rsp], 0
$LN131@qeth_init_:
  00d7a	b9 01 00 00 00	 mov	 ecx, 1
  00d7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173753
  00d8c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00d91	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d99	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00d9d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00da2	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv567[rsp]
  00da9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00dad	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv573[rsp]
  00db4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00db8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173754
  00dbf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00dc4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173755
  00dcb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00dd0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00dd5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ddb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173756
  00de2	ba 1b 10 00 00	 mov	 edx, 4123		; 0000101bH
  00de7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173757
  00dee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4124 :             retcode = -1;

  00df4	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1
$LN73@qeth_init_:

; 4125 :         }
; 4126 :         if (!grp->ttnetmask && !grp->ttpfxlen)

  00dfc	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00e01	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  00e09	0f 85 ed 00 00
	00		 jne	 $LN74@qeth_init_
  00e0f	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00e14	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  00e1c	0f 85 da 00 00
	00		 jne	 $LN74@qeth_init_

; 4127 :         {
; 4128 :             // "%1d:%04X %s: Required parameter '%s' missing"
; 4129 :             WRMSG( HHC00917, "E", LCSS_DEVNUM, dev->typname, "netmask" );

  00e22	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e2b	74 15		 je	 SHORT $LN132@qeth_init_
  00e2d	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e35	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e39	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv594[rsp], eax
  00e40	eb 0b		 jmp	 SHORT $LN133@qeth_init_
$LN132@qeth_init_:
  00e42	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv594[rsp], 0
$LN133@qeth_init_:
  00e4d	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e56	74 17		 je	 SHORT $LN134@qeth_init_
  00e58	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e60	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00e64	d1 f8		 sar	 eax, 1
  00e66	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv600[rsp], eax
  00e6d	eb 0b		 jmp	 SHORT $LN135@qeth_init_
$LN134@qeth_init_:
  00e6f	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv600[rsp], 0
$LN135@qeth_init_:
  00e7a	b9 01 00 00 00	 mov	 ecx, 1
  00e7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173759
  00e8c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00e91	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e99	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00e9d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ea2	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv594[rsp]
  00ea9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ead	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv600[rsp]
  00eb4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00eb8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173760
  00ebf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ec4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173761
  00ecb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ed0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ed5	41 b9 03 00 00
	00		 mov	 r9d, 3
  00edb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173762
  00ee2	ba 21 10 00 00	 mov	 edx, 4129		; 00001021H
  00ee7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173763
  00eee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4130 :             retcode = -1;

  00ef4	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1
$LN74@qeth_init_:

; 4131 :         }
; 4132 : #endif
; 4133 : 
; 4134 :         /* If no tuntap device was specified use the defined default */
; 4135 :         if (!grp->ttdev)

  00efc	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00f01	48 83 78 58 00	 cmp	 QWORD PTR [rax+88], 0
  00f06	75 18		 jne	 SHORT $LN75@qeth_init_

; 4136 :             grp->ttdev = strdup( DEF_NETDEV );

  00f08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_init_sysblk_netdev
  00f0e	48 8b c8	 mov	 rcx, rax
  00f11	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00f17	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00f1c	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
$LN75@qeth_init_:

; 4137 : 
; 4138 :         /* Check the grp->tthwaddr value */
; 4139 :         if (grp->tthwaddr)

  00f20	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00f25	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00f2a	0f 84 40 01 00
	00		 je	 $LN76@qeth_init_

; 4140 :         {
; 4141 :             if (ParseMAC( grp->tthwaddr, mac ) != 0 ||

  00f30	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR mac$17[rsp]
  00f38	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00f3d	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00f41	e8 00 00 00 00	 call	 ParseMAC
  00f46	85 c0		 test	 eax, eax
  00f48	75 22		 jne	 SHORT $LN78@qeth_init_
  00f4a	41 b8 06 00 00
	00		 mov	 r8d, 6
  00f50	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?zeromac@?CA@??qeth_init_handler@@9@9
  00f57	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR mac$17[rsp]
  00f5f	e8 00 00 00 00	 call	 memcmp
  00f64	85 c0		 test	 eax, eax
  00f66	0f 85 04 01 00
	00		 jne	 $LN77@qeth_init_
$LN78@qeth_init_:

; 4142 :                 memcmp( mac, zeromac, IFHWADDRLEN ) == 0)
; 4143 :             {
; 4144 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4145 :                 WRMSG(HHC00916, "E", LCSS_DEVNUM, dev->typname,

  00f6c	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f75	74 15		 je	 SHORT $LN136@qeth_init_
  00f77	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f7f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00f83	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv639[rsp], eax
  00f8a	eb 0b		 jmp	 SHORT $LN137@qeth_init_
$LN136@qeth_init_:
  00f8c	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv639[rsp], 0
$LN137@qeth_init_:
  00f97	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00fa0	74 17		 je	 SHORT $LN138@qeth_init_
  00fa2	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00faa	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00fae	d1 f8		 sar	 eax, 1
  00fb0	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv645[rsp], eax
  00fb7	eb 0b		 jmp	 SHORT $LN139@qeth_init_
$LN138@qeth_init_:
  00fb9	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv645[rsp], 0
$LN139@qeth_init_:
  00fc4	b9 01 00 00 00	 mov	 ecx, 1
  00fc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00fcf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00fd4	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00fd8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00fdd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173768
  00fe4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00fe9	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ff1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00ff5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ffa	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv639[rsp]
  01001	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01005	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv645[rsp]
  0100c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173769
  01017	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0101c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173770
  01023	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01028	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0102d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01033	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173771
  0103a	ba 32 10 00 00	 mov	 edx, 4146		; 00001032H
  0103f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173772
  01046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4146 :                                      "hwaddr", grp->tthwaddr );
; 4147 :                 retcode = -1;

  0104c	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4148 :                 free(grp->tthwaddr);

  01054	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01059	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0105d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4149 :                 grp->tthwaddr = NULL;

  01063	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01068	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
$LN77@qeth_init_:
$LN76@qeth_init_:

; 4150 :             }
; 4151 :         }
; 4152 : 
; 4153 :         /* Check the grp->ttipaddr and grp->ttpfxlen values */
; 4154 :         if (grp->ttipaddr)

  01070	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01075	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0107d	0f 84 08 02 00
	00		 je	 $LN79@qeth_init_

; 4155 :         {
; 4156 :             // Check whether a numeric IPv4 address has been specified.
; 4157 :             memset( &hrb, 0, sizeof(hrb) );

  01083	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR hrb$16[rsp]
  0108b	48 8b f8	 mov	 rdi, rax
  0108e	33 c0		 xor	 eax, eax
  01090	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  01095	f3 aa		 rep stosb

; 4158 :             hrb.wantafam = AF_INET;

  01097	c7 84 24 d8 02
	00 00 02 00 00
	00		 mov	 DWORD PTR hrb$16[rsp+360], 2

; 4159 :             hrb.numeric = TRUE;

  010a2	c7 84 24 d4 02
	00 00 01 00 00
	00		 mov	 DWORD PTR hrb$16[rsp+356], 1

; 4160 :             memcpy( hrb.host, grp->ttipaddr, strlen(grp->ttipaddr) );

  010ad	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  010b2	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  010b9	e8 00 00 00 00	 call	 strlen
  010be	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR hrb$16[rsp]
  010c6	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  010cb	48 8b f9	 mov	 rdi, rcx
  010ce	48 8b b2 80 00
	00 00		 mov	 rsi, QWORD PTR [rdx+128]
  010d5	48 8b c8	 mov	 rcx, rax
  010d8	f3 a4		 rep movsb

; 4161 :             work_rc = resolve_host( &hrb);

  010da	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR hrb$16[rsp]
  010e2	e8 00 00 00 00	 call	 resolve_host
  010e7	89 44 24 74	 mov	 DWORD PTR work_rc$2[rsp], eax

; 4162 :             if (work_rc == 0)

  010eb	83 7c 24 74 00	 cmp	 DWORD PTR work_rc$2[rsp], 0
  010f0	75 2a		 jne	 SHORT $LN80@qeth_init_

; 4163 :             {
; 4164 :                 hinet_pton( AF_INET, grp->ttipaddr, grp->confipaddr4 );

  010f2	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  010f7	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  010fd	4c 8b c0	 mov	 r8, rax
  01100	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01105	48 8b 90 80 00
	00 00		 mov	 rdx, QWORD PTR [rax+128]
  0110c	b9 02 00 00 00	 mov	 ecx, 2
  01111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_pton

; 4165 :             }

  01117	e9 6f 01 00 00	 jmp	 $LN81@qeth_init_
$LN80@qeth_init_:

; 4166 :             else
; 4167 :             {
; 4168 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4169 :                 WRMSG(HHC00916, "E", LCSS_DEVNUM, dev->typname,

  0111c	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01125	74 15		 je	 SHORT $LN140@qeth_init_
  01127	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0112f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01133	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv690[rsp], eax
  0113a	eb 0b		 jmp	 SHORT $LN141@qeth_init_
$LN140@qeth_init_:
  0113c	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv690[rsp], 0
$LN141@qeth_init_:
  01147	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01150	74 17		 je	 SHORT $LN142@qeth_init_
  01152	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0115a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0115e	d1 f8		 sar	 eax, 1
  01160	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv696[rsp], eax
  01167	eb 0b		 jmp	 SHORT $LN143@qeth_init_
$LN142@qeth_init_:
  01169	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv696[rsp], 0
$LN143@qeth_init_:
  01174	b9 01 00 00 00	 mov	 ecx, 1
  01179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0117f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01184	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0118b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01190	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173776
  01197	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0119c	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011a4	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  011a8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  011ad	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv690[rsp]
  011b4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011b8	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv696[rsp]
  011bf	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  011c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173777
  011ca	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  011cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173778
  011d6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  011db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  011e0	41 b9 03 00 00
	00		 mov	 r9d, 3
  011e6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173779
  011ed	ba 4a 10 00 00	 mov	 edx, 4170		; 0000104aH
  011f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173780
  011f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4170 :                                      "ipaddr", grp->ttipaddr );
; 4171 :                 retcode = -1;

  011ff	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4172 :                 free(grp->ttipaddr);

  01207	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0120c	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  01213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4173 :                 grp->ttipaddr = NULL;

  01219	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0121e	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 4174 :                 if(grp->ttpfxlen)

  01229	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0122e	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  01236	74 22		 je	 SHORT $LN82@qeth_init_

; 4175 :                 {
; 4176 :                     free(grp->ttpfxlen);

  01238	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0123d	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  01244	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4177 :                     grp->ttpfxlen = NULL;

  0124a	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0124f	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0
$LN82@qeth_init_:

; 4178 :                 }
; 4179 :                 if(grp->ttnetmask)

  0125a	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0125f	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  01267	74 22		 je	 SHORT $LN83@qeth_init_

; 4180 :                 {
; 4181 :                     free(grp->ttnetmask);

  01269	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0126e	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  01275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4182 :                     grp->ttnetmask = NULL;

  0127b	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01280	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0
$LN83@qeth_init_:
$LN81@qeth_init_:
$LN79@qeth_init_:

; 4183 :                 }
; 4184 :             }
; 4185 :         }
; 4186 : 
; 4187 : #if defined( OPTION_W32_CTCI )
; 4188 :         if (!grp->ttnetmask && !grp->ttpfxlen)

  0128b	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01290	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  01298	75 41		 jne	 SHORT $LN84@qeth_init_
  0129a	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0129f	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  012a7	75 32		 jne	 SHORT $LN84@qeth_init_

; 4189 :         {
; 4190 :             grp->ttnetmask = strdup("255.255.255.255");

  012a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173784
  012b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  012b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  012bb	48 89 81 90 00
	00 00		 mov	 QWORD PTR [rcx+144], rax

; 4191 :             grp->ttpfxlen = strdup("32");

  012c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173785
  012c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  012cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  012d4	48 89 81 88 00
	00 00		 mov	 QWORD PTR [rcx+136], rax
$LN84@qeth_init_:

; 4192 :         }
; 4193 : #endif
; 4194 : 
; 4195 :         if (grp->ttnetmask)

  012db	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  012e0	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  012e8	0f 84 ce 02 00
	00		 je	 $LN85@qeth_init_

; 4196 :         {
; 4197 :             char *new_ttpfxlen = NULL;

  012ee	48 c7 84 24 38
	01 00 00 00 00
	00 00		 mov	 QWORD PTR new_ttpfxlen$11[rsp], 0

; 4198 :             /* Build new prefix length based on netmask */
; 4199 :             if (netmask2prefix( grp->ttnetmask, &new_ttpfxlen ) != 0)

  012fa	48 8d 94 24 38
	01 00 00	 lea	 rdx, QWORD PTR new_ttpfxlen$11[rsp]
  01302	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01307	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  0130e	e8 00 00 00 00	 call	 netmask2prefix
  01313	85 c0		 test	 eax, eax
  01315	0f 84 56 01 00
	00		 je	 $LN86@qeth_init_

; 4200 :             {
; 4201 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4202 :                 WRMSG(HHC00916, "E", LCSS_DEVNUM, dev->typname,

  0131b	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01324	74 15		 je	 SHORT $LN144@qeth_init_
  01326	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0132e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01332	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv777[rsp], eax
  01339	eb 0b		 jmp	 SHORT $LN145@qeth_init_
$LN144@qeth_init_:
  0133b	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv777[rsp], 0
$LN145@qeth_init_:
  01346	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0134f	74 17		 je	 SHORT $LN146@qeth_init_
  01351	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01359	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0135d	d1 f8		 sar	 eax, 1
  0135f	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv783[rsp], eax
  01366	eb 0b		 jmp	 SHORT $LN147@qeth_init_
$LN146@qeth_init_:
  01368	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv783[rsp], 0
$LN147@qeth_init_:
  01373	b9 01 00 00 00	 mov	 ecx, 1
  01378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0137e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01383	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  0138a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0138f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173789
  01396	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0139b	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013a3	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  013a7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  013ac	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv777[rsp]
  013b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  013b7	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv783[rsp]
  013be	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  013c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173790
  013c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  013ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173791
  013d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  013da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  013df	41 b9 03 00 00
	00		 mov	 r9d, 3
  013e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173792
  013ec	ba 6b 10 00 00	 mov	 edx, 4203		; 0000106bH
  013f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173793
  013f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4203 :                                      "netmask", grp->ttnetmask );
; 4204 :                 retcode = -1;

  013fe	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4205 :                 free( grp->ttnetmask );

  01406	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0140b	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  01412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4206 :                 free( grp->ttipaddr  );

  01418	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0141d	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  01424	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4207 :                 free( grp->ttpfxlen  );

  0142a	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0142f	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  01436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4208 :                 grp->ttnetmask = NULL;

  0143c	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01441	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 4209 :                 grp->ttipaddr  = NULL;

  0144c	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01451	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 4210 :                 grp->ttpfxlen  = NULL;

  0145c	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01461	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 4211 :             }

  0146c	e9 4b 01 00 00	 jmp	 $LN87@qeth_init_
$LN86@qeth_init_:

; 4212 :             else if (grp->ttpfxlen)

  01471	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01476	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0147e	0f 84 38 01 00
	00		 je	 $LN88@qeth_init_

; 4213 :             {
; 4214 :                 /* Check netmask value (via newly built prefix)
; 4215 :                    for consistency with existing prefix length */
; 4216 :                 if (grp->ttpfxlen &&

  01484	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01489	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  01491	0f 84 ff 00 00
	00		 je	 $LN89@qeth_init_
  01497	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0149c	48 8b 90 88 00
	00 00		 mov	 rdx, QWORD PTR [rax+136]
  014a3	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR new_ttpfxlen$11[rsp]
  014ab	e8 00 00 00 00	 call	 strcmp
  014b0	85 c0		 test	 eax, eax
  014b2	0f 84 de 00 00
	00		 je	 $LN89@qeth_init_

; 4217 :                     strcmp( new_ttpfxlen, grp->ttpfxlen ) != 0)
; 4218 :                 {
; 4219 :                     // HHC03998 "%1d:%04X %s: %s inconsistent with %s"
; 4220 :                     WRMSG(HHC03998, "W", LCSS_DEVNUM, dev->typname,

  014b8	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  014c1	74 15		 je	 SHORT $LN148@qeth_init_
  014c3	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014cb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  014cf	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv819[rsp], eax
  014d6	eb 0b		 jmp	 SHORT $LN149@qeth_init_
$LN148@qeth_init_:
  014d8	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv819[rsp], 0
$LN149@qeth_init_:
  014e3	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  014ec	74 17		 je	 SHORT $LN150@qeth_init_
  014ee	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014f6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  014fa	d1 f8		 sar	 eax, 1
  014fc	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv825[rsp], eax
  01503	eb 0b		 jmp	 SHORT $LN151@qeth_init_
$LN150@qeth_init_:
  01505	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv825[rsp], 0
$LN151@qeth_init_:
  01510	b9 01 00 00 00	 mov	 ecx, 1
  01515	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0151b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173796
  01522	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01527	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173797
  0152e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01533	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0153b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0153f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01544	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv819[rsp]
  0154b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0154f	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv825[rsp]
  01556	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0155a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173798
  01561	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01566	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173799
  0156d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01572	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01577	41 b9 03 00 00
	00		 mov	 r9d, 3
  0157d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173800
  01584	ba 7d 10 00 00	 mov	 edx, 4221		; 0000107dH
  01589	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173801
  01590	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN89@qeth_init_:

; 4221 :                         "prefix length", "netmask" );
; 4222 :                 }
; 4223 :                 /* Use consistent prefix length */
; 4224 :                 free( grp->ttpfxlen );

  01596	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0159b	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  015a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4225 :                 grp->ttpfxlen = new_ttpfxlen;

  015a8	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  015ad	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR new_ttpfxlen$11[rsp]
  015b5	48 89 88 88 00
	00 00		 mov	 QWORD PTR [rax+136], rcx
$LN88@qeth_init_:
$LN87@qeth_init_:
$LN85@qeth_init_:

; 4226 :             }
; 4227 :         }
; 4228 :         if (grp->ttpfxlen)

  015bc	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  015c1	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  015c9	0f 84 ce 02 00
	00		 je	 $LN90@qeth_init_

; 4229 :         {
; 4230 :             char *new_ttnetmask = NULL;

  015cf	48 c7 84 24 40
	01 00 00 00 00
	00 00		 mov	 QWORD PTR new_ttnetmask$12[rsp], 0

; 4231 :             /* Build new netmask based on prefix length */
; 4232 :             if (prefix2netmask( grp->ttpfxlen, &new_ttnetmask ) != 0)

  015db	48 8d 94 24 40
	01 00 00	 lea	 rdx, QWORD PTR new_ttnetmask$12[rsp]
  015e3	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  015e8	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  015ef	e8 00 00 00 00	 call	 prefix2netmask
  015f4	85 c0		 test	 eax, eax
  015f6	0f 84 56 01 00
	00		 je	 $LN91@qeth_init_

; 4233 :             {
; 4234 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4235 :                 WRMSG(HHC00916, "E", LCSS_DEVNUM, dev->typname,

  015fc	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01605	74 15		 je	 SHORT $LN152@qeth_init_
  01607	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0160f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01613	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv854[rsp], eax
  0161a	eb 0b		 jmp	 SHORT $LN153@qeth_init_
$LN152@qeth_init_:
  0161c	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv854[rsp], 0
$LN153@qeth_init_:
  01627	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01630	74 17		 je	 SHORT $LN154@qeth_init_
  01632	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0163a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0163e	d1 f8		 sar	 eax, 1
  01640	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv860[rsp], eax
  01647	eb 0b		 jmp	 SHORT $LN155@qeth_init_
$LN154@qeth_init_:
  01649	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv860[rsp], 0
$LN155@qeth_init_:
  01654	b9 01 00 00 00	 mov	 ecx, 1
  01659	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0165f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01664	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0166b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01670	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173805
  01677	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0167c	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01684	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01688	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0168d	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv854[rsp]
  01694	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01698	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv860[rsp]
  0169f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  016a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173806
  016aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  016af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173807
  016b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  016bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  016c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173808
  016cd	ba 8c 10 00 00	 mov	 edx, 4236		; 0000108cH
  016d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173809
  016d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4236 :                                      "ipaddr", grp->ttipaddr );
; 4237 :                 retcode = -1;

  016df	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4238 :                 free( grp->ttpfxlen  );

  016e7	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  016ec	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  016f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4239 :                 free( grp->ttipaddr  );

  016f9	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  016fe	48 8b 88 80 00
	00 00		 mov	 rcx, QWORD PTR [rax+128]
  01705	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4240 :                 free( grp->ttnetmask );

  0170b	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01710	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  01717	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4241 :                 grp->ttpfxlen  = NULL;

  0171d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01722	48 c7 80 88 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+136], 0

; 4242 :                 grp->ttipaddr  = NULL;

  0172d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01732	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 4243 :                 grp->ttnetmask = NULL;

  0173d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01742	48 c7 80 90 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+144], 0

; 4244 :             }

  0174d	e9 4b 01 00 00	 jmp	 $LN92@qeth_init_
$LN91@qeth_init_:

; 4245 :             else if (grp->ttnetmask)

  01752	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01757	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0175f	0f 84 38 01 00
	00		 je	 $LN93@qeth_init_

; 4246 :             {
; 4247 :                 /* Check prefix length (via newly built netmask)
; 4248 :                    for consistency with existing netmask value */
; 4249 :                 if (grp->ttnetmask &&

  01765	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0176a	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  01772	0f 84 ff 00 00
	00		 je	 $LN94@qeth_init_
  01778	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0177d	48 8b 90 90 00
	00 00		 mov	 rdx, QWORD PTR [rax+144]
  01784	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR new_ttnetmask$12[rsp]
  0178c	e8 00 00 00 00	 call	 strcmp
  01791	85 c0		 test	 eax, eax
  01793	0f 84 de 00 00
	00		 je	 $LN94@qeth_init_

; 4250 :                     strcmp( new_ttnetmask, grp->ttnetmask ) != 0)
; 4251 :                 {
; 4252 :                     // HHC03998 "%1d:%04X %s: %s inconsistent with %s"
; 4253 :                     WRMSG(HHC03998, "W", LCSS_DEVNUM, dev->typname,

  01799	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  017a2	74 15		 je	 SHORT $LN156@qeth_init_
  017a4	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017ac	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  017b0	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv896[rsp], eax
  017b7	eb 0b		 jmp	 SHORT $LN157@qeth_init_
$LN156@qeth_init_:
  017b9	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv896[rsp], 0
$LN157@qeth_init_:
  017c4	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  017cd	74 17		 je	 SHORT $LN158@qeth_init_
  017cf	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017d7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  017db	d1 f8		 sar	 eax, 1
  017dd	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv902[rsp], eax
  017e4	eb 0b		 jmp	 SHORT $LN159@qeth_init_
$LN158@qeth_init_:
  017e6	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv902[rsp], 0
$LN159@qeth_init_:
  017f1	b9 01 00 00 00	 mov	 ecx, 1
  017f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  017fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173812
  01803	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01808	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173813
  0180f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01814	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0181c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01820	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01825	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv896[rsp]
  0182c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01830	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv902[rsp]
  01837	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0183b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173814
  01842	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01847	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173815
  0184e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01853	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01858	41 b9 03 00 00
	00		 mov	 r9d, 3
  0185e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173816
  01865	ba 9e 10 00 00	 mov	 edx, 4254		; 0000109eH
  0186a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173817
  01871	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN94@qeth_init_:

; 4254 :                         "netmask", "prefix length" );
; 4255 :                 }
; 4256 :                 /* Use consistent netmask */
; 4257 :                 free( grp->ttnetmask );

  01877	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0187c	48 8b 88 90 00
	00 00		 mov	 rcx, QWORD PTR [rax+144]
  01883	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4258 :                 grp->ttnetmask = new_ttnetmask;

  01889	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0188e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR new_ttnetmask$12[rsp]
  01896	48 89 88 90 00
	00 00		 mov	 QWORD PTR [rax+144], rcx
$LN93@qeth_init_:
$LN92@qeth_init_:
$LN90@qeth_init_:

; 4259 :             }
; 4260 :         }
; 4261 : 
; 4262 : #if defined( ENABLE_IPV6 )
; 4263 :         /* Check the grp->ttipaddr6 and grp->ttpfxlen6 values */
; 4264 :         if (grp->ttipaddr6)

  0189d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  018a2	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  018aa	0f 84 c8 01 00
	00		 je	 $LN95@qeth_init_

; 4265 :         {
; 4266 :             // Check whether a numeric IPv6 address has been specified.
; 4267 :             memset( &hrb, 0, sizeof(hrb) );

  018b0	48 8d 84 24 70
	01 00 00	 lea	 rax, QWORD PTR hrb$16[rsp]
  018b8	48 8b f8	 mov	 rdi, rax
  018bb	33 c0		 xor	 eax, eax
  018bd	b9 c0 01 00 00	 mov	 ecx, 448		; 000001c0H
  018c2	f3 aa		 rep stosb

; 4268 :             hrb.wantafam = AF_INET6;

  018c4	c7 84 24 d8 02
	00 00 17 00 00
	00		 mov	 DWORD PTR hrb$16[rsp+360], 23

; 4269 :             hrb.numeric = TRUE;

  018cf	c7 84 24 d4 02
	00 00 01 00 00
	00		 mov	 DWORD PTR hrb$16[rsp+356], 1

; 4270 :             memcpy( hrb.host, grp->ttipaddr6, strlen(grp->ttipaddr6) );

  018da	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  018df	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  018e6	e8 00 00 00 00	 call	 strlen
  018eb	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR hrb$16[rsp]
  018f3	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  018f8	48 8b f9	 mov	 rdi, rcx
  018fb	48 8b b2 98 00
	00 00		 mov	 rsi, QWORD PTR [rdx+152]
  01902	48 8b c8	 mov	 rcx, rax
  01905	f3 a4		 rep movsb

; 4271 :             work_rc = resolve_host( &hrb);

  01907	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR hrb$16[rsp]
  0190f	e8 00 00 00 00	 call	 resolve_host
  01914	89 44 24 74	 mov	 DWORD PTR work_rc$2[rsp], eax

; 4272 :             if (work_rc == 0)

  01918	83 7c 24 74 00	 cmp	 DWORD PTR work_rc$2[rsp], 0
  0191d	75 2a		 jne	 SHORT $LN96@qeth_init_

; 4273 :             {
; 4274 :                 hinet_pton( AF_INET6, grp->ttipaddr6, grp->confipaddr6 );

  0191f	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01924	48 05 b8 00 00
	00		 add	 rax, 184		; 000000b8H
  0192a	4c 8b c0	 mov	 r8, rax
  0192d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01932	48 8b 90 98 00
	00 00		 mov	 rdx, QWORD PTR [rax+152]
  01939	b9 17 00 00 00	 mov	 ecx, 23
  0193e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_pton

; 4275 :             }

  01944	e9 2f 01 00 00	 jmp	 $LN97@qeth_init_
$LN96@qeth_init_:

; 4276 :             else
; 4277 :             {
; 4278 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4279 :                 WRMSG(HHC00916, "E", LCSS_DEVNUM, dev->typname,

  01949	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01952	74 15		 je	 SHORT $LN160@qeth_init_
  01954	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0195c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01960	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv947[rsp], eax
  01967	eb 0b		 jmp	 SHORT $LN161@qeth_init_
$LN160@qeth_init_:
  01969	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv947[rsp], 0
$LN161@qeth_init_:
  01974	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0197d	74 17		 je	 SHORT $LN162@qeth_init_
  0197f	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01987	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0198b	d1 f8		 sar	 eax, 1
  0198d	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv953[rsp], eax
  01994	eb 0b		 jmp	 SHORT $LN163@qeth_init_
$LN162@qeth_init_:
  01996	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv953[rsp], 0
$LN163@qeth_init_:
  019a1	b9 01 00 00 00	 mov	 ecx, 1
  019a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  019ac	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  019b1	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  019b8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  019bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173821
  019c4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  019c9	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  019d1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  019d5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  019da	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv947[rsp]
  019e1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  019e5	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv953[rsp]
  019ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  019f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173822
  019f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  019fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173823
  01a03	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01a08	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01a0d	41 b9 03 00 00
	00		 mov	 r9d, 3
  01a13	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173824
  01a1a	ba b8 10 00 00	 mov	 edx, 4280		; 000010b8H
  01a1f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173825
  01a26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4280 :                                      "ipaddr6", grp->ttipaddr6 );
; 4281 :                 retcode = -1;

  01a2c	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4282 :                 free( grp->ttipaddr6 );

  01a34	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01a39	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  01a40	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4283 :                 free( grp->ttpfxlen6 );

  01a46	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01a4b	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  01a52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4284 :                 grp->ttipaddr6 = NULL;

  01a58	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01a5d	48 c7 80 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+152], 0

; 4285 :                 grp->ttpfxlen6 = NULL;

  01a68	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01a6d	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0
$LN97@qeth_init_:
$LN95@qeth_init_:

; 4286 :             }
; 4287 :         }
; 4288 :         if (grp->ttpfxlen6)

  01a78	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01a7d	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  01a85	0f 84 d7 01 00
	00		 je	 $LN98@qeth_init_

; 4289 :         {
; 4290 :             // Check whether a numeric prefix in the range 1 to 128 has been specified.
; 4291 :             work_rc = 0;

  01a8b	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR work_rc$2[rsp], 0

; 4292 :             for (p = grp->ttpfxlen6; isdigit(*p); p++) { }

  01a93	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01a98	48 8b 80 a0 00
	00 00		 mov	 rax, QWORD PTR [rax+160]
  01a9f	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR p$7[rsp], rax
  01aa7	eb 13		 jmp	 SHORT $LN25@qeth_init_
$LN23@qeth_init_:
  01aa9	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  01ab1	48 ff c0	 inc	 rax
  01ab4	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR p$7[rsp], rax
$LN25@qeth_init_:
  01abc	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  01ac4	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01ac7	8b c8		 mov	 ecx, eax
  01ac9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  01acf	85 c0		 test	 eax, eax
  01ad1	74 02		 je	 SHORT $LN24@qeth_init_
  01ad3	eb d4		 jmp	 SHORT $LN23@qeth_init_
$LN24@qeth_init_:

; 4293 :             if (*p != '\0' || !strlen(grp->ttpfxlen6))

  01ad5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR p$7[rsp]
  01add	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01ae0	85 c0		 test	 eax, eax
  01ae2	75 16		 jne	 SHORT $LN100@qeth_init_
  01ae4	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01ae9	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  01af0	e8 00 00 00 00	 call	 strlen
  01af5	48 85 c0	 test	 rax, rax
  01af8	75 08		 jne	 SHORT $LN99@qeth_init_
$LN100@qeth_init_:

; 4294 :                 work_rc = -1;

  01afa	c7 44 24 74 ff
	ff ff ff	 mov	 DWORD PTR work_rc$2[rsp], -1
$LN99@qeth_init_:

; 4295 :             pfxlen = atoi(grp->ttpfxlen6);

  01b02	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01b07	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  01b0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01b14	89 84 24 18 01
	00 00		 mov	 DWORD PTR pfxlen$8[rsp], eax

; 4296 :             if (work_rc != 0 || pfxlen > 128 )

  01b1b	83 7c 24 74 00	 cmp	 DWORD PTR work_rc$2[rsp], 0
  01b20	75 11		 jne	 SHORT $LN102@qeth_init_
  01b22	81 bc 24 18 01
	00 00 80 00 00
	00		 cmp	 DWORD PTR pfxlen$8[rsp], 128 ; 00000080H
  01b2d	0f 8e 2f 01 00
	00		 jle	 $LN101@qeth_init_
$LN102@qeth_init_:

; 4297 :             {
; 4298 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4299 :                 WRMSG(HHC00916, "E", LCSS_DEVNUM, dev->typname,

  01b33	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01b3c	74 15		 je	 SHORT $LN164@qeth_init_
  01b3e	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b46	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01b4a	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv1061[rsp], eax
  01b51	eb 0b		 jmp	 SHORT $LN165@qeth_init_
$LN164@qeth_init_:
  01b53	c7 84 24 f0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1061[rsp], 0
$LN165@qeth_init_:
  01b5e	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01b67	74 17		 je	 SHORT $LN166@qeth_init_
  01b69	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01b71	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01b75	d1 f8		 sar	 eax, 1
  01b77	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv1067[rsp], eax
  01b7e	eb 0b		 jmp	 SHORT $LN167@qeth_init_
$LN166@qeth_init_:
  01b80	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1067[rsp], 0
$LN167@qeth_init_:
  01b8b	b9 01 00 00 00	 mov	 ecx, 1
  01b90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01b96	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01b9b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  01ba2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01ba7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173831
  01bae	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01bb3	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01bbb	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01bbf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01bc4	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv1061[rsp]
  01bcb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01bcf	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv1067[rsp]
  01bd6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01bda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173832
  01be1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01be6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173833
  01bed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bf2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01bf7	41 b9 03 00 00
	00		 mov	 r9d, 3
  01bfd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173834
  01c04	ba cc 10 00 00	 mov	 edx, 4300		; 000010ccH
  01c09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173835
  01c10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4300 :                                      "ipaddr6", grp->ttpfxlen6 );
; 4301 :                 retcode = -1;

  01c16	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4302 :                 free( grp->ttpfxlen6 );

  01c1e	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01c23	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  01c2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4303 :                 free( grp->ttipaddr6 );

  01c30	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01c35	48 8b 88 98 00
	00 00		 mov	 rcx, QWORD PTR [rax+152]
  01c3c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4304 :                 grp->ttpfxlen6 = NULL;

  01c42	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01c47	48 c7 80 a0 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+160], 0

; 4305 :                 grp->ttipaddr6 = NULL;

  01c52	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01c57	48 c7 80 98 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+152], 0
$LN101@qeth_init_:
$LN98@qeth_init_:

; 4306 :             }
; 4307 :         }
; 4308 : #endif /* defined( ENABLE_IPV6 ) */
; 4309 : 
; 4310 :         /* Check the MTU value */
; 4311 :         if (grp->ttmtu)

  01c62	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01c67	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  01c6c	0f 84 26 01 00
	00		 je	 $LN103@qeth_init_

; 4312 :         {
; 4313 :             U16 uMTU = (U16) atoi( grp->ttmtu );

  01c72	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01c77	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  01c7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01c81	66 89 44 24 7c	 mov	 WORD PTR uMTU$4[rsp], ax

; 4314 :             if (uMTU < QETH_MIN_MTU)

  01c86	0f b7 44 24 7c	 movzx	 eax, WORD PTR uMTU$4[rsp]
  01c8b	83 f8 3c	 cmp	 eax, 60			; 0000003cH
  01c8e	0f 8d 04 01 00
	00		 jge	 $LN104@qeth_init_

; 4315 :             {
; 4316 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4317 :                 WRMSG( HHC00916, "E", LCSS_DEVNUM,

  01c94	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01c9d	74 15		 je	 SHORT $LN168@qeth_init_
  01c9f	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ca7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01cab	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv1100[rsp], eax
  01cb2	eb 0b		 jmp	 SHORT $LN169@qeth_init_
$LN168@qeth_init_:
  01cb4	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1100[rsp], 0
$LN169@qeth_init_:
  01cbf	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01cc8	74 17		 je	 SHORT $LN170@qeth_init_
  01cca	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01cd2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01cd6	d1 f8		 sar	 eax, 1
  01cd8	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv1106[rsp], eax
  01cdf	eb 0b		 jmp	 SHORT $LN171@qeth_init_
$LN170@qeth_init_:
  01ce1	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1106[rsp], 0
$LN171@qeth_init_:
  01cec	b9 01 00 00 00	 mov	 ecx, 1
  01cf1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01cf7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01cfc	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  01d00	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01d05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173838
  01d0c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01d11	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01d19	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01d1d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01d22	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv1100[rsp]
  01d29	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01d2d	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv1106[rsp]
  01d34	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01d38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173839
  01d3f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01d44	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173840
  01d4b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d50	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d55	41 b9 03 00 00
	00		 mov	 r9d, 3
  01d5b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173841
  01d62	ba de 10 00 00	 mov	 edx, 4318		; 000010deH
  01d67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173842
  01d6e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4318 :                     dev->typname, "mtu", grp->ttmtu );
; 4319 :                 retcode = -1;

  01d74	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4320 :                 free( grp->ttmtu );

  01d7c	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01d81	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  01d85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4321 :                 grp->ttmtu = NULL;

  01d8b	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01d90	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0
$LN104@qeth_init_:
$LN103@qeth_init_:

; 4322 :             }
; 4323 :         }
; 4324 : 
; 4325 :         /* Check the grp->ttchpid value */
; 4326 :         if (grp->ttchpid)

  01d98	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01d9d	48 83 b8 a8 00
	00 00 00	 cmp	 QWORD PTR [rax+168], 0
  01da5	0f 84 ac 01 00
	00		 je	 $LN105@qeth_init_

; 4327 :         {
; 4328 :             if(sscanf(grp->ttchpid, "%x%c", &chpid, &c) != 1 || chpid < 0x00 || chpid > 0xFF)

  01dab	4c 8d 4c 24 78	 lea	 r9, QWORD PTR c$3[rsp]
  01db0	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR chpid$6[rsp]
  01db8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173847
  01dbf	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01dc4	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  01dcb	e8 00 00 00 00	 call	 sscanf
  01dd0	83 f8 01	 cmp	 eax, 1
  01dd3	75 1b		 jne	 SHORT $LN108@qeth_init_
  01dd5	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR chpid$6[rsp], 0
  01ddd	7c 11		 jl	 SHORT $LN108@qeth_init_
  01ddf	81 bc 24 88 00
	00 00 ff 00 00
	00		 cmp	 DWORD PTR chpid$6[rsp], 255 ; 000000ffH
  01dea	0f 8e 0f 01 00
	00		 jle	 $LN106@qeth_init_
$LN108@qeth_init_:

; 4329 :             {
; 4330 :                 // HHC00916 "%1d:%04X %s: option %s value %s invalid"
; 4331 :                 WRMSG(HHC00916, "E", LCSS_DEVNUM, dev->typname,

  01df0	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01df9	74 15		 je	 SHORT $LN172@qeth_init_
  01dfb	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e03	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01e07	89 84 24 00 01
	00 00		 mov	 DWORD PTR tv1139[rsp], eax
  01e0e	eb 0b		 jmp	 SHORT $LN173@qeth_init_
$LN172@qeth_init_:
  01e10	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1139[rsp], 0
$LN173@qeth_init_:
  01e1b	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01e24	74 17		 je	 SHORT $LN174@qeth_init_
  01e26	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01e2e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01e32	d1 f8		 sar	 eax, 1
  01e34	89 84 24 04 01
	00 00		 mov	 DWORD PTR tv1145[rsp], eax
  01e3b	eb 0b		 jmp	 SHORT $LN175@qeth_init_
$LN174@qeth_init_:
  01e3d	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1145[rsp], 0
$LN175@qeth_init_:
  01e48	b9 01 00 00 00	 mov	 ecx, 1
  01e4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e53	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01e58	48 8b 89 a8 00
	00 00		 mov	 rcx, QWORD PTR [rcx+168]
  01e5f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01e64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173848
  01e6b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01e70	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01e78	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  01e7c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01e81	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR tv1139[rsp]
  01e88	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01e8c	8b 8c 24 04 01
	00 00		 mov	 ecx, DWORD PTR tv1145[rsp]
  01e93	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01e97	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173849
  01e9e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01ea3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173850
  01eaa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01eaf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01eb4	41 b9 03 00 00
	00		 mov	 r9d, 3
  01eba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173851
  01ec1	ba ec 10 00 00	 mov	 edx, 4332		; 000010ecH
  01ec6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173852
  01ecd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 4332 :                                      "chpid", grp->ttchpid );
; 4333 :                 retcode = -1;

  01ed3	c7 44 24 6c ff
	ff ff ff	 mov	 DWORD PTR retcode$[rsp], -1

; 4334 :                 free(grp->ttchpid);

  01edb	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01ee0	48 8b 88 a8 00
	00 00		 mov	 rcx, QWORD PTR [rax+168]
  01ee7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4335 :                 grp->ttchpid = NULL;

  01eed	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01ef2	48 c7 80 a8 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+168], 0

; 4336 :             }

  01efd	eb 58		 jmp	 SHORT $LN107@qeth_init_
$LN106@qeth_init_:

; 4337 :             else
; 4338 :             {
; 4339 :                 for (i = 0; i < dev->group->members; i++)

  01eff	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  01f07	eb 0a		 jmp	 SHORT $LN28@qeth_init_
$LN26@qeth_init_:
  01f09	8b 44 24 70	 mov	 eax, DWORD PTR i$1[rsp]
  01f0d	ff c0		 inc	 eax
  01f0f	89 44 24 70	 mov	 DWORD PTR i$1[rsp], eax
$LN28@qeth_init_:
  01f13	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f1b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01f1f	8b 00		 mov	 eax, DWORD PTR [rax]
  01f21	39 44 24 70	 cmp	 DWORD PTR i$1[rsp], eax
  01f25	7d 30		 jge	 SHORT $LN27@qeth_init_

; 4340 :                 {
; 4341 :                     dev->group->memdev[i]->pmcw.chpid[0] = chpid;

  01f27	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f2f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01f33	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01f38	48 8b 44 c8 10	 mov	 rax, QWORD PTR [rax+rcx*8+16]
  01f3d	b9 01 00 00 00	 mov	 ecx, 1
  01f42	48 6b c9 00	 imul	 rcx, rcx, 0
  01f46	0f b6 94 24 88
	00 00 00	 movzx	 edx, BYTE PTR chpid$6[rsp]
  01f4e	88 94 08 fc 02
	00 00		 mov	 BYTE PTR [rax+rcx+764], dl

; 4342 :                 }

  01f55	eb b2		 jmp	 SHORT $LN26@qeth_init_
$LN27@qeth_init_:
$LN107@qeth_init_:
$LN105@qeth_init_:

; 4343 :             }
; 4344 :         }
; 4345 : 
; 4346 :         /* Initialize each device's Full Link Address array */
; 4347 :         cua = dev->group->memdev[0];

  01f57	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f5f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01f63	b9 08 00 00 00	 mov	 ecx, 8
  01f68	48 6b c9 00	 imul	 rcx, rcx, 0
  01f6c	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  01f71	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR cua$15[rsp], rax

; 4348 :         destlink = 0x000D; // ZZ FIXME: where should this come from?

  01f79	b8 0d 00 00 00	 mov	 eax, 13
  01f7e	66 89 84 24 80
	00 00 00	 mov	 WORD PTR destlink$5[rsp], ax

; 4349 :         for(i = 0; i < dev->group->members; i++) {

  01f86	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  01f8e	eb 0a		 jmp	 SHORT $LN31@qeth_init_
$LN29@qeth_init_:
  01f90	8b 44 24 70	 mov	 eax, DWORD PTR i$1[rsp]
  01f94	ff c0		 inc	 eax
  01f96	89 44 24 70	 mov	 DWORD PTR i$1[rsp], eax
$LN31@qeth_init_:
  01f9a	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01fa2	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01fa6	8b 00		 mov	 eax, DWORD PTR [rax]
  01fa8	39 44 24 70	 cmp	 DWORD PTR i$1[rsp], eax
  01fac	7d 48		 jge	 SHORT $LN30@qeth_init_

; 4350 :             dev->group->memdev[i]->fla[0] =

  01fae	0f b7 84 24 80
	00 00 00	 movzx	 eax, WORD PTR destlink$5[rsp]
  01fb6	c1 e0 08	 shl	 eax, 8
  01fb9	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR cua$15[rsp]
  01fc1	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  01fc5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01fcb	0b c1		 or	 eax, ecx
  01fcd	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01fd5	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  01fd9	48 63 54 24 70	 movsxd	 rdx, DWORD PTR i$1[rsp]
  01fde	48 8b 4c d1 10	 mov	 rcx, QWORD PTR [rcx+rdx*8+16]
  01fe3	ba 02 00 00 00	 mov	 edx, 2
  01fe8	48 6b d2 00	 imul	 rdx, rdx, 0
  01fec	66 89 84 11 bc
	05 00 00	 mov	 WORD PTR [rcx+rdx+1468], ax

; 4351 :                 (destlink << 8) | (cua->devnum & 0x00FF);
; 4352 :         }

  01ff4	eb 9a		 jmp	 SHORT $LN29@qeth_init_
$LN30@qeth_init_:

; 4353 : 
; 4354 :         /* Initialize mask fields */
; 4355 :         if(grp->ttpfxlen) {

  01ff6	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01ffb	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  02003	74 37		 je	 SHORT $LN109@qeth_init_

; 4356 :             mask4 = makepfxmask4( grp->ttpfxlen );

  02005	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0200a	48 8b 88 88 00
	00 00		 mov	 rcx, QWORD PTR [rax+136]
  02011	e8 00 00 00 00	 call	 makepfxmask4
  02016	89 84 24 1c 01
	00 00		 mov	 DWORD PTR mask4$[rsp], eax

; 4357 :             STORE_FW( grp->confpfxmask4, mask4 );

  0201d	8b 8c 24 1c 01
	00 00		 mov	 ecx, DWORD PTR mask4$[rsp]
  02024	e8 00 00 00 00	 call	 _byteswap_ulong
  02029	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0202e	48 81 c1 b4 00
	00 00		 add	 rcx, 180		; 000000b4H
  02035	8b d0		 mov	 edx, eax
  02037	e8 00 00 00 00	 call	 store_fw_noswap
$LN109@qeth_init_:

; 4358 :         }
; 4359 :         if(grp->ttpfxlen6)

  0203c	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  02041	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  02049	74 1f		 je	 SHORT $LN110@qeth_init_

; 4360 :             makepfxmask6( grp->ttpfxlen6, grp->confpfxmask6 );

  0204b	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  02050	48 05 c8 00 00
	00		 add	 rax, 200		; 000000c8H
  02056	48 8b d0	 mov	 rdx, rax
  02059	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0205e	48 8b 88 a0 00
	00 00		 mov	 rcx, QWORD PTR [rax+160]
  02065	e8 00 00 00 00	 call	 makepfxmask6
$LN110@qeth_init_:
$LN72@qeth_init_:

; 4361 :     }
; 4362 : 
; 4363 :     return retcode;

  0206a	8b 44 24 6c	 mov	 eax, DWORD PTR retcode$[rsp]

; 4364 : 
; 4365 : } /* end function qeth_init_handler */

  0206e	48 8b 8c 24 58
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  02076	48 33 cc	 xor	 rcx, rsp
  02079	e8 00 00 00 00	 call	 __security_check_cookie
  0207e	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  02085	5f		 pop	 rdi
  02086	5e		 pop	 rsi
  02087	c3		 ret	 0
qeth_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv151 = 0
copylen$ = 4
cua$ = 8
dev_ned$ = 16
ctl_ned$ = 24
tkn_ned$ = 32
gen_neq$ = 40
work$ = 48
__$ArrayPad$ = 176
dev$ = 224
buffer$ = 232
bufsz$ = 240
qeth_read_configuration_data PROC

; 3854 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3855 :     int   copylen;
; 3856 :     BYTE  work[ sizeof( configuration_data ) ];
; 3857 : 
; 3858 :     NED *dev_ned = (NED*)&work[0];  /* Device NED is first       */

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 00	 imul	 rax, rax, 0
  00033	48 8d 44 04 30	 lea	 rax, QWORD PTR work$[rsp+rax]
  00038	48 89 44 24 10	 mov	 QWORD PTR dev_ned$[rsp], rax

; 3859 :     NED *ctl_ned = dev_ned + 1;     /* Control Unit NED is next  */

  0003d	48 8b 44 24 10	 mov	 rax, QWORD PTR dev_ned$[rsp]
  00042	48 83 c0 20	 add	 rax, 32			; 00000020H
  00046	48 89 44 24 18	 mov	 QWORD PTR ctl_ned$[rsp], rax

; 3860 :     NED *tkn_ned = ctl_ned + 1;     /* Token NED is last NED     */

  0004b	48 8b 44 24 18	 mov	 rax, QWORD PTR ctl_ned$[rsp]
  00050	48 83 c0 20	 add	 rax, 32			; 00000020H
  00054	48 89 44 24 20	 mov	 QWORD PTR tkn_ned$[rsp], rax

; 3861 :     NEQ *gen_neq = (NEQ*)tkn_ned+1; /* General NEQ always last   */

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR tkn_ned$[rsp]
  0005e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00062	48 89 44 24 28	 mov	 QWORD PTR gen_neq$[rsp], rax

; 3862 :     DEVBLK *cua;                    /* Our Control Unit device   */
; 3863 : 
; 3864 :     /* Copy configuration data from tempate */
; 3865 :     memcpy (work, configuration_data, sizeof( work ));

  00067	48 8d 44 24 30	 lea	 rax, QWORD PTR work$[rsp]
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_data
  00073	48 8b f8	 mov	 rdi, rax
  00076	48 8b f1	 mov	 rsi, rcx
  00079	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0007e	f3 a4		 rep movsb

; 3866 : 
; 3867 :     /* The first device in the group is the control unit */
; 3868 :     cua = dev->group->memdev[0];

  00080	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00088	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008c	b9 08 00 00 00	 mov	 ecx, 8
  00091	48 6b c9 00	 imul	 rcx, rcx, 0
  00095	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  0009a	48 89 44 24 08	 mov	 QWORD PTR cua$[rsp], rax

; 3869 : 
; 3870 :     /* Insert the Channel Path ID (CHPID) into all of the NEDs */
; 3871 :     dev_ned->tag[0] = dev->pmcw.chpid[0];

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	b9 01 00 00 00	 mov	 ecx, 1
  000ad	48 6b c9 00	 imul	 rcx, rcx, 0
  000b1	48 8b 54 24 10	 mov	 rdx, QWORD PTR dev_ned$[rsp]
  000b6	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  000be	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  000c6	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 3872 :     ctl_ned->tag[0] = cua->pmcw.chpid[0];

  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	48 6b c0 00	 imul	 rax, rax, 0
  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	48 6b c9 00	 imul	 rcx, rcx, 0
  000dc	48 8b 54 24 18	 mov	 rdx, QWORD PTR ctl_ned$[rsp]
  000e1	48 8b 7c 24 08	 mov	 rdi, QWORD PTR cua$[rsp]
  000e6	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  000ee	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 3873 :     tkn_ned->tag[0] = cua->pmcw.chpid[0];

  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	48 6b c0 00	 imul	 rax, rax, 0
  000fb	b9 01 00 00 00	 mov	 ecx, 1
  00100	48 6b c9 00	 imul	 rcx, rcx, 0
  00104	48 8b 54 24 20	 mov	 rdx, QWORD PTR tkn_ned$[rsp]
  00109	48 8b 7c 24 08	 mov	 rdi, QWORD PTR cua$[rsp]
  0010e	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  00116	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 3874 : 
; 3875 :     /* Insert the device's device number into its device NED. */
; 3876 :     dev_ned->tag[1] = dev->devnum & 0xFF;

  0011a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00122	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00126	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0012b	b9 01 00 00 00	 mov	 ecx, 1
  00130	48 6b c9 01	 imul	 rcx, rcx, 1
  00134	48 8b 54 24 10	 mov	 rdx, QWORD PTR dev_ned$[rsp]
  00139	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 3877 : 
; 3878 :     /* Insert the control unit address into the General NEQ */
; 3879 :     gen_neq->iid[0] = cua->pmcw.chpid[0];

  0013d	b8 01 00 00 00	 mov	 eax, 1
  00142	48 6b c0 00	 imul	 rax, rax, 0
  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	48 6b c9 00	 imul	 rcx, rcx, 0
  0014f	48 8b 54 24 28	 mov	 rdx, QWORD PTR gen_neq$[rsp]
  00154	48 8b 7c 24 08	 mov	 rdi, QWORD PTR cua$[rsp]
  00159	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  00161	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 3880 :     gen_neq->iid[1] = cua->devnum & 0xFF;

  00165	48 8b 44 24 08	 mov	 rax, QWORD PTR cua$[rsp]
  0016a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0016e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	48 6b c9 01	 imul	 rcx, rcx, 1
  0017c	48 8b 54 24 28	 mov	 rdx, QWORD PTR gen_neq$[rsp]
  00181	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 3881 : 
; 3882 :     /* Finally, copy the work area into the caller's buffer */
; 3883 :     copylen = bufsz < (int) sizeof( work ) ? bufsz : (int) sizeof( work );

  00185	81 bc 24 f0 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR bufsz$[rsp], 128 ; 00000080H
  00190	7d 0c		 jge	 SHORT $LN3@qeth_read_
  00192	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR bufsz$[rsp]
  00199	89 04 24	 mov	 DWORD PTR tv151[rsp], eax
  0019c	eb 07		 jmp	 SHORT $LN4@qeth_read_
$LN3@qeth_read_:
  0019e	c7 04 24 80 00
	00 00		 mov	 DWORD PTR tv151[rsp], 128 ; 00000080H
$LN4@qeth_read_:
  001a5	8b 04 24	 mov	 eax, DWORD PTR tv151[rsp]
  001a8	89 44 24 04	 mov	 DWORD PTR copylen$[rsp], eax

; 3884 :     memcpy( buffer, work, copylen );

  001ac	48 63 44 24 04	 movsxd	 rax, DWORD PTR copylen$[rsp]
  001b1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR work$[rsp]
  001b6	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR buffer$[rsp]
  001be	48 8b f1	 mov	 rsi, rcx
  001c1	48 8b c8	 mov	 rcx, rax
  001c4	f3 a4		 rep movsb

; 3885 : 
; 3886 :     /* Return to them the number of bytes we provided */
; 3887 :     return copylen;

  001c6	8b 44 24 04	 mov	 eax, DWORD PTR copylen$[rsp]

; 3888 : }

  001ca	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d2	48 33 cc	 xor	 rcx, rsp
  001d5	e8 00 00 00 00	 call	 __security_check_cookie
  001da	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001e1	5f		 pop	 rdi
  001e2	5e		 pop	 rsi
  001e3	c3		 ret	 0
qeth_read_configuration_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 64
dev$ = 96
qeth_halt_or_clear PROC

; 3836 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3837 :     OSA_GRP* grp = (OSA_GRP*) dev->group->grp_data;

  00009	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00016	48 89 44 24 40	 mov	 QWORD PTR grp$[rsp], rax

; 3838 : 
; 3839 :     if (QTYPE_READ == dev->qtype)

  0001b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00020	0f b6 80 80 1b
	00 00		 movzx	 eax, BYTE PTR [rax+7040]
  00027	83 f8 01	 cmp	 eax, 1
  0002a	75 14		 jne	 SHORT $LN5@qeth_halt_

; 3840 :         qeth_halt_read_device( dev, grp );

  0002c	48 8b 54 24 40	 mov	 rdx, QWORD PTR grp$[rsp]
  00031	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00036	e8 00 00 00 00	 call	 qeth_halt_read_device
  0003b	e9 a8 00 00 00	 jmp	 $LN6@qeth_halt_
$LN5@qeth_halt_:

; 3841 :     else if (QTYPE_DATA == dev->qtype)

  00040	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00045	0f b6 80 80 1b
	00 00		 movzx	 eax, BYTE PTR [rax+7040]
  0004c	83 f8 03	 cmp	 eax, 3
  0004f	75 14		 jne	 SHORT $LN7@qeth_halt_

; 3842 :         qeth_halt_data_device( dev, grp );

  00051	48 8b 54 24 40	 mov	 rdx, QWORD PTR grp$[rsp]
  00056	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0005b	e8 00 00 00 00	 call	 qeth_halt_data_device
  00060	e9 83 00 00 00	 jmp	 $LN8@qeth_halt_
$LN7@qeth_halt_:

; 3843 :     else
; 3844 :     {
; 3845 :         DBGTRC( dev, "qeth_halt_or_clear: noop!" );

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173528
  0006c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00071	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  00076	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173529
  0007d	ba 05 0f 00 00	 mov	 edx, 3845		; 00000f05H
  00082	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173530
  00089	e8 00 00 00 00	 call	 dbgtrc
$LN4@qeth_halt_:

; 3846 :         PTT_QETH_TRACE( "*halt noop", dev->devnum, 0,0 );

  0008e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00095	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00098	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0009e	48 85 c0	 test	 rax, rax
  000a1	74 3f		 je	 SHORT $LN9@qeth_halt_
  000a3	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ac	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000b5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173532
  000c5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000ca	45 33 c9	 xor	 r9d, r9d
  000cd	44 8b c0	 mov	 r8d, eax
  000d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173533
  000d7	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@qeth_halt_:
  000e2	33 c0		 xor	 eax, eax
  000e4	85 c0		 test	 eax, eax
  000e6	75 a6		 jne	 SHORT $LN4@qeth_halt_
$LN8@qeth_halt_:
$LN6@qeth_halt_:

; 3847 :     }
; 3848 : }

  000e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ec	c3		 ret	 0
qeth_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
sig$1 = 64
dev$ = 96
grp$ = 104
qeth_halt_data_device PROC

; 3805 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3806 :     obtain_lock( &grp->qlock );

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00013	48 83 c0 10	 add	 rax, 16
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173484
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3807 :     {
; 3808 :         /* Is data device still active? */
; 3809 :         if (dev->busy && dev->scsw.flag2 & SCSW2_Q)

  00027	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0002c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00032	c1 e8 13	 shr	 eax, 19
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 d9 01 00
	00		 je	 $LN14@qeth_halt_
  00040	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00045	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0004c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00051	85 c0		 test	 eax, eax
  00053	0f 84 c0 01 00
	00		 je	 $LN14@qeth_halt_

; 3810 :         {
; 3811 :             BYTE  sig  = QDSIG_HALT;

  00059	c6 44 24 40 01	 mov	 BYTE PTR sig$1[rsp], 1

; 3812 : 
; 3813 :             DBGTRC( dev, "Halting data device" );

  0005e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173486
  00065	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006a	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  0006f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173487
  00076	ba e5 0e 00 00	 mov	 edx, 3813		; 00000ee5H
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173488
  00082	e8 00 00 00 00	 call	 dbgtrc
$LN4@qeth_halt_:

; 3814 :             {
; 3815 :                 /* Ask, then wait for, the Activate Queues loop to exit */
; 3816 :                 PTT_QETH_TRACE( "b4 halt data", 0,0,0 );

  00087	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0008e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00091	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00097	48 85 c0	 test	 rax, rax
  0009a	74 36		 je	 SHORT $LN15@qeth_halt_
  0009c	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000a5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173490
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	45 33 c9	 xor	 r9d, r9d
  000bd	45 33 c0	 xor	 r8d, r8d
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173491
  000c7	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@qeth_halt_:
  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 af		 jne	 SHORT $LN4@qeth_halt_
$LN7@qeth_halt_:

; 3817 :                 VERIFY( qeth_write_pipe( grp->ppfd[1], &sig ) == 1);

  000d8	b8 04 00 00 00	 mov	 eax, 4
  000dd	48 6b c0 01	 imul	 rax, rax, 1
  000e1	48 8d 54 24 40	 lea	 rdx, QWORD PTR sig$1[rsp]
  000e6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  000eb	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  000f2	e8 00 00 00 00	 call	 qeth_write_pipe
  000f7	83 f8 01	 cmp	 eax, 1
  000fa	74 5c		 je	 SHORT $LN16@qeth_halt_
$LN10@qeth_halt_:
  000fc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173493
  00103	41 b8 e9 0e 00
	00		 mov	 r8d, 3817		; 00000ee9H
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173494
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173495
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00123	85 c0		 test	 eax, eax
  00125	74 20		 je	 SHORT $LN17@qeth_halt_
  00127	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG173497
  0012e	41 b8 e9 0e 00
	00		 mov	 r8d, 3817		; 00000ee9H
  00134	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173498
  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173499
  00142	e8 00 00 00 00	 call	 DebuggerTrace
$LN17@qeth_halt_:
  00147	33 c0		 xor	 eax, eax
  00149	85 c0		 test	 eax, eax
  0014b	75 af		 jne	 SHORT $LN10@qeth_halt_
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00153	85 c0		 test	 eax, eax
  00155	74 01		 je	 SHORT $LN18@qeth_halt_
  00157	cc		 int	 3
$LN18@qeth_halt_:
$LN16@qeth_halt_:
  00158	33 c0		 xor	 eax, eax
  0015a	85 c0		 test	 eax, eax
  0015c	0f 85 76 ff ff
	ff		 jne	 $LN7@qeth_halt_

; 3818 :                 wait_condition( &grp->qdcond, &grp->qlock );

  00162	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00167	48 83 c0 10	 add	 rax, 16
  0016b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  00170	48 83 c1 08	 add	 rcx, 8
  00174	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173501
  0017b	48 8b d0	 mov	 rdx, rax
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 3819 :                 dev->scsw.flag2 &= ~SCSW2_Q;

  00184	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00189	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00190	0f ba f0 07	 btr	 eax, 7
  00194	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00199	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al
$LN13@qeth_halt_:

; 3820 :                 PTT_QETH_TRACE( "af halt data", 0,0,0 );

  0019f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001a6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001a9	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001af	48 85 c0	 test	 rax, rax
  001b2	74 36		 je	 SHORT $LN19@qeth_halt_
  001b4	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  001bd	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  001c6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173503
  001cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d2	45 33 c9	 xor	 r9d, r9d
  001d5	45 33 c0	 xor	 r8d, r8d
  001d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173504
  001df	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN19@qeth_halt_:
  001ea	33 c0		 xor	 eax, eax
  001ec	85 c0		 test	 eax, eax
  001ee	75 af		 jne	 SHORT $LN13@qeth_halt_

; 3821 :             }
; 3822 :             DBGTRC( dev, "Data device halted" );

  001f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173505
  001f7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001fc	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dev$[rsp]
  00201	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173506
  00208	ba ee 0e 00 00	 mov	 edx, 3822		; 00000eeeH
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173507
  00214	e8 00 00 00 00	 call	 dbgtrc
$LN14@qeth_halt_:

; 3823 :         }
; 3824 :     }
; 3825 :     release_lock (&grp->qlock );

  00219	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0021e	48 83 c0 10	 add	 rax, 16
  00222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173508
  00229	48 8b c8	 mov	 rcx, rax
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3826 : }

  00232	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00236	c3		 ret	 0
qeth_halt_data_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
dev$ = 80
grp$ = 88
qeth_halt_read_device PROC

; 3783 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3784 :     obtain_lock( &grp->qlock );

  0000e	48 8b 44 24 58	 mov	 rax, QWORD PTR grp$[rsp]
  00013	48 83 c0 10	 add	 rax, 16
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173436
  0001e	48 8b c8	 mov	 rcx, rax
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 3785 :     {
; 3786 :         /* Is read device still active? */
; 3787 :         if (dev->busy && dev->qdio.idxstate == MPC_IDX_STATE_ACTIVE)

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00032	c1 e8 13	 shr	 eax, 19
  00035	83 e0 01	 and	 eax, 1
  00038	85 c0		 test	 eax, eax
  0003a	0f 84 48 01 00
	00		 je	 $LN8@qeth_halt_
  00040	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00045	83 b8 34 13 00
	00 01		 cmp	 DWORD PTR [rax+4916], 1
  0004c	0f 85 36 01 00
	00		 jne	 $LN8@qeth_halt_

; 3788 :         {
; 3789 :             DBGTRC( dev, "Halting read device" );

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173438
  00059	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0005e	4c 8b 4c 24 50	 mov	 r9, QWORD PTR dev$[rsp]
  00063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173439
  0006a	ba cd 0e 00 00	 mov	 edx, 3789		; 00000ecdH
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173440
  00076	e8 00 00 00 00	 call	 dbgtrc
$LN4@qeth_halt_:

; 3790 :             {
; 3791 :                 /* Ask, then wait for, the READ CCW loop to exit */
; 3792 :                 PTT_QETH_TRACE( "b4 halt read", 0,0,0 );

  0007b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00082	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00085	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0008b	48 85 c0	 test	 rax, rax
  0008e	74 36		 je	 SHORT $LN9@qeth_halt_
  00090	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00099	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000a2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173442
  000a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ae	45 33 c9	 xor	 r9d, r9d
  000b1	45 33 c0	 xor	 r8d, r8d
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173443
  000bb	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN9@qeth_halt_:
  000c6	33 c0		 xor	 eax, eax
  000c8	85 c0		 test	 eax, eax
  000ca	75 af		 jne	 SHORT $LN4@qeth_halt_

; 3793 :                 dev->qdio.idxstate = MPC_IDX_STATE_HALTING;

  000cc	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000d1	c7 80 34 13 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+4916], 2

; 3794 :                 signal_condition( &grp->qrcond );

  000db	48 8b 44 24 58	 mov	 rax, QWORD PTR grp$[rsp]
  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173444
  000e7	48 8b c8	 mov	 rcx, rax
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 3795 :                 wait_condition( &grp->qrcond, &grp->qlock );

  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR grp$[rsp]
  000f5	48 83 c0 10	 add	 rax, 16
  000f9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR grp$[rsp]
  000fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173445
  00105	48 8b d0	 mov	 rdx, rax
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
$LN7@qeth_halt_:

; 3796 :                 PTT_QETH_TRACE( "af halt read", 0,0,0 );

  0010e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00115	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00118	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0011e	48 85 c0	 test	 rax, rax
  00121	74 36		 je	 SHORT $LN10@qeth_halt_
  00123	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0012c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00135	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173447
  0013c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00141	45 33 c9	 xor	 r9d, r9d
  00144	45 33 c0	 xor	 r8d, r8d
  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173448
  0014e	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN10@qeth_halt_:
  00159	33 c0		 xor	 eax, eax
  0015b	85 c0		 test	 eax, eax
  0015d	75 af		 jne	 SHORT $LN7@qeth_halt_

; 3797 :             }
; 3798 :             DBGTRC( dev, "Read device halted" );

  0015f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173449
  00166	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016b	4c 8b 4c 24 50	 mov	 r9, QWORD PTR dev$[rsp]
  00170	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173450
  00177	ba d6 0e 00 00	 mov	 edx, 3798		; 00000ed6H
  0017c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173451
  00183	e8 00 00 00 00	 call	 dbgtrc
$LN8@qeth_halt_:

; 3799 :         }
; 3800 :     }
; 3801 :     release_lock( &grp->qlock );

  00188	48 8b 44 24 58	 mov	 rax, QWORD PTR grp$[rsp]
  0018d	48 83 c0 10	 add	 rax, 16
  00191	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173452
  00198	48 8b c8	 mov	 rcx, rax
  0019b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 3802 : }

  001a1	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a5	c3		 ret	 0
qeth_halt_read_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
sk$1 = 64
qn$ = 68
bn$2 = 72
qrc$3 = 76
sbn$4 = 80
sqn$ = 84
found_buff$ = 88
tv281 = 92
mb$5 = 96
mq$ = 100
sbala$6 = 104
slsb$7 = 112
grp$ = 120
sl$8 = 128
sbal$9 = 136
dev$ = 160
process_output_queues PROC

; 3692 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 3693 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 89 44 24 78	 mov	 QWORD PTR grp$[rsp], rax

; 3694 : int sqn = dev->qdio.o_qpos;             /* Starting queue number     */

  00021	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00029	8b 80 c8 13 00
	00		 mov	 eax, DWORD PTR [rax+5064]
  0002f	89 44 24 54	 mov	 DWORD PTR sqn$[rsp], eax

; 3695 : int mq = dev->qdio.o_qcnt;              /* Maximum number of queues  */

  00033	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  00041	89 44 24 64	 mov	 DWORD PTR mq$[rsp], eax

; 3696 : int qn = sqn;                           /* Working queue number      */

  00045	8b 44 24 54	 mov	 eax, DWORD PTR sqn$[rsp]
  00049	89 44 24 44	 mov	 DWORD PTR qn$[rsp], eax

; 3697 : int found_buff = 0;                     /* Found primed O/P buffer   */

  0004d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR found_buff$[rsp], 0
$LN4@process_ou:

; 3698 : 
; 3699 :     PTT_QETH_TRACE( "proutq entr", 0,0,0 );

  00055	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0005c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0005f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00065	48 85 c0	 test	 rax, rax
  00068	74 36		 je	 SHORT $LN20@process_ou
  0006a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00073	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0007c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173385
  00083	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00088	45 33 c9	 xor	 r9d, r9d
  0008b	45 33 c0	 xor	 r8d, r8d
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173386
  00095	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN20@process_ou:
  000a0	33 c0		 xor	 eax, eax
  000a2	85 c0		 test	 eax, eax
  000a4	75 af		 jne	 SHORT $LN4@process_ou
$LN7@process_ou:

; 3700 :     do
; 3701 :     {
; 3702 :         if(dev->qdio.o_qmask & (0x80000000 >> qn))

  000a6	8b 44 24 44	 mov	 eax, DWORD PTR qn$[rsp]
  000aa	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  000af	89 4c 24 5c	 mov	 DWORD PTR tv281[rsp], ecx
  000b3	0f b6 c8	 movzx	 ecx, al
  000b6	8b 44 24 5c	 mov	 eax, DWORD PTR tv281[rsp]
  000ba	d3 e8		 shr	 eax, cl
  000bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000c4	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  000ca	23 c8		 and	 ecx, eax
  000cc	8b c1		 mov	 eax, ecx
  000ce	85 c0		 test	 eax, eax
  000d0	0f 84 1d 03 00
	00		 je	 $LN21@process_ou

; 3703 :         {
; 3704 :         QDIO_SLSB *slsb = (QDIO_SLSB*)(dev->mainstor + dev->qdio.o_slsbla[qn]);

  000d6	48 63 44 24 44	 movsxd	 rax, DWORD PTR qn$[rsp]
  000db	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e3	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000ea	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000f2	48 03 8c c2 58
	1a 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+6744]
  000fa	48 8b c1	 mov	 rax, rcx
  000fd	48 89 44 24 70	 mov	 QWORD PTR slsb$7[rsp], rax

; 3705 :         int sbn = dev->qdio.o_bpos[qn]; /* Starting buffer number    */

  00102	48 63 44 24 44	 movsxd	 rax, DWORD PTR qn$[rsp]
  00107	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010f	8b 84 81 cc 13
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+5068]
  00116	89 44 24 50	 mov	 DWORD PTR sbn$4[rsp], eax

; 3706 :         int mb = QMAXBUFS;              /* Maximum number of buffers */

  0011a	c7 44 24 60 80
	00 00 00	 mov	 DWORD PTR mb$5[rsp], 128 ; 00000080H

; 3707 :         int bn = sbn;                   /* Working buffer number     */

  00122	8b 44 24 50	 mov	 eax, DWORD PTR sbn$4[rsp]
  00126	89 44 24 48	 mov	 DWORD PTR bn$2[rsp], eax
$LN10@process_ou:

; 3708 : 
; 3709 :             do
; 3710 :             {
; 3711 :                 if(slsb->slsbe[bn] == SLSBE_OUTPUT_PRIMED)

  0012a	48 63 44 24 48	 movsxd	 rax, DWORD PTR bn$2[rsp]
  0012f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR slsb$7[rsp]
  00134	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00138	83 f8 62	 cmp	 eax, 98			; 00000062H
  0013b	0f 85 70 02 00
	00		 jne	 $LN22@process_ou

; 3712 :                 {
; 3713 :                 QDIO_SL *sl = (QDIO_SL*)(dev->mainstor + dev->qdio.o_sla[qn]);

  00141	48 63 44 24 44	 movsxd	 rax, DWORD PTR qn$[rsp]
  00146	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0014e	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00155	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0015d	48 03 8c c2 58
	19 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+6488]
  00165	48 8b c1	 mov	 rax, rcx
  00168	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR sl$8[rsp], rax

; 3714 :                 U64 sbala;              /* Storage Block Address List*/
; 3715 :                 BYTE sk;                /* Storage Key               */
; 3716 :                 QRC qrc;                /* Internal return code      */
; 3717 : 
; 3718 :                     if (grp->debugmask & DBGQETHQUEUES)

  00170	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  00175	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  0017b	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00180	85 c0		 test	 eax, eax
  00182	74 3c		 je	 SHORT $LN23@process_ou

; 3719 :                         DBGTRC(dev, "Output Queue(%d) Buffer(%d)", qn, bn);

  00184	8b 44 24 48	 mov	 eax, DWORD PTR bn$2[rsp]
  00188	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0018c	8b 44 24 44	 mov	 eax, DWORD PTR qn$[rsp]
  00190	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00194	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173390
  0019b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a0	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  001a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173391
  001af	ba 87 0e 00 00	 mov	 edx, 3719		; 00000e87H
  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173392
  001bb	e8 00 00 00 00	 call	 dbgtrc
$LN23@process_ou:

; 3720 : 
; 3721 :                     found_buff = 1;

  001c0	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR found_buff$[rsp], 1

; 3722 :                     sk = dev->qdio.o_slk[qn];

  001c8	48 63 44 24 44	 movsxd	 rax, DWORD PTR qn$[rsp]
  001cd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d5	0f b6 84 01 f8
	17 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6136]
  001dd	88 44 24 40	 mov	 BYTE PTR sk$1[rsp], al

; 3723 :                     FETCH_DW( sbala, sl->sbala[bn] );

  001e1	48 63 44 24 48	 movsxd	 rax, DWORD PTR bn$2[rsp]
  001e6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sl$8[rsp]
  001ee	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001f2	48 8b c8	 mov	 rcx, rax
  001f5	e8 00 00 00 00	 call	 fetch_dw_noswap
  001fa	48 8b c8	 mov	 rcx, rax
  001fd	e8 00 00 00 00	 call	 _byteswap_uint64
  00202	48 89 44 24 68	 mov	 QWORD PTR sbala$6[rsp], rax

; 3724 : 
; 3725 :                     /* Verify Storage Block Address List is accessible */
; 3726 :                     if(STORCHK( sbala, sizeof(QDIO_SBAL)-1, sk, STORKEY_REF, dev ))

  00207	0f b6 44 24 40	 movzx	 eax, BYTE PTR sk$1[rsp]
  0020c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00214	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00219	41 b9 04 00 00
	00		 mov	 r9d, 4
  0021f	44 8b c0	 mov	 r8d, eax
  00222	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00227	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sbala$6[rsp]
  0022c	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  00231	85 c0		 test	 eax, eax
  00233	74 4b		 je	 SHORT $LN24@process_ou

; 3727 :                     {
; 3728 :                         DBGTRC(dev, "STORCHK Error SBALA(%llx), Key(%2.2X)", sbala, sk);

  00235	0f b6 44 24 40	 movzx	 eax, BYTE PTR sk$1[rsp]
  0023a	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0023e	48 8b 44 24 68	 mov	 rax, QWORD PTR sbala$6[rsp]
  00243	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00248	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173395
  0024f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00254	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0025c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173396
  00263	ba 90 0e 00 00	 mov	 edx, 3728		; 00000e90H
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173397
  0026f	e8 00 00 00 00	 call	 dbgtrc

; 3729 :                         qrc = QRC_ESTORCHK;

  00274	b8 fe ff ff ff	 mov	 eax, -2
  00279	66 89 44 24 4c	 mov	 WORD PTR qrc$3[rsp], ax

; 3730 :                     }

  0027e	eb 71		 jmp	 SHORT $LN25@process_ou
$LN24@process_ou:

; 3731 :                     else
; 3732 :                     {
; 3733 :                         /* Write packets from this primed buffer */
; 3734 :                         QDIO_SBAL *sbal = (QDIO_SBAL*)(dev->mainstor + sbala);

  00280	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00288	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0028f	48 03 44 24 68	 add	 rax, QWORD PTR sbala$6[rsp]
  00294	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR sbal$9[rsp], rax

; 3735 : 
; 3736 :                         sk = dev->qdio.o_sbalk[qn];

  0029c	48 63 44 24 44	 movsxd	 rax, DWORD PTR qn$[rsp]
  002a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a9	0f b6 84 01 18
	18 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6168]
  002b1	88 44 24 40	 mov	 BYTE PTR sk$1[rsp], al

; 3737 : 
; 3738 :                         if ((qrc = write_buffered_packets( dev, grp, sbal, sk )) >= 0)

  002b5	44 0f b6 4c 24
	40		 movzx	 r9d, BYTE PTR sk$1[rsp]
  002bb	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR sbal$9[rsp]
  002c3	48 8b 54 24 78	 mov	 rdx, QWORD PTR grp$[rsp]
  002c8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d0	e8 00 00 00 00	 call	 write_buffered_packets
  002d5	66 89 44 24 4c	 mov	 WORD PTR qrc$3[rsp], ax
  002da	0f bf 44 24 4c	 movsx	 eax, WORD PTR qrc$3[rsp]
  002df	85 c0		 test	 eax, eax
  002e1	7c 0e		 jl	 SHORT $LN26@process_ou

; 3739 :                             slsb->slsbe[bn] = SLSBE_OUTPUT_COMPLETED;

  002e3	48 63 44 24 48	 movsxd	 rax, DWORD PTR bn$2[rsp]
  002e8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR slsb$7[rsp]
  002ed	c6 04 01 a1	 mov	 BYTE PTR [rcx+rax], 161	; 000000a1H
$LN26@process_ou:
$LN25@process_ou:

; 3740 :                     }
; 3741 : 
; 3742 :                     /* Packets written or an error has ocurred */
; 3743 :                     ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.o_slsbla[qn], (STORKEY_REF | STORKEY_CHANGE) );

  002f1	48 63 44 24 44	 movsxd	 rax, DWORD PTR qn$[rsp]
  002f6	41 b0 06	 mov	 r8b, 6
  002f9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00301	48 8b 94 c1 58
	1a 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+6744]
  00309	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00311	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 3744 : 
; 3745 :                     /* Handle errors */
; 3746 :                     if (qrc < 0)

  00316	0f bf 44 24 4c	 movsx	 eax, WORD PTR qrc$3[rsp]
  0031b	85 c0		 test	 eax, eax
  0031d	0f 8d 8e 00 00
	00		 jge	 $LN27@process_ou

; 3747 :                     {
; 3748 :                         slsb->slsbe[bn] = SLSBE_ERROR;

  00323	48 63 44 24 48	 movsxd	 rax, DWORD PTR bn$2[rsp]
  00328	48 8b 4c 24 70	 mov	 rcx, QWORD PTR slsb$7[rsp]
  0032d	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3749 :                         SET_ALSI(dev,ALSI_ERROR);

  00331	b2 80		 mov	 dl, 128			; 00000080H
  00333	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033b	e8 00 00 00 00	 call	 set_alsi

; 3750 :                         grp->oqPCI = TRUE;

  00340	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  00345	c7 80 f4 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1524], 1
$LN13@process_ou:

; 3751 :                         PTT_QETH_TRACE( "*proutq ERR", qn,bn,qrc );

  0034f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00356	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00359	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0035f	48 85 c0	 test	 rax, rax
  00362	74 42		 je	 SHORT $LN28@process_ou
  00364	48 0f bf 44 24
	4c		 movsx	 rax, WORD PTR qrc$3[rsp]
  0036a	48 63 4c 24 48	 movsxd	 rcx, DWORD PTR bn$2[rsp]
  0036f	48 63 54 24 44	 movsxd	 rdx, DWORD PTR qn$[rsp]
  00374	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0037d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00382	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173401
  00389	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0038e	4c 8b c9	 mov	 r9, rcx
  00391	4c 8b c2	 mov	 r8, rdx
  00394	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173402
  0039b	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  003a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN28@process_ou:
  003a6	33 c0		 xor	 eax, eax
  003a8	85 c0		 test	 eax, eax
  003aa	75 a3		 jne	 SHORT $LN13@process_ou

; 3752 :                         return;

  003ac	e9 35 01 00 00	 jmp	 $LN1@process_ou
$LN27@process_ou:
$LN22@process_ou:

; 3753 :                     }
; 3754 : 
; 3755 :                 } /* end if(SLSBE_OUTPUT_PRIMED) */
; 3756 : 
; 3757 :                 /* Go on to the next buffer... */
; 3758 :                 if(++bn >= mb)

  003b1	8b 44 24 48	 mov	 eax, DWORD PTR bn$2[rsp]
  003b5	ff c0		 inc	 eax
  003b7	89 44 24 48	 mov	 DWORD PTR bn$2[rsp], eax
  003bb	8b 44 24 60	 mov	 eax, DWORD PTR mb$5[rsp]
  003bf	39 44 24 48	 cmp	 DWORD PTR bn$2[rsp], eax
  003c3	7c 08		 jl	 SHORT $LN29@process_ou

; 3759 :                     bn = 0;

  003c5	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bn$2[rsp], 0
$LN29@process_ou:

; 3760 :             }
; 3761 :             while ((dev->qdio.o_bpos[qn] = bn) != sbn);

  003cd	48 63 44 24 44	 movsxd	 rax, DWORD PTR qn$[rsp]
  003d2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003da	8b 54 24 48	 mov	 edx, DWORD PTR bn$2[rsp]
  003de	89 94 81 cc 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+5068], edx
  003e5	8b 44 24 50	 mov	 eax, DWORD PTR sbn$4[rsp]
  003e9	39 44 24 48	 cmp	 DWORD PTR bn$2[rsp], eax
  003ed	0f 85 37 fd ff
	ff		 jne	 $LN10@process_ou
$LN21@process_ou:

; 3762 : 
; 3763 :         } /* end if(dev->qdio.o_qmask & (0x80000000 >> qn)) */
; 3764 : 
; 3765 :         /* Go on to the next queue... */
; 3766 :         if(++qn >= mq)

  003f3	8b 44 24 44	 mov	 eax, DWORD PTR qn$[rsp]
  003f7	ff c0		 inc	 eax
  003f9	89 44 24 44	 mov	 DWORD PTR qn$[rsp], eax
  003fd	8b 44 24 64	 mov	 eax, DWORD PTR mq$[rsp]
  00401	39 44 24 44	 cmp	 DWORD PTR qn$[rsp], eax
  00405	7c 08		 jl	 SHORT $LN30@process_ou

; 3767 :             qn = 0;

  00407	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR qn$[rsp], 0
$LN30@process_ou:

; 3768 :     }
; 3769 :     while ((dev->qdio.o_qpos = qn) != sqn);

  0040f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00417	8b 4c 24 44	 mov	 ecx, DWORD PTR qn$[rsp]
  0041b	89 88 c8 13 00
	00		 mov	 DWORD PTR [rax+5064], ecx
  00421	8b 44 24 54	 mov	 eax, DWORD PTR sqn$[rsp]
  00425	39 44 24 44	 cmp	 DWORD PTR qn$[rsp], eax
  00429	0f 85 77 fc ff
	ff		 jne	 $LN7@process_ou

; 3770 : 
; 3771 :     if (!found_buff)

  0042f	83 7c 24 58 00	 cmp	 DWORD PTR found_buff$[rsp], 0
  00434	75 5f		 jne	 SHORT $LN31@process_ou
$LN16@process_ou:

; 3772 :         PTT_QETH_TRACE( "*proutq EOF", dev->qdio.o_qmask,0,0 );

  00436	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0043d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00440	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00446	48 85 c0	 test	 rax, rax
  00449	74 44		 je	 SHORT $LN32@process_ou
  0044b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00453	8b 80 50 14 00
	00		 mov	 eax, DWORD PTR [rax+5200]
  00459	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00462	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0046b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173407
  00472	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00477	45 33 c9	 xor	 r9d, r9d
  0047a	44 8b c0	 mov	 r8d, eax
  0047d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173408
  00484	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00489	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN32@process_ou:
  0048f	33 c0		 xor	 eax, eax
  00491	85 c0		 test	 eax, eax
  00493	75 a1		 jne	 SHORT $LN16@process_ou
$LN31@process_ou:
$LN19@process_ou:

; 3773 : 
; 3774 :     PTT_QETH_TRACE( "proutq exit", 0,0,0 );

  00495	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0049c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0049f	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  004a5	48 85 c0	 test	 rax, rax
  004a8	74 36		 je	 SHORT $LN33@process_ou
  004aa	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004b3	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  004bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173410
  004c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004c8	45 33 c9	 xor	 r9d, r9d
  004cb	45 33 c0	 xor	 r8d, r8d
  004ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173411
  004d5	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  004da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN33@process_ou:
  004e0	33 c0		 xor	 eax, eax
  004e2	85 c0		 test	 eax, eax
  004e4	75 af		 jne	 SHORT $LN19@process_ou
$LN1@process_ou:

; 3775 : }

  004e6	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  004ed	c3		 ret	 0
process_output_queues ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
sk$1 = 96
qrc$2 = 100
qn$ = 104
bn$3 = 108
grp$ = 112
sbn$4 = 120
sqn$ = 124
did_read$ = 128
tv321 = 132
tv327 = 136
tv387 = 140
mb$5 = 144
mq$ = 148
packet_len$6 = 152
sbala$7 = 160
sbal$8 = 168
slsb$9 = 176
sl$10 = 184
tv314 = 192
buff$11 = 208
__$ArrayPad$ = 4304
dev$ = 4336
process_input_queues PROC

; 3551 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 e8 10 00 00	 mov	 eax, 4328		; 000010e8H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 d0
	10 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3552 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00024	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00030	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00034	48 89 44 24 70	 mov	 QWORD PTR grp$[rsp], rax

; 3553 : int sqn = dev->qdio.i_qpos;             /* Starting queue number     */

  00039	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	8b 80 40 13 00
	00		 mov	 eax, DWORD PTR [rax+4928]
  00047	89 44 24 7c	 mov	 DWORD PTR sqn$[rsp], eax

; 3554 : int mq = dev->qdio.i_qcnt;              /* Maximum number of queues  */

  0004b	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00053	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00059	89 84 24 94 00
	00 00		 mov	 DWORD PTR mq$[rsp], eax

; 3555 : int qn = sqn;                           /* Working queue number      */

  00060	8b 44 24 7c	 mov	 eax, DWORD PTR sqn$[rsp]
  00064	89 44 24 68	 mov	 DWORD PTR qn$[rsp], eax

; 3556 : int did_read = 0;                       /* Indicates some data read  */

  00068	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR did_read$[rsp], 0
$LN4@process_in:

; 3557 : 
; 3558 :     PTT_QETH_TRACE( "prinq entr", 0,0,0 );

  00073	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0007a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00083	48 85 c0	 test	 rax, rax
  00086	74 36		 je	 SHORT $LN26@process_in
  00088	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00091	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173273
  000a1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a6	45 33 c9	 xor	 r9d, r9d
  000a9	45 33 c0	 xor	 r8d, r8d
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173274
  000b3	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN26@process_in:
  000be	33 c0		 xor	 eax, eax
  000c0	85 c0		 test	 eax, eax
  000c2	75 af		 jne	 SHORT $LN4@process_in
$LN7@process_in:

; 3559 :     do
; 3560 :     {
; 3561 :         if(dev->qdio.i_qmask & (0x80000000 >> qn))

  000c4	8b 44 24 68	 mov	 eax, DWORD PTR qn$[rsp]
  000c8	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  000cd	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv387[rsp], ecx
  000d4	0f b6 c8	 movzx	 ecx, al
  000d7	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv387[rsp]
  000de	d3 e8		 shr	 eax, cl
  000e0	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e8	8b 89 4c 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5196]
  000ee	23 c8		 and	 ecx, eax
  000f0	8b c1		 mov	 eax, ecx
  000f2	85 c0		 test	 eax, eax
  000f4	0f 84 c0 04 00
	00		 je	 $LN27@process_in

; 3562 :         {
; 3563 :         QDIO_SLSB *slsb = (QDIO_SLSB*)(dev->mainstor + dev->qdio.i_slsbla[qn]);

  000fa	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  000ff	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00107	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0010e	48 8b 94 24 f0
	10 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00116	48 03 8c c2 d8
	16 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+5848]
  0011e	48 8b c1	 mov	 rax, rcx
  00121	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR slsb$9[rsp], rax

; 3564 :         int sbn = dev->qdio.i_bpos[qn]; /* Starting buffer number    */

  00129	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  0012e	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00136	8b 84 81 44 13
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4932]
  0013d	89 44 24 78	 mov	 DWORD PTR sbn$4[rsp], eax

; 3565 :         int mb = QMAXBUFS;              /* Maximum number of buffers */

  00141	c7 84 24 90 00
	00 00 80 00 00
	00		 mov	 DWORD PTR mb$5[rsp], 128 ; 00000080H

; 3566 :         int bn = sbn;                   /* Working buffer number     */

  0014c	8b 44 24 78	 mov	 eax, DWORD PTR sbn$4[rsp]
  00150	89 44 24 6c	 mov	 DWORD PTR bn$3[rsp], eax
$LN10@process_in:

; 3567 :         QRC qrc;                        /* Internal return code      */
; 3568 : 
; 3569 :             do
; 3570 :             {
; 3571 :                 if(slsb->slsbe[bn] == SLSBE_INPUT_EMPTY)

  00154	48 63 44 24 6c	 movsxd	 rax, DWORD PTR bn$3[rsp]
  00159	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR slsb$9[rsp]
  00161	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00165	83 f8 41	 cmp	 eax, 65			; 00000041H
  00168	0f 85 07 04 00
	00		 jne	 $LN28@process_in

; 3572 :                 {
; 3573 :                 QDIO_SL *sl = (QDIO_SL*)(dev->mainstor + dev->qdio.i_sla[qn]);

  0016e	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  00173	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017b	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00182	48 8b 94 24 f0
	10 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0018a	48 03 8c c2 d8
	15 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+5592]
  00192	48 8b c1	 mov	 rax, rcx
  00195	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR sl$10[rsp], rax

; 3574 :                 U64 sbala;              /* Storage Block Address List*/
; 3575 :                 BYTE sk;                /* Storage Key               */
; 3576 : 
; 3577 :                     sk = dev->qdio.i_slk[qn];

  0019d	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  001a2	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001aa	0f b6 84 01 74
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5236]
  001b2	88 44 24 60	 mov	 BYTE PTR sk$1[rsp], al

; 3578 :                     FETCH_DW( sbala, sl->sbala[bn] );

  001b6	48 63 44 24 6c	 movsxd	 rax, DWORD PTR bn$3[rsp]
  001bb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR sl$10[rsp]
  001c3	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001c7	48 8b c8	 mov	 rcx, rax
  001ca	e8 00 00 00 00	 call	 fetch_dw_noswap
  001cf	48 8b c8	 mov	 rcx, rax
  001d2	e8 00 00 00 00	 call	 _byteswap_uint64
  001d7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR sbala$7[rsp], rax

; 3579 : 
; 3580 :                     /* Verify Storage Block Address List is accessible */
; 3581 :                     if(STORCHK( sbala, sizeof(QDIO_SBAL)-1, sk, STORKEY_REF, dev ))

  001df	0f b6 44 24 60	 movzx	 eax, BYTE PTR sk$1[rsp]
  001e4	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ec	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001f1	41 b9 04 00 00
	00		 mov	 r9d, 4
  001f7	44 8b c0	 mov	 r8d, eax
  001fa	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001ff	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sbala$7[rsp]
  00207	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  0020c	85 c0		 test	 eax, eax
  0020e	74 51		 je	 SHORT $LN29@process_in

; 3582 :                     {
; 3583 :                         DBGTRC(dev, "STORCHK Error SBALA(%llx), Key(%2.2X)", sbala, sk);

  00210	0f b6 44 24 60	 movzx	 eax, BYTE PTR sk$1[rsp]
  00215	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00219	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sbala$7[rsp]
  00221	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00226	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173279
  0022d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00232	4c 8b 8c 24 f0
	10 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0023a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173280
  00241	ba ff 0d 00 00	 mov	 edx, 3583		; 00000dffH
  00246	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173281
  0024d	e8 00 00 00 00	 call	 dbgtrc

; 3584 :                         qrc = QRC_ESTORCHK;

  00252	b8 fe ff ff ff	 mov	 eax, -2
  00257	66 89 44 24 64	 mov	 WORD PTR qrc$2[rsp], ax

; 3585 :                     }

  0025c	e9 51 02 00 00	 jmp	 $LN30@process_in
$LN29@process_in:

; 3586 :                     else
; 3587 :                     {
; 3588 :                         /* Read packets into this empty buffer */
; 3589 :                         QDIO_SBAL *sbal = (QDIO_SBAL*)(dev->mainstor + sbala);

  00261	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00269	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00270	48 03 84 24 a0
	00 00 00	 add	 rax, QWORD PTR sbala$7[rsp]
  00278	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR sbal$8[rsp], rax

; 3590 :                         sk = dev->qdio.i_sbalk[qn];

  00280	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  00285	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028d	0f b6 84 01 94
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5268]
  00295	88 44 24 60	 mov	 BYTE PTR sk$1[rsp], al

; 3591 :                         did_read = 1;

  00299	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR did_read$[rsp], 1

; 3592 : 
; 3593 :                         if (grp->l3)

  002a4	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  002a9	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  002b0	74 5a		 je	 SHORT $LN31@process_in

; 3594 :                         {
; 3595 :                             if (grp->l3r.firstbhr)

  002b2	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  002b7	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  002bc	74 27		 je	 SHORT $LN33@process_in

; 3596 :                                 qrc = read_l3r_buffers( dev, grp, sbal, sk );

  002be	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR sk$1[rsp]
  002c4	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR sbal$8[rsp]
  002cc	48 8b 54 24 70	 mov	 rdx, QWORD PTR grp$[rsp]
  002d1	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d9	e8 00 00 00 00	 call	 read_l3r_buffers
  002de	66 89 44 24 64	 mov	 WORD PTR qrc$2[rsp], ax
  002e3	eb 25		 jmp	 SHORT $LN34@process_in
$LN33@process_in:

; 3597 :                             else
; 3598 :                                 qrc = read_L3_packets( dev, grp, sbal, sk );

  002e5	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR sk$1[rsp]
  002eb	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR sbal$8[rsp]
  002f3	48 8b 54 24 70	 mov	 rdx, QWORD PTR grp$[rsp]
  002f8	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00300	e8 00 00 00 00	 call	 read_L3_packets
  00305	66 89 44 24 64	 mov	 WORD PTR qrc$2[rsp], ax
$LN34@process_in:

; 3599 :                         }

  0030a	eb 25		 jmp	 SHORT $LN32@process_in
$LN31@process_in:

; 3600 :                         else
; 3601 :                             qrc = read_L2_packets( dev, grp, sbal, sk );

  0030c	44 0f b6 4c 24
	60		 movzx	 r9d, BYTE PTR sk$1[rsp]
  00312	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR sbal$8[rsp]
  0031a	48 8b 54 24 70	 mov	 rdx, QWORD PTR grp$[rsp]
  0031f	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00327	e8 00 00 00 00	 call	 read_L2_packets
  0032c	66 89 44 24 64	 mov	 WORD PTR qrc$2[rsp], ax
$LN32@process_in:

; 3602 : 
; 3603 :                         /* Mark the buffer as having been completed */
; 3604 :                         if (qrc >= 0)

  00331	0f bf 44 24 64	 movsx	 eax, WORD PTR qrc$2[rsp]
  00336	85 c0		 test	 eax, eax
  00338	0f 8c 08 01 00
	00		 jl	 $LN35@process_in

; 3605 :                         {
; 3606 :                             if (grp->debugmask & DBGQETHQUEUES)

  0033e	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  00343	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00349	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0034e	85 c0		 test	 eax, eax
  00350	74 3c		 je	 SHORT $LN37@process_in

; 3607 :                                 DBGTRC(dev, "Input Queue(%d) Buffer(%d)", qn, bn);

  00352	8b 44 24 6c	 mov	 eax, DWORD PTR bn$3[rsp]
  00356	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0035a	8b 44 24 68	 mov	 eax, DWORD PTR qn$[rsp]
  0035e	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00362	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173289
  00369	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0036e	4c 8b 8c 24 f0
	10 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00376	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173290
  0037d	ba 17 0e 00 00	 mov	 edx, 3607		; 00000e17H
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173291
  00389	e8 00 00 00 00	 call	 dbgtrc
$LN37@process_in:

; 3608 : 
; 3609 :                             slsb->slsbe[bn] = SLSBE_INPUT_COMPLETED;

  0038e	48 63 44 24 6c	 movsxd	 rax, DWORD PTR bn$3[rsp]
  00393	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR slsb$9[rsp]
  0039b	c6 04 01 82	 mov	 BYTE PTR [rcx+rax], 130	; 00000082H

; 3610 :                             ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.i_slsbla[qn], (STORKEY_REF | STORKEY_CHANGE) );

  0039f	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  003a4	41 b0 06	 mov	 r8b, 6
  003a7	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003af	48 8b 94 c1 d8
	16 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+5848]
  003b7	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003bf	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 3611 :                             SET_DSCI(dev,DSCI_IOCOMP);

  003c4	b2 01		 mov	 dl, 1
  003c6	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ce	e8 00 00 00 00	 call	 set_dsci

; 3612 :                             grp->iqPCI = TRUE;

  003d3	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  003d8	c7 80 f0 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1520], 1
$LN13@process_in:

; 3613 :                             PTT_QETH_TRACE( "prinq OK", qn,bn,qrc );

  003e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003ec	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  003f2	48 85 c0	 test	 rax, rax
  003f5	74 42		 je	 SHORT $LN38@process_in
  003f7	48 0f bf 44 24
	64		 movsx	 rax, WORD PTR qrc$2[rsp]
  003fd	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR bn$3[rsp]
  00402	48 63 54 24 68	 movsxd	 rdx, DWORD PTR qn$[rsp]
  00407	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00410	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00415	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173293
  0041c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00421	4c 8b c9	 mov	 r9, rcx
  00424	4c 8b c2	 mov	 r8, rdx
  00427	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173294
  0042e	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00433	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN38@process_in:
  00439	33 c0		 xor	 eax, eax
  0043b	85 c0		 test	 eax, eax
  0043d	75 a3		 jne	 SHORT $LN13@process_in

; 3614 :                             return;

  0043f	e9 f1 03 00 00	 jmp	 $LN1@process_in

; 3615 :                         }

  00444	eb 6c		 jmp	 SHORT $LN36@process_in
$LN35@process_in:

; 3616 :                         else if (qrc == QRC_EPKEOF)

  00446	0f bf 44 24 64	 movsx	 eax, WORD PTR qrc$2[rsp]
  0044b	83 f8 fc	 cmp	 eax, -4
  0044e	75 62		 jne	 SHORT $LN39@process_in
$LN16@process_in:

; 3617 :                         {
; 3618 :                             /* We didn't find any packets/frames meant
; 3619 :                             for us (perhaps the destination MAC or IP
; 3620 :                             addresses didn't match) so just return. */
; 3621 :                             PTT_QETH_TRACE( "*prcinq EOF", qn,bn,qrc );

  00450	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00457	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0045a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00460	48 85 c0	 test	 rax, rax
  00463	74 42		 je	 SHORT $LN40@process_in
  00465	48 0f bf 44 24
	64		 movsx	 rax, WORD PTR qrc$2[rsp]
  0046b	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR bn$3[rsp]
  00470	48 63 54 24 68	 movsxd	 rdx, DWORD PTR qn$[rsp]
  00475	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0047e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00483	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173297
  0048a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0048f	4c 8b c9	 mov	 r9, rcx
  00492	4c 8b c2	 mov	 r8, rdx
  00495	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173298
  0049c	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN40@process_in:
  004a7	33 c0		 xor	 eax, eax
  004a9	85 c0		 test	 eax, eax
  004ab	75 a3		 jne	 SHORT $LN16@process_in

; 3622 :                             return;   /* (nothing for us to do) */

  004ad	e9 83 03 00 00	 jmp	 $LN1@process_in
$LN39@process_in:
$LN36@process_in:
$LN30@process_in:

; 3623 :                         }
; 3624 :                     }
; 3625 : 
; 3626 :                     /* Handle errors here since both read_L2_packets
; 3627 :                        and read_L3_packets may also return an error */
; 3628 :                     if (qrc < 0)

  004b2	0f bf 44 24 64	 movsx	 eax, WORD PTR qrc$2[rsp]
  004b7	85 c0		 test	 eax, eax
  004b9	0f 8d b6 00 00
	00		 jge	 $LN41@process_in

; 3629 :                     {
; 3630 :                         slsb->slsbe[bn] = SLSBE_ERROR;

  004bf	48 63 44 24 6c	 movsxd	 rax, DWORD PTR bn$3[rsp]
  004c4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR slsb$9[rsp]
  004cc	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 3631 :                         ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.i_slsbla[qn], (STORKEY_REF | STORKEY_CHANGE) );

  004d0	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  004d5	41 b0 06	 mov	 r8b, 6
  004d8	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004e0	48 8b 94 c1 d8
	16 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+5848]
  004e8	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004f0	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 3632 :                         SET_ALSI(dev,ALSI_ERROR);

  004f5	b2 80		 mov	 dl, 128			; 00000080H
  004f7	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004ff	e8 00 00 00 00	 call	 set_alsi

; 3633 :                         grp->iqPCI = TRUE;

  00504	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  00509	c7 80 f0 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1520], 1
$LN19@process_in:

; 3634 :                         PTT_QETH_TRACE( "*prcinq ERR", qn,bn,qrc );

  00513	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0051a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0051d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00523	48 85 c0	 test	 rax, rax
  00526	74 42		 je	 SHORT $LN42@process_in
  00528	48 0f bf 44 24
	64		 movsx	 rax, WORD PTR qrc$2[rsp]
  0052e	48 63 4c 24 6c	 movsxd	 rcx, DWORD PTR bn$3[rsp]
  00533	48 63 54 24 68	 movsxd	 rdx, DWORD PTR qn$[rsp]
  00538	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00541	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00546	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173301
  0054d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00552	4c 8b c9	 mov	 r9, rcx
  00555	4c 8b c2	 mov	 r8, rdx
  00558	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173302
  0055f	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00564	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN42@process_in:
  0056a	33 c0		 xor	 eax, eax
  0056c	85 c0		 test	 eax, eax
  0056e	75 a3		 jne	 SHORT $LN19@process_in

; 3635 :                         return;

  00570	e9 c0 02 00 00	 jmp	 $LN1@process_in
$LN41@process_in:
$LN28@process_in:

; 3636 :                     }
; 3637 : 
; 3638 :                 } /* end if (SLSBE_INPUT_EMPTY) */
; 3639 : 
; 3640 :                 /* Go on to the next buffer... */
; 3641 :                 if(++bn >= mb)

  00575	8b 44 24 6c	 mov	 eax, DWORD PTR bn$3[rsp]
  00579	ff c0		 inc	 eax
  0057b	89 44 24 6c	 mov	 DWORD PTR bn$3[rsp], eax
  0057f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR mb$5[rsp]
  00586	39 44 24 6c	 cmp	 DWORD PTR bn$3[rsp], eax
  0058a	7c 08		 jl	 SHORT $LN43@process_in

; 3642 :                     bn = 0;

  0058c	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR bn$3[rsp], 0
$LN43@process_in:

; 3643 :             }
; 3644 :             while ((dev->qdio.i_bpos[qn] = bn) != sbn);

  00594	48 63 44 24 68	 movsxd	 rax, DWORD PTR qn$[rsp]
  00599	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005a1	8b 54 24 6c	 mov	 edx, DWORD PTR bn$3[rsp]
  005a5	89 94 81 44 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+4932], edx
  005ac	8b 44 24 78	 mov	 eax, DWORD PTR sbn$4[rsp]
  005b0	39 44 24 6c	 cmp	 DWORD PTR bn$3[rsp], eax
  005b4	0f 85 9a fb ff
	ff		 jne	 $LN10@process_in
$LN27@process_in:

; 3645 : 
; 3646 :         } /* end if(dev->qdio.i_qmask & (0x80000000 >> qn)) */
; 3647 : 
; 3648 :         /* Go on to the next queue... */
; 3649 :         if(++qn >= mq)

  005ba	8b 44 24 68	 mov	 eax, DWORD PTR qn$[rsp]
  005be	ff c0		 inc	 eax
  005c0	89 44 24 68	 mov	 DWORD PTR qn$[rsp], eax
  005c4	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR mq$[rsp]
  005cb	39 44 24 68	 cmp	 DWORD PTR qn$[rsp], eax
  005cf	7c 08		 jl	 SHORT $LN44@process_in

; 3650 :             qn = 0;

  005d1	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR qn$[rsp], 0
$LN44@process_in:

; 3651 :     }
; 3652 :     while ((dev->qdio.i_qpos = qn) != sqn);

  005d9	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e1	8b 4c 24 68	 mov	 ecx, DWORD PTR qn$[rsp]
  005e5	89 88 40 13 00
	00		 mov	 DWORD PTR [rax+4928], ecx
  005eb	8b 44 24 7c	 mov	 eax, DWORD PTR sqn$[rsp]
  005ef	39 44 24 68	 cmp	 DWORD PTR qn$[rsp], eax
  005f3	0f 85 cb fa ff
	ff		 jne	 $LN7@process_in

; 3653 : 
; 3654 :     /* PROGRAMMING NOTE: If we did not actually perform a read
; 3655 :        from the tuntap device in the logic above, then we need
; 3656 :        to do so here at this time. We were called for a reason.
; 3657 :        There are supposedly packets to be read but since we did
; 3658 :        not attempt to read any of them we need to do so at this
; 3659 :        time. Failure to do this causes ACTIVATE QUEUES to call
; 3660 :        us continuously, over and over and over again and again
; 3661 :        and again, because its 'select' function still indicates
; 3662 :        that the socket still has unread data waiting to be read.
; 3663 :     */
; 3664 :     if (!did_read && more_packets( dev ))

  005f9	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR did_read$[rsp], 0
  00601	0f 85 dd 01 00
	00		 jne	 $LN45@process_in
  00607	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0060f	e8 00 00 00 00	 call	 more_packets
  00614	0f b6 c0	 movzx	 eax, al
  00617	85 c0		 test	 eax, eax
  00619	0f 84 c5 01 00
	00		 je	 $LN45@process_in

; 3665 :     {
; 3666 :         char buff[4096];
; 3667 :         int packet_len = TUNTAP_Read( grp->ttfd, buff, sizeof( buff ));

  0061f	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00625	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buff$11[rsp]
  0062d	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  00632	8b 88 f8 05 00
	00		 mov	 ecx, DWORD PTR [rax+1528]
  00638	e8 00 00 00 00	 call	 tt32_read
  0063d	89 84 24 98 00
	00 00		 mov	 DWORD PTR packet_len$6[rsp], eax

; 3668 :         if (packet_len)

  00644	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR packet_len$6[rsp], 0
  0064c	0f 84 83 01 00
	00		 je	 $LN46@process_in

; 3669 :         {
; 3670 :             dev->qdio.dropcnt++;

  00652	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0065a	8b 80 30 13 00
	00		 mov	 eax, DWORD PTR [rax+4912]
  00660	ff c0		 inc	 eax
  00662	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0066a	89 81 30 13 00
	00		 mov	 DWORD PTR [rcx+4912], eax
$LN22@process_in:

; 3671 :             PTT_QETH_TRACE( "*prcinq drop", dev->qdio.i_qmask, 0, 0 );

  00670	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00677	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0067a	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00680	48 85 c0	 test	 rax, rax
  00683	74 44		 je	 SHORT $LN47@process_in
  00685	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0068d	8b 80 4c 14 00
	00		 mov	 eax, DWORD PTR [rax+5196]
  00693	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0069c	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  006a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173308
  006ac	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006b1	45 33 c9	 xor	 r9d, r9d
  006b4	44 8b c0	 mov	 r8d, eax
  006b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173309
  006be	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  006c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN47@process_in:
  006c9	33 c0		 xor	 eax, eax
  006cb	85 c0		 test	 eax, eax
  006cd	75 a1		 jne	 SHORT $LN22@process_in

; 3672 :             if (grp->debugmask & DBGQETHDROP)

  006cf	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  006d4	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  006da	83 e0 40	 and	 eax, 64			; 00000040H
  006dd	85 c0		 test	 eax, eax
  006df	0f 84 f0 00 00
	00		 je	 $LN48@process_in

; 3673 :             {
; 3674 :                 // "%1d:%04X %s: %s: Input dropped: %s"
; 3675 :                 WRMSG( HHC03810, "W", LCSS_DEVNUM,

  006e5	48 83 bc 24 f0
	10 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006ee	74 15		 je	 SHORT $LN51@process_in
  006f0	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006f8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006fc	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv321[rsp], eax
  00703	eb 0b		 jmp	 SHORT $LN52@process_in
$LN51@process_in:
  00705	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv321[rsp], 0
$LN52@process_in:
  00710	48 83 bc 24 f0
	10 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00719	74 17		 je	 SHORT $LN53@process_in
  0071b	48 8b 84 24 f0
	10 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00723	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00727	d1 f8		 sar	 eax, 1
  00729	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv327[rsp], eax
  00730	eb 0b		 jmp	 SHORT $LN54@process_in
$LN53@process_in:
  00732	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv327[rsp], 0
$LN54@process_in:
  0073d	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  00742	48 83 c0 60	 add	 rax, 96			; 00000060H
  00746	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv314[rsp], rax
  0074e	b9 01 00 00 00	 mov	 ecx, 1
  00753	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00759	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173311
  00760	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00765	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv314[rsp]
  0076d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00772	48 8b 8c 24 f0
	10 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0077a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0077e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00783	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv321[rsp]
  0078a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0078e	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv327[rsp]
  00795	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00799	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173312
  007a0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173313
  007ac	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  007b6	41 b9 03 00 00
	00		 mov	 r9d, 3
  007bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173314
  007c3	ba 5c 0e 00 00	 mov	 edx, 3676		; 00000e5cH
  007c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173315
  007cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN48@process_in:
$LN46@process_in:

; 3676 :                     dev->typname, grp->ttifname, "No available buffers" );
; 3677 :             }
; 3678 :         }
; 3679 :         /* No available/empty Input Queues were to be found */
; 3680 :         /* Wake up the program so it can process its queues */
; 3681 :         grp->iqPCI = TRUE;

  007d5	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  007da	c7 80 f0 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1520], 1
$LN45@process_in:
$LN25@process_in:

; 3682 :     }
; 3683 :     PTT_QETH_TRACE( "prinq exit", 0,0,0 );

  007e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  007eb	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007ee	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  007f4	48 85 c0	 test	 rax, rax
  007f7	74 36		 je	 SHORT $LN49@process_in
  007f9	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00802	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0080b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173317
  00812	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00817	45 33 c9	 xor	 r9d, r9d
  0081a	45 33 c0	 xor	 r8d, r8d
  0081d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173318
  00824	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00829	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN49@process_in:
  0082f	33 c0		 xor	 eax, eax
  00831	85 c0		 test	 eax, eax
  00833	75 af		 jne	 SHORT $LN25@process_in
$LN1@process_in:

; 3684 : }

  00835	48 8b 8c 24 d0
	10 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0083d	48 33 cc	 xor	 rcx, rsp
  00840	e8 00 00 00 00	 call	 __security_check_cookie
  00845	48 81 c4 e8 10
	00 00		 add	 rsp, 4328		; 000010e8H
  0084c	c3		 ret	 0
process_input_queues ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
hwEthernetType$ = 112
pktlen$ = 116
sb$ = 120
iTraceLen$ = 124
hdr_id$ = 128
qrc$ = 132
sblen$ = 136
pkt$ = 144
icmpv6$1 = 152
flag0$ = 153
length$2 = 156
tv228 = 160
hdrlen$ = 164
iPktVer$ = 168
hdr$ = 176
tv175 = 184
tv181 = 188
tv201 = 192
tv207 = 196
tv335 = 200
tv341 = 204
tv361 = 208
tv367 = 212
tv472 = 216
tv478 = 220
tv521 = 224
tv527 = 228
tv149 = 232
tv155 = 236
o3hdr$ = 240
tv353 = 248
tv193 = 252
ssb$ = 256
eth$ = 264
sba$ = 272
ip6$3 = 280
o2hdr$ = 288
tv328 = 296
tv457 = 304
tv506 = 312
cPktType$ = 320
__$ArrayPad$ = 328
dev$ = 352
grp$ = 360
sbal$ = 368
sbalk$ = 376
write_buffered_packets PROC

; 3286 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3287 :     U64 sba;                            /* Storage Block Address     */
; 3288 :     BYTE* hdr;                          /* Ptr to OSA packet header  */
; 3289 :     OSA_HDR2* o2hdr;                    /* Ptr to OSA layer2 header  */
; 3290 :     OSA_HDR3* o3hdr;                    /* Ptr to OSA layer3 header  */
; 3291 :     BYTE* pkt;                          /* Ptr to packet or frame    */
; 3292 :     U32 sblen;                          /* Length of Storage Block   */
; 3293 :     int hdrlen;                         /* Length of OSA header      */
; 3294 :     int pktlen;                         /* Packet or frame length    */
; 3295 :     int sb;                             /* Storage Block number      */
; 3296 :     int ssb;                            /* Starting Storage Block    */
; 3297 :     QRC qrc;                            /* Internal return code      */
; 3298 :     BYTE hdr_id;                        /* OSA Header Block Id       */
; 3299 :     BYTE flag0;                         /* Storage Block Flag        */
; 3300 : 
; 3301 :     ETHFRM* eth;                        /* Ethernet frame header     */
; 3302 :     U16  hwEthernetType;
; 3303 :     int iPktVer;
; 3304 :     int iTraceLen;
; 3305 :     char cPktType[8];
; 3306 : 
; 3307 : 
; 3308 :     sb = 0;                             /* Start w/Storage Block 0   */

  0002d	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR sb$[rsp], 0
$LN4@write_buff:

; 3309 : 
; 3310 :     do
; 3311 :     {
; 3312 :         /* Save starting Storage Block number */
; 3313 :         ssb = sb;

  00035	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  00039	89 84 24 00 01
	00 00		 mov	 DWORD PTR ssb$[rsp], eax

; 3314 : 
; 3315 :         /* Retrieve the (next) Storage Block and check its key */
; 3316 :         FETCH_DW( sba,   sbal->sbale[sb].addr   );

  00040	48 63 44 24 78	 movsxd	 rax, DWORD PTR sb$[rsp]
  00045	48 6b c0 10	 imul	 rax, rax, 16
  00049	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  00051	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00056	48 8b c8	 mov	 rcx, rax
  00059	e8 00 00 00 00	 call	 fetch_dw_noswap
  0005e	48 8b c8	 mov	 rcx, rax
  00061	e8 00 00 00 00	 call	 _byteswap_uint64
  00066	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR sba$[rsp], rax

; 3317 :         FETCH_FW( sblen, sbal->sbale[sb].length );

  0006e	48 63 44 24 78	 movsxd	 rax, DWORD PTR sb$[rsp]
  00073	48 6b c0 10	 imul	 rax, rax, 16
  00077	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  0007f	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00084	48 8b c8	 mov	 rcx, rax
  00087	e8 00 00 00 00	 call	 fetch_fw_noswap
  0008c	8b c8		 mov	 ecx, eax
  0008e	e8 00 00 00 00	 call	 _byteswap_ulong
  00093	89 84 24 88 00
	00 00		 mov	 DWORD PTR sblen$[rsp], eax

; 3318 :         if (!sblen)

  0009a	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR sblen$[rsp], 0
  000a2	75 39		 jne	 SHORT $LN7@write_buff

; 3319 :             return SBALE_ERROR( QRC_EZEROBLK, dev,sbal,sbalk,sb);

  000a4	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  000a8	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000ac	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  000b4	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  000b8	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  000c0	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000c8	66 ba f9 ff	 mov	 dx, -7
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173095
  000d3	e8 00 00 00 00	 call	 SBALE_Error
  000d8	e9 98 0f 00 00	 jmp	 $LN1@write_buff
$LN7@write_buff:

; 3320 :         if (STORCHK( sba, sblen-1, sbalk, STORKEY_REF, dev ))

  000dd	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  000e5	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR sblen$[rsp]
  000ec	ff c9		 dec	 ecx
  000ee	8b c9		 mov	 ecx, ecx
  000f0	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000f8	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000fd	41 b9 04 00 00
	00		 mov	 r9d, 4
  00103	44 8b c0	 mov	 r8d, eax
  00106	8b d1		 mov	 edx, ecx
  00108	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR sba$[rsp]
  00110	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  00115	85 c0		 test	 eax, eax
  00117	74 39		 je	 SHORT $LN8@write_buff

; 3321 :             return SBALE_ERROR( QRC_ESTORCHK, dev,sbal,sbalk,sb);

  00119	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  0011d	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00121	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  00129	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0012d	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  00135	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0013d	66 ba fe ff	 mov	 dx, -2
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173097
  00148	e8 00 00 00 00	 call	 SBALE_Error
  0014d	e9 23 0f 00 00	 jmp	 $LN1@write_buff
$LN8@write_buff:

; 3322 : 
; 3323 :         /* Get pointer to OSA header */
; 3324 :         hdr = (BYTE*)(dev->mainstor + sba);

  00152	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015a	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00161	48 03 84 24 10
	01 00 00	 add	 rax, QWORD PTR sba$[rsp]
  00169	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR hdr$[rsp], rax

; 3325 : 
; 3326 :         /* Verify Block is long enough to hold the full OSA header.
; 3327 :            FIXME: there is nothing in the specs that requires the
; 3328 :            header to not span multiple Storage Blocks so we should
; 3329 :            should probably support it, but at the moment we do not. */
; 3330 :         if (sblen < max(sizeof(OSA_HDR2),sizeof(OSA_HDR3)))

  00171	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sblen$[rsp]
  00178	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  0017c	0f 83 d2 00 00
	00		 jae	 $LN9@write_buff

; 3331 :             WRMSG( HHC03983, "W", LCSS_DEVNUM,

  00182	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0018b	74 15		 je	 SHORT $LN50@write_buff
  0018d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00195	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00199	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv149[rsp], eax
  001a0	eb 0b		 jmp	 SHORT $LN51@write_buff
$LN50@write_buff:
  001a2	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv149[rsp], 0
$LN51@write_buff:
  001ad	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001b6	74 17		 je	 SHORT $LN52@write_buff
  001b8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001c4	d1 f8		 sar	 eax, 1
  001c6	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv155[rsp], eax
  001cd	eb 0b		 jmp	 SHORT $LN53@write_buff
$LN52@write_buff:
  001cf	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv155[rsp], 0
$LN53@write_buff:
  001da	b9 01 00 00 00	 mov	 ecx, 1
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173099
  001ec	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001f1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f9	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001fd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00202	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv149[rsp]
  00209	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0020d	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv155[rsp]
  00214	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173100
  0021f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173101
  0022b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00230	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00235	41 b9 03 00 00
	00		 mov	 r9d, 3
  0023b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173102
  00242	ba 04 0d 00 00	 mov	 edx, 3332		; 00000d04H
  00247	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173103
  0024e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@write_buff:

; 3332 :                 dev->typname, "** FIXME ** OSA_HDR spans multiple storage blocks." );
; 3333 : 
; 3334 :         /* Debugging */
; 3335 :         if (grp->debugmask & DBGQETHDATA)

  00254	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0025c	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00262	83 e0 02	 and	 eax, 2
  00265	85 c0		 test	 eax, eax
  00267	0f 84 14 02 00
	00		 je	 $LN10@write_buff

; 3336 :         {
; 3337 :           iTraceLen = sblen;

  0026d	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sblen$[rsp]
  00274	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 3338 : 
; 3339 :           // HHC00981 "%1d:%04X %s: Accept data of size %d bytes from guest"
; 3340 :           WRMSG(HHC00981, "D", LCSS_DEVNUM, dev->typname, iTraceLen);

  00278	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00281	74 15		 je	 SHORT $LN54@write_buff
  00283	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0028b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0028f	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv175[rsp], eax
  00296	eb 0b		 jmp	 SHORT $LN55@write_buff
$LN54@write_buff:
  00298	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
$LN55@write_buff:
  002a3	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ac	74 17		 je	 SHORT $LN56@write_buff
  002ae	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002ba	d1 f8		 sar	 eax, 1
  002bc	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
  002c3	eb 0b		 jmp	 SHORT $LN57@write_buff
$LN56@write_buff:
  002c5	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
$LN57@write_buff:
  002d0	b9 01 00 00 00	 mov	 ecx, 1
  002d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002db	8b 4c 24 7c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  002df	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  002e3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002eb	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002ef	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002f4	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv175[rsp]
  002fb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002ff	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv181[rsp]
  00306	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0030a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173105
  00311	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00316	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173106
  0031d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00322	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00327	41 b9 03 00 00
	00		 mov	 r9d, 3
  0032d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173107
  00334	ba 0c 0d 00 00	 mov	 edx, 3340		; 00000d0cH
  00339	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173108
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3341 :           if (iTraceLen > 256)

  00346	81 7c 24 7c 00
	01 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H
  0034e	0f 8e f7 00 00
	00		 jle	 $LN11@write_buff

; 3342 :           {
; 3343 :             iTraceLen = 256;

  00354	c7 44 24 7c 00
	01 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 256 ; 00000100H

; 3344 :             // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 3345 :             WRMSG(HHC00980, "D", LCSS_DEVNUM, dev->typname,

  0035c	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00365	74 15		 je	 SHORT $LN58@write_buff
  00367	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0036f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00373	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  0037a	eb 0b		 jmp	 SHORT $LN59@write_buff
$LN58@write_buff:
  0037c	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv201[rsp], 0
$LN59@write_buff:
  00387	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00390	74 17		 je	 SHORT $LN60@write_buff
  00392	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0039a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0039e	d1 f8		 sar	 eax, 1
  003a0	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv207[rsp], eax
  003a7	eb 0b		 jmp	 SHORT $LN61@write_buff
$LN60@write_buff:
  003a9	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv207[rsp], 0
$LN61@write_buff:
  003b4	8b 44 24 7c	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  003b8	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR sblen$[rsp]
  003bf	2b c8		 sub	 ecx, eax
  003c1	8b c1		 mov	 eax, ecx
  003c3	89 84 24 fc 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
  003ca	b9 01 00 00 00	 mov	 ecx, 1
  003cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003d5	8b 8c 24 fc 00
	00 00		 mov	 ecx, DWORD PTR tv193[rsp]
  003dc	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  003e0	8b 4c 24 7c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  003e4	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  003e8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003f0	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  003f4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003f9	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv201[rsp]
  00400	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00404	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv207[rsp]
  0040b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0040f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173110
  00416	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0041b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173111
  00422	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00427	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0042c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00432	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173112
  00439	ba 12 0d 00 00	 mov	 edx, 3346		; 00000d12H
  0043e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173113
  00445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN11@write_buff:

; 3346 :                                  iTraceLen, (sblen - iTraceLen) );
; 3347 :           }
; 3348 :           net_data_trace( dev, hdr, iTraceLen, FROM_GUEST, 'D', "data", 0 );

  0044b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00453	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173114
  0045a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0045f	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00464	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00467	44 8b 44 24 7c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  0046c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR hdr$[rsp]
  00474	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0047c	e8 00 00 00 00	 call	 net_data_trace
$LN10@write_buff:

; 3349 :         }
; 3350 : 
; 3351 :         /* Determine if Layer 2 Ethernet frame or Layer 3 IP packet */
; 3352 :         hdr_id = hdr[0];

  00481	b8 01 00 00 00	 mov	 eax, 1
  00486	48 6b c0 00	 imul	 rax, rax, 0
  0048a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdr$[rsp]
  00492	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00496	88 84 24 80 00
	00 00		 mov	 BYTE PTR hdr_id$[rsp], al

; 3353 :         switch (hdr_id)

  0049d	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR hdr_id$[rsp]
  004a5	88 84 24 a0 00
	00 00		 mov	 BYTE PTR tv228[rsp], al
  004ac	80 bc 24 a0 00
	00 00 01	 cmp	 BYTE PTR tv228[rsp], 1
  004b4	0f 84 99 00 00
	00		 je	 $LN13@write_buff
  004ba	80 bc 24 a0 00
	00 00 02	 cmp	 BYTE PTR tv228[rsp], 2
  004c2	74 21		 je	 SHORT $LN12@write_buff
  004c4	80 bc 24 a0 00
	00 00 03	 cmp	 BYTE PTR tv228[rsp], 3
  004cc	0f 84 ec 00 00
	00		 je	 $LN14@write_buff
  004d2	80 bc 24 a0 00
	00 00 04	 cmp	 BYTE PTR tv228[rsp], 4
  004da	0f 84 de 00 00
	00		 je	 $LN15@write_buff
  004e0	e9 d9 00 00 00	 jmp	 $LN16@write_buff
$LN12@write_buff:

; 3354 :         {
; 3355 :         U16 length;
; 3356 :         case HDR_ID_LAYER2:
; 3357 :         {
; 3358 :          /* ETHFRM* eth; */
; 3359 :             o2hdr = (OSA_HDR2*)hdr;

  004e5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  004ed	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR o2hdr$[rsp], rax

; 3360 :             hdrlen = sizeof(OSA_HDR2);

  004f5	c7 84 24 a4 00
	00 00 20 00 00
	00		 mov	 DWORD PTR hdrlen$[rsp], 32 ; 00000020H

; 3361 :             pkt = hdr + hdrlen;

  00500	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR hdrlen$[rsp]
  00508	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdr$[rsp]
  00510	48 03 c8	 add	 rcx, rax
  00513	48 8b c1	 mov	 rax, rcx
  00516	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pkt$[rsp], rax

; 3362 :             FETCH_HW( length, o2hdr->pktlen );

  0051e	48 8b 84 24 20
	01 00 00	 mov	 rax, QWORD PTR o2hdr$[rsp]
  00526	48 83 c0 06	 add	 rax, 6
  0052a	48 8b c8	 mov	 rcx, rax
  0052d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00532	0f b7 c8	 movzx	 ecx, ax
  00535	e8 00 00 00 00	 call	 _byteswap_ushort
  0053a	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR length$2[rsp], ax

; 3363 :             pktlen = length;

  00542	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR length$2[rsp]
  0054a	89 44 24 74	 mov	 DWORD PTR pktlen$[rsp], eax

; 3364 :          /* eth = (ETHFRM*)pkt; */
; 3365 :             break;

  0054e	e9 a4 00 00 00	 jmp	 $LN5@write_buff
$LN13@write_buff:

; 3366 :         }
; 3367 :         case HDR_ID_LAYER3:
; 3368 :         {
; 3369 :             o3hdr = (OSA_HDR3*)hdr;

  00553	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0055b	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR o3hdr$[rsp], rax

; 3370 :             hdrlen = sizeof(OSA_HDR3);

  00563	c7 84 24 a4 00
	00 00 20 00 00
	00		 mov	 DWORD PTR hdrlen$[rsp], 32 ; 00000020H

; 3371 :             pkt = hdr + hdrlen;

  0056e	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR hdrlen$[rsp]
  00576	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR hdr$[rsp]
  0057e	48 03 c8	 add	 rcx, rax
  00581	48 8b c1	 mov	 rax, rcx
  00584	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pkt$[rsp], rax

; 3372 :             FETCH_HW( length, o3hdr->length );

  0058c	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR o3hdr$[rsp]
  00594	48 83 c0 08	 add	 rax, 8
  00598	48 8b c8	 mov	 rcx, rax
  0059b	e8 00 00 00 00	 call	 fetch_hw_noswap
  005a0	0f b7 c8	 movzx	 ecx, ax
  005a3	e8 00 00 00 00	 call	 _byteswap_ushort
  005a8	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR length$2[rsp], ax

; 3373 :             pktlen = length;

  005b0	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR length$2[rsp]
  005b8	89 44 24 74	 mov	 DWORD PTR pktlen$[rsp], eax

; 3374 :             break;

  005bc	eb 39		 jmp	 SHORT $LN5@write_buff
$LN14@write_buff:
$LN15@write_buff:
$LN16@write_buff:

; 3375 :         }
; 3376 :         case HDR_ID_TSO:
; 3377 :         case HDR_ID_OSN:
; 3378 :         default:
; 3379 :             return SBALE_ERROR( QRC_EPKTYP, dev,sbal,sbalk,sb);

  005be	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  005c2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  005c6	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  005ce	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  005d2	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  005da	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  005e2	66 ba fb ff	 mov	 dx, -5
  005e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173120
  005ed	e8 00 00 00 00	 call	 SBALE_Error
  005f2	e9 7e 0a 00 00	 jmp	 $LN1@write_buff
$LN5@write_buff:

; 3380 :         }
; 3381 : 
; 3382 : 
; 3383 :         /* Make sure the packet/frame fits in the device buffer */
; 3384 :         if (pktlen > dev->bufsize)

  005f7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ff	8b 80 d8 01 00
	00		 mov	 eax, DWORD PTR [rax+472]
  00605	39 44 24 74	 cmp	 DWORD PTR pktlen$[rsp], eax
  00609	7e 39		 jle	 SHORT $LN17@write_buff

; 3385 :             return SBALE_ERROR( QRC_EPKSIZ, dev,sbal,sbalk,sb);

  0060b	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  0060f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00613	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  0061b	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0061f	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  00627	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  0062f	66 ba fa ff	 mov	 dx, -6
  00633	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173122
  0063a	e8 00 00 00 00	 call	 SBALE_Error
  0063f	e9 31 0a 00 00	 jmp	 $LN1@write_buff
$LN17@write_buff:

; 3386 : 
; 3387 :         /* Copy the actual packet/frame into the device buffer */
; 3388 :         sblen -= hdrlen;

  00644	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR hdrlen$[rsp]
  0064b	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR sblen$[rsp]
  00652	2b c8		 sub	 ecx, eax
  00654	8b c1		 mov	 eax, ecx
  00656	89 84 24 88 00
	00 00		 mov	 DWORD PTR sblen$[rsp], eax

; 3389 :         dev->bufres = pktlen;

  0065d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00665	8b 4c 24 74	 mov	 ecx, DWORD PTR pktlen$[rsp]
  00669	89 88 e4 01 00
	00		 mov	 DWORD PTR [rax+484], ecx

; 3390 :         dev->buflen = 0;

  0066f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00677	c7 80 dc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+476], 0

; 3391 : 
; 3392 :         if ((qrc = copy_storage_fragments( dev, grp, sbal, sbalk,
; 3393 :                                            &sb, pkt, sblen )) < 0)

  00681	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR sblen$[rsp]
  00688	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0068c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pkt$[rsp]
  00694	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00699	48 8d 44 24 78	 lea	 rax, QWORD PTR sb$[rsp]
  0069e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006a3	44 0f b6 8c 24
	78 01 00 00	 movzx	 r9d, BYTE PTR sbalk$[rsp]
  006ac	4c 8b 84 24 70
	01 00 00	 mov	 r8, QWORD PTR sbal$[rsp]
  006b4	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  006bc	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006c4	e8 00 00 00 00	 call	 copy_storage_fragments
  006c9	66 89 84 24 84
	00 00 00	 mov	 WORD PTR qrc$[rsp], ax
  006d1	0f bf 84 24 84
	00 00 00	 movsx	 eax, WORD PTR qrc$[rsp]
  006d9	85 c0		 test	 eax, eax
  006db	7d 0d		 jge	 SHORT $LN18@write_buff

; 3394 :             return qrc;

  006dd	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR qrc$[rsp]
  006e5	e9 8b 09 00 00	 jmp	 $LN1@write_buff
$LN18@write_buff:

; 3395 : 
; 3396 :         /* Save ending flag */
; 3397 :         flag0 = sbal->sbale[sb].flags[0];

  006ea	48 63 44 24 78	 movsxd	 rax, DWORD PTR sb$[rsp]
  006ef	48 6b c0 10	 imul	 rax, rax, 16
  006f3	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  006fb	48 03 c8	 add	 rcx, rax
  006fe	48 8b c1	 mov	 rax, rcx
  00701	b9 01 00 00 00	 mov	 ecx, 1
  00706	48 6b c9 00	 imul	 rcx, rcx, 0
  0070a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0070e	88 84 24 99 00
	00 00		 mov	 BYTE PTR flag0$[rsp], al

; 3398 : 
; 3399 :         /* Trace the pack/frame if debugging is enabled */
; 3400 :         if (grp->debugmask & DBGQETHSBALE)

  00715	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0071d	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00723	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00728	85 c0		 test	 eax, eax
  0072a	74 63		 je	 SHORT $LN19@write_buff

; 3401 :             DBGTRC( dev, "Output SBALE(%d-%d): Len: %04X (%d)",

  0072c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00734	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  0073a	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0073e	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00746	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  0074c	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00750	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  00754	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00758	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR ssb$[rsp]
  0075f	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00763	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173125
  0076a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0076f	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00777	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173126
  0077e	ba 4a 0d 00 00	 mov	 edx, 3402		; 00000d4aH
  00783	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173127
  0078a	e8 00 00 00 00	 call	 dbgtrc
$LN19@write_buff:

; 3402 :                 ssb, sb, dev->buflen, dev->buflen );
; 3403 : 
; 3404 :         /* Initialize packet pointer and packet length */
; 3405 :         pkt    = dev->buf;

  0078f	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00797	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  0079e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pkt$[rsp], rax

; 3406 :         pktlen = dev->buflen;

  007a6	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007ae	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  007b4	89 44 24 74	 mov	 DWORD PTR pktlen$[rsp], eax

; 3407 : 
; 3408 :         /* I know the following looks pretty weird but it seems to be         */
; 3409 :         /* necessary when using IPv6 over layer 3. IPv6 uses ICMPv6 Neighbor  */
; 3410 :         /* Solicitation (NS) & Neighbor Advertisment (NA) to determine the    */
; 3411 :         /* link layer address (i.e. Ethernet MAC) for an IPv6 address. When   */
; 3412 :         /* the guest sends out a NS, this function sends the packet over the  */
; 3413 :         /* tun to the host, whereupon the host duly ignores the packet. Hence */
; 3414 :         /* this function, and function process_l3_icmpv6_packet, responds to  */
; 3415 :         /* the NS with a NA. It seems that the NA must contain a link local   */
; 3416 :         /* address, otherwise the guest ignores the packet. However, after    */
; 3417 :         /* the guest has received an NA with a link local address every IPv6  */
; 3418 :         /* packet from the guest is an Ethernet frame containing the IPv6     */
; 3419 :         /* packet. Perhaps that's how OSD's actually work? IPv6 packets to    */
; 3420 :         /* the guest don't need to be Ethernet frames.                        */
; 3421 :         /*                                                                    */
; 3422 :         /* Originally the whole of this section was surrounded by             */
; 3423 :         /* '#if defined(ENABLE_IPV6)'/'#endif'. However, implementing zLinux  */
; 3424 :         /* layer 3 support showed that zLinux emmitted IPv4 ARP frames, which */
; 3425 :         /* if sent to the tun interface upset the tun. Subsequent exposure to */
; 3426 :         /* layer 3 VSWITCH prompted a revamp to make checks less specific.    */
; 3427 :         /*                                                                    */
; 3428 :         if (hdr_id == HDR_ID_LAYER3)

  007b8	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR hdr_id$[rsp]
  007c0	83 f8 01	 cmp	 eax, 1
  007c3	0f 85 3c 03 00
	00		 jne	 $LN20@write_buff

; 3429 :         {
; 3430 :             /* Might this be a L2 Ethernet Frame? (and not an L3 IP packet?)  */
; 3431 :             o3hdr = (OSA_HDR3*)hdr;

  007c9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  007d1	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR o3hdr$[rsp], rax

; 3432 :             if (o3hdr->flags & HDR3_FLAGS_PASSTHRU)

  007d9	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR o3hdr$[rsp]
  007e1	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  007e5	83 e0 10	 and	 eax, 16
  007e8	85 c0		 test	 eax, eax
  007ea	0f 84 15 03 00
	00		 je	 $LN21@write_buff

; 3433 :             {
; 3434 :                 eth = (ETHFRM*)pkt;

  007f0	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pkt$[rsp]
  007f8	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR eth$[rsp], rax

; 3435 :                 FETCH_HW( hwEthernetType, eth->hwEthernetType );

  00800	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR eth$[rsp]
  00808	48 83 c0 0c	 add	 rax, 12
  0080c	48 8b c8	 mov	 rcx, rax
  0080f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00814	0f b7 c8	 movzx	 ecx, ax
  00817	e8 00 00 00 00	 call	 _byteswap_ushort
  0081c	66 89 44 24 70	 mov	 WORD PTR hwEthernetType$[rsp], ax

; 3436 :                 /* */
; 3437 :                 if (!(o3hdr->flags & HDR3_FLAGS_IPV6))

  00821	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR o3hdr$[rsp]
  00829	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0082d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00832	85 c0		 test	 eax, eax
  00834	0f 85 7f 02 00
	00		 jne	 $LN22@write_buff

; 3438 :                 {
; 3439 :                     /* It probably is an L2 Ethernet Frame! */
; 3440 :                     if (hwEthernetType != ETH_TYPE_IP)

  0083a	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  0083f	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00844	0f 84 6f 02 00
	00		 je	 $LN23@write_buff

; 3441 :                     {
; 3442 :                         /* Can't write L2 Ethernet frame to L3 tun device! */
; 3443 :                         dev->qdio.dropcnt++;

  0084a	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00852	8b 80 30 13 00
	00		 mov	 eax, DWORD PTR [rax+4912]
  00858	ff c0		 inc	 eax
  0085a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00862	89 81 30 13 00
	00		 mov	 DWORD PTR [rcx+4912], eax

; 3444 :                         if (grp->debugmask & DBGQETHDROP)

  00868	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00870	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00876	83 e0 40	 and	 eax, 64			; 00000040H
  00879	85 c0		 test	 eax, eax
  0087b	0f 84 33 02 00
	00		 je	 $LN24@write_buff

; 3445 :                         {
; 3446 :                             // "%1d:%04X %s: %s: Output dropped: %s"
; 3447 :                             WRMSG( HHC03811, "W", LCSS_DEVNUM,

  00881	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0088a	74 15		 je	 SHORT $LN62@write_buff
  0088c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00894	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00898	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv335[rsp], eax
  0089f	eb 0b		 jmp	 SHORT $LN63@write_buff
$LN62@write_buff:
  008a1	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv335[rsp], 0
$LN63@write_buff:
  008ac	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008b5	74 17		 je	 SHORT $LN64@write_buff
  008b7	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008bf	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  008c3	d1 f8		 sar	 eax, 1
  008c5	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv341[rsp], eax
  008cc	eb 0b		 jmp	 SHORT $LN65@write_buff
$LN64@write_buff:
  008ce	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv341[rsp], 0
$LN65@write_buff:
  008d9	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  008e1	48 83 c0 60	 add	 rax, 96			; 00000060H
  008e5	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv328[rsp], rax
  008ed	b9 01 00 00 00	 mov	 ecx, 1
  008f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173133
  008ff	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00904	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv328[rsp]
  0090c	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00911	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00919	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0091d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00922	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv335[rsp]
  00929	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0092d	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv341[rsp]
  00934	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00938	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173134
  0093f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00944	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173135
  0094b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00950	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00955	41 b9 03 00 00
	00		 mov	 r9d, 3
  0095b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173136
  00962	ba 78 0d 00 00	 mov	 edx, 3448		; 00000d78H
  00967	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173137
  0096e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3448 :                                 dev->typname, grp->ttifname, "L2 frame on tun device" );
; 3449 :                             iTraceLen = pktlen;

  00974	8b 44 24 74	 mov	 eax, DWORD PTR pktlen$[rsp]
  00978	89 44 24 7c	 mov	 DWORD PTR iTraceLen$[rsp], eax

; 3450 :                             if (iTraceLen > 128)

  0097c	81 7c 24 7c 80
	00 00 00	 cmp	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H
  00984	0f 8e f4 00 00
	00		 jle	 $LN25@write_buff

; 3451 :                             {
; 3452 :                               iTraceLen = 128;

  0098a	c7 44 24 7c 80
	00 00 00	 mov	 DWORD PTR iTraceLen$[rsp], 128 ; 00000080H

; 3453 :                               // HHC00980 "%1d:%04X %s: Data of size %d bytes displayed, data of size %d bytes not displayed"
; 3454 :                               WRMSG(HHC00980, "D", LCSS_DEVNUM, dev->typname,

  00992	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0099b	74 15		 je	 SHORT $LN66@write_buff
  0099d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009a5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  009a9	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv361[rsp], eax
  009b0	eb 0b		 jmp	 SHORT $LN67@write_buff
$LN66@write_buff:
  009b2	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv361[rsp], 0
$LN67@write_buff:
  009bd	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  009c6	74 17		 je	 SHORT $LN68@write_buff
  009c8	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009d0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  009d4	d1 f8		 sar	 eax, 1
  009d6	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv367[rsp], eax
  009dd	eb 0b		 jmp	 SHORT $LN69@write_buff
$LN68@write_buff:
  009df	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv367[rsp], 0
$LN69@write_buff:
  009ea	8b 44 24 7c	 mov	 eax, DWORD PTR iTraceLen$[rsp]
  009ee	8b 4c 24 74	 mov	 ecx, DWORD PTR pktlen$[rsp]
  009f2	2b c8		 sub	 ecx, eax
  009f4	8b c1		 mov	 eax, ecx
  009f6	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tv353[rsp], eax
  009fd	b9 01 00 00 00	 mov	 ecx, 1
  00a02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a08	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR tv353[rsp]
  00a0f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00a13	8b 4c 24 7c	 mov	 ecx, DWORD PTR iTraceLen$[rsp]
  00a17	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00a1b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a23	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00a27	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a2c	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv361[rsp]
  00a33	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a37	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv367[rsp]
  00a3e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a42	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173139
  00a49	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a4e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173140
  00a55	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a5a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a5f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a65	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173141
  00a6c	ba 7f 0d 00 00	 mov	 edx, 3455		; 00000d7fH
  00a71	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173142
  00a78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN25@write_buff:

; 3455 :                                                    iTraceLen, (pktlen - iTraceLen) );
; 3456 :                             }
; 3457 :                             net_data_trace( dev, pkt, iTraceLen, FROM_GUEST, 'D', "drop", 0 );

  00a7e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00a86	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173143
  00a8d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a92	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00a97	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00a9a	44 8b 44 24 7c	 mov	 r8d, DWORD PTR iTraceLen$[rsp]
  00a9f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pkt$[rsp]
  00aa7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00aaf	e8 00 00 00 00	 call	 net_data_trace
$LN24@write_buff:

; 3458 :                         }
; 3459 :                         continue; /* (don't write this, probably ARP, packet) */

  00ab4	e9 45 05 00 00	 jmp	 $LN2@write_buff
$LN23@write_buff:
$LN22@write_buff:

; 3460 :                     }
; 3461 :                 }
; 3462 :                 /* Bump past L2 Ethernet header to actual L3 IP packet */
; 3463 :                 pkt += sizeof(ETHFRM);

  00ab9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pkt$[rsp]
  00ac1	48 83 c0 0e	 add	 rax, 14
  00ac5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pkt$[rsp], rax

; 3464 :                 pktlen -= sizeof(ETHFRM);

  00acd	48 63 44 24 74	 movsxd	 rax, DWORD PTR pktlen$[rsp]
  00ad2	48 83 e8 0e	 sub	 rax, 14
  00ad6	89 44 24 74	 mov	 DWORD PTR pktlen$[rsp], eax

; 3465 :                 /* Bump past 802.1Q header to actual L3 IP packet */
; 3466 :                 if (hwEthernetType == ETH_TYPE_VLANTAG)

  00ada	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00adf	3d 00 81 00 00	 cmp	 eax, 33024		; 00008100H
  00ae4	75 1f		 jne	 SHORT $LN26@write_buff

; 3467 :                 {
; 3468 :                     pkt += 4;

  00ae6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pkt$[rsp]
  00aee	48 83 c0 04	 add	 rax, 4
  00af2	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pkt$[rsp], rax

; 3469 :                     pktlen -= 4;

  00afa	8b 44 24 74	 mov	 eax, DWORD PTR pktlen$[rsp]
  00afe	83 e8 04	 sub	 eax, 4
  00b01	89 44 24 74	 mov	 DWORD PTR pktlen$[rsp], eax
$LN26@write_buff:
$LN21@write_buff:
$LN20@write_buff:

; 3470 :                 }
; 3471 :             }
; 3472 :         }
; 3473 : 
; 3474 :         /* Debugging */
; 3475 :         if (grp->debugmask & DBGQETHPACKET)

  00b05	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00b0d	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00b13	83 e0 01	 and	 eax, 1
  00b16	85 c0		 test	 eax, eax
  00b18	0f 84 2a 04 00
	00		 je	 $LN27@write_buff

; 3476 :         {
; 3477 :             if (!grp->l3)

  00b1e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00b26	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00b2d	0f 85 56 02 00
	00		 jne	 $LN28@write_buff

; 3478 :             {
; 3479 :                 eth = (ETHFRM*) pkt;

  00b33	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pkt$[rsp]
  00b3b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR eth$[rsp], rax

; 3480 :                 FETCH_HW( hwEthernetType, eth->hwEthernetType );

  00b43	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR eth$[rsp]
  00b4b	48 83 c0 0c	 add	 rax, 12
  00b4f	48 8b c8	 mov	 rcx, rax
  00b52	e8 00 00 00 00	 call	 fetch_hw_noswap
  00b57	0f b7 c8	 movzx	 ecx, ax
  00b5a	e8 00 00 00 00	 call	 _byteswap_ushort
  00b5f	66 89 44 24 70	 mov	 WORD PTR hwEthernetType$[rsp], ax

; 3481 : 
; 3482 :                      if (ETH_TYPE_IP   == hwEthernetType) STRLCPY( cPktType, "IPv4"    );

  00b64	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00b69	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  00b6e	75 20		 jne	 SHORT $LN30@write_buff
  00b70	41 b8 08 00 00
	00		 mov	 r8d, 8
  00b76	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173150
  00b7d	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00b85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00b8b	e9 c2 00 00 00	 jmp	 $LN31@write_buff
$LN30@write_buff:

; 3483 :                 else if (ETH_TYPE_IPV6 == hwEthernetType) STRLCPY( cPktType, "IPv6"    );

  00b90	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00b95	3d dd 86 00 00	 cmp	 eax, 34525		; 000086ddH
  00b9a	75 20		 jne	 SHORT $LN32@write_buff
  00b9c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00ba2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173153
  00ba9	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00bb1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00bb7	e9 96 00 00 00	 jmp	 $LN33@write_buff
$LN32@write_buff:

; 3484 :                 else if (ETH_TYPE_ARP  == hwEthernetType) STRLCPY( cPktType, "ARP"     );

  00bbc	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00bc1	3d 06 08 00 00	 cmp	 eax, 2054		; 00000806H
  00bc6	75 1d		 jne	 SHORT $LN34@write_buff
  00bc8	41 b8 08 00 00
	00		 mov	 r8d, 8
  00bce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173156
  00bd5	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00bdd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00be3	eb 6d		 jmp	 SHORT $LN35@write_buff
$LN34@write_buff:

; 3485 :                 else if (ETH_TYPE_RARP == hwEthernetType) STRLCPY( cPktType, "RARP"    );

  00be5	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00bea	3d 35 80 00 00	 cmp	 eax, 32821		; 00008035H
  00bef	75 1d		 jne	 SHORT $LN36@write_buff
  00bf1	41 b8 08 00 00
	00		 mov	 r8d, 8
  00bf7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173159
  00bfe	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00c06	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00c0c	eb 44		 jmp	 SHORT $LN37@write_buff
$LN36@write_buff:

; 3486 :                 else if (ETH_TYPE_SNA  == hwEthernetType) STRLCPY( cPktType, "SNA"     );

  00c0e	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00c13	3d d5 80 00 00	 cmp	 eax, 32981		; 000080d5H
  00c18	75 1d		 jne	 SHORT $LN38@write_buff
  00c1a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00c20	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173162
  00c27	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00c2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00c35	eb 1b		 jmp	 SHORT $LN39@write_buff
$LN38@write_buff:

; 3487 :                 else                                      STRLCPY( cPktType, "unknown" );

  00c37	41 b8 08 00 00
	00		 mov	 r8d, 8
  00c3d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173163
  00c44	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00c4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN39@write_buff:
$LN37@write_buff:
$LN35@write_buff:
$LN33@write_buff:
$LN31@write_buff:

; 3488 : 
; 3489 :                 // HHC00985 "%1d:%04X %s: Send frame of size %d bytes (with %s packet) to device %s"
; 3490 :                 WRMSG(HHC00985, "D", LCSS_DEVNUM, dev->typname,

  00c52	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c5b	74 15		 je	 SHORT $LN70@write_buff
  00c5d	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c65	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00c69	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv472[rsp], eax
  00c70	eb 0b		 jmp	 SHORT $LN71@write_buff
$LN70@write_buff:
  00c72	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv472[rsp], 0
$LN71@write_buff:
  00c7d	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00c86	74 17		 je	 SHORT $LN72@write_buff
  00c88	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c90	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00c94	d1 f8		 sar	 eax, 1
  00c96	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv478[rsp], eax
  00c9d	eb 0b		 jmp	 SHORT $LN73@write_buff
$LN72@write_buff:
  00c9f	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv478[rsp], 0
$LN73@write_buff:
  00caa	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00cb2	48 83 c0 60	 add	 rax, 96			; 00000060H
  00cb6	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv457[rsp], rax
  00cbe	b9 01 00 00 00	 mov	 ecx, 1
  00cc3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00cc9	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv457[rsp]
  00cd1	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00cd6	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00cde	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ce3	8b 4c 24 74	 mov	 ecx, DWORD PTR pktlen$[rsp]
  00ce7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00ceb	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cf3	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00cf7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cfc	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv472[rsp]
  00d03	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d07	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv478[rsp]
  00d0e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173164
  00d19	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173165
  00d25	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d2a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d2f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d35	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173166
  00d3c	ba a3 0d 00 00	 mov	 edx, 3491		; 00000da3H
  00d41	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173167
  00d48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3491 :                                      pktlen, cPktType, grp->ttifname );
; 3492 :                 net_data_trace( dev, pkt, pktlen, FROM_GUEST, 'D', "Frame ", 0 );

  00d4e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00d56	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173168
  00d5d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00d62	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00d67	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00d6a	44 8b 44 24 74	 mov	 r8d, DWORD PTR pktlen$[rsp]
  00d6f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pkt$[rsp]
  00d77	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d7f	e8 00 00 00 00	 call	 net_data_trace

; 3493 :             }

  00d84	e9 bf 01 00 00	 jmp	 $LN29@write_buff
$LN28@write_buff:

; 3494 :             else
; 3495 :             {
; 3496 :                 iPktVer = ((pkt[0] & 0xF0) >> 4);

  00d89	b8 01 00 00 00	 mov	 eax, 1
  00d8e	48 6b c0 00	 imul	 rax, rax, 0
  00d92	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pkt$[rsp]
  00d9a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00d9e	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00da3	c1 f8 04	 sar	 eax, 4
  00da6	89 84 24 a8 00
	00 00		 mov	 DWORD PTR iPktVer$[rsp], eax

; 3497 : 
; 3498 :                      if (iPktVer == 4) STRLCPY( cPktType, " IPv4" );

  00dad	83 bc 24 a8 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  00db5	75 1d		 jne	 SHORT $LN40@write_buff
  00db7	41 b8 08 00 00
	00		 mov	 r8d, 8
  00dbd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173171
  00dc4	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00dcc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00dd2	eb 42		 jmp	 SHORT $LN41@write_buff
$LN40@write_buff:

; 3499 :                 else if (iPktVer == 6) STRLCPY( cPktType, " IPv6" );

  00dd4	83 bc 24 a8 00
	00 00 06	 cmp	 DWORD PTR iPktVer$[rsp], 6
  00ddc	75 1d		 jne	 SHORT $LN42@write_buff
  00dde	41 b8 08 00 00
	00		 mov	 r8d, 8
  00de4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173174
  00deb	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00df3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00df9	eb 1b		 jmp	 SHORT $LN43@write_buff
$LN42@write_buff:

; 3500 :                 else                   STRLCPY( cPktType, " ????" );

  00dfb	41 b8 08 00 00
	00		 mov	 r8d, 8
  00e01	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173175
  00e08	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00e10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN43@write_buff:
$LN41@write_buff:

; 3501 : 
; 3502 :                 // HHC00910 "%1d:%04X %s: Send%s packet of size %d bytes to device %s"
; 3503 :                 WRMSG( HHC00910, "D", LCSS_DEVNUM,

  00e16	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e1f	74 15		 je	 SHORT $LN74@write_buff
  00e21	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e29	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e2d	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv521[rsp], eax
  00e34	eb 0b		 jmp	 SHORT $LN75@write_buff
$LN74@write_buff:
  00e36	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv521[rsp], 0
$LN75@write_buff:
  00e41	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e4a	74 17		 je	 SHORT $LN76@write_buff
  00e4c	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e54	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00e58	d1 f8		 sar	 eax, 1
  00e5a	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv527[rsp], eax
  00e61	eb 0b		 jmp	 SHORT $LN77@write_buff
$LN76@write_buff:
  00e63	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv527[rsp], 0
$LN77@write_buff:
  00e6e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00e76	48 83 c0 60	 add	 rax, 96			; 00000060H
  00e7a	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv506[rsp], rax
  00e82	b9 01 00 00 00	 mov	 ecx, 1
  00e87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e8d	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv506[rsp]
  00e95	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00e9a	8b 4c 24 74	 mov	 ecx, DWORD PTR pktlen$[rsp]
  00e9e	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00ea2	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00eaa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00eaf	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00eb7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00ebb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00ec0	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv521[rsp]
  00ec7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00ecb	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv527[rsp]
  00ed2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00ed6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173176
  00edd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00ee2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173177
  00ee9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00eee	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ef3	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ef9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173178
  00f00	ba b0 0d 00 00	 mov	 edx, 3504		; 00000db0H
  00f05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173179
  00f0c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3504 :                     dev->typname, cPktType, pktlen, grp->ttifname );
; 3505 :                 net_data_trace( dev, pkt, pktlen, FROM_GUEST, 'D', "Packet", 0 );

  00f12	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00f1a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173180
  00f21	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00f26	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00f2b	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00f2e	44 8b 44 24 74	 mov	 r8d, DWORD PTR pktlen$[rsp]
  00f33	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR pkt$[rsp]
  00f3b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f43	e8 00 00 00 00	 call	 net_data_trace
$LN29@write_buff:
$LN27@write_buff:

; 3506 :             }
; 3507 :         }
; 3508 : 
; 3509 :         /* Write the packet */
; 3510 :         qrc = write_packet( dev, grp, pkt, pktlen );

  00f48	44 8b 4c 24 74	 mov	 r9d, DWORD PTR pktlen$[rsp]
  00f4d	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR pkt$[rsp]
  00f55	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00f5d	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f65	e8 00 00 00 00	 call	 write_packet
  00f6a	66 89 84 24 84
	00 00 00	 mov	 WORD PTR qrc$[rsp], ax

; 3511 : 
; 3512 : #if defined( ENABLE_IPV6 )
; 3513 : 
; 3514 :         /* Layer 3 mode? */
; 3515 :         if (grp->l3)

  00f72	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00f7a	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00f81	74 7b		 je	 SHORT $LN44@write_buff

; 3516 :         {
; 3517 :             if ((iPktVer = ((pkt[0] & 0xF0) >> 4)) == 6)

  00f83	b8 01 00 00 00	 mov	 eax, 1
  00f88	48 6b c0 00	 imul	 rax, rax, 0
  00f8c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pkt$[rsp]
  00f94	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00f98	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00f9d	c1 f8 04	 sar	 eax, 4
  00fa0	89 84 24 a8 00
	00 00		 mov	 DWORD PTR iPktVer$[rsp], eax
  00fa7	83 bc 24 a8 00
	00 00 06	 cmp	 DWORD PTR iPktVer$[rsp], 6
  00faf	75 4d		 jne	 SHORT $LN45@write_buff

; 3518 :             {
; 3519 :                 IP6FRM* ip6;
; 3520 :                 BYTE    icmpv6 = 58;  /* = 0x3A */

  00fb1	c6 84 24 98 00
	00 00 3a	 mov	 BYTE PTR icmpv6$1[rsp], 58 ; 0000003aH

; 3521 :                 ip6 = (IP6FRM*) pkt;

  00fb9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pkt$[rsp]
  00fc1	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR ip6$3[rsp], rax

; 3522 : 
; 3523 :                 if (ip6->bNextHeader == icmpv6)

  00fc9	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR ip6$3[rsp]
  00fd1	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00fd5	0f b6 8c 24 98
	00 00 00	 movzx	 ecx, BYTE PTR icmpv6$1[rsp]
  00fdd	3b c1		 cmp	 eax, ecx
  00fdf	75 1d		 jne	 SHORT $LN46@write_buff

; 3524 :                     process_l3_icmpv6_packet( dev, grp, ip6 );

  00fe1	4c 8b 84 24 18
	01 00 00	 mov	 r8, QWORD PTR ip6$3[rsp]
  00fe9	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00ff1	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ff9	e8 00 00 00 00	 call	 process_l3_icmpv6_packet
$LN46@write_buff:
$LN45@write_buff:
$LN44@write_buff:
$LN2@write_buff:

; 3525 :             }
; 3526 :         }
; 3527 : #endif /* defined( ENABLE_IPV6 ) */
; 3528 : 
; 3529 :     }
; 3530 :     while (qrc >= 0 && !IS_LAST_SBALE_ENTRY( flag0 ) && ++sb < QMAXSTBK);

  00ffe	0f bf 84 24 84
	00 00 00	 movsx	 eax, WORD PTR qrc$[rsp]
  01006	85 c0		 test	 eax, eax
  01008	7c 24		 jl	 SHORT $LN47@write_buff
  0100a	0f b6 84 24 99
	00 00 00	 movzx	 eax, BYTE PTR flag0$[rsp]
  01012	83 e0 40	 and	 eax, 64			; 00000040H
  01015	85 c0		 test	 eax, eax
  01017	75 15		 jne	 SHORT $LN47@write_buff
  01019	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  0101d	ff c0		 inc	 eax
  0101f	89 44 24 78	 mov	 DWORD PTR sb$[rsp], eax
  01023	83 7c 24 78 10	 cmp	 DWORD PTR sb$[rsp], 16
  01028	0f 8c 07 f0 ff
	ff		 jl	 $LN4@write_buff
$LN47@write_buff:

; 3531 : 
; 3532 :     if (sb < QMAXSTBK)

  0102e	83 7c 24 78 10	 cmp	 DWORD PTR sb$[rsp], 16
  01033	7d 0a		 jge	 SHORT $LN48@write_buff

; 3533 :         return qrc;

  01035	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR qrc$[rsp]
  0103d	eb 36		 jmp	 SHORT $LN1@write_buff
$LN48@write_buff:

; 3534 : 
; 3535 :     return SBALE_ERROR( QRC_ESBNOEOF, dev,sbal,sbalk,sb-1);

  0103f	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  01043	ff c8		 dec	 eax
  01045	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  01049	0f b6 84 24 78
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  01051	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  01055	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  0105d	4c 8b 84 24 60
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  01065	66 ba f6 ff	 mov	 dx, -10
  01069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173186
  01070	e8 00 00 00 00	 call	 SBALE_Error
$LN1@write_buff:

; 3536 : }

  01075	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0107d	48 33 cc	 xor	 rcx, rsp
  01080	e8 00 00 00 00	 call	 __security_check_cookie
  01085	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  0108c	c3		 ret	 0
write_buffered_packets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
udp$ = 112
sb$ = 116
qrc$ = 120
length$ = 124
datalen$ = 128
bhr$ = 136
tv150 = 144
iPktVer$ = 148
tv177 = 152
tv194 = 156
tv200 = 160
bufdata$ = 168
ip4$ = 176
ip6$ = 184
o3hdr$ = 192
cPktType$ = 224
__$ArrayPad$ = 232
dev$ = 272
grp$ = 280
sbal$ = 288
sbalk$ = 296
read_l3r_buffers PROC

; 3183 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3184 :     OSA_BHR* bhr;
; 3185 :     BYTE*    bufdata;
; 3186 :     IP4FRM*  ip4;
; 3187 :     IP6FRM*  ip6;
; 3188 :     U32      datalen, length;
; 3189 :     OSA_HDR3 o3hdr;
; 3190 :     QRC      qrc;
; 3191 :     BYTE     udp = 17;

  0002f	c6 44 24 70 11	 mov	 BYTE PTR udp$[rsp], 17

; 3192 :     int      sb = 0;     /* Start with Storage Block zero */

  00034	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR sb$[rsp], 0
$LN4@read_l3r_b:

; 3193 :     int      iPktVer;
; 3194 :     char     cPktType[8];
; 3195 : 
; 3196 :     do
; 3197 :     {
; 3198 :         /* Remove layer 3 response buffer from chain. */
; 3199 :         bhr = remove_buffer_from_chain( &grp->l3r );

  0003c	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00044	48 83 c0 38	 add	 rax, 56			; 00000038H
  00048	48 8b c8	 mov	 rcx, rax
  0004b	e8 00 00 00 00	 call	 remove_buffer_from_chain
  00050	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR bhr$[rsp], rax

; 3200 :         if (!bhr) return QRC_EPKEOF;

  00058	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR bhr$[rsp], 0
  00061	75 0a		 jne	 SHORT $LN5@read_l3r_b
  00063	b8 fc ff ff ff	 mov	 eax, -4
  00068	e9 f5 04 00 00	 jmp	 $LN1@read_l3r_b
$LN5@read_l3r_b:

; 3201 : 
; 3202 :         /* Point to response data and get its length. */
; 3203 :         bufdata = (BYTE*)bhr + SizeBHR;

  0006d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR bhr$[rsp]
  00075	48 83 c0 18	 add	 rax, 24
  00079	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR bufdata$[rsp], rax

; 3204 :         datalen = bhr->datalen;

  00081	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR bhr$[rsp]
  00089	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0008c	89 84 24 80 00
	00 00		 mov	 DWORD PTR datalen$[rsp], eax

; 3205 :         length = bhr->datalen;

  00093	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR bhr$[rsp]
  0009b	8b 40 14	 mov	 eax, DWORD PTR [rax+20]
  0009e	89 44 24 7c	 mov	 DWORD PTR length$[rsp], eax

; 3206 : 
; 3207 :         /* Build the Layer 3 OSA header */
; 3208 :         memset( &o3hdr, 0, sizeof( OSA_HDR3 ));

  000a2	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp]
  000aa	48 8b f8	 mov	 rdi, rax
  000ad	33 c0		 xor	 eax, eax
  000af	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000b4	f3 aa		 rep stosb

; 3209 :         STORE_HW( o3hdr.length, datalen );

  000b6	0f b7 8c 24 80
	00 00 00	 movzx	 ecx, WORD PTR datalen$[rsp]
  000be	e8 00 00 00 00	 call	 _byteswap_ushort
  000c3	0f b7 d0	 movzx	 edx, ax
  000c6	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR o3hdr$[rsp+8]
  000ce	e8 00 00 00 00	 call	 store_hw_noswap

; 3210 :         o3hdr.id = HDR_ID_LAYER3;

  000d3	c6 84 24 c0 00
	00 00 01	 mov	 BYTE PTR o3hdr$[rsp], 1

; 3211 : 
; 3212 :         /* Check the IP packet version. The first 4-bits of the     */
; 3213 :         /* first byte of the IP header contains the version number. */
; 3214 :         iPktVer = ( ( bufdata[0] & 0xF0 ) >> 4 );

  000db	b8 01 00 00 00	 mov	 eax, 1
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR bufdata$[rsp]
  000ec	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000f0	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000f5	c1 f8 04	 sar	 eax, 4
  000f8	89 84 24 94 00
	00 00		 mov	 DWORD PTR iPktVer$[rsp], eax

; 3215 :         if (iPktVer == 4)

  000ff	83 bc 24 94 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  00107	0f 85 da 00 00
	00		 jne	 $LN6@read_l3r_b

; 3216 :         {
; 3217 :             ip4 = (IP4FRM*)bufdata;

  0010d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR bufdata$[rsp]
  00115	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ip4$[rsp], rax

; 3218 :             STRLCPY( cPktType, " IPv4" );

  0011d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173024
  0012a	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3219 :             memcpy( &o3hdr.dest_addr[12], &ip4->lDstIP, 4 );

  00138	b8 01 00 00 00	 mov	 eax, 1
  0013d	48 6b c0 0c	 imul	 rax, rax, 12
  00141	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ip4$[rsp]
  00149	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0014c	89 8c 04 d0 00
	00 00		 mov	 DWORD PTR o3hdr$[rsp+rax+16], ecx

; 3220 :             memcpy( o3hdr.in_cksum, ip4->hwChecksum, 2 );

  00153	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ip4$[rsp]
  0015b	0f b7 40 0a	 movzx	 eax, WORD PTR [rax+10]
  0015f	66 89 84 24 c2
	00 00 00	 mov	 WORD PTR o3hdr$[rsp+2], ax

; 3221 :             o3hdr.flags = l3_cast_type_ipv4( &o3hdr.dest_addr[12], grp );

  00167	b8 01 00 00 00	 mov	 eax, 1
  0016c	48 6b c0 0c	 imul	 rax, rax, 12
  00170	48 8d 84 04 d0
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp+rax+16]
  00178	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00180	48 8b c8	 mov	 rcx, rax
  00183	e8 00 00 00 00	 call	 l3_cast_type_ipv4
  00188	88 84 24 c1 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+1], al

; 3222 :             if (o3hdr.flags == HDR3_FLAGS_NOTFORUS)

  0018f	0f b6 84 24 c1
	00 00 00	 movzx	 eax, BYTE PTR o3hdr$[rsp+1]
  00197	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0019c	75 08		 jne	 SHORT $LN8@read_l3r_b

; 3223 :                 length = 0; /* Not our packet */

  0019e	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR length$[rsp], 0
$LN8@read_l3r_b:

; 3224 :             o3hdr.ext_flags = (ip4->bProtocol == udp) ? HDR3_EXFLAG_UDP : 0;

  001a6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ip4$[rsp]
  001ae	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  001b2	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR udp$[rsp]
  001b7	3b c1		 cmp	 eax, ecx
  001b9	75 0d		 jne	 SHORT $LN19@read_l3r_b
  001bb	c7 84 24 90 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv150[rsp], 64 ; 00000040H
  001c6	eb 0b		 jmp	 SHORT $LN20@read_l3r_b
$LN19@read_l3r_b:
  001c8	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv150[rsp], 0
$LN20@read_l3r_b:
  001d3	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR tv150[rsp]
  001db	88 84 24 cb 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+11], al

; 3225 :         }

  001e2	e9 fe 00 00 00	 jmp	 $LN7@read_l3r_b
$LN6@read_l3r_b:

; 3226 :         else if (iPktVer == 6)

  001e7	83 bc 24 94 00
	00 00 06	 cmp	 DWORD PTR iPktVer$[rsp], 6
  001ef	0f 85 cd 00 00
	00		 jne	 $LN9@read_l3r_b

; 3227 :         {
; 3228 :             ip6 = (IP6FRM*)bufdata;

  001f5	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR bufdata$[rsp]
  001fd	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR ip6$[rsp], rax

; 3229 :             STRLCPY( cPktType, " IPv6" );

  00205	41 b8 08 00 00
	00		 mov	 r8d, 8
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173028
  00212	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3230 :             memcpy( o3hdr.dest_addr, ip6->bDstAddr, 16 );

  00220	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp+16]
  00228	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR ip6$[rsp]
  00230	48 8b f8	 mov	 rdi, rax
  00233	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00237	b9 10 00 00 00	 mov	 ecx, 16
  0023c	f3 a4		 rep movsb

; 3231 :             o3hdr.flags = l3_cast_type_ipv6( o3hdr.dest_addr, grp );

  0023e	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00246	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR o3hdr$[rsp+16]
  0024e	e8 00 00 00 00	 call	 l3_cast_type_ipv6
  00253	88 84 24 c1 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+1], al

; 3232 :             if (o3hdr.flags == HDR3_FLAGS_NOTFORUS)

  0025a	0f b6 84 24 c1
	00 00 00	 movzx	 eax, BYTE PTR o3hdr$[rsp+1]
  00262	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00267	75 08		 jne	 SHORT $LN11@read_l3r_b

; 3233 :                 length = 0; /* Not our packet */

  00269	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR length$[rsp], 0
$LN11@read_l3r_b:

; 3234 :             o3hdr.flags |= HDR3_FLAGS_IPV6;

  00271	0f b6 84 24 c1
	00 00 00	 movzx	 eax, BYTE PTR o3hdr$[rsp+1]
  00279	0f ba e8 07	 bts	 eax, 7
  0027d	88 84 24 c1 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+1], al

; 3235 :             o3hdr.ext_flags = (ip6->bNextHeader == udp) ? HDR3_EXFLAG_UDP : 0;

  00284	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR ip6$[rsp]
  0028c	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00290	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR udp$[rsp]
  00295	3b c1		 cmp	 eax, ecx
  00297	75 0d		 jne	 SHORT $LN21@read_l3r_b
  00299	c7 84 24 98 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv177[rsp], 64 ; 00000040H
  002a4	eb 0b		 jmp	 SHORT $LN22@read_l3r_b
$LN21@read_l3r_b:
  002a6	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv177[rsp], 0
$LN22@read_l3r_b:
  002b1	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR tv177[rsp]
  002b9	88 84 24 cb 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+11], al

; 3236 :         }

  002c0	eb 23		 jmp	 SHORT $LN10@read_l3r_b
$LN9@read_l3r_b:

; 3237 :         else
; 3238 :         {
; 3239 :             /* Err... not IPv4 or IPv6! */
; 3240 :             STRLCPY( cPktType, "" );

  002c2	41 b8 08 00 00
	00		 mov	 r8d, 8
  002c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG173030
  002cf	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  002d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3241 :             length = 0;

  002dd	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR length$[rsp], 0
$LN10@read_l3r_b:
$LN7@read_l3r_b:

; 3242 :         }
; 3243 : 
; 3244 :         if (length)

  002e5	83 7c 24 7c 00	 cmp	 DWORD PTR length$[rsp], 0
  002ea	0f 84 9e 01 00
	00		 je	 $LN12@read_l3r_b

; 3245 :         {
; 3246 :             /* Debugging */
; 3247 :             if (grp->debugmask & DBGQETHPACKET)

  002f0	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  002f8	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  002fe	83 e0 01	 and	 eax, 1
  00301	85 c0		 test	 eax, eax
  00303	0f 84 23 01 00
	00		 je	 $LN14@read_l3r_b

; 3248 :             {
; 3249 :                 // HHC00913 "%1d:%04X %s: Receive%s packet of size %d bytes from device %s"
; 3250 :                 WRMSG(HHC00913, "D", LCSS_DEVNUM, dev->typname,

  00309	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00312	74 15		 je	 SHORT $LN23@read_l3r_b
  00314	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00320	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv194[rsp], eax
  00327	eb 0b		 jmp	 SHORT $LN24@read_l3r_b
$LN23@read_l3r_b:
  00329	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv194[rsp], 0
$LN24@read_l3r_b:
  00334	48 83 bc 24 10
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0033d	74 17		 je	 SHORT $LN25@read_l3r_b
  0033f	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00347	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0034b	d1 f8		 sar	 eax, 1
  0034d	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv200[rsp], eax
  00354	eb 0b		 jmp	 SHORT $LN26@read_l3r_b
$LN25@read_l3r_b:
  00356	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv200[rsp], 0
$LN26@read_l3r_b:
  00361	b9 01 00 00 00	 mov	 ecx, 1
  00366	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173034
  00373	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00378	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR datalen$[rsp]
  0037f	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00383	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  0038b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00390	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00398	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0039c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003a1	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv194[rsp]
  003a8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003ac	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv200[rsp]
  003b3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173035
  003be	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173036
  003ca	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003cf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d4	41 b9 03 00 00
	00		 mov	 r9d, 3
  003da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG173037
  003e1	ba b3 0c 00 00	 mov	 edx, 3251		; 00000cb3H
  003e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG173038
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3251 :                                 cPktType, datalen, "layer 3 response" );
; 3252 : /*              net_data_trace( dev, (BYTE*)&o3hdr, sizeof(o3hdr), TO_GUEST, 'D', "L3 hdr", 0 );    */
; 3253 :                 net_data_trace( dev, bufdata, datalen, TO_GUEST, 'D', "Packet", 0 );

  003f3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  003fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG173039
  00402	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00407	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  0040c	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  0040f	44 8b 84 24 80
	00 00 00	 mov	 r8d, DWORD PTR datalen$[rsp]
  00417	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR bufdata$[rsp]
  0041f	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00427	e8 00 00 00 00	 call	 net_data_trace
$LN14@read_l3r_b:

; 3254 :             }
; 3255 : 
; 3256 :             /* Copy header and packet to buffer storage block(s) */
; 3257 :             qrc = copy_packet_to_storage( dev, grp, sbal, sb, sbalk,

  0042c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR datalen$[rsp]
  00433	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00437	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR bufdata$[rsp]
  0043f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00444	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR [rsp+48], 32	; 00000020H
  0044c	48 8d 84 24 c0
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp]
  00454	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00459	0f b6 84 24 28
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  00461	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00465	44 8b 4c 24 74	 mov	 r9d, DWORD PTR sb$[rsp]
  0046a	4c 8b 84 24 20
	01 00 00	 mov	 r8, QWORD PTR sbal$[rsp]
  00472	48 8b 94 24 18
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  0047a	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00482	e8 00 00 00 00	 call	 copy_packet_to_storage
  00487	66 89 44 24 78	 mov	 WORD PTR qrc$[rsp], ax

; 3258 :                                           (BYTE*)&o3hdr, sizeof(o3hdr),
; 3259 :                                           bufdata, datalen );
; 3260 :         }

  0048c	eb 07		 jmp	 SHORT $LN13@read_l3r_b
$LN12@read_l3r_b:

; 3261 :         else
; 3262 :             qrc = 0;

  0048e	33 c0		 xor	 eax, eax
  00490	66 89 44 24 78	 mov	 WORD PTR qrc$[rsp], ax
$LN13@read_l3r_b:

; 3263 : 
; 3264 :         /* Free layer 3 response buffer. Read is complete. */
; 3265 :         if (bhr->content) free( bhr->content );

  00495	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR bhr$[rsp]
  0049d	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  004a2	74 12		 je	 SHORT $LN15@read_l3r_b
  004a4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR bhr$[rsp]
  004ac	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  004b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN15@read_l3r_b:

; 3266 :         free( bhr );

  004b6	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR bhr$[rsp]
  004be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3267 :     }
; 3268 :     while (qrc >= 0 && grp->rdpack && grp->l3r.firstbhr && ++sb < QMAXSTBK);

  004c4	0f bf 44 24 78	 movsx	 eax, WORD PTR qrc$[rsp]
  004c9	85 c0		 test	 eax, eax
  004cb	7c 35		 jl	 SHORT $LN16@read_l3r_b
  004cd	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  004d5	83 b8 e8 05 00
	00 00		 cmp	 DWORD PTR [rax+1512], 0
  004dc	74 24		 je	 SHORT $LN16@read_l3r_b
  004de	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  004e6	48 83 78 40 00	 cmp	 QWORD PTR [rax+64], 0
  004eb	74 15		 je	 SHORT $LN16@read_l3r_b
  004ed	8b 44 24 74	 mov	 eax, DWORD PTR sb$[rsp]
  004f1	ff c0		 inc	 eax
  004f3	89 44 24 74	 mov	 DWORD PTR sb$[rsp], eax
  004f7	83 7c 24 74 10	 cmp	 DWORD PTR sb$[rsp], 16
  004fc	0f 8c 3a fb ff
	ff		 jl	 $LN4@read_l3r_b
$LN16@read_l3r_b:

; 3269 : 
; 3270 :     /* Mark end of buffer */
; 3271 :     if (sb >= QMAXSTBK) sb--;

  00502	83 7c 24 74 10	 cmp	 DWORD PTR sb$[rsp], 16
  00507	7c 0a		 jl	 SHORT $LN17@read_l3r_b
  00509	8b 44 24 74	 mov	 eax, DWORD PTR sb$[rsp]
  0050d	ff c8		 dec	 eax
  0050f	89 44 24 74	 mov	 DWORD PTR sb$[rsp], eax
$LN17@read_l3r_b:

; 3272 :     sbal->sbale[sb].flags[0] |= SBALE_FLAG0_LAST_ENTRY;

  00513	48 63 44 24 74	 movsxd	 rax, DWORD PTR sb$[rsp]
  00518	48 6b c0 10	 imul	 rax, rax, 16
  0051c	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  00524	48 03 c8	 add	 rcx, rax
  00527	48 8b c1	 mov	 rax, rcx
  0052a	b9 01 00 00 00	 mov	 ecx, 1
  0052f	48 6b c9 00	 imul	 rcx, rcx, 0
  00533	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00537	83 c8 40	 or	 eax, 64			; 00000040H
  0053a	b9 01 00 00 00	 mov	 ecx, 1
  0053f	48 6b c9 00	 imul	 rcx, rcx, 0
  00543	48 63 54 24 74	 movsxd	 rdx, DWORD PTR sb$[rsp]
  00548	48 6b d2 10	 imul	 rdx, rdx, 16
  0054c	48 8b bc 24 20
	01 00 00	 mov	 rdi, QWORD PTR sbal$[rsp]
  00554	48 03 fa	 add	 rdi, rdx
  00557	48 8b d7	 mov	 rdx, rdi
  0055a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3273 : 
; 3274 :     return qrc;

  0055d	0f b7 44 24 78	 movzx	 eax, WORD PTR qrc$[rsp]
$LN1@read_l3r_b:

; 3275 : }

  00562	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0056a	48 33 cc	 xor	 rcx, rsp
  0056d	e8 00 00 00 00	 call	 __security_check_cookie
  00572	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00579	5f		 pop	 rdi
  0057a	5e		 pop	 rsi
  0057b	c3		 ret	 0
read_l3r_buffers ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
udp$ = 112
qrc$ = 116
sb$ = 120
tv151 = 124
iPktVer$ = 128
tv179 = 132
tv197 = 136
tv203 = 140
ip4$ = 144
ip6$ = 152
tv187 = 160
o3hdr$ = 168
cPktType$ = 200
__$ArrayPad$ = 208
dev$ = 256
grp$ = 264
sbal$ = 272
sbalk$ = 280
read_L3_packets PROC

; 3098 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3099 :     IP4FRM* ip4;
; 3100 :     IP6FRM* ip6;
; 3101 :     OSA_HDR3 o3hdr;
; 3102 :     QRC qrc;
; 3103 :     BYTE udp = 17;

  0002f	c6 44 24 70 11	 mov	 BYTE PTR udp$[rsp], 17

; 3104 :     int sb = 0;     /* Start with Storage Block zero */

  00034	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR sb$[rsp], 0
$LN4@read_L3_pa:

; 3105 :     int   iPktVer;
; 3106 :     char  cPktType[8];
; 3107 : 
; 3108 :     do
; 3109 :     {
; 3110 :         /* Read another packet into the device buffer */
; 3111 :         if ((qrc = read_packet( dev, grp )) != 0)

  0003c	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00044	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0004c	e8 00 00 00 00	 call	 read_packet
  00051	66 89 44 24 74	 mov	 WORD PTR qrc$[rsp], ax
  00056	0f bf 44 24 74	 movsx	 eax, WORD PTR qrc$[rsp]
  0005b	85 c0		 test	 eax, eax
  0005d	74 0a		 je	 SHORT $LN5@read_L3_pa

; 3112 :             return qrc; /*(probably EOF)*/

  0005f	0f b7 44 24 74	 movzx	 eax, WORD PTR qrc$[rsp]
  00064	e9 c9 04 00 00	 jmp	 $LN1@read_L3_pa
$LN5@read_L3_pa:

; 3113 : 
; 3114 :         /* Build the Layer 3 OSA header */
; 3115 :         memset( &o3hdr, 0, sizeof( OSA_HDR3 ));

  00069	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp]
  00071	48 8b f8	 mov	 rdi, rax
  00074	33 c0		 xor	 eax, eax
  00076	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0007b	f3 aa		 rep stosb

; 3116 :         STORE_HW( o3hdr.length, dev->buflen );

  0007d	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00085	0f b7 88 dc 01
	00 00		 movzx	 ecx, WORD PTR [rax+476]
  0008c	e8 00 00 00 00	 call	 _byteswap_ushort
  00091	0f b7 d0	 movzx	 edx, ax
  00094	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR o3hdr$[rsp+8]
  0009c	e8 00 00 00 00	 call	 store_hw_noswap

; 3117 :         o3hdr.id = HDR_ID_LAYER3;

  000a1	c6 84 24 a8 00
	00 00 01	 mov	 BYTE PTR o3hdr$[rsp], 1

; 3118 : //      STORE_HW( o3hdr.frame_offset, ???? ); // TSO only?
; 3119 : //      STORE_FW( o3hdr.token, ???? );
; 3120 : 
; 3121 :         /* Check the IP packet version. The first 4-bits of the     */
; 3122 :         /* first byte of the IP header contains the version number. */
; 3123 :         iPktVer = ( ( dev->buf[0] & 0xF0 ) >> 4 );

  000a9	b8 01 00 00 00	 mov	 eax, 1
  000ae	48 6b c0 00	 imul	 rax, rax, 0
  000b2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ba	48 8b 89 c8 01
	00 00		 mov	 rcx, QWORD PTR [rcx+456]
  000c1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c5	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000ca	c1 f8 04	 sar	 eax, 4
  000cd	89 84 24 80 00
	00 00		 mov	 DWORD PTR iPktVer$[rsp], eax

; 3124 :         if (iPktVer == 4)

  000d4	83 bc 24 80 00
	00 00 04	 cmp	 DWORD PTR iPktVer$[rsp], 4
  000dc	0f 85 da 00 00
	00		 jne	 $LN6@read_L3_pa

; 3125 :         {
; 3126 :             ip4 = (IP4FRM*)dev->buf;

  000e2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ea	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  000f1	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ip4$[rsp], rax

; 3127 :             STRLCPY( cPktType, " IPv4" );

  000f9	41 b8 08 00 00
	00		 mov	 r8d, 8
  000ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172973
  00106	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3128 :             memcpy( &o3hdr.dest_addr[12], &ip4->lDstIP, 4 );

  00114	b8 01 00 00 00	 mov	 eax, 1
  00119	48 6b c0 0c	 imul	 rax, rax, 12
  0011d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ip4$[rsp]
  00125	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00128	89 8c 04 b8 00
	00 00		 mov	 DWORD PTR o3hdr$[rsp+rax+16], ecx

; 3129 :             memcpy( o3hdr.in_cksum, ip4->hwChecksum, 2 );

  0012f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ip4$[rsp]
  00137	0f b7 40 0a	 movzx	 eax, WORD PTR [rax+10]
  0013b	66 89 84 24 aa
	00 00 00	 mov	 WORD PTR o3hdr$[rsp+2], ax

; 3130 :             o3hdr.flags = l3_cast_type_ipv4( &o3hdr.dest_addr[12], grp );

  00143	b8 01 00 00 00	 mov	 eax, 1
  00148	48 6b c0 0c	 imul	 rax, rax, 12
  0014c	48 8d 84 04 b8
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp+rax+16]
  00154	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  0015c	48 8b c8	 mov	 rcx, rax
  0015f	e8 00 00 00 00	 call	 l3_cast_type_ipv4
  00164	88 84 24 a9 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+1], al

; 3131 :             if (o3hdr.flags == HDR3_FLAGS_NOTFORUS)

  0016b	0f b6 84 24 a9
	00 00 00	 movzx	 eax, BYTE PTR o3hdr$[rsp+1]
  00173	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00178	75 0a		 jne	 SHORT $LN8@read_L3_pa

; 3132 :                 return QRC_EPKEOF; /* Not our packet */

  0017a	b8 fc ff ff ff	 mov	 eax, -4
  0017f	e9 ae 03 00 00	 jmp	 $LN1@read_L3_pa
$LN8@read_L3_pa:

; 3133 :             o3hdr.ext_flags = (ip4->bProtocol == udp) ? HDR3_EXFLAG_UDP : 0;

  00184	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ip4$[rsp]
  0018c	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  00190	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR udp$[rsp]
  00195	3b c1		 cmp	 eax, ecx
  00197	75 0a		 jne	 SHORT $LN16@read_L3_pa
  00199	c7 44 24 7c 40
	00 00 00	 mov	 DWORD PTR tv151[rsp], 64 ; 00000040H
  001a1	eb 08		 jmp	 SHORT $LN17@read_L3_pa
$LN16@read_L3_pa:
  001a3	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN17@read_L3_pa:
  001ab	0f b6 44 24 7c	 movzx	 eax, BYTE PTR tv151[rsp]
  001b0	88 84 24 b3 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+11], al

; 3134 :         }

  001b7	e9 ff 00 00 00	 jmp	 $LN7@read_L3_pa
$LN6@read_L3_pa:

; 3135 :         else if (iPktVer == 6)

  001bc	83 bc 24 80 00
	00 00 06	 cmp	 DWORD PTR iPktVer$[rsp], 6
  001c4	0f 85 d6 00 00
	00		 jne	 $LN9@read_L3_pa

; 3136 :         {
; 3137 :             ip6 = (IP6FRM*)dev->buf;

  001ca	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d2	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  001d9	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR ip6$[rsp], rax

; 3138 :             STRLCPY( cPktType, " IPv6" );

  001e1	41 b8 08 00 00
	00		 mov	 r8d, 8
  001e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172977
  001ee	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 3139 :             memcpy( o3hdr.dest_addr, ip6->bDstAddr, 16 );

  001fc	48 8d 84 24 b8
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp+16]
  00204	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR ip6$[rsp]
  0020c	48 8b f8	 mov	 rdi, rax
  0020f	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00213	b9 10 00 00 00	 mov	 ecx, 16
  00218	f3 a4		 rep movsb

; 3140 :             o3hdr.flags = l3_cast_type_ipv6( o3hdr.dest_addr, grp );

  0021a	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00222	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR o3hdr$[rsp+16]
  0022a	e8 00 00 00 00	 call	 l3_cast_type_ipv6
  0022f	88 84 24 a9 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+1], al

; 3141 :             if (o3hdr.flags == HDR3_FLAGS_NOTFORUS)

  00236	0f b6 84 24 a9
	00 00 00	 movzx	 eax, BYTE PTR o3hdr$[rsp+1]
  0023e	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00243	75 0a		 jne	 SHORT $LN11@read_L3_pa

; 3142 :                 return QRC_EPKEOF; /* Not our packet */

  00245	b8 fc ff ff ff	 mov	 eax, -4
  0024a	e9 e3 02 00 00	 jmp	 $LN1@read_L3_pa
$LN11@read_L3_pa:

; 3143 : /* ????     o3hdr.flags |= HDR3_FLAGS_PASSTHRU | HDR3_FLAGS_IPV6;    */
; 3144 :             o3hdr.flags |= HDR3_FLAGS_IPV6;

  0024f	0f b6 84 24 a9
	00 00 00	 movzx	 eax, BYTE PTR o3hdr$[rsp+1]
  00257	0f ba e8 07	 bts	 eax, 7
  0025b	88 84 24 a9 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+1], al

; 3145 :             o3hdr.ext_flags = (ip6->bNextHeader == udp) ? HDR3_EXFLAG_UDP : 0;

  00262	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR ip6$[rsp]
  0026a	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0026e	0f b6 4c 24 70	 movzx	 ecx, BYTE PTR udp$[rsp]
  00273	3b c1		 cmp	 eax, ecx
  00275	75 0d		 jne	 SHORT $LN18@read_L3_pa
  00277	c7 84 24 84 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv179[rsp], 64 ; 00000040H
  00282	eb 0b		 jmp	 SHORT $LN19@read_L3_pa
$LN18@read_L3_pa:
  00284	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv179[rsp], 0
$LN19@read_L3_pa:
  0028f	0f b6 84 24 84
	00 00 00	 movzx	 eax, BYTE PTR tv179[rsp]
  00297	88 84 24 b3 00
	00 00		 mov	 BYTE PTR o3hdr$[rsp+11], al

; 3146 :         }

  0029e	eb 1b		 jmp	 SHORT $LN10@read_L3_pa
$LN9@read_L3_pa:

; 3147 :         else
; 3148 :         {
; 3149 :             /* Err... not IPv4 or IPv6! */
; 3150 :             STRLCPY( cPktType, "" );

  002a0	41 b8 08 00 00
	00		 mov	 r8d, 8
  002a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172979
  002ad	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  002b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN10@read_L3_pa:
$LN7@read_L3_pa:

; 3151 :         }
; 3152 : 
; 3153 :         /* Debugging */
; 3154 :         if (grp->debugmask & DBGQETHPACKET)

  002bb	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  002c3	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  002c9	83 e0 01	 and	 eax, 1
  002cc	85 c0		 test	 eax, eax
  002ce	0f 84 4d 01 00
	00		 je	 $LN12@read_L3_pa

; 3155 :         {
; 3156 :             // HHC00913 "%1d:%04X %s: Receive%s packet of size %d bytes from device %s"
; 3157 :             WRMSG(HHC00913, "D", LCSS_DEVNUM, dev->typname,

  002d4	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002dd	74 15		 je	 SHORT $LN20@read_L3_pa
  002df	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002eb	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv197[rsp], eax
  002f2	eb 0b		 jmp	 SHORT $LN21@read_L3_pa
$LN20@read_L3_pa:
  002f4	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv197[rsp], 0
$LN21@read_L3_pa:
  002ff	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00308	74 17		 je	 SHORT $LN22@read_L3_pa
  0030a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00312	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00316	d1 f8		 sar	 eax, 1
  00318	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  0031f	eb 0b		 jmp	 SHORT $LN23@read_L3_pa
$LN22@read_L3_pa:
  00321	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv203[rsp], 0
$LN23@read_L3_pa:
  0032c	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00334	48 83 c0 60	 add	 rax, 96			; 00000060H
  00338	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv187[rsp], rax
  00340	b9 01 00 00 00	 mov	 ecx, 1
  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0034b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv187[rsp]
  00353	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00358	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00360	8b 89 dc 01 00
	00		 mov	 ecx, DWORD PTR [rcx+476]
  00366	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0036a	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00372	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00377	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0037f	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00383	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00388	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv197[rsp]
  0038f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00393	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  0039a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0039e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172981
  003a5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172982
  003b1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003bb	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172983
  003c8	ba 56 0c 00 00	 mov	 edx, 3158		; 00000c56H
  003cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172984
  003d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3158 :                             cPktType, dev->buflen, grp->ttifname );
; 3159 : /*          net_data_trace( dev, (BYTE*)&o3hdr, sizeof(o3hdr), TO_GUEST, 'D', "L3 hdr", 0 );        */
; 3160 :             net_data_trace( dev, dev->buf, dev->buflen, TO_GUEST, 'D', "Packet", 0 );

  003da	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  003e2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172985
  003e9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003ee	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  003f3	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  003f6	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003fe	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  00405	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0040d	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00414	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0041c	e8 00 00 00 00	 call	 net_data_trace
$LN12@read_L3_pa:

; 3161 :         }
; 3162 : 
; 3163 :         /* Copy header and packet to buffer storage block(s) */
; 3164 :         qrc = copy_packet_to_storage( dev, grp, sbal, sb, sbalk,

  00421	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00429	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  0042f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00433	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043b	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  00442	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00447	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR [rsp+48], 32	; 00000020H
  0044f	48 8d 84 24 a8
	00 00 00	 lea	 rax, QWORD PTR o3hdr$[rsp]
  00457	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0045c	0f b6 84 24 18
	01 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  00464	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00468	44 8b 4c 24 78	 mov	 r9d, DWORD PTR sb$[rsp]
  0046d	4c 8b 84 24 10
	01 00 00	 mov	 r8, QWORD PTR sbal$[rsp]
  00475	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  0047d	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00485	e8 00 00 00 00	 call	 copy_packet_to_storage
  0048a	66 89 44 24 74	 mov	 WORD PTR qrc$[rsp], ax

; 3165 :                                       (BYTE*) &o3hdr, sizeof( o3hdr ),
; 3166 :                                       dev->buf, dev->buflen );
; 3167 :     }
; 3168 :     while (qrc >= 0 && grp->rdpack && more_packets( dev ) && ++sb < QMAXSTBK);

  0048f	0f bf 44 24 74	 movsx	 eax, WORD PTR qrc$[rsp]
  00494	85 c0		 test	 eax, eax
  00496	7c 3a		 jl	 SHORT $LN13@read_L3_pa
  00498	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  004a0	83 b8 e8 05 00
	00 00		 cmp	 DWORD PTR [rax+1512], 0
  004a7	74 29		 je	 SHORT $LN13@read_L3_pa
  004a9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004b1	e8 00 00 00 00	 call	 more_packets
  004b6	0f b6 c0	 movzx	 eax, al
  004b9	85 c0		 test	 eax, eax
  004bb	74 15		 je	 SHORT $LN13@read_L3_pa
  004bd	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  004c1	ff c0		 inc	 eax
  004c3	89 44 24 78	 mov	 DWORD PTR sb$[rsp], eax
  004c7	83 7c 24 78 10	 cmp	 DWORD PTR sb$[rsp], 16
  004cc	0f 8c 6a fb ff
	ff		 jl	 $LN4@read_L3_pa
$LN13@read_L3_pa:

; 3169 : 
; 3170 :     /* Mark end of buffer */
; 3171 :     if (sb >= QMAXSTBK) sb--;

  004d2	83 7c 24 78 10	 cmp	 DWORD PTR sb$[rsp], 16
  004d7	7c 0a		 jl	 SHORT $LN14@read_L3_pa
  004d9	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  004dd	ff c8		 dec	 eax
  004df	89 44 24 78	 mov	 DWORD PTR sb$[rsp], eax
$LN14@read_L3_pa:

; 3172 :     sbal->sbale[sb].flags[0] |= SBALE_FLAG0_LAST_ENTRY;

  004e3	48 63 44 24 78	 movsxd	 rax, DWORD PTR sb$[rsp]
  004e8	48 6b c0 10	 imul	 rax, rax, 16
  004ec	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  004f4	48 03 c8	 add	 rcx, rax
  004f7	48 8b c1	 mov	 rax, rcx
  004fa	b9 01 00 00 00	 mov	 ecx, 1
  004ff	48 6b c9 00	 imul	 rcx, rcx, 0
  00503	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00507	83 c8 40	 or	 eax, 64			; 00000040H
  0050a	b9 01 00 00 00	 mov	 ecx, 1
  0050f	48 6b c9 00	 imul	 rcx, rcx, 0
  00513	48 63 54 24 78	 movsxd	 rdx, DWORD PTR sb$[rsp]
  00518	48 6b d2 10	 imul	 rdx, rdx, 16
  0051c	48 8b bc 24 10
	01 00 00	 mov	 rdi, QWORD PTR sbal$[rsp]
  00524	48 03 fa	 add	 rdi, rdx
  00527	48 8b d7	 mov	 rdx, rdi
  0052a	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3173 : 
; 3174 :     return qrc;

  0052d	0f b7 44 24 74	 movzx	 eax, WORD PTR qrc$[rsp]
$LN1@read_L3_pa:

; 3175 : }

  00532	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0053a	48 33 cc	 xor	 rcx, rsp
  0053d	e8 00 00 00 00	 call	 __security_check_cookie
  00542	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  00549	5f		 pop	 rdi
  0054a	5e		 pop	 rsi
  0054b	c3		 ret	 0
read_L3_packets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
hwEthernetType$ = 112
qrc$ = 116
sb$ = 120
tv86 = 124
mactype$ = 128
tv189 = 132
tv195 = 136
eth$ = 144
tv173 = 152
o2hdr$ = 160
cPktType$ = 192
__$ArrayPad$ = 200
dev$ = 224
grp$ = 232
sbal$ = 240
sbalk$ = 248
read_L2_packets PROC

; 3018 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3019 :     OSA_HDR2 o2hdr;
; 3020 :     ETHFRM* eth;
; 3021 :     int mactype;
; 3022 :     QRC qrc;
; 3023 :     int sb = 0;     /* Start with Storage Block zero */

  0002e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR sb$[rsp], 0
$LN4@read_L2_pa:

; 3024 :     U16  hwEthernetType;
; 3025 :     char cPktType[8];
; 3026 : 
; 3027 :     do {
; 3028 :         /* Find (another) frame for our MAC */
; 3029 :         eth = (ETHFRM*)dev->buf;

  00036	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  00045	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR eth$[rsp], rax
$LN5@read_L2_pa:

; 3030 :         for(;;)
; 3031 :         {
; 3032 :             if ((qrc = read_packet( dev, grp )) < 0)

  0004d	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00055	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0005d	e8 00 00 00 00	 call	 read_packet
  00062	66 89 44 24 74	 mov	 WORD PTR qrc$[rsp], ax
  00067	0f bf 44 24 74	 movsx	 eax, WORD PTR qrc$[rsp]
  0006c	85 c0		 test	 eax, eax
  0006e	7d 0a		 jge	 SHORT $LN10@read_L2_pa

; 3033 :                 return qrc; /*(probably EOF)*/

  00070	0f b7 44 24 74	 movzx	 eax, WORD PTR qrc$[rsp]
  00075	e9 c6 04 00 00	 jmp	 $LN1@read_L2_pa
$LN10@read_L2_pa:

; 3034 : 
; 3035 :             /* Verify the frame is being sent to us */
; 3036 :             if (!(mactype = validate_mac( eth->bDestMAC, MAC_TYPE_ANY, grp )))

  0007a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eth$[rsp]
  00082	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR grp$[rsp]
  0008a	ba 0f 00 00 00	 mov	 edx, 15
  0008f	48 8b c8	 mov	 rcx, rax
  00092	e8 00 00 00 00	 call	 validate_mac
  00097	89 84 24 80 00
	00 00		 mov	 DWORD PTR mactype$[rsp], eax
  0009e	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR mactype$[rsp], 0
  000a6	75 02		 jne	 SHORT $LN11@read_L2_pa

; 3037 :                 continue; /* (try next packet) */

  000a8	eb a3		 jmp	 SHORT $LN5@read_L2_pa
$LN11@read_L2_pa:

; 3038 :             /* We found a frame being sent to our MAC */
; 3039 :             break;

  000aa	eb 02		 jmp	 SHORT $LN6@read_L2_pa

; 3040 :         }

  000ac	eb 9f		 jmp	 SHORT $LN5@read_L2_pa
$LN6@read_L2_pa:

; 3041 : 
; 3042 :         /* Build the Layer 2 OSA header */
; 3043 :         memset( &o2hdr, 0, sizeof( OSA_HDR2 ));

  000ae	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR o2hdr$[rsp]
  000b6	48 8b f8	 mov	 rdi, rax
  000b9	33 c0		 xor	 eax, eax
  000bb	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000c0	f3 aa		 rep stosb

; 3044 :         STORE_HW( o2hdr.pktlen, dev->buflen );

  000c2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ca	0f b7 88 dc 01
	00 00		 movzx	 ecx, WORD PTR [rax+476]
  000d1	e8 00 00 00 00	 call	 _byteswap_ushort
  000d6	0f b7 d0	 movzx	 edx, ax
  000d9	48 8d 8c 24 a6
	00 00 00	 lea	 rcx, QWORD PTR o2hdr$[rsp+6]
  000e1	e8 00 00 00 00	 call	 store_hw_noswap

; 3045 :         o2hdr.id = HDR_ID_LAYER2;

  000e6	c6 84 24 a0 00
	00 00 02	 mov	 BYTE PTR o2hdr$[rsp], 2

; 3046 : 
; 3047 :         switch( mactype & MAC_TYPE_ANY ) {

  000ee	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR mactype$[rsp]
  000f5	83 e0 0f	 and	 eax, 15
  000f8	89 44 24 7c	 mov	 DWORD PTR tv86[rsp], eax
  000fc	83 7c 24 7c 01	 cmp	 DWORD PTR tv86[rsp], 1
  00101	74 36		 je	 SHORT $LN13@read_L2_pa
  00103	83 7c 24 7c 02	 cmp	 DWORD PTR tv86[rsp], 2
  00108	74 09		 je	 SHORT $LN12@read_L2_pa
  0010a	83 7c 24 7c 04	 cmp	 DWORD PTR tv86[rsp], 4
  0010f	74 4e		 je	 SHORT $LN14@read_L2_pa
  00111	eb 70		 jmp	 SHORT $LN8@read_L2_pa
$LN12@read_L2_pa:

; 3048 :         case MAC_TYPE_UNICST:
; 3049 :             o2hdr.flags[2] |= HDR2_FLAGS2_UNICAST;

  00113	b8 01 00 00 00	 mov	 eax, 1
  00118	48 6b c0 02	 imul	 rax, rax, 2
  0011c	0f b6 84 04 a1
	00 00 00	 movzx	 eax, BYTE PTR o2hdr$[rsp+rax+1]
  00124	83 c8 03	 or	 eax, 3
  00127	b9 01 00 00 00	 mov	 ecx, 1
  0012c	48 6b c9 02	 imul	 rcx, rcx, 2
  00130	88 84 0c a1 00
	00 00		 mov	 BYTE PTR o2hdr$[rsp+rcx+1], al

; 3050 :             break;

  00137	eb 4a		 jmp	 SHORT $LN8@read_L2_pa
$LN13@read_L2_pa:

; 3051 :         case MAC_TYPE_BRDCST:
; 3052 :             o2hdr.flags[2] |= HDR2_FLAGS2_BROADCAST;

  00139	b8 01 00 00 00	 mov	 eax, 1
  0013e	48 6b c0 02	 imul	 rax, rax, 2
  00142	0f b6 84 04 a1
	00 00 00	 movzx	 eax, BYTE PTR o2hdr$[rsp+rax+1]
  0014a	83 c8 02	 or	 eax, 2
  0014d	b9 01 00 00 00	 mov	 ecx, 1
  00152	48 6b c9 02	 imul	 rcx, rcx, 2
  00156	88 84 0c a1 00
	00 00		 mov	 BYTE PTR o2hdr$[rsp+rcx+1], al

; 3053 :             break;

  0015d	eb 24		 jmp	 SHORT $LN8@read_L2_pa
$LN14@read_L2_pa:

; 3054 :         case MAC_TYPE_MLTCST:
; 3055 :             o2hdr.flags[2] |= HDR2_FLAGS2_MULTICAST;

  0015f	b8 01 00 00 00	 mov	 eax, 1
  00164	48 6b c0 02	 imul	 rax, rax, 2
  00168	0f b6 84 04 a1
	00 00 00	 movzx	 eax, BYTE PTR o2hdr$[rsp+rax+1]
  00170	83 c8 01	 or	 eax, 1
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	48 6b c9 02	 imul	 rcx, rcx, 2
  0017c	88 84 0c a1 00
	00 00		 mov	 BYTE PTR o2hdr$[rsp+rcx+1], al
$LN8@read_L2_pa:

; 3056 :             break;
; 3057 :         }
; 3058 : 
; 3059 :         /* Debugging */
; 3060 :         if (grp->debugmask & DBGQETHPACKET)

  00183	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0018b	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00191	83 e0 01	 and	 eax, 1
  00194	85 c0		 test	 eax, eax
  00196	0f 84 93 02 00
	00		 je	 $LN15@read_L2_pa

; 3061 :         {
; 3062 :             FETCH_HW( hwEthernetType, eth->hwEthernetType );

  0019c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR eth$[rsp]
  001a4	48 83 c0 0c	 add	 rax, 12
  001a8	48 8b c8	 mov	 rcx, rax
  001ab	e8 00 00 00 00	 call	 fetch_hw_noswap
  001b0	0f b7 c8	 movzx	 ecx, ax
  001b3	e8 00 00 00 00	 call	 _byteswap_ushort
  001b8	66 89 44 24 70	 mov	 WORD PTR hwEthernetType$[rsp], ax

; 3063 : 
; 3064 :                  if (ETH_TYPE_IP   == hwEthernetType) STRLCPY( cPktType, "IPv4"    );

  001bd	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  001c2	3d 00 08 00 00	 cmp	 eax, 2048		; 00000800H
  001c7	75 20		 jne	 SHORT $LN16@read_L2_pa
  001c9	41 b8 08 00 00
	00		 mov	 r8d, 8
  001cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172923
  001d6	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  001e4	e9 c2 00 00 00	 jmp	 $LN17@read_L2_pa
$LN16@read_L2_pa:

; 3065 :             else if (ETH_TYPE_IPV6 == hwEthernetType) STRLCPY( cPktType, "IPv6"    );

  001e9	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  001ee	3d dd 86 00 00	 cmp	 eax, 34525		; 000086ddH
  001f3	75 20		 jne	 SHORT $LN18@read_L2_pa
  001f5	41 b8 08 00 00
	00		 mov	 r8d, 8
  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172926
  00202	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00210	e9 96 00 00 00	 jmp	 $LN19@read_L2_pa
$LN18@read_L2_pa:

; 3066 :             else if (ETH_TYPE_ARP  == hwEthernetType) STRLCPY( cPktType, "ARP"     );

  00215	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  0021a	3d 06 08 00 00	 cmp	 eax, 2054		; 00000806H
  0021f	75 1d		 jne	 SHORT $LN20@read_L2_pa
  00221	41 b8 08 00 00
	00		 mov	 r8d, 8
  00227	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172929
  0022e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00236	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  0023c	eb 6d		 jmp	 SHORT $LN21@read_L2_pa
$LN20@read_L2_pa:

; 3067 :             else if (ETH_TYPE_RARP == hwEthernetType) STRLCPY( cPktType, "RARP"    );

  0023e	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  00243	3d 35 80 00 00	 cmp	 eax, 32821		; 00008035H
  00248	75 1d		 jne	 SHORT $LN22@read_L2_pa
  0024a	41 b8 08 00 00
	00		 mov	 r8d, 8
  00250	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172932
  00257	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00265	eb 44		 jmp	 SHORT $LN23@read_L2_pa
$LN22@read_L2_pa:

; 3068 :             else if (ETH_TYPE_SNA  == hwEthernetType) STRLCPY( cPktType, "SNA"     );

  00267	0f b7 44 24 70	 movzx	 eax, WORD PTR hwEthernetType$[rsp]
  0026c	3d d5 80 00 00	 cmp	 eax, 32981		; 000080d5H
  00271	75 1d		 jne	 SHORT $LN24@read_L2_pa
  00273	41 b8 08 00 00
	00		 mov	 r8d, 8
  00279	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172935
  00280	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00288	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  0028e	eb 1b		 jmp	 SHORT $LN25@read_L2_pa
$LN24@read_L2_pa:

; 3069 :             else                                      STRLCPY( cPktType, "unknown" );

  00290	41 b8 08 00 00
	00		 mov	 r8d, 8
  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172936
  0029d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN25@read_L2_pa:
$LN23@read_L2_pa:
$LN21@read_L2_pa:
$LN19@read_L2_pa:
$LN17@read_L2_pa:

; 3070 : 
; 3071 :             // "%1d:%04X %s: Receive frame of size %d bytes (with %s packet) from device %s"
; 3072 :             WRMSG( HHC00986, "D", LCSS_DEVNUM,

  002ab	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002b4	74 15		 je	 SHORT $LN29@read_L2_pa
  002b6	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002be	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002c2	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv189[rsp], eax
  002c9	eb 0b		 jmp	 SHORT $LN30@read_L2_pa
$LN29@read_L2_pa:
  002cb	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv189[rsp], 0
$LN30@read_L2_pa:
  002d6	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002df	74 17		 je	 SHORT $LN31@read_L2_pa
  002e1	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002ed	d1 f8		 sar	 eax, 1
  002ef	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv195[rsp], eax
  002f6	eb 0b		 jmp	 SHORT $LN32@read_L2_pa
$LN31@read_L2_pa:
  002f8	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv195[rsp], 0
$LN32@read_L2_pa:
  00303	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0030b	48 83 c0 60	 add	 rax, 96			; 00000060H
  0030f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  00317	b9 01 00 00 00	 mov	 ecx, 1
  0031c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00322	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  0032a	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0032f	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR cPktType$[rsp]
  00337	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0033c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00344	8b 89 dc 01 00
	00		 mov	 ecx, DWORD PTR [rcx+476]
  0034a	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0034e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00356	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0035a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0035f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  00366	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0036a	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv195[rsp]
  00371	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00375	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172937
  0037c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00381	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172938
  00388	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0038d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00392	41 b9 03 00 00
	00		 mov	 r9d, 3
  00398	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172939
  0039f	ba 01 0c 00 00	 mov	 edx, 3073		; 00000c01H
  003a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172940
  003ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 3073 :                 dev->typname, dev->buflen, cPktType, grp->ttifname );
; 3074 :             net_data_trace( dev, (BYTE*) &o2hdr, sizeof( o2hdr ), TO_GUEST, 'D', "L2 hdr", 0 );

  003b1	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  003b9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172941
  003c0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003c5	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  003ca	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  003cd	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  003d3	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR o2hdr$[rsp]
  003db	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e3	e8 00 00 00 00	 call	 net_data_trace

; 3075 :             net_data_trace( dev,    dev->buf,     dev->buflen,    TO_GUEST, 'D', "Frame ", 0 );

  003e8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  003f0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172942
  003f7	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003fc	c6 44 24 20 44	 mov	 BYTE PTR [rsp+32], 68	; 00000044H
  00401	41 b1 3e	 mov	 r9b, 62			; 0000003eH
  00404	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0040c	44 8b 80 dc 01
	00 00		 mov	 r8d, DWORD PTR [rax+476]
  00413	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0041b	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00422	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042a	e8 00 00 00 00	 call	 net_data_trace
$LN15@read_L2_pa:

; 3076 :         }
; 3077 : 
; 3078 :         /* Copy header and frame to buffer storage block(s) */
; 3079 :         qrc = copy_packet_to_storage( dev, grp, sbal, sb, sbalk,

  0042f	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00437	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  0043d	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00441	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00449	48 8b 80 c8 01
	00 00		 mov	 rax, QWORD PTR [rax+456]
  00450	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00455	c7 44 24 30 20
	00 00 00	 mov	 DWORD PTR [rsp+48], 32	; 00000020H
  0045d	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR o2hdr$[rsp]
  00465	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0046a	0f b6 84 24 f8
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  00472	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00476	44 8b 4c 24 78	 mov	 r9d, DWORD PTR sb$[rsp]
  0047b	4c 8b 84 24 f0
	00 00 00	 mov	 r8, QWORD PTR sbal$[rsp]
  00483	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  0048b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00493	e8 00 00 00 00	 call	 copy_packet_to_storage
  00498	66 89 44 24 74	 mov	 WORD PTR qrc$[rsp], ax

; 3080 :                                       (BYTE*) &o2hdr, sizeof( o2hdr ),
; 3081 :                                       dev->buf, dev->buflen );
; 3082 :     }
; 3083 :     while (qrc >= 0 && grp->rdpack && more_packets( dev ) && ++sb < QMAXSTBK);

  0049d	0f bf 44 24 74	 movsx	 eax, WORD PTR qrc$[rsp]
  004a2	85 c0		 test	 eax, eax
  004a4	7c 3a		 jl	 SHORT $LN26@read_L2_pa
  004a6	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  004ae	83 b8 e8 05 00
	00 00		 cmp	 DWORD PTR [rax+1512], 0
  004b5	74 29		 je	 SHORT $LN26@read_L2_pa
  004b7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004bf	e8 00 00 00 00	 call	 more_packets
  004c4	0f b6 c0	 movzx	 eax, al
  004c7	85 c0		 test	 eax, eax
  004c9	74 15		 je	 SHORT $LN26@read_L2_pa
  004cb	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  004cf	ff c0		 inc	 eax
  004d1	89 44 24 78	 mov	 DWORD PTR sb$[rsp], eax
  004d5	83 7c 24 78 10	 cmp	 DWORD PTR sb$[rsp], 16
  004da	0f 8c 56 fb ff
	ff		 jl	 $LN4@read_L2_pa
$LN26@read_L2_pa:

; 3084 : 
; 3085 :     /* Mark end of buffer */
; 3086 :     if (sb >= QMAXSTBK) sb--;

  004e0	83 7c 24 78 10	 cmp	 DWORD PTR sb$[rsp], 16
  004e5	7c 0a		 jl	 SHORT $LN27@read_L2_pa
  004e7	8b 44 24 78	 mov	 eax, DWORD PTR sb$[rsp]
  004eb	ff c8		 dec	 eax
  004ed	89 44 24 78	 mov	 DWORD PTR sb$[rsp], eax
$LN27@read_L2_pa:

; 3087 :     sbal->sbale[sb].flags[0] |= SBALE_FLAG0_LAST_ENTRY;

  004f1	48 63 44 24 78	 movsxd	 rax, DWORD PTR sb$[rsp]
  004f6	48 6b c0 10	 imul	 rax, rax, 16
  004fa	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  00502	48 03 c8	 add	 rcx, rax
  00505	48 8b c1	 mov	 rax, rcx
  00508	b9 01 00 00 00	 mov	 ecx, 1
  0050d	48 6b c9 00	 imul	 rcx, rcx, 0
  00511	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00515	83 c8 40	 or	 eax, 64			; 00000040H
  00518	b9 01 00 00 00	 mov	 ecx, 1
  0051d	48 6b c9 00	 imul	 rcx, rcx, 0
  00521	48 63 54 24 78	 movsxd	 rdx, DWORD PTR sb$[rsp]
  00526	48 6b d2 10	 imul	 rdx, rdx, 16
  0052a	48 8b bc 24 f0
	00 00 00	 mov	 rdi, QWORD PTR sbal$[rsp]
  00532	48 03 fa	 add	 rdi, rdx
  00535	48 8b d7	 mov	 rdx, rdi
  00538	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3088 : 
; 3089 :     return qrc;

  0053b	0f b7 44 24 74	 movzx	 eax, WORD PTR qrc$[rsp]
$LN1@read_L2_pa:

; 3090 : }

  00540	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00548	48 33 cc	 xor	 rcx, rsp
  0054b	e8 00 00 00 00	 call	 __security_check_cookie
  00550	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00557	5f		 pop	 rdi
  00558	c3		 ret	 0
read_L2_packets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
frag0$ = 80
qrc$ = 84
i$1 = 88
sbrem$ = 92
sboff$ = 96
ssb$ = 100
dev$ = 128
grp$ = 136
sbal$ = 144
sb$ = 152
sbalk$ = 160
hdr$ = 168
hdrlen$ = 176
frm$ = 184
frmlen$ = 192
copy_packet_to_storage PROC

; 2972 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2973 :     int ssb = sb;                       /* Starting Storage Block    */

  00018	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sb$[rsp]
  0001f	89 44 24 64	 mov	 DWORD PTR ssb$[rsp], eax

; 2974 :     U32 sboff = 0;                      /* Storage Block offset      */

  00023	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR sboff$[rsp], 0

; 2975 :     U32 sbrem = 0;                      /* Storage Block remaining   */

  0002b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR sbrem$[rsp], 0

; 2976 :     BYTE frag0;                         /* SBALE fragment flag       */
; 2977 :     QRC qrc;                            /* Internal return code      */
; 2978 : 
; 2979 :     /* Start with the header first */
; 2980 :     frag0 = SBALE_FLAG0_FRAG_FIRST;

  00033	c6 44 24 50 04	 mov	 BYTE PTR frag0$[rsp], 4

; 2981 :     if ((qrc = copy_fragment_to_storage( dev, sbal, sbalk,
; 2982 :         &sb, &frag0, &sboff, &sbrem, hdr, hdrlen )) < 0 )

  00038	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR hdrlen$[rsp]
  0003f	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00043	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR hdr$[rsp]
  0004b	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00050	48 8d 44 24 5c	 lea	 rax, QWORD PTR sbrem$[rsp]
  00055	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0005a	48 8d 44 24 60	 lea	 rax, QWORD PTR sboff$[rsp]
  0005f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00064	48 8d 44 24 50	 lea	 rax, QWORD PTR frag0$[rsp]
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR sb$[rsp]
  00076	44 0f b6 84 24
	a0 00 00 00	 movzx	 r8d, BYTE PTR sbalk$[rsp]
  0007f	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sbal$[rsp]
  00087	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0008f	e8 00 00 00 00	 call	 copy_fragment_to_storage
  00094	66 89 44 24 54	 mov	 WORD PTR qrc$[rsp], ax
  00099	0f bf 44 24 54	 movsx	 eax, WORD PTR qrc$[rsp]
  0009e	85 c0		 test	 eax, eax
  000a0	7d 0a		 jge	 SHORT $LN8@copy_packe

; 2983 :         return qrc;

  000a2	0f b7 44 24 54	 movzx	 eax, WORD PTR qrc$[rsp]
  000a7	e9 5d 02 00 00	 jmp	 $LN1@copy_packe
$LN8@copy_packe:

; 2984 : 
; 2985 :     /* Then copy the packet/frame */
; 2986 :     if ((qrc = copy_fragment_to_storage( dev, sbal, sbalk,
; 2987 :         &sb, &frag0, &sboff, &sbrem, frm, frmlen )) < 0 )

  000ac	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR frmlen$[rsp]
  000b3	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  000b7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR frm$[rsp]
  000bf	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000c4	48 8d 44 24 5c	 lea	 rax, QWORD PTR sbrem$[rsp]
  000c9	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000ce	48 8d 44 24 60	 lea	 rax, QWORD PTR sboff$[rsp]
  000d3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000d8	48 8d 44 24 50	 lea	 rax, QWORD PTR frag0$[rsp]
  000dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e2	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR sb$[rsp]
  000ea	44 0f b6 84 24
	a0 00 00 00	 movzx	 r8d, BYTE PTR sbalk$[rsp]
  000f3	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sbal$[rsp]
  000fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00103	e8 00 00 00 00	 call	 copy_fragment_to_storage
  00108	66 89 44 24 54	 mov	 WORD PTR qrc$[rsp], ax
  0010d	0f bf 44 24 54	 movsx	 eax, WORD PTR qrc$[rsp]
  00112	85 c0		 test	 eax, eax
  00114	7d 0a		 jge	 SHORT $LN9@copy_packe

; 2988 :         return qrc;

  00116	0f b7 44 24 54	 movzx	 eax, WORD PTR qrc$[rsp]
  0011b	e9 e9 01 00 00	 jmp	 $LN1@copy_packe
$LN9@copy_packe:

; 2989 : 
; 2990 :     /* Mark last fragment */
; 2991 :     frag0 = SBALE_FLAG0_FRAG_LAST;

  00120	c6 44 24 50 0c	 mov	 BYTE PTR frag0$[rsp], 12

; 2992 :     STORE_FW( sbal->sbale[sb].length, sboff );

  00125	8b 4c 24 60	 mov	 ecx, DWORD PTR sboff$[rsp]
  00129	e8 00 00 00 00	 call	 _byteswap_ulong
  0012e	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR sb$[rsp]
  00136	48 6b c9 10	 imul	 rcx, rcx, 16
  0013a	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sbal$[rsp]
  00142	48 8d 4c 0a 04	 lea	 rcx, QWORD PTR [rdx+rcx+4]
  00147	8b d0		 mov	 edx, eax
  00149	e8 00 00 00 00	 call	 store_fw_noswap

; 2993 :     STORE_FW( sbal->sbale[sb].flags,     0   );

  0014e	33 c9		 xor	 ecx, ecx
  00150	e8 00 00 00 00	 call	 _byteswap_ulong
  00155	48 63 8c 24 98
	00 00 00	 movsxd	 rcx, DWORD PTR sb$[rsp]
  0015d	48 6b c9 10	 imul	 rcx, rcx, 16
  00161	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR sbal$[rsp]
  00169	48 03 d1	 add	 rdx, rcx
  0016c	48 8b ca	 mov	 rcx, rdx
  0016f	8b d0		 mov	 edx, eax
  00171	e8 00 00 00 00	 call	 store_fw_noswap
$LN4@copy_packe:

; 2994 :     SET_SBALE_FRAG( sbal->sbale[sb].flags[0], frag0 );

  00176	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sb$[rsp]
  0017e	48 6b c0 10	 imul	 rax, rax, 16
  00182	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  0018a	48 03 c8	 add	 rcx, rax
  0018d	48 8b c1	 mov	 rax, rcx
  00190	b9 01 00 00 00	 mov	 ecx, 1
  00195	48 6b c9 00	 imul	 rcx, rcx, 0
  00199	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0019d	83 e0 b3	 and	 eax, -77		; ffffffffffffffb3H
  001a0	b9 01 00 00 00	 mov	 ecx, 1
  001a5	48 6b c9 00	 imul	 rcx, rcx, 0
  001a9	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR sb$[rsp]
  001b1	48 6b d2 10	 imul	 rdx, rdx, 16
  001b5	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR sbal$[rsp]
  001bd	4c 03 c2	 add	 r8, rdx
  001c0	49 8b d0	 mov	 rdx, r8
  001c3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001c6	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR sb$[rsp]
  001ce	48 6b c0 10	 imul	 rax, rax, 16
  001d2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  001da	48 03 c8	 add	 rcx, rax
  001dd	48 8b c1	 mov	 rax, rcx
  001e0	b9 01 00 00 00	 mov	 ecx, 1
  001e5	48 6b c9 00	 imul	 rcx, rcx, 0
  001e9	0f b6 54 24 50	 movzx	 edx, BYTE PTR frag0$[rsp]
  001ee	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001f2	0b c2		 or	 eax, edx
  001f4	b9 01 00 00 00	 mov	 ecx, 1
  001f9	48 6b c9 00	 imul	 rcx, rcx, 0
  001fd	48 63 94 24 98
	00 00 00	 movsxd	 rdx, DWORD PTR sb$[rsp]
  00205	48 6b d2 10	 imul	 rdx, rdx, 16
  00209	4c 8b 84 24 90
	00 00 00	 mov	 r8, QWORD PTR sbal$[rsp]
  00211	4c 03 c2	 add	 r8, rdx
  00214	49 8b d0	 mov	 rdx, r8
  00217	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0021a	33 c0		 xor	 eax, eax
  0021c	85 c0		 test	 eax, eax
  0021e	0f 85 52 ff ff
	ff		 jne	 $LN4@copy_packe

; 2995 : 
; 2996 :     /* Dump the SBALE's we consumed */
; 2997 :     if (grp->debugmask & DBGQETHSBALE)

  00224	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0022c	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00232	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00237	85 c0		 test	 eax, eax
  00239	0f 84 c8 00 00
	00		 je	 $LN10@copy_packe

; 2998 :     {
; 2999 :         int  i;
; 3000 :         for (i=ssb; i <= sb; i++)

  0023f	8b 44 24 64	 mov	 eax, DWORD PTR ssb$[rsp]
  00243	89 44 24 58	 mov	 DWORD PTR i$1[rsp], eax
  00247	eb 0a		 jmp	 SHORT $LN7@copy_packe
$LN5@copy_packe:
  00249	8b 44 24 58	 mov	 eax, DWORD PTR i$1[rsp]
  0024d	ff c0		 inc	 eax
  0024f	89 44 24 58	 mov	 DWORD PTR i$1[rsp], eax
$LN7@copy_packe:
  00253	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR sb$[rsp]
  0025a	39 44 24 58	 cmp	 DWORD PTR i$1[rsp], eax
  0025e	0f 8f a3 00 00
	00		 jg	 $LN6@copy_packe

; 3001 :         {
; 3002 :             FETCH_FW( sbrem, sbal->sbale[i].length );

  00264	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$1[rsp]
  00269	48 6b c0 10	 imul	 rax, rax, 16
  0026d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  00275	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  0027a	48 8b c8	 mov	 rcx, rax
  0027d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00282	8b c8		 mov	 ecx, eax
  00284	e8 00 00 00 00	 call	 _byteswap_ulong
  00289	89 44 24 5c	 mov	 DWORD PTR sbrem$[rsp], eax

; 3003 :             frag0 = sbal->sbale[i].flags[0];

  0028d	48 63 44 24 58	 movsxd	 rax, DWORD PTR i$1[rsp]
  00292	48 6b c0 10	 imul	 rax, rax, 16
  00296	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  0029e	48 03 c8	 add	 rcx, rax
  002a1	48 8b c1	 mov	 rax, rcx
  002a4	b9 01 00 00 00	 mov	 ecx, 1
  002a9	48 6b c9 00	 imul	 rcx, rcx, 0
  002ad	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002b1	88 44 24 50	 mov	 BYTE PTR frag0$[rsp], al

; 3004 :             DBGTRC( dev, "Input SBALE(%d): flag: %02X Len: %04X (%d)",

  002b5	0f b6 44 24 50	 movzx	 eax, BYTE PTR frag0$[rsp]
  002ba	8b 4c 24 5c	 mov	 ecx, DWORD PTR sbrem$[rsp]
  002be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002c2	8b 4c 24 5c	 mov	 ecx, DWORD PTR sbrem$[rsp]
  002c6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002ca	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002ce	8b 44 24 58	 mov	 eax, DWORD PTR i$1[rsp]
  002d2	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002d6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172883
  002dd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002e2	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  002ea	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172884
  002f1	ba bd 0b 00 00	 mov	 edx, 3005		; 00000bbdH
  002f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172885
  002fd	e8 00 00 00 00	 call	 dbgtrc

; 3005 :                 i, frag0, sbrem, sbrem );
; 3006 :         }

  00302	e9 42 ff ff ff	 jmp	 $LN5@copy_packe
$LN6@copy_packe:
$LN10@copy_packe:

; 3007 :     }
; 3008 : 
; 3009 :     return QRC_SUCCESS;

  00307	33 c0		 xor	 eax, eax
$LN1@copy_packe:

; 3010 : }

  00309	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0030d	c3		 ret	 0
copy_packet_to_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
len$ = 48
tv133 = 52
tv135 = 56
tv214 = 60
dst$ = 64
sba$ = 72
dev$ = 112
grp$ = 120
sbal$ = 128
sbalk$ = 136
sb$ = 144
sbsrc$ = 152
sblen$ = 160
copy_storage_fragments PROC

; 2896 : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2897 :     U64 sba;                            /* Storage Block Address     */
; 2898 :     BYTE *dst;                          /* Destination address       */
; 2899 :     U32 len;                            /* Copy length               */
; 2900 : 
; 2901 :     dst = dev->buf + dev->buflen;       /* Build destination pointer */

  0001a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001f	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	48 03 81 c8 01
	00 00		 add	 rax, QWORD PTR [rcx+456]
  00032	48 89 44 24 40	 mov	 QWORD PTR dst$[rsp], rax
$LN2@copy_stora:

; 2902 : 
; 2903 :     /* Copy data from each Storage Block in turn until the entire
; 2904 :        packet/frame has been copied or we reach the ending Block. */
; 2905 :     while (dev->bufres > 0)

  00037	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	83 b8 e4 01 00
	00 00		 cmp	 DWORD PTR [rax+484], 0
  00043	0f 8e ba 03 00
	00		 jle	 $LN3@copy_stora

; 2906 :     {
; 2907 :         /* End of current storage block? */
; 2908 :         if (!sblen)

  00049	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR sblen$[rsp], 0
  00051	0f 85 e0 02 00
	00		 jne	 $LN4@copy_stora

; 2909 :         {
; 2910 :             /* Is this the last storage block? */
; 2911 :             if (WR_LOGICALLY_LAST_SBALE( sbal->sbale[*sb].flags[0] ))

  00057	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  0005c	83 b8 ec 05 00
	00 00		 cmp	 DWORD PTR [rax+1516], 0
  00063	74 7f		 je	 SHORT $LN13@copy_stora
  00065	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  0006d	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00070	48 6b c0 10	 imul	 rax, rax, 16
  00074	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  0007c	48 03 c8	 add	 rcx, rax
  0007f	48 8b c1	 mov	 rax, rcx
  00082	b9 01 00 00 00	 mov	 ecx, 1
  00087	48 6b c9 00	 imul	 rcx, rcx, 0
  0008b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0008f	83 e0 0c	 and	 eax, 12
  00092	83 f8 0c	 cmp	 eax, 12
  00095	74 3b		 je	 SHORT $LN11@copy_stora
  00097	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  0009f	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000a2	48 6b c0 10	 imul	 rax, rax, 16
  000a6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  000ae	48 03 c8	 add	 rcx, rax
  000b1	48 8b c1	 mov	 rax, rcx
  000b4	b9 01 00 00 00	 mov	 ecx, 1
  000b9	48 6b c9 00	 imul	 rcx, rcx, 0
  000bd	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000c1	83 e0 40	 and	 eax, 64			; 00000040H
  000c4	85 c0		 test	 eax, eax
  000c6	75 0a		 jne	 SHORT $LN11@copy_stora
  000c8	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
  000d0	eb 08		 jmp	 SHORT $LN12@copy_stora
$LN11@copy_stora:
  000d2	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
$LN12@copy_stora:
  000da	8b 44 24 34	 mov	 eax, DWORD PTR tv133[rsp]
  000de	89 44 24 38	 mov	 DWORD PTR tv135[rsp], eax
  000e2	eb 31		 jmp	 SHORT $LN14@copy_stora
$LN13@copy_stora:
  000e4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  000ec	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000ef	48 6b c0 10	 imul	 rax, rax, 16
  000f3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  000fb	48 03 c8	 add	 rcx, rax
  000fe	48 8b c1	 mov	 rax, rcx
  00101	b9 01 00 00 00	 mov	 ecx, 1
  00106	48 6b c9 00	 imul	 rcx, rcx, 0
  0010a	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0010e	83 e0 40	 and	 eax, 64			; 00000040H
  00111	89 44 24 38	 mov	 DWORD PTR tv135[rsp], eax
$LN14@copy_stora:
  00115	83 7c 24 38 00	 cmp	 DWORD PTR tv135[rsp], 0
  0011a	74 3c		 je	 SHORT $LN5@copy_stora

; 2912 :             {
; 2913 :                 /* We have copied as much data as we possibly can but
; 2914 :                 dev->bufres is not zero so the Storage Blocks Entries
; 2915 :                 are wrong. THIS SHOULD NEVER OCCUR since our device
; 2916 :                 buffer size is always set to the maximum size of 64K. */
; 2917 :                 return SBALE_ERROR( QRC_EPKSBLEN, dev,sbal,sbalk,*sb);

  0011c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00124	8b 00		 mov	 eax, DWORD PTR [rax]
  00126	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0012a	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  00132	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00136	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  0013e	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00143	66 ba f8 ff	 mov	 dx, -8
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172840
  0014e	e8 00 00 00 00	 call	 SBALE_Error
  00153	e9 ad 02 00 00	 jmp	 $LN1@copy_stora
$LN5@copy_stora:

; 2918 :             }
; 2919 : 
; 2920 :             /* Request interrupt if needed */
; 2921 :             if (sbal->sbale[*sb].flags[3] & SBALE_FLAG3_PCI_REQ)

  00158	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00160	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00163	48 6b c0 10	 imul	 rax, rax, 16
  00167	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  0016f	48 03 c8	 add	 rcx, rax
  00172	48 8b c1	 mov	 rax, rcx
  00175	b9 01 00 00 00	 mov	 ecx, 1
  0017a	48 6b c9 03	 imul	 rcx, rcx, 3
  0017e	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00182	83 e0 40	 and	 eax, 64			; 00000040H
  00185	85 c0		 test	 eax, eax
  00187	74 1b		 je	 SHORT $LN6@copy_stora

; 2922 :             {
; 2923 :                 SET_DSCI(dev,DSCI_IOCOMP);

  00189	b2 01		 mov	 dl, 1
  0018b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00190	e8 00 00 00 00	 call	 set_dsci

; 2924 :                 grp->oqPCI = TRUE;

  00195	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  0019a	c7 80 f4 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1524], 1
$LN6@copy_stora:

; 2925 :             }
; 2926 : 
; 2927 :             /* Retrieve the next storage block entry */
; 2928 :             if (*sb >= (QMAXSTBK-1))

  001a4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  001ac	83 38 0f	 cmp	 DWORD PTR [rax], 15
  001af	7c 3c		 jl	 SHORT $LN7@copy_stora

; 2929 :                 return SBALE_ERROR( QRC_ENOSPC, dev,sbal,sbalk,*sb);

  001b1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  001b9	8b 00		 mov	 eax, DWORD PTR [rax]
  001bb	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  001bf	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  001c7	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001cb	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  001d3	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  001d8	66 ba fd ff	 mov	 dx, -3
  001dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172843
  001e3	e8 00 00 00 00	 call	 SBALE_Error
  001e8	e9 18 02 00 00	 jmp	 $LN1@copy_stora
$LN7@copy_stora:

; 2930 :             *sb = *sb + 1;

  001ed	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  001f5	8b 00		 mov	 eax, DWORD PTR [rax]
  001f7	ff c0		 inc	 eax
  001f9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR sb$[rsp]
  00201	89 01		 mov	 DWORD PTR [rcx], eax

; 2931 :             FETCH_DW( sba,   sbal->sbale[*sb].addr   );

  00203	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  0020b	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0020e	48 6b c0 10	 imul	 rax, rax, 16
  00212	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  0021a	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0021f	48 8b c8	 mov	 rcx, rax
  00222	e8 00 00 00 00	 call	 fetch_dw_noswap
  00227	48 8b c8	 mov	 rcx, rax
  0022a	e8 00 00 00 00	 call	 _byteswap_uint64
  0022f	48 89 44 24 48	 mov	 QWORD PTR sba$[rsp], rax

; 2932 :             FETCH_FW( sblen, sbal->sbale[*sb].length );

  00234	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  0023c	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0023f	48 6b c0 10	 imul	 rax, rax, 16
  00243	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  0024b	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00250	48 8b c8	 mov	 rcx, rax
  00253	e8 00 00 00 00	 call	 fetch_fw_noswap
  00258	8b c8		 mov	 ecx, eax
  0025a	e8 00 00 00 00	 call	 _byteswap_ulong
  0025f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sblen$[rsp], eax

; 2933 :             if (!sblen)

  00266	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR sblen$[rsp], 0
  0026e	75 3c		 jne	 SHORT $LN8@copy_stora

; 2934 :                 return SBALE_ERROR( QRC_EZEROBLK, dev,sbal,sbalk,*sb);

  00270	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00278	8b 00		 mov	 eax, DWORD PTR [rax]
  0027a	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0027e	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  00286	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  0028a	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  00292	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00297	66 ba f9 ff	 mov	 dx, -7
  0029b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172845
  002a2	e8 00 00 00 00	 call	 SBALE_Error
  002a7	e9 59 01 00 00	 jmp	 $LN1@copy_stora
$LN8@copy_stora:

; 2935 :             if (STORCHK( sba, sblen-1, sbalk, STORKEY_CHANGE, dev))

  002ac	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  002b4	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sblen$[rsp]
  002bb	ff c9		 dec	 ecx
  002bd	8b c9		 mov	 ecx, ecx
  002bf	48 8b 54 24 70	 mov	 rdx, QWORD PTR dev$[rsp]
  002c4	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002c9	41 b9 02 00 00
	00		 mov	 r9d, 2
  002cf	44 8b c0	 mov	 r8d, eax
  002d2	8b d1		 mov	 edx, ecx
  002d4	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sba$[rsp]
  002d9	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  002de	85 c0		 test	 eax, eax
  002e0	74 3c		 je	 SHORT $LN9@copy_stora

; 2936 :                 return SBALE_ERROR( QRC_ESTORCHK, dev,sbal,sbalk,*sb);

  002e2	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  002ea	8b 00		 mov	 eax, DWORD PTR [rax]
  002ec	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002f0	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  002f8	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  002fc	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR sbal$[rsp]
  00304	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  00309	66 ba fe ff	 mov	 dx, -2
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172847
  00314	e8 00 00 00 00	 call	 SBALE_Error
  00319	e9 e7 00 00 00	 jmp	 $LN1@copy_stora
$LN9@copy_stora:

; 2937 : 
; 2938 :             /* Point to new data source */
; 2939 :             sbsrc = (BYTE*)(dev->mainstor + sba);

  0031e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00323	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0032a	48 03 44 24 48	 add	 rax, QWORD PTR sba$[rsp]
  0032f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR sbsrc$[rsp], rax
$LN4@copy_stora:

; 2940 :         }
; 2941 : 
; 2942 :         /* Copying packet/frame to device from this storage block */
; 2943 :         len = min( (U32)dev->bufres, sblen );

  00337	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0033c	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sblen$[rsp]
  00343	39 88 e4 01 00
	00		 cmp	 DWORD PTR [rax+484], ecx
  00349	73 11		 jae	 SHORT $LN15@copy_stora
  0034b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00350	8b 80 e4 01 00
	00		 mov	 eax, DWORD PTR [rax+484]
  00356	89 44 24 3c	 mov	 DWORD PTR tv214[rsp], eax
  0035a	eb 0b		 jmp	 SHORT $LN16@copy_stora
$LN15@copy_stora:
  0035c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR sblen$[rsp]
  00363	89 44 24 3c	 mov	 DWORD PTR tv214[rsp], eax
$LN16@copy_stora:
  00367	8b 44 24 3c	 mov	 eax, DWORD PTR tv214[rsp]
  0036b	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 2944 :         memcpy( dst, sbsrc, len );

  0036f	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00373	48 8b 7c 24 40	 mov	 rdi, QWORD PTR dst$[rsp]
  00378	48 8b b4 24 98
	00 00 00	 mov	 rsi, QWORD PTR sbsrc$[rsp]
  00380	8b c8		 mov	 ecx, eax
  00382	f3 a4		 rep movsb

; 2945 : 
; 2946 :         dst         += len;

  00384	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00388	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dst$[rsp]
  0038d	48 03 c8	 add	 rcx, rax
  00390	48 8b c1	 mov	 rax, rcx
  00393	48 89 44 24 40	 mov	 QWORD PTR dst$[rsp], rax

; 2947 :         dev->buflen += len;

  00398	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0039d	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  003a3	03 44 24 30	 add	 eax, DWORD PTR len$[rsp]
  003a7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003ac	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 2948 :         dev->bufres -= len;

  003b2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  003b7	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  003bb	8b 80 e4 01 00
	00		 mov	 eax, DWORD PTR [rax+484]
  003c1	2b c1		 sub	 eax, ecx
  003c3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003c8	89 81 e4 01 00
	00		 mov	 DWORD PTR [rcx+484], eax

; 2949 :         sbsrc       += len;

  003ce	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  003d2	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sbsrc$[rsp]
  003da	48 03 c8	 add	 rcx, rax
  003dd	48 8b c1	 mov	 rax, rcx
  003e0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR sbsrc$[rsp], rax

; 2950 :         sblen       -= len;

  003e8	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  003ec	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR sblen$[rsp]
  003f3	2b c8		 sub	 ecx, eax
  003f5	8b c1		 mov	 eax, ecx
  003f7	89 84 24 a0 00
	00 00		 mov	 DWORD PTR sblen$[rsp], eax

; 2951 :     }

  003fe	e9 34 fc ff ff	 jmp	 $LN2@copy_stora
$LN3@copy_stora:

; 2952 : 
; 2953 :     return QRC_SUCCESS;

  00403	33 c0		 xor	 eax, eax
$LN1@copy_stora:

; 2954 : }

  00405	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00409	5f		 pop	 rdi
  0040a	5e		 pop	 rsi
  0040b	c3		 ret	 0
copy_storage_fragments ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
len$ = 48
tv213 = 52
dst$ = 56
sba$ = 64
dev$ = 112
sbal$ = 120
sbalk$ = 128
sb$ = 136
frag0$ = 144
sboff$ = 152
sbrem$ = 160
src$ = 168
rem$ = 176
copy_fragment_to_storage PROC

; 2821 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2822 :     U64 sba;                            /* Storage Block Address     */
; 2823 :     BYTE *dst = NULL;                   /* Destination address       */

  0001a	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR dst$[rsp], 0
$LN2@copy_fragm:

; 2824 :     int len;                            /* Copy length (work)        */
; 2825 : 
; 2826 :     /* While src bytes remain to be copied */
; 2827 :     while (rem > 0)

  00023	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR rem$[rsp], 0
  0002b	0f 8e e0 03 00
	00		 jle	 $LN3@copy_fragm

; 2828 :     {
; 2829 :         /* End of current Storage Block? */
; 2830 :         if (!*sbrem && *sboff)

  00031	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sbrem$[rsp]
  00039	83 38 00	 cmp	 DWORD PTR [rax], 0
  0003c	0f 85 91 01 00
	00		 jne	 $LN7@copy_fragm
  00042	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sboff$[rsp]
  0004a	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004d	0f 84 80 01 00
	00		 je	 $LN7@copy_fragm

; 2831 :         {
; 2832 :             /* Done using this Storage Block */
; 2833 :             STORE_FW( sbal->sbale[*sb].length, *sboff );

  00053	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sboff$[rsp]
  0005b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005d	e8 00 00 00 00	 call	 _byteswap_ulong
  00062	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR sb$[rsp]
  0006a	48 63 09	 movsxd	 rcx, DWORD PTR [rcx]
  0006d	48 6b c9 10	 imul	 rcx, rcx, 16
  00071	48 8b 54 24 78	 mov	 rdx, QWORD PTR sbal$[rsp]
  00076	48 8d 4c 0a 04	 lea	 rcx, QWORD PTR [rdx+rcx+4]
  0007b	8b d0		 mov	 edx, eax
  0007d	e8 00 00 00 00	 call	 store_fw_noswap

; 2834 :             STORE_FW( sbal->sbale[*sb].flags,     0   );

  00082	33 c9		 xor	 ecx, ecx
  00084	e8 00 00 00 00	 call	 _byteswap_ulong
  00089	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR sb$[rsp]
  00091	48 63 09	 movsxd	 rcx, DWORD PTR [rcx]
  00094	48 6b c9 10	 imul	 rcx, rcx, 16
  00098	48 8b 54 24 78	 mov	 rdx, QWORD PTR sbal$[rsp]
  0009d	48 03 d1	 add	 rdx, rcx
  000a0	48 8b ca	 mov	 rcx, rdx
  000a3	8b d0		 mov	 edx, eax
  000a5	e8 00 00 00 00	 call	 store_fw_noswap
$LN6@copy_fragm:

; 2835 :             SET_SBALE_FRAG( sbal->sbale[*sb].flags[0], *frag0 );

  000aa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  000b2	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  000b5	48 6b c0 10	 imul	 rax, rax, 16
  000b9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sbal$[rsp]
  000be	48 03 c8	 add	 rcx, rax
  000c1	48 8b c1	 mov	 rax, rcx
  000c4	b9 01 00 00 00	 mov	 ecx, 1
  000c9	48 6b c9 00	 imul	 rcx, rcx, 0
  000cd	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000d1	83 e0 b3	 and	 eax, -77		; ffffffffffffffb3H
  000d4	b9 01 00 00 00	 mov	 ecx, 1
  000d9	48 6b c9 00	 imul	 rcx, rcx, 0
  000dd	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR sb$[rsp]
  000e5	48 63 12	 movsxd	 rdx, DWORD PTR [rdx]
  000e8	48 6b d2 10	 imul	 rdx, rdx, 16
  000ec	4c 8b 44 24 78	 mov	 r8, QWORD PTR sbal$[rsp]
  000f1	4c 03 c2	 add	 r8, rdx
  000f4	49 8b d0	 mov	 rdx, r8
  000f7	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000fa	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00102	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00105	48 6b c0 10	 imul	 rax, rax, 16
  00109	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sbal$[rsp]
  0010e	48 03 c8	 add	 rcx, rax
  00111	48 8b c1	 mov	 rax, rcx
  00114	b9 01 00 00 00	 mov	 ecx, 1
  00119	48 6b c9 00	 imul	 rcx, rcx, 0
  0011d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR frag0$[rsp]
  00125	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  00128	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0012c	0b c2		 or	 eax, edx
  0012e	b9 01 00 00 00	 mov	 ecx, 1
  00133	48 6b c9 00	 imul	 rcx, rcx, 0
  00137	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR sb$[rsp]
  0013f	48 63 12	 movsxd	 rdx, DWORD PTR [rdx]
  00142	48 6b d2 10	 imul	 rdx, rdx, 16
  00146	4c 8b 44 24 78	 mov	 r8, QWORD PTR sbal$[rsp]
  0014b	4c 03 c2	 add	 r8, rdx
  0014e	49 8b d0	 mov	 rdx, r8
  00151	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00154	33 c0		 xor	 eax, eax
  00156	85 c0		 test	 eax, eax
  00158	0f 85 4c ff ff
	ff		 jne	 $LN6@copy_fragm

; 2836 : 
; 2837 :             /* Go on to next Storage Block */
; 2838 :             if (*sb >= (QMAXSTBK-1))

  0015e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00166	83 38 0f	 cmp	 DWORD PTR [rax], 15
  00169	7c 39		 jl	 SHORT $LN8@copy_fragm

; 2839 :                 return SBALE_ERROR( QRC_ENOSPC, dev,sbal,sbalk,*sb);

  0016b	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00173	8b 00		 mov	 eax, DWORD PTR [rax]
  00175	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00179	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  00181	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00185	4c 8b 4c 24 78	 mov	 r9, QWORD PTR sbal$[rsp]
  0018a	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  0018f	66 ba fd ff	 mov	 dx, -3
  00193	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172807
  0019a	e8 00 00 00 00	 call	 SBALE_Error
  0019f	e9 6f 02 00 00	 jmp	 $LN1@copy_fragm
$LN8@copy_fragm:

; 2840 :             *sb = *sb + 1;

  001a4	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  001ac	8b 00		 mov	 eax, DWORD PTR [rax]
  001ae	ff c0		 inc	 eax
  001b0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR sb$[rsp]
  001b8	89 01		 mov	 DWORD PTR [rcx], eax

; 2841 :             *frag0 = SBALE_FLAG0_FRAG_MIDDLE;

  001ba	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR frag0$[rsp]
  001c2	c6 00 08	 mov	 BYTE PTR [rax], 8

; 2842 :             *sboff = 0;

  001c5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sboff$[rsp]
  001cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN7@copy_fragm:

; 2843 :         }
; 2844 : 
; 2845 :         /* Starting a new Storage Block? */
; 2846 :         if (!*sboff || !dst)

  001d3	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sboff$[rsp]
  001db	83 38 00	 cmp	 DWORD PTR [rax], 0
  001de	74 0c		 je	 SHORT $LN10@copy_fragm
  001e0	48 83 7c 24 38
	00		 cmp	 QWORD PTR dst$[rsp], 0
  001e6	0f 85 5b 01 00
	00		 jne	 $LN9@copy_fragm
$LN10@copy_fragm:

; 2847 :         {
; 2848 :             /* Check the Storage Block's length and key */
; 2849 :             FETCH_DW(  sba,   sbal->sbale[*sb].addr   );

  001ec	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  001f4	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  001f7	48 6b c0 10	 imul	 rax, rax, 16
  001fb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sbal$[rsp]
  00200	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  00205	48 8b c8	 mov	 rcx, rax
  00208	e8 00 00 00 00	 call	 fetch_dw_noswap
  0020d	48 8b c8	 mov	 rcx, rax
  00210	e8 00 00 00 00	 call	 _byteswap_uint64
  00215	48 89 44 24 40	 mov	 QWORD PTR sba$[rsp], rax

; 2850 :             FETCH_FW( *sbrem, sbal->sbale[*sb].length );

  0021a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00222	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  00225	48 6b c0 10	 imul	 rax, rax, 16
  00229	48 8b 4c 24 78	 mov	 rcx, QWORD PTR sbal$[rsp]
  0022e	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00233	48 8b c8	 mov	 rcx, rax
  00236	e8 00 00 00 00	 call	 fetch_fw_noswap
  0023b	8b c8		 mov	 ecx, eax
  0023d	e8 00 00 00 00	 call	 _byteswap_ulong
  00242	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sbrem$[rsp]
  0024a	89 01		 mov	 DWORD PTR [rcx], eax

; 2851 :             if (!*sbrem)

  0024c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sbrem$[rsp]
  00254	83 38 00	 cmp	 DWORD PTR [rax], 0
  00257	75 39		 jne	 SHORT $LN11@copy_fragm

; 2852 :                 return SBALE_ERROR( QRC_EZEROBLK, dev,sbal,sbalk,*sb);

  00259	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  00261	8b 00		 mov	 eax, DWORD PTR [rax]
  00263	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00267	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  0026f	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00273	4c 8b 4c 24 78	 mov	 r9, QWORD PTR sbal$[rsp]
  00278	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  0027d	66 ba f9 ff	 mov	 dx, -7
  00281	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172811
  00288	e8 00 00 00 00	 call	 SBALE_Error
  0028d	e9 81 01 00 00	 jmp	 $LN1@copy_fragm
$LN11@copy_fragm:

; 2853 :             if (STORCHK(sba,(*sbrem)-1,sbalk,STORKEY_CHANGE,dev))

  00292	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  0029a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sbrem$[rsp]
  002a2	8b 09		 mov	 ecx, DWORD PTR [rcx]
  002a4	ff c9		 dec	 ecx
  002a6	8b c9		 mov	 ecx, ecx
  002a8	48 8b 54 24 70	 mov	 rdx, QWORD PTR dev$[rsp]
  002ad	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002b2	41 b9 02 00 00
	00		 mov	 r9d, 2
  002b8	44 8b c0	 mov	 r8d, eax
  002bb	8b d1		 mov	 edx, ecx
  002bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sba$[rsp]
  002c2	e8 00 00 00 00	 call	 qeth_storage_access_check_and_update
  002c7	85 c0		 test	 eax, eax
  002c9	74 39		 je	 SHORT $LN12@copy_fragm

; 2854 :                 return SBALE_ERROR( QRC_ESTORCHK, dev,sbal,sbalk,*sb);

  002cb	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR sb$[rsp]
  002d3	8b 00		 mov	 eax, DWORD PTR [rax]
  002d5	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  002d9	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR sbalk$[rsp]
  002e1	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  002e5	4c 8b 4c 24 78	 mov	 r9, QWORD PTR sbal$[rsp]
  002ea	4c 8b 44 24 70	 mov	 r8, QWORD PTR dev$[rsp]
  002ef	66 ba fe ff	 mov	 dx, -2
  002f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172813
  002fa	e8 00 00 00 00	 call	 SBALE_Error
  002ff	e9 0f 01 00 00	 jmp	 $LN1@copy_fragm
$LN12@copy_fragm:

; 2855 :             *sbrem -= *sboff;

  00304	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sbrem$[rsp]
  0030c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sboff$[rsp]
  00314	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00316	8b 00		 mov	 eax, DWORD PTR [rax]
  00318	2b c1		 sub	 eax, ecx
  0031a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sbrem$[rsp]
  00322	89 01		 mov	 DWORD PTR [rcx], eax

; 2856 : 
; 2857 :             /* Calculate new destination address */
; 2858 :             dst = (BYTE*)(dev->mainstor + sba + *sboff);

  00324	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00329	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00330	48 03 44 24 40	 add	 rax, QWORD PTR sba$[rsp]
  00335	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sboff$[rsp]
  0033d	8b 09		 mov	 ecx, DWORD PTR [rcx]
  0033f	48 03 c1	 add	 rax, rcx
  00342	48 89 44 24 38	 mov	 QWORD PTR dst$[rsp], rax
$LN9@copy_fragm:

; 2859 :         }
; 2860 : 
; 2861 :         /* Continue copying data to Storage Block */
; 2862 :         len = min( *sbrem, (U32)rem );

  00347	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sbrem$[rsp]
  0034f	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR rem$[rsp]
  00356	39 08		 cmp	 DWORD PTR [rax], ecx
  00358	73 10		 jae	 SHORT $LN14@copy_fragm
  0035a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sbrem$[rsp]
  00362	8b 00		 mov	 eax, DWORD PTR [rax]
  00364	89 44 24 34	 mov	 DWORD PTR tv213[rsp], eax
  00368	eb 0b		 jmp	 SHORT $LN15@copy_fragm
$LN14@copy_fragm:
  0036a	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR rem$[rsp]
  00371	89 44 24 34	 mov	 DWORD PTR tv213[rsp], eax
$LN15@copy_fragm:
  00375	8b 44 24 34	 mov	 eax, DWORD PTR tv213[rsp]
  00379	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 2863 :         memcpy( dst, src, len );

  0037d	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00382	48 8b 7c 24 38	 mov	 rdi, QWORD PTR dst$[rsp]
  00387	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  0038f	48 8b c8	 mov	 rcx, rax
  00392	f3 a4		 rep movsb

; 2864 : 
; 2865 :         dst    += len;

  00394	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  00399	48 8b 4c 24 38	 mov	 rcx, QWORD PTR dst$[rsp]
  0039e	48 03 c8	 add	 rcx, rax
  003a1	48 8b c1	 mov	 rax, rcx
  003a4	48 89 44 24 38	 mov	 QWORD PTR dst$[rsp], rax

; 2866 :         src    += len;

  003a9	48 63 44 24 30	 movsxd	 rax, DWORD PTR len$[rsp]
  003ae	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR src$[rsp]
  003b6	48 03 c8	 add	 rcx, rax
  003b9	48 8b c1	 mov	 rax, rcx
  003bc	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR src$[rsp], rax

; 2867 :         rem    -= len;

  003c4	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  003c8	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR rem$[rsp]
  003cf	2b c8		 sub	 ecx, eax
  003d1	8b c1		 mov	 eax, ecx
  003d3	89 84 24 b0 00
	00 00		 mov	 DWORD PTR rem$[rsp], eax

; 2868 :         *sboff += len;

  003da	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR sboff$[rsp]
  003e2	8b 00		 mov	 eax, DWORD PTR [rax]
  003e4	03 44 24 30	 add	 eax, DWORD PTR len$[rsp]
  003e8	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR sboff$[rsp]
  003f0	89 01		 mov	 DWORD PTR [rcx], eax

; 2869 :         *sbrem -= len;

  003f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR sbrem$[rsp]
  003fa	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  003fe	8b 00		 mov	 eax, DWORD PTR [rax]
  00400	2b c1		 sub	 eax, ecx
  00402	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR sbrem$[rsp]
  0040a	89 01		 mov	 DWORD PTR [rcx], eax

; 2870 :     }

  0040c	e9 12 fc ff ff	 jmp	 $LN2@copy_fragm
$LN3@copy_fragm:

; 2871 : 
; 2872 :     /* PROGRAMMING NOTE: the CALLER will mark last fragment! */
; 2873 :     return QRC_SUCCESS;

  00411	33 c0		 xor	 eax, eax
$LN1@copy_fragm:

; 2874 : }

  00413	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00417	5f		 pop	 rdi
  00418	5e		 pop	 rsi
  00419	c3		 ret	 0
copy_fragment_to_storage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
errnum$ = 112
tv85 = 116
tv145 = 120
tv151 = 124
wrote$ = 128
tv134 = 136
tv138 = 144
dev$ = 176
grp$ = 184
pkt$ = 192
pktlen$ = 200
write_packet PROC

; 2780 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@write_pack:

; 2781 :     int wrote, errnum;
; 2782 : 
; 2783 :     PTT_QETH_TRACE( "wrpack entr", 0, pktlen, 0 );

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00022	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00025	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 3e		 je	 SHORT $LN11@write_pack
  00030	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR pktlen$[rsp]
  00038	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00041	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172760
  00051	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00056	4c 8b c8	 mov	 r9, rax
  00059	45 33 c0	 xor	 r8d, r8d
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172761
  00063	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@write_pack:
  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 a7		 jne	 SHORT $LN4@write_pack

; 2784 :     wrote = TUNTAP_Write( dev->fd, pkt, pktlen );

  00074	44 8b 84 24 c8
	00 00 00	 mov	 r8d, DWORD PTR pktlen$[rsp]
  0007c	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR pkt$[rsp]
  00084	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008c	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00092	e8 00 00 00 00	 call	 tt32_write
  00097	89 84 24 80 00
	00 00		 mov	 DWORD PTR wrote$[rsp], eax

; 2785 :     errnum = errno;

  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a4	8b 00		 mov	 eax, DWORD PTR [rax]
  000a6	89 44 24 70	 mov	 DWORD PTR errnum$[rsp], eax

; 2786 : 
; 2787 :     if (likely(wrote == pktlen))

  000aa	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR pktlen$[rsp]
  000b1	39 84 24 80 00
	00 00		 cmp	 DWORD PTR wrote$[rsp], eax
  000b8	75 0a		 jne	 SHORT $LN18@write_pack
  000ba	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  000c2	eb 08		 jmp	 SHORT $LN19@write_pack
$LN18@write_pack:
  000c4	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN19@write_pack:
  000cc	83 7c 24 74 00	 cmp	 DWORD PTR tv85[rsp], 0
  000d1	74 7e		 je	 SHORT $LN12@write_pack

; 2788 :     {
; 2789 :         dev->qdio.txcnt++;

  000d3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000db	8b 80 2c 13 00
	00		 mov	 eax, DWORD PTR [rax+4908]
  000e1	ff c0		 inc	 eax
  000e3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000eb	89 81 2c 13 00
	00		 mov	 DWORD PTR [rcx+4908], eax
$LN7@write_pack:

; 2790 :         PTT_QETH_TRACE( "wrpack exit", 0, pktlen, QRC_SUCCESS );

  000f1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000f8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fb	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00101	48 85 c0	 test	 rax, rax
  00104	74 3e		 je	 SHORT $LN13@write_pack
  00106	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR pktlen$[rsp]
  0010e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00117	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172764
  00127	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0012c	4c 8b c8	 mov	 r9, rax
  0012f	45 33 c0	 xor	 r8d, r8d
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172765
  00139	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN13@write_pack:
  00144	33 c0		 xor	 eax, eax
  00146	85 c0		 test	 eax, eax
  00148	75 a7		 jne	 SHORT $LN7@write_pack

; 2791 :         return QRC_SUCCESS;

  0014a	33 c0		 xor	 eax, eax
  0014c	e9 66 01 00 00	 jmp	 $LN1@write_pack
$LN12@write_pack:

; 2792 :     }
; 2793 : 
; 2794 :     // HHC00911 "%1d:%04X %s: error writing to device %s: %d %s"
; 2795 :     WRMSG(HHC00911, "E", LCSS_DEVNUM,

  00151	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0015a	74 12		 je	 SHORT $LN20@write_pack
  0015c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00164	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00168	89 44 24 78	 mov	 DWORD PTR tv145[rsp], eax
  0016c	eb 08		 jmp	 SHORT $LN21@write_pack
$LN20@write_pack:
  0016e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN21@write_pack:
  00176	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0017f	74 14		 je	 SHORT $LN22@write_pack
  00181	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00189	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0018d	d1 f8		 sar	 eax, 1
  0018f	89 44 24 7c	 mov	 DWORD PTR tv151[rsp], eax
  00193	eb 08		 jmp	 SHORT $LN23@write_pack
$LN22@write_pack:
  00195	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN23@write_pack:
  0019d	8b 4c 24 70	 mov	 ecx, DWORD PTR errnum$[rsp]
  001a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001a7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv134[rsp], rax
  001af	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  001b7	48 83 c1 60	 add	 rcx, 96			; 00000060H
  001bb	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv138[rsp], rcx
  001c3	b9 01 00 00 00	 mov	 ecx, 1
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ce	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv134[rsp]
  001d6	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001db	8b 4c 24 70	 mov	 ecx, DWORD PTR errnum$[rsp]
  001df	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  001e3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv138[rsp]
  001eb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001fc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00201	8b 4c 24 78	 mov	 ecx, DWORD PTR tv145[rsp]
  00205	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00209	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv151[rsp]
  0020d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172766
  00218	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172767
  00224	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00234	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172768
  0023b	ba ec 0a 00 00	 mov	 edx, 2796		; 00000aecH
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172769
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2796 :         dev->typname, grp->ttifname, errnum, strerror( errnum ));
; 2797 :     errno = errnum;

  0024d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00253	8b 4c 24 70	 mov	 ecx, DWORD PTR errnum$[rsp]
  00257	89 08		 mov	 DWORD PTR [rax], ecx
$LN10@write_pack:

; 2798 :     PTT_QETH_TRACE( "wrpack exit", 0, pktlen, QRC_EIOERR );

  00259	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00260	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00263	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00269	48 85 c0	 test	 rax, rax
  0026c	74 3e		 je	 SHORT $LN14@write_pack
  0026e	48 63 84 24 c8
	00 00 00	 movsxd	 rax, DWORD PTR pktlen$[rsp]
  00276	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0027f	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  00288	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172771
  0028f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00294	4c 8b c8	 mov	 r9, rax
  00297	45 33 c0	 xor	 r8d, r8d
  0029a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172772
  002a1	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@write_pack:
  002ac	33 c0		 xor	 eax, eax
  002ae	85 c0		 test	 eax, eax
  002b0	75 a7		 jne	 SHORT $LN10@write_pack

; 2799 :     return QRC_EIOERR;

  002b2	b8 ff ff ff ff	 mov	 eax, -1
$LN1@write_pack:

; 2800 : }

  002b7	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002be	c3		 ret	 0
write_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
errnum$ = 112
tv91 = 116
tv152 = 120
tv158 = 124
tv190 = 128
tv141 = 136
tv145 = 144
dev$ = 176
grp$ = 184
read_packet PROC

; 2734 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@read_packe:

; 2735 :     int errnum;
; 2736 : 
; 2737 :     PTT_QETH_TRACE( "rdpack entr", dev->bufsize, 0, 0 );

  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00021	48 85 c0	 test	 rax, rax
  00024	74 45		 je	 SHORT $LN17@read_packe
  00026	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002e	48 63 80 d8 01
	00 00		 movsxd	 rax, DWORD PTR [rax+472]
  00035	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0003e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172698
  0004e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00053	45 33 c9	 xor	 r9d, r9d
  00056	4c 8b c0	 mov	 r8, rax
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172699
  00060	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN17@read_packe:
  0006b	33 c0		 xor	 eax, eax
  0006d	85 c0		 test	 eax, eax
  0006f	75 a0		 jne	 SHORT $LN4@read_packe

; 2738 :     dev->buflen = TUNTAP_Read( dev->fd, dev->buf, dev->bufsize );

  00071	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00079	44 8b 80 d8 01
	00 00		 mov	 r8d, DWORD PTR [rax+472]
  00080	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00088	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  0008f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00097	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0009d	e8 00 00 00 00	 call	 tt32_read
  000a2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000aa	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 2739 :     errnum = errno;

  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b6	8b 00		 mov	 eax, DWORD PTR [rax]
  000b8	89 44 24 70	 mov	 DWORD PTR errnum$[rsp], eax

; 2740 : 
; 2741 :     if (unlikely(dev->buflen < 0))

  000bc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c4	83 b8 dc 01 00
	00 00		 cmp	 DWORD PTR [rax+476], 0
  000cb	7d 0a		 jge	 SHORT $LN29@read_packe
  000cd	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv91[rsp], 1
  000d5	eb 08		 jmp	 SHORT $LN30@read_packe
$LN29@read_packe:
  000d7	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv91[rsp], 0
$LN30@read_packe:
  000df	83 7c 24 74 00	 cmp	 DWORD PTR tv91[rsp], 0
  000e4	0f 84 16 02 00
	00		 je	 $LN18@read_packe

; 2742 :     {
; 2743 :         if (errnum == EAGAIN)

  000ea	83 7c 24 70 0b	 cmp	 DWORD PTR errnum$[rsp], 11
  000ef	0f 85 8a 00 00
	00		 jne	 $LN19@read_packe

; 2744 :         {
; 2745 :             errno = EAGAIN;

  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000fb	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11
$LN7@read_packe:

; 2746 :             PTT_QETH_TRACE( "rdpack exit", dev->bufsize, dev->buflen, QRC_EPKEOF );

  00101	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00108	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0010b	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00111	48 85 c0	 test	 rax, rax
  00114	74 54		 je	 SHORT $LN21@read_packe
  00116	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011e	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  00125	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012d	48 63 89 d8 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+472]
  00134	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0013d	48 c7 44 24 28
	fc ff ff ff	 mov	 QWORD PTR [rsp+40], -4
  00146	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172704
  0014d	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00152	4c 8b c8	 mov	 r9, rax
  00155	4c 8b c1	 mov	 r8, rcx
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172705
  0015f	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN21@read_packe:
  0016a	33 c0		 xor	 eax, eax
  0016c	85 c0		 test	 eax, eax
  0016e	75 91		 jne	 SHORT $LN7@read_packe

; 2747 :             return QRC_EPKEOF;

  00170	b8 fc ff ff ff	 mov	 eax, -4
  00175	e9 d1 02 00 00	 jmp	 $LN1@read_packe

; 2748 :         }

  0017a	e9 81 01 00 00	 jmp	 $LN20@read_packe
$LN19@read_packe:

; 2749 :         else
; 2750 :         {
; 2751 :             // HHC00912 "%1d:%04X %s: error reading from device %s: %d %s"
; 2752 :             WRMSG(HHC00912, "E", LCSS_DEVNUM,

  0017f	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00188	74 12		 je	 SHORT $LN31@read_packe
  0018a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00192	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00196	89 44 24 78	 mov	 DWORD PTR tv152[rsp], eax
  0019a	eb 08		 jmp	 SHORT $LN32@read_packe
$LN31@read_packe:
  0019c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN32@read_packe:
  001a4	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ad	74 14		 je	 SHORT $LN33@read_packe
  001af	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001bb	d1 f8		 sar	 eax, 1
  001bd	89 44 24 7c	 mov	 DWORD PTR tv158[rsp], eax
  001c1	eb 08		 jmp	 SHORT $LN34@read_packe
$LN33@read_packe:
  001c3	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN34@read_packe:
  001cb	8b 4c 24 70	 mov	 ecx, DWORD PTR errnum$[rsp]
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001d5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
  001dd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  001e5	48 83 c1 60	 add	 rcx, 96			; 00000060H
  001e9	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv145[rsp], rcx
  001f1	b9 01 00 00 00	 mov	 ecx, 1
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001fc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv141[rsp]
  00204	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00209	8b 4c 24 70	 mov	 ecx, DWORD PTR errnum$[rsp]
  0020d	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00211	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv145[rsp]
  00219	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0021e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00226	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0022a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0022f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv152[rsp]
  00233	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00237	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv158[rsp]
  0023b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0023f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172706
  00246	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0024b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172707
  00252	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00257	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0025c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00262	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172708
  00269	ba c1 0a 00 00	 mov	 edx, 2753		; 00000ac1H
  0026e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172709
  00275	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2753 :                 dev->typname, grp->ttifname, errnum, strerror( errnum ));
; 2754 :             errno = errnum;

  0027b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00281	8b 4c 24 70	 mov	 ecx, DWORD PTR errnum$[rsp]
  00285	89 08		 mov	 DWORD PTR [rax], ecx
$LN10@read_packe:

; 2755 :             PTT_QETH_TRACE( "rdpack exit", dev->bufsize, dev->buflen, QRC_EIOERR );

  00287	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0028e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00291	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00297	48 85 c0	 test	 rax, rax
  0029a	74 54		 je	 SHORT $LN22@read_packe
  0029c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a4	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  002ab	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b3	48 63 89 d8 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+472]
  002ba	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  002c3	48 c7 44 24 28
	ff ff ff ff	 mov	 QWORD PTR [rsp+40], -1
  002cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172711
  002d3	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002d8	4c 8b c8	 mov	 r9, rax
  002db	4c 8b c1	 mov	 r8, rcx
  002de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172712
  002e5	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@read_packe:
  002f0	33 c0		 xor	 eax, eax
  002f2	85 c0		 test	 eax, eax
  002f4	75 91		 jne	 SHORT $LN10@read_packe

; 2756 :             return QRC_EIOERR;

  002f6	b8 ff ff ff ff	 mov	 eax, -1
  002fb	e9 4b 01 00 00	 jmp	 $LN1@read_packe
$LN20@read_packe:
$LN18@read_packe:

; 2757 :         }
; 2758 :     }
; 2759 : 
; 2760 :     if (unlikely(dev->buflen == 0))

  00300	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00308	83 b8 dc 01 00
	00 00		 cmp	 DWORD PTR [rax+476], 0
  0030f	75 0d		 jne	 SHORT $LN37@read_packe
  00311	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv190[rsp], 1
  0031c	eb 0b		 jmp	 SHORT $LN38@read_packe
$LN37@read_packe:
  0031e	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv190[rsp], 0
$LN38@read_packe:
  00329	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv190[rsp], 0
  00331	0f 84 85 00 00
	00		 je	 $LN23@read_packe

; 2761 :     {
; 2762 :         errno = EAGAIN;

  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0033d	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11
$LN13@read_packe:

; 2763 :         PTT_QETH_TRACE( "rdpack exit", dev->bufsize, dev->buflen, QRC_EPKEOF );

  00343	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0034a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0034d	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00353	48 85 c0	 test	 rax, rax
  00356	74 54		 je	 SHORT $LN24@read_packe
  00358	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00360	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  00367	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0036f	48 63 89 d8 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+472]
  00376	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0037f	48 c7 44 24 28
	fc ff ff ff	 mov	 QWORD PTR [rsp+40], -4
  00388	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172715
  0038f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00394	4c 8b c8	 mov	 r9, rax
  00397	4c 8b c1	 mov	 r8, rcx
  0039a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172716
  003a1	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  003a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@read_packe:
  003ac	33 c0		 xor	 eax, eax
  003ae	85 c0		 test	 eax, eax
  003b0	75 91		 jne	 SHORT $LN13@read_packe

; 2764 :         return QRC_EPKEOF;

  003b2	b8 fc ff ff ff	 mov	 eax, -4
  003b7	e9 8f 00 00 00	 jmp	 $LN1@read_packe
$LN23@read_packe:

; 2765 :     }
; 2766 : 
; 2767 :     /* Count packets received */
; 2768 :     dev->qdio.rxcnt++;

  003bc	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003c4	8b 80 28 13 00
	00		 mov	 eax, DWORD PTR [rax+4904]
  003ca	ff c0		 inc	 eax
  003cc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d4	89 81 28 13 00
	00		 mov	 DWORD PTR [rcx+4904], eax
$LN16@read_packe:

; 2769 : 
; 2770 :     PTT_QETH_TRACE( "rdpack exit", dev->bufsize, dev->buflen, QRC_SUCCESS );

  003da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  003e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003e4	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  003ea	48 85 c0	 test	 rax, rax
  003ed	74 54		 je	 SHORT $LN25@read_packe
  003ef	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f7	48 63 80 dc 01
	00 00		 movsxd	 rax, DWORD PTR [rax+476]
  003fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00406	48 63 89 d8 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+472]
  0040d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00416	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172718
  00426	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0042b	4c 8b c8	 mov	 r9, rax
  0042e	4c 8b c1	 mov	 r8, rcx
  00431	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172719
  00438	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0043d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN25@read_packe:
  00443	33 c0		 xor	 eax, eax
  00445	85 c0		 test	 eax, eax
  00447	75 91		 jne	 SHORT $LN16@read_packe

; 2771 :     return QRC_SUCCESS;

  00449	33 c0		 xor	 eax, eax
$LN1@read_packe:

; 2772 : }

  0044b	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00452	c3		 ret	 0
read_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv74 = 32
tv$ = 40
readset$ = 48
__$ArrayPad$ = 8256
dev$ = 8288
more_packets PROC

; 2720 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 58 20 00 00	 mov	 eax, 8280		; 00002058H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 40
	20 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2721 :     fd_set readset;
; 2722 :     struct timeval tv = {0,0};

  00024	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv$[rsp], 0
  0002c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv$[rsp+4], 0

; 2723 :     FD_ZERO( &readset );

  00034	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR readset$[rsp], 0

; 2724 :     FD_SET( dev->fd, &readset );

  0003c	48 8d 54 24 30	 lea	 rdx, QWORD PTR readset$[rsp]
  00041	48 8b 84 24 60
	20 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00049	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 2725 :     return (qeth_select( dev->fd+1, &readset, &tv ) > 0);

  00055	48 8b 84 24 60
	20 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005d	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  00063	ff c0		 inc	 eax
  00065	4c 8d 44 24 28	 lea	 r8, QWORD PTR tv$[rsp]
  0006a	48 8d 54 24 30	 lea	 rdx, QWORD PTR readset$[rsp]
  0006f	8b c8		 mov	 ecx, eax
  00071	e8 00 00 00 00	 call	 qeth_select
  00076	85 c0		 test	 eax, eax
  00078	7e 0a		 jle	 SHORT $LN3@more_packe
  0007a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00082	eb 08		 jmp	 SHORT $LN4@more_packe
$LN3@more_packe:
  00084	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN4@more_packe:
  0008c	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv74[rsp]

; 2726 : }

  00091	48 8b 8c 24 40
	20 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00099	48 33 cc	 xor	 rcx, rsp
  0009c	e8 00 00 00 00	 call	 __security_check_cookie
  000a1	48 81 c4 58 20
	00 00		 add	 rsp, 8280		; 00002058H
  000a8	c3		 ret	 0
more_packets ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 32
dest_addr$ = 64
grp$ = 72
l3_cast_type_ipv6 PROC

; 2686 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2687 :     static const BYTE dest_zero[16] = {0};
; 2688 :     int i;
; 2689 : 
; 2690 :     /* Note: why check for the any address? */
; 2691 :     if (memcmp( dest_addr, dest_zero, 16 ) == 0)

  0000e	41 b8 10 00 00
	00		 mov	 r8d, 16
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?dest_zero@?1??l3_cast_type_ipv6@@9@9
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_addr$[rsp]
  00020	e8 00 00 00 00	 call	 memcmp
  00025	85 c0		 test	 eax, eax
  00027	75 07		 jne	 SHORT $LN5@l3_cast_ty

; 2692 :         return HDR3_FLAGS_NOCAST;

  00029	33 c0		 xor	 eax, eax
  0002b	e9 8e 00 00 00	 jmp	 $LN1@l3_cast_ty
$LN5@l3_cast_ty:

; 2693 : 
; 2694 :     if (dest_addr[0] == 0xFF)

  00030	b8 01 00 00 00	 mov	 eax, 1
  00035	48 6b c0 00	 imul	 rax, rax, 0
  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_addr$[rsp]
  0003e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00042	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00047	75 07		 jne	 SHORT $LN6@l3_cast_ty

; 2695 :         return HDR3_FLAGS_MULTICAST;

  00049	b8 04 00 00 00	 mov	 eax, 4
  0004e	eb 6e		 jmp	 SHORT $LN1@l3_cast_ty
$LN6@l3_cast_ty:

; 2696 : 
; 2697 :     /* Check whether the IPv6 address is in the table. */
; 2698 :     for (i = 0; i < OSA_MAXIPV6; i++)

  00050	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00058	eb 0a		 jmp	 SHORT $LN4@l3_cast_ty
$LN2@l3_cast_ty:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005e	ff c0		 inc	 eax
  00060	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@l3_cast_ty:
  00064	83 7c 24 20 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00069	7d 4e		 jge	 SHORT $LN3@l3_cast_ty

; 2699 :     {
; 2700 :         if (grp->ipaddr6[i].type == IPV6_TYPE_INUSE &&

  0006b	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00070	48 6b c0 14	 imul	 rax, rax, 20
  00074	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00079	83 bc 01 e8 01
	00 00 01	 cmp	 DWORD PTR [rcx+rax+488], 1
  00081	75 34		 jne	 SHORT $LN7@l3_cast_ty
  00083	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00088	48 6b c0 14	 imul	 rax, rax, 20
  0008c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00091	48 8d 84 01 d8
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+472]
  00099	41 b8 10 00 00
	00		 mov	 r8d, 16
  0009f	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest_addr$[rsp]
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	e8 00 00 00 00	 call	 memcmp
  000ac	85 c0		 test	 eax, eax
  000ae	75 07		 jne	 SHORT $LN7@l3_cast_ty

; 2701 :             memcmp(grp->ipaddr6[i].addr, dest_addr, 16) == 0)
; 2702 :         {
; 2703 :             return HDR3_FLAGS_UNICAST;

  000b0	b8 06 00 00 00	 mov	 eax, 6
  000b5	eb 07		 jmp	 SHORT $LN1@l3_cast_ty
$LN7@l3_cast_ty:

; 2704 :         }
; 2705 :     }

  000b7	eb a1		 jmp	 SHORT $LN2@l3_cast_ty
$LN3@l3_cast_ty:

; 2706 : 
; 2707 :     /* Oh dear, the IPv6 address isn't in the table. */
; 2708 :     return HDR3_FLAGS_NOTFORUS;

  000b9	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$LN1@l3_cast_ty:

; 2709 : }

  000be	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c2	c3		 ret	 0
l3_cast_type_ipv6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 32
dest_hbo$ = 36
mask_hbo$ = 40
dest_addr$ = 64
grp$ = 72
l3_cast_type_ipv4 PROC

; 2655 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2656 : U32 dest_hbo;
; 2657 : U32 mask_hbo;
; 2658 : int i;
; 2659 :     FETCH_FW(dest_hbo, dest_addr);

  0000e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest_addr$[rsp]
  00013	e8 00 00 00 00	 call	 fetch_fw_noswap
  00018	8b c8		 mov	 ecx, eax
  0001a	e8 00 00 00 00	 call	 _byteswap_ulong
  0001f	89 44 24 24	 mov	 DWORD PTR dest_hbo$[rsp], eax

; 2660 :     FETCH_FW(mask_hbo, grp->confpfxmask4);

  00023	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00028	48 05 b4 00 00
	00		 add	 rax, 180		; 000000b4H
  0002e	48 8b c8	 mov	 rcx, rax
  00031	e8 00 00 00 00	 call	 fetch_fw_noswap
  00036	8b c8		 mov	 ecx, eax
  00038	e8 00 00 00 00	 call	 _byteswap_ulong
  0003d	89 44 24 28	 mov	 DWORD PTR mask_hbo$[rsp], eax

; 2661 :     /* Note: why check for the loopback address? */
; 2662 :     if (!dest_hbo)

  00041	83 7c 24 24 00	 cmp	 DWORD PTR dest_hbo$[rsp], 0
  00046	75 07		 jne	 SHORT $LN5@l3_cast_ty

; 2663 :         return HDR3_FLAGS_NOCAST;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 96 00 00 00	 jmp	 $LN1@l3_cast_ty
$LN5@l3_cast_ty:

; 2664 :     if ((dest_hbo & 0xF0000000) == 0xE0000000) // 224-239 (E0-EF)

  0004f	8b 44 24 24	 mov	 eax, DWORD PTR dest_hbo$[rsp]
  00053	25 00 00 00 f0	 and	 eax, -268435456		; f0000000H
  00058	3d 00 00 00 e0	 cmp	 eax, -536870912		; e0000000H
  0005d	75 07		 jne	 SHORT $LN6@l3_cast_ty

; 2665 :         return HDR3_FLAGS_MULTICAST;

  0005f	b8 04 00 00 00	 mov	 eax, 4
  00064	eb 7f		 jmp	 SHORT $LN1@l3_cast_ty
$LN6@l3_cast_ty:

; 2666 :     if ((dest_hbo & mask_hbo) == mask_hbo)

  00066	8b 44 24 28	 mov	 eax, DWORD PTR mask_hbo$[rsp]
  0006a	8b 4c 24 24	 mov	 ecx, DWORD PTR dest_hbo$[rsp]
  0006e	23 c8		 and	 ecx, eax
  00070	8b c1		 mov	 eax, ecx
  00072	3b 44 24 28	 cmp	 eax, DWORD PTR mask_hbo$[rsp]
  00076	75 07		 jne	 SHORT $LN7@l3_cast_ty

; 2667 :         return HDR3_FLAGS_BROADCAST;

  00078	b8 05 00 00 00	 mov	 eax, 5
  0007d	eb 66		 jmp	 SHORT $LN1@l3_cast_ty
$LN7@l3_cast_ty:

; 2668 : 
; 2669 :     /* Check whether the IPv4 address is in the table. */
; 2670 :     for (i = 0; i < OSA_MAXIPV4; i++)

  0007f	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00087	eb 0a		 jmp	 SHORT $LN4@l3_cast_ty
$LN2@l3_cast_ty:
  00089	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0008d	ff c0		 inc	 eax
  0008f	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@l3_cast_ty:
  00093	83 7c 24 20 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00098	7d 46		 jge	 SHORT $LN3@l3_cast_ty

; 2671 :     {
; 2672 :         if (grp->ipaddr4[i].type == IPV4_TYPE_INUSE &&

  0009a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0009f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  000a4	83 bc c1 dc 00
	00 00 01	 cmp	 DWORD PTR [rcx+rax*8+220], 1
  000ac	75 30		 jne	 SHORT $LN8@l3_cast_ty
  000ae	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000b3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  000b8	48 8d 84 c1 d8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+216]
  000c0	41 b8 04 00 00
	00		 mov	 r8d, 4
  000c6	48 8b 54 24 40	 mov	 rdx, QWORD PTR dest_addr$[rsp]
  000cb	48 8b c8	 mov	 rcx, rax
  000ce	e8 00 00 00 00	 call	 memcmp
  000d3	85 c0		 test	 eax, eax
  000d5	75 07		 jne	 SHORT $LN8@l3_cast_ty

; 2673 :             memcmp(grp->ipaddr4[i].addr, dest_addr, 4) == 0)
; 2674 :         {
; 2675 :             return HDR3_FLAGS_UNICAST;

  000d7	b8 06 00 00 00	 mov	 eax, 6
  000dc	eb 07		 jmp	 SHORT $LN1@l3_cast_ty
$LN8@l3_cast_ty:

; 2676 :         }
; 2677 :     }

  000de	eb a9		 jmp	 SHORT $LN2@l3_cast_ty
$LN3@l3_cast_ty:

; 2678 :     return HDR3_FLAGS_NOTFORUS;

  000e0	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
$LN1@l3_cast_ty:

; 2679 : }

  000e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e9	c3		 ret	 0
l3_cast_type_ipv4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv153 = 96
tv159 = 100
sblen$ = 104
sba$ = 112
sbala$ = 120
errmsg$ = 128
__$ArrayPad$ = 384
msg$ = 416
qrc$ = 424
dev$ = 432
sbal$ = 440
sbalk$ = 448
sb$ = 456
SBALE_Error PROC

; 2583 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2584 :     char errmsg[256] = {0};

  0002e	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR errmsg$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00040	f3 aa		 rep stosb

; 2585 :     U64 sbala = (U64)((BYTE*)sbal - dev->mainstor);

  00042	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004a	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00051	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  00059	48 2b c8	 sub	 rcx, rax
  0005c	48 8b c1	 mov	 rax, rcx
  0005f	48 89 44 24 78	 mov	 QWORD PTR sbala$[rsp], rax

; 2586 :     U64 sba;
; 2587 :     U32 sblen;
; 2588 : 
; 2589 :     FETCH_DW( sba,   sbal->sbale[sb].addr   );

  00064	48 63 84 24 c8
	01 00 00	 movsxd	 rax, DWORD PTR sb$[rsp]
  0006c	48 6b c0 10	 imul	 rax, rax, 16
  00070	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  00078	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 fetch_dw_noswap
  00085	48 8b c8	 mov	 rcx, rax
  00088	e8 00 00 00 00	 call	 _byteswap_uint64
  0008d	48 89 44 24 70	 mov	 QWORD PTR sba$[rsp], rax

; 2590 :     FETCH_FW( sblen, sbal->sbale[sb].length );

  00092	48 63 84 24 c8
	01 00 00	 movsxd	 rax, DWORD PTR sb$[rsp]
  0009a	48 6b c0 10	 imul	 rax, rax, 16
  0009e	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  000a6	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	e8 00 00 00 00	 call	 fetch_fw_noswap
  000b3	8b c8		 mov	 ecx, eax
  000b5	e8 00 00 00 00	 call	 _byteswap_ulong
  000ba	89 44 24 68	 mov	 DWORD PTR sblen$[rsp], eax

; 2591 : 
; 2592 :     MSGBUF( errmsg, msg, sb, sbala, sbalk, sba, sblen,

  000be	48 63 84 24 c8
	01 00 00	 movsxd	 rax, DWORD PTR sb$[rsp]
  000c6	48 6b c0 10	 imul	 rax, rax, 16
  000ca	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR sbal$[rsp]
  000d2	48 03 c8	 add	 rcx, rax
  000d5	48 8b c1	 mov	 rax, rcx
  000d8	b9 01 00 00 00	 mov	 ecx, 1
  000dd	48 6b c9 03	 imul	 rcx, rcx, 3
  000e1	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000e5	48 63 8c 24 c8
	01 00 00	 movsxd	 rcx, DWORD PTR sb$[rsp]
  000ed	48 6b c9 10	 imul	 rcx, rcx, 16
  000f1	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR sbal$[rsp]
  000f9	48 03 d1	 add	 rdx, rcx
  000fc	48 8b ca	 mov	 rcx, rdx
  000ff	ba 01 00 00 00	 mov	 edx, 1
  00104	48 6b d2 00	 imul	 rdx, rdx, 0
  00108	0f b6 0c 11	 movzx	 ecx, BYTE PTR [rcx+rdx]
  0010c	0f b6 94 24 c0
	01 00 00	 movzx	 edx, BYTE PTR sbalk$[rsp]
  00114	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00118	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0011c	8b 44 24 68	 mov	 eax, DWORD PTR sblen$[rsp]
  00120	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00124	48 8b 44 24 70	 mov	 rax, QWORD PTR sba$[rsp]
  00129	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0012e	89 54 24 28	 mov	 DWORD PTR [rsp+40], edx
  00132	48 8b 44 24 78	 mov	 rax, QWORD PTR sbala$[rsp]
  00137	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0013c	44 8b 8c 24 c8
	01 00 00	 mov	 r9d, DWORD PTR sb$[rsp]
  00144	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR msg$[rsp]
  0014c	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00151	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR errmsg$[rsp]
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2593 :         sbal->sbale[sb].flags[0],
; 2594 :         sbal->sbale[sb].flags[3]);
; 2595 : 
; 2596 :     // HHC03985 "%1d:%04X %s: %s"
; 2597 :     WRMSG( HHC03985, "E", LCSS_DEVNUM,

  0015f	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00168	74 12		 je	 SHORT $LN3@SBALE_Erro
  0016a	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00172	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00176	89 44 24 60	 mov	 DWORD PTR tv153[rsp], eax
  0017a	eb 08		 jmp	 SHORT $LN4@SBALE_Erro
$LN3@SBALE_Erro:
  0017c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN4@SBALE_Erro:
  00184	48 83 bc 24 b0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0018d	74 14		 je	 SHORT $LN5@SBALE_Erro
  0018f	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00197	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0019b	d1 f8		 sar	 eax, 1
  0019d	89 44 24 64	 mov	 DWORD PTR tv159[rsp], eax
  001a1	eb 08		 jmp	 SHORT $LN6@SBALE_Erro
$LN5@SBALE_Erro:
  001a3	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN6@SBALE_Erro:
  001ab	b9 01 00 00 00	 mov	 ecx, 1
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b6	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR errmsg$[rsp]
  001be	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001c3	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001cb	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001cf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d4	8b 4c 24 60	 mov	 ecx, DWORD PTR tv153[rsp]
  001d8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001dc	8b 4c 24 64	 mov	 ecx, DWORD PTR tv159[rsp]
  001e0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172603
  001eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172604
  001f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00201	41 b9 03 00 00
	00		 mov	 r9d, 3
  00207	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172605
  0020e	ba 26 0a 00 00	 mov	 edx, 2598		; 00000a26H
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172606
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2598 :         dev->typname, errmsg );
; 2599 : 
; 2600 :     return qrc;

  00220	0f b7 84 24 a8
	01 00 00	 movzx	 eax, WORD PTR qrc$[rsp]

; 2601 : }

  00228	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00230	48 33 cc	 xor	 rcx, rsp
  00233	e8 00 00 00 00	 call	 __security_check_cookie
  00238	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  0023f	5f		 pop	 rdi
  00240	c3		 ret	 0
SBALE_Error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 48
dev$ = 80
raise_adapter_interrupt PROC

; 2504 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2505 :     OSA_GRP* grp = (OSA_GRP*) dev->group->grp_data;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00016	48 89 44 24 30	 mov	 QWORD PTR grp$[rsp], rax

; 2506 : 
; 2507 :     /* Don't waste time queuing interrupts during power off sequence */
; 2508 :     if (sysblk.shutdown)

  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00022	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00028	c1 e8 0b	 shr	 eax, 11
  0002b	83 e0 01	 and	 eax, 1
  0002e	85 c0		 test	 eax, eax
  00030	74 05		 je	 SHORT $LN4@raise_adap

; 2509 :         return;

  00032	e9 56 01 00 00	 jmp	 $LN1@raise_adap
$LN4@raise_adap:
$LN2@raise_adap:

; 2510 : 
; 2511 :     /* Keep trying to OBTAIN_INTLOCK until we either succeed
; 2512 :        or we detect that a halt/clear subchannel was requested
; 2513 :        (which would cause a deadlock if we just blindly tried
; 2514 :        to obtain it).  Note that we test for the halt or clear
; 2515 :        subchannel request WITHOUT first obtaining dev->lock to
; 2516 :        prevent a deadlock that would occur for the same reason
; 2517 :        (since channel.c holds BOTH during HSCH/CSCH processing).
; 2518 :     */
; 2519 :     while (!(dev->scsw.flag2 & (SCSW2_FC_HALT | SCSW2_FC_CLEAR)))

  00037	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00043	83 e0 30	 and	 eax, 48			; 00000030H
  00046	85 c0		 test	 eax, eax
  00048	0f 85 3f 01 00
	00		 jne	 $LN3@raise_adap

; 2520 :     {
; 2521 :         /* Try to obtain the interrupt lock (OBTAIN_INTLOCK) */
; 2522 :         if (TRY_OBTAIN_INTLOCK( NULL ) == 0)

  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172571
  00055	33 c9		 xor	 ecx, ecx
  00057	e8 00 00 00 00	 call	 Try_Obtain_Interrupt_Lock
  0005c	85 c0		 test	 eax, eax
  0005e	0f 85 1e 01 00
	00		 jne	 $LN5@raise_adap

; 2523 :         {
; 2524 :             /* Interrupt lock obtained; queue the interrupt */
; 2525 :             obtain_lock( &dev->lock );

  00064	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00069	48 83 c0 38	 add	 rax, 56			; 00000038H
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172572
  00074	48 8b c8	 mov	 rcx, rax
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2526 :             {
; 2527 :                 if (grp->debugmask & DBGQETHINTRUPT)

  0007d	48 8b 44 24 30	 mov	 rax, QWORD PTR grp$[rsp]
  00082	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  00088	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0008d	85 c0		 test	 eax, eax
  0008f	74 29		 je	 SHORT $LN6@raise_adap

; 2528 :                     DBGTRC( dev, "Adapter Interrupt" );

  00091	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172574
  00098	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009d	4c 8b 4c 24 50	 mov	 r9, QWORD PTR dev$[rsp]
  000a2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172575
  000a9	ba e0 09 00 00	 mov	 edx, 2528		; 000009e0H
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172576
  000b5	e8 00 00 00 00	 call	 dbgtrc
$LN6@raise_adap:

; 2529 : 
; 2530 :                 dev->pciscsw.flag2 |= SCSW2_Q | SCSW2_FC_START;

  000ba	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000bf	0f b6 80 16 03
	00 00		 movzx	 eax, BYTE PTR [rax+790]
  000c6	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  000cb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000d0	88 81 16 03 00
	00		 mov	 BYTE PTR [rcx+790], al

; 2531 :                 dev->pciscsw.flag3 |= SCSW3_SC_INTER | SCSW3_SC_PEND;

  000d6	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000db	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000e2	83 c8 09	 or	 eax, 9
  000e5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000ea	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al

; 2532 :                 dev->pciscsw.chanstat = CSW_PCI;

  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000f5	c6 80 1d 03 00
	00 80		 mov	 BYTE PTR [rax+797], 128	; 00000080H

; 2533 : 
; 2534 :                 obtain_lock( &sysblk.iointqlk );

  000fc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00103	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00109	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172577
  00110	48 8b c8	 mov	 rcx, rax
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2535 :                 {
; 2536 :                     QUEUE_IO_INTERRUPT_QLOCKED( &dev->pciioint, FALSE );

  00119	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0011e	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  00124	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172578
  0012b	33 d2		 xor	 edx, edx
  0012d	48 8b c8	 mov	 rcx, rax
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Queue_IO_Interrupt_QLocked

; 2537 :                     UPDATE_IC_IOPENDING_QLOCKED();

  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Update_IC_IOPENDING_QLocked

; 2538 :                 }
; 2539 :                 release_lock( &sysblk.iointqlk );

  0013c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00143	48 05 78 10 00
	00		 add	 rax, 4216		; 00001078H
  00149	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172579
  00150	48 8b c8	 mov	 rcx, rax
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2540 :             }
; 2541 :             release_lock( &dev->lock );

  00159	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0015e	48 83 c0 38	 add	 rax, 56			; 00000038H
  00162	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172580
  00169	48 8b c8	 mov	 rcx, rax
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2542 : 
; 2543 :             RELEASE_INTLOCK( NULL );

  00172	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172581
  00179	33 c9		 xor	 ecx, ecx
  0017b	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 2544 :             return;

  00180	eb 0b		 jmp	 SHORT $LN1@raise_adap
$LN5@raise_adap:

; 2545 :         }
; 2546 : 
; 2547 :         /* Yield to hopefully allow current lock owner a chance
; 2548 :            to finish using it and release it before we try again.
; 2549 :         */
; 2550 :         sched_yield();

  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 2551 :     }

  00188	e9 aa fe ff ff	 jmp	 $LN2@raise_adap
$LN3@raise_adap:
$LN1@raise_adap:

; 2552 : 
; 2553 :     /* Halt/Clear Subchannel was requested for device.
; 2554 :        Return immediately without queuing any interrupt.
; 2555 :     */
; 2556 : }

  0018d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00191	c3		 ret	 0
raise_adapter_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
reqtype$ = 96
tv85 = 100
tv258 = 104
tv264 = 108
iear$ = 112
rsp_bhr$ = 120
grp$ = 128
dev$ = 176
iea$ = 184
ieasize$ = 192
osa_device_cmd PROC

; 2373 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 2374 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00018	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00020	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00024	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00028	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR grp$[rsp], rax

; 2375 : OSA_BHR *rsp_bhr;
; 2376 : MPC_IEAR *iear;
; 2377 : U16 reqtype;
; 2378 : 
; 2379 :     /* Allocate a buffer to which the IEA will be copied */
; 2380 :     /* and then modified, to become the IEAR.            */
; 2381 :     rsp_bhr = alloc_buffer( dev, ieasize+10 );

  00030	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ieasize$[rsp]
  00037	83 c0 0a	 add	 eax, 10
  0003a	8b d0		 mov	 edx, eax
  0003c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00044	e8 00 00 00 00	 call	 alloc_buffer
  00049	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 2382 :     if (!rsp_bhr)

  0004e	48 83 7c 24 78
	00		 cmp	 QWORD PTR rsp_bhr$[rsp], 0
  00054	75 05		 jne	 SHORT $LN4@osa_device

; 2383 :         return;

  00056	e9 ad 05 00 00	 jmp	 $LN1@osa_device
$LN4@osa_device:

; 2384 :     rsp_bhr->datalen = ieasize;

  0005b	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  00060	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR ieasize$[rsp]
  00067	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 2385 : 
; 2386 :     /* Point to response IEAR. */
; 2387 :     iear = (MPC_IEAR*)((BYTE*)rsp_bhr + SizeBHR);

  0006a	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  0006f	48 83 c0 18	 add	 rax, 24
  00073	48 89 44 24 70	 mov	 QWORD PTR iear$[rsp], rax

; 2388 : 
; 2389 :     /* Copy request to response buffer. */
; 2390 :     memcpy(iear, iea, ieasize);

  00078	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR ieasize$[rsp]
  00080	48 8b 7c 24 70	 mov	 rdi, QWORD PTR iear$[rsp]
  00085	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR iea$[rsp]
  0008d	48 8b c8	 mov	 rcx, rax
  00090	f3 a4		 rep movsb

; 2391 : 
; 2392 :     /*  The IDX_ACT_TYPE_READ and IDX_ACT_TYPE_WRITE requests & responses     */
; 2393 :     /*  tell the OSA adapter which of its 256 potential device addresses      */
; 2394 :     /*  make up the, in QETH terms, group. The IDX_ACT_TYPE_READ request      */
; 2395 :     /*  identifies the read device, and the IDX_ACT_TYPE_WRITE request        */
; 2396 :     /*  identifies the write device. Each of the requests contains a list of  */
; 2397 :     /*  device(s) that will be the data device(s). As QETH only supports a    */
; 2398 :     /*  group with a single data device, we only ever see a list with a       */
; 2399 :     /*  single entry. (VTAM supports up to 238 data devices in a group.) The  */
; 2400 :     /*  requests also contain the iea->port variable containing the OSA port  */
; 2401 :     /*  number, something that is of great importance to a real OSA, but      */
; 2402 :     /*  QETH completely ignores. The requests also contains the iea->dataset  */
; 2403 :     /*  variable, which I believe contains the OSA port name for non-QDIO     */
; 2404 :     /*  OSA's (see PUS_0A).                                                   */
; 2405 :     /*  Note: I said earlier that QETH ignores the iea->port variable. What   */
; 2406 :     /*  I should have said is that QETH ignores the variable after checking   */
; 2407 :     /*  that the port number is zero. The check probably should be removed.   */
; 2408 : 
; 2409 :     FETCH_HW(reqtype, iea->type);

  00092	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR iea$[rsp]
  0009a	48 83 c0 08	 add	 rax, 8
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	e8 00 00 00 00	 call	 fetch_hw_noswap
  000a6	0f b7 c8	 movzx	 ecx, ax
  000a9	e8 00 00 00 00	 call	 _byteswap_ushort
  000ae	66 89 44 24 60	 mov	 WORD PTR reqtype$[rsp], ax

; 2410 :     switch(reqtype) {

  000b3	0f b7 44 24 60	 movzx	 eax, WORD PTR reqtype$[rsp]
  000b8	89 44 24 64	 mov	 DWORD PTR tv85[rsp], eax
  000bc	81 7c 24 64 01
	15 00 00	 cmp	 DWORD PTR tv85[rsp], 5377 ; 00001501H
  000c4	0f 84 bd 01 00
	00		 je	 $LN7@osa_device
  000ca	81 7c 24 64 01
	19 00 00	 cmp	 DWORD PTR tv85[rsp], 6401 ; 00001901H
  000d2	74 05		 je	 SHORT $LN5@osa_device
  000d4	e9 cf 03 00 00	 jmp	 $LN9@osa_device
$LN5@osa_device:

; 2411 : 
; 2412 :     case IDX_ACT_TYPE_READ:
; 2413 : 
; 2414 :         strcat( dev->dev_data, "IDX_ACT_TYPE_READ" );  /* Prepare the contentstring */

  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172530
  000e0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e8	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  000ef	e8 00 00 00 00	 call	 strcat

; 2415 :         rsp_bhr->content = strdup( dev->dev_data );

  000f4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00109	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  0010e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2416 : 
; 2417 :         /* Display the request MPC_IEA, maybe. */
; 2418 :         DBGUPD( dev, 2, iea, ieasize, FROM_GUEST, "%s: Request", dev->dev_data );

  00112	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011a	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00121	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172531
  0012d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00132	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  00137	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ieasize$[rsp]
  0013e	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00142	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR iea$[rsp]
  0014a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014f	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00157	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0015f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172532
  00166	ba 72 09 00 00	 mov	 edx, 2418		; 00000972H
  0016b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172533
  00172	e8 00 00 00 00	 call	 dbgupd

; 2419 : 
; 2420 :         if((iea->port & IDX_ACT_PORT_MASK) != OSA_PORTNO)

  00177	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR iea$[rsp]
  0017f	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00183	83 e0 3f	 and	 eax, 63			; 0000003fH
  00186	85 c0		 test	 eax, eax
  00188	74 56		 je	 SHORT $LN6@osa_device

; 2421 :         {
; 2422 :             DBGTRC(dev, "IDX_ACT_TYPE_READ: Invalid OSA Port %d",

  0018a	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR iea$[rsp]
  00192	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  00196	83 e0 3f	 and	 eax, 63			; 0000003fH
  00199	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0019d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172535
  001a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a9	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  001b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172536
  001b8	ba 77 09 00 00	 mov	 edx, 2423		; 00000977H
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172537
  001c4	e8 00 00 00 00	 call	 dbgtrc

; 2423 :                 (iea->port & IDX_ACT_PORT_MASK));
; 2424 :             dev->qdio.idxstate = MPC_IDX_STATE_INACTIVE;

  001c9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d1	c7 80 34 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4916], 0

; 2425 :             break;

  001db	e9 02 04 00 00	 jmp	 $LN2@osa_device
$LN6@osa_device:

; 2426 :         }
; 2427 : 
; 2428 :         iear->resp &= (0xFF - IDX_RSP_RESP_MASK);

  001e0	48 8b 44 24 70	 mov	 rax, QWORD PTR iear$[rsp]
  001e5	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  001e9	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  001ee	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  001f3	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 2429 :         iear->resp |= IDX_RSP_RESP_OK;

  001f6	48 8b 44 24 70	 mov	 rax, QWORD PTR iear$[rsp]
  001fb	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  001ff	83 c8 02	 or	 eax, 2
  00202	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  00207	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 2430 :         iear->flags = (IDX_RSP_FLAGS_NOPORTREQ + IDX_RSP_FLAGS_40);

  0020a	48 8b 44 24 70	 mov	 rax, QWORD PTR iear$[rsp]
  0020f	c6 40 0b c0	 mov	 BYTE PTR [rax+11], 192	; 000000c0H

; 2431 :         STORE_FW(iear->token, QTOKEN1);

  00213	b9 f1 e3 c5 d8	 mov	 ecx, -658119695		; d8c5e3f1H
  00218	e8 00 00 00 00	 call	 _byteswap_ulong
  0021d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  00222	48 83 c1 0c	 add	 rcx, 12
  00226	8b d0		 mov	 edx, eax
  00228	e8 00 00 00 00	 call	 store_fw_noswap

; 2432 :         STORE_HW(iear->flevel, IDX_RSP_FLEVEL_0201);

  0022d	66 b9 01 02	 mov	 cx, 513			; 00000201H
  00231	e8 00 00 00 00	 call	 _byteswap_ushort
  00236	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  0023b	48 83 c1 10	 add	 rcx, 16
  0023f	0f b7 d0	 movzx	 edx, ax
  00242	e8 00 00 00 00	 call	 store_hw_noswap

; 2433 :         STORE_FW(iear->uclevel, QUCLEVEL);

  00247	b9 f1 c3 d9 c8	 mov	 ecx, -925252623		; c8d9c3f1H
  0024c	e8 00 00 00 00	 call	 _byteswap_ulong
  00251	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  00256	48 83 c1 12	 add	 rcx, 18
  0025a	8b d0		 mov	 edx, eax
  0025c	e8 00 00 00 00	 call	 store_fw_noswap

; 2434 :         dev->qdio.idxstate = MPC_IDX_STATE_ACTIVE;

  00261	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00269	c7 80 34 13 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4916], 1

; 2435 :         dev->qtype = QTYPE_READ;

  00273	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0027b	c6 80 80 1b 00
	00 01		 mov	 BYTE PTR [rax+7040], 1

; 2436 : 
; 2437 :         break;

  00282	e9 5b 03 00 00	 jmp	 $LN2@osa_device
$LN7@osa_device:

; 2438 : 
; 2439 :     case IDX_ACT_TYPE_WRITE:
; 2440 : 
; 2441 :         strcat( dev->dev_data, "IDX_ACT_TYPE_WRITE" );  /* Prepare the contentstring */

  00287	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172539
  0028e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00296	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0029d	e8 00 00 00 00	 call	 strcat

; 2442 :         rsp_bhr->content = strdup( dev->dev_data );

  002a2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002aa	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  002b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  002b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  002bc	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2443 : 
; 2444 :         /* Display the request MPC_IEA, maybe. */
; 2445 :         DBGUPD( dev, 2, iea, ieasize, FROM_GUEST, "%s: Request", dev->dev_data );

  002c0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002c8	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  002cf	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  002d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172540
  002db	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  002e0	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  002e5	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ieasize$[rsp]
  002ec	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  002f0	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR iea$[rsp]
  002f8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002fd	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00305	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0030d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172541
  00314	ba 8d 09 00 00	 mov	 edx, 2445		; 0000098dH
  00319	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172542
  00320	e8 00 00 00 00	 call	 dbgupd

; 2446 : 
; 2447 :         memcpy( grp->gtissue, iea->token, MPC_TOKEN_LENGTH );  /* Remember guest token issuer */

  00325	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0032d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR iea$[rsp]
  00335	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  00338	89 88 30 06 00
	00		 mov	 DWORD PTR [rax+1584], ecx

; 2448 :         grp->ipas4 = IPA_SUPP_IPv4;

  0033e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00346	c7 80 10 06 00
	00 71 15 00 00	 mov	 DWORD PTR [rax+1552], 5489 ; 00001571H

; 2449 : #if defined( ENABLE_IPV6 )
; 2450 :         grp->ipas6 = IPA_SUPP_IPv6;

  00350	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00358	c7 80 14 06 00
	00 60 14 00 00	 mov	 DWORD PTR [rax+1556], 5216 ; 00001460H

; 2451 : #else
; 2452 :         grp->ipas6 = 0;
; 2453 : #endif
; 2454 :         grp->ipae0 = 0;

  00362	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0036a	c7 80 18 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1560], 0

; 2455 :         grp->ipae4 = 0;

  00374	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0037c	c7 80 1c 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1564], 0

; 2456 :         grp->ipae6 = 0;

  00386	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0038e	c7 80 20 06 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1568], 0

; 2457 : 
; 2458 :         if((iea->port & IDX_ACT_PORT_MASK) != OSA_PORTNO)

  00398	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR iea$[rsp]
  003a0	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  003a4	83 e0 3f	 and	 eax, 63			; 0000003fH
  003a7	85 c0		 test	 eax, eax
  003a9	74 56		 je	 SHORT $LN8@osa_device

; 2459 :         {
; 2460 :             DBGTRC(dev, "IDX_ACT_TYPE_WRITE: Invalid OSA Port %d",

  003ab	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR iea$[rsp]
  003b3	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  003b7	83 e0 3f	 and	 eax, 63			; 0000003fH
  003ba	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  003be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172544
  003c5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003ca	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  003d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172545
  003d9	ba 9d 09 00 00	 mov	 edx, 2461		; 0000099dH
  003de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172546
  003e5	e8 00 00 00 00	 call	 dbgtrc

; 2461 :                 (iea->port & IDX_ACT_PORT_MASK));
; 2462 :             dev->qdio.idxstate = MPC_IDX_STATE_INACTIVE;

  003ea	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f2	c7 80 34 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4916], 0

; 2463 :             break;

  003fc	e9 e1 01 00 00	 jmp	 $LN2@osa_device
$LN8@osa_device:

; 2464 :         }
; 2465 : 
; 2466 :         iear->resp &= (0xFF - IDX_RSP_RESP_MASK);

  00401	48 8b 44 24 70	 mov	 rax, QWORD PTR iear$[rsp]
  00406	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  0040a	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  0040f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  00414	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 2467 :         iear->resp |= IDX_RSP_RESP_OK;

  00417	48 8b 44 24 70	 mov	 rax, QWORD PTR iear$[rsp]
  0041c	0f b6 40 08	 movzx	 eax, BYTE PTR [rax+8]
  00420	83 c8 02	 or	 eax, 2
  00423	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  00428	88 41 08	 mov	 BYTE PTR [rcx+8], al

; 2468 :         iear->flags = (IDX_RSP_FLAGS_NOPORTREQ + IDX_RSP_FLAGS_40);

  0042b	48 8b 44 24 70	 mov	 rax, QWORD PTR iear$[rsp]
  00430	c6 40 0b c0	 mov	 BYTE PTR [rax+11], 192	; 000000c0H

; 2469 :         STORE_FW(iear->token, QTOKEN1);

  00434	b9 f1 e3 c5 d8	 mov	 ecx, -658119695		; d8c5e3f1H
  00439	e8 00 00 00 00	 call	 _byteswap_ulong
  0043e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  00443	48 83 c1 0c	 add	 rcx, 12
  00447	8b d0		 mov	 edx, eax
  00449	e8 00 00 00 00	 call	 store_fw_noswap

; 2470 :         STORE_HW(iear->flevel, IDX_RSP_FLEVEL_0201);

  0044e	66 b9 01 02	 mov	 cx, 513			; 00000201H
  00452	e8 00 00 00 00	 call	 _byteswap_ushort
  00457	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  0045c	48 83 c1 10	 add	 rcx, 16
  00460	0f b7 d0	 movzx	 edx, ax
  00463	e8 00 00 00 00	 call	 store_hw_noswap

; 2471 :         STORE_FW(iear->uclevel, QUCLEVEL);

  00468	b9 f1 c3 d9 c8	 mov	 ecx, -925252623		; c8d9c3f1H
  0046d	e8 00 00 00 00	 call	 _byteswap_ulong
  00472	48 8b 4c 24 70	 mov	 rcx, QWORD PTR iear$[rsp]
  00477	48 83 c1 12	 add	 rcx, 18
  0047b	8b d0		 mov	 edx, eax
  0047d	e8 00 00 00 00	 call	 store_fw_noswap

; 2472 :         dev->qdio.idxstate = MPC_IDX_STATE_ACTIVE;

  00482	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048a	c7 80 34 13 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4916], 1

; 2473 :         dev->qtype = QTYPE_WRITE;

  00494	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0049c	c6 80 80 1b 00
	00 02		 mov	 BYTE PTR [rax+7040], 2

; 2474 : 
; 2475 :         break;

  004a3	e9 3a 01 00 00	 jmp	 $LN2@osa_device
$LN9@osa_device:

; 2476 : 
; 2477 :     default:
; 2478 : 
; 2479 :         // HHC03991 "%1d:%04X %s: %s"
; 2480 :         WRMSG( HHC03991, "W", LCSS_DEVNUM, dev->typname,

  004a8	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004b1	74 12		 je	 SHORT $LN12@osa_device
  004b3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004bb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004bf	89 44 24 68	 mov	 DWORD PTR tv258[rsp], eax
  004c3	eb 08		 jmp	 SHORT $LN13@osa_device
$LN12@osa_device:
  004c5	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv258[rsp], 0
$LN13@osa_device:
  004cd	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  004d6	74 14		 je	 SHORT $LN14@osa_device
  004d8	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004e0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  004e4	d1 f8		 sar	 eax, 1
  004e6	89 44 24 6c	 mov	 DWORD PTR tv264[rsp], eax
  004ea	eb 08		 jmp	 SHORT $LN15@osa_device
$LN14@osa_device:
  004ec	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv264[rsp], 0
$LN15@osa_device:
  004f4	b9 01 00 00 00	 mov	 ecx, 1
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172548
  00506	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0050b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00513	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00517	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0051c	8b 4c 24 68	 mov	 ecx, DWORD PTR tv258[rsp]
  00520	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00524	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv264[rsp]
  00528	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0052c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172549
  00533	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00538	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172550
  0053f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00544	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00549	41 b9 03 00 00
	00		 mov	 r9d, 3
  0054f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172551
  00556	ba b1 09 00 00	 mov	 edx, 2481		; 000009b1H
  0055b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172552
  00562	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2481 :                "Unknown IDX_ACT_TYPE_xxx" );
; 2482 :         net_data_trace( dev, (BYTE*)iea, ieasize, FROM_GUEST, 'I', "IEA?", 0 );

  00568	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00570	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172553
  00577	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0057c	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  00581	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  00584	44 8b 84 24 c0
	00 00 00	 mov	 r8d, DWORD PTR ieasize$[rsp]
  0058c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR iea$[rsp]
  00594	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0059c	e8 00 00 00 00	 call	 net_data_trace

; 2483 : 
; 2484 :         dev->qdio.idxstate = MPC_IDX_STATE_INACTIVE;

  005a1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005a9	c7 80 34 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4916], 0

; 2485 : 
; 2486 :         // Free the response buffer.
; 2487 :         if (rsp_bhr->content) free( rsp_bhr->content );

  005b3	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  005b8	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  005bd	74 0f		 je	 SHORT $LN10@osa_device
  005bf	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  005c4	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN10@osa_device:

; 2488 :         free( rsp_bhr );

  005ce	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  005d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2489 :         rsp_bhr = NULL;

  005d9	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], 0
$LN2@osa_device:

; 2490 : 
; 2491 :         break;
; 2492 :     }
; 2493 : 
; 2494 :     // Add response buffer to chain.
; 2495 :     add_buffer_to_chain( &grp->idx, rsp_bhr );

  005e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  005ea	48 83 c0 18	 add	 rax, 24
  005ee	48 8b 54 24 78	 mov	 rdx, QWORD PTR rsp_bhr$[rsp]
  005f3	48 8b c8	 mov	 rcx, rax
  005f6	e8 00 00 00 00	 call	 add_buffer_to_chain

; 2496 :     signal_idx_event( grp );

  005fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00603	e8 00 00 00 00	 call	 signal_idx_event
$LN1@osa_device:

; 2497 : }

  00608	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0060f	5f		 pop	 rdi
  00610	5e		 pop	 rsi
  00611	c3		 ret	 0
osa_device_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 96
ipa$1 = 104
retcode$2 = 112
proto$3 = 116
rsp_bhr$ = 120
ipadatasize$4 = 128
retcode$5 = 132
was_enabled$6 = 136
was_enabled$7 = 137
ano$8 = 140
ipa_sap$9 = 144
rc$10 = 152
cmd$11 = 156
req_rrh$ = 160
rc$12 = 168
ipa_sip$13 = 176
tv204 = 184
flags$14 = 188
tv1540 = 192
tv1607 = 196
rqsize$15 = 200
uLength3$16 = 204
lendata$17 = 208
tv90 = 212
tv380 = 216
tv1199 = 220
tv1331 = 224
ipa_mac$18 = 232
len$19 = 240
offph$ = 244
tv80 = 248
flags$20 = 252
rc$21 = 256
cmd$22 = 260
ipasize$23 = 264
req_puk$24 = 272
ipa_sas$25 = 280
rsp_th$26 = 288
tv1774 = 296
uLength1$27 = 300
tv2049 = 304
tv2055 = 308
offrrh$ = 312
tv161 = 316
tv167 = 320
tv271 = 324
tv277 = 328
tv603 = 332
rc$28 = 336
tv1057 = 340
cmd$29 = 344
req_puk$30 = 352
ip6$31 = 360
rsp_rrh$32 = 368
ipa_sip$33 = 376
sma$34 = 384
tv1678 = 392
promisc$35 = 396
uLoselen$36 = 400
offdata$37 = 404
rc$38 = 408
tv1553 = 412
rc$39 = 416
cmd$40 = 420
qry$41 = 424
sci$42 = 432
rsp_ph$43 = 440
tv1777 = 448
ipa_mac$44 = 456
ipa_mac$45 = 464
ipa_mac$46 = 472
ipa_rtg$47 = 480
sma$48 = 488
spm$49 = 496
protoc$50 = 504
anoc$51 = 520
ipaddr$52 = 536
cmd_not_supp$53 = 552
not_supp$54 = 568
tthwaddr$55 = 584
ipmask$56 = 616
not_supp$57 = 632
not_supp$58 = 648
buf$59 = 672
msgbuf$60 = 736
__$ArrayPad$ = 992
dev$ = 1040
req_th$ = 1048
datalen$ = 1056
osa_adapter_cmd PROC

; 1280 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec f8 03
	00 00		 sub	 rsp, 1016		; 000003f8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1281 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0002a	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00032	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00036	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003a	48 89 44 24 60	 mov	 QWORD PTR grp$[rsp], rax

; 1282 : 
; 1283 : OSA_BHR *rsp_bhr;
; 1284 : 
; 1285 : MPC_RRH *req_rrh;
; 1286 : /* MPC_PH  *req_ph; */
; 1287 : 
; 1288 : U32 offrrh;
; 1289 : U16 offph;
; 1290 : 
; 1291 :     /* Point to request MPC_RRH and MPC_PH. */
; 1292 :     FETCH_FW(offrrh,req_th->offrrh);

  0003f	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  00047	48 83 c0 08	 add	 rax, 8
  0004b	48 8b c8	 mov	 rcx, rax
  0004e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00053	8b c8		 mov	 ecx, eax
  00055	e8 00 00 00 00	 call	 _byteswap_ulong
  0005a	89 84 24 38 01
	00 00		 mov	 DWORD PTR offrrh$[rsp], eax

; 1293 :     req_rrh = (MPC_RRH*)((BYTE*)req_th+offrrh);

  00061	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR offrrh$[rsp]
  00068	48 8b 8c 24 18
	04 00 00	 mov	 rcx, QWORD PTR req_th$[rsp]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR req_rrh$[rsp], rax

; 1294 :     FETCH_HW(offph,req_rrh->offph);

  0007e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR req_rrh$[rsp]
  00086	48 83 c0 10	 add	 rax, 16
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00092	0f b7 c8	 movzx	 ecx, ax
  00095	e8 00 00 00 00	 call	 _byteswap_ushort
  0009a	66 89 84 24 f4
	00 00 00	 mov	 WORD PTR offph$[rsp], ax

; 1295 :     /* req_ph = (MPC_PH*)((BYTE*)req_rrh+offph); */
; 1296 : 
; 1297 :     switch(req_rrh->type) {

  000a2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR req_rrh$[rsp]
  000aa	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  000ae	88 84 24 f8 00
	00 00		 mov	 BYTE PTR tv80[rsp], al
  000b5	80 bc 24 f8 00
	00 00 41	 cmp	 BYTE PTR tv80[rsp], 65	; 00000041H
  000bd	0f 84 07 03 00
	00		 je	 $LN64@osa_adapte
  000c3	80 bc 24 f8 00
	00 00 81	 cmp	 BYTE PTR tv80[rsp], 129	; 00000081H
  000cb	74 13		 je	 SHORT $LN58@osa_adapte
  000cd	80 bc 24 f8 00
	00 00 c1	 cmp	 BYTE PTR tv80[rsp], 193	; 000000c1H
  000d5	0f 84 db 06 00
	00		 je	 $LN74@osa_adapte
  000db	e9 b3 35 00 00	 jmp	 $LN214@osa_adapte
$LN58@osa_adapte:

; 1298 : 
; 1299 :     case RRH_TYPE_CM:
; 1300 :         strcat( dev->dev_data, "RRH_TYPE_CM" );  /* Prepare the contentstring */

  000e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172164
  000e7	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ef	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  000f6	e8 00 00 00 00	 call	 strcat

; 1301 :         {
; 1302 :             MPC_PUK *req_puk;
; 1303 : 
; 1304 :             req_puk = mpc_point_puk( dev, req_th, req_rrh );

  000fb	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00103	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  0010b	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_puk
  00119	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR req_puk$30[rsp], rax

; 1305 : 
; 1306 :             switch(req_puk->type) {

  00121	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR req_puk$30[rsp]
  00129	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0012d	88 84 24 d4 00
	00 00		 mov	 BYTE PTR tv90[rsp], al
  00134	80 bc 24 d4 00
	00 00 02	 cmp	 BYTE PTR tv90[rsp], 2
  0013c	74 2b		 je	 SHORT $LN59@osa_adapte
  0013e	80 bc 24 d4 00
	00 00 03	 cmp	 BYTE PTR tv90[rsp], 3
  00146	0f 84 fb 00 00
	00		 je	 $LN62@osa_adapte
  0014c	80 bc 24 d4 00
	00 00 04	 cmp	 BYTE PTR tv90[rsp], 4
  00154	74 5d		 je	 SHORT $LN60@osa_adapte
  00156	80 bc 24 d4 00
	00 00 05	 cmp	 BYTE PTR tv90[rsp], 5
  0015e	0f 84 99 00 00
	00		 je	 $LN61@osa_adapte
  00164	e9 28 01 00 00	 jmp	 $LN63@osa_adapte
$LN59@osa_adapte:

; 1307 : 
; 1308 :             case PUK_TYPE_ENABLE:
; 1309 :                 strcat( dev->dev_data, ": PUK_TYPE_ENABLE (CM_ENABLE)" );  /* Prepare the contentstring */

  00169	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172166
  00170	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00178	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0017f	e8 00 00 00 00	 call	 strcat

; 1310 :                 rsp_bhr = process_cm_enable( dev, req_th, req_rrh, req_puk );

  00184	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR req_puk$30[rsp]
  0018c	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00194	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  0019c	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a4	e8 00 00 00 00	 call	 process_cm_enable
  001a9	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1311 :                 break;

  001ae	e9 f2 01 00 00	 jmp	 $LN4@osa_adapte
$LN60@osa_adapte:

; 1312 : 
; 1313 :             case PUK_TYPE_SETUP:
; 1314 :                 strcat( dev->dev_data, ": PUK_TYPE_SETUP (CM_SETUP)" );  /* Prepare the contentstring */

  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172168
  001ba	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c2	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  001c9	e8 00 00 00 00	 call	 strcat

; 1315 :                 rsp_bhr = process_cm_setup( dev, req_th, req_rrh, req_puk );

  001ce	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR req_puk$30[rsp]
  001d6	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  001de	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  001e6	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ee	e8 00 00 00 00	 call	 process_cm_setup
  001f3	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1316 :                 break;

  001f8	e9 a8 01 00 00	 jmp	 $LN4@osa_adapte
$LN61@osa_adapte:

; 1317 : 
; 1318 :             case PUK_TYPE_TAKEDOWN:
; 1319 :                 strcat( dev->dev_data, ": PUK_TYPE_TAKEDOWN (CM_TAKEDOWN)" );  /* Prepare the contentstring */

  001fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172170
  00204	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020c	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00213	e8 00 00 00 00	 call	 strcat

; 1320 :                 rsp_bhr = process_cm_takedown( dev, req_th, req_rrh, req_puk );

  00218	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR req_puk$30[rsp]
  00220	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00228	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  00230	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00238	e8 00 00 00 00	 call	 process_cm_takedown
  0023d	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1321 :                 break;

  00242	e9 5e 01 00 00	 jmp	 $LN4@osa_adapte
$LN62@osa_adapte:

; 1322 : 
; 1323 :             case PUK_TYPE_DISABLE:
; 1324 :                 strcat( dev->dev_data, ": PUK_TYPE_DISABLE (CM_DISABLE)" );  /* Prepare the contentstring */

  00247	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172172
  0024e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00256	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0025d	e8 00 00 00 00	 call	 strcat

; 1325 :                 rsp_bhr = process_cm_disable( dev, req_th, req_rrh, req_puk );

  00262	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR req_puk$30[rsp]
  0026a	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00272	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  0027a	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00282	e8 00 00 00 00	 call	 process_cm_disable
  00287	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1326 :                 break;

  0028c	e9 14 01 00 00	 jmp	 $LN4@osa_adapte
$LN63@osa_adapte:

; 1327 : 
; 1328 :             default:
; 1329 :                 // HHC03991 "%1d:%04X %s: %s"
; 1330 :                 WRMSG( HHC03991, "W", LCSS_DEVNUM, dev->typname,

  00291	48 83 bc 24 10
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0029a	74 15		 je	 SHORT $LN216@osa_adapte
  0029c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002a4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002a8	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  002af	eb 0b		 jmp	 SHORT $LN217@osa_adapte
$LN216@osa_adapte:
  002b1	c7 84 24 3c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv161[rsp], 0
$LN217@osa_adapte:
  002bc	48 83 bc 24 10
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002c5	74 17		 je	 SHORT $LN218@osa_adapte
  002c7	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002cf	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002d3	d1 f8		 sar	 eax, 1
  002d5	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv167[rsp], eax
  002dc	eb 0b		 jmp	 SHORT $LN219@osa_adapte
$LN218@osa_adapte:
  002de	c7 84 24 40 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv167[rsp], 0
$LN219@osa_adapte:
  002e9	b9 01 00 00 00	 mov	 ecx, 1
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172174
  002fb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00300	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00308	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0030c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00311	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  00318	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0031c	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv167[rsp]
  00323	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00327	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172175
  0032e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172176
  0033a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0033f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00344	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172177
  00351	ba 33 05 00 00	 mov	 edx, 1331		; 00000533H
  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172178
  0035d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1331 :                     "Unknown PUK_TYPE_xxx (CM Unknown)" );
; 1332 :                 net_data_trace( dev, (BYTE*)req_th, datalen, FROM_GUEST, 'I', "???", 0 );

  00363	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0036b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172179
  00372	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00377	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  0037c	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0037f	44 8b 84 24 20
	04 00 00	 mov	 r8d, DWORD PTR datalen$[rsp]
  00387	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  0038f	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00397	e8 00 00 00 00	 call	 net_data_trace

; 1333 :                 rsp_bhr = NULL;

  0039c	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], 0
$LN4@osa_adapte:

; 1334 : 
; 1335 :             }
; 1336 : 
; 1337 :             // Add response buffer to chain.
; 1338 :             add_buffer_to_chain( &grp->idx, rsp_bhr );

  003a5	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  003aa	48 83 c0 18	 add	 rax, 24
  003ae	48 8b 54 24 78	 mov	 rdx, QWORD PTR rsp_bhr$[rsp]
  003b3	48 8b c8	 mov	 rcx, rax
  003b6	e8 00 00 00 00	 call	 add_buffer_to_chain

; 1339 :             signal_idx_event( grp );

  003bb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  003c0	e8 00 00 00 00	 call	 signal_idx_event

; 1340 : 
; 1341 :         }
; 1342 :         break;

  003c5	e9 d4 33 00 00	 jmp	 $LN2@osa_adapte
$LN64@osa_adapte:

; 1343 : 
; 1344 :     /*  The RRH_TYPE_ULP requests enable/disable a specific data device. The  */
; 1345 :     /*  data device being enabled is identified by the ULP_SETUP PUS_0B       */
; 1346 :     /*  contents. The data device being disabled is identified by the token.  */
; 1347 :     /*  Note: The ULP_ENABLE, ULP_SETUP & ULP_ACTIVE exchanges also prepares  */
; 1348 :     /*  the token that identifies the data device in subsequent RRH_TYPE_IPA  */
; 1349 :     /*  requests & responses. QETH currently uses the constant 'QET5' for     */
; 1350 :     /*  the token, I wonder if it should be unique?                           */
; 1351 :     case RRH_TYPE_ULP:
; 1352 :         strcat( dev->dev_data, "RRH_TYPE_ULP" );  /* Prepare the contentstring */

  003ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172181
  003d1	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d9	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  003e0	e8 00 00 00 00	 call	 strcat

; 1353 :         {
; 1354 :             MPC_PUK *req_puk;
; 1355 : 
; 1356 :             req_puk = mpc_point_puk(dev,req_th,req_rrh);

  003e5	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  003ed	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  003f5	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_puk
  00403	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR req_puk$24[rsp], rax

; 1357 : 
; 1358 :             switch(req_puk->type) {

  0040b	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR req_puk$24[rsp]
  00413	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00417	88 84 24 b8 00
	00 00		 mov	 BYTE PTR tv204[rsp], al
  0041e	80 bc 24 b8 00
	00 00 02	 cmp	 BYTE PTR tv204[rsp], 2
  00426	74 3d		 je	 SHORT $LN65@osa_adapte
  00428	80 bc 24 b8 00
	00 00 03	 cmp	 BYTE PTR tv204[rsp], 3
  00430	0f 84 fd 01 00
	00		 je	 $LN72@osa_adapte
  00436	80 bc 24 b8 00
	00 00 04	 cmp	 BYTE PTR tv204[rsp], 4
  0043e	0f 84 11 01 00
	00		 je	 $LN69@osa_adapte
  00444	80 bc 24 b8 00
	00 00 05	 cmp	 BYTE PTR tv204[rsp], 5
  0044c	0f 84 97 01 00
	00		 je	 $LN71@osa_adapte
  00452	80 bc 24 b8 00
	00 00 60	 cmp	 BYTE PTR tv204[rsp], 96	; 00000060H
  0045a	0f 84 3f 01 00
	00		 je	 $LN70@osa_adapte
  00460	e9 18 02 00 00	 jmp	 $LN73@osa_adapte
$LN65@osa_adapte:

; 1359 : 
; 1360 :             case PUK_TYPE_ENABLE:
; 1361 :                 strcat( dev->dev_data, ": PUK_TYPE_ENABLE (ULP_ENABLE)" );  /* Prepare the contentstring */

  00465	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172183
  0046c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00474	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0047b	e8 00 00 00 00	 call	 strcat

; 1362 :                 if (process_ulp_enable_extract( dev, req_th, req_rrh, req_puk ) != 0)

  00480	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR req_puk$24[rsp]
  00488	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00490	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  00498	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a0	e8 00 00 00 00	 call	 process_ulp_enable_extract
  004a5	85 c0		 test	 eax, eax
  004a7	74 0e		 je	 SHORT $LN66@osa_adapte

; 1363 :                 {
; 1364 :                     rsp_bhr = NULL;

  004a9	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], 0

; 1365 :                     break;

  004b2	e9 da 02 00 00	 jmp	 $LN6@osa_adapte
$LN66@osa_adapte:

; 1366 :                 }
; 1367 :                 if (grp->ttfd < 0)

  004b7	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  004bc	83 b8 f8 05 00
	00 00		 cmp	 DWORD PTR [rax+1528], 0
  004c3	7d 61		 jge	 SHORT $LN67@osa_adapte

; 1368 :                     if (qeth_create_interface( dev, grp ) != 0)

  004c5	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  004ca	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004d2	e8 00 00 00 00	 call	 qeth_create_interface
  004d7	85 c0		 test	 eax, eax
  004d9	74 4b		 je	 SHORT $LN68@osa_adapte

; 1369 :                         QERRMSG( dev, grp, -1,

  004db	c7 44 24 38 5a
	05 00 00	 mov	 DWORD PTR [rsp+56], 1370 ; 0000055aH
  004e3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172187
  004ea	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  004ef	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172188
  004f6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  004fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172189
  00502	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00507	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172190
  0050e	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00514	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  00519	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00521	e8 00 00 00 00	 call	 qeth_errnum_msg
$LN68@osa_adapte:
$LN67@osa_adapte:

; 1370 :                             "E", "qeth_create_interface() failed" );
; 1371 :                 rsp_bhr = process_ulp_enable( dev, req_th, req_rrh, req_puk );

  00526	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR req_puk$24[rsp]
  0052e	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00536	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  0053e	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00546	e8 00 00 00 00	 call	 process_ulp_enable
  0054b	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1372 :                 break;

  00550	e9 3c 02 00 00	 jmp	 $LN6@osa_adapte
$LN69@osa_adapte:

; 1373 : 
; 1374 :             case PUK_TYPE_SETUP:
; 1375 :                 strcat( dev->dev_data, ": PUK_TYPE_SETUP (ULP_SETUP)" );  /* Prepare the contentstring */

  00555	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172192
  0055c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00564	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0056b	e8 00 00 00 00	 call	 strcat

; 1376 :                 rsp_bhr = process_ulp_setup( dev, req_th, req_rrh, req_puk );

  00570	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR req_puk$24[rsp]
  00578	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00580	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  00588	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00590	e8 00 00 00 00	 call	 process_ulp_setup
  00595	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1377 :                 break;

  0059a	e9 f2 01 00 00	 jmp	 $LN6@osa_adapte
$LN70@osa_adapte:

; 1378 : 
; 1379 :             case PUK_TYPE_ACTIVE:
; 1380 :                 strcat( dev->dev_data, ": PUK_TYPE_ACTIVE (ULP_ACTIVE)" );  /* Prepare the contentstring */

  0059f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172194
  005a6	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ae	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  005b5	e8 00 00 00 00	 call	 strcat

; 1381 :                 rsp_bhr = process_dm_act( dev, req_th, req_rrh, req_puk );

  005ba	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR req_puk$24[rsp]
  005c2	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  005ca	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  005d2	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005da	e8 00 00 00 00	 call	 process_dm_act
  005df	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1382 :                 break;

  005e4	e9 a8 01 00 00	 jmp	 $LN6@osa_adapte
$LN71@osa_adapte:

; 1383 : 
; 1384 :             case PUK_TYPE_TAKEDOWN:
; 1385 :                 strcat( dev->dev_data, ": PUK_TYPE_TAKEDOWN (ULP_TAKEDOWN)" );  /* Prepare the contentstring */

  005e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172196
  005f0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f8	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  005ff	e8 00 00 00 00	 call	 strcat

; 1386 :                 rsp_bhr = process_ulp_takedown( dev, req_th, req_rrh, req_puk );

  00604	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR req_puk$24[rsp]
  0060c	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  00614	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  0061c	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00624	e8 00 00 00 00	 call	 process_ulp_takedown
  00629	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1387 :                 break;

  0062e	e9 5e 01 00 00	 jmp	 $LN6@osa_adapte
$LN72@osa_adapte:

; 1388 : 
; 1389 :             case PUK_TYPE_DISABLE:
; 1390 :                 strcat( dev->dev_data, ": PUK_TYPE_DISABLE (ULP_DISABLE)" );  /* Prepare the contentstring */

  00633	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172198
  0063a	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00642	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00649	e8 00 00 00 00	 call	 strcat

; 1391 :                 rsp_bhr = process_ulp_disable( dev, req_th, req_rrh, req_puk );

  0064e	4c 8b 8c 24 10
	01 00 00	 mov	 r9, QWORD PTR req_puk$24[rsp]
  00656	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR req_rrh$[rsp]
  0065e	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  00666	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0066e	e8 00 00 00 00	 call	 process_ulp_disable
  00673	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1392 :                 break;

  00678	e9 14 01 00 00	 jmp	 $LN6@osa_adapte
$LN73@osa_adapte:

; 1393 : 
; 1394 :             default:
; 1395 :                 // HHC03991 "%1d:%04X %s: %s"
; 1396 :                 WRMSG( HHC03991, "W", LCSS_DEVNUM, dev->typname,

  0067d	48 83 bc 24 10
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00686	74 15		 je	 SHORT $LN220@osa_adapte
  00688	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00690	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00694	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv271[rsp], eax
  0069b	eb 0b		 jmp	 SHORT $LN221@osa_adapte
$LN220@osa_adapte:
  0069d	c7 84 24 44 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv271[rsp], 0
$LN221@osa_adapte:
  006a8	48 83 bc 24 10
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  006b1	74 17		 je	 SHORT $LN222@osa_adapte
  006b3	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006bb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  006bf	d1 f8		 sar	 eax, 1
  006c1	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv277[rsp], eax
  006c8	eb 0b		 jmp	 SHORT $LN223@osa_adapte
$LN222@osa_adapte:
  006ca	c7 84 24 48 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv277[rsp], 0
$LN223@osa_adapte:
  006d5	b9 01 00 00 00	 mov	 ecx, 1
  006da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172200
  006e7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006ec	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006f4	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006f8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006fd	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv271[rsp]
  00704	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00708	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv277[rsp]
  0070f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00713	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172201
  0071a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0071f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172202
  00726	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0072b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00730	41 b9 03 00 00
	00		 mov	 r9d, 3
  00736	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172203
  0073d	ba 75 05 00 00	 mov	 edx, 1397		; 00000575H
  00742	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172204
  00749	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1397 :                     "Unknown PUK_TYPE_xxx (ULP Unknown)" );
; 1398 :                 net_data_trace( dev, (BYTE*)req_th, datalen, FROM_GUEST, 'I', "???", 0 );

  0074f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  00757	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172205
  0075e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00763	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  00768	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  0076b	44 8b 84 24 20
	04 00 00	 mov	 r8d, DWORD PTR datalen$[rsp]
  00773	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  0077b	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00783	e8 00 00 00 00	 call	 net_data_trace

; 1399 :                 rsp_bhr = NULL;

  00788	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], 0
$LN6@osa_adapte:

; 1400 :             }
; 1401 : 
; 1402 :             // Add response buffer to chain.
; 1403 :             add_buffer_to_chain( &grp->idx, rsp_bhr );

  00791	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00796	48 83 c0 18	 add	 rax, 24
  0079a	48 8b 54 24 78	 mov	 rdx, QWORD PTR rsp_bhr$[rsp]
  0079f	48 8b c8	 mov	 rcx, rax
  007a2	e8 00 00 00 00	 call	 add_buffer_to_chain

; 1404 :             signal_idx_event( grp );

  007a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  007ac	e8 00 00 00 00	 call	 signal_idx_event

; 1405 :         }
; 1406 :         break;

  007b1	e9 e8 2f 00 00	 jmp	 $LN2@osa_adapte
$LN74@osa_adapte:

; 1407 : 
; 1408 :     /*  The RRH_TYPE_IPA requests configure a specific data device            */
; 1409 :     /*  identified by the MPC_RRH->token variable. As QETH only supports a    */
; 1410 :     /*  group with a single data device, this isn't a problem (yet!).         */
; 1411 :     case RRH_TYPE_IPA:
; 1412 :         strcat( dev->dev_data, "RRH_TYPE_IPA" );  /* Prepare the contentstring */

  007b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172207
  007bd	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007c5	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  007cc	e8 00 00 00 00	 call	 strcat

; 1413 :         {
; 1414 :             MPC_TH  *rsp_th;
; 1415 :             MPC_RRH *rsp_rrh;
; 1416 :             MPC_PH  *rsp_ph;
; 1417 :             MPC_IPA *ipa;
; 1418 : 
; 1419 :             U32      rqsize;
; 1420 :             U32      offdata;
; 1421 :             U32      lendata;
; 1422 : //          U32      ackseq;
; 1423 : 
; 1424 :             U16      proto;
; 1425 :             char     protoc[10];
; 1426 : 
; 1427 :             int      ipasize = SIZE_IPA;

  007d1	c7 84 24 08 01
	00 00 14 00 00
	00		 mov	 DWORD PTR ipasize$23[rsp], 20

; 1428 :             int      ipadatasize = -1;

  007dc	c7 84 24 80 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ipadatasize$4[rsp], -1

; 1429 : 
; 1430 :             /* Allocate a buffer to which the request will be copied */
; 1431 :             /* and then modified, to become the response.            */
; 1432 :             FETCH_FW(rqsize,req_th->length);

  007e7	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  007ef	48 83 c0 0c	 add	 rax, 12
  007f3	48 8b c8	 mov	 rcx, rax
  007f6	e8 00 00 00 00	 call	 fetch_fw_noswap
  007fb	8b c8		 mov	 ecx, eax
  007fd	e8 00 00 00 00	 call	 _byteswap_ulong
  00802	89 84 24 c8 00
	00 00		 mov	 DWORD PTR rqsize$15[rsp], eax

; 1433 :             rsp_bhr = alloc_buffer( dev, rqsize+100 );

  00809	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR rqsize$15[rsp]
  00810	83 c0 64	 add	 eax, 100		; 00000064H
  00813	8b d0		 mov	 edx, eax
  00815	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0081d	e8 00 00 00 00	 call	 alloc_buffer
  00822	48 89 44 24 78	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 1434 :             if (!rsp_bhr)

  00827	48 83 7c 24 78
	00		 cmp	 QWORD PTR rsp_bhr$[rsp], 0
  0082d	75 05		 jne	 SHORT $LN75@osa_adapte

; 1435 :                 break;

  0082f	e9 6a 2f 00 00	 jmp	 $LN2@osa_adapte
$LN75@osa_adapte:

; 1436 :             rsp_bhr->datalen = rqsize;

  00834	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  00839	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR rqsize$15[rsp]
  00840	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 1437 : 
; 1438 :             /* Point to response MPC_TH. */
; 1439 :             rsp_th = (MPC_TH*)((BYTE*)rsp_bhr + SizeBHR);

  00843	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  00848	48 83 c0 18	 add	 rax, 24
  0084c	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR rsp_th$26[rsp], rax

; 1440 : 
; 1441 :             /* Copy request to response buffer. */
; 1442 :             memcpy(rsp_th,req_th,rqsize);

  00854	8b 84 24 c8 00
	00 00		 mov	 eax, DWORD PTR rqsize$15[rsp]
  0085b	48 8b bc 24 20
	01 00 00	 mov	 rdi, QWORD PTR rsp_th$26[rsp]
  00863	48 8b b4 24 18
	04 00 00	 mov	 rsi, QWORD PTR req_th$[rsp]
  0086b	8b c8		 mov	 ecx, eax
  0086d	f3 a4		 rep movsb

; 1443 : 
; 1444 :             /* Point to response MPC_RRH and MPC_PH. */
; 1445 :             rsp_rrh = (MPC_RRH*)((BYTE*)rsp_th+offrrh);

  0086f	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR offrrh$[rsp]
  00876	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR rsp_th$26[rsp]
  0087e	48 03 c8	 add	 rcx, rax
  00881	48 8b c1	 mov	 rax, rcx
  00884	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR rsp_rrh$32[rsp], rax

; 1446 :             rsp_ph = (MPC_PH*)((BYTE*)rsp_rrh+offph);

  0088c	0f b7 84 24 f4
	00 00 00	 movzx	 eax, WORD PTR offph$[rsp]
  00894	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR rsp_rrh$32[rsp]
  0089c	48 03 c8	 add	 rcx, rax
  0089f	48 8b c1	 mov	 rax, rcx
  008a2	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR rsp_ph$43[rsp], rax

; 1447 : 
; 1448 :             /* Get the length of and point to response MPC_IPA and associated command. */
; 1449 :             FETCH_F3( lendata, rsp_ph->lendata );

  008aa	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rsp_ph$43[rsp]
  008b2	48 ff c0	 inc	 rax
  008b5	48 8b c8	 mov	 rcx, rax
  008b8	e8 00 00 00 00	 call	 fetch_f3_noswap
  008bd	8b c8		 mov	 ecx, eax
  008bf	e8 00 00 00 00	 call	 _byteswap_ulong
  008c4	89 84 24 d0 00
	00 00		 mov	 DWORD PTR lendata$17[rsp], eax

; 1450 :             FETCH_FW( offdata, rsp_ph->offdata );

  008cb	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR rsp_ph$43[rsp]
  008d3	48 83 c0 04	 add	 rax, 4
  008d7	48 8b c8	 mov	 rcx, rax
  008da	e8 00 00 00 00	 call	 fetch_fw_noswap
  008df	8b c8		 mov	 ecx, eax
  008e1	e8 00 00 00 00	 call	 _byteswap_ulong
  008e6	89 84 24 94 01
	00 00		 mov	 DWORD PTR offdata$37[rsp], eax

; 1451 :             ipa = (MPC_IPA*)((BYTE*)rsp_th + offdata);

  008ed	8b 84 24 94 01
	00 00		 mov	 eax, DWORD PTR offdata$37[rsp]
  008f4	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR rsp_th$26[rsp]
  008fc	48 03 c8	 add	 rcx, rax
  008ff	48 8b c1	 mov	 rax, rcx
  00902	48 89 44 24 68	 mov	 QWORD PTR ipa$1[rsp], rax

; 1452 : 
; 1453 :             /* Modify the response MPC_TH and MPC_RRH. */
; 1454 :             STORE_FW( rsp_th->seqnum, 0 );

  00907	33 c9		 xor	 ecx, ecx
  00909	e8 00 00 00 00	 call	 _byteswap_ulong
  0090e	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR rsp_th$26[rsp]
  00916	48 83 c1 04	 add	 rcx, 4
  0091a	8b d0		 mov	 edx, eax
  0091c	e8 00 00 00 00	 call	 store_fw_noswap

; 1455 :             STORE_HW( rsp_th->unknown10, 0x0FFC );        /* !!! */

  00921	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00925	e8 00 00 00 00	 call	 _byteswap_ushort
  0092a	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR rsp_th$26[rsp]
  00932	48 83 c1 10	 add	 rcx, 16
  00936	0f b7 d0	 movzx	 edx, ax
  00939	e8 00 00 00 00	 call	 store_hw_noswap

; 1456 :             rsp_rrh->proto = PROTOCOL_UNKNOWN;

  0093e	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR rsp_rrh$32[rsp]
  00946	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 1457 :             memcpy( rsp_rrh->token, grp->gtulpconn, MPC_TOKEN_LENGTH );

  0094a	48 8b 84 24 70
	01 00 00	 mov	 rax, QWORD PTR rsp_rrh$32[rsp]
  00952	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00957	8b 89 40 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1600]
  0095d	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 1458 : 
; 1459 :             /* Make a note of the protocol the request relates to. */
; 1460 :             FETCH_HW(proto,ipa->proto);

  00960	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  00965	48 83 c0 0a	 add	 rax, 10
  00969	48 8b c8	 mov	 rcx, rax
  0096c	e8 00 00 00 00	 call	 fetch_hw_noswap
  00971	0f b7 c8	 movzx	 ecx, ax
  00974	e8 00 00 00 00	 call	 _byteswap_ushort
  00979	66 89 44 24 74	 mov	 WORD PTR proto$3[rsp], ax

; 1461 :             if (proto == IPA_PROTO_IPV4) {

  0097e	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  00983	83 f8 04	 cmp	 eax, 4
  00986	75 16		 jne	 SHORT $LN76@osa_adapte

; 1462 :                 strcpy( protoc, " (IPv4)" );

  00988	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172211
  0098f	48 8d 8c 24 f8
	01 00 00	 lea	 rcx, QWORD PTR protoc$50[rsp]
  00997	e8 00 00 00 00	 call	 strcpy
  0099c	eb 34		 jmp	 SHORT $LN77@osa_adapte
$LN76@osa_adapte:

; 1463 :             } else if (proto == IPA_PROTO_IPV6) {

  0099e	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  009a3	83 f8 06	 cmp	 eax, 6
  009a6	75 16		 jne	 SHORT $LN78@osa_adapte

; 1464 :                 strcpy( protoc, " (IPv6)" );

  009a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172214
  009af	48 8d 8c 24 f8
	01 00 00	 lea	 rcx, QWORD PTR protoc$50[rsp]
  009b7	e8 00 00 00 00	 call	 strcpy

; 1465 :             } else {

  009bc	eb 14		 jmp	 SHORT $LN79@osa_adapte
$LN78@osa_adapte:

; 1466 :                 strcpy( protoc, "" );

  009be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172215
  009c5	48 8d 8c 24 f8
	01 00 00	 lea	 rcx, QWORD PTR protoc$50[rsp]
  009cd	e8 00 00 00 00	 call	 strcpy
$LN79@osa_adapte:
$LN77@osa_adapte:

; 1467 :             }
; 1468 : 
; 1469 :             switch(ipa->cmd) {

  009d2	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  009d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  009da	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv380[rsp], eax
  009e1	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv380[rsp]
  009e8	ff c8		 dec	 eax
  009ea	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv380[rsp], eax
  009f1	81 bc 24 d8 00
	00 00 c2 00 00
	00		 cmp	 DWORD PTR tv380[rsp], 194 ; 000000c2H
  009fc	0f 87 1b 29 00
	00		 ja	 $LN204@osa_adapte
  00a02	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR tv380[rsp]
  00a0a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00a11	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN238@osa_adapte[rcx+rax]
  00a19	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN239@osa_adapte[rcx+rax*4]
  00a20	48 03 c1	 add	 rax, rcx
  00a23	ff e0		 jmp	 rax
$LN80@osa_adapte:

; 1470 : 
; 1471 :             case IPA_CMD_STARTLAN:  /* 0x01 : Start LAN operations */
; 1472 :                 /* Note: the request MPC_IPA may be 16 or 20-bytes in length  */
; 1473 :                 /* with nothing following, or may be 20-byte in length with   */
; 1474 :                 /* an unpredictable number of bytes following. The response   */
; 1475 :                 /* MPC_IPA we return is always 16-bytes in length with        */
; 1476 :                 /* nothing following. There was a reason for this, I just     */
; 1477 :                 /* wish, I could remember what it was! Something to do with   */
; 1478 :                 /* z/VM TCPIP I think, but...                                 */
; 1479 :                 {
; 1480 : 
; 1481 :                     strcat( dev->dev_data, ": IPA_CMD_STARTLAN" );  /* Prepare the contentstring */

  00a25	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172217
  00a2c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a34	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00a3b	e8 00 00 00 00	 call	 strcat

; 1482 :                     rsp_bhr->content = strdup( dev->dev_data );

  00a40	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a48	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00a4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00a55	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  00a5a	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1483 : 
; 1484 :                     /* Display the request MPC_TH etc., maybe. */
; 1485 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  00a5e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a66	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00a6d	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00a72	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172218
  00a79	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00a7e	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  00a83	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00a8c	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  00a94	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00a99	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00aa1	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00aa9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172219
  00ab0	ba cd 05 00 00	 mov	 edx, 1485		; 000005cdH
  00ab5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172220
  00abc	e8 00 00 00 00	 call	 dbgupd

; 1486 : 
; 1487 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  00ac1	33 c9		 xor	 ecx, ecx
  00ac3	e8 00 00 00 00	 call	 _byteswap_ushort
  00ac8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  00acd	48 83 c1 04	 add	 rcx, 4
  00ad1	0f b7 d0	 movzx	 edx, ax
  00ad4	e8 00 00 00 00	 call	 store_hw_noswap

; 1488 :                     grp->ipae0 |= IPA_SETADAPTERPARMS;

  00ad9	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00ade	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [rax+1560]
  00ae4	0f ba e8 0a	 bts	 eax, 10
  00ae8	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00aed	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 1489 :                     grp->ipae4 |= IPA_SETADAPTERPARMS;

  00af3	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00af8	8b 80 1c 06 00
	00		 mov	 eax, DWORD PTR [rax+1564]
  00afe	0f ba e8 0a	 bts	 eax, 10
  00b02	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00b07	89 81 1c 06 00
	00		 mov	 DWORD PTR [rcx+1564], eax

; 1490 :                     grp->ipae6 |= IPA_SETADAPTERPARMS;

  00b0d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00b12	8b 80 20 06 00
	00		 mov	 eax, DWORD PTR [rax+1568]
  00b18	0f ba e8 0a	 bts	 eax, 10
  00b1c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00b21	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax

; 1491 : 
; 1492 :                     ipasize = SIZE_IPA_SHORT;

  00b27	c7 84 24 08 01
	00 00 10 00 00
	00		 mov	 DWORD PTR ipasize$23[rsp], 16

; 1493 :                     ipadatasize = 0;

  00b32	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 0
$LN12@osa_adapte:

; 1494 : 
; 1495 :                     /* Enable the TUN or TAP interface */
; 1496 :                     VERIFY( qeth_enable_interface( dev, grp ) == 0);

  00b3d	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  00b42	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b4a	e8 00 00 00 00	 call	 qeth_enable_interface
  00b4f	85 c0		 test	 eax, eax
  00b51	74 5c		 je	 SHORT $LN81@osa_adapte
$LN15@osa_adapte:
  00b53	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172222
  00b5a	41 b8 d8 05 00
	00		 mov	 r8d, 1496		; 000005d8H
  00b60	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172223
  00b67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172224
  00b6e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00b74	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b7a	85 c0		 test	 eax, eax
  00b7c	74 20		 je	 SHORT $LN82@osa_adapte
  00b7e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172226
  00b85	41 b8 d8 05 00
	00		 mov	 r8d, 1496		; 000005d8H
  00b8b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172227
  00b92	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172228
  00b99	e8 00 00 00 00	 call	 DebuggerTrace
$LN82@osa_adapte:
  00b9e	33 c0		 xor	 eax, eax
  00ba0	85 c0		 test	 eax, eax
  00ba2	75 af		 jne	 SHORT $LN15@osa_adapte
  00ba4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00baa	85 c0		 test	 eax, eax
  00bac	74 01		 je	 SHORT $LN83@osa_adapte
  00bae	cc		 int	 3
$LN83@osa_adapte:
$LN81@osa_adapte:
  00baf	33 c0		 xor	 eax, eax
  00bb1	85 c0		 test	 eax, eax
  00bb3	75 88		 jne	 SHORT $LN12@osa_adapte

; 1497 :                 }
; 1498 :                 /* end case IPA_CMD_STARTLAN:  0x01 */
; 1499 :                 break;

  00bb5	e9 5a 28 00 00	 jmp	 $LN8@osa_adapte
$LN84@osa_adapte:

; 1500 : 
; 1501 :             case IPA_CMD_STOPLAN:  /* 0x02 : Stop LAN operations */
; 1502 :                 {
; 1503 :                     strcat( dev->dev_data, ": IPA_CMD_STOPLAN" );  /* Prepare the contentstring */

  00bba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172231
  00bc1	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bc9	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00bd0	e8 00 00 00 00	 call	 strcat

; 1504 :                     rsp_bhr->content = strdup( dev->dev_data );

  00bd5	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bdd	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00be4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00bea	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  00bef	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1505 : 
; 1506 :                     /* Display the request MPC_TH etc., maybe. */
; 1507 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  00bf3	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00bfb	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00c02	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00c07	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172232
  00c0e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00c13	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  00c18	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00c21	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  00c29	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00c2e	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00c36	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00c3e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172233
  00c45	ba e3 05 00 00	 mov	 edx, 1507		; 000005e3H
  00c4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172234
  00c51	e8 00 00 00 00	 call	 dbgupd

; 1508 : 
; 1509 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  00c56	33 c9		 xor	 ecx, ecx
  00c58	e8 00 00 00 00	 call	 _byteswap_ushort
  00c5d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  00c62	48 83 c1 04	 add	 rcx, 4
  00c66	0f b7 d0	 movzx	 edx, ax
  00c69	e8 00 00 00 00	 call	 store_hw_noswap

; 1510 :                     grp->ipae0 &= ~IPA_SETADAPTERPARMS;

  00c6e	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00c73	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [rax+1560]
  00c79	0f ba f0 0a	 btr	 eax, 10
  00c7d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00c82	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 1511 :                     grp->ipae4 &= ~IPA_SETADAPTERPARMS;

  00c88	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00c8d	8b 80 1c 06 00
	00		 mov	 eax, DWORD PTR [rax+1564]
  00c93	0f ba f0 0a	 btr	 eax, 10
  00c97	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00c9c	89 81 1c 06 00
	00		 mov	 DWORD PTR [rcx+1564], eax

; 1512 :                     grp->ipae6 &= ~IPA_SETADAPTERPARMS;

  00ca2	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00ca7	8b 80 20 06 00
	00		 mov	 eax, DWORD PTR [rax+1568]
  00cad	0f ba f0 0a	 btr	 eax, 10
  00cb1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00cb6	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax
$LN18@osa_adapte:

; 1513 : 
; 1514 :                     /* Disable the TUN or TAP interface */
; 1515 :                     VERIFY( qeth_disable_interface( dev, grp ) == 0);

  00cbc	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  00cc1	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cc9	e8 00 00 00 00	 call	 qeth_disable_interface
  00cce	85 c0		 test	 eax, eax
  00cd0	74 5c		 je	 SHORT $LN85@osa_adapte
$LN21@osa_adapte:
  00cd2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172236
  00cd9	41 b8 eb 05 00
	00		 mov	 r8d, 1515		; 000005ebH
  00cdf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172237
  00ce6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172238
  00ced	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00cf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00cf9	85 c0		 test	 eax, eax
  00cfb	74 20		 je	 SHORT $LN86@osa_adapte
  00cfd	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172240
  00d04	41 b8 eb 05 00
	00		 mov	 r8d, 1515		; 000005ebH
  00d0a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172241
  00d11	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172242
  00d18	e8 00 00 00 00	 call	 DebuggerTrace
$LN86@osa_adapte:
  00d1d	33 c0		 xor	 eax, eax
  00d1f	85 c0		 test	 eax, eax
  00d21	75 af		 jne	 SHORT $LN21@osa_adapte
  00d23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00d29	85 c0		 test	 eax, eax
  00d2b	74 01		 je	 SHORT $LN87@osa_adapte
  00d2d	cc		 int	 3
$LN87@osa_adapte:
$LN85@osa_adapte:
  00d2e	33 c0		 xor	 eax, eax
  00d30	85 c0		 test	 eax, eax
  00d32	75 88		 jne	 SHORT $LN18@osa_adapte

; 1516 :                 }
; 1517 :                 /* end case IPA_CMD_STOPLAN:  0x02 */
; 1518 :                 break;

  00d34	e9 db 26 00 00	 jmp	 $LN8@osa_adapte
$LN88@osa_adapte:

; 1519 : 
; 1520 :             case IPA_CMD_SETVMAC:  /* 0x21 : Set Layer-2 MAC address */
; 1521 :                 {
; 1522 :                 MPC_IPA_MAC *ipa_mac = (MPC_IPA_MAC*)(ipa+1);

  00d39	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  00d3e	48 83 c0 14	 add	 rax, 20
  00d42	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ipa_mac$18[rsp], rax

; 1523 :                 int rc = 0;

  00d4a	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$12[rsp], 0

; 1524 : #if defined( OPTION_W32_CTCI )
; 1525 :                 char tthwaddr[32] = {0}; // 11:22:33:44:55:66

  00d55	48 8d 84 24 48
	02 00 00	 lea	 rax, QWORD PTR tthwaddr$55[rsp]
  00d5d	48 8b f8	 mov	 rdi, rax
  00d60	33 c0		 xor	 eax, eax
  00d62	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00d67	f3 aa		 rep stosb

; 1526 :                 BYTE was_enabled;
; 1527 : #endif
; 1528 : 
; 1529 :                     strcat( dev->dev_data, ": IPA_CMD_SETVMAC" );  /* Prepare the contentstring */

  00d69	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172245
  00d70	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d78	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00d7f	e8 00 00 00 00	 call	 strcat

; 1530 :                     rsp_bhr->content = strdup( dev->dev_data );

  00d84	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d8c	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00d93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00d99	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  00d9e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1531 : 
; 1532 :                     /* Display the request MPC_TH etc., maybe. */
; 1533 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  00da2	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00daa	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00db1	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00db6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172246
  00dbd	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00dc2	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  00dc7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00dd0	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  00dd8	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ddd	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00de5	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00ded	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172247
  00df4	ba fd 05 00 00	 mov	 edx, 1533		; 000005fdH
  00df9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172248
  00e00	e8 00 00 00 00	 call	 dbgupd

; 1534 : 
; 1535 :                     /* Register the MAC address */
; 1536 :                     rc = register_mac(grp, dev, ipa_mac->macaddr, MAC_TYPE_UNICST);

  00e05	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ipa_mac$18[rsp]
  00e0d	48 83 c0 04	 add	 rax, 4
  00e11	41 b9 02 00 00
	00		 mov	 r9d, 2
  00e17	4c 8b c0	 mov	 r8, rax
  00e1a	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00e22	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00e27	e8 00 00 00 00	 call	 register_mac
  00e2c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR rc$12[rsp], eax

; 1537 :                     if (rc == -1) {          /* MAC table full */

  00e33	83 bc 24 a8 00
	00 00 ff	 cmp	 DWORD PTR rc$12[rsp], -1
  00e3b	75 1c		 jne	 SHORT $LN89@osa_adapte

; 1538 :                         STORE_HW(ipa->rc, IPA_RC_L2_ADDR_TABLE_FULL);

  00e3d	66 b9 06 20	 mov	 cx, 8198		; 00002006H
  00e41	e8 00 00 00 00	 call	 _byteswap_ushort
  00e46	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  00e4b	48 83 c1 04	 add	 rcx, 4
  00e4f	0f b7 d0	 movzx	 edx, ax
  00e52	e8 00 00 00 00	 call	 store_hw_noswap
  00e57	eb 3e		 jmp	 SHORT $LN90@osa_adapte
$LN89@osa_adapte:

; 1539 :                     } else if (rc == 1) {    /* MAC address in table */

  00e59	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR rc$12[rsp], 1
  00e61	75 1c		 jne	 SHORT $LN91@osa_adapte

; 1540 :                         STORE_HW(ipa->rc, IPA_RC_L2_DUP_MAC);

  00e63	66 b9 05 20	 mov	 cx, 8197		; 00002005H
  00e67	e8 00 00 00 00	 call	 _byteswap_ushort
  00e6c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  00e71	48 83 c1 04	 add	 rcx, 4
  00e75	0f b7 d0	 movzx	 edx, ax
  00e78	e8 00 00 00 00	 call	 store_hw_noswap

; 1541 :                     } else {                 /* MAC address added to table */

  00e7d	eb 18		 jmp	 SHORT $LN92@osa_adapte
$LN91@osa_adapte:

; 1542 :                         STORE_HW(ipa->rc, IPA_RC_SUCCESS);

  00e7f	33 c9		 xor	 ecx, ecx
  00e81	e8 00 00 00 00	 call	 _byteswap_ushort
  00e86	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  00e8b	48 83 c1 04	 add	 rcx, 4
  00e8f	0f b7 d0	 movzx	 edx, ax
  00e92	e8 00 00 00 00	 call	 store_hw_noswap
$LN92@osa_adapte:
$LN90@osa_adapte:

; 1543 :                     }
; 1544 : 
; 1545 : #if defined( OPTION_W32_CTCI )
; 1546 : #if defined( OPTION_TUNTAP_SETMACADDR )
; 1547 :                     // PROGRAMMING NOTE: normally one should not change
; 1548 :                     // tuntap's MAC but due to the way Windows CTCI-WIN
; 1549 :                     // is implemented (designed) we MUST change the MAC
; 1550 :                     // for Windows. This is ONLY for Windows. For Linux
; 1551 :                     // we should leave the tuntap MAC alone (as-is).
; 1552 : 
; 1553 :                     /* We only set the interface MAC address if the MAC    */
; 1554 :                     /* address supplied by the guest is different to the   */
; 1555 :                     /* interface MAC address that is currently being used. */
; 1556 :                     if (memcmp( grp->iMAC, ipa_mac->macaddr, IFHWADDRLEN ) != 0)

  00e97	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR ipa_mac$18[rsp]
  00e9f	48 83 c0 04	 add	 rax, 4
  00ea3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  00ea8	48 81 c1 28 06
	00 00		 add	 rcx, 1576		; 00000628H
  00eaf	41 b8 06 00 00
	00		 mov	 r8d, 6
  00eb5	48 8b d0	 mov	 rdx, rax
  00eb8	e8 00 00 00 00	 call	 memcmp
  00ebd	85 c0		 test	 eax, eax
  00ebf	0f 84 0e 03 00
	00		 je	 $LN93@osa_adapte

; 1557 :                     {
; 1558 : 
; 1559 :                         /* Save guest MAC address */
; 1560 :                         MSGBUF( tthwaddr, "%02x:%02x:%02x:%02x:%02x:%02x"

  00ec5	b8 01 00 00 00	 mov	 eax, 1
  00eca	48 6b c0 05	 imul	 rax, rax, 5
  00ece	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ipa_mac$18[rsp]
  00ed6	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  00edb	b9 01 00 00 00	 mov	 ecx, 1
  00ee0	48 6b c9 04	 imul	 rcx, rcx, 4
  00ee4	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR ipa_mac$18[rsp]
  00eec	0f b6 4c 0a 04	 movzx	 ecx, BYTE PTR [rdx+rcx+4]
  00ef1	ba 01 00 00 00	 mov	 edx, 1
  00ef6	48 6b d2 03	 imul	 rdx, rdx, 3
  00efa	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR ipa_mac$18[rsp]
  00f02	0f b6 54 17 04	 movzx	 edx, BYTE PTR [rdi+rdx+4]
  00f07	bf 01 00 00 00	 mov	 edi, 1
  00f0c	48 6b ff 02	 imul	 rdi, rdi, 2
  00f10	48 8b b4 24 e8
	00 00 00	 mov	 rsi, QWORD PTR ipa_mac$18[rsp]
  00f18	0f b6 7c 3e 04	 movzx	 edi, BYTE PTR [rsi+rdi+4]
  00f1d	be 01 00 00 00	 mov	 esi, 1
  00f22	48 6b f6 01	 imul	 rsi, rsi, 1
  00f26	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR ipa_mac$18[rsp]
  00f2e	41 0f b6 74 30
	04		 movzx	 esi, BYTE PTR [r8+rsi+4]
  00f34	41 b8 01 00 00
	00		 mov	 r8d, 1
  00f3a	4d 6b c0 00	 imul	 r8, r8, 0
  00f3e	4c 8b 8c 24 e8
	00 00 00	 mov	 r9, QWORD PTR ipa_mac$18[rsp]
  00f46	47 0f b6 44 01
	04		 movzx	 r8d, BYTE PTR [r9+r8+4]
  00f4c	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00f50	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f54	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00f58	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  00f5c	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00f60	45 8b c8	 mov	 r9d, r8d
  00f63	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172254
  00f6a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00f6f	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR tthwaddr$55[rsp]
  00f77	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1561 :                             ,ipa_mac->macaddr[0]
; 1562 :                             ,ipa_mac->macaddr[1]
; 1563 :                             ,ipa_mac->macaddr[2]
; 1564 :                             ,ipa_mac->macaddr[3]
; 1565 :                             ,ipa_mac->macaddr[4]
; 1566 :                             ,ipa_mac->macaddr[5]
; 1567 :                         );
; 1568 : 
; 1569 :                         was_enabled = grp->enabled ? TRUE : FALSE;

  00f7d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  00f82	83 b8 dc 05 00
	00 00		 cmp	 DWORD PTR [rax+1500], 0
  00f89	74 0d		 je	 SHORT $LN224@osa_adapte
  00f8b	c7 84 24 4c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv603[rsp], 1
  00f96	eb 0b		 jmp	 SHORT $LN225@osa_adapte
$LN224@osa_adapte:
  00f98	c7 84 24 4c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv603[rsp], 0
$LN225@osa_adapte:
  00fa3	0f b6 84 24 4c
	01 00 00	 movzx	 eax, BYTE PTR tv603[rsp]
  00fab	88 84 24 88 00
	00 00		 mov	 BYTE PTR was_enabled$6[rsp], al

; 1570 : 
; 1571 :                         if (was_enabled)

  00fb2	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR was_enabled$6[rsp]
  00fba	85 c0		 test	 eax, eax
  00fbc	74 78		 je	 SHORT $LN94@osa_adapte
$LN24@osa_adapte:

; 1572 :                             VERIFY( qeth_disable_interface( dev, grp ) == 0);

  00fbe	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  00fc3	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fcb	e8 00 00 00 00	 call	 qeth_disable_interface
  00fd0	85 c0		 test	 eax, eax
  00fd2	74 5c		 je	 SHORT $LN95@osa_adapte
$LN27@osa_adapte:
  00fd4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172257
  00fdb	41 b8 24 06 00
	00		 mov	 r8d, 1572		; 00000624H
  00fe1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172258
  00fe8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172259
  00fef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00ff5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00ffb	85 c0		 test	 eax, eax
  00ffd	74 20		 je	 SHORT $LN96@osa_adapte
  00fff	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172261
  01006	41 b8 24 06 00
	00		 mov	 r8d, 1572		; 00000624H
  0100c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172262
  01013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172263
  0101a	e8 00 00 00 00	 call	 DebuggerTrace
$LN96@osa_adapte:
  0101f	33 c0		 xor	 eax, eax
  01021	85 c0		 test	 eax, eax
  01023	75 af		 jne	 SHORT $LN27@osa_adapte
  01025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0102b	85 c0		 test	 eax, eax
  0102d	74 01		 je	 SHORT $LN97@osa_adapte
  0102f	cc		 int	 3
$LN97@osa_adapte:
$LN95@osa_adapte:
  01030	33 c0		 xor	 eax, eax
  01032	85 c0		 test	 eax, eax
  01034	75 88		 jne	 SHORT $LN24@osa_adapte
$LN94@osa_adapte:

; 1573 : 
; 1574 :                         rc = TUNTAP_SetMACAddr( grp->ttifname, tthwaddr );

  01036	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0103b	48 83 c0 60	 add	 rax, 96			; 00000060H
  0103f	48 8d 94 24 48
	02 00 00	 lea	 rdx, QWORD PTR tthwaddr$55[rsp]
  01047	48 8b c8	 mov	 rcx, rax
  0104a	e8 00 00 00 00	 call	 TUNTAP_SetMACAddr
  0104f	89 84 24 a8 00
	00 00		 mov	 DWORD PTR rc$12[rsp], eax

; 1575 : 
; 1576 :                         if (rc == 0)

  01056	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR rc$12[rsp], 0
  0105e	75 45		 jne	 SHORT $LN98@osa_adapte

; 1577 :                         {
; 1578 :                             free( grp->tthwaddr );

  01060	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01065	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  01069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1579 :                             grp->tthwaddr = strdup( tthwaddr );

  0106f	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR tthwaddr$55[rsp]
  01077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0107d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01082	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 1580 :                             memcpy( grp->iMAC, ipa_mac->macaddr, IFHWADDRLEN );

  01086	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0108b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ipa_mac$18[rsp]
  01093	48 8d b8 28 06
	00 00		 lea	 rdi, QWORD PTR [rax+1576]
  0109a	48 8d 71 04	 lea	 rsi, QWORD PTR [rcx+4]
  0109e	b9 06 00 00 00	 mov	 ecx, 6
  010a3	f3 a4		 rep movsb
$LN98@osa_adapte:

; 1581 :                         }
; 1582 : 
; 1583 :                         if (was_enabled)

  010a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR was_enabled$6[rsp]
  010ad	85 c0		 test	 eax, eax
  010af	74 78		 je	 SHORT $LN99@osa_adapte
$LN30@osa_adapte:

; 1584 :                             VERIFY( qeth_enable_interface( dev, grp ) == 0);

  010b1	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  010b6	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010be	e8 00 00 00 00	 call	 qeth_enable_interface
  010c3	85 c0		 test	 eax, eax
  010c5	74 5c		 je	 SHORT $LN100@osa_adapte
$LN33@osa_adapte:
  010c7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172268
  010ce	41 b8 30 06 00
	00		 mov	 r8d, 1584		; 00000630H
  010d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172269
  010db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172270
  010e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  010e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  010ee	85 c0		 test	 eax, eax
  010f0	74 20		 je	 SHORT $LN101@osa_adapte
  010f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172272
  010f9	41 b8 30 06 00
	00		 mov	 r8d, 1584		; 00000630H
  010ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172273
  01106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172274
  0110d	e8 00 00 00 00	 call	 DebuggerTrace
$LN101@osa_adapte:
  01112	33 c0		 xor	 eax, eax
  01114	85 c0		 test	 eax, eax
  01116	75 af		 jne	 SHORT $LN33@osa_adapte
  01118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0111e	85 c0		 test	 eax, eax
  01120	74 01		 je	 SHORT $LN102@osa_adapte
  01122	cc		 int	 3
$LN102@osa_adapte:
$LN100@osa_adapte:
  01123	33 c0		 xor	 eax, eax
  01125	85 c0		 test	 eax, eax
  01127	75 88		 jne	 SHORT $LN30@osa_adapte
$LN99@osa_adapte:

; 1585 : 
; 1586 :                         if (rc != 0)

  01129	83 bc 24 a8 00
	00 00 00	 cmp	 DWORD PTR rc$12[rsp], 0
  01131	0f 84 9c 00 00
	00		 je	 $LN103@osa_adapte

; 1587 :                         {
; 1588 :                             char msgbuf[256];
; 1589 :                             MSGBUF( msgbuf,

  01137	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0113c	48 83 c0 60	 add	 rax, 96			; 00000060H
  01140	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR tthwaddr$55[rsp]
  01148	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0114d	4c 8b c8	 mov	 r9, rax
  01150	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172277
  01157	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0115c	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$60[rsp]
  01164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1590 :                                 "IPA_CMD_SETVMAC(%s,%s) failed",
; 1591 :                                 grp->ttifname, tthwaddr );
; 1592 :                             QERRMSG( dev, grp, errno, "E", msgbuf );

  0116a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01170	c7 44 24 38 38
	06 00 00	 mov	 DWORD PTR [rsp+56], 1592 ; 00000638H
  01178	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172278
  0117f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172279
  0118b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01190	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR msgbuf$60[rsp]
  01198	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0119d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172280
  011a4	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  011a7	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  011ac	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011b4	e8 00 00 00 00	 call	 qeth_errnum_msg

; 1593 :                             STORE_HW( ipa->rc, IPA_RC_FFFF );

  011b9	66 b9 ff ff	 mov	 cx, 65535		; 0000ffffH
  011bd	e8 00 00 00 00	 call	 _byteswap_ushort
  011c2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  011c7	48 83 c1 04	 add	 rcx, 4
  011cb	0f b7 d0	 movzx	 edx, ax
  011ce	e8 00 00 00 00	 call	 store_hw_noswap
$LN103@osa_adapte:
$LN93@osa_adapte:

; 1594 :                         }
; 1595 : 
; 1596 :                     }
; 1597 : #endif /* defined( OPTION_TUNTAP_SETMACADDR ) */
; 1598 : #endif /* defined( OPTION_W32_CTCI ) */
; 1599 : 
; 1600 :                 }
; 1601 :                 /* end case IPA_CMD_SETVMAC:  0x21 */
; 1602 :                 break;

  011d3	e9 3c 22 00 00	 jmp	 $LN8@osa_adapte
$LN104@osa_adapte:

; 1603 : 
; 1604 :             case IPA_CMD_DELVMAC:  /* 0x22 : Delete Layer-2 MAC address */
; 1605 :                 {
; 1606 :                 MPC_IPA_MAC *ipa_mac = (MPC_IPA_MAC*)(ipa+1);

  011d8	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  011dd	48 83 c0 14	 add	 rax, 20
  011e1	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR ipa_mac$44[rsp], rax

; 1607 :                 int  rc;
; 1608 : 
; 1609 :                     strcat( dev->dev_data, ": IPA_CMD_DELVMAC" );  /* Prepare the contentstring */

  011e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172282
  011f0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011f8	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  011ff	e8 00 00 00 00	 call	 strcat

; 1610 :                     rsp_bhr->content = strdup( dev->dev_data );

  01204	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0120c	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  01219	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  0121e	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1611 : 
; 1612 :                     /* Display the request MPC_TH etc., maybe. */
; 1613 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  01222	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0122a	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  01231	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  01236	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172283
  0123d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  01242	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  01247	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01250	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  01258	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0125d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  01265	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0126d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172284
  01274	ba 4d 06 00 00	 mov	 edx, 1613		; 0000064dH
  01279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172285
  01280	e8 00 00 00 00	 call	 dbgupd

; 1614 : 
; 1615 :                     rc = unregister_mac(grp, dev, ipa_mac->macaddr, MAC_TYPE_UNICST, TRUE);

  01285	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR ipa_mac$44[rsp]
  0128d	48 83 c0 04	 add	 rax, 4
  01291	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  01296	41 b9 02 00 00
	00		 mov	 r9d, 2
  0129c	4c 8b c0	 mov	 r8, rax
  0129f	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  012a7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  012ac	e8 00 00 00 00	 call	 unregister_mac
  012b1	89 84 24 a0 01
	00 00		 mov	 DWORD PTR rc$39[rsp], eax

; 1616 :                     if (rc == 1) {           /* MAC address not in table */

  012b8	83 bc 24 a0 01
	00 00 01	 cmp	 DWORD PTR rc$39[rsp], 1
  012c0	75 1c		 jne	 SHORT $LN105@osa_adapte

; 1617 :                         STORE_HW(ipa->rc, IPA_RC_L2_MAC_NOT_FOUND);

  012c2	66 b9 10 20	 mov	 cx, 8208		; 00002010H
  012c6	e8 00 00 00 00	 call	 _byteswap_ushort
  012cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  012d0	48 83 c1 04	 add	 rcx, 4
  012d4	0f b7 d0	 movzx	 edx, ax
  012d7	e8 00 00 00 00	 call	 store_hw_noswap

; 1618 :                     } else {                 /* MAC address removed from table */

  012dc	eb 18		 jmp	 SHORT $LN106@osa_adapte
$LN105@osa_adapte:

; 1619 :                         STORE_HW(ipa->rc, IPA_RC_SUCCESS);

  012de	33 c9		 xor	 ecx, ecx
  012e0	e8 00 00 00 00	 call	 _byteswap_ushort
  012e5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  012ea	48 83 c1 04	 add	 rcx, 4
  012ee	0f b7 d0	 movzx	 edx, ax
  012f1	e8 00 00 00 00	 call	 store_hw_noswap
$LN106@osa_adapte:

; 1620 :                     }
; 1621 :                 }
; 1622 :                 /* end case IPA_CMD_DELVMAC:  0x22 */
; 1623 :                 break;

  012f6	e9 19 21 00 00	 jmp	 $LN8@osa_adapte
$LN107@osa_adapte:

; 1624 : 
; 1625 :             case IPA_CMD_SETGMAC:  /* 0x23 : Set Layer-2 Group Multicast address */
; 1626 :                 {
; 1627 :                 MPC_IPA_MAC *ipa_mac = (MPC_IPA_MAC*)(ipa+1);

  012fb	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  01300	48 83 c0 14	 add	 rax, 20
  01304	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR ipa_mac$45[rsp], rax

; 1628 :                 int  rc;
; 1629 : 
; 1630 :                     strcat( dev->dev_data, ": IPA_CMD_SETGMAC" );  /* Prepare the contentstring */

  0130c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172289
  01313	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0131b	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01322	e8 00 00 00 00	 call	 strcat

; 1631 :                     rsp_bhr->content = strdup( dev->dev_data );

  01327	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0132f	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0133c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  01341	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1632 : 
; 1633 :                     /* Display the request MPC_TH etc., maybe. */
; 1634 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  01345	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0134d	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  01354	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  01359	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172290
  01360	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  01365	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0136a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01373	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  0137b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01380	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  01388	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01390	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172291
  01397	ba 62 06 00 00	 mov	 edx, 1634		; 00000662H
  0139c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172292
  013a3	e8 00 00 00 00	 call	 dbgupd

; 1635 : 
; 1636 :                     rc = register_mac(grp, dev, ipa_mac->macaddr, MAC_TYPE_MLTCST);

  013a8	48 8b 84 24 d0
	01 00 00	 mov	 rax, QWORD PTR ipa_mac$45[rsp]
  013b0	48 83 c0 04	 add	 rax, 4
  013b4	41 b9 04 00 00
	00		 mov	 r9d, 4
  013ba	4c 8b c0	 mov	 r8, rax
  013bd	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  013c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  013ca	e8 00 00 00 00	 call	 register_mac
  013cf	89 84 24 50 01
	00 00		 mov	 DWORD PTR rc$28[rsp], eax

; 1637 :                     if (rc == -1) {          /* MAC table full */

  013d6	83 bc 24 50 01
	00 00 ff	 cmp	 DWORD PTR rc$28[rsp], -1
  013de	75 1c		 jne	 SHORT $LN108@osa_adapte

; 1638 :                         STORE_HW(ipa->rc, IPA_RC_L2_ADDR_TABLE_FULL);

  013e0	66 b9 06 20	 mov	 cx, 8198		; 00002006H
  013e4	e8 00 00 00 00	 call	 _byteswap_ushort
  013e9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  013ee	48 83 c1 04	 add	 rcx, 4
  013f2	0f b7 d0	 movzx	 edx, ax
  013f5	e8 00 00 00 00	 call	 store_hw_noswap
  013fa	eb 3e		 jmp	 SHORT $LN109@osa_adapte
$LN108@osa_adapte:

; 1639 :                     } else if (rc == 1) {    /* MAC address in table */

  013fc	83 bc 24 50 01
	00 00 01	 cmp	 DWORD PTR rc$28[rsp], 1
  01404	75 1c		 jne	 SHORT $LN110@osa_adapte

; 1640 :                         STORE_HW(ipa->rc, IPA_RC_L2_DUP_MAC);

  01406	66 b9 05 20	 mov	 cx, 8197		; 00002005H
  0140a	e8 00 00 00 00	 call	 _byteswap_ushort
  0140f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  01414	48 83 c1 04	 add	 rcx, 4
  01418	0f b7 d0	 movzx	 edx, ax
  0141b	e8 00 00 00 00	 call	 store_hw_noswap

; 1641 :                     } else {                 /* MAC address added to table */

  01420	eb 18		 jmp	 SHORT $LN111@osa_adapte
$LN110@osa_adapte:

; 1642 :                         STORE_HW(ipa->rc, IPA_RC_SUCCESS);

  01422	33 c9		 xor	 ecx, ecx
  01424	e8 00 00 00 00	 call	 _byteswap_ushort
  01429	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  0142e	48 83 c1 04	 add	 rcx, 4
  01432	0f b7 d0	 movzx	 edx, ax
  01435	e8 00 00 00 00	 call	 store_hw_noswap
$LN111@osa_adapte:
$LN109@osa_adapte:

; 1643 :                     }
; 1644 :                 }
; 1645 :                 /* end case IPA_CMD_SETGMAC:  0x23 */
; 1646 :                 break;

  0143a	e9 d5 1f 00 00	 jmp	 $LN8@osa_adapte
$LN112@osa_adapte:

; 1647 : 
; 1648 :             case IPA_CMD_DELGMAC:  /* 0x24 : Delete Layer-2 Group Multicast address */
; 1649 :                 {
; 1650 :                 MPC_IPA_MAC *ipa_mac = (MPC_IPA_MAC*)(ipa+1);

  0143f	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  01444	48 83 c0 14	 add	 rax, 20
  01448	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR ipa_mac$46[rsp], rax

; 1651 :                 int  rc;
; 1652 : 
; 1653 :                     strcat( dev->dev_data, ": IPA_CMD_DELGMAC" );  /* Prepare the contentstring */

  01450	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172298
  01457	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0145f	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01466	e8 00 00 00 00	 call	 strcat

; 1654 :                     rsp_bhr->content = strdup( dev->dev_data );

  0146b	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01473	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0147a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  01480	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  01485	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1655 : 
; 1656 :                     /* Display the request MPC_TH etc., maybe. */
; 1657 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  01489	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01491	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  01498	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0149d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172299
  014a4	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  014a9	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  014ae	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  014b7	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  014bf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  014c4	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  014cc	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  014d4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172300
  014db	ba 79 06 00 00	 mov	 edx, 1657		; 00000679H
  014e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172301
  014e7	e8 00 00 00 00	 call	 dbgupd

; 1658 : 
; 1659 :                     rc = unregister_mac(grp, dev, ipa_mac->macaddr, MAC_TYPE_MLTCST, TRUE);

  014ec	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR ipa_mac$46[rsp]
  014f4	48 83 c0 04	 add	 rax, 4
  014f8	c6 44 24 20 01	 mov	 BYTE PTR [rsp+32], 1
  014fd	41 b9 04 00 00
	00		 mov	 r9d, 4
  01503	4c 8b c0	 mov	 r8, rax
  01506	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0150e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01513	e8 00 00 00 00	 call	 unregister_mac
  01518	89 84 24 98 01
	00 00		 mov	 DWORD PTR rc$38[rsp], eax

; 1660 :                     if (rc == 1) {           /* MAC address not in table */

  0151f	83 bc 24 98 01
	00 00 01	 cmp	 DWORD PTR rc$38[rsp], 1
  01527	75 1c		 jne	 SHORT $LN113@osa_adapte

; 1661 :                         STORE_HW(ipa->rc, IPA_RC_L2_GMAC_NOT_FOUND);

  01529	66 b9 0b 20	 mov	 cx, 8203		; 0000200bH
  0152d	e8 00 00 00 00	 call	 _byteswap_ushort
  01532	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  01537	48 83 c1 04	 add	 rcx, 4
  0153b	0f b7 d0	 movzx	 edx, ax
  0153e	e8 00 00 00 00	 call	 store_hw_noswap

; 1662 :                     } else {                 /* MAC address removed from table */

  01543	eb 18		 jmp	 SHORT $LN114@osa_adapte
$LN113@osa_adapte:

; 1663 :                         STORE_HW(ipa->rc, IPA_RC_SUCCESS);

  01545	33 c9		 xor	 ecx, ecx
  01547	e8 00 00 00 00	 call	 _byteswap_ushort
  0154c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  01551	48 83 c1 04	 add	 rcx, 4
  01555	0f b7 d0	 movzx	 edx, ax
  01558	e8 00 00 00 00	 call	 store_hw_noswap
$LN114@osa_adapte:

; 1664 :                     }
; 1665 :                 }
; 1666 :                 /* end case IPA_CMD_DELGMAC:  0x24 */
; 1667 :                 break;

  0155d	e9 b2 1e 00 00	 jmp	 $LN8@osa_adapte
$LN115@osa_adapte:

; 1668 : 
; 1669 :             case IPA_CMD_SETVLAN:  /* 0x25 : Set Layer-2 VLAN */
; 1670 :                 {
; 1671 :                     strcat( dev->dev_data, ": IPA_CMD_SETVLAN" );  /* Prepare the contentstring */

  01562	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172305
  01569	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01571	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01578	e8 00 00 00 00	 call	 strcat

; 1672 :                     strcat( dev->dev_data, protoc );               /* Prepare the contentstring */

  0157d	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  01585	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0158d	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01594	e8 00 00 00 00	 call	 strcat

; 1673 :                     rsp_bhr->content = strdup( dev->dev_data );

  01599	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015a1	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  015a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  015ae	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  015b3	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1674 : 
; 1675 :                     /* Display the request MPC_TH etc., maybe. */
; 1676 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  015b7	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015bf	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  015c6	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  015cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172306
  015d2	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  015d7	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  015dc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  015e5	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  015ed	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  015f2	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  015fa	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01602	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172307
  01609	ba 8c 06 00 00	 mov	 edx, 1676		; 0000068cH
  0160e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172308
  01615	e8 00 00 00 00	 call	 dbgupd

; 1677 : 
; 1678 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  0161a	33 c9		 xor	 ecx, ecx
  0161c	e8 00 00 00 00	 call	 _byteswap_ushort
  01621	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  01626	48 83 c1 04	 add	 rcx, 4
  0162a	0f b7 d0	 movzx	 edx, ax
  0162d	e8 00 00 00 00	 call	 store_hw_noswap

; 1679 : 
; 1680 :                     ipadatasize = 2;

  01632	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 2

; 1681 :                 }
; 1682 :                 /* end case IPA_CMD_SETVLAN:  0x25 */
; 1683 :                 break;

  0163d	e9 d2 1d 00 00	 jmp	 $LN8@osa_adapte
$LN116@osa_adapte:

; 1684 : 
; 1685 :             case IPA_CMD_DELVLAN:  /* 0x26 : Delete Layer-2 VLAN */
; 1686 :                 {
; 1687 :                     strcat( dev->dev_data, ": IPA_CMD_DELVLAN" );  /* Prepare the contentstring */

  01642	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172310
  01649	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01651	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01658	e8 00 00 00 00	 call	 strcat

; 1688 :                     strcat( dev->dev_data, protoc );               /* Prepare the contentstring */

  0165d	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  01665	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0166d	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01674	e8 00 00 00 00	 call	 strcat

; 1689 :                     rsp_bhr->content = strdup( dev->dev_data );

  01679	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01681	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01688	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0168e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  01693	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1690 : 
; 1691 :                     /* Display the request MPC_TH etc., maybe. */
; 1692 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  01697	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0169f	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  016a6	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  016ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172311
  016b2	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  016b7	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  016bc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  016c5	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  016cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  016d2	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  016da	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  016e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172312
  016e9	ba 9c 06 00 00	 mov	 edx, 1692		; 0000069cH
  016ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172313
  016f5	e8 00 00 00 00	 call	 dbgupd

; 1693 : 
; 1694 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  016fa	33 c9		 xor	 ecx, ecx
  016fc	e8 00 00 00 00	 call	 _byteswap_ushort
  01701	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  01706	48 83 c1 04	 add	 rcx, 4
  0170a	0f b7 d0	 movzx	 edx, ax
  0170d	e8 00 00 00 00	 call	 store_hw_noswap

; 1695 : 
; 1696 :                     ipadatasize = 2;

  01712	c7 84 24 80 00
	00 00 02 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 2

; 1697 :                 }
; 1698 :                 /* end case IPA_CMD_DELVLAN:  0x26 */
; 1699 :                 break;

  0171d	e9 f2 1c 00 00	 jmp	 $LN8@osa_adapte
$LN117@osa_adapte:

; 1700 : 
; 1701 :             case IPA_CMD_SETIP:  /* 0xB1 : Set Layer-3 IP unicast address */
; 1702 :                 {
; 1703 :                 MPC_IPA_SIP *ipa_sip = (MPC_IPA_SIP*)(ipa+1);

  01722	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  01727	48 83 c0 14	 add	 rax, 20
  0172b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR ipa_sip$13[rsp], rax

; 1704 :                 U16  retcode;
; 1705 :                 int  rc;
; 1706 :                 U32  flags;
; 1707 :                 char ipaddr[16] = {0};

  01733	48 8d 84 24 18
	02 00 00	 lea	 rax, QWORD PTR ipaddr$52[rsp]
  0173b	48 8b f8	 mov	 rdi, rax
  0173e	33 c0		 xor	 eax, eax
  01740	b9 10 00 00 00	 mov	 ecx, 16
  01745	f3 aa		 rep stosb

; 1708 :                 char ipmask[16] = {0};

  01747	48 8d 84 24 68
	02 00 00	 lea	 rax, QWORD PTR ipmask$56[rsp]
  0174f	48 8b f8	 mov	 rdi, rax
  01752	33 c0		 xor	 eax, eax
  01754	b9 10 00 00 00	 mov	 ecx, 16
  01759	f3 aa		 rep stosb

; 1709 : #if defined( OPTION_W32_CTCI )
; 1710 :                 BYTE was_enabled;
; 1711 : #endif
; 1712 : 
; 1713 :                     strcat( dev->dev_data, ": IPA_CMD_SETIP" );  /* Prepare the contentstring */

  0175b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172315
  01762	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0176a	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01771	e8 00 00 00 00	 call	 strcat

; 1714 :                     strcat( dev->dev_data, protoc );             /* Prepare the contentstring */

  01776	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  0177e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01786	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0178d	e8 00 00 00 00	 call	 strcat

; 1715 :                     rsp_bhr->content = strdup( dev->dev_data );

  01792	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0179a	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  017a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  017a7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  017ac	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1716 : 
; 1717 :                     /* Display the request MPC_TH etc., maybe. */
; 1718 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  017b0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017b8	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  017bf	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  017c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172316
  017cb	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  017d0	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  017d5	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  017de	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  017e6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  017eb	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  017f3	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  017fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172317
  01802	ba b6 06 00 00	 mov	 edx, 1718		; 000006b6H
  01807	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172318
  0180e	e8 00 00 00 00	 call	 dbgupd

; 1719 : 
; 1720 :                     retcode = IPA_RC_OK;

  01813	33 c0		 xor	 eax, eax
  01815	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax

; 1721 : 
; 1722 :                     if (proto == IPA_PROTO_IPV4)

  0181a	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  0181f	83 f8 04	 cmp	 eax, 4
  01822	0f 85 e3 03 00
	00		 jne	 $LN118@osa_adapte

; 1723 :                     {
; 1724 :                       /* Save guest IPv4 address and netmask.        */
; 1725 :                       /* Note: ipa_sip->data.ip4.mask often contains */
; 1726 :                       /* 0xFFFFFF00, irrespective of the subnet mask */
; 1727 :                       /* the guest is actually using.                */
; 1728 :                       MSGBUF(ipaddr,"%d.%d.%d.%d",ipa_sip->data.ip4.addr[0],

  01828	b8 01 00 00 00	 mov	 eax, 1
  0182d	48 6b c0 03	 imul	 rax, rax, 3
  01831	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ipa_sip$13[rsp]
  01839	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0183d	b9 01 00 00 00	 mov	 ecx, 1
  01842	48 6b c9 02	 imul	 rcx, rcx, 2
  01846	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ipa_sip$13[rsp]
  0184e	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  01852	ba 01 00 00 00	 mov	 edx, 1
  01857	48 6b d2 01	 imul	 rdx, rdx, 1
  0185b	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR ipa_sip$13[rsp]
  01863	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  01867	bf 01 00 00 00	 mov	 edi, 1
  0186c	48 6b ff 00	 imul	 rdi, rdi, 0
  01870	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR ipa_sip$13[rsp]
  01878	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  0187c	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01880	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  01884	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  01888	44 8b cf	 mov	 r9d, edi
  0188b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172321
  01892	ba 10 00 00 00	 mov	 edx, 16
  01897	48 8d 8c 24 18
	02 00 00	 lea	 rcx, QWORD PTR ipaddr$52[rsp]
  0189f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1729 :                                                   ipa_sip->data.ip4.addr[1],
; 1730 :                                                   ipa_sip->data.ip4.addr[2],
; 1731 :                                                   ipa_sip->data.ip4.addr[3]);
; 1732 :                       MSGBUF(ipmask,"%d.%d.%d.%d",ipa_sip->data.ip4.mask[0],

  018a5	b8 01 00 00 00	 mov	 eax, 1
  018aa	48 6b c0 03	 imul	 rax, rax, 3
  018ae	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR ipa_sip$13[rsp]
  018b6	0f b6 44 01 04	 movzx	 eax, BYTE PTR [rcx+rax+4]
  018bb	b9 01 00 00 00	 mov	 ecx, 1
  018c0	48 6b c9 02	 imul	 rcx, rcx, 2
  018c4	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR ipa_sip$13[rsp]
  018cc	0f b6 4c 0a 04	 movzx	 ecx, BYTE PTR [rdx+rcx+4]
  018d1	ba 01 00 00 00	 mov	 edx, 1
  018d6	48 6b d2 01	 imul	 rdx, rdx, 1
  018da	48 8b bc 24 b0
	00 00 00	 mov	 rdi, QWORD PTR ipa_sip$13[rsp]
  018e2	0f b6 54 17 04	 movzx	 edx, BYTE PTR [rdi+rdx+4]
  018e7	bf 01 00 00 00	 mov	 edi, 1
  018ec	48 6b ff 00	 imul	 rdi, rdi, 0
  018f0	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR ipa_sip$13[rsp]
  018f8	0f b6 7c 3e 04	 movzx	 edi, BYTE PTR [rsi+rdi+4]
  018fd	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  01901	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  01905	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  01909	44 8b cf	 mov	 r9d, edi
  0190c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172322
  01913	ba 10 00 00 00	 mov	 edx, 16
  01918	48 8d 8c 24 68
	02 00 00	 lea	 rcx, QWORD PTR ipmask$56[rsp]
  01920	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1733 :                                                   ipa_sip->data.ip4.mask[1],
; 1734 :                                                   ipa_sip->data.ip4.mask[2],
; 1735 :                                                   ipa_sip->data.ip4.mask[3]);
; 1736 :                       FETCH_FW(flags,ipa_sip->data.ip4.flags);

  01926	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ipa_sip$13[rsp]
  0192e	48 83 c0 08	 add	 rax, 8
  01932	48 8b c8	 mov	 rcx, rax
  01935	e8 00 00 00 00	 call	 fetch_fw_noswap
  0193a	8b c8		 mov	 ecx, eax
  0193c	e8 00 00 00 00	 call	 _byteswap_ulong
  01941	89 84 24 bc 00
	00 00		 mov	 DWORD PTR flags$14[rsp], eax

; 1737 :                       /* Note: whether an address is flagged as default */
; 1738 :                       /* or vipa appear to depend on what the guest is, */
; 1739 :                       /* and how the inferface is defined in the guest. */
; 1740 :                       if (0
; 1741 :                           || flags == IPA_SIP_DEFAULT
; 1742 :                           || flags == IPA_SIP_VIPA
; 1743 :                           || flags == IPA_SIP_TAKEOVER

  01948	33 c0		 xor	 eax, eax
  0194a	85 c0		 test	 eax, eax
  0194c	75 22		 jne	 SHORT $LN122@osa_adapte
  0194e	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR flags$14[rsp], 0
  01956	74 18		 je	 SHORT $LN122@osa_adapte
  01958	83 bc 24 bc 00
	00 00 01	 cmp	 DWORD PTR flags$14[rsp], 1
  01960	74 0e		 je	 SHORT $LN122@osa_adapte
  01962	83 bc 24 bc 00
	00 00 02	 cmp	 DWORD PTR flags$14[rsp], 2
  0196a	0f 85 8c 02 00
	00		 jne	 $LN120@osa_adapte
$LN122@osa_adapte:

; 1744 :                       )
; 1745 :                       {
; 1746 :                         /* Register the IPv4 address */
; 1747 :                         rc = register_ipv4(grp, dev, (BYTE*)ipa_sip->data.ip4.addr);

  01970	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ipa_sip$13[rsp]
  01978	4c 8b c0	 mov	 r8, rax
  0197b	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01983	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01988	e8 00 00 00 00	 call	 register_ipv4
  0198d	89 84 24 98 00
	00 00		 mov	 DWORD PTR rc$10[rsp], eax

; 1748 :                         if (rc == -1) {          /* IP table full */

  01994	83 bc 24 98 00
	00 00 ff	 cmp	 DWORD PTR rc$10[rsp], -1
  0199c	75 0c		 jne	 SHORT $LN123@osa_adapte

; 1749 :                             retcode = IPA_RC_IP_ADDR_TABLE_FULL;

  0199e	b8 06 e0 00 00	 mov	 eax, 57350		; 0000e006H
  019a3	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax
  019a8	eb 1d		 jmp	 SHORT $LN124@osa_adapte
$LN123@osa_adapte:

; 1750 :                         } else if (rc == 1) {    /* IP address in table */

  019aa	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR rc$10[rsp], 1
  019b2	75 0c		 jne	 SHORT $LN125@osa_adapte

; 1751 :                             retcode = IPA_RC_IP_ADDR_ALREADY_USED;

  019b4	b8 0a e0 00 00	 mov	 eax, 57354		; 0000e00aH
  019b9	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax

; 1752 :                         } else {                 /* IP address added to table */

  019be	eb 07		 jmp	 SHORT $LN126@osa_adapte
$LN125@osa_adapte:

; 1753 :                             retcode = IPA_RC_SUCCESS;

  019c0	33 c0		 xor	 eax, eax
  019c2	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax
$LN126@osa_adapte:
$LN124@osa_adapte:

; 1754 :                         }
; 1755 : 
; 1756 :                         /* We only set the interface IPv4 address if the address */
; 1757 :                         /* provided by the guest is different from the address   */
; 1758 :                         /* specified on the configuration statement.             */
; 1759 :                         /* Note: grp->confipaddr4 contains nulls if no address   */
; 1760 :                         /* was specified on the configuration statement.         */
; 1761 :                         if (memcmp( grp->confipaddr4, ipa_sip->data.ip4.addr, 4 ) != 0)

  019c7	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ipa_sip$13[rsp]
  019cf	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  019d4	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  019db	41 b8 04 00 00
	00		 mov	 r8d, 4
  019e1	48 8b d0	 mov	 rdx, rax
  019e4	e8 00 00 00 00	 call	 memcmp
  019e9	85 c0		 test	 eax, eax
  019eb	0f 84 fe 01 00
	00		 je	 $LN127@osa_adapte

; 1762 :                         {
; 1763 : #if defined( OPTION_W32_CTCI )
; 1764 :                           if (tt32_multiple_ip_support())

  019f1	e8 00 00 00 00	 call	 tt32_multiple_ip_support
  019f6	0f b6 c0	 movzx	 eax, al
  019f9	85 c0		 test	 eax, eax
  019fb	74 10		 je	 SHORT $LN128@osa_adapte

; 1765 :                               rc = 0; // 'register_ipv4' did it for us

  019fd	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rc$10[rsp], 0
  01a08	e9 5d 01 00 00	 jmp	 $LN129@osa_adapte
$LN128@osa_adapte:

; 1766 :                           else
; 1767 :                           {
; 1768 :                               /* If the interface is already enabled/up we need to temporarily */
; 1769 :                               /* bring it down (disable it) so we can change the IP address    */
; 1770 :                               /* and then afterwards bring it back up again (enable it).       */
; 1771 :                               was_enabled = grp->enabled ? TRUE : FALSE;

  01a0d	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01a12	83 b8 dc 05 00
	00 00		 cmp	 DWORD PTR [rax+1500], 0
  01a19	74 0d		 je	 SHORT $LN226@osa_adapte
  01a1b	c7 84 24 54 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1057[rsp], 1
  01a26	eb 0b		 jmp	 SHORT $LN227@osa_adapte
$LN226@osa_adapte:
  01a28	c7 84 24 54 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1057[rsp], 0
$LN227@osa_adapte:
  01a33	0f b6 84 24 54
	01 00 00	 movzx	 eax, BYTE PTR tv1057[rsp]
  01a3b	88 84 24 89 00
	00 00		 mov	 BYTE PTR was_enabled$7[rsp], al

; 1772 : 
; 1773 :                               if (was_enabled)

  01a42	0f b6 84 24 89
	00 00 00	 movzx	 eax, BYTE PTR was_enabled$7[rsp]
  01a4a	85 c0		 test	 eax, eax
  01a4c	74 78		 je	 SHORT $LN130@osa_adapte
$LN36@osa_adapte:

; 1774 :                                   VERIFY( qeth_disable_interface( dev, grp ) == 0);

  01a4e	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  01a53	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01a5b	e8 00 00 00 00	 call	 qeth_disable_interface
  01a60	85 c0		 test	 eax, eax
  01a62	74 5c		 je	 SHORT $LN131@osa_adapte
$LN39@osa_adapte:
  01a64	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172335
  01a6b	41 b8 ee 06 00
	00		 mov	 r8d, 1774		; 000006eeH
  01a71	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172336
  01a78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172337
  01a7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01a85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01a8b	85 c0		 test	 eax, eax
  01a8d	74 20		 je	 SHORT $LN132@osa_adapte
  01a8f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172339
  01a96	41 b8 ee 06 00
	00		 mov	 r8d, 1774		; 000006eeH
  01a9c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172340
  01aa3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172341
  01aaa	e8 00 00 00 00	 call	 DebuggerTrace
$LN132@osa_adapte:
  01aaf	33 c0		 xor	 eax, eax
  01ab1	85 c0		 test	 eax, eax
  01ab3	75 af		 jne	 SHORT $LN39@osa_adapte
  01ab5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01abb	85 c0		 test	 eax, eax
  01abd	74 01		 je	 SHORT $LN133@osa_adapte
  01abf	cc		 int	 3
$LN133@osa_adapte:
$LN131@osa_adapte:
  01ac0	33 c0		 xor	 eax, eax
  01ac2	85 c0		 test	 eax, eax
  01ac4	75 88		 jne	 SHORT $LN36@osa_adapte
$LN130@osa_adapte:

; 1775 : #endif
; 1776 :                               rc = TUNTAP_SetDestAddr( grp->ttifname, ipaddr );

  01ac6	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01acb	48 83 c0 60	 add	 rax, 96			; 00000060H
  01acf	48 8d 94 24 18
	02 00 00	 lea	 rdx, QWORD PTR ipaddr$52[rsp]
  01ad7	48 8b c8	 mov	 rcx, rax
  01ada	e8 00 00 00 00	 call	 TUNTAP_SetDestAddr
  01adf	89 84 24 98 00
	00 00		 mov	 DWORD PTR rc$10[rsp], eax

; 1777 : #if defined( OPTION_W32_CTCI )
; 1778 :                               if (was_enabled)

  01ae6	0f b6 84 24 89
	00 00 00	 movzx	 eax, BYTE PTR was_enabled$7[rsp]
  01aee	85 c0		 test	 eax, eax
  01af0	74 78		 je	 SHORT $LN134@osa_adapte
$LN42@osa_adapte:

; 1779 :                                   VERIFY( qeth_enable_interface( dev, grp ) == 0);

  01af2	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  01af7	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01aff	e8 00 00 00 00	 call	 qeth_enable_interface
  01b04	85 c0		 test	 eax, eax
  01b06	74 5c		 je	 SHORT $LN135@osa_adapte
$LN45@osa_adapte:
  01b08	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172345
  01b0f	41 b8 f3 06 00
	00		 mov	 r8d, 1779		; 000006f3H
  01b15	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172346
  01b1c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172347
  01b23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  01b29	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01b2f	85 c0		 test	 eax, eax
  01b31	74 20		 je	 SHORT $LN136@osa_adapte
  01b33	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172349
  01b3a	41 b8 f3 06 00
	00		 mov	 r8d, 1779		; 000006f3H
  01b40	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172350
  01b47	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172351
  01b4e	e8 00 00 00 00	 call	 DebuggerTrace
$LN136@osa_adapte:
  01b53	33 c0		 xor	 eax, eax
  01b55	85 c0		 test	 eax, eax
  01b57	75 af		 jne	 SHORT $LN45@osa_adapte
  01b59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  01b5f	85 c0		 test	 eax, eax
  01b61	74 01		 je	 SHORT $LN137@osa_adapte
  01b63	cc		 int	 3
$LN137@osa_adapte:
$LN135@osa_adapte:
  01b64	33 c0		 xor	 eax, eax
  01b66	85 c0		 test	 eax, eax
  01b68	75 88		 jne	 SHORT $LN42@osa_adapte
$LN134@osa_adapte:
$LN129@osa_adapte:

; 1780 :                           }
; 1781 : #endif
; 1782 :                           if (rc != 0)

  01b6a	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR rc$10[rsp], 0
  01b72	74 7b		 je	 SHORT $LN138@osa_adapte

; 1783 :                           {
; 1784 :                               char buf[64];
; 1785 :                               MSGBUF( buf, "TUNTAP_SetDestAddr(%s) failed", ipaddr );

  01b74	4c 8d 8c 24 18
	02 00 00	 lea	 r9, QWORD PTR ipaddr$52[rsp]
  01b7c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172354
  01b83	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  01b88	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$59[rsp]
  01b90	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1786 :                               QERRMSG( dev, grp, errno, "E", buf );

  01b96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  01b9c	c7 44 24 38 fa
	06 00 00	 mov	 DWORD PTR [rsp+56], 1786 ; 000006faH
  01ba4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172355
  01bab	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01bb0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172356
  01bb7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01bbc	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$59[rsp]
  01bc4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  01bc9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG172357
  01bd0	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  01bd3	48 8b 54 24 60	 mov	 rdx, QWORD PTR grp$[rsp]
  01bd8	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01be0	e8 00 00 00 00	 call	 qeth_errnum_msg

; 1787 :                               retcode = IPA_RC_FFFF;

  01be5	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  01bea	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax
$LN138@osa_adapte:
$LN127@osa_adapte:

; 1788 :                           }
; 1789 :                         }
; 1790 : 
; 1791 :                         ipadatasize = (4 + 4 + 4);

  01bef	c7 84 24 80 00
	00 00 0c 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 12

; 1792 :                       }

  01bfa	eb 0a		 jmp	 SHORT $LN121@osa_adapte
$LN120@osa_adapte:

; 1793 :                       else
; 1794 :                       {
; 1795 :                         retcode = IPA_RC_UNSUPPORTED_SUBCMD;

  01bfc	b8 0e e0 00 00	 mov	 eax, 57358		; 0000e00eH
  01c01	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax
$LN121@osa_adapte:

; 1796 :                       }
; 1797 :                     }

  01c06	e9 a8 00 00 00	 jmp	 $LN119@osa_adapte
$LN118@osa_adapte:

; 1798 : #if defined( ENABLE_IPV6 )
; 1799 :                     else if (proto == IPA_PROTO_IPV6)

  01c0b	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  01c10	83 f8 06	 cmp	 eax, 6
  01c13	0f 85 90 00 00
	00		 jne	 $LN139@osa_adapte

; 1800 :                     {
; 1801 :                       FETCH_FW(flags,ipa_sip->data.ip6.flags);

  01c19	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ipa_sip$13[rsp]
  01c21	48 83 c0 20	 add	 rax, 32			; 00000020H
  01c25	48 8b c8	 mov	 rcx, rax
  01c28	e8 00 00 00 00	 call	 fetch_fw_noswap
  01c2d	8b c8		 mov	 ecx, eax
  01c2f	e8 00 00 00 00	 call	 _byteswap_ulong
  01c34	89 84 24 bc 00
	00 00		 mov	 DWORD PTR flags$14[rsp], eax

; 1802 :                       if (flags == IPA_SIP_DEFAULT)

  01c3b	83 bc 24 bc 00
	00 00 00	 cmp	 DWORD PTR flags$14[rsp], 0
  01c43	75 62		 jne	 SHORT $LN141@osa_adapte

; 1803 :                       {
; 1804 :                         /* Register the IPv6 address */
; 1805 :                         rc = register_ipv6(grp, dev, (BYTE*)ipa_sip->data.ip6.addr);

  01c45	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR ipa_sip$13[rsp]
  01c4d	4c 8b c0	 mov	 r8, rax
  01c50	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01c58	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01c5d	e8 00 00 00 00	 call	 register_ipv6
  01c62	89 84 24 98 00
	00 00		 mov	 DWORD PTR rc$10[rsp], eax

; 1806 :                         if (rc == -1) {          /* IP table full */

  01c69	83 bc 24 98 00
	00 00 ff	 cmp	 DWORD PTR rc$10[rsp], -1
  01c71	75 0c		 jne	 SHORT $LN142@osa_adapte

; 1807 :                             retcode = IPA_RC_IP_ADDR_TABLE_FULL;

  01c73	b8 06 e0 00 00	 mov	 eax, 57350		; 0000e006H
  01c78	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax
  01c7d	eb 1d		 jmp	 SHORT $LN143@osa_adapte
$LN142@osa_adapte:

; 1808 :                         } else if (rc == 1) {    /* IP address in table */

  01c7f	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR rc$10[rsp], 1
  01c87	75 0c		 jne	 SHORT $LN144@osa_adapte

; 1809 :                             retcode = IPA_RC_IP_ADDR_ALREADY_USED;

  01c89	b8 0a e0 00 00	 mov	 eax, 57354		; 0000e00aH
  01c8e	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax

; 1810 :                         } else {                 /* IP address added to table */

  01c93	eb 07		 jmp	 SHORT $LN145@osa_adapte
$LN144@osa_adapte:

; 1811 :                             retcode = IPA_RC_SUCCESS;

  01c95	33 c0		 xor	 eax, eax
  01c97	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax
$LN145@osa_adapte:
$LN143@osa_adapte:

; 1812 :                         }
; 1813 : 
; 1814 :                         // TUNTAP_SetDestAddr issues an ioctl SIOCSIFDSTADDR request,
; 1815 :                         // for which there doesn't appear to be an IPv6 equivalent.
; 1816 :                         // The concept of peer IPv6 addresses doesn't seem to exist,
; 1817 :                         // presumably one is supposed to use routing.
; 1818 : 
; 1819 :                         ipadatasize = (16 + 16 + 4);

  01c9c	c7 84 24 80 00
	00 00 24 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 36 ; 00000024H
$LN141@osa_adapte:

; 1820 :                       }
; 1821 :                     }

  01ca7	eb 0a		 jmp	 SHORT $LN140@osa_adapte
$LN139@osa_adapte:

; 1822 : #endif /* defined( ENABLE_IPV6 ) */
; 1823 :                     else
; 1824 :                     {
; 1825 :                         retcode = IPA_RC_INVALID_IP_VERSION;

  01ca9	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  01cae	66 89 44 24 70	 mov	 WORD PTR retcode$2[rsp], ax
$LN140@osa_adapte:
$LN119@osa_adapte:

; 1826 :                     }
; 1827 : 
; 1828 :                     STORE_HW(ipa->rc,retcode);

  01cb3	0f b7 4c 24 70	 movzx	 ecx, WORD PTR retcode$2[rsp]
  01cb8	e8 00 00 00 00	 call	 _byteswap_ushort
  01cbd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  01cc2	48 83 c1 04	 add	 rcx, 4
  01cc6	0f b7 d0	 movzx	 edx, ax
  01cc9	e8 00 00 00 00	 call	 store_hw_noswap

; 1829 :                 }
; 1830 :                 /* end case IPA_CMD_SETIP:  0xB1 */
; 1831 :                 break;

  01cce	e9 41 17 00 00	 jmp	 $LN8@osa_adapte
$LN146@osa_adapte:

; 1832 : 
; 1833 :             case IPA_CMD_QIPASSIST:  /* 0xB2 : Query Layer-3 IP assist capability */
; 1834 :                 {
; 1835 : 
; 1836 :                     strcat( dev->dev_data, ": IPA_CMD_QIPASSIST" );  /* Prepare the contentstring */

  01cd3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172366
  01cda	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ce2	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01ce9	e8 00 00 00 00	 call	 strcat

; 1837 :                     strcat( dev->dev_data, protoc );                 /* Prepare the contentstring */

  01cee	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  01cf6	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01cfe	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01d05	e8 00 00 00 00	 call	 strcat

; 1838 :                     rsp_bhr->content = strdup( dev->dev_data );

  01d0a	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d12	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01d19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  01d1f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  01d24	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1839 : 
; 1840 :                     /* Display the request MPC_TH etc., maybe. */
; 1841 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  01d28	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01d30	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  01d37	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  01d3c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172367
  01d43	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  01d48	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  01d4d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  01d56	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  01d5e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  01d63	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  01d6b	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  01d73	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172368
  01d7a	ba 31 07 00 00	 mov	 edx, 1841		; 00000731H
  01d7f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172369
  01d86	e8 00 00 00 00	 call	 dbgupd

; 1842 : 
; 1843 :                     grp->ipae0 |= IPA_SETADAPTERPARMS;

  01d8b	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01d90	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [rax+1560]
  01d96	0f ba e8 0a	 bts	 eax, 10
  01d9a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01d9f	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 1844 :                     grp->ipae4 |= IPA_SETADAPTERPARMS;

  01da5	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01daa	8b 80 1c 06 00
	00		 mov	 eax, DWORD PTR [rax+1564]
  01db0	0f ba e8 0a	 bts	 eax, 10
  01db4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01db9	89 81 1c 06 00
	00		 mov	 DWORD PTR [rcx+1564], eax

; 1845 :                     grp->ipae6 |= IPA_SETADAPTERPARMS;

  01dbf	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  01dc4	8b 80 20 06 00
	00		 mov	 eax, DWORD PTR [rax+1568]
  01dca	0f ba e8 0a	 bts	 eax, 10
  01dce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  01dd3	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax

; 1846 : 
; 1847 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  01dd9	33 c9		 xor	 ecx, ecx
  01ddb	e8 00 00 00 00	 call	 _byteswap_ushort
  01de0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  01de5	48 83 c1 04	 add	 rcx, 4
  01de9	0f b7 d0	 movzx	 edx, ax
  01dec	e8 00 00 00 00	 call	 store_hw_noswap

; 1848 : 
; 1849 :                     ipadatasize = 0;

  01df1	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 0

; 1850 :                 }
; 1851 :                 /* end case IPA_CMD_QIPASSIST:  0xB2 */
; 1852 :                 break;

  01dfc	e9 13 16 00 00	 jmp	 $LN8@osa_adapte
$LN147@osa_adapte:

; 1853 : 
; 1854 :             case IPA_CMD_SETASSPARMS:  /* 0xB3 : Set Layer-3 IP assist parameters */
; 1855 :                 {
; 1856 :                 MPC_IPA_SAS *ipa_sas = (MPC_IPA_SAS*)(ipa+1);

  01e01	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  01e06	48 83 c0 14	 add	 rax, 20
  01e0a	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR ipa_sas$25[rsp], rax

; 1857 :                 U32 ano;
; 1858 :                 U16 cmd;
; 1859 :                 U16 len;
; 1860 :                 char anoc[16];
; 1861 : 
; 1862 :                     FETCH_FW(ano,ipa_sas->hdr.ano);    /* Assist number */

  01e12	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR ipa_sas$25[rsp]
  01e1a	48 8b c8	 mov	 rcx, rax
  01e1d	e8 00 00 00 00	 call	 fetch_fw_noswap
  01e22	8b c8		 mov	 ecx, eax
  01e24	e8 00 00 00 00	 call	 _byteswap_ulong
  01e29	89 84 24 8c 00
	00 00		 mov	 DWORD PTR ano$8[rsp], eax

; 1863 :                     FETCH_HW(cmd,ipa_sas->hdr.cmd);    /* Command code */

  01e30	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR ipa_sas$25[rsp]
  01e38	48 83 c0 06	 add	 rax, 6
  01e3c	48 8b c8	 mov	 rcx, rax
  01e3f	e8 00 00 00 00	 call	 fetch_hw_noswap
  01e44	0f b7 c8	 movzx	 ecx, ax
  01e47	e8 00 00 00 00	 call	 _byteswap_ushort
  01e4c	66 89 84 24 9c
	00 00 00	 mov	 WORD PTR cmd$11[rsp], ax

; 1864 :                     FETCH_HW(len,ipa_sas->hdr.len);    /* Length */

  01e54	48 8b 84 24 18
	01 00 00	 mov	 rax, QWORD PTR ipa_sas$25[rsp]
  01e5c	48 83 c0 04	 add	 rax, 4
  01e60	48 8b c8	 mov	 rcx, rax
  01e63	e8 00 00 00 00	 call	 fetch_hw_noswap
  01e68	0f b7 c8	 movzx	 ecx, ax
  01e6b	e8 00 00 00 00	 call	 _byteswap_ushort
  01e70	66 89 84 24 f0
	00 00 00	 mov	 WORD PTR len$19[rsp], ax

; 1865 :                     MSGBUF(anoc, " 0x%08X", ano);      /* Assist number in hex character */

  01e78	44 8b 8c 24 8c
	00 00 00	 mov	 r9d, DWORD PTR ano$8[rsp]
  01e80	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172371
  01e87	ba 10 00 00 00	 mov	 edx, 16
  01e8c	48 8d 8c 24 08
	02 00 00	 lea	 rcx, QWORD PTR anoc$51[rsp]
  01e94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1866 : 
; 1867 :                     strcat( dev->dev_data, ": IPA_CMD_SETASSPARMS" );  /* Prepare the contentstring */

  01e9a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172372
  01ea1	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ea9	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01eb0	e8 00 00 00 00	 call	 strcat

; 1868 :                     strcat( dev->dev_data, protoc );                   /* Prepare the contentstring */

  01eb5	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  01ebd	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ec5	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01ecc	e8 00 00 00 00	 call	 strcat

; 1869 :                     switch(cmd) {

  01ed1	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR cmd$11[rsp]
  01ed9	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv1199[rsp], eax
  01ee0	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR tv1199[rsp]
  01ee7	ff c8		 dec	 eax
  01ee9	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv1199[rsp], eax
  01ef0	83 bc 24 dc 00
	00 00 07	 cmp	 DWORD PTR tv1199[rsp], 7
  01ef8	0f 87 bc 01 00
	00		 ja	 $LN155@osa_adapte
  01efe	48 63 84 24 dc
	00 00 00	 movsxd	 rax, DWORD PTR tv1199[rsp]
  01f06	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  01f0d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN237@osa_adapte[rcx+rax*4]
  01f14	48 03 c1	 add	 rax, rcx
  01f17	ff e0		 jmp	 rax
$LN148@osa_adapte:

; 1870 :                     case IPA_SAS_CMD_START:      /* 0x0001 */
; 1871 :                         strcat( dev->dev_data, ": START" );            /* Prepare the contentstring */

  01f19	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172374
  01f20	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f28	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01f2f	e8 00 00 00 00	 call	 strcat

; 1872 :                         strcat( dev->dev_data, anoc );                 /* Prepare the contentstring */

  01f34	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR anoc$51[rsp]
  01f3c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f44	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01f4b	e8 00 00 00 00	 call	 strcat

; 1873 :                         break;

  01f50	e9 c1 01 00 00	 jmp	 $LN46@osa_adapte
$LN149@osa_adapte:

; 1874 :                     case IPA_SAS_CMD_STOP:       /* 0x0002 */
; 1875 :                         strcat( dev->dev_data, ": STOP" );             /* Prepare the contentstring */

  01f55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172376
  01f5c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f64	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01f6b	e8 00 00 00 00	 call	 strcat

; 1876 :                         strcat( dev->dev_data, anoc );                 /* Prepare the contentstring */

  01f70	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR anoc$51[rsp]
  01f78	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01f80	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01f87	e8 00 00 00 00	 call	 strcat

; 1877 :                         break;

  01f8c	e9 85 01 00 00	 jmp	 $LN46@osa_adapte
$LN150@osa_adapte:

; 1878 :                     case IPA_SAS_CMD_CONFIGURE:  /* 0x0003 */
; 1879 :                         strcat( dev->dev_data, ": CONFIGURE" );        /* Prepare the contentstring */

  01f91	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172378
  01f98	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01fa0	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01fa7	e8 00 00 00 00	 call	 strcat

; 1880 :                         strcat( dev->dev_data, anoc );                 /* Prepare the contentstring */

  01fac	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR anoc$51[rsp]
  01fb4	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01fbc	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01fc3	e8 00 00 00 00	 call	 strcat

; 1881 :                         break;

  01fc8	e9 49 01 00 00	 jmp	 $LN46@osa_adapte
$LN151@osa_adapte:

; 1882 :                     case IPA_SAS_CMD_ENABLE:     /* 0x0004 */
; 1883 :                         strcat( dev->dev_data, ": ENABLE" );           /* Prepare the contentstring */

  01fcd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172380
  01fd4	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01fdc	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01fe3	e8 00 00 00 00	 call	 strcat

; 1884 :                         strcat( dev->dev_data, anoc );                 /* Prepare the contentstring */

  01fe8	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR anoc$51[rsp]
  01ff0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01ff8	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  01fff	e8 00 00 00 00	 call	 strcat

; 1885 :                         break;

  02004	e9 0d 01 00 00	 jmp	 $LN46@osa_adapte
$LN152@osa_adapte:

; 1886 :                     case IPA_SAS_CMD_0005:       /* 0x0005 */
; 1887 :                         strcat( dev->dev_data, ": CMD_0005" );         /* Prepare the contentstring */

  02009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172382
  02010	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02018	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0201f	e8 00 00 00 00	 call	 strcat

; 1888 :                         strcat( dev->dev_data, anoc );                 /* Prepare the contentstring */

  02024	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR anoc$51[rsp]
  0202c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02034	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0203b	e8 00 00 00 00	 call	 strcat

; 1889 :                         break;

  02040	e9 d1 00 00 00	 jmp	 $LN46@osa_adapte
$LN153@osa_adapte:

; 1890 :                     case IPA_SAS_CMD_0006:       /* 0x0006 */
; 1891 :                         strcat( dev->dev_data, ": CMD_0006" );         /* Prepare the contentstring */

  02045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172384
  0204c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02054	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0205b	e8 00 00 00 00	 call	 strcat

; 1892 :                         strcat( dev->dev_data, anoc );                 /* Prepare the contentstring */

  02060	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR anoc$51[rsp]
  02068	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02070	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02077	e8 00 00 00 00	 call	 strcat

; 1893 :                         break;

  0207c	e9 95 00 00 00	 jmp	 $LN46@osa_adapte
$LN154@osa_adapte:

; 1894 :                     case IPA_SAS_CMD_0008:       /* 0x0008 */
; 1895 :                         strcat( dev->dev_data, ": CMD_0008" );         /* Prepare the contentstring */

  02081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172386
  02088	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02090	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02097	e8 00 00 00 00	 call	 strcat

; 1896 :                         strcat( dev->dev_data, anoc );                 /* Prepare the contentstring */

  0209c	48 8d 94 24 08
	02 00 00	 lea	 rdx, QWORD PTR anoc$51[rsp]
  020a4	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  020ac	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  020b3	e8 00 00 00 00	 call	 strcat

; 1897 :                         break;

  020b8	eb 5c		 jmp	 SHORT $LN46@osa_adapte
$LN155@osa_adapte:

; 1898 :                     default:
; 1899 :                         {
; 1900 :                         char not_supp[12];
; 1901 :                             MSGBUF( not_supp, " (0x%04X)", cmd );

  020ba	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR cmd$11[rsp]
  020c2	44 8b c8	 mov	 r9d, eax
  020c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172388
  020cc	ba 0c 00 00 00	 mov	 edx, 12
  020d1	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR not_supp$54[rsp]
  020d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1902 :                             strcat( dev->dev_data, ": NOT SUPPORTED" );  /* Prepare the contentstring */

  020df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172389
  020e6	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  020ee	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  020f5	e8 00 00 00 00	 call	 strcat

; 1903 :                             strcat( dev->dev_data, not_supp );           /* Prepare the contentstring */

  020fa	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR not_supp$54[rsp]
  02102	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0210a	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02111	e8 00 00 00 00	 call	 strcat
$LN46@osa_adapte:

; 1904 :                         }
; 1905 :                     }
; 1906 :                     rsp_bhr->content = strdup( dev->dev_data );

  02116	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0211e	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0212b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  02130	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1907 : 
; 1908 :                     /* Display the request MPC_TH etc., maybe. */
; 1909 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  02134	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0213c	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  02143	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  02148	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172390
  0214f	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  02154	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  02159	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02162	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  0216a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0216f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  02177	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0217f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172391
  02186	ba 75 07 00 00	 mov	 edx, 1909		; 00000775H
  0218b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172392
  02192	e8 00 00 00 00	 call	 dbgupd

; 1910 : 
; 1911 :                     if (proto == IPA_PROTO_IPV4) {

  02197	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  0219c	83 f8 04	 cmp	 eax, 4
  0219f	75 3b		 jne	 SHORT $LN156@osa_adapte

; 1912 :                         if (!(ano & grp->ipas4)) {

  021a1	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  021a6	8b 80 10 06 00
	00		 mov	 eax, DWORD PTR [rax+1552]
  021ac	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ano$8[rsp]
  021b3	23 c8		 and	 ecx, eax
  021b5	8b c1		 mov	 eax, ecx
  021b7	85 c0		 test	 eax, eax
  021b9	75 1f		 jne	 SHORT $LN158@osa_adapte

; 1913 :                             STORE_HW(ipa->rc,IPA_RC_NOTSUPP);

  021bb	66 b9 01 00	 mov	 cx, 1
  021bf	e8 00 00 00 00	 call	 _byteswap_ushort
  021c4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  021c9	48 83 c1 04	 add	 rcx, 4
  021cd	0f b7 d0	 movzx	 edx, ax
  021d0	e8 00 00 00 00	 call	 store_hw_noswap

; 1914 :                             break;

  021d5	e9 3a 12 00 00	 jmp	 $LN8@osa_adapte
$LN158@osa_adapte:

; 1915 :                         }

  021da	eb 7e		 jmp	 SHORT $LN157@osa_adapte
$LN156@osa_adapte:

; 1916 :                     } else if (proto == IPA_PROTO_IPV6) {

  021dc	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  021e1	83 f8 06	 cmp	 eax, 6
  021e4	75 3b		 jne	 SHORT $LN159@osa_adapte

; 1917 :                         if (!(ano & grp->ipas6)) {

  021e6	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  021eb	8b 80 14 06 00
	00		 mov	 eax, DWORD PTR [rax+1556]
  021f1	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ano$8[rsp]
  021f8	23 c8		 and	 ecx, eax
  021fa	8b c1		 mov	 eax, ecx
  021fc	85 c0		 test	 eax, eax
  021fe	75 1f		 jne	 SHORT $LN161@osa_adapte

; 1918 :                             STORE_HW(ipa->rc,IPA_RC_NOTSUPP);

  02200	66 b9 01 00	 mov	 cx, 1
  02204	e8 00 00 00 00	 call	 _byteswap_ushort
  02209	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  0220e	48 83 c1 04	 add	 rcx, 4
  02212	0f b7 d0	 movzx	 edx, ax
  02215	e8 00 00 00 00	 call	 store_hw_noswap

; 1919 :                             break;

  0221a	e9 f5 11 00 00	 jmp	 $LN8@osa_adapte
$LN161@osa_adapte:

; 1920 :                         }
; 1921 :                     } else {

  0221f	eb 39		 jmp	 SHORT $LN160@osa_adapte
$LN159@osa_adapte:

; 1922 :                         if (!(ano & grp->ipas4)) {

  02221	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  02226	8b 80 10 06 00
	00		 mov	 eax, DWORD PTR [rax+1552]
  0222c	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ano$8[rsp]
  02233	23 c8		 and	 ecx, eax
  02235	8b c1		 mov	 eax, ecx
  02237	85 c0		 test	 eax, eax
  02239	75 1f		 jne	 SHORT $LN162@osa_adapte

; 1923 :                             STORE_HW(ipa->rc,IPA_RC_NOTSUPP);

  0223b	66 b9 01 00	 mov	 cx, 1
  0223f	e8 00 00 00 00	 call	 _byteswap_ushort
  02244	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02249	48 83 c1 04	 add	 rcx, 4
  0224d	0f b7 d0	 movzx	 edx, ax
  02250	e8 00 00 00 00	 call	 store_hw_noswap

; 1924 :                             break;

  02255	e9 ba 11 00 00	 jmp	 $LN8@osa_adapte
$LN162@osa_adapte:
$LN160@osa_adapte:
$LN157@osa_adapte:

; 1925 :                         }
; 1926 :                     }
; 1927 : 
; 1928 :                     switch(cmd) {

  0225a	0f b7 84 24 9c
	00 00 00	 movzx	 eax, WORD PTR cmd$11[rsp]
  02262	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv1331[rsp], eax
  02269	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv1331[rsp]
  02270	ff c8		 dec	 eax
  02272	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv1331[rsp], eax
  02279	83 bc 24 e0 00
	00 00 07	 cmp	 DWORD PTR tv1331[rsp], 7
  02281	0f 87 8c 01 00
	00		 ja	 $LN170@osa_adapte
  02287	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR tv1331[rsp]
  0228f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  02296	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN236@osa_adapte[rcx+rax*4]
  0229d	48 03 c1	 add	 rax, rcx
  022a0	ff e0		 jmp	 rax
$LN163@osa_adapte:

; 1929 : 
; 1930 :                     case IPA_SAS_CMD_START:      /* 0x0001 */
; 1931 :                         grp->ipae4 |= ano;

  022a2	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  022a7	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ano$8[rsp]
  022ae	8b 80 1c 06 00
	00		 mov	 eax, DWORD PTR [rax+1564]
  022b4	0b c1		 or	 eax, ecx
  022b6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  022bb	89 81 1c 06 00
	00		 mov	 DWORD PTR [rcx+1564], eax

; 1932 :                         grp->ipae6 |= ano;

  022c1	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  022c6	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ano$8[rsp]
  022cd	8b 80 20 06 00
	00		 mov	 eax, DWORD PTR [rax+1568]
  022d3	0b c1		 or	 eax, ecx
  022d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  022da	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax

; 1933 :                         grp->ipae0 |= ano;

  022e0	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  022e5	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR ano$8[rsp]
  022ec	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [rax+1560]
  022f2	0b c1		 or	 eax, ecx
  022f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  022f9	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 1934 :                         STORE_HW(ipa_sas->hdr.rc,IPA_RC_OK);

  022ff	33 c9		 xor	 ecx, ecx
  02301	e8 00 00 00 00	 call	 _byteswap_ushort
  02306	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ipa_sas$25[rsp]
  0230e	48 83 c1 08	 add	 rcx, 8
  02312	0f b7 d0	 movzx	 edx, ax
  02315	e8 00 00 00 00	 call	 store_hw_noswap

; 1935 :                         STORE_HW(ipa->rc,IPA_RC_OK);

  0231a	33 c9		 xor	 ecx, ecx
  0231c	e8 00 00 00 00	 call	 _byteswap_ushort
  02321	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02326	48 83 c1 04	 add	 rcx, 4
  0232a	0f b7 d0	 movzx	 edx, ax
  0232d	e8 00 00 00 00	 call	 store_hw_noswap

; 1936 :                         break;

  02332	e9 f6 00 00 00	 jmp	 $LN48@osa_adapte
$LN164@osa_adapte:

; 1937 : 
; 1938 :                     case IPA_SAS_CMD_STOP:       /* 0x0002 */
; 1939 :                         grp->ipae4 &= (0xFFFFFFFF - ano);

  02337	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0233c	2b 84 24 8c 00
	00 00		 sub	 eax, DWORD PTR ano$8[rsp]
  02343	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  02348	8b 89 1c 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1564]
  0234e	23 c8		 and	 ecx, eax
  02350	8b c1		 mov	 eax, ecx
  02352	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  02357	89 81 1c 06 00
	00		 mov	 DWORD PTR [rcx+1564], eax

; 1940 :                         grp->ipae6 &= (0xFFFFFFFF - ano);

  0235d	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  02362	2b 84 24 8c 00
	00 00		 sub	 eax, DWORD PTR ano$8[rsp]
  02369	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0236e	8b 89 20 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1568]
  02374	23 c8		 and	 ecx, eax
  02376	8b c1		 mov	 eax, ecx
  02378	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0237d	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax

; 1941 :                         grp->ipae0 &= (0xFFFFFFFF - ano);

  02383	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  02388	2b 84 24 8c 00
	00 00		 sub	 eax, DWORD PTR ano$8[rsp]
  0238f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  02394	8b 89 18 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1560]
  0239a	23 c8		 and	 ecx, eax
  0239c	8b c1		 mov	 eax, ecx
  0239e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  023a3	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 1942 :                         STORE_HW(ipa_sas->hdr.rc,IPA_RC_OK);

  023a9	33 c9		 xor	 ecx, ecx
  023ab	e8 00 00 00 00	 call	 _byteswap_ushort
  023b0	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ipa_sas$25[rsp]
  023b8	48 83 c1 08	 add	 rcx, 8
  023bc	0f b7 d0	 movzx	 edx, ax
  023bf	e8 00 00 00 00	 call	 store_hw_noswap

; 1943 :                         STORE_HW(ipa->rc,IPA_RC_OK);

  023c4	33 c9		 xor	 ecx, ecx
  023c6	e8 00 00 00 00	 call	 _byteswap_ushort
  023cb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  023d0	48 83 c1 04	 add	 rcx, 4
  023d4	0f b7 d0	 movzx	 edx, ax
  023d7	e8 00 00 00 00	 call	 store_hw_noswap

; 1944 :                         break;

  023dc	eb 4f		 jmp	 SHORT $LN48@osa_adapte
$LN165@osa_adapte:
$LN166@osa_adapte:
$LN167@osa_adapte:
$LN168@osa_adapte:
$LN169@osa_adapte:

; 1945 : 
; 1946 :                     case IPA_SAS_CMD_CONFIGURE:  /* 0x0003 */
; 1947 :                     case IPA_SAS_CMD_ENABLE:     /* 0x0004 */
; 1948 :                     case IPA_SAS_CMD_0005:       /* 0x0005 */
; 1949 :                     case IPA_SAS_CMD_0006:       /* 0x0006 */
; 1950 :                     case IPA_SAS_CMD_0008:       /* 0x0008 */
; 1951 :                         STORE_HW(ipa_sas->hdr.rc,IPA_RC_OK);

  023de	33 c9		 xor	 ecx, ecx
  023e0	e8 00 00 00 00	 call	 _byteswap_ushort
  023e5	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR ipa_sas$25[rsp]
  023ed	48 83 c1 08	 add	 rcx, 8
  023f1	0f b7 d0	 movzx	 edx, ax
  023f4	e8 00 00 00 00	 call	 store_hw_noswap

; 1952 :                         STORE_HW(ipa->rc,IPA_RC_OK);

  023f9	33 c9		 xor	 ecx, ecx
  023fb	e8 00 00 00 00	 call	 _byteswap_ushort
  02400	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02405	48 83 c1 04	 add	 rcx, 4
  02409	0f b7 d0	 movzx	 edx, ax
  0240c	e8 00 00 00 00	 call	 store_hw_noswap

; 1953 :                         break;

  02411	eb 1a		 jmp	 SHORT $LN48@osa_adapte
$LN170@osa_adapte:

; 1954 : 
; 1955 :                     default:
; 1956 :                     /*  STORE_HW(ipa_sas->hdr.rc,IPA_RC_UNSUPPORTED_SUBCMD);  */
; 1957 :                         STORE_HW(ipa->rc,IPA_RC_UNSUPPORTED_SUBCMD);

  02413	66 b9 0e e0	 mov	 cx, 57358		; 0000e00eH
  02417	e8 00 00 00 00	 call	 _byteswap_ushort
  0241c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02421	48 83 c1 04	 add	 rcx, 4
  02425	0f b7 d0	 movzx	 edx, ax
  02428	e8 00 00 00 00	 call	 store_hw_noswap
$LN48@osa_adapte:

; 1958 :                     }
; 1959 : 
; 1960 :                     ipadatasize = (len + 4);

  0242d	0f b7 84 24 f0
	00 00 00	 movzx	 eax, WORD PTR len$19[rsp]
  02435	83 c0 04	 add	 eax, 4
  02438	89 84 24 80 00
	00 00		 mov	 DWORD PTR ipadatasize$4[rsp], eax

; 1961 :                 }
; 1962 :                 /* end case IPA_CMD_SETASSPARMS:  0xB3 */
; 1963 :                 break;

  0243f	e9 d0 0f 00 00	 jmp	 $LN8@osa_adapte
$LN171@osa_adapte:

; 1964 : 
; 1965 :             case IPA_CMD_SETIPM:  /* 0xB4 : Set Layer-3 IP multicast address */
; 1966 :                 {
; 1967 :                     strcat( dev->dev_data, ": IPA_CMD_SETIPM" );  /* Prepare the contentstring */

  02444	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172409
  0244b	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02453	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0245a	e8 00 00 00 00	 call	 strcat

; 1968 :                     strcat( dev->dev_data, protoc );              /* Prepare the contentstring */

  0245f	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  02467	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0246f	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02476	e8 00 00 00 00	 call	 strcat

; 1969 :                     rsp_bhr->content = strdup( dev->dev_data );

  0247b	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02483	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0248a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  02490	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  02495	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1970 : 
; 1971 :                     /* Display the request MPC_TH etc., maybe. */
; 1972 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  02499	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  024a1	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  024a8	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  024ad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172410
  024b4	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  024b9	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  024be	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  024c7	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  024cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  024d4	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  024dc	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  024e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172411
  024eb	ba b4 07 00 00	 mov	 edx, 1972		; 000007b4H
  024f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172412
  024f7	e8 00 00 00 00	 call	 dbgupd

; 1973 : 
; 1974 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  024fc	33 c9		 xor	 ecx, ecx
  024fe	e8 00 00 00 00	 call	 _byteswap_ushort
  02503	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02508	48 83 c1 04	 add	 rcx, 4
  0250c	0f b7 d0	 movzx	 edx, ax
  0250f	e8 00 00 00 00	 call	 store_hw_noswap

; 1975 : 
; 1976 :                     ipadatasize = (8 + 16);

  02514	c7 84 24 80 00
	00 00 18 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 24

; 1977 :                 }
; 1978 :                 /* end case IPA_CMD_SETIPM:  0xB4 */
; 1979 :                 break;

  0251f	e9 f0 0e 00 00	 jmp	 $LN8@osa_adapte
$LN172@osa_adapte:

; 1980 : 
; 1981 :             case IPA_CMD_DELIPM:  /* 0xB5 : Delete Layer-3 IP multicast address */
; 1982 :                 {
; 1983 :                     strcat( dev->dev_data, ": IPA_CMD_DELIPM" );  /* Prepare the contentstring */

  02524	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172414
  0252b	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02533	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0253a	e8 00 00 00 00	 call	 strcat

; 1984 :                     strcat( dev->dev_data, protoc );              /* Prepare the contentstring */

  0253f	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  02547	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0254f	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02556	e8 00 00 00 00	 call	 strcat

; 1985 :                     rsp_bhr->content = strdup( dev->dev_data );

  0255b	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02563	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0256a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  02570	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  02575	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1986 : 
; 1987 :                     /* Display the request MPC_TH etc., maybe. */
; 1988 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  02579	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02581	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  02588	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0258d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172415
  02594	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  02599	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0259e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  025a7	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  025af	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  025b4	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  025bc	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  025c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172416
  025cb	ba c4 07 00 00	 mov	 edx, 1988		; 000007c4H
  025d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172417
  025d7	e8 00 00 00 00	 call	 dbgupd

; 1989 : 
; 1990 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  025dc	33 c9		 xor	 ecx, ecx
  025de	e8 00 00 00 00	 call	 _byteswap_ushort
  025e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  025e8	48 83 c1 04	 add	 rcx, 4
  025ec	0f b7 d0	 movzx	 edx, ax
  025ef	e8 00 00 00 00	 call	 store_hw_noswap

; 1991 :                 }
; 1992 :                 /* end case IPA_CMD_DELIPM:  0xB5 */
; 1993 :                 break;

  025f4	e9 1b 0e 00 00	 jmp	 $LN8@osa_adapte
$LN173@osa_adapte:

; 1994 : 
; 1995 :             case IPA_CMD_SETRTG:  /* 0xB6 : Set Layer-3 routing information */
; 1996 :                 {
; 1997 :                 BYTE *ipa_rtg = (BYTE*)(ipa+1);

  025f9	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  025fe	48 83 c0 14	 add	 rax, 20
  02602	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR ipa_rtg$47[rsp], rax

; 1998 : 
; 1999 :                     strcat( dev->dev_data, ": IPA_CMD_SETRTG" );  /* Prepare the contentstring */

  0260a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172419
  02611	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02619	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02620	e8 00 00 00 00	 call	 strcat

; 2000 :                     strcat( dev->dev_data, protoc );              /* Prepare the contentstring */

  02625	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  0262d	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02635	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0263c	e8 00 00 00 00	 call	 strcat

; 2001 :                     rsp_bhr->content = strdup( dev->dev_data );

  02641	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02649	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02650	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  02656	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  0265b	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2002 : 
; 2003 :                     /* Display the request MPC_TH etc., maybe. */
; 2004 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  0265f	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02667	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0266e	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  02673	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172420
  0267a	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0267f	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  02684	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0268d	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  02695	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0269a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  026a2	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  026aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172421
  026b1	ba d4 07 00 00	 mov	 edx, 2004		; 000007d4H
  026b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172422
  026bd	e8 00 00 00 00	 call	 dbgupd

; 2005 : 
; 2006 :                     ipa_rtg[0] = 0;

  026c2	b8 01 00 00 00	 mov	 eax, 1
  026c7	48 6b c0 00	 imul	 rax, rax, 0
  026cb	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR ipa_rtg$47[rsp]
  026d3	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 2007 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  026d7	33 c9		 xor	 ecx, ecx
  026d9	e8 00 00 00 00	 call	 _byteswap_ushort
  026de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  026e3	48 83 c1 04	 add	 rcx, 4
  026e7	0f b7 d0	 movzx	 edx, ax
  026ea	e8 00 00 00 00	 call	 store_hw_noswap

; 2008 :                     ipadatasize = 1;

  026ef	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 1

; 2009 :                 }
; 2010 :                 /* end case IPA_CMD_DELIPM:  0xB6 */
; 2011 :                 break;

  026fa	e9 15 0d 00 00	 jmp	 $LN8@osa_adapte
$LN174@osa_adapte:

; 2012 : 
; 2013 :             case IPA_CMD_DELIP:  /* 0xB7  Delete Layer-3 IP unicast address */
; 2014 :                 {
; 2015 :                 MPC_IPA_SIP *ipa_sip = (MPC_IPA_SIP*)(ipa+1);

  026ff	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  02704	48 83 c0 14	 add	 rax, 20
  02708	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR ipa_sip$33[rsp], rax

; 2016 :                 U16  retcode;
; 2017 :                 int  rc;
; 2018 :                 U32  flags;
; 2019 : 
; 2020 :                     strcat( dev->dev_data, ": IPA_CMD_DELIP" );  /* Prepare the contentstring */

  02710	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172424
  02717	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0271f	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02726	e8 00 00 00 00	 call	 strcat

; 2021 :                     strcat( dev->dev_data, protoc );             /* Prepare the contentstring */

  0272b	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  02733	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0273b	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02742	e8 00 00 00 00	 call	 strcat

; 2022 :                     rsp_bhr->content = strdup( dev->dev_data );

  02747	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0274f	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02756	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0275c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  02761	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2023 : 
; 2024 :                     /* Display the request MPC_TH etc., maybe. */
; 2025 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  02765	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0276d	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  02774	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  02779	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172425
  02780	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  02785	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0278a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02793	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  0279b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  027a0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  027a8	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  027b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172426
  027b7	ba e9 07 00 00	 mov	 edx, 2025		; 000007e9H
  027bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172427
  027c3	e8 00 00 00 00	 call	 dbgupd

; 2026 : 
; 2027 :                     retcode = IPA_RC_OK;

  027c8	33 c0		 xor	 eax, eax
  027ca	66 89 84 24 84
	00 00 00	 mov	 WORD PTR retcode$5[rsp], ax

; 2028 : 
; 2029 :                     if (proto == IPA_PROTO_IPV4)

  027d2	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  027d7	83 f8 04	 cmp	 eax, 4
  027da	75 78		 jne	 SHORT $LN175@osa_adapte

; 2030 :                     {
; 2031 :                       FETCH_FW(flags,ipa_sip->data.ip4.flags);

  027dc	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR ipa_sip$33[rsp]
  027e4	48 83 c0 08	 add	 rax, 8
  027e8	48 8b c8	 mov	 rcx, rax
  027eb	e8 00 00 00 00	 call	 fetch_fw_noswap
  027f0	8b c8		 mov	 ecx, eax
  027f2	e8 00 00 00 00	 call	 _byteswap_ulong
  027f7	89 84 24 fc 00
	00 00		 mov	 DWORD PTR flags$20[rsp], eax

; 2032 :                       if (flags == IPA_SIP_DEFAULT)

  027fe	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR flags$20[rsp], 0
  02806	75 47		 jne	 SHORT $LN177@osa_adapte

; 2033 :                       {
; 2034 : 
; 2035 :                         /* Unregister the IPv4 address */
; 2036 :                         rc = unregister_ipv4(grp, dev, (BYTE*)ipa_sip->data.ip4.addr);

  02808	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR ipa_sip$33[rsp]
  02810	4c 8b c0	 mov	 r8, rax
  02813	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0281b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  02820	e8 00 00 00 00	 call	 unregister_ipv4
  02825	89 84 24 00 01
	00 00		 mov	 DWORD PTR rc$21[rsp], eax

; 2037 :                         if (rc == 1) {           /* IP address not in table */

  0282c	83 bc 24 00 01
	00 00 01	 cmp	 DWORD PTR rc$21[rsp], 1
  02834	75 0f		 jne	 SHORT $LN178@osa_adapte

; 2038 :                           retcode = IPA_RC_UNREGISTERED_ADDR;

  02836	b8 11 00 00 00	 mov	 eax, 17
  0283b	66 89 84 24 84
	00 00 00	 mov	 WORD PTR retcode$5[rsp], ax

; 2039 :                         } else {                 /* IP address removed from to table */

  02843	eb 0a		 jmp	 SHORT $LN179@osa_adapte
$LN178@osa_adapte:

; 2040 :                           retcode = IPA_RC_SUCCESS;

  02845	33 c0		 xor	 eax, eax
  02847	66 89 84 24 84
	00 00 00	 mov	 WORD PTR retcode$5[rsp], ax
$LN179@osa_adapte:
$LN177@osa_adapte:

; 2041 :                         }
; 2042 : 
; 2043 :                       }
; 2044 :                     }

  0284f	e9 8c 00 00 00	 jmp	 $LN176@osa_adapte
$LN175@osa_adapte:

; 2045 : #if defined( ENABLE_IPV6 )
; 2046 :                     else if (proto == IPA_PROTO_IPV6)

  02854	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  02859	83 f8 06	 cmp	 eax, 6
  0285c	75 75		 jne	 SHORT $LN180@osa_adapte

; 2047 :                     {
; 2048 :                       FETCH_FW(flags,ipa_sip->data.ip6.flags);

  0285e	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR ipa_sip$33[rsp]
  02866	48 83 c0 20	 add	 rax, 32			; 00000020H
  0286a	48 8b c8	 mov	 rcx, rax
  0286d	e8 00 00 00 00	 call	 fetch_fw_noswap
  02872	8b c8		 mov	 ecx, eax
  02874	e8 00 00 00 00	 call	 _byteswap_ulong
  02879	89 84 24 fc 00
	00 00		 mov	 DWORD PTR flags$20[rsp], eax

; 2049 :                       if (flags == IPA_SIP_DEFAULT)

  02880	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR flags$20[rsp], 0
  02888	75 47		 jne	 SHORT $LN182@osa_adapte

; 2050 :                       {
; 2051 : 
; 2052 :                         /* Register the IPv6 address */
; 2053 :                         rc = unregister_ipv6(grp, dev, (BYTE*)ipa_sip->data.ip6.addr);

  0288a	48 8b 84 24 78
	01 00 00	 mov	 rax, QWORD PTR ipa_sip$33[rsp]
  02892	4c 8b c0	 mov	 r8, rax
  02895	48 8b 94 24 10
	04 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0289d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  028a2	e8 00 00 00 00	 call	 unregister_ipv6
  028a7	89 84 24 00 01
	00 00		 mov	 DWORD PTR rc$21[rsp], eax

; 2054 :                         if (rc == 1) {           /* IP address not in table */

  028ae	83 bc 24 00 01
	00 00 01	 cmp	 DWORD PTR rc$21[rsp], 1
  028b6	75 0f		 jne	 SHORT $LN183@osa_adapte

; 2055 :                           retcode = IPA_RC_UNREGISTERED_ADDR;

  028b8	b8 11 00 00 00	 mov	 eax, 17
  028bd	66 89 84 24 84
	00 00 00	 mov	 WORD PTR retcode$5[rsp], ax

; 2056 :                         } else {                 /* IP address removed from to table */

  028c5	eb 0a		 jmp	 SHORT $LN184@osa_adapte
$LN183@osa_adapte:

; 2057 :                           retcode = IPA_RC_SUCCESS;

  028c7	33 c0		 xor	 eax, eax
  028c9	66 89 84 24 84
	00 00 00	 mov	 WORD PTR retcode$5[rsp], ax
$LN184@osa_adapte:
$LN182@osa_adapte:

; 2058 :                         }
; 2059 : 
; 2060 :                       }
; 2061 :                     }

  028d1	eb 0d		 jmp	 SHORT $LN181@osa_adapte
$LN180@osa_adapte:

; 2062 : #endif /* defined( ENABLE_IPV6 ) */
; 2063 :                     else
; 2064 :                     {
; 2065 :                       retcode = IPA_RC_INVALID_IP_VERSION;

  028d3	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  028d8	66 89 84 24 84
	00 00 00	 mov	 WORD PTR retcode$5[rsp], ax
$LN181@osa_adapte:
$LN176@osa_adapte:

; 2066 :                     }
; 2067 : 
; 2068 :                     STORE_HW(ipa->rc,retcode);

  028e0	0f b7 8c 24 84
	00 00 00	 movzx	 ecx, WORD PTR retcode$5[rsp]
  028e8	e8 00 00 00 00	 call	 _byteswap_ushort
  028ed	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  028f2	48 83 c1 04	 add	 rcx, 4
  028f6	0f b7 d0	 movzx	 edx, ax
  028f9	e8 00 00 00 00	 call	 store_hw_noswap

; 2069 :                 }
; 2070 :                 /* end case IPA_CMD_DELIP:  0xB7 */
; 2071 :                 break;

  028fe	e9 11 0b 00 00	 jmp	 $LN8@osa_adapte
$LN185@osa_adapte:

; 2072 : 
; 2073 :             case IPA_CMD_SETADPPARMS:  /* 0xB8 : Set Adapter Parameters */
; 2074 :                 {
; 2075 :                 MPC_IPA_SAP *ipa_sap = (MPC_IPA_SAP*)(ipa+1);

  02903	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  02908	48 83 c0 14	 add	 rax, 20
  0290c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR ipa_sap$9[rsp], rax

; 2076 :                 U32 cmd;
; 2077 : 
; 2078 :                     strcat( dev->dev_data, ": IPA_CMD_SETADPPARMS" );    /* Prepare the contentstring */

  02914	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172439
  0291b	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02923	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0292a	e8 00 00 00 00	 call	 strcat

; 2079 :                     strcat( dev->dev_data, protoc );                     /* Prepare the contentstring */

  0292f	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  02937	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0293f	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02946	e8 00 00 00 00	 call	 strcat

; 2080 :                     FETCH_FW(cmd,ipa_sap->cmd);

  0294b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ipa_sap$9[rsp]
  02953	48 83 c0 0c	 add	 rax, 12
  02957	48 8b c8	 mov	 rcx, rax
  0295a	e8 00 00 00 00	 call	 fetch_fw_noswap
  0295f	8b c8		 mov	 ecx, eax
  02961	e8 00 00 00 00	 call	 _byteswap_ulong
  02966	89 84 24 04 01
	00 00		 mov	 DWORD PTR cmd$22[rsp], eax

; 2081 :                     switch(cmd) {

  0296d	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR cmd$22[rsp]
  02974	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv1540[rsp], eax
  0297b	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR tv1540[rsp], 1
  02983	74 42		 je	 SHORT $LN186@osa_adapte
  02985	83 bc 24 c0 00
	00 00 02	 cmp	 DWORD PTR tv1540[rsp], 2
  0298d	74 58		 je	 SHORT $LN187@osa_adapte
  0298f	81 bc 24 c0 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR tv1540[rsp], 1024 ; 00000400H
  0299a	0f 84 29 01 00
	00		 je	 $LN190@osa_adapte
  029a0	81 bc 24 c0 00
	00 00 00 08 00
	00		 cmp	 DWORD PTR tv1540[rsp], 2048 ; 00000800H
  029ab	0f 84 38 01 00
	00		 je	 $LN191@osa_adapte
  029b1	81 bc 24 c0 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR tv1540[rsp], 65536 ; 00010000H
  029bc	0f 84 44 01 00
	00		 je	 $LN192@osa_adapte
  029c2	e9 5c 01 00 00	 jmp	 $LN193@osa_adapte
$LN186@osa_adapte:

; 2082 :                     case IPA_SAP_QUERY:      /* 0x00000001 */
; 2083 :                         strcat( dev->dev_data, ": QUERY" );              /* Prepare the contentstring */

  029c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172441
  029ce	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  029d6	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  029dd	e8 00 00 00 00	 call	 strcat

; 2084 :                         break;

  029e2	e9 95 01 00 00	 jmp	 $LN50@osa_adapte
$LN187@osa_adapte:

; 2085 :                     case IPA_SAP_SETMAC:     /* 0x00000002 */
; 2086 :                         strcat( dev->dev_data, ": SETMAC" );             /* Prepare the contentstring */

  029e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172443
  029ee	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  029f6	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  029fd	e8 00 00 00 00	 call	 strcat

; 2087 :                         {
; 2088 :                         SAP_SMA *sma = (SAP_SMA*)(ipa_sap+1);

  02a02	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ipa_sap$9[rsp]
  02a0a	48 83 c0 18	 add	 rax, 24
  02a0e	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR sma$48[rsp], rax

; 2089 :                         U32 cmd;
; 2090 :                             FETCH_FW(cmd,sma->cmd);

  02a16	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR sma$48[rsp]
  02a1e	48 8b c8	 mov	 rcx, rax
  02a21	e8 00 00 00 00	 call	 fetch_fw_noswap
  02a26	8b c8		 mov	 ecx, eax
  02a28	e8 00 00 00 00	 call	 _byteswap_ulong
  02a2d	89 84 24 58 01
	00 00		 mov	 DWORD PTR cmd$29[rsp], eax

; 2091 :                             switch(cmd) {

  02a34	8b 84 24 58 01
	00 00		 mov	 eax, DWORD PTR cmd$29[rsp]
  02a3b	89 84 24 9c 01
	00 00		 mov	 DWORD PTR tv1553[rsp], eax
  02a42	83 bc 24 9c 01
	00 00 00	 cmp	 DWORD PTR tv1553[rsp], 0
  02a4a	74 02		 je	 SHORT $LN188@osa_adapte
  02a4c	eb 1d		 jmp	 SHORT $LN189@osa_adapte
$LN188@osa_adapte:

; 2092 :                             case IPA_SAP_SMA_CMD_READ:  /* 0 */
; 2093 :                                 strcat( dev->dev_data, ": READ" );       /* Prepare the contentstring */

  02a4e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172445
  02a55	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02a5d	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02a64	e8 00 00 00 00	 call	 strcat

; 2094 :                                 break;

  02a69	eb 59		 jmp	 SHORT $LN52@osa_adapte
$LN189@osa_adapte:

; 2095 : //                          case IPA_SAP_SMA_CMD_REPLACE:  /* 1 */
; 2096 : //                              strcat( dev->dev_data, ": REPLACE" );    /* Prepare the contentstring */
; 2097 : //                              break;
; 2098 : //                          case IPA_SAP_SMA_CMD_ADD:  /* 2 */
; 2099 : //                              strcat( dev->dev_data, ": ADD" );        /* Prepare the contentstring */
; 2100 : //                              break;
; 2101 : //                          case IPA_SAP_SMA_CMD_DEL:  /* 4 */
; 2102 : //                              strcat( dev->dev_data, ": DELETE" );     /* Prepare the contentstring */
; 2103 : //                              break;
; 2104 : //                          case IPA_SAP_SMA_CMD_RESET:  /* 8 */
; 2105 : //                              strcat( dev->dev_data, ": RESET" );      /* Prepare the contentstring */
; 2106 : //                              break;
; 2107 :                             default:
; 2108 :                                 {
; 2109 :                                 char not_supp[16];
; 2110 :                                     MSGBUF( not_supp, " (0x%08X)", cmd );

  02a6b	44 8b 8c 24 58
	01 00 00	 mov	 r9d, DWORD PTR cmd$29[rsp]
  02a73	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172447
  02a7a	ba 10 00 00 00	 mov	 edx, 16
  02a7f	48 8d 8c 24 78
	02 00 00	 lea	 rcx, QWORD PTR not_supp$57[rsp]
  02a87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2111 :                                     strcat( dev->dev_data, ": NOT SUPPORTED" );  /* Prepare the contentstring */

  02a8d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172448
  02a94	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02a9c	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02aa3	e8 00 00 00 00	 call	 strcat

; 2112 :                                     strcat( dev->dev_data, not_supp );           /* Prepare the contentstring */

  02aa8	48 8d 94 24 78
	02 00 00	 lea	 rdx, QWORD PTR not_supp$57[rsp]
  02ab0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02ab8	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02abf	e8 00 00 00 00	 call	 strcat
$LN52@osa_adapte:

; 2113 :                                 }
; 2114 :                             }
; 2115 :                         }
; 2116 :                         break;

  02ac4	e9 b3 00 00 00	 jmp	 $LN50@osa_adapte
$LN190@osa_adapte:

; 2117 : //                  case IPA_SAP_SETGADR:    /* 0x00000004 */
; 2118 : //                      strcat( dev->dev_data, ": SETGADR" );            /* Prepare the contentstring */
; 2119 : //                      break;
; 2120 : //                  case IPA_SAP_SETFADR:    /* 0x00000008 */
; 2121 : //                      strcat( dev->dev_data, ": SETFADR" );            /* Prepare the contentstring */
; 2122 : //                      break;
; 2123 : //                  case IPA_SAP_SETAMODE:   /* 0x00000010 */
; 2124 : //                      strcat( dev->dev_data, ": SETAMODE" );           /* Prepare the contentstring */
; 2125 : //                      break;
; 2126 : //                  case IPA_SAP_SETCFG:     /* 0x00000020 */
; 2127 : //                      strcat( dev->dev_data, ": SETCFG" );             /* Prepare the contentstring */
; 2128 : //                      break;
; 2129 : //                  case IPA_SAP_SETCFGE:    /* 0x00000040 */
; 2130 : //                      strcat( dev->dev_data, ": SETCFGE" );            /* Prepare the contentstring */
; 2131 : //                      break;
; 2132 : //                  case IPA_SAP_BRDCST:     /* 0x00000080 */
; 2133 : //                      strcat( dev->dev_data, ": BRDCST" );             /* Prepare the contentstring */
; 2134 : //                      break;
; 2135 : //                  case IPA_SAP_OSAMSG:     /* 0x00000100 */
; 2136 : //                      strcat( dev->dev_data, ": OSAMSG" );             /* Prepare the contentstring */
; 2137 : //                      break;
; 2138 : //                  case IPA_SAP_SETSNMP:    /* 0x00000200 */
; 2139 : //                      strcat( dev->dev_data, ": SETSNMP" );            /* Prepare the contentstring */
; 2140 : //                      break;
; 2141 :                     case IPA_SAP_CARDINFO:   /* 0x00000400 */
; 2142 :                         strcat( dev->dev_data, ": CARDINFO" );           /* Prepare the contentstring */

  02ac9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172450
  02ad0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02ad8	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02adf	e8 00 00 00 00	 call	 strcat

; 2143 :                         break;

  02ae4	e9 93 00 00 00	 jmp	 $LN50@osa_adapte
$LN191@osa_adapte:

; 2144 :                     case IPA_SAP_PROMISC:    /* 0x00000800 */
; 2145 :                         strcat( dev->dev_data, ": PROMISC" );            /* Prepare the contentstring */

  02ae9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172452
  02af0	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02af8	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02aff	e8 00 00 00 00	 call	 strcat

; 2146 :                         break;

  02b04	eb 76		 jmp	 SHORT $LN50@osa_adapte
$LN192@osa_adapte:

; 2147 : //                  case IPA_SAP_SETDIAG:    /* 0x00002000 */
; 2148 : //                      strcat( dev->dev_data, ": SETDIAG" );            /* Prepare the contentstring */
; 2149 : //                      break;
; 2150 :                     case IPA_SAP_SETACCESS:  /* 0x00010000 */
; 2151 :                         strcat( dev->dev_data, ": SETACCESS" );          /* Prepare the contentstring */

  02b06	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172454
  02b0d	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02b15	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02b1c	e8 00 00 00 00	 call	 strcat

; 2152 :                         break;

  02b21	eb 59		 jmp	 SHORT $LN50@osa_adapte
$LN193@osa_adapte:

; 2153 :                     default:
; 2154 :                         {
; 2155 :                         char not_supp[16];
; 2156 :                             MSGBUF( not_supp, " (0x%08X)", cmd );

  02b23	44 8b 8c 24 04
	01 00 00	 mov	 r9d, DWORD PTR cmd$22[rsp]
  02b2b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172456
  02b32	ba 10 00 00 00	 mov	 edx, 16
  02b37	48 8d 8c 24 88
	02 00 00	 lea	 rcx, QWORD PTR not_supp$58[rsp]
  02b3f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2157 :                             strcat( dev->dev_data, ": NOT SUPPORTED" );  /* Prepare the contentstring */

  02b45	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172457
  02b4c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02b54	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02b5b	e8 00 00 00 00	 call	 strcat

; 2158 :                             strcat( dev->dev_data, not_supp );           /* Prepare the contentstring */

  02b60	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR not_supp$58[rsp]
  02b68	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02b70	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02b77	e8 00 00 00 00	 call	 strcat
$LN50@osa_adapte:

; 2159 :                         }
; 2160 :                     }
; 2161 :                     rsp_bhr->content = strdup( dev->dev_data );

  02b7c	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02b84	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  02b8b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  02b91	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  02b96	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2162 : 
; 2163 :                     /* Display the request MPC_TH etc., maybe. */
; 2164 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  02b9a	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  02ba2	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  02ba9	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  02bae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172458
  02bb5	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  02bba	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  02bbf	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  02bc8	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  02bd0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  02bd5	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  02bdd	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  02be5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172459
  02bec	ba 74 08 00 00	 mov	 edx, 2164		; 00000874H
  02bf1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172460
  02bf8	e8 00 00 00 00	 call	 dbgupd

; 2165 : 
; 2166 :                     switch(cmd) {

  02bfd	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR cmd$22[rsp]
  02c04	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv1607[rsp], eax
  02c0b	83 bc 24 c4 00
	00 00 01	 cmp	 DWORD PTR tv1607[rsp], 1
  02c13	74 46		 je	 SHORT $LN194@osa_adapte
  02c15	83 bc 24 c4 00
	00 00 02	 cmp	 DWORD PTR tv1607[rsp], 2
  02c1d	0f 84 07 01 00
	00		 je	 $LN195@osa_adapte
  02c23	81 bc 24 c4 00
	00 00 00 04 00
	00		 cmp	 DWORD PTR tv1607[rsp], 1024 ; 00000400H
  02c2e	0f 84 6d 02 00
	00		 je	 $LN198@osa_adapte
  02c34	81 bc 24 c4 00
	00 00 00 08 00
	00		 cmp	 DWORD PTR tv1607[rsp], 2048 ; 00000800H
  02c3f	0f 84 2e 03 00
	00		 je	 $LN199@osa_adapte
  02c45	81 bc 24 c4 00
	00 00 00 00 01
	00		 cmp	 DWORD PTR tv1607[rsp], 65536 ; 00010000H
  02c50	0f 84 1f 04 00
	00		 je	 $LN200@osa_adapte
  02c56	e9 4f 04 00 00	 jmp	 $LN201@osa_adapte
$LN194@osa_adapte:

; 2167 : 
; 2168 :                     case IPA_SAP_QUERY:  /*0x00000001 */
; 2169 :                         {
; 2170 :                         SAP_QRY *qry = (SAP_QRY*)(ipa_sap+1);

  02c5b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ipa_sap$9[rsp]
  02c63	48 83 c0 18	 add	 rax, 24
  02c67	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR qry$41[rsp], rax

; 2171 : 
; 2172 :                             STORE_FW(qry->nlan,0x00000001);

  02c6f	b9 01 00 00 00	 mov	 ecx, 1
  02c74	e8 00 00 00 00	 call	 _byteswap_ulong
  02c79	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR qry$41[rsp]
  02c81	8b d0		 mov	 edx, eax
  02c83	e8 00 00 00 00	 call	 store_fw_noswap

; 2173 :                             qry->lan_type = QETH_LINK_TYPE_FAST_ETH;

  02c88	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR qry$41[rsp]
  02c90	c6 40 04 01	 mov	 BYTE PTR [rax+4], 1

; 2174 :                             STORE_FW(qry->suppcm,IPA_SAP_SUPP);

  02c94	b9 03 0c 00 00	 mov	 ecx, 3075		; 00000c03H
  02c99	e8 00 00 00 00	 call	 _byteswap_ulong
  02c9e	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR qry$41[rsp]
  02ca6	48 83 c1 08	 add	 rcx, 8
  02caa	8b d0		 mov	 edx, eax
  02cac	e8 00 00 00 00	 call	 store_fw_noswap

; 2175 :                             STORE_FW(ipa_sap->suppcm,IPA_SAP_SUPP);

  02cb1	b9 03 0c 00 00	 mov	 ecx, 3075		; 00000c03H
  02cb6	e8 00 00 00 00	 call	 _byteswap_ulong
  02cbb	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02cc3	8b d0		 mov	 edx, eax
  02cc5	e8 00 00 00 00	 call	 store_fw_noswap

; 2176 :                             STORE_HW(ipa_sap->cmdlen,(sizeof(SAP_QRY)+sizeof(MPC_IPA_SAP)-8));

  02cca	66 b9 24 00	 mov	 cx, 36			; 00000024H
  02cce	e8 00 00 00 00	 call	 _byteswap_ushort
  02cd3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02cdb	48 83 c1 08	 add	 rcx, 8
  02cdf	0f b7 d0	 movzx	 edx, ax
  02ce2	e8 00 00 00 00	 call	 store_hw_noswap

; 2177 :                             STORE_HW(ipa_sap->rc,IPA_RC_OK);

  02ce7	33 c9		 xor	 ecx, ecx
  02ce9	e8 00 00 00 00	 call	 _byteswap_ushort
  02cee	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02cf6	48 83 c1 10	 add	 rcx, 16
  02cfa	0f b7 d0	 movzx	 edx, ax
  02cfd	e8 00 00 00 00	 call	 store_hw_noswap

; 2178 :                             STORE_HW(ipa->rc,IPA_RC_OK);

  02d02	33 c9		 xor	 ecx, ecx
  02d04	e8 00 00 00 00	 call	 _byteswap_ushort
  02d09	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02d0e	48 83 c1 04	 add	 rcx, 4
  02d12	0f b7 d0	 movzx	 edx, ax
  02d15	e8 00 00 00 00	 call	 store_hw_noswap

; 2179 :                             ipadatasize = (sizeof(SAP_QRY)+sizeof(MPC_IPA_SAP));

  02d1a	c7 84 24 80 00
	00 00 2c 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 44 ; 0000002cH

; 2180 :                         }
; 2181 :                         break;

  02d25	e9 b7 03 00 00	 jmp	 $LN54@osa_adapte
$LN195@osa_adapte:

; 2182 : 
; 2183 :                     case IPA_SAP_SETMAC:  /* 0x00000002 */
; 2184 :                         {
; 2185 :                         SAP_SMA *sma = (SAP_SMA*)(ipa_sap+1);

  02d2a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ipa_sap$9[rsp]
  02d32	48 83 c0 18	 add	 rax, 24
  02d36	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR sma$34[rsp], rax

; 2186 :                         U32 cmd;
; 2187 : 
; 2188 :                             FETCH_FW(cmd,sma->cmd);

  02d3e	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR sma$34[rsp]
  02d46	48 8b c8	 mov	 rcx, rax
  02d49	e8 00 00 00 00	 call	 fetch_fw_noswap
  02d4e	8b c8		 mov	 ecx, eax
  02d50	e8 00 00 00 00	 call	 _byteswap_ulong
  02d55	89 84 24 a4 01
	00 00		 mov	 DWORD PTR cmd$40[rsp], eax

; 2189 :                             switch(cmd) {

  02d5c	8b 84 24 a4 01
	00 00		 mov	 eax, DWORD PTR cmd$40[rsp]
  02d63	89 84 24 88 01
	00 00		 mov	 DWORD PTR tv1678[rsp], eax
  02d6a	83 bc 24 88 01
	00 00 00	 cmp	 DWORD PTR tv1678[rsp], 0
  02d72	74 05		 je	 SHORT $LN196@osa_adapte
  02d74	e9 ec 00 00 00	 jmp	 $LN197@osa_adapte
$LN196@osa_adapte:

; 2190 : 
; 2191 :                             case IPA_SAP_SMA_CMD_READ:  /* 0 */
; 2192 :                                 STORE_FW(sma->asize,IFHWADDRLEN);

  02d79	b9 06 00 00 00	 mov	 ecx, 6
  02d7e	e8 00 00 00 00	 call	 _byteswap_ulong
  02d83	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR sma$34[rsp]
  02d8b	48 83 c1 04	 add	 rcx, 4
  02d8f	8b d0		 mov	 edx, eax
  02d91	e8 00 00 00 00	 call	 store_fw_noswap

; 2193 :                                 STORE_FW(sma->nomacs,1);

  02d96	b9 01 00 00 00	 mov	 ecx, 1
  02d9b	e8 00 00 00 00	 call	 _byteswap_ulong
  02da0	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR sma$34[rsp]
  02da8	48 83 c1 08	 add	 rcx, 8
  02dac	8b d0		 mov	 edx, eax
  02dae	e8 00 00 00 00	 call	 store_fw_noswap

; 2194 :                                 memcpy(sma->addr, grp->iMAC, IFHWADDRLEN);

  02db3	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR sma$34[rsp]
  02dbb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  02dc0	48 8d 78 0c	 lea	 rdi, QWORD PTR [rax+12]
  02dc4	48 8d b1 28 06
	00 00		 lea	 rsi, QWORD PTR [rcx+1576]
  02dcb	b9 06 00 00 00	 mov	 ecx, 6
  02dd0	f3 a4		 rep movsb

; 2195 :                                 STORE_FW(ipa_sap->suppcm,IPA_SAP_SUPP);

  02dd2	b9 03 0c 00 00	 mov	 ecx, 3075		; 00000c03H
  02dd7	e8 00 00 00 00	 call	 _byteswap_ulong
  02ddc	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02de4	8b d0		 mov	 edx, eax
  02de6	e8 00 00 00 00	 call	 store_fw_noswap

; 2196 :                                 STORE_FW(ipa_sap->resv004,IPA_SAP_SUPP);  /* !!!! */

  02deb	b9 03 0c 00 00	 mov	 ecx, 3075		; 00000c03H
  02df0	e8 00 00 00 00	 call	 _byteswap_ulong
  02df5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02dfd	48 83 c1 04	 add	 rcx, 4
  02e01	8b d0		 mov	 edx, eax
  02e03	e8 00 00 00 00	 call	 store_fw_noswap

; 2197 :                                 STORE_HW(ipa_sap->cmdlen,(sizeof(SAP_SMA)+sizeof(MPC_IPA_SAP)-8));

  02e08	66 b9 22 00	 mov	 cx, 34			; 00000022H
  02e0c	e8 00 00 00 00	 call	 _byteswap_ushort
  02e11	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02e19	48 83 c1 08	 add	 rcx, 8
  02e1d	0f b7 d0	 movzx	 edx, ax
  02e20	e8 00 00 00 00	 call	 store_hw_noswap

; 2198 :                                 STORE_HW(ipa_sap->rc,IPA_RC_OK);

  02e25	33 c9		 xor	 ecx, ecx
  02e27	e8 00 00 00 00	 call	 _byteswap_ushort
  02e2c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02e34	48 83 c1 10	 add	 rcx, 16
  02e38	0f b7 d0	 movzx	 edx, ax
  02e3b	e8 00 00 00 00	 call	 store_hw_noswap

; 2199 :                                 STORE_HW(ipa->rc,IPA_RC_OK);

  02e40	33 c9		 xor	 ecx, ecx
  02e42	e8 00 00 00 00	 call	 _byteswap_ushort
  02e47	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02e4c	48 83 c1 04	 add	 rcx, 4
  02e50	0f b7 d0	 movzx	 edx, ax
  02e53	e8 00 00 00 00	 call	 store_hw_noswap

; 2200 :                                 ipadatasize = (sizeof(SAP_SMA)+sizeof(MPC_IPA_SAP));

  02e58	c7 84 24 80 00
	00 00 2a 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 42 ; 0000002aH

; 2201 :                                 break;

  02e63	eb 37		 jmp	 SHORT $LN56@osa_adapte
$LN197@osa_adapte:

; 2202 : 
; 2203 : //                          case IPA_SAP_SMA_CMD_REPLACE:  /* 1 */
; 2204 : //                          case IPA_SAP_SMA_CMD_ADD:  /* 2 */
; 2205 : //                          case IPA_SAP_SMA_CMD_DEL:  /* 4 */
; 2206 : //                          case IPA_SAP_SMA_CMD_RESET:  /* 8 */
; 2207 : 
; 2208 :                             default:
; 2209 :                                 STORE_HW(ipa_sap->rc,IPA_RC_UNSUPPORTED_SUBCMD);

  02e65	66 b9 0e e0	 mov	 cx, 57358		; 0000e00eH
  02e69	e8 00 00 00 00	 call	 _byteswap_ushort
  02e6e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02e76	48 83 c1 10	 add	 rcx, 16
  02e7a	0f b7 d0	 movzx	 edx, ax
  02e7d	e8 00 00 00 00	 call	 store_hw_noswap

; 2210 :                                 STORE_HW(ipa->rc,IPA_RC_UNSUPPORTED_SUBCMD);

  02e82	66 b9 0e e0	 mov	 cx, 57358		; 0000e00eH
  02e86	e8 00 00 00 00	 call	 _byteswap_ushort
  02e8b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02e90	48 83 c1 04	 add	 rcx, 4
  02e94	0f b7 d0	 movzx	 edx, ax
  02e97	e8 00 00 00 00	 call	 store_hw_noswap
$LN56@osa_adapte:

; 2211 :                             }
; 2212 :                         }
; 2213 :                         break;

  02e9c	e9 40 02 00 00	 jmp	 $LN54@osa_adapte
$LN198@osa_adapte:

; 2214 : 
; 2215 :                     case IPA_SAP_CARDINFO:  /* 0x00000400 */
; 2216 :                         {
; 2217 :                         SAP_SCI *sci = (SAP_SCI*)(ipa_sap+1);

  02ea1	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ipa_sap$9[rsp]
  02ea9	48 83 c0 18	 add	 rax, 24
  02ead	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR sci$42[rsp], rax

; 2218 :                             sci->card_type = QETH_CARD_TYPE_OSD;

  02eb5	48 8b 84 24 b0
	01 00 00	 mov	 rax, QWORD PTR sci$42[rsp]
  02ebd	c6 00 01	 mov	 BYTE PTR [rax], 1

; 2219 :                             STORE_HW(sci->port_mode,QETH_PORT_MODE_FULLDUPLEX);

  02ec0	66 b9 03 00	 mov	 cx, 3
  02ec4	e8 00 00 00 00	 call	 _byteswap_ushort
  02ec9	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR sci$42[rsp]
  02ed1	48 83 c1 02	 add	 rcx, 2
  02ed5	0f b7 d0	 movzx	 edx, ax
  02ed8	e8 00 00 00 00	 call	 store_hw_noswap

; 2220 :                             STORE_FW(sci->port_speed,QETH_PORT_SPEED_10M);

  02edd	b9 05 00 00 00	 mov	 ecx, 5
  02ee2	e8 00 00 00 00	 call	 _byteswap_ulong
  02ee7	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR sci$42[rsp]
  02eef	48 83 c1 04	 add	 rcx, 4
  02ef3	8b d0		 mov	 edx, eax
  02ef5	e8 00 00 00 00	 call	 store_fw_noswap

; 2221 :                             STORE_FW(ipa_sap->suppcm,IPA_SAP_SUPP);

  02efa	b9 03 0c 00 00	 mov	 ecx, 3075		; 00000c03H
  02eff	e8 00 00 00 00	 call	 _byteswap_ulong
  02f04	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02f0c	8b d0		 mov	 edx, eax
  02f0e	e8 00 00 00 00	 call	 store_fw_noswap

; 2222 :                             STORE_HW(ipa_sap->cmdlen,(sizeof(SAP_SCI)+sizeof(MPC_IPA_SAP)-8));

  02f13	66 b9 1c 00	 mov	 cx, 28
  02f17	e8 00 00 00 00	 call	 _byteswap_ushort
  02f1c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02f24	48 83 c1 08	 add	 rcx, 8
  02f28	0f b7 d0	 movzx	 edx, ax
  02f2b	e8 00 00 00 00	 call	 store_hw_noswap

; 2223 :                             STORE_HW(ipa_sap->rc,IPA_RC_OK);

  02f30	33 c9		 xor	 ecx, ecx
  02f32	e8 00 00 00 00	 call	 _byteswap_ushort
  02f37	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  02f3f	48 83 c1 10	 add	 rcx, 16
  02f43	0f b7 d0	 movzx	 edx, ax
  02f46	e8 00 00 00 00	 call	 store_hw_noswap

; 2224 :                             STORE_HW(ipa->rc,IPA_RC_OK);

  02f4b	33 c9		 xor	 ecx, ecx
  02f4d	e8 00 00 00 00	 call	 _byteswap_ushort
  02f52	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  02f57	48 83 c1 04	 add	 rcx, 4
  02f5b	0f b7 d0	 movzx	 edx, ax
  02f5e	e8 00 00 00 00	 call	 store_hw_noswap

; 2225 :                             ipadatasize = (sizeof(SAP_SCI)+sizeof(MPC_IPA_SAP));

  02f63	c7 84 24 80 00
	00 00 24 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 36 ; 00000024H

; 2226 :                         }
; 2227 :                         break;

  02f6e	e9 6e 01 00 00	 jmp	 $LN54@osa_adapte
$LN199@osa_adapte:

; 2228 : 
; 2229 :                     case IPA_SAP_PROMISC:  /* 0x00000800 */
; 2230 :                         {
; 2231 :                         SAP_SPM *spm = (SAP_SPM*)(ipa_sap+1);

  02f73	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR ipa_sap$9[rsp]
  02f7b	48 83 c0 18	 add	 rax, 24
  02f7f	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR spm$49[rsp], rax

; 2232 :                         U32 promisc;
; 2233 :                             FETCH_FW(promisc,spm->promisc);

  02f87	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR spm$49[rsp]
  02f8f	48 8b c8	 mov	 rcx, rax
  02f92	e8 00 00 00 00	 call	 fetch_fw_noswap
  02f97	8b c8		 mov	 ecx, eax
  02f99	e8 00 00 00 00	 call	 _byteswap_ulong
  02f9e	89 84 24 8c 01
	00 00		 mov	 DWORD PTR promisc$35[rsp], eax

; 2234 :                             grp->promisc = promisc ? MAC_TYPE_PROMISC : 0;

  02fa5	83 bc 24 8c 01
	00 00 00	 cmp	 DWORD PTR promisc$35[rsp], 0
  02fad	74 0d		 je	 SHORT $LN228@osa_adapte
  02faf	c7 84 24 28 01
	00 00 80 00 00
	00		 mov	 DWORD PTR tv1774[rsp], 128 ; 00000080H
  02fba	eb 0b		 jmp	 SHORT $LN229@osa_adapte
$LN228@osa_adapte:
  02fbc	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1774[rsp], 0
$LN229@osa_adapte:
  02fc7	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  02fcc	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv1774[rsp]
  02fd3	89 88 d8 05 00
	00		 mov	 DWORD PTR [rax+1496], ecx

; 2235 :                             DBGTRC(dev, "  IPA_SAP_PROMISC %s",grp->promisc ? "On" : "Off");

  02fd9	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  02fde	83 b8 d8 05 00
	00 00		 cmp	 DWORD PTR [rax+1496], 0
  02fe5	74 11		 je	 SHORT $LN230@osa_adapte
  02fe7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172467
  02fee	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1777[rsp], rax
  02ff6	eb 0f		 jmp	 SHORT $LN231@osa_adapte
$LN230@osa_adapte:
  02ff8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172468
  02fff	48 89 84 24 c0
	01 00 00	 mov	 QWORD PTR tv1777[rsp], rax
$LN231@osa_adapte:
  03007	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR tv1777[rsp]
  0300f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  03014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172469
  0301b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03020	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  03028	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172470
  0302f	ba bb 08 00 00	 mov	 edx, 2235		; 000008bbH
  03034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172471
  0303b	e8 00 00 00 00	 call	 dbgtrc

; 2236 :                             STORE_HW(ipa_sap->rc,IPA_RC_OK);

  03040	33 c9		 xor	 ecx, ecx
  03042	e8 00 00 00 00	 call	 _byteswap_ushort
  03047	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  0304f	48 83 c1 10	 add	 rcx, 16
  03053	0f b7 d0	 movzx	 edx, ax
  03056	e8 00 00 00 00	 call	 store_hw_noswap

; 2237 :                             STORE_HW(ipa->rc,IPA_RC_OK);

  0305b	33 c9		 xor	 ecx, ecx
  0305d	e8 00 00 00 00	 call	 _byteswap_ushort
  03062	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  03067	48 83 c1 04	 add	 rcx, 4
  0306b	0f b7 d0	 movzx	 edx, ax
  0306e	e8 00 00 00 00	 call	 store_hw_noswap

; 2238 :                         }
; 2239 :                         break;

  03073	eb 6c		 jmp	 SHORT $LN54@osa_adapte
$LN200@osa_adapte:

; 2240 : 
; 2241 :                     case IPA_SAP_SETACCESS:  /* 0x00010000 */
; 2242 :                         STORE_HW(ipa_sap->rc,IPA_RC_OK);

  03075	33 c9		 xor	 ecx, ecx
  03077	e8 00 00 00 00	 call	 _byteswap_ushort
  0307c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  03084	48 83 c1 10	 add	 rcx, 16
  03088	0f b7 d0	 movzx	 edx, ax
  0308b	e8 00 00 00 00	 call	 store_hw_noswap

; 2243 :                         STORE_HW(ipa->rc,IPA_RC_OK);

  03090	33 c9		 xor	 ecx, ecx
  03092	e8 00 00 00 00	 call	 _byteswap_ushort
  03097	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  0309c	48 83 c1 04	 add	 rcx, 4
  030a0	0f b7 d0	 movzx	 edx, ax
  030a3	e8 00 00 00 00	 call	 store_hw_noswap

; 2244 :                         break;

  030a8	eb 37		 jmp	 SHORT $LN54@osa_adapte
$LN201@osa_adapte:

; 2245 : 
; 2246 :                     default:
; 2247 :                         STORE_HW(ipa_sap->rc,IPA_RC_UNSUPPORTED_SUBCMD);

  030aa	66 b9 0e e0	 mov	 cx, 57358		; 0000e00eH
  030ae	e8 00 00 00 00	 call	 _byteswap_ushort
  030b3	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR ipa_sap$9[rsp]
  030bb	48 83 c1 10	 add	 rcx, 16
  030bf	0f b7 d0	 movzx	 edx, ax
  030c2	e8 00 00 00 00	 call	 store_hw_noswap

; 2248 :                         STORE_HW(ipa->rc,IPA_RC_UNSUPPORTED_SUBCMD);

  030c7	66 b9 0e e0	 mov	 cx, 57358		; 0000e00eH
  030cb	e8 00 00 00 00	 call	 _byteswap_ushort
  030d0	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  030d5	48 83 c1 04	 add	 rcx, 4
  030d9	0f b7 d0	 movzx	 edx, ax
  030dc	e8 00 00 00 00	 call	 store_hw_noswap
$LN54@osa_adapte:

; 2249 :                     }
; 2250 :                 }
; 2251 :                 /* end case IPA_CMD_SETADPPARMS:  0xB8 */
; 2252 :                 break;

  030e1	e9 2e 03 00 00	 jmp	 $LN8@osa_adapte
$LN202@osa_adapte:

; 2253 : 
; 2254 :             case IPA_CMD_SETDIAGASS:  /* 0xB9 : Set Layer-3 diagnostic assists */
; 2255 :                 {
; 2256 :                     strcat( dev->dev_data, ": IPA_CMD_SETDIAGASS" );  /* Prepare the contentstring */

  030e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172475
  030ed	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  030f5	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  030fc	e8 00 00 00 00	 call	 strcat

; 2257 :                     strcat( dev->dev_data, protoc );                  /* Prepare the contentstring */

  03101	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  03109	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03111	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  03118	e8 00 00 00 00	 call	 strcat

; 2258 :                     rsp_bhr->content = strdup( dev->dev_data );

  0311d	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03125	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0312c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  03132	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  03137	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2259 : 
; 2260 :                     /* Display the request MPC_TH etc., maybe. */
; 2261 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  0313b	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03143	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0314a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0314f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172476
  03156	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0315b	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  03160	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  03169	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  03171	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  03176	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0317e	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  03186	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172477
  0318d	ba d5 08 00 00	 mov	 edx, 2261		; 000008d5H
  03192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172478
  03199	e8 00 00 00 00	 call	 dbgupd

; 2262 : 
; 2263 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  0319e	33 c9		 xor	 ecx, ecx
  031a0	e8 00 00 00 00	 call	 _byteswap_ushort
  031a5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  031aa	48 83 c1 04	 add	 rcx, 4
  031ae	0f b7 d0	 movzx	 edx, ax
  031b1	e8 00 00 00 00	 call	 store_hw_noswap

; 2264 :                 }
; 2265 :                 /* end case IPA_CMD_SETDIAGASS:  0xB9 */
; 2266 :                 break;

  031b6	e9 59 02 00 00	 jmp	 $LN8@osa_adapte
$LN203@osa_adapte:

; 2267 : 
; 2268 :             case IPA_CMD_CREATEADDR:  /* 0xC3 : Create Layer-3 IPv6 address from Layer-2 MAC address */
; 2269 :                 {
; 2270 :                 BYTE *ip6 = (BYTE*)(ipa+1);

  031bb	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  031c0	48 83 c0 14	 add	 rax, 20
  031c4	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR ip6$31[rsp], rax

; 2271 : 
; 2272 :                     strcat( dev->dev_data, ": IPA_CMD_CREATEADDR" );  /* Prepare the contentstring */

  031cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172480
  031d3	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  031db	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  031e2	e8 00 00 00 00	 call	 strcat

; 2273 :                     strcat( dev->dev_data, protoc );                  /* Prepare the contentstring */

  031e7	48 8d 94 24 f8
	01 00 00	 lea	 rdx, QWORD PTR protoc$50[rsp]
  031ef	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  031f7	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  031fe	e8 00 00 00 00	 call	 strcat

; 2274 :                     rsp_bhr->content = strdup( dev->dev_data );

  03203	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0320b	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  03212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  03218	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  0321d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2275 : 
; 2276 :                     /* Display the request MPC_TH etc., maybe. */
; 2277 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  03221	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03229	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  03230	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  03235	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172481
  0323c	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  03241	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  03246	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0324f	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  03257	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0325c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  03264	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0326c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172482
  03273	ba e5 08 00 00	 mov	 edx, 2277		; 000008e5H
  03278	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172483
  0327f	e8 00 00 00 00	 call	 dbgupd

; 2278 : 
; 2279 :                     /* Return the values that the guest wiil use to create   */
; 2280 :                     /* the low-order 64-bits of the IPv6 link local address. */
; 2281 :                     memcpy( ip6+0, grp->iMAC, IFHWADDRLEN );

  03284	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  03289	48 8b bc 24 68
	01 00 00	 mov	 rdi, QWORD PTR ip6$31[rsp]
  03291	48 8d b0 28 06
	00 00		 lea	 rsi, QWORD PTR [rax+1576]
  03298	b9 06 00 00 00	 mov	 ecx, 6
  0329d	f3 a4		 rep movsb

; 2282 :                     ip6[6] = 0xFF;

  0329f	b8 01 00 00 00	 mov	 eax, 1
  032a4	48 6b c0 06	 imul	 rax, rax, 6
  032a8	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR ip6$31[rsp]
  032b0	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 2283 :                     ip6[7] = 0xFE;

  032b4	b8 01 00 00 00	 mov	 eax, 1
  032b9	48 6b c0 07	 imul	 rax, rax, 7
  032bd	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR ip6$31[rsp]
  032c5	c6 04 01 fe	 mov	 BYTE PTR [rcx+rax], 254	; 000000feH

; 2284 :                     ip6[0] |= 0x02; // FIXME: IPA_CMD_CREATEADDR: is this needed?

  032c9	b8 01 00 00 00	 mov	 eax, 1
  032ce	48 6b c0 00	 imul	 rax, rax, 0
  032d2	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR ip6$31[rsp]
  032da	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  032de	83 c8 02	 or	 eax, 2
  032e1	b9 01 00 00 00	 mov	 ecx, 1
  032e6	48 6b c9 00	 imul	 rcx, rcx, 0
  032ea	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR ip6$31[rsp]
  032f2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 2285 : 
; 2286 :                     STORE_HW(ipa->rc,IPA_RC_OK);

  032f5	33 c9		 xor	 ecx, ecx
  032f7	e8 00 00 00 00	 call	 _byteswap_ushort
  032fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  03301	48 83 c1 04	 add	 rcx, 4
  03305	0f b7 d0	 movzx	 edx, ax
  03308	e8 00 00 00 00	 call	 store_hw_noswap

; 2287 : 
; 2288 :                     ipadatasize = 8;

  0330d	c7 84 24 80 00
	00 00 08 00 00
	00		 mov	 DWORD PTR ipadatasize$4[rsp], 8

; 2289 :                 }
; 2290 :                 /* end case IPA_CMD_CREATEADDR:  0xC3 */
; 2291 :                 break;

  03318	e9 f7 00 00 00	 jmp	 $LN8@osa_adapte
$LN204@osa_adapte:

; 2292 : 
; 2293 :             default:
; 2294 :                 {
; 2295 :                 char cmd_not_supp[10];
; 2296 : 
; 2297 :                     MSGBUF( cmd_not_supp, " (0x%02X)", ipa->cmd );

  0331d	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  03322	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  03325	44 8b c8	 mov	 r9d, eax
  03328	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172485
  0332f	ba 0a 00 00 00	 mov	 edx, 10
  03334	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR cmd_not_supp$53[rsp]
  0333c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2298 :                     strcat( dev->dev_data, ": NOT SUPPORTED" );  /* Prepare the contentstring */

  03342	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG172486
  03349	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03351	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  03358	e8 00 00 00 00	 call	 strcat

; 2299 :                     strcat( dev->dev_data, cmd_not_supp );       /* Prepare the contentstring */

  0335d	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR cmd_not_supp$53[rsp]
  03365	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0336d	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  03374	e8 00 00 00 00	 call	 strcat

; 2300 :                     rsp_bhr->content = strdup( dev->dev_data );

  03379	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  03381	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  03388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0338e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  03393	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2301 : 
; 2302 :                     /* Display the request MPC_TH etc., maybe. */
; 2303 :                     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  03397	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0339f	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  033a6	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  033ab	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172487
  033b2	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  033b7	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  033bc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  033c5	48 8b 84 24 18
	04 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  033cd	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  033d2	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  033da	4c 8b 8c 24 10
	04 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  033e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172488
  033e9	ba ff 08 00 00	 mov	 edx, 2303		; 000008ffH
  033ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172489
  033f5	e8 00 00 00 00	 call	 dbgupd

; 2304 : 
; 2305 :                     STORE_HW(ipa->rc,IPA_RC_NOTSUPP);

  033fa	66 b9 01 00	 mov	 cx, 1
  033fe	e8 00 00 00 00	 call	 _byteswap_ushort
  03403	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  03408	48 83 c1 04	 add	 rcx, 4
  0340c	0f b7 d0	 movzx	 edx, ax
  0340f	e8 00 00 00 00	 call	 store_hw_noswap
$LN8@osa_adapte:

; 2306 :                 }
; 2307 :             }
; 2308 :             /* end switch(ipa->cmd) */
; 2309 : 
; 2310 :             {
; 2311 :             U32  uLoselen;
; 2312 :             U32  uLength1;
; 2313 :             U32  uLength3;
; 2314 : 
; 2315 :                 if (ipasize != SIZE_IPA || ipadatasize != -1) {

  03414	83 bc 24 08 01
	00 00 14	 cmp	 DWORD PTR ipasize$23[rsp], 20
  0341c	75 0e		 jne	 SHORT $LN206@osa_adapte
  0341e	83 bc 24 80 00
	00 00 ff	 cmp	 DWORD PTR ipadatasize$4[rsp], -1
  03426	0f 84 d7 00 00
	00		 je	 $LN205@osa_adapte
$LN206@osa_adapte:

; 2316 :                     uLength3 = ipasize + ipadatasize;

  0342c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR ipadatasize$4[rsp]
  03433	8b 8c 24 08 01
	00 00		 mov	 ecx, DWORD PTR ipasize$23[rsp]
  0343a	03 c8		 add	 ecx, eax
  0343c	8b c1		 mov	 eax, ecx
  0343e	89 84 24 cc 00
	00 00		 mov	 DWORD PTR uLength3$16[rsp], eax

; 2317 :                     uLoselen = lendata - uLength3;

  03445	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR uLength3$16[rsp]
  0344c	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR lendata$17[rsp]
  03453	2b c8		 sub	 ecx, eax
  03455	8b c1		 mov	 eax, ecx
  03457	89 84 24 90 01
	00 00		 mov	 DWORD PTR uLoselen$36[rsp], eax

; 2318 :                     uLength1 = rqsize - uLoselen;

  0345e	8b 84 24 90 01
	00 00		 mov	 eax, DWORD PTR uLoselen$36[rsp]
  03465	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR rqsize$15[rsp]
  0346c	2b c8		 sub	 ecx, eax
  0346e	8b c1		 mov	 eax, ecx
  03470	89 84 24 2c 01
	00 00		 mov	 DWORD PTR uLength1$27[rsp], eax

; 2319 :                     rsp_bhr->datalen = uLength1;

  03477	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  0347c	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR uLength1$27[rsp]
  03483	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 2320 :                     STORE_FW( rsp_th->length, uLength1 );

  03486	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR uLength1$27[rsp]
  0348d	e8 00 00 00 00	 call	 _byteswap_ulong
  03492	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR rsp_th$26[rsp]
  0349a	48 83 c1 0c	 add	 rcx, 12
  0349e	8b d0		 mov	 edx, eax
  034a0	e8 00 00 00 00	 call	 store_fw_noswap

; 2321 :                     STORE_HW( rsp_rrh->lenfida, (U16)uLength3 );

  034a5	0f b7 8c 24 cc
	00 00 00	 movzx	 ecx, WORD PTR uLength3$16[rsp]
  034ad	e8 00 00 00 00	 call	 _byteswap_ushort
  034b2	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR rsp_rrh$32[rsp]
  034ba	48 83 c1 12	 add	 rcx, 18
  034be	0f b7 d0	 movzx	 edx, ax
  034c1	e8 00 00 00 00	 call	 store_hw_noswap

; 2322 :                     STORE_F3( rsp_rrh->lenalda, uLength3 );

  034c6	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR uLength3$16[rsp]
  034cd	e8 00 00 00 00	 call	 _byteswap_ulong
  034d2	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR rsp_rrh$32[rsp]
  034da	48 83 c1 14	 add	 rcx, 20
  034de	8b d0		 mov	 edx, eax
  034e0	e8 00 00 00 00	 call	 store_f3_noswap

; 2323 :                     STORE_F3( rsp_ph->lendata, uLength3 );

  034e5	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR uLength3$16[rsp]
  034ec	e8 00 00 00 00	 call	 _byteswap_ulong
  034f1	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR rsp_ph$43[rsp]
  034f9	48 ff c1	 inc	 rcx
  034fc	8b d0		 mov	 edx, eax
  034fe	e8 00 00 00 00	 call	 store_f3_noswap
$LN205@osa_adapte:

; 2324 :                 }
; 2325 : 
; 2326 :             }
; 2327 : 
; 2328 : //          ipa->iid = IPA_IID_ADAPTER | IPA_IID_REPLY;
; 2329 :             ipa->iid = IPA_IID_HOST;

  03503	48 8b 44 24 68	 mov	 rax, QWORD PTR ipa$1[rsp]
  03508	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0

; 2330 :             if (proto == IPA_PROTO_IPV4) {

  0350c	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  03511	83 f8 04	 cmp	 eax, 4
  03514	75 72		 jne	 SHORT $LN207@osa_adapte

; 2331 :                 STORE_FW(ipa->ipas,grp->ipas4);

  03516	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0351b	8b 88 10 06 00
	00		 mov	 ecx, DWORD PTR [rax+1552]
  03521	e8 00 00 00 00	 call	 _byteswap_ulong
  03526	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  0352b	48 83 c1 0c	 add	 rcx, 12
  0352f	8b d0		 mov	 edx, eax
  03531	e8 00 00 00 00	 call	 store_fw_noswap

; 2332 :                 grp->ipae4 &= grp->ipas4;

  03536	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  0353b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  03540	8b 89 10 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1552]
  03546	8b 80 1c 06 00
	00		 mov	 eax, DWORD PTR [rax+1564]
  0354c	23 c1		 and	 eax, ecx
  0354e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  03553	89 81 1c 06 00
	00		 mov	 DWORD PTR [rcx+1564], eax

; 2333 :                 if (lendata >= SIZE_IPA) {

  03559	83 bc 24 d0 00
	00 00 14	 cmp	 DWORD PTR lendata$17[rsp], 20
  03561	72 20		 jb	 SHORT $LN209@osa_adapte

; 2334 :                     STORE_FW(ipa->ipae,grp->ipae4);

  03563	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  03568	8b 88 1c 06 00
	00		 mov	 ecx, DWORD PTR [rax+1564]
  0356e	e8 00 00 00 00	 call	 _byteswap_ulong
  03573	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  03578	48 83 c1 10	 add	 rcx, 16
  0357c	8b d0		 mov	 edx, eax
  0357e	e8 00 00 00 00	 call	 store_fw_noswap
$LN209@osa_adapte:

; 2335 :                 }

  03583	e9 e6 00 00 00	 jmp	 $LN208@osa_adapte
$LN207@osa_adapte:

; 2336 :             } else if (proto == IPA_PROTO_IPV6) {

  03588	0f b7 44 24 74	 movzx	 eax, WORD PTR proto$3[rsp]
  0358d	83 f8 06	 cmp	 eax, 6
  03590	75 6f		 jne	 SHORT $LN210@osa_adapte

; 2337 :                 STORE_FW(ipa->ipas,grp->ipas6);

  03592	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  03597	8b 88 14 06 00
	00		 mov	 ecx, DWORD PTR [rax+1556]
  0359d	e8 00 00 00 00	 call	 _byteswap_ulong
  035a2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  035a7	48 83 c1 0c	 add	 rcx, 12
  035ab	8b d0		 mov	 edx, eax
  035ad	e8 00 00 00 00	 call	 store_fw_noswap

; 2338 :                 grp->ipae6 &= grp->ipas6;

  035b2	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  035b7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  035bc	8b 89 14 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1556]
  035c2	8b 80 20 06 00
	00		 mov	 eax, DWORD PTR [rax+1568]
  035c8	23 c1		 and	 eax, ecx
  035ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  035cf	89 81 20 06 00
	00		 mov	 DWORD PTR [rcx+1568], eax

; 2339 :                 if (lendata >= SIZE_IPA) {

  035d5	83 bc 24 d0 00
	00 00 14	 cmp	 DWORD PTR lendata$17[rsp], 20
  035dd	72 20		 jb	 SHORT $LN212@osa_adapte

; 2340 :                     STORE_FW(ipa->ipae,grp->ipae6);

  035df	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  035e4	8b 88 20 06 00
	00		 mov	 ecx, DWORD PTR [rax+1568]
  035ea	e8 00 00 00 00	 call	 _byteswap_ulong
  035ef	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  035f4	48 83 c1 10	 add	 rcx, 16
  035f8	8b d0		 mov	 edx, eax
  035fa	e8 00 00 00 00	 call	 store_fw_noswap
$LN212@osa_adapte:

; 2341 :                 }
; 2342 :             } else {

  035ff	eb 6d		 jmp	 SHORT $LN211@osa_adapte
$LN210@osa_adapte:

; 2343 :                 STORE_FW(ipa->ipas,grp->ipas4);

  03601	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  03606	8b 88 10 06 00
	00		 mov	 ecx, DWORD PTR [rax+1552]
  0360c	e8 00 00 00 00	 call	 _byteswap_ulong
  03611	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  03616	48 83 c1 0c	 add	 rcx, 12
  0361a	8b d0		 mov	 edx, eax
  0361c	e8 00 00 00 00	 call	 store_fw_noswap

; 2344 :                 grp->ipae0 &= grp->ipas4;

  03621	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  03626	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0362b	8b 89 10 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1552]
  03631	8b 80 18 06 00
	00		 mov	 eax, DWORD PTR [rax+1560]
  03637	23 c1		 and	 eax, ecx
  03639	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  0363e	89 81 18 06 00
	00		 mov	 DWORD PTR [rcx+1560], eax

; 2345 :                 if (lendata >= SIZE_IPA) {

  03644	83 bc 24 d0 00
	00 00 14	 cmp	 DWORD PTR lendata$17[rsp], 20
  0364c	72 20		 jb	 SHORT $LN213@osa_adapte

; 2346 :                     STORE_FW(ipa->ipae,grp->ipae0);

  0364e	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  03653	8b 88 18 06 00
	00		 mov	 ecx, DWORD PTR [rax+1560]
  03659	e8 00 00 00 00	 call	 _byteswap_ulong
  0365e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ipa$1[rsp]
  03663	48 83 c1 10	 add	 rcx, 16
  03667	8b d0		 mov	 edx, eax
  03669	e8 00 00 00 00	 call	 store_fw_noswap
$LN213@osa_adapte:
$LN211@osa_adapte:
$LN208@osa_adapte:

; 2347 :                 }
; 2348 :             }
; 2349 : 
; 2350 :             // Add response buffer to chain.
; 2351 :             add_buffer_to_chain( &grp->idx, rsp_bhr );

  0366e	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$[rsp]
  03673	48 83 c0 18	 add	 rax, 24
  03677	48 8b 54 24 78	 mov	 rdx, QWORD PTR rsp_bhr$[rsp]
  0367c	48 8b c8	 mov	 rcx, rax
  0367f	e8 00 00 00 00	 call	 add_buffer_to_chain

; 2352 :             signal_idx_event( grp );

  03684	48 8b 4c 24 60	 mov	 rcx, QWORD PTR grp$[rsp]
  03689	e8 00 00 00 00	 call	 signal_idx_event

; 2353 :         }
; 2354 :         /* end case RRH_TYPE_IPA: */
; 2355 :         break;

  0368e	e9 0b 01 00 00	 jmp	 $LN2@osa_adapte
$LN214@osa_adapte:

; 2356 : 
; 2357 :     default:
; 2358 :         // HHC03991 "%1d:%04X %s: %s"
; 2359 :         WRMSG( HHC03991, "W", LCSS_DEVNUM, dev->typname,

  03693	48 83 bc 24 10
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0369c	74 15		 je	 SHORT $LN232@osa_adapte
  0369e	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  036a6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  036aa	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv2049[rsp], eax
  036b1	eb 0b		 jmp	 SHORT $LN233@osa_adapte
$LN232@osa_adapte:
  036b3	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv2049[rsp], 0
$LN233@osa_adapte:
  036be	48 83 bc 24 10
	04 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  036c7	74 17		 je	 SHORT $LN234@osa_adapte
  036c9	48 8b 84 24 10
	04 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  036d1	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  036d5	d1 f8		 sar	 eax, 1
  036d7	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv2055[rsp], eax
  036de	eb 0b		 jmp	 SHORT $LN235@osa_adapte
$LN234@osa_adapte:
  036e0	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv2055[rsp], 0
$LN235@osa_adapte:
  036eb	b9 01 00 00 00	 mov	 ecx, 1
  036f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  036f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172500
  036fd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  03702	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0370a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0370e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  03713	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv2049[rsp]
  0371a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0371e	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv2055[rsp]
  03725	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  03729	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172501
  03730	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  03735	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172502
  0373c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  03741	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  03746	41 b9 03 00 00
	00		 mov	 r9d, 3
  0374c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG172503
  03753	ba 38 09 00 00	 mov	 edx, 2360		; 00000938H
  03758	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG172504
  0375f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2360 :                "Unknown RHH_TYPE_xxx" );
; 2361 :         net_data_trace( dev, (BYTE*)req_th, datalen, FROM_GUEST, 'I', "???", 0 );

  03765	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR [rsp+48], 0
  0376d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG172505
  03774	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  03779	c6 44 24 20 49	 mov	 BYTE PTR [rsp+32], 73	; 00000049H
  0377e	41 b1 3c	 mov	 r9b, 60			; 0000003cH
  03781	44 8b 84 24 20
	04 00 00	 mov	 r8d, DWORD PTR datalen$[rsp]
  03789	48 8b 94 24 18
	04 00 00	 mov	 rdx, QWORD PTR req_th$[rsp]
  03791	48 8b 8c 24 10
	04 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  03799	e8 00 00 00 00	 call	 net_data_trace
$LN2@osa_adapte:

; 2362 : 
; 2363 :     }
; 2364 :     /* end switch(req_rrh->type) */
; 2365 : }

  0379e	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  037a6	48 33 cc	 xor	 rcx, rsp
  037a9	e8 00 00 00 00	 call	 __security_check_cookie
  037ae	48 81 c4 f8 03
	00 00		 add	 rsp, 1016		; 000003f8H
  037b5	5f		 pop	 rdi
  037b6	5e		 pop	 rsi
  037b7	c3		 ret	 0
$LN239@osa_adapte:
  037b8	00 00 00 00	 DD	 $LN80@osa_adapte
  037bc	00 00 00 00	 DD	 $LN84@osa_adapte
  037c0	00 00 00 00	 DD	 $LN88@osa_adapte
  037c4	00 00 00 00	 DD	 $LN104@osa_adapte
  037c8	00 00 00 00	 DD	 $LN107@osa_adapte
  037cc	00 00 00 00	 DD	 $LN112@osa_adapte
  037d0	00 00 00 00	 DD	 $LN115@osa_adapte
  037d4	00 00 00 00	 DD	 $LN116@osa_adapte
  037d8	00 00 00 00	 DD	 $LN117@osa_adapte
  037dc	00 00 00 00	 DD	 $LN146@osa_adapte
  037e0	00 00 00 00	 DD	 $LN147@osa_adapte
  037e4	00 00 00 00	 DD	 $LN171@osa_adapte
  037e8	00 00 00 00	 DD	 $LN172@osa_adapte
  037ec	00 00 00 00	 DD	 $LN173@osa_adapte
  037f0	00 00 00 00	 DD	 $LN174@osa_adapte
  037f4	00 00 00 00	 DD	 $LN185@osa_adapte
  037f8	00 00 00 00	 DD	 $LN202@osa_adapte
  037fc	00 00 00 00	 DD	 $LN203@osa_adapte
  03800	00 00 00 00	 DD	 $LN204@osa_adapte
$LN238@osa_adapte:
  03804	00		 DB	 0
  03805	01		 DB	 1
  03806	12		 DB	 18
  03807	12		 DB	 18
  03808	12		 DB	 18
  03809	12		 DB	 18
  0380a	12		 DB	 18
  0380b	12		 DB	 18
  0380c	12		 DB	 18
  0380d	12		 DB	 18
  0380e	12		 DB	 18
  0380f	12		 DB	 18
  03810	12		 DB	 18
  03811	12		 DB	 18
  03812	12		 DB	 18
  03813	12		 DB	 18
  03814	12		 DB	 18
  03815	12		 DB	 18
  03816	12		 DB	 18
  03817	12		 DB	 18
  03818	12		 DB	 18
  03819	12		 DB	 18
  0381a	12		 DB	 18
  0381b	12		 DB	 18
  0381c	12		 DB	 18
  0381d	12		 DB	 18
  0381e	12		 DB	 18
  0381f	12		 DB	 18
  03820	12		 DB	 18
  03821	12		 DB	 18
  03822	12		 DB	 18
  03823	12		 DB	 18
  03824	02		 DB	 2
  03825	03		 DB	 3
  03826	04		 DB	 4
  03827	05		 DB	 5
  03828	06		 DB	 6
  03829	07		 DB	 7
  0382a	12		 DB	 18
  0382b	12		 DB	 18
  0382c	12		 DB	 18
  0382d	12		 DB	 18
  0382e	12		 DB	 18
  0382f	12		 DB	 18
  03830	12		 DB	 18
  03831	12		 DB	 18
  03832	12		 DB	 18
  03833	12		 DB	 18
  03834	12		 DB	 18
  03835	12		 DB	 18
  03836	12		 DB	 18
  03837	12		 DB	 18
  03838	12		 DB	 18
  03839	12		 DB	 18
  0383a	12		 DB	 18
  0383b	12		 DB	 18
  0383c	12		 DB	 18
  0383d	12		 DB	 18
  0383e	12		 DB	 18
  0383f	12		 DB	 18
  03840	12		 DB	 18
  03841	12		 DB	 18
  03842	12		 DB	 18
  03843	12		 DB	 18
  03844	12		 DB	 18
  03845	12		 DB	 18
  03846	12		 DB	 18
  03847	12		 DB	 18
  03848	12		 DB	 18
  03849	12		 DB	 18
  0384a	12		 DB	 18
  0384b	12		 DB	 18
  0384c	12		 DB	 18
  0384d	12		 DB	 18
  0384e	12		 DB	 18
  0384f	12		 DB	 18
  03850	12		 DB	 18
  03851	12		 DB	 18
  03852	12		 DB	 18
  03853	12		 DB	 18
  03854	12		 DB	 18
  03855	12		 DB	 18
  03856	12		 DB	 18
  03857	12		 DB	 18
  03858	12		 DB	 18
  03859	12		 DB	 18
  0385a	12		 DB	 18
  0385b	12		 DB	 18
  0385c	12		 DB	 18
  0385d	12		 DB	 18
  0385e	12		 DB	 18
  0385f	12		 DB	 18
  03860	12		 DB	 18
  03861	12		 DB	 18
  03862	12		 DB	 18
  03863	12		 DB	 18
  03864	12		 DB	 18
  03865	12		 DB	 18
  03866	12		 DB	 18
  03867	12		 DB	 18
  03868	12		 DB	 18
  03869	12		 DB	 18
  0386a	12		 DB	 18
  0386b	12		 DB	 18
  0386c	12		 DB	 18
  0386d	12		 DB	 18
  0386e	12		 DB	 18
  0386f	12		 DB	 18
  03870	12		 DB	 18
  03871	12		 DB	 18
  03872	12		 DB	 18
  03873	12		 DB	 18
  03874	12		 DB	 18
  03875	12		 DB	 18
  03876	12		 DB	 18
  03877	12		 DB	 18
  03878	12		 DB	 18
  03879	12		 DB	 18
  0387a	12		 DB	 18
  0387b	12		 DB	 18
  0387c	12		 DB	 18
  0387d	12		 DB	 18
  0387e	12		 DB	 18
  0387f	12		 DB	 18
  03880	12		 DB	 18
  03881	12		 DB	 18
  03882	12		 DB	 18
  03883	12		 DB	 18
  03884	12		 DB	 18
  03885	12		 DB	 18
  03886	12		 DB	 18
  03887	12		 DB	 18
  03888	12		 DB	 18
  03889	12		 DB	 18
  0388a	12		 DB	 18
  0388b	12		 DB	 18
  0388c	12		 DB	 18
  0388d	12		 DB	 18
  0388e	12		 DB	 18
  0388f	12		 DB	 18
  03890	12		 DB	 18
  03891	12		 DB	 18
  03892	12		 DB	 18
  03893	12		 DB	 18
  03894	12		 DB	 18
  03895	12		 DB	 18
  03896	12		 DB	 18
  03897	12		 DB	 18
  03898	12		 DB	 18
  03899	12		 DB	 18
  0389a	12		 DB	 18
  0389b	12		 DB	 18
  0389c	12		 DB	 18
  0389d	12		 DB	 18
  0389e	12		 DB	 18
  0389f	12		 DB	 18
  038a0	12		 DB	 18
  038a1	12		 DB	 18
  038a2	12		 DB	 18
  038a3	12		 DB	 18
  038a4	12		 DB	 18
  038a5	12		 DB	 18
  038a6	12		 DB	 18
  038a7	12		 DB	 18
  038a8	12		 DB	 18
  038a9	12		 DB	 18
  038aa	12		 DB	 18
  038ab	12		 DB	 18
  038ac	12		 DB	 18
  038ad	12		 DB	 18
  038ae	12		 DB	 18
  038af	12		 DB	 18
  038b0	12		 DB	 18
  038b1	12		 DB	 18
  038b2	12		 DB	 18
  038b3	12		 DB	 18
  038b4	08		 DB	 8
  038b5	09		 DB	 9
  038b6	0a		 DB	 10
  038b7	0b		 DB	 11
  038b8	0c		 DB	 12
  038b9	0d		 DB	 13
  038ba	0e		 DB	 14
  038bb	0f		 DB	 15
  038bc	10		 DB	 16
  038bd	12		 DB	 18
  038be	12		 DB	 18
  038bf	12		 DB	 18
  038c0	12		 DB	 18
  038c1	12		 DB	 18
  038c2	12		 DB	 18
  038c3	12		 DB	 18
  038c4	12		 DB	 18
  038c5	12		 DB	 18
  038c6	11		 DB	 17
  038c7	90		 npad	 1
$LN237@osa_adapte:
  038c8	00 00 00 00	 DD	 $LN148@osa_adapte
  038cc	00 00 00 00	 DD	 $LN149@osa_adapte
  038d0	00 00 00 00	 DD	 $LN150@osa_adapte
  038d4	00 00 00 00	 DD	 $LN151@osa_adapte
  038d8	00 00 00 00	 DD	 $LN152@osa_adapte
  038dc	00 00 00 00	 DD	 $LN153@osa_adapte
  038e0	00 00 00 00	 DD	 $LN155@osa_adapte
  038e4	00 00 00 00	 DD	 $LN154@osa_adapte
$LN236@osa_adapte:
  038e8	00 00 00 00	 DD	 $LN163@osa_adapte
  038ec	00 00 00 00	 DD	 $LN164@osa_adapte
  038f0	00 00 00 00	 DD	 $LN165@osa_adapte
  038f4	00 00 00 00	 DD	 $LN166@osa_adapte
  038f8	00 00 00 00	 DD	 $LN167@osa_adapte
  038fc	00 00 00 00	 DD	 $LN168@osa_adapte
  03900	00 00 00 00	 DD	 $LN170@osa_adapte
  03904	00 00 00 00	 DD	 $LN169@osa_adapte
osa_adapter_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
rc$ = 112
uMTU$1 = 116
i$ = 120
ttmtu$2 = 128
tv93 = 136
tv200 = 140
tv288 = 144
tv294 = 148
tv161 = 152
tv165 = 156
tv154 = 160
tv194 = 168
tv156 = 176
tv249 = 184
buf$ = 192
buf$3 = 256
__$ArrayPad$ = 320
dev$ = 352
grp$ = 360
qeth_create_interface PROC

; 1113 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1114 :     int i, rc;
; 1115 :     char buf[64];
; 1116 : 
; 1117 :     /* We should only ever be called ONCE */
; 1118 :     if (grp->ttfd >= 0)

  00023	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0002b	83 b8 f8 05 00
	00 00		 cmp	 DWORD PTR [rax+1528], 0
  00032	0f 8c 9f 00 00
	00		 jl	 $LN23@qeth_creat

; 1119 :     {
; 1120 :         DBGTRC( dev, "ERROR: TUNTAP Interface already exists!" );

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171900
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0004c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171901
  00053	ba 60 04 00 00	 mov	 edx, 1120		; 00000460H
  00058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171902
  0005f	e8 00 00 00 00	 call	 dbgtrc
$LN4@qeth_creat:

; 1121 :         ASSERT(0);              /* (Oops!) */

  00064	33 c0		 xor	 eax, eax
  00066	83 f8 01	 cmp	 eax, 1
  00069	74 5c		 je	 SHORT $LN24@qeth_creat
$LN7@qeth_creat:
  0006b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171904
  00072	41 b8 61 04 00
	00		 mov	 r8d, 1121		; 00000461H
  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171905
  0007f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171906
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00092	85 c0		 test	 eax, eax
  00094	74 20		 je	 SHORT $LN25@qeth_creat
  00096	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171908
  0009d	41 b8 61 04 00
	00		 mov	 r8d, 1121		; 00000461H
  000a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171909
  000aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171910
  000b1	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@qeth_creat:
  000b6	33 c0		 xor	 eax, eax
  000b8	85 c0		 test	 eax, eax
  000ba	75 af		 jne	 SHORT $LN7@qeth_creat
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c2	85 c0		 test	 eax, eax
  000c4	74 01		 je	 SHORT $LN26@qeth_creat
  000c6	cc		 int	 3
$LN26@qeth_creat:
$LN24@qeth_creat:
  000c7	33 c0		 xor	 eax, eax
  000c9	85 c0		 test	 eax, eax
  000cb	75 97		 jne	 SHORT $LN4@qeth_creat

; 1122 :         return -1;              /* Return failure */

  000cd	b8 ff ff ff ff	 mov	 eax, -1
  000d2	e9 f2 09 00 00	 jmp	 $LN1@qeth_creat
$LN23@qeth_creat:

; 1123 :     }
; 1124 : 
; 1125 :     /* Create the new interface by opening the TUNTAP device */
; 1126 :     if ((rc = TUNTAP_CreateInterface
; 1127 :     (
; 1128 :         grp->ttdev,
; 1129 :         0
; 1130 :             | IFF_NO_PI
; 1131 :             | IFF_OSOCK
; 1132 :             | (grp->l3 ? IFF_TUN : IFF_TAP)
; 1133 :         ,
; 1134 :         &grp->ttfd,
; 1135 :         grp->ttifname
; 1136 : 
; 1137 :     )) != 0)

  000d7	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  000df	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  000e6	74 0d		 je	 SHORT $LN49@qeth_creat
  000e8	c7 84 24 88 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv93[rsp], 1
  000f3	eb 0b		 jmp	 SHORT $LN50@qeth_creat
$LN49@qeth_creat:
  000f5	c7 84 24 88 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv93[rsp], 2
$LN50@qeth_creat:
  00100	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00108	48 83 c0 60	 add	 rax, 96			; 00000060H
  0010c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00114	48 81 c1 f8 05
	00 00		 add	 rcx, 1528		; 000005f8H
  0011b	8b 94 24 88 00
	00 00		 mov	 edx, DWORD PTR tv93[rsp]
  00122	81 ca 00 10 00
	08		 or	 edx, 134221824		; 08001000H
  00128	4c 8b c8	 mov	 r9, rax
  0012b	4c 8b c1	 mov	 r8, rcx
  0012e	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00136	48 8b 48 58	 mov	 rcx, QWORD PTR [rax+88]
  0013a	e8 00 00 00 00	 call	 TUNTAP_CreateInterface
  0013f	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00143	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00148	74 56		 je	 SHORT $LN27@qeth_creat

; 1138 :         return QERRMSG( dev, grp, errno,

  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00150	c7 44 24 38 73
	04 00 00	 mov	 DWORD PTR [rsp+56], 1139 ; 00000473H
  00158	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171913
  0015f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171914
  0016b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171915
  00177	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0017c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171916
  00183	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00186	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  0018e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00196	e8 00 00 00 00	 call	 qeth_errnum_msg
  0019b	e9 29 09 00 00	 jmp	 $LN1@qeth_creat
$LN27@qeth_creat:

; 1139 :             "E", "TUNTAP_CreateInterface() failed" );
; 1140 : 
; 1141 :     /* Update DEVBLK file descriptors */
; 1142 :     for (i=0; i < dev->group->acount; i++)

  001a0	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001a8	eb 0a		 jmp	 SHORT $LN10@qeth_creat
$LN8@qeth_creat:
  001aa	8b 44 24 78	 mov	 eax, DWORD PTR i$[rsp]
  001ae	ff c0		 inc	 eax
  001b0	89 44 24 78	 mov	 DWORD PTR i$[rsp], eax
$LN10@qeth_creat:
  001b4	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001bc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001c0	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001c3	39 44 24 78	 cmp	 DWORD PTR i$[rsp], eax
  001c7	7d 2c		 jge	 SHORT $LN9@qeth_creat

; 1143 :         dev->group->memdev[i]->fd = grp->ttfd;

  001c9	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d1	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001d5	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR i$[rsp]
  001da	48 8b 44 c8 10	 mov	 rax, QWORD PTR [rax+rcx*8+16]
  001df	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  001e7	8b 89 f8 05 00
	00		 mov	 ecx, DWORD PTR [rcx+1528]
  001ed	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
  001f3	eb b5		 jmp	 SHORT $LN8@qeth_creat
$LN9@qeth_creat:

; 1144 : 
; 1145 :     // HHC00901 "%1d:%04X %s: interface %s, type %s opened"
; 1146 :     WRMSG( HHC00901, "I", SSID_TO_LCSS(dev->ssid),

  001f5	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  001fd	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00204	74 11		 je	 SHORT $LN51@qeth_creat
  00206	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171917
  0020d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv154[rsp], rax
  00215	eb 0f		 jmp	 SHORT $LN52@qeth_creat
$LN51@qeth_creat:
  00217	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171918
  0021e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv154[rsp], rax
$LN52@qeth_creat:
  00226	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0022e	48 83 c0 60	 add	 rax, 96			; 00000060H
  00232	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv156[rsp], rax
  0023a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00242	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00246	89 8c 24 98 00
	00 00		 mov	 DWORD PTR tv161[rsp], ecx
  0024d	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00255	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00259	d1 fa		 sar	 edx, 1
  0025b	89 94 24 9c 00
	00 00		 mov	 DWORD PTR tv165[rsp], edx
  00262	b9 01 00 00 00	 mov	 ecx, 1
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv154[rsp]
  00275	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0027a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv156[rsp]
  00282	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00287	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028f	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00293	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00298	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv161[rsp]
  0029f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a3	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv165[rsp]
  002aa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171919
  002b5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171920
  002c1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171921
  002d8	ba 7e 04 00 00	 mov	 edx, 1150		; 0000047eH
  002dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171922
  002e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1147 :                          dev->devnum,
; 1148 :                          dev->typname,
; 1149 :                          grp->ttifname,
; 1150 :                          (grp->l3 ? "TUN" : "TAP"));
; 1151 : 
; 1152 :     /* Set NON-Blocking mode by disabling Blocking mode */
; 1153 :     if ((rc = socket_set_blocking_mode(grp->ttfd,0)) != 0)

  002ea	33 d2		 xor	 edx, edx
  002ec	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  002f4	8b 88 f8 05 00
	00		 mov	 ecx, DWORD PTR [rax+1528]
  002fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode
  00300	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00304	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00309	74 4d		 je	 SHORT $LN28@qeth_creat

; 1154 :         QERRMSG( dev, grp, rc,

  0030b	c7 44 24 38 83
	04 00 00	 mov	 DWORD PTR [rsp+56], 1155 ; 00000483H
  00313	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171924
  0031a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0031f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171925
  00326	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0032b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171926
  00332	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00337	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171927
  0033e	44 8b 44 24 70	 mov	 r8d, DWORD PTR rc$[rsp]
  00343	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  0034b	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00353	e8 00 00 00 00	 call	 qeth_errnum_msg
$LN28@qeth_creat:

; 1155 :             "W", "socket_set_blocking_mode() failed" );
; 1156 : 
; 1157 :     /* Set the interface's MTU size, if possible */
; 1158 :     {
; 1159 :         /* Save original requested value, if any */
; 1160 :         char*  ttmtu  = grp->ttmtu ? strdup( grp->ttmtu ) : NULL;

  00358	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00360	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00365	74 1c		 je	 SHORT $LN53@qeth_creat
  00367	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0036f	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00373	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00379	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv194[rsp], rax
  00381	eb 0c		 jmp	 SHORT $LN54@qeth_creat
$LN53@qeth_creat:
  00383	48 c7 84 24 a8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv194[rsp], 0
$LN54@qeth_creat:
  0038f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv194[rsp]
  00397	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ttmtu$2[rsp], rax

; 1161 :         U16    uMTU   = ttmtu ? (U16) atoi( ttmtu ) : 0;

  0039f	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR ttmtu$2[rsp], 0
  003a8	74 1a		 je	 SHORT $LN55@qeth_creat
  003aa	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ttmtu$2[rsp]
  003b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  003b8	0f b7 c0	 movzx	 eax, ax
  003bb	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv200[rsp], eax
  003c2	eb 0b		 jmp	 SHORT $LN56@qeth_creat
$LN55@qeth_creat:
  003c4	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv200[rsp], 0
$LN56@qeth_creat:
  003cf	0f b7 84 24 8c
	00 00 00	 movzx	 eax, WORD PTR tv200[rsp]
  003d7	66 89 44 24 74	 mov	 WORD PTR uMTU$1[rsp], ax

; 1162 : 
; 1163 :         /* Retrieve the interface's actual MTU */
; 1164 :         free( grp->ttmtu );

  003dc	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  003e4	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  003e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1165 :         grp->ttmtu = NULL;

  003ee	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  003f6	48 c7 40 78 00
	00 00 00	 mov	 QWORD PTR [rax+120], 0

; 1166 :         grp->uMTU  = 0;

  003fe	33 c0		 xor	 eax, eax
  00400	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00408	66 89 81 2e 06
	00 00		 mov	 WORD PTR [rcx+1582], ax

; 1167 :         InitMTU( dev, grp );  /* get interface's mtu value */

  0040f	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00417	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0041f	e8 00 00 00 00	 call	 InitMTU
$LN13@qeth_creat:

; 1168 :         ASSERT( grp->ttmtu );

  00424	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0042c	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  00431	75 5c		 jne	 SHORT $LN29@qeth_creat
$LN16@qeth_creat:
  00433	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171929
  0043a	41 b8 90 04 00
	00		 mov	 r8d, 1168		; 00000490H
  00440	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171930
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171931
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00454	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0045a	85 c0		 test	 eax, eax
  0045c	74 20		 je	 SHORT $LN30@qeth_creat
  0045e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171933
  00465	41 b8 90 04 00
	00		 mov	 r8d, 1168		; 00000490H
  0046b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171934
  00472	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171935
  00479	e8 00 00 00 00	 call	 DebuggerTrace
$LN30@qeth_creat:
  0047e	33 c0		 xor	 eax, eax
  00480	85 c0		 test	 eax, eax
  00482	75 af		 jne	 SHORT $LN16@qeth_creat
  00484	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0048a	85 c0		 test	 eax, eax
  0048c	74 01		 je	 SHORT $LN31@qeth_creat
  0048e	cc		 int	 3
$LN31@qeth_creat:
$LN29@qeth_creat:
  0048f	33 c0		 xor	 eax, eax
  00491	85 c0		 test	 eax, eax
  00493	75 8f		 jne	 SHORT $LN13@qeth_creat
$LN19@qeth_creat:

; 1169 :         ASSERT( grp->uMTU  );

  00495	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0049d	0f b7 80 2e 06
	00 00		 movzx	 eax, WORD PTR [rax+1582]
  004a4	85 c0		 test	 eax, eax
  004a6	75 5c		 jne	 SHORT $LN32@qeth_creat
$LN22@qeth_creat:
  004a8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171938
  004af	41 b8 91 04 00
	00		 mov	 r8d, 1169		; 00000491H
  004b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171939
  004bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171940
  004c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004cf	85 c0		 test	 eax, eax
  004d1	74 20		 je	 SHORT $LN33@qeth_creat
  004d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171942
  004da	41 b8 91 04 00
	00		 mov	 r8d, 1169		; 00000491H
  004e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171943
  004e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171944
  004ee	e8 00 00 00 00	 call	 DebuggerTrace
$LN33@qeth_creat:
  004f3	33 c0		 xor	 eax, eax
  004f5	85 c0		 test	 eax, eax
  004f7	75 af		 jne	 SHORT $LN22@qeth_creat
  004f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004ff	85 c0		 test	 eax, eax
  00501	74 01		 je	 SHORT $LN34@qeth_creat
  00503	cc		 int	 3
$LN34@qeth_creat:
$LN32@qeth_creat:
  00504	33 c0		 xor	 eax, eax
  00506	85 c0		 test	 eax, eax
  00508	75 8b		 jne	 SHORT $LN19@qeth_creat

; 1170 : 
; 1171 :         /* Decrease their requested MTU if neccessary */
; 1172 :         if (ttmtu)

  0050a	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR ttmtu$2[rsp], 0
  00513	0f 84 1f 02 00
	00		 je	 $LN35@qeth_creat

; 1173 :         {
; 1174 :             if (uMTU > grp->uMTU)

  00519	0f b7 44 24 74	 movzx	 eax, WORD PTR uMTU$1[rsp]
  0051e	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00526	0f b7 89 2e 06
	00 00		 movzx	 ecx, WORD PTR [rcx+1582]
  0052d	3b c1		 cmp	 eax, ecx
  0052f	0f 8e 21 01 00
	00		 jle	 $LN36@qeth_creat

; 1175 :             {
; 1176 :                 // "%1d:%04X %s: %s: Requested MTU %s too large; decreasing to %s bytes"
; 1177 :                 WRMSG( HHC03809, "W", LCSS_DEVNUM,

  00535	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0053e	74 15		 je	 SHORT $LN57@qeth_creat
  00540	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00548	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0054c	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv288[rsp], eax
  00553	eb 0b		 jmp	 SHORT $LN58@qeth_creat
$LN57@qeth_creat:
  00555	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv288[rsp], 0
$LN58@qeth_creat:
  00560	48 83 bc 24 60
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00569	74 17		 je	 SHORT $LN59@qeth_creat
  0056b	48 8b 84 24 60
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00573	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00577	d1 f8		 sar	 eax, 1
  00579	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv294[rsp], eax
  00580	eb 0b		 jmp	 SHORT $LN60@qeth_creat
$LN59@qeth_creat:
  00582	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv294[rsp], 0
$LN60@qeth_creat:
  0058d	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00595	48 83 c0 60	 add	 rax, 96			; 00000060H
  00599	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv249[rsp], rax
  005a1	b9 01 00 00 00	 mov	 ecx, 1
  005a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005ac	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  005b4	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  005b8	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  005bd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ttmtu$2[rsp]
  005c5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005ca	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv249[rsp]
  005d2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005d7	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005df	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  005e3	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005e8	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv288[rsp]
  005ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005f3	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv294[rsp]
  005fa	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171949
  00605	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0060a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171950
  00611	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00616	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0061b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00621	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171951
  00628	ba 9a 04 00 00	 mov	 edx, 1178		; 0000049aH
  0062d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171952
  00634	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1178 :                     dev->typname, grp->ttifname, ttmtu, grp->ttmtu );
; 1179 :                 free( ttmtu );

  0063a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ttmtu$2[rsp]
  00642	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1180 :                 ttmtu = NULL;

  00648	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ttmtu$2[rsp], 0

; 1181 :             }

  00654	eb 3a		 jmp	 SHORT $LN37@qeth_creat
$LN36@qeth_creat:

; 1182 :             else /* Use their requested value */
; 1183 :             {
; 1184 :                 free( grp->ttmtu );

  00656	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0065e	48 8b 48 78	 mov	 rcx, QWORD PTR [rax+120]
  00662	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 1185 :                 grp->ttmtu = ttmtu;

  00668	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00670	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ttmtu$2[rsp]
  00678	48 89 48 78	 mov	 QWORD PTR [rax+120], rcx

; 1186 :                 grp->uMTU  = uMTU;

  0067c	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00684	0f b7 4c 24 74	 movzx	 ecx, WORD PTR uMTU$1[rsp]
  00689	66 89 88 2e 06
	00 00		 mov	 WORD PTR [rax+1582], cx
$LN37@qeth_creat:

; 1187 :             }
; 1188 : 
; 1189 :             MSGBUF( buf, "TUNTAP_SetMTU(%s) failed", grp->ttmtu );

  00690	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00698	4c 8b 48 78	 mov	 r9, QWORD PTR [rax+120]
  0069c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171953
  006a3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  006a8	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  006b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1190 :             if ((rc = TUNTAP_SetMTU( grp->ttifname, grp->ttmtu )) != 0)

  006b6	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  006be	48 83 c0 60	 add	 rax, 96			; 00000060H
  006c2	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  006ca	48 8b 51 78	 mov	 rdx, QWORD PTR [rcx+120]
  006ce	48 8b c8	 mov	 rcx, rax
  006d1	e8 00 00 00 00	 call	 TUNTAP_SetMTU
  006d6	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  006da	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  006df	74 57		 je	 SHORT $LN38@qeth_creat

; 1191 :                 return QERRMSG( dev, grp, errno, "E", buf );

  006e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  006e7	c7 44 24 38 a7
	04 00 00	 mov	 DWORD PTR [rsp+56], 1191 ; 000004a7H
  006ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171955
  006f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171956
  00702	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00707	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0070f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00714	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171957
  0071b	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0071e	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00726	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0072e	e8 00 00 00 00	 call	 qeth_errnum_msg
  00733	e9 91 03 00 00	 jmp	 $LN1@qeth_creat
$LN38@qeth_creat:
$LN35@qeth_creat:

; 1192 :         }
; 1193 :     }
; 1194 : 
; 1195 : #if defined( OPTION_TUNTAP_SETMACADDR )
; 1196 :     /* Make sure the interface has a valid MAC address.      */
; 1197 :     /* TUN's of course don't have MAC addresses, only TAP's. */
; 1198 :     if (grp->tthwaddr) {

  00738	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00740	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00745	0f 84 bd 00 00
	00		 je	 $LN39@qeth_creat

; 1199 :         if (!grp->l3)

  0074b	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00753	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  0075a	0f 85 a8 00 00
	00		 jne	 $LN40@qeth_creat

; 1200 :         {
; 1201 :             if ((rc = TUNTAP_SetMACAddr( grp->ttifname, grp->tthwaddr )) != 0)

  00760	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00768	48 83 c0 60	 add	 rax, 96			; 00000060H
  0076c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00774	48 8b 51 70	 mov	 rdx, QWORD PTR [rcx+112]
  00778	48 8b c8	 mov	 rcx, rax
  0077b	e8 00 00 00 00	 call	 TUNTAP_SetMACAddr
  00780	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00784	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00789	74 7d		 je	 SHORT $LN41@qeth_creat

; 1202 :             {
; 1203 :                 MSGBUF( buf, "TUNTAP_SetMACAddr(%s) failed", grp->tthwaddr );

  0078b	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00793	4c 8b 48 70	 mov	 r9, QWORD PTR [rax+112]
  00797	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171961
  0079e	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  007a3	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  007ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1204 :                 return QERRMSG( dev, grp, errno, "E", buf );

  007b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  007b7	c7 44 24 38 b4
	04 00 00	 mov	 DWORD PTR [rsp+56], 1204 ; 000004b4H
  007bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171962
  007c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  007cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171963
  007d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  007d7	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  007df	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007e4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171964
  007eb	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  007ee	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  007f6	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007fe	e8 00 00 00 00	 call	 qeth_errnum_msg
  00803	e9 c1 02 00 00	 jmp	 $LN1@qeth_creat
$LN41@qeth_creat:
$LN40@qeth_creat:
$LN39@qeth_creat:

; 1205 :             }
; 1206 :         }
; 1207 :     }
; 1208 : #endif
; 1209 : 
; 1210 :     /* Make sure the interface has a valid MAC address.      */
; 1211 :     /* TUN's of course don't have MAC addresses, only TAP's, */
; 1212 :     /* but we need to keep up a pretence.                    */
; 1213 :     InitMACAddr( dev, grp );

  00808	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00810	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00818	e8 00 00 00 00	 call	 InitMACAddr

; 1214 : 
; 1215 :     /* If possible, assign an IPv4 address to the guest interface */
; 1216 :     if (1
; 1217 : #if defined( OPTION_W32_CTCI )
; 1218 :         && grp->l3
; 1219 : #endif
; 1220 :         && grp->ttipaddr

  0081d	33 c0		 xor	 eax, eax
  0081f	83 f8 01	 cmp	 eax, 1
  00822	0f 84 dd 00 00
	00		 je	 $LN42@qeth_creat
  00828	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00830	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00837	0f 84 c8 00 00
	00		 je	 $LN42@qeth_creat
  0083d	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00845	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0084d	0f 84 b2 00 00
	00		 je	 $LN42@qeth_creat

; 1221 :     )
; 1222 :     {
; 1223 : #if defined( OPTION_W32_CTCI )
; 1224 :         if ((rc = TUNTAP_SetDestAddr( grp->ttifname,grp->ttipaddr )) != 0)

  00853	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0085b	48 83 c0 60	 add	 rax, 96			; 00000060H
  0085f	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00867	48 8b 91 80 00
	00 00		 mov	 rdx, QWORD PTR [rcx+128]
  0086e	48 8b c8	 mov	 rcx, rax
  00871	e8 00 00 00 00	 call	 TUNTAP_SetDestAddr
  00876	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  0087a	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0087f	0f 84 80 00 00
	00		 je	 $LN43@qeth_creat

; 1225 :         {
; 1226 :             char buf[64];
; 1227 :             MSGBUF( buf, "TUNTAP_SetDestAddr(\"%s\") failed", grp->ttipaddr );

  00885	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0088d	4c 8b 88 80 00
	00 00		 mov	 r9, QWORD PTR [rax+128]
  00894	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171967
  0089b	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  008a0	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  008a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1228 :             return QERRMSG( dev, grp, errno, "E", buf );

  008ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  008b4	c7 44 24 38 cc
	04 00 00	 mov	 DWORD PTR [rsp+56], 1228 ; 000004ccH
  008bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171968
  008c3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171969
  008cf	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008d4	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  008dc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171970
  008e8	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  008eb	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  008f3	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008fb	e8 00 00 00 00	 call	 qeth_errnum_msg
  00900	e9 c4 01 00 00	 jmp	 $LN1@qeth_creat
$LN43@qeth_creat:
$LN42@qeth_creat:

; 1229 :         }
; 1230 : #else /* Linux */
; 1231 :         if ((rc = TUNTAP_SetIPAddr( grp->ttifname, grp->ttipaddr )) != 0)
; 1232 :         {
; 1233 :             char buf[64];
; 1234 :             MSGBUF( buf, "TUNTAP_SetIPAddr(\"%s\") failed", grp->ttipaddr );
; 1235 :             return QERRMSG( dev, grp, errno, "E", buf );
; 1236 :         }
; 1237 : #endif /* CTCI-WIN or Linux */
; 1238 :     }
; 1239 : 
; 1240 :     /* Same thing with the IPv4 subnet mask */
; 1241 : #if defined( OPTION_TUNTAP_SETNETMASK )
; 1242 :     if(
; 1243 : #if defined( OPTION_W32_CTCI )
; 1244 :        grp->l3 &&

  00905	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0090d	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00914	0f 84 c8 00 00
	00		 je	 $LN44@qeth_creat
  0091a	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00922	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  0092a	0f 84 b2 00 00
	00		 je	 $LN44@qeth_creat

; 1245 : #endif
; 1246 :                   grp->ttnetmask)
; 1247 :     {
; 1248 :         if ((rc = TUNTAP_SetNetMask( grp->ttifname, grp->ttnetmask )) != 0)

  00930	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00938	48 83 c0 60	 add	 rax, 96			; 00000060H
  0093c	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00944	48 8b 91 90 00
	00 00		 mov	 rdx, QWORD PTR [rcx+144]
  0094b	48 8b c8	 mov	 rcx, rax
  0094e	e8 00 00 00 00	 call	 TUNTAP_SetNetMask
  00953	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00957	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0095c	0f 84 80 00 00
	00		 je	 $LN45@qeth_creat

; 1249 :         {
; 1250 :             MSGBUF( buf, "TUNTAP_SetNetMask(%s) failed", grp->ttnetmask );

  00962	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0096a	4c 8b 88 90 00
	00 00		 mov	 r9, QWORD PTR [rax+144]
  00971	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171973
  00978	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0097d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00985	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1251 :             return QERRMSG( dev, grp, errno, "E", buf );

  0098b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00991	c7 44 24 38 e3
	04 00 00	 mov	 DWORD PTR [rsp+56], 1251 ; 000004e3H
  00999	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171974
  009a0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171975
  009ac	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009b1	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  009b9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171976
  009c5	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  009c8	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  009d0	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009d8	e8 00 00 00 00	 call	 qeth_errnum_msg
  009dd	e9 e7 00 00 00	 jmp	 $LN1@qeth_creat
$LN45@qeth_creat:
$LN44@qeth_creat:

; 1252 :         }
; 1253 :     }
; 1254 : #endif /* defined( OPTION_TUNTAP_SETNETMASK ) */
; 1255 : 
; 1256 :     /* Assign it an IPv6 address too, if possible */
; 1257 : #if defined( ENABLE_IPV6 )
; 1258 :     if(
; 1259 : #if defined( OPTION_W32_CTCI )
; 1260 :        grp->l3 &&

  009e2	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  009ea	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  009f1	0f 84 d0 00 00
	00		 je	 $LN46@qeth_creat
  009f7	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  009ff	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  00a07	0f 84 ba 00 00
	00		 je	 $LN46@qeth_creat

; 1261 : #endif
; 1262 :                   grp->ttipaddr6)
; 1263 :     {
; 1264 :         if((rc = TUNTAP_SetIPAddr6(grp->ttifname, grp->ttipaddr6, grp->ttpfxlen6)) != 0)

  00a0d	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00a15	48 83 c0 60	 add	 rax, 96			; 00000060H
  00a19	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00a21	4c 8b 81 a0 00
	00 00		 mov	 r8, QWORD PTR [rcx+160]
  00a28	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00a30	48 8b 91 98 00
	00 00		 mov	 rdx, QWORD PTR [rcx+152]
  00a37	48 8b c8	 mov	 rcx, rax
  00a3a	e8 00 00 00 00	 call	 TUNTAP_SetIPAddr6
  00a3f	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00a43	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00a48	74 7d		 je	 SHORT $LN47@qeth_creat

; 1265 :         {
; 1266 :             MSGBUF( buf, "TUNTAP_SetIPAddr6(%s) failed", grp->ttipaddr6 );

  00a4a	48 8b 84 24 68
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00a52	4c 8b 88 98 00
	00 00		 mov	 r9, QWORD PTR [rax+152]
  00a59	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171979
  00a60	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00a65	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00a6d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1267 :             return QERRMSG( dev, grp, errno, "E", buf );

  00a73	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00a79	c7 44 24 38 f3
	04 00 00	 mov	 DWORD PTR [rsp+56], 1267 ; 000004f3H
  00a81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171980
  00a88	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a8d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171981
  00a94	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a99	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00aa1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00aa6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171982
  00aad	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  00ab0	48 8b 94 24 68
	01 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  00ab8	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ac0	e8 00 00 00 00	 call	 qeth_errnum_msg
  00ac5	eb 02		 jmp	 SHORT $LN1@qeth_creat
$LN47@qeth_creat:
$LN46@qeth_creat:

; 1268 :         }
; 1269 :     }
; 1270 : #endif /* defined( ENABLE_IPV6 ) */
; 1271 : 
; 1272 :     return 0;

  00ac7	33 c0		 xor	 eax, eax
$LN1@qeth_creat:

; 1273 : }

  00ac9	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00ad1	48 33 cc	 xor	 rcx, rsp
  00ad4	e8 00 00 00 00	 call	 __security_check_cookie
  00ad9	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  00ae0	c3		 ret	 0
qeth_create_interface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv68 = 64
tv72 = 68
rc$1 = 72
flags$2 = 76
dev$ = 96
grp$ = 104
qeth_disable_interface PROC

; 1073 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1074 :     if (!grp->enabled)

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00013	83 b8 dc 05 00
	00 00		 cmp	 DWORD PTR [rax+1500], 0
  0001a	75 07		 jne	 SHORT $LN2@qeth_disab

; 1075 :         return 0;

  0001c	33 c0		 xor	 eax, eax
  0001e	e9 e2 00 00 00	 jmp	 $LN1@qeth_disab
$LN2@qeth_disab:

; 1076 : 
; 1077 : #if defined( OPTION_W32_CTCI )
; 1078 :     {
; 1079 :         int rc;
; 1080 :         int flags;
; 1081 : 
; 1082 :         flags = ( 0

  00023	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00028	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  0002f	74 0a		 je	 SHORT $LN5@qeth_disab
  00031	c7 44 24 40 04
	00 00 00	 mov	 DWORD PTR tv68[rsp], 4
  00039	eb 08		 jmp	 SHORT $LN6@qeth_disab
$LN5@qeth_disab:
  0003b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN6@qeth_disab:
  00043	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00048	83 b8 d8 05 00
	00 00		 cmp	 DWORD PTR [rax+1496], 0
  0004f	74 0a		 je	 SHORT $LN7@qeth_disab
  00051	c7 44 24 44 00
	01 00 00	 mov	 DWORD PTR tv72[rsp], 256 ; 00000100H
  00059	eb 08		 jmp	 SHORT $LN8@qeth_disab
$LN7@qeth_disab:
  0005b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN8@qeth_disab:
  00063	8b 44 24 40	 mov	 eax, DWORD PTR tv68[rsp]
  00067	0d 02 02 00 00	 or	 eax, 514		; 00000202H
  0006c	0b 44 24 44	 or	 eax, DWORD PTR tv72[rsp]
  00070	89 44 24 4c	 mov	 DWORD PTR flags$2[rsp], eax

; 1083 :                 | IFF_ALLMULTI
; 1084 :                 | IFF_BROADCAST
; 1085 : #if defined( TUNTAP_IFF_RUNNING_NEEDED )
; 1086 :                 | IFF_RUNNING
; 1087 : #endif
; 1088 :                 | (grp->debugmask ? IFF_DEBUG : 0)
; 1089 :                 | (grp->promisc ? IFF_PROMISC : 0)
; 1090 :                 );
; 1091 : 
; 1092 :         rc = TUNTAP_SetFlags( grp->ttifname, flags );

  00074	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00079	48 83 c0 60	 add	 rax, 96			; 00000060H
  0007d	8b 54 24 4c	 mov	 edx, DWORD PTR flags$2[rsp]
  00081	48 8b c8	 mov	 rcx, rax
  00084	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  00089	89 44 24 48	 mov	 DWORD PTR rc$1[rsp], eax

; 1093 :         if (rc != 0)

  0008d	83 7c 24 48 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00092	74 51		 je	 SHORT $LN3@qeth_disab

; 1094 :         {
; 1095 :             QERRMSG( dev, grp, errno,

  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009a	c7 44 24 38 48
	04 00 00	 mov	 DWORD PTR [rsp+56], 1096 ; 00000448H
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171855
  000a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171856
  000b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171857
  000c1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171858
  000cd	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000d0	48 8b 54 24 68	 mov	 rdx, QWORD PTR grp$[rsp]
  000d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000da	e8 00 00 00 00	 call	 qeth_errnum_msg

; 1096 :                 "E", "qeth_disable_interface() failed" );
; 1097 :             return rc;

  000df	8b 44 24 48	 mov	 eax, DWORD PTR rc$1[rsp]
  000e3	eb 20		 jmp	 SHORT $LN1@qeth_disab
$LN3@qeth_disab:

; 1098 :         }
; 1099 :     }
; 1100 : #endif /* defined( OPTION_W32_CTCI ) */
; 1101 : 
; 1102 :     grp->enabled = 0;

  000e5	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  000ea	c7 80 dc 05 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+1500], 0

; 1103 :     qeth_report_using( dev, grp );

  000f4	48 8b 54 24 68	 mov	 rdx, QWORD PTR grp$[rsp]
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000fe	e8 00 00 00 00	 call	 qeth_report_using

; 1104 : 
; 1105 :     return 0;

  00103	33 c0		 xor	 eax, eax
$LN1@qeth_disab:

; 1106 : }

  00105	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00109	c3		 ret	 0
qeth_disable_interface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv68 = 64
tv72 = 68
rc$ = 72
flags$ = 76
dev$ = 96
grp$ = 104
qeth_enable_interface PROC

; 1030 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1031 :     int rc;
; 1032 :     int flags;
; 1033 : 
; 1034 :     if (grp->enabled)

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00013	83 b8 dc 05 00
	00 00		 cmp	 DWORD PTR [rax+1500], 0
  0001a	74 07		 je	 SHORT $LN2@qeth_enabl

; 1035 :         return 0;

  0001c	33 c0		 xor	 eax, eax
  0001e	e9 e2 00 00 00	 jmp	 $LN1@qeth_enabl
$LN2@qeth_enabl:

; 1036 : 
; 1037 :     flags = ( 0

  00023	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00028	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  0002f	74 0a		 je	 SHORT $LN5@qeth_enabl
  00031	c7 44 24 40 04
	00 00 00	 mov	 DWORD PTR tv68[rsp], 4
  00039	eb 08		 jmp	 SHORT $LN6@qeth_enabl
$LN5@qeth_enabl:
  0003b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN6@qeth_enabl:
  00043	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00048	83 b8 d8 05 00
	00 00		 cmp	 DWORD PTR [rax+1496], 0
  0004f	74 0a		 je	 SHORT $LN7@qeth_enabl
  00051	c7 44 24 44 00
	01 00 00	 mov	 DWORD PTR tv72[rsp], 256 ; 00000100H
  00059	eb 08		 jmp	 SHORT $LN8@qeth_enabl
$LN7@qeth_enabl:
  0005b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN8@qeth_enabl:
  00063	8b 44 24 40	 mov	 eax, DWORD PTR tv68[rsp]
  00067	0d 03 02 00 00	 or	 eax, 515		; 00000203H
  0006c	0b 44 24 44	 or	 eax, DWORD PTR tv72[rsp]
  00070	89 44 24 4c	 mov	 DWORD PTR flags$[rsp], eax

; 1038 :             | IFF_UP
; 1039 :             | IFF_ALLMULTI
; 1040 :             | IFF_BROADCAST
; 1041 : #if defined( TUNTAP_IFF_RUNNING_NEEDED )
; 1042 :             | IFF_RUNNING
; 1043 : #endif
; 1044 : #if defined( OPTION_W32_CTCI )
; 1045 :             | (grp->debugmask ? IFF_DEBUG : 0)
; 1046 : #endif
; 1047 :             | (grp->promisc ? IFF_PROMISC : 0)
; 1048 :             );
; 1049 : 
; 1050 :     rc = TUNTAP_SetFlags( grp->ttifname, flags );

  00074	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00079	48 83 c0 60	 add	 rax, 96			; 00000060H
  0007d	8b 54 24 4c	 mov	 edx, DWORD PTR flags$[rsp]
  00081	48 8b c8	 mov	 rcx, rax
  00084	e8 00 00 00 00	 call	 TUNTAP_SetFlags
  00089	89 44 24 48	 mov	 DWORD PTR rc$[rsp], eax

; 1051 :     if (rc != 0)

  0008d	83 7c 24 48 00	 cmp	 DWORD PTR rc$[rsp], 0
  00092	74 51		 je	 SHORT $LN3@qeth_enabl

; 1052 :     {
; 1053 :         QERRMSG( dev, grp, errno,

  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009a	c7 44 24 38 1e
	04 00 00	 mov	 DWORD PTR [rsp+56], 1054 ; 0000041eH
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171841
  000a9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171842
  000b5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171843
  000c1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000c6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG171844
  000cd	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000d0	48 8b 54 24 68	 mov	 rdx, QWORD PTR grp$[rsp]
  000d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000da	e8 00 00 00 00	 call	 qeth_errnum_msg

; 1054 :             "E", "qeth_enable_interface() failed" );
; 1055 :         return rc;

  000df	8b 44 24 48	 mov	 eax, DWORD PTR rc$[rsp]
  000e3	eb 20		 jmp	 SHORT $LN1@qeth_enabl
$LN3@qeth_enabl:

; 1056 :     }
; 1057 : 
; 1058 :     grp->enabled = 1;

  000e5	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  000ea	c7 80 dc 05 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+1500], 1

; 1059 :     qeth_report_using( dev, grp );

  000f4	48 8b 54 24 68	 mov	 rdx, QWORD PTR grp$[rsp]
  000f9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000fe	e8 00 00 00 00	 call	 qeth_report_using

; 1060 : 
; 1061 :     return 0;

  00103	33 c0		 xor	 eax, eax
$LN1@qeth_enabl:

; 1062 : }

  00105	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00109	c3		 ret	 0
qeth_enable_interface ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv81 = 112
tv87 = 116
tv145 = 120
tv151 = 124
tv175 = 128
tv181 = 132
tv207 = 136
tv213 = 140
tv237 = 144
tv243 = 148
tv267 = 152
tv273 = 156
tv299 = 160
tv305 = 164
tv359 = 168
tv365 = 172
tv68 = 176
tv74 = 184
tv138 = 192
tv168 = 200
tv200 = 208
tv230 = 216
tv260 = 224
tv288 = 232
tv292 = 240
tv316 = 248
tv352 = 256
not$ = 264
__$ArrayPad$ = 272
dev$ = 304
grp$ = 312
qeth_report_using PROC

; 974  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 28 01
	00 00		 sub	 rsp, 296		; 00000128H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 975  :     char not[8];
; 976  :     STRLCPY( not, grp->enabled ? "" : "not " );

  00023	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0002b	83 b8 dc 05 00
	00 00		 cmp	 DWORD PTR [rax+1500], 0
  00032	74 11		 je	 SHORT $LN9@qeth_repor
  00034	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171783
  0003b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv68[rsp], rax
  00043	eb 0f		 jmp	 SHORT $LN10@qeth_repor
$LN9@qeth_repor:
  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171784
  0004c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv68[rsp], rax
$LN10@qeth_repor:
  00054	41 b8 08 00 00
	00		 mov	 r8d, 8
  0005a	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR tv68[rsp]
  00062	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 977  : 
; 978  :     // HHC03997 "%1d:%04X %s: Interface %s %susing %s %s"
; 979  :     WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  00070	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00079	74 12		 je	 SHORT $LN11@qeth_repor
  0007b	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00083	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00087	89 44 24 70	 mov	 DWORD PTR tv81[rsp], eax
  0008b	eb 08		 jmp	 SHORT $LN12@qeth_repor
$LN11@qeth_repor:
  0008d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN12@qeth_repor:
  00095	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0009e	74 14		 je	 SHORT $LN13@qeth_repor
  000a0	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000ac	d1 f8		 sar	 eax, 1
  000ae	89 44 24 74	 mov	 DWORD PTR tv87[rsp], eax
  000b2	eb 08		 jmp	 SHORT $LN14@qeth_repor
$LN13@qeth_repor:
  000b4	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN14@qeth_repor:
  000bc	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  000c4	48 83 c0 60	 add	 rax, 96			; 00000060H
  000c8	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000db	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000e3	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000e7	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171785
  000f3	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  000f8	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  00100	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00105	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv74[rsp]
  0010d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00112	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0011a	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0011e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00123	8b 4c 24 70	 mov	 ecx, DWORD PTR tv81[rsp]
  00127	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0012b	8b 4c 24 74	 mov	 ecx, DWORD PTR tv87[rsp]
  0012f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171786
  0013a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171787
  00146	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00150	41 b9 03 00 00
	00		 mov	 r9d, 3
  00156	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171788
  0015d	ba d4 03 00 00	 mov	 edx, 980		; 000003d4H
  00162	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171789
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 980  :         grp->ttifname, not, "MAC address", grp->tthwaddr );
; 981  : 
; 982  :     if (grp->l3 && grp->ttipaddr)

  0016f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00177	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  0017e	0f 84 42 02 00
	00		 je	 $LN2@qeth_repor
  00184	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0018c	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00194	0f 84 2c 02 00
	00		 je	 $LN2@qeth_repor

; 983  :     {
; 984  :         WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  0019a	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001a3	74 12		 je	 SHORT $LN15@qeth_repor
  001a5	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ad	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001b1	89 44 24 78	 mov	 DWORD PTR tv145[rsp], eax
  001b5	eb 08		 jmp	 SHORT $LN16@qeth_repor
$LN15@qeth_repor:
  001b7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN16@qeth_repor:
  001bf	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001c8	74 14		 je	 SHORT $LN17@qeth_repor
  001ca	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d2	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001d6	d1 f8		 sar	 eax, 1
  001d8	89 44 24 7c	 mov	 DWORD PTR tv151[rsp], eax
  001dc	eb 08		 jmp	 SHORT $LN18@qeth_repor
$LN17@qeth_repor:
  001de	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN18@qeth_repor:
  001e6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  001ee	48 83 c0 60	 add	 rax, 96			; 00000060H
  001f2	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv138[rsp], rax
  001fa	b9 01 00 00 00	 mov	 ecx, 1
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00205	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0020d	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00214	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00219	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171791
  00220	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00225	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  0022d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00232	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv138[rsp]
  0023a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0023f	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00247	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0024b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00250	8b 4c 24 78	 mov	 ecx, DWORD PTR tv145[rsp]
  00254	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00258	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv151[rsp]
  0025c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171792
  00267	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0026c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171793
  00273	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00278	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00283	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171794
  0028a	ba d9 03 00 00	 mov	 edx, 985		; 000003d9H
  0028f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171795
  00296	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 985  :              grp->ttifname, not, "IP address", grp->ttipaddr );
; 986  : 
; 987  :         if(grp->ttnetmask)

  0029c	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  002a4	48 83 b8 90 00
	00 00 00	 cmp	 QWORD PTR [rax+144], 0
  002ac	0f 84 14 01 00
	00		 je	 $LN3@qeth_repor

; 988  :         {
; 989  :             WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  002b2	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002bb	74 15		 je	 SHORT $LN19@qeth_repor
  002bd	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002c5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002c9	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv175[rsp], eax
  002d0	eb 0b		 jmp	 SHORT $LN20@qeth_repor
$LN19@qeth_repor:
  002d2	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
$LN20@qeth_repor:
  002dd	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002e6	74 17		 je	 SHORT $LN21@qeth_repor
  002e8	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002f4	d1 f8		 sar	 eax, 1
  002f6	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
  002fd	eb 0b		 jmp	 SHORT $LN22@qeth_repor
$LN21@qeth_repor:
  002ff	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
$LN22@qeth_repor:
  0030a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00312	48 83 c0 60	 add	 rax, 96			; 00000060H
  00316	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv168[rsp], rax
  0031e	b9 01 00 00 00	 mov	 ecx, 1
  00323	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00329	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00331	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00338	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0033d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171797
  00344	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00349	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  00351	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00356	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv168[rsp]
  0035e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00363	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0036b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0036f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00374	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv175[rsp]
  0037b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0037f	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv181[rsp]
  00386	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0038a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171798
  00391	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00396	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171799
  0039d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003a7	41 b9 03 00 00
	00		 mov	 r9d, 3
  003ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171800
  003b4	ba de 03 00 00	 mov	 edx, 990		; 000003deH
  003b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171801
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@qeth_repor:
$LN2@qeth_repor:

; 990  :                 grp->ttifname, not, "subnet mask", grp->ttnetmask );
; 991  :         }
; 992  :     }
; 993  : 
; 994  :     if (grp->l3 && grp->ttipaddr6)

  003c6	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  003ce	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  003d5	0f 84 54 02 00
	00		 je	 $LN4@qeth_repor
  003db	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  003e3	48 83 b8 98 00
	00 00 00	 cmp	 QWORD PTR [rax+152], 0
  003eb	0f 84 3e 02 00
	00		 je	 $LN4@qeth_repor

; 995  :     {
; 996  :         WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  003f1	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003fa	74 15		 je	 SHORT $LN23@qeth_repor
  003fc	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00404	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00408	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv207[rsp], eax
  0040f	eb 0b		 jmp	 SHORT $LN24@qeth_repor
$LN23@qeth_repor:
  00411	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv207[rsp], 0
$LN24@qeth_repor:
  0041c	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00425	74 17		 je	 SHORT $LN25@qeth_repor
  00427	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0042f	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00433	d1 f8		 sar	 eax, 1
  00435	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv213[rsp], eax
  0043c	eb 0b		 jmp	 SHORT $LN26@qeth_repor
$LN25@qeth_repor:
  0043e	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv213[rsp], 0
$LN26@qeth_repor:
  00449	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00451	48 83 c0 60	 add	 rax, 96			; 00000060H
  00455	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv200[rsp], rax
  0045d	b9 01 00 00 00	 mov	 ecx, 1
  00462	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00468	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00470	48 8b 89 98 00
	00 00		 mov	 rcx, QWORD PTR [rcx+152]
  00477	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0047c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171803
  00483	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00488	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  00490	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00495	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv200[rsp]
  0049d	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004a2	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004aa	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  004ae	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  004b3	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv207[rsp]
  004ba	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  004be	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv213[rsp]
  004c5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171804
  004d0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  004d5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171805
  004dc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004e6	41 b9 03 00 00
	00		 mov	 r9d, 3
  004ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171806
  004f3	ba e5 03 00 00	 mov	 edx, 997		; 000003e5H
  004f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171807
  004ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 997  :             grp->ttifname, not, "IP address", grp->ttipaddr6 );
; 998  : 
; 999  :         if(grp->ttpfxlen6)

  00505	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0050d	48 83 b8 a0 00
	00 00 00	 cmp	 QWORD PTR [rax+160], 0
  00515	0f 84 14 01 00
	00		 je	 $LN5@qeth_repor

; 1000 :         {
; 1001 :             WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  0051b	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00524	74 15		 je	 SHORT $LN27@qeth_repor
  00526	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00532	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv237[rsp], eax
  00539	eb 0b		 jmp	 SHORT $LN28@qeth_repor
$LN27@qeth_repor:
  0053b	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv237[rsp], 0
$LN28@qeth_repor:
  00546	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0054f	74 17		 je	 SHORT $LN29@qeth_repor
  00551	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00559	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0055d	d1 f8		 sar	 eax, 1
  0055f	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv243[rsp], eax
  00566	eb 0b		 jmp	 SHORT $LN30@qeth_repor
$LN29@qeth_repor:
  00568	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv243[rsp], 0
$LN30@qeth_repor:
  00573	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0057b	48 83 c0 60	 add	 rax, 96			; 00000060H
  0057f	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv230[rsp], rax
  00587	b9 01 00 00 00	 mov	 ecx, 1
  0058c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00592	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0059a	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  005a1	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  005a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171809
  005ad	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  005b2	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  005ba	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005bf	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv230[rsp]
  005c7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005cc	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005d4	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  005d8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005dd	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv237[rsp]
  005e4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005e8	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv243[rsp]
  005ef	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171810
  005fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171811
  00606	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0060b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00610	41 b9 03 00 00
	00		 mov	 r9d, 3
  00616	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171812
  0061d	ba ea 03 00 00	 mov	 edx, 1002		; 000003eaH
  00622	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171813
  00629	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN5@qeth_repor:
$LN4@qeth_repor:

; 1002 :                 grp->ttifname, not, "prefix length", grp->ttpfxlen6 );
; 1003 :         }
; 1004 :     }
; 1005 : 
; 1006 :     if (grp->ttmtu)

  0062f	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00637	48 83 78 78 00	 cmp	 QWORD PTR [rax+120], 0
  0063c	0f 84 11 01 00
	00		 je	 $LN6@qeth_repor

; 1007 :     {
; 1008 :         WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  00642	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0064b	74 15		 je	 SHORT $LN31@qeth_repor
  0064d	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00655	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00659	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv267[rsp], eax
  00660	eb 0b		 jmp	 SHORT $LN32@qeth_repor
$LN31@qeth_repor:
  00662	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv267[rsp], 0
$LN32@qeth_repor:
  0066d	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00676	74 17		 je	 SHORT $LN33@qeth_repor
  00678	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00680	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00684	d1 f8		 sar	 eax, 1
  00686	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv273[rsp], eax
  0068d	eb 0b		 jmp	 SHORT $LN34@qeth_repor
$LN33@qeth_repor:
  0068f	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
$LN34@qeth_repor:
  0069a	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  006a2	48 83 c0 60	 add	 rax, 96			; 00000060H
  006a6	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv260[rsp], rax
  006ae	b9 01 00 00 00	 mov	 ecx, 1
  006b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006b9	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  006c1	48 8b 49 78	 mov	 rcx, QWORD PTR [rcx+120]
  006c5	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  006ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171815
  006d1	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  006d6	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  006de	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006e3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv260[rsp]
  006eb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006f0	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006f8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  006fc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00701	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv267[rsp]
  00708	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0070c	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  00713	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00717	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171816
  0071e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00723	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171817
  0072a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0072f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00734	41 b9 03 00 00
	00		 mov	 r9d, 3
  0073a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171818
  00741	ba f1 03 00 00	 mov	 edx, 1009		; 000003f1H
  00746	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171819
  0074d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@qeth_repor:

; 1009 :             grp->ttifname, not, "MTU", grp->ttmtu );
; 1010 :     }
; 1011 : 
; 1012 : #if defined( ENABLE_IPV6 )
; 1013 :     if (grp->l3 && grp->enabled)

  00753	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0075b	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00762	0f 84 5b 02 00
	00		 je	 $LN7@qeth_repor
  00768	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00770	83 b8 dc 05 00
	00 00		 cmp	 DWORD PTR [rax+1500], 0
  00777	0f 84 46 02 00
	00		 je	 $LN7@qeth_repor

; 1014 :     {
; 1015 :         // HHC03997 "%1d:%04X %s: Interface %s %susing %s %s"
; 1016 :         WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  0077d	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00786	74 15		 je	 SHORT $LN35@qeth_repor
  00788	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00790	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00794	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv299[rsp], eax
  0079b	eb 0b		 jmp	 SHORT $LN36@qeth_repor
$LN35@qeth_repor:
  0079d	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv299[rsp], 0
$LN36@qeth_repor:
  007a8	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007b1	74 17		 je	 SHORT $LN37@qeth_repor
  007b3	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007bb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  007bf	d1 f8		 sar	 eax, 1
  007c1	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv305[rsp], eax
  007c8	eb 0b		 jmp	 SHORT $LN38@qeth_repor
$LN37@qeth_repor:
  007ca	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv305[rsp], 0
$LN38@qeth_repor:
  007d5	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  007dd	48 05 4a 06 00
	00		 add	 rax, 1610		; 0000064aH
  007e3	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv288[rsp], rax
  007eb	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  007f3	48 83 c1 60	 add	 rcx, 96			; 00000060H
  007f7	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR tv292[rsp], rcx
  007ff	b9 01 00 00 00	 mov	 ecx, 1
  00804	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0080a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv288[rsp]
  00812	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  00817	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171821
  0081e	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00823	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  0082b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00830	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv292[rsp]
  00838	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0083d	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00845	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00849	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0084e	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv299[rsp]
  00855	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00859	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv305[rsp]
  00860	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00864	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171822
  0086b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00870	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171823
  00877	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0087c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00881	41 b9 03 00 00
	00		 mov	 r9d, 3
  00887	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171824
  0088e	ba f9 03 00 00	 mov	 edx, 1017		; 000003f9H
  00893	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171825
  0089a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1017 :             grp->ttifname, not, "drive MAC address", grp->szDriveMACAddr );
; 1018 :         // HHC03997 "%1d:%04X %s: Interface %s %susing %s %s"
; 1019 :         WRMSG( HHC03997, "I", LCSS_DEVNUM, dev->typname,

  008a0	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008a9	74 15		 je	 SHORT $LN39@qeth_repor
  008ab	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008b3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008b7	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv359[rsp], eax
  008be	eb 0b		 jmp	 SHORT $LN40@qeth_repor
$LN39@qeth_repor:
  008c0	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv359[rsp], 0
$LN40@qeth_repor:
  008cb	48 83 bc 24 30
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008d4	74 17		 je	 SHORT $LN41@qeth_repor
  008d6	48 8b 84 24 30
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008de	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  008e2	d1 f8		 sar	 eax, 1
  008e4	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv365[rsp], eax
  008eb	eb 0b		 jmp	 SHORT $LN42@qeth_repor
$LN41@qeth_repor:
  008ed	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv365[rsp], 0
$LN42@qeth_repor:
  008f8	48 8b 84 24 38
	01 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00900	48 05 72 06 00
	00		 add	 rax, 1650		; 00000672H
  00906	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv316[rsp], rax
  0090e	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00916	48 83 c1 60	 add	 rcx, 96			; 00000060H
  0091a	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR tv352[rsp], rcx
  00922	b9 01 00 00 00	 mov	 ecx, 1
  00927	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0092d	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv316[rsp]
  00935	48 89 4c 24 68	 mov	 QWORD PTR [rsp+104], rcx
  0093a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171826
  00941	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00946	48 8d 8c 24 08
	01 00 00	 lea	 rcx, QWORD PTR not$[rsp]
  0094e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00953	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv352[rsp]
  0095b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00960	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00968	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0096c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00971	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv359[rsp]
  00978	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0097c	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv365[rsp]
  00983	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00987	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171827
  0098e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00993	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171828
  0099a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0099f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  009aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171829
  009b1	ba fc 03 00 00	 mov	 edx, 1020		; 000003fcH
  009b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171830
  009bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@qeth_repor:

; 1020 :             grp->ttifname, not, "drive IP address", grp->szDriveLLAddr6 );
; 1021 :     }
; 1022 : #endif
; 1023 : }

  009c3	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009cb	48 33 cc	 xor	 rcx, rsp
  009ce	e8 00 00 00 00	 call	 __security_check_cookie
  009d3	48 81 c4 28 01
	00 00		 add	 rsp, 296		; 00000128H
  009da	c3		 ret	 0
qeth_report_using ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv155 = 96
tv161 = 100
tv184 = 104
tv190 = 108
tv209 = 112
tv215 = 116
tv148 = 120
tv177 = 128
tv202 = 136
msgbuf$ = 144
strerr$ = 400
msgloc$ = 656
__$ArrayPad$ = 912
dev$ = 944
grp$ = 952
errnum$ = 960
msgcode$ = 968
errmsg$ = 976
func$ = 984
filename$ = 992
line$ = 1000
qeth_errnum_msg PROC

; 930  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec a0 03
	00 00		 sub	 rsp, 928		; 000003a0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 90
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 931  :     char strerr[256] = {0};

  0002e	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR strerr$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00040	f3 aa		 rep stosb

; 932  :     char msgbuf[256] = {0};

  00042	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR msgbuf$[rsp]
  0004a	48 8b f8	 mov	 rdi, rax
  0004d	33 c0		 xor	 eax, eax
  0004f	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00054	f3 aa		 rep stosb

; 933  :     char msgloc[256] = {0};

  00056	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR msgloc$[rsp]
  0005e	48 8b f8	 mov	 rdi, rax
  00061	33 c0		 xor	 eax, eax
  00063	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00068	f3 aa		 rep stosb

; 934  : 
; 935  :     if (errnum >= 0)

  0006a	83 bc 24 c0 03
	00 00 00	 cmp	 DWORD PTR errnum$[rsp], 0
  00072	7c 26		 jl	 SHORT $LN2@qeth_errnu

; 936  :         STRLCPY( strerr, strerror( errnum ));

  00074	8b 8c 24 c0 03
	00 00		 mov	 ecx, DWORD PTR errnum$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00081	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00087	48 8b d0	 mov	 rdx, rax
  0008a	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR strerr$[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  00098	eb 1b		 jmp	 SHORT $LN3@qeth_errnu
$LN2@qeth_errnu:

; 937  :     else
; 938  :         STRLCPY( strerr, "An unidentified error has occurred" );

  0009a	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171753
  000a7	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR strerr$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN3@qeth_errnu:

; 939  : 
; 940  :     /* Manually identify ACTUAL source of error if emsgloc is enabled,
; 941  :        since normal emsgloc identifies US as source which doesn't help.
; 942  :     */
; 943  :     if (MLVL( EMSGLOC ) && (0

  000b5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000bc	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  000c2	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  000c7	85 c0		 test	 eax, eax
  000c9	74 76		 je	 SHORT $LN4@qeth_errnu
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 30		 jne	 SHORT $LN5@qeth_errnu
  000d1	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR msgcode$[rsp]
  000d9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000dc	83 f8 53	 cmp	 eax, 83			; 00000053H
  000df	74 20		 je	 SHORT $LN5@qeth_errnu
  000e1	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR msgcode$[rsp]
  000e9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000ec	83 f8 45	 cmp	 eax, 69			; 00000045H
  000ef	74 10		 je	 SHORT $LN5@qeth_errnu
  000f1	48 8b 84 24 c8
	03 00 00	 mov	 rax, QWORD PTR msgcode$[rsp]
  000f9	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000fc	83 f8 57	 cmp	 eax, 87			; 00000057H
  000ff	75 40		 jne	 SHORT $LN4@qeth_errnu
$LN5@qeth_errnu:

; 944  :         || 'S' == *msgcode
; 945  :         || 'E' == *msgcode
; 946  :         || 'W' == *msgcode
; 947  :     ))
; 948  :         MSGBUF( msgloc, "%s() at %s(%d): ",

  00101	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR filename$[rsp]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_trimloc
  0010f	8b 8c 24 e8 03
	00 00		 mov	 ecx, DWORD PTR line$[rsp]
  00116	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  0011a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0011f	4c 8b 8c 24 d8
	03 00 00	 mov	 r9, QWORD PTR func$[rsp]
  00127	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171756
  0012e	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00133	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR msgloc$[rsp]
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN4@qeth_errnu:

; 949  :             func, TRIMLOC( filename ), line );
; 950  : 
; 951  :     /* "function() failed, rc=99 (0x00000063): an error occurred" */
; 952  :     MSGBUF( msgbuf, "%s%s, rc=%d (0x%08X): %s",

  00141	48 8d 84 24 90
	01 00 00	 lea	 rax, QWORD PTR strerr$[rsp]
  00149	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0014e	8b 84 24 c0 03
	00 00		 mov	 eax, DWORD PTR errnum$[rsp]
  00155	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00159	8b 84 24 c0 03
	00 00		 mov	 eax, DWORD PTR errnum$[rsp]
  00160	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00164	48 8b 84 24 d0
	03 00 00	 mov	 rax, QWORD PTR errmsg$[rsp]
  0016c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00171	4c 8d 8c 24 90
	02 00 00	 lea	 r9, QWORD PTR msgloc$[rsp]
  00179	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171757
  00180	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00185	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 953  :         msgloc, errmsg, errnum, errnum, strerr );
; 954  : 
; 955  :     // HHC03996 "%1d:%04X %s: %s: %s"
; 956  :     if (str_caseless_eq( "E", msgcode ))

  00193	48 8b 94 24 c8
	03 00 00	 mov	 rdx, QWORD PTR msgcode$[rsp]
  0019b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171760
  001a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  001a8	85 c0		 test	 eax, eax
  001aa	0f 85 e1 00 00
	00		 jne	 $LN6@qeth_errnu

; 957  :         WRMSG( HHC03996, "E", LCSS_DEVNUM,

  001b0	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001b9	74 12		 je	 SHORT $LN11@qeth_errnu
  001bb	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001c3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001c7	89 44 24 60	 mov	 DWORD PTR tv155[rsp], eax
  001cb	eb 08		 jmp	 SHORT $LN12@qeth_errnu
$LN11@qeth_errnu:
  001cd	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN12@qeth_errnu:
  001d5	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001de	74 14		 je	 SHORT $LN13@qeth_errnu
  001e0	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e8	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ec	d1 f8		 sar	 eax, 1
  001ee	89 44 24 64	 mov	 DWORD PTR tv161[rsp], eax
  001f2	eb 08		 jmp	 SHORT $LN14@qeth_errnu
$LN13@qeth_errnu:
  001f4	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN14@qeth_errnu:
  001fc	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00204	48 83 c0 60	 add	 rax, 96			; 00000060H
  00208	48 89 44 24 78	 mov	 QWORD PTR tv148[rsp], rax
  0020d	b9 01 00 00 00	 mov	 ecx, 1
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00218	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00220	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00225	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv148[rsp]
  0022a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0022f	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00237	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0023b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00240	8b 4c 24 60	 mov	 ecx, DWORD PTR tv155[rsp]
  00244	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00248	8b 4c 24 64	 mov	 ecx, DWORD PTR tv161[rsp]
  0024c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00250	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171761
  00257	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0025c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171762
  00263	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00268	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0026d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00273	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171763
  0027a	ba be 03 00 00	 mov	 edx, 958		; 000003beH
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171764
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  0028c	e9 e6 01 00 00	 jmp	 $LN7@qeth_errnu
$LN6@qeth_errnu:

; 958  :             dev->typname, grp->ttifname, msgbuf );
; 959  :     else if (str_caseless_eq( "W", msgcode ))

  00291	48 8b 94 24 c8
	03 00 00	 mov	 rdx, QWORD PTR msgcode$[rsp]
  00299	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171767
  002a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002a6	85 c0		 test	 eax, eax
  002a8	0f 85 e7 00 00
	00		 jne	 $LN8@qeth_errnu

; 960  :         WRMSG( HHC03996,      "W", LCSS_DEVNUM,

  002ae	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002b7	74 12		 je	 SHORT $LN15@qeth_errnu
  002b9	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002c1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002c5	89 44 24 68	 mov	 DWORD PTR tv184[rsp], eax
  002c9	eb 08		 jmp	 SHORT $LN16@qeth_errnu
$LN15@qeth_errnu:
  002cb	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
$LN16@qeth_errnu:
  002d3	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002dc	74 14		 je	 SHORT $LN17@qeth_errnu
  002de	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  002ea	d1 f8		 sar	 eax, 1
  002ec	89 44 24 6c	 mov	 DWORD PTR tv190[rsp], eax
  002f0	eb 08		 jmp	 SHORT $LN18@qeth_errnu
$LN17@qeth_errnu:
  002f2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
$LN18@qeth_errnu:
  002fa	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00302	48 83 c0 60	 add	 rax, 96			; 00000060H
  00306	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  0030e	b9 01 00 00 00	 mov	 ecx, 1
  00313	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00319	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00321	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00326	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv177[rsp]
  0032e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00333	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0033b	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0033f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00344	8b 4c 24 68	 mov	 ecx, DWORD PTR tv184[rsp]
  00348	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0034c	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv190[rsp]
  00350	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00354	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171768
  0035b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00360	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171769
  00367	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00371	41 b9 03 00 00
	00		 mov	 r9d, 3
  00377	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171770
  0037e	ba c1 03 00 00	 mov	 edx, 961		; 000003c1H
  00383	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171771
  0038a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00390	e9 e2 00 00 00	 jmp	 $LN9@qeth_errnu
$LN8@qeth_errnu:

; 961  :             dev->typname, grp->ttifname, msgbuf );
; 962  :     else
; 963  :         WRMSG( HHC03996, "I", LCSS_DEVNUM,

  00395	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0039e	74 12		 je	 SHORT $LN19@qeth_errnu
  003a0	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003ac	89 44 24 70	 mov	 DWORD PTR tv209[rsp], eax
  003b0	eb 08		 jmp	 SHORT $LN20@qeth_errnu
$LN19@qeth_errnu:
  003b2	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
$LN20@qeth_errnu:
  003ba	48 83 bc 24 b0
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003c3	74 14		 je	 SHORT $LN21@qeth_errnu
  003c5	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003cd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003d1	d1 f8		 sar	 eax, 1
  003d3	89 44 24 74	 mov	 DWORD PTR tv215[rsp], eax
  003d7	eb 08		 jmp	 SHORT $LN22@qeth_errnu
$LN21@qeth_errnu:
  003d9	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN22@qeth_errnu:
  003e1	48 8b 84 24 b8
	03 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  003e9	48 83 c0 60	 add	 rax, 96			; 00000060H
  003ed	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv202[rsp], rax
  003f5	b9 01 00 00 00	 mov	 ecx, 1
  003fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00400	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$[rsp]
  00408	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0040d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv202[rsp]
  00415	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0041a	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00422	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00426	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0042b	8b 4c 24 70	 mov	 ecx, DWORD PTR tv209[rsp]
  0042f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00433	8b 4c 24 74	 mov	 ecx, DWORD PTR tv215[rsp]
  00437	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0043b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171772
  00442	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171773
  0044e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00453	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00458	41 b9 03 00 00
	00		 mov	 r9d, 3
  0045e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171774
  00465	ba c4 03 00 00	 mov	 edx, 964		; 000003c4H
  0046a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171775
  00471	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@qeth_errnu:
$LN7@qeth_errnu:

; 964  :             dev->typname, grp->ttifname, msgbuf );
; 965  : 
; 966  :     return errnum;

  00477	8b 84 24 c0 03
	00 00		 mov	 eax, DWORD PTR errnum$[rsp]

; 967  : }

  0047e	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00486	48 33 cc	 xor	 rcx, rsp
  00489	e8 00 00 00 00	 call	 __security_check_cookie
  0048e	48 81 c4 a0 03
	00 00		 add	 rsp, 928		; 000003a0H
  00495	5f		 pop	 rdi
  00496	c3		 ret	 0
qeth_errnum_msg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
errnum$ = 64
rc$ = 68
fd$ = 96
sig$ = 104
qeth_write_pipe PROC

; 897  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@qeth_write:

; 898  :     int rc, errnum;
; 899  :     PTT_QETH_TRACE( "b4 wrpipe", 0,0,*sig );

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0001d	48 85 c0	 test	 rax, rax
  00020	74 3a		 je	 SHORT $LN11@qeth_write
  00022	48 8b 44 24 68	 mov	 rax, QWORD PTR sig$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171722
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	45 33 c9	 xor	 r9d, r9d
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171723
  00051	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@qeth_write:
  0005c	33 c0		 xor	 eax, eax
  0005e	85 c0		 test	 eax, eax
  00060	75 ab		 jne	 SHORT $LN4@qeth_write
$LN5@qeth_write:

; 900  :     for (;;) {
; 901  :         rc = write_pipe( fd, sig, 1 );

  00062	48 63 44 24 60	 movsxd	 rax, DWORD PTR fd$[rsp]
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00070	48 8b 54 24 68	 mov	 rdx, QWORD PTR sig$[rsp]
  00075	48 8b c8	 mov	 rcx, rax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  0007e	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 902  :         if (rc > 0)

  00082	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  00087	7e 02		 jle	 SHORT $LN12@qeth_write

; 903  :             break;

  00089	eb 3c		 jmp	 SHORT $LN6@qeth_write
$LN12@qeth_write:

; 904  :         errnum = HSO_errno;

  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00091	89 44 24 40	 mov	 DWORD PTR errnum$[rsp], eax

; 905  :         if (!QETH_TEMP_PIPE_ERROR( errnum ))

  00095	81 7c 24 40 14
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10004 ; 00002714H
  0009d	74 20		 je	 SHORT $LN13@qeth_write
  0009f	81 7c 24 40 33
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10035 ; 00002733H
  000a7	74 16		 je	 SHORT $LN13@qeth_write
  000a9	81 7c 24 40 35
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10037 ; 00002735H
  000b1	74 0c		 je	 SHORT $LN13@qeth_write
  000b3	81 7c 24 40 33
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10035 ; 00002733H
  000bb	74 02		 je	 SHORT $LN13@qeth_write

; 906  :             break;

  000bd	eb 08		 jmp	 SHORT $LN6@qeth_write
$LN13@qeth_write:

; 907  :         sched_yield();

  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 908  :     }

  000c5	eb 9b		 jmp	 SHORT $LN5@qeth_write
$LN6@qeth_write:

; 909  :     if (rc <= 0)

  000c7	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cc	7f 0c		 jg	 SHORT $LN14@qeth_write

; 910  :         errno = errnum;

  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d4	8b 4c 24 40	 mov	 ecx, DWORD PTR errnum$[rsp]
  000d8	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@qeth_write:
$LN10@qeth_write:

; 911  :     PTT_QETH_TRACE( "af wrpipe", 0,0,*sig );

  000da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e4	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000ea	48 85 c0	 test	 rax, rax
  000ed	74 3a		 je	 SHORT $LN15@qeth_write
  000ef	48 8b 44 24 68	 mov	 rax, QWORD PTR sig$[rsp]
  000f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00100	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00105	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171728
  0010c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00111	45 33 c9	 xor	 r9d, r9d
  00114	45 33 c0	 xor	 r8d, r8d
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171729
  0011e	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@qeth_write:
  00129	33 c0		 xor	 eax, eax
  0012b	85 c0		 test	 eax, eax
  0012d	75 ab		 jne	 SHORT $LN10@qeth_write

; 912  :     return rc;

  0012f	8b 44 24 44	 mov	 eax, DWORD PTR rc$[rsp]

; 913  : }

  00133	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00137	c3		 ret	 0
qeth_write_pipe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
errnum$ = 64
rc$ = 68
fd$ = 96
sig$ = 104
qeth_read_pipe PROC

; 879  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@qeth_read_:

; 880  :     int rc, errnum;
; 881  :     PTT_QETH_TRACE( "b4 rdpipe", 0,0,*sig );

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0001d	48 85 c0	 test	 rax, rax
  00020	74 3a		 je	 SHORT $LN11@qeth_read_
  00022	48 8b 44 24 68	 mov	 rax, QWORD PTR sig$[rsp]
  00027	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0002a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00033	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171682
  0003f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00044	45 33 c9	 xor	 r9d, r9d
  00047	45 33 c0	 xor	 r8d, r8d
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171683
  00051	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@qeth_read_:
  0005c	33 c0		 xor	 eax, eax
  0005e	85 c0		 test	 eax, eax
  00060	75 ab		 jne	 SHORT $LN4@qeth_read_
$LN5@qeth_read_:

; 882  :     for (;;) {
; 883  :         rc = read_pipe( fd, sig, 1 );

  00062	48 63 44 24 60	 movsxd	 rax, DWORD PTR fd$[rsp]
  00067	45 33 c9	 xor	 r9d, r9d
  0006a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00070	48 8b 54 24 68	 mov	 rdx, QWORD PTR sig$[rsp]
  00075	48 8b c8	 mov	 rcx, rax
  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  0007e	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 884  :         if (rc > 0)

  00082	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  00087	7e 02		 jle	 SHORT $LN12@qeth_read_

; 885  :             break;

  00089	eb 3c		 jmp	 SHORT $LN6@qeth_read_
$LN12@qeth_read_:

; 886  :         errnum = HSO_errno;

  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00091	89 44 24 40	 mov	 DWORD PTR errnum$[rsp], eax

; 887  :         if (!QETH_TEMP_PIPE_ERROR( errnum ))

  00095	81 7c 24 40 14
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10004 ; 00002714H
  0009d	74 20		 je	 SHORT $LN13@qeth_read_
  0009f	81 7c 24 40 33
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10035 ; 00002733H
  000a7	74 16		 je	 SHORT $LN13@qeth_read_
  000a9	81 7c 24 40 35
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10037 ; 00002735H
  000b1	74 0c		 je	 SHORT $LN13@qeth_read_
  000b3	81 7c 24 40 33
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10035 ; 00002733H
  000bb	74 02		 je	 SHORT $LN13@qeth_read_

; 888  :             break;

  000bd	eb 08		 jmp	 SHORT $LN6@qeth_read_
$LN13@qeth_read_:

; 889  :         sched_yield();

  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 890  :     }

  000c5	eb 9b		 jmp	 SHORT $LN5@qeth_read_
$LN6@qeth_read_:

; 891  :     if (rc <= 0)

  000c7	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  000cc	7f 0c		 jg	 SHORT $LN14@qeth_read_

; 892  :         errno = errnum;

  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d4	8b 4c 24 40	 mov	 ecx, DWORD PTR errnum$[rsp]
  000d8	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@qeth_read_:
$LN10@qeth_read_:

; 893  :     PTT_QETH_TRACE( "af rdpipe", 0,0,*sig );

  000da	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000e4	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  000ea	48 85 c0	 test	 rax, rax
  000ed	74 3a		 je	 SHORT $LN15@qeth_read_
  000ef	48 8b 44 24 68	 mov	 rax, QWORD PTR sig$[rsp]
  000f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f7	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00100	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00105	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171688
  0010c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00111	45 33 c9	 xor	 r9d, r9d
  00114	45 33 c0	 xor	 r8d, r8d
  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171689
  0011e	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00123	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@qeth_read_:
  00129	33 c0		 xor	 eax, eax
  0012b	85 c0		 test	 eax, eax
  0012d	75 ab		 jne	 SHORT $LN10@qeth_read_

; 894  :     return rc;

  0012f	8b 44 24 44	 mov	 eax, DWORD PTR rc$[rsp]

; 895  : }

  00133	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00137	c3		 ret	 0
qeth_read_pipe ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
errnum$ = 64
rc$ = 68
nfds$ = 96
rdset$ = 104
tv$ = 112
qeth_select PROC

; 855  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@qeth_selec:

; 856  :     int rc, errnum;
; 857  :     PTT_QETH_TRACE( "b4 select", 0,0,0 );

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00019	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001c	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00022	48 85 c0	 test	 rax, rax
  00025	74 36		 je	 SHORT $LN11@qeth_selec
  00027	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00030	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171642
  00040	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00045	45 33 c9	 xor	 r9d, r9d
  00048	45 33 c0	 xor	 r8d, r8d
  0004b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171643
  00052	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN11@qeth_selec:
  0005d	33 c0		 xor	 eax, eax
  0005f	85 c0		 test	 eax, eax
  00061	75 af		 jne	 SHORT $LN4@qeth_selec
$LN5@qeth_selec:

; 858  :     for (;;)
; 859  :     {
; 860  :         /* Do the select */
; 861  :         rc = select( nfds, rdset, NULL, NULL, tv );

  00063	c7 44 24 30 5d
	03 00 00	 mov	 DWORD PTR [rsp+48], 861	; 0000035dH
  0006b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171644
  00072	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR tv$[rsp]
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	45 33 c9	 xor	 r9d, r9d
  00084	45 33 c0	 xor	 r8d, r8d
  00087	48 8b 54 24 68	 mov	 rdx, QWORD PTR rdset$[rsp]
  0008c	8b 4c 24 60	 mov	 ecx, DWORD PTR nfds$[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  00096	89 44 24 44	 mov	 DWORD PTR rc$[rsp], eax

; 862  :         /* Get error code */
; 863  :         errnum = HSO_errno;

  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000a0	89 44 24 40	 mov	 DWORD PTR errnum$[rsp], eax

; 864  :         /* Return if successful */
; 865  :         if (rc >= 0)

  000a4	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a9	7c 02		 jl	 SHORT $LN12@qeth_selec

; 866  :             break;

  000ab	eb 32		 jmp	 SHORT $LN6@qeth_selec
$LN12@qeth_selec:

; 867  :         /* Return if non-temporary error */
; 868  :         if (!QETH_TEMP_PIPE_ERROR( errnum ))

  000ad	81 7c 24 40 14
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10004 ; 00002714H
  000b5	74 20		 je	 SHORT $LN13@qeth_selec
  000b7	81 7c 24 40 33
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10035 ; 00002733H
  000bf	74 16		 je	 SHORT $LN13@qeth_selec
  000c1	81 7c 24 40 35
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10037 ; 00002735H
  000c9	74 0c		 je	 SHORT $LN13@qeth_selec
  000cb	81 7c 24 40 33
	27 00 00	 cmp	 DWORD PTR errnum$[rsp], 10035 ; 00002733H
  000d3	74 02		 je	 SHORT $LN13@qeth_selec

; 869  :             break;

  000d5	eb 08		 jmp	 SHORT $LN6@qeth_selec
$LN13@qeth_selec:

; 870  :         /* Otherwise pause before retrying */
; 871  :         sched_yield();

  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 872  :     }

  000dd	eb 84		 jmp	 SHORT $LN5@qeth_selec
$LN6@qeth_selec:

; 873  :     if (rc <= 0)

  000df	83 7c 24 44 00	 cmp	 DWORD PTR rc$[rsp], 0
  000e4	7f 0c		 jg	 SHORT $LN14@qeth_selec

; 874  :         errno = errnum;

  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ec	8b 4c 24 40	 mov	 ecx, DWORD PTR errnum$[rsp]
  000f0	89 08		 mov	 DWORD PTR [rax], ecx
$LN14@qeth_selec:
$LN10@qeth_selec:

; 875  :     PTT_QETH_TRACE( "af select", 0,0,0 );

  000f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000f9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000fc	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  00102	48 85 c0	 test	 rax, rax
  00105	74 36		 je	 SHORT $LN15@qeth_selec
  00107	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00110	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  00119	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171649
  00120	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00125	45 33 c9	 xor	 r9d, r9d
  00128	45 33 c0	 xor	 r8d, r8d
  0012b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171650
  00132	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN15@qeth_selec:
  0013d	33 c0		 xor	 eax, eax
  0013f	85 c0		 test	 eax, eax
  00141	75 af		 jne	 SHORT $LN10@qeth_selec

; 876  :     return rc;

  00143	8b 44 24 44	 mov	 eax, DWORD PTR rc$[rsp]

; 877  : }

  00147	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0014b	c3		 ret	 0
qeth_select ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 0
grp$ = 32
unregister_all_ipv6 PROC

; 835  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 836  : int i;
; 837  :     for (i = 0; i < OSA_MAXIPV6; i++)

  0000a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00011	eb 08		 jmp	 SHORT $LN4@unregister
$LN2@unregister:
  00013	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00016	ff c0		 inc	 eax
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@unregister:
  0001b	83 3c 24 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  0001f	7d 3b		 jge	 SHORT $LN3@unregister

; 838  :     {
; 839  :         grp->ipaddr6[i].type = IPV6_TYPE_NONE;

  00021	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00025	48 6b c0 14	 imul	 rax, rax, 20
  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  0002e	c7 84 01 e8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+488], 0

; 840  :         memset(grp->ipaddr6[i].addr, 0, 16);

  00039	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0003d	48 6b c0 14	 imul	 rax, rax, 20
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  00046	48 8d 84 01 d8
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+472]
  0004e	48 8b f8	 mov	 rdi, rax
  00051	33 c0		 xor	 eax, eax
  00053	b9 10 00 00 00	 mov	 ecx, 16
  00058	f3 aa		 rep stosb

; 841  :     }

  0005a	eb b7		 jmp	 SHORT $LN2@unregister
$LN3@unregister:

; 842  :     return 0;

  0005c	33 c0		 xor	 eax, eax

; 843  : }

  0005e	48 83 c4 10	 add	 rsp, 16
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
unregister_all_ipv6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 96
tv142 = 100
tv148 = 104
tv171 = 108
tv177 = 112
tv135 = 120
tv164 = 128
charip6$ = 136
__$ArrayPad$ = 184
grp$ = 208
dev$ = 216
ipaddr6$ = 224
unregister_ipv6 PROC

; 803  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 804  : int i;
; 805  : char charip6[48];
; 806  :     /* Check whether the IPv6 address is registered. */
; 807  :     for (i = 0; i < OSA_MAXIPV6; i++)

  00029	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00031	eb 0a		 jmp	 SHORT $LN4@unregister
$LN2@unregister:
  00033	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00037	ff c0		 inc	 eax
  00039	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@unregister:
  0003d	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00042	0f 8d a0 01 00
	00		 jge	 $LN3@unregister

; 808  :     {
; 809  :         if (grp->ipaddr6[i].type == IPV6_TYPE_INUSE &&

  00048	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0004d	48 6b c0 14	 imul	 rax, rax, 20
  00051	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00059	83 bc 01 e8 01
	00 00 01	 cmp	 DWORD PTR [rcx+rax+488], 1
  00061	0f 85 7c 01 00
	00		 jne	 $LN5@unregister
  00067	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0006c	48 6b c0 14	 imul	 rax, rax, 20
  00070	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00078	48 8d 84 01 d8
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+472]
  00080	41 b8 10 00 00
	00		 mov	 r8d, 16
  00086	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr6$[rsp]
  0008e	48 8b c8	 mov	 rcx, rax
  00091	e8 00 00 00 00	 call	 memcmp
  00096	85 c0		 test	 eax, eax
  00098	0f 85 45 01 00
	00		 jne	 $LN5@unregister

; 810  :             memcmp(grp->ipaddr6[i].addr, ipaddr6, 16) == 0)
; 811  :         {
; 812  :             grp->ipaddr6[i].type = IPV6_TYPE_NONE;

  0009e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000a3	48 6b c0 14	 imul	 rax, rax, 20
  000a7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000af	c7 84 01 e8 01
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+488], 0

; 813  :             memset(grp->ipaddr6[i].addr, 0, 16);

  000ba	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000bf	48 6b c0 14	 imul	 rax, rax, 20
  000c3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000cb	48 8d 84 01 d8
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+472]
  000d3	48 8b f8	 mov	 rdi, rax
  000d6	33 c0		 xor	 eax, eax
  000d8	b9 10 00 00 00	 mov	 ecx, 16
  000dd	f3 aa		 rep stosb

; 814  :             hinet_ntop( AF_INET6, ipaddr6, charip6, sizeof(charip6) );

  000df	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  000e5	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip6$[rsp]
  000ed	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr6$[rsp]
  000f5	b9 17 00 00 00	 mov	 ecx, 23
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 815  :             // HHC03807 "%1d:%04X %s: %s: Unregistered guest IP address %s"
; 816  :             WRMSG(HHC03807, "I", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00100	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00109	74 12		 je	 SHORT $LN7@unregister
  0010b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00113	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00117	89 44 24 64	 mov	 DWORD PTR tv142[rsp], eax
  0011b	eb 08		 jmp	 SHORT $LN8@unregister
$LN7@unregister:
  0011d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN8@unregister:
  00125	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0012e	74 14		 je	 SHORT $LN9@unregister
  00130	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00138	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0013c	d1 f8		 sar	 eax, 1
  0013e	89 44 24 68	 mov	 DWORD PTR tv148[rsp], eax
  00142	eb 08		 jmp	 SHORT $LN10@unregister
$LN9@unregister:
  00144	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
$LN10@unregister:
  0014c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00154	48 83 c0 60	 add	 rax, 96			; 00000060H
  00158	48 89 44 24 78	 mov	 QWORD PTR tv135[rsp], rax
  0015d	b9 01 00 00 00	 mov	 ecx, 1
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00168	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip6$[rsp]
  00170	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00175	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv135[rsp]
  0017a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0017f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00187	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0018b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00190	8b 4c 24 64	 mov	 ecx, DWORD PTR tv142[rsp]
  00194	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00198	8b 4c 24 68	 mov	 ecx, DWORD PTR tv148[rsp]
  0019c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171591
  001a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171592
  001b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171593
  001ca	ba 31 03 00 00	 mov	 edx, 817		; 00000331H
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171594
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 817  :                     charip6 );
; 818  :             return 0;

  001dc	33 c0		 xor	 eax, eax
  001de	e9 0d 01 00 00	 jmp	 $LN1@unregister
$LN5@unregister:

; 819  :         }
; 820  :     }

  001e3	e9 4b fe ff ff	 jmp	 $LN2@unregister
$LN3@unregister:

; 821  :     /* Oh dear, the IPv6 address wasn't registered. */
; 822  :     hinet_ntop( AF_INET6, ipaddr6, charip6, sizeof(charip6) );

  001e8	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  001ee	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip6$[rsp]
  001f6	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr6$[rsp]
  001fe	b9 17 00 00 00	 mov	 ecx, 23
  00203	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 823  :     // HHC03808 "%1d:%04X %s: %s: Cannot unregister guest IP address %s"
; 824  :     WRMSG(HHC03808, "W", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00209	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00212	74 12		 je	 SHORT $LN11@unregister
  00214	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0021c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00220	89 44 24 6c	 mov	 DWORD PTR tv171[rsp], eax
  00224	eb 08		 jmp	 SHORT $LN12@unregister
$LN11@unregister:
  00226	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN12@unregister:
  0022e	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00237	74 14		 je	 SHORT $LN13@unregister
  00239	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00241	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00245	d1 f8		 sar	 eax, 1
  00247	89 44 24 70	 mov	 DWORD PTR tv177[rsp], eax
  0024b	eb 08		 jmp	 SHORT $LN14@unregister
$LN13@unregister:
  0024d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv177[rsp], 0
$LN14@unregister:
  00255	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0025d	48 83 c0 60	 add	 rax, 96			; 00000060H
  00261	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv164[rsp], rax
  00269	b9 01 00 00 00	 mov	 ecx, 1
  0026e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00274	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip6$[rsp]
  0027c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00281	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv164[rsp]
  00289	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0028e	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00296	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0029a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0029f	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv171[rsp]
  002a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002a7	8b 4c 24 70	 mov	 ecx, DWORD PTR tv177[rsp]
  002ab	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171595
  002b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171596
  002c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  002d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171597
  002d9	ba 39 03 00 00	 mov	 edx, 825		; 00000339H
  002de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171598
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 825  :             charip6 );
; 826  :     return 1;

  002eb	b8 01 00 00 00	 mov	 eax, 1
$LN1@unregister:

; 827  : }

  002f0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002f8	48 33 cc	 xor	 rcx, rsp
  002fb	e8 00 00 00 00	 call	 __security_check_cookie
  00300	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00307	5f		 pop	 rdi
  00308	c3		 ret	 0
unregister_ipv6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 96
tv153 = 100
tv159 = 104
tv182 = 108
tv188 = 112
tv146 = 120
tv175 = 128
charip6$ = 136
__$ArrayPad$ = 184
grp$ = 224
dev$ = 232
ipaddr6$ = 240
register_ipv6 PROC

; 762  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 763  : int i;
; 764  : char charip6[48];
; 765  :     /* Check whether the IPv6 address is already registered. */
; 766  :     for (i = 0; i < OSA_MAXIPV6; i++)

  0002a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00032	eb 0a		 jmp	 SHORT $LN4@register_i
$LN2@register_i:
  00034	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00038	ff c0		 inc	 eax
  0003a	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@register_i:
  0003e	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00043	7d 5a		 jge	 SHORT $LN3@register_i

; 767  :     {
; 768  :         if (grp->ipaddr6[i].type == IPV6_TYPE_INUSE &&

  00045	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0004a	48 6b c0 14	 imul	 rax, rax, 20
  0004e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00056	83 bc 01 e8 01
	00 00 01	 cmp	 DWORD PTR [rcx+rax+488], 1
  0005e	75 3d		 jne	 SHORT $LN8@register_i
  00060	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00065	48 6b c0 14	 imul	 rax, rax, 20
  00069	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00071	48 8d 84 01 d8
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax+472]
  00079	41 b8 10 00 00
	00		 mov	 r8d, 16
  0007f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr6$[rsp]
  00087	48 8b c8	 mov	 rcx, rax
  0008a	e8 00 00 00 00	 call	 memcmp
  0008f	85 c0		 test	 eax, eax
  00091	75 0a		 jne	 SHORT $LN8@register_i

; 769  :             memcmp(grp->ipaddr6[i].addr, ipaddr6, 16) == 0)
; 770  :         {
; 771  :             return 1;

  00093	b8 01 00 00 00	 mov	 eax, 1
  00098	e9 95 02 00 00	 jmp	 $LN1@register_i
$LN8@register_i:

; 772  :         }
; 773  :     }

  0009d	eb 95		 jmp	 SHORT $LN2@register_i
$LN3@register_i:

; 774  :     /* Register the previously unknown IPv6 address. */
; 775  :     for (i = 0; i < OSA_MAXIPV6; i++)

  0009f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a7	eb 0a		 jmp	 SHORT $LN7@register_i
$LN5@register_i:
  000a9	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  000ad	ff c0		 inc	 eax
  000af	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@register_i:
  000b3	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  000b8	0f 8d 6c 01 00
	00		 jge	 $LN6@register_i

; 776  :     {
; 777  :         if (grp->ipaddr6[i].type == IPV6_TYPE_NONE)

  000be	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000c3	48 6b c0 14	 imul	 rax, rax, 20
  000c7	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000cf	83 bc 01 e8 01
	00 00 00	 cmp	 DWORD PTR [rcx+rax+488], 0
  000d7	0f 85 48 01 00
	00		 jne	 $LN9@register_i

; 778  :         {
; 779  :             memcpy(grp->ipaddr6[i].addr, ipaddr6, 16);

  000dd	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000e2	48 6b c0 14	 imul	 rax, rax, 20
  000e6	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000ee	48 8d bc 01 d8
	01 00 00	 lea	 rdi, QWORD PTR [rcx+rax+472]
  000f6	48 8b b4 24 f0
	00 00 00	 mov	 rsi, QWORD PTR ipaddr6$[rsp]
  000fe	b9 10 00 00 00	 mov	 ecx, 16
  00103	f3 a4		 rep movsb

; 780  :             grp->ipaddr6[i].type = IPV6_TYPE_INUSE;

  00105	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0010a	48 6b c0 14	 imul	 rax, rax, 20
  0010e	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00116	c7 84 01 e8 01
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax+488], 1

; 781  :             hinet_ntop( AF_INET6, ipaddr6, charip6, sizeof(charip6) );

  00121	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00127	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip6$[rsp]
  0012f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr6$[rsp]
  00137	b9 17 00 00 00	 mov	 ecx, 23
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 782  :             // HHC03805 "%1d:%04X %s: s: Registered guest IP address %s"
; 783  :             WRMSG(HHC03805, "I", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00142	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0014b	74 12		 je	 SHORT $LN11@register_i
  0014d	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00155	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00159	89 44 24 64	 mov	 DWORD PTR tv153[rsp], eax
  0015d	eb 08		 jmp	 SHORT $LN12@register_i
$LN11@register_i:
  0015f	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN12@register_i:
  00167	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00170	74 14		 je	 SHORT $LN13@register_i
  00172	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0017e	d1 f8		 sar	 eax, 1
  00180	89 44 24 68	 mov	 DWORD PTR tv159[rsp], eax
  00184	eb 08		 jmp	 SHORT $LN14@register_i
$LN13@register_i:
  00186	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv159[rsp], 0
$LN14@register_i:
  0018e	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00196	48 83 c0 60	 add	 rax, 96			; 00000060H
  0019a	48 89 44 24 78	 mov	 QWORD PTR tv146[rsp], rax
  0019f	b9 01 00 00 00	 mov	 ecx, 1
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001aa	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip6$[rsp]
  001b2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001b7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv146[rsp]
  001bc	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001c1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c9	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001cd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d2	8b 4c 24 64	 mov	 ecx, DWORD PTR tv153[rsp]
  001d6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001da	8b 4c 24 68	 mov	 ecx, DWORD PTR tv159[rsp]
  001de	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171569
  001e9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171570
  001f5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001fa	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ff	41 b9 03 00 00
	00		 mov	 r9d, 3
  00205	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171571
  0020c	ba 10 03 00 00	 mov	 edx, 784		; 00000310H
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171572
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 784  :                     charip6 );
; 785  :             return 0;

  0021e	33 c0		 xor	 eax, eax
  00220	e9 0d 01 00 00	 jmp	 $LN1@register_i
$LN9@register_i:

; 786  :         }
; 787  :     }

  00225	e9 7f fe ff ff	 jmp	 $LN5@register_i
$LN6@register_i:

; 788  :     /* Oh dear, the IPv6 address table is full. */
; 789  :     hinet_ntop( AF_INET6, ipaddr6, charip6, sizeof(charip6) );

  0022a	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00230	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip6$[rsp]
  00238	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr6$[rsp]
  00240	b9 17 00 00 00	 mov	 ecx, 23
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 790  :     // HHC03806 "%1d:%04X %s: s: Cannot register guest IP address %s"
; 791  :     WRMSG(HHC03806, "E", LCSS_DEVNUM, dev->typname, grp->ttifname,

  0024b	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00254	74 12		 je	 SHORT $LN15@register_i
  00256	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00262	89 44 24 6c	 mov	 DWORD PTR tv182[rsp], eax
  00266	eb 08		 jmp	 SHORT $LN16@register_i
$LN15@register_i:
  00268	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
$LN16@register_i:
  00270	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00279	74 14		 je	 SHORT $LN17@register_i
  0027b	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00283	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00287	d1 f8		 sar	 eax, 1
  00289	89 44 24 70	 mov	 DWORD PTR tv188[rsp], eax
  0028d	eb 08		 jmp	 SHORT $LN18@register_i
$LN17@register_i:
  0028f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv188[rsp], 0
$LN18@register_i:
  00297	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0029f	48 83 c0 60	 add	 rax, 96			; 00000060H
  002a3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv175[rsp], rax
  002ab	b9 01 00 00 00	 mov	 ecx, 1
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b6	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip6$[rsp]
  002be	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002c3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv175[rsp]
  002cb	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002d0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002d8	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002dc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002e1	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv182[rsp]
  002e5	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002e9	8b 4c 24 70	 mov	 ecx, DWORD PTR tv188[rsp]
  002ed	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171573
  002f8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171574
  00304	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00309	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00314	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171575
  0031b	ba 18 03 00 00	 mov	 edx, 792		; 00000318H
  00320	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171576
  00327	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 792  :           charip6 );
; 793  :     return -1;

  0032d	b8 ff ff ff ff	 mov	 eax, -1
$LN1@register_i:

; 794  : }

  00332	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0033a	48 33 cc	 xor	 rcx, rsp
  0033d	e8 00 00 00 00	 call	 __security_check_cookie
  00342	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00349	5f		 pop	 rdi
  0034a	5e		 pop	 rsi
  0034b	c3		 ret	 0
register_ipv6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 0
grp$ = 32
unregister_all_ipv4 PROC

; 743  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 744  : int i;
; 745  :     for (i = 0; i < OSA_MAXIPV4; i++)

  0000a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00011	eb 08		 jmp	 SHORT $LN4@unregister
$LN2@unregister:
  00013	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00016	ff c0		 inc	 eax
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@unregister:
  0001b	83 3c 24 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  0001f	7d 33		 jge	 SHORT $LN3@unregister

; 746  :     {
; 747  :         grp->ipaddr4[i].type = IPV4_TYPE_NONE;

  00021	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00025	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  0002a	c7 84 c1 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+220], 0

; 748  :         memset(grp->ipaddr4[i].addr, 0, 4);

  00035	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  0003e	48 8d 84 c1 d8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+216]
  00046	48 8b f8	 mov	 rdi, rax
  00049	33 c0		 xor	 eax, eax
  0004b	b9 04 00 00 00	 mov	 ecx, 4
  00050	f3 aa		 rep stosb

; 749  :     }

  00052	eb bf		 jmp	 SHORT $LN2@unregister
$LN3@unregister:

; 750  :     return 0;

  00054	33 c0		 xor	 eax, eax

; 751  : }

  00056	48 83 c4 10	 add	 rsp, 16
  0005a	5f		 pop	 rdi
  0005b	c3		 ret	 0
unregister_all_ipv4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 96
tv150 = 100
tv156 = 104
tv179 = 108
tv185 = 112
tv143 = 120
tv172 = 128
charip4$ = 136
__$ArrayPad$ = 184
grp$ = 208
dev$ = 216
ipaddr4$ = 224
unregister_ipv4 PROC

; 704  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 705  : int i;
; 706  : char charip4[48];
; 707  :     /* Check whether the IPv4 address is registered. */
; 708  :     for (i = 0; i < OSA_MAXIPV4; i++)

  00029	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00031	eb 0a		 jmp	 SHORT $LN4@unregister
$LN2@unregister:
  00033	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00037	ff c0		 inc	 eax
  00039	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@unregister:
  0003d	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00042	0f 8d c0 01 00
	00		 jge	 $LN3@unregister

; 709  :     {
; 710  :         if (grp->ipaddr4[i].type == IPV4_TYPE_INUSE &&

  00048	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0004d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00055	83 bc c1 dc 00
	00 00 01	 cmp	 DWORD PTR [rcx+rax*8+220], 1
  0005d	0f 85 a0 01 00
	00		 jne	 $LN5@unregister
  00063	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00068	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00070	48 8d 84 c1 d8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+216]
  00078	41 b8 04 00 00
	00		 mov	 r8d, 4
  0007e	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  00086	48 8b c8	 mov	 rcx, rax
  00089	e8 00 00 00 00	 call	 memcmp
  0008e	85 c0		 test	 eax, eax
  00090	0f 85 6d 01 00
	00		 jne	 $LN5@unregister

; 711  :             memcmp(grp->ipaddr4[i].addr, ipaddr4, 4) == 0)
; 712  :         {
; 713  : #if defined( OPTION_W32_CTCI )
; 714  :             if (tt32_multiple_ip_support())

  00096	e8 00 00 00 00	 call	 tt32_multiple_ip_support
  0009b	0f b6 c0	 movzx	 eax, al
  0009e	85 c0		 test	 eax, eax
  000a0	74 24		 je	 SHORT $LN6@unregister

; 715  :             {
; 716  :                 if (TT32_DelIPAddr( grp->ttfd, ipaddr4 ) < 0)

  000a2	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  000aa	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  000b2	8b 88 f8 05 00
	00		 mov	 ecx, DWORD PTR [rax+1528]
  000b8	e8 00 00 00 00	 call	 TT32_DelIPAddr
  000bd	85 c0		 test	 eax, eax
  000bf	7d 05		 jge	 SHORT $LN7@unregister

; 717  :                     break; // (fail)

  000c1	e9 42 01 00 00	 jmp	 $LN3@unregister
$LN7@unregister:
$LN6@unregister:

; 718  :             }
; 719  : #endif
; 720  :             grp->ipaddr4[i].type = IPV4_TYPE_NONE;

  000c6	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000cb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000d3	c7 84 c1 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+220], 0

; 721  :             memset(grp->ipaddr4[i].addr, 0, 4);

  000de	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000e3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000eb	48 8d 84 c1 d8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+216]
  000f3	48 8b f8	 mov	 rdi, rax
  000f6	33 c0		 xor	 eax, eax
  000f8	b9 04 00 00 00	 mov	 ecx, 4
  000fd	f3 aa		 rep stosb

; 722  :             hinet_ntop( AF_INET, ipaddr4, charip4, sizeof(charip4) );

  000ff	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00105	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip4$[rsp]
  0010d	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  00115	b9 02 00 00 00	 mov	 ecx, 2
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 723  :             // HHC03807 "%1d:%04X %s: s: Unregister guest IP address %s"
; 724  :             WRMSG(HHC03807, "I", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00120	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00129	74 12		 je	 SHORT $LN9@unregister
  0012b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00133	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00137	89 44 24 64	 mov	 DWORD PTR tv150[rsp], eax
  0013b	eb 08		 jmp	 SHORT $LN10@unregister
$LN9@unregister:
  0013d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN10@unregister:
  00145	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0014e	74 14		 je	 SHORT $LN11@unregister
  00150	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00158	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0015c	d1 f8		 sar	 eax, 1
  0015e	89 44 24 68	 mov	 DWORD PTR tv156[rsp], eax
  00162	eb 08		 jmp	 SHORT $LN12@unregister
$LN11@unregister:
  00164	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv156[rsp], 0
$LN12@unregister:
  0016c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00174	48 83 c0 60	 add	 rax, 96			; 00000060H
  00178	48 89 44 24 78	 mov	 QWORD PTR tv143[rsp], rax
  0017d	b9 01 00 00 00	 mov	 ecx, 1
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00188	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip4$[rsp]
  00190	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00195	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv143[rsp]
  0019a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0019f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a7	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001ab	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001b0	8b 4c 24 64	 mov	 ecx, DWORD PTR tv150[rsp]
  001b4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001b8	8b 4c 24 68	 mov	 ecx, DWORD PTR tv156[rsp]
  001bc	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171535
  001c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171536
  001d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  001e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171537
  001ea	ba d5 02 00 00	 mov	 edx, 725		; 000002d5H
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171538
  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 725  :                     charip4 );
; 726  :             return 0;

  001fc	33 c0		 xor	 eax, eax
  001fe	e9 0d 01 00 00	 jmp	 $LN1@unregister
$LN5@unregister:

; 727  :         }
; 728  :     }

  00203	e9 2b fe ff ff	 jmp	 $LN2@unregister
$LN3@unregister:

; 729  :     /* Oh dear, the IPv4 address wasn't registered. */
; 730  :     hinet_ntop( AF_INET, ipaddr4, charip4, sizeof(charip4) );

  00208	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  0020e	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip4$[rsp]
  00216	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  0021e	b9 02 00 00 00	 mov	 ecx, 2
  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 731  :     // HHC03808 "%1d:%04X %s: s: Cannot unregister guest IP address %s"
; 732  :     WRMSG(HHC03808, "W", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00229	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00232	74 12		 je	 SHORT $LN13@unregister
  00234	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00240	89 44 24 6c	 mov	 DWORD PTR tv179[rsp], eax
  00244	eb 08		 jmp	 SHORT $LN14@unregister
$LN13@unregister:
  00246	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN14@unregister:
  0024e	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00257	74 14		 je	 SHORT $LN15@unregister
  00259	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00261	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00265	d1 f8		 sar	 eax, 1
  00267	89 44 24 70	 mov	 DWORD PTR tv185[rsp], eax
  0026b	eb 08		 jmp	 SHORT $LN16@unregister
$LN15@unregister:
  0026d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN16@unregister:
  00275	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0027d	48 83 c0 60	 add	 rax, 96			; 00000060H
  00281	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv172[rsp], rax
  00289	b9 01 00 00 00	 mov	 ecx, 1
  0028e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00294	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip4$[rsp]
  0029c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002a1	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv172[rsp]
  002a9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002ae	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002b6	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002ba	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002bf	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv179[rsp]
  002c3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002c7	8b 4c 24 70	 mov	 ecx, DWORD PTR tv185[rsp]
  002cb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171539
  002d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171540
  002e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171541
  002f9	ba dd 02 00 00	 mov	 edx, 733		; 000002ddH
  002fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171542
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 733  :           charip4 );
; 734  :     return 1;

  0030b	b8 01 00 00 00	 mov	 eax, 1
$LN1@unregister:

; 735  : }

  00310	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00318	48 33 cc	 xor	 rcx, rsp
  0031b	e8 00 00 00 00	 call	 __security_check_cookie
  00320	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  00327	5f		 pop	 rdi
  00328	c3		 ret	 0
unregister_ipv4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 96
tv161 = 100
tv167 = 104
tv190 = 108
tv196 = 112
tv154 = 120
tv183 = 128
charip4$ = 136
__$ArrayPad$ = 184
grp$ = 208
dev$ = 216
ipaddr4$ = 224
register_ipv4 PROC

; 656  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : int i;
; 658  : char charip4[48];
; 659  :     /* Check whether the IPv4 address is already registered. */
; 660  :     for (i = 0; i < OSA_MAXIPV4; i++)

  00028	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00030	eb 0a		 jmp	 SHORT $LN4@register_i
$LN2@register_i:
  00032	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00036	ff c0		 inc	 eax
  00038	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@register_i:
  0003c	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00041	7d 52		 jge	 SHORT $LN3@register_i

; 661  :     {
; 662  :         if (grp->ipaddr4[i].type == IPV4_TYPE_INUSE &&

  00043	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00048	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00050	83 bc c1 dc 00
	00 00 01	 cmp	 DWORD PTR [rcx+rax*8+220], 1
  00058	75 39		 jne	 SHORT $LN8@register_i
  0005a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0005f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00067	48 8d 84 c1 d8
	00 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+216]
  0006f	41 b8 04 00 00
	00		 mov	 r8d, 4
  00075	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  0007d	48 8b c8	 mov	 rcx, rax
  00080	e8 00 00 00 00	 call	 memcmp
  00085	85 c0		 test	 eax, eax
  00087	75 0a		 jne	 SHORT $LN8@register_i

; 663  :             memcmp(grp->ipaddr4[i].addr, ipaddr4, 4) == 0)
; 664  :         {
; 665  :             return 1;

  00089	b8 01 00 00 00	 mov	 eax, 1
  0008e	e9 b3 02 00 00	 jmp	 $LN1@register_i
$LN8@register_i:

; 666  :         }
; 667  :     }

  00093	eb 9d		 jmp	 SHORT $LN2@register_i
$LN3@register_i:

; 668  :     /* Register the previously unknown IPv4 address. */
; 669  :     for (i = 0; i < OSA_MAXIPV4; i++)

  00095	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0009d	eb 0a		 jmp	 SHORT $LN7@register_i
$LN5@register_i:
  0009f	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  000a3	ff c0		 inc	 eax
  000a5	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@register_i:
  000a9	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  000ae	0f 8d 8a 01 00
	00		 jge	 $LN6@register_i

; 670  :     {
; 671  :         if (grp->ipaddr4[i].type == IPV4_TYPE_NONE)

  000b4	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000b9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000c1	83 bc c1 dc 00
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+220], 0
  000c9	0f 85 6a 01 00
	00		 jne	 $LN9@register_i

; 672  :         {
; 673  : #if defined( OPTION_W32_CTCI )
; 674  :             if (tt32_multiple_ip_support())

  000cf	e8 00 00 00 00	 call	 tt32_multiple_ip_support
  000d4	0f b6 c0	 movzx	 eax, al
  000d7	85 c0		 test	 eax, eax
  000d9	74 24		 je	 SHORT $LN10@register_i

; 675  :             {
; 676  :                 if (TT32_AddIPAddr( grp->ttfd, ipaddr4 ) < 0)

  000db	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  000e3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  000eb	8b 88 f8 05 00
	00		 mov	 ecx, DWORD PTR [rax+1528]
  000f1	e8 00 00 00 00	 call	 TT32_AddIPAddr
  000f6	85 c0		 test	 eax, eax
  000f8	7d 05		 jge	 SHORT $LN11@register_i

; 677  :                     break; // (fail)

  000fa	e9 3f 01 00 00	 jmp	 $LN6@register_i
$LN11@register_i:
$LN10@register_i:

; 678  :             }
; 679  : #endif
; 680  :             memcpy(grp->ipaddr4[i].addr, ipaddr4, 4);

  000ff	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00104	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0010c	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  00114	8b 12		 mov	 edx, DWORD PTR [rdx]
  00116	89 94 c1 d8 00
	00 00		 mov	 DWORD PTR [rcx+rax*8+216], edx

; 681  :             grp->ipaddr4[i].type = IPV4_TYPE_INUSE;

  0011d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00122	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0012a	c7 84 c1 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+220], 1

; 682  :             hinet_ntop( AF_INET, ipaddr4, charip4, sizeof(charip4) );

  00135	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  0013b	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip4$[rsp]
  00143	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  0014b	b9 02 00 00 00	 mov	 ecx, 2
  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 683  :             // HHC03805 "%1d:%04X %s: %s: Registered guest IP address %s"
; 684  :             WRMSG(HHC03805, "I", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00156	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0015f	74 12		 je	 SHORT $LN13@register_i
  00161	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00169	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0016d	89 44 24 64	 mov	 DWORD PTR tv161[rsp], eax
  00171	eb 08		 jmp	 SHORT $LN14@register_i
$LN13@register_i:
  00173	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN14@register_i:
  0017b	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00184	74 14		 je	 SHORT $LN15@register_i
  00186	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0018e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00192	d1 f8		 sar	 eax, 1
  00194	89 44 24 68	 mov	 DWORD PTR tv167[rsp], eax
  00198	eb 08		 jmp	 SHORT $LN16@register_i
$LN15@register_i:
  0019a	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN16@register_i:
  001a2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  001aa	48 83 c0 60	 add	 rax, 96			; 00000060H
  001ae	48 89 44 24 78	 mov	 QWORD PTR tv154[rsp], rax
  001b3	b9 01 00 00 00	 mov	 ecx, 1
  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001be	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip4$[rsp]
  001c6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001cb	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv154[rsp]
  001d0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001d5	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001dd	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001e1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001e6	8b 4c 24 64	 mov	 ecx, DWORD PTR tv161[rsp]
  001ea	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ee	8b 4c 24 68	 mov	 ecx, DWORD PTR tv167[rsp]
  001f2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171511
  001fd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171512
  00209	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00213	41 b9 03 00 00
	00		 mov	 r9d, 3
  00219	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171513
  00220	ba ad 02 00 00	 mov	 edx, 685		; 000002adH
  00225	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171514
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 685  :                     charip4 );
; 686  :             return 0;

  00232	33 c0		 xor	 eax, eax
  00234	e9 0d 01 00 00	 jmp	 $LN1@register_i
$LN9@register_i:

; 687  :         }
; 688  :     }

  00239	e9 61 fe ff ff	 jmp	 $LN5@register_i
$LN6@register_i:

; 689  :     /* Oh dear, the table of IPv4 addresses is full. */
; 690  :     hinet_ntop( AF_INET, ipaddr4, charip4, sizeof(charip4) );

  0023e	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  00244	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR charip4$[rsp]
  0024c	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR ipaddr4$[rsp]
  00254	b9 02 00 00 00	 mov	 ecx, 2
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop

; 691  :     // HHC03806 "%1d:%04X %s: %s: Cannot register guest IP address %s"
; 692  :     WRMSG(HHC03806, "E", LCSS_DEVNUM, dev->typname, grp->ttifname,

  0025f	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00268	74 12		 je	 SHORT $LN17@register_i
  0026a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00272	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00276	89 44 24 6c	 mov	 DWORD PTR tv190[rsp], eax
  0027a	eb 08		 jmp	 SHORT $LN18@register_i
$LN17@register_i:
  0027c	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
$LN18@register_i:
  00284	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0028d	74 14		 je	 SHORT $LN19@register_i
  0028f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00297	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0029b	d1 f8		 sar	 eax, 1
  0029d	89 44 24 70	 mov	 DWORD PTR tv196[rsp], eax
  002a1	eb 08		 jmp	 SHORT $LN20@register_i
$LN19@register_i:
  002a3	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv196[rsp], 0
$LN20@register_i:
  002ab	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  002b3	48 83 c0 60	 add	 rax, 96			; 00000060H
  002b7	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv183[rsp], rax
  002bf	b9 01 00 00 00	 mov	 ecx, 1
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ca	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charip4$[rsp]
  002d2	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002d7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv183[rsp]
  002df	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002e4	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002ec	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  002f0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002f5	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv190[rsp]
  002f9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002fd	8b 4c 24 70	 mov	 ecx, DWORD PTR tv196[rsp]
  00301	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171515
  0030c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00311	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171516
  00318	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0031d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00322	41 b9 03 00 00
	00		 mov	 r9d, 3
  00328	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171517
  0032f	ba b5 02 00 00	 mov	 edx, 693		; 000002b5H
  00334	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171518
  0033b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 693  :             charip4 );
; 694  :     return -1;

  00341	b8 ff ff ff ff	 mov	 eax, -1
$LN1@register_i:

; 695  : }

  00346	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0034e	48 33 cc	 xor	 rcx, rsp
  00351	e8 00 00 00 00	 call	 __security_check_cookie
  00356	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0035d	c3		 ret	 0
register_ipv4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv73 = 32
tv75 = 36
major$1 = 40
inter$2 = 44
build$3 = 48
minor$4 = 52
tt32_multiple_ip_support PROC

; 631  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 632  :     static bool didthis = false;       // (only need to do this once)
; 633  :     static bool multiple_ip_support;   // (boolean we're determining)
; 634  : 
; 635  :     if (!didthis)

  00004	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?didthis@?1??tt32_multiple_ip_support@@9@9
  0000b	85 c0		 test	 eax, eax
  0000d	75 66		 jne	 SHORT $LN2@tt32_multi

; 636  :     {
; 637  :         int major, inter, minor, build;
; 638  :         tt32_version_numbers( &major, &inter, &minor, &build );

  0000f	4c 8d 4c 24 30	 lea	 r9, QWORD PTR build$3[rsp]
  00014	4c 8d 44 24 34	 lea	 r8, QWORD PTR minor$4[rsp]
  00019	48 8d 54 24 2c	 lea	 rdx, QWORD PTR inter$2[rsp]
  0001e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR major$1[rsp]
  00023	e8 00 00 00 00	 call	 tt32_version_numbers

; 639  :         // CTCI-WIN v3.7 or greater?
; 640  :         multiple_ip_support = (((major * 100) + inter) >= 307);

  00028	6b 44 24 28 64	 imul	 eax, DWORD PTR major$1[rsp], 100 ; 00000064H
  0002d	03 44 24 2c	 add	 eax, DWORD PTR inter$2[rsp]
  00031	3d 33 01 00 00	 cmp	 eax, 307		; 00000133H
  00036	7c 0a		 jl	 SHORT $LN4@tt32_multi
  00038	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  00040	eb 08		 jmp	 SHORT $LN5@tt32_multi
$LN4@tt32_multi:
  00042	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN5@tt32_multi:
  0004a	83 7c 24 20 00	 cmp	 DWORD PTR tv73[rsp], 0
  0004f	75 0a		 jne	 SHORT $LN6@tt32_multi
  00051	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
  00059	eb 08		 jmp	 SHORT $LN7@tt32_multi
$LN6@tt32_multi:
  0005b	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
$LN7@tt32_multi:
  00063	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv75[rsp]
  00068	88 05 00 00 00
	00		 mov	 BYTE PTR ?multiple_ip_support@?1??tt32_multiple_ip_support@@9@9, al

; 641  :         didthis = true;

  0006e	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?didthis@?1??tt32_multiple_ip_support@@9@9, 1
$LN2@tt32_multi:

; 642  :     }
; 643  :     return multiple_ip_support;

  00075	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?multiple_ip_support@?1??tt32_multiple_ip_support@@9@9

; 644  : }

  0007c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00080	c3		 ret	 0
tt32_multiple_ip_support ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 32
mac$ = 64
type$ = 72
grp$ = 80
validate_mac PROC

; 595  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 596  : int i;  /* Utility variable */
; 597  : 
; 598  :     /* Always accept broadcast frames */
; 599  :     /* Search for all FFs             */
; 600  : 
; 601  :     for(i=0;i<IFHWADDRLEN;i++)

  00012	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0001a	eb 0a		 jmp	 SHORT $LN4@validate_m
$LN2@validate_m:
  0001c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00020	ff c0		 inc	 eax
  00022	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@validate_m:
  00026	83 7c 24 20 06	 cmp	 DWORD PTR i$[rsp], 6
  0002b	7d 19		 jge	 SHORT $LN3@validate_m

; 602  :     {
; 603  :        if(mac[i]!=0xff) break;

  0002d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR mac$[rsp]
  00037	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0003b	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  00040	74 02		 je	 SHORT $LN8@validate_m
  00042	eb 02		 jmp	 SHORT $LN3@validate_m
$LN8@validate_m:

; 604  :     }

  00044	eb d6		 jmp	 SHORT $LN2@validate_m
$LN3@validate_m:

; 605  :     /* If we reached end of MAC address, all FF then it is a broadcast */
; 606  :     /* Return it is a broadcast unless broadcast isn't sought for      */
; 607  :     /* unless the interface is in promiscuous mode                     */
; 608  : 
; 609  :     if(i==(IFHWADDRLEN)) return (MAC_TYPE_BRDCST & type) | grp->promisc;

  00046	83 7c 24 20 06	 cmp	 DWORD PTR i$[rsp], 6
  0004b	75 17		 jne	 SHORT $LN9@validate_m
  0004d	8b 44 24 48	 mov	 eax, DWORD PTR type$[rsp]
  00051	83 e0 01	 and	 eax, 1
  00054	48 8b 4c 24 50	 mov	 rcx, QWORD PTR grp$[rsp]
  00059	0b 81 d8 05 00
	00		 or	 eax, DWORD PTR [rcx+1496]
  0005f	e9 9b 00 00 00	 jmp	 $LN1@validate_m
$LN9@validate_m:

; 610  : 
; 611  :     /* Find a matching MAC (Unicast or Multicast) */
; 612  :     for(i = 0; i < OSA_MAXMAC; i++)

  00064	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0006c	eb 0a		 jmp	 SHORT $LN7@validate_m
$LN5@validate_m:
  0006e	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00072	ff c0		 inc	 eax
  00074	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@validate_m:
  00078	83 7c 24 20 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  0007d	7d 75		 jge	 SHORT $LN6@validate_m

; 613  :     {
; 614  :         /* Find a type matching the search mask with a matching MAC addr */
; 615  :         if((grp->mac[i].type & type) && !memcmp(grp->mac[i].addr,mac,IFHWADDRLEN))

  0007f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00084	48 6b c0 0c	 imul	 rax, rax, 12
  00088	48 8b 4c 24 50	 mov	 rcx, QWORD PTR grp$[rsp]
  0008d	8b 54 24 48	 mov	 edx, DWORD PTR type$[rsp]
  00091	8b 84 01 60 04
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1120]
  00098	23 c2		 and	 eax, edx
  0009a	85 c0		 test	 eax, eax
  0009c	74 51		 je	 SHORT $LN10@validate_m
  0009e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000a3	48 6b c0 0c	 imul	 rax, rax, 12
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR grp$[rsp]
  000ac	48 8d 84 01 58
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1112]
  000b4	41 b8 06 00 00
	00		 mov	 r8d, 6
  000ba	48 8b 54 24 40	 mov	 rdx, QWORD PTR mac$[rsp]
  000bf	48 8b c8	 mov	 rcx, rax
  000c2	e8 00 00 00 00	 call	 memcmp
  000c7	85 c0		 test	 eax, eax
  000c9	75 24		 jne	 SHORT $LN10@validate_m

; 616  :             return grp->mac[i].type | grp->promisc;

  000cb	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000d0	48 6b c0 0c	 imul	 rax, rax, 12
  000d4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR grp$[rsp]
  000d9	48 8b 54 24 50	 mov	 rdx, QWORD PTR grp$[rsp]
  000de	8b 92 d8 05 00
	00		 mov	 edx, DWORD PTR [rdx+1496]
  000e4	8b 84 01 60 04
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1120]
  000eb	0b c2		 or	 eax, edx
  000ed	eb 10		 jmp	 SHORT $LN1@validate_m
$LN10@validate_m:

; 617  :     }

  000ef	e9 7a ff ff ff	 jmp	 $LN5@validate_m
$LN6@validate_m:

; 618  : 
; 619  :     /* Not match found - but accept it if the interface is in promiscuous mode */
; 620  :     /* Otherwise, ignore the frame                                             */
; 621  : 
; 622  :     return grp->promisc;

  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR grp$[rsp]
  000f9	8b 80 d8 05 00
	00		 mov	 eax, DWORD PTR [rax+1496]
$LN1@validate_m:

; 623  : }

  000ff	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00103	c3		 ret	 0
validate_mac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 0
grp$ = 32
unregister_all_mac PROC

; 578  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 10	 sub	 rsp, 16

; 579  : int i;
; 580  :     for(i = 0; i < OSA_MAXMAC; i++)

  0000a	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00011	eb 08		 jmp	 SHORT $LN4@unregister
$LN2@unregister:
  00013	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00016	ff c0		 inc	 eax
  00018	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@unregister:
  0001b	83 3c 24 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  0001f	7d 3b		 jge	 SHORT $LN3@unregister

; 581  :     {
; 582  :         grp->mac[i].type = MAC_TYPE_NONE;

  00021	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00025	48 6b c0 0c	 imul	 rax, rax, 12
  00029	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  0002e	c7 84 01 60 04
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+1120], 0

; 583  :         memset(grp->mac[i].addr, 0, IFHWADDRLEN);

  00039	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0003d	48 6b c0 0c	 imul	 rax, rax, 12
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  00046	48 8d 84 01 58
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1112]
  0004e	48 8b f8	 mov	 rdi, rax
  00051	33 c0		 xor	 eax, eax
  00053	b9 06 00 00 00	 mov	 ecx, 6
  00058	f3 aa		 rep stosb

; 584  :     }

  0005a	eb b7		 jmp	 SHORT $LN2@unregister
$LN3@unregister:

; 585  :     return MAC_TYPE_NONE;

  0005c	33 c0		 xor	 eax, eax

; 586  : }

  0005e	48 83 c4 10	 add	 rsp, 16
  00062	5f		 pop	 rdi
  00063	c3		 ret	 0
unregister_all_mac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 96
tv166 = 100
tv172 = 104
tv220 = 108
tv226 = 112
tv159 = 120
tv213 = 128
charmac$ = 136
__$ArrayPad$ = 160
grp$ = 192
dev$ = 200
mac$ = 208
type$ = 216
warnmsg$ = 224
unregister_mac PROC

; 538  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec b0 00
	00 00		 sub	 rsp, 176		; 000000b0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@unregister:

; 539  : int i;
; 540  : char charmac[24];
; 541  : UNREFERENCED(type);

  0002e	33 c0		 xor	 eax, eax
  00030	85 c0		 test	 eax, eax
  00032	75 fa		 jne	 SHORT $LN4@unregister

; 542  :     /* Check whether the MAC address is registered. */
; 543  :     for (i = 0; i < OSA_MAXMAC; i++)

  00034	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0003c	eb 0a		 jmp	 SHORT $LN7@unregister
$LN5@unregister:
  0003e	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00042	ff c0		 inc	 eax
  00044	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@unregister:
  00048	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  0004d	0f 8d 31 02 00
	00		 jge	 $LN6@unregister

; 544  :     {
; 545  :         if (grp->mac[i].type &&

  00053	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00058	48 6b c0 0c	 imul	 rax, rax, 12
  0005c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00064	83 bc 01 60 04
	00 00 00	 cmp	 DWORD PTR [rcx+rax+1120], 0
  0006c	0f 84 0d 02 00
	00		 je	 $LN8@unregister
  00072	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00077	48 6b c0 0c	 imul	 rax, rax, 12
  0007b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00083	48 8d 84 01 58
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1112]
  0008b	41 b8 06 00 00
	00		 mov	 r8d, 6
  00091	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR mac$[rsp]
  00099	48 8b c8	 mov	 rcx, rax
  0009c	e8 00 00 00 00	 call	 memcmp
  000a1	85 c0		 test	 eax, eax
  000a3	0f 85 d6 01 00
	00		 jne	 $LN8@unregister

; 546  :             memcmp(grp->mac[i].addr, mac, IFHWADDRLEN) == 0)
; 547  :         {
; 548  :             grp->mac[i].type = MAC_TYPE_NONE;

  000a9	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000ae	48 6b c0 0c	 imul	 rax, rax, 12
  000b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000ba	c7 84 01 60 04
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax+1120], 0

; 549  :             memset(grp->mac[i].addr, 0, IFHWADDRLEN);

  000c5	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000ca	48 6b c0 0c	 imul	 rax, rax, 12
  000ce	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000d6	48 8d 84 01 58
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1112]
  000de	48 8b f8	 mov	 rdi, rax
  000e1	33 c0		 xor	 eax, eax
  000e3	b9 06 00 00 00	 mov	 ecx, 6
  000e8	f3 aa		 rep stosb

; 550  :             MSGBUF( charmac,

  000ea	b8 01 00 00 00	 mov	 eax, 1
  000ef	48 6b c0 05	 imul	 rax, rax, 5
  000f3	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR mac$[rsp]
  000fb	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ff	b9 01 00 00 00	 mov	 ecx, 1
  00104	48 6b c9 04	 imul	 rcx, rcx, 4
  00108	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR mac$[rsp]
  00110	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00114	ba 01 00 00 00	 mov	 edx, 1
  00119	48 6b d2 03	 imul	 rdx, rdx, 3
  0011d	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR mac$[rsp]
  00125	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00129	bf 01 00 00 00	 mov	 edi, 1
  0012e	48 6b ff 02	 imul	 rdi, rdi, 2
  00132	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR mac$[rsp]
  0013a	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  0013f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00145	4d 6b c0 01	 imul	 r8, r8, 1
  00149	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR mac$[rsp]
  00151	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00156	41 b9 01 00 00
	00		 mov	 r9d, 1
  0015c	4d 6b c9 00	 imul	 r9, r9, 0
  00160	4c 8b 94 24 d0
	00 00 00	 mov	 r10, QWORD PTR mac$[rsp]
  00168	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  0016d	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00171	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00175	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00179	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  0017d	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  00182	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171443
  00189	ba 18 00 00 00	 mov	 edx, 24
  0018e	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 551  :                       "%02x:%02x:%02x:%02x:%02x:%02x",
; 552  :                       mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] );
; 553  :             // HHC03803 "%1d:%04X %s: %s: Unregistered guest MAC address %s"
; 554  :             WRMSG(HHC03803, "I", LCSS_DEVNUM, dev->typname, grp->ttifname,

  0019c	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001a5	74 12		 je	 SHORT $LN11@unregister
  001a7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001af	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001b3	89 44 24 64	 mov	 DWORD PTR tv166[rsp], eax
  001b7	eb 08		 jmp	 SHORT $LN12@unregister
$LN11@unregister:
  001b9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
$LN12@unregister:
  001c1	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ca	74 14		 je	 SHORT $LN13@unregister
  001cc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d4	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001d8	d1 f8		 sar	 eax, 1
  001da	89 44 24 68	 mov	 DWORD PTR tv172[rsp], eax
  001de	eb 08		 jmp	 SHORT $LN14@unregister
$LN13@unregister:
  001e0	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN14@unregister:
  001e8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  001f0	48 83 c0 60	 add	 rax, 96			; 00000060H
  001f4	48 89 44 24 78	 mov	 QWORD PTR tv159[rsp], rax
  001f9	b9 01 00 00 00	 mov	 ecx, 1
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00204	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  0020c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00211	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv159[rsp]
  00216	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0021b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00223	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00227	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0022c	8b 4c 24 64	 mov	 ecx, DWORD PTR tv166[rsp]
  00230	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00234	8b 4c 24 68	 mov	 ecx, DWORD PTR tv172[rsp]
  00238	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0023c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171444
  00243	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00248	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171445
  0024f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00254	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00259	41 b9 03 00 00
	00		 mov	 r9d, 3
  0025f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171446
  00266	ba 2b 02 00 00	 mov	 edx, 555		; 0000022bH
  0026b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171447
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 555  :                       charmac );
; 556  :             return 0;

  00278	33 c0		 xor	 eax, eax
  0027a	e9 ae 01 00 00	 jmp	 $LN1@unregister
$LN8@unregister:

; 557  :         }
; 558  :     }

  0027f	e9 ba fd ff ff	 jmp	 $LN5@unregister
$LN6@unregister:

; 559  :     /* Oh dear, the MAC address wasn't registered. */
; 560  :     if (warnmsg)

  00284	0f b6 84 24 e0
	00 00 00	 movzx	 eax, BYTE PTR warnmsg$[rsp]
  0028c	85 c0		 test	 eax, eax
  0028e	0f 84 94 01 00
	00		 je	 $LN9@unregister

; 561  :     {
; 562  :         MSGBUF( charmac,

  00294	b8 01 00 00 00	 mov	 eax, 1
  00299	48 6b c0 05	 imul	 rax, rax, 5
  0029d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR mac$[rsp]
  002a5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002a9	b9 01 00 00 00	 mov	 ecx, 1
  002ae	48 6b c9 04	 imul	 rcx, rcx, 4
  002b2	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR mac$[rsp]
  002ba	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002be	ba 01 00 00 00	 mov	 edx, 1
  002c3	48 6b d2 03	 imul	 rdx, rdx, 3
  002c7	48 8b bc 24 d0
	00 00 00	 mov	 rdi, QWORD PTR mac$[rsp]
  002cf	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  002d3	bf 01 00 00 00	 mov	 edi, 1
  002d8	48 6b ff 02	 imul	 rdi, rdi, 2
  002dc	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR mac$[rsp]
  002e4	41 0f b6 3c 38	 movzx	 edi, BYTE PTR [r8+rdi]
  002e9	41 b8 01 00 00
	00		 mov	 r8d, 1
  002ef	4d 6b c0 01	 imul	 r8, r8, 1
  002f3	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR mac$[rsp]
  002fb	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00300	41 b9 01 00 00
	00		 mov	 r9d, 1
  00306	4d 6b c9 00	 imul	 r9, r9, 0
  0030a	4c 8b 94 24 d0
	00 00 00	 mov	 r10, QWORD PTR mac$[rsp]
  00312	47 0f b6 0c 0a	 movzx	 r9d, BYTE PTR [r10+r9]
  00317	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0031b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0031f	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00323	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  00327	44 89 44 24 20	 mov	 DWORD PTR [rsp+32], r8d
  0032c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171449
  00333	ba 18 00 00 00	 mov	 edx, 24
  00338	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 563  :                   "%02x:%02x:%02x:%02x:%02x:%02x",
; 564  :                   mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] );
; 565  :         // HHC03804 "%1d:%04X %s: %s: Cannot unregister guest MAC address %s"
; 566  :         WRMSG(HHC03804, "W", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00346	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0034f	74 12		 je	 SHORT $LN15@unregister
  00351	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00359	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0035d	89 44 24 6c	 mov	 DWORD PTR tv220[rsp], eax
  00361	eb 08		 jmp	 SHORT $LN16@unregister
$LN15@unregister:
  00363	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv220[rsp], 0
$LN16@unregister:
  0036b	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00374	74 14		 je	 SHORT $LN17@unregister
  00376	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0037e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00382	d1 f8		 sar	 eax, 1
  00384	89 44 24 70	 mov	 DWORD PTR tv226[rsp], eax
  00388	eb 08		 jmp	 SHORT $LN18@unregister
$LN17@unregister:
  0038a	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv226[rsp], 0
$LN18@unregister:
  00392	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0039a	48 83 c0 60	 add	 rax, 96			; 00000060H
  0039e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv213[rsp], rax
  003a6	b9 01 00 00 00	 mov	 ecx, 1
  003ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003b1	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  003b9	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003be	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv213[rsp]
  003c6	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003cb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d3	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  003d7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003dc	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv220[rsp]
  003e0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003e4	8b 4c 24 70	 mov	 ecx, DWORD PTR tv226[rsp]
  003e8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171450
  003f3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171451
  003ff	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00404	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00409	41 b9 03 00 00
	00		 mov	 r9d, 3
  0040f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171452
  00416	ba 37 02 00 00	 mov	 edx, 567		; 00000237H
  0041b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171453
  00422	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@unregister:

; 567  :                   charmac );
; 568  :     }
; 569  :     return 1;

  00428	b8 01 00 00 00	 mov	 eax, 1
$LN1@unregister:

; 570  : }

  0042d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00435	48 33 cc	 xor	 rcx, rsp
  00438	e8 00 00 00 00	 call	 __security_check_cookie
  0043d	48 81 c4 b0 00
	00 00		 add	 rsp, 176		; 000000b0H
  00444	5f		 pop	 rdi
  00445	c3		 ret	 0
unregister_mac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 96
tv176 = 100
tv182 = 104
tv228 = 108
tv234 = 112
tv169 = 120
tv221 = 128
charmac$ = 136
__$ArrayPad$ = 160
grp$ = 208
dev$ = 216
mac$ = 224
type$ = 232
register_mac PROC

; 492  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00024	48 33 c4	 xor	 rax, rsp
  00027	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 493  : int i;
; 494  : char charmac[24];
; 495  : 
; 496  :     /* Check whether the MAC address is already registered. */
; 497  :     for (i = 0; i < OSA_MAXMAC; i++)

  0002f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00037	eb 0a		 jmp	 SHORT $LN4@register_m
$LN2@register_m:
  00039	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0003d	ff c0		 inc	 eax
  0003f	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@register_m:
  00043	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00048	7d 5a		 jge	 SHORT $LN3@register_m

; 498  :     {
; 499  :         if (grp->mac[i].type &&

  0004a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0004f	48 6b c0 0c	 imul	 rax, rax, 12
  00053	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0005b	83 bc 01 60 04
	00 00 00	 cmp	 DWORD PTR [rcx+rax+1120], 0
  00063	74 3d		 je	 SHORT $LN8@register_m
  00065	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0006a	48 6b c0 0c	 imul	 rax, rax, 12
  0006e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00076	48 8d 84 01 58
	04 00 00	 lea	 rax, QWORD PTR [rcx+rax+1112]
  0007e	41 b8 06 00 00
	00		 mov	 r8d, 6
  00084	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR mac$[rsp]
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	e8 00 00 00 00	 call	 memcmp
  00094	85 c0		 test	 eax, eax
  00096	75 0a		 jne	 SHORT $LN8@register_m

; 500  :             memcmp(grp->mac[i].addr, mac, IFHWADDRLEN) == 0)
; 501  :         {
; 502  :             return 1;

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	e9 ba 03 00 00	 jmp	 $LN1@register_m
$LN8@register_m:

; 503  :         }
; 504  :     }

  000a2	eb 95		 jmp	 SHORT $LN2@register_m
$LN3@register_m:

; 505  :     /* Register the previously unknown MAC address. */
; 506  :     for (i = 0; i < OSA_MAXMAC; i++)

  000a4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ac	eb 0a		 jmp	 SHORT $LN7@register_m
$LN5@register_m:
  000ae	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  000b2	ff c0		 inc	 eax
  000b4	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@register_m:
  000b8	83 7c 24 60 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  000bd	0f 8d 00 02 00
	00		 jge	 $LN6@register_m

; 507  :     {
; 508  :         if (!grp->mac[i].type)

  000c3	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000c8	48 6b c0 0c	 imul	 rax, rax, 12
  000cc	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000d4	83 bc 01 60 04
	00 00 00	 cmp	 DWORD PTR [rcx+rax+1120], 0
  000dc	0f 85 dc 01 00
	00		 jne	 $LN9@register_m

; 509  :         {
; 510  :             memcpy(grp->mac[i].addr, mac, IFHWADDRLEN);

  000e2	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000e7	48 6b c0 0c	 imul	 rax, rax, 12
  000eb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  000f3	48 8d bc 01 58
	04 00 00	 lea	 rdi, QWORD PTR [rcx+rax+1112]
  000fb	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR mac$[rsp]
  00103	b9 06 00 00 00	 mov	 ecx, 6
  00108	f3 a4		 rep movsb

; 511  :             grp->mac[i].type = type;

  0010a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0010f	48 6b c0 0c	 imul	 rax, rax, 12
  00113	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0011b	8b 94 24 e8 00
	00 00		 mov	 edx, DWORD PTR type$[rsp]
  00122	89 94 01 60 04
	00 00		 mov	 DWORD PTR [rcx+rax+1120], edx

; 512  :             MSGBUF( charmac,

  00129	b8 01 00 00 00	 mov	 eax, 1
  0012e	48 6b c0 05	 imul	 rax, rax, 5
  00132	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR mac$[rsp]
  0013a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0013e	b9 01 00 00 00	 mov	 ecx, 1
  00143	48 6b c9 04	 imul	 rcx, rcx, 4
  00147	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR mac$[rsp]
  0014f	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00153	ba 01 00 00 00	 mov	 edx, 1
  00158	48 6b d2 03	 imul	 rdx, rdx, 3
  0015c	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR mac$[rsp]
  00164	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00168	bf 01 00 00 00	 mov	 edi, 1
  0016d	48 6b ff 02	 imul	 rdi, rdi, 2
  00171	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR mac$[rsp]
  00179	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  0017d	be 01 00 00 00	 mov	 esi, 1
  00182	48 6b f6 01	 imul	 rsi, rsi, 1
  00186	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR mac$[rsp]
  0018e	41 0f b6 34 30	 movzx	 esi, BYTE PTR [r8+rsi]
  00193	41 b8 01 00 00
	00		 mov	 r8d, 1
  00199	4d 6b c0 00	 imul	 r8, r8, 0
  0019d	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR mac$[rsp]
  001a5	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  001aa	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  001ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b2	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  001b6	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  001ba	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  001be	45 8b c8	 mov	 r9d, r8d
  001c1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171412
  001c8	ba 18 00 00 00	 mov	 edx, 24
  001cd	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 513  :                       "%02x:%02x:%02x:%02x:%02x:%02x",
; 514  :                       mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] );
; 515  :             // HHC03801 "%1d:%04X %s: %s: Register guest MAC address %s"
; 516  :             WRMSG(HHC03801, "I", LCSS_DEVNUM, dev->typname, grp->ttifname,

  001db	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001e4	74 12		 je	 SHORT $LN11@register_m
  001e6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ee	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001f2	89 44 24 64	 mov	 DWORD PTR tv176[rsp], eax
  001f6	eb 08		 jmp	 SHORT $LN12@register_m
$LN11@register_m:
  001f8	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
$LN12@register_m:
  00200	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00209	74 14		 je	 SHORT $LN13@register_m
  0020b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00213	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00217	d1 f8		 sar	 eax, 1
  00219	89 44 24 68	 mov	 DWORD PTR tv182[rsp], eax
  0021d	eb 08		 jmp	 SHORT $LN14@register_m
$LN13@register_m:
  0021f	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
$LN14@register_m:
  00227	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0022f	48 83 c0 60	 add	 rax, 96			; 00000060H
  00233	48 89 44 24 78	 mov	 QWORD PTR tv169[rsp], rax
  00238	b9 01 00 00 00	 mov	 ecx, 1
  0023d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00243	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  0024b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00250	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv169[rsp]
  00255	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0025a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00262	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00266	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0026b	8b 4c 24 64	 mov	 ecx, DWORD PTR tv176[rsp]
  0026f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00273	8b 4c 24 68	 mov	 ecx, DWORD PTR tv182[rsp]
  00277	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0027b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171413
  00282	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171414
  0028e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00293	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00298	41 b9 03 00 00
	00		 mov	 r9d, 3
  0029e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171415
  002a5	ba 05 02 00 00	 mov	 edx, 517		; 00000205H
  002aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171416
  002b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 517  :                       charmac );
; 518  :             return 0;

  002b7	33 c0		 xor	 eax, eax
  002b9	e9 9e 01 00 00	 jmp	 $LN1@register_m
$LN9@register_m:

; 519  :         }
; 520  :     }

  002be	e9 eb fd ff ff	 jmp	 $LN5@register_m
$LN6@register_m:

; 521  :     /* Oh dear, the MAC address table is full. */
; 522  :     MSGBUF( charmac,

  002c3	b8 01 00 00 00	 mov	 eax, 1
  002c8	48 6b c0 05	 imul	 rax, rax, 5
  002cc	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR mac$[rsp]
  002d4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  002d8	b9 01 00 00 00	 mov	 ecx, 1
  002dd	48 6b c9 04	 imul	 rcx, rcx, 4
  002e1	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR mac$[rsp]
  002e9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  002ed	ba 01 00 00 00	 mov	 edx, 1
  002f2	48 6b d2 03	 imul	 rdx, rdx, 3
  002f6	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR mac$[rsp]
  002fe	0f b6 14 17	 movzx	 edx, BYTE PTR [rdi+rdx]
  00302	bf 01 00 00 00	 mov	 edi, 1
  00307	48 6b ff 02	 imul	 rdi, rdi, 2
  0030b	48 8b b4 24 e0
	00 00 00	 mov	 rsi, QWORD PTR mac$[rsp]
  00313	0f b6 3c 3e	 movzx	 edi, BYTE PTR [rsi+rdi]
  00317	be 01 00 00 00	 mov	 esi, 1
  0031c	48 6b f6 01	 imul	 rsi, rsi, 1
  00320	4c 8b 84 24 e0
	00 00 00	 mov	 r8, QWORD PTR mac$[rsp]
  00328	41 0f b6 34 30	 movzx	 esi, BYTE PTR [r8+rsi]
  0032d	41 b8 01 00 00
	00		 mov	 r8d, 1
  00333	4d 6b c0 00	 imul	 r8, r8, 0
  00337	4c 8b 8c 24 e0
	00 00 00	 mov	 r9, QWORD PTR mac$[rsp]
  0033f	47 0f b6 04 01	 movzx	 r8d, BYTE PTR [r9+r8]
  00344	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00348	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0034c	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00350	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  00354	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00358	45 8b c8	 mov	 r9d, r8d
  0035b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171417
  00362	ba 18 00 00 00	 mov	 edx, 24
  00367	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  0036f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 523  :               "%02x:%02x:%02x:%02x:%02x:%02x",
; 524  :               mac[0], mac[1], mac[2], mac[3], mac[4], mac[5] );
; 525  :     // HHC03802 "%1d:%04X %s: %s: Cannot register guest MAC address %s"
; 526  :     WRMSG(HHC03802, "E", LCSS_DEVNUM, dev->typname, grp->ttifname,

  00375	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0037e	74 12		 je	 SHORT $LN15@register_m
  00380	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00388	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0038c	89 44 24 6c	 mov	 DWORD PTR tv228[rsp], eax
  00390	eb 08		 jmp	 SHORT $LN16@register_m
$LN15@register_m:
  00392	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN16@register_m:
  0039a	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003a3	74 14		 je	 SHORT $LN17@register_m
  003a5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003ad	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  003b1	d1 f8		 sar	 eax, 1
  003b3	89 44 24 70	 mov	 DWORD PTR tv234[rsp], eax
  003b7	eb 08		 jmp	 SHORT $LN18@register_m
$LN17@register_m:
  003b9	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
$LN18@register_m:
  003c1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  003c9	48 83 c0 60	 add	 rax, 96			; 00000060H
  003cd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv221[rsp], rax
  003d5	b9 01 00 00 00	 mov	 ecx, 1
  003da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e0	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR charmac$[rsp]
  003e8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv221[rsp]
  003f5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  003fa	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00402	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00406	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0040b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv228[rsp]
  0040f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00413	8b 4c 24 70	 mov	 ecx, DWORD PTR tv234[rsp]
  00417	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0041b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171418
  00422	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00427	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171419
  0042e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00433	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00438	41 b9 03 00 00
	00		 mov	 r9d, 3
  0043e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171420
  00445	ba 0f 02 00 00	 mov	 edx, 527		; 0000020fH
  0044a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171421
  00451	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 527  :               charmac );
; 528  :     return -1;

  00457	b8 ff ff ff ff	 mov	 eax, -1
$LN1@register_m:

; 529  : }

  0045c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00464	48 33 cc	 xor	 rcx, rsp
  00467	e8 00 00 00 00	 call	 __security_check_cookie
  0046c	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00473	5f		 pop	 rdi
  00474	5e		 pop	 rsi
  00475	c3		 ret	 0
register_mac ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
dsci$1 = 32
alsi$2 = 40
dev$ = 64
bits$ = 72
set_dsci PROC

; 457  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 458  :     if (dev->qdio.dsci)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 83 b8 70 1b
	00 00 00	 cmp	 QWORD PTR [rax+7024], 0
  0001a	0f 84 d6 00 00
	00		 je	 $LN2@set_dsci

; 459  :     {
; 460  :         BYTE* dsci = dev->mainstor + dev->qdio.dsci;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00025	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00031	48 03 81 70 1b
	00 00		 add	 rax, QWORD PTR [rcx+7024]
  00038	48 89 44 24 20	 mov	 QWORD PTR dsci$1[rsp], rax

; 461  :         BYTE* alsi = dev->mainstor + dev->qdio.alsi;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00042	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004e	48 03 81 68 1b
	00 00		 add	 rax, QWORD PTR [rcx+7016]
  00055	48 89 44 24 28	 mov	 QWORD PTR alsi$2[rsp], rax

; 462  : 
; 463  :         obtain_lock( &sysblk.mainlock );

  0005a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00061	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171390
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 464  :         {
; 465  :             *dsci |= bits;

  00077	0f b6 44 24 48	 movzx	 eax, BYTE PTR bits$[rsp]
  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dsci$1[rsp]
  00081	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00084	0b c8		 or	 ecx, eax
  00086	8b c1		 mov	 eax, ecx
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dsci$1[rsp]
  0008d	88 01		 mov	 BYTE PTR [rcx], al

; 466  :             ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.dsci, (STORKEY_REF | STORKEY_CHANGE) );

  0008f	41 b0 06	 mov	 r8b, 6
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00097	48 8b 90 70 1b
	00 00		 mov	 rdx, QWORD PTR [rax+7024]
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000a3	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 467  : 
; 468  :             *alsi |= bits;

  000a8	0f b6 44 24 48	 movzx	 eax, BYTE PTR bits$[rsp]
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR alsi$2[rsp]
  000b2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000b5	0b c8		 or	 ecx, eax
  000b7	8b c1		 mov	 eax, ecx
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR alsi$2[rsp]
  000be	88 01		 mov	 BYTE PTR [rcx], al

; 469  :             ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.alsi, (STORKEY_REF | STORKEY_CHANGE) );

  000c0	41 b0 06	 mov	 r8b, 6
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	48 8b 90 68 1b
	00 00		 mov	 rdx, QWORD PTR [rax+7016]
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d4	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 470  :         }
; 471  :         release_lock( &sysblk.mainlock );

  000d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e0	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171391
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN2@set_dsci:

; 472  :     }
; 473  : }

  000f6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fa	c3		 ret	 0
set_dsci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
alsi$1 = 32
dev$ = 64
bits$ = 72
set_alsi PROC

; 436  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 437  :     if (dev->qdio.alsi)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 83 b8 68 1b
	00 00 00	 cmp	 QWORD PTR [rax+7016], 0
  0001a	0f 84 88 00 00
	00		 je	 $LN2@set_alsi

; 438  :     {
; 439  :         BYTE* alsi = dev->mainstor + dev->qdio.alsi;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00025	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00031	48 03 81 68 1b
	00 00		 add	 rax, QWORD PTR [rcx+7016]
  00038	48 89 44 24 20	 mov	 QWORD PTR alsi$1[rsp], rax

; 440  : 
; 441  :         obtain_lock( &sysblk.mainlock );

  0003d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00044	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171379
  00051	48 8b c8	 mov	 rcx, rax
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 442  :         {
; 443  :             *alsi |= bits;

  0005a	0f b6 44 24 48	 movzx	 eax, BYTE PTR bits$[rsp]
  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alsi$1[rsp]
  00064	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00067	0b c8		 or	 ecx, eax
  00069	8b c1		 mov	 eax, ecx
  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alsi$1[rsp]
  00070	88 01		 mov	 BYTE PTR [rcx], al

; 444  :             ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.alsi, (STORKEY_REF | STORKEY_CHANGE) );

  00072	41 b0 06	 mov	 r8b, 6
  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0007a	48 8b 90 68 1b
	00 00		 mov	 rdx, QWORD PTR [rax+7016]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00086	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 445  :         }
; 446  :         release_lock( &sysblk.mainlock );

  0008b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00092	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171380
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN2@set_alsi:

; 447  :     }
; 448  : }

  000a8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ac	c3		 ret	 0
set_alsi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
rc$ = 48
addr$ = 80
len$ = 88
key$ = 96
acc$ = 104
dev$ = 112
qeth_storage_access_check_and_update PROC

; 417  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 418  :   int rc;
; 419  :   rc=qeth_storage_access_check(addr,len,key,acc,dev);

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	44 8b 4c 24 68	 mov	 r9d, DWORD PTR acc$[rsp]
  00027	44 8b 44 24 60	 mov	 r8d, DWORD PTR key$[rsp]
  0002c	48 8b 54 24 58	 mov	 rdx, QWORD PTR len$[rsp]
  00031	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00036	e8 00 00 00 00	 call	 qeth_storage_access_check
  0003b	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 420  :   if(rc==0)

  0003f	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  00044	75 1a		 jne	 SHORT $LN2@qeth_stora

; 421  :   {
; 422  :     /* Update the REF/CHANGE flag in the storage key */
; 423  :     ARCH_DEP( or_dev_4K_storage_key )( dev, addr, (acc & (STORKEY_REF | STORKEY_CHANGE)) );

  00046	8b 44 24 68	 mov	 eax, DWORD PTR acc$[rsp]
  0004a	83 e0 06	 and	 eax, 6
  0004d	44 0f b6 c0	 movzx	 r8d, al
  00051	48 8b 54 24 50	 mov	 rdx, QWORD PTR addr$[rsp]
  00056	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0005b	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key
$LN2@qeth_stora:

; 424  :   }
; 425  :   return rc;

  00060	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]

; 426  : }

  00064	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00068	c3		 ret	 0
qeth_storage_access_check_and_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
addr$ = 80
len$ = 88
key$ = 96
acc$ = 104
dev$ = 112
qeth_storage_access_check PROC

; 364  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 365  :   if(addr+len>dev->mainlim)

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0001d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00022	48 03 c8	 add	 rcx, rax
  00025	48 8b c1	 mov	 rax, rcx
  00028	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002d	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  00034	76 3d		 jbe	 SHORT $LN2@qeth_stora

; 366  :   {
; 367  :     DBGTRC(dev,"Address %llx above main storage",addr);

  00036	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0003b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00040	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171334
  00047	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171335
  00058	ba 6f 01 00 00	 mov	 edx, 367		; 0000016fH
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171336
  00064	e8 00 00 00 00	 call	 dbgtrc

; 368  :     return CSW_PROGC;  /* Outside storage */

  00069	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0006e	e9 10 02 00 00	 jmp	 $LN1@qeth_stora
$LN2@qeth_stora:

; 369  :   }
; 370  :   if(dev->orb.flag5 & ORB5_A)     /* Address limit checking enabled ?*/

  00073	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00078	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0007f	83 e0 10	 and	 eax, 16
  00082	85 c0		 test	 eax, eax
  00084	0f 84 06 01 00
	00		 je	 $LN3@qeth_stora

; 371  :   {
; 372  :     if(dev->pmcw.flag5 & PMCW5_LM_LOW)  /* Low address defined ? */

  0008a	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0008f	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00096	83 e0 20	 and	 eax, 32			; 00000020H
  00099	85 c0		 test	 eax, eax
  0009b	74 65		 je	 SHORT $LN4@qeth_stora

; 373  :     {
; 374  :       if(addr<sysblk.addrlimval)

  0009d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a4	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  000ab	48 39 44 24 50	 cmp	 QWORD PTR addr$[rsp], rax
  000b0	73 50		 jae	 SHORT $LN5@qeth_stora

; 375  :       {
; 376  :         DBGTRC(dev,"Address %llx below limit of %llx",addr,sysblk.addrlimval);

  000b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b9	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  000c0	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  000c5	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  000ca	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171340
  000d6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000db	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  000e0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171341
  000e7	ba 78 01 00 00	 mov	 edx, 376		; 00000178H
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171342
  000f3	e8 00 00 00 00	 call	 dbgtrc

; 377  :         return CSW_PROGC;

  000f8	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000fd	e9 81 01 00 00	 jmp	 $LN1@qeth_stora
$LN5@qeth_stora:
$LN4@qeth_stora:

; 378  :       }
; 379  :     }
; 380  :     if(dev->pmcw.flag5 & PMCW5_LM_HIGH) /* High address defined ? */

  00102	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00107	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0010e	83 e0 40	 and	 eax, 64			; 00000040H
  00111	85 c0		 test	 eax, eax
  00113	74 7b		 je	 SHORT $LN6@qeth_stora

; 381  :     {
; 382  :       if((addr+len)>sysblk.addrlimval)

  00115	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0011a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0011f	48 03 c8	 add	 rcx, rax
  00122	48 8b c1	 mov	 rax, rcx
  00125	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012c	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  00133	76 5b		 jbe	 SHORT $LN7@qeth_stora

; 383  :       {
; 384  :         DBGTRC(dev,"Address %llx above limit of %llx",addr+len,sysblk.addrlimval);

  00135	48 8b 44 24 58	 mov	 rax, QWORD PTR len$[rsp]
  0013a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  0013f	48 03 c8	 add	 rcx, rax
  00142	48 8b c1	 mov	 rax, rcx
  00145	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0014c	48 8b 89 60 12
	00 00		 mov	 rcx, QWORD PTR [rcx+4704]
  00153	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00158	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0015d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171345
  00164	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00169	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  0016e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171346
  00175	ba 80 01 00 00	 mov	 edx, 384		; 00000180H
  0017a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171347
  00181	e8 00 00 00 00	 call	 dbgtrc

; 385  :         return CSW_PROGC;

  00186	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0018b	e9 f3 00 00 00	 jmp	 $LN1@qeth_stora
$LN7@qeth_stora:
$LN6@qeth_stora:
$LN3@qeth_stora:

; 386  :       }
; 387  :     }
; 388  :   }
; 389  :   /* key 0 always right */
; 390  :   if(key==0) return 0;

  00190	83 7c 24 60 00	 cmp	 DWORD PTR key$[rsp], 0
  00195	75 07		 jne	 SHORT $LN8@qeth_stora
  00197	33 c0		 xor	 eax, eax
  00199	e9 e5 00 00 00	 jmp	 $LN1@qeth_stora
$LN8@qeth_stora:

; 391  : 
; 392  :   /* This may not be described anywhere - and could be wrong  */
; 393  :   /* But apparently z/VM TC/IP expects Key 14 to allow access to all */
; 394  :   /* including storage frames with key 0.... */
; 395  :   /* and apparently z/OS TCP/IP expects Key 6 to allow access to all */
; 396  :   /* including storage frames with key 0.... */
; 397  :   if((key & 0Xf0)==0xe0) return 0; /* Special case for key 14 ? */

  0019e	8b 44 24 60	 mov	 eax, DWORD PTR key$[rsp]
  001a2	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  001a7	3d e0 00 00 00	 cmp	 eax, 224		; 000000e0H
  001ac	75 07		 jne	 SHORT $LN9@qeth_stora
  001ae	33 c0		 xor	 eax, eax
  001b0	e9 ce 00 00 00	 jmp	 $LN1@qeth_stora
$LN9@qeth_stora:

; 398  :   if((key & 0Xf0)==0x60) return 0; /* Special case for key 6 ? */

  001b5	8b 44 24 60	 mov	 eax, DWORD PTR key$[rsp]
  001b9	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  001be	83 f8 60	 cmp	 eax, 96			; 00000060H
  001c1	75 07		 jne	 SHORT $LN10@qeth_stora
  001c3	33 c0		 xor	 eax, eax
  001c5	e9 b9 00 00 00	 jmp	 $LN1@qeth_stora
$LN10@qeth_stora:

; 399  : 
; 400  :   /* Key match check if keys match we're good */
; 401  :   if((ARCH_DEP( get_dev_4K_storage_key )( dev, addr ) & STORKEY_KEY) == key) return 0;

  001ca	48 8b 54 24 50	 mov	 rdx, QWORD PTR addr$[rsp]
  001cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001d4	e8 00 00 00 00	 call	 s370_get_dev_4K_storage_key
  001d9	0f b6 c0	 movzx	 eax, al
  001dc	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  001e1	3b 44 24 60	 cmp	 eax, DWORD PTR key$[rsp]
  001e5	75 07		 jne	 SHORT $LN11@qeth_stora
  001e7	33 c0		 xor	 eax, eax
  001e9	e9 95 00 00 00	 jmp	 $LN1@qeth_stora
$LN11@qeth_stora:

; 402  : 
; 403  :   /* Ok for fetch (i.e. ref) when key mismatches */
; 404  :   /* (as long as not fetch-protected) */
; 405  :   if(!((ARCH_DEP( get_dev_4K_storage_key )( dev, addr )) & STORKEY_FETCH) && acc==STORKEY_REF) return 0;

  001ee	48 8b 54 24 50	 mov	 rdx, QWORD PTR addr$[rsp]
  001f3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001f8	e8 00 00 00 00	 call	 s370_get_dev_4K_storage_key
  001fd	0f b6 c0	 movzx	 eax, al
  00200	83 e0 08	 and	 eax, 8
  00203	85 c0		 test	 eax, eax
  00205	75 0b		 jne	 SHORT $LN12@qeth_stora
  00207	83 7c 24 68 04	 cmp	 DWORD PTR acc$[rsp], 4
  0020c	75 04		 jne	 SHORT $LN12@qeth_stora
  0020e	33 c0		 xor	 eax, eax
  00210	eb 71		 jmp	 SHORT $LN1@qeth_stora
$LN12@qeth_stora:

; 406  : 
; 407  :   /* Ok for write (i.e. chg) or fetch (i.e. ref) when write allowed even on key mismatch */
; 408  :   /* (i.e. when storage already changed we presume writes are allowed?) */
; 409  :   if(((ARCH_DEP( get_dev_4K_storage_key )( dev, addr )) & STORKEY_CHANGE)) return 0;

  00212	48 8b 54 24 50	 mov	 rdx, QWORD PTR addr$[rsp]
  00217	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0021c	e8 00 00 00 00	 call	 s370_get_dev_4K_storage_key
  00221	0f b6 c0	 movzx	 eax, al
  00224	83 e0 02	 and	 eax, 2
  00227	85 c0		 test	 eax, eax
  00229	74 04		 je	 SHORT $LN13@qeth_stora
  0022b	33 c0		 xor	 eax, eax
  0022d	eb 54		 jmp	 SHORT $LN1@qeth_stora
$LN13@qeth_stora:

; 410  :   DBGTRC(dev,"Key mismatch protection exception : requested key : %x, storage key : %x access type %x",key,ARCH_DEP( get_dev_4K_storage_key )( dev, addr ),acc);

  0022f	48 8b 54 24 50	 mov	 rdx, QWORD PTR addr$[rsp]
  00234	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00239	e8 00 00 00 00	 call	 s370_get_dev_4K_storage_key
  0023e	0f b6 c0	 movzx	 eax, al
  00241	8b 4c 24 68	 mov	 ecx, DWORD PTR acc$[rsp]
  00245	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00249	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0024d	8b 44 24 60	 mov	 eax, DWORD PTR key$[rsp]
  00251	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00255	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG171354
  0025c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00261	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  00266	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171355
  0026d	ba 9a 01 00 00	 mov	 edx, 410		; 0000019aH
  00272	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171356
  00279	e8 00 00 00 00	 call	 dbgtrc

; 411  : 
; 412  :   return CSW_PROTC;

  0027e	b8 10 00 00 00	 mov	 eax, 16
$LN1@qeth_stora:

; 413  : }

  00283	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00287	c3		 ret	 0
qeth_storage_access_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
sig$ = 48
qsig2str PROC

; 335  : static const char* qsig2str( BYTE sig ) {

  00000	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 336  :     static const char* sigstr[] = {
; 337  :     /*0*/ "QDSIG_RESET",
; 338  :     /*1*/ "QDSIG_HALT",
; 339  :     /*2*/ "QDSIG_SYNC",
; 340  :     /*3*/ "QDSIG_READ",
; 341  :     /*4*/ "QDSIG_RDMULT",
; 342  :     /*5*/ "QDSIG_WRIT",
; 343  :     /*6*/ "QDSIG_WRMULT",
; 344  :     /*7*/ "QDSIG_WAKEUP",
; 345  :     }; static char buf[16];
; 346  :     if (sig < _countof( sigstr ))

  00008	0f b6 44 24 30	 movzx	 eax, BYTE PTR sig$[rsp]
  0000d	48 83 f8 08	 cmp	 rax, 8
  00011	73 12		 jae	 SHORT $LN2@qsig2str

; 347  :         return sigstr[ sig ];

  00013	0f b6 44 24 30	 movzx	 eax, BYTE PTR sig$[rsp]
  00018	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?sigstr@?1??qsig2str@@9@9
  0001f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00023	eb 28		 jmp	 SHORT $LN1@qsig2str
$LN2@qsig2str:

; 348  :     MSGBUF(buf,"QDSIG_0x%02X",sig);

  00025	0f b6 44 24 30	 movzx	 eax, BYTE PTR sig$[rsp]
  0002a	44 8b c8	 mov	 r9d, eax
  0002d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG171320
  00034	ba 10 00 00 00	 mov	 edx, 16
  00039	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?buf@?1??qsig2str@@9@9
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 349  :     return buf;

  00046	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?buf@?1??qsig2str@@9@9
$LN1@qsig2str:

; 350  : }

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
qsig2str ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
uChecksum$ = 32
i$ = 36
uTwobytes$ = 40
j$ = 44
uHighhalf$ = 48
pBytePtr$ = 56
$T1 = 64
bPseudoHeader$ = 72
__$ArrayPad$ = 112
pIP6FRM$ = 160
pIcmpHdr$ = 168
iIcmpLen$ = 176
calculate_icmpv6_checksum PROC

; 6726 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 70	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6727 :     BYTE*      pBytePtr;
; 6728 :     int        i,j;
; 6729 :     U16        uTwobytes;            // Two bytes of data
; 6730 :     U32        uHighhalf;            // High-order half of the checksum
; 6731 :     U32        uChecksum;            // The checksum
; 6732 :     BYTE       bPseudoHeader[40];    //  0-15  Source address
; 6733 :                                      // 16-31  Destination address
; 6734 :                                      // 32-35  Upper-layer packet length
; 6735 :                                      // 36-38  zero
; 6736 :                                      //   39   Next Header (i.e. 58 (0x3a))
; 6737 : 
; 6738 :     // Clear the checksum in the ICMP header before calculating the checksum.
; 6739 :     STORE_HW( pIcmpHdr+2, 0x0000 );

  00027	33 c9		 xor	 ecx, ecx
  00029	e8 00 00 00 00	 call	 _byteswap_ushort
  0002e	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  00036	48 83 c1 02	 add	 rcx, 2
  0003a	0f b7 d0	 movzx	 edx, ax
  0003d	e8 00 00 00 00	 call	 store_hw_noswap

; 6740 : 
; 6741 :     // Construct the Psuedo-Header for the checksum calcuation.
; 6742 :     memcpy( bPseudoHeader+0, pIP6FRM->bSrcAddr, 16 );

  00042	48 8d 44 24 48	 lea	 rax, QWORD PTR bPseudoHeader$[rsp]
  00047	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pIP6FRM$[rsp]
  0004f	48 8b f8	 mov	 rdi, rax
  00052	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  00056	b9 10 00 00 00	 mov	 ecx, 16
  0005b	f3 a4		 rep movsb

; 6743 :     memcpy( bPseudoHeader+16, pIP6FRM->bDstAddr, 16 );

  0005d	48 8d 44 24 58	 lea	 rax, QWORD PTR bPseudoHeader$[rsp+16]
  00062	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR pIP6FRM$[rsp]
  0006a	48 8b f8	 mov	 rdi, rax
  0006d	48 8d 71 18	 lea	 rsi, QWORD PTR [rcx+24]
  00071	b9 10 00 00 00	 mov	 ecx, 16
  00076	f3 a4		 rep movsb

; 6744 :     STORE_FW( bPseudoHeader+32, iIcmpLen );

  00078	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR iIcmpLen$[rsp]
  0007f	e8 00 00 00 00	 call	 _byteswap_ulong
  00084	48 8d 4c 24 68	 lea	 rcx, QWORD PTR bPseudoHeader$[rsp+32]
  00089	8b d0		 mov	 edx, eax
  0008b	e8 00 00 00 00	 call	 store_fw_noswap

; 6745 :     for( i = 36; i <= 38; i++ )

  00090	c7 44 24 24 24
	00 00 00	 mov	 DWORD PTR i$[rsp], 36	; 00000024H
  00098	eb 0a		 jmp	 SHORT $LN4@calculate_
$LN2@calculate_:
  0009a	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0009e	ff c0		 inc	 eax
  000a0	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@calculate_:
  000a4	83 7c 24 24 26	 cmp	 DWORD PTR i$[rsp], 38	; 00000026H
  000a9	7f 25		 jg	 SHORT $LN3@calculate_

; 6746 :         bPseudoHeader[i] = 0x00;

  000ab	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  000b0	48 89 44 24 40	 mov	 QWORD PTR $T1[rsp], rax
  000b5	48 83 7c 24 40
	28		 cmp	 QWORD PTR $T1[rsp], 40	; 00000028H
  000bb	73 02		 jae	 SHORT $LN12@calculate_
  000bd	eb 05		 jmp	 SHORT $LN13@calculate_
$LN12@calculate_:
  000bf	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN13@calculate_:
  000c4	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp]
  000c9	c6 44 04 48 00	 mov	 BYTE PTR bPseudoHeader$[rsp+rax], 0
  000ce	eb ca		 jmp	 SHORT $LN2@calculate_
$LN3@calculate_:

; 6747 :     bPseudoHeader[39] = 0x3A;

  000d0	b8 01 00 00 00	 mov	 eax, 1
  000d5	48 6b c0 27	 imul	 rax, rax, 39		; 00000027H
  000d9	c6 44 04 48 3a	 mov	 BYTE PTR bPseudoHeader$[rsp+rax], 58 ; 0000003aH

; 6748 : 
; 6749 :     // Calculate the checksum.
; 6750 :     uChecksum = 0;

  000de	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR uChecksum$[rsp], 0

; 6751 :     for( i = 0; i <= 38; i += 2 )

  000e6	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000ee	eb 0b		 jmp	 SHORT $LN7@calculate_
$LN5@calculate_:
  000f0	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  000f4	83 c0 02	 add	 eax, 2
  000f7	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN7@calculate_:
  000fb	83 7c 24 24 26	 cmp	 DWORD PTR i$[rsp], 38	; 00000026H
  00100	7f 32		 jg	 SHORT $LN6@calculate_

; 6752 :     {
; 6753 :         FETCH_HW( uTwobytes, bPseudoHeader+i );

  00102	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00107	48 8d 44 04 48	 lea	 rax, QWORD PTR bPseudoHeader$[rsp+rax]
  0010c	48 8b c8	 mov	 rcx, rax
  0010f	e8 00 00 00 00	 call	 fetch_hw_noswap
  00114	0f b7 c8	 movzx	 ecx, ax
  00117	e8 00 00 00 00	 call	 _byteswap_ushort
  0011c	66 89 44 24 28	 mov	 WORD PTR uTwobytes$[rsp], ax

; 6754 :         uChecksum += uTwobytes;

  00121	0f b7 44 24 28	 movzx	 eax, WORD PTR uTwobytes$[rsp]
  00126	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  0012a	03 c8		 add	 ecx, eax
  0012c	8b c1		 mov	 eax, ecx
  0012e	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6755 :     }

  00132	eb bc		 jmp	 SHORT $LN5@calculate_
$LN6@calculate_:

; 6756 :     pBytePtr = pIcmpHdr;                   // Point to the ICMPv6 header.

  00134	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR pIcmpHdr$[rsp]
  0013c	48 89 44 24 38	 mov	 QWORD PTR pBytePtr$[rsp], rax

; 6757 :     j = iIcmpLen;                          // Get the length of the

  00141	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR iIcmpLen$[rsp]
  00148	89 44 24 2c	 mov	 DWORD PTR j$[rsp], eax

; 6758 :     j++;                                   // ICMPv6 packet rounded up

  0014c	8b 44 24 2c	 mov	 eax, DWORD PTR j$[rsp]
  00150	ff c0		 inc	 eax
  00152	89 44 24 2c	 mov	 DWORD PTR j$[rsp], eax

; 6759 :     j &= 0xFFFFFFFE;                       // to the next multiple of two.

  00156	8b 44 24 2c	 mov	 eax, DWORD PTR j$[rsp]
  0015a	83 e0 fe	 and	 eax, -2			; fffffffeH
  0015d	89 44 24 2c	 mov	 DWORD PTR j$[rsp], eax

; 6760 :     for( i = 0; i <= j - 2; i += 2 )

  00161	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00169	eb 0b		 jmp	 SHORT $LN10@calculate_
$LN8@calculate_:
  0016b	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  0016f	83 c0 02	 add	 eax, 2
  00172	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN10@calculate_:
  00176	8b 44 24 2c	 mov	 eax, DWORD PTR j$[rsp]
  0017a	83 e8 02	 sub	 eax, 2
  0017d	39 44 24 24	 cmp	 DWORD PTR i$[rsp], eax
  00181	7f 38		 jg	 SHORT $LN9@calculate_

; 6761 :     {
; 6762 :         FETCH_HW( uTwobytes, pBytePtr );

  00183	48 8b 4c 24 38	 mov	 rcx, QWORD PTR pBytePtr$[rsp]
  00188	e8 00 00 00 00	 call	 fetch_hw_noswap
  0018d	0f b7 c8	 movzx	 ecx, ax
  00190	e8 00 00 00 00	 call	 _byteswap_ushort
  00195	66 89 44 24 28	 mov	 WORD PTR uTwobytes$[rsp], ax

; 6763 :         uChecksum += uTwobytes;

  0019a	0f b7 44 24 28	 movzx	 eax, WORD PTR uTwobytes$[rsp]
  0019f	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  001a3	03 c8		 add	 ecx, eax
  001a5	8b c1		 mov	 eax, ecx
  001a7	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6764 :         pBytePtr += 2;

  001ab	48 8b 44 24 38	 mov	 rax, QWORD PTR pBytePtr$[rsp]
  001b0	48 83 c0 02	 add	 rax, 2
  001b4	48 89 44 24 38	 mov	 QWORD PTR pBytePtr$[rsp], rax

; 6765 :     }

  001b9	eb b0		 jmp	 SHORT $LN8@calculate_
$LN9@calculate_:

; 6766 :     uHighhalf = uChecksum >> 16;           // Get the high-order half

  001bb	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001bf	c1 e8 10	 shr	 eax, 16
  001c2	89 44 24 30	 mov	 DWORD PTR uHighhalf$[rsp], eax

; 6767 :                                            // of the checksum value.
; 6768 :     uChecksum &= 0x0000FFFF;               // Get the low-order half.

  001c6	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001ca	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001cf	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6769 :     uChecksum += uHighhalf;                // Add the high-order half

  001d3	8b 44 24 30	 mov	 eax, DWORD PTR uHighhalf$[rsp]
  001d7	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  001db	03 c8		 add	 ecx, eax
  001dd	8b c1		 mov	 eax, ecx
  001df	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6770 :                                            // to the low-order half.
; 6771 :     uHighhalf = uChecksum >> 16;           // Get the high-order half

  001e3	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001e7	c1 e8 10	 shr	 eax, 16
  001ea	89 44 24 30	 mov	 DWORD PTR uHighhalf$[rsp], eax

; 6772 :                                            // of the checksum value again.
; 6773 :     uChecksum &= 0x0000FFFF;               // Get the low-order half.

  001ee	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  001f2	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  001f7	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6774 :     uChecksum += uHighhalf;                // Add the high-order half

  001fb	8b 44 24 30	 mov	 eax, DWORD PTR uHighhalf$[rsp]
  001ff	8b 4c 24 20	 mov	 ecx, DWORD PTR uChecksum$[rsp]
  00203	03 c8		 add	 ecx, eax
  00205	8b c1		 mov	 eax, ecx
  00207	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6775 :                                            // to the low-order half again
; 6776 :                                            // to include any carry.
; 6777 :     uChecksum ^= 0xFFFFFFFF;               // Complement the bits.

  0020b	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  0020f	83 f0 ff	 xor	 eax, -1			; ffffffffH
  00212	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6778 :     uChecksum &= 0x0000FFFF;               // Get a clean checksum.

  00216	8b 44 24 20	 mov	 eax, DWORD PTR uChecksum$[rsp]
  0021a	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0021f	89 44 24 20	 mov	 DWORD PTR uChecksum$[rsp], eax

; 6779 :     uTwobytes = uChecksum;                 // Copy to a two-byte value.

  00223	0f b7 44 24 20	 movzx	 eax, WORD PTR uChecksum$[rsp]
  00228	66 89 44 24 28	 mov	 WORD PTR uTwobytes$[rsp], ax

; 6780 : 
; 6781 :     // Set the checksum in the ICMP header.
; 6782 :     STORE_HW( pIcmpHdr+2, uTwobytes );

  0022d	0f b7 4c 24 28	 movzx	 ecx, WORD PTR uTwobytes$[rsp]
  00232	e8 00 00 00 00	 call	 _byteswap_ushort
  00237	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR pIcmpHdr$[rsp]
  0023f	48 83 c1 02	 add	 rcx, 2
  00243	0f b7 d0	 movzx	 edx, ax
  00246	e8 00 00 00 00	 call	 store_hw_noswap
$LN11@calculate_:

; 6783 : 
; 6784 : }   /* End function  calculate_icmpv6_checksum() */

  0024b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00250	48 33 cc	 xor	 rcx, rsp
  00253	e8 00 00 00 00	 call	 __security_check_cookie
  00258	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  0025f	5f		 pop	 rdi
  00260	5e		 pop	 rsi
  00261	c3		 ret	 0
calculate_icmpv6_checksum ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
sig$ = 32
ip6re_payload_size$ = 36
ip6re$ = 40
ip6re_header_size$ = 48
icmpre$ = 56
ip6re_packet_size$ = 64
icmp$ = 72
bhrre$ = 80
tv317 = 88
solicitednode$ = 96
unspecified$ = 112
__$ArrayPad$ = 128
dev$ = 176
grp$ = 184
ip6$ = 192
process_l3_icmpv6_packet PROC

; 6598 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6599 :     BYTE*      icmp;                // ICMPv6 header
; 6600 :     OSA_BHR*   bhrre;               // Response buffer header
; 6601 :     IP6FRM*    ip6re;               // Response IPv6 header
; 6602 :     BYTE*      icmpre;              // Response ICMPv6 data
; 6603 :     U32        ip6re_packet_size;   // Response IPv6 packet size
; 6604 :     U16        ip6re_header_size;   // Response IPv6 header size
; 6605 :     U16        ip6re_payload_size;  // Response ICMPv6 data size
; 6606 :     char       unspecified[16];
; 6607 :     char       solicitednode[16];
; 6608 :     BYTE       sig;
; 6609 : 
; 6610 :     // Initialize variables
; 6611 :     memset( unspecified, 0, 16 );

  0002a	48 8d 44 24 70	 lea	 rax, QWORD PTR unspecified$[rsp]
  0002f	48 8b f8	 mov	 rdi, rax
  00032	33 c0		 xor	 eax, eax
  00034	b9 10 00 00 00	 mov	 ecx, 16
  00039	f3 aa		 rep stosb

; 6612 :     memset( solicitednode, 0, 16 );

  0003b	48 8d 44 24 60	 lea	 rax, QWORD PTR solicitednode$[rsp]
  00040	48 8b f8	 mov	 rdi, rax
  00043	33 c0		 xor	 eax, eax
  00045	b9 10 00 00 00	 mov	 ecx, 16
  0004a	f3 aa		 rep stosb

; 6613 :     solicitednode[0] = 0xFF;

  0004c	b8 01 00 00 00	 mov	 eax, 1
  00051	48 6b c0 00	 imul	 rax, rax, 0
  00055	c6 44 04 60 ff	 mov	 BYTE PTR solicitednode$[rsp+rax], -1

; 6614 :     solicitednode[1] = 0x02;

  0005a	b8 01 00 00 00	 mov	 eax, 1
  0005f	48 6b c0 01	 imul	 rax, rax, 1
  00063	c6 44 04 60 02	 mov	 BYTE PTR solicitednode$[rsp+rax], 2

; 6615 :     solicitednode[11] = 0x01;

  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	48 6b c0 0b	 imul	 rax, rax, 11
  00071	c6 44 04 60 01	 mov	 BYTE PTR solicitednode$[rsp+rax], 1

; 6616 :     solicitednode[12] = 0xFF;

  00076	b8 01 00 00 00	 mov	 eax, 1
  0007b	48 6b c0 0c	 imul	 rax, rax, 12
  0007f	c6 44 04 60 ff	 mov	 BYTE PTR solicitednode$[rsp+rax], -1

; 6617 : 
; 6618 :     // Point to the ICMPv6 header
; 6619 :     icmp = (BYTE*)ip6->bPayload;

  00084	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR ip6$[rsp]
  0008c	48 83 c0 28	 add	 rax, 40			; 00000028H
  00090	48 89 44 24 48	 mov	 QWORD PTR icmp$[rsp], rax

; 6620 : 
; 6621 :     // Process Neighbor Solicitation
; 6622 :     if (icmp[0] == 0x87)    /* 0x87 = 135 */

  00095	b8 01 00 00 00	 mov	 eax, 1
  0009a	48 6b c0 00	 imul	 rax, rax, 0
  0009e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR icmp$[rsp]
  000a3	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000a7	3d 87 00 00 00	 cmp	 eax, 135		; 00000087H
  000ac	0f 85 fa 02 00
	00		 jne	 $LN8@process_l3

; 6623 :     {                       /* Start of Neighbor Solicitation */
; 6624 : 
; 6625 :       // Check for a Neighbor Solicitation message sent by the guest
; 6626 :       // to verify that no other node is using the guests IP address.
; 6627 :       // The source address is unspecified, and the destination address
; 6628 :       // is the Solicited Node address, i.e. FF02::1:FFxx:xxxx.
; 6629 : 
; 6630 : //    if (memcmp( &ip6->bSrcAddr[0], &unspecified, 16 ) == 0 &&
; 6631 : //        memcmp( &ip6->bDstAddr[0], &solicitednode, 13 ) == 0 &&
; 6632 : //        memcmp( &ip6->bDstAddr[13], &icmp[8+13], 3 ) == 0)
; 6633 : //    {
; 6634 : //      return;
; 6635 : //    }
; 6636 : 
; 6637 :       // Check for a Neighbor Solicitation message sent by the guest
; 6638 :       // to resolve the specified IP address. The source address
; 6639 :       // is the guests IP address, and the destination address is
; 6640 :       // the Solicited Node address, i.e. FF02::1:FFxx:xxxx.
; 6641 : 
; 6642 :       if (memcmp( &ip6->bSrcAddr[0], &unspecified, 16 ) != 0 &&
; 6643 :           memcmp( &ip6->bDstAddr[0], &solicitednode, 13 ) == 0 &&

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	48 6b c0 00	 imul	 rax, rax, 0
  000bb	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ip6$[rsp]
  000c3	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  000c8	41 b8 10 00 00
	00		 mov	 r8d, 16
  000ce	48 8d 54 24 70	 lea	 rdx, QWORD PTR unspecified$[rsp]
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	e8 00 00 00 00	 call	 memcmp
  000db	85 c0		 test	 eax, eax
  000dd	0f 84 c9 02 00
	00		 je	 $LN9@process_l3
  000e3	b8 01 00 00 00	 mov	 eax, 1
  000e8	48 6b c0 00	 imul	 rax, rax, 0
  000ec	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ip6$[rsp]
  000f4	48 8d 44 01 18	 lea	 rax, QWORD PTR [rcx+rax+24]
  000f9	41 b8 0d 00 00
	00		 mov	 r8d, 13
  000ff	48 8d 54 24 60	 lea	 rdx, QWORD PTR solicitednode$[rsp]
  00104	48 8b c8	 mov	 rcx, rax
  00107	e8 00 00 00 00	 call	 memcmp
  0010c	85 c0		 test	 eax, eax
  0010e	0f 85 98 02 00
	00		 jne	 $LN9@process_l3
  00114	b8 01 00 00 00	 mov	 eax, 1
  00119	48 6b c0 15	 imul	 rax, rax, 21
  0011d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR icmp$[rsp]
  00122	48 03 c8	 add	 rcx, rax
  00125	48 8b c1	 mov	 rax, rcx
  00128	b9 01 00 00 00	 mov	 ecx, 1
  0012d	48 6b c9 0d	 imul	 rcx, rcx, 13
  00131	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR ip6$[rsp]
  00139	48 8d 4c 0a 18	 lea	 rcx, QWORD PTR [rdx+rcx+24]
  0013e	41 b8 03 00 00
	00		 mov	 r8d, 3
  00144	48 8b d0	 mov	 rdx, rax
  00147	e8 00 00 00 00	 call	 memcmp
  0014c	85 c0		 test	 eax, eax
  0014e	0f 85 58 02 00
	00		 jne	 $LN9@process_l3

; 6644 :           memcmp( &ip6->bDstAddr[13], &icmp[8+13], 3 ) == 0)
; 6645 :       {
; 6646 :         // Prepare various sizes
; 6647 :         ip6re_header_size = sizeof(IP6FRM);

  00154	b8 28 00 00 00	 mov	 eax, 40			; 00000028H
  00159	66 89 44 24 30	 mov	 WORD PTR ip6re_header_size$[rsp], ax

; 6648 :         ip6re_payload_size = 32;

  0015e	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00163	66 89 44 24 24	 mov	 WORD PTR ip6re_payload_size$[rsp], ax

; 6649 :         ip6re_packet_size = ip6re_header_size + ip6re_payload_size;

  00168	0f b7 44 24 30	 movzx	 eax, WORD PTR ip6re_header_size$[rsp]
  0016d	0f b7 4c 24 24	 movzx	 ecx, WORD PTR ip6re_payload_size$[rsp]
  00172	03 c1		 add	 eax, ecx
  00174	89 44 24 40	 mov	 DWORD PTR ip6re_packet_size$[rsp], eax

; 6650 : 
; 6651 :         // Allocate a buffer in which the ICMPv6 Neighbor Advertisment message
; 6652 :         // will be built. Note: the message will be 72 bytes.
; 6653 :         // The source address is the target address, the destination
; 6654 :         // address is the Link-Local Scope All Nodes multicast address,
; 6655 :         // i.e. FF02:0:0:0:0:0:0:1.
; 6656 : 
; 6657 :         bhrre = alloc_buffer( dev, (ip6re_packet_size + 10) );

  00178	8b 44 24 40	 mov	 eax, DWORD PTR ip6re_packet_size$[rsp]
  0017c	83 c0 0a	 add	 eax, 10
  0017f	8b d0		 mov	 edx, eax
  00181	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00189	e8 00 00 00 00	 call	 alloc_buffer
  0018e	48 89 44 24 50	 mov	 QWORD PTR bhrre$[rsp], rax

; 6658 :         if (!bhrre) return;

  00193	48 83 7c 24 50
	00		 cmp	 QWORD PTR bhrre$[rsp], 0
  00199	75 05		 jne	 SHORT $LN10@process_l3
  0019b	e9 0c 02 00 00	 jmp	 $LN1@process_l3
$LN10@process_l3:

; 6659 :         bhrre->datalen = ip6re_packet_size;

  001a0	48 8b 44 24 50	 mov	 rax, QWORD PTR bhrre$[rsp]
  001a5	8b 4c 24 40	 mov	 ecx, DWORD PTR ip6re_packet_size$[rsp]
  001a9	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 6660 :         ip6re = (IP6FRM*)((BYTE*)bhrre + SizeBHR);

  001ac	48 8b 44 24 50	 mov	 rax, QWORD PTR bhrre$[rsp]
  001b1	48 83 c0 18	 add	 rax, 24
  001b5	48 89 44 24 28	 mov	 QWORD PTR ip6re$[rsp], rax

; 6661 :         icmpre = (BYTE*)ip6re->bPayload;

  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR ip6re$[rsp]
  001bf	48 83 c0 28	 add	 rax, 40			; 00000028H
  001c3	48 89 44 24 38	 mov	 QWORD PTR icmpre$[rsp], rax

; 6662 : 
; 6663 :         // Prepare response IPv6 header
; 6664 :         ip6re->bVersTCFlow[0] = 0x60;

  001c8	b8 01 00 00 00	 mov	 eax, 1
  001cd	48 6b c0 00	 imul	 rax, rax, 0
  001d1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ip6re$[rsp]
  001d6	c6 04 01 60	 mov	 BYTE PTR [rcx+rax], 96	; 00000060H

; 6665 :         STORE_HW( ip6re->bPayloadLength, ip6re_payload_size );

  001da	0f b7 4c 24 24	 movzx	 ecx, WORD PTR ip6re_payload_size$[rsp]
  001df	e8 00 00 00 00	 call	 _byteswap_ushort
  001e4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ip6re$[rsp]
  001e9	48 83 c1 04	 add	 rcx, 4
  001ed	0f b7 d0	 movzx	 edx, ax
  001f0	e8 00 00 00 00	 call	 store_hw_noswap

; 6666 :         ip6re->bNextHeader = 0x3A;

  001f5	48 8b 44 24 28	 mov	 rax, QWORD PTR ip6re$[rsp]
  001fa	c6 40 06 3a	 mov	 BYTE PTR [rax+6], 58	; 0000003aH

; 6667 :         ip6re->bHopLimit = 0xFF;

  001fe	48 8b 44 24 28	 mov	 rax, QWORD PTR ip6re$[rsp]
  00203	c6 40 07 ff	 mov	 BYTE PTR [rax+7], 255	; 000000ffH

; 6668 :         memcpy( ip6re->bSrcAddr, &icmp[8], 16 );

  00207	b8 01 00 00 00	 mov	 eax, 1
  0020c	48 6b c0 08	 imul	 rax, rax, 8
  00210	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ip6re$[rsp]
  00215	48 8b 54 24 48	 mov	 rdx, QWORD PTR icmp$[rsp]
  0021a	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  0021e	48 8d 34 02	 lea	 rsi, QWORD PTR [rdx+rax]
  00222	b9 10 00 00 00	 mov	 ecx, 16
  00227	f3 a4		 rep movsb

; 6669 :         memcpy( ip6re->bDstAddr, ip6->bSrcAddr, 16 );

  00229	48 8b 44 24 28	 mov	 rax, QWORD PTR ip6re$[rsp]
  0022e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR ip6$[rsp]
  00236	48 8d 78 18	 lea	 rdi, QWORD PTR [rax+24]
  0023a	48 8d 71 08	 lea	 rsi, QWORD PTR [rcx+8]
  0023e	b9 10 00 00 00	 mov	 ecx, 16
  00243	f3 a4		 rep movsb

; 6670 : 
; 6671 :         // Prepare response ICMPv6 data
; 6672 :         icmpre[0] = 0x88;                    /* Neighbor Advertisment  0x88 = 136 */

  00245	b8 01 00 00 00	 mov	 eax, 1
  0024a	48 6b c0 00	 imul	 rax, rax, 0
  0024e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR icmpre$[rsp]
  00253	c6 04 01 88	 mov	 BYTE PTR [rcx+rax], 136	; 00000088H

; 6673 :         icmpre[4] = 0x60;                    /* Solicited & Override flags */

  00257	b8 01 00 00 00	 mov	 eax, 1
  0025c	48 6b c0 04	 imul	 rax, rax, 4
  00260	48 8b 4c 24 38	 mov	 rcx, QWORD PTR icmpre$[rsp]
  00265	c6 04 01 60	 mov	 BYTE PTR [rcx+rax], 96	; 00000060H

; 6674 :         memcpy( &icmpre[8], &icmp[8], 16 );  /* Target IP address */

  00269	b8 01 00 00 00	 mov	 eax, 1
  0026e	48 6b c0 08	 imul	 rax, rax, 8
  00272	b9 01 00 00 00	 mov	 ecx, 1
  00277	48 6b c9 08	 imul	 rcx, rcx, 8
  0027b	48 8b 54 24 38	 mov	 rdx, QWORD PTR icmpre$[rsp]
  00280	48 8b 7c 24 48	 mov	 rdi, QWORD PTR icmp$[rsp]
  00285	48 89 7c 24 58	 mov	 QWORD PTR tv317[rsp], rdi
  0028a	48 8d 3c 0a	 lea	 rdi, QWORD PTR [rdx+rcx]
  0028e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv317[rsp]
  00293	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00297	b9 10 00 00 00	 mov	 ecx, 16
  0029c	f3 a4		 rep movsb

; 6675 :         icmpre[24] = 0x02;                   /* Target link local option */

  0029e	b8 01 00 00 00	 mov	 eax, 1
  002a3	48 6b c0 18	 imul	 rax, rax, 24
  002a7	48 8b 4c 24 38	 mov	 rcx, QWORD PTR icmpre$[rsp]
  002ac	c6 04 01 02	 mov	 BYTE PTR [rcx+rax], 2

; 6676 :         icmpre[25] = 0x01;                   /* Length of option in 8-byte units */

  002b0	b8 01 00 00 00	 mov	 eax, 1
  002b5	48 6b c0 19	 imul	 rax, rax, 25
  002b9	48 8b 4c 24 38	 mov	 rcx, QWORD PTR icmpre$[rsp]
  002be	c6 04 01 01	 mov	 BYTE PTR [rcx+rax], 1

; 6677 :         memcpy( &icmpre[26], grp->iaDriveMACAddr, IFHWADDRLEN );

  002c2	b8 01 00 00 00	 mov	 eax, 1
  002c7	48 6b c0 1a	 imul	 rax, rax, 26
  002cb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR icmpre$[rsp]
  002d0	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR grp$[rsp]
  002d8	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  002dc	48 8d b2 44 06
	00 00		 lea	 rsi, QWORD PTR [rdx+1604]
  002e3	b9 06 00 00 00	 mov	 ecx, 6
  002e8	f3 a4		 rep movsb

; 6678 : 
; 6679 :         // Calculate and set the ICMPv6 checksum
; 6680 :         calculate_icmpv6_checksum( ip6re, icmpre, (int)ip6re_payload_size );

  002ea	0f b7 44 24 24	 movzx	 eax, WORD PTR ip6re_payload_size$[rsp]
  002ef	44 8b c0	 mov	 r8d, eax
  002f2	48 8b 54 24 38	 mov	 rdx, QWORD PTR icmpre$[rsp]
  002f7	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ip6re$[rsp]
  002fc	e8 00 00 00 00	 call	 calculate_icmpv6_checksum

; 6681 : 
; 6682 :         // Add response buffer to chain.
; 6683 :         add_buffer_to_chain( &grp->l3r, bhrre );

  00301	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00309	48 83 c0 38	 add	 rax, 56			; 00000038H
  0030d	48 8b 54 24 50	 mov	 rdx, QWORD PTR bhrre$[rsp]
  00312	48 8b c8	 mov	 rcx, rax
  00315	e8 00 00 00 00	 call	 add_buffer_to_chain

; 6684 :         sig = QDSIG_WAKEUP;

  0031a	c6 44 24 20 07	 mov	 BYTE PTR sig$[rsp], 7
$LN4@process_l3:

; 6685 :         VERIFY( qeth_write_pipe( grp->ppfd[1], &sig ) == 1);

  0031f	b8 04 00 00 00	 mov	 eax, 4
  00324	48 6b c0 01	 imul	 rax, rax, 1
  00328	48 8d 54 24 20	 lea	 rdx, QWORD PTR sig$[rsp]
  0032d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00335	8b 8c 01 fc 05
	00 00		 mov	 ecx, DWORD PTR [rcx+rax+1532]
  0033c	e8 00 00 00 00	 call	 qeth_write_pipe
  00341	83 f8 01	 cmp	 eax, 1
  00344	74 5c		 je	 SHORT $LN11@process_l3
$LN7@process_l3:
  00346	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG175522
  0034d	41 b8 1d 1a 00
	00		 mov	 r8d, 6685		; 00001a1dH
  00353	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175523
  0035a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175524
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00367	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0036d	85 c0		 test	 eax, eax
  0036f	74 20		 je	 SHORT $LN12@process_l3
  00371	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG175526
  00378	41 b8 1d 1a 00
	00		 mov	 r8d, 6685		; 00001a1dH
  0037e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175527
  00385	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175528
  0038c	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@process_l3:
  00391	33 c0		 xor	 eax, eax
  00393	85 c0		 test	 eax, eax
  00395	75 af		 jne	 SHORT $LN7@process_l3
  00397	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0039d	85 c0		 test	 eax, eax
  0039f	74 01		 je	 SHORT $LN13@process_l3
  003a1	cc		 int	 3
$LN13@process_l3:
$LN11@process_l3:
  003a2	33 c0		 xor	 eax, eax
  003a4	85 c0		 test	 eax, eax
  003a6	0f 85 73 ff ff
	ff		 jne	 $LN4@process_l3
$LN9@process_l3:
$LN8@process_l3:
$LN1@process_l3:

; 6686 :         return;
; 6687 :       }
; 6688 : 
; 6689 :     } /* End of Neighbor Solicitation */
; 6690 : 
; 6691 :     // Hmm... an ICMPv6 message sent by the guest
; 6692 :     // that we don't handle.
; 6693 : }

  003ac	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003b4	48 33 cc	 xor	 rcx, rsp
  003b7	e8 00 00 00 00	 call	 __security_check_cookie
  003bc	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  003c3	5f		 pop	 rdi
  003c4	5e		 pop	 rsi
  003c5	c3		 ret	 0
process_l3_icmpv6_packet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
i$ = 64
qmask$ = 68
tv90 = 72
tv133 = 76
tv172 = 80
tv183 = 84
tv136 = 88
dev$ = 112
output$ = 120
qeth_init_queue PROC

; 5325 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H
$LN4@qeth_init_:

; 5326 : int i;
; 5327 : U32 qmask;
; 5328 : 
; 5329 :     PTT_QETH_TRACE( "initq entry", dev->qdio.i_qcnt, dev->qdio.o_qcnt, output );

  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  0001d	48 85 c0	 test	 rax, rax
  00020	74 4f		 je	 SHORT $LN14@qeth_init_
  00022	48 63 44 24 78	 movsxd	 rax, DWORD PTR output$[rsp]
  00027	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	48 63 89 c4 13
	00 00		 movsxd	 rcx, DWORD PTR [rcx+5060]
  00033	48 8b 54 24 70	 mov	 rdx, QWORD PTR dev$[rsp]
  00038	48 63 92 3c 13
	00 00		 movsxd	 rdx, DWORD PTR [rdx+4924]
  0003f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00048	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174670
  00054	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00059	4c 8b c9	 mov	 r9, rcx
  0005c	4c 8b c2	 mov	 r8, rdx
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174671
  00066	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN14@qeth_init_:
  00071	33 c0		 xor	 eax, eax
  00073	85 c0		 test	 eax, eax
  00075	75 96		 jne	 SHORT $LN4@qeth_init_

; 5330 : 
; 5331 :     if (output)

  00077	83 7c 24 78 00	 cmp	 DWORD PTR output$[rsp], 0
  0007c	74 7d		 je	 SHORT $LN15@qeth_init_

; 5332 :     {
; 5333 :         dev->qdio.o_qpos = 0;

  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00083	c7 80 c8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5064], 0

; 5334 :         for (i=0; i < QDIO_MAXQ; i++)

  0008d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN7@qeth_init_
$LN5@qeth_init_:
  00097	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN7@qeth_init_:
  000a1	83 7c 24 40 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  000a6	7d 17		 jge	 SHORT $LN6@qeth_init_

; 5335 :             dev->qdio.o_bpos[i] = 0;

  000a8	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  000ad	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000b2	c7 84 81 cc 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+5068], 0
  000bd	eb d8		 jmp	 SHORT $LN5@qeth_init_
$LN6@qeth_init_:

; 5336 :         qmask = dev->qdio.o_qmask = ~(0xffffffff >> dev->qdio.o_qcnt);

  000bf	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000c4	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  000ca	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  000cf	89 4c 24 50	 mov	 DWORD PTR tv172[rsp], ecx
  000d3	0f b6 c8	 movzx	 ecx, al
  000d6	8b 44 24 50	 mov	 eax, DWORD PTR tv172[rsp]
  000da	d3 e8		 shr	 eax, cl
  000dc	f7 d0		 not	 eax
  000de	89 44 24 48	 mov	 DWORD PTR tv90[rsp], eax
  000e2	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000e7	8b 4c 24 48	 mov	 ecx, DWORD PTR tv90[rsp]
  000eb	89 88 50 14 00
	00		 mov	 DWORD PTR [rax+5200], ecx
  000f1	8b 44 24 48	 mov	 eax, DWORD PTR tv90[rsp]
  000f5	89 44 24 44	 mov	 DWORD PTR qmask$[rsp], eax

; 5337 :     }

  000f9	eb 7b		 jmp	 SHORT $LN16@qeth_init_
$LN15@qeth_init_:

; 5338 :     else /* input */
; 5339 :     {
; 5340 :         dev->qdio.i_qpos = 0;

  000fb	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00100	c7 80 40 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4928], 0

; 5341 :         for (i=0; i < QDIO_MAXQ; i++)

  0010a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00112	eb 0a		 jmp	 SHORT $LN10@qeth_init_
$LN8@qeth_init_:
  00114	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00118	ff c0		 inc	 eax
  0011a	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN10@qeth_init_:
  0011e	83 7c 24 40 20	 cmp	 DWORD PTR i$[rsp], 32	; 00000020H
  00123	7d 17		 jge	 SHORT $LN9@qeth_init_

; 5342 :             dev->qdio.i_bpos[i] = 0;

  00125	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0012a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0012f	c7 84 81 44 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+4932], 0
  0013a	eb d8		 jmp	 SHORT $LN8@qeth_init_
$LN9@qeth_init_:

; 5343 :         qmask = dev->qdio.i_qmask = ~(0xffffffff >> dev->qdio.i_qcnt);

  0013c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00141	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00147	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  0014c	89 4c 24 54	 mov	 DWORD PTR tv183[rsp], ecx
  00150	0f b6 c8	 movzx	 ecx, al
  00153	8b 44 24 54	 mov	 eax, DWORD PTR tv183[rsp]
  00157	d3 e8		 shr	 eax, cl
  00159	f7 d0		 not	 eax
  0015b	89 44 24 4c	 mov	 DWORD PTR tv133[rsp], eax
  0015f	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00164	8b 4c 24 4c	 mov	 ecx, DWORD PTR tv133[rsp]
  00168	89 88 4c 14 00
	00		 mov	 DWORD PTR [rax+5196], ecx
  0016e	8b 44 24 4c	 mov	 eax, DWORD PTR tv133[rsp]
  00172	89 44 24 44	 mov	 DWORD PTR qmask$[rsp], eax
$LN16@qeth_init_:

; 5344 :     }
; 5345 : 
; 5346 :     DBGTRC(dev, "Initialize %s Queue: qmask(0x%08X)",

  00176	83 7c 24 78 00	 cmp	 DWORD PTR output$[rsp], 0
  0017b	74 0e		 je	 SHORT $LN19@qeth_init_
  0017d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174674
  00184	48 89 44 24 58	 mov	 QWORD PTR tv136[rsp], rax
  00189	eb 0c		 jmp	 SHORT $LN20@qeth_init_
$LN19@qeth_init_:
  0018b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174675
  00192	48 89 44 24 58	 mov	 QWORD PTR tv136[rsp], rax
$LN20@qeth_init_:
  00197	8b 44 24 44	 mov	 eax, DWORD PTR qmask$[rsp]
  0019b	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  0019f	48 8b 44 24 58	 mov	 rax, QWORD PTR tv136[rsp]
  001a4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174676
  001b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b5	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  001ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174677
  001c1	ba e3 14 00 00	 mov	 edx, 5347		; 000014e3H
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174678
  001cd	e8 00 00 00 00	 call	 dbgtrc
$LN13@qeth_init_:

; 5347 :         output ? "Output" : "Input", qmask );
; 5348 : 
; 5349 :     PTT_QETH_TRACE( "initq exit", dev->qdio.i_qcnt, dev->qdio.o_qcnt, qmask );

  001d2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  001d9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001dc	48 25 00 00 04
	00		 and	 rax, 262144		; 00040000H
  001e2	48 85 c0	 test	 rax, rax
  001e5	74 4e		 je	 SHORT $LN17@qeth_init_
  001e7	8b 44 24 44	 mov	 eax, DWORD PTR qmask$[rsp]
  001eb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001f0	48 63 89 c4 13
	00 00		 movsxd	 rcx, DWORD PTR [rcx+5060]
  001f7	48 8b 54 24 70	 mov	 rdx, QWORD PTR dev$[rsp]
  001fc	48 63 92 3c 13
	00 00		 movsxd	 rdx, DWORD PTR [rdx+4924]
  00203	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0020c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00211	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174680
  00218	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021d	4c 8b c9	 mov	 r9, rcx
  00220	4c 8b c2	 mov	 r8, rdx
  00223	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG174681
  0022a	b9 00 00 04 00	 mov	 ecx, 262144		; 00040000H
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN17@qeth_init_:
  00235	33 c0		 xor	 eax, eax
  00237	85 c0		 test	 eax, eax
  00239	75 97		 jne	 SHORT $LN13@qeth_init_

; 5350 : }

  0023b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0023f	c3		 ret	 0
qeth_init_queue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
dev$ = 48
qeth_init_queues PROC

; 5317 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 5318 :     qeth_init_queue(dev,0);     /* Initialize ALL Input  Queues      */

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00010	e8 00 00 00 00	 call	 qeth_init_queue

; 5319 :     qeth_init_queue(dev,1);     /* Initialize ALL Output Queues      */

  00015	ba 01 00 00 00	 mov	 edx, 1
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001f	e8 00 00 00 00	 call	 qeth_init_queue

; 5320 : }

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
qeth_init_queues ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
quo$1 = 32
pfxlen$2 = 36
rem$3 = 40
tv151 = 44
tv72 = 48
tv81 = 56
ttpfxlen6$ = 80
pfxmask6$ = 88
makepfxmask6 PROC

; 6573 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 6574 :     if (ttpfxlen6)

  0000f	48 83 7c 24 50
	00		 cmp	 QWORD PTR ttpfxlen6$[rsp], 0
  00015	0f 84 bf 00 00
	00		 je	 $LN2@makepfxmas

; 6575 :     {
; 6576 :         int pfxlen = atoi( ttpfxlen6 );

  0001b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ttpfxlen6$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00026	89 44 24 24	 mov	 DWORD PTR pfxlen$2[rsp], eax

; 6577 :         int quo = pfxlen / 8;

  0002a	8b 44 24 24	 mov	 eax, DWORD PTR pfxlen$2[rsp]
  0002e	99		 cdq
  0002f	83 e2 07	 and	 edx, 7
  00032	03 c2		 add	 eax, edx
  00034	c1 f8 03	 sar	 eax, 3
  00037	89 44 24 20	 mov	 DWORD PTR quo$1[rsp], eax

; 6578 :         int rem = pfxlen % 8;

  0003b	8b 44 24 24	 mov	 eax, DWORD PTR pfxlen$2[rsp]
  0003f	99		 cdq
  00040	83 e2 07	 and	 edx, 7
  00043	03 c2		 add	 eax, edx
  00045	83 e0 07	 and	 eax, 7
  00048	2b c2		 sub	 eax, edx
  0004a	89 44 24 28	 mov	 DWORD PTR rem$3[rsp], eax

; 6579 :         if (quo)

  0004e	83 7c 24 20 00	 cmp	 DWORD PTR quo$1[rsp], 0
  00053	74 2a		 je	 SHORT $LN4@makepfxmas

; 6580 :             memset( &pfxmask6[0], 0x00, quo );

  00055	48 63 44 24 20	 movsxd	 rax, DWORD PTR quo$1[rsp]
  0005a	48 89 44 24 30	 mov	 QWORD PTR tv72[rsp], rax
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	48 6b c9 00	 imul	 rcx, rcx, 0
  00068	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfxmask6$[rsp]
  0006d	48 03 d1	 add	 rdx, rcx
  00070	48 8b ca	 mov	 rcx, rdx
  00073	48 8b f9	 mov	 rdi, rcx
  00076	33 c0		 xor	 eax, eax
  00078	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv72[rsp]
  0007d	f3 aa		 rep stosb
$LN4@makepfxmas:

; 6581 :         if (quo < 16)

  0007f	83 7c 24 20 10	 cmp	 DWORD PTR quo$1[rsp], 16
  00084	7d 52		 jge	 SHORT $LN5@makepfxmas

; 6582 :         {
; 6583 :             memset( &pfxmask6[quo], 0xFF, 16-quo );

  00086	b8 10 00 00 00	 mov	 eax, 16
  0008b	2b 44 24 20	 sub	 eax, DWORD PTR quo$1[rsp]
  0008f	48 98		 cdqe
  00091	48 89 44 24 38	 mov	 QWORD PTR tv81[rsp], rax
  00096	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR quo$1[rsp]
  0009b	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfxmask6$[rsp]
  000a0	48 03 d1	 add	 rdx, rcx
  000a3	48 8b ca	 mov	 rcx, rdx
  000a6	48 8b f9	 mov	 rdi, rcx
  000a9	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000ae	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv81[rsp]
  000b3	f3 aa		 rep stosb

; 6584 :             pfxmask6[quo] = (0xFF >> rem);

  000b5	8b 44 24 28	 mov	 eax, DWORD PTR rem$3[rsp]
  000b9	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  000be	89 4c 24 2c	 mov	 DWORD PTR tv151[rsp], ecx
  000c2	0f b6 c8	 movzx	 ecx, al
  000c5	8b 44 24 2c	 mov	 eax, DWORD PTR tv151[rsp]
  000c9	d3 f8		 sar	 eax, cl
  000cb	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR quo$1[rsp]
  000d0	48 8b 54 24 58	 mov	 rdx, QWORD PTR pfxmask6$[rsp]
  000d5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@makepfxmas:

; 6585 :         }
; 6586 :     }

  000d8	eb 23		 jmp	 SHORT $LN3@makepfxmas
$LN2@makepfxmas:

; 6587 :     else
; 6588 :         memset( &pfxmask6[0], 0xFF, 16 );

  000da	b8 01 00 00 00	 mov	 eax, 1
  000df	48 6b c0 00	 imul	 rax, rax, 0
  000e3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pfxmask6$[rsp]
  000e8	48 03 c8	 add	 rcx, rax
  000eb	48 8b c1	 mov	 rax, rcx
  000ee	48 8b f8	 mov	 rdi, rax
  000f1	b8 ff 00 00 00	 mov	 eax, 255		; 000000ffH
  000f6	b9 10 00 00 00	 mov	 ecx, 16
  000fb	f3 aa		 rep stosb
$LN3@makepfxmas:

; 6589 : }

  000fd	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00101	5f		 pop	 rdi
  00102	c3		 ret	 0
makepfxmask6 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
pfxlen$ = 32
pfxmask4$ = 36
tv77 = 40
ttpfxlen$ = 64
makepfxmask4 PROC

; 6555 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6556 :     U32 pfxmask4;
; 6557 :     int pfxlen = atoi( ttpfxlen );

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ttpfxlen$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00014	89 44 24 20	 mov	 DWORD PTR pfxlen$[rsp], eax

; 6558 :     if (pfxlen >= 32)

  00018	83 7c 24 20 20	 cmp	 DWORD PTR pfxlen$[rsp], 32 ; 00000020H
  0001d	7c 0a		 jl	 SHORT $LN2@makepfxmas

; 6559 :         pfxmask4 = 0x00000000;

  0001f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR pfxmask4$[rsp], 0
  00027	eb 2b		 jmp	 SHORT $LN3@makepfxmas
$LN2@makepfxmas:

; 6560 :     else if (pfxlen <= 0)

  00029	83 7c 24 20 00	 cmp	 DWORD PTR pfxlen$[rsp], 0
  0002e	7f 0a		 jg	 SHORT $LN4@makepfxmas

; 6561 :         pfxmask4 = 0xFFFFFFFF;

  00030	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR pfxmask4$[rsp], -1 ; ffffffffH
  00038	eb 1a		 jmp	 SHORT $LN5@makepfxmas
$LN4@makepfxmas:

; 6562 :     else
; 6563 :         pfxmask4 = (0xFFFFFFFF >> pfxlen);

  0003a	8b 44 24 20	 mov	 eax, DWORD PTR pfxlen$[rsp]
  0003e	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00043	89 4c 24 28	 mov	 DWORD PTR tv77[rsp], ecx
  00047	0f b6 c8	 movzx	 ecx, al
  0004a	8b 44 24 28	 mov	 eax, DWORD PTR tv77[rsp]
  0004e	d3 e8		 shr	 eax, cl
  00050	89 44 24 24	 mov	 DWORD PTR pfxmask4$[rsp], eax
$LN5@makepfxmas:
$LN3@makepfxmas:

; 6564 :     return htonl( pfxmask4 );

  00054	8b 4c 24 24	 mov	 ecx, DWORD PTR pfxmask4$[rsp]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl

; 6565 : }

  0005e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00062	c3		 ret	 0
makepfxmask4 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
pfxlen$ = 32
addr4$ = 36
p$ = 40
ttpfxlen$ = 64
ttnetmask$ = 72
prefix2netmask PROC

; 6533 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6534 :     struct in_addr addr4;
; 6535 :     char* p;
; 6536 :     int pfxlen;
; 6537 :     /* make sure it's a number from 0 to 32 */
; 6538 :     for (p = ttpfxlen; isdigit(*p); p++) { }

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR ttpfxlen$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  00018	eb 0d		 jmp	 SHORT $LN4@prefix2net
$LN2@prefix2net:
  0001a	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0001f	48 ff c0	 inc	 rax
  00022	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
$LN4@prefix2net:
  00027	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0002c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0002f	8b c8		 mov	 ecx, eax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  00037	85 c0		 test	 eax, eax
  00039	74 02		 je	 SHORT $LN3@prefix2net
  0003b	eb dd		 jmp	 SHORT $LN2@prefix2net
$LN3@prefix2net:

; 6539 :     if (*p || !ttpfxlen[0] || (pfxlen = atoi(ttpfxlen)) > 32)

  0003d	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00042	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00045	85 c0		 test	 eax, eax
  00047	75 2c		 jne	 SHORT $LN6@prefix2net
  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	48 6b c0 00	 imul	 rax, rax, 0
  00052	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ttpfxlen$[rsp]
  00057	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0005b	85 c0		 test	 eax, eax
  0005d	74 16		 je	 SHORT $LN6@prefix2net
  0005f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ttpfxlen$[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0006a	89 44 24 20	 mov	 DWORD PTR pfxlen$[rsp], eax
  0006e	83 7c 24 20 20	 cmp	 DWORD PTR pfxlen$[rsp], 32 ; 00000020H
  00073	7e 07		 jle	 SHORT $LN5@prefix2net
$LN6@prefix2net:

; 6540 :         return -1;

  00075	b8 ff ff ff ff	 mov	 eax, -1
  0007a	eb 51		 jmp	 SHORT $LN1@prefix2net
$LN5@prefix2net:

; 6541 :     addr4.s_addr = ~makepfxmask4( ttpfxlen );

  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ttpfxlen$[rsp]
  00081	e8 00 00 00 00	 call	 makepfxmask4
  00086	f7 d0		 not	 eax
  00088	89 44 24 24	 mov	 DWORD PTR addr4$[rsp], eax

; 6542 :     if (!(p = inet_ntoa( addr4 )))

  0008c	8b 4c 24 24	 mov	 ecx, DWORD PTR addr4$[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_ntoa
  00096	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  0009b	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$[rsp], 0
  000a1	75 07		 jne	 SHORT $LN7@prefix2net

; 6543 :         return -1;

  000a3	b8 ff ff ff ff	 mov	 eax, -1
  000a8	eb 23		 jmp	 SHORT $LN1@prefix2net
$LN7@prefix2net:

; 6544 :     free( *ttnetmask );

  000aa	48 8b 44 24 48	 mov	 rax, QWORD PTR ttnetmask$[rsp]
  000af	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6545 :     *ttnetmask = strdup(p);

  000b8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR p$[rsp]
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000c3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ttnetmask$[rsp]
  000c8	48 89 01	 mov	 QWORD PTR [rcx], rax

; 6546 :     return 0;

  000cb	33 c0		 xor	 eax, eax
$LN1@prefix2net:

; 6547 : }

  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
prefix2netmask ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
pfxlen$ = 32
mask$ = 36
netmask$ = 40
tv138 = 44
cbuf$ = 48
__$ArrayPad$ = 64
ttnetmask$ = 96
ttpfxlen$ = 104
netmask2prefix PROC

; 6508 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6509 :     U32 netmask, mask;
; 6510 :     int pfxlen;
; 6511 :     char cbuf[16];
; 6512 :     netmask = ntohl( inet_addr( ttnetmask ));

  0001d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ttnetmask$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_addr
  00028	8b c8		 mov	 ecx, eax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohl
  00030	89 44 24 28	 mov	 DWORD PTR netmask$[rsp], eax

; 6513 :     if (netmask == ntohl( INADDR_NONE ) &&

  00034	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ntohl
  0003f	39 44 24 28	 cmp	 DWORD PTR netmask$[rsp], eax
  00043	75 1f		 jne	 SHORT $LN5@netmask2pr
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175449
  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ttnetmask$[rsp]
  00051	e8 00 00 00 00	 call	 strcmp
  00056	85 c0		 test	 eax, eax
  00058	74 0a		 je	 SHORT $LN5@netmask2pr

; 6514 :         strcmp( ttnetmask, "255.255.255.255" ) != 0)
; 6515 :         return -1;

  0005a	b8 ff ff ff ff	 mov	 eax, -1
  0005f	e9 9c 00 00 00	 jmp	 $LN1@netmask2pr
$LN5@netmask2pr:

; 6516 :     for (pfxlen=0, mask=netmask; mask & 0x80000000; mask <<= 1)

  00064	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pfxlen$[rsp], 0
  0006c	8b 44 24 28	 mov	 eax, DWORD PTR netmask$[rsp]
  00070	89 44 24 24	 mov	 DWORD PTR mask$[rsp], eax
  00074	eb 0a		 jmp	 SHORT $LN4@netmask2pr
$LN2@netmask2pr:
  00076	8b 44 24 24	 mov	 eax, DWORD PTR mask$[rsp]
  0007a	d1 e0		 shl	 eax, 1
  0007c	89 44 24 24	 mov	 DWORD PTR mask$[rsp], eax
$LN4@netmask2pr:
  00080	8b 44 24 24	 mov	 eax, DWORD PTR mask$[rsp]
  00084	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00089	85 c0		 test	 eax, eax
  0008b	74 0c		 je	 SHORT $LN3@netmask2pr

; 6517 :         pfxlen++;

  0008d	8b 44 24 20	 mov	 eax, DWORD PTR pfxlen$[rsp]
  00091	ff c0		 inc	 eax
  00093	89 44 24 20	 mov	 DWORD PTR pfxlen$[rsp], eax
  00097	eb dd		 jmp	 SHORT $LN2@netmask2pr
$LN3@netmask2pr:

; 6518 :     /* we don't support discontiguous subnets */
; 6519 :     if (netmask != (0xFFFFFFFF << (32-pfxlen)))

  00099	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0009e	2b 44 24 20	 sub	 eax, DWORD PTR pfxlen$[rsp]
  000a2	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  000a7	89 4c 24 2c	 mov	 DWORD PTR tv138[rsp], ecx
  000ab	0f b6 c8	 movzx	 ecx, al
  000ae	8b 44 24 2c	 mov	 eax, DWORD PTR tv138[rsp]
  000b2	d3 e0		 shl	 eax, cl
  000b4	39 44 24 28	 cmp	 DWORD PTR netmask$[rsp], eax
  000b8	74 07		 je	 SHORT $LN6@netmask2pr

; 6520 :         return -1;

  000ba	b8 ff ff ff ff	 mov	 eax, -1
  000bf	eb 3f		 jmp	 SHORT $LN1@netmask2pr
$LN6@netmask2pr:

; 6521 :     MSGBUF( cbuf, "%d", pfxlen );

  000c1	44 8b 4c 24 20	 mov	 r9d, DWORD PTR pfxlen$[rsp]
  000c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175451
  000cd	ba 10 00 00 00	 mov	 edx, 16
  000d2	48 8d 4c 24 30	 lea	 rcx, QWORD PTR cbuf$[rsp]
  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6522 :     free( *ttpfxlen );

  000dd	48 8b 44 24 68	 mov	 rax, QWORD PTR ttpfxlen$[rsp]
  000e2	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6523 :     *ttpfxlen = strdup( cbuf );

  000eb	48 8d 4c 24 30	 lea	 rcx, QWORD PTR cbuf$[rsp]
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000f6	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ttpfxlen$[rsp]
  000fb	48 89 01	 mov	 QWORD PTR [rcx], rax

; 6524 :     return 0;

  000fe	33 c0		 xor	 eax, eax
$LN1@netmask2pr:

; 6525 : }

  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00105	48 33 cc	 xor	 rcx, rsp
  00108	e8 00 00 00 00	 call	 __security_check_cookie
  0010d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00111	c3		 ret	 0
netmask2prefix ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
uMTU$ = 48
rc$ = 52
ttmtu$ = 56
dev$ = 80
grp$ = 88
InitMTU	PROC

; 6473 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 6474 :     char* ttmtu;
; 6475 :     U16 uMTU;
; 6476 :     int rc = 0;

  0000e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 6477 : 
; 6478 :     /* Retrieve the MTU value directly from the TUNTAP interface */
; 6479 :     rc = TUNTAP_GetMTU( grp->ttifname, &ttmtu );

  00016	48 8b 44 24 58	 mov	 rax, QWORD PTR grp$[rsp]
  0001b	48 83 c0 60	 add	 rax, 96			; 00000060H
  0001f	48 8d 54 24 38	 lea	 rdx, QWORD PTR ttmtu$[rsp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 TUNTAP_GetMTU
  0002c	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 6480 : 
; 6481 :     /* Did we get what we wanted? */
; 6482 :     if (0
; 6483 :         || rc != 0
; 6484 :         || !(uMTU = (U16) atoi( ttmtu ))
; 6485 :         || uMTU < (60    - 14)
; 6486 :         || uMTU > (65535 - 14)

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 36		 jne	 SHORT $LN6@InitMTU
  00036	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003b	75 2f		 jne	 SHORT $LN6@InitMTU
  0003d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ttmtu$[rsp]
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00048	66 89 44 24 30	 mov	 WORD PTR uMTU$[rsp], ax
  0004d	0f b7 44 24 30	 movzx	 eax, WORD PTR uMTU$[rsp]
  00052	85 c0		 test	 eax, eax
  00054	74 16		 je	 SHORT $LN6@InitMTU
  00056	0f b7 44 24 30	 movzx	 eax, WORD PTR uMTU$[rsp]
  0005b	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  0005e	7c 0c		 jl	 SHORT $LN6@InitMTU
  00060	0f b7 44 24 30	 movzx	 eax, WORD PTR uMTU$[rsp]
  00065	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  0006a	7e 5c		 jle	 SHORT $LN5@InitMTU
$LN6@InitMTU:
$LN4@InitMTU:

; 6487 :     )
; 6488 :     {
; 6489 :         UNREFERENCED(dev); /*(unreferenced in non-debug build)*/

  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 fa		 jne	 SHORT $LN4@InitMTU

; 6490 :         DBGTRC(dev, "** WARNING ** TUNTAP_GetMTU() failed! Using default.");

  00072	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175431
  00079	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0007e	4c 8b 4c 24 50	 mov	 r9, QWORD PTR dev$[rsp]
  00083	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175432
  0008a	ba 5a 19 00 00	 mov	 edx, 6490		; 0000195aH
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175433
  00096	e8 00 00 00 00	 call	 dbgtrc

; 6491 :         free( ttmtu );

  0009b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ttmtu$[rsp]
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6492 :         ttmtu = strdup( QETH_DEF_MTU );

  000a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175434
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000b3	48 89 44 24 38	 mov	 QWORD PTR ttmtu$[rsp], rax

; 6493 :         uMTU = (U16) atoi( ttmtu );

  000b8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ttmtu$[rsp]
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000c3	66 89 44 24 30	 mov	 WORD PTR uMTU$[rsp], ax
$LN5@InitMTU:

; 6494 :     }
; 6495 : 
; 6496 :     grp->ttmtu = strdup( ttmtu );

  000c8	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ttmtu$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000d3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR grp$[rsp]
  000d8	48 89 41 78	 mov	 QWORD PTR [rcx+120], rax

; 6497 :     grp->uMTU  = uMTU;

  000dc	48 8b 44 24 58	 mov	 rax, QWORD PTR grp$[rsp]
  000e1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR uMTU$[rsp]
  000e6	66 89 88 2e 06
	00 00		 mov	 WORD PTR [rax+1582], cx

; 6498 : 
; 6499 :     free( ttmtu );

  000ed	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ttmtu$[rsp]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6500 : }

  000f8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000fc	c3		 ret	 0
InitMTU	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
j$ = 80
tthwaddr$ = 88
rc$ = 96
pszMAC$1 = 104
tv294 = 112
addr6$ = 120
iMAC$ = 136
szMAC$ = 144
__$ArrayPad$ = 168
dev$ = 208
grp$ = 216
InitMACAddr PROC

; 6382 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6383 :     static const BYTE zeromac[IFHWADDRLEN] = {0};
; 6384 :     char* tthwaddr = NULL;

  00025	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR tthwaddr$[rsp], 0

; 6385 :     BYTE iMAC[ IFHWADDRLEN ];
; 6386 :     char szMAC[3*IFHWADDRLEN] = {0};

  0002e	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR szMAC$[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 12 00 00 00	 mov	 ecx, 18
  00040	f3 aa		 rep stosb

; 6387 :     int rc = 0;

  00042	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 6388 : #if defined( ENABLE_IPV6 )
; 6389 :     int j;
; 6390 :     struct in6_addr addr6;
; 6391 : #endif
; 6392 : 
; 6393 :     /* Do different things for TAP's (layer 2) and TUN's (layer 3) */
; 6394 :     if (!grp->l3) {

  0004a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00052	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  00059	0f 85 ac 01 00
	00		 jne	 $LN14@InitMACAdd

; 6395 : 
; 6396 :         /* Retrieve the MAC Address directly from the TAP interface */
; 6397 :         rc = TUNTAP_GetMACAddr( grp->ttifname, &tthwaddr );

  0005f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00067	48 83 c0 60	 add	 rax, 96			; 00000060H
  0006b	48 8d 54 24 58	 lea	 rdx, QWORD PTR tthwaddr$[rsp]
  00070	48 8b c8	 mov	 rcx, rax
  00073	e8 00 00 00 00	 call	 TUNTAP_GetMACAddr
  00078	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 6398 : 
; 6399 :         /* Did we get what we wanted? */
; 6400 :         if (0
; 6401 :             || rc != 0
; 6402 :             || ParseMAC( tthwaddr, iMAC ) != 0
; 6403 :             || memcmp( iMAC, zeromac, IFHWADDRLEN ) == 0

  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 3f		 jne	 SHORT $LN17@InitMACAdd
  00082	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00087	75 38		 jne	 SHORT $LN17@InitMACAdd
  00089	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR iMAC$[rsp]
  00091	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tthwaddr$[rsp]
  00096	e8 00 00 00 00	 call	 ParseMAC
  0009b	85 c0		 test	 eax, eax
  0009d	75 22		 jne	 SHORT $LN17@InitMACAdd
  0009f	41 b8 06 00 00
	00		 mov	 r8d, 6
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?zeromac@?1??InitMACAddr@@9@9
  000ac	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  000b4	e8 00 00 00 00	 call	 memcmp
  000b9	85 c0		 test	 eax, eax
  000bb	0f 85 ce 00 00
	00		 jne	 $LN16@InitMACAdd
$LN17@InitMACAdd:
$LN4@InitMACAdd:

; 6404 :         )
; 6405 :         {
; 6406 :             char* pszMAC;
; 6407 :             UNREFERENCED( dev ); // (unreferenced in non-debug build)

  000c1	33 c0		 xor	 eax, eax
  000c3	85 c0		 test	 eax, eax
  000c5	75 fa		 jne	 SHORT $LN4@InitMACAdd

; 6408 :             DBGTRC( dev, "** WARNING ** TUNTAP_GetMACAddr() failed! Using default." );

  000c7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175398
  000ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d3	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  000db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175399
  000e2	ba 08 19 00 00	 mov	 edx, 6408		; 00001908H
  000e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175400
  000ee	e8 00 00 00 00	 call	 dbgtrc

; 6409 :             build_herc_iface_mac( iMAC, NULL );

  000f3	33 d2		 xor	 edx, edx
  000f5	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  000fd	e8 00 00 00 00	 call	 build_herc_iface_mac
$LN7@InitMACAdd:

; 6410 :             VERIFY( FormatMAC( &pszMAC, iMAC ) == 0);

  00102	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR iMAC$[rsp]
  0010a	48 8d 4c 24 68	 lea	 rcx, QWORD PTR pszMAC$1[rsp]
  0010f	e8 00 00 00 00	 call	 FormatMAC
  00114	85 c0		 test	 eax, eax
  00116	74 5c		 je	 SHORT $LN18@InitMACAdd
$LN10@InitMACAdd:
  00118	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG175402
  0011f	41 b8 0a 19 00
	00		 mov	 r8d, 6410		; 0000190aH
  00125	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175403
  0012c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175404
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0013f	85 c0		 test	 eax, eax
  00141	74 20		 je	 SHORT $LN19@InitMACAdd
  00143	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG175406
  0014a	41 b8 0a 19 00
	00		 mov	 r8d, 6410		; 0000190aH
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175407
  00157	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175408
  0015e	e8 00 00 00 00	 call	 DebuggerTrace
$LN19@InitMACAdd:
  00163	33 c0		 xor	 eax, eax
  00165	85 c0		 test	 eax, eax
  00167	75 af		 jne	 SHORT $LN10@InitMACAdd
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016f	85 c0		 test	 eax, eax
  00171	74 01		 je	 SHORT $LN20@InitMACAdd
  00173	cc		 int	 3
$LN20@InitMACAdd:
$LN18@InitMACAdd:
  00174	33 c0		 xor	 eax, eax
  00176	85 c0		 test	 eax, eax
  00178	75 88		 jne	 SHORT $LN7@InitMACAdd

; 6411 :             free( tthwaddr );

  0017a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tthwaddr$[rsp]
  0017f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6412 :             tthwaddr = pszMAC;

  00185	48 8b 44 24 68	 mov	 rax, QWORD PTR pszMAC$1[rsp]
  0018a	48 89 44 24 58	 mov	 QWORD PTR tthwaddr$[rsp], rax
$LN16@InitMACAdd:

; 6413 :         }
; 6414 : 
; 6415 :         grp->tthwaddr = strdup( tthwaddr );

  0018f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tthwaddr$[rsp]
  00194	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0019a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  001a2	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 6416 :         memcpy( grp->iMAC, iMAC, IFHWADDRLEN );

  001a6	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  001ae	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  001b6	48 8d b8 28 06
	00 00		 lea	 rdi, QWORD PTR [rax+1576]
  001bd	48 8b f1	 mov	 rsi, rcx
  001c0	b9 06 00 00 00	 mov	 ecx, 6
  001c5	f3 a4		 rep movsb

; 6417 :         free( tthwaddr );

  001c7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tthwaddr$[rsp]
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6418 : 
; 6419 : #if defined( ENABLE_IPV6 )
; 6420 :         memset( &grp->iaDriveLLAddr6, 0, sizeof(grp->iaDriveLLAddr6) );

  001d2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  001da	48 05 62 06 00
	00		 add	 rax, 1634		; 00000662H
  001e0	48 8b f8	 mov	 rdi, rax
  001e3	33 c0		 xor	 eax, eax
  001e5	b9 10 00 00 00	 mov	 ecx, 16
  001ea	f3 aa		 rep stosb

; 6421 :         memset( grp->szDriveLLAddr6, 0, sizeof(grp->szDriveLLAddr6) );

  001ec	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  001f4	48 05 72 06 00
	00		 add	 rax, 1650		; 00000672H
  001fa	48 8b f8	 mov	 rdi, rax
  001fd	33 c0		 xor	 eax, eax
  001ff	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00204	f3 aa		 rep stosb

; 6422 : #endif
; 6423 : 
; 6424 :     } else {

  00206	e9 a7 03 00 00	 jmp	 $LN15@InitMACAdd
$LN14@InitMACAdd:

; 6425 : 
; 6426 :         /* If grp->tthwaddr specified a valid MAC address use it, */
; 6427 :         /* otherwise create a MAC address. This MAC address is    */
; 6428 :         /* reported to and used by the guest. The reported MAC    */
; 6429 :         /* is used to create the guests link local IPv6 address.  */
; 6430 :         if (grp->tthwaddr &&
; 6431 :             ParseMAC( grp->tthwaddr, iMAC ) == 0 &&

  0020b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00213	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00218	74 61		 je	 SHORT $LN21@InitMACAdd
  0021a	48 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR iMAC$[rsp]
  00222	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0022a	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  0022e	e8 00 00 00 00	 call	 ParseMAC
  00233	85 c0		 test	 eax, eax
  00235	75 44		 jne	 SHORT $LN21@InitMACAdd
  00237	41 b8 06 00 00
	00		 mov	 r8d, 6
  0023d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?zeromac@?1??InitMACAddr@@9@9
  00244	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  0024c	e8 00 00 00 00	 call	 memcmp
  00251	85 c0		 test	 eax, eax
  00253	74 26		 je	 SHORT $LN21@InitMACAdd

; 6432 :             memcmp( iMAC, zeromac, IFHWADDRLEN ) != 0)
; 6433 :         {
; 6434 :             memcpy( grp->iMAC, iMAC, IFHWADDRLEN );

  00255	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0025d	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  00265	48 8d b8 28 06
	00 00		 lea	 rdi, QWORD PTR [rax+1576]
  0026c	48 8b f1	 mov	 rsi, rcx
  0026f	b9 06 00 00 00	 mov	 ecx, 6
  00274	f3 a4		 rep movsb

; 6435 :         } else {

  00276	e9 f5 00 00 00	 jmp	 $LN22@InitMACAdd
$LN21@InitMACAdd:

; 6436 :             free( grp->tthwaddr );

  0027b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00283	48 8b 48 70	 mov	 rcx, QWORD PTR [rax+112]
  00287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6437 :             build_herc_iface_mac( iMAC, NULL );

  0028d	33 d2		 xor	 edx, edx
  0028f	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  00297	e8 00 00 00 00	 call	 build_herc_iface_mac

; 6438 :             MSGBUF( szMAC, "%02x:%02x:%02x:%02x:%02x:%02x",

  0029c	b8 01 00 00 00	 mov	 eax, 1
  002a1	48 6b c0 05	 imul	 rax, rax, 5
  002a5	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR iMAC$[rsp+rax]
  002ad	b9 01 00 00 00	 mov	 ecx, 1
  002b2	48 6b c9 04	 imul	 rcx, rcx, 4
  002b6	0f b6 8c 0c 88
	00 00 00	 movzx	 ecx, BYTE PTR iMAC$[rsp+rcx]
  002be	ba 01 00 00 00	 mov	 edx, 1
  002c3	48 6b d2 03	 imul	 rdx, rdx, 3
  002c7	0f b6 94 14 88
	00 00 00	 movzx	 edx, BYTE PTR iMAC$[rsp+rdx]
  002cf	bf 01 00 00 00	 mov	 edi, 1
  002d4	48 6b ff 02	 imul	 rdi, rdi, 2
  002d8	0f b6 bc 3c 88
	00 00 00	 movzx	 edi, BYTE PTR iMAC$[rsp+rdi]
  002e0	be 01 00 00 00	 mov	 esi, 1
  002e5	48 6b f6 01	 imul	 rsi, rsi, 1
  002e9	0f b6 b4 34 88
	00 00 00	 movzx	 esi, BYTE PTR iMAC$[rsp+rsi]
  002f1	41 b8 01 00 00
	00		 mov	 r8d, 1
  002f7	4d 6b c0 00	 imul	 r8, r8, 0
  002fb	46 0f b6 84 04
	88 00 00 00	 movzx	 r8d, BYTE PTR iMAC$[rsp+r8]
  00304	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  00308	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0030c	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  00310	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  00314	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  00318	45 8b c8	 mov	 r9d, r8d
  0031b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175412
  00322	ba 12 00 00 00	 mov	 edx, 18
  00327	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szMAC$[rsp]
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6439 :                     iMAC[0], iMAC[1], iMAC[2], iMAC[3], iMAC[4], iMAC[5] );
; 6440 :             grp->tthwaddr = strdup( szMAC );

  00335	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR szMAC$[rsp]
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00343	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  0034b	48 89 41 70	 mov	 QWORD PTR [rcx+112], rax

; 6441 :             memcpy( grp->iMAC, iMAC, IFHWADDRLEN );

  0034f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00357	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  0035f	48 8d b8 28 06
	00 00		 lea	 rdi, QWORD PTR [rax+1576]
  00366	48 8b f1	 mov	 rsi, rcx
  00369	b9 06 00 00 00	 mov	 ecx, 6
  0036e	f3 a4		 rep movsb
$LN22@InitMACAdd:

; 6442 :         }
; 6443 : 
; 6444 : #if defined( ENABLE_IPV6 )
; 6445 :         /* Create a Driver MAC address using pseudo-random numbers */
; 6446 :         for (j = 0; j < 6; j++)

  00370	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  00378	eb 0a		 jmp	 SHORT $LN13@InitMACAdd
$LN11@InitMACAdd:
  0037a	8b 44 24 50	 mov	 eax, DWORD PTR j$[rsp]
  0037e	ff c0		 inc	 eax
  00380	89 44 24 50	 mov	 DWORD PTR j$[rsp], eax
$LN13@InitMACAdd:
  00384	83 7c 24 50 06	 cmp	 DWORD PTR j$[rsp], 6
  00389	7d 2c		 jge	 SHORT $LN12@InitMACAdd

; 6447 :             iMAC[j] = (int)((rand()/(RAND_MAX+1.0))*256);

  0038b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00391	f2 0f 2a c0	 cvtsi2sd xmm0, eax
  00395	f2 0f 5e 05 00
	00 00 00	 divsd	 xmm0, QWORD PTR __real@40e0000000000000
  0039d	f2 0f 59 05 00
	00 00 00	 mulsd	 xmm0, QWORD PTR __real@4070000000000000
  003a5	f2 0f 2c c0	 cvttsd2si eax, xmm0
  003a9	48 63 4c 24 50	 movsxd	 rcx, DWORD PTR j$[rsp]
  003ae	88 84 0c 88 00
	00 00		 mov	 BYTE PTR iMAC$[rsp+rcx], al
  003b5	eb c3		 jmp	 SHORT $LN11@InitMACAdd
$LN12@InitMACAdd:

; 6448 :         iMAC[0] &= 0xFE;  /* Clear multicast bit. */

  003b7	b8 01 00 00 00	 mov	 eax, 1
  003bc	48 6b c0 00	 imul	 rax, rax, 0
  003c0	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR iMAC$[rsp+rax]
  003c8	25 fe 00 00 00	 and	 eax, 254		; 000000feH
  003cd	b9 01 00 00 00	 mov	 ecx, 1
  003d2	48 6b c9 00	 imul	 rcx, rcx, 0
  003d6	88 84 0c 88 00
	00 00		 mov	 BYTE PTR iMAC$[rsp+rcx], al

; 6449 :         iMAC[0] |= 0x02;  /* Set local assignment bit. */

  003dd	b8 01 00 00 00	 mov	 eax, 1
  003e2	48 6b c0 00	 imul	 rax, rax, 0
  003e6	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR iMAC$[rsp+rax]
  003ee	83 c8 02	 or	 eax, 2
  003f1	b9 01 00 00 00	 mov	 ecx, 1
  003f6	48 6b c9 00	 imul	 rcx, rcx, 0
  003fa	88 84 0c 88 00
	00 00		 mov	 BYTE PTR iMAC$[rsp+rcx], al

; 6450 :         memcpy( grp->iaDriveMACAddr, iMAC, IFHWADDRLEN );

  00401	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00409	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR iMAC$[rsp]
  00411	48 8d b8 44 06
	00 00		 lea	 rdi, QWORD PTR [rax+1604]
  00418	48 8b f1	 mov	 rsi, rcx
  0041b	b9 06 00 00 00	 mov	 ecx, 6
  00420	f3 a4		 rep movsb

; 6451 :         MSGBUF( grp->szDriveMACAddr,

  00422	b8 01 00 00 00	 mov	 eax, 1
  00427	48 6b c0 05	 imul	 rax, rax, 5
  0042b	0f b6 84 04 88
	00 00 00	 movzx	 eax, BYTE PTR iMAC$[rsp+rax]
  00433	b9 01 00 00 00	 mov	 ecx, 1
  00438	48 6b c9 04	 imul	 rcx, rcx, 4
  0043c	0f b6 8c 0c 88
	00 00 00	 movzx	 ecx, BYTE PTR iMAC$[rsp+rcx]
  00444	ba 01 00 00 00	 mov	 edx, 1
  00449	48 6b d2 03	 imul	 rdx, rdx, 3
  0044d	0f b6 94 14 88
	00 00 00	 movzx	 edx, BYTE PTR iMAC$[rsp+rdx]
  00455	bf 01 00 00 00	 mov	 edi, 1
  0045a	48 6b ff 02	 imul	 rdi, rdi, 2
  0045e	0f b6 bc 3c 88
	00 00 00	 movzx	 edi, BYTE PTR iMAC$[rsp+rdi]
  00466	be 01 00 00 00	 mov	 esi, 1
  0046b	48 6b f6 01	 imul	 rsi, rsi, 1
  0046f	0f b6 b4 34 88
	00 00 00	 movzx	 esi, BYTE PTR iMAC$[rsp+rsi]
  00477	41 b8 01 00 00
	00		 mov	 r8d, 1
  0047d	4d 6b c0 00	 imul	 r8, r8, 0
  00481	46 0f b6 84 04
	88 00 00 00	 movzx	 r8d, BYTE PTR iMAC$[rsp+r8]
  0048a	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR grp$[rsp]
  00492	49 81 c1 4a 06
	00 00		 add	 r9, 1610		; 0000064aH
  00499	4c 89 4c 24 70	 mov	 QWORD PTR tv294[rsp], r9
  0049e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  004a2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  004a6	89 54 24 30	 mov	 DWORD PTR [rsp+48], edx
  004aa	89 7c 24 28	 mov	 DWORD PTR [rsp+40], edi
  004ae	89 74 24 20	 mov	 DWORD PTR [rsp+32], esi
  004b2	45 8b c8	 mov	 r9d, r8d
  004b5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175413
  004bc	ba 18 00 00 00	 mov	 edx, 24
  004c1	48 8b 44 24 70	 mov	 rax, QWORD PTR tv294[rsp]
  004c6	48 8b c8	 mov	 rcx, rax
  004c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6452 :                   "%02x:%02x:%02x:%02x:%02x:%02x",
; 6453 :                   iMAC[0], iMAC[1], iMAC[2], iMAC[3], iMAC[4], iMAC[5] );
; 6454 :         /* Create a Driver Link Local address from the Driver MAC address */
; 6455 :         addr6.s6_addr[0] = 0xFE;

  004cf	b8 01 00 00 00	 mov	 eax, 1
  004d4	48 6b c0 00	 imul	 rax, rax, 0
  004d8	c6 44 04 78 fe	 mov	 BYTE PTR addr6$[rsp+rax], 254 ; 000000feH

; 6456 :         addr6.s6_addr[1] = 0x80;

  004dd	b8 01 00 00 00	 mov	 eax, 1
  004e2	48 6b c0 01	 imul	 rax, rax, 1
  004e6	c6 44 04 78 80	 mov	 BYTE PTR addr6$[rsp+rax], 128 ; 00000080H

; 6457 :         memset( &addr6.s6_addr[2], 0, 6 );

  004eb	b8 01 00 00 00	 mov	 eax, 1
  004f0	48 6b c0 02	 imul	 rax, rax, 2
  004f4	48 8d 44 04 78	 lea	 rax, QWORD PTR addr6$[rsp+rax]
  004f9	48 8b f8	 mov	 rdi, rax
  004fc	33 c0		 xor	 eax, eax
  004fe	b9 06 00 00 00	 mov	 ecx, 6
  00503	f3 aa		 rep stosb

; 6458 :         memcpy( &addr6.s6_addr[8], &iMAC[0], 3 );

  00505	b8 01 00 00 00	 mov	 eax, 1
  0050a	48 6b c0 00	 imul	 rax, rax, 0
  0050e	b9 01 00 00 00	 mov	 ecx, 1
  00513	48 6b c9 08	 imul	 rcx, rcx, 8
  00517	48 8d 7c 0c 78	 lea	 rdi, QWORD PTR addr6$[rsp+rcx]
  0051c	48 8d b4 04 88
	00 00 00	 lea	 rsi, QWORD PTR iMAC$[rsp+rax]
  00524	b9 03 00 00 00	 mov	 ecx, 3
  00529	f3 a4		 rep movsb

; 6459 :         addr6.s6_addr[11] = 0xFF;

  0052b	b8 01 00 00 00	 mov	 eax, 1
  00530	48 6b c0 0b	 imul	 rax, rax, 11
  00534	c6 44 04 78 ff	 mov	 BYTE PTR addr6$[rsp+rax], 255 ; 000000ffH

; 6460 :         addr6.s6_addr[12] = 0xFE;

  00539	b8 01 00 00 00	 mov	 eax, 1
  0053e	48 6b c0 0c	 imul	 rax, rax, 12
  00542	c6 44 04 78 fe	 mov	 BYTE PTR addr6$[rsp+rax], 254 ; 000000feH

; 6461 :         memcpy( &addr6.s6_addr[13], &iMAC[3], 3 );

  00547	b8 01 00 00 00	 mov	 eax, 1
  0054c	48 6b c0 03	 imul	 rax, rax, 3
  00550	b9 01 00 00 00	 mov	 ecx, 1
  00555	48 6b c9 0d	 imul	 rcx, rcx, 13
  00559	48 8d 7c 0c 78	 lea	 rdi, QWORD PTR addr6$[rsp+rcx]
  0055e	48 8d b4 04 88
	00 00 00	 lea	 rsi, QWORD PTR iMAC$[rsp+rax]
  00566	b9 03 00 00 00	 mov	 ecx, 3
  0056b	f3 a4		 rep movsb

; 6462 :         memcpy( &grp->iaDriveLLAddr6, &addr6, sizeof(grp->iaDriveLLAddr6) );

  0056d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00575	48 8d 4c 24 78	 lea	 rcx, QWORD PTR addr6$[rsp]
  0057a	48 8d b8 62 06
	00 00		 lea	 rdi, QWORD PTR [rax+1634]
  00581	48 8b f1	 mov	 rsi, rcx
  00584	b9 10 00 00 00	 mov	 ecx, 16
  00589	f3 a4		 rep movsb

; 6463 :         hinet_ntop( AF_INET6, &addr6, grp->szDriveLLAddr6, sizeof(grp->szDriveLLAddr6) );

  0058b	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00593	48 05 72 06 00
	00		 add	 rax, 1650		; 00000672H
  00599	41 b9 30 00 00
	00		 mov	 r9d, 48			; 00000030H
  0059f	4c 8b c0	 mov	 r8, rax
  005a2	48 8d 54 24 78	 lea	 rdx, QWORD PTR addr6$[rsp]
  005a7	b9 17 00 00 00	 mov	 ecx, 23
  005ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_inet_ntop
$LN15@InitMACAdd:

; 6464 : #endif /* defined( ENABLE_IPV6 ) */
; 6465 :     }
; 6466 : }

  005b2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005ba	48 33 cc	 xor	 rcx, rsp
  005bd	e8 00 00 00 00	 call	 __security_check_cookie
  005c2	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  005c9	5f		 pop	 rdi
  005ca	5e		 pop	 rsi
  005cb	c3		 ret	 0
InitMACAddr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 48
signal_idx_event PROC

; 6371 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6372 :     obtain_lock( &grp->qlock );

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR grp$[rsp]
  0000e	48 83 c0 10	 add	 rax, 16
  00012	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175358
  00019	48 8b c8	 mov	 rcx, rax
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6373 :     signal_condition( &grp->qrcond );

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR grp$[rsp]
  00027	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175359
  0002e	48 8b c8	 mov	 rcx, rax
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition

; 6374 :     release_lock( &grp->qlock );

  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR grp$[rsp]
  0003c	48 83 c0 10	 add	 rax, 16
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175360
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6375 : }

  00050	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00054	c3		 ret	 0
signal_idx_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
bhr$ = 32
ban$ = 64
remove_and_free_any_buffers_on_chain PROC

; 6342 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6343 :     OSA_BHR*    bhr;                       // OSA_BHR
; 6344 : 
; 6345 :     // Obtain the buffer chain lock.
; 6346 :     obtain_lock( &ban->lockbhr );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175353
  00015	48 8b c8	 mov	 rcx, rax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN2@remove_and:

; 6347 : 
; 6348 :     // Remove and free the OSA_BHRs on the chain, if there are any...
; 6349 :     while( ban->firstbhr != NULL )

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00023	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00028	74 3b		 je	 SHORT $LN3@remove_and

; 6350 :     {
; 6351 :         bhr = ban->firstbhr;               // Pointer to first OSA_BHR

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  0002f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00033	48 89 44 24 20	 mov	 QWORD PTR bhr$[rsp], rax

; 6352 :         ban->firstbhr = bhr->next;         // Make the next the first OSA_BHR

  00038	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  0003d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bhr$[rsp]
  00042	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00045	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 6353 :         free( bhr->content );              // Free the buffer content string

  00049	48 8b 44 24 20	 mov	 rax, QWORD PTR bhr$[rsp]
  0004e	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6354 :         free( bhr );                       // Free the message buffer

  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bhr$[rsp]
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 6355 :     }

  00063	eb b9		 jmp	 SHORT $LN2@remove_and
$LN3@remove_and:

; 6356 : 
; 6357 :     // Reset the chain pointers.
; 6358 :     ban->firstbhr = NULL;                  // Clear

  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  0006a	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 6359 :     ban->lastbhr = NULL;                   // the chain

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00077	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 6360 :     ban->numbhr = 0;                       // pointers and count

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00084	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0

; 6361 : 
; 6362 :     // Release the buffer chain lock.
; 6363 :     release_lock( &ban->lockbhr );

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00090	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175354
  00097	48 8b c8	 mov	 rcx, rax
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6364 : }

  000a0	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a4	c3		 ret	 0
remove_and_free_any_buffers_on_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
bhr$ = 32
ban$ = 64
remove_buffer_from_chain PROC

; 6309 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 6310 :     OSA_BHR*    bhr;                       // OSA_BHR
; 6311 : 
; 6312 :     // Obtain the buffer chain lock.
; 6313 :     obtain_lock( &ban->lockbhr );

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175338
  00015	48 8b c8	 mov	 rcx, rax
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6314 : 
; 6315 :     // Point to first OSA_BHR on the chain.
; 6316 :     bhr = ban->firstbhr;                   // Pointer to first OSA_BHR

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00023	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00027	48 89 44 24 20	 mov	 QWORD PTR bhr$[rsp], rax

; 6317 : 
; 6318 :     // Remove the first OSA_BHR from the chain, if there is one...
; 6319 :     if (bhr)                               // If there is a OSA_BHR

  0002c	48 83 7c 24 20
	00		 cmp	 QWORD PTR bhr$[rsp], 0
  00032	74 54		 je	 SHORT $LN2@remove_buf

; 6320 :     {
; 6321 :         ban->firstbhr = bhr->next;         // Make the next the first OSA_BHR

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR bhr$[rsp]
  0003e	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00041	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 6322 :         ban->numbhr--;                     // Decrement number of OSA_BHRs

  00045	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  0004a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0004d	ff c8		 dec	 eax
  0004f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ban$[rsp]
  00054	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 6323 :         bhr->next = NULL;                  // Clear the pointer to next OSA_BHR

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR bhr$[rsp]
  0005c	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 6324 :         if (!ban->firstbhr)                // if there are no more OSA_BHRs

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00068	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  0006d	75 19		 jne	 SHORT $LN3@remove_buf

; 6325 :         {
; 6326 : //          ban->firstbhr = NULL;          // Clear
; 6327 :             ban->lastbhr = NULL;           // the chain

  0006f	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00074	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 6328 :             ban->numbhr = 0;               // pointers and count

  0007c	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  00081	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
$LN3@remove_buf:
$LN2@remove_buf:

; 6329 :         }
; 6330 :     }
; 6331 : 
; 6332 :     // Release the buffer chain lock.
; 6333 :     release_lock( &ban->lockbhr );

  00088	48 8b 44 24 40	 mov	 rax, QWORD PTR ban$[rsp]
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175341
  00094	48 8b c8	 mov	 rcx, rax
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 6334 : 
; 6335 :     return bhr;

  0009d	48 8b 44 24 20	 mov	 rax, QWORD PTR bhr$[rsp]

; 6336 : }

  000a2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a6	c3		 ret	 0
remove_buffer_from_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
ban$ = 48
bhr$ = 56
add_buffer_to_chain PROC

; 6279 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 6280 :     // Prepare OSA_BHR for adding to chain.
; 6281 :     if (!bhr) return;                      // Any OSA_BHR been passed?

  0000e	48 83 7c 24 38
	00		 cmp	 QWORD PTR bhr$[rsp], 0
  00014	75 05		 jne	 SHORT $LN2@add_buffer
  00016	e9 9d 00 00 00	 jmp	 $LN1@add_buffer
$LN2@add_buffer:

; 6282 :     bhr->next = NULL;                      // Clear the pointer to next OSA_BHR

  0001b	48 8b 44 24 38	 mov	 rax, QWORD PTR bhr$[rsp]
  00020	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 6283 : 
; 6284 :     // Obtain the buffer chain lock.
; 6285 :     obtain_lock( &ban->lockbhr );

  00027	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175328
  00033	48 8b c8	 mov	 rcx, rax
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 6286 : 
; 6287 :     // Add OSA_BHR to end of chain.
; 6288 :     if (ban->firstbhr)                     // if there are already OSA_BHRs

  0003c	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  00041	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00046	74 33		 je	 SHORT $LN3@add_buffer

; 6289 :     {
; 6290 :         ban->lastbhr->next = bhr;          // Add the OSA_BHR to

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  0004d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00051	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bhr$[rsp]
  00056	48 89 08	 mov	 QWORD PTR [rax], rcx

; 6291 :         ban->lastbhr = bhr;                // the end of the chain

  00059	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  0005e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bhr$[rsp]
  00063	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 6292 :         ban->numbhr++;                     // Increment number of OSA_BHRs

  00067	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  0006c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0006f	ff c0		 inc	 eax
  00071	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ban$[rsp]
  00076	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 6293 :     }

  00079	eb 28		 jmp	 SHORT $LN4@add_buffer
$LN3@add_buffer:

; 6294 :     else
; 6295 :     {
; 6296 :         ban->firstbhr = bhr;               // Make the OSA_BHR

  0007b	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  00080	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bhr$[rsp]
  00085	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 6297 :         ban->lastbhr = bhr;                // the only OSA_BHR

  00089	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  0008e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR bhr$[rsp]
  00093	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 6298 :         ban->numbhr = 1;                   // on the chain

  00097	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  0009c	c7 40 18 01 00
	00 00		 mov	 DWORD PTR [rax+24], 1
$LN4@add_buffer:

; 6299 :     }
; 6300 : 
; 6301 :     // Release the buffer chain lock.
; 6302 :     release_lock( &ban->lockbhr );

  000a3	48 8b 44 24 30	 mov	 rax, QWORD PTR ban$[rsp]
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG175331
  000af	48 8b c8	 mov	 rcx, rax
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN1@add_buffer:

; 6303 : }

  000b8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000bc	c3		 ret	 0
add_buffer_to_chain ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
buflen$ = 96
tv88 = 100
tv94 = 104
bhr$ = 112
tv74 = 120
tv139 = 128
etext$ = 136
__$ArrayPad$ = 176
dev$ = 208
size$ = 216
alloc_buffer PROC

; 6250 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec c0 00
	00 00		 sub	 rsp, 192		; 000000c0H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 6251 :     OSA_BHR*   bhr;                        // OSA_BHR
; 6252 :     int        buflen;                     // Buffer length
; 6253 :     char       etext[40];                  // malloc error text
; 6254 : 
; 6255 :     // Allocate the buffer.
; 6256 :     buflen = SizeBHR + size;

  00023	48 63 84 24 d8
	00 00 00	 movsxd	 rax, DWORD PTR size$[rsp]
  0002b	48 83 c0 18	 add	 rax, 24
  0002f	89 44 24 60	 mov	 DWORD PTR buflen$[rsp], eax

; 6257 :     bhr = malloc( buflen );                // Allocate the buffer

  00033	48 63 44 24 60	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00038	48 8b c8	 mov	 rcx, rax
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00041	48 89 44 24 70	 mov	 QWORD PTR bhr$[rsp], rax

; 6258 :     if (!bhr)                              // if the allocate was not successful...

  00046	48 83 7c 24 70
	00		 cmp	 QWORD PTR bhr$[rsp], 0
  0004c	0f 85 01 01 00
	00		 jne	 $LN2@alloc_buff

; 6259 :     {
; 6260 :         // Report the bad news.
; 6261 :         MSGBUF( etext, "malloc(%n)", &buflen );

  00052	4c 8d 4c 24 60	 lea	 r9, QWORD PTR buflen$[rsp]
  00057	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175316
  0005e	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00063	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 6262 :         // HHC00900 "%1d:%04X %s: error in function %s: %s"
; 6263 :         WRMSG(HHC00900, "E", LCSS_DEVNUM, dev->typname,

  00071	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0007a	74 12		 je	 SHORT $LN4@alloc_buff
  0007c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00084	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00088	89 44 24 64	 mov	 DWORD PTR tv88[rsp], eax
  0008c	eb 08		 jmp	 SHORT $LN5@alloc_buff
$LN4@alloc_buff:
  0008e	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN5@alloc_buff:
  00096	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0009f	74 14		 je	 SHORT $LN6@alloc_buff
  000a1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000ad	d1 f8		 sar	 eax, 1
  000af	89 44 24 68	 mov	 DWORD PTR tv94[rsp], eax
  000b3	eb 08		 jmp	 SHORT $LN7@alloc_buff
$LN6@alloc_buff:
  000b5	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN7@alloc_buff:
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c3	8b 08		 mov	 ecx, DWORD PTR [rax]
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000cb	48 89 44 24 78	 mov	 QWORD PTR tv74[rsp], rax
  000d0	b9 01 00 00 00	 mov	 ecx, 1
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000db	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv74[rsp]
  000e0	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000e5	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR etext$[rsp]
  000ed	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000f2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000fa	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000fe	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00103	8b 4c 24 64	 mov	 ecx, DWORD PTR tv88[rsp]
  00107	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0010b	8b 4c 24 68	 mov	 ecx, DWORD PTR tv94[rsp]
  0010f	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00113	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175317
  0011a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0011f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175318
  00126	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00130	41 b9 03 00 00
	00		 mov	 r9d, 3
  00136	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175319
  0013d	ba 78 18 00 00	 mov	 edx, 6264		; 00001878H
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175320
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 6264 :                              etext, strerror(errno) );
; 6265 :         return NULL;

  0014f	33 c0		 xor	 eax, eax
  00151	eb 32		 jmp	 SHORT $LN1@alloc_buff
$LN2@alloc_buff:

; 6266 :     }
; 6267 : 
; 6268 :     // Clear the buffer.
; 6269 :     memset( bhr, 0, buflen );

  00153	48 63 44 24 60	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00158	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv139[rsp], rax
  00160	48 8b 7c 24 70	 mov	 rdi, QWORD PTR bhr$[rsp]
  00165	33 c0		 xor	 eax, eax
  00167	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv139[rsp]
  0016f	f3 aa		 rep stosb

; 6270 :     bhr->arealen = size;

  00171	48 8b 44 24 70	 mov	 rax, QWORD PTR bhr$[rsp]
  00176	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR size$[rsp]
  0017d	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 6271 : 
; 6272 :     return bhr;

  00180	48 8b 44 24 70	 mov	 rax, QWORD PTR bhr$[rsp]
$LN1@alloc_buff:

; 6273 : }

  00185	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0018d	48 33 cc	 xor	 rcx, rsp
  00190	e8 00 00 00 00	 call	 __security_check_cookie
  00195	48 81 c4 c0 00
	00 00		 add	 rsp, 192		; 000000c0H
  0019c	5f		 pop	 rdi
  0019d	c3		 ret	 0
alloc_buffer ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 80
dev$ = 112
req_th$ = 120
req_rrh$ = 128
req_puk$ = 136
process_ulp_disable PROC

; 6226 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 6227 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00025	48 89 44 24 50	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_ul:

; 6228 : 
; 6229 :     UNREFERENCED(req_rrh);

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 fa		 jne	 SHORT $LN4@process_ul
$LN7@process_ul:

; 6230 :     UNREFERENCED(req_puk);

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 fa		 jne	 SHORT $LN7@process_ul

; 6231 : 
; 6232 :     /* Display the request MPC_TH etc., maybe. */
; 6233 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  00036	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00042	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00047	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175301
  0004e	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00053	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  00058	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00061	48 8b 44 24 78	 mov	 rax, QWORD PTR req_th$[rsp]
  00066	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0006b	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00073	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  00078	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175302
  0007f	ba 59 18 00 00	 mov	 edx, 6233		; 00001859H
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175303
  0008b	e8 00 00 00 00	 call	 dbgupd

; 6234 : 
; 6235 :     /* There will be a single MPC_PUS_03 containing the grp->gtcmfilt token */
; 6236 : 
; 6237 :     /* Disable the TUN interface */
; 6238 :     if (grp->l3)

  00090	48 8b 44 24 50	 mov	 rax, QWORD PTR grp$[rsp]
  00095	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  0009c	74 0f		 je	 SHORT $LN8@process_ul

; 6239 :         qeth_disable_interface( dev, grp );

  0009e	48 8b 54 24 50	 mov	 rdx, QWORD PTR grp$[rsp]
  000a3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000a8	e8 00 00 00 00	 call	 qeth_disable_interface
$LN8@process_ul:

; 6240 : 
; 6241 :     /* There will be no response. */
; 6242 :     return NULL;

  000ad	33 c0		 xor	 eax, eax

; 6243 : }

  000af	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000b3	c3		 ret	 0
process_ulp_disable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 80
dev$ = 112
req_th$ = 120
req_rrh$ = 128
req_puk$ = 136
process_ulp_takedown PROC

; 6205 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 6206 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00025	48 89 44 24 50	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_ul:

; 6207 : 
; 6208 :     UNREFERENCED(grp);

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 fa		 jne	 SHORT $LN4@process_ul
$LN7@process_ul:

; 6209 :     UNREFERENCED(req_rrh);

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 fa		 jne	 SHORT $LN7@process_ul
$LN10@process_ul:

; 6210 :     UNREFERENCED(req_puk);

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	75 fa		 jne	 SHORT $LN10@process_ul

; 6211 : 
; 6212 :     /* Display the request MPC_TH etc., maybe. */
; 6213 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00048	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175280
  00054	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00059	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0005e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR req_th$[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00079	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175281
  00085	ba 45 18 00 00	 mov	 edx, 6213		; 00001845H
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175282
  00091	e8 00 00 00 00	 call	 dbgupd

; 6214 : 
; 6215 :     /* There will be no response. */
; 6216 :     return NULL;

  00096	33 c0		 xor	 eax, eax

; 6217 : }

  00098	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0009c	c3		 ret	 0
process_ulp_takedown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
uLength4$ = 80
rsp_rrh$ = 88
uLength3$ = 96
uLength1$ = 100
rsp_th$ = 104
tv164 = 112
uLength2$ = 116
rsp_puk$ = 120
rsp_pus_04$ = 128
rsp_bhr$ = 136
rsp_ph$ = 144
grp$ = 152
dev$ = 176
req_th$ = 184
req_rrh$ = 192
req_puk$ = 200
process_dm_act PROC

; 6113 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 6114 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_dm:

; 6115 : 
; 6116 : //C_PUS *req_pus_04;
; 6117 : 
; 6118 : OSA_BHR *rsp_bhr;
; 6119 : MPC_TH  *rsp_th;
; 6120 : MPC_RRH *rsp_rrh;
; 6121 : MPC_PH  *rsp_ph;
; 6122 : MPC_PUK *rsp_puk;
; 6123 : MPC_PUS *rsp_pus_04;
; 6124 : 
; 6125 : U32 uLength1;
; 6126 : U32 uLength2;
; 6127 : U32 uLength3;
; 6128 : U16 uLength4;
; 6129 : 
; 6130 :     UNREFERENCED(req_rrh);

  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 fa		 jne	 SHORT $LN4@process_dm
$LN7@process_dm:

; 6131 :     UNREFERENCED(req_puk);

  00039	33 c0		 xor	 eax, eax
  0003b	85 c0		 test	 eax, eax
  0003d	75 fa		 jne	 SHORT $LN7@process_dm

; 6132 : 
; 6133 :     /* Display the request MPC_TH etc., maybe. */
; 6134 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  0003f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00047	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0004e	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175255
  0005a	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0005f	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  00064	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0006d	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  00075	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00082	4c 8b 8c 24 b0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  0008a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175256
  00091	ba f6 17 00 00	 mov	 edx, 6134		; 000017f6H
  00096	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175257
  0009d	e8 00 00 00 00	 call	 dbgupd

; 6135 : 
; 6136 :     // Fix-up various lengths
; 6137 :     uLength4 = SIZE_PUS_04;                      // first MPC_PUS

  000a2	b8 09 00 00 00	 mov	 eax, 9
  000a7	66 89 44 24 50	 mov	 WORD PTR uLength4$[rsp], ax

; 6138 :     uLength3 = SIZE_PUK + uLength4;              // the MPC_PUK and the MPC_PUSs (the data)

  000ac	0f b7 44 24 50	 movzx	 eax, WORD PTR uLength4$[rsp]
  000b1	83 c0 0c	 add	 eax, 12
  000b4	89 44 24 60	 mov	 DWORD PTR uLength3$[rsp], eax

; 6139 :     uLength2 = SIZE_TH + SIZE_RRH_1 + SIZE_PH;   // the MPC_TH/MPC_RRH/MPC_PH

  000b8	c7 44 24 74 38
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 56 ; 00000038H

; 6140 :     uLength1 = uLength2 + uLength3;              // the MPC_TH/MPC_RRH/MPC_PH and data

  000c0	8b 44 24 60	 mov	 eax, DWORD PTR uLength3$[rsp]
  000c4	8b 4c 24 74	 mov	 ecx, DWORD PTR uLength2$[rsp]
  000c8	03 c8		 add	 ecx, eax
  000ca	8b c1		 mov	 eax, ecx
  000cc	89 44 24 64	 mov	 DWORD PTR uLength1$[rsp], eax

; 6141 : 
; 6142 :     // Allocate a buffer in which the response will be build.
; 6143 :     rsp_bhr = alloc_buffer( dev, uLength1+10 );

  000d0	8b 44 24 64	 mov	 eax, DWORD PTR uLength1$[rsp]
  000d4	83 c0 0a	 add	 eax, 10
  000d7	8b d0		 mov	 edx, eax
  000d9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000e1	e8 00 00 00 00	 call	 alloc_buffer
  000e6	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 6144 :     if (!rsp_bhr)

  000ee	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR rsp_bhr$[rsp], 0
  000f7	75 07		 jne	 SHORT $LN8@process_dm

; 6145 :         return NULL;

  000f9	33 c0		 xor	 eax, eax
  000fb	e9 cd 02 00 00	 jmp	 $LN1@process_dm
$LN8@process_dm:

; 6146 :     rsp_bhr->content = strdup( dev->dev_data );

  00100	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00108	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00115	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  0011d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 6147 :     rsp_bhr->datalen = uLength1;

  00121	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  00129	8b 4c 24 64	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0012d	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 6148 : 
; 6149 :     // Fix-up various pointers
; 6150 :     rsp_th = (MPC_TH*)((BYTE*)rsp_bhr + SizeBHR);

  00130	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  00138	48 83 c0 18	 add	 rax, 24
  0013c	48 89 44 24 68	 mov	 QWORD PTR rsp_th$[rsp], rax

; 6151 :     rsp_rrh = (MPC_RRH*)((BYTE*)rsp_th + SIZE_TH);

  00141	48 8b 44 24 68	 mov	 rax, QWORD PTR rsp_th$[rsp]
  00146	48 83 c0 14	 add	 rax, 20
  0014a	48 89 44 24 58	 mov	 QWORD PTR rsp_rrh$[rsp], rax

; 6152 :     rsp_ph = (MPC_PH*)((BYTE*)rsp_rrh + SIZE_RRH_1);

  0014f	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00154	48 83 c0 1c	 add	 rax, 28
  00158	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rsp_ph$[rsp], rax

; 6153 :     rsp_puk = (MPC_PUK*)((BYTE*)rsp_ph + SIZE_PH);

  00160	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  00168	48 83 c0 08	 add	 rax, 8
  0016c	48 89 44 24 78	 mov	 QWORD PTR rsp_puk$[rsp], rax

; 6154 :     rsp_pus_04 = (MPC_PUS*)((BYTE*)rsp_puk + SIZE_PUK);

  00171	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  00176	48 83 c0 0c	 add	 rax, 12
  0017a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rsp_pus_04$[rsp], rax

; 6155 : 
; 6156 :     // Prepare MPC_TH
; 6157 :     STORE_FW( rsp_th->first4, MPC_TH_FIRST4 );

  00182	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00187	e8 00 00 00 00	 call	 _byteswap_ulong
  0018c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00191	8b d0		 mov	 edx, eax
  00193	e8 00 00 00 00	 call	 store_fw_noswap

; 6158 :     STORE_FW( rsp_th->offrrh, SIZE_TH );

  00198	b9 14 00 00 00	 mov	 ecx, 20
  0019d	e8 00 00 00 00	 call	 _byteswap_ulong
  001a2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  001a7	48 83 c1 08	 add	 rcx, 8
  001ab	8b d0		 mov	 edx, eax
  001ad	e8 00 00 00 00	 call	 store_fw_noswap

; 6159 :     STORE_FW( rsp_th->length, uLength1 );

  001b2	8b 4c 24 64	 mov	 ecx, DWORD PTR uLength1$[rsp]
  001b6	e8 00 00 00 00	 call	 _byteswap_ulong
  001bb	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  001c0	48 83 c1 0c	 add	 rcx, 12
  001c4	8b d0		 mov	 edx, eax
  001c6	e8 00 00 00 00	 call	 store_fw_noswap

; 6160 :     STORE_HW( rsp_th->unknown10, 0x0FFC );            /* !!! */

  001cb	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  001cf	e8 00 00 00 00	 call	 _byteswap_ushort
  001d4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  001d9	48 83 c1 10	 add	 rcx, 16
  001dd	0f b7 d0	 movzx	 edx, ax
  001e0	e8 00 00 00 00	 call	 store_hw_noswap

; 6161 :     STORE_HW( rsp_th->numrrh, 1 );

  001e5	66 b9 01 00	 mov	 cx, 1
  001e9	e8 00 00 00 00	 call	 _byteswap_ushort
  001ee	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  001f3	48 83 c1 12	 add	 rcx, 18
  001f7	0f b7 d0	 movzx	 edx, ax
  001fa	e8 00 00 00 00	 call	 store_hw_noswap

; 6162 : 
; 6163 :     // Prepare MPC_RRH
; 6164 :     rsp_rrh->type = RRH_TYPE_ULP;

  001ff	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00204	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 6165 : //  rsp_rrh->proto = PROTOCOL_UNKNOWN;
; 6166 :     rsp_rrh->proto = PROTOCOL_02;

  00208	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  0020d	c6 40 05 02	 mov	 BYTE PTR [rax+5], 2

; 6167 :     STORE_HW( rsp_rrh->numph, 1 );

  00211	66 b9 01 00	 mov	 cx, 1
  00215	e8 00 00 00 00	 call	 _byteswap_ushort
  0021a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  0021f	48 83 c1 06	 add	 rcx, 6
  00223	0f b7 d0	 movzx	 edx, ax
  00226	e8 00 00 00 00	 call	 store_hw_noswap

; 6168 :     STORE_FW( rsp_rrh->seqnum, ++grp->seqnumcm );

  0022b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00233	8b 80 0c 06 00
	00		 mov	 eax, DWORD PTR [rax+1548]
  00239	ff c0		 inc	 eax
  0023b	89 44 24 70	 mov	 DWORD PTR tv164[rsp], eax
  0023f	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00247	8b 4c 24 70	 mov	 ecx, DWORD PTR tv164[rsp]
  0024b	89 88 0c 06 00
	00		 mov	 DWORD PTR [rax+1548], ecx
  00251	8b 4c 24 70	 mov	 ecx, DWORD PTR tv164[rsp]
  00255	e8 00 00 00 00	 call	 _byteswap_ulong
  0025a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  0025f	48 83 c1 08	 add	 rcx, 8
  00263	8b d0		 mov	 edx, eax
  00265	e8 00 00 00 00	 call	 store_fw_noswap

; 6169 :     memcpy( rsp_rrh->ackseq, req_rrh->seqnum, 4 );

  0026a	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  0026f	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR req_rrh$[rsp]
  00277	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0027a	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 6170 :     STORE_HW( rsp_rrh->offph, SIZE_RRH_1 );

  0027d	66 b9 1c 00	 mov	 cx, 28
  00281	e8 00 00 00 00	 call	 _byteswap_ushort
  00286	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  0028b	48 83 c1 10	 add	 rcx, 16
  0028f	0f b7 d0	 movzx	 edx, ax
  00292	e8 00 00 00 00	 call	 store_hw_noswap

; 6171 :     STORE_HW( rsp_rrh->lenfida, (U16)uLength3 );

  00297	0f b7 4c 24 60	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0029c	e8 00 00 00 00	 call	 _byteswap_ushort
  002a1	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002a6	48 83 c1 12	 add	 rcx, 18
  002aa	0f b7 d0	 movzx	 edx, ax
  002ad	e8 00 00 00 00	 call	 store_hw_noswap

; 6172 :     STORE_F3( rsp_rrh->lenalda, uLength3 );

  002b2	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength3$[rsp]
  002b6	e8 00 00 00 00	 call	 _byteswap_ulong
  002bb	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002c0	48 83 c1 14	 add	 rcx, 20
  002c4	8b d0		 mov	 edx, eax
  002c6	e8 00 00 00 00	 call	 store_f3_noswap

; 6173 :     rsp_rrh->tokenx5 = MPC_TOKEN_X5;

  002cb	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  002d0	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 6174 :     memcpy( rsp_rrh->token, grp->gtcmconn, MPC_TOKEN_LENGTH );

  002d4	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  002d9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  002e1	8b 89 38 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1592]
  002e7	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 6175 : 
; 6176 :     // Prepare MPC_PH
; 6177 :     rsp_ph->locdata = PH_LOC_1;

  002ea	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  002f2	c6 00 01	 mov	 BYTE PTR [rax], 1

; 6178 :     STORE_F3( rsp_ph->lendata, uLength3 );

  002f5	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength3$[rsp]
  002f9	e8 00 00 00 00	 call	 _byteswap_ulong
  002fe	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00306	48 ff c1	 inc	 rcx
  00309	8b d0		 mov	 edx, eax
  0030b	e8 00 00 00 00	 call	 store_f3_noswap

; 6179 :     STORE_FW( rsp_ph->offdata, uLength2 );

  00310	8b 4c 24 74	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00314	e8 00 00 00 00	 call	 _byteswap_ulong
  00319	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00321	48 83 c1 04	 add	 rcx, 4
  00325	8b d0		 mov	 edx, eax
  00327	e8 00 00 00 00	 call	 store_fw_noswap

; 6180 : 
; 6181 :     // Prepare MPC_PUK
; 6182 :     STORE_HW( rsp_puk->length, SIZE_PUK );

  0032c	66 b9 0c 00	 mov	 cx, 12
  00330	e8 00 00 00 00	 call	 _byteswap_ushort
  00335	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  0033a	0f b7 d0	 movzx	 edx, ax
  0033d	e8 00 00 00 00	 call	 store_hw_noswap

; 6183 :     rsp_puk->what = PUK_WHAT_43;

  00342	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  00347	c6 40 02 43	 mov	 BYTE PTR [rax+2], 67	; 00000043H

; 6184 :     rsp_puk->type = PUK_TYPE_ACTIVE;

  0034b	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  00350	c6 40 03 60	 mov	 BYTE PTR [rax+3], 96	; 00000060H

; 6185 :     STORE_HW( rsp_puk->lenpus, uLength4 );

  00354	0f b7 4c 24 50	 movzx	 ecx, WORD PTR uLength4$[rsp]
  00359	e8 00 00 00 00	 call	 _byteswap_ushort
  0035e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  00363	48 83 c1 04	 add	 rcx, 4
  00367	0f b7 d0	 movzx	 edx, ax
  0036a	e8 00 00 00 00	 call	 store_hw_noswap

; 6186 : 
; 6187 :     // Prepare first MPC_PUS
; 6188 :     STORE_HW( rsp_pus_04->length, SIZE_PUS_04 );

  0036f	66 b9 09 00	 mov	 cx, 9
  00373	e8 00 00 00 00	 call	 _byteswap_ushort
  00378	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_04$[rsp]
  00380	0f b7 d0	 movzx	 edx, ax
  00383	e8 00 00 00 00	 call	 store_hw_noswap

; 6189 :     rsp_pus_04->what = PUS_WHAT_04;

  00388	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  00390	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 6190 :     rsp_pus_04->type = PUS_TYPE_04;

  00394	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  0039c	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 6191 :     rsp_pus_04->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  003a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  003a8	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 6192 :     memcpy( rsp_pus_04->vc.pus_04.token, grp->gtulpconn, MPC_TOKEN_LENGTH );

  003ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  003b4	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  003bc	8b 89 40 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1600]
  003c2	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 6193 : 
; 6194 :     return rsp_bhr;

  003c5	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
$LN1@process_dm:

; 6195 : }

  003cd	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  003d4	c3		 ret	 0
process_dm_act ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
uLength4$ = 80
len_pus_0B$ = 84
rsp_rrh$ = 88
uLength3$ = 96
uLength1$ = 100
rsp_th$ = 104
rsp_pus_04$ = 112
rsp_pus_08$ = 120
rsp_pus_07$ = 128
tv203 = 136
uLength2$ = 140
rsp_puk$ = 144
grp$ = 152
rsp_bhr$ = 160
rsp_ph$ = 168
req_pus_0B$ = 176
req_pus_04$ = 184
req_pus_06$ = 192
rsp_pus_0B$ = 200
dev$ = 240
req_th$ = 248
req_rrh$ = 256
req_puk$ = 264
process_ulp_setup PROC

; 5970 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H

; 5971 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0001d	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00025	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00029	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_ul:

; 5972 : 
; 5973 : MPC_PUS *req_pus_04;
; 5974 : //C_PUS *req_pus_05;
; 5975 : MPC_PUS *req_pus_06;
; 5976 : MPC_PUS *req_pus_0B;
; 5977 : U16      len_pus_0B;
; 5978 : 
; 5979 : OSA_BHR *rsp_bhr;
; 5980 : MPC_TH  *rsp_th;
; 5981 : MPC_RRH *rsp_rrh;
; 5982 : MPC_PH  *rsp_ph;
; 5983 : MPC_PUK *rsp_puk;
; 5984 : MPC_PUS *rsp_pus_04;
; 5985 : MPC_PUS *rsp_pus_08;
; 5986 : MPC_PUS *rsp_pus_07;
; 5987 : MPC_PUS *rsp_pus_0B;
; 5988 : 
; 5989 : U32 uLength1;
; 5990 : U32 uLength2;
; 5991 : U32 uLength3;
; 5992 : U16 uLength4;
; 5993 : 
; 5994 :     UNREFERENCED(req_rrh);

  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 fa		 jne	 SHORT $LN4@process_ul

; 5995 : 
; 5996 :     /* Display the request MPC_TH etc., maybe. */
; 5997 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  0003b	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  0004a	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175206
  00056	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  0005b	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  00060	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00069	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  00071	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00076	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0007e	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00086	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175207
  0008d	ba 6d 17 00 00	 mov	 edx, 5997		; 0000176dH
  00092	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175208
  00099	e8 00 00 00 00	 call	 dbgupd

; 5998 : 
; 5999 :     /* Point to the expected MPC_PUS and check they are present. */
; 6000 :     req_pus_04 = mpc_point_pus( dev, req_puk, PUS_TYPE_04 );

  0009e	41 b0 04	 mov	 r8b, 4
  000a1	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000a9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000b7	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR req_pus_04$[rsp], rax

; 6001 :     req_pus_06 = mpc_point_pus( dev, req_puk, PUS_TYPE_06 );

  000bf	41 b0 06	 mov	 r8b, 6
  000c2	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000ca	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000d8	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR req_pus_06$[rsp], rax

; 6002 :     req_pus_0B = mpc_point_pus( dev, req_puk, PUS_TYPE_0B );

  000e0	41 b0 0b	 mov	 r8b, 11
  000e3	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000eb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000f9	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR req_pus_0B$[rsp], rax

; 6003 :     if( !req_pus_04 || !req_pus_06 || !req_pus_0B )

  00101	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR req_pus_04$[rsp], 0
  0010a	74 16		 je	 SHORT $LN6@process_ul
  0010c	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR req_pus_06$[rsp], 0
  00115	74 0b		 je	 SHORT $LN6@process_ul
  00117	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR req_pus_0B$[rsp], 0
  00120	75 33		 jne	 SHORT $LN5@process_ul
$LN6@process_ul:

; 6004 :     {
; 6005 :         /* FIXME Expected pus not present, error message please. */
; 6006 :         DBGTRC(dev, "process_ulp_setup: Expected pus not present");

  00122	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175211
  00129	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012e	4c 8b 8c 24 f0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00136	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175212
  0013d	ba 76 17 00 00	 mov	 edx, 6006		; 00001776H
  00142	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175213
  00149	e8 00 00 00 00	 call	 dbgtrc

; 6007 :         return NULL;

  0014e	33 c0		 xor	 eax, eax
  00150	e9 71 04 00 00	 jmp	 $LN1@process_ul
$LN5@process_ul:

; 6008 :     }
; 6009 :     FETCH_HW( len_pus_0B, req_pus_0B->length);

  00155	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR req_pus_0B$[rsp]
  0015d	48 8b c8	 mov	 rcx, rax
  00160	e8 00 00 00 00	 call	 fetch_hw_noswap
  00165	0f b7 c8	 movzx	 ecx, ax
  00168	e8 00 00 00 00	 call	 _byteswap_ushort
  0016d	66 89 44 24 54	 mov	 WORD PTR len_pus_0B$[rsp], ax

; 6010 : 
; 6011 :     /* Copy the guests ULP Connection token from request PUS_TYPE_04. */
; 6012 :     /* FIXME: The ULP Connection token is unique for each data path.  */
; 6013 :     /* FIXME: If multiple data paths are ever supported, the token    */
; 6014 :     /* FIXME: needs to be kept in a data path related block, not grp. */
; 6015 :     memcpy( grp->gtulpconn, req_pus_04->vc.pus_04.token, MPC_TOKEN_LENGTH );

  00172	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0017a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR req_pus_04$[rsp]
  00182	8b 49 05	 mov	 ecx, DWORD PTR [rcx+5]
  00185	89 88 40 06 00
	00		 mov	 DWORD PTR [rax+1600], ecx

; 6016 : 
; 6017 :     // Fix-up various lengths
; 6018 :     uLength4 = SIZE_PUS_04 +                     // first MPC_PUS

  0018b	0f b7 44 24 54	 movzx	 eax, WORD PTR len_pus_0B$[rsp]
  00190	83 c0 1a	 add	 eax, 26
  00193	66 89 44 24 50	 mov	 WORD PTR uLength4$[rsp], ax

; 6019 :                SIZE_PUS_08 +                     // second MPC_PUS
; 6020 :                SIZE_PUS_07 +                     // third MPC_PUS
; 6021 :                len_pus_0B;                       // fourth MPC_PUS
; 6022 :     uLength3 = SIZE_PUK + uLength4;              // the MPC_PUK and the MPC_PUSs (the data)

  00198	0f b7 44 24 50	 movzx	 eax, WORD PTR uLength4$[rsp]
  0019d	83 c0 0c	 add	 eax, 12
  001a0	89 44 24 60	 mov	 DWORD PTR uLength3$[rsp], eax

; 6023 :     uLength2 = SIZE_TH + SIZE_RRH_1 + SIZE_PH;   // the MPC_TH/MPC_RRH/MPC_PH

  001a4	c7 84 24 8c 00
	00 00 38 00 00
	00		 mov	 DWORD PTR uLength2$[rsp], 56 ; 00000038H

; 6024 :     uLength1 = uLength2 + uLength3;              // the MPC_TH/MPC_RRH/MPC_PH and data

  001af	8b 44 24 60	 mov	 eax, DWORD PTR uLength3$[rsp]
  001b3	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR uLength2$[rsp]
  001ba	03 c8		 add	 ecx, eax
  001bc	8b c1		 mov	 eax, ecx
  001be	89 44 24 64	 mov	 DWORD PTR uLength1$[rsp], eax

; 6025 : 
; 6026 :     // Allocate a buffer in which the response will be build.
; 6027 :     rsp_bhr = alloc_buffer( dev, uLength1+10 );

  001c2	8b 44 24 64	 mov	 eax, DWORD PTR uLength1$[rsp]
  001c6	83 c0 0a	 add	 eax, 10
  001c9	8b d0		 mov	 edx, eax
  001cb	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001d3	e8 00 00 00 00	 call	 alloc_buffer
  001d8	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 6028 :     if (!rsp_bhr)

  001e0	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rsp_bhr$[rsp], 0
  001e9	75 07		 jne	 SHORT $LN7@process_ul

; 6029 :         return NULL;

  001eb	33 c0		 xor	 eax, eax
  001ed	e9 d4 03 00 00	 jmp	 $LN1@process_ul
$LN7@process_ul:

; 6030 :     rsp_bhr->content = strdup( dev->dev_data );

  001f2	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fa	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00207	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  0020f	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 6031 :     rsp_bhr->datalen = uLength1;

  00213	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  0021b	8b 4c 24 64	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0021f	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 6032 : 
; 6033 :     // Fix-up various pointers
; 6034 :     rsp_th = (MPC_TH*)((BYTE*)rsp_bhr + SizeBHR);

  00222	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  0022a	48 83 c0 18	 add	 rax, 24
  0022e	48 89 44 24 68	 mov	 QWORD PTR rsp_th$[rsp], rax

; 6035 :     rsp_rrh = (MPC_RRH*)((BYTE*)rsp_th + SIZE_TH);

  00233	48 8b 44 24 68	 mov	 rax, QWORD PTR rsp_th$[rsp]
  00238	48 83 c0 14	 add	 rax, 20
  0023c	48 89 44 24 58	 mov	 QWORD PTR rsp_rrh$[rsp], rax

; 6036 :     rsp_ph = (MPC_PH*)((BYTE*)rsp_rrh + SIZE_RRH_1);

  00241	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00246	48 83 c0 1c	 add	 rax, 28
  0024a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR rsp_ph$[rsp], rax

; 6037 :     rsp_puk = (MPC_PUK*)((BYTE*)rsp_ph + SIZE_PH);

  00252	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  0025a	48 83 c0 08	 add	 rax, 8
  0025e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rsp_puk$[rsp], rax

; 6038 :     rsp_pus_04 = (MPC_PUS*)((BYTE*)rsp_puk + SIZE_PUK);

  00266	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  0026e	48 83 c0 0c	 add	 rax, 12
  00272	48 89 44 24 70	 mov	 QWORD PTR rsp_pus_04$[rsp], rax

; 6039 :     rsp_pus_08 = (MPC_PUS*)((BYTE*)rsp_pus_04 + SIZE_PUS_04);

  00277	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  0027c	48 83 c0 09	 add	 rax, 9
  00280	48 89 44 24 78	 mov	 QWORD PTR rsp_pus_08$[rsp], rax

; 6040 :     rsp_pus_07 = (MPC_PUS*)((BYTE*)rsp_pus_08 + SIZE_PUS_08);

  00285	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  0028a	48 83 c0 09	 add	 rax, 9
  0028e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rsp_pus_07$[rsp], rax

; 6041 :     rsp_pus_0B = (MPC_PUS*)((BYTE*)rsp_pus_07 + SIZE_PUS_07);

  00296	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_07$[rsp]
  0029e	48 83 c0 08	 add	 rax, 8
  002a2	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR rsp_pus_0B$[rsp], rax

; 6042 : 
; 6043 :     // Prepare MPC_TH
; 6044 :     STORE_FW( rsp_th->first4, MPC_TH_FIRST4 );

  002aa	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  002af	e8 00 00 00 00	 call	 _byteswap_ulong
  002b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  002b9	8b d0		 mov	 edx, eax
  002bb	e8 00 00 00 00	 call	 store_fw_noswap

; 6045 :     STORE_FW( rsp_th->offrrh, SIZE_TH );

  002c0	b9 14 00 00 00	 mov	 ecx, 20
  002c5	e8 00 00 00 00	 call	 _byteswap_ulong
  002ca	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  002cf	48 83 c1 08	 add	 rcx, 8
  002d3	8b d0		 mov	 edx, eax
  002d5	e8 00 00 00 00	 call	 store_fw_noswap

; 6046 :     STORE_FW( rsp_th->length, uLength1 );

  002da	8b 4c 24 64	 mov	 ecx, DWORD PTR uLength1$[rsp]
  002de	e8 00 00 00 00	 call	 _byteswap_ulong
  002e3	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  002e8	48 83 c1 0c	 add	 rcx, 12
  002ec	8b d0		 mov	 edx, eax
  002ee	e8 00 00 00 00	 call	 store_fw_noswap

; 6047 :     STORE_HW( rsp_th->unknown10, 0x0FFC );            /* !!! */

  002f3	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  002f7	e8 00 00 00 00	 call	 _byteswap_ushort
  002fc	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00301	48 83 c1 10	 add	 rcx, 16
  00305	0f b7 d0	 movzx	 edx, ax
  00308	e8 00 00 00 00	 call	 store_hw_noswap

; 6048 :     STORE_HW( rsp_th->numrrh, 1 );

  0030d	66 b9 01 00	 mov	 cx, 1
  00311	e8 00 00 00 00	 call	 _byteswap_ushort
  00316	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  0031b	48 83 c1 12	 add	 rcx, 18
  0031f	0f b7 d0	 movzx	 edx, ax
  00322	e8 00 00 00 00	 call	 store_hw_noswap

; 6049 : 
; 6050 :     // Prepare MPC_RRH
; 6051 :     rsp_rrh->type = RRH_TYPE_ULP;

  00327	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  0032c	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 6052 : //  rsp_rrh->proto = PROTOCOL_UNKNOWN;
; 6053 :     rsp_rrh->proto = PROTOCOL_02;

  00330	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00335	c6 40 05 02	 mov	 BYTE PTR [rax+5], 2

; 6054 :     STORE_HW( rsp_rrh->numph, 1 );

  00339	66 b9 01 00	 mov	 cx, 1
  0033d	e8 00 00 00 00	 call	 _byteswap_ushort
  00342	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  00347	48 83 c1 06	 add	 rcx, 6
  0034b	0f b7 d0	 movzx	 edx, ax
  0034e	e8 00 00 00 00	 call	 store_hw_noswap

; 6055 :     STORE_FW( rsp_rrh->seqnum, ++grp->seqnumcm );

  00353	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0035b	8b 80 0c 06 00
	00		 mov	 eax, DWORD PTR [rax+1548]
  00361	ff c0		 inc	 eax
  00363	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  0036a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  00372	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  00379	89 88 0c 06 00
	00		 mov	 DWORD PTR [rax+1548], ecx
  0037f	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  00386	e8 00 00 00 00	 call	 _byteswap_ulong
  0038b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  00390	48 83 c1 08	 add	 rcx, 8
  00394	8b d0		 mov	 edx, eax
  00396	e8 00 00 00 00	 call	 store_fw_noswap

; 6056 :     memcpy( rsp_rrh->ackseq, req_rrh->seqnum, 4 );

  0039b	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  003a0	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR req_rrh$[rsp]
  003a8	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  003ab	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 6057 :     STORE_HW( rsp_rrh->offph, SIZE_RRH_1 );

  003ae	66 b9 1c 00	 mov	 cx, 28
  003b2	e8 00 00 00 00	 call	 _byteswap_ushort
  003b7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  003bc	48 83 c1 10	 add	 rcx, 16
  003c0	0f b7 d0	 movzx	 edx, ax
  003c3	e8 00 00 00 00	 call	 store_hw_noswap

; 6058 :     STORE_HW( rsp_rrh->lenfida, (U16)uLength3 );

  003c8	0f b7 4c 24 60	 movzx	 ecx, WORD PTR uLength3$[rsp]
  003cd	e8 00 00 00 00	 call	 _byteswap_ushort
  003d2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  003d7	48 83 c1 12	 add	 rcx, 18
  003db	0f b7 d0	 movzx	 edx, ax
  003de	e8 00 00 00 00	 call	 store_hw_noswap

; 6059 :     STORE_F3( rsp_rrh->lenalda, uLength3 );

  003e3	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength3$[rsp]
  003e7	e8 00 00 00 00	 call	 _byteswap_ulong
  003ec	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  003f1	48 83 c1 14	 add	 rcx, 20
  003f5	8b d0		 mov	 edx, eax
  003f7	e8 00 00 00 00	 call	 store_f3_noswap

; 6060 :     rsp_rrh->tokenx5 = MPC_TOKEN_X5;

  003fc	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00401	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 6061 :     memcpy( rsp_rrh->token, grp->gtcmconn, MPC_TOKEN_LENGTH );

  00405	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  0040a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00412	8b 89 38 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1592]
  00418	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 6062 : 
; 6063 :     // Prepare MPC_PH
; 6064 :     rsp_ph->locdata = PH_LOC_1;

  0041b	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  00423	c6 00 01	 mov	 BYTE PTR [rax], 1

; 6065 :     STORE_F3( rsp_ph->lendata, uLength3 );

  00426	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0042a	e8 00 00 00 00	 call	 _byteswap_ulong
  0042f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00437	48 ff c1	 inc	 rcx
  0043a	8b d0		 mov	 edx, eax
  0043c	e8 00 00 00 00	 call	 store_f3_noswap

; 6066 :     STORE_FW( rsp_ph->offdata, uLength2 );

  00441	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR uLength2$[rsp]
  00448	e8 00 00 00 00	 call	 _byteswap_ulong
  0044d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00455	48 83 c1 04	 add	 rcx, 4
  00459	8b d0		 mov	 edx, eax
  0045b	e8 00 00 00 00	 call	 store_fw_noswap

; 6067 : 
; 6068 :     // Prepare MPC_PUK
; 6069 :     STORE_HW( rsp_puk->length, SIZE_PUK );

  00460	66 b9 0c 00	 mov	 cx, 12
  00464	e8 00 00 00 00	 call	 _byteswap_ushort
  00469	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  00471	0f b7 d0	 movzx	 edx, ax
  00474	e8 00 00 00 00	 call	 store_hw_noswap

; 6070 :     rsp_puk->what = PUK_WHAT_41;

  00479	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  00481	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 6071 :     rsp_puk->type = PUK_TYPE_CONFIRM;

  00485	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  0048d	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 6072 :     STORE_HW( rsp_puk->lenpus, uLength4 );

  00491	0f b7 4c 24 50	 movzx	 ecx, WORD PTR uLength4$[rsp]
  00496	e8 00 00 00 00	 call	 _byteswap_ushort
  0049b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  004a3	48 83 c1 04	 add	 rcx, 4
  004a7	0f b7 d0	 movzx	 edx, ax
  004aa	e8 00 00 00 00	 call	 store_hw_noswap

; 6073 : 
; 6074 :     // Prepare first MPC_PUS
; 6075 :     STORE_HW( rsp_pus_04->length, SIZE_PUS_04 );

  004af	66 b9 09 00	 mov	 cx, 9
  004b3	e8 00 00 00 00	 call	 _byteswap_ushort
  004b8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_pus_04$[rsp]
  004bd	0f b7 d0	 movzx	 edx, ax
  004c0	e8 00 00 00 00	 call	 store_hw_noswap

; 6076 :     rsp_pus_04->what = PUS_WHAT_04;

  004c5	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  004ca	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 6077 :     rsp_pus_04->type = PUS_TYPE_04;

  004ce	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  004d3	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 6078 :     rsp_pus_04->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  004d7	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  004dc	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 6079 :     memcpy( rsp_pus_04->vc.pus_04.token, grp->gtulpconn, MPC_TOKEN_LENGTH );

  004e0	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  004e5	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  004ed	8b 89 40 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1600]
  004f3	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 6080 : 
; 6081 :     // Prepare second MPC_PUS
; 6082 :     /* FIXME: The ULP Connection tokens need to be unique for each data path. */
; 6083 :     /* FIXME: If multiple data paths are ever supported, QTOKEN5 shouldn't    */
; 6084 :     /* FIXME: be used. something unique is required. Something incorporating  */
; 6085 :     /* FIXME: the data paths device address perhaps? It will also need to be  */
; 6086 :     /* FIXME: kept in a data path related block, not grp.                     */
; 6087 :     STORE_HW( rsp_pus_08->length, SIZE_PUS_08 );

  004f6	66 b9 09 00	 mov	 cx, 9
  004fa	e8 00 00 00 00	 call	 _byteswap_ushort
  004ff	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_pus_08$[rsp]
  00504	0f b7 d0	 movzx	 edx, ax
  00507	e8 00 00 00 00	 call	 store_hw_noswap

; 6088 :     rsp_pus_08->what = PUS_WHAT_04;

  0050c	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  00511	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 6089 :     rsp_pus_08->type = PUS_TYPE_08;

  00515	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  0051a	c6 40 03 08	 mov	 BYTE PTR [rax+3], 8

; 6090 :     rsp_pus_08->vc.pus_08.tokenx5 = MPC_TOKEN_X5;

  0051e	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  00523	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 6091 :     STORE_FW( rsp_pus_08->vc.pus_08.token, QTOKEN5 );

  00527	b9 f5 e3 c5 d8	 mov	 ecx, -658119691		; d8c5e3f5H
  0052c	e8 00 00 00 00	 call	 _byteswap_ulong
  00531	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_pus_08$[rsp]
  00536	48 83 c1 05	 add	 rcx, 5
  0053a	8b d0		 mov	 edx, eax
  0053c	e8 00 00 00 00	 call	 store_fw_noswap

; 6092 : 
; 6093 :     // Prepare third MPC_PUS
; 6094 :     STORE_HW( rsp_pus_07->length, SIZE_PUS_07 );

  00541	66 b9 08 00	 mov	 cx, 8
  00545	e8 00 00 00 00	 call	 _byteswap_ushort
  0054a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_07$[rsp]
  00552	0f b7 d0	 movzx	 edx, ax
  00555	e8 00 00 00 00	 call	 store_hw_noswap

; 6095 :     rsp_pus_07->what = PUS_WHAT_04;

  0055a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_07$[rsp]
  00562	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 6096 :     rsp_pus_07->type = PUS_TYPE_07;

  00566	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_07$[rsp]
  0056e	c6 40 03 07	 mov	 BYTE PTR [rax+3], 7

; 6097 :     memcpy( rsp_pus_07->vc.pus_07.unknown04+0, req_pus_06->vc.pus_06.unknown04, 2 );

  00572	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_07$[rsp]
  0057a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR req_pus_06$[rsp]
  00582	0f b7 49 04	 movzx	 ecx, WORD PTR [rcx+4]
  00586	66 89 48 04	 mov	 WORD PTR [rax+4], cx

; 6098 :     STORE_HW( rsp_pus_07->vc.pus_07.unknown04+2, 0x0000 );

  0058a	33 c9		 xor	 ecx, ecx
  0058c	e8 00 00 00 00	 call	 _byteswap_ushort
  00591	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_07$[rsp]
  00599	48 83 c1 06	 add	 rcx, 6
  0059d	0f b7 d0	 movzx	 edx, ax
  005a0	e8 00 00 00 00	 call	 store_hw_noswap

; 6099 : 
; 6100 :     // Prepare fourth MPC_PUS
; 6101 :     memcpy( rsp_pus_0B, req_pus_0B, len_pus_0B );

  005a5	0f b7 44 24 54	 movzx	 eax, WORD PTR len_pus_0B$[rsp]
  005aa	48 8b bc 24 c8
	00 00 00	 mov	 rdi, QWORD PTR rsp_pus_0B$[rsp]
  005b2	48 8b b4 24 b0
	00 00 00	 mov	 rsi, QWORD PTR req_pus_0B$[rsp]
  005ba	8b c8		 mov	 ecx, eax
  005bc	f3 a4		 rep movsb

; 6102 : 
; 6103 :     return rsp_bhr;

  005be	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
$LN1@process_ul:

; 6104 : }

  005c6	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  005cd	5f		 pop	 rdi
  005ce	5e		 pop	 rsi
  005cf	c3		 ret	 0
process_ulp_setup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
len_req_pus_0A$ = 48
len_rsp_pus_0A$ = 52
uLength4$ = 56
rsp_rrh$ = 64
uLength3$ = 72
rsp_pus_01$ = 80
uLength1$ = 88
rsp_th$ = 96
tv188 = 104
uLength2$ = 108
rsp_puk$ = 112
grp$ = 120
rsp_bhr$ = 128
rsp_ph$ = 136
rsp_pus_0A$ = 144
req_pus_01$ = 152
req_pus_0A$ = 160
dev$ = 208
req_th$ = 216
req_rrh$ = 224
req_puk$ = 232
process_ulp_enable PROC

; 5848 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 5849 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0001d	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00025	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00029	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002d	48 89 44 24 78	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_ul:

; 5850 : 
; 5851 : MPC_PUS *req_pus_01;
; 5852 : MPC_PUS *req_pus_0A;
; 5853 : 
; 5854 : OSA_BHR *rsp_bhr;
; 5855 : MPC_TH  *rsp_th;
; 5856 : MPC_RRH *rsp_rrh;
; 5857 : MPC_PH  *rsp_ph;
; 5858 : MPC_PUK *rsp_puk;
; 5859 : MPC_PUS *rsp_pus_01;
; 5860 : MPC_PUS *rsp_pus_0A;
; 5861 : 
; 5862 : U16      len_req_pus_0A;
; 5863 : U16      len_rsp_pus_0A;
; 5864 : 
; 5865 : U32 uLength1;
; 5866 : U32 uLength2;
; 5867 : U32 uLength3;
; 5868 : U16 uLength4;
; 5869 : 
; 5870 :     UNREFERENCED(req_th);

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 fa		 jne	 SHORT $LN4@process_ul
$LN7@process_ul:

; 5871 :     UNREFERENCED(req_rrh);

  00038	33 c0		 xor	 eax, eax
  0003a	85 c0		 test	 eax, eax
  0003c	75 fa		 jne	 SHORT $LN7@process_ul

; 5872 : 
; 5873 :     /* Point to the expected MPC_PUS and check they are present. */
; 5874 :     req_pus_01 = mpc_point_pus( dev, req_puk, PUS_TYPE_01 );

  0003e	41 b0 01	 mov	 r8b, 1
  00041	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  00049	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  00057	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR req_pus_01$[rsp], rax

; 5875 :     req_pus_0A = mpc_point_pus( dev, req_puk, PUS_TYPE_0A );

  0005f	41 b0 0a	 mov	 r8b, 10
  00062	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  0006a	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  00078	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR req_pus_0A$[rsp], rax

; 5876 :     if( !req_pus_01 || !req_pus_0A )

  00080	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR req_pus_01$[rsp], 0
  00089	74 0b		 je	 SHORT $LN9@process_ul
  0008b	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR req_pus_0A$[rsp], 0
  00094	75 33		 jne	 SHORT $LN8@process_ul
$LN9@process_ul:

; 5877 :     {
; 5878 :         /* FIXME Expected pus not present, error message please. */
; 5879 :         DBGTRC(dev, "process_ulp_enable: Expected pus not present");

  00096	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175150
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175151
  000b1	ba f7 16 00 00	 mov	 edx, 5879		; 000016f7H
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175152
  000bd	e8 00 00 00 00	 call	 dbgtrc

; 5880 :         return NULL;

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 fa 03 00 00	 jmp	 $LN1@process_ul
$LN8@process_ul:

; 5881 :     }
; 5882 : 
; 5883 :     /* Copy the guests ULP Filter token from request PUS_TYPE_01. */
; 5884 :     memcpy( grp->gtulpfilt, req_pus_01->vc.pus_01.token, MPC_TOKEN_LENGTH );

  000c9	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  000ce	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR req_pus_01$[rsp]
  000d6	8b 49 07	 mov	 ecx, DWORD PTR [rcx+7]
  000d9	89 88 3c 06 00
	00		 mov	 DWORD PTR [rax+1596], ecx

; 5885 : 
; 5886 :     /* Determine length of request and response PUS_TYPE_0A. */
; 5887 :     len_rsp_pus_0A = SIZE_PUS_0A_B;

  000df	b8 18 00 00 00	 mov	 eax, 24
  000e4	66 89 44 24 34	 mov	 WORD PTR len_rsp_pus_0A$[rsp], ax

; 5888 :     FETCH_HW( len_req_pus_0A, req_pus_0A->length);

  000e9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR req_pus_0A$[rsp]
  000f1	48 8b c8	 mov	 rcx, rax
  000f4	e8 00 00 00 00	 call	 fetch_hw_noswap
  000f9	0f b7 c8	 movzx	 ecx, ax
  000fc	e8 00 00 00 00	 call	 _byteswap_ushort
  00101	66 89 44 24 30	 mov	 WORD PTR len_req_pus_0A$[rsp], ax

; 5889 :     if( len_req_pus_0A > SIZE_PUS_0A_B )

  00106	0f b7 44 24 30	 movzx	 eax, WORD PTR len_req_pus_0A$[rsp]
  0010b	83 f8 18	 cmp	 eax, 24
  0010e	7e 0a		 jle	 SHORT $LN10@process_ul

; 5890 :         len_rsp_pus_0A = len_req_pus_0A;

  00110	0f b7 44 24 30	 movzx	 eax, WORD PTR len_req_pus_0A$[rsp]
  00115	66 89 44 24 34	 mov	 WORD PTR len_rsp_pus_0A$[rsp], ax
$LN10@process_ul:

; 5891 : 
; 5892 :     // Fix-up various lengths
; 5893 :     uLength4 = SIZE_PUS_01 +                     // first MPC_PUS

  0011a	0f b7 44 24 34	 movzx	 eax, WORD PTR len_rsp_pus_0A$[rsp]
  0011f	83 c0 0b	 add	 eax, 11
  00122	66 89 44 24 38	 mov	 WORD PTR uLength4$[rsp], ax

; 5894 :                len_rsp_pus_0A;                   // second MPC_PUS
; 5895 :     uLength3 = SIZE_PUK + uLength4;              // the MPC_PUK and the MPC_PUSs (the data)

  00127	0f b7 44 24 38	 movzx	 eax, WORD PTR uLength4$[rsp]
  0012c	83 c0 0c	 add	 eax, 12
  0012f	89 44 24 48	 mov	 DWORD PTR uLength3$[rsp], eax

; 5896 :     uLength2 = SIZE_TH + SIZE_RRH_1 + SIZE_PH;   // the MPC_TH/MPC_RRH/MPC_PH

  00133	c7 44 24 6c 38
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 56 ; 00000038H

; 5897 :     uLength1 = uLength2 + uLength3;              // the MPC_TH/MPC_RRH/MPC_PH and data

  0013b	8b 44 24 48	 mov	 eax, DWORD PTR uLength3$[rsp]
  0013f	8b 4c 24 6c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00143	03 c8		 add	 ecx, eax
  00145	8b c1		 mov	 eax, ecx
  00147	89 44 24 58	 mov	 DWORD PTR uLength1$[rsp], eax

; 5898 : 
; 5899 :     // Allocate a buffer in which the response will be build.
; 5900 :     rsp_bhr = alloc_buffer( dev, uLength1+10 );

  0014b	8b 44 24 58	 mov	 eax, DWORD PTR uLength1$[rsp]
  0014f	83 c0 0a	 add	 eax, 10
  00152	8b d0		 mov	 edx, eax
  00154	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015c	e8 00 00 00 00	 call	 alloc_buffer
  00161	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 5901 :     if (!rsp_bhr)

  00169	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR rsp_bhr$[rsp], 0
  00172	75 07		 jne	 SHORT $LN11@process_ul

; 5902 :         return NULL;

  00174	33 c0		 xor	 eax, eax
  00176	e9 48 03 00 00	 jmp	 $LN1@process_ul
$LN11@process_ul:

; 5903 :     rsp_bhr->content = strdup( dev->dev_data );

  0017b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00183	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00190	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  00198	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 5904 :     rsp_bhr->datalen = uLength1;

  0019c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  001a4	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  001a8	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 5905 : 
; 5906 :     // Fix-up various pointers
; 5907 :     rsp_th = (MPC_TH*)((BYTE*)rsp_bhr + SizeBHR);

  001ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  001b3	48 83 c0 18	 add	 rax, 24
  001b7	48 89 44 24 60	 mov	 QWORD PTR rsp_th$[rsp], rax

; 5908 :     rsp_rrh = (MPC_RRH*)((BYTE*)rsp_th + SIZE_TH);

  001bc	48 8b 44 24 60	 mov	 rax, QWORD PTR rsp_th$[rsp]
  001c1	48 83 c0 14	 add	 rax, 20
  001c5	48 89 44 24 40	 mov	 QWORD PTR rsp_rrh$[rsp], rax

; 5909 :     rsp_ph = (MPC_PH*)((BYTE*)rsp_rrh + SIZE_RRH_1);

  001ca	48 8b 44 24 40	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  001cf	48 83 c0 1c	 add	 rax, 28
  001d3	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR rsp_ph$[rsp], rax

; 5910 :     rsp_puk = (MPC_PUK*)((BYTE*)rsp_ph + SIZE_PH);

  001db	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  001e3	48 83 c0 08	 add	 rax, 8
  001e7	48 89 44 24 70	 mov	 QWORD PTR rsp_puk$[rsp], rax

; 5911 :     rsp_pus_01 = (MPC_PUS*)((BYTE*)rsp_puk + SIZE_PUK);

  001ec	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  001f1	48 83 c0 0c	 add	 rax, 12
  001f5	48 89 44 24 50	 mov	 QWORD PTR rsp_pus_01$[rsp], rax

; 5912 :     rsp_pus_0A = (MPC_PUS*)((BYTE*)rsp_pus_01 + SIZE_PUS_01);

  001fa	48 8b 44 24 50	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  001ff	48 83 c0 0b	 add	 rax, 11
  00203	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rsp_pus_0A$[rsp], rax

; 5913 : 
; 5914 :     // Prepare MPC_TH
; 5915 :     STORE_FW( rsp_th->first4, MPC_TH_FIRST4 );

  0020b	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00210	e8 00 00 00 00	 call	 _byteswap_ulong
  00215	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  0021a	8b d0		 mov	 edx, eax
  0021c	e8 00 00 00 00	 call	 store_fw_noswap

; 5916 :     STORE_FW( rsp_th->offrrh, SIZE_TH );

  00221	b9 14 00 00 00	 mov	 ecx, 20
  00226	e8 00 00 00 00	 call	 _byteswap_ulong
  0022b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00230	48 83 c1 08	 add	 rcx, 8
  00234	8b d0		 mov	 edx, eax
  00236	e8 00 00 00 00	 call	 store_fw_noswap

; 5917 :     STORE_FW( rsp_th->length, uLength1 );

  0023b	8b 4c 24 58	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0023f	e8 00 00 00 00	 call	 _byteswap_ulong
  00244	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00249	48 83 c1 0c	 add	 rcx, 12
  0024d	8b d0		 mov	 edx, eax
  0024f	e8 00 00 00 00	 call	 store_fw_noswap

; 5918 :     STORE_HW( rsp_th->unknown10, 0x0FFC );            /* !!! */

  00254	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00258	e8 00 00 00 00	 call	 _byteswap_ushort
  0025d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00262	48 83 c1 10	 add	 rcx, 16
  00266	0f b7 d0	 movzx	 edx, ax
  00269	e8 00 00 00 00	 call	 store_hw_noswap

; 5919 :     STORE_HW( rsp_th->numrrh, 1 );

  0026e	66 b9 01 00	 mov	 cx, 1
  00272	e8 00 00 00 00	 call	 _byteswap_ushort
  00277	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  0027c	48 83 c1 12	 add	 rcx, 18
  00280	0f b7 d0	 movzx	 edx, ax
  00283	e8 00 00 00 00	 call	 store_hw_noswap

; 5920 : 
; 5921 :     // Prepare MPC_RRH
; 5922 :     rsp_rrh->type = RRH_TYPE_ULP;

  00288	48 8b 44 24 40	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  0028d	c6 40 04 41	 mov	 BYTE PTR [rax+4], 65	; 00000041H

; 5923 : //  rsp_rrh->proto = PROTOCOL_UNKNOWN;
; 5924 :     rsp_rrh->proto = PROTOCOL_02;

  00291	48 8b 44 24 40	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00296	c6 40 05 02	 mov	 BYTE PTR [rax+5], 2

; 5925 :     STORE_HW( rsp_rrh->numph, 1 );

  0029a	66 b9 01 00	 mov	 cx, 1
  0029e	e8 00 00 00 00	 call	 _byteswap_ushort
  002a3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002a8	48 83 c1 06	 add	 rcx, 6
  002ac	0f b7 d0	 movzx	 edx, ax
  002af	e8 00 00 00 00	 call	 store_hw_noswap

; 5926 :     STORE_FW( rsp_rrh->seqnum, ++grp->seqnumcm );

  002b4	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  002b9	8b 80 0c 06 00
	00		 mov	 eax, DWORD PTR [rax+1548]
  002bf	ff c0		 inc	 eax
  002c1	89 44 24 68	 mov	 DWORD PTR tv188[rsp], eax
  002c5	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  002ca	8b 4c 24 68	 mov	 ecx, DWORD PTR tv188[rsp]
  002ce	89 88 0c 06 00
	00		 mov	 DWORD PTR [rax+1548], ecx
  002d4	8b 4c 24 68	 mov	 ecx, DWORD PTR tv188[rsp]
  002d8	e8 00 00 00 00	 call	 _byteswap_ulong
  002dd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002e2	48 83 c1 08	 add	 rcx, 8
  002e6	8b d0		 mov	 edx, eax
  002e8	e8 00 00 00 00	 call	 store_fw_noswap

; 5927 :     memcpy( rsp_rrh->ackseq, req_rrh->seqnum, 4 );

  002ed	48 8b 44 24 40	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  002f2	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR req_rrh$[rsp]
  002fa	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  002fd	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 5928 :     STORE_HW( rsp_rrh->offph, SIZE_RRH_1 );

  00300	66 b9 1c 00	 mov	 cx, 28
  00304	e8 00 00 00 00	 call	 _byteswap_ushort
  00309	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  0030e	48 83 c1 10	 add	 rcx, 16
  00312	0f b7 d0	 movzx	 edx, ax
  00315	e8 00 00 00 00	 call	 store_hw_noswap

; 5929 :     STORE_HW( rsp_rrh->lenfida, (U16)uLength3 );

  0031a	0f b7 4c 24 48	 movzx	 ecx, WORD PTR uLength3$[rsp]
  0031f	e8 00 00 00 00	 call	 _byteswap_ushort
  00324	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  00329	48 83 c1 12	 add	 rcx, 18
  0032d	0f b7 d0	 movzx	 edx, ax
  00330	e8 00 00 00 00	 call	 store_hw_noswap

; 5930 :     STORE_F3( rsp_rrh->lenalda, uLength3 );

  00335	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00339	e8 00 00 00 00	 call	 _byteswap_ulong
  0033e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  00343	48 83 c1 14	 add	 rcx, 20
  00347	8b d0		 mov	 edx, eax
  00349	e8 00 00 00 00	 call	 store_f3_noswap

; 5931 :     rsp_rrh->tokenx5 = MPC_TOKEN_X5;

  0034e	48 8b 44 24 40	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00353	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5932 :     memcpy( rsp_rrh->token, grp->gtcmconn, MPC_TOKEN_LENGTH );

  00357	48 8b 44 24 40	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  0035c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR grp$[rsp]
  00361	8b 89 38 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1592]
  00367	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5933 : 
; 5934 :     // Prepare MPC_PH
; 5935 :     rsp_ph->locdata = PH_LOC_1;

  0036a	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  00372	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5936 :     STORE_F3( rsp_ph->lendata, uLength3 );

  00375	8b 4c 24 48	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00379	e8 00 00 00 00	 call	 _byteswap_ulong
  0037e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00386	48 ff c1	 inc	 rcx
  00389	8b d0		 mov	 edx, eax
  0038b	e8 00 00 00 00	 call	 store_f3_noswap

; 5937 :     STORE_FW( rsp_ph->offdata, uLength2 );

  00390	8b 4c 24 6c	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00394	e8 00 00 00 00	 call	 _byteswap_ulong
  00399	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  003a1	48 83 c1 04	 add	 rcx, 4
  003a5	8b d0		 mov	 edx, eax
  003a7	e8 00 00 00 00	 call	 store_fw_noswap

; 5938 : 
; 5939 :     // Prepare MPC_PUK
; 5940 :     STORE_HW( rsp_puk->length, SIZE_PUK );

  003ac	66 b9 0c 00	 mov	 cx, 12
  003b0	e8 00 00 00 00	 call	 _byteswap_ushort
  003b5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  003ba	0f b7 d0	 movzx	 edx, ax
  003bd	e8 00 00 00 00	 call	 store_hw_noswap

; 5941 :     rsp_puk->what = PUK_WHAT_41;

  003c2	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  003c7	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5942 :     rsp_puk->type = PUK_TYPE_ENABLE;

  003cb	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  003d0	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5943 :     STORE_HW( rsp_puk->lenpus, uLength4 );

  003d4	0f b7 4c 24 38	 movzx	 ecx, WORD PTR uLength4$[rsp]
  003d9	e8 00 00 00 00	 call	 _byteswap_ushort
  003de	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  003e3	48 83 c1 04	 add	 rcx, 4
  003e7	0f b7 d0	 movzx	 edx, ax
  003ea	e8 00 00 00 00	 call	 store_hw_noswap

; 5944 : 
; 5945 :     // Prepare first MPC_PUS
; 5946 :     STORE_HW( rsp_pus_01->length, SIZE_PUS_01 );

  003ef	66 b9 0b 00	 mov	 cx, 11
  003f3	e8 00 00 00 00	 call	 _byteswap_ushort
  003f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rsp_pus_01$[rsp]
  003fd	0f b7 d0	 movzx	 edx, ax
  00400	e8 00 00 00 00	 call	 store_hw_noswap

; 5947 :     rsp_pus_01->what = PUS_WHAT_04;

  00405	48 8b 44 24 50	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  0040a	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5948 :     rsp_pus_01->type = PUS_TYPE_01;

  0040e	48 8b 44 24 50	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  00413	c6 40 03 01	 mov	 BYTE PTR [rax+3], 1

; 5949 :     rsp_pus_01->vc.pus_01.proto = req_pus_01->vc.pus_01.proto;

  00417	48 8b 44 24 50	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  0041c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR req_pus_01$[rsp]
  00424	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00428	88 48 04	 mov	 BYTE PTR [rax+4], cl

; 5950 :     rsp_pus_01->vc.pus_01.unknown05 = 0x04;           /* !!! */

  0042b	48 8b 44 24 50	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  00430	c6 40 05 04	 mov	 BYTE PTR [rax+5], 4

; 5951 :     rsp_pus_01->vc.pus_01.tokenx5 = MPC_TOKEN_X5;

  00434	48 8b 44 24 50	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  00439	c6 40 06 05	 mov	 BYTE PTR [rax+6], 5

; 5952 :     STORE_FW( rsp_pus_01->vc.pus_01.token, QTOKEN4 );

  0043d	b9 f4 e3 c5 d8	 mov	 ecx, -658119692		; d8c5e3f4H
  00442	e8 00 00 00 00	 call	 _byteswap_ulong
  00447	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rsp_pus_01$[rsp]
  0044c	48 83 c1 07	 add	 rcx, 7
  00450	8b d0		 mov	 edx, eax
  00452	e8 00 00 00 00	 call	 store_fw_noswap

; 5953 : 
; 5954 :     // Prepare second MPC_PUS
; 5955 :     memcpy( rsp_pus_0A, req_pus_0A, len_req_pus_0A );

  00457	0f b7 44 24 30	 movzx	 eax, WORD PTR len_req_pus_0A$[rsp]
  0045c	48 8b bc 24 90
	00 00 00	 mov	 rdi, QWORD PTR rsp_pus_0A$[rsp]
  00464	48 8b b4 24 a0
	00 00 00	 mov	 rsi, QWORD PTR req_pus_0A$[rsp]
  0046c	8b c8		 mov	 ecx, eax
  0046e	f3 a4		 rep movsb

; 5956 :     STORE_HW( rsp_pus_0A->length, len_rsp_pus_0A );

  00470	0f b7 4c 24 34	 movzx	 ecx, WORD PTR len_rsp_pus_0A$[rsp]
  00475	e8 00 00 00 00	 call	 _byteswap_ushort
  0047a	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_0A$[rsp]
  00482	0f b7 d0	 movzx	 edx, ax
  00485	e8 00 00 00 00	 call	 store_hw_noswap

; 5957 :     STORE_HW( rsp_pus_0A->vc.pus_0A.mtu, grp->uMTU );

  0048a	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  0048f	0f b7 88 2e 06
	00 00		 movzx	 ecx, WORD PTR [rax+1582]
  00496	e8 00 00 00 00	 call	 _byteswap_ushort
  0049b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_0A$[rsp]
  004a3	48 83 c1 08	 add	 rcx, 8
  004a7	0f b7 d0	 movzx	 edx, ax
  004aa	e8 00 00 00 00	 call	 store_hw_noswap

; 5958 :     rsp_pus_0A->vc.pus_0A.linktype = QETH_LINK_TYPE_FAST_ETH;

  004af	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_0A$[rsp]
  004b7	c6 40 14 01	 mov	 BYTE PTR [rax+20], 1

; 5959 : 
; 5960 :     return rsp_bhr;

  004bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
$LN1@process_ul:

; 5961 : }

  004c3	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  004ca	5f		 pop	 rdi
  004cb	5e		 pop	 rsi
  004cc	c3		 ret	 0
process_ulp_enable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv129 = 96
tv139 = 100
tv145 = 104
grp$ = 112
req_pus_01$ = 120
tv132 = 128
req_pus_0A$ = 136
dev$ = 160
req_th$ = 168
req_rrh$ = 176
req_puk$ = 184
process_ulp_enable_extract PROC

; 5805 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 5806 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 89 44 24 70	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_ul:

; 5807 : 
; 5808 : MPC_PUS *req_pus_01;
; 5809 : MPC_PUS *req_pus_0A;
; 5810 : 
; 5811 :     UNREFERENCED(req_rrh);

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 fa		 jne	 SHORT $LN4@process_ul

; 5812 : 
; 5813 :     /* Display the request MPC_TH etc., maybe. */
; 5814 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  00036	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003e	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00045	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175086
  00051	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00056	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0005b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00064	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00079	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00081	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175087
  00088	ba b6 16 00 00	 mov	 edx, 5814		; 000016b6H
  0008d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175088
  00094	e8 00 00 00 00	 call	 dbgupd

; 5815 : 
; 5816 :     /* Point to the expected MPC_PUS and check they are present. */
; 5817 :     req_pus_01 = mpc_point_pus( dev, req_puk, PUS_TYPE_01 );

  00099	41 b0 01	 mov	 r8b, 1
  0009c	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000a4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000b2	48 89 44 24 78	 mov	 QWORD PTR req_pus_01$[rsp], rax

; 5818 :     req_pus_0A = mpc_point_pus( dev, req_puk, PUS_TYPE_0A );

  000b7	41 b0 0a	 mov	 r8b, 10
  000ba	48 8b 94 24 b8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000d0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR req_pus_0A$[rsp], rax

; 5819 :     if( !req_pus_01 || !req_pus_0A )

  000d8	48 83 7c 24 78
	00		 cmp	 QWORD PTR req_pus_01$[rsp], 0
  000de	74 0b		 je	 SHORT $LN6@process_ul
  000e0	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR req_pus_0A$[rsp], 0
  000e9	75 36		 jne	 SHORT $LN5@process_ul
$LN6@process_ul:

; 5820 :     {
; 5821 :         /* FIXME Expected pus not present, error message please. */
; 5822 :         DBGTRC(dev, "process_ulp_enable_extract: Expected pus not present");

  000eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175091
  000f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f7	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  000ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175092
  00106	ba be 16 00 00	 mov	 edx, 5822		; 000016beH
  0010b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175093
  00112	e8 00 00 00 00	 call	 dbgtrc

; 5823 :         return -1;

  00117	b8 ff ff ff ff	 mov	 eax, -1
  0011c	e9 3e 01 00 00	 jmp	 $LN1@process_ul
$LN5@process_ul:

; 5824 :     }
; 5825 : 
; 5826 :     /* Remember whether we are using layer2 or layer3. */
; 5827 :     grp->l3 = (req_pus_01->vc.pus_01.proto == PROTOCOL_LAYER3);

  00121	48 8b 44 24 78	 mov	 rax, QWORD PTR req_pus_01$[rsp]
  00126	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0012a	83 f8 03	 cmp	 eax, 3
  0012d	75 0a		 jne	 SHORT $LN8@process_ul
  0012f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv129[rsp], 1
  00137	eb 08		 jmp	 SHORT $LN9@process_ul
$LN8@process_ul:
  00139	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv129[rsp], 0
$LN9@process_ul:
  00141	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  00146	8b 4c 24 60	 mov	 ecx, DWORD PTR tv129[rsp]
  0014a	89 88 e4 05 00
	00		 mov	 DWORD PTR [rax+1508], ecx

; 5828 : 
; 5829 :     // HHC03800 "%1d:%04X %s: Adapter mode set to %s"
; 5830 :     WRMSG( HHC03800, "I", LCSS_DEVNUM, dev->typname, grp->l3 ? "Layer 3"

  00150	48 8b 44 24 70	 mov	 rax, QWORD PTR grp$[rsp]
  00155	83 b8 e4 05 00
	00 00		 cmp	 DWORD PTR [rax+1508], 0
  0015c	74 11		 je	 SHORT $LN10@process_ul
  0015e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175094
  00165	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  0016d	eb 0f		 jmp	 SHORT $LN11@process_ul
$LN10@process_ul:
  0016f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175095
  00176	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
$LN11@process_ul:
  0017e	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00187	74 12		 je	 SHORT $LN12@process_ul
  00189	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00191	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00195	89 44 24 64	 mov	 DWORD PTR tv139[rsp], eax
  00199	eb 08		 jmp	 SHORT $LN13@process_ul
$LN12@process_ul:
  0019b	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
$LN13@process_ul:
  001a3	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ac	74 14		 je	 SHORT $LN14@process_ul
  001ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001b6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001ba	d1 f8		 sar	 eax, 1
  001bc	89 44 24 68	 mov	 DWORD PTR tv145[rsp], eax
  001c0	eb 08		 jmp	 SHORT $LN15@process_ul
$LN14@process_ul:
  001c2	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN15@process_ul:
  001ca	b9 01 00 00 00	 mov	 ecx, 1
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  001dd	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001e2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ea	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001ee	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001f3	8b 4c 24 64	 mov	 ecx, DWORD PTR tv139[rsp]
  001f7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001fb	8b 4c 24 68	 mov	 ecx, DWORD PTR tv145[rsp]
  001ff	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00203	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175096
  0020a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175097
  00216	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00220	41 b9 03 00 00
	00		 mov	 r9d, 3
  00226	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175098
  0022d	ba c7 16 00 00	 mov	 edx, 5831		; 000016c7H
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175099
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5831 :                                                              : "Layer 2" );
; 5832 :     /* Clear any registered IP or MAC addresses. */
; 5833 :     unregister_all_ipv4( grp );

  0023f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR grp$[rsp]
  00244	e8 00 00 00 00	 call	 unregister_all_ipv4

; 5834 :     unregister_all_ipv6( grp );

  00249	48 8b 4c 24 70	 mov	 rcx, QWORD PTR grp$[rsp]
  0024e	e8 00 00 00 00	 call	 unregister_all_ipv6

; 5835 :     unregister_all_mac( grp );

  00253	48 8b 4c 24 70	 mov	 rcx, QWORD PTR grp$[rsp]
  00258	e8 00 00 00 00	 call	 unregister_all_mac

; 5836 : 
; 5837 :     return 0;

  0025d	33 c0		 xor	 eax, eax
$LN1@process_ul:

; 5838 : }

  0025f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00266	c3		 ret	 0
process_ulp_enable_extract ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 80
dev$ = 112
req_th$ = 120
req_rrh$ = 128
req_puk$ = 136
process_cm_disable PROC

; 5783 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5784 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00025	48 89 44 24 50	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_cm:

; 5785 : 
; 5786 :     UNREFERENCED(grp);

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 fa		 jne	 SHORT $LN4@process_cm
$LN7@process_cm:

; 5787 :     UNREFERENCED(req_rrh);

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 fa		 jne	 SHORT $LN7@process_cm
$LN10@process_cm:

; 5788 :     UNREFERENCED(req_puk);

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	75 fa		 jne	 SHORT $LN10@process_cm

; 5789 : 
; 5790 :     /* Display the request MPC_TH etc., maybe. */
; 5791 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00048	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175067
  00054	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00059	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0005e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR req_th$[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00079	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175068
  00085	ba 9f 16 00 00	 mov	 edx, 5791		; 0000169fH
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175069
  00091	e8 00 00 00 00	 call	 dbgupd

; 5792 : 
; 5793 :     /* There will be no response. */
; 5794 :     return NULL;

  00096	33 c0		 xor	 eax, eax

; 5795 : }

  00098	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0009c	c3		 ret	 0
process_cm_disable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
grp$ = 80
dev$ = 112
req_th$ = 120
req_rrh$ = 128
req_puk$ = 136
process_cm_takedown PROC

; 5765 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 5766 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00021	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00025	48 89 44 24 50	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_cm:

; 5767 : 
; 5768 :     UNREFERENCED(grp);

  0002a	33 c0		 xor	 eax, eax
  0002c	85 c0		 test	 eax, eax
  0002e	75 fa		 jne	 SHORT $LN4@process_cm
$LN7@process_cm:

; 5769 :     UNREFERENCED(req_rrh);

  00030	33 c0		 xor	 eax, eax
  00032	85 c0		 test	 eax, eax
  00034	75 fa		 jne	 SHORT $LN7@process_cm
$LN10@process_cm:

; 5770 :     UNREFERENCED(req_puk);

  00036	33 c0		 xor	 eax, eax
  00038	85 c0		 test	 eax, eax
  0003a	75 fa		 jne	 SHORT $LN10@process_cm

; 5771 : 
; 5772 :     /* Display the request MPC_TH etc., maybe. */
; 5773 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  0003c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00048	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175043
  00054	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00059	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0005e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00067	48 8b 44 24 78	 mov	 rax, QWORD PTR req_th$[rsp]
  0006c	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00071	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00079	4c 8b 4c 24 70	 mov	 r9, QWORD PTR dev$[rsp]
  0007e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175044
  00085	ba 8d 16 00 00	 mov	 edx, 5773		; 0000168dH
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175045
  00091	e8 00 00 00 00	 call	 dbgupd

; 5774 : 
; 5775 :     /* There will be no response. */
; 5776 :     return NULL;

  00096	33 c0		 xor	 eax, eax

; 5777 : }

  00098	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0009c	c3		 ret	 0
process_cm_takedown ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
uLength4$ = 80
uLength3$ = 84
rsp_rrh$ = 88
uLength1$ = 96
rsp_th$ = 104
rsp_pus_04$ = 112
rsp_pus_08$ = 120
uLength2$ = 128
rsp_puk$ = 136
rsp_pus_07$ = 144
rsp_bhr$ = 152
rsp_ph$ = 160
grp$ = 168
req_pus_04$ = 176
req_pus_06$ = 184
dev$ = 208
req_th$ = 216
req_rrh$ = 224
req_puk$ = 232
process_cm_setup PROC

; 5645 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 5646 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0001b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_cm:

; 5647 : 
; 5648 : MPC_PUS *req_pus_04;
; 5649 : MPC_PUS *req_pus_06;
; 5650 : 
; 5651 : OSA_BHR *rsp_bhr;
; 5652 : MPC_TH  *rsp_th;
; 5653 : MPC_RRH *rsp_rrh;
; 5654 : MPC_PH  *rsp_ph;
; 5655 : MPC_PUK *rsp_puk;
; 5656 : MPC_PUS *rsp_pus_04;
; 5657 : MPC_PUS *rsp_pus_08;
; 5658 : MPC_PUS *rsp_pus_07;
; 5659 : 
; 5660 : U32 uLength1;
; 5661 : U32 uLength2;
; 5662 : U32 uLength3;
; 5663 : U16 uLength4;
; 5664 : 
; 5665 :     UNREFERENCED(req_rrh);

  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 fa		 jne	 SHORT $LN4@process_cm

; 5666 : 
; 5667 :     /* Display the request MPC_TH etc., maybe. */
; 5668 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  00039	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00048	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175013
  00054	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00059	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0005e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00067	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  0006f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00074	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0007c	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00084	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175014
  0008b	ba 24 16 00 00	 mov	 edx, 5668		; 00001624H
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175015
  00097	e8 00 00 00 00	 call	 dbgupd

; 5669 : 
; 5670 :     /* Point to the expected MPC_PUS and check they are present. */
; 5671 :     req_pus_04 = mpc_point_pus( dev, req_puk, PUS_TYPE_04 );

  0009c	41 b0 04	 mov	 r8b, 4
  0009f	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000a7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000b5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR req_pus_04$[rsp], rax

; 5672 :     req_pus_06 = mpc_point_pus( dev, req_puk, PUS_TYPE_06 );

  000bd	41 b0 06	 mov	 r8b, 6
  000c0	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000c8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000d6	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR req_pus_06$[rsp], rax

; 5673 :     if( !req_pus_04 || !req_pus_06 )

  000de	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR req_pus_04$[rsp], 0
  000e7	74 0b		 je	 SHORT $LN6@process_cm
  000e9	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR req_pus_06$[rsp], 0
  000f2	75 33		 jne	 SHORT $LN5@process_cm
$LN6@process_cm:

; 5674 :     {
; 5675 :         /* FIXME Expected pus not present, error message please. */
; 5676 :         DBGTRC(dev, "process_cm_setup: Expected pus not present");

  000f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG175018
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00108	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG175019
  0010f	ba 2c 16 00 00	 mov	 edx, 5676		; 0000162cH
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG175020
  0011b	e8 00 00 00 00	 call	 dbgtrc

; 5677 :         return NULL;

  00120	33 c0		 xor	 eax, eax
  00122	e9 ce 03 00 00	 jmp	 $LN1@process_cm
$LN5@process_cm:

; 5678 :     }
; 5679 : 
; 5680 :     /* Copy the guests CM Connection token from request PUS_TYPE_04. */
; 5681 :     memcpy( grp->gtcmconn, req_pus_04->vc.pus_04.token, MPC_TOKEN_LENGTH );

  00127	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0012f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR req_pus_04$[rsp]
  00137	8b 49 05	 mov	 ecx, DWORD PTR [rcx+5]
  0013a	89 88 38 06 00
	00		 mov	 DWORD PTR [rax+1592], ecx

; 5682 : 
; 5683 :     // Fix-up various lengths
; 5684 :     uLength4 = SIZE_PUS_04 +                     // first MPC_PUS

  00140	b8 1a 00 00 00	 mov	 eax, 26
  00145	66 89 44 24 50	 mov	 WORD PTR uLength4$[rsp], ax

; 5685 :                SIZE_PUS_08 +                     // second MPC_PUS
; 5686 :                SIZE_PUS_07;                      // third MPC_PUS
; 5687 :     uLength3 = SIZE_PUK + uLength4;              // the MPC_PUK and the MPC_PUSs (the data)

  0014a	0f b7 44 24 50	 movzx	 eax, WORD PTR uLength4$[rsp]
  0014f	83 c0 0c	 add	 eax, 12
  00152	89 44 24 54	 mov	 DWORD PTR uLength3$[rsp], eax

; 5688 :     uLength2 = SIZE_TH + SIZE_RRH_1 + SIZE_PH;   // the MPC_TH/MPC_RRH/MPC_PH

  00156	c7 84 24 80 00
	00 00 38 00 00
	00		 mov	 DWORD PTR uLength2$[rsp], 56 ; 00000038H

; 5689 :     uLength1 = uLength2 + uLength3;              // the MPC_TH/MPC_RRH/MPC_PH and data

  00161	8b 44 24 54	 mov	 eax, DWORD PTR uLength3$[rsp]
  00165	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR uLength2$[rsp]
  0016c	03 c8		 add	 ecx, eax
  0016e	8b c1		 mov	 eax, ecx
  00170	89 44 24 60	 mov	 DWORD PTR uLength1$[rsp], eax

; 5690 : 
; 5691 :     // Allocate a buffer in which the response will be build.
; 5692 :     rsp_bhr = alloc_buffer( dev, uLength1+10 );

  00174	8b 44 24 60	 mov	 eax, DWORD PTR uLength1$[rsp]
  00178	83 c0 0a	 add	 eax, 10
  0017b	8b d0		 mov	 edx, eax
  0017d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00185	e8 00 00 00 00	 call	 alloc_buffer
  0018a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 5693 :     if (!rsp_bhr)

  00192	48 83 bc 24 98
	00 00 00 00	 cmp	 QWORD PTR rsp_bhr$[rsp], 0
  0019b	75 07		 jne	 SHORT $LN7@process_cm

; 5694 :         return NULL;

  0019d	33 c0		 xor	 eax, eax
  0019f	e9 51 03 00 00	 jmp	 $LN1@process_cm
$LN7@process_cm:

; 5695 :     rsp_bhr->content = strdup( dev->dev_data );

  001a4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ac	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  001b9	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  001c1	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 5696 :     rsp_bhr->datalen = uLength1;

  001c5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  001cd	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength1$[rsp]
  001d1	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 5697 : 
; 5698 :     // Fix-up various pointers
; 5699 :     rsp_th = (MPC_TH*)((BYTE*)rsp_bhr + SizeBHR);

  001d4	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  001dc	48 83 c0 18	 add	 rax, 24
  001e0	48 89 44 24 68	 mov	 QWORD PTR rsp_th$[rsp], rax

; 5700 :     rsp_rrh = (MPC_RRH*)((BYTE*)rsp_th + SIZE_TH);

  001e5	48 8b 44 24 68	 mov	 rax, QWORD PTR rsp_th$[rsp]
  001ea	48 83 c0 14	 add	 rax, 20
  001ee	48 89 44 24 58	 mov	 QWORD PTR rsp_rrh$[rsp], rax

; 5701 :     rsp_ph = (MPC_PH*)((BYTE*)rsp_rrh + SIZE_RRH_1);

  001f3	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  001f8	48 83 c0 1c	 add	 rax, 28
  001fc	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR rsp_ph$[rsp], rax

; 5702 :     rsp_puk = (MPC_PUK*)((BYTE*)rsp_ph + SIZE_PH);

  00204	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  0020c	48 83 c0 08	 add	 rax, 8
  00210	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR rsp_puk$[rsp], rax

; 5703 :     rsp_pus_04 = (MPC_PUS*)((BYTE*)rsp_puk + SIZE_PUK);

  00218	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  00220	48 83 c0 0c	 add	 rax, 12
  00224	48 89 44 24 70	 mov	 QWORD PTR rsp_pus_04$[rsp], rax

; 5704 :     rsp_pus_08 = (MPC_PUS*)((BYTE*)rsp_pus_04 + SIZE_PUS_04);

  00229	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  0022e	48 83 c0 09	 add	 rax, 9
  00232	48 89 44 24 78	 mov	 QWORD PTR rsp_pus_08$[rsp], rax

; 5705 :     rsp_pus_07 = (MPC_PUS*)((BYTE*)rsp_pus_08 + SIZE_PUS_08);

  00237	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  0023c	48 83 c0 09	 add	 rax, 9
  00240	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rsp_pus_07$[rsp], rax

; 5706 : 
; 5707 :     // Prepare MPC_TH
; 5708 :     STORE_FW( rsp_th->first4, MPC_TH_FIRST4 );

  00248	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  0024d	e8 00 00 00 00	 call	 _byteswap_ulong
  00252	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00257	8b d0		 mov	 edx, eax
  00259	e8 00 00 00 00	 call	 store_fw_noswap

; 5709 :     STORE_FW( rsp_th->offrrh, SIZE_TH );

  0025e	b9 14 00 00 00	 mov	 ecx, 20
  00263	e8 00 00 00 00	 call	 _byteswap_ulong
  00268	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  0026d	48 83 c1 08	 add	 rcx, 8
  00271	8b d0		 mov	 edx, eax
  00273	e8 00 00 00 00	 call	 store_fw_noswap

; 5710 :     STORE_FW( rsp_th->length, uLength1 );

  00278	8b 4c 24 60	 mov	 ecx, DWORD PTR uLength1$[rsp]
  0027c	e8 00 00 00 00	 call	 _byteswap_ulong
  00281	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00286	48 83 c1 0c	 add	 rcx, 12
  0028a	8b d0		 mov	 edx, eax
  0028c	e8 00 00 00 00	 call	 store_fw_noswap

; 5711 :     STORE_HW( rsp_th->unknown10, 0x0FFC );            /* !!! */

  00291	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00295	e8 00 00 00 00	 call	 _byteswap_ushort
  0029a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  0029f	48 83 c1 10	 add	 rcx, 16
  002a3	0f b7 d0	 movzx	 edx, ax
  002a6	e8 00 00 00 00	 call	 store_hw_noswap

; 5712 :     STORE_HW( rsp_th->numrrh, 1 );

  002ab	66 b9 01 00	 mov	 cx, 1
  002af	e8 00 00 00 00	 call	 _byteswap_ushort
  002b4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  002b9	48 83 c1 12	 add	 rcx, 18
  002bd	0f b7 d0	 movzx	 edx, ax
  002c0	e8 00 00 00 00	 call	 store_hw_noswap

; 5713 : 
; 5714 :     // Prepare MPC_RRH
; 5715 :     rsp_rrh->type = RRH_TYPE_CM;

  002c5	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  002ca	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 5716 :     rsp_rrh->proto = PROTOCOL_UNKNOWN;

  002ce	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  002d3	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5717 :     STORE_HW( rsp_rrh->numph, 1 );

  002d7	66 b9 01 00	 mov	 cx, 1
  002db	e8 00 00 00 00	 call	 _byteswap_ushort
  002e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002e5	48 83 c1 06	 add	 rcx, 6
  002e9	0f b7 d0	 movzx	 edx, ax
  002ec	e8 00 00 00 00	 call	 store_hw_noswap

; 5718 : //  STORE_FW( rsp_rrh->seqnum, ++grp->seqnumis );
; 5719 :     STORE_HW( rsp_rrh->offph, SIZE_RRH_1 );

  002f1	66 b9 1c 00	 mov	 cx, 28
  002f5	e8 00 00 00 00	 call	 _byteswap_ushort
  002fa	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002ff	48 83 c1 10	 add	 rcx, 16
  00303	0f b7 d0	 movzx	 edx, ax
  00306	e8 00 00 00 00	 call	 store_hw_noswap

; 5720 :     STORE_HW( rsp_rrh->lenfida, (U16)uLength3 );

  0030b	0f b7 4c 24 54	 movzx	 ecx, WORD PTR uLength3$[rsp]
  00310	e8 00 00 00 00	 call	 _byteswap_ushort
  00315	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  0031a	48 83 c1 12	 add	 rcx, 18
  0031e	0f b7 d0	 movzx	 edx, ax
  00321	e8 00 00 00 00	 call	 store_hw_noswap

; 5721 :     STORE_F3( rsp_rrh->lenalda, uLength3 );

  00326	8b 4c 24 54	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0032a	e8 00 00 00 00	 call	 _byteswap_ulong
  0032f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  00334	48 83 c1 14	 add	 rcx, 20
  00338	8b d0		 mov	 edx, eax
  0033a	e8 00 00 00 00	 call	 store_f3_noswap

; 5722 :     rsp_rrh->tokenx5 = MPC_TOKEN_X5;

  0033f	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00344	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5723 :     memcpy( rsp_rrh->token, grp->gtissue, MPC_TOKEN_LENGTH );

  00348	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  0034d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00355	8b 89 30 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1584]
  0035b	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5724 : 
; 5725 :     // Prepare MPC_PH
; 5726 :     rsp_ph->locdata = PH_LOC_1;

  0035e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  00366	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5727 :     STORE_F3( rsp_ph->lendata, uLength3 );

  00369	8b 4c 24 54	 mov	 ecx, DWORD PTR uLength3$[rsp]
  0036d	e8 00 00 00 00	 call	 _byteswap_ulong
  00372	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  0037a	48 ff c1	 inc	 rcx
  0037d	8b d0		 mov	 edx, eax
  0037f	e8 00 00 00 00	 call	 store_f3_noswap

; 5728 :     STORE_FW( rsp_ph->offdata, uLength2 );

  00384	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR uLength2$[rsp]
  0038b	e8 00 00 00 00	 call	 _byteswap_ulong
  00390	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00398	48 83 c1 04	 add	 rcx, 4
  0039c	8b d0		 mov	 edx, eax
  0039e	e8 00 00 00 00	 call	 store_fw_noswap

; 5729 : 
; 5730 :     // Prepare MPC_PUK
; 5731 :     STORE_HW( rsp_puk->length, SIZE_PUK );

  003a3	66 b9 0c 00	 mov	 cx, 12
  003a7	e8 00 00 00 00	 call	 _byteswap_ushort
  003ac	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  003b4	0f b7 d0	 movzx	 edx, ax
  003b7	e8 00 00 00 00	 call	 store_hw_noswap

; 5732 :     rsp_puk->what = PUK_WHAT_41;

  003bc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  003c4	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5733 :     rsp_puk->type = PUK_TYPE_CONFIRM;

  003c8	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  003d0	c6 40 03 06	 mov	 BYTE PTR [rax+3], 6

; 5734 :     STORE_HW( rsp_puk->lenpus, uLength4 );

  003d4	0f b7 4c 24 50	 movzx	 ecx, WORD PTR uLength4$[rsp]
  003d9	e8 00 00 00 00	 call	 _byteswap_ushort
  003de	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  003e6	48 83 c1 04	 add	 rcx, 4
  003ea	0f b7 d0	 movzx	 edx, ax
  003ed	e8 00 00 00 00	 call	 store_hw_noswap

; 5735 : 
; 5736 :     // Prepare first MPC_PUS
; 5737 :     STORE_HW( rsp_pus_04->length, SIZE_PUS_04 );

  003f2	66 b9 09 00	 mov	 cx, 9
  003f6	e8 00 00 00 00	 call	 _byteswap_ushort
  003fb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_pus_04$[rsp]
  00400	0f b7 d0	 movzx	 edx, ax
  00403	e8 00 00 00 00	 call	 store_hw_noswap

; 5738 :     rsp_pus_04->what = PUS_WHAT_04;

  00408	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  0040d	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5739 :     rsp_pus_04->type = PUS_TYPE_04;

  00411	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  00416	c6 40 03 04	 mov	 BYTE PTR [rax+3], 4

; 5740 :     rsp_pus_04->vc.pus_04.tokenx5 = MPC_TOKEN_X5;

  0041a	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  0041f	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5741 :     memcpy( rsp_pus_04->vc.pus_04.token, grp->gtcmconn, MPC_TOKEN_LENGTH );

  00423	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_pus_04$[rsp]
  00428	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00430	8b 89 38 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1592]
  00436	89 48 05	 mov	 DWORD PTR [rax+5], ecx

; 5742 : 
; 5743 :     // Prepare second MPC_PUS
; 5744 :     STORE_HW( rsp_pus_08->length, SIZE_PUS_08 );

  00439	66 b9 09 00	 mov	 cx, 9
  0043d	e8 00 00 00 00	 call	 _byteswap_ushort
  00442	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_pus_08$[rsp]
  00447	0f b7 d0	 movzx	 edx, ax
  0044a	e8 00 00 00 00	 call	 store_hw_noswap

; 5745 :     rsp_pus_08->what = PUS_WHAT_04;

  0044f	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  00454	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5746 :     rsp_pus_08->type = PUS_TYPE_08;

  00458	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  0045d	c6 40 03 08	 mov	 BYTE PTR [rax+3], 8

; 5747 :     rsp_pus_08->vc.pus_08.tokenx5 = MPC_TOKEN_X5;

  00461	48 8b 44 24 78	 mov	 rax, QWORD PTR rsp_pus_08$[rsp]
  00466	c6 40 04 05	 mov	 BYTE PTR [rax+4], 5

; 5748 :     STORE_FW( rsp_pus_08->vc.pus_08.token, QTOKEN3 );

  0046a	b9 f3 e3 c5 d8	 mov	 ecx, -658119693		; d8c5e3f3H
  0046f	e8 00 00 00 00	 call	 _byteswap_ulong
  00474	48 8b 4c 24 78	 mov	 rcx, QWORD PTR rsp_pus_08$[rsp]
  00479	48 83 c1 05	 add	 rcx, 5
  0047d	8b d0		 mov	 edx, eax
  0047f	e8 00 00 00 00	 call	 store_fw_noswap

; 5749 : 
; 5750 :     // Prepare third MPC_PUS
; 5751 :     STORE_HW( rsp_pus_07->length, SIZE_PUS_07 );

  00484	66 b9 08 00	 mov	 cx, 8
  00488	e8 00 00 00 00	 call	 _byteswap_ushort
  0048d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_07$[rsp]
  00495	0f b7 d0	 movzx	 edx, ax
  00498	e8 00 00 00 00	 call	 store_hw_noswap

; 5752 :     rsp_pus_07->what = PUS_WHAT_04;

  0049d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_07$[rsp]
  004a5	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5753 :     rsp_pus_07->type = PUS_TYPE_07;

  004a9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_07$[rsp]
  004b1	c6 40 03 07	 mov	 BYTE PTR [rax+3], 7

; 5754 : //  memcpy( rsp_pus_07->vc.pus_07.unknown04+0, req_pus_06->vc.pus_06.unknown04, 2 );
; 5755 :     STORE_HW( rsp_pus_07->vc.pus_07.unknown04+0, 0x4000 );

  004b5	66 b9 00 40	 mov	 cx, 16384		; 00004000H
  004b9	e8 00 00 00 00	 call	 _byteswap_ushort
  004be	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_07$[rsp]
  004c6	48 83 c1 04	 add	 rcx, 4
  004ca	0f b7 d0	 movzx	 edx, ax
  004cd	e8 00 00 00 00	 call	 store_hw_noswap

; 5756 :     STORE_HW( rsp_pus_07->vc.pus_07.unknown04+2, 0x0000 );

  004d2	33 c9		 xor	 ecx, ecx
  004d4	e8 00 00 00 00	 call	 _byteswap_ushort
  004d9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_07$[rsp]
  004e1	48 83 c1 06	 add	 rcx, 6
  004e5	0f b7 d0	 movzx	 edx, ax
  004e8	e8 00 00 00 00	 call	 store_hw_noswap

; 5757 : 
; 5758 :     return rsp_bhr;

  004ed	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
$LN1@process_cm:

; 5759 : }

  004f5	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004fc	c3		 ret	 0
process_cm_setup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
uLength4$ = 80
uLength3$ = 84
rsp_rrh$ = 88
rsp_pus_01$ = 96
uLength1$ = 104
rsp_th$ = 112
uLength2$ = 120
rsp_puk$ = 128
rsp_bhr$ = 136
rsp_ph$ = 144
rsp_pus_02$ = 152
req_pus_01$ = 160
grp$ = 168
req_pus_02$ = 176
dev$ = 208
req_th$ = 216
req_rrh$ = 224
req_puk$ = 232
process_cm_enable PROC

; 5536 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 5537 : OSA_GRP *grp = (OSA_GRP*)dev->group->grp_data;

  0001b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00027	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR grp$[rsp], rax
$LN4@process_cm:

; 5538 : 
; 5539 : MPC_PUS *req_pus_01;
; 5540 : MPC_PUS *req_pus_02;
; 5541 : 
; 5542 : OSA_BHR *rsp_bhr;
; 5543 : MPC_TH  *rsp_th;
; 5544 : MPC_RRH *rsp_rrh;
; 5545 : MPC_PH  *rsp_ph;
; 5546 : MPC_PUK *rsp_puk;
; 5547 : MPC_PUS *rsp_pus_01;
; 5548 : MPC_PUS *rsp_pus_02;
; 5549 : 
; 5550 : U32 uLength1;
; 5551 : U32 uLength2;
; 5552 : U32 uLength3;
; 5553 : U16 uLength4;
; 5554 : 
; 5555 :     UNREFERENCED(req_rrh);

  00033	33 c0		 xor	 eax, eax
  00035	85 c0		 test	 eax, eax
  00037	75 fa		 jne	 SHORT $LN4@process_cm

; 5556 : 
; 5557 :     /* Display the request MPC_TH etc., maybe. */
; 5558 :     DBGUPD( dev, 1, req_th, 0, FROM_GUEST, "%s: Request", dev->dev_data );

  00039	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00041	48 8b 80 08 06
	00 00		 mov	 rax, QWORD PTR [rax+1544]
  00048	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  0004d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174958
  00054	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00059	c6 44 24 38 3c	 mov	 BYTE PTR [rsp+56], 60	; 0000003cH
  0005e	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00067	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR req_th$[rsp]
  0006f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00074	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  0007c	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00084	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174959
  0008b	ba b6 15 00 00	 mov	 edx, 5558		; 000015b6H
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174960
  00097	e8 00 00 00 00	 call	 dbgupd

; 5559 : 
; 5560 :     /* Point to the expected MPC_PUS and check they are present. */
; 5561 :     req_pus_01 = mpc_point_pus( dev, req_puk, PUS_TYPE_01 );

  0009c	41 b0 01	 mov	 r8b, 1
  0009f	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000a7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000b5	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR req_pus_01$[rsp], rax

; 5562 :     req_pus_02 = mpc_point_pus( dev, req_puk, PUS_TYPE_02 );

  000bd	41 b0 02	 mov	 r8b, 2
  000c0	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR req_puk$[rsp]
  000c8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_point_pus
  000d6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR req_pus_02$[rsp], rax

; 5563 :     if( !req_pus_01 || !req_pus_02 )

  000de	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR req_pus_01$[rsp], 0
  000e7	74 0b		 je	 SHORT $LN6@process_cm
  000e9	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR req_pus_02$[rsp], 0
  000f2	75 33		 jne	 SHORT $LN5@process_cm
$LN6@process_cm:

; 5564 :     {
; 5565 :         /* FIXME Expected pus not present, error message please. */
; 5566 :         DBGTRC(dev, "process_cm_enable: Expected pus not present");

  000f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG174963
  000fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00100	4c 8b 8c 24 d0
	00 00 00	 mov	 r9, QWORD PTR dev$[rsp]
  00108	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG174964
  0010f	ba be 15 00 00	 mov	 edx, 5566		; 000015beH
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG174965
  0011b	e8 00 00 00 00	 call	 dbgtrc

; 5567 :         return NULL;

  00120	33 c0		 xor	 eax, eax
  00122	e9 4a 03 00 00	 jmp	 $LN1@process_cm
$LN5@process_cm:

; 5568 :     }
; 5569 : 
; 5570 :     /* Copy the guests CM Filter token from request PUS_TYPE_01. */
; 5571 :     memcpy( grp->gtcmfilt, req_pus_01->vc.pus_01.token, MPC_TOKEN_LENGTH );

  00127	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR grp$[rsp]
  0012f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR req_pus_01$[rsp]
  00137	8b 49 07	 mov	 ecx, DWORD PTR [rcx+7]
  0013a	89 88 34 06 00
	00		 mov	 DWORD PTR [rax+1588], ecx

; 5572 : 
; 5573 :     // Fix-up various lengths
; 5574 :     uLength4 = SIZE_PUS_01 +                     // first MPC_PUS

  00140	b8 17 00 00 00	 mov	 eax, 23
  00145	66 89 44 24 50	 mov	 WORD PTR uLength4$[rsp], ax

; 5575 :                SIZE_PUS_02_C;                    // second MPC_PUS
; 5576 :     uLength3 = SIZE_PUK + uLength4;              // the MPC_PUK and the MPC_PUSs (the data)

  0014a	0f b7 44 24 50	 movzx	 eax, WORD PTR uLength4$[rsp]
  0014f	83 c0 0c	 add	 eax, 12
  00152	89 44 24 54	 mov	 DWORD PTR uLength3$[rsp], eax

; 5577 :     uLength2 = SIZE_TH + SIZE_RRH_1 + SIZE_PH;   // the MPC_TH/MPC_RRH/MPC_PH

  00156	c7 44 24 78 38
	00 00 00	 mov	 DWORD PTR uLength2$[rsp], 56 ; 00000038H

; 5578 :     uLength1 = uLength2 + uLength3;              // the MPC_TH/MPC_RRH/MPC_PH and data

  0015e	8b 44 24 54	 mov	 eax, DWORD PTR uLength3$[rsp]
  00162	8b 4c 24 78	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00166	03 c8		 add	 ecx, eax
  00168	8b c1		 mov	 eax, ecx
  0016a	89 44 24 68	 mov	 DWORD PTR uLength1$[rsp], eax

; 5579 : 
; 5580 :     // Allocate a buffer in which the response will be build.
; 5581 :     rsp_bhr = alloc_buffer( dev, uLength1+10 );

  0016e	8b 44 24 68	 mov	 eax, DWORD PTR uLength1$[rsp]
  00172	83 c0 0a	 add	 eax, 10
  00175	8b d0		 mov	 edx, eax
  00177	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0017f	e8 00 00 00 00	 call	 alloc_buffer
  00184	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR rsp_bhr$[rsp], rax

; 5582 :     if (!rsp_bhr)

  0018c	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR rsp_bhr$[rsp], 0
  00195	75 07		 jne	 SHORT $LN7@process_cm

; 5583 :         return NULL;

  00197	33 c0		 xor	 eax, eax
  00199	e9 d3 02 00 00	 jmp	 $LN1@process_cm
$LN7@process_cm:

; 5584 :     rsp_bhr->content = strdup( dev->dev_data );

  0019e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a6	48 8b 88 08 06
	00 00		 mov	 rcx, QWORD PTR [rax+1544]
  001ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  001b3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR rsp_bhr$[rsp]
  001bb	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 5585 :     rsp_bhr->datalen = uLength1;

  001bf	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  001c7	8b 4c 24 68	 mov	 ecx, DWORD PTR uLength1$[rsp]
  001cb	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 5586 : 
; 5587 :     // Fix-up various pointers
; 5588 :     rsp_th = (MPC_TH*)((BYTE*)rsp_bhr + SizeBHR);

  001ce	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
  001d6	48 83 c0 18	 add	 rax, 24
  001da	48 89 44 24 70	 mov	 QWORD PTR rsp_th$[rsp], rax

; 5589 :     rsp_rrh = (MPC_RRH*)((BYTE*)rsp_th + SIZE_TH);

  001df	48 8b 44 24 70	 mov	 rax, QWORD PTR rsp_th$[rsp]
  001e4	48 83 c0 14	 add	 rax, 20
  001e8	48 89 44 24 58	 mov	 QWORD PTR rsp_rrh$[rsp], rax

; 5590 :     rsp_ph = (MPC_PH*)((BYTE*)rsp_rrh + SIZE_RRH_1);

  001ed	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  001f2	48 83 c0 1c	 add	 rax, 28
  001f6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR rsp_ph$[rsp], rax

; 5591 :     rsp_puk = (MPC_PUK*)((BYTE*)rsp_ph + SIZE_PH);

  001fe	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  00206	48 83 c0 08	 add	 rax, 8
  0020a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rsp_puk$[rsp], rax

; 5592 :     rsp_pus_01 = (MPC_PUS*)((BYTE*)rsp_puk + SIZE_PUK);

  00212	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  0021a	48 83 c0 0c	 add	 rax, 12
  0021e	48 89 44 24 60	 mov	 QWORD PTR rsp_pus_01$[rsp], rax

; 5593 :     rsp_pus_02 = (MPC_PUS*)((BYTE*)rsp_pus_01 + SIZE_PUS_01);

  00223	48 8b 44 24 60	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  00228	48 83 c0 0b	 add	 rax, 11
  0022c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR rsp_pus_02$[rsp], rax

; 5594 : 
; 5595 :     // Prepare MPC_TH
; 5596 :     STORE_FW( rsp_th->first4, MPC_TH_FIRST4 );

  00234	b9 00 00 e0 00	 mov	 ecx, 14680064		; 00e00000H
  00239	e8 00 00 00 00	 call	 _byteswap_ulong
  0023e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00243	8b d0		 mov	 edx, eax
  00245	e8 00 00 00 00	 call	 store_fw_noswap

; 5597 :     STORE_FW( rsp_th->offrrh, SIZE_TH );

  0024a	b9 14 00 00 00	 mov	 ecx, 20
  0024f	e8 00 00 00 00	 call	 _byteswap_ulong
  00254	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00259	48 83 c1 08	 add	 rcx, 8
  0025d	8b d0		 mov	 edx, eax
  0025f	e8 00 00 00 00	 call	 store_fw_noswap

; 5598 :     STORE_FW( rsp_th->length, uLength1 );

  00264	8b 4c 24 68	 mov	 ecx, DWORD PTR uLength1$[rsp]
  00268	e8 00 00 00 00	 call	 _byteswap_ulong
  0026d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  00272	48 83 c1 0c	 add	 rcx, 12
  00276	8b d0		 mov	 edx, eax
  00278	e8 00 00 00 00	 call	 store_fw_noswap

; 5599 :     STORE_HW( rsp_th->unknown10, 0x0FFC );            /* !!! */

  0027d	66 b9 fc 0f	 mov	 cx, 4092		; 00000ffcH
  00281	e8 00 00 00 00	 call	 _byteswap_ushort
  00286	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  0028b	48 83 c1 10	 add	 rcx, 16
  0028f	0f b7 d0	 movzx	 edx, ax
  00292	e8 00 00 00 00	 call	 store_hw_noswap

; 5600 :     STORE_HW( rsp_th->numrrh, 1 );

  00297	66 b9 01 00	 mov	 cx, 1
  0029b	e8 00 00 00 00	 call	 _byteswap_ushort
  002a0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR rsp_th$[rsp]
  002a5	48 83 c1 12	 add	 rcx, 18
  002a9	0f b7 d0	 movzx	 edx, ax
  002ac	e8 00 00 00 00	 call	 store_hw_noswap

; 5601 : 
; 5602 :     // Prepare MPC_RRH
; 5603 :     rsp_rrh->type = RRH_TYPE_CM;

  002b1	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  002b6	c6 40 04 81	 mov	 BYTE PTR [rax+4], 129	; 00000081H

; 5604 :     rsp_rrh->proto = PROTOCOL_UNKNOWN;

  002ba	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  002bf	c6 40 05 7e	 mov	 BYTE PTR [rax+5], 126	; 0000007eH

; 5605 :     STORE_HW( rsp_rrh->numph, 1 );

  002c3	66 b9 01 00	 mov	 cx, 1
  002c7	e8 00 00 00 00	 call	 _byteswap_ushort
  002cc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002d1	48 83 c1 06	 add	 rcx, 6
  002d5	0f b7 d0	 movzx	 edx, ax
  002d8	e8 00 00 00 00	 call	 store_hw_noswap

; 5606 : //  STORE_FW( rsp_rrh->seqnum, ++grp->seqnumis );
; 5607 :     STORE_HW( rsp_rrh->offph, SIZE_RRH_1 );

  002dd	66 b9 1c 00	 mov	 cx, 28
  002e1	e8 00 00 00 00	 call	 _byteswap_ushort
  002e6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  002eb	48 83 c1 10	 add	 rcx, 16
  002ef	0f b7 d0	 movzx	 edx, ax
  002f2	e8 00 00 00 00	 call	 store_hw_noswap

; 5608 :     STORE_HW( rsp_rrh->lenfida, (U16)uLength3 );

  002f7	0f b7 4c 24 54	 movzx	 ecx, WORD PTR uLength3$[rsp]
  002fc	e8 00 00 00 00	 call	 _byteswap_ushort
  00301	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  00306	48 83 c1 12	 add	 rcx, 18
  0030a	0f b7 d0	 movzx	 edx, ax
  0030d	e8 00 00 00 00	 call	 store_hw_noswap

; 5609 :     STORE_F3( rsp_rrh->lenalda, uLength3 );

  00312	8b 4c 24 54	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00316	e8 00 00 00 00	 call	 _byteswap_ulong
  0031b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR rsp_rrh$[rsp]
  00320	48 83 c1 14	 add	 rcx, 20
  00324	8b d0		 mov	 edx, eax
  00326	e8 00 00 00 00	 call	 store_f3_noswap

; 5610 :     rsp_rrh->tokenx5 = MPC_TOKEN_X5;

  0032b	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00330	c6 40 17 05	 mov	 BYTE PTR [rax+23], 5

; 5611 :     memcpy( rsp_rrh->token, grp->gtissue, MPC_TOKEN_LENGTH );

  00334	48 8b 44 24 58	 mov	 rax, QWORD PTR rsp_rrh$[rsp]
  00339	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR grp$[rsp]
  00341	8b 89 30 06 00
	00		 mov	 ecx, DWORD PTR [rcx+1584]
  00347	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 5612 : 
; 5613 :     // Prepare MPC_PH
; 5614 :     rsp_ph->locdata = PH_LOC_1;

  0034a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR rsp_ph$[rsp]
  00352	c6 00 01	 mov	 BYTE PTR [rax], 1

; 5615 :     STORE_F3( rsp_ph->lendata, uLength3 );

  00355	8b 4c 24 54	 mov	 ecx, DWORD PTR uLength3$[rsp]
  00359	e8 00 00 00 00	 call	 _byteswap_ulong
  0035e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00366	48 ff c1	 inc	 rcx
  00369	8b d0		 mov	 edx, eax
  0036b	e8 00 00 00 00	 call	 store_f3_noswap

; 5616 :     STORE_FW( rsp_ph->offdata, uLength2 );

  00370	8b 4c 24 78	 mov	 ecx, DWORD PTR uLength2$[rsp]
  00374	e8 00 00 00 00	 call	 _byteswap_ulong
  00379	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR rsp_ph$[rsp]
  00381	48 83 c1 04	 add	 rcx, 4
  00385	8b d0		 mov	 edx, eax
  00387	e8 00 00 00 00	 call	 store_fw_noswap

; 5617 : 
; 5618 :     // Prepare MPC_PUK
; 5619 :     STORE_HW( rsp_puk->length, SIZE_PUK );

  0038c	66 b9 0c 00	 mov	 cx, 12
  00390	e8 00 00 00 00	 call	 _byteswap_ushort
  00395	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  0039d	0f b7 d0	 movzx	 edx, ax
  003a0	e8 00 00 00 00	 call	 store_hw_noswap

; 5620 :     rsp_puk->what = PUK_WHAT_41;

  003a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  003ad	c6 40 02 41	 mov	 BYTE PTR [rax+2], 65	; 00000041H

; 5621 :     rsp_puk->type = PUK_TYPE_ENABLE;

  003b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rsp_puk$[rsp]
  003b9	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5622 :     STORE_HW( rsp_puk->lenpus, uLength4 );

  003bd	0f b7 4c 24 50	 movzx	 ecx, WORD PTR uLength4$[rsp]
  003c2	e8 00 00 00 00	 call	 _byteswap_ushort
  003c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rsp_puk$[rsp]
  003cf	48 83 c1 04	 add	 rcx, 4
  003d3	0f b7 d0	 movzx	 edx, ax
  003d6	e8 00 00 00 00	 call	 store_hw_noswap

; 5623 : 
; 5624 :     // Prepare first MPC_PUS
; 5625 :     STORE_HW( rsp_pus_01->length, SIZE_PUS_01 );

  003db	66 b9 0b 00	 mov	 cx, 11
  003df	e8 00 00 00 00	 call	 _byteswap_ushort
  003e4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rsp_pus_01$[rsp]
  003e9	0f b7 d0	 movzx	 edx, ax
  003ec	e8 00 00 00 00	 call	 store_hw_noswap

; 5626 :     rsp_pus_01->what = PUS_WHAT_04;

  003f1	48 8b 44 24 60	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  003f6	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5627 :     rsp_pus_01->type = PUS_TYPE_01;

  003fa	48 8b 44 24 60	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  003ff	c6 40 03 01	 mov	 BYTE PTR [rax+3], 1

; 5628 :     rsp_pus_01->vc.pus_01.proto = PROTOCOL_UNKNOWN;

  00403	48 8b 44 24 60	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  00408	c6 40 04 7e	 mov	 BYTE PTR [rax+4], 126	; 0000007eH

; 5629 :     rsp_pus_01->vc.pus_01.unknown05 = 0x04;           /* !!! */

  0040c	48 8b 44 24 60	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  00411	c6 40 05 04	 mov	 BYTE PTR [rax+5], 4

; 5630 :     rsp_pus_01->vc.pus_01.tokenx5 = MPC_TOKEN_X5;

  00415	48 8b 44 24 60	 mov	 rax, QWORD PTR rsp_pus_01$[rsp]
  0041a	c6 40 06 05	 mov	 BYTE PTR [rax+6], 5

; 5631 :     STORE_FW( rsp_pus_01->vc.pus_01.token, QTOKEN2 );

  0041e	b9 f2 e3 c5 d8	 mov	 ecx, -658119694		; d8c5e3f2H
  00423	e8 00 00 00 00	 call	 _byteswap_ulong
  00428	48 8b 4c 24 60	 mov	 rcx, QWORD PTR rsp_pus_01$[rsp]
  0042d	48 83 c1 07	 add	 rcx, 7
  00431	8b d0		 mov	 edx, eax
  00433	e8 00 00 00 00	 call	 store_fw_noswap

; 5632 : 
; 5633 :     // Prepare second MPC_PUS (which will contain 8-bytes of nulls)
; 5634 :     STORE_HW( rsp_pus_02->length, SIZE_PUS_02_C );

  00438	66 b9 0c 00	 mov	 cx, 12
  0043c	e8 00 00 00 00	 call	 _byteswap_ushort
  00441	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR rsp_pus_02$[rsp]
  00449	0f b7 d0	 movzx	 edx, ax
  0044c	e8 00 00 00 00	 call	 store_hw_noswap

; 5635 :     rsp_pus_02->what = PUS_WHAT_04;

  00451	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_02$[rsp]
  00459	c6 40 02 04	 mov	 BYTE PTR [rax+2], 4

; 5636 :     rsp_pus_02->type = PUS_TYPE_02;

  0045d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR rsp_pus_02$[rsp]
  00465	c6 40 03 02	 mov	 BYTE PTR [rax+3], 2

; 5637 : 
; 5638 :     return rsp_bhr;

  00469	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR rsp_bhr$[rsp]
$LN1@process_cm:

; 5639 : }

  00471	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  00478	c3		 ret	 0
process_cm_enable ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv84 = 80
tv90 = 84
devgrp$ = 88
grp$1 = 96
vargs$2 = 104
buf$3 = 112
__$ArrayPad$ = 368
file$ = 400
line$ = 408
func$ = 416
dev$ = 424
what$ = 432
adr$ = 440
len$ = 448
dir$ = 456
fmt$ = 464
dbgupd	PROC

; 201  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 202  :   DEVGRP *devgrp = dev->group;

  0002c	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00038	48 89 44 24 58	 mov	 QWORD PTR devgrp$[rsp], rax

; 203  :   if (devgrp)

  0003d	48 83 7c 24 58
	00		 cmp	 QWORD PTR devgrp$[rsp], 0
  00043	0f 84 e1 01 00
	00		 je	 $LN2@dbgupd

; 204  :   {
; 205  :     OSA_GRP* grp = devgrp->grp_data;

  00049	48 8b 44 24 58	 mov	 rax, QWORD PTR devgrp$[rsp]
  0004e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00052	48 89 44 24 60	 mov	 QWORD PTR grp$1[rsp], rax

; 206  :     if (grp && (grp->debugmask & DBGQETHUPDOWN))

  00057	48 83 7c 24 60
	00		 cmp	 QWORD PTR grp$1[rsp], 0
  0005d	0f 84 c7 01 00
	00		 je	 $LN3@dbgupd
  00063	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$1[rsp]
  00068	8b 80 e0 05 00
	00		 mov	 eax, DWORD PTR [rax+1504]
  0006e	83 e0 10	 and	 eax, 16
  00071	85 c0		 test	 eax, eax
  00073	0f 84 b1 01 00
	00		 je	 $LN3@dbgupd

; 207  :     {
; 208  :       char buf[256];
; 209  :       va_list   vargs;
; 210  :       va_start( vargs, fmt );

  00079	48 8d 84 24 d8
	01 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  00081	48 89 44 24 68	 mov	 QWORD PTR vargs$2[rsp], rax

; 211  :       vsnprintf( buf, sizeof(buf), fmt, vargs );

  00086	4c 8b 4c 24 68	 mov	 r9, QWORD PTR vargs$2[rsp]
  0008b	4c 8b 84 24 d0
	01 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  00093	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00098	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$3[rsp]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf

; 212  :       // HHC03991D "%1d:%04X %s: %s"
; 213  :       fwritemsg( file, line, func, WRMSG_NORMAL, stdout,

  000a3	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ac	74 12		 je	 SHORT $LN11@dbgupd
  000ae	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ba	89 44 24 50	 mov	 DWORD PTR tv84[rsp], eax
  000be	eb 08		 jmp	 SHORT $LN12@dbgupd
$LN11@dbgupd:
  000c0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
$LN12@dbgupd:
  000c8	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d1	74 14		 je	 SHORT $LN13@dbgupd
  000d3	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000db	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000df	d1 f8		 sar	 eax, 1
  000e1	89 44 24 54	 mov	 DWORD PTR tv90[rsp], eax
  000e5	eb 08		 jmp	 SHORT $LN14@dbgupd
$LN13@dbgupd:
  000e7	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN14@dbgupd:
  000ef	b9 01 00 00 00	 mov	 ecx, 1
  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000fa	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$3[rsp]
  000ff	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00104	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00110	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00115	8b 4c 24 50	 mov	 ecx, DWORD PTR tv84[rsp]
  00119	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0011d	8b 4c 24 54	 mov	 ecx, DWORD PTR tv90[rsp]
  00121	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171177
  0012c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00131	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00136	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013c	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  00144	8b 94 24 98 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  0014b	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00153	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 214  :         "HHC03991D " HHC03991 "\n", LCSS_DEVNUM, dev->typname, buf );
; 215  :       va_end( vargs );

  00159	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR vargs$2[rsp], 0

; 216  :       if (what == 3) {

  00162	83 bc 24 b0 01
	00 00 03	 cmp	 DWORD PTR what$[rsp], 3
  0016a	75 2c		 jne	 SHORT $LN4@dbgupd

; 217  :         mpc_display_osa_iear( dev, adr, dir, len );

  0016c	44 8b 8c 24 c0
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  00174	44 0f b6 84 24
	c8 01 00 00	 movzx	 r8d, BYTE PTR dir$[rsp]
  0017d	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR adr$[rsp]
  00185	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_osa_iear
  00193	e9 92 00 00 00	 jmp	 $LN5@dbgupd
$LN4@dbgupd:

; 218  :       } else if (what == 2) {

  00198	83 bc 24 b0 01
	00 00 02	 cmp	 DWORD PTR what$[rsp], 2
  001a0	75 29		 jne	 SHORT $LN6@dbgupd

; 219  :         mpc_display_osa_iea( dev, adr, dir, len );

  001a2	44 8b 8c 24 c0
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  001aa	44 0f b6 84 24
	c8 01 00 00	 movzx	 r8d, BYTE PTR dir$[rsp]
  001b3	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR adr$[rsp]
  001bb	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_osa_iea
  001c9	eb 5f		 jmp	 SHORT $LN7@dbgupd
$LN6@dbgupd:

; 220  :       } else if (what == 1) {

  001cb	83 bc 24 b0 01
	00 00 01	 cmp	 DWORD PTR what$[rsp], 1
  001d3	75 24		 jne	 SHORT $LN8@dbgupd

; 221  :         mpc_display_osa_th_etc( dev, adr, dir, 0 );

  001d5	45 33 c9	 xor	 r9d, r9d
  001d8	44 0f b6 84 24
	c8 01 00 00	 movzx	 r8d, BYTE PTR dir$[rsp]
  001e1	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR adr$[rsp]
  001e9	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_osa_th_etc

; 222  :       } else {

  001f7	eb 31		 jmp	 SHORT $LN9@dbgupd
$LN8@dbgupd:

; 223  :         mpc_display_stuff( dev, "", adr, len, dir );

  001f9	0f b6 84 24 c8
	01 00 00	 movzx	 eax, BYTE PTR dir$[rsp]
  00201	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00205	44 8b 8c 24 c0
	01 00 00	 mov	 r9d, DWORD PTR len$[rsp]
  0020d	4c 8b 84 24 b8
	01 00 00	 mov	 r8, QWORD PTR adr$[rsp]
  00215	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG171184
  0021c	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_mpc_display_stuff
$LN9@dbgupd:
$LN7@dbgupd:
$LN5@dbgupd:
$LN3@dbgupd:
$LN2@dbgupd:

; 224  :       }
; 225  :     }
; 226  :   }
; 227  : }

  0022a	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00232	48 33 cc	 xor	 rcx, rsp
  00235	e8 00 00 00 00	 call	 __security_check_cookie
  0023a	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  00241	c3		 ret	 0
dbgupd	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\qeth.c
_TEXT	SEGMENT
tv83 = 80
tv89 = 84
devgrp$ = 88
grp$1 = 96
vargs$2 = 104
buf$3 = 112
__$ArrayPad$ = 368
file$ = 400
line$ = 408
func$ = 416
dev$ = 424
fmt$ = 432
dbgtrc	PROC

; 170  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 171  :   DEVGRP *devgrp = dev->group;

  0002c	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00034	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00038	48 89 44 24 58	 mov	 QWORD PTR devgrp$[rsp], rax

; 172  :   if (devgrp)

  0003d	48 83 7c 24 58
	00		 cmp	 QWORD PTR devgrp$[rsp], 0
  00043	0f 84 15 01 00
	00		 je	 $LN2@dbgtrc

; 173  :   {
; 174  :     OSA_GRP* grp = devgrp->grp_data;

  00049	48 8b 44 24 58	 mov	 rax, QWORD PTR devgrp$[rsp]
  0004e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00052	48 89 44 24 60	 mov	 QWORD PTR grp$1[rsp], rax

; 175  :     if (grp && grp->debugmask)

  00057	48 83 7c 24 60
	00		 cmp	 QWORD PTR grp$1[rsp], 0
  0005d	0f 84 fb 00 00
	00		 je	 $LN3@dbgtrc
  00063	48 8b 44 24 60	 mov	 rax, QWORD PTR grp$1[rsp]
  00068	83 b8 e0 05 00
	00 00		 cmp	 DWORD PTR [rax+1504], 0
  0006f	0f 84 e9 00 00
	00		 je	 $LN3@dbgtrc

; 176  :     {
; 177  :       char buf[256];
; 178  :       va_list   vargs;
; 179  :       va_start( vargs, fmt );

  00075	48 8d 84 24 b8
	01 00 00	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0007d	48 89 44 24 68	 mov	 QWORD PTR vargs$2[rsp], rax

; 180  :       vsnprintf( buf, sizeof(buf), fmt, vargs );

  00082	4c 8b 4c 24 68	 mov	 r9, QWORD PTR vargs$2[rsp]
  00087	4c 8b 84 24 b0
	01 00 00	 mov	 r8, QWORD PTR fmt$[rsp]
  0008f	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00094	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$3[rsp]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_vsnprintf

; 181  :       // HHC03991D "%1d:%04X %s: %s"
; 182  :       fwritemsg( file, line, func, WRMSG_NORMAL, stdout,

  0009f	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000a8	74 12		 je	 SHORT $LN5@dbgtrc
  000aa	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000b6	89 44 24 50	 mov	 DWORD PTR tv83[rsp], eax
  000ba	eb 08		 jmp	 SHORT $LN6@dbgtrc
$LN5@dbgtrc:
  000bc	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN6@dbgtrc:
  000c4	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000cd	74 14		 je	 SHORT $LN7@dbgtrc
  000cf	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000db	d1 f8		 sar	 eax, 1
  000dd	89 44 24 54	 mov	 DWORD PTR tv89[rsp], eax
  000e1	eb 08		 jmp	 SHORT $LN8@dbgtrc
$LN7@dbgtrc:
  000e3	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN8@dbgtrc:
  000eb	b9 01 00 00 00	 mov	 ecx, 1
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f6	48 8d 4c 24 70	 lea	 rcx, QWORD PTR buf$3[rsp]
  000fb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00100	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00108	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  0010c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00111	8b 4c 24 50	 mov	 ecx, DWORD PTR tv83[rsp]
  00115	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00119	8b 4c 24 54	 mov	 ecx, DWORD PTR tv89[rsp]
  0011d	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG171147
  00128	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00132	41 b9 03 00 00
	00		 mov	 r9d, 3
  00138	4c 8b 84 24 a0
	01 00 00	 mov	 r8, QWORD PTR func$[rsp]
  00140	8b 94 24 98 01
	00 00		 mov	 edx, DWORD PTR line$[rsp]
  00147	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 183  :         "HHC03991D " HHC03991 "\n", LCSS_DEVNUM, dev->typname, buf );
; 184  :       va_end( vargs );

  00155	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR vargs$2[rsp], 0
$LN3@dbgtrc:
$LN2@dbgtrc:

; 185  :     }
; 186  :   }
; 187  : }

  0015e	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00166	48 33 cc	 xor	 rcx, rsp
  00169	e8 00 00 00 00	 call	 __security_check_cookie
  0016e	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  00175	c3		 ret	 0
dbgtrc	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
s370_or_dev_4K_storage_key PROC				; COMDAT

; 246  :   inline void  ARCH_DEP( or_dev_4K_storage_key )  ( DEVBLK* dev, U64 abs, BYTE bits ) {        ARCH_DEP( _or_dev_storage_key  )( dev, abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	0f b6 44 24 40	 movzx	 eax, BYTE PTR bits$[rsp]
  00018	83 e0 fe	 and	 eax, -2
  0001b	41 b1 04	 mov	 r9b, 4
  0001e	44 0f b6 c0	 movzx	 r8d, al
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 s370__or_dev_storage_key
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
s370_or_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
s370_get_dev_4K_storage_key PROC			; COMDAT

; 244  :   inline BYTE  ARCH_DEP( get_dev_4K_storage_key ) ( DEVBLK* dev, U64 abs            ) { return ARCH_DEP( _get_dev_storage_key )( dev, abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b0 04	 mov	 r8b, 4
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001b	e8 00 00 00 00	 call	 s370__get_dev_storage_key
  00020	0f b6 c0	 movzx	 eax, al
  00023	83 e0 fe	 and	 eax, -2
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
s370_get_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_dev_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
dev$ = 80
abs$ = 88
bits$ = 96
K$ = 104
s370__or_dev_storage_key PROC				; COMDAT

; 206  : {

$LN8:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_d:

; 207  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@s370__or_d

; 208  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  0001e	0f b6 44 24 68	 movzx	 eax, BYTE PTR K$[rsp]
  00023	83 f8 04	 cmp	 eax, 4
  00026	75 61		 jne	 SHORT $LN5@s370__or_d
  00028	33 c0		 xor	 eax, eax
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	74 5a		 je	 SHORT $LN5@s370__or_d

; 209  :     {
; 210  :         BYTE* skey1_ptr = _get_dev_storekey1_ptr( dev, abs );

  0002f	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00039	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  0003e	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 211  :         BYTE* skey2_ptr = _get_dev_storekey2_ptr( dev, abs );

  00043	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0004d	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  00052	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 212  :         OR_SKEY( skey1_ptr, bits );

  00057	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00061	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00064	0b c8		 or	 ecx, eax
  00066	8b c1		 mov	 eax, ecx
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0006d	88 01		 mov	 BYTE PTR [rcx], al

; 213  :         OR_SKEY( skey2_ptr, bits );

  0006f	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00079	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0007c	0b c8		 or	 ecx, eax
  0007e	8b c1		 mov	 eax, ecx
  00080	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00085	88 01		 mov	 BYTE PTR [rcx], al

; 214  :     }

  00087	eb 32		 jmp	 SHORT $LN6@s370__or_d
$LN5@s370__or_d:

; 215  :     else
; 216  :     {
; 217  :         BYTE* skey_ptr  = _get_dev_storekey_ptr(  dev, abs, K );

  00089	44 0f b6 44 24
	68		 movzx	 r8d, BYTE PTR K$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00099	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  0009e	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 218  :         OR_SKEY( skey_ptr, bits );

  000a3	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000ad	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000b0	0b c8		 or	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000b9	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_d:

; 219  :     }
; 220  : }

  000bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bf	c3		 ret	 0
s370__or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__get_dev_storage_key
_TEXT	SEGMENT
skey$ = 32
dev$ = 64
abs$ = 72
K$ = 80
s370__get_dev_storage_key PROC				; COMDAT

; 144  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370__get_:

; 145  :     BYTE skey;
; 146  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s370__get_

; 147  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00019	0f b6 44 24 50	 movzx	 eax, BYTE PTR K$[rsp]
  0001e	83 f8 04	 cmp	 eax, 4
  00021	75 43		 jne	 SHORT $LN5@s370__get_
  00023	33 c0		 xor	 eax, eax
  00025	83 f8 01	 cmp	 eax, 1
  00028	74 3c		 je	 SHORT $LN5@s370__get_

; 148  :     {
; 149  :         skey  = *_get_dev_storekey1_ptr( dev, abs );

  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00034	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  00039	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003c	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 150  :         skey |= *_get_dev_storekey2_ptr( dev, abs ) & ~(STORKEY_KEY);

  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004a	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  0004f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00052	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00057	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  0005c	0b c8		 or	 ecx, eax
  0005e	8b c1		 mov	 eax, ecx
  00060	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 151  :     }

  00064	eb 1c		 jmp	 SHORT $LN6@s370__get_
$LN5@s370__get_:

; 152  :     else
; 153  :         skey  = *_get_dev_storekey_ptr(  dev, abs, K );

  00066	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR K$[rsp]
  0006c	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00076	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  0007b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007e	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s370__get_:

; 154  :     return skey;

  00082	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 155  : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
s370__get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey2_ptr
_TEXT	SEGMENT
dev$ = 8
abs$ = 16
_get_dev_storekey2_ptr PROC				; COMDAT

; 72   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 73   :     ABS_CHECK( abs );
; 74   :     return &STOREKEY2( abs, dev );

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR abs$[rsp]
  0000f	48 c1 e8 0b	 shr	 rax, 11
  00013	48 83 c8 01	 or	 rax, 1
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0001c	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx

; 75   : }

  00029	c3		 ret	 0
_get_dev_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey1_ptr
_TEXT	SEGMENT
dev$ = 8
abs$ = 16
_get_dev_storekey1_ptr PROC				; COMDAT

; 66   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 67   :     ABS_CHECK( abs );
; 68   :     return &STOREKEY1( abs, dev );

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR abs$[rsp]
  0000f	48 c1 e8 0b	 shr	 rax, 11
  00013	48 83 e0 fe	 and	 rax, -2
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0001c	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx

; 69   : }

  00029	c3		 ret	 0
_get_dev_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
dev$ = 32
abs$ = 40
K$ = 48
_get_dev_storekey_ptr PROC				; COMDAT

; 47   : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 48   :     ABS_CHECK( abs );
; 49   :     return (4 == K) ? &STOREKEY1( abs, dev ) // (see feature.h PROGRAMMING NOTE)

  00013	0f b6 44 24 30	 movzx	 eax, BYTE PTR K$[rsp]
  00018	83 f8 04	 cmp	 eax, 4
  0001b	75 25		 jne	 SHORT $LN3@get_dev_st
  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00022	48 c1 e8 0b	 shr	 rax, 11
  00026	48 83 e0 fe	 and	 rax, -2
  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0002f	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  00040	eb 1f		 jmp	 SHORT $LN4@get_dev_st
$LN3@get_dev_st:
  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00047	48 c1 e8 0b	 shr	 rax, 11
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_dev_st:
  00061	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 50   :                     : &STOREKEY(  abs, dev );
; 51   : }

  00065	48 83 c4 18	 add	 rsp, 24
  00069	c3		 ret	 0
_get_dev_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
rc$ = 32
regs$ = 64
location$ = 72
Try_Obtain_Interrupt_Lock PROC

; 389  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 390  :     int rc;
; 391  :     if (regs)

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Try_Obtain

; 392  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Try_Obtain:

; 393  :     if ((rc = hthread_try_obtain_lock( &sysblk.intlock, location )) == 0)

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_try_obtain_lock
  00044	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00048	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0004d	75 11		 jne	 SHORT $LN3@Try_Obtain

; 394  :         Interrupt_Lock_Obtained( regs, location );

  0004f	48 8b 54 24 48	 mov	 rdx, QWORD PTR location$[rsp]
  00054	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00059	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained
  0005e	eb 1b		 jmp	 SHORT $LN4@Try_Obtain
$LN3@Try_Obtain:

; 395  :     else if (regs)

  00060	48 83 7c 24 40
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00066	74 13		 je	 SHORT $LN5@Try_Obtain

; 396  :         HOSTREGS->intwait = false;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006d	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00074	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0
$LN5@Try_Obtain:
$LN4@Try_Obtain:

; 397  :     return rc;

  0007b	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 398  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
Try_Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_f3_noswap
_TEXT	SEGMENT
ptr$ = 24
value$ = 32
store_f3_noswap PROC					; COMDAT

; 799  :     inline void store_f3_noswap(void *ptr, U32 value) {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi

; 800  :       value >>= 8;

  0000b	8b 44 24 20	 mov	 eax, DWORD PTR value$[rsp]
  0000f	c1 e8 08	 shr	 eax, 8
  00012	89 44 24 20	 mov	 DWORD PTR value$[rsp], eax

; 801  :       memcpy((BYTE *)ptr, ((BYTE *)&value), 3);

  00016	48 8d 44 24 20	 lea	 rax, QWORD PTR value$[rsp]
  0001b	48 8b 7c 24 18	 mov	 rdi, QWORD PTR ptr$[rsp]
  00020	48 8b f0	 mov	 rsi, rax
  00023	b9 03 00 00 00	 mov	 ecx, 3
  00028	f3 a4		 rep movsb

; 802  :     }

  0002a	5f		 pop	 rdi
  0002b	5e		 pop	 rsi
  0002c	c3		 ret	 0
store_f3_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_f3_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 48
fetch_f3_noswap PROC					; COMDAT

; 780  :     inline U32 fetch_f3_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 18	 sub	 rsp, 24

; 781  :       U32 value;
; 782  :       memcpy(((BYTE *)&value), (BYTE *)ptr, 3);

  0000b	48 8d 04 24	 lea	 rax, QWORD PTR value$[rsp]
  0000f	48 8b f8	 mov	 rdi, rax
  00012	48 8b 74 24 30	 mov	 rsi, QWORD PTR ptr$[rsp]
  00017	b9 03 00 00 00	 mov	 ecx, 3
  0001c	f3 a4		 rep movsb

; 783  :       value <<= 8;

  0001e	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]
  00021	c1 e0 08	 shl	 eax, 8
  00024	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 784  :       return value;

  00027	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 785  :     }

  0002a	48 83 c4 18	 add	 rsp, 24
  0002e	5f		 pop	 rdi
  0002f	5e		 pop	 rsi
  00030	c3		 ret	 0
fetch_f3_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
