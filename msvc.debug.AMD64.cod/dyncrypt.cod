; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
mask	DB	080H
	DB	040H
	DB	020H
	DB	010H
	DB	08H
	DB	04H
	DB	02H
	DB	01H
kmctr_wrap DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	01H
	DD	01H
	DD	00H
	DD	00H
	DD	00H
kmctr_keylengths DD 00H
	DD	08H
	DD	010H
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	08H
	DD	010H
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	018H
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	018H
	DD	020H
	DD	00H
	DD	00H
	DD	00H
kmctr_pblens DD	00H
	DD	08H
	DD	010H
	DD	018H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	020H
	DD	028H
	DD	030H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	010H
	DD	018H
	DD	020H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	030H
	DD	038H
	DD	040H
	DD	00H
	DD	00H
	DD	00H
poly	DB	00H
	DB	0e1H
	ORG $+6
?query_bits@?1??s370_dyn_perform_cryptographic_computation@@9@9 DB 0f0H ; `s370_dyn_perform_cryptographic_computation'::`2'::query_bits
	DB	070H
	DB	038H
	DB	038H
	DB	00H
	DB	00H
	DB	028H
	DB	028H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
?query_bits@?1??z900_dyn_perform_cryptographic_computation@@9@9 DB 0f0H ; `z900_dyn_perform_cryptographic_computation'::`2'::query_bits
	DB	070H
	DB	038H
	DB	038H
	DB	00H
	DB	00H
	DB	028H
	DB	028H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
CONST	ENDS
PUBLIC	RtlSecureZeroMemory
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	s370_maddr_l
PUBLIC	s370_vstorec
PUBLIC	s370_vfetchc
PUBLIC	s370_validate_operand
PUBLIC	crypto_fetch32
PUBLIC	crypto_store32
PUBLIC	crypto_cswap32
PUBLIC	crypto_cswap64
PUBLIC	crypto_secure0
PUBLIC	gcm_gf_mult
PUBLIC	xts_mult_x
PUBLIC	xts_gf_mult
PUBLIC	shift_left
PUBLIC	des_set_key
PUBLIC	des_encrypt
PUBLIC	des_decrypt
PUBLIC	des3_set_2keys
PUBLIC	des3_set_3keys
PUBLIC	des3_encrypt
PUBLIC	des3_decrypt
PUBLIC	s370_dyn_compute_intermediate_message_digest
PUBLIC	s370_dyn_compute_last_message_digest
PUBLIC	s370_dyn_cipher_message
PUBLIC	s370_dyn_compute_message_authentication_code
PUBLIC	s370_dyn_cipher_message_with_chaining
PUBLIC	s370_dyn_cipher_message_with_counter
PUBLIC	s370_dyn_cipher_message_with_cipher_feedback
PUBLIC	s370_dyn_cipher_message_with_output_feedback
PUBLIC	s370_dyn_perform_cryptographic_computation
PUBLIC	s370_dyn_perform_cryptographic_key_management_operation
PUBLIC	s390_maddr_l
PUBLIC	s390_vstorec
PUBLIC	s390_vfetchc
PUBLIC	s390_validate_operand
PUBLIC	s390_dyn_compute_intermediate_message_digest
PUBLIC	s390_dyn_compute_last_message_digest
PUBLIC	s390_dyn_cipher_message
PUBLIC	s390_dyn_compute_message_authentication_code
PUBLIC	s390_dyn_cipher_message_with_chaining
PUBLIC	s390_dyn_perform_cryptographic_key_management_operation
PUBLIC	s390_dyn_perform_cryptographic_computation
PUBLIC	s390_dyn_cipher_message_with_cipher_feedback
PUBLIC	s390_dyn_cipher_message_with_output_feedback
PUBLIC	s390_dyn_cipher_message_with_counter
PUBLIC	z900_is_per3_event_suppressed
PUBLIC	z900_per3_zero
PUBLIC	z900_per3_zero_check
PUBLIC	z900_per3_zero_check2
PUBLIC	z900_per3_zero_lcheck
PUBLIC	z900_maddr_l
PUBLIC	z900_vstorec
PUBLIC	z900_vfetchc
PUBLIC	z900_validate_operand
PUBLIC	z900_dyn_compute_intermediate_message_digest
PUBLIC	z900_dyn_compute_last_message_digest
PUBLIC	z900_dyn_cipher_message
PUBLIC	z900_dyn_compute_message_authentication_code
PUBLIC	z900_dyn_cipher_message_with_chaining
PUBLIC	z900_dyn_cipher_message_with_counter
PUBLIC	z900_dyn_cipher_message_with_cipher_feedback
PUBLIC	z900_dyn_cipher_message_with_output_feedback
PUBLIC	z900_dyn_perform_cryptographic_computation
PUBLIC	z900_dyn_perform_cryptographic_key_management_operation
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_define_instructs_ep
PUBLIC	hdl_register_symbols_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	longjmp:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_reverse_bits:PROC
EXTRN	__imp_s370_fetch_int_timer:PROC
EXTRN	__imp_s370_store_int_timer:PROC
EXTRN	__imp_txf_maddr_l:PROC
EXTRN	__imp_z900_abort_transaction:PROC
EXTRN	__imp_s370_program_interrupt:PROC
EXTRN	__imp_s390_program_interrupt:PROC
EXTRN	__imp_z900_program_interrupt:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_s370_logical_to_main_l:PROC
EXTRN	__imp_s390_logical_to_main_l:PROC
EXTRN	__imp_z900_logical_to_main_l:PROC
EXTRN	rijndael_set_key:PROC
EXTRN	rijndael_decrypt:PROC
EXTRN	rijndael_encrypt:PROC
EXTRN	SHA1Transform:PROC
EXTRN	SHA256Transform:PROC
EXTRN	SHA512Transform:PROC
EXTRN	des_key_setup:PROC
EXTRN	des_encipher:PROC
EXTRN	des_decipher:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$RtlSecureZeroMemory DD imagerel $LN3
	DD	imagerel $LN3+48
	DD	imagerel $unwind$RtlSecureZeroMemory
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+475
	DD	imagerel $unwind$s370_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vstorec DD imagerel $LN24
	DD	imagerel $LN24+598
	DD	imagerel $unwind$s370_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_vfetchc DD imagerel $LN24
	DD	imagerel $LN24+529
	DD	imagerel $unwind$s370_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_validate_operand DD imagerel $LN24
	DD	imagerel $LN24+272
	DD	imagerel $unwind$s370_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$crypto_fetch32 DD imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$crypto_fetch32
$pdata$crypto_store32 DD imagerel $LN3
	DD	imagerel $LN3+39
	DD	imagerel $unwind$crypto_store32
$pdata$crypto_cswap32 DD imagerel $LN3
	DD	imagerel $LN3+22
	DD	imagerel $unwind$crypto_cswap32
$pdata$crypto_cswap64 DD imagerel $LN3
	DD	imagerel $LN3+24
	DD	imagerel $unwind$crypto_cswap64
$pdata$crypto_secure0 DD imagerel $LN3
	DD	imagerel $LN3+34
	DD	imagerel $unwind$crypto_secure0
$pdata$gcm_rightshift DD imagerel gcm_rightshift
	DD	imagerel gcm_rightshift+131
	DD	imagerel $unwind$gcm_rightshift
$pdata$gcm_gf_mult DD imagerel $LN10
	DD	imagerel $LN10+339
	DD	imagerel $unwind$gcm_gf_mult
$pdata$xts_mult_x DD imagerel $LN7
	DD	imagerel $LN7+165
	DD	imagerel $unwind$xts_mult_x
$pdata$xts_gf_mult DD imagerel $LN9
	DD	imagerel $LN9+220
	DD	imagerel $unwind$xts_gf_mult
$pdata$sha1_getcv DD imagerel sha1_getcv
	DD	imagerel sha1_getcv+223
	DD	imagerel $unwind$sha1_getcv
$pdata$sha1_seticv DD imagerel sha1_seticv
	DD	imagerel sha1_seticv+255
	DD	imagerel $unwind$sha1_seticv
$pdata$sha256_getcv DD imagerel sha256_getcv
	DD	imagerel sha256_getcv+223
	DD	imagerel $unwind$sha256_getcv
$pdata$sha256_seticv DD imagerel sha256_seticv
	DD	imagerel sha256_seticv+255
	DD	imagerel $unwind$sha256_seticv
$pdata$sha512_getcv DD imagerel sha512_getcv
	DD	imagerel sha512_getcv+440
	DD	imagerel $unwind$sha512_getcv
$pdata$sha512_seticv DD imagerel sha512_seticv
	DD	imagerel sha512_seticv+493
	DD	imagerel $unwind$sha512_seticv
$pdata$shift_left DD imagerel $LN8
	DD	imagerel $LN8+261
	DD	imagerel $unwind$shift_left
$pdata$des_set_key DD imagerel $LN3
	DD	imagerel $LN3+114
	DD	imagerel $unwind$des_set_key
$pdata$des_encrypt DD imagerel $LN3
	DD	imagerel $LN3+171
	DD	imagerel $unwind$des_encrypt
$pdata$des_decrypt DD imagerel $LN3
	DD	imagerel $LN3+171
	DD	imagerel $unwind$des_decrypt
$pdata$des3_set_2keys DD imagerel $LN3
	DD	imagerel $LN3+240
	DD	imagerel $unwind$des3_set_2keys
$pdata$des3_set_3keys DD imagerel $LN3
	DD	imagerel $LN3+294
	DD	imagerel $unwind$des3_set_3keys
$pdata$des3_encrypt DD imagerel $LN3
	DD	imagerel $LN3+305
	DD	imagerel $unwind$des3_encrypt
$pdata$des3_decrypt DD imagerel $LN3
	DD	imagerel $LN3+305
	DD	imagerel $unwind$des3_decrypt
$pdata$unwrap_aes DD imagerel unwrap_aes
	DD	imagerel unwrap_aes+666
	DD	imagerel $unwind$unwrap_aes
$pdata$unwrap_dea DD imagerel unwrap_dea
	DD	imagerel unwrap_dea+593
	DD	imagerel $unwind$unwrap_dea
$pdata$wrap_aes DD imagerel wrap_aes
	DD	imagerel wrap_aes+627
	DD	imagerel $unwind$wrap_aes
$pdata$wrap_dea DD imagerel wrap_dea
	DD	imagerel wrap_dea+503
	DD	imagerel $unwind$wrap_dea
$pdata$s370_kimd_sha DD imagerel s370_kimd_sha
	DD	imagerel s370_kimd_sha+1203
	DD	imagerel $unwind$s370_kimd_sha
$pdata$s370_kimd_ghash DD imagerel s370_kimd_ghash
	DD	imagerel s370_kimd_ghash+847
	DD	imagerel $unwind$s370_kimd_ghash
$pdata$s370_klmd_sha DD imagerel s370_klmd_sha
	DD	imagerel s370_klmd_sha+1587
	DD	imagerel $unwind$s370_klmd_sha
$pdata$s370_km_dea DD imagerel s370_km_dea
	DD	imagerel s370_km_dea+1383
	DD	imagerel $unwind$s370_km_dea
$pdata$s370_km_aes DD imagerel s370_km_aes
	DD	imagerel s370_km_aes+1148
	DD	imagerel $unwind$s370_km_aes
$pdata$s370_km_xts_aes DD imagerel s370_km_xts_aes
	DD	imagerel s370_km_xts_aes+1495
	DD	imagerel $unwind$s370_km_xts_aes
$pdata$s370_kmac_dea DD imagerel s370_kmac_dea
	DD	imagerel s370_kmac_dea+1490
	DD	imagerel $unwind$s370_kmac_dea
$pdata$s370_kmac_aes DD imagerel s370_kmac_aes
	DD	imagerel s370_kmac_aes+1098
	DD	imagerel $unwind$s370_kmac_aes
$pdata$s370_kmc_dea DD imagerel s370_kmc_dea
	DD	imagerel s370_kmc_dea+2466
	DD	imagerel $unwind$s370_kmc_dea
$pdata$s370_kmc_aes DD imagerel s370_kmc_aes
	DD	imagerel s370_kmc_aes+1549
	DD	imagerel $unwind$s370_kmc_aes
$pdata$s370_kmc_prng DD imagerel s370_kmc_prng
	DD	imagerel s370_kmc_prng+1482
	DD	imagerel $unwind$s370_kmc_prng
$pdata$s370_kmctr_dea DD imagerel s370_kmctr_dea
	DD	imagerel s370_kmctr_dea+1772
	DD	imagerel $unwind$s370_kmctr_dea
$pdata$s370_kmctr_aes DD imagerel s370_kmctr_aes
	DD	imagerel s370_kmctr_aes+1363
	DD	imagerel $unwind$s370_kmctr_aes
$pdata$s370_kmf_dea DD imagerel s370_kmf_dea
	DD	imagerel s370_kmf_dea+2039
	DD	imagerel $unwind$s370_kmf_dea
$pdata$s370_kmf_aes DD imagerel s370_kmf_aes
	DD	imagerel s370_kmf_aes+1628
	DD	imagerel $unwind$s370_kmf_aes
$pdata$s370_kmo_dea DD imagerel s370_kmo_dea
	DD	imagerel s370_kmo_dea+1699
	DD	imagerel $unwind$s370_kmo_dea
$pdata$s370_kmo_aes DD imagerel s370_kmo_aes
	DD	imagerel s370_kmo_aes+1282
	DD	imagerel $unwind$s370_kmo_aes
$pdata$s370_pcc_cmac_dea DD imagerel s370_pcc_cmac_dea
	DD	imagerel s370_pcc_cmac_dea+2568
	DD	imagerel $unwind$s370_pcc_cmac_dea
$pdata$s370_pcc_cmac_aes DD imagerel s370_pcc_cmac_aes
	DD	imagerel s370_pcc_cmac_aes+1861
	DD	imagerel $unwind$s370_pcc_cmac_aes
$pdata$s370_pcc_xts_aes DD imagerel s370_pcc_xts_aes
	DD	imagerel s370_pcc_xts_aes+1307
	DD	imagerel $unwind$s370_pcc_xts_aes
$pdata$s370_pckmo_dea DD imagerel s370_pckmo_dea
	DD	imagerel s370_pckmo_dea+329
	DD	imagerel $unwind$s370_pckmo_dea
$pdata$s370_pckmo_aes DD imagerel s370_pckmo_aes
	DD	imagerel s370_pckmo_aes+333
	DD	imagerel $unwind$s370_pckmo_aes
$pdata$s370_dyn_compute_intermediate_message_digest DD imagerel $LN31
	DD	imagerel $LN31+1203
	DD	imagerel $unwind$s370_dyn_compute_intermediate_message_digest
$pdata$s370_dyn_compute_last_message_digest DD imagerel $LN28
	DD	imagerel $LN28+1129
	DD	imagerel $unwind$s370_dyn_compute_last_message_digest
$pdata$s370_dyn_cipher_message DD imagerel $LN45
	DD	imagerel $LN45+1385
	DD	imagerel $unwind$s370_dyn_cipher_message
$pdata$s370_dyn_compute_message_authentication_code DD imagerel $LN38
	DD	imagerel $LN38+1240
	DD	imagerel $unwind$s370_dyn_compute_message_authentication_code
$pdata$s370_dyn_cipher_message_with_chaining DD imagerel $LN42
	DD	imagerel $LN42+1380
	DD	imagerel $unwind$s370_dyn_cipher_message_with_chaining
$pdata$s370_dyn_cipher_message_with_counter DD imagerel $LN34
	DD	imagerel $LN34+1216
	DD	imagerel $unwind$s370_dyn_cipher_message_with_counter
$pdata$s370_dyn_cipher_message_with_cipher_feedback DD imagerel $LN34
	DD	imagerel $LN34+1172
	DD	imagerel $unwind$s370_dyn_cipher_message_with_cipher_feedback
$pdata$s370_dyn_cipher_message_with_output_feedback DD imagerel $LN34
	DD	imagerel $LN34+1172
	DD	imagerel $unwind$s370_dyn_cipher_message_with_output_feedback
$pdata$s370_dyn_perform_cryptographic_computation DD imagerel $LN35
	DD	imagerel $LN35+473
	DD	imagerel $unwind$s370_dyn_perform_cryptographic_computation
$pdata$s370_dyn_perform_cryptographic_key_management_operation DD imagerel $LN33
	DD	imagerel $LN33+1192
	DD	imagerel $unwind$s370_dyn_perform_cryptographic_key_management_operation
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_maddr_l DD imagerel $LN14
	DD	imagerel $LN14+475
	DD	imagerel $unwind$s390_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vstorec DD imagerel $LN9
	DD	imagerel $LN9+498
	DD	imagerel $unwind$s390_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+432
	DD	imagerel $unwind$s390_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+185
	DD	imagerel $unwind$s390_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$s390_kimd_sha DD imagerel s390_kimd_sha
	DD	imagerel s390_kimd_sha+1248
	DD	imagerel $unwind$s390_kimd_sha
$pdata$s390_klmd_sha DD imagerel s390_klmd_sha
	DD	imagerel s390_klmd_sha+1632
	DD	imagerel $unwind$s390_klmd_sha
$pdata$s390_km_dea DD imagerel s390_km_dea
	DD	imagerel s390_km_dea+1371
	DD	imagerel $unwind$s390_km_dea
$pdata$s390_km_aes DD imagerel s390_km_aes
	DD	imagerel s390_km_aes+1136
	DD	imagerel $unwind$s390_km_aes
$pdata$s390_kmac_dea DD imagerel s390_kmac_dea
	DD	imagerel s390_kmac_dea+1477
	DD	imagerel $unwind$s390_kmac_dea
$pdata$s390_kmc_dea DD imagerel s390_kmc_dea
	DD	imagerel s390_kmc_dea+2464
	DD	imagerel $unwind$s390_kmc_dea
$pdata$s390_kmc_aes DD imagerel s390_kmc_aes
	DD	imagerel s390_kmc_aes+1547
	DD	imagerel $unwind$s390_kmc_aes
$pdata$s390_kmc_prng DD imagerel s390_kmc_prng
	DD	imagerel s390_kmc_prng+1537
	DD	imagerel $unwind$s390_kmc_prng
$pdata$s390_dyn_compute_intermediate_message_digest DD imagerel $LN28
	DD	imagerel $LN28+1149
	DD	imagerel $unwind$s390_dyn_compute_intermediate_message_digest
$pdata$s390_dyn_compute_last_message_digest DD imagerel $LN28
	DD	imagerel $LN28+1140
	DD	imagerel $unwind$s390_dyn_compute_last_message_digest
$pdata$s390_dyn_cipher_message DD imagerel $LN28
	DD	imagerel $LN28+1180
	DD	imagerel $unwind$s390_dyn_cipher_message
$pdata$s390_dyn_compute_message_authentication_code DD imagerel $LN24
	DD	imagerel $LN24+1024
	DD	imagerel $unwind$s390_dyn_compute_message_authentication_code
$pdata$s390_dyn_cipher_message_with_chaining DD imagerel $LN32
	DD	imagerel $LN32+1260
	DD	imagerel $unwind$s390_dyn_cipher_message_with_chaining
$pdata$s390_dyn_perform_cryptographic_key_management_operation DD imagerel $LN19
	DD	imagerel $LN19+348
	DD	imagerel $unwind$s390_dyn_perform_cryptographic_key_management_operation
$pdata$s390_dyn_perform_cryptographic_computation DD imagerel $LN19
	DD	imagerel $LN19+348
	DD	imagerel $unwind$s390_dyn_perform_cryptographic_computation
$pdata$s390_dyn_cipher_message_with_cipher_feedback DD imagerel $LN19
	DD	imagerel $LN19+348
	DD	imagerel $unwind$s390_dyn_cipher_message_with_cipher_feedback
$pdata$s390_dyn_cipher_message_with_output_feedback DD imagerel $LN19
	DD	imagerel $LN19+348
	DD	imagerel $unwind$s390_dyn_cipher_message_with_output_feedback
$pdata$s390_dyn_cipher_message_with_counter DD imagerel $LN19
	DD	imagerel $LN19+348
	DD	imagerel $unwind$s390_dyn_cipher_message_with_counter
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero DD imagerel $LN12
	DD	imagerel $LN12+215
	DD	imagerel $unwind$z900_per3_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check DD imagerel $LN6
	DD	imagerel $LN6+101
	DD	imagerel $unwind$z900_per3_zero_check
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_check2 DD imagerel $LN9
	DD	imagerel $LN9+189
	DD	imagerel $unwind$z900_per3_zero_check2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_per3_zero_lcheck DD imagerel $LN8
	DD	imagerel $LN8+190
	DD	imagerel $unwind$z900_per3_zero_lcheck
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_maddr_l DD imagerel $LN18
	DD	imagerel $LN18+659
	DD	imagerel $unwind$z900_maddr_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vstorec DD imagerel $LN9
	DD	imagerel $LN9+511
	DD	imagerel $unwind$z900_vstorec
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_vfetchc DD imagerel $LN9
	DD	imagerel $LN9+445
	DD	imagerel $unwind$z900_vfetchc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_validate_operand DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$z900_validate_operand
pdata	ENDS
pdata	SEGMENT
$pdata$z900_kimd_sha DD imagerel z900_kimd_sha
	DD	imagerel z900_kimd_sha+2282
	DD	imagerel $unwind$z900_kimd_sha
$pdata$z900_kimd_ghash DD imagerel z900_kimd_ghash
	DD	imagerel z900_kimd_ghash+1871
	DD	imagerel $unwind$z900_kimd_ghash
$pdata$z900_klmd_sha DD imagerel z900_klmd_sha
	DD	imagerel z900_klmd_sha+2701
	DD	imagerel $unwind$z900_klmd_sha
$pdata$z900_km_dea DD imagerel z900_km_dea
	DD	imagerel z900_km_dea+2566
	DD	imagerel $unwind$z900_km_dea
$pdata$z900_km_aes DD imagerel z900_km_aes
	DD	imagerel z900_km_aes+2331
	DD	imagerel $unwind$z900_km_aes
$pdata$z900_km_xts_aes DD imagerel z900_km_xts_aes
	DD	imagerel z900_km_xts_aes+2856
	DD	imagerel $unwind$z900_km_xts_aes
$pdata$z900_kmac_dea DD imagerel z900_kmac_dea
	DD	imagerel z900_kmac_dea+2539
	DD	imagerel $unwind$z900_kmac_dea
$pdata$z900_kmac_aes DD imagerel z900_kmac_aes
	DD	imagerel z900_kmac_aes+2119
	DD	imagerel $unwind$z900_kmac_aes
$pdata$z900_kmc_dea DD imagerel z900_kmc_dea
	DD	imagerel z900_kmc_dea+3835
	DD	imagerel $unwind$z900_kmc_dea
$pdata$z900_kmc_aes DD imagerel z900_kmc_aes
	DD	imagerel z900_kmc_aes+2909
	DD	imagerel $unwind$z900_kmc_aes
$pdata$z900_kmc_prng DD imagerel z900_kmc_prng
	DD	imagerel z900_kmc_prng+2818
	DD	imagerel $unwind$z900_kmc_prng
$pdata$z900_kmctr_dea DD imagerel z900_kmctr_dea
	DD	imagerel z900_kmctr_dea+3282
	DD	imagerel $unwind$z900_kmctr_dea
$pdata$z900_kmctr_aes DD imagerel z900_kmctr_aes
	DD	imagerel z900_kmctr_aes+2876
	DD	imagerel $unwind$z900_kmctr_aes
$pdata$z900_kmf_dea DD imagerel z900_kmf_dea
	DD	imagerel z900_kmf_dea+3486
	DD	imagerel $unwind$z900_kmf_dea
$pdata$z900_kmf_aes DD imagerel z900_kmf_aes
	DD	imagerel z900_kmf_aes+3058
	DD	imagerel $unwind$z900_kmf_aes
$pdata$z900_kmo_dea DD imagerel z900_kmo_dea
	DD	imagerel z900_kmo_dea+3059
	DD	imagerel $unwind$z900_kmo_dea
$pdata$z900_kmo_aes DD imagerel z900_kmo_aes
	DD	imagerel z900_kmo_aes+2639
	DD	imagerel $unwind$z900_kmo_aes
$pdata$z900_pcc_cmac_dea DD imagerel z900_pcc_cmac_dea
	DD	imagerel z900_pcc_cmac_dea+2817
	DD	imagerel $unwind$z900_pcc_cmac_dea
$pdata$z900_pcc_cmac_aes DD imagerel z900_pcc_cmac_aes
	DD	imagerel z900_pcc_cmac_aes+2101
	DD	imagerel $unwind$z900_pcc_cmac_aes
$pdata$z900_pcc_xts_aes DD imagerel z900_pcc_xts_aes
	DD	imagerel z900_pcc_xts_aes+1555
	DD	imagerel $unwind$z900_pcc_xts_aes
$pdata$z900_pckmo_dea DD imagerel z900_pckmo_dea
	DD	imagerel z900_pckmo_dea+565
	DD	imagerel $unwind$z900_pckmo_dea
$pdata$z900_pckmo_aes DD imagerel z900_pckmo_aes
	DD	imagerel z900_pckmo_aes+569
	DD	imagerel $unwind$z900_pckmo_aes
$pdata$z900_dyn_compute_intermediate_message_digest DD imagerel $LN33
	DD	imagerel $LN33+1357
	DD	imagerel $unwind$z900_dyn_compute_intermediate_message_digest
$pdata$z900_dyn_compute_last_message_digest DD imagerel $LN38
	DD	imagerel $LN38+1589
	DD	imagerel $unwind$z900_dyn_compute_last_message_digest
$pdata$z900_dyn_cipher_message DD imagerel $LN55
	DD	imagerel $LN55+1841
	DD	imagerel $unwind$z900_dyn_cipher_message
$pdata$z900_dyn_compute_message_authentication_code DD imagerel $LN40
	DD	imagerel $LN40+1388
	DD	imagerel $unwind$z900_dyn_compute_message_authentication_code
$pdata$z900_dyn_cipher_message_with_chaining DD imagerel $LN52
	DD	imagerel $LN52+1836
	DD	imagerel $unwind$z900_dyn_cipher_message_with_chaining
$pdata$z900_dyn_cipher_message_with_counter DD imagerel $LN36
	DD	imagerel $LN36+1412
	DD	imagerel $unwind$z900_dyn_cipher_message_with_counter
$pdata$z900_dyn_cipher_message_with_cipher_feedback DD imagerel $LN44
	DD	imagerel $LN44+1628
	DD	imagerel $unwind$z900_dyn_cipher_message_with_cipher_feedback
$pdata$z900_dyn_cipher_message_with_output_feedback DD imagerel $LN44
	DD	imagerel $LN44+1628
	DD	imagerel $unwind$z900_dyn_cipher_message_with_output_feedback
$pdata$z900_dyn_perform_cryptographic_computation DD imagerel $LN37
	DD	imagerel $LN37+557
	DD	imagerel $unwind$z900_dyn_perform_cryptographic_computation
$pdata$z900_dyn_perform_cryptographic_key_management_operation DD imagerel $LN39
	DD	imagerel $LN39+1424
	DD	imagerel $unwind$z900_dyn_perform_cryptographic_key_management_operation
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+152
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_instructs_ep DD imagerel $LN153
	DD	imagerel $LN153+1304
	DD	imagerel $unwind$hdl_define_instructs_ep
$pdata$hdl_register_symbols_ep DD imagerel $LN6
	DD	imagerel $LN6+281
	DD	imagerel $unwind$hdl_register_symbols_ep
pdata	ENDS
_DATA	SEGMENT
exp_table DB	0a4H
	DB	06dH
	DB	0dbH
	DB	0b6H
	DB	06dH
	DB	0dbH
	DB	0b6H
	DB	06dH
	DB	092H
	DB	024H
	DB	049H
	DB	092H
	DB	024H
	DB	049H
	DB	092H
	DB	024H
	DB	05aH
	DB	045H
	DB	051H
	DB	014H
	DB	08aH
	DB	0a2H
	DB	028H
	DB	08aH
	DB	061H
	DB	018H
	DB	086H
	DB	061H
	DB	09aH
	DB	0a6H
	DB	069H
	DB	09aH
	DB	0acH
	DB	0b6H
	DB	0f3H
	DB	03cH
	DB	045H
	DB	051H
	DB	0d7H
	DB	075H
	DB	0dbH
	DB	0b6H
	DB	0aeH
	DB	0ebH
	DB	0fbH
	DB	0beH
	DB	0aeH
	DB	0ebH
	DB	092H
	DB	0cfH
	DB	0b6H
	DB	0e7H
	DB	028H
	DB	00H
	DB	049H
	DB	0dbH
	DB	075H
	DB	09eH
	DB	024H
	DB	08H
	DB	0c3H
	DB	071H
	DB	01cH
	DB	0c7H
	DB	098H
	DB	029H
	DB	0b7H
	DB	052H
	DB	03eH
	DB	0d5H
	DB	0acH
	DB	0ebH
	DB	0eaH
	DB	08aH
	DB	092H
	DB	086H
	DB	030H
	DB	04dH
	DB	0d3H
	DB	034H
	DB	0a5H
	DB	075H
	DB	01aH
	DB	0b6H
	DB	081H
	DB	07aH
	DB	063H
	DB	018H
	DB	061H
	DB	06eH
	DB	0a4H
	DB	0e3H
	DB	078H
	DB	0caH
	DB	0b2H
	DB	02cH
	DB	06H
	DB	04fH
	DB	09H
	DB	028H
	DB	0eH
	DB	0bbH
	DB	06H
	DB	086H
	DB	041H
	DB	019H
	DB	0b8H
	DB	020H
	DB	09dH
	DB	018H
	DB	086H
	DB	061H
	DB	0b9H
	DB	017H
	DB	0afH
	DB	07fH
	DB	0e2H
	DB	0abH
	DB	024H
	DB	08aH
	DB	0f9H
	DB	0dH
	DB	0abH
	DB	034H
	DB	069H
	DB	065H
	DB	021H
	DB	08H
	DB	0c5H
	DB	08cH
	DB	03cH
	DB	03eH
	DB	05fH
	DB	0a3H
	DB	015H
	DB	060H
	DB	0b5H
	DB	02aH
	DB	01cH
	DB	014H
	DB	0deH
	DB	041H
	DB	064H
	DB	0dfH
	DB	06cH
	DB	077H
	DB	082H
	DB	02aH
	DB	0ceH
	DB	066H
	DB	02bH
	DB	0abH
	DB	033H
	DB	0fH
	DB	08bH
	DB	064H
	DB	047H
	DB	00H
	DB	093H
	DB	030H
	DB	0acH
	DB	013H
	DB	06fH
	DB	036H
	DB	052H
	DB	0fH
	DB	0bdH
	DB	0ebH
	DB	0bH
	DB	0f1H
	DB	0bcH
	DB	0e2H
	DB	022H
	DB	09aH
	DB	06dH
	DB	09aH
	DB	09dH
	DB	077H
	DB	037H
	DB	05H
	DB	091H
	DB	0afH
	DB	0a7H
	DB	077H
	DB	06eH
	DB	0f4H
	DB	06H
	DB	08eH
	DB	03fH
	DB	0e7H
	DB	0a2H
	DB	0ebH
	DB	068H
	DB	0edH
	DB	0cbH
	DB	05aH
	DB	0c6H
	DB	0a9H
	DB	02bH
	DB	02H
	DB	067H
	DB	0b6H
	DB	055H
	DB	067H
	DB	0e4H
	DB	086H
	DB	08bH
	DB	071H
	DB	0c1H
	DB	0acH
	DB	0e2H
	DB	06H
	DB	02cH
	DB	014H
	DB	0c3H
	DB	012H
	DB	0e0H
	DB	0dcH
	DB	057H
	DB	0fdH
	DB	0c2H
	DB	066H
	DB	0a7H
	DB	0beH
	DB	052H
	DB	0f7H
	DB	0eH
	DB	021H
	DB	067H
	DB	069H
	DB	0b6H
	DB	09cH
	DB	01eH
	DB	0b5H
	DB	0dbH
	DB	027H
	DB	085H
	DB	08dH
	DB	0f5H
	DB	0aaH
	DB	0d5H
	DB	064H
	DB	057H
	DB	05fH
	DB	05bH
	DB	0f8H
	DB	0bdH
	DB	046H
	DB	0c2H
	DB	02dH
	DB	044H
	DB	017H
	DB	01bH
	DB	043H
	DB	07aH
	DB	0c7H
	DB	0caH
	DB	0f4H
	DB	080H
	DB	0ceH
	DB	040H
	DB	011H
	DB	093H
	DB	08dH
	DB	08H
	DB	0f9H
	DB	0c4H
	DB	0d8H
	DB	0d7H
	DB	026H
	DB	02H
	DB	0efH
	DB	062H
	DB	045H
	DB	0eeH
	DB	0bbH
	DB	02bH
	DB	044H
	DB	031H
	DB	0fbH
	DB	088H
	DB	05cH
	DB	092H
	DB	085H
	DB	056H
	DB	07aH
	DB	0aH
	DB	039H
	DB	0fH
	DB	07eH
	DB	0a0H
	DB	029H
	DB	058H
	DB	0daH
	DB	0b3H
	DB	046H
	DB	06dH
	DB	01cH
	DB	0ffH
	DB	0abH
	DB	097H
	DB	0a5H
	DB	0d4H
	DB	0dH
	DB	01dH
	DB	069H
	DB	0f1H
	DB	07aH
	DB	067H
	DB	056H
	DB	0afH
	DB	0ebH
	DB	09dH
	DB	028H
	DB	0ebH
	DB	04aH
	DB	04H
	DB	0c7H
	DB	077H
	DB	0b3H
	DB	00H
	DB	04H
	DB	05aH
	DB	0b7H
	DB	0c9H
	DB	036H
	DB	0efH
	DB	0c3H
	DB	09fH
	DB	0b8H
	DB	090H
	DB	0e3H
	DB	045H
	DB	095H
	DB	034H
	DB	074H
	DB	0a3H
	DB	057H
	DB	077H
	DB	072H
	DB	064H
	DB	0bcH
	DB	0fbH
	DB	027H
	DB	0b6H
	DB	0e6H
	DB	0f5H
	DB	058H
	DB	0e1H
	DB	0e7H
	DB	07fH
	DB	0bfH
	DB	053H
	DB	0beH
	DB	0fdH
	DB	0f9H
	DB	08fH
	DB	01bH
	DB	04bH
	DB	058H
	DB	0b5H
	DB	0d0H
	DB	072H
	DB	0bcH
	DB	018H
	DB	04cH
	DB	0aeH
	DB	0e2H
	DB	026H
	DB	026H
	DB	080H
	DB	072H
	DB	09eH
	DB	020H
	DB	0a9H
	DB	0abH
	DB	039H
	DB	057H
	DB	0b1H
	DB	096H
	DB	0c8H
	DB	03bH
	DB	0fbH
	DB	018H
	DB	098H
	DB	0deH
	DB	073H
	DB	058H
	DB	044H
	DB	08cH
	DB	090H
	DB	042H
	DB	0bdH
	DB	0f5H
	DB	02cH
	DB	0c7H
	DB	090H
	DB	058H
	DB	0b8H
	DB	0faH
	DB	0d8H
	DB	0c1H
	DB	0caH
	DB	05aH
	DB	03H
	DB	0eeH
	DB	0a7H
	DB	08dH
	DB	031H
	DB	04H
	DB	0a0H
	DB	0b5H
	DB	053H
	DB	034H
	DB	021H
	DB	0c7H
	DB	0f1H
	DB	0adH
	DB	031H
	DB	0d1H
	DB	0ffH
	DB	032H
	DB	0adH
	DB	05bH
	DB	0ecH
	DB	0dcH
	DB	08fH
	DB	0a1H
	DB	049H
	DB	03eH
	DB	040H
	DB	0a6H
	DB	055H
	DB	039H
	DB	050H
	DB	01H
	DB	0beH
	DB	03dH
	DB	0cfH
	DB	0b5H
	DB	0e1H
	DB	05bH
	DB	0f5H
	DB	0b1H
	DB	033H
	DB	01aH
	DB	062H
	DB	08bH
	DB	07cH
	DB	0c7H
	DB	0b9H
	DB	038H
	DB	066H
	DB	0c6H
	DB	04fH
	DB	0ffH
	DB	0d6H
	DB	0b6H
	DB	0baH
	DB	03eH
	DB	095H
	DB	088H
	DB	0f9H
	DB	0a2H
	DB	054H
	DB	051H
	DB	02dH
	DB	06bH
	DB	0f0H
	DB	0c0H
	DB	052H
	DB	024H
	DB	0a6H
	DB	0f3H
	DB	082H
	DB	08fH
	DB	075H
	DB	09cH
	DB	0ccH
	DB	018H
	DB	0a1H
	DB	082H
	DB	0b8H
	DB	037H
	DB	04dH
	DB	0eH
	DB	0e3H
	DB	029H
	DB	0dbH
	DB	0f0H
	DB	013H
	DB	09H
	DB	075H
	DB	0eaH
	DB	07bH
	DB	021H
	DB	07bH
	DB	0ddH
	DB	020H
	DB	0d6H
	DB	08eH
	DB	075H
	DB	0a8H
	DB	0dcH
	DB	0caH
	DB	098H
	DB	06H
	DB	045H
	DB	0c1H
	DB	0dfH
	DB	0e2H
	DB	040H
	DB	09dH
	DB	067H
	DB	0eaH
	DB	02H
	DB	0abH
	DB	0dfH
	DB	0aaH
	DB	03cH
	DB	032H
	DB	07dH
	DB	08H
	DB	05eH
	DB	0a1H
	DB	024H
	DB	031H
	DB	06cH
	DB	055H
	DB	0cH
	DB	078H
	DB	074H
	DB	0e3H
	DB	086H
	DB	08eH
	DB	04H
	DB	067H
	DB	0fcH
	DB	078H
	DB	0cH
	DB	0dH
	DB	022H
	DB	065H
	DB	09fH
	DB	0b3H
	DB	040H
	DB	01bH
	DB	097H
	DB	011H
	DB	020H
	DB	0c5H
	DB	0f1H
	DB	04dH
	DB	064H
	DB	0eeH
	DB	06cH
	DB	056H
	DB	04H
	DB	042H
	DB	086H
	DB	097H
	DB	0f3H
	DB	0a8H
	DB	02eH
	DB	06bH
	DB	065H
	DB	043H
	DB	018H
	DB	025H
	DB	082H
	DB	064H
	DB	053H
	DB	040H
	DB	045H
	DB	0dbH
	DB	0efH
	DB	05bH
	DB	05fH
	DB	0a3H
	DB	0f2H
	DB	032H
	DB	06H
	DB	0eH
	DB	0f5H
	DB	08aH
	DB	02aH
	DB	0f6H
	DB	096H
	DB	010H
	DB	0b4H
	DB	06dH
	DB	038H
	DB	0c3H
	DB	085H
	DB	0f8H
	DB	069H
	DB	0c8H
	DB	087H
	DB	092H
	DB	087H
	DB	0ddH
	DB	0c3H
	DB	04bH
	DB	089H
	DB	047H
	DB	0a7H
	DB	0adH
	DB	0bbH
	DB	044H
	DB	0e5H
	DB	0bdH
	DB	06aH
	DB	01aH
	DB	0f9H
	DB	0a6H
	DB	0acH
	DB	037H
	DB	0d7H
	DB	07cH
	DB	0caH
	DB	07cH
	DB	0a0H
	DB	074H
	DB	055H
	DB	06H
	DB	023H
	DB	0f4H
	DB	06dH
	DB	0abH
	DB	0dfH
	DB	04fH
	DB	049H
	DB	0adH
	DB	063H
	DB	0e0H
	DB	03aH
	DB	034H
	DB	0cfH
	DB	0c0H
	DB	092H
	DB	038H
	DB	0aaH
	DB	078H
	DB	0fbH
	DB	03aH
	DB	081H
	DB	03cH
	DB	0cdH
	DB	0f4H
	DB	0f3H
	DB	078H
	DB	020H
	DB	067H
	DB	047H
	DB	086H
	DB	07cH
	DB	031H
	DB	096H
	DB	04eH
	DB	057H
	DB	02cH
	DB	0a0H
	DB	0d1H
	DB	09aH
	DB	01dH
	DB	0c6H
	DB	0c9H
	DB	0a0H
	DB	051H
	DB	064H
	DB	026H
	DB	028H
	DB	03bH
	DB	027H
	DB	02eH
	DB	0c5H
	DB	04cH
	DB	091H
	DB	00H
	DB	078H
	DB	0efH
	DB	0b4H
	DB	01bH
	DB	078H
	DB	059H
	DB	088H
	DB	064H
	DB	0d6H
	DB	0baH
	DB	05eH
	DB	0daH
	DB	0dH
	DB	044H
	DB	08H
	DB	0edH
	DB	00H
	DB	099H
	DB	05bH
	DB	080H
	DB	044H
	DB	0e5H
	DB	044H
	DB	0a0H
	DB	059H
	DB	0edH
	DB	0e9H
	DB	0dcH
	DB	0bfH
	DB	06H
	DB	0ceH
	DB	0c4H
	DB	0dfH
	DB	07H
	DB	0b3H
	DB	04dH
	DB	06cH
	DB	0b1H
	DB	025H
	DB	025H
	DB	05H
	DB	045H
	DB	0edH
	DB	044H
	DB	0c4H
	DB	078H
	DB	0bdH
	DB	041H
	DB	084H
	DB	073H
	DB	071H
	DB	0a2H
	DB	015H
	DB	019H
	DB	0f2H
	DB	0d3H
	DB	092H
	DB	099H
	DB	0f1H
	DB	05dH
	DB	0a9H
	DB	0c7H
	DB	01fH
	DB	058H
	DB	013H
	DB	03bH
	DB	0c9H
	DB	0e0H
	DB	07fH
	DB	0f6H
	DB	0daH
	DB	074H
	DB	0caH
	DB	07aH
	DB	0e4H
	DB	01eH
	DB	081H
	DB	0c2H
	DB	087H
	DB	02aH
	DB	04H
	DB	077H
	DB	0a9H
	DB	0dcH
	DB	0b4H
	DB	032H
	DB	0d5H
	DB	0a3H
	DB	079H
	DB	06eH
	DB	096H
	DB	066H
	DB	0faH
	DB	03eH
	DB	040H
	DB	0c3H
	DB	01eH
	DB	089H
	DB	07fH
	DB	0caH
	DB	049H
	DB	01fH
	DB	01aH
	DB	0edH
	DB	0baH
	DB	0d8H
	DB	05bH
	DB	0eaH
	DB	061H
	DB	08fH
	DB	096H
	DB	0faH
	DB	0b4H
	DB	059H
	DB	08fH
	DB	0dbH
	DB	07H
	DB	02aH
	DB	0faH
	DB	094H
	DB	0aaH
	DB	062H
	DB	0ecH
	DB	03dH
	DB	02eH
	DB	00H
	DB	038H
	DB	051H
	DB	023H
	DB	06aH
	DB	02cH
	DB	0caH
	DB	0c1H
	DB	014H
	DB	03H
	DB	08fH
	DB	01cH
	DB	03dH
	DB	05bH
	DB	03bH
	DB	0b6H
	DB	0e4H
	DB	01bH
	DB	0cbH
	DB	00H
	DB	056H
	DB	0d4H
	DB	0d6H
	DB	066H
	DB	044H
	DB	081H
	DB	0b4H
	DB	0deH
	DB	023H
	DB	022H
	DB	0e5H
	DB	0d1H
	DB	03H
	DB	06bH
	DB	02cH
	DB	02H
	DB	0b0H
	DB	0c2H
	DB	06aH
	DB	048H
	DB	05bH
	DB	043H
	DB	012H
	DB	05cH
	DB	0bbH
	DB	059H
	DB	037H
	DB	05H
	DB	00H
	DB	084H
	DB	040H
	DB	0e9H
	DB	0bdH
	DB	081H
	DB	09dH
	DB	02H
	DB	07cH
	DB	04H
	DB	04bH
	DB	0fbH
	DB	06eH
	DB	036H
	DB	0a0H
	DB	0d5H
	DB	04eH
	DB	02H
	DB	0f4H
	DB	092H
	DB	04cH
	DB	0ffH
	DB	07fH
	DB	03bH
	DB	037H
	DB	03H
	DB	0b6H
	DB	0c6H
	DB	019H
	DB	0c4H
	DB	0d7H
	DB	07cH
	DB	0dcH
	DB	04eH
	DB	010H
	DB	0f9H
	DB	0f4H
	DB	013H
	DB	04bH
	DB	0eeH
	DB	01dH
	DB	0fH
	DB	0fdH
	DB	0caH
	DB	0ecH
	DB	097H
	DB	0cbH
	DB	02fH
	DB	0ecH
	DB	039H
	DB	03cH
	DB	0ddH
	DB	0c9H
	DB	0d7H
	DB	0dcH
	DB	056H
	DB	06eH
	DB	070H
	DB	0f9H
	DB	031H
	DB	035H
	DB	09cH
	DB	095H
	DB	07aH
	DB	0caH
	DB	030H
	DB	0bdH
	DB	044H
	DB	0eeH
	DB	09cH
	DB	0baH
	DB	07bH
	DB	011H
	DB	04aH
	DB	02dH
	DB	0f7H
	DB	06aH
	DB	0fH
	DB	08bH
	DB	013H
	DB	03eH
	DB	0c6H
	DB	055H
	DB	06fH
	DB	0e9H
	DB	047H
	DB	041H
	DB	06cH
	DB	0ccH
	DB	0f1H
	DB	04fH
	DB	074H
	DB	06aH
	DB	054H
	DB	097H
	DB	0afH
	DB	0bH
	DB	064H
	DB	042H
	DB	02bH
	DB	0f9H
	DB	0fcH
	DB	010H
	DB	0f0H
	DB	091H
	DB	044H
	DB	088H
	DB	0bfH
	DB	094H
	DB	0a4H
	DB	061H
	DB	065H
	DB	014H
	DB	032H
	DB	0cbH
	DB	055H
	DB	0ffH
	DB	08eH
	DB	0bfH
	DB	0d4H
	DB	0a8H
	DB	0adH
	DB	025H
	DB	0e3H
	DB	0bcH
	DB	0a3H
	DB	036H
	DB	097H
	DB	07dH
	DB	065H
	DB	07fH
	DB	0d4H
	DB	053H
	DB	0f6H
	DB	02fH
	DB	0daH
	DB	031H
	DB	07eH
	DB	0c5H
	DB	0c2H
	DB	065H
	DB	02aH
	DB	07eH
	DB	0d8H
	DB	0c6H
	DB	092H
	DB	042H
	DB	0eH
	DB	0c3H
	DB	0cbH
	DB	040H
	DB	0edH
	DB	0e6H
	DB	030H
	DB	09dH
	DB	07cH
	DB	0f6H
	DB	099H
	DB	0a2H
	DB	095H
	DB	0a7H
	DB	098H
	DB	0e5H
	DB	044H
	DB	0b9H
	DB	032H
	DB	058H
	DB	06bH
	DB	0eaH
	DB	01fH
	DB	065H
	DB	061H
	DB	0acH
	DB	0f2H
	DB	0a1H
	DB	0a9H
	DB	037H
	DB	0e1H
	DB	0aaH
	DB	081H
	DB	085H
	DB	081H
	DB	0a1H
	DB	01H
	DB	02eH
	DB	02bH
	DB	04eH
	DB	0f6H
	DB	04fH
	DB	0e8H
	DB	0d6H
	DB	092H
	DB	026H
	DB	0a5H
	DB	06eH
	DB	0acH
	DB	075H
	DB	057H
	DB	03fH
	DB	07eH
	DB	013H
	DB	06cH
	DB	0d4H
	DB	03dH
	DB	03aH
	DB	0cbH
	DB	0a8H
	DB	066H
	DB	0f8H
	DB	0f6H
	DB	0deH
	DB	0ddH
	DB	056H
	DB	083H
	DB	089H
	DB	03bH
	DB	0fdH
	DB	0f0H
	DB	0d6H
	DB	09eH
	DB	044H
	DB	064H
	DB	0a8H
	DB	070H
	DB	098H
	DB	042H
	DB	08dH
	DB	0e6H
	DB	0a2H
	DB	043H
	DB	03cH
	DB	07aH
	DB	082H
	DB	0eH
	DB	03eH
	DB	078H
	DB	096H
	DB	0d9H
	DB	05aH
	DB	08bH
	DB	04fH
	DB	0baH
	DB	028H
	DB	067H
	DB	02dH
	DB	0f7H
	DB	0b5H
	DB	0e7H
	DB	04aH
	DB	0d4H
	DB	07H
	DB	09fH
	DB	035H
	DB	097H
	DB	0dbH
	DB	077H
	DB	06fH
	DB	09eH
	DB	05H
	DB	04eH
	DB	0a1H
	DB	086H
	DB	08fH
	DB	042H
	DB	074H
	DB	0e7H
	DB	0a4H
	DB	014H
	DB	0a8H
	DB	055H
	DB	057H
	DB	073H
	DB	013H
	DB	086H
	DB	022H
	DB	0bbH
	DB	082H
	DB	067H
	DB	014H
	DB	0b0H
	DB	011H
	DB	03H
	DB	074H
	DB	0b7H
	DB	073H
	DB	019H
	DB	078H
	DB	0acH
	DB	075H
	DB	0b0H
	DB	013H
	DB	0e2H
	DB	093H
	DB	0bdH
	DB	034H
	DB	054H
	DB	043H
	DB	052H
	DB	02H
	DB	074H
	DB	0f7H
	DB	060H
	DB	0b8H
	DB	018H
	DB	03bH
	DB	051H
	DB	0cfH
	DB	0fbH
	DB	04dH
	DB	0c4H
	DB	052H
	DB	08bH
	DB	0c5H
	DB	092H
	DB	0fdH
	DB	0f6H
	DB	05fH
	DB	090H
	DB	062H
	DB	093H
	DB	046H
	DB	021H
	DB	0a3H
	DB	0abH
	DB	0beH
	DB	0b3H
	DB	092H
	DB	0c7H
	DB	0a4H
	DB	014H
	DB	058H
	DB	03cH
	DB	023H
	DB	04H
	DB	0daH
	DB	058H
	DB	0a4H
	DB	031H
	DB	0bbH
	DB	0ccH
	DB	036H
	DB	034H
	DB	040H
	DB	0c7H
	DB	051H
	DB	083H
	DB	048H
	DB	060H
	DB	096H
	DB	074H
	DB	04bH
	DB	09cH
	DB	011H
	DB	053H
	DB	09bH
	DB	093H
	DB	06dH
	DB	068H
	DB	0f7H
	DB	0e8H
	DB	0d2H
	DB	0a6H
	DB	07dH
	DB	09H
	DB	0dbH
	DB	0e4H
	DB	08H
	DB	066H
	DB	0f1H
	DB	01bH
	DB	0b2H
	DB	0c8H
	DB	0f7H
	DB	084H
	DB	0b4H
	DB	0eeH
	DB	029H
	DB	08cH
	DB	075H
	DB	04dH
	DB	0a6H
	DB	066H
	DB	08fH
	DB	0bdH
	DB	0c0H
	DB	034H
	DB	076H
	DB	068H
	DB	0e5H
	DB	0bdH
	DB	0b1H
	DB	0e8H
	DB	05aH
	DB	08eH
	DB	032H
	DB	04dH
	DB	0c0H
	DB	0e6H
	DB	01dH
	DB	042H
	DB	059H
	DB	011H
	DB	07cH
	DB	0b8H
	DB	0f5H
	DB	08cH
	DB	02cH
	DB	044H
	DB	01eH
	DB	08cH
	DB	0cfH
	DB	0fbH
	DB	0fdH
	DB	081H
	DB	0ebH
	DB	0d9H
	DB	016H
	DB	078H
	DB	01dH
	DB	0feH
	DB	018H
	DB	02H
	DB	092H
	DB	072H
	DB	017H
	DB	0b6H
	DB	016H
	DB	0e3H
	DB	01eH
	DB	03bH
	DB	0bH
	DB	077H
	DB	06fH
	DB	06cH
	DB	021H
	DB	066H
	DB	0c8H
	DB	0a1H
	DB	044H
	DB	070H
	DB	0d9H
	DB	067H
	DB	0c2H
	DB	0afH
	DB	0aaH
	DB	05aH
	DB	067H
	DB	0bH
	DB	05bH
	DB	0d1H
	DB	0a3H
	DB	0abH
	DB	046H
	DB	099H
	DB	0bbH
	DB	099H
	DB	03eH
	DB	09H
	DB	0aH
	DB	071H
	DB	048H
	DB	011H
	DB	030H
	DB	058H
	DB	0baH
	DB	0daH
	DB	01aH
	DB	07dH
	DB	06aH
	DB	06H
	DB	05bH
	DB	0c7H
	DB	05fH
	DB	085H
	DB	0fbH
	DB	064H
	DB	0ecH
	DB	07eH
	DB	020H
	DB	08fH
	DB	042H
	DB	03bH
	DB	0bfH
	DB	0d9H
	DB	049H
	DB	096H
	DB	0a3H
	DB	0d6H
	DB	0d9H
	DB	07dH
	DB	080H
	DB	0d3H
	DB	085H
	DB	0cH
	DB	093H
	DB	058H
	DB	082H
	DB	08H
	DB	085H
	DB	0e3H
	DB	0eH
	DB	014H
	DB	0b9H
	DB	07aH
	DB	059H
	DB	0a7H
	DB	0d7H
	DB	0eeH
	DB	099H
	DB	010H
	DB	0d5H
	DB	0dH
	DB	062H
	DB	0d7H
	DB	07bH
	DB	0e7H
	DB	0b3H
	DB	04cH
	DB	0b3H
	DB	075H
	DB	00H
	DB	0eH
	DB	0c2H
	DB	0c7H
	DB	0a8H
	DB	0eaH
	DB	0c9H
	DB	04cH
	DB	01cH
	DB	037H
	DB	046H
	DB	050H
	DB	06cH
	DB	0b3H
	DB	010H
	DB	0afH
	DB	068H
	DB	0beH
	DB	0ddH
	DB	0a7H
	DB	012H
	DB	0caH
	DB	06bH
	DB	011H
	DB	0c6H
	DB	0c9H
	DB	094H
	DB	017H
	DB	08eH
	DB	0deH
	DB	0f4H
	DB	0b6H
	DB	08bH
	DB	054H
	DB	054H
	DB	018H
	DB	0dH
	DB	0eeH
	DB	014H
	DB	073H
	DB	07H
	DB	09cH
	DB	0e2H
	DB	02eH
	DB	0a2H
	DB	092H
	DB	085H
	DB	0fcH
	DB	05cH
	DB	0aeH
	DB	0feH
	DB	0dfH
	DB	0f8H
	DB	0a6H
	DB	083H
	DB	0e1H
	DB	0a9H
	DB	0adH
	DB	0d3H
	DB	0c1H
	DB	0e2H
	DB	02fH
	DB	0a0H
	DB	0b8H
	DB	058H
	DB	03aH
	DB	0abH
	DB	0eaH
	DB	0deH
	DB	064H
	DB	0a5H
	DB	073H
	DB	0f1H
	DB	062H
	DB	0eaH
	DB	0a5H
	DB	0aeH
	DB	0acH
	DB	073H
	DB	05aH
	DB	047H
	DB	01eH
	DB	062H
	DB	01cH
	DB	0a4H
	DB	017H
	DB	0ffH
	DB	07aH
	DB	00H
	DB	0aaH
	DB	0bbH
	DB	09H
	DB	08H
	DB	0bcH
	DB	0d1H
	DB	0c1H
	DB	0e1H
	DB	022H
	DB	0b0H
	DB	020H
	DB	074H
	DB	0ddH
	DB	090H
	DB	0c1H
	DB	040H
	DB	0c5H
	DB	016H
	DB	070H
	DB	027H
	DB	0eH
	DB	070H
	DB	04cH
	DB	0e0H
	DB	037H
	DB	0f5H
	DB	0d3H
	DB	070H
	DB	07aH
	DB	08eH
	DB	0ddH
	DB	044H
	DB	07bH
	DB	0aH
	DB	080H
	DB	05fH
	DB	05aH
	DB	012H
	DB	09H
	DB	0ddH
	DB	0b2H
	DB	0d1H
	DB	0caH
	DB	0b2H
	DB	0a7H
	DB	011H
	DB	05bH
	DB	0a9H
	DB	074H
	DB	0aH
	DB	0deH
	DB	0fH
	DB	033H
	DB	0b9H
	DB	036H
	DB	022H
	DB	020H
	DB	0c3H
	DB	0ceH
	DB	02aH
	DB	05H
	DB	095H
	DB	06H
	DB	0f8H
	DB	07aH
	DB	077H
	DB	021H
	DB	018H
	DB	0b0H
	DB	0d3H
	DB	05dH
	DB	099H
	DB	0aH
	DB	02dH
	DB	078H
	DB	0b0H
	DB	022H
	DB	0deH
	DB	068H
	DB	069H
	DB	09eH
	DB	060H
	DB	062H
	DB	092H
	DB	0fcH
	DB	0f1H
	DB	0d2H
	DB	0e4H
	DB	0deH
	DB	0dcH
	DB	060H
	DB	0c2H
	DB	0f6H
	DB	038H
	DB	04fH
	DB	071H
	DB	024H
	DB	0b8H
	DB	0fbH
	DB	067H
	DB	028H
	DB	0cfH
	DB	042H
	DB	073H
	DB	0a7H
	DB	031H
	DB	0d3H
	DB	019H
	DB	0d3H
	DB	05aH
	DB	09dH
	DB	0c7H
	DB	038H
	DB	017H
	DB	089H
	DB	08aH
	DB	022H
	DB	02dH
	DB	0c7H
	DB	0bbH
	DB	06eH
	DB	0e6H
	DB	0cbH
	DB	053H
	DB	09cH
	DB	05eH
	DB	02cH
	DB	0c5H
	DB	0efH
	DB	0b7H
	DB	0a5H
	DB	082H
	DB	05fH
	DB	0f3H
	DB	016H
	DB	043H
	DB	034H
	DB	0eH
	DB	015H
	DB	029H
	DB	038H
	DB	0f3H
	DB	0c3H
	DB	095H
	DB	069H
	DB	072H
	DB	01fH
	DB	032H
	DB	0f2H
	DB	0c7H
	DB	053H
	DB	023H
	DB	0fcH
	DB	0f6H
	DB	024H
	DB	044H
	DB	0c2H
	DB	034H
	DB	076H
	DB	083H
	DB	0b3H
	DB	0adH
	DB	05aH
	DB	0dH
	DB	035H
	DB	061H
	DB	06H
	DB	03dH
	DB	0d8H
	DB	03bH
	DB	02cH
	DB	039H
	DB	04cH
	DB	0cfH
	DB	07cH
	DB	068H
	DB	0f5H
	DB	04bH
	DB	0e9H
	DB	0a6H
	DB	099H
	DB	075H
	DB	095H
	DB	0f6H
	DB	04bH
	DB	084H
	DB	0bbH
	DB	01dH
	DB	048H
	DB	0fH
	DB	062H
	DB	06bH
	DB	093H
	DB	097H
	DB	01aH
	DB	04dH
	DB	061H
	DB	0adH
	DB	056H
	DB	017H
	DB	0a4H
	DB	0f8H
	DB	0c7H
	DB	0adH
	DB	045H
	DB	0deH
	DB	0f9H
	DB	080H
	DB	051H
	DB	0d1H
	DB	038H
	DB	0dfH
	DB	0bdH
	DB	082H
	DB	095H
	DB	0f6H
	DB	091H
	DB	0adH
	DB	083H
	DB	04dH
	DB	026H
	DB	0beH
	DB	0eeH
	DB	087H
	DB	045H
	DB	0b1H
	DB	097H
	DB	093H
	DB	057H
	DB	0daH
	DB	09eH
	DB	057H
	DB	013H
	DB	0a5H
	DB	083H
	DB	0edH
	DB	059H
	DB	06H
	DB	09cH
	DB	0f0H
	DB	089H
	DB	082H
	DB	021H
	DB	042H
	DB	055H
	DB	093H
	DB	058H
	DB	03H
	DB	0a3H
	DB	0b4H
	DB	011H
	DB	0b9H
	DB	082H
	DB	0feH
	DB	065H
	DB	0f8H
	DB	0a6H
	DB	0e1H
	DB	054H
	DB	0deH
	DB	05fH
	DB	05eH
	DB	0d3H
	DB	0ffH
	DB	0deH
	DB	0afH
	DB	01H
	DB	0b4H
	DB	011H
	DB	0b3H
	DB	030H
	DB	02dH
	DB	035H
	DB	0d0H
	DB	0caH
	DB	058H
	DB	065H
	DB	075H
	DB	0b7H
	DB	04eH
	DB	059H
	DB	015H
	DB	0b7H
	DB	01eH
	DB	0eaH
	DB	04H
	DB	0dfH
	DB	011H
	DB	08eH
	DB	061H
	DB	0eaH
	DB	01H
	DB	065H
	DB	02dH
	DB	031H
	DB	09bH
	DB	050H
	DB	069H
	DB	08bH
	DB	087H
	DB	079H
	DB	018H
	DB	075H
	DB	0c7H
	DB	092H
	DB	0c6H
	DB	093H
	DB	0c6H
	DB	086H
	DB	014H
	DB	054H
	DB	0d2H
	DB	040H
	DB	01H
	DB	086H
	DB	070H
	DB	0efH
	DB	078H
	DB	069H
	DB	019H
	DB	0e6H
	DB	08fH
	DB	011H
	DB	061H
	DB	09H
	DB	011H
	DB	011H
	DB	011H
	DB	00H
	DB	01H
	DB	010H
	DB	040H
	DB	050H
	DB	055H
	DB	050H
	DB	015H
	DB	055H
	DB	05H
	DB	041H
	DB	054H
	DB	044H
	DB	050H
	DB	01H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	0c8H
	DB	0cfH
	DB	0f7H
	DB	093H
	DB	0aeH
	DB	01cH
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	086H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0eaH
	DB	0caH
	DB	021H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	087H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	011H
	DB	01H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	015H
	DB	040H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	087H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	010H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
$SG196173 DB	'C:\papa\MyGit\hyperion-zvector\dyncrypt.c:4956', 00H
	ORG $+1
$SG196206 DB	'SDL 4.60', 00H
	ORG $+3
$SG196213 DB	'SYSBLK', 00H
	ORG $+1
$SG196407 DB	'I', 00H
	ORG $+2
$SG196207 DB	'HERCULES', 00H
	ORG $+3
$SG196406 DB	'Crypto', 00H
	ORG $+1
$SG196412 DB	'I', 00H
	ORG $+2
$SG196209 DB	'SDL 4.00', 00H
	ORG $+3
$SG196210 DB	'REGS', 00H
	ORG $+3
$SG196417 DB	'I', 00H
	ORG $+2
$SG196212 DB	'SDL 4.2', 00H
$SG196339 DB	'dyn_compute_intermediate_message_digest', 00H
$SG196341 DB	'dyn_compute_intermediate_message_digest', 00H
$SG196343 DB	'dyn_compute_intermediate_message_digest', 00H
$SG196345 DB	'dyn_compute_last_message_digest', 00H
$SG196347 DB	'dyn_compute_last_message_digest', 00H
$SG196349 DB	'dyn_compute_last_message_digest', 00H
$SG196351 DB	'dyn_cipher_message', 00H
	ORG $+5
$SG196353 DB	'dyn_cipher_message', 00H
	ORG $+5
$SG196355 DB	'dyn_cipher_message', 00H
	ORG $+5
$SG196357 DB	'dyn_compute_message_authentication_code', 00H
$SG196359 DB	'dyn_compute_message_authentication_code', 00H
$SG196361 DB	'dyn_compute_message_authentication_code', 00H
$SG196363 DB	'dyn_cipher_message_with_chaining', 00H
	ORG $+7
$SG196365 DB	'dyn_cipher_message_with_chaining', 00H
	ORG $+7
$SG196367 DB	'dyn_cipher_message_with_chaining', 00H
	ORG $+7
$SG196369 DB	'dyn_perform_cryptographic_key_management_operation', 00H
	ORG $+5
$SG196371 DB	'dyn_perform_cryptographic_key_management_operation', 00H
	ORG $+5
$SG196373 DB	'dyn_perform_cryptographic_key_management_operation', 00H
	ORG $+5
$SG196375 DB	'dyn_cipher_message_with_counter', 00H
$SG196377 DB	'dyn_cipher_message_with_counter', 00H
$SG196379 DB	'dyn_cipher_message_with_counter', 00H
$SG196381 DB	'dyn_cipher_message_with_cipher_feedback', 00H
$SG196383 DB	'dyn_cipher_message_with_cipher_feedback', 00H
$SG196385 DB	'dyn_cipher_message_with_cipher_feedback', 00H
$SG196387 DB	'dyn_cipher_message_with_output_feedback', 00H
$SG196389 DB	'dyn_cipher_message_with_output_feedback', 00H
$SG196391 DB	'dyn_cipher_message_with_output_feedback', 00H
$SG196393 DB	'dyn_perform_cryptographic_computation', 00H
	ORG $+2
$SG196395 DB	'dyn_perform_cryptographic_computation', 00H
	ORG $+2
$SG196397 DB	'dyn_perform_cryptographic_computation', 00H
	ORG $+2
$SG196405 DB	' (C) Copyright 2003-2016 by Bernard van der Helm', 00H
	ORG $+7
$SG196408 DB	'HHC00150%s %s module loaded%s', 0aH, 00H
	ORG $+1
$SG196409 DB	'hdl_register_symbols_ep', 00H
$SG196410 DB	'C:\papa\MyGit\hyperion-zvector\dyncrypt.c', 00H
	ORG $+6
$SG196411 DB	'Message Security Assist', 00H
$SG196413 DB	'HHC00151%s Activated facility: %s', 0aH, 00H
	ORG $+5
$SG196414 DB	'hdl_register_symbols_ep', 00H
$SG196415 DB	'C:\papa\MyGit\hyperion-zvector\dyncrypt.c', 00H
	ORG $+6
$SG196416 DB	'Message Security Assist Extension 1, 2, 3 and 4', 00H
$SG196418 DB	'HHC00151%s Activated facility: %s', 0aH, 00H
	ORG $+5
$SG196419 DB	'hdl_register_symbols_ep', 00H
$SG196420 DB	'C:\papa\MyGit\hyperion-zvector\dyncrypt.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_validate_operand DD 011701H
	DD	08217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_maddr_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_lcheck DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check2 DD 011201H
	DD	06212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero_check DD 010d01H
	DD	0620dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_per3_zero DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_perform_cryptographic_key_management_operation
	DD	01bH
	DD	0523H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_cipher_message_with_output_feedback
	DD	01bH
	DD	05d0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_cipher_message_with_cipher_feedback
	DD	01bH
	DD	05d0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_cipher_message_with_counter
	DD	01bH
	DD	04f5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_cipher_message_with_chaining
	DD	01bH
	DD	0694H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_compute_message_authentication_code
	DD	01bH
	DD	04e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_cipher_message
	DD	01bH
	DD	0694H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_compute_last_message_digest
	DD	01bH
	DD	061dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_dyn_compute_intermediate_message_digest
	DD	01bH
	DD	0535H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_pckmo_aes
	DD	016H
	DD	0221H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_pckmo_dea
	DD	016H
	DD	021dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_pcc_xts_aes
	DD	018H
	DD	05f9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_pcc_cmac_aes
	DD	017H
	DD	081cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_pcc_cmac_dea
	DD	017H
	DD	0ae8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmo_aes
	DD	01eH
	DD	0a37H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmo_dea
	DD	01eH
	DD	0bdbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmf_aes
	DD	01eH
	DD	0bdaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmf_dea
	DD	01eH
	DD	0d86H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmctr_aes
	DD	023H
	DD	0b24H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmctr_dea
	DD	023H
	DD	0cbaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmc_prng
	DD	01eH
	DD	0aeaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmc_aes
	DD	020H
	DD	0b43H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmc_dea
	DD	01eH
	DD	0ee3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmac_aes
	DD	01eH
	DD	082fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kmac_dea
	DD	01eH
	DD	09d3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_km_xts_aes
	DD	01eH
	DD	0b10H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_km_aes
	DD	01eH
	DD	0903H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_km_dea
	DD	01eH
	DD	09eeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_klmd_sha
	DD	020H
	DD	0a73H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kimd_ghash
	DD	01eH
	DD	0737H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_kimd_sha
	DD	023H
	DD	08d2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_dyn_cipher_message_with_chaining
	DD	01bH
	DD	046bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_dyn_compute_message_authentication_code
	DD	01bH
	DD	03e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_dyn_cipher_message
	DD	01bH
	DD	042dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_dyn_compute_last_message_digest
	DD	01bH
	DD	045cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_dyn_compute_intermediate_message_digest
	DD	01bH
	DD	0465H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_kmc_prng
	DD	01eH
	DD	05e9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_kmc_aes
	DD	020H
	DD	05f1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_kmc_dea
	DD	01eH
	DD	0988H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_kmac_dea
	DD	01eH
	DD	05adH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_km_aes
	DD	01eH
	DD	0458H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_km_dea
	DD	01eH
	DD	0543H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_klmd_sha
	DD	020H
	DD	0646H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_kimd_sha
	DD	023H
	DD	04c8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_perform_cryptographic_key_management_operation
	DD	01bH
	DD	0439H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_cipher_message_with_output_feedback
	DD	01bH
	DD	0408H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_cipher_message_with_cipher_feedback
	DD	01bH
	DD	0408H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_cipher_message_with_counter
	DD	01bH
	DD	0434H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_cipher_message_with_chaining
	DD	01bH
	DD	04ccH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_compute_message_authentication_code
	DD	01bH
	DD	044aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_cipher_message
	DD	01bH
	DD	04ccH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_compute_last_message_digest
	DD	01bH
	DD	0451H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_dyn_compute_intermediate_message_digest
	DD	01bH
	DD	049bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_pckmo_aes
	DD	016H
	DD	0135H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_pckmo_dea
	DD	016H
	DD	0131H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_pcc_xts_aes
	DD	018H
	DD	0501H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_pcc_cmac_aes
	DD	017H
	DD	072cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_pcc_cmac_dea
	DD	017H
	DD	09efH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmo_aes
	DD	01eH
	DD	04eaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmo_dea
	DD	01eH
	DD	068bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmf_aes
	DD	01eH
	DD	0644H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmf_dea
	DD	01eH
	DD	07dfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmctr_aes
	DD	023H
	DD	053bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmctr_dea
	DD	023H
	DD	06d4H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmc_prng
	DD	01eH
	DD	05b2H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmc_aes
	DD	020H
	DD	05f3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmc_dea
	DD	01eH
	DD	098aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmac_aes
	DD	01eH
	DD	0432H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kmac_dea
	DD	01eH
	DD	05baH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_km_xts_aes
	DD	01eH
	DD	05bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_km_aes
	DD	01eH
	DD	0464H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_km_dea
	DD	01eH
	DD	054fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_klmd_sha
	DD	020H
	DD	0619H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kimd_ghash
	DD	01eH
	DD	0337H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_kimd_sha
	DD	023H
	DD	049bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:wrap_dea
	DD	01cH
	DD	01ddH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:wrap_aes
	DD	01cH
	DD	0259H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:unwrap_dea
	DD	01aH
	DD	0239H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:unwrap_aes
	DD	01cH
	DD	0280H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:xts_gf_mult
	DD	01dH
	DD	0caH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:gcm_gf_mult
	DD	01fH
	DD	013fH
voltbl	ENDS
xdata	SEGMENT
$unwind$crypto_fetch32 DD 010901H
	DD	04209H
$unwind$crypto_store32 DD 010d01H
	DD	0420dH
$unwind$crypto_cswap32 DD 010801H
	DD	04208H
$unwind$crypto_cswap64 DD 010901H
	DD	04209H
$unwind$crypto_secure0 DD 010e01H
	DD	0420eH
$unwind$gcm_rightshift DD 010901H
	DD	02209H
$unwind$gcm_gf_mult DD 032419H
	DD	07011a215H
	DD	06010H
	DD	imagerel __GSHandlerCheck
	DD	048H
$unwind$xts_mult_x DD 010901H
	DD	02209H
$unwind$xts_gf_mult DD 012219H
	DD	0c213H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$sha1_getcv DD 010e01H
	DD	0220eH
$unwind$sha1_seticv DD 010e01H
	DD	0220eH
$unwind$sha256_getcv DD 010e01H
	DD	0220eH
$unwind$sha256_seticv DD 010e01H
	DD	0220eH
$unwind$sha512_getcv DD 010e01H
	DD	0220eH
$unwind$sha512_seticv DD 010e01H
	DD	0220eH
$unwind$shift_left DD 011301H
	DD	02213H
$unwind$des_set_key DD 010e01H
	DD	0620eH
$unwind$des_encrypt DD 011301H
	DD	08213H
$unwind$des_decrypt DD 011301H
	DD	08213H
$unwind$des3_set_2keys DD 011301H
	DD	06213H
$unwind$des3_set_3keys DD 011801H
	DD	06218H
$unwind$des3_encrypt DD 011301H
	DD	08213H
$unwind$des3_decrypt DD 011301H
	DD	08213H
$unwind$unwrap_aes DD 042419H
	DD	04b0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$unwrap_dea DD 022219H
	DD	03f0110H
	DD	imagerel __GSHandlerCheck
	DD	01e0H
$unwind$wrap_aes DD 042419H
	DD	04b0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$wrap_dea DD 042419H
	DD	03d0112H
	DD	0600a700bH
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$s370_kimd_sha DD 022b19H
	DD	0670119H
	DD	imagerel __GSHandlerCheck
	DD	0320H
$unwind$s370_kimd_ghash DD 022619H
	DD	0130114H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s370_klmd_sha DD 042819H
	DD	06d0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$s370_km_dea DD 022619H
	DD	05f0114H
	DD	imagerel __GSHandlerCheck
	DD	02e8H
$unwind$s370_km_aes DD 022619H
	DD	0590114H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$s370_km_xts_aes DD 022619H
	DD	05d0114H
	DD	imagerel __GSHandlerCheck
	DD	02d0H
$unwind$s370_kmac_dea DD 022619H
	DD	04f0114H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$s370_kmac_aes DD 022619H
	DD	0590114H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$s370_kmc_dea DD 022619H
	DD	0510114H
	DD	imagerel __GSHandlerCheck
	DD	0278H
$unwind$s370_kmc_aes DD 042819H
	DD	05f0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	02e0H
$unwind$s370_kmc_prng DD 022619H
	DD	04b0114H
	DD	imagerel __GSHandlerCheck
	DD	0248H
$unwind$s370_kmctr_dea DD 022b19H
	DD	0530119H
	DD	imagerel __GSHandlerCheck
	DD	0280H
$unwind$s370_kmctr_aes DD 022b19H
	DD	05d0119H
	DD	imagerel __GSHandlerCheck
	DD	02d0H
$unwind$s370_kmf_dea DD 022619H
	DD	0510114H
	DD	imagerel __GSHandlerCheck
	DD	0278H
$unwind$s370_kmf_aes DD 022619H
	DD	05f0114H
	DD	imagerel __GSHandlerCheck
	DD	02e0H
$unwind$s370_kmo_dea DD 022619H
	DD	0510114H
	DD	imagerel __GSHandlerCheck
	DD	0270H
$unwind$s370_kmo_aes DD 022619H
	DD	05b0114H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$s370_pcc_cmac_dea DD 031f19H
	DD	056010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
$unwind$s370_pcc_cmac_aes DD 031f19H
	DD	064010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0310H
$unwind$s370_pcc_xts_aes DD 042019H
	DD	065010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0310H
$unwind$s370_pckmo_dea DD 021e19H
	DD	013010cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s370_pckmo_aes DD 021e19H
	DD	013010cH
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$s370_dyn_compute_intermediate_message_digest DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_compute_last_message_digest DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_cipher_message DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_compute_message_authentication_code DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_cipher_message_with_chaining DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_cipher_message_with_counter DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_cipher_message_with_cipher_feedback DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_cipher_message_with_output_feedback DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s370_dyn_perform_cryptographic_computation DD 010e01H
	DD	0820eH
$unwind$s370_dyn_perform_cryptographic_key_management_operation DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s390_kimd_sha DD 022b19H
	DD	0670119H
	DD	imagerel __GSHandlerCheck
	DD	0320H
$unwind$s390_klmd_sha DD 042819H
	DD	06d0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$s390_km_dea DD 022619H
	DD	05f0114H
	DD	imagerel __GSHandlerCheck
	DD	02e8H
$unwind$s390_km_aes DD 022619H
	DD	0590114H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$s390_kmac_dea DD 022619H
	DD	04f0114H
	DD	imagerel __GSHandlerCheck
	DD	0260H
$unwind$s390_kmc_dea DD 022619H
	DD	0510114H
	DD	imagerel __GSHandlerCheck
	DD	0278H
$unwind$s390_kmc_aes DD 042819H
	DD	05f0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	02e0H
$unwind$s390_kmc_prng DD 022619H
	DD	04b0114H
	DD	imagerel __GSHandlerCheck
	DD	0248H
$unwind$s390_dyn_compute_intermediate_message_digest DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s390_dyn_compute_last_message_digest DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s390_dyn_cipher_message DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s390_dyn_compute_message_authentication_code DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s390_dyn_cipher_message_with_chaining DD 022319H
	DD	0170111H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$s390_dyn_perform_cryptographic_key_management_operation DD 010e01H
	DD	0820eH
$unwind$s390_dyn_perform_cryptographic_computation DD 010e01H
	DD	0820eH
$unwind$s390_dyn_cipher_message_with_cipher_feedback DD 010e01H
	DD	0820eH
$unwind$s390_dyn_cipher_message_with_output_feedback DD 010e01H
	DD	0820eH
$unwind$s390_dyn_cipher_message_with_counter DD 010e01H
	DD	0820eH
$unwind$z900_kimd_sha DD 022b19H
	DD	0730119H
	DD	imagerel __GSHandlerCheck
	DD	0380H
$unwind$z900_kimd_ghash DD 022619H
	DD	01d0114H
	DD	imagerel __GSHandlerCheck
	DD	0d8H
$unwind$z900_klmd_sha DD 042819H
	DD	0790116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	03b0H
$unwind$z900_km_dea DD 022619H
	DD	06b0114H
	DD	imagerel __GSHandlerCheck
	DD	0348H
$unwind$z900_km_aes DD 022619H
	DD	0650114H
	DD	imagerel __GSHandlerCheck
	DD	0310H
$unwind$z900_km_xts_aes DD 022619H
	DD	06b0114H
	DD	imagerel __GSHandlerCheck
	DD	0340H
$unwind$z900_kmac_dea DD 022619H
	DD	0590114H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$z900_kmac_aes DD 022619H
	DD	0650114H
	DD	imagerel __GSHandlerCheck
	DD	0310H
$unwind$z900_kmc_dea DD 022619H
	DD	05f0114H
	DD	imagerel __GSHandlerCheck
	DD	02e8H
$unwind$z900_kmc_aes DD 042819H
	DD	06d0116H
	DD	0600e700fH
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$z900_kmc_prng DD 022619H
	DD	0590114H
	DD	imagerel __GSHandlerCheck
	DD	02b8H
$unwind$z900_kmctr_dea DD 022b19H
	DD	0610119H
	DD	imagerel __GSHandlerCheck
	DD	02f0H
$unwind$z900_kmctr_aes DD 022b19H
	DD	06d0119H
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$z900_kmf_dea DD 022619H
	DD	0610114H
	DD	imagerel __GSHandlerCheck
	DD	02f8H
$unwind$z900_kmf_aes DD 022619H
	DD	06d0114H
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$z900_kmo_dea DD 022619H
	DD	05f0114H
	DD	imagerel __GSHandlerCheck
	DD	02e0H
$unwind$z900_kmo_aes DD 022619H
	DD	0690114H
	DD	imagerel __GSHandlerCheck
	DD	0330H
$unwind$z900_pcc_cmac_dea DD 031f19H
	DD	05a010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02c0H
$unwind$z900_pcc_cmac_aes DD 031f19H
	DD	066010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0320H
$unwind$z900_pcc_xts_aes DD 042019H
	DD	067010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0320H
$unwind$z900_pckmo_dea DD 021e19H
	DD	017010cH
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_pckmo_aes DD 021e19H
	DD	017010cH
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$z900_dyn_compute_intermediate_message_digest DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_dyn_compute_last_message_digest DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_dyn_cipher_message DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_dyn_compute_message_authentication_code DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_dyn_cipher_message_with_chaining DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_dyn_cipher_message_with_counter DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$z900_dyn_cipher_message_with_cipher_feedback DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_dyn_cipher_message_with_output_feedback DD 022319H
	DD	01b0111H
	DD	imagerel __GSHandlerCheck
	DD	0c0H
$unwind$z900_dyn_perform_cryptographic_computation DD 010e01H
	DD	0820eH
$unwind$z900_dyn_perform_cryptographic_key_management_operation DD 022319H
	DD	0190111H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$hdl_check_depends_ep DD 010901H
	DD	06209H
$unwind$hdl_define_instructs_ep DD 010901H
	DD	04209H
$unwind$hdl_register_symbols_ep DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_validate_operand DD 011601H
	DD	08216H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vfetchc DD 031901H
	DD	07015a219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_vstorec DD 031901H
	DD	07015c219H
	DD	06014H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_maddr_l DD 011701H
	DD	0a217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RtlSecureZeroMemory DD 020f01H
	DD	0700b120fH
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
regsym$ = 96
hdl_register_symbols_ep PROC

; 5131 : HDL_REGISTER_SECTION;

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@hdl_regist:

; 5132 : {
; 5133 :   /* Display copyright, version and level of support information */
; 5134 : 
; 5135 :   UNREFERENCED( regsym );   // (HDL_REGISTER_SECTION parameter)

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@hdl_regist

; 5136 : 
; 5137 :   // "%s module loaded%s"
; 5138 :   WRMSG( HHC00150, "I", "Crypto", " (C) Copyright 2003-2016 by Bernard van der Helm");

  0000f	b9 01 00 00 00	 mov	 ecx, 1
  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0001a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196405
  00021	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00026	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196406
  0002d	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196407
  00039	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196408
  00045	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0004a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00055	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196409
  0005c	ba 12 14 00 00	 mov	 edx, 5138		; 00001412H
  00061	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196410
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5139 : 
; 5140 :   // "Activated facility: %s"
; 5141 :   WRMSG( HHC00151, "I", "Message Security Assist");

  0006e	b9 01 00 00 00	 mov	 ecx, 1
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00079	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196411
  00080	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196412
  0008c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196413
  00098	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0009d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  000a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196414
  000af	ba 15 14 00 00	 mov	 edx, 5141		; 00001415H
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196415
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5142 : 
; 5143 : #if defined( _FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 5144 :   WRMSG( HHC00151, "I", "Message Security Assist Extension 1, 2, 3 and 4");

  000c1	b9 01 00 00 00	 mov	 ecx, 1
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196416
  000d3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196417
  000df	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196418
  000eb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000f0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f5	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196419
  00102	ba 18 14 00 00	 mov	 edx, 5144		; 00001418H
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196420
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 5145 : #else
; 5146 :   #if defined( _FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 5147 :     WRMSG( HHC00151, "I", "Message Security Assist Extension 1, 2 and 3");
; 5148 :   #else
; 5149 :     #if defined( _FEATURE_MSA_EXTENSION_FACILITY_2 )
; 5150 :       WRMSG( HHC00151, "I", "Message Security Assist Extension 1 and 2");
; 5151 :     #else
; 5152 :       #if defined( _FEATURE_MSA_EXTENSION_FACILITY_1 )
; 5153 :         WRMSG( HHC00151, "I", "Message Security Assist Extension 1");
; 5154 :       #endif /* defined( _FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 5155 :     #endif /* defined( _FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 5156 :   #endif /* defined( _FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 5157 : #endif /* defined( _FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 5158 : }
; 5159 : END_REGISTER_SECTION;

  00114	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00118	c3		 ret	 0
hdl_register_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
defins$ = 48
hdl_define_instructs_ep PROC

; 5078 : HDL_INSTRUCTION_SECTION;

$LN153:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@hdl_define:
$LN7@hdl_define:

; 5079 : {
; 5080 :     // (allows for a much shorter HDL_INST statement)
; 5081 : 
; 5082 : #define HDL_INST            HDL_DEF_INST
; 5083 : #define ARCH_____390_900                       HDL_INSTARCH_390 | HDL_INSTARCH_900
; 5084 : #define ARCH_________900                                          HDL_INSTARCH_900
; 5085 : #define ARCH_370_390_900    HDL_INSTARCH_370 | HDL_INSTARCH_390 | HDL_INSTARCH_900
; 5086 : #define ARCH_370_____900    HDL_INSTARCH_370                    | HDL_INSTARCH_900
; 5087 : #define OPCODE( _opcode )   0x ## _opcode
; 5088 : 
; 5089 :   /* Install our instructions for the architectures we support */
; 5090 : 
; 5091 : #if defined( _FEATURE_017_MSA_FACILITY )
; 5092 :   #if !defined( _FEATURE_370_EXTENSION )
; 5093 :   HDL_INST( ARCH_____390_900, OPCODE( B93E ), dyn_compute_intermediate_message_digest );
; 5094 :   HDL_INST( ARCH_____390_900, OPCODE( B93F ), dyn_compute_last_message_digest         );
; 5095 :   HDL_INST( ARCH_____390_900, OPCODE( B92E ), dyn_cipher_message                      );
; 5096 :   HDL_INST( ARCH_____390_900, OPCODE( B91E ), dyn_compute_message_authentication_code );
; 5097 :   HDL_INST( ARCH_____390_900, OPCODE( B92F ), dyn_cipher_message_with_chaining        );
; 5098 :   #else
; 5099 :   HDL_INST( ARCH_370_390_900, OPCODE( B93E ), dyn_compute_intermediate_message_digest );

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	74 1c		 je	 SHORT $LN122@hdl_define
  00010	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_compute_intermediate_message_digest
  00017	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196339
  0001e	ba 3e b9 00 00	 mov	 edx, 47422		; 0000b93eH
  00023	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00028	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN122@hdl_define:
  0002c	33 c0		 xor	 eax, eax
  0002e	85 c0		 test	 eax, eax
  00030	75 d7		 jne	 SHORT $LN7@hdl_define
$LN10@hdl_define:
  00032	33 c0		 xor	 eax, eax
  00034	83 f8 01	 cmp	 eax, 1
  00037	74 1c		 je	 SHORT $LN123@hdl_define
  00039	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_compute_intermediate_message_digest
  00040	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196341
  00047	ba 3e b9 00 00	 mov	 edx, 47422		; 0000b93eH
  0004c	b9 00 00 00 40	 mov	 ecx, 1073741824		; 40000000H
  00051	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN123@hdl_define:
  00055	33 c0		 xor	 eax, eax
  00057	85 c0		 test	 eax, eax
  00059	75 d7		 jne	 SHORT $LN10@hdl_define
$LN13@hdl_define:
  0005b	33 c0		 xor	 eax, eax
  0005d	83 f8 01	 cmp	 eax, 1
  00060	74 1c		 je	 SHORT $LN124@hdl_define
  00062	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_compute_intermediate_message_digest
  00069	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196343
  00070	ba 3e b9 00 00	 mov	 edx, 47422		; 0000b93eH
  00075	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  0007a	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN124@hdl_define:
  0007e	33 c0		 xor	 eax, eax
  00080	85 c0		 test	 eax, eax
  00082	75 d7		 jne	 SHORT $LN13@hdl_define
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	0f 85 7b ff ff
	ff		 jne	 $LN4@hdl_define
$LN16@hdl_define:
$LN19@hdl_define:

; 5100 :   HDL_INST( ARCH_370_390_900, OPCODE( B93F ), dyn_compute_last_message_digest         );

  0008e	33 c0		 xor	 eax, eax
  00090	83 f8 01	 cmp	 eax, 1
  00093	74 1c		 je	 SHORT $LN125@hdl_define
  00095	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_compute_last_message_digest
  0009c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196345
  000a3	ba 3f b9 00 00	 mov	 edx, 47423		; 0000b93fH
  000a8	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  000ad	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN125@hdl_define:
  000b1	33 c0		 xor	 eax, eax
  000b3	85 c0		 test	 eax, eax
  000b5	75 d7		 jne	 SHORT $LN19@hdl_define
$LN22@hdl_define:
  000b7	33 c0		 xor	 eax, eax
  000b9	83 f8 01	 cmp	 eax, 1
  000bc	74 1c		 je	 SHORT $LN126@hdl_define
  000be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_compute_last_message_digest
  000c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196347
  000cc	ba 3f b9 00 00	 mov	 edx, 47423		; 0000b93fH
  000d1	b9 00 00 00 40	 mov	 ecx, 1073741824		; 40000000H
  000d6	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN126@hdl_define:
  000da	33 c0		 xor	 eax, eax
  000dc	85 c0		 test	 eax, eax
  000de	75 d7		 jne	 SHORT $LN22@hdl_define
$LN25@hdl_define:
  000e0	33 c0		 xor	 eax, eax
  000e2	83 f8 01	 cmp	 eax, 1
  000e5	74 1c		 je	 SHORT $LN127@hdl_define
  000e7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_compute_last_message_digest
  000ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196349
  000f5	ba 3f b9 00 00	 mov	 edx, 47423		; 0000b93fH
  000fa	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  000ff	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN127@hdl_define:
  00103	33 c0		 xor	 eax, eax
  00105	85 c0		 test	 eax, eax
  00107	75 d7		 jne	 SHORT $LN25@hdl_define
  00109	33 c0		 xor	 eax, eax
  0010b	85 c0		 test	 eax, eax
  0010d	0f 85 7b ff ff
	ff		 jne	 $LN16@hdl_define
$LN28@hdl_define:
$LN31@hdl_define:

; 5101 :   HDL_INST( ARCH_370_390_900, OPCODE( B92E ), dyn_cipher_message                      );

  00113	33 c0		 xor	 eax, eax
  00115	83 f8 01	 cmp	 eax, 1
  00118	74 1c		 je	 SHORT $LN128@hdl_define
  0011a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_cipher_message
  00121	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196351
  00128	ba 2e b9 00 00	 mov	 edx, 47406		; 0000b92eH
  0012d	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00132	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN128@hdl_define:
  00136	33 c0		 xor	 eax, eax
  00138	85 c0		 test	 eax, eax
  0013a	75 d7		 jne	 SHORT $LN31@hdl_define
$LN34@hdl_define:
  0013c	33 c0		 xor	 eax, eax
  0013e	83 f8 01	 cmp	 eax, 1
  00141	74 1c		 je	 SHORT $LN129@hdl_define
  00143	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_cipher_message
  0014a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196353
  00151	ba 2e b9 00 00	 mov	 edx, 47406		; 0000b92eH
  00156	b9 00 00 00 40	 mov	 ecx, 1073741824		; 40000000H
  0015b	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN129@hdl_define:
  0015f	33 c0		 xor	 eax, eax
  00161	85 c0		 test	 eax, eax
  00163	75 d7		 jne	 SHORT $LN34@hdl_define
$LN37@hdl_define:
  00165	33 c0		 xor	 eax, eax
  00167	83 f8 01	 cmp	 eax, 1
  0016a	74 1c		 je	 SHORT $LN130@hdl_define
  0016c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_cipher_message
  00173	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196355
  0017a	ba 2e b9 00 00	 mov	 edx, 47406		; 0000b92eH
  0017f	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  00184	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN130@hdl_define:
  00188	33 c0		 xor	 eax, eax
  0018a	85 c0		 test	 eax, eax
  0018c	75 d7		 jne	 SHORT $LN37@hdl_define
  0018e	33 c0		 xor	 eax, eax
  00190	85 c0		 test	 eax, eax
  00192	0f 85 7b ff ff
	ff		 jne	 $LN28@hdl_define
$LN40@hdl_define:
$LN43@hdl_define:

; 5102 :   HDL_INST( ARCH_370_390_900, OPCODE( B91E ), dyn_compute_message_authentication_code );

  00198	33 c0		 xor	 eax, eax
  0019a	83 f8 01	 cmp	 eax, 1
  0019d	74 1c		 je	 SHORT $LN131@hdl_define
  0019f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_compute_message_authentication_code
  001a6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196357
  001ad	ba 1e b9 00 00	 mov	 edx, 47390		; 0000b91eH
  001b2	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  001b7	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN131@hdl_define:
  001bb	33 c0		 xor	 eax, eax
  001bd	85 c0		 test	 eax, eax
  001bf	75 d7		 jne	 SHORT $LN43@hdl_define
$LN46@hdl_define:
  001c1	33 c0		 xor	 eax, eax
  001c3	83 f8 01	 cmp	 eax, 1
  001c6	74 1c		 je	 SHORT $LN132@hdl_define
  001c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_compute_message_authentication_code
  001cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196359
  001d6	ba 1e b9 00 00	 mov	 edx, 47390		; 0000b91eH
  001db	b9 00 00 00 40	 mov	 ecx, 1073741824		; 40000000H
  001e0	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN132@hdl_define:
  001e4	33 c0		 xor	 eax, eax
  001e6	85 c0		 test	 eax, eax
  001e8	75 d7		 jne	 SHORT $LN46@hdl_define
$LN49@hdl_define:
  001ea	33 c0		 xor	 eax, eax
  001ec	83 f8 01	 cmp	 eax, 1
  001ef	74 1c		 je	 SHORT $LN133@hdl_define
  001f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_compute_message_authentication_code
  001f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196361
  001ff	ba 1e b9 00 00	 mov	 edx, 47390		; 0000b91eH
  00204	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  00209	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN133@hdl_define:
  0020d	33 c0		 xor	 eax, eax
  0020f	85 c0		 test	 eax, eax
  00211	75 d7		 jne	 SHORT $LN49@hdl_define
  00213	33 c0		 xor	 eax, eax
  00215	85 c0		 test	 eax, eax
  00217	0f 85 7b ff ff
	ff		 jne	 $LN40@hdl_define
$LN52@hdl_define:
$LN55@hdl_define:

; 5103 :   HDL_INST( ARCH_370_390_900, OPCODE( B92F ), dyn_cipher_message_with_chaining        );

  0021d	33 c0		 xor	 eax, eax
  0021f	83 f8 01	 cmp	 eax, 1
  00222	74 1c		 je	 SHORT $LN134@hdl_define
  00224	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_cipher_message_with_chaining
  0022b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196363
  00232	ba 2f b9 00 00	 mov	 edx, 47407		; 0000b92fH
  00237	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0023c	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN134@hdl_define:
  00240	33 c0		 xor	 eax, eax
  00242	85 c0		 test	 eax, eax
  00244	75 d7		 jne	 SHORT $LN55@hdl_define
$LN58@hdl_define:
  00246	33 c0		 xor	 eax, eax
  00248	83 f8 01	 cmp	 eax, 1
  0024b	74 1c		 je	 SHORT $LN135@hdl_define
  0024d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_cipher_message_with_chaining
  00254	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196365
  0025b	ba 2f b9 00 00	 mov	 edx, 47407		; 0000b92fH
  00260	b9 00 00 00 40	 mov	 ecx, 1073741824		; 40000000H
  00265	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN135@hdl_define:
  00269	33 c0		 xor	 eax, eax
  0026b	85 c0		 test	 eax, eax
  0026d	75 d7		 jne	 SHORT $LN58@hdl_define
$LN61@hdl_define:
  0026f	33 c0		 xor	 eax, eax
  00271	83 f8 01	 cmp	 eax, 1
  00274	74 1c		 je	 SHORT $LN136@hdl_define
  00276	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_cipher_message_with_chaining
  0027d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196367
  00284	ba 2f b9 00 00	 mov	 edx, 47407		; 0000b92fH
  00289	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  0028e	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN136@hdl_define:
  00292	33 c0		 xor	 eax, eax
  00294	85 c0		 test	 eax, eax
  00296	75 d7		 jne	 SHORT $LN61@hdl_define
  00298	33 c0		 xor	 eax, eax
  0029a	85 c0		 test	 eax, eax
  0029c	0f 85 7b ff ff
	ff		 jne	 $LN52@hdl_define
$LN64@hdl_define:
$LN67@hdl_define:

; 5104 :   #endif
; 5105 : #endif
; 5106 : 
; 5107 : #if defined( _FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 5108 :   #if !defined( _FEATURE_370_EXTENSION )
; 5109 :   HDL_INST( ARCH_________900, OPCODE( B928 ), dyn_perform_cryptographic_key_management_operation );
; 5110 :   #else
; 5111 :   HDL_INST( ARCH_370_____900, OPCODE( B928 ), dyn_perform_cryptographic_key_management_operation );

  002a2	33 c0		 xor	 eax, eax
  002a4	83 f8 01	 cmp	 eax, 1
  002a7	74 1c		 je	 SHORT $LN137@hdl_define
  002a9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_perform_cryptographic_key_management_operation
  002b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196369
  002b7	ba 28 b9 00 00	 mov	 edx, 47400		; 0000b928H
  002bc	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  002c1	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN137@hdl_define:
  002c5	33 c0		 xor	 eax, eax
  002c7	85 c0		 test	 eax, eax
  002c9	75 d7		 jne	 SHORT $LN67@hdl_define
$LN70@hdl_define:
  002cb	33 c0		 xor	 eax, eax
  002cd	85 c0		 test	 eax, eax
  002cf	74 19		 je	 SHORT $LN138@hdl_define
  002d1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_perform_cryptographic_key_management_operation
  002d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196371
  002df	ba 28 b9 00 00	 mov	 edx, 47400		; 0000b928H
  002e4	33 c9		 xor	 ecx, ecx
  002e6	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN138@hdl_define:
  002ea	33 c0		 xor	 eax, eax
  002ec	85 c0		 test	 eax, eax
  002ee	75 db		 jne	 SHORT $LN70@hdl_define
$LN73@hdl_define:
  002f0	33 c0		 xor	 eax, eax
  002f2	83 f8 01	 cmp	 eax, 1
  002f5	74 1c		 je	 SHORT $LN139@hdl_define
  002f7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_perform_cryptographic_key_management_operation
  002fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196373
  00305	ba 28 b9 00 00	 mov	 edx, 47400		; 0000b928H
  0030a	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  0030f	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN139@hdl_define:
  00313	33 c0		 xor	 eax, eax
  00315	85 c0		 test	 eax, eax
  00317	75 d7		 jne	 SHORT $LN73@hdl_define
  00319	33 c0		 xor	 eax, eax
  0031b	85 c0		 test	 eax, eax
  0031d	75 83		 jne	 SHORT $LN64@hdl_define
$LN76@hdl_define:
$LN79@hdl_define:

; 5112 :   #endif
; 5113 : #endif
; 5114 : 
; 5115 : #if defined( _FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 5116 :   #if !defined( _FEATURE_370_EXTENSION )
; 5117 :   HDL_INST( ARCH_________900, OPCODE( B92D ), dyn_cipher_message_with_counter         );
; 5118 :   HDL_INST( ARCH_________900, OPCODE( B92A ), dyn_cipher_message_with_cipher_feedback );
; 5119 :   HDL_INST( ARCH_________900, OPCODE( B92B ), dyn_cipher_message_with_output_feedback );
; 5120 :   HDL_INST( ARCH_________900, OPCODE( B92C ), dyn_perform_cryptographic_computation   );
; 5121 :   #else
; 5122 :   HDL_INST( ARCH_370_____900, OPCODE( B92D ), dyn_cipher_message_with_counter         );

  0031f	33 c0		 xor	 eax, eax
  00321	83 f8 01	 cmp	 eax, 1
  00324	74 1c		 je	 SHORT $LN140@hdl_define
  00326	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_cipher_message_with_counter
  0032d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196375
  00334	ba 2d b9 00 00	 mov	 edx, 47405		; 0000b92dH
  00339	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0033e	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN140@hdl_define:
  00342	33 c0		 xor	 eax, eax
  00344	85 c0		 test	 eax, eax
  00346	75 d7		 jne	 SHORT $LN79@hdl_define
$LN82@hdl_define:
  00348	33 c0		 xor	 eax, eax
  0034a	85 c0		 test	 eax, eax
  0034c	74 19		 je	 SHORT $LN141@hdl_define
  0034e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_cipher_message_with_counter
  00355	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196377
  0035c	ba 2d b9 00 00	 mov	 edx, 47405		; 0000b92dH
  00361	33 c9		 xor	 ecx, ecx
  00363	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN141@hdl_define:
  00367	33 c0		 xor	 eax, eax
  00369	85 c0		 test	 eax, eax
  0036b	75 db		 jne	 SHORT $LN82@hdl_define
$LN85@hdl_define:
  0036d	33 c0		 xor	 eax, eax
  0036f	83 f8 01	 cmp	 eax, 1
  00372	74 1c		 je	 SHORT $LN142@hdl_define
  00374	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_cipher_message_with_counter
  0037b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196379
  00382	ba 2d b9 00 00	 mov	 edx, 47405		; 0000b92dH
  00387	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  0038c	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN142@hdl_define:
  00390	33 c0		 xor	 eax, eax
  00392	85 c0		 test	 eax, eax
  00394	75 d7		 jne	 SHORT $LN85@hdl_define
  00396	33 c0		 xor	 eax, eax
  00398	85 c0		 test	 eax, eax
  0039a	75 83		 jne	 SHORT $LN76@hdl_define
$LN88@hdl_define:
$LN91@hdl_define:

; 5123 :   HDL_INST( ARCH_370_____900, OPCODE( B92A ), dyn_cipher_message_with_cipher_feedback );

  0039c	33 c0		 xor	 eax, eax
  0039e	83 f8 01	 cmp	 eax, 1
  003a1	74 1c		 je	 SHORT $LN143@hdl_define
  003a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_cipher_message_with_cipher_feedback
  003aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196381
  003b1	ba 2a b9 00 00	 mov	 edx, 47402		; 0000b92aH
  003b6	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  003bb	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN143@hdl_define:
  003bf	33 c0		 xor	 eax, eax
  003c1	85 c0		 test	 eax, eax
  003c3	75 d7		 jne	 SHORT $LN91@hdl_define
$LN94@hdl_define:
  003c5	33 c0		 xor	 eax, eax
  003c7	85 c0		 test	 eax, eax
  003c9	74 19		 je	 SHORT $LN144@hdl_define
  003cb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_cipher_message_with_cipher_feedback
  003d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196383
  003d9	ba 2a b9 00 00	 mov	 edx, 47402		; 0000b92aH
  003de	33 c9		 xor	 ecx, ecx
  003e0	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN144@hdl_define:
  003e4	33 c0		 xor	 eax, eax
  003e6	85 c0		 test	 eax, eax
  003e8	75 db		 jne	 SHORT $LN94@hdl_define
$LN97@hdl_define:
  003ea	33 c0		 xor	 eax, eax
  003ec	83 f8 01	 cmp	 eax, 1
  003ef	74 1c		 je	 SHORT $LN145@hdl_define
  003f1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_cipher_message_with_cipher_feedback
  003f8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196385
  003ff	ba 2a b9 00 00	 mov	 edx, 47402		; 0000b92aH
  00404	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  00409	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN145@hdl_define:
  0040d	33 c0		 xor	 eax, eax
  0040f	85 c0		 test	 eax, eax
  00411	75 d7		 jne	 SHORT $LN97@hdl_define
  00413	33 c0		 xor	 eax, eax
  00415	85 c0		 test	 eax, eax
  00417	75 83		 jne	 SHORT $LN88@hdl_define
$LN100@hdl_define:
$LN103@hdl_define:

; 5124 :   HDL_INST( ARCH_370_____900, OPCODE( B92B ), dyn_cipher_message_with_output_feedback );

  00419	33 c0		 xor	 eax, eax
  0041b	83 f8 01	 cmp	 eax, 1
  0041e	74 1c		 je	 SHORT $LN146@hdl_define
  00420	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_cipher_message_with_output_feedback
  00427	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196387
  0042e	ba 2b b9 00 00	 mov	 edx, 47403		; 0000b92bH
  00433	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00438	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN146@hdl_define:
  0043c	33 c0		 xor	 eax, eax
  0043e	85 c0		 test	 eax, eax
  00440	75 d7		 jne	 SHORT $LN103@hdl_define
$LN106@hdl_define:
  00442	33 c0		 xor	 eax, eax
  00444	85 c0		 test	 eax, eax
  00446	74 19		 je	 SHORT $LN147@hdl_define
  00448	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_cipher_message_with_output_feedback
  0044f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196389
  00456	ba 2b b9 00 00	 mov	 edx, 47403		; 0000b92bH
  0045b	33 c9		 xor	 ecx, ecx
  0045d	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN147@hdl_define:
  00461	33 c0		 xor	 eax, eax
  00463	85 c0		 test	 eax, eax
  00465	75 db		 jne	 SHORT $LN106@hdl_define
$LN109@hdl_define:
  00467	33 c0		 xor	 eax, eax
  00469	83 f8 01	 cmp	 eax, 1
  0046c	74 1c		 je	 SHORT $LN148@hdl_define
  0046e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_cipher_message_with_output_feedback
  00475	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196391
  0047c	ba 2b b9 00 00	 mov	 edx, 47403		; 0000b92bH
  00481	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  00486	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN148@hdl_define:
  0048a	33 c0		 xor	 eax, eax
  0048c	85 c0		 test	 eax, eax
  0048e	75 d7		 jne	 SHORT $LN109@hdl_define
  00490	33 c0		 xor	 eax, eax
  00492	85 c0		 test	 eax, eax
  00494	75 83		 jne	 SHORT $LN100@hdl_define
$LN112@hdl_define:
$LN115@hdl_define:

; 5125 :   HDL_INST( ARCH_370_____900, OPCODE( B92C ), dyn_perform_cryptographic_computation   );

  00496	33 c0		 xor	 eax, eax
  00498	83 f8 01	 cmp	 eax, 1
  0049b	74 1c		 je	 SHORT $LN149@hdl_define
  0049d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s370_dyn_perform_cryptographic_computation
  004a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196393
  004ab	ba 2c b9 00 00	 mov	 edx, 47404		; 0000b92cH
  004b0	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  004b5	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN149@hdl_define:
  004b9	33 c0		 xor	 eax, eax
  004bb	85 c0		 test	 eax, eax
  004bd	75 d7		 jne	 SHORT $LN115@hdl_define
$LN118@hdl_define:
  004bf	33 c0		 xor	 eax, eax
  004c1	85 c0		 test	 eax, eax
  004c3	74 19		 je	 SHORT $LN150@hdl_define
  004c5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:s390_dyn_perform_cryptographic_computation
  004cc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196395
  004d3	ba 2c b9 00 00	 mov	 edx, 47404		; 0000b92cH
  004d8	33 c9		 xor	 ecx, ecx
  004da	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN150@hdl_define:
  004de	33 c0		 xor	 eax, eax
  004e0	85 c0		 test	 eax, eax
  004e2	75 db		 jne	 SHORT $LN118@hdl_define
$LN121@hdl_define:
  004e4	33 c0		 xor	 eax, eax
  004e6	83 f8 01	 cmp	 eax, 1
  004e9	74 1c		 je	 SHORT $LN151@hdl_define
  004eb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:z900_dyn_perform_cryptographic_computation
  004f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG196397
  004f9	ba 2c b9 00 00	 mov	 edx, 47404		; 0000b92cH
  004fe	b9 00 00 00 20	 mov	 ecx, 536870912		; 20000000H
  00503	ff 54 24 30	 call	 QWORD PTR defins$[rsp]
$LN151@hdl_define:
  00507	33 c0		 xor	 eax, eax
  00509	85 c0		 test	 eax, eax
  0050b	75 d7		 jne	 SHORT $LN121@hdl_define
  0050d	33 c0		 xor	 eax, eax
  0050f	85 c0		 test	 eax, eax
  00511	75 83		 jne	 SHORT $LN112@hdl_define

; 5126 :   #endif
; 5127 : #endif
; 5128 : }
; 5129 : END_INSTRUCTION_SECTION;

  00513	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00517	c3		 ret	 0
hdl_define_instructs_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 64
hdl_check_depends_ep PROC

; 5068 : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 5069 : {
; 5070 :    HDL_DEPENDENCY(HERCULES);

  00011	41 b8 08 00 00
	00		 mov	 r8d, 8
  00017	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196206
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196207
  00025	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00029	85 c0		 test	 eax, eax
  0002b	74 08		 je	 SHORT $LN11@hdl_check_
  0002d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00035	33 c0		 xor	 eax, eax
  00037	85 c0		 test	 eax, eax
  00039	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 5071 :    HDL_DEPENDENCY(REGS);

  0003b	41 b8 80 60 01
	00		 mov	 r8d, 90240		; 00016080H
  00041	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196209
  00048	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196210
  0004f	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 08		 je	 SHORT $LN12@hdl_check_
  00057	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  0005f	33 c0		 xor	 eax, eax
  00061	85 c0		 test	 eax, eax
  00063	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 5072 : // HDL_DEPENDENCY(DEVBLK);
; 5073 :    HDL_DEPENDENCY(SYSBLK);

  00065	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG196212
  00072	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG196213
  00079	ff 54 24 40	 call	 QWORD PTR depchk$[rsp]
  0007d	85 c0		 test	 eax, eax
  0007f	74 08		 je	 SHORT $LN13@hdl_check_
  00081	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  00089	33 c0		 xor	 eax, eax
  0008b	85 c0		 test	 eax, eax
  0008d	75 d6		 jne	 SHORT $LN10@hdl_check_

; 5074 : // HDL_DEPENDENCY(WEBBLK);
; 5075 : }
; 5076 : END_DEPENDENCY_SECTION;

  0008f	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  00093	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00097	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
msa$ = 48
i$1 = 52
tv299 = 56
tv310 = 60
tv319 = 64
fc$ = 68
tv334 = 72
r2$ = 80
r1$ = 84
query_bits$ = 96
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
z900_dyn_perform_cryptographic_key_management_operation PROC

; 4940 : {

$LN39:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4941 :   int fc;
; 4942 :   int msa;
; 4943 :   BYTE query_bits[][16] =

  00023	c6 44 24 60 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  00078	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000cb	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000d3	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000db	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000e3	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000eb	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000f3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000fb	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00103	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0010b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00113	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0011b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00123	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0012b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00133	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0013b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00143	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0014b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00153	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0015b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00163	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0016b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00173	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0017b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00183	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0018b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00193	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0019b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001a3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001ab	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001b3	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001bb	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001c3	c6 84 24 a0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001cb	c6 84 24 a1 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  001d3	c6 84 24 a2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001db	c6 84 24 a3 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  001e3	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001eb	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001f3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001fb	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00203	c6 84 24 a8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  0020b	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00213	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0021b	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00223	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0022b	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00233	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0023b	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4944 :   {
; 4945 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4946 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4947 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4948 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4949 :     /**/ { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4950 :   };
; 4951 :   int r1;
; 4952 :   int r2;
; 4953 : 
; 4954 :   RRE(inst, regs, r1, r2);

  00243	b8 01 00 00 00	 mov	 eax, 1
  00248	48 6b c0 03	 imul	 rax, rax, 3
  0024c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00254	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00258	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
  0025c	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  00260	83 e0 0f	 and	 eax, 15
  00263	89 44 24 50	 mov	 DWORD PTR r2$[rsp], eax
  00267	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  0026b	c1 f8 04	 sar	 eax, 4
  0026e	83 e0 0f	 and	 eax, 15
  00271	89 44 24 54	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_p:
  00275	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00281	48 83 c0 04	 add	 rax, 4
  00285	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00291	33 c0		 xor	 eax, eax
  00293	83 f8 04	 cmp	 eax, 4
  00296	74 0f		 je	 SHORT $LN10@z900_dyn_p
  00298	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN10@z900_dyn_p:
  002a7	33 c0		 xor	 eax, eax
  002a9	85 c0		 test	 eax, eax
  002ab	75 c8		 jne	 SHORT $LN4@z900_dyn_p

; 4955 :   PER_ZEROADDR_CHECK( regs, 1 );

  002ad	ba 01 00 00 00	 mov	 edx, 1
  002b2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ba	e8 00 00 00 00	 call	 z900_per3_zero_check
$LN7@z900_dyn_p:

; 4956 :   TXF_INSTR_CHECK( regs );

  002bf	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002c7	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  002ce	85 c0		 test	 eax, eax
  002d0	74 40		 je	 SHORT $LN11@z900_dyn_p
  002d2	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002da	8b 80 84 af 00
	00		 mov	 eax, DWORD PTR [rax+44932]
  002e0	0f ba e8 0c	 bts	 eax, 12
  002e4	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ec	89 81 84 af 00
	00		 mov	 DWORD PTR [rcx+44932], eax
  002f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG196173
  002f9	41 b8 0b 00 00
	00		 mov	 r8d, 11
  002ff	ba 02 00 00 00	 mov	 edx, 2
  00304	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_abort_transaction
$LN11@z900_dyn_p:
  00312	33 c0		 xor	 eax, eax
  00314	85 c0		 test	 eax, eax
  00316	75 a7		 jne	 SHORT $LN7@z900_dyn_p

; 4957 : 
; 4958 :   /* The following is the same as doing a FACILITY_CHECK */
; 4959 :   msa = get_msa(regs);

  00318	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00320	e8 00 00 00 00	 call	 get_msa
  00325	89 44 24 30	 mov	 DWORD PTR msa$[rsp], eax

; 4960 :   if(msa < 3)

  00329	83 7c 24 30 03	 cmp	 DWORD PTR msa$[rsp], 3
  0032e	7d 13		 jge	 SHORT $LN12@z900_dyn_p

; 4961 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00330	ba 01 00 00 00	 mov	 edx, 1
  00335	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN12@z900_dyn_p:

; 4962 : 
; 4963 : #ifdef OPTION_PCKMO_DEBUG
; 4964 :   WRMSG(HHC90100, "D", "PCKMO: perform cryptographic key management operation");
; 4965 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4966 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4967 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4968 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4969 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 4970 : 
; 4971 :   /* Privileged operation */
; 4972 :   PRIV_CHECK(regs);

  00343	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034b	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0034f	83 e0 01	 and	 eax, 1
  00352	85 c0		 test	 eax, eax
  00354	74 1b		 je	 SHORT $LN13@z900_dyn_p
  00356	ba 02 00 00 00	 mov	 edx, 2
  0035b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00363	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036b	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN13@z900_dyn_p:

; 4973 : 
; 4974 :   /* Check special conditions */
; 4975 :   if(unlikely(GR0_m(regs)))

  00371	b8 08 00 00 00	 mov	 eax, 8
  00376	48 6b c0 00	 imul	 rax, rax, 0
  0037a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00382	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00389	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0038e	85 c0		 test	 eax, eax
  00390	74 0a		 je	 SHORT $LN28@z900_dyn_p
  00392	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv299[rsp], 1
  0039a	eb 08		 jmp	 SHORT $LN29@z900_dyn_p
$LN28@z900_dyn_p:
  0039c	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv299[rsp], 0
$LN29@z900_dyn_p:
  003a4	83 7c 24 38 00	 cmp	 DWORD PTR tv299[rsp], 0
  003a9	74 0a		 je	 SHORT $LN34@z900_dyn_p
  003ab	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv310[rsp], 1
  003b3	eb 08		 jmp	 SHORT $LN35@z900_dyn_p
$LN34@z900_dyn_p:
  003b5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv310[rsp], 0
$LN35@z900_dyn_p:
  003bd	83 7c 24 3c 00	 cmp	 DWORD PTR tv310[rsp], 0
  003c2	74 13		 je	 SHORT $LN14@z900_dyn_p

; 4976 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003c4	ba 06 00 00 00	 mov	 edx, 6
  003c9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN14@z900_dyn_p:

; 4977 : 
; 4978 :   /* Initialize values */
; 4979 :   fc = GR0_fc(regs);

  003d7	b8 08 00 00 00	 mov	 eax, 8
  003dc	48 6b c0 00	 imul	 rax, rax, 0
  003e0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003ef	83 e0 7f	 and	 eax, 127		; 0000007fH
  003f2	89 44 24 44	 mov	 DWORD PTR fc$[rsp], eax

; 4980 :   switch(fc)

  003f6	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  003fa	89 44 24 40	 mov	 DWORD PTR tv319[rsp], eax
  003fe	83 7c 24 40 14	 cmp	 DWORD PTR tv319[rsp], 20
  00403	0f 87 07 01 00
	00		 ja	 $LN26@z900_dyn_p
  00409	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv319[rsp]
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00415	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN38@z900_dyn_p[rcx+rax*4]
  0041c	48 03 c1	 add	 rax, rcx
  0041f	ff e0		 jmp	 rax
$LN15@z900_dyn_p:

; 4981 :   {
; 4982 :     case 0: /* Query */
; 4983 :     {
; 4984 :       /* Store the parameter block */
; 4985 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00421	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00429	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0042f	83 e0 01	 and	 eax, 1
  00432	85 c0		 test	 eax, eax
  00434	74 20		 je	 SHORT $LN36@z900_dyn_p
  00436	b8 08 00 00 00	 mov	 eax, 8
  0043b	48 6b c0 01	 imul	 rax, rax, 1
  0043f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00447	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0044f	48 89 44 24 48	 mov	 QWORD PTR tv334[rsp], rax
  00454	eb 1d		 jmp	 SHORT $LN37@z900_dyn_p
$LN36@z900_dyn_p:
  00456	b8 08 00 00 00	 mov	 eax, 8
  0045b	48 6b c0 01	 imul	 rax, rax, 1
  0045f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00467	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0046e	48 89 44 24 48	 mov	 QWORD PTR tv334[rsp], rax
$LN37@z900_dyn_p:
  00473	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00482	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv334[rsp]
  00487	48 23 c8	 and	 rcx, rax
  0048a	48 8b c1	 mov	 rax, rcx
  0048d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00492	48 6b c9 10	 imul	 rcx, rcx, 16
  00496	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0049b	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004a3	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  004a8	41 b9 01 00 00
	00		 mov	 r9d, 1
  004ae	4c 8b c0	 mov	 r8, rax
  004b1	b2 0f		 mov	 dl, 15
  004b3	e8 00 00 00 00	 call	 z900_vstorec

; 4986 : 
; 4987 : #ifdef OPTION_PCKMO_DEBUG
; 4988 :       LOGBYTE("output:", query_bits[msa], 16);
; 4989 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 4990 : 
; 4991 :       return;

  004b8	eb 69		 jmp	 SHORT $LN1@z900_dyn_p
$LN16@z900_dyn_p:
$LN17@z900_dyn_p:
$LN18@z900_dyn_p:

; 4992 :     }
; 4993 :     case 1: /* encrypt-dea */
; 4994 :     case 2: /* encrypt-tdea-128 */
; 4995 :     case 3: /* encrypt-tdea-192 */
; 4996 :     {
; 4997 :       if(msa >= 3)

  004ba	83 7c 24 30 03	 cmp	 DWORD PTR msa$[rsp], 3
  004bf	7c 0f		 jl	 SHORT $LN19@z900_dyn_p

; 4998 :         ARCH_DEP(pckmo_dea)(regs);

  004c1	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c9	e8 00 00 00 00	 call	 z900_pckmo_dea
  004ce	eb 13		 jmp	 SHORT $LN20@z900_dyn_p
$LN19@z900_dyn_p:

; 4999 :       else
; 5000 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004d0	ba 06 00 00 00	 mov	 edx, 6
  004d5	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_dyn_p:

; 5001 :       break;

  004e3	eb 3e		 jmp	 SHORT $LN8@z900_dyn_p
$LN21@z900_dyn_p:
$LN22@z900_dyn_p:
$LN23@z900_dyn_p:

; 5002 :     }
; 5003 :     case 18: /* encrypt-aes-128 */
; 5004 :     case 19: /* encrypt-aes-192 */
; 5005 :     case 20: /* encrypt-aes-256 */
; 5006 :     {
; 5007 :       if(msa >= 3)

  004e5	83 7c 24 30 03	 cmp	 DWORD PTR msa$[rsp], 3
  004ea	7c 0f		 jl	 SHORT $LN24@z900_dyn_p

; 5008 :         ARCH_DEP(pckmo_aes)(regs);

  004ec	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f4	e8 00 00 00 00	 call	 z900_pckmo_aes
  004f9	eb 13		 jmp	 SHORT $LN25@z900_dyn_p
$LN24@z900_dyn_p:

; 5009 :       else
; 5010 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004fb	ba 06 00 00 00	 mov	 edx, 6
  00500	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00508	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN25@z900_dyn_p:

; 5011 :       break;

  0050e	eb 13		 jmp	 SHORT $LN8@z900_dyn_p
$LN26@z900_dyn_p:

; 5012 :     }
; 5013 :     default:
; 5014 :     {
; 5015 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00510	ba 06 00 00 00	 mov	 edx, 6
  00515	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN8@z900_dyn_p:
$LN1@z900_dyn_p:

; 5016 :       break;
; 5017 :     }
; 5018 :   }
; 5019 : }

  00523	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0052b	48 33 cc	 xor	 rcx, rsp
  0052e	e8 00 00 00 00	 call	 __security_check_cookie
  00533	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0053a	c3		 ret	 0
  0053b	90		 npad	 1
$LN38@z900_dyn_p:
  0053c	00 00 00 00	 DD	 $LN15@z900_dyn_p
  00540	00 00 00 00	 DD	 $LN16@z900_dyn_p
  00544	00 00 00 00	 DD	 $LN17@z900_dyn_p
  00548	00 00 00 00	 DD	 $LN18@z900_dyn_p
  0054c	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00550	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00554	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00558	00 00 00 00	 DD	 $LN26@z900_dyn_p
  0055c	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00560	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00564	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00568	00 00 00 00	 DD	 $LN26@z900_dyn_p
  0056c	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00570	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00574	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00578	00 00 00 00	 DD	 $LN26@z900_dyn_p
  0057c	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00580	00 00 00 00	 DD	 $LN26@z900_dyn_p
  00584	00 00 00 00	 DD	 $LN21@z900_dyn_p
  00588	00 00 00 00	 DD	 $LN22@z900_dyn_p
  0058c	00 00 00 00	 DD	 $LN23@z900_dyn_p
z900_dyn_perform_cryptographic_key_management_operation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
msa$ = 48
tv84 = 52
tv131 = 56
inst$ = 80
regs$ = 88
z900_dyn_perform_cryptographic_computation PROC

; 4870 : {

$LN37:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4871 :   int msa = get_msa(regs);

  0000e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00013	e8 00 00 00 00	 call	 get_msa
  00018	89 44 24 30	 mov	 DWORD PTR msa$[rsp], eax
$LN4@z900_dyn_p:

; 4872 :   static const BYTE query_bits[][16] =
; 4873 :   {
; 4874 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4875 :   };
; 4876 : 
; 4877 :   UNREFERENCED(inst);              /* This operation has no operands */

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN4@z900_dyn_p
$LN7@z900_dyn_p:

; 4878 :   INST_UPDATE_PSW(regs, 4, 4);        /* All operands implied        */

  00022	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00027	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002b	48 83 c0 04	 add	 rax, 4
  0002f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00034	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00038	33 c0		 xor	 eax, eax
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	74 0c		 je	 SHORT $LN10@z900_dyn_p
  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00044	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN10@z900_dyn_p:
  0004b	33 c0		 xor	 eax, eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 d1		 jne	 SHORT $LN7@z900_dyn_p

; 4879 :   PER_ZEROADDR_CHECK( regs, 1 );

  00051	ba 01 00 00 00	 mov	 edx, 1
  00056	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	e8 00 00 00 00	 call	 z900_per3_zero_check

; 4880 : 
; 4881 :   /* The following is the same as doing a FACILITY_CHECK */
; 4882 :   if(msa < 4)

  00060	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  00065	7d 12		 jge	 SHORT $LN11@z900_dyn_p

; 4883 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00067	ba 01 00 00 00	 mov	 edx, 1
  0006c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
  00077	eb 0f		 jmp	 SHORT $LN12@z900_dyn_p
$LN11@z900_dyn_p:

; 4884 :   else if (msa > 4) msa = 4;

  00079	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  0007e	7e 08		 jle	 SHORT $LN13@z900_dyn_p
  00080	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR msa$[rsp], 4
$LN13@z900_dyn_p:
$LN12@z900_dyn_p:

; 4885 : 
; 4886 : #ifdef OPTION_PCC_DEBUG
; 4887 :   WRMSG(HHC90100, "D", "PCC: perform cryptographic computation");
; 4888 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4889 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4890 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4891 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 4892 : 
; 4893 :   switch(GR0_fc(regs))

  00088	b8 08 00 00 00	 mov	 eax, 8
  0008d	48 6b c0 00	 imul	 rax, rax, 0
  00091	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0009d	83 e0 7f	 and	 eax, 127		; 0000007fH
  000a0	89 44 24 34	 mov	 DWORD PTR tv84[rsp], eax
  000a4	83 7c 24 34 3c	 cmp	 DWORD PTR tv84[rsp], 60	; 0000003cH
  000a9	0f 87 e3 00 00
	00		 ja	 $LN31@z900_dyn_p
  000af	8b 44 24 34	 mov	 eax, DWORD PTR tv84[rsp]
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000ba	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN35@z900_dyn_p[rcx+rax]
  000c2	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN36@z900_dyn_p[rcx+rax*4]
  000c9	48 03 c1	 add	 rax, rcx
  000cc	ff e0		 jmp	 rax
$LN14@z900_dyn_p:

; 4894 :   {
; 4895 :     case 0: /* Query */
; 4896 :       /* Store the parameter block */
; 4897 :       ARCH_DEP(vstorec)(query_bits[msa - 4], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  000ce	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  000d3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d9	83 e0 01	 and	 eax, 1
  000dc	85 c0		 test	 eax, eax
  000de	74 1d		 je	 SHORT $LN33@z900_dyn_p
  000e0	b8 08 00 00 00	 mov	 eax, 8
  000e5	48 6b c0 01	 imul	 rax, rax, 1
  000e9	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  000f6	48 89 44 24 38	 mov	 QWORD PTR tv131[rsp], rax
  000fb	eb 1a		 jmp	 SHORT $LN34@z900_dyn_p
$LN33@z900_dyn_p:
  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 01	 imul	 rax, rax, 1
  00106	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00112	48 89 44 24 38	 mov	 QWORD PTR tv131[rsp], rax
$LN34@z900_dyn_p:
  00117	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0011c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00123	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv131[rsp]
  00128	48 23 c8	 and	 rcx, rax
  0012b	48 8b c1	 mov	 rax, rcx
  0012e	8b 4c 24 30	 mov	 ecx, DWORD PTR msa$[rsp]
  00132	83 e9 04	 sub	 ecx, 4
  00135	48 63 c9	 movsxd	 rcx, ecx
  00138	48 6b c9 10	 imul	 rcx, rcx, 16
  0013c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?query_bits@?1??z900_dyn_perform_cryptographic_computation@@9@9
  00143	48 03 d1	 add	 rdx, rcx
  00146	48 8b ca	 mov	 rcx, rdx
  00149	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  0014e	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00153	41 b9 01 00 00
	00		 mov	 r9d, 1
  00159	4c 8b c0	 mov	 r8, rax
  0015c	b2 0f		 mov	 dl, 15
  0015e	e8 00 00 00 00	 call	 z900_vstorec

; 4898 : 
; 4899 : #ifdef OPTION_PCC_DEBUG
; 4900 :       LOGBYTE("output:", query_bits[msa - 4], 16);
; 4901 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 4902 : 
; 4903 :       /* Set condition code 0 */
; 4904 :       regs->psw.cc = 0;

  00163	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00168	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4905 :       return;

  0016c	eb 34		 jmp	 SHORT $LN1@z900_dyn_p
$LN15@z900_dyn_p:
$LN16@z900_dyn_p:
$LN17@z900_dyn_p:
$LN18@z900_dyn_p:
$LN19@z900_dyn_p:
$LN20@z900_dyn_p:

; 4906 :     case  1: /* dea */
; 4907 :     case  2: /* tdea-128 */
; 4908 :     case  3: /* tdea-192 */
; 4909 :     case  9: /* encrypted dea */
; 4910 :     case 10: /* encrypted tdea-128 */
; 4911 :     case 11: /* encrypted tdea-192 */
; 4912 :       ARCH_DEP(pcc_cmac_dea)(regs);

  0016e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	e8 00 00 00 00	 call	 z900_pcc_cmac_dea

; 4913 :       break;

  00178	eb 28		 jmp	 SHORT $LN8@z900_dyn_p
$LN21@z900_dyn_p:
$LN22@z900_dyn_p:
$LN23@z900_dyn_p:
$LN24@z900_dyn_p:
$LN25@z900_dyn_p:
$LN26@z900_dyn_p:

; 4914 :     case 18: /* aes-128 */
; 4915 :     case 19: /* aes-192 */
; 4916 :     case 20: /* aes-256 */
; 4917 :     case 26: /* encrypted aes-128 */
; 4918 :     case 27: /* encrypted aes-192 */
; 4919 :     case 28: /* encrypted aes-256 */
; 4920 :       ARCH_DEP(pcc_cmac_aes)(regs);

  0017a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0017f	e8 00 00 00 00	 call	 z900_pcc_cmac_aes

; 4921 :       break;

  00184	eb 1c		 jmp	 SHORT $LN8@z900_dyn_p
$LN27@z900_dyn_p:
$LN28@z900_dyn_p:
$LN29@z900_dyn_p:
$LN30@z900_dyn_p:

; 4922 :     case 50: /* aes-128 */
; 4923 :     case 52: /* aes-256 */
; 4924 :     case 58: /* encrypted aes-128 */
; 4925 :     case 60: /* encrypted aes-256 */
; 4926 :       ARCH_DEP(pcc_xts_aes)(regs);

  00186	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0018b	e8 00 00 00 00	 call	 z900_pcc_xts_aes

; 4927 :       break;

  00190	eb 10		 jmp	 SHORT $LN8@z900_dyn_p
$LN31@z900_dyn_p:

; 4928 :     default:
; 4929 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00192	ba 06 00 00 00	 mov	 edx, 6
  00197	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN8@z900_dyn_p:
$LN1@z900_dyn_p:

; 4930 :       break;
; 4931 :   }
; 4932 : }

  001a2	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001a6	c3		 ret	 0
  001a7	90		 npad	 1
$LN36@z900_dyn_p:
  001a8	00 00 00 00	 DD	 $LN14@z900_dyn_p
  001ac	00 00 00 00	 DD	 $LN15@z900_dyn_p
  001b0	00 00 00 00	 DD	 $LN16@z900_dyn_p
  001b4	00 00 00 00	 DD	 $LN17@z900_dyn_p
  001b8	00 00 00 00	 DD	 $LN18@z900_dyn_p
  001bc	00 00 00 00	 DD	 $LN19@z900_dyn_p
  001c0	00 00 00 00	 DD	 $LN20@z900_dyn_p
  001c4	00 00 00 00	 DD	 $LN21@z900_dyn_p
  001c8	00 00 00 00	 DD	 $LN22@z900_dyn_p
  001cc	00 00 00 00	 DD	 $LN23@z900_dyn_p
  001d0	00 00 00 00	 DD	 $LN24@z900_dyn_p
  001d4	00 00 00 00	 DD	 $LN25@z900_dyn_p
  001d8	00 00 00 00	 DD	 $LN26@z900_dyn_p
  001dc	00 00 00 00	 DD	 $LN27@z900_dyn_p
  001e0	00 00 00 00	 DD	 $LN28@z900_dyn_p
  001e4	00 00 00 00	 DD	 $LN29@z900_dyn_p
  001e8	00 00 00 00	 DD	 $LN30@z900_dyn_p
  001ec	00 00 00 00	 DD	 $LN31@z900_dyn_p
$LN35@z900_dyn_p:
  001f0	00		 DB	 0
  001f1	01		 DB	 1
  001f2	02		 DB	 2
  001f3	03		 DB	 3
  001f4	11		 DB	 17
  001f5	11		 DB	 17
  001f6	11		 DB	 17
  001f7	11		 DB	 17
  001f8	11		 DB	 17
  001f9	04		 DB	 4
  001fa	05		 DB	 5
  001fb	06		 DB	 6
  001fc	11		 DB	 17
  001fd	11		 DB	 17
  001fe	11		 DB	 17
  001ff	11		 DB	 17
  00200	11		 DB	 17
  00201	11		 DB	 17
  00202	07		 DB	 7
  00203	08		 DB	 8
  00204	09		 DB	 9
  00205	11		 DB	 17
  00206	11		 DB	 17
  00207	11		 DB	 17
  00208	11		 DB	 17
  00209	11		 DB	 17
  0020a	0a		 DB	 10
  0020b	0b		 DB	 11
  0020c	0c		 DB	 12
  0020d	11		 DB	 17
  0020e	11		 DB	 17
  0020f	11		 DB	 17
  00210	11		 DB	 17
  00211	11		 DB	 17
  00212	11		 DB	 17
  00213	11		 DB	 17
  00214	11		 DB	 17
  00215	11		 DB	 17
  00216	11		 DB	 17
  00217	11		 DB	 17
  00218	11		 DB	 17
  00219	11		 DB	 17
  0021a	11		 DB	 17
  0021b	11		 DB	 17
  0021c	11		 DB	 17
  0021d	11		 DB	 17
  0021e	11		 DB	 17
  0021f	11		 DB	 17
  00220	11		 DB	 17
  00221	11		 DB	 17
  00222	0d		 DB	 13
  00223	11		 DB	 17
  00224	0e		 DB	 14
  00225	11		 DB	 17
  00226	11		 DB	 17
  00227	11		 DB	 17
  00228	11		 DB	 17
  00229	11		 DB	 17
  0022a	0f		 DB	 15
  0022b	11		 DB	 17
  0022c	10		 DB	 16
z900_dyn_perform_cryptographic_computation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv338 = 64
tv347 = 68
tv89 = 72
tv297 = 80
tv313 = 88
tv362 = 96
query_bits$ = 112
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_dyn_cipher_message_with_output_feedback PROC

; 4772 : {

$LN44:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4773 :   int msa;
; 4774 :   BYTE query_bits[][16] =

  00023	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  0007b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  00083	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  0008b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00093	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0009b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  000a3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  000ab	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  000b3	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000bb	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000c3	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000cb	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000d3	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000db	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000e3	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000eb	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000f3	c6 84 24 90 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000fb	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  00103	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  0010b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  00113	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  0011b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  00123	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  0012b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00133	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0013b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00143	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0014b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00153	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0015b	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00163	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0016b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00173	c6 84 24 a0 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+48], 0
  0017b	c6 84 24 a1 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00183	c6 84 24 a2 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0018b	c6 84 24 a3 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00193	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0019b	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  001a3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  001ab	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  001b3	c6 84 24 a8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  001bb	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  001c3	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  001cb	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001d3	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001db	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001e3	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001eb	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001f3	c6 84 24 b0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001fb	c6 84 24 b1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  00203	c6 84 24 b2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  0020b	c6 84 24 b3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  00213	c6 84 24 b4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  0021b	c6 84 24 b5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  00223	c6 84 24 b6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  0022b	c6 84 24 b7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00233	c6 84 24 b8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  0023b	c6 84 24 b9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00243	c6 84 24 ba 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0024b	c6 84 24 bb 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00253	c6 84 24 bc 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0025b	c6 84 24 bd 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00263	c6 84 24 be 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0026b	c6 84 24 bf 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4775 :   {
; 4776 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4777 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4778 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4779 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4780 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4781 :   };
; 4782 :   int r1;
; 4783 :   int r2;
; 4784 : 
; 4785 :   RRE(inst, regs, r1, r2);

  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	48 6b c0 03	 imul	 rax, rax, 3
  0027c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00284	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00288	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0028c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00290	83 e0 0f	 and	 eax, 15
  00293	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00297	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0029b	c1 f8 04	 sar	 eax, 4
  0029e	83 e0 0f	 and	 eax, 15
  002a1	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_c:
  002a5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002b1	48 83 c0 04	 add	 rax, 4
  002b5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  002c1	33 c0		 xor	 eax, eax
  002c3	83 f8 04	 cmp	 eax, 4
  002c6	74 0f		 je	 SHORT $LN7@z900_dyn_c
  002c8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4786 : 
; 4787 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4788 :     if (0
; 4789 :         || GR_A( 1,  regs ) == 0
; 4790 :         || GR_A( r1, regs ) == 0
; 4791 :         || GR_A( r2, regs ) == 0

  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 02 01 00
	00		 jne	 $LN9@z900_dyn_c
  002e7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ef	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002f5	83 e0 01	 and	 eax, 1
  002f8	85 c0		 test	 eax, eax
  002fa	74 20		 je	 SHORT $LN31@z900_dyn_c
  002fc	b8 08 00 00 00	 mov	 eax, 8
  00301	48 6b c0 01	 imul	 rax, rax, 1
  00305	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00315	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
  0031a	eb 1d		 jmp	 SHORT $LN32@z900_dyn_c
$LN31@z900_dyn_c:
  0031c	b8 08 00 00 00	 mov	 eax, 8
  00321	48 6b c0 01	 imul	 rax, rax, 1
  00325	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00334	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
$LN32@z900_dyn_c:
  00339	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv89[rsp], 0
  0033f	0f 84 a4 00 00
	00		 je	 $LN9@z900_dyn_c
  00345	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00353	83 e0 01	 and	 eax, 1
  00356	85 c0		 test	 eax, eax
  00358	74 1c		 je	 SHORT $LN33@z900_dyn_c
  0035a	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0035f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00367	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0036f	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
  00374	eb 19		 jmp	 SHORT $LN34@z900_dyn_c
$LN33@z900_dyn_c:
  00376	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0037b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0038a	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
$LN34@z900_dyn_c:
  0038f	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv297[rsp], 0
  00395	74 52		 je	 SHORT $LN9@z900_dyn_c
  00397	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003a5	83 e0 01	 and	 eax, 1
  003a8	85 c0		 test	 eax, eax
  003aa	74 1c		 je	 SHORT $LN35@z900_dyn_c
  003ac	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003c1	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
  003c6	eb 19		 jmp	 SHORT $LN36@z900_dyn_c
$LN35@z900_dyn_c:
  003c8	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003dc	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
$LN36@z900_dyn_c:
  003e1	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv313[rsp], 0
  003e7	75 0d		 jne	 SHORT $LN8@z900_dyn_c
$LN9@z900_dyn_c:

; 4792 :     )
; 4793 :         ARCH_DEP( per3_zero )( regs );

  003e9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 z900_per3_zero
$LN8@z900_dyn_c:

; 4794 : #endif
; 4795 : 
; 4796 :   /* The following is the same as doing a FACILITY_CHECK */
; 4797 :   msa = get_msa(regs);

  003f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fe	e8 00 00 00 00	 call	 get_msa
  00403	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4798 :   if(msa < 4)

  00407	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0040c	7d 13		 jge	 SHORT $LN10@z900_dyn_c

; 4799 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  0040e	ba 01 00 00 00	 mov	 edx, 1
  00413	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN10@z900_dyn_c:

; 4800 : 
; 4801 : #ifdef OPTION_KMO_DEBUG
; 4802 :   WRMSG(HHC90100, "D", "KMO: cipher message with output feedback");
; 4803 :   WRMSG(HHC90101, "D", 1, r1);
; 4804 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4805 :   WRMSG(HHC90101, "D", 2, r2);
; 4806 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4807 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4808 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4809 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4810 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4811 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 4812 : 
; 4813 :   /* Check special conditions */
; 4814 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  00421	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  00426	74 27		 je	 SHORT $LN37@z900_dyn_c
  00428	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0042c	83 e0 01	 and	 eax, 1
  0042f	85 c0		 test	 eax, eax
  00431	75 1c		 jne	 SHORT $LN37@z900_dyn_c
  00433	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  00438	74 15		 je	 SHORT $LN37@z900_dyn_c
  0043a	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0043e	83 e0 01	 and	 eax, 1
  00441	85 c0		 test	 eax, eax
  00443	75 0a		 jne	 SHORT $LN37@z900_dyn_c
  00445	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
  0044d	eb 08		 jmp	 SHORT $LN40@z900_dyn_c
$LN37@z900_dyn_c:
  0044f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv338[rsp], 1
$LN40@z900_dyn_c:
  00457	83 7c 24 40 00	 cmp	 DWORD PTR tv338[rsp], 0
  0045c	74 13		 je	 SHORT $LN11@z900_dyn_c

; 4815 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0045e	ba 06 00 00 00	 mov	 edx, 6
  00463	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN11@z900_dyn_c:

; 4816 : 
; 4817 :   switch(GR0_fc(regs))

  00471	b8 08 00 00 00	 mov	 eax, 8
  00476	48 6b c0 00	 imul	 rax, rax, 0
  0047a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00482	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00489	83 e0 7f	 and	 eax, 127		; 0000007fH
  0048c	89 44 24 44	 mov	 DWORD PTR tv347[rsp], eax
  00490	83 7c 24 44 1c	 cmp	 DWORD PTR tv347[rsp], 28
  00495	0f 87 22 01 00
	00		 ja	 $LN29@z900_dyn_c
  0049b	8b 44 24 44	 mov	 eax, DWORD PTR tv347[rsp]
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  004a6	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN43@z900_dyn_c[rcx+rax*4]
  004ad	48 03 c1	 add	 rax, rcx
  004b0	ff e0		 jmp	 rax
$LN12@z900_dyn_c:

; 4818 :   {
; 4819 :     case 0: /* Query */
; 4820 :     {
; 4821 :       /* Store the parameter block */
; 4822 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  004b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ba	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004c0	83 e0 01	 and	 eax, 1
  004c3	85 c0		 test	 eax, eax
  004c5	74 20		 je	 SHORT $LN41@z900_dyn_c
  004c7	b8 08 00 00 00	 mov	 eax, 8
  004cc	48 6b c0 01	 imul	 rax, rax, 1
  004d0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d8	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  004e0	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
  004e5	eb 1d		 jmp	 SHORT $LN42@z900_dyn_c
$LN41@z900_dyn_c:
  004e7	b8 08 00 00 00	 mov	 eax, 8
  004ec	48 6b c0 01	 imul	 rax, rax, 1
  004f0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004ff	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
$LN42@z900_dyn_c:
  00504	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00513	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv362[rsp]
  00518	48 23 c8	 and	 rcx, rax
  0051b	48 8b c1	 mov	 rax, rcx
  0051e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00523	48 6b c9 10	 imul	 rcx, rcx, 16
  00527	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0052c	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00534	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00539	41 b9 01 00 00
	00		 mov	 r9d, 1
  0053f	4c 8b c0	 mov	 r8, rax
  00542	b2 0f		 mov	 dl, 15
  00544	e8 00 00 00 00	 call	 z900_vstorec

; 4823 : 
; 4824 : #ifdef OPTION_KMO_DEBUG
; 4825 :       LOGBYTE("output:", query_bits[msa], 16);
; 4826 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 4827 : 
; 4828 :       /* Set condition code 0 */
; 4829 :       regs->psw.cc = 0;

  00549	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00551	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4830 :       return;

  00555	eb 79		 jmp	 SHORT $LN1@z900_dyn_c
$LN13@z900_dyn_c:
$LN14@z900_dyn_c:
$LN15@z900_dyn_c:
$LN16@z900_dyn_c:
$LN17@z900_dyn_c:
$LN18@z900_dyn_c:

; 4831 :     }
; 4832 :     case 1: /* dea */
; 4833 :     case 2: /* tdea-128 */
; 4834 :     case 3: /* tdea-192 */
; 4835 :     case 9: /* encrypted dea */
; 4836 :     case 10: /* encrypted tdea-128 */
; 4837 :     case 11: /* encrypted tdea-192 */
; 4838 :     {
; 4839 :       if(msa >= 4)

  00557	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0055c	7c 17		 jl	 SHORT $LN19@z900_dyn_c

; 4840 :         ARCH_DEP(kmo_dea)(r1, r2, regs);

  0055e	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00566	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0056a	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0056e	e8 00 00 00 00	 call	 z900_kmo_dea
  00573	eb 13		 jmp	 SHORT $LN20@z900_dyn_c
$LN19@z900_dyn_c:

; 4841 :       else
; 4842 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00575	ba 06 00 00 00	 mov	 edx, 6
  0057a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_dyn_c:

; 4843 :       break;

  00588	eb 46		 jmp	 SHORT $LN5@z900_dyn_c
$LN21@z900_dyn_c:
$LN22@z900_dyn_c:
$LN23@z900_dyn_c:
$LN24@z900_dyn_c:
$LN25@z900_dyn_c:
$LN26@z900_dyn_c:

; 4844 :     }
; 4845 :     case 18: /* aes-128 */
; 4846 :     case 19: /* aes-192 */
; 4847 :     case 20: /* aes-256 */
; 4848 :     case 26: /* encrypted aes-128 */
; 4849 :     case 27: /* encrypted aes-192 */
; 4850 :     case 28: /* encrypted aes-256 */
; 4851 :     {
; 4852 :       if(msa >= 4)

  0058a	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0058f	7c 17		 jl	 SHORT $LN27@z900_dyn_c

; 4853 :         ARCH_DEP(kmo_aes)(r1, r2, regs);

  00591	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00599	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0059d	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005a1	e8 00 00 00 00	 call	 z900_kmo_aes
  005a6	eb 13		 jmp	 SHORT $LN28@z900_dyn_c
$LN27@z900_dyn_c:

; 4854 :       else
; 4855 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005a8	ba 06 00 00 00	 mov	 edx, 6
  005ad	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN28@z900_dyn_c:

; 4856 :       break;

  005bb	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN29@z900_dyn_c:

; 4857 :     }
; 4858 :     default:
; 4859 :     {
; 4860 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005bd	ba 06 00 00 00	 mov	 edx, 6
  005c2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4861 :       break;
; 4862 :     }
; 4863 :   }
; 4864 : }

  005d0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005d8	48 33 cc	 xor	 rcx, rsp
  005db	e8 00 00 00 00	 call	 __security_check_cookie
  005e0	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  005e7	c3		 ret	 0
$LN43@z900_dyn_c:
  005e8	00 00 00 00	 DD	 $LN12@z900_dyn_c
  005ec	00 00 00 00	 DD	 $LN13@z900_dyn_c
  005f0	00 00 00 00	 DD	 $LN14@z900_dyn_c
  005f4	00 00 00 00	 DD	 $LN15@z900_dyn_c
  005f8	00 00 00 00	 DD	 $LN29@z900_dyn_c
  005fc	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00600	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00604	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00608	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0060c	00 00 00 00	 DD	 $LN16@z900_dyn_c
  00610	00 00 00 00	 DD	 $LN17@z900_dyn_c
  00614	00 00 00 00	 DD	 $LN18@z900_dyn_c
  00618	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0061c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00620	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00624	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00628	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0062c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00630	00 00 00 00	 DD	 $LN21@z900_dyn_c
  00634	00 00 00 00	 DD	 $LN22@z900_dyn_c
  00638	00 00 00 00	 DD	 $LN23@z900_dyn_c
  0063c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00640	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00644	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00648	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0064c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00650	00 00 00 00	 DD	 $LN24@z900_dyn_c
  00654	00 00 00 00	 DD	 $LN25@z900_dyn_c
  00658	00 00 00 00	 DD	 $LN26@z900_dyn_c
z900_dyn_cipher_message_with_output_feedback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv338 = 64
tv347 = 68
tv89 = 72
tv297 = 80
tv313 = 88
tv362 = 96
query_bits$ = 112
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_dyn_cipher_message_with_cipher_feedback PROC

; 4671 : {

$LN44:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4672 :   int msa;
; 4673 :   BYTE query_bits[][16] =

  00023	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  0007b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  00083	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  0008b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00093	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0009b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  000a3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  000ab	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  000b3	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000bb	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000c3	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000cb	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000d3	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000db	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000e3	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000eb	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000f3	c6 84 24 90 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000fb	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  00103	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  0010b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  00113	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  0011b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  00123	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  0012b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00133	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0013b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00143	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0014b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00153	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0015b	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00163	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0016b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00173	c6 84 24 a0 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+48], 0
  0017b	c6 84 24 a1 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00183	c6 84 24 a2 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0018b	c6 84 24 a3 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00193	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0019b	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  001a3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  001ab	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  001b3	c6 84 24 a8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  001bb	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  001c3	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  001cb	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001d3	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001db	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001e3	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001eb	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001f3	c6 84 24 b0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001fb	c6 84 24 b1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  00203	c6 84 24 b2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  0020b	c6 84 24 b3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  00213	c6 84 24 b4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  0021b	c6 84 24 b5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  00223	c6 84 24 b6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  0022b	c6 84 24 b7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00233	c6 84 24 b8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  0023b	c6 84 24 b9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00243	c6 84 24 ba 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0024b	c6 84 24 bb 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00253	c6 84 24 bc 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0025b	c6 84 24 bd 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00263	c6 84 24 be 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0026b	c6 84 24 bf 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4674 :   {
; 4675 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4676 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4677 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4678 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4679 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4680 :   };
; 4681 :   int r1;
; 4682 :   int r2;
; 4683 : 
; 4684 :   RRE(inst, regs, r1, r2);

  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	48 6b c0 03	 imul	 rax, rax, 3
  0027c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00284	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00288	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0028c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00290	83 e0 0f	 and	 eax, 15
  00293	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00297	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0029b	c1 f8 04	 sar	 eax, 4
  0029e	83 e0 0f	 and	 eax, 15
  002a1	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_c:
  002a5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002b1	48 83 c0 04	 add	 rax, 4
  002b5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  002c1	33 c0		 xor	 eax, eax
  002c3	83 f8 04	 cmp	 eax, 4
  002c6	74 0f		 je	 SHORT $LN7@z900_dyn_c
  002c8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4685 : 
; 4686 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4687 :     if (0
; 4688 :         || GR_A( 1,  regs ) == 0
; 4689 :         || GR_A( r1, regs ) == 0
; 4690 :         || GR_A( r2, regs ) == 0

  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 02 01 00
	00		 jne	 $LN9@z900_dyn_c
  002e7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ef	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002f5	83 e0 01	 and	 eax, 1
  002f8	85 c0		 test	 eax, eax
  002fa	74 20		 je	 SHORT $LN31@z900_dyn_c
  002fc	b8 08 00 00 00	 mov	 eax, 8
  00301	48 6b c0 01	 imul	 rax, rax, 1
  00305	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00315	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
  0031a	eb 1d		 jmp	 SHORT $LN32@z900_dyn_c
$LN31@z900_dyn_c:
  0031c	b8 08 00 00 00	 mov	 eax, 8
  00321	48 6b c0 01	 imul	 rax, rax, 1
  00325	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00334	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
$LN32@z900_dyn_c:
  00339	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv89[rsp], 0
  0033f	0f 84 a4 00 00
	00		 je	 $LN9@z900_dyn_c
  00345	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00353	83 e0 01	 and	 eax, 1
  00356	85 c0		 test	 eax, eax
  00358	74 1c		 je	 SHORT $LN33@z900_dyn_c
  0035a	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0035f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00367	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0036f	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
  00374	eb 19		 jmp	 SHORT $LN34@z900_dyn_c
$LN33@z900_dyn_c:
  00376	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0037b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0038a	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
$LN34@z900_dyn_c:
  0038f	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv297[rsp], 0
  00395	74 52		 je	 SHORT $LN9@z900_dyn_c
  00397	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003a5	83 e0 01	 and	 eax, 1
  003a8	85 c0		 test	 eax, eax
  003aa	74 1c		 je	 SHORT $LN35@z900_dyn_c
  003ac	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003c1	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
  003c6	eb 19		 jmp	 SHORT $LN36@z900_dyn_c
$LN35@z900_dyn_c:
  003c8	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003dc	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
$LN36@z900_dyn_c:
  003e1	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv313[rsp], 0
  003e7	75 0d		 jne	 SHORT $LN8@z900_dyn_c
$LN9@z900_dyn_c:

; 4691 :     )
; 4692 :         ARCH_DEP( per3_zero )( regs );

  003e9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 z900_per3_zero
$LN8@z900_dyn_c:

; 4693 : #endif
; 4694 : 
; 4695 :   /* The following is the same as doing a FACILITY_CHECK */
; 4696 :   msa = get_msa(regs);

  003f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fe	e8 00 00 00 00	 call	 get_msa
  00403	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4697 :   if(msa < 4)

  00407	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0040c	7d 13		 jge	 SHORT $LN10@z900_dyn_c

; 4698 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  0040e	ba 01 00 00 00	 mov	 edx, 1
  00413	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN10@z900_dyn_c:

; 4699 : 
; 4700 : #ifdef OPTION_KMF_DEBUG
; 4701 :   WRMSG(HHC90100, "D", "KMF: cipher message with cipher feedback");
; 4702 :   WRMSG(HHC90101, "D", 1, r1);
; 4703 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4704 :   WRMSG(HHC90101, "D", 2, r2);
; 4705 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4706 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4707 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4708 :   WRMSG(HHC90112, "D", GR0_lcfb(regs));
; 4709 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4710 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4711 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4712 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 4713 : 
; 4714 :   /* Check special conditions */
; 4715 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  00421	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  00426	74 27		 je	 SHORT $LN37@z900_dyn_c
  00428	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0042c	83 e0 01	 and	 eax, 1
  0042f	85 c0		 test	 eax, eax
  00431	75 1c		 jne	 SHORT $LN37@z900_dyn_c
  00433	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  00438	74 15		 je	 SHORT $LN37@z900_dyn_c
  0043a	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0043e	83 e0 01	 and	 eax, 1
  00441	85 c0		 test	 eax, eax
  00443	75 0a		 jne	 SHORT $LN37@z900_dyn_c
  00445	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
  0044d	eb 08		 jmp	 SHORT $LN40@z900_dyn_c
$LN37@z900_dyn_c:
  0044f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv338[rsp], 1
$LN40@z900_dyn_c:
  00457	83 7c 24 40 00	 cmp	 DWORD PTR tv338[rsp], 0
  0045c	74 13		 je	 SHORT $LN11@z900_dyn_c

; 4716 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0045e	ba 06 00 00 00	 mov	 edx, 6
  00463	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN11@z900_dyn_c:

; 4717 : 
; 4718 :   switch(GR0_fc(regs))

  00471	b8 08 00 00 00	 mov	 eax, 8
  00476	48 6b c0 00	 imul	 rax, rax, 0
  0047a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00482	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00489	83 e0 7f	 and	 eax, 127		; 0000007fH
  0048c	89 44 24 44	 mov	 DWORD PTR tv347[rsp], eax
  00490	83 7c 24 44 1c	 cmp	 DWORD PTR tv347[rsp], 28
  00495	0f 87 22 01 00
	00		 ja	 $LN29@z900_dyn_c
  0049b	8b 44 24 44	 mov	 eax, DWORD PTR tv347[rsp]
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  004a6	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN43@z900_dyn_c[rcx+rax*4]
  004ad	48 03 c1	 add	 rax, rcx
  004b0	ff e0		 jmp	 rax
$LN12@z900_dyn_c:

; 4719 :   {
; 4720 :     case 0: /* Query */
; 4721 :     {
; 4722 :       /* Store the parameter block */
; 4723 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  004b2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ba	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004c0	83 e0 01	 and	 eax, 1
  004c3	85 c0		 test	 eax, eax
  004c5	74 20		 je	 SHORT $LN41@z900_dyn_c
  004c7	b8 08 00 00 00	 mov	 eax, 8
  004cc	48 6b c0 01	 imul	 rax, rax, 1
  004d0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d8	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  004e0	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
  004e5	eb 1d		 jmp	 SHORT $LN42@z900_dyn_c
$LN41@z900_dyn_c:
  004e7	b8 08 00 00 00	 mov	 eax, 8
  004ec	48 6b c0 01	 imul	 rax, rax, 1
  004f0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004ff	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
$LN42@z900_dyn_c:
  00504	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00513	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv362[rsp]
  00518	48 23 c8	 and	 rcx, rax
  0051b	48 8b c1	 mov	 rax, rcx
  0051e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00523	48 6b c9 10	 imul	 rcx, rcx, 16
  00527	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0052c	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00534	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00539	41 b9 01 00 00
	00		 mov	 r9d, 1
  0053f	4c 8b c0	 mov	 r8, rax
  00542	b2 0f		 mov	 dl, 15
  00544	e8 00 00 00 00	 call	 z900_vstorec

; 4724 : 
; 4725 : #ifdef OPTION_KMF_DEBUG
; 4726 :       LOGBYTE("output:", query_bits[msa], 16);
; 4727 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 4728 : 
; 4729 :       /* Set condition code 0 */
; 4730 :       regs->psw.cc = 0;

  00549	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00551	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4731 :       return;

  00555	eb 79		 jmp	 SHORT $LN1@z900_dyn_c
$LN13@z900_dyn_c:
$LN14@z900_dyn_c:
$LN15@z900_dyn_c:
$LN16@z900_dyn_c:
$LN17@z900_dyn_c:
$LN18@z900_dyn_c:

; 4732 :     }
; 4733 : 
; 4734 :     case 1: /* dea */
; 4735 :     case 2: /* tdea-128 */
; 4736 :     case 3: /* tdea-192 */
; 4737 :     case 9: /* encrypted dea */
; 4738 :     case 10: /* encrypted tdea-128 */
; 4739 :     case 11: /* encrypted tdea-192 */
; 4740 :     {
; 4741 :       if(msa >= 4)

  00557	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0055c	7c 17		 jl	 SHORT $LN19@z900_dyn_c

; 4742 :         ARCH_DEP(kmf_dea)(r1, r2, regs);

  0055e	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00566	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0056a	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0056e	e8 00 00 00 00	 call	 z900_kmf_dea
  00573	eb 13		 jmp	 SHORT $LN20@z900_dyn_c
$LN19@z900_dyn_c:

; 4743 :       else
; 4744 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00575	ba 06 00 00 00	 mov	 edx, 6
  0057a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00582	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_dyn_c:

; 4745 :       break;

  00588	eb 46		 jmp	 SHORT $LN5@z900_dyn_c
$LN21@z900_dyn_c:
$LN22@z900_dyn_c:
$LN23@z900_dyn_c:
$LN24@z900_dyn_c:
$LN25@z900_dyn_c:
$LN26@z900_dyn_c:

; 4746 :     }
; 4747 :     case 18: /* aes-128 */
; 4748 :     case 19: /* aes-192 */
; 4749 :     case 20: /* aes-256 */
; 4750 :     case 26: /* encrypted aes-128 */
; 4751 :     case 27: /* encrypted aes-192 */
; 4752 :     case 28: /* encrypted aes-256 */
; 4753 :     {
; 4754 :       if(msa >= 4)

  0058a	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0058f	7c 17		 jl	 SHORT $LN27@z900_dyn_c

; 4755 :         ARCH_DEP(kmf_aes)(r1, r2, regs);

  00591	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00599	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0059d	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005a1	e8 00 00 00 00	 call	 z900_kmf_aes
  005a6	eb 13		 jmp	 SHORT $LN28@z900_dyn_c
$LN27@z900_dyn_c:

; 4756 :       else
; 4757 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005a8	ba 06 00 00 00	 mov	 edx, 6
  005ad	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN28@z900_dyn_c:

; 4758 :       break;

  005bb	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN29@z900_dyn_c:

; 4759 :     }
; 4760 :     default:
; 4761 :     {
; 4762 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005bd	ba 06 00 00 00	 mov	 edx, 6
  005c2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4763 :       break;
; 4764 :     }
; 4765 :   }
; 4766 : }

  005d0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005d8	48 33 cc	 xor	 rcx, rsp
  005db	e8 00 00 00 00	 call	 __security_check_cookie
  005e0	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  005e7	c3		 ret	 0
$LN43@z900_dyn_c:
  005e8	00 00 00 00	 DD	 $LN12@z900_dyn_c
  005ec	00 00 00 00	 DD	 $LN13@z900_dyn_c
  005f0	00 00 00 00	 DD	 $LN14@z900_dyn_c
  005f4	00 00 00 00	 DD	 $LN15@z900_dyn_c
  005f8	00 00 00 00	 DD	 $LN29@z900_dyn_c
  005fc	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00600	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00604	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00608	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0060c	00 00 00 00	 DD	 $LN16@z900_dyn_c
  00610	00 00 00 00	 DD	 $LN17@z900_dyn_c
  00614	00 00 00 00	 DD	 $LN18@z900_dyn_c
  00618	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0061c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00620	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00624	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00628	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0062c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00630	00 00 00 00	 DD	 $LN21@z900_dyn_c
  00634	00 00 00 00	 DD	 $LN22@z900_dyn_c
  00638	00 00 00 00	 DD	 $LN23@z900_dyn_c
  0063c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00640	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00644	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00648	00 00 00 00	 DD	 $LN29@z900_dyn_c
  0064c	00 00 00 00	 DD	 $LN29@z900_dyn_c
  00650	00 00 00 00	 DD	 $LN24@z900_dyn_c
  00654	00 00 00 00	 DD	 $LN25@z900_dyn_c
  00658	00 00 00 00	 DD	 $LN26@z900_dyn_c
z900_dyn_cipher_message_with_cipher_feedback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r3$ = 52
r1$ = 56
msa$ = 60
temp$1 = 64
tv310 = 68
tv319 = 72
tv334 = 80
query_bits$ = 96
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
z900_dyn_cipher_message_with_counter PROC

; 4576 : {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4577 :   int msa;
; 4578 :   BYTE query_bits[][16] =

  00023	c6 44 24 60 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  00078	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000cb	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000d3	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000db	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000e3	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000eb	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000f3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000fb	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00103	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0010b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00113	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0011b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00123	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0012b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00133	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0013b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00143	c6 84 24 90 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+48], 0
  0014b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00153	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0015b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00163	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0016b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00173	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0017b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00183	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0018b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00193	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0019b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001a3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001ab	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001b3	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001bb	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001c3	c6 84 24 a0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001cb	c6 84 24 a1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001d3	c6 84 24 a2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001db	c6 84 24 a3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001e3	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001eb	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001f3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001fb	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00203	c6 84 24 a8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  0020b	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00213	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0021b	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00223	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0022b	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00233	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0023b	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4579 :   {
; 4580 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4581 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4582 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4583 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4584 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4585 :   };
; 4586 :   int r1;
; 4587 :   int r2;
; 4588 :   int r3;
; 4589 : 
; 4590 :   RRF_M(inst, regs, r1, r2, r3);

  00243	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0024b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00250	8b c8		 mov	 ecx, eax
  00252	e8 00 00 00 00	 call	 _byteswap_ulong
  00257	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  0025b	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0025f	83 e0 0f	 and	 eax, 15
  00262	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00266	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0026a	c1 e8 04	 shr	 eax, 4
  0026d	83 e0 0f	 and	 eax, 15
  00270	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
  00274	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00278	c1 e8 0c	 shr	 eax, 12
  0027b	83 e0 0f	 and	 eax, 15
  0027e	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
$LN4@z900_dyn_c:
  00282	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0028e	48 83 c0 04	 add	 rax, 4
  00292	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0029e	33 c0		 xor	 eax, eax
  002a0	83 f8 04	 cmp	 eax, 4
  002a3	74 0f		 je	 SHORT $LN7@z900_dyn_c
  002a5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002b4	33 c0		 xor	 eax, eax
  002b6	85 c0		 test	 eax, eax
  002b8	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4591 :   PER_ZEROADDR_CHECK( regs, 1 );

  002ba	ba 01 00 00 00	 mov	 edx, 1
  002bf	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c7	e8 00 00 00 00	 call	 z900_per3_zero_check

; 4592 :   PER_ZEROADDR_CHECK2( regs, r1, r3 );

  002cc	44 8b 44 24 34	 mov	 r8d, DWORD PTR r3$[rsp]
  002d1	8b 54 24 38	 mov	 edx, DWORD PTR r1$[rsp]
  002d5	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002dd	e8 00 00 00 00	 call	 z900_per3_zero_check2

; 4593 :   PER_ZEROADDR_LCHECK( regs, r2, r2+1 );

  002e2	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002e6	ff c0		 inc	 eax
  002e8	44 8b c0	 mov	 r8d, eax
  002eb	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  002ef	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	e8 00 00 00 00	 call	 z900_per3_zero_lcheck

; 4594 : 
; 4595 :   /* The following is the same as doing a FACILITY_CHECK */
; 4596 :   msa = get_msa(regs);

  002fc	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00304	e8 00 00 00 00	 call	 get_msa
  00309	89 44 24 3c	 mov	 DWORD PTR msa$[rsp], eax

; 4597 :   if(msa < 4)

  0030d	83 7c 24 3c 04	 cmp	 DWORD PTR msa$[rsp], 4
  00312	7d 13		 jge	 SHORT $LN8@z900_dyn_c

; 4598 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00314	ba 01 00 00 00	 mov	 edx, 1
  00319	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN8@z900_dyn_c:

; 4599 : 
; 4600 : #ifdef OPTION_KMCTR_DEBUG
; 4601 :   WRMSG(HHC90100, "D", "KMCTR: cipher message with counter");
; 4602 :   WRMSG(HHC90101, "D", 1, r1);
; 4603 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4604 :   WRMSG(HHC90101, "D", 2, r2);
; 4605 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4606 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4607 :   WRMSG(HHC90101, "D", 3, r3);
; 4608 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4609 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4610 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4611 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 4612 : 
; 4613 :   /* Check special conditions */
; 4614 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01 || !r3 || r3 & 0x01))

  00327	83 7c 24 38 00	 cmp	 DWORD PTR r1$[rsp], 0
  0032c	74 39		 je	 SHORT $LN29@z900_dyn_c
  0032e	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  00332	83 e0 01	 and	 eax, 1
  00335	85 c0		 test	 eax, eax
  00337	75 2e		 jne	 SHORT $LN29@z900_dyn_c
  00339	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  0033e	74 27		 je	 SHORT $LN29@z900_dyn_c
  00340	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  00344	83 e0 01	 and	 eax, 1
  00347	85 c0		 test	 eax, eax
  00349	75 1c		 jne	 SHORT $LN29@z900_dyn_c
  0034b	83 7c 24 34 00	 cmp	 DWORD PTR r3$[rsp], 0
  00350	74 15		 je	 SHORT $LN29@z900_dyn_c
  00352	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  00356	83 e0 01	 and	 eax, 1
  00359	85 c0		 test	 eax, eax
  0035b	75 0a		 jne	 SHORT $LN29@z900_dyn_c
  0035d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv310[rsp], 0
  00365	eb 08		 jmp	 SHORT $LN32@z900_dyn_c
$LN29@z900_dyn_c:
  00367	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv310[rsp], 1
$LN32@z900_dyn_c:
  0036f	83 7c 24 44 00	 cmp	 DWORD PTR tv310[rsp], 0
  00374	74 13		 je	 SHORT $LN9@z900_dyn_c

; 4615 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00376	ba 06 00 00 00	 mov	 edx, 6
  0037b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN9@z900_dyn_c:

; 4616 : 
; 4617 :   switch(GR0_fc(regs))

  00389	b8 08 00 00 00	 mov	 eax, 8
  0038e	48 6b c0 00	 imul	 rax, rax, 0
  00392	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003a1	83 e0 7f	 and	 eax, 127		; 0000007fH
  003a4	89 44 24 48	 mov	 DWORD PTR tv319[rsp], eax
  003a8	83 7c 24 48 1c	 cmp	 DWORD PTR tv319[rsp], 28
  003ad	0f 87 2f 01 00
	00		 ja	 $LN27@z900_dyn_c
  003b3	8b 44 24 48	 mov	 eax, DWORD PTR tv319[rsp]
  003b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  003be	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN35@z900_dyn_c[rcx+rax*4]
  003c5	48 03 c1	 add	 rax, rcx
  003c8	ff e0		 jmp	 rax
$LN10@z900_dyn_c:

; 4618 :   {
; 4619 :     case 0: /* Query */
; 4620 :     {
; 4621 :       /* Store the parameter block */
; 4622 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  003ca	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003d2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003d8	83 e0 01	 and	 eax, 1
  003db	85 c0		 test	 eax, eax
  003dd	74 20		 je	 SHORT $LN33@z900_dyn_c
  003df	b8 08 00 00 00	 mov	 eax, 8
  003e4	48 6b c0 01	 imul	 rax, rax, 1
  003e8	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f0	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  003f8	48 89 44 24 50	 mov	 QWORD PTR tv334[rsp], rax
  003fd	eb 1d		 jmp	 SHORT $LN34@z900_dyn_c
$LN33@z900_dyn_c:
  003ff	b8 08 00 00 00	 mov	 eax, 8
  00404	48 6b c0 01	 imul	 rax, rax, 1
  00408	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00410	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00417	48 89 44 24 50	 mov	 QWORD PTR tv334[rsp], rax
$LN34@z900_dyn_c:
  0041c	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00424	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0042b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv334[rsp]
  00430	48 23 c8	 and	 rcx, rax
  00433	48 8b c1	 mov	 rax, rcx
  00436	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0043b	48 6b c9 10	 imul	 rcx, rcx, 16
  0043f	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00444	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0044c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00451	41 b9 01 00 00
	00		 mov	 r9d, 1
  00457	4c 8b c0	 mov	 r8, rax
  0045a	b2 0f		 mov	 dl, 15
  0045c	e8 00 00 00 00	 call	 z900_vstorec

; 4623 : 
; 4624 : #ifdef OPTION_KMCTR_DEBUG
; 4625 :       LOGBYTE("output:", query_bits[msa], 16);
; 4626 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 4627 : 
; 4628 :       /* Set condition code 0 */
; 4629 :       regs->psw.cc = 0;

  00461	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00469	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4630 :       return;

  0046d	e9 83 00 00 00	 jmp	 $LN1@z900_dyn_c
$LN11@z900_dyn_c:
$LN12@z900_dyn_c:
$LN13@z900_dyn_c:
$LN14@z900_dyn_c:
$LN15@z900_dyn_c:
$LN16@z900_dyn_c:

; 4631 :     }
; 4632 : 
; 4633 :     case 1: /* dea */
; 4634 :     case 2: /* tdea-128 */
; 4635 :     case 3: /* tdea-192 */
; 4636 :     case 9: /* encrypted dea */
; 4637 :     case 10: /* encrypted tdea-128 */
; 4638 :     case 11: /* encrypted tdea-192 */
; 4639 :     {
; 4640 :       if(msa >= 4)

  00472	83 7c 24 3c 04	 cmp	 DWORD PTR msa$[rsp], 4
  00477	7c 1c		 jl	 SHORT $LN17@z900_dyn_c

; 4641 :         ARCH_DEP(kmctr_dea)(r1, r2, r3, regs);

  00479	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00481	44 8b 44 24 34	 mov	 r8d, DWORD PTR r3$[rsp]
  00486	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0048a	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  0048e	e8 00 00 00 00	 call	 z900_kmctr_dea
  00493	eb 13		 jmp	 SHORT $LN18@z900_dyn_c
$LN17@z900_dyn_c:

; 4642 :       else
; 4643 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00495	ba 06 00 00 00	 mov	 edx, 6
  0049a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN18@z900_dyn_c:

; 4644 :       break;

  004a8	eb 4b		 jmp	 SHORT $LN5@z900_dyn_c
$LN19@z900_dyn_c:
$LN20@z900_dyn_c:
$LN21@z900_dyn_c:
$LN22@z900_dyn_c:
$LN23@z900_dyn_c:
$LN24@z900_dyn_c:

; 4645 :     }
; 4646 :     case 18: /* aes-128 */
; 4647 :     case 19: /* aes-192 */
; 4648 :     case 20: /* aes-256 */
; 4649 :     case 26: /* encrypted aes-128 */
; 4650 :     case 27: /* encrypted aes-192 */
; 4651 :     case 28: /* encrypted aes-256 */
; 4652 :     {
; 4653 :       if(msa >= 4)

  004aa	83 7c 24 3c 04	 cmp	 DWORD PTR msa$[rsp], 4
  004af	7c 1c		 jl	 SHORT $LN25@z900_dyn_c

; 4654 :         ARCH_DEP(kmctr_aes)(r1, r2, r3, regs);

  004b1	4c 8b 8c 24 d8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  004b9	44 8b 44 24 34	 mov	 r8d, DWORD PTR r3$[rsp]
  004be	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  004c2	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  004c6	e8 00 00 00 00	 call	 z900_kmctr_aes
  004cb	eb 13		 jmp	 SHORT $LN26@z900_dyn_c
$LN25@z900_dyn_c:

; 4655 :       else
; 4656 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004cd	ba 06 00 00 00	 mov	 edx, 6
  004d2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN26@z900_dyn_c:

; 4657 :       break;

  004e0	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN27@z900_dyn_c:

; 4658 :     }
; 4659 :     default:
; 4660 :     {
; 4661 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004e2	ba 06 00 00 00	 mov	 edx, 6
  004e7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4662 :       break;
; 4663 :     }
; 4664 :   }
; 4665 : }

  004f5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004fd	48 33 cc	 xor	 rcx, rsp
  00500	e8 00 00 00 00	 call	 __security_check_cookie
  00505	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0050c	c3		 ret	 0
  0050d	0f 1f 00	 npad	 3
$LN35@z900_dyn_c:
  00510	00 00 00 00	 DD	 $LN10@z900_dyn_c
  00514	00 00 00 00	 DD	 $LN11@z900_dyn_c
  00518	00 00 00 00	 DD	 $LN12@z900_dyn_c
  0051c	00 00 00 00	 DD	 $LN13@z900_dyn_c
  00520	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00524	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00528	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0052c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00530	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00534	00 00 00 00	 DD	 $LN14@z900_dyn_c
  00538	00 00 00 00	 DD	 $LN15@z900_dyn_c
  0053c	00 00 00 00	 DD	 $LN16@z900_dyn_c
  00540	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00544	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00548	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0054c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00550	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00554	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00558	00 00 00 00	 DD	 $LN19@z900_dyn_c
  0055c	00 00 00 00	 DD	 $LN20@z900_dyn_c
  00560	00 00 00 00	 DD	 $LN21@z900_dyn_c
  00564	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00568	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0056c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00570	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00574	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00578	00 00 00 00	 DD	 $LN22@z900_dyn_c
  0057c	00 00 00 00	 DD	 $LN23@z900_dyn_c
  00580	00 00 00 00	 DD	 $LN24@z900_dyn_c
z900_dyn_cipher_message_with_counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv338 = 64
tv347 = 68
tv89 = 72
tv297 = 80
tv313 = 88
tv362 = 96
query_bits$ = 112
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_dyn_cipher_message_with_chaining PROC

; 4434 : {

$LN52:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4435 :   int msa;
; 4436 :   BYTE query_bits[][16] =

  00023	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  0007b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  00083	c6 84 24 82 00
	00 00 20	 mov	 BYTE PTR query_bits$[rsp+18], 32 ; 00000020H
  0008b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00093	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0009b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  000a3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  000ab	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  000b3	c6 84 24 88 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+24], 16
  000bb	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000c3	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000cb	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000d3	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000db	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000e3	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000eb	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000f3	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000fb	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  00103	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+34], 56 ; 00000038H
  0010b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  00113	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  0011b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  00123	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  0012b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00133	c6 84 24 98 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+40], 16
  0013b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00143	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0014b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00153	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0015b	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00163	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0016b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00173	c6 84 24 a0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0017b	c6 84 24 a1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00183	c6 84 24 a2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0018b	c6 84 24 a3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+51], 56 ; 00000038H
  00193	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0019b	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  001a3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  001ab	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  001b3	c6 84 24 a8 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+56], 16
  001bb	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  001c3	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  001cb	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001d3	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001db	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001e3	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001eb	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001f3	c6 84 24 b0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001fb	c6 84 24 b1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  00203	c6 84 24 b2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  0020b	c6 84 24 b3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  00213	c6 84 24 b4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  0021b	c6 84 24 b5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  00223	c6 84 24 b6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  0022b	c6 84 24 b7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00233	c6 84 24 b8 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+72], 16
  0023b	c6 84 24 b9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00243	c6 84 24 ba 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0024b	c6 84 24 bb 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00253	c6 84 24 bc 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0025b	c6 84 24 bd 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00263	c6 84 24 be 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0026b	c6 84 24 bf 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4437 :   {
; 4438 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4439 :     { 0xf0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4440 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4441 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4442 :     /**/ { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4443 :   };
; 4444 :   int r1;
; 4445 :   int r2;
; 4446 : 
; 4447 :   RRE(inst, regs, r1, r2);

  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	48 6b c0 03	 imul	 rax, rax, 3
  0027c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00284	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00288	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0028c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00290	83 e0 0f	 and	 eax, 15
  00293	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00297	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0029b	c1 f8 04	 sar	 eax, 4
  0029e	83 e0 0f	 and	 eax, 15
  002a1	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_c:
  002a5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002b1	48 83 c0 04	 add	 rax, 4
  002b5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  002c1	33 c0		 xor	 eax, eax
  002c3	83 f8 04	 cmp	 eax, 4
  002c6	74 0f		 je	 SHORT $LN7@z900_dyn_c
  002c8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4448 : 
; 4449 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4450 :     if (0
; 4451 :         || GR_A( 1,  regs ) == 0
; 4452 :         || GR_A( r1, regs ) == 0
; 4453 :         || GR_A( r2, regs ) == 0

  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 02 01 00
	00		 jne	 $LN9@z900_dyn_c
  002e7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ef	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002f5	83 e0 01	 and	 eax, 1
  002f8	85 c0		 test	 eax, eax
  002fa	74 20		 je	 SHORT $LN38@z900_dyn_c
  002fc	b8 08 00 00 00	 mov	 eax, 8
  00301	48 6b c0 01	 imul	 rax, rax, 1
  00305	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00315	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
  0031a	eb 1d		 jmp	 SHORT $LN39@z900_dyn_c
$LN38@z900_dyn_c:
  0031c	b8 08 00 00 00	 mov	 eax, 8
  00321	48 6b c0 01	 imul	 rax, rax, 1
  00325	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00334	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
$LN39@z900_dyn_c:
  00339	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv89[rsp], 0
  0033f	0f 84 a4 00 00
	00		 je	 $LN9@z900_dyn_c
  00345	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00353	83 e0 01	 and	 eax, 1
  00356	85 c0		 test	 eax, eax
  00358	74 1c		 je	 SHORT $LN40@z900_dyn_c
  0035a	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0035f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00367	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0036f	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
  00374	eb 19		 jmp	 SHORT $LN41@z900_dyn_c
$LN40@z900_dyn_c:
  00376	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0037b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0038a	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
$LN41@z900_dyn_c:
  0038f	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv297[rsp], 0
  00395	74 52		 je	 SHORT $LN9@z900_dyn_c
  00397	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003a5	83 e0 01	 and	 eax, 1
  003a8	85 c0		 test	 eax, eax
  003aa	74 1c		 je	 SHORT $LN42@z900_dyn_c
  003ac	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003c1	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
  003c6	eb 19		 jmp	 SHORT $LN43@z900_dyn_c
$LN42@z900_dyn_c:
  003c8	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003dc	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
$LN43@z900_dyn_c:
  003e1	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv313[rsp], 0
  003e7	75 0d		 jne	 SHORT $LN8@z900_dyn_c
$LN9@z900_dyn_c:

; 4454 :     )
; 4455 :         ARCH_DEP( per3_zero )( regs );

  003e9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 z900_per3_zero
$LN8@z900_dyn_c:

; 4456 : #endif
; 4457 : 
; 4458 :   /* The following is the same as doing a FACILITY_CHECK */
; 4459 :   msa = get_msa(regs);

  003f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fe	e8 00 00 00 00	 call	 get_msa
  00403	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4460 :   if(msa < 0)

  00407	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  0040c	7d 13		 jge	 SHORT $LN10@z900_dyn_c

; 4461 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  0040e	ba 01 00 00 00	 mov	 edx, 1
  00413	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN10@z900_dyn_c:

; 4462 : 
; 4463 : #ifdef OPTION_KMC_DEBUG
; 4464 :   WRMSG(HHC90100, "D", "KMC: cipher message with chaining");
; 4465 :   WRMSG(HHC90101, "D", 1, r1);
; 4466 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4467 :   WRMSG(HHC90101, "D", 2, r2);
; 4468 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4469 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4470 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4471 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4472 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4473 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4474 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 4475 : 
; 4476 :   /* Check special conditions */
; 4477 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  00421	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  00426	74 27		 je	 SHORT $LN44@z900_dyn_c
  00428	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0042c	83 e0 01	 and	 eax, 1
  0042f	85 c0		 test	 eax, eax
  00431	75 1c		 jne	 SHORT $LN44@z900_dyn_c
  00433	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  00438	74 15		 je	 SHORT $LN44@z900_dyn_c
  0043a	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0043e	83 e0 01	 and	 eax, 1
  00441	85 c0		 test	 eax, eax
  00443	75 0a		 jne	 SHORT $LN44@z900_dyn_c
  00445	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
  0044d	eb 08		 jmp	 SHORT $LN47@z900_dyn_c
$LN44@z900_dyn_c:
  0044f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv338[rsp], 1
$LN47@z900_dyn_c:
  00457	83 7c 24 40 00	 cmp	 DWORD PTR tv338[rsp], 0
  0045c	74 13		 je	 SHORT $LN11@z900_dyn_c

; 4478 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0045e	ba 06 00 00 00	 mov	 edx, 6
  00463	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN11@z900_dyn_c:

; 4479 : 
; 4480 :   switch(GR0_fc(regs))

  00471	b8 08 00 00 00	 mov	 eax, 8
  00476	48 6b c0 00	 imul	 rax, rax, 0
  0047a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00482	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00489	83 e0 7f	 and	 eax, 127		; 0000007fH
  0048c	89 44 24 44	 mov	 DWORD PTR tv347[rsp], eax
  00490	83 7c 24 44 43	 cmp	 DWORD PTR tv347[rsp], 67 ; 00000043H
  00495	0f 87 e6 01 00
	00		 ja	 $LN36@z900_dyn_c
  0049b	8b 44 24 44	 mov	 eax, DWORD PTR tv347[rsp]
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  004a6	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN50@z900_dyn_c[rcx+rax]
  004ae	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN51@z900_dyn_c[rcx+rax*4]
  004b5	48 03 c1	 add	 rax, rcx
  004b8	ff e0		 jmp	 rax
$LN12@z900_dyn_c:

; 4481 :   {
; 4482 :     case 0: /* Query */
; 4483 :     {
; 4484 :       /* Store the parameter block */
; 4485 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  004ba	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004c8	83 e0 01	 and	 eax, 1
  004cb	85 c0		 test	 eax, eax
  004cd	74 20		 je	 SHORT $LN48@z900_dyn_c
  004cf	b8 08 00 00 00	 mov	 eax, 8
  004d4	48 6b c0 01	 imul	 rax, rax, 1
  004d8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e0	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  004e8	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
  004ed	eb 1d		 jmp	 SHORT $LN49@z900_dyn_c
$LN48@z900_dyn_c:
  004ef	b8 08 00 00 00	 mov	 eax, 8
  004f4	48 6b c0 01	 imul	 rax, rax, 1
  004f8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00500	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00507	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
$LN49@z900_dyn_c:
  0050c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00514	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0051b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv362[rsp]
  00520	48 23 c8	 and	 rcx, rax
  00523	48 8b c1	 mov	 rax, rcx
  00526	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0052b	48 6b c9 10	 imul	 rcx, rcx, 16
  0052f	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00534	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0053c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00541	41 b9 01 00 00
	00		 mov	 r9d, 1
  00547	4c 8b c0	 mov	 r8, rax
  0054a	b2 0f		 mov	 dl, 15
  0054c	e8 00 00 00 00	 call	 z900_vstorec

; 4486 : 
; 4487 : #ifdef OPTION_KMC_DEBUG
; 4488 :       LOGBYTE("output:", query_bits[msa], 16);
; 4489 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 4490 : 
; 4491 :       /* Set condition code 0 */
; 4492 :       regs->psw.cc = 0;

  00551	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00559	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4493 :       return;

  0055d	e9 32 01 00 00	 jmp	 $LN1@z900_dyn_c
$LN13@z900_dyn_c:
$LN14@z900_dyn_c:
$LN15@z900_dyn_c:

; 4494 :     }
; 4495 :     case 1: /* dea */
; 4496 :     case 2: /* tdea-128 */
; 4497 :     case 3: /* tdea-192 */
; 4498 :     {
; 4499 :       ARCH_DEP(kmc_dea)(r1, r2, regs);

  00562	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0056a	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0056e	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00572	e8 00 00 00 00	 call	 z900_kmc_dea

; 4500 :       break;

  00577	e9 18 01 00 00	 jmp	 $LN5@z900_dyn_c
$LN16@z900_dyn_c:
$LN17@z900_dyn_c:
$LN18@z900_dyn_c:

; 4501 :     }
; 4502 : 
; 4503 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4504 :     case 9: /* encrypted dea */
; 4505 :     case 10: /* encrypted tdea-128 */
; 4506 :     case 11: /* encrypted tdea-192 */
; 4507 :     {
; 4508 :       if(msa >= 3)

  0057c	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  00581	7c 17		 jl	 SHORT $LN19@z900_dyn_c

; 4509 :         ARCH_DEP(kmc_dea)(r1, r2, regs);

  00583	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0058b	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0058f	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00593	e8 00 00 00 00	 call	 z900_kmc_dea
  00598	eb 13		 jmp	 SHORT $LN20@z900_dyn_c
$LN19@z900_dyn_c:

; 4510 :       else
; 4511 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0059a	ba 06 00 00 00	 mov	 edx, 6
  0059f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_dyn_c:

; 4512 :       break;

  005ad	e9 e2 00 00 00	 jmp	 $LN5@z900_dyn_c
$LN21@z900_dyn_c:

; 4513 :     }
; 4514 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4515 : 
; 4516 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4517 :     case 18: /* aes-128 */
; 4518 :     {
; 4519 :       if(msa >= 1)

  005b2	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  005b7	7c 17		 jl	 SHORT $LN22@z900_dyn_c

; 4520 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  005b9	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005c1	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  005c5	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005c9	e8 00 00 00 00	 call	 z900_kmc_aes
  005ce	eb 13		 jmp	 SHORT $LN23@z900_dyn_c
$LN22@z900_dyn_c:

; 4521 :       else
; 4522 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005d0	ba 06 00 00 00	 mov	 edx, 6
  005d5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN23@z900_dyn_c:

; 4523 :       break;

  005e3	e9 ac 00 00 00	 jmp	 $LN5@z900_dyn_c
$LN24@z900_dyn_c:
$LN25@z900_dyn_c:

; 4524 :     }
; 4525 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4526 : 
; 4527 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4528 :     case 19: /* aes-192 */
; 4529 :     case 20: /* aes-256 */
; 4530 :     {
; 4531 :       if(msa >= 2)

  005e8	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  005ed	7c 17		 jl	 SHORT $LN26@z900_dyn_c

; 4532 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  005ef	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005f7	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  005fb	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005ff	e8 00 00 00 00	 call	 z900_kmc_aes
  00604	eb 13		 jmp	 SHORT $LN27@z900_dyn_c
$LN26@z900_dyn_c:

; 4533 :       else
; 4534 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00606	ba 06 00 00 00	 mov	 edx, 6
  0060b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00613	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN27@z900_dyn_c:

; 4535 :       break;

  00619	eb 79		 jmp	 SHORT $LN5@z900_dyn_c
$LN28@z900_dyn_c:
$LN29@z900_dyn_c:
$LN30@z900_dyn_c:

; 4536 :     }
; 4537 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4538 : 
; 4539 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4540 :     case 26: /* encrypted aes-128 */
; 4541 :     case 27: /* encrypted aes-192 */
; 4542 :     case 28: /* encrypted aes-256 */
; 4543 :     {
; 4544 :       if(msa >= 3)

  0061b	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  00620	7c 17		 jl	 SHORT $LN31@z900_dyn_c

; 4545 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  00622	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0062a	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0062e	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00632	e8 00 00 00 00	 call	 z900_kmc_aes
  00637	eb 13		 jmp	 SHORT $LN32@z900_dyn_c
$LN31@z900_dyn_c:

; 4546 :       else
; 4547 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00639	ba 06 00 00 00	 mov	 edx, 6
  0063e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00646	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN32@z900_dyn_c:

; 4548 :       break;

  0064c	eb 46		 jmp	 SHORT $LN5@z900_dyn_c
$LN33@z900_dyn_c:

; 4549 :     }
; 4550 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4551 : 
; 4552 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4553 :     case 67: /* prng */
; 4554 :     {
; 4555 :       if(msa >= 1)

  0064e	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  00653	7c 17		 jl	 SHORT $LN34@z900_dyn_c

; 4556 :         ARCH_DEP(kmc_prng)(r1, r2, regs);

  00655	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0065d	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00661	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00665	e8 00 00 00 00	 call	 z900_kmc_prng
  0066a	eb 13		 jmp	 SHORT $LN35@z900_dyn_c
$LN34@z900_dyn_c:

; 4557 :       else
; 4558 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0066c	ba 06 00 00 00	 mov	 edx, 6
  00671	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00679	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN35@z900_dyn_c:

; 4559 :       break;

  0067f	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN36@z900_dyn_c:

; 4560 :     }
; 4561 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4562 : 
; 4563 :     default:
; 4564 :     {
; 4565 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00681	ba 06 00 00 00	 mov	 edx, 6
  00686	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4566 :       break;
; 4567 :     }
; 4568 :   }
; 4569 : }

  00694	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0069c	48 33 cc	 xor	 rcx, rsp
  0069f	e8 00 00 00 00	 call	 __security_check_cookie
  006a4	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006ab	c3		 ret	 0
$LN51@z900_dyn_c:
  006ac	00 00 00 00	 DD	 $LN12@z900_dyn_c
  006b0	00 00 00 00	 DD	 $LN13@z900_dyn_c
  006b4	00 00 00 00	 DD	 $LN14@z900_dyn_c
  006b8	00 00 00 00	 DD	 $LN15@z900_dyn_c
  006bc	00 00 00 00	 DD	 $LN16@z900_dyn_c
  006c0	00 00 00 00	 DD	 $LN17@z900_dyn_c
  006c4	00 00 00 00	 DD	 $LN18@z900_dyn_c
  006c8	00 00 00 00	 DD	 $LN21@z900_dyn_c
  006cc	00 00 00 00	 DD	 $LN24@z900_dyn_c
  006d0	00 00 00 00	 DD	 $LN25@z900_dyn_c
  006d4	00 00 00 00	 DD	 $LN28@z900_dyn_c
  006d8	00 00 00 00	 DD	 $LN29@z900_dyn_c
  006dc	00 00 00 00	 DD	 $LN30@z900_dyn_c
  006e0	00 00 00 00	 DD	 $LN33@z900_dyn_c
  006e4	00 00 00 00	 DD	 $LN36@z900_dyn_c
$LN50@z900_dyn_c:
  006e8	00		 DB	 0
  006e9	01		 DB	 1
  006ea	02		 DB	 2
  006eb	03		 DB	 3
  006ec	0e		 DB	 14
  006ed	0e		 DB	 14
  006ee	0e		 DB	 14
  006ef	0e		 DB	 14
  006f0	0e		 DB	 14
  006f1	04		 DB	 4
  006f2	05		 DB	 5
  006f3	06		 DB	 6
  006f4	0e		 DB	 14
  006f5	0e		 DB	 14
  006f6	0e		 DB	 14
  006f7	0e		 DB	 14
  006f8	0e		 DB	 14
  006f9	0e		 DB	 14
  006fa	07		 DB	 7
  006fb	08		 DB	 8
  006fc	09		 DB	 9
  006fd	0e		 DB	 14
  006fe	0e		 DB	 14
  006ff	0e		 DB	 14
  00700	0e		 DB	 14
  00701	0e		 DB	 14
  00702	0a		 DB	 10
  00703	0b		 DB	 11
  00704	0c		 DB	 12
  00705	0e		 DB	 14
  00706	0e		 DB	 14
  00707	0e		 DB	 14
  00708	0e		 DB	 14
  00709	0e		 DB	 14
  0070a	0e		 DB	 14
  0070b	0e		 DB	 14
  0070c	0e		 DB	 14
  0070d	0e		 DB	 14
  0070e	0e		 DB	 14
  0070f	0e		 DB	 14
  00710	0e		 DB	 14
  00711	0e		 DB	 14
  00712	0e		 DB	 14
  00713	0e		 DB	 14
  00714	0e		 DB	 14
  00715	0e		 DB	 14
  00716	0e		 DB	 14
  00717	0e		 DB	 14
  00718	0e		 DB	 14
  00719	0e		 DB	 14
  0071a	0e		 DB	 14
  0071b	0e		 DB	 14
  0071c	0e		 DB	 14
  0071d	0e		 DB	 14
  0071e	0e		 DB	 14
  0071f	0e		 DB	 14
  00720	0e		 DB	 14
  00721	0e		 DB	 14
  00722	0e		 DB	 14
  00723	0e		 DB	 14
  00724	0e		 DB	 14
  00725	0e		 DB	 14
  00726	0e		 DB	 14
  00727	0e		 DB	 14
  00728	0e		 DB	 14
  00729	0e		 DB	 14
  0072a	0e		 DB	 14
  0072b	0d		 DB	 13
z900_dyn_cipher_message_with_chaining ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
msa$ = 52
r1$ = 56
i$1 = 60
tv93 = 64
tv299 = 68
tv308 = 72
tv323 = 80
query_bits$ = 96
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
z900_dyn_compute_message_authentication_code PROC

; 4334 : {

$LN40:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4335 :   int msa;
; 4336 :   BYTE query_bits[][16] =

  00023	c6 44 24 60 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  00078	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000cb	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000d3	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000db	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000e3	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000eb	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000f3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000fb	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00103	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0010b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00113	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0011b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00123	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0012b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00133	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0013b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00143	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0014b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00153	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0015b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00163	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0016b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00173	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0017b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00183	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0018b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00193	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0019b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001a3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001ab	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001b3	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001bb	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001c3	c6 84 24 a0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001cb	c6 84 24 a1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001d3	c6 84 24 a2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001db	c6 84 24 a3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001e3	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001eb	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001f3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001fb	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00203	c6 84 24 a8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  0020b	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00213	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0021b	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00223	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0022b	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00233	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0023b	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4337 :   {
; 4338 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4339 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4340 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4341 :     { 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4342 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4343 :   };
; 4344 :   int r1;
; 4345 :   int r2;
; 4346 : 
; 4347 :   RRE(inst, regs, r1, r2);

  00243	b8 01 00 00 00	 mov	 eax, 1
  00248	48 6b c0 03	 imul	 rax, rax, 3
  0024c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00254	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00258	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0025c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00260	83 e0 0f	 and	 eax, 15
  00263	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00267	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0026b	c1 f8 04	 sar	 eax, 4
  0026e	83 e0 0f	 and	 eax, 15
  00271	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_c:
  00275	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00281	48 83 c0 04	 add	 rax, 4
  00285	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00291	33 c0		 xor	 eax, eax
  00293	83 f8 04	 cmp	 eax, 4
  00296	74 0f		 je	 SHORT $LN7@z900_dyn_c
  00298	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002a7	33 c0		 xor	 eax, eax
  002a9	85 c0		 test	 eax, eax
  002ab	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4348 :   PER_ZEROADDR_CHECK2( regs, 1, r2 );

  002ad	44 8b 44 24 30	 mov	 r8d, DWORD PTR r2$[rsp]
  002b2	ba 01 00 00 00	 mov	 edx, 1
  002b7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	e8 00 00 00 00	 call	 z900_per3_zero_check2

; 4349 : 
; 4350 :   /* The following is the same as doing a FACILITY_CHECK */
; 4351 :   msa = get_msa(regs);

  002c4	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	e8 00 00 00 00	 call	 get_msa
  002d1	89 44 24 34	 mov	 DWORD PTR msa$[rsp], eax

; 4352 :   if(msa < 0)

  002d5	83 7c 24 34 00	 cmp	 DWORD PTR msa$[rsp], 0
  002da	7d 13		 jge	 SHORT $LN8@z900_dyn_c

; 4353 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  002dc	ba 01 00 00 00	 mov	 edx, 1
  002e1	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN8@z900_dyn_c:

; 4354 : 
; 4355 : #ifdef OPTION_KMAC_DEBUG
; 4356 :   WRMSG(HHC90100, "D", "KMAC: compute message authentication code");
; 4357 :   WRMSG(HHC90101, "D", 2, r2);
; 4358 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4359 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4360 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4361 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4362 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4363 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4364 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 4365 : 
; 4366 :   /* Check special conditions */
; 4367 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002ef	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002f4	74 4f		 je	 SHORT $LN29@z900_dyn_c
  002f6	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002fa	83 e0 01	 and	 eax, 1
  002fd	85 c0		 test	 eax, eax
  002ff	75 44		 jne	 SHORT $LN29@z900_dyn_c
  00301	b8 08 00 00 00	 mov	 eax, 8
  00306	48 6b c0 00	 imul	 rax, rax, 0
  0030a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00312	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00319	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0031e	85 c0		 test	 eax, eax
  00320	74 0a		 je	 SHORT $LN30@z900_dyn_c
  00322	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  0032a	eb 08		 jmp	 SHORT $LN31@z900_dyn_c
$LN30@z900_dyn_c:
  0032c	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN31@z900_dyn_c:
  00334	83 7c 24 40 00	 cmp	 DWORD PTR tv93[rsp], 0
  00339	75 0a		 jne	 SHORT $LN29@z900_dyn_c
  0033b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv299[rsp], 0
  00343	eb 08		 jmp	 SHORT $LN36@z900_dyn_c
$LN29@z900_dyn_c:
  00345	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv299[rsp], 1
$LN36@z900_dyn_c:
  0034d	83 7c 24 44 00	 cmp	 DWORD PTR tv299[rsp], 0
  00352	74 13		 je	 SHORT $LN9@z900_dyn_c

; 4368 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00354	ba 06 00 00 00	 mov	 edx, 6
  00359	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN9@z900_dyn_c:

; 4369 : 
; 4370 :   switch(GR0_fc(regs))

  00367	b8 08 00 00 00	 mov	 eax, 8
  0036c	48 6b c0 00	 imul	 rax, rax, 0
  00370	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0037f	83 e0 7f	 and	 eax, 127		; 0000007fH
  00382	89 44 24 48	 mov	 DWORD PTR tv308[rsp], eax
  00386	83 7c 24 48 1c	 cmp	 DWORD PTR tv308[rsp], 28
  0038b	0f 87 3c 01 00
	00		 ja	 $LN27@z900_dyn_c
  00391	8b 44 24 48	 mov	 eax, DWORD PTR tv308[rsp]
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0039c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN39@z900_dyn_c[rcx+rax*4]
  003a3	48 03 c1	 add	 rax, rcx
  003a6	ff e0		 jmp	 rax
$LN10@z900_dyn_c:

; 4371 :   {
; 4372 :     case 0: /* Query */
; 4373 :     {
; 4374 :       /* Store the parameter block */
; 4375 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  003a8	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003b6	83 e0 01	 and	 eax, 1
  003b9	85 c0		 test	 eax, eax
  003bb	74 20		 je	 SHORT $LN37@z900_dyn_c
  003bd	b8 08 00 00 00	 mov	 eax, 8
  003c2	48 6b c0 01	 imul	 rax, rax, 1
  003c6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ce	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  003d6	48 89 44 24 50	 mov	 QWORD PTR tv323[rsp], rax
  003db	eb 1d		 jmp	 SHORT $LN38@z900_dyn_c
$LN37@z900_dyn_c:
  003dd	b8 08 00 00 00	 mov	 eax, 8
  003e2	48 6b c0 01	 imul	 rax, rax, 1
  003e6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003f5	48 89 44 24 50	 mov	 QWORD PTR tv323[rsp], rax
$LN38@z900_dyn_c:
  003fa	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00402	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00409	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv323[rsp]
  0040e	48 23 c8	 and	 rcx, rax
  00411	48 8b c1	 mov	 rax, rcx
  00414	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00419	48 6b c9 10	 imul	 rcx, rcx, 16
  0041d	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00422	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0042a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0042f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00435	4c 8b c0	 mov	 r8, rax
  00438	b2 0f		 mov	 dl, 15
  0043a	e8 00 00 00 00	 call	 z900_vstorec

; 4376 : 
; 4377 : #ifdef OPTION_KMAC_DEBUG
; 4378 :       LOGBYTE("output:", query_bits[msa], 16);
; 4379 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 4380 : 
; 4381 :       /* Set condition code 0 */
; 4382 :       regs->psw.cc = 0;

  0043f	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00447	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4383 :       return;

  0044b	e9 90 00 00 00	 jmp	 $LN1@z900_dyn_c
$LN11@z900_dyn_c:
$LN12@z900_dyn_c:
$LN13@z900_dyn_c:

; 4384 :     }
; 4385 :     case 1: /* dea */
; 4386 :     case 2: /* tdea-128 */
; 4387 :     case 3: /* tdea-192 */
; 4388 :     {
; 4389 :       ARCH_DEP(kmac_dea)(r1, r2, regs);

  00450	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00458	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0045c	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  00460	e8 00 00 00 00	 call	 z900_kmac_dea

; 4390 :       break;

  00465	eb 79		 jmp	 SHORT $LN5@z900_dyn_c
$LN14@z900_dyn_c:
$LN15@z900_dyn_c:
$LN16@z900_dyn_c:

; 4391 :     }
; 4392 : 
; 4393 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4394 :     case 9: /* encrypted dea */
; 4395 :     case 10: /* encrypted tdea-128 */
; 4396 :     case 11: /* encrypted tdea-192 */
; 4397 :     {
; 4398 :       if(msa >= 3)

  00467	83 7c 24 34 03	 cmp	 DWORD PTR msa$[rsp], 3
  0046c	7c 17		 jl	 SHORT $LN17@z900_dyn_c

; 4399 :         ARCH_DEP(kmac_dea)(r1, r2, regs);

  0046e	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00476	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0047a	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  0047e	e8 00 00 00 00	 call	 z900_kmac_dea
  00483	eb 13		 jmp	 SHORT $LN18@z900_dyn_c
$LN17@z900_dyn_c:

; 4400 :       else
; 4401 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00485	ba 06 00 00 00	 mov	 edx, 6
  0048a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00492	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN18@z900_dyn_c:

; 4402 :       break;

  00498	eb 46		 jmp	 SHORT $LN5@z900_dyn_c
$LN19@z900_dyn_c:
$LN20@z900_dyn_c:
$LN21@z900_dyn_c:
$LN22@z900_dyn_c:
$LN23@z900_dyn_c:
$LN24@z900_dyn_c:

; 4403 :     }
; 4404 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4405 : 
; 4406 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4407 :     case 18: /* aes */
; 4408 :     case 19: /* aes-192 */
; 4409 :     case 20: /* aes-256 */
; 4410 :     case 26: /* encrypted aes */
; 4411 :     case 27: /* encrypted aes-192 */
; 4412 :     case 28: /* encrypted aes-256 */
; 4413 :     {
; 4414 :       if(msa >= 4)

  0049a	83 7c 24 34 04	 cmp	 DWORD PTR msa$[rsp], 4
  0049f	7c 17		 jl	 SHORT $LN25@z900_dyn_c

; 4415 :         ARCH_DEP(kmac_aes)(r1, r2, regs);

  004a1	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004a9	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  004ad	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  004b1	e8 00 00 00 00	 call	 z900_kmac_aes
  004b6	eb 13		 jmp	 SHORT $LN26@z900_dyn_c
$LN25@z900_dyn_c:

; 4416 :       else
; 4417 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004b8	ba 06 00 00 00	 mov	 edx, 6
  004bd	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN26@z900_dyn_c:

; 4418 :       break;

  004cb	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN27@z900_dyn_c:

; 4419 :     }
; 4420 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4421 : 
; 4422 :     default:
; 4423 :     {
; 4424 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004cd	ba 06 00 00 00	 mov	 edx, 6
  004d2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4425 :       break;
; 4426 :     }
; 4427 :   }
; 4428 : }

  004e0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004e8	48 33 cc	 xor	 rcx, rsp
  004eb	e8 00 00 00 00	 call	 __security_check_cookie
  004f0	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004f7	c3		 ret	 0
$LN39@z900_dyn_c:
  004f8	00 00 00 00	 DD	 $LN10@z900_dyn_c
  004fc	00 00 00 00	 DD	 $LN11@z900_dyn_c
  00500	00 00 00 00	 DD	 $LN12@z900_dyn_c
  00504	00 00 00 00	 DD	 $LN13@z900_dyn_c
  00508	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0050c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00510	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00514	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00518	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0051c	00 00 00 00	 DD	 $LN14@z900_dyn_c
  00520	00 00 00 00	 DD	 $LN15@z900_dyn_c
  00524	00 00 00 00	 DD	 $LN16@z900_dyn_c
  00528	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0052c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00530	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00534	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00538	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0053c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00540	00 00 00 00	 DD	 $LN19@z900_dyn_c
  00544	00 00 00 00	 DD	 $LN20@z900_dyn_c
  00548	00 00 00 00	 DD	 $LN21@z900_dyn_c
  0054c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00550	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00554	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00558	00 00 00 00	 DD	 $LN27@z900_dyn_c
  0055c	00 00 00 00	 DD	 $LN27@z900_dyn_c
  00560	00 00 00 00	 DD	 $LN22@z900_dyn_c
  00564	00 00 00 00	 DD	 $LN23@z900_dyn_c
  00568	00 00 00 00	 DD	 $LN24@z900_dyn_c
z900_dyn_compute_message_authentication_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv338 = 64
tv347 = 68
tv89 = 72
tv297 = 80
tv313 = 88
tv362 = 96
query_bits$ = 112
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_dyn_cipher_message PROC

; 4190 : {

$LN55:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4191 :   int msa;
; 4192 :   BYTE query_bits[][16] =

  00023	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  0007b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  00083	c6 84 24 82 00
	00 00 20	 mov	 BYTE PTR query_bits$[rsp+18], 32 ; 00000020H
  0008b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00093	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0009b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  000a3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  000ab	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  000b3	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000bb	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000c3	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000cb	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000d3	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000db	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000e3	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000eb	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000f3	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000fb	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  00103	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+34], 56 ; 00000038H
  0010b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  00113	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  0011b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  00123	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  0012b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00133	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0013b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00143	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0014b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00153	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0015b	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00163	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0016b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00173	c6 84 24 a0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0017b	c6 84 24 a1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00183	c6 84 24 a2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0018b	c6 84 24 a3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+51], 56 ; 00000038H
  00193	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0019b	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  001a3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  001ab	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  001b3	c6 84 24 a8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  001bb	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  001c3	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  001cb	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001d3	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001db	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001e3	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001eb	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001f3	c6 84 24 b0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001fb	c6 84 24 b1 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  00203	c6 84 24 b2 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  0020b	c6 84 24 b3 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  00213	c6 84 24 b4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  0021b	c6 84 24 b5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  00223	c6 84 24 b6 00
	00 00 28	 mov	 BYTE PTR query_bits$[rsp+70], 40 ; 00000028H
  0022b	c6 84 24 b7 00
	00 00 28	 mov	 BYTE PTR query_bits$[rsp+71], 40 ; 00000028H
  00233	c6 84 24 b8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  0023b	c6 84 24 b9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00243	c6 84 24 ba 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0024b	c6 84 24 bb 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00253	c6 84 24 bc 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0025b	c6 84 24 bd 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00263	c6 84 24 be 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0026b	c6 84 24 bf 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4193 :   {
; 4194 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4195 :     { 0xf0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4196 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4197 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4198 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4199 :   };
; 4200 :   int r1;
; 4201 :   int r2;
; 4202 : 
; 4203 :   RRE(inst, regs, r1, r2);

  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	48 6b c0 03	 imul	 rax, rax, 3
  0027c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00284	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00288	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0028c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00290	83 e0 0f	 and	 eax, 15
  00293	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00297	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0029b	c1 f8 04	 sar	 eax, 4
  0029e	83 e0 0f	 and	 eax, 15
  002a1	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_c:
  002a5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002b1	48 83 c0 04	 add	 rax, 4
  002b5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  002c1	33 c0		 xor	 eax, eax
  002c3	83 f8 04	 cmp	 eax, 4
  002c6	74 0f		 je	 SHORT $LN7@z900_dyn_c
  002c8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4204 : 
; 4205 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4206 :     if (0
; 4207 :         || GR_A( 1,  regs ) == 0
; 4208 :         || GR_A( r1, regs ) == 0
; 4209 :         || GR_A( r2, regs ) == 0

  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 02 01 00
	00		 jne	 $LN9@z900_dyn_c
  002e7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ef	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002f5	83 e0 01	 and	 eax, 1
  002f8	85 c0		 test	 eax, eax
  002fa	74 20		 je	 SHORT $LN41@z900_dyn_c
  002fc	b8 08 00 00 00	 mov	 eax, 8
  00301	48 6b c0 01	 imul	 rax, rax, 1
  00305	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00315	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
  0031a	eb 1d		 jmp	 SHORT $LN42@z900_dyn_c
$LN41@z900_dyn_c:
  0031c	b8 08 00 00 00	 mov	 eax, 8
  00321	48 6b c0 01	 imul	 rax, rax, 1
  00325	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00334	48 89 44 24 48	 mov	 QWORD PTR tv89[rsp], rax
$LN42@z900_dyn_c:
  00339	48 83 7c 24 48
	00		 cmp	 QWORD PTR tv89[rsp], 0
  0033f	0f 84 a4 00 00
	00		 je	 $LN9@z900_dyn_c
  00345	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00353	83 e0 01	 and	 eax, 1
  00356	85 c0		 test	 eax, eax
  00358	74 1c		 je	 SHORT $LN43@z900_dyn_c
  0035a	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0035f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00367	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0036f	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
  00374	eb 19		 jmp	 SHORT $LN44@z900_dyn_c
$LN43@z900_dyn_c:
  00376	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0037b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0038a	48 89 44 24 50	 mov	 QWORD PTR tv297[rsp], rax
$LN44@z900_dyn_c:
  0038f	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv297[rsp], 0
  00395	74 52		 je	 SHORT $LN9@z900_dyn_c
  00397	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003a5	83 e0 01	 and	 eax, 1
  003a8	85 c0		 test	 eax, eax
  003aa	74 1c		 je	 SHORT $LN45@z900_dyn_c
  003ac	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003c1	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
  003c6	eb 19		 jmp	 SHORT $LN46@z900_dyn_c
$LN45@z900_dyn_c:
  003c8	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003dc	48 89 44 24 58	 mov	 QWORD PTR tv313[rsp], rax
$LN46@z900_dyn_c:
  003e1	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv313[rsp], 0
  003e7	75 0d		 jne	 SHORT $LN8@z900_dyn_c
$LN9@z900_dyn_c:

; 4210 :     )
; 4211 :         ARCH_DEP( per3_zero )( regs );

  003e9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 z900_per3_zero
$LN8@z900_dyn_c:

; 4212 : #endif
; 4213 : 
; 4214 :   /* The following is the same as doing a FACILITY_CHECK */
; 4215 :   msa = get_msa(regs);

  003f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fe	e8 00 00 00 00	 call	 get_msa
  00403	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4216 :   if(msa < 0)

  00407	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  0040c	7d 13		 jge	 SHORT $LN10@z900_dyn_c

; 4217 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  0040e	ba 01 00 00 00	 mov	 edx, 1
  00413	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN10@z900_dyn_c:

; 4218 : 
; 4219 : #ifdef OPTION_KM_DEBUG
; 4220 :   WRMSG(HHC90100, "D", "KM: cipher message");
; 4221 :   WRMSG(HHC90101, "D", 1, r1);
; 4222 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4223 :   WRMSG(HHC90101, "D", 2, r2);
; 4224 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4225 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4226 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4227 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4228 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4229 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4230 : #endif /* #ifdef OPTION_KM_DEBUG */
; 4231 : 
; 4232 :   /* Check special conditions */
; 4233 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  00421	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  00426	74 27		 je	 SHORT $LN47@z900_dyn_c
  00428	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  0042c	83 e0 01	 and	 eax, 1
  0042f	85 c0		 test	 eax, eax
  00431	75 1c		 jne	 SHORT $LN47@z900_dyn_c
  00433	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  00438	74 15		 je	 SHORT $LN47@z900_dyn_c
  0043a	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0043e	83 e0 01	 and	 eax, 1
  00441	85 c0		 test	 eax, eax
  00443	75 0a		 jne	 SHORT $LN47@z900_dyn_c
  00445	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv338[rsp], 0
  0044d	eb 08		 jmp	 SHORT $LN50@z900_dyn_c
$LN47@z900_dyn_c:
  0044f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv338[rsp], 1
$LN50@z900_dyn_c:
  00457	83 7c 24 40 00	 cmp	 DWORD PTR tv338[rsp], 0
  0045c	74 13		 je	 SHORT $LN11@z900_dyn_c

; 4234 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0045e	ba 06 00 00 00	 mov	 edx, 6
  00463	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN11@z900_dyn_c:

; 4235 : 
; 4236 :   switch(GR0_fc(regs))

  00471	b8 08 00 00 00	 mov	 eax, 8
  00476	48 6b c0 00	 imul	 rax, rax, 0
  0047a	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00482	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00489	83 e0 7f	 and	 eax, 127		; 0000007fH
  0048c	89 44 24 44	 mov	 DWORD PTR tv347[rsp], eax
  00490	83 7c 24 44 3c	 cmp	 DWORD PTR tv347[rsp], 60 ; 0000003cH
  00495	0f 87 e6 01 00
	00		 ja	 $LN39@z900_dyn_c
  0049b	8b 44 24 44	 mov	 eax, DWORD PTR tv347[rsp]
  0049f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  004a6	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN53@z900_dyn_c[rcx+rax]
  004ae	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN54@z900_dyn_c[rcx+rax*4]
  004b5	48 03 c1	 add	 rax, rcx
  004b8	ff e0		 jmp	 rax
$LN12@z900_dyn_c:

; 4237 :   {
; 4238 :     case 0: /* Query */
; 4239 :     {
; 4240 :       /* Store the parameter block */
; 4241 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  004ba	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004c8	83 e0 01	 and	 eax, 1
  004cb	85 c0		 test	 eax, eax
  004cd	74 20		 je	 SHORT $LN51@z900_dyn_c
  004cf	b8 08 00 00 00	 mov	 eax, 8
  004d4	48 6b c0 01	 imul	 rax, rax, 1
  004d8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e0	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  004e8	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
  004ed	eb 1d		 jmp	 SHORT $LN52@z900_dyn_c
$LN51@z900_dyn_c:
  004ef	b8 08 00 00 00	 mov	 eax, 8
  004f4	48 6b c0 01	 imul	 rax, rax, 1
  004f8	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00500	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00507	48 89 44 24 60	 mov	 QWORD PTR tv362[rsp], rax
$LN52@z900_dyn_c:
  0050c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00514	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0051b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv362[rsp]
  00520	48 23 c8	 and	 rcx, rax
  00523	48 8b c1	 mov	 rax, rcx
  00526	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0052b	48 6b c9 10	 imul	 rcx, rcx, 16
  0052f	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00534	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0053c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00541	41 b9 01 00 00
	00		 mov	 r9d, 1
  00547	4c 8b c0	 mov	 r8, rax
  0054a	b2 0f		 mov	 dl, 15
  0054c	e8 00 00 00 00	 call	 z900_vstorec

; 4242 : 
; 4243 : #ifdef OPTION_KM_DEBUG
; 4244 :       LOGBYTE("output:", query_bits[msa], 16);
; 4245 : #endif /* #ifdef OPTION_KM_DEBUG */
; 4246 : 
; 4247 :       /* Set condition code 0 */
; 4248 :       regs->psw.cc = 0;

  00551	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00559	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4249 :       return;

  0055d	e9 32 01 00 00	 jmp	 $LN1@z900_dyn_c
$LN13@z900_dyn_c:
$LN14@z900_dyn_c:
$LN15@z900_dyn_c:

; 4250 :     }
; 4251 :     case 1: /* dea */
; 4252 :     case 2: /* tdea-128 */
; 4253 :     case 3: /* tdea-192 */
; 4254 :     {
; 4255 :       ARCH_DEP(km_dea)(r1, r2, regs);

  00562	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0056a	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0056e	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00572	e8 00 00 00 00	 call	 z900_km_dea

; 4256 :       break;

  00577	e9 18 01 00 00	 jmp	 $LN5@z900_dyn_c
$LN16@z900_dyn_c:
$LN17@z900_dyn_c:
$LN18@z900_dyn_c:

; 4257 :     }
; 4258 : 
; 4259 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4260 :     case 9: /* encrypted dea */
; 4261 :     case 10: /* encrypted tdea-128 */
; 4262 :     case 11: /* encrypted tdea-192 */
; 4263 :     {
; 4264 :       if(msa >= 3)

  0057c	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  00581	7c 17		 jl	 SHORT $LN19@z900_dyn_c

; 4265 :         ARCH_DEP(km_dea)(r1, r2, regs);

  00583	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0058b	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0058f	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00593	e8 00 00 00 00	 call	 z900_km_dea
  00598	eb 13		 jmp	 SHORT $LN20@z900_dyn_c
$LN19@z900_dyn_c:

; 4266 :       else
; 4267 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0059a	ba 06 00 00 00	 mov	 edx, 6
  0059f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_dyn_c:

; 4268 :       break;

  005ad	e9 e2 00 00 00	 jmp	 $LN5@z900_dyn_c
$LN21@z900_dyn_c:

; 4269 :     }
; 4270 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4271 : 
; 4272 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4273 :     case 18: /* aes-128 */
; 4274 :     {
; 4275 :       if(msa >= 1)

  005b2	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  005b7	7c 17		 jl	 SHORT $LN22@z900_dyn_c

; 4276 :         ARCH_DEP(km_aes)(r1, r2, regs);

  005b9	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005c1	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  005c5	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005c9	e8 00 00 00 00	 call	 z900_km_aes
  005ce	eb 13		 jmp	 SHORT $LN23@z900_dyn_c
$LN22@z900_dyn_c:

; 4277 :       else
; 4278 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005d0	ba 06 00 00 00	 mov	 edx, 6
  005d5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN23@z900_dyn_c:

; 4279 :       break;

  005e3	e9 ac 00 00 00	 jmp	 $LN5@z900_dyn_c
$LN24@z900_dyn_c:
$LN25@z900_dyn_c:

; 4280 :     }
; 4281 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4282 : 
; 4283 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4284 :     case 19: /* aes-192 */
; 4285 :     case 20: /* aes-256 */
; 4286 :     {
; 4287 :       if(msa >= 2)

  005e8	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  005ed	7c 17		 jl	 SHORT $LN26@z900_dyn_c

; 4288 :         ARCH_DEP(km_aes)(r1, r2, regs);

  005ef	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005f7	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  005fb	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005ff	e8 00 00 00 00	 call	 z900_km_aes
  00604	eb 13		 jmp	 SHORT $LN27@z900_dyn_c
$LN26@z900_dyn_c:

; 4289 :       else
; 4290 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00606	ba 06 00 00 00	 mov	 edx, 6
  0060b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00613	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN27@z900_dyn_c:

; 4291 :       break;

  00619	eb 79		 jmp	 SHORT $LN5@z900_dyn_c
$LN28@z900_dyn_c:
$LN29@z900_dyn_c:
$LN30@z900_dyn_c:

; 4292 :     }
; 4293 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4294 : 
; 4295 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4296 :     case 26: /* encrypted aes-128 */
; 4297 :     case 27: /* encrypted aes-192 */
; 4298 :     case 28: /* encrypted aes-256 */
; 4299 :     {
; 4300 :       if(msa >= 3)

  0061b	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  00620	7c 17		 jl	 SHORT $LN31@z900_dyn_c

; 4301 :         ARCH_DEP(km_aes)(r1, r2, regs);

  00622	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0062a	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0062e	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00632	e8 00 00 00 00	 call	 z900_km_aes
  00637	eb 13		 jmp	 SHORT $LN32@z900_dyn_c
$LN31@z900_dyn_c:

; 4302 :       else
; 4303 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00639	ba 06 00 00 00	 mov	 edx, 6
  0063e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00646	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN32@z900_dyn_c:

; 4304 :       break;

  0064c	eb 46		 jmp	 SHORT $LN5@z900_dyn_c
$LN33@z900_dyn_c:
$LN34@z900_dyn_c:
$LN35@z900_dyn_c:
$LN36@z900_dyn_c:

; 4305 :     }
; 4306 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4307 : 
; 4308 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4309 :     case 50: /* xts aes-128 */
; 4310 :     case 52: /* xts aes-256 */
; 4311 :     case 58: /* encrypted xts aes-128 */
; 4312 :     case 60: /* encrypted xts aes-256 */
; 4313 :     {
; 4314 :       if(msa >= 4)

  0064e	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  00653	7c 17		 jl	 SHORT $LN37@z900_dyn_c

; 4315 :         ARCH_DEP(km_xts_aes)(r1, r2, regs);

  00655	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0065d	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00661	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00665	e8 00 00 00 00	 call	 z900_km_xts_aes
  0066a	eb 13		 jmp	 SHORT $LN38@z900_dyn_c
$LN37@z900_dyn_c:

; 4316 :       else
; 4317 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0066c	ba 06 00 00 00	 mov	 edx, 6
  00671	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00679	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN38@z900_dyn_c:

; 4318 :       break;

  0067f	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN39@z900_dyn_c:

; 4319 :     }
; 4320 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4321 : 
; 4322 :     default:
; 4323 :     {
; 4324 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00681	ba 06 00 00 00	 mov	 edx, 6
  00686	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4325 :       break;
; 4326 :     }
; 4327 :   }
; 4328 : }

  00694	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0069c	48 33 cc	 xor	 rcx, rsp
  0069f	e8 00 00 00 00	 call	 __security_check_cookie
  006a4	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  006ab	c3		 ret	 0
$LN54@z900_dyn_c:
  006ac	00 00 00 00	 DD	 $LN12@z900_dyn_c
  006b0	00 00 00 00	 DD	 $LN13@z900_dyn_c
  006b4	00 00 00 00	 DD	 $LN14@z900_dyn_c
  006b8	00 00 00 00	 DD	 $LN15@z900_dyn_c
  006bc	00 00 00 00	 DD	 $LN16@z900_dyn_c
  006c0	00 00 00 00	 DD	 $LN17@z900_dyn_c
  006c4	00 00 00 00	 DD	 $LN18@z900_dyn_c
  006c8	00 00 00 00	 DD	 $LN21@z900_dyn_c
  006cc	00 00 00 00	 DD	 $LN24@z900_dyn_c
  006d0	00 00 00 00	 DD	 $LN25@z900_dyn_c
  006d4	00 00 00 00	 DD	 $LN28@z900_dyn_c
  006d8	00 00 00 00	 DD	 $LN29@z900_dyn_c
  006dc	00 00 00 00	 DD	 $LN30@z900_dyn_c
  006e0	00 00 00 00	 DD	 $LN33@z900_dyn_c
  006e4	00 00 00 00	 DD	 $LN34@z900_dyn_c
  006e8	00 00 00 00	 DD	 $LN35@z900_dyn_c
  006ec	00 00 00 00	 DD	 $LN36@z900_dyn_c
  006f0	00 00 00 00	 DD	 $LN39@z900_dyn_c
$LN53@z900_dyn_c:
  006f4	00		 DB	 0
  006f5	01		 DB	 1
  006f6	02		 DB	 2
  006f7	03		 DB	 3
  006f8	11		 DB	 17
  006f9	11		 DB	 17
  006fa	11		 DB	 17
  006fb	11		 DB	 17
  006fc	11		 DB	 17
  006fd	04		 DB	 4
  006fe	05		 DB	 5
  006ff	06		 DB	 6
  00700	11		 DB	 17
  00701	11		 DB	 17
  00702	11		 DB	 17
  00703	11		 DB	 17
  00704	11		 DB	 17
  00705	11		 DB	 17
  00706	07		 DB	 7
  00707	08		 DB	 8
  00708	09		 DB	 9
  00709	11		 DB	 17
  0070a	11		 DB	 17
  0070b	11		 DB	 17
  0070c	11		 DB	 17
  0070d	11		 DB	 17
  0070e	0a		 DB	 10
  0070f	0b		 DB	 11
  00710	0c		 DB	 12
  00711	11		 DB	 17
  00712	11		 DB	 17
  00713	11		 DB	 17
  00714	11		 DB	 17
  00715	11		 DB	 17
  00716	11		 DB	 17
  00717	11		 DB	 17
  00718	11		 DB	 17
  00719	11		 DB	 17
  0071a	11		 DB	 17
  0071b	11		 DB	 17
  0071c	11		 DB	 17
  0071d	11		 DB	 17
  0071e	11		 DB	 17
  0071f	11		 DB	 17
  00720	11		 DB	 17
  00721	11		 DB	 17
  00722	11		 DB	 17
  00723	11		 DB	 17
  00724	11		 DB	 17
  00725	11		 DB	 17
  00726	0d		 DB	 13
  00727	11		 DB	 17
  00728	0e		 DB	 14
  00729	11		 DB	 17
  0072a	11		 DB	 17
  0072b	11		 DB	 17
  0072c	11		 DB	 17
  0072d	11		 DB	 17
  0072e	0f		 DB	 15
  0072f	11		 DB	 17
  00730	10		 DB	 16
z900_dyn_cipher_message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
tv353 = 56
msa$ = 60
i$1 = 64
tv330 = 68
tv344 = 72
tv89 = 80
tv297 = 88
tv313 = 96
tv368 = 104
query_bits$ = 112
__$ArrayPad$ = 192
inst$ = 224
regs$ = 232
z900_dyn_compute_last_message_digest PROC

; 4090 : {

$LN38:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec d8 00
	00 00		 sub	 rsp, 216		; 000000d8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4091 :   int msa;
; 4092 :   BYTE query_bits[][16] =

  00023	c6 44 24 70 c0	 mov	 BYTE PTR query_bits$[rsp], 192 ; 000000c0H
  00028	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 84 24 80 00
	00 00 e0	 mov	 BYTE PTR query_bits$[rsp+16], 224 ; 000000e0H
  0007b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  00083	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  0008b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00093	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0009b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  000a3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  000ab	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  000b3	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000bb	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000c3	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000cb	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000d3	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000db	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000e3	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000eb	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000f3	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000fb	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  00103	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  0010b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  00113	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  0011b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  00123	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  0012b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00133	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0013b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00143	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0014b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00153	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0015b	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00163	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0016b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00173	c6 84 24 a0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0017b	c6 84 24 a1 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00183	c6 84 24 a2 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0018b	c6 84 24 a3 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00193	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0019b	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  001a3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  001ab	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  001b3	c6 84 24 a8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  001bb	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  001c3	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  001cb	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001d3	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001db	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001e3	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001eb	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001f3	c6 84 24 b0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001fb	c6 84 24 b1 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  00203	c6 84 24 b2 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+66], 0
  0020b	c6 84 24 b3 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  00213	c6 84 24 b4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  0021b	c6 84 24 b5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  00223	c6 84 24 b6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  0022b	c6 84 24 b7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00233	c6 84 24 b8 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  0023b	c6 84 24 b9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00243	c6 84 24 ba 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0024b	c6 84 24 bb 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00253	c6 84 24 bc 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0025b	c6 84 24 bd 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00263	c6 84 24 be 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0026b	c6 84 24 bf 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4093 :   {
; 4094 :     { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4095 :     { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4096 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4097 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4098 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4099 :   };
; 4100 :   int r1;
; 4101 :   int r2;
; 4102 : 
; 4103 :   RRE(inst, regs, r1, r2);

  00273	b8 01 00 00 00	 mov	 eax, 1
  00278	48 6b c0 03	 imul	 rax, rax, 3
  0027c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00284	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00288	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
  0028c	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00290	83 e0 0f	 and	 eax, 15
  00293	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00297	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0029b	c1 f8 04	 sar	 eax, 4
  0029e	83 e0 0f	 and	 eax, 15
  002a1	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_c:
  002a5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ad	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  002b1	48 83 c0 04	 add	 rax, 4
  002b5	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bd	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  002c1	33 c0		 xor	 eax, eax
  002c3	83 f8 04	 cmp	 eax, 4
  002c6	74 0f		 je	 SHORT $LN7@z900_dyn_c
  002c8	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002d7	33 c0		 xor	 eax, eax
  002d9	85 c0		 test	 eax, eax
  002db	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4104 : 
; 4105 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4106 :     if (0
; 4107 :         || GR_A( 1,  regs ) == 0
; 4108 :         || GR_A( r1, regs ) == 0
; 4109 :         || GR_A( r2, regs ) == 0

  002dd	33 c0		 xor	 eax, eax
  002df	85 c0		 test	 eax, eax
  002e1	0f 85 02 01 00
	00		 jne	 $LN9@z900_dyn_c
  002e7	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ef	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002f5	83 e0 01	 and	 eax, 1
  002f8	85 c0		 test	 eax, eax
  002fa	74 20		 je	 SHORT $LN22@z900_dyn_c
  002fc	b8 08 00 00 00	 mov	 eax, 8
  00301	48 6b c0 01	 imul	 rax, rax, 1
  00305	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0030d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00315	48 89 44 24 50	 mov	 QWORD PTR tv89[rsp], rax
  0031a	eb 1d		 jmp	 SHORT $LN23@z900_dyn_c
$LN22@z900_dyn_c:
  0031c	b8 08 00 00 00	 mov	 eax, 8
  00321	48 6b c0 01	 imul	 rax, rax, 1
  00325	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00334	48 89 44 24 50	 mov	 QWORD PTR tv89[rsp], rax
$LN23@z900_dyn_c:
  00339	48 83 7c 24 50
	00		 cmp	 QWORD PTR tv89[rsp], 0
  0033f	0f 84 a4 00 00
	00		 je	 $LN9@z900_dyn_c
  00345	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00353	83 e0 01	 and	 eax, 1
  00356	85 c0		 test	 eax, eax
  00358	74 1c		 je	 SHORT $LN24@z900_dyn_c
  0035a	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0035f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00367	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0036f	48 89 44 24 58	 mov	 QWORD PTR tv297[rsp], rax
  00374	eb 19		 jmp	 SHORT $LN25@z900_dyn_c
$LN24@z900_dyn_c:
  00376	48 63 44 24 34	 movsxd	 rax, DWORD PTR r1$[rsp]
  0037b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00383	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0038a	48 89 44 24 58	 mov	 QWORD PTR tv297[rsp], rax
$LN25@z900_dyn_c:
  0038f	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv297[rsp], 0
  00395	74 52		 je	 SHORT $LN9@z900_dyn_c
  00397	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003a5	83 e0 01	 and	 eax, 1
  003a8	85 c0		 test	 eax, eax
  003aa	74 1c		 je	 SHORT $LN26@z900_dyn_c
  003ac	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003b1	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003c1	48 89 44 24 60	 mov	 QWORD PTR tv313[rsp], rax
  003c6	eb 19		 jmp	 SHORT $LN27@z900_dyn_c
$LN26@z900_dyn_c:
  003c8	48 63 44 24 30	 movsxd	 rax, DWORD PTR r2$[rsp]
  003cd	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003dc	48 89 44 24 60	 mov	 QWORD PTR tv313[rsp], rax
$LN27@z900_dyn_c:
  003e1	48 83 7c 24 60
	00		 cmp	 QWORD PTR tv313[rsp], 0
  003e7	75 0d		 jne	 SHORT $LN8@z900_dyn_c
$LN9@z900_dyn_c:

; 4110 :     )
; 4111 :         ARCH_DEP( per3_zero )( regs );

  003e9	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	e8 00 00 00 00	 call	 z900_per3_zero
$LN8@z900_dyn_c:

; 4112 : #endif
; 4113 : 
; 4114 :   /* The following is the same as doing a FACILITY_CHECK */
; 4115 :   msa = get_msa(regs);

  003f6	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fe	e8 00 00 00 00	 call	 get_msa
  00403	89 44 24 3c	 mov	 DWORD PTR msa$[rsp], eax

; 4116 :   if(msa < 0)

  00407	83 7c 24 3c 00	 cmp	 DWORD PTR msa$[rsp], 0
  0040c	7d 13		 jge	 SHORT $LN10@z900_dyn_c

; 4117 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  0040e	ba 01 00 00 00	 mov	 edx, 1
  00413	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN10@z900_dyn_c:

; 4118 : 
; 4119 : #ifdef OPTION_KLMD_DEBUG
; 4120 :   WRMSG(HHC90100, "D", "KLMD: compute last message digest");
; 4121 :   WRMSG(HHC90101, "D", 1, r1);
; 4122 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4123 :   WRMSG(HHC90101, "D", 2, r2);
; 4124 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4125 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4126 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4127 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4128 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4129 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4130 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 4131 : 
; 4132 :   /* Check special conditions */
; 4133 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  00421	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  00426	74 4f		 je	 SHORT $LN28@z900_dyn_c
  00428	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  0042c	83 e0 01	 and	 eax, 1
  0042f	85 c0		 test	 eax, eax
  00431	75 44		 jne	 SHORT $LN28@z900_dyn_c
  00433	b8 08 00 00 00	 mov	 eax, 8
  00438	48 6b c0 00	 imul	 rax, rax, 0
  0043c	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00444	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0044b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00450	85 c0		 test	 eax, eax
  00452	74 0a		 je	 SHORT $LN29@z900_dyn_c
  00454	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv330[rsp], 1
  0045c	eb 08		 jmp	 SHORT $LN30@z900_dyn_c
$LN29@z900_dyn_c:
  0045e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv330[rsp], 0
$LN30@z900_dyn_c:
  00466	83 7c 24 44 00	 cmp	 DWORD PTR tv330[rsp], 0
  0046b	75 0a		 jne	 SHORT $LN28@z900_dyn_c
  0046d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv344[rsp], 0
  00475	eb 08		 jmp	 SHORT $LN35@z900_dyn_c
$LN28@z900_dyn_c:
  00477	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv344[rsp], 1
$LN35@z900_dyn_c:
  0047f	83 7c 24 48 00	 cmp	 DWORD PTR tv344[rsp], 0
  00484	74 13		 je	 SHORT $LN11@z900_dyn_c

; 4134 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00486	ba 06 00 00 00	 mov	 edx, 6
  0048b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN11@z900_dyn_c:

; 4135 : 
; 4136 :   switch(GR0_fc(regs))

  00499	b8 08 00 00 00	 mov	 eax, 8
  0049e	48 6b c0 00	 imul	 rax, rax, 0
  004a2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004aa	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004b1	83 e0 7f	 and	 eax, 127		; 0000007fH
  004b4	89 44 24 38	 mov	 DWORD PTR tv353[rsp], eax
  004b8	83 7c 24 38 00	 cmp	 DWORD PTR tv353[rsp], 0
  004bd	74 26		 je	 SHORT $LN12@z900_dyn_c
  004bf	83 7c 24 38 01	 cmp	 DWORD PTR tv353[rsp], 1
  004c4	0f 84 c3 00 00
	00		 je	 $LN13@z900_dyn_c
  004ca	83 7c 24 38 02	 cmp	 DWORD PTR tv353[rsp], 2
  004cf	0f 84 cf 00 00
	00		 je	 $LN14@z900_dyn_c
  004d5	83 7c 24 38 03	 cmp	 DWORD PTR tv353[rsp], 3
  004da	0f 84 f7 00 00
	00		 je	 $LN17@z900_dyn_c
  004e0	e9 25 01 00 00	 jmp	 $LN20@z900_dyn_c
$LN12@z900_dyn_c:

; 4137 :   {
; 4138 :     case 0: /* Query */
; 4139 :     {
; 4140 :       /* Store the parameter block */
; 4141 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  004e5	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ed	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004f3	83 e0 01	 and	 eax, 1
  004f6	85 c0		 test	 eax, eax
  004f8	74 20		 je	 SHORT $LN36@z900_dyn_c
  004fa	b8 08 00 00 00	 mov	 eax, 8
  004ff	48 6b c0 01	 imul	 rax, rax, 1
  00503	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050b	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00513	48 89 44 24 68	 mov	 QWORD PTR tv368[rsp], rax
  00518	eb 1d		 jmp	 SHORT $LN37@z900_dyn_c
$LN36@z900_dyn_c:
  0051a	b8 08 00 00 00	 mov	 eax, 8
  0051f	48 6b c0 01	 imul	 rax, rax, 1
  00523	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052b	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00532	48 89 44 24 68	 mov	 QWORD PTR tv368[rsp], rax
$LN37@z900_dyn_c:
  00537	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00546	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv368[rsp]
  0054b	48 23 c8	 and	 rcx, rax
  0054e	48 8b c1	 mov	 rax, rcx
  00551	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00556	48 6b c9 10	 imul	 rcx, rcx, 16
  0055a	48 8d 4c 0c 70	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0055f	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00567	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0056c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00572	4c 8b c0	 mov	 r8, rax
  00575	b2 0f		 mov	 dl, 15
  00577	e8 00 00 00 00	 call	 z900_vstorec

; 4142 : 
; 4143 : #ifdef OPTION_KLMD_DEBUG
; 4144 :       LOGBYTE("output:", query_bits[msa], 16);
; 4145 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 4146 : 
; 4147 :       /* Set condition code 0 */
; 4148 :       regs->psw.cc = 0;

  0057c	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00584	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4149 :       return;

  00588	e9 90 00 00 00	 jmp	 $LN1@z900_dyn_c
$LN13@z900_dyn_c:

; 4150 :     }
; 4151 :     case 1: /* sha-1 */
; 4152 :     {
; 4153 :       ARCH_DEP(klmd_sha)(r1, r2, regs);

  0058d	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00595	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00599	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0059d	e8 00 00 00 00	 call	 z900_klmd_sha

; 4154 :       break;

  005a2	eb 79		 jmp	 SHORT $LN5@z900_dyn_c
$LN14@z900_dyn_c:

; 4155 :     }
; 4156 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4157 :     case 2: /* sha-256 */
; 4158 :     {
; 4159 :       if(msa >= 1)

  005a4	83 7c 24 3c 01	 cmp	 DWORD PTR msa$[rsp], 1
  005a9	7c 17		 jl	 SHORT $LN15@z900_dyn_c

; 4160 :         ARCH_DEP(klmd_sha)(r1, r2, regs);

  005ab	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005b3	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  005b7	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005bb	e8 00 00 00 00	 call	 z900_klmd_sha
  005c0	eb 13		 jmp	 SHORT $LN16@z900_dyn_c
$LN15@z900_dyn_c:

; 4161 :       else
; 4162 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005c2	ba 06 00 00 00	 mov	 edx, 6
  005c7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN16@z900_dyn_c:

; 4163 :       break;

  005d5	eb 46		 jmp	 SHORT $LN5@z900_dyn_c
$LN17@z900_dyn_c:

; 4164 :     }
; 4165 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4166 : 
; 4167 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4168 :     case 3: /* sha-512 */
; 4169 :     {
; 4170 :       if(msa >= 2)

  005d7	83 7c 24 3c 02	 cmp	 DWORD PTR msa$[rsp], 2
  005dc	7c 17		 jl	 SHORT $LN18@z900_dyn_c

; 4171 :         ARCH_DEP(klmd_sha)(r1, r2, regs);

  005de	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  005e6	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  005ea	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  005ee	e8 00 00 00 00	 call	 z900_klmd_sha
  005f3	eb 13		 jmp	 SHORT $LN19@z900_dyn_c
$LN18@z900_dyn_c:

; 4172 :       else
; 4173 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  005f5	ba 06 00 00 00	 mov	 edx, 6
  005fa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00602	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN19@z900_dyn_c:

; 4174 :       break;

  00608	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN20@z900_dyn_c:

; 4175 :     }
; 4176 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4177 : 
; 4178 :     default:
; 4179 :     {
; 4180 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0060a	ba 06 00 00 00	 mov	 edx, 6
  0060f	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00617	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4181 :       break;
; 4182 :     }
; 4183 :   }
; 4184 : }

  0061d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00625	48 33 cc	 xor	 rcx, rsp
  00628	e8 00 00 00 00	 call	 __security_check_cookie
  0062d	48 81 c4 d8 00
	00 00		 add	 rsp, 216		; 000000d8H
  00634	c3		 ret	 0
z900_dyn_compute_last_message_digest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
tv308 = 52
msa$ = 56
r1$ = 60
i$1 = 64
tv93 = 68
tv299 = 72
tv323 = 80
query_bits$ = 96
__$ArrayPad$ = 176
inst$ = 208
regs$ = 216
z900_dyn_compute_intermediate_message_digest PROC

; 3986 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3987 :   int msa;
; 3988 :   BYTE query_bits[][16] =

  00023	c6 44 24 60 c0	 mov	 BYTE PTR query_bits$[rsp], 192 ; 000000c0H
  00028	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 70 e0	 mov	 BYTE PTR query_bits$[rsp+16], 224 ; 000000e0H
  00078	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000cb	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000d3	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000db	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000e3	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000eb	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000f3	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000fb	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  00103	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  0010b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  00113	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  0011b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  00123	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  0012b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00133	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0013b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00143	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0014b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00153	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0015b	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00163	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0016b	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00173	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0017b	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00183	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0018b	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00193	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0019b	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  001a3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  001ab	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  001b3	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  001bb	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  001c3	c6 84 24 a0 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  001cb	c6 84 24 a1 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  001d3	c6 84 24 a2 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+66], 0
  001db	c6 84 24 a3 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  001e3	c6 84 24 a4 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001eb	c6 84 24 a5 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001f3	c6 84 24 a6 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001fb	c6 84 24 a7 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  00203	c6 84 24 a8 00
	00 00 40	 mov	 BYTE PTR query_bits$[rsp+72], 64 ; 00000040H
  0020b	c6 84 24 a9 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  00213	c6 84 24 aa 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  0021b	c6 84 24 ab 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  00223	c6 84 24 ac 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  0022b	c6 84 24 ad 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00233	c6 84 24 ae 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0023b	c6 84 24 af 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 3989 :   {
; 3990 :     { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3991 :     { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3992 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3993 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3994 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 3995 :   };
; 3996 :   int r1;
; 3997 :   int r2;
; 3998 : 
; 3999 :   RRE(inst, regs, r1, r2);

  00243	b8 01 00 00 00	 mov	 eax, 1
  00248	48 6b c0 03	 imul	 rax, rax, 3
  0024c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00254	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00258	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
  0025c	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00260	83 e0 0f	 and	 eax, 15
  00263	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00267	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0026b	c1 f8 04	 sar	 eax, 4
  0026e	83 e0 0f	 and	 eax, 15
  00271	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@z900_dyn_c:
  00275	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00281	48 83 c0 04	 add	 rax, 4
  00285	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00291	33 c0		 xor	 eax, eax
  00293	83 f8 04	 cmp	 eax, 4
  00296	74 0f		 je	 SHORT $LN7@z900_dyn_c
  00298	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a0	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@z900_dyn_c:
  002a7	33 c0		 xor	 eax, eax
  002a9	85 c0		 test	 eax, eax
  002ab	75 c8		 jne	 SHORT $LN4@z900_dyn_c

; 4000 :   PER_ZEROADDR_CHECK2( regs, 1, r2 );

  002ad	44 8b 44 24 30	 mov	 r8d, DWORD PTR r2$[rsp]
  002b2	ba 01 00 00 00	 mov	 edx, 1
  002b7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002bf	e8 00 00 00 00	 call	 z900_per3_zero_check2

; 4001 : 
; 4002 :   /* The following is the same as doing a FACILITY_CHECK */
; 4003 :   msa = get_msa(regs);

  002c4	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cc	e8 00 00 00 00	 call	 get_msa
  002d1	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4004 :   if(msa < 0)

  002d5	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  002da	7d 13		 jge	 SHORT $LN8@z900_dyn_c

; 4005 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  002dc	ba 01 00 00 00	 mov	 edx, 1
  002e1	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN8@z900_dyn_c:

; 4006 : 
; 4007 : #ifdef OPTION_KIMD_DEBUG
; 4008 :   WRMSG(HHC90100, "D", "KIMD: compute intermediate message digest");
; 4009 :   WRMSG(HHC90101, "D", 1, r1);
; 4010 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4011 :   WRMSG(HHC90101, "D", 2, r2);
; 4012 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4013 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4014 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4015 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4016 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4017 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4018 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 4019 : 
; 4020 :   /* Check special conditions */
; 4021 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002ef	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002f4	74 4f		 je	 SHORT $LN23@z900_dyn_c
  002f6	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002fa	83 e0 01	 and	 eax, 1
  002fd	85 c0		 test	 eax, eax
  002ff	75 44		 jne	 SHORT $LN23@z900_dyn_c
  00301	b8 08 00 00 00	 mov	 eax, 8
  00306	48 6b c0 00	 imul	 rax, rax, 0
  0030a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00312	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00319	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0031e	85 c0		 test	 eax, eax
  00320	74 0a		 je	 SHORT $LN24@z900_dyn_c
  00322	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  0032a	eb 08		 jmp	 SHORT $LN25@z900_dyn_c
$LN24@z900_dyn_c:
  0032c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN25@z900_dyn_c:
  00334	83 7c 24 44 00	 cmp	 DWORD PTR tv93[rsp], 0
  00339	75 0a		 jne	 SHORT $LN23@z900_dyn_c
  0033b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv299[rsp], 0
  00343	eb 08		 jmp	 SHORT $LN30@z900_dyn_c
$LN23@z900_dyn_c:
  00345	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv299[rsp], 1
$LN30@z900_dyn_c:
  0034d	83 7c 24 48 00	 cmp	 DWORD PTR tv299[rsp], 0
  00352	74 13		 je	 SHORT $LN9@z900_dyn_c

; 4022 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00354	ba 06 00 00 00	 mov	 edx, 6
  00359	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00361	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN9@z900_dyn_c:

; 4023 : 
; 4024 :   switch(GR0_fc(regs))

  00367	b8 08 00 00 00	 mov	 eax, 8
  0036c	48 6b c0 00	 imul	 rax, rax, 0
  00370	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00378	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0037f	83 e0 7f	 and	 eax, 127		; 0000007fH
  00382	89 44 24 34	 mov	 DWORD PTR tv308[rsp], eax
  00386	83 7c 24 34 00	 cmp	 DWORD PTR tv308[rsp], 0
  0038b	74 31		 je	 SHORT $LN10@z900_dyn_c
  0038d	83 7c 24 34 01	 cmp	 DWORD PTR tv308[rsp], 1
  00392	0f 84 ce 00 00
	00		 je	 $LN11@z900_dyn_c
  00398	83 7c 24 34 02	 cmp	 DWORD PTR tv308[rsp], 2
  0039d	0f 84 e0 00 00
	00		 je	 $LN12@z900_dyn_c
  003a3	83 7c 24 34 03	 cmp	 DWORD PTR tv308[rsp], 3
  003a8	0f 84 0b 01 00
	00		 je	 $LN15@z900_dyn_c
  003ae	83 7c 24 34 41	 cmp	 DWORD PTR tv308[rsp], 65 ; 00000041H
  003b3	0f 84 36 01 00
	00		 je	 $LN18@z900_dyn_c
  003b9	e9 64 01 00 00	 jmp	 $LN21@z900_dyn_c
$LN10@z900_dyn_c:

; 4025 :   {
; 4026 :     case 0: /* Query */
; 4027 :     {
; 4028 :       /* Store the parameter block */
; 4029 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  003be	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003cc	83 e0 01	 and	 eax, 1
  003cf	85 c0		 test	 eax, eax
  003d1	74 20		 je	 SHORT $LN31@z900_dyn_c
  003d3	b8 08 00 00 00	 mov	 eax, 8
  003d8	48 6b c0 01	 imul	 rax, rax, 1
  003dc	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e4	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  003ec	48 89 44 24 50	 mov	 QWORD PTR tv323[rsp], rax
  003f1	eb 1d		 jmp	 SHORT $LN32@z900_dyn_c
$LN31@z900_dyn_c:
  003f3	b8 08 00 00 00	 mov	 eax, 8
  003f8	48 6b c0 01	 imul	 rax, rax, 1
  003fc	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00404	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0040b	48 89 44 24 50	 mov	 QWORD PTR tv323[rsp], rax
$LN32@z900_dyn_c:
  00410	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00418	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0041f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv323[rsp]
  00424	48 23 c8	 and	 rcx, rax
  00427	48 8b c1	 mov	 rax, rcx
  0042a	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0042f	48 6b c9 10	 imul	 rcx, rcx, 16
  00433	48 8d 4c 0c 60	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00438	48 8b 94 24 d8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00440	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00445	41 b9 01 00 00
	00		 mov	 r9d, 1
  0044b	4c 8b c0	 mov	 r8, rax
  0044e	b2 0f		 mov	 dl, 15
  00450	e8 00 00 00 00	 call	 z900_vstorec

; 4030 : 
; 4031 : #ifdef OPTION_KIMD_DEBUG
; 4032 :       LOGBYTE("output:", query_bits[msa], 16);
; 4033 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 4034 : 
; 4035 :       /* Set condition code 0 */
; 4036 :       regs->psw.cc = 0;

  00455	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0045d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4037 :       return;

  00461	e9 cf 00 00 00	 jmp	 $LN1@z900_dyn_c
$LN11@z900_dyn_c:

; 4038 :     }
; 4039 :     case 1: /* sha-1 */
; 4040 :     {
; 4041 :       ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  00466	45 33 c9	 xor	 r9d, r9d
  00469	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00471	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00475	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00479	e8 00 00 00 00	 call	 z900_kimd_sha

; 4042 :       break;

  0047e	e9 b2 00 00 00	 jmp	 $LN5@z900_dyn_c
$LN12@z900_dyn_c:

; 4043 :     }
; 4044 : 
; 4045 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4046 :     case 2: /* sha-256 */
; 4047 :     {
; 4048 :       if(msa >= 1)

  00483	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  00488	7c 1a		 jl	 SHORT $LN13@z900_dyn_c

; 4049 :         ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  0048a	45 33 c9	 xor	 r9d, r9d
  0048d	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00495	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00499	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0049d	e8 00 00 00 00	 call	 z900_kimd_sha
  004a2	eb 13		 jmp	 SHORT $LN14@z900_dyn_c
$LN13@z900_dyn_c:

; 4050 :       else
; 4051 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004a4	ba 06 00 00 00	 mov	 edx, 6
  004a9	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN14@z900_dyn_c:

; 4052 :       break;

  004b7	eb 7c		 jmp	 SHORT $LN5@z900_dyn_c
$LN15@z900_dyn_c:

; 4053 :     }
; 4054 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4055 : 
; 4056 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4057 :     case 3: /* sha-512 */
; 4058 :     {
; 4059 :       if(msa >= 2)

  004b9	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  004be	7c 1a		 jl	 SHORT $LN16@z900_dyn_c

; 4060 :         ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  004c0	45 33 c9	 xor	 r9d, r9d
  004c3	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004cb	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  004cf	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  004d3	e8 00 00 00 00	 call	 z900_kimd_sha
  004d8	eb 13		 jmp	 SHORT $LN17@z900_dyn_c
$LN16@z900_dyn_c:

; 4061 :       else
; 4062 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004da	ba 06 00 00 00	 mov	 edx, 6
  004df	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN17@z900_dyn_c:

; 4063 :       break;

  004ed	eb 46		 jmp	 SHORT $LN5@z900_dyn_c
$LN18@z900_dyn_c:

; 4064 :     }
; 4065 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4066 : 
; 4067 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4068 :     case 65: /* ghash */
; 4069 :     {
; 4070 :       if(msa >= 4)

  004ef	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  004f4	7c 17		 jl	 SHORT $LN19@z900_dyn_c

; 4071 :         ARCH_DEP(kimd_ghash)(r1, r2, regs);

  004f6	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  004fe	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00502	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00506	e8 00 00 00 00	 call	 z900_kimd_ghash
  0050b	eb 13		 jmp	 SHORT $LN20@z900_dyn_c
$LN19@z900_dyn_c:

; 4072 :       else
; 4073 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0050d	ba 06 00 00 00	 mov	 edx, 6
  00512	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_dyn_c:

; 4074 :       break;

  00520	eb 13		 jmp	 SHORT $LN5@z900_dyn_c
$LN21@z900_dyn_c:

; 4075 :     }
; 4076 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4077 : 
; 4078 :     default:
; 4079 :     {
; 4080 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00522	ba 06 00 00 00	 mov	 edx, 6
  00527	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_dyn_c:
$LN1@z900_dyn_c:

; 4081 :       break;
; 4082 :     }
; 4083 :   }
; 4084 : }

  00535	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0053d	48 33 cc	 xor	 rcx, rsp
  00540	e8 00 00 00 00	 call	 __security_check_cookie
  00545	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0054c	c3		 ret	 0
z900_dyn_compute_intermediate_message_digest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
keylen$ = 52
fc$ = 56
tv89 = 64
tv139 = 72
tv163 = 80
parameter_block$ = 96
__$ArrayPad$ = 160
regs$ = 192
z900_pckmo_aes PROC

; 3947 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3948 :   int fc;
; 3949 :   int keylen;
; 3950 :   BYTE parameter_block[64];
; 3951 :   int parameter_blocklen;
; 3952 : 
; 3953 :   /* Initialize values */
; 3954 :   fc = GR0_fc(regs);

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 00	 imul	 rax, rax, 0
  00027	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00036	83 e0 7f	 and	 eax, 127		; 0000007fH
  00039	89 44 24 38	 mov	 DWORD PTR fc$[rsp], eax

; 3955 :   keylen = (fc - 16) * 8;

  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fc$[rsp]
  00041	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00048	89 44 24 34	 mov	 DWORD PTR keylen$[rsp], eax

; 3956 :   parameter_blocklen = keylen + 32;

  0004c	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  00050	83 c0 20	 add	 eax, 32			; 00000020H
  00053	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3957 : 
; 3958 :   /* Test writeability */
; 3959 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  00057	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00065	83 e0 01	 and	 eax, 1
  00068	85 c0		 test	 eax, eax
  0006a	74 20		 je	 SHORT $LN3@z900_pckmo
  0006c	b8 08 00 00 00	 mov	 eax, 8
  00071	48 6b c0 01	 imul	 rax, rax, 1
  00075	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00085	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
  0008a	eb 1d		 jmp	 SHORT $LN4@z900_pckmo
$LN3@z900_pckmo:
  0008c	b8 08 00 00 00	 mov	 eax, 8
  00091	48 6b c0 01	 imul	 rax, rax, 1
  00095	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000a4	48 89 44 24 40	 mov	 QWORD PTR tv89[rsp], rax
$LN4@z900_pckmo:
  000a9	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  000ad	ff c8		 dec	 eax
  000af	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b7	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  000be	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv89[rsp]
  000c3	48 23 d1	 and	 rdx, rcx
  000c6	48 8b ca	 mov	 rcx, rdx
  000c9	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000d1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000d6	41 b9 02 00 00
	00		 mov	 r9d, 2
  000dc	44 8b c0	 mov	 r8d, eax
  000df	ba 01 00 00 00	 mov	 edx, 1
  000e4	e8 00 00 00 00	 call	 z900_validate_operand

; 3960 : 
; 3961 :   /* Fetch the parameter block */
; 3962 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  000e9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000f1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000f7	83 e0 01	 and	 eax, 1
  000fa	85 c0		 test	 eax, eax
  000fc	74 20		 je	 SHORT $LN5@z900_pckmo
  000fe	b8 08 00 00 00	 mov	 eax, 8
  00103	48 6b c0 01	 imul	 rax, rax, 1
  00107	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00117	48 89 44 24 48	 mov	 QWORD PTR tv139[rsp], rax
  0011c	eb 1d		 jmp	 SHORT $LN6@z900_pckmo
$LN5@z900_pckmo:
  0011e	b8 08 00 00 00	 mov	 eax, 8
  00123	48 6b c0 01	 imul	 rax, rax, 1
  00127	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00136	48 89 44 24 48	 mov	 QWORD PTR tv139[rsp], rax
$LN6@z900_pckmo:
  0013b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00143	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0014a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv139[rsp]
  0014f	48 23 c8	 and	 rcx, rax
  00152	48 8b c1	 mov	 rax, rcx
  00155	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00159	ff c9		 dec	 ecx
  0015b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00168	41 b9 01 00 00
	00		 mov	 r9d, 1
  0016e	4c 8b c0	 mov	 r8, rax
  00171	0f b6 d1	 movzx	 edx, cl
  00174	48 8d 4c 24 60	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00179	e8 00 00 00 00	 call	 z900_vfetchc

; 3963 : 
; 3964 : #ifdef OPTION_PCKMO_DEBUG
; 3965 :   LOGBYTE("key in : ", parameter_block, keylen);
; 3966 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3967 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3968 : 
; 3969 :   /* Encrypt the key and fill the wrapping key verification pattern */
; 3970 :   wrap_aes(parameter_block, keylen);

  0017e	8b 54 24 34	 mov	 edx, DWORD PTR keylen$[rsp]
  00182	48 8d 4c 24 60	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00187	e8 00 00 00 00	 call	 wrap_aes

; 3971 : 
; 3972 :   /* Store the parameterblock */
; 3973 :   ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0018c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00194	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0019a	83 e0 01	 and	 eax, 1
  0019d	85 c0		 test	 eax, eax
  0019f	74 20		 je	 SHORT $LN7@z900_pckmo
  001a1	b8 08 00 00 00	 mov	 eax, 8
  001a6	48 6b c0 01	 imul	 rax, rax, 1
  001aa	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b2	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  001ba	48 89 44 24 50	 mov	 QWORD PTR tv163[rsp], rax
  001bf	eb 1d		 jmp	 SHORT $LN8@z900_pckmo
$LN7@z900_pckmo:
  001c1	b8 08 00 00 00	 mov	 eax, 8
  001c6	48 6b c0 01	 imul	 rax, rax, 1
  001ca	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001d9	48 89 44 24 50	 mov	 QWORD PTR tv163[rsp], rax
$LN8@z900_pckmo:
  001de	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e6	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001ed	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv163[rsp]
  001f2	48 23 c8	 and	 rcx, rax
  001f5	48 8b c1	 mov	 rax, rcx
  001f8	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001fc	ff c9		 dec	 ecx
  001fe	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00206	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0020b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00211	4c 8b c0	 mov	 r8, rax
  00214	0f b6 d1	 movzx	 edx, cl
  00217	48 8d 4c 24 60	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0021c	e8 00 00 00 00	 call	 z900_vstorec

; 3974 : 
; 3975 : #ifdef OPTION_PCKMO_DEBUG
; 3976 :   LOGBYTE("key out: ", parameter_block, keylen);
; 3977 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3978 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3979 : }

  00221	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00229	48 33 cc	 xor	 rcx, rsp
  0022c	e8 00 00 00 00	 call	 __security_check_cookie
  00231	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00238	c3		 ret	 0
z900_pckmo_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
keylen$ = 52
fc$ = 56
tv88 = 64
tv138 = 72
tv162 = 80
parameter_block$ = 96
__$ArrayPad$ = 160
regs$ = 192
z900_pckmo_dea PROC

; 3909 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3910 :   int fc;
; 3911 :   int keylen;
; 3912 :   BYTE parameter_block[64];
; 3913 :   int parameter_blocklen;
; 3914 : 
; 3915 :   /* Initialize values */
; 3916 :   fc = GR0_fc(regs);

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 00	 imul	 rax, rax, 0
  00027	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00036	83 e0 7f	 and	 eax, 127		; 0000007fH
  00039	89 44 24 38	 mov	 DWORD PTR fc$[rsp], eax

; 3917 :   keylen = fc * 8;

  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fc$[rsp]
  00041	c1 e0 03	 shl	 eax, 3
  00044	89 44 24 34	 mov	 DWORD PTR keylen$[rsp], eax

; 3918 :   parameter_blocklen = keylen + 24;

  00048	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  0004c	83 c0 18	 add	 eax, 24
  0004f	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3919 : 
; 3920 :   /* Test writeability */
; 3921 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  00053	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0005b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00061	83 e0 01	 and	 eax, 1
  00064	85 c0		 test	 eax, eax
  00066	74 20		 je	 SHORT $LN3@z900_pckmo
  00068	b8 08 00 00 00	 mov	 eax, 8
  0006d	48 6b c0 01	 imul	 rax, rax, 1
  00071	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00079	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00081	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
  00086	eb 1d		 jmp	 SHORT $LN4@z900_pckmo
$LN3@z900_pckmo:
  00088	b8 08 00 00 00	 mov	 eax, 8
  0008d	48 6b c0 01	 imul	 rax, rax, 1
  00091	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00099	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000a0	48 89 44 24 40	 mov	 QWORD PTR tv88[rsp], rax
$LN4@z900_pckmo:
  000a5	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  000a9	ff c8		 dec	 eax
  000ab	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  000ba	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv88[rsp]
  000bf	48 23 d1	 and	 rdx, rcx
  000c2	48 8b ca	 mov	 rcx, rdx
  000c5	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000cd	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000d2	41 b9 02 00 00
	00		 mov	 r9d, 2
  000d8	44 8b c0	 mov	 r8d, eax
  000db	ba 01 00 00 00	 mov	 edx, 1
  000e0	e8 00 00 00 00	 call	 z900_validate_operand

; 3922 : 
; 3923 :   /* Fetch the parameter block */
; 3924 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  000e5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ed	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000f3	83 e0 01	 and	 eax, 1
  000f6	85 c0		 test	 eax, eax
  000f8	74 20		 je	 SHORT $LN5@z900_pckmo
  000fa	b8 08 00 00 00	 mov	 eax, 8
  000ff	48 6b c0 01	 imul	 rax, rax, 1
  00103	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00113	48 89 44 24 48	 mov	 QWORD PTR tv138[rsp], rax
  00118	eb 1d		 jmp	 SHORT $LN6@z900_pckmo
$LN5@z900_pckmo:
  0011a	b8 08 00 00 00	 mov	 eax, 8
  0011f	48 6b c0 01	 imul	 rax, rax, 1
  00123	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012b	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00132	48 89 44 24 48	 mov	 QWORD PTR tv138[rsp], rax
$LN6@z900_pckmo:
  00137	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0013f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00146	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv138[rsp]
  0014b	48 23 c8	 and	 rcx, rax
  0014e	48 8b c1	 mov	 rax, rcx
  00151	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00155	ff c9		 dec	 ecx
  00157	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0015f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00164	41 b9 01 00 00
	00		 mov	 r9d, 1
  0016a	4c 8b c0	 mov	 r8, rax
  0016d	0f b6 d1	 movzx	 edx, cl
  00170	48 8d 4c 24 60	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00175	e8 00 00 00 00	 call	 z900_vfetchc

; 3925 : 
; 3926 : #ifdef OPTION_PCKMO_DEBUG
; 3927 :   LOGBYTE("key in : ", parameter_block, keylen);
; 3928 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3929 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3930 : 
; 3931 :   /* Encrypt the key and fill the wrapping key verification pattern */
; 3932 :   wrap_dea(parameter_block, keylen);

  0017a	8b 54 24 34	 mov	 edx, DWORD PTR keylen$[rsp]
  0017e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00183	e8 00 00 00 00	 call	 wrap_dea

; 3933 : 
; 3934 :   /* Store the parameterblock */
; 3935 :   ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00188	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00196	83 e0 01	 and	 eax, 1
  00199	85 c0		 test	 eax, eax
  0019b	74 20		 je	 SHORT $LN7@z900_pckmo
  0019d	b8 08 00 00 00	 mov	 eax, 8
  001a2	48 6b c0 01	 imul	 rax, rax, 1
  001a6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  001b6	48 89 44 24 50	 mov	 QWORD PTR tv162[rsp], rax
  001bb	eb 1d		 jmp	 SHORT $LN8@z900_pckmo
$LN7@z900_pckmo:
  001bd	b8 08 00 00 00	 mov	 eax, 8
  001c2	48 6b c0 01	 imul	 rax, rax, 1
  001c6	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001d5	48 89 44 24 50	 mov	 QWORD PTR tv162[rsp], rax
$LN8@z900_pckmo:
  001da	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001e2	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001e9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv162[rsp]
  001ee	48 23 c8	 and	 rcx, rax
  001f1	48 8b c1	 mov	 rax, rcx
  001f4	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001f8	ff c9		 dec	 ecx
  001fa	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00202	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00207	41 b9 01 00 00
	00		 mov	 r9d, 1
  0020d	4c 8b c0	 mov	 r8, rax
  00210	0f b6 d1	 movzx	 edx, cl
  00213	48 8d 4c 24 60	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00218	e8 00 00 00 00	 call	 z900_vstorec

; 3936 : 
; 3937 : #ifdef OPTION_PCKMO_DEBUG
; 3938 :   LOGBYTE("key out: ", parameter_block, keylen);
; 3939 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3940 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3941 : }

  0021d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00225	48 33 cc	 xor	 rcx, rsp
  00228	e8 00 00 00 00	 call	 __security_check_cookie
  0022d	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00234	c3		 ret	 0
z900_pckmo_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
ibi$ = 56
keylen$ = 64
tv70 = 68
tv81 = 72
tv161 = 76
wrap$ = 80
tweak$ = 88
xts$ = 96
tfc$ = 104
tv292 = 108
tv184 = 112
tv205 = 120
bsn$ = 128
tv336 = 136
context$ = 144
mask$ = 640
zero$ = 648
parameter_block$ = 672
__$ArrayPad$ = 800
regs$ = 848
z900_pcc_xts_aes PROC

; 3793 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 38 03
	00 00		 sub	 rsp, 824		; 00000338H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3794 :   BYTE *bsn;
; 3795 :   rijndael_ctx context;
; 3796 :   BYTE *ibi;
; 3797 :   int keylen;
; 3798 :   BYTE mask[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

  00020	c6 84 24 80 02
	00 00 80	 mov	 BYTE PTR mask$[rsp], 128 ; 00000080H
  00028	c6 84 24 81 02
	00 00 40	 mov	 BYTE PTR mask$[rsp+1], 64 ; 00000040H
  00030	c6 84 24 82 02
	00 00 20	 mov	 BYTE PTR mask$[rsp+2], 32 ; 00000020H
  00038	c6 84 24 83 02
	00 00 10	 mov	 BYTE PTR mask$[rsp+3], 16
  00040	c6 84 24 84 02
	00 00 08	 mov	 BYTE PTR mask$[rsp+4], 8
  00048	c6 84 24 85 02
	00 00 04	 mov	 BYTE PTR mask$[rsp+5], 4
  00050	c6 84 24 86 02
	00 00 02	 mov	 BYTE PTR mask$[rsp+6], 2
  00058	c6 84 24 87 02
	00 00 01	 mov	 BYTE PTR mask$[rsp+7], 1

; 3799 :   BYTE parameter_block[128];
; 3800 :   int parameter_blocklen;
; 3801 :   int tfc;
; 3802 :   BYTE *tweak;
; 3803 :   int wrap;
; 3804 :   BYTE *xts;
; 3805 :   BYTE zero[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

  00060	c6 84 24 88 02
	00 00 00	 mov	 BYTE PTR zero$[rsp], 0
  00068	c6 84 24 89 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+1], 0
  00070	c6 84 24 8a 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+2], 0
  00078	c6 84 24 8b 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+3], 0
  00080	c6 84 24 8c 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+4], 0
  00088	c6 84 24 8d 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+5], 0
  00090	c6 84 24 8e 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+6], 0
  00098	c6 84 24 8f 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+7], 0
  000a0	c6 84 24 90 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+8], 0
  000a8	c6 84 24 91 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+9], 0
  000b0	c6 84 24 92 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+10], 0
  000b8	c6 84 24 93 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+11], 0
  000c0	c6 84 24 94 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+12], 0
  000c8	c6 84 24 95 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+13], 0
  000d0	c6 84 24 96 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+14], 0
  000d8	c6 84 24 97 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+15], 0

; 3806 : 
; 3807 :   /* Check special conditions */
; 3808 :   if(unlikely(GR0_m(regs)))

  000e0	b8 08 00 00 00	 mov	 eax, 8
  000e5	48 6b c0 00	 imul	 rax, rax, 0
  000e9	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fd	85 c0		 test	 eax, eax
  000ff	74 0a		 je	 SHORT $LN15@z900_pcc_x
  00101	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00109	eb 08		 jmp	 SHORT $LN16@z900_pcc_x
$LN15@z900_pcc_x:
  0010b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN16@z900_pcc_x:
  00113	83 7c 24 44 00	 cmp	 DWORD PTR tv70[rsp], 0
  00118	74 0a		 je	 SHORT $LN21@z900_pcc_x
  0011a	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00122	eb 08		 jmp	 SHORT $LN22@z900_pcc_x
$LN21@z900_pcc_x:
  00124	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN22@z900_pcc_x:
  0012c	83 7c 24 48 00	 cmp	 DWORD PTR tv81[rsp], 0
  00131	74 13		 je	 SHORT $LN5@z900_pcc_x

; 3809 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00133	ba 06 00 00 00	 mov	 edx, 6
  00138	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN5@z900_pcc_x:

; 3810 : 
; 3811 :   /* Initialize values */
; 3812 :   tfc = GR0_tfc(regs);

  00146	b8 08 00 00 00	 mov	 eax, 8
  0014b	48 6b c0 00	 imul	 rax, rax, 0
  0014f	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0015e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00161	83 e0 77	 and	 eax, 119		; 00000077H
  00164	89 44 24 68	 mov	 DWORD PTR tfc$[rsp], eax

; 3813 :   wrap = GR0_wrap(regs);

  00168	b8 08 00 00 00	 mov	 eax, 8
  0016d	48 6b c0 00	 imul	 rax, rax, 0
  00171	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00180	83 e0 08	 and	 eax, 8
  00183	85 c0		 test	 eax, eax
  00185	74 0a		 je	 SHORT $LN23@z900_pcc_x
  00187	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0018f	eb 08		 jmp	 SHORT $LN24@z900_pcc_x
$LN23@z900_pcc_x:
  00191	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN24@z900_pcc_x:
  00199	8b 44 24 4c	 mov	 eax, DWORD PTR tv161[rsp]
  0019d	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 3814 :   keylen = (tfc - 49) * 8 + 8;

  001a1	8b 44 24 68	 mov	 eax, DWORD PTR tfc$[rsp]
  001a5	8d 04 c5 80 fe
	ff ff		 lea	 eax, DWORD PTR [rax*8-384]
  001ac	89 44 24 40	 mov	 DWORD PTR keylen$[rsp], eax

; 3815 :   parameter_blocklen = keylen + 64;

  001b0	8b 44 24 40	 mov	 eax, DWORD PTR keylen$[rsp]
  001b4	83 c0 40	 add	 eax, 64			; 00000040H
  001b7	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3816 :   if(wrap)

  001bb	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001c0	74 0b		 je	 SHORT $LN6@z900_pcc_x

; 3817 :     parameter_blocklen += 32;

  001c2	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001c6	83 c0 20	 add	 eax, 32			; 00000020H
  001c9	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN6@z900_pcc_x:

; 3818 : 
; 3819 :   /* Test writeability XTS parameter */
; 3820 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + parameter_blocklen - 16) & ADDRESS_MAXWRAP(regs), 1, 31, ACCTYPE_WRITE, regs);

  001cd	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001db	83 e0 01	 and	 eax, 1
  001de	85 c0		 test	 eax, eax
  001e0	74 20		 je	 SHORT $LN25@z900_pcc_x
  001e2	b8 08 00 00 00	 mov	 eax, 8
  001e7	48 6b c0 01	 imul	 rax, rax, 1
  001eb	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f3	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  001fb	48 89 44 24 70	 mov	 QWORD PTR tv184[rsp], rax
  00200	eb 1d		 jmp	 SHORT $LN26@z900_pcc_x
$LN25@z900_pcc_x:
  00202	b8 08 00 00 00	 mov	 eax, 8
  00207	48 6b c0 01	 imul	 rax, rax, 1
  0020b	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0021a	48 89 44 24 70	 mov	 QWORD PTR tv184[rsp], rax
$LN26@z900_pcc_x:
  0021f	48 63 44 24 30	 movsxd	 rax, DWORD PTR parameter_blocklen$[rsp]
  00224	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv184[rsp]
  00229	48 8d 44 01 f0	 lea	 rax, QWORD PTR [rcx+rax-16]
  0022e	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00236	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  0023d	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00245	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0024a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00250	41 b8 1f 00 00
	00		 mov	 r8d, 31
  00256	ba 01 00 00 00	 mov	 edx, 1
  0025b	48 8b c8	 mov	 rcx, rax
  0025e	e8 00 00 00 00	 call	 z900_validate_operand

; 3821 : 
; 3822 :   /* Fetch the parameter block */
; 3823 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00263	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00271	83 e0 01	 and	 eax, 1
  00274	85 c0		 test	 eax, eax
  00276	74 20		 je	 SHORT $LN27@z900_pcc_x
  00278	b8 08 00 00 00	 mov	 eax, 8
  0027d	48 6b c0 01	 imul	 rax, rax, 1
  00281	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00289	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00291	48 89 44 24 78	 mov	 QWORD PTR tv205[rsp], rax
  00296	eb 1d		 jmp	 SHORT $LN28@z900_pcc_x
$LN27@z900_pcc_x:
  00298	b8 08 00 00 00	 mov	 eax, 8
  0029d	48 6b c0 01	 imul	 rax, rax, 1
  002a1	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a9	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002b0	48 89 44 24 78	 mov	 QWORD PTR tv205[rsp], rax
$LN28@z900_pcc_x:
  002b5	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bd	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002c4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv205[rsp]
  002c9	48 23 c8	 and	 rcx, rax
  002cc	48 8b c1	 mov	 rax, rcx
  002cf	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  002d3	ff c9		 dec	 ecx
  002d5	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002dd	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002e2	41 b9 01 00 00
	00		 mov	 r9d, 1
  002e8	4c 8b c0	 mov	 r8, rax
  002eb	0f b6 d1	 movzx	 edx, cl
  002ee	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  002f6	e8 00 00 00 00	 call	 z900_vfetchc

; 3824 :   tweak = &parameter_block[parameter_blocklen - 64];

  002fb	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  002ff	83 e8 40	 sub	 eax, 64			; 00000040H
  00302	48 98		 cdqe
  00304	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0030c	48 89 44 24 58	 mov	 QWORD PTR tweak$[rsp], rax

; 3825 :   bsn = &parameter_block[parameter_blocklen - 48];

  00311	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00315	83 e8 30	 sub	 eax, 48			; 00000030H
  00318	48 98		 cdqe
  0031a	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00322	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR bsn$[rsp], rax

; 3826 :   ibi = &parameter_block[parameter_blocklen - 32];

  0032a	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0032e	83 e8 20	 sub	 eax, 32			; 00000020H
  00331	48 98		 cdqe
  00333	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0033b	48 89 44 24 38	 mov	 QWORD PTR ibi$[rsp], rax

; 3827 :   xts = &parameter_block[parameter_blocklen - 16];

  00340	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00344	83 e8 10	 sub	 eax, 16
  00347	48 98		 cdqe
  00349	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00351	48 89 44 24 60	 mov	 QWORD PTR xts$[rsp], rax

; 3828 : 
; 3829 : #ifdef OPTION_PCC_DEBUG
; 3830 :   LOGBYTE("k     :", parameter_block, keylen);
; 3831 :   if(wrap)
; 3832 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 32);
; 3833 :   LOGBYTE("tweak :", tweak, 16);
; 3834 :   LOGBYTE("bsn   :", bsn, 16);
; 3835 :   LOGBYTE("ibi   :", ibi, 16);
; 3836 :   LOGBYTE("xts   :", xts, 16);
; 3837 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3838 : 
; 3839 :   /* Verify and unwrap */
; 3840 :   if(wrap && unwrap_aes(parameter_block, keylen))

  00356	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0035b	74 26		 je	 SHORT $LN7@z900_pcc_x
  0035d	8b 54 24 40	 mov	 edx, DWORD PTR keylen$[rsp]
  00361	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00369	e8 00 00 00 00	 call	 unwrap_aes
  0036e	85 c0		 test	 eax, eax
  00370	74 11		 je	 SHORT $LN7@z900_pcc_x

; 3841 :   {
; 3842 : 
; 3843 : #ifdef OPTION_PCC_DEBUG
; 3844 :     WRMSG(HHC90111, "D");
; 3845 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3846 : 
; 3847 :     regs->psw.cc = 1;

  00372	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037a	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3848 :     return;

  0037e	e9 76 02 00 00	 jmp	 $LN1@z900_pcc_x
$LN7@z900_pcc_x:

; 3849 :   }
; 3850 : 
; 3851 :   /* Encrypt tweak */
; 3852 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  00383	8b 44 24 40	 mov	 eax, DWORD PTR keylen$[rsp]
  00387	c1 e0 03	 shl	 eax, 3
  0038a	44 8b c0	 mov	 r8d, eax
  0038d	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00395	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0039d	e8 00 00 00 00	 call	 rijndael_set_key

; 3853 :   rijndael_encrypt(&context, tweak, tweak);

  003a2	4c 8b 44 24 58	 mov	 r8, QWORD PTR tweak$[rsp]
  003a7	48 8b 54 24 58	 mov	 rdx, QWORD PTR tweak$[rsp]
  003ac	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  003b4	e8 00 00 00 00	 call	 rijndael_encrypt

; 3854 : 
; 3855 :   /* Check block sequential number (j) == 0 */
; 3856 :   if(!memcmp(bsn, zero, 16))

  003b9	41 b8 10 00 00
	00		 mov	 r8d, 16
  003bf	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR zero$[rsp]
  003c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bsn$[rsp]
  003cf	e8 00 00 00 00	 call	 memcmp
  003d4	85 c0		 test	 eax, eax
  003d6	75 36		 jne	 SHORT $LN8@z900_pcc_x

; 3857 :   {
; 3858 :     zeromem(ibi, 15);

  003d8	48 8b 7c 24 38	 mov	 rdi, QWORD PTR ibi$[rsp]
  003dd	33 c0		 xor	 eax, eax
  003df	b9 0f 00 00 00	 mov	 ecx, 15
  003e4	f3 aa		 rep stosb

; 3859 :     ibi[15] = 128;

  003e6	b8 01 00 00 00	 mov	 eax, 1
  003eb	48 6b c0 0f	 imul	 rax, rax, 15
  003ef	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  003f4	c6 04 01 80	 mov	 BYTE PTR [rcx+rax], 128	; 00000080H

; 3860 :     memcpy(xts, tweak, 16);

  003f8	48 8b 7c 24 60	 mov	 rdi, QWORD PTR xts$[rsp]
  003fd	48 8b 74 24 58	 mov	 rsi, QWORD PTR tweak$[rsp]
  00402	b9 10 00 00 00	 mov	 ecx, 16
  00407	f3 a4		 rep movsb

; 3861 :   }

  00409	e9 44 01 00 00	 jmp	 $LN9@z900_pcc_x
$LN8@z900_pcc_x:

; 3862 :   else
; 3863 :   {
; 3864 :     /* Check intermediate block index (t) > 127 */
; 3865 :     if(memcmp(ibi, zero, 15) || ibi[15] > 127)

  0040e	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00414	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR zero$[rsp]
  0041c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00421	e8 00 00 00 00	 call	 memcmp
  00426	85 c0		 test	 eax, eax
  00428	75 17		 jne	 SHORT $LN11@z900_pcc_x
  0042a	b8 01 00 00 00	 mov	 eax, 1
  0042f	48 6b c0 0f	 imul	 rax, rax, 15
  00433	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00438	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0043c	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0043f	7e 11		 jle	 SHORT $LN10@z900_pcc_x
$LN11@z900_pcc_x:

; 3866 :     {
; 3867 :       /* Invalid imtermediate block index, return with cc2 */
; 3868 :       regs->psw.cc = 2;

  00441	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00449	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 3869 :       return;

  0044d	e9 a7 01 00 00	 jmp	 $LN1@z900_pcc_x
$LN10@z900_pcc_x:

; 3870 :     }
; 3871 : 
; 3872 :     /* Intitial execution? */
; 3873 :     if(!ibi[15]) memcpy(xts, tweak, 16);

  00452	b8 01 00 00 00	 mov	 eax, 1
  00457	48 6b c0 0f	 imul	 rax, rax, 15
  0045b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00460	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00464	85 c0		 test	 eax, eax
  00466	75 11		 jne	 SHORT $LN12@z900_pcc_x
  00468	48 8b 7c 24 60	 mov	 rdi, QWORD PTR xts$[rsp]
  0046d	48 8b 74 24 58	 mov	 rsi, QWORD PTR tweak$[rsp]
  00472	b9 10 00 00 00	 mov	 ecx, 16
  00477	f3 a4		 rep movsb
$LN12@z900_pcc_x:
$LN4@z900_pcc_x:

; 3874 : 
; 3875 :     /* Calculate xts parameter */
; 3876 :     do
; 3877 :     {
; 3878 :       if(bsn[ibi[15] / 8] & mask[ibi[15] % 8])

  00479	b8 01 00 00 00	 mov	 eax, 1
  0047e	48 6b c0 0f	 imul	 rax, rax, 15
  00482	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00487	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0048b	99		 cdq
  0048c	83 e2 07	 and	 edx, 7
  0048f	03 c2		 add	 eax, edx
  00491	c1 f8 03	 sar	 eax, 3
  00494	48 98		 cdqe
  00496	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR bsn$[rsp]
  0049e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004a2	89 44 24 6c	 mov	 DWORD PTR tv292[rsp], eax
  004a6	b9 01 00 00 00	 mov	 ecx, 1
  004ab	48 6b c9 0f	 imul	 rcx, rcx, 15
  004af	48 8b 54 24 38	 mov	 rdx, QWORD PTR ibi$[rsp]
  004b4	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  004b8	8b c1		 mov	 eax, ecx
  004ba	99		 cdq
  004bb	83 e2 07	 and	 edx, 7
  004be	03 c2		 add	 eax, edx
  004c0	83 e0 07	 and	 eax, 7
  004c3	2b c2		 sub	 eax, edx
  004c5	48 98		 cdqe
  004c7	0f b6 84 04 80
	02 00 00	 movzx	 eax, BYTE PTR mask$[rsp+rax]
  004cf	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv292[rsp]
  004d3	23 c8		 and	 ecx, eax
  004d5	8b c1		 mov	 eax, ecx
  004d7	85 c0		 test	 eax, eax
  004d9	74 35		 je	 SHORT $LN13@z900_pcc_x

; 3879 :       {
; 3880 : #ifdef OPTION_PCC_DEBUG
; 3881 :         LOGBYTE("ibi   :", ibi, 16);
; 3882 :         LOGBYTE("xts   :", xts, 16);
; 3883 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3884 :         xts_gf_mult(xts, exp_table[ibi[15]], xts);

  004db	b8 01 00 00 00	 mov	 eax, 1
  004e0	48 6b c0 0f	 imul	 rax, rax, 15
  004e4	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  004e9	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004ed	48 6b c0 10	 imul	 rax, rax, 16
  004f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exp_table
  004f8	48 03 c8	 add	 rcx, rax
  004fb	48 8b c1	 mov	 rax, rcx
  004fe	4c 8b 44 24 60	 mov	 r8, QWORD PTR xts$[rsp]
  00503	48 8b d0	 mov	 rdx, rax
  00506	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xts$[rsp]
  0050b	e8 00 00 00 00	 call	 xts_gf_mult
$LN13@z900_pcc_x:

; 3885 :       }
; 3886 :       ibi[15]++;

  00510	b8 01 00 00 00	 mov	 eax, 1
  00515	48 6b c0 0f	 imul	 rax, rax, 15
  00519	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  0051e	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00522	fe c0		 inc	 al
  00524	b9 01 00 00 00	 mov	 ecx, 1
  00529	48 6b c9 0f	 imul	 rcx, rcx, 15
  0052d	48 8b 54 24 38	 mov	 rdx, QWORD PTR ibi$[rsp]
  00532	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3887 :     }
; 3888 :     while(ibi[15] != 128);

  00535	b8 01 00 00 00	 mov	 eax, 1
  0053a	48 6b c0 0f	 imul	 rax, rax, 15
  0053e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00543	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00547	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0054c	0f 85 27 ff ff
	ff		 jne	 $LN4@z900_pcc_x
$LN9@z900_pcc_x:

; 3889 :   }
; 3890 : 
; 3891 : #ifdef OPTION_PCC_DEBUG
; 3892 :   LOGBYTE("ibi   :", ibi, 16);
; 3893 :   LOGBYTE("xts   :", xts, 16);
; 3894 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3895 : 
; 3896 :   /* Store Intermediate Bit Index and XTS */
; 3897 :   ARCH_DEP(vstorec)(ibi, 31, (GR_A(1, regs) + parameter_blocklen - 32) & ADDRESS_MAXWRAP(regs), 1, regs);

  00552	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0055a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00560	83 e0 01	 and	 eax, 1
  00563	85 c0		 test	 eax, eax
  00565	74 23		 je	 SHORT $LN29@z900_pcc_x
  00567	b8 08 00 00 00	 mov	 eax, 8
  0056c	48 6b c0 01	 imul	 rax, rax, 1
  00570	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00578	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00580	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00588	eb 20		 jmp	 SHORT $LN30@z900_pcc_x
$LN29@z900_pcc_x:
  0058a	b8 08 00 00 00	 mov	 eax, 8
  0058f	48 6b c0 01	 imul	 rax, rax, 1
  00593	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059b	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  005a2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
$LN30@z900_pcc_x:
  005aa	48 63 44 24 30	 movsxd	 rax, DWORD PTR parameter_blocklen$[rsp]
  005af	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv336[rsp]
  005b7	48 8d 44 01 e0	 lea	 rax, QWORD PTR [rcx+rax-32]
  005bc	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c4	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  005cb	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005d3	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005d8	41 b9 01 00 00
	00		 mov	 r9d, 1
  005de	4c 8b c0	 mov	 r8, rax
  005e1	b2 1f		 mov	 dl, 31
  005e3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  005e8	e8 00 00 00 00	 call	 z900_vstorec

; 3898 : 
; 3899 :   /* Normal completion */
; 3900 :   regs->psw.cc = 0;

  005ed	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005f5	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_pcc_x:

; 3901 : }

  005f9	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00601	48 33 cc	 xor	 rcx, rsp
  00604	e8 00 00 00 00	 call	 __security_check_cookie
  00609	48 81 c4 38 03
	00 00		 add	 rsp, 824		; 00000338H
  00610	5f		 pop	 rdi
  00611	5e		 pop	 rsi
  00612	c3		 ret	 0
z900_pcc_xts_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
tv70 = 60
tv81 = 64
tv161 = 68
wrap$ = 72
tfc$ = 76
tv494 = 80
tv256 = 84
tv287 = 88
tv184 = 96
tv203 = 104
$T1 = 112
tv417 = 120
tv239 = 128
tv267 = 136
context$ = 144
mask$ = 640
r128$ = 648
k$ = 664
parameter_block$ = 688
__$ArrayPad$ = 800
regs$ = 832
z900_pcc_cmac_aes PROC

; 3664 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 30 03
	00 00		 sub	 rsp, 816		; 00000330H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3665 :   rijndael_ctx context;
; 3666 :   int i;
; 3667 :   BYTE k[16];
; 3668 :   int keylen;
; 3669 :   BYTE mask[8] = { 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };

  0001f	c6 84 24 80 02
	00 00 80	 mov	 BYTE PTR mask$[rsp], 128 ; 00000080H
  00027	c6 84 24 81 02
	00 00 c0	 mov	 BYTE PTR mask$[rsp+1], 192 ; 000000c0H
  0002f	c6 84 24 82 02
	00 00 e0	 mov	 BYTE PTR mask$[rsp+2], 224 ; 000000e0H
  00037	c6 84 24 83 02
	00 00 f0	 mov	 BYTE PTR mask$[rsp+3], 240 ; 000000f0H
  0003f	c6 84 24 84 02
	00 00 f8	 mov	 BYTE PTR mask$[rsp+4], 248 ; 000000f8H
  00047	c6 84 24 85 02
	00 00 fc	 mov	 BYTE PTR mask$[rsp+5], 252 ; 000000fcH
  0004f	c6 84 24 86 02
	00 00 fe	 mov	 BYTE PTR mask$[rsp+6], 254 ; 000000feH
  00057	c6 84 24 87 02
	00 00 ff	 mov	 BYTE PTR mask$[rsp+7], 255 ; 000000ffH

; 3670 :   BYTE parameter_block[104];
; 3671 :   int parameter_blocklen;
; 3672 :   BYTE r128[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87 };

  0005f	c6 84 24 88 02
	00 00 00	 mov	 BYTE PTR r128$[rsp], 0
  00067	c6 84 24 89 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+1], 0
  0006f	c6 84 24 8a 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+2], 0
  00077	c6 84 24 8b 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+3], 0
  0007f	c6 84 24 8c 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+4], 0
  00087	c6 84 24 8d 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+5], 0
  0008f	c6 84 24 8e 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+6], 0
  00097	c6 84 24 8f 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+7], 0
  0009f	c6 84 24 90 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+8], 0
  000a7	c6 84 24 91 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+9], 0
  000af	c6 84 24 92 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+10], 0
  000b7	c6 84 24 93 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+11], 0
  000bf	c6 84 24 94 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+12], 0
  000c7	c6 84 24 95 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+13], 0
  000cf	c6 84 24 96 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+14], 0
  000d7	c6 84 24 97 02
	00 00 87	 mov	 BYTE PTR r128$[rsp+15], 135 ; 00000087H

; 3673 :   int tfc;
; 3674 :   int wrap;
; 3675 : 
; 3676 :   /* Check special conditions */
; 3677 :   if(unlikely(GR0_m(regs)))

  000df	b8 08 00 00 00	 mov	 eax, 8
  000e4	48 6b c0 00	 imul	 rax, rax, 0
  000e8	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fc	85 c0		 test	 eax, eax
  000fe	74 0a		 je	 SHORT $LN26@z900_pcc_c
  00100	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00108	eb 08		 jmp	 SHORT $LN27@z900_pcc_c
$LN26@z900_pcc_c:
  0010a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN27@z900_pcc_c:
  00112	83 7c 24 3c 00	 cmp	 DWORD PTR tv70[rsp], 0
  00117	74 0a		 je	 SHORT $LN32@z900_pcc_c
  00119	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00121	eb 08		 jmp	 SHORT $LN33@z900_pcc_c
$LN32@z900_pcc_c:
  00123	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN33@z900_pcc_c:
  0012b	83 7c 24 40 00	 cmp	 DWORD PTR tv81[rsp], 0
  00130	74 13		 je	 SHORT $LN14@z900_pcc_c

; 3678 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN14@z900_pcc_c:

; 3679 : 
; 3680 :   /* Initialize values */
; 3681 :   tfc = GR0_tfc(regs);

  00145	b8 08 00 00 00	 mov	 eax, 8
  0014a	48 6b c0 00	 imul	 rax, rax, 0
  0014e	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0015d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00160	83 e0 77	 and	 eax, 119		; 00000077H
  00163	89 44 24 4c	 mov	 DWORD PTR tfc$[rsp], eax

; 3682 :   wrap = GR0_wrap(regs);

  00167	b8 08 00 00 00	 mov	 eax, 8
  0016c	48 6b c0 00	 imul	 rax, rax, 0
  00170	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017f	83 e0 08	 and	 eax, 8
  00182	85 c0		 test	 eax, eax
  00184	74 0a		 je	 SHORT $LN34@z900_pcc_c
  00186	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0018e	eb 08		 jmp	 SHORT $LN35@z900_pcc_c
$LN34@z900_pcc_c:
  00190	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN35@z900_pcc_c:
  00198	8b 44 24 44	 mov	 eax, DWORD PTR tv161[rsp]
  0019c	89 44 24 48	 mov	 DWORD PTR wrap$[rsp], eax

; 3683 :   keylen = (tfc - 17) * 8 + 8;

  001a0	8b 44 24 4c	 mov	 eax, DWORD PTR tfc$[rsp]
  001a4	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  001ab	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 3684 :   parameter_blocklen = keylen + 40;

  001af	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  001b3	83 c0 28	 add	 eax, 40			; 00000028H
  001b6	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3685 :   if(wrap)

  001ba	83 7c 24 48 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001bf	74 0b		 je	 SHORT $LN15@z900_pcc_c

; 3686 :     parameter_blocklen += 32;

  001c1	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001c5	83 c0 20	 add	 eax, 32			; 00000020H
  001c8	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN15@z900_pcc_c:

; 3687 : 
; 3688 :   /* Test writeability output chaining value */
; 3689 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + 24) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  001cc	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001d4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001da	83 e0 01	 and	 eax, 1
  001dd	85 c0		 test	 eax, eax
  001df	74 20		 je	 SHORT $LN36@z900_pcc_c
  001e1	b8 08 00 00 00	 mov	 eax, 8
  001e6	48 6b c0 01	 imul	 rax, rax, 1
  001ea	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f2	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  001fa	48 89 44 24 60	 mov	 QWORD PTR tv184[rsp], rax
  001ff	eb 1d		 jmp	 SHORT $LN37@z900_pcc_c
$LN36@z900_pcc_c:
  00201	b8 08 00 00 00	 mov	 eax, 8
  00206	48 6b c0 01	 imul	 rax, rax, 1
  0020a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00212	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00219	48 89 44 24 60	 mov	 QWORD PTR tv184[rsp], rax
$LN37@z900_pcc_c:
  0021e	48 8b 44 24 60	 mov	 rax, QWORD PTR tv184[rsp]
  00223	48 83 c0 18	 add	 rax, 24
  00227	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022f	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00236	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00243	41 b9 02 00 00
	00		 mov	 r9d, 2
  00249	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0024f	ba 01 00 00 00	 mov	 edx, 1
  00254	48 8b c8	 mov	 rcx, rax
  00257	e8 00 00 00 00	 call	 z900_validate_operand

; 3690 : 
; 3691 :   /* Fetch the parameter block */
; 3692 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0025c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00264	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0026a	83 e0 01	 and	 eax, 1
  0026d	85 c0		 test	 eax, eax
  0026f	74 20		 je	 SHORT $LN38@z900_pcc_c
  00271	b8 08 00 00 00	 mov	 eax, 8
  00276	48 6b c0 01	 imul	 rax, rax, 1
  0027a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00282	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0028a	48 89 44 24 68	 mov	 QWORD PTR tv203[rsp], rax
  0028f	eb 1d		 jmp	 SHORT $LN39@z900_pcc_c
$LN38@z900_pcc_c:
  00291	b8 08 00 00 00	 mov	 eax, 8
  00296	48 6b c0 01	 imul	 rax, rax, 1
  0029a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002a9	48 89 44 24 68	 mov	 QWORD PTR tv203[rsp], rax
$LN39@z900_pcc_c:
  002ae	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b6	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002bd	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv203[rsp]
  002c2	48 23 c8	 and	 rcx, rax
  002c5	48 8b c1	 mov	 rax, rcx
  002c8	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  002cc	ff c9		 dec	 ecx
  002ce	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d6	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002db	41 b9 01 00 00
	00		 mov	 r9d, 1
  002e1	4c 8b c0	 mov	 r8, rax
  002e4	0f b6 d1	 movzx	 edx, cl
  002e7	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  002ef	e8 00 00 00 00	 call	 z900_vfetchc

; 3693 : 
; 3694 : #ifdef OPTION_PCC_DEBUG
; 3695 :   LOGBYTE("ml    :", parameter_block, 1);
; 3696 :   LOGBYTE("msg   :", &parameter_block[8], 16);
; 3697 :   LOGBYTE("icv   :", &parameter_block[24], 16);
; 3698 :   LOGBYTE("k     :", &parameter_block[40], keylen);
; 3699 :   if(wrap)
; 3700 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 40], 32);
; 3701 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3702 : 
; 3703 :   /* Verify and unwrap */
; 3704 :   if(wrap && unwrap_aes(&parameter_block[40], keylen))

  002f4	83 7c 24 48 00	 cmp	 DWORD PTR wrap$[rsp], 0
  002f9	74 32		 je	 SHORT $LN16@z900_pcc_c
  002fb	b8 01 00 00 00	 mov	 eax, 1
  00300	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00304	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0030c	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  00310	48 8b c8	 mov	 rcx, rax
  00313	e8 00 00 00 00	 call	 unwrap_aes
  00318	85 c0		 test	 eax, eax
  0031a	74 11		 je	 SHORT $LN16@z900_pcc_c

; 3705 :   {
; 3706 : 
; 3707 : #ifdef OPTION_PCC_DEBUG
; 3708 :     WRMSG(HHC90111, "D");
; 3709 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3710 : 
; 3711 :     regs->psw.cc = 1;

  0031c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00324	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3712 :     return;

  00328	e9 ef 04 00 00	 jmp	 $LN1@z900_pcc_c
$LN16@z900_pcc_c:

; 3713 :   }
; 3714 : 
; 3715 :   /* Set the cryptographic key */
; 3716 :   rijndael_set_key(&context, &parameter_block[40], keylen * 8);

  0032d	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00331	c1 e0 03	 shl	 eax, 3
  00334	b9 01 00 00 00	 mov	 ecx, 1
  00339	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  0033d	48 8d 8c 0c b0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00345	44 8b c0	 mov	 r8d, eax
  00348	48 8b d1	 mov	 rdx, rcx
  0034b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00353	e8 00 00 00 00	 call	 rijndael_set_key

; 3717 : 
; 3718 :   /* Check validity ML value */
; 3719 :   if(parameter_block[0] > 128)

  00358	b8 01 00 00 00	 mov	 eax, 1
  0035d	48 6b c0 00	 imul	 rax, rax, 0
  00361	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00369	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0036e	7e 11		 jle	 SHORT $LN17@z900_pcc_c

; 3720 :   {
; 3721 :     regs->psw.cc = 2;

  00370	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00378	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 3722 :     return;

  0037c	e9 9b 04 00 00	 jmp	 $LN1@z900_pcc_c
$LN17@z900_pcc_c:

; 3723 :   }
; 3724 : 
; 3725 :   /* Place the one bit */
; 3726 :   if(parameter_block[0] != 128)

  00381	b8 01 00 00 00	 mov	 eax, 1
  00386	48 6b c0 00	 imul	 rax, rax, 0
  0038a	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00392	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00397	0f 84 9b 00 00
	00		 je	 $LN18@z900_pcc_c

; 3727 :     parameter_block[(parameter_block[0] / 8) + 8] |= (0x80 >> (parameter_block[0] % 8));

  0039d	b8 01 00 00 00	 mov	 eax, 1
  003a2	48 6b c0 00	 imul	 rax, rax, 0
  003a6	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  003ae	99		 cdq
  003af	83 e2 07	 and	 edx, 7
  003b2	03 c2		 add	 eax, edx
  003b4	c1 f8 03	 sar	 eax, 3
  003b7	83 c0 08	 add	 eax, 8
  003ba	48 98		 cdqe
  003bc	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv239[rsp], rax
  003c4	b9 01 00 00 00	 mov	 ecx, 1
  003c9	48 6b c9 00	 imul	 rcx, rcx, 0
  003cd	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003d5	8b c1		 mov	 eax, ecx
  003d7	99		 cdq
  003d8	83 e2 07	 and	 edx, 7
  003db	03 c2		 add	 eax, edx
  003dd	83 e0 07	 and	 eax, 7
  003e0	2b c2		 sub	 eax, edx
  003e2	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  003e7	89 4c 24 50	 mov	 DWORD PTR tv494[rsp], ecx
  003eb	0f b6 c8	 movzx	 ecx, al
  003ee	8b 44 24 50	 mov	 eax, DWORD PTR tv494[rsp]
  003f2	d3 f8		 sar	 eax, cl
  003f4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv239[rsp]
  003fc	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00404	0b c8		 or	 ecx, eax
  00406	8b c1		 mov	 eax, ecx
  00408	89 44 24 54	 mov	 DWORD PTR tv256[rsp], eax
  0040c	b9 01 00 00 00	 mov	 ecx, 1
  00411	48 6b c9 00	 imul	 rcx, rcx, 0
  00415	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0041d	8b c1		 mov	 eax, ecx
  0041f	99		 cdq
  00420	83 e2 07	 and	 edx, 7
  00423	03 c2		 add	 eax, edx
  00425	c1 f8 03	 sar	 eax, 3
  00428	83 c0 08	 add	 eax, 8
  0042b	48 98		 cdqe
  0042d	8b 4c 24 54	 mov	 ecx, DWORD PTR tv256[rsp]
  00431	88 8c 04 b0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl
$LN18@z900_pcc_c:

; 3728 : 
; 3729 :   /* Pad with zeroes */
; 3730 :   if(parameter_block[0] < 127)

  00438	b8 01 00 00 00	 mov	 eax, 1
  0043d	48 6b c0 00	 imul	 rax, rax, 0
  00441	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00449	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0044c	0f 8d f2 00 00
	00		 jge	 $LN19@z900_pcc_c

; 3731 :   {
; 3732 :     parameter_block[(parameter_block[0] / 8) + 8] &= mask[parameter_block[0] % 8];

  00452	b8 01 00 00 00	 mov	 eax, 1
  00457	48 6b c0 00	 imul	 rax, rax, 0
  0045b	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00463	99		 cdq
  00464	83 e2 07	 and	 edx, 7
  00467	03 c2		 add	 eax, edx
  00469	c1 f8 03	 sar	 eax, 3
  0046c	83 c0 08	 add	 eax, 8
  0046f	48 98		 cdqe
  00471	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv267[rsp], rax
  00479	b9 01 00 00 00	 mov	 ecx, 1
  0047e	48 6b c9 00	 imul	 rcx, rcx, 0
  00482	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0048a	8b c1		 mov	 eax, ecx
  0048c	99		 cdq
  0048d	83 e2 07	 and	 edx, 7
  00490	03 c2		 add	 eax, edx
  00492	83 e0 07	 and	 eax, 7
  00495	2b c2		 sub	 eax, edx
  00497	48 98		 cdqe
  00499	0f b6 84 04 80
	02 00 00	 movzx	 eax, BYTE PTR mask$[rsp+rax]
  004a1	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv267[rsp]
  004a9	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  004b1	23 c8		 and	 ecx, eax
  004b3	8b c1		 mov	 eax, ecx
  004b5	89 44 24 58	 mov	 DWORD PTR tv287[rsp], eax
  004b9	b9 01 00 00 00	 mov	 ecx, 1
  004be	48 6b c9 00	 imul	 rcx, rcx, 0
  004c2	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  004ca	8b c1		 mov	 eax, ecx
  004cc	99		 cdq
  004cd	83 e2 07	 and	 edx, 7
  004d0	03 c2		 add	 eax, edx
  004d2	c1 f8 03	 sar	 eax, 3
  004d5	83 c0 08	 add	 eax, 8
  004d8	48 98		 cdqe
  004da	8b 4c 24 58	 mov	 ecx, DWORD PTR tv287[rsp]
  004de	88 8c 04 b0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl

; 3733 :     for(i = (parameter_block[0] / 8) + 1; i < 16; i++)

  004e5	b8 01 00 00 00	 mov	 eax, 1
  004ea	48 6b c0 00	 imul	 rax, rax, 0
  004ee	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  004f6	99		 cdq
  004f7	83 e2 07	 and	 edx, 7
  004fa	03 c2		 add	 eax, edx
  004fc	c1 f8 03	 sar	 eax, 3
  004ff	ff c0		 inc	 eax
  00501	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00505	eb 0a		 jmp	 SHORT $LN4@z900_pcc_c
$LN2@z900_pcc_c:
  00507	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0050b	ff c0		 inc	 eax
  0050d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_pcc_c:
  00511	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00516	7d 2c		 jge	 SHORT $LN3@z900_pcc_c

; 3734 :       parameter_block[i + 8] = 0x00;

  00518	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0051c	83 c0 08	 add	 eax, 8
  0051f	48 98		 cdqe
  00521	48 89 44 24 70	 mov	 QWORD PTR $T1[rsp], rax
  00526	48 83 7c 24 70
	68		 cmp	 QWORD PTR $T1[rsp], 104	; 00000068H
  0052c	73 02		 jae	 SHORT $LN40@z900_pcc_c
  0052e	eb 05		 jmp	 SHORT $LN41@z900_pcc_c
$LN40@z900_pcc_c:
  00530	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN41@z900_pcc_c:
  00535	48 8b 44 24 70	 mov	 rax, QWORD PTR $T1[rsp]
  0053a	c6 84 04 b0 02
	00 00 00	 mov	 BYTE PTR parameter_block$[rsp+rax], 0
  00542	eb c3		 jmp	 SHORT $LN2@z900_pcc_c
$LN3@z900_pcc_c:
$LN19@z900_pcc_c:

; 3735 :   }
; 3736 : 
; 3737 : #ifdef OPTION_PCC_DEBUG
; 3738 :   LOGBYTE("msg   :", &parameter_block[8], 16);
; 3739 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3740 : 
; 3741 :   /* Calculate subkeys */
; 3742 :   zeromem(k, 16);

  00544	48 8d 84 24 98
	02 00 00	 lea	 rax, QWORD PTR k$[rsp]
  0054c	48 8b f8	 mov	 rdi, rax
  0054f	33 c0		 xor	 eax, eax
  00551	b9 10 00 00 00	 mov	 ecx, 16
  00556	f3 aa		 rep stosb

; 3743 :   rijndael_encrypt(&context, k, k);

  00558	4c 8d 84 24 98
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  00560	48 8d 94 24 98
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00568	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00570	e8 00 00 00 00	 call	 rijndael_encrypt

; 3744 : 
; 3745 :   /* Calculate subkeys Kx and Ky */
; 3746 :   if(!(k[0] & 0x80))

  00575	b8 01 00 00 00	 mov	 eax, 1
  0057a	48 6b c0 00	 imul	 rax, rax, 0
  0057e	0f b6 84 04 98
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00586	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0058b	85 c0		 test	 eax, eax
  0058d	75 1d		 jne	 SHORT $LN20@z900_pcc_c

; 3747 :     shift_left(k, k, 16);

  0058f	41 b8 10 00 00
	00		 mov	 r8d, 16
  00595	48 8d 94 24 98
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0059d	48 8d 8c 24 98
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  005a5	e8 00 00 00 00	 call	 shift_left
  005aa	eb 60		 jmp	 SHORT $LN21@z900_pcc_c
$LN20@z900_pcc_c:

; 3748 :   else
; 3749 :   {
; 3750 :     shift_left(k, k, 16);

  005ac	41 b8 10 00 00
	00		 mov	 r8d, 16
  005b2	48 8d 94 24 98
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  005ba	48 8d 8c 24 98
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  005c2	e8 00 00 00 00	 call	 shift_left

; 3751 :     for(i = 0; i < 16; i++)

  005c7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005cf	eb 0a		 jmp	 SHORT $LN7@z900_pcc_c
$LN5@z900_pcc_c:
  005d1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005d5	ff c0		 inc	 eax
  005d7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_pcc_c:
  005db	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  005e0	7d 2a		 jge	 SHORT $LN6@z900_pcc_c

; 3752 :       k[i] ^= r128[i];

  005e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005e7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005ec	0f b6 8c 0c 88
	02 00 00	 movzx	 ecx, BYTE PTR r128$[rsp+rcx]
  005f4	0f b6 84 04 98
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  005fc	33 c1		 xor	 eax, ecx
  005fe	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00603	88 84 0c 98 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  0060a	eb c5		 jmp	 SHORT $LN5@z900_pcc_c
$LN6@z900_pcc_c:
$LN21@z900_pcc_c:

; 3753 :   }
; 3754 :   if(parameter_block[0] != 128)

  0060c	b8 01 00 00 00	 mov	 eax, 1
  00611	48 6b c0 00	 imul	 rax, rax, 0
  00615	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0061d	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00622	0f 84 97 00 00
	00		 je	 $LN22@z900_pcc_c

; 3755 :   {
; 3756 :     if(!(k[0] & 0x80))

  00628	b8 01 00 00 00	 mov	 eax, 1
  0062d	48 6b c0 00	 imul	 rax, rax, 0
  00631	0f b6 84 04 98
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00639	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0063e	85 c0		 test	 eax, eax
  00640	75 1d		 jne	 SHORT $LN23@z900_pcc_c

; 3757 :       shift_left(k, k, 16);

  00642	41 b8 10 00 00
	00		 mov	 r8d, 16
  00648	48 8d 94 24 98
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00650	48 8d 8c 24 98
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00658	e8 00 00 00 00	 call	 shift_left
  0065d	eb 60		 jmp	 SHORT $LN24@z900_pcc_c
$LN23@z900_pcc_c:

; 3758 :     else
; 3759 :     {
; 3760 :       shift_left(k, k, 16);

  0065f	41 b8 10 00 00
	00		 mov	 r8d, 16
  00665	48 8d 94 24 98
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0066d	48 8d 8c 24 98
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00675	e8 00 00 00 00	 call	 shift_left

; 3761 :       for(i = 0; i < 16; i++)

  0067a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00682	eb 0a		 jmp	 SHORT $LN10@z900_pcc_c
$LN8@z900_pcc_c:
  00684	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00688	ff c0		 inc	 eax
  0068a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_pcc_c:
  0068e	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00693	7d 2a		 jge	 SHORT $LN9@z900_pcc_c

; 3762 :         k[i] ^= r128[i];

  00695	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0069a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0069f	0f b6 8c 0c 88
	02 00 00	 movzx	 ecx, BYTE PTR r128$[rsp+rcx]
  006a7	0f b6 84 04 98
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  006af	33 c1		 xor	 eax, ecx
  006b1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006b6	88 84 0c 98 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  006bd	eb c5		 jmp	 SHORT $LN8@z900_pcc_c
$LN9@z900_pcc_c:
$LN24@z900_pcc_c:
$LN22@z900_pcc_c:

; 3763 :     }
; 3764 :   }
; 3765 : 
; 3766 : #ifdef OPTION_PCC_DEBUG
; 3767 :   LOGBYTE("Subkey:", k, 16);
; 3768 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3769 : 
; 3770 :   /* XOR with kx or ky and encrypt */
; 3771 :   for(i = 0; i < 16; i++)

  006bf	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006c7	eb 0a		 jmp	 SHORT $LN13@z900_pcc_c
$LN11@z900_pcc_c:
  006c9	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006cd	ff c0		 inc	 eax
  006cf	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_pcc_c:
  006d3	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  006d8	7d 69		 jge	 SHORT $LN12@z900_pcc_c

; 3772 :   {
; 3773 :     parameter_block[i + 8] ^= k[i];

  006da	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006de	83 c0 08	 add	 eax, 8
  006e1	48 98		 cdqe
  006e3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006e8	0f b6 8c 0c 98
	02 00 00	 movzx	 ecx, BYTE PTR k$[rsp+rcx]
  006f0	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  006f8	33 c1		 xor	 eax, ecx
  006fa	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  006fe	83 c1 08	 add	 ecx, 8
  00701	48 63 c9	 movsxd	 rcx, ecx
  00704	88 84 0c b0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3774 :     parameter_block[i + 8] ^= parameter_block[i + 24];

  0070b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0070f	83 c0 08	 add	 eax, 8
  00712	48 98		 cdqe
  00714	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00718	83 c1 18	 add	 ecx, 24
  0071b	48 63 c9	 movsxd	 rcx, ecx
  0071e	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00726	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0072e	33 c1		 xor	 eax, ecx
  00730	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00734	83 c1 08	 add	 ecx, 8
  00737	48 63 c9	 movsxd	 rcx, ecx
  0073a	88 84 0c b0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3775 :   }

  00741	eb 86		 jmp	 SHORT $LN11@z900_pcc_c
$LN12@z900_pcc_c:

; 3776 :   rijndael_encrypt(&context, &parameter_block[8], &parameter_block[8]);

  00743	b8 01 00 00 00	 mov	 eax, 1
  00748	48 6b c0 08	 imul	 rax, rax, 8
  0074c	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00754	b9 01 00 00 00	 mov	 ecx, 1
  00759	48 6b c9 08	 imul	 rcx, rcx, 8
  0075d	48 8d 8c 0c b0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00765	4c 8b c0	 mov	 r8, rax
  00768	48 8b d1	 mov	 rdx, rcx
  0076b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00773	e8 00 00 00 00	 call	 rijndael_encrypt

; 3777 : 
; 3778 : #ifdef OPTION_PCC_DEBUG
; 3779 :   LOGBYTE("cmac  :", &parameter_block[8], 16);
; 3780 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3781 : 
; 3782 :   /* Store the CMAC */
; 3783 :   ARCH_DEP(vstorec)(&parameter_block[8], 15, (GR_A(1, regs) + 24) & ADDRESS_MAXWRAP(regs), 1, regs);

  00778	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00780	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00786	83 e0 01	 and	 eax, 1
  00789	85 c0		 test	 eax, eax
  0078b	74 20		 je	 SHORT $LN42@z900_pcc_c
  0078d	b8 08 00 00 00	 mov	 eax, 8
  00792	48 6b c0 01	 imul	 rax, rax, 1
  00796	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079e	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  007a6	48 89 44 24 78	 mov	 QWORD PTR tv417[rsp], rax
  007ab	eb 1d		 jmp	 SHORT $LN43@z900_pcc_c
$LN42@z900_pcc_c:
  007ad	b8 08 00 00 00	 mov	 eax, 8
  007b2	48 6b c0 01	 imul	 rax, rax, 1
  007b6	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007be	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  007c5	48 89 44 24 78	 mov	 QWORD PTR tv417[rsp], rax
$LN43@z900_pcc_c:
  007ca	48 8b 44 24 78	 mov	 rax, QWORD PTR tv417[rsp]
  007cf	48 83 c0 18	 add	 rax, 24
  007d3	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007db	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  007e2	b9 01 00 00 00	 mov	 ecx, 1
  007e7	48 6b c9 08	 imul	 rcx, rcx, 8
  007eb	48 8d 8c 0c b0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  007f3	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007fb	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00800	41 b9 01 00 00
	00		 mov	 r9d, 1
  00806	4c 8b c0	 mov	 r8, rax
  00809	b2 0f		 mov	 dl, 15
  0080b	e8 00 00 00 00	 call	 z900_vstorec

; 3784 : 
; 3785 :   /* Normal completion */
; 3786 :   regs->psw.cc = 0;

  00810	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00818	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_pcc_c:
$LN25@z900_pcc_c:

; 3787 : }

  0081c	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00824	48 33 cc	 xor	 rcx, rsp
  00827	e8 00 00 00 00	 call	 __security_check_cookie
  0082c	48 81 c4 30 03
	00 00		 add	 rsp, 816		; 00000330H
  00833	5f		 pop	 rdi
  00834	c3		 ret	 0
z900_pcc_cmac_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
tfc$ = 52
parameter_blocklen$ = 56
tv217 = 60
tv320 = 64
tv438 = 68
tv70 = 72
tv81 = 76
tv161 = 80
wrap$ = 84
keylen$ = 88
tv587 = 92
tv276 = 96
tv307 = 100
tv182 = 104
tv201 = 112
$T1 = 120
tv505 = 128
tv259 = 136
tv287 = 144
context1$ = 160
context2$ = 304
context3$ = 448
k$ = 592
r64$ = 600
mask$ = 608
parameter_block$ = 624
__$ArrayPad$ = 704
regs$ = 736
z900_pcc_cmac_dea PROC

; 3451 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec d0 02
	00 00		 sub	 rsp, 720		; 000002d0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3452 :   des_context context1;
; 3453 :   des_context context2;
; 3454 :   des_context context3;
; 3455 :   int i;
; 3456 :   BYTE k[8];
; 3457 :   int keylen;
; 3458 :   BYTE mask[8] = { 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };

  0001f	c6 84 24 60 02
	00 00 80	 mov	 BYTE PTR mask$[rsp], 128 ; 00000080H
  00027	c6 84 24 61 02
	00 00 c0	 mov	 BYTE PTR mask$[rsp+1], 192 ; 000000c0H
  0002f	c6 84 24 62 02
	00 00 e0	 mov	 BYTE PTR mask$[rsp+2], 224 ; 000000e0H
  00037	c6 84 24 63 02
	00 00 f0	 mov	 BYTE PTR mask$[rsp+3], 240 ; 000000f0H
  0003f	c6 84 24 64 02
	00 00 f8	 mov	 BYTE PTR mask$[rsp+4], 248 ; 000000f8H
  00047	c6 84 24 65 02
	00 00 fc	 mov	 BYTE PTR mask$[rsp+5], 252 ; 000000fcH
  0004f	c6 84 24 66 02
	00 00 fe	 mov	 BYTE PTR mask$[rsp+6], 254 ; 000000feH
  00057	c6 84 24 67 02
	00 00 ff	 mov	 BYTE PTR mask$[rsp+7], 255 ; 000000ffH

; 3459 :   BYTE parameter_block[72];
; 3460 :   int parameter_blocklen;
; 3461 :   BYTE r64[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b };

  0005f	c6 84 24 58 02
	00 00 00	 mov	 BYTE PTR r64$[rsp], 0
  00067	c6 84 24 59 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+1], 0
  0006f	c6 84 24 5a 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+2], 0
  00077	c6 84 24 5b 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+3], 0
  0007f	c6 84 24 5c 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+4], 0
  00087	c6 84 24 5d 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+5], 0
  0008f	c6 84 24 5e 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+6], 0
  00097	c6 84 24 5f 02
	00 00 1b	 mov	 BYTE PTR r64$[rsp+7], 27

; 3462 :   int tfc;
; 3463 :   int wrap;
; 3464 : 
; 3465 :   /* Check special conditions */
; 3466 :   if(unlikely(GR0_m(regs)))

  0009f	b8 08 00 00 00	 mov	 eax, 8
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000b7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN41@z900_pcc_c
  000c0	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN42@z900_pcc_c
$LN41@z900_pcc_c:
  000ca	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN42@z900_pcc_c:
  000d2	83 7c 24 48 00	 cmp	 DWORD PTR tv70[rsp], 0
  000d7	74 0a		 je	 SHORT $LN47@z900_pcc_c
  000d9	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  000e1	eb 08		 jmp	 SHORT $LN48@z900_pcc_c
$LN47@z900_pcc_c:
  000e3	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN48@z900_pcc_c:
  000eb	83 7c 24 4c 00	 cmp	 DWORD PTR tv81[rsp], 0
  000f0	74 13		 je	 SHORT $LN20@z900_pcc_c

; 3467 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000f2	ba 06 00 00 00	 mov	 edx, 6
  000f7	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_pcc_c:

; 3468 : 
; 3469 :   /* Initialize values */
; 3470 :   tfc = GR0_tfc(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 00	 imul	 rax, rax, 0
  0010e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00120	83 e0 77	 and	 eax, 119		; 00000077H
  00123	89 44 24 34	 mov	 DWORD PTR tfc$[rsp], eax

; 3471 :   wrap = GR0_wrap(regs);

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 00	 imul	 rax, rax, 0
  00130	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0013f	83 e0 08	 and	 eax, 8
  00142	85 c0		 test	 eax, eax
  00144	74 0a		 je	 SHORT $LN49@z900_pcc_c
  00146	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0014e	eb 08		 jmp	 SHORT $LN50@z900_pcc_c
$LN49@z900_pcc_c:
  00150	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN50@z900_pcc_c:
  00158	8b 44 24 50	 mov	 eax, DWORD PTR tv161[rsp]
  0015c	89 44 24 54	 mov	 DWORD PTR wrap$[rsp], eax

; 3472 :   keylen = tfc * 8;

  00160	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  00164	c1 e0 03	 shl	 eax, 3
  00167	89 44 24 58	 mov	 DWORD PTR keylen$[rsp], eax

; 3473 :   parameter_blocklen = keylen + 24;

  0016b	8b 44 24 58	 mov	 eax, DWORD PTR keylen$[rsp]
  0016f	83 c0 18	 add	 eax, 24
  00172	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3474 :   if(wrap)

  00176	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0017b	74 0b		 je	 SHORT $LN21@z900_pcc_c

; 3475 :     parameter_blocklen += 24;

  0017d	8b 44 24 38	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00181	83 c0 18	 add	 eax, 24
  00184	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN21@z900_pcc_c:

; 3476 : 
; 3477 :   /* Test writeability output chaining value */
; 3478 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + 16) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  00188	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00196	83 e0 01	 and	 eax, 1
  00199	85 c0		 test	 eax, eax
  0019b	74 20		 je	 SHORT $LN51@z900_pcc_c
  0019d	b8 08 00 00 00	 mov	 eax, 8
  001a2	48 6b c0 01	 imul	 rax, rax, 1
  001a6	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  001b6	48 89 44 24 68	 mov	 QWORD PTR tv182[rsp], rax
  001bb	eb 1d		 jmp	 SHORT $LN52@z900_pcc_c
$LN51@z900_pcc_c:
  001bd	b8 08 00 00 00	 mov	 eax, 8
  001c2	48 6b c0 01	 imul	 rax, rax, 1
  001c6	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ce	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001d5	48 89 44 24 68	 mov	 QWORD PTR tv182[rsp], rax
$LN52@z900_pcc_c:
  001da	48 8b 44 24 68	 mov	 rax, QWORD PTR tv182[rsp]
  001df	48 83 c0 10	 add	 rax, 16
  001e3	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001eb	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  001f2	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fa	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001ff	41 b9 02 00 00
	00		 mov	 r9d, 2
  00205	41 b8 07 00 00
	00		 mov	 r8d, 7
  0020b	ba 01 00 00 00	 mov	 edx, 1
  00210	48 8b c8	 mov	 rcx, rax
  00213	e8 00 00 00 00	 call	 z900_validate_operand

; 3479 : 
; 3480 :   /* Fetch the parameter block */
; 3481 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00218	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00220	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00226	83 e0 01	 and	 eax, 1
  00229	85 c0		 test	 eax, eax
  0022b	74 20		 je	 SHORT $LN53@z900_pcc_c
  0022d	b8 08 00 00 00	 mov	 eax, 8
  00232	48 6b c0 01	 imul	 rax, rax, 1
  00236	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00246	48 89 44 24 70	 mov	 QWORD PTR tv201[rsp], rax
  0024b	eb 1d		 jmp	 SHORT $LN54@z900_pcc_c
$LN53@z900_pcc_c:
  0024d	b8 08 00 00 00	 mov	 eax, 8
  00252	48 6b c0 01	 imul	 rax, rax, 1
  00256	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00265	48 89 44 24 70	 mov	 QWORD PTR tv201[rsp], rax
$LN54@z900_pcc_c:
  0026a	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00272	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00279	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv201[rsp]
  0027e	48 23 c8	 and	 rcx, rax
  00281	48 8b c1	 mov	 rax, rcx
  00284	8b 4c 24 38	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00288	ff c9		 dec	 ecx
  0028a	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00292	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00297	41 b9 01 00 00
	00		 mov	 r9d, 1
  0029d	4c 8b c0	 mov	 r8, rax
  002a0	0f b6 d1	 movzx	 edx, cl
  002a3	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  002ab	e8 00 00 00 00	 call	 z900_vfetchc

; 3482 : 
; 3483 : #ifdef OPTION_PCC_DEBUG
; 3484 :   LOGBYTE("ml    :", parameter_block, 1);
; 3485 :   LOGBYTE("msg   :", &parameter_block[8], 8);
; 3486 :   LOGBYTE("icv   :", &parameter_block[16], 8);
; 3487 :   switch(tfc)
; 3488 :   {
; 3489 :     case 1: /* dea */
; 3490 :     {
; 3491 :       LOGBYTE("k     :", &parameter_block[24], 8);
; 3492 :       break;
; 3493 :     }
; 3494 :     case 2: /* tdea-128 */
; 3495 :     {
; 3496 :       LOGBYTE("k1    :", &parameter_block[24], 8);
; 3497 :       LOGBYTE("k2    :", &parameter_block[32], 8);
; 3498 :       break;
; 3499 :     }
; 3500 :     case 3: /* tdea-192 */
; 3501 :     {
; 3502 :       LOGBYTE("k1    :", &parameter_block[24], 8);
; 3503 :       LOGBYTE("k2    :", &parameter_block[32], 8);
; 3504 :       LOGBYTE("k3    :", &parameter_block[40], 8);
; 3505 :       break;
; 3506 :     }
; 3507 :   }
; 3508 :   if(wrap)
; 3509 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 24], 24);
; 3510 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3511 : 
; 3512 :   /* Verify and unwrap */
; 3513 :   if(wrap && unwrap_dea(&parameter_block[24], keylen))

  002b0	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  002b5	74 32		 je	 SHORT $LN22@z900_pcc_c
  002b7	b8 01 00 00 00	 mov	 eax, 1
  002bc	48 6b c0 18	 imul	 rax, rax, 24
  002c0	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002c8	8b 54 24 58	 mov	 edx, DWORD PTR keylen$[rsp]
  002cc	48 8b c8	 mov	 rcx, rax
  002cf	e8 00 00 00 00	 call	 unwrap_dea
  002d4	85 c0		 test	 eax, eax
  002d6	74 11		 je	 SHORT $LN22@z900_pcc_c

; 3514 :   {
; 3515 : 
; 3516 : #ifdef OPTION_PCC_DEBUG
; 3517 :     WRMSG(HHC90111, "D");
; 3518 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3519 : 
; 3520 :     regs->psw.cc = 1;

  002d8	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e0	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3521 :     return;

  002e4	e9 ff 07 00 00	 jmp	 $LN1@z900_pcc_c
$LN22@z900_pcc_c:

; 3522 :   }
; 3523 : 
; 3524 :   /* Set the cryptographic key */
; 3525 :   switch(tfc)

  002e9	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  002ed	89 44 24 3c	 mov	 DWORD PTR tv217[rsp], eax
  002f1	83 7c 24 3c 01	 cmp	 DWORD PTR tv217[rsp], 1
  002f6	74 13		 je	 SHORT $LN23@z900_pcc_c
  002f8	83 7c 24 3c 02	 cmp	 DWORD PTR tv217[rsp], 2
  002fd	74 32		 je	 SHORT $LN24@z900_pcc_c
  002ff	83 7c 24 3c 03	 cmp	 DWORD PTR tv217[rsp], 3
  00304	74 6f		 je	 SHORT $LN25@z900_pcc_c
  00306	e9 cd 00 00 00	 jmp	 $LN2@z900_pcc_c
$LN23@z900_pcc_c:

; 3526 :   {
; 3527 :     case 1: /* dea */
; 3528 :     {
; 3529 :       des_set_key(&context1, &parameter_block[24]);

  0030b	b8 01 00 00 00	 mov	 eax, 1
  00310	48 6b c0 18	 imul	 rax, rax, 24
  00314	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0031c	48 8b d0	 mov	 rdx, rax
  0031f	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00327	e8 00 00 00 00	 call	 des_set_key

; 3530 :       break;

  0032c	e9 a7 00 00 00	 jmp	 $LN2@z900_pcc_c
$LN24@z900_pcc_c:

; 3531 :     }
; 3532 :     case 2: /* tdea-128 */
; 3533 :     {
; 3534 :       des_set_key(&context1, &parameter_block[24]);

  00331	b8 01 00 00 00	 mov	 eax, 1
  00336	48 6b c0 18	 imul	 rax, rax, 24
  0033a	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00342	48 8b d0	 mov	 rdx, rax
  00345	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0034d	e8 00 00 00 00	 call	 des_set_key

; 3535 :       des_set_key(&context2, &parameter_block[32]);

  00352	b8 01 00 00 00	 mov	 eax, 1
  00357	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0035b	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00363	48 8b d0	 mov	 rdx, rax
  00366	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0036e	e8 00 00 00 00	 call	 des_set_key

; 3536 :       break;

  00373	eb 63		 jmp	 SHORT $LN2@z900_pcc_c
$LN25@z900_pcc_c:

; 3537 :     }
; 3538 :     case 3: /* tdea-192 */
; 3539 :     {
; 3540 :       des_set_key(&context1, &parameter_block[24]);

  00375	b8 01 00 00 00	 mov	 eax, 1
  0037a	48 6b c0 18	 imul	 rax, rax, 24
  0037e	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00386	48 8b d0	 mov	 rdx, rax
  00389	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00391	e8 00 00 00 00	 call	 des_set_key

; 3541 :       des_set_key(&context2, &parameter_block[32]);

  00396	b8 01 00 00 00	 mov	 eax, 1
  0039b	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0039f	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003a7	48 8b d0	 mov	 rdx, rax
  003aa	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  003b2	e8 00 00 00 00	 call	 des_set_key

; 3542 :       des_set_key(&context3, &parameter_block[40]);

  003b7	b8 01 00 00 00	 mov	 eax, 1
  003bc	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  003c0	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003c8	48 8b d0	 mov	 rdx, rax
  003cb	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  003d3	e8 00 00 00 00	 call	 des_set_key
$LN2@z900_pcc_c:

; 3543 :       break;
; 3544 :     }
; 3545 :   }
; 3546 : 
; 3547 :   /* Check validity ML value */
; 3548 :   if(parameter_block[0] > 64)

  003d8	b8 01 00 00 00	 mov	 eax, 1
  003dd	48 6b c0 00	 imul	 rax, rax, 0
  003e1	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  003e9	83 f8 40	 cmp	 eax, 64			; 00000040H
  003ec	7e 11		 jle	 SHORT $LN26@z900_pcc_c

; 3549 :   {
; 3550 :     regs->psw.cc = 2;

  003ee	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f6	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 3551 :     return;

  003fa	e9 e9 06 00 00	 jmp	 $LN1@z900_pcc_c
$LN26@z900_pcc_c:

; 3552 :   }
; 3553 : 
; 3554 :   /* Place the one bit */
; 3555 :   if(parameter_block[0] != 64)

  003ff	b8 01 00 00 00	 mov	 eax, 1
  00404	48 6b c0 00	 imul	 rax, rax, 0
  00408	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00410	83 f8 40	 cmp	 eax, 64			; 00000040H
  00413	0f 84 9b 00 00
	00		 je	 $LN27@z900_pcc_c

; 3556 :     parameter_block[(parameter_block[0] / 8) + 8] |= (0x80 >> (parameter_block[0] % 8));

  00419	b8 01 00 00 00	 mov	 eax, 1
  0041e	48 6b c0 00	 imul	 rax, rax, 0
  00422	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0042a	99		 cdq
  0042b	83 e2 07	 and	 edx, 7
  0042e	03 c2		 add	 eax, edx
  00430	c1 f8 03	 sar	 eax, 3
  00433	83 c0 08	 add	 eax, 8
  00436	48 98		 cdqe
  00438	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv259[rsp], rax
  00440	b9 01 00 00 00	 mov	 ecx, 1
  00445	48 6b c9 00	 imul	 rcx, rcx, 0
  00449	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00451	8b c1		 mov	 eax, ecx
  00453	99		 cdq
  00454	83 e2 07	 and	 edx, 7
  00457	03 c2		 add	 eax, edx
  00459	83 e0 07	 and	 eax, 7
  0045c	2b c2		 sub	 eax, edx
  0045e	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  00463	89 4c 24 5c	 mov	 DWORD PTR tv587[rsp], ecx
  00467	0f b6 c8	 movzx	 ecx, al
  0046a	8b 44 24 5c	 mov	 eax, DWORD PTR tv587[rsp]
  0046e	d3 f8		 sar	 eax, cl
  00470	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv259[rsp]
  00478	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00480	0b c8		 or	 ecx, eax
  00482	8b c1		 mov	 eax, ecx
  00484	89 44 24 60	 mov	 DWORD PTR tv276[rsp], eax
  00488	b9 01 00 00 00	 mov	 ecx, 1
  0048d	48 6b c9 00	 imul	 rcx, rcx, 0
  00491	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00499	8b c1		 mov	 eax, ecx
  0049b	99		 cdq
  0049c	83 e2 07	 and	 edx, 7
  0049f	03 c2		 add	 eax, edx
  004a1	c1 f8 03	 sar	 eax, 3
  004a4	83 c0 08	 add	 eax, 8
  004a7	48 98		 cdqe
  004a9	8b 4c 24 60	 mov	 ecx, DWORD PTR tv276[rsp]
  004ad	88 8c 04 70 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl
$LN27@z900_pcc_c:

; 3557 : 
; 3558 :   /* Pad with zeroes */
; 3559 :   if(parameter_block[0] < 63)

  004b4	b8 01 00 00 00	 mov	 eax, 1
  004b9	48 6b c0 00	 imul	 rax, rax, 0
  004bd	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  004c5	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  004c8	0f 8d f2 00 00
	00		 jge	 $LN28@z900_pcc_c

; 3560 :   {
; 3561 :     parameter_block[(parameter_block[0] / 8) + 8] &= mask[parameter_block[0] % 8];

  004ce	b8 01 00 00 00	 mov	 eax, 1
  004d3	48 6b c0 00	 imul	 rax, rax, 0
  004d7	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  004df	99		 cdq
  004e0	83 e2 07	 and	 edx, 7
  004e3	03 c2		 add	 eax, edx
  004e5	c1 f8 03	 sar	 eax, 3
  004e8	83 c0 08	 add	 eax, 8
  004eb	48 98		 cdqe
  004ed	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
  004f5	b9 01 00 00 00	 mov	 ecx, 1
  004fa	48 6b c9 00	 imul	 rcx, rcx, 0
  004fe	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00506	8b c1		 mov	 eax, ecx
  00508	99		 cdq
  00509	83 e2 07	 and	 edx, 7
  0050c	03 c2		 add	 eax, edx
  0050e	83 e0 07	 and	 eax, 7
  00511	2b c2		 sub	 eax, edx
  00513	48 98		 cdqe
  00515	0f b6 84 04 60
	02 00 00	 movzx	 eax, BYTE PTR mask$[rsp+rax]
  0051d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv287[rsp]
  00525	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0052d	23 c8		 and	 ecx, eax
  0052f	8b c1		 mov	 eax, ecx
  00531	89 44 24 64	 mov	 DWORD PTR tv307[rsp], eax
  00535	b9 01 00 00 00	 mov	 ecx, 1
  0053a	48 6b c9 00	 imul	 rcx, rcx, 0
  0053e	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00546	8b c1		 mov	 eax, ecx
  00548	99		 cdq
  00549	83 e2 07	 and	 edx, 7
  0054c	03 c2		 add	 eax, edx
  0054e	c1 f8 03	 sar	 eax, 3
  00551	83 c0 08	 add	 eax, 8
  00554	48 98		 cdqe
  00556	8b 4c 24 64	 mov	 ecx, DWORD PTR tv307[rsp]
  0055a	88 8c 04 70 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl

; 3562 :     for(i = (parameter_block[0] / 8) + 1; i < 8; i++)

  00561	b8 01 00 00 00	 mov	 eax, 1
  00566	48 6b c0 00	 imul	 rax, rax, 0
  0056a	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00572	99		 cdq
  00573	83 e2 07	 and	 edx, 7
  00576	03 c2		 add	 eax, edx
  00578	c1 f8 03	 sar	 eax, 3
  0057b	ff c0		 inc	 eax
  0057d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00581	eb 0a		 jmp	 SHORT $LN6@z900_pcc_c
$LN4@z900_pcc_c:
  00583	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00587	ff c0		 inc	 eax
  00589	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN6@z900_pcc_c:
  0058d	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00592	7d 2c		 jge	 SHORT $LN5@z900_pcc_c

; 3563 :       parameter_block[i + 8] = 0x00;

  00594	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00598	83 c0 08	 add	 eax, 8
  0059b	48 98		 cdqe
  0059d	48 89 44 24 78	 mov	 QWORD PTR $T1[rsp], rax
  005a2	48 83 7c 24 78
	48		 cmp	 QWORD PTR $T1[rsp], 72	; 00000048H
  005a8	73 02		 jae	 SHORT $LN55@z900_pcc_c
  005aa	eb 05		 jmp	 SHORT $LN56@z900_pcc_c
$LN55@z900_pcc_c:
  005ac	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN56@z900_pcc_c:
  005b1	48 8b 44 24 78	 mov	 rax, QWORD PTR $T1[rsp]
  005b6	c6 84 04 70 02
	00 00 00	 mov	 BYTE PTR parameter_block$[rsp+rax], 0
  005be	eb c3		 jmp	 SHORT $LN4@z900_pcc_c
$LN5@z900_pcc_c:
$LN28@z900_pcc_c:

; 3564 :   }
; 3565 : 
; 3566 : #ifdef OPTION_PCC_DEBUG
; 3567 :   LOGBYTE("msg   :", &parameter_block[8], 8);
; 3568 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3569 : 
; 3570 :   /* Calculate subkey */
; 3571 :   zeromem(k, 8);

  005c0	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR k$[rsp]
  005c8	48 8b f8	 mov	 rdi, rax
  005cb	33 c0		 xor	 eax, eax
  005cd	b9 08 00 00 00	 mov	 ecx, 8
  005d2	f3 aa		 rep stosb

; 3572 :   switch(tfc)

  005d4	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  005d8	89 44 24 40	 mov	 DWORD PTR tv320[rsp], eax
  005dc	83 7c 24 40 01	 cmp	 DWORD PTR tv320[rsp], 1
  005e1	74 17		 je	 SHORT $LN29@z900_pcc_c
  005e3	83 7c 24 40 02	 cmp	 DWORD PTR tv320[rsp], 2
  005e8	74 32		 je	 SHORT $LN30@z900_pcc_c
  005ea	83 7c 24 40 03	 cmp	 DWORD PTR tv320[rsp], 3
  005ef	0f 84 80 00 00
	00		 je	 $LN31@z900_pcc_c
  005f5	e9 d2 00 00 00	 jmp	 $LN7@z900_pcc_c
$LN29@z900_pcc_c:

; 3573 :   {
; 3574 :     case 1: /* dea */
; 3575 :     {
; 3576 :       des_encrypt(&context1, k, k);

  005fa	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  00602	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0060a	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00612	e8 00 00 00 00	 call	 des_encrypt

; 3577 :       break;

  00617	e9 b0 00 00 00	 jmp	 $LN7@z900_pcc_c
$LN30@z900_pcc_c:

; 3578 :     }
; 3579 :     case 2: /* tdea-128 */
; 3580 :     {
; 3581 :       des_encrypt(&context1, k, k);

  0061c	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  00624	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0062c	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00634	e8 00 00 00 00	 call	 des_encrypt

; 3582 :       des_decrypt(&context2, k, k);

  00639	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  00641	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00649	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00651	e8 00 00 00 00	 call	 des_decrypt

; 3583 :       des_encrypt(&context1, k, k);

  00656	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  0065e	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00666	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0066e	e8 00 00 00 00	 call	 des_encrypt

; 3584 :       break;

  00673	eb 57		 jmp	 SHORT $LN7@z900_pcc_c
$LN31@z900_pcc_c:

; 3585 :     }
; 3586 :     case 3: /* tdea-192 */
; 3587 :     {
; 3588 :       des_encrypt(&context1, k, k);

  00675	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  0067d	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00685	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0068d	e8 00 00 00 00	 call	 des_encrypt

; 3589 :       des_decrypt(&context2, k, k);

  00692	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  0069a	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  006a2	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  006aa	e8 00 00 00 00	 call	 des_decrypt

; 3590 :       des_encrypt(&context3, k, k);

  006af	4c 8d 84 24 50
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  006b7	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  006bf	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  006c7	e8 00 00 00 00	 call	 des_encrypt
$LN7@z900_pcc_c:

; 3591 :       break;
; 3592 :     }
; 3593 :   }
; 3594 : 
; 3595 :   /* Calculate subkeys Kx and Ky */
; 3596 :   if(!(k[0] & 0x80))

  006cc	b8 01 00 00 00	 mov	 eax, 1
  006d1	48 6b c0 00	 imul	 rax, rax, 0
  006d5	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  006dd	25 80 00 00 00	 and	 eax, 128		; 00000080H
  006e2	85 c0		 test	 eax, eax
  006e4	75 1d		 jne	 SHORT $LN32@z900_pcc_c

; 3597 :     shift_left(k, k, 8);

  006e6	41 b8 08 00 00
	00		 mov	 r8d, 8
  006ec	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  006f4	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  006fc	e8 00 00 00 00	 call	 shift_left
  00701	eb 60		 jmp	 SHORT $LN33@z900_pcc_c
$LN32@z900_pcc_c:

; 3598 :   else
; 3599 :   {
; 3600 :     shift_left(k, k, 8);

  00703	41 b8 08 00 00
	00		 mov	 r8d, 8
  00709	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00711	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00719	e8 00 00 00 00	 call	 shift_left

; 3601 :     for(i = 0; i < 8; i++)

  0071e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00726	eb 0a		 jmp	 SHORT $LN11@z900_pcc_c
$LN9@z900_pcc_c:
  00728	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0072c	ff c0		 inc	 eax
  0072e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@z900_pcc_c:
  00732	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00737	7d 2a		 jge	 SHORT $LN10@z900_pcc_c

; 3602 :       k[i] ^= r64[i];

  00739	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0073e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00743	0f b6 8c 0c 58
	02 00 00	 movzx	 ecx, BYTE PTR r64$[rsp+rcx]
  0074b	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00753	33 c1		 xor	 eax, ecx
  00755	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0075a	88 84 0c 50 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  00761	eb c5		 jmp	 SHORT $LN9@z900_pcc_c
$LN10@z900_pcc_c:
$LN33@z900_pcc_c:

; 3603 :   }
; 3604 :   if(parameter_block[0] != 64)

  00763	b8 01 00 00 00	 mov	 eax, 1
  00768	48 6b c0 00	 imul	 rax, rax, 0
  0076c	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00774	83 f8 40	 cmp	 eax, 64			; 00000040H
  00777	0f 84 97 00 00
	00		 je	 $LN34@z900_pcc_c

; 3605 :   {
; 3606 :     if(!(k[0] & 0x80))

  0077d	b8 01 00 00 00	 mov	 eax, 1
  00782	48 6b c0 00	 imul	 rax, rax, 0
  00786	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  0078e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00793	85 c0		 test	 eax, eax
  00795	75 1d		 jne	 SHORT $LN35@z900_pcc_c

; 3607 :       shift_left(k, k, 8);

  00797	41 b8 08 00 00
	00		 mov	 r8d, 8
  0079d	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  007a5	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  007ad	e8 00 00 00 00	 call	 shift_left
  007b2	eb 60		 jmp	 SHORT $LN36@z900_pcc_c
$LN35@z900_pcc_c:

; 3608 :     else
; 3609 :     {
; 3610 :       shift_left(k, k, 8);

  007b4	41 b8 08 00 00
	00		 mov	 r8d, 8
  007ba	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  007c2	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  007ca	e8 00 00 00 00	 call	 shift_left

; 3611 :       for(i = 0; i < 8; i++)

  007cf	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007d7	eb 0a		 jmp	 SHORT $LN14@z900_pcc_c
$LN12@z900_pcc_c:
  007d9	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007dd	ff c0		 inc	 eax
  007df	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN14@z900_pcc_c:
  007e3	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  007e8	7d 2a		 jge	 SHORT $LN13@z900_pcc_c

; 3612 :         k[i] ^= r64[i];

  007ea	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  007ef	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  007f4	0f b6 8c 0c 58
	02 00 00	 movzx	 ecx, BYTE PTR r64$[rsp+rcx]
  007fc	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00804	33 c1		 xor	 eax, ecx
  00806	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0080b	88 84 0c 50 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  00812	eb c5		 jmp	 SHORT $LN12@z900_pcc_c
$LN13@z900_pcc_c:
$LN36@z900_pcc_c:
$LN34@z900_pcc_c:

; 3613 :     }
; 3614 :   }
; 3615 : 
; 3616 : #ifdef OPTION_PCC_DEBUG
; 3617 :   LOGBYTE("Subkey:", k, 8);
; 3618 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3619 : 
; 3620 :   /* XOR with kx or ky and encrypt */
; 3621 :   for(i = 0; i < 8; i++)

  00814	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0081c	eb 0a		 jmp	 SHORT $LN17@z900_pcc_c
$LN15@z900_pcc_c:
  0081e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00822	ff c0		 inc	 eax
  00824	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN17@z900_pcc_c:
  00828	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0082d	7d 69		 jge	 SHORT $LN16@z900_pcc_c

; 3622 :   {
; 3623 :     parameter_block[i + 8] ^= k[i];

  0082f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00833	83 c0 08	 add	 eax, 8
  00836	48 98		 cdqe
  00838	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0083d	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR k$[rsp+rcx]
  00845	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0084d	33 c1		 xor	 eax, ecx
  0084f	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00853	83 c1 08	 add	 ecx, 8
  00856	48 63 c9	 movsxd	 rcx, ecx
  00859	88 84 0c 70 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3624 :     parameter_block[i + 8] ^= parameter_block[i + 16];

  00860	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00864	83 c0 08	 add	 eax, 8
  00867	48 98		 cdqe
  00869	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0086d	83 c1 10	 add	 ecx, 16
  00870	48 63 c9	 movsxd	 rcx, ecx
  00873	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0087b	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00883	33 c1		 xor	 eax, ecx
  00885	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00889	83 c1 08	 add	 ecx, 8
  0088c	48 63 c9	 movsxd	 rcx, ecx
  0088f	88 84 0c 70 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3625 :   }

  00896	eb 86		 jmp	 SHORT $LN15@z900_pcc_c
$LN16@z900_pcc_c:

; 3626 :   switch(tfc)

  00898	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  0089c	89 44 24 44	 mov	 DWORD PTR tv438[rsp], eax
  008a0	83 7c 24 44 01	 cmp	 DWORD PTR tv438[rsp], 1
  008a5	74 17		 je	 SHORT $LN37@z900_pcc_c
  008a7	83 7c 24 44 02	 cmp	 DWORD PTR tv438[rsp], 2
  008ac	74 4a		 je	 SHORT $LN38@z900_pcc_c
  008ae	83 7c 24 44 03	 cmp	 DWORD PTR tv438[rsp], 3
  008b3	0f 84 e3 00 00
	00		 je	 $LN39@z900_pcc_c
  008b9	e9 7d 01 00 00	 jmp	 $LN18@z900_pcc_c
$LN37@z900_pcc_c:

; 3627 :   {
; 3628 :     case 1: /* dea */
; 3629 :     {
; 3630 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  008be	b8 01 00 00 00	 mov	 eax, 1
  008c3	48 6b c0 08	 imul	 rax, rax, 8
  008c7	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  008cf	b9 01 00 00 00	 mov	 ecx, 1
  008d4	48 6b c9 08	 imul	 rcx, rcx, 8
  008d8	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  008e0	4c 8b c0	 mov	 r8, rax
  008e3	48 8b d1	 mov	 rdx, rcx
  008e6	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  008ee	e8 00 00 00 00	 call	 des_encrypt

; 3631 :       break;

  008f3	e9 43 01 00 00	 jmp	 $LN18@z900_pcc_c
$LN38@z900_pcc_c:

; 3632 :     }
; 3633 :     case 2: /* tdea-128 */
; 3634 :     {
; 3635 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  008f8	b8 01 00 00 00	 mov	 eax, 1
  008fd	48 6b c0 08	 imul	 rax, rax, 8
  00901	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00909	b9 01 00 00 00	 mov	 ecx, 1
  0090e	48 6b c9 08	 imul	 rcx, rcx, 8
  00912	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0091a	4c 8b c0	 mov	 r8, rax
  0091d	48 8b d1	 mov	 rdx, rcx
  00920	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00928	e8 00 00 00 00	 call	 des_encrypt

; 3636 :       des_decrypt(&context2, &parameter_block[8], &parameter_block[8]);

  0092d	b8 01 00 00 00	 mov	 eax, 1
  00932	48 6b c0 08	 imul	 rax, rax, 8
  00936	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0093e	b9 01 00 00 00	 mov	 ecx, 1
  00943	48 6b c9 08	 imul	 rcx, rcx, 8
  00947	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0094f	4c 8b c0	 mov	 r8, rax
  00952	48 8b d1	 mov	 rdx, rcx
  00955	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0095d	e8 00 00 00 00	 call	 des_decrypt

; 3637 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  00962	b8 01 00 00 00	 mov	 eax, 1
  00967	48 6b c0 08	 imul	 rax, rax, 8
  0096b	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00973	b9 01 00 00 00	 mov	 ecx, 1
  00978	48 6b c9 08	 imul	 rcx, rcx, 8
  0097c	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00984	4c 8b c0	 mov	 r8, rax
  00987	48 8b d1	 mov	 rdx, rcx
  0098a	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00992	e8 00 00 00 00	 call	 des_encrypt

; 3638 :       break;

  00997	e9 9f 00 00 00	 jmp	 $LN18@z900_pcc_c
$LN39@z900_pcc_c:

; 3639 :     }
; 3640 :     case 3: /* tdea-192 */
; 3641 :     {
; 3642 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  0099c	b8 01 00 00 00	 mov	 eax, 1
  009a1	48 6b c0 08	 imul	 rax, rax, 8
  009a5	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  009ad	b9 01 00 00 00	 mov	 ecx, 1
  009b2	48 6b c9 08	 imul	 rcx, rcx, 8
  009b6	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  009be	4c 8b c0	 mov	 r8, rax
  009c1	48 8b d1	 mov	 rdx, rcx
  009c4	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  009cc	e8 00 00 00 00	 call	 des_encrypt

; 3643 :       des_decrypt(&context2, &parameter_block[8], &parameter_block[8]);

  009d1	b8 01 00 00 00	 mov	 eax, 1
  009d6	48 6b c0 08	 imul	 rax, rax, 8
  009da	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  009e2	b9 01 00 00 00	 mov	 ecx, 1
  009e7	48 6b c9 08	 imul	 rcx, rcx, 8
  009eb	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  009f3	4c 8b c0	 mov	 r8, rax
  009f6	48 8b d1	 mov	 rdx, rcx
  009f9	48 8d 8c 24 30
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00a01	e8 00 00 00 00	 call	 des_decrypt

; 3644 :       des_encrypt(&context3, &parameter_block[8], &parameter_block[8]);

  00a06	b8 01 00 00 00	 mov	 eax, 1
  00a0b	48 6b c0 08	 imul	 rax, rax, 8
  00a0f	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00a17	b9 01 00 00 00	 mov	 ecx, 1
  00a1c	48 6b c9 08	 imul	 rcx, rcx, 8
  00a20	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00a28	4c 8b c0	 mov	 r8, rax
  00a2b	48 8b d1	 mov	 rdx, rcx
  00a2e	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00a36	e8 00 00 00 00	 call	 des_encrypt
$LN18@z900_pcc_c:

; 3645 :       break;
; 3646 :     }
; 3647 :   }
; 3648 : 
; 3649 : #ifdef OPTION_PCC_DEBUG
; 3650 :   LOGBYTE("cmac  :", &parameter_block[8], 8);
; 3651 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3652 : 
; 3653 :   /* Store the CMAC */
; 3654 :   ARCH_DEP(vstorec)(&parameter_block[8], 7, (GR_A(1, regs) + 16) & ADDRESS_MAXWRAP(regs), 1, regs);

  00a3b	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a43	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a49	83 e0 01	 and	 eax, 1
  00a4c	85 c0		 test	 eax, eax
  00a4e	74 23		 je	 SHORT $LN57@z900_pcc_c
  00a50	b8 08 00 00 00	 mov	 eax, 8
  00a55	48 6b c0 01	 imul	 rax, rax, 1
  00a59	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a61	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00a69	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv505[rsp], rax
  00a71	eb 20		 jmp	 SHORT $LN58@z900_pcc_c
$LN57@z900_pcc_c:
  00a73	b8 08 00 00 00	 mov	 eax, 8
  00a78	48 6b c0 01	 imul	 rax, rax, 1
  00a7c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a84	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00a8b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv505[rsp], rax
$LN58@z900_pcc_c:
  00a93	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv505[rsp]
  00a9b	48 83 c0 10	 add	 rax, 16
  00a9f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa7	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00aae	b9 01 00 00 00	 mov	 ecx, 1
  00ab3	48 6b c9 08	 imul	 rcx, rcx, 8
  00ab7	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00abf	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ac7	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00acc	41 b9 01 00 00
	00		 mov	 r9d, 1
  00ad2	4c 8b c0	 mov	 r8, rax
  00ad5	b2 07		 mov	 dl, 7
  00ad7	e8 00 00 00 00	 call	 z900_vstorec

; 3655 : 
; 3656 :   /* Normal completion */
; 3657 :   regs->psw.cc = 0;

  00adc	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ae4	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_pcc_c:
$LN40@z900_pcc_c:

; 3658 : }

  00ae8	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00af0	48 33 cc	 xor	 rcx, rsp
  00af3	e8 00 00 00 00	 call	 __security_check_cookie
  00af8	48 81 c4 d0 02
	00 00		 add	 rsp, 720		; 000002d0H
  00aff	5f		 pop	 rdi
  00b00	c3		 ret	 0
z900_pcc_cmac_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv135 = 64
tv157 = 68
tv178 = 72
tv193 = 76
wrap$ = 80
tv257 = 84
tv390 = 88
tv510 = 92
tv531 = 96
tfc$ = 100
r1_is_not_r2$ = 104
tv80 = 112
tv155 = 120
tv216 = 128
tv234 = 136
tv279 = 144
tv316 = 152
tv336 = 160
tv364 = 168
tv385 = 176
tv414 = 184
tv435 = 192
tv464 = 200
tv488 = 208
tv508 = 216
context$ = 224
message_block$ = 720
parameter_block$ = 736
__$ArrayPad$ = 816
r1$ = 848
r2$ = 856
regs$ = 864
z900_kmo_aes PROC

; 3336 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 48 03
	00 00		 sub	 rsp, 840		; 00000348H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 30
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3337 :   rijndael_ctx context;
; 3338 :   int crypted;
; 3339 :   int i;
; 3340 :   int keylen;
; 3341 :   BYTE message_block[16];
; 3342 :   BYTE parameter_block[80];
; 3343 :   int parameter_blocklen;
; 3344 :   int r1_is_not_r2;
; 3345 :   int tfc;
; 3346 :   int wrap;
; 3347 : 
; 3348 :   /* Check special conditions */
; 3349 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00026	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 22		 je	 SHORT $LN30@z900_kmo_a
  0003b	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00042	ff c0		 inc	 eax
  00044	48 98		 cdqe
  00046	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00056	48 89 44 24 70	 mov	 QWORD PTR tv80[rsp], rax
  0005b	eb 1f		 jmp	 SHORT $LN31@z900_kmo_a
$LN30@z900_kmo_a:
  0005d	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00064	ff c0		 inc	 eax
  00066	48 98		 cdqe
  00068	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	48 89 44 24 70	 mov	 QWORD PTR tv80[rsp], rax
$LN31@z900_kmo_a:
  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR tv80[rsp]
  00083	b9 10 00 00 00	 mov	 ecx, 16
  00088	48 f7 f1	 div	 rcx
  0008b	48 8b c2	 mov	 rax, rdx
  0008e	48 85 c0	 test	 rax, rax
  00091	74 0a		 je	 SHORT $LN36@z900_kmo_a
  00093	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0009b	eb 08		 jmp	 SHORT $LN37@z900_kmo_a
$LN36@z900_kmo_a:
  0009d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN37@z900_kmo_a:
  000a5	83 7c 24 40 00	 cmp	 DWORD PTR tv135[rsp], 0
  000aa	74 13		 je	 SHORT $LN17@z900_kmo_a

; 3350 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ac	ba 06 00 00 00	 mov	 edx, 6
  000b1	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN17@z900_kmo_a:

; 3351 : 
; 3352 :   /* Return with cc 0 on zero length */
; 3353 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000bf	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 22		 je	 SHORT $LN38@z900_kmo_a
  000d4	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000db	ff c0		 inc	 eax
  000dd	48 98		 cdqe
  000df	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000ef	48 89 44 24 78	 mov	 QWORD PTR tv155[rsp], rax
  000f4	eb 1f		 jmp	 SHORT $LN39@z900_kmo_a
$LN38@z900_kmo_a:
  000f6	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000fd	ff c0		 inc	 eax
  000ff	48 98		 cdqe
  00101	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00110	48 89 44 24 78	 mov	 QWORD PTR tv155[rsp], rax
$LN39@z900_kmo_a:
  00115	48 83 7c 24 78
	00		 cmp	 QWORD PTR tv155[rsp], 0
  0011b	75 0a		 jne	 SHORT $LN40@z900_kmo_a
  0011d	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  00125	eb 08		 jmp	 SHORT $LN41@z900_kmo_a
$LN40@z900_kmo_a:
  00127	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN41@z900_kmo_a:
  0012f	83 7c 24 44 00	 cmp	 DWORD PTR tv157[rsp], 0
  00134	74 0a		 je	 SHORT $LN46@z900_kmo_a
  00136	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  0013e	eb 08		 jmp	 SHORT $LN47@z900_kmo_a
$LN46@z900_kmo_a:
  00140	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN47@z900_kmo_a:
  00148	83 7c 24 48 00	 cmp	 DWORD PTR tv178[rsp], 0
  0014d	74 11		 je	 SHORT $LN18@z900_kmo_a

; 3354 :   {
; 3355 :     regs->psw.cc = 0;

  0014f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3356 :     return;

  0015b	e9 d7 08 00 00	 jmp	 $LN1@z900_kmo_a
$LN18@z900_kmo_a:

; 3357 :   }
; 3358 : 
; 3359 :   /* Initialize values */
; 3360 :   tfc = GR0_tfc(regs);

  00160	b8 08 00 00 00	 mov	 eax, 8
  00165	48 6b c0 00	 imul	 rax, rax, 0
  00169	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00178	83 e0 7f	 and	 eax, 127		; 0000007fH
  0017b	83 e0 77	 and	 eax, 119		; 00000077H
  0017e	89 44 24 64	 mov	 DWORD PTR tfc$[rsp], eax

; 3361 :   wrap = GR0_wrap(regs);

  00182	b8 08 00 00 00	 mov	 eax, 8
  00187	48 6b c0 00	 imul	 rax, rax, 0
  0018b	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0019a	83 e0 08	 and	 eax, 8
  0019d	85 c0		 test	 eax, eax
  0019f	74 0a		 je	 SHORT $LN48@z900_kmo_a
  001a1	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001a9	eb 08		 jmp	 SHORT $LN49@z900_kmo_a
$LN48@z900_kmo_a:
  001ab	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN49@z900_kmo_a:
  001b3	8b 44 24 4c	 mov	 eax, DWORD PTR tv193[rsp]
  001b7	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 3362 :   keylen = (tfc - 17) * 8 + 8;

  001bb	8b 44 24 64	 mov	 eax, DWORD PTR tfc$[rsp]
  001bf	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  001c6	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 3363 :   parameter_blocklen = keylen + 16;

  001ca	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  001ce	83 c0 10	 add	 eax, 16
  001d1	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3364 :   if(wrap)

  001d5	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001da	74 0b		 je	 SHORT $LN19@z900_kmo_a

; 3365 :     parameter_blocklen += 32;

  001dc	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001e0	83 c0 20	 add	 eax, 32			; 00000020H
  001e3	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN19@z900_kmo_a:

; 3366 : 
; 3367 :   /* Test writeability output chaining value */
; 3368 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  001e7	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ef	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001f5	83 e0 01	 and	 eax, 1
  001f8	85 c0		 test	 eax, eax
  001fa	74 23		 je	 SHORT $LN50@z900_kmo_a
  001fc	b8 08 00 00 00	 mov	 eax, 8
  00201	48 6b c0 01	 imul	 rax, rax, 1
  00205	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00215	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv216[rsp], rax
  0021d	eb 20		 jmp	 SHORT $LN51@z900_kmo_a
$LN50@z900_kmo_a:
  0021f	b8 08 00 00 00	 mov	 eax, 8
  00224	48 6b c0 01	 imul	 rax, rax, 1
  00228	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00230	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00237	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv216[rsp], rax
$LN51@z900_kmo_a:
  0023f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0024e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv216[rsp]
  00256	48 23 c8	 and	 rcx, rax
  00259	48 8b c1	 mov	 rax, rcx
  0025c	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00269	41 b9 02 00 00
	00		 mov	 r9d, 2
  0026f	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00275	ba 01 00 00 00	 mov	 edx, 1
  0027a	48 8b c8	 mov	 rcx, rax
  0027d	e8 00 00 00 00	 call	 z900_validate_operand

; 3369 : 
; 3370 :   /* Fetch the parameter block */
; 3371 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00282	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00290	83 e0 01	 and	 eax, 1
  00293	85 c0		 test	 eax, eax
  00295	74 23		 je	 SHORT $LN52@z900_kmo_a
  00297	b8 08 00 00 00	 mov	 eax, 8
  0029c	48 6b c0 01	 imul	 rax, rax, 1
  002a0	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a8	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002b0	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv234[rsp], rax
  002b8	eb 20		 jmp	 SHORT $LN53@z900_kmo_a
$LN52@z900_kmo_a:
  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 01	 imul	 rax, rax, 1
  002c3	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv234[rsp], rax
$LN53@z900_kmo_a:
  002da	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002e2	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002e9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv234[rsp]
  002f1	48 23 c8	 and	 rcx, rax
  002f4	48 8b c1	 mov	 rax, rcx
  002f7	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  002fb	ff c9		 dec	 ecx
  002fd	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00305	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0030a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00310	4c 8b c0	 mov	 r8, rax
  00313	0f b6 d1	 movzx	 edx, cl
  00316	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0031e	e8 00 00 00 00	 call	 z900_vfetchc

; 3372 : 
; 3373 : #ifdef OPTION_KMO_DEBUG
; 3374 :   LOGBYTE("cv    :", parameter_block, 16);
; 3375 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 3376 :   if(wrap)
; 3377 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 16], 32);
; 3378 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3379 : 
; 3380 :   /* Verify and unwrap */
; 3381 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  00323	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00328	74 32		 je	 SHORT $LN20@z900_kmo_a
  0032a	b8 01 00 00 00	 mov	 eax, 1
  0032f	48 6b c0 10	 imul	 rax, rax, 16
  00333	48 8d 84 04 e0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0033b	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  0033f	48 8b c8	 mov	 rcx, rax
  00342	e8 00 00 00 00	 call	 unwrap_aes
  00347	85 c0		 test	 eax, eax
  00349	74 11		 je	 SHORT $LN20@z900_kmo_a

; 3382 :   {
; 3383 : 
; 3384 : #ifdef OPTION_KMO_DEBUG
; 3385 :     WRMSG(HHC90111, "D");
; 3386 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3387 : 
; 3388 :     regs->psw.cc = 1;

  0034b	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00353	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3389 :     return;

  00357	e9 db 06 00 00	 jmp	 $LN1@z900_kmo_a
$LN20@z900_kmo_a:

; 3390 :   }
; 3391 : 
; 3392 :   /* Set the cryptographic key */
; 3393 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  0035c	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00360	c1 e0 03	 shl	 eax, 3
  00363	b9 01 00 00 00	 mov	 ecx, 1
  00368	48 6b c9 10	 imul	 rcx, rcx, 16
  0036c	48 8d 8c 0c e0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00374	44 8b c0	 mov	 r8d, eax
  00377	48 8b d1	 mov	 rdx, rcx
  0037a	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00382	e8 00 00 00 00	 call	 rijndael_set_key

; 3394 : 
; 3395 :   /* Try to process the CPU-determined amount of data */
; 3396 :   r1_is_not_r2 = r1 != r2;

  00387	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0038e	39 84 24 50 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00395	74 0a		 je	 SHORT $LN54@z900_kmo_a
  00397	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv257[rsp], 1
  0039f	eb 08		 jmp	 SHORT $LN55@z900_kmo_a
$LN54@z900_kmo_a:
  003a1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv257[rsp], 0
$LN55@z900_kmo_a:
  003a9	8b 44 24 54	 mov	 eax, DWORD PTR tv257[rsp]
  003ad	89 44 24 68	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 3397 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  003b1	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  003b9	eb 0b		 jmp	 SHORT $LN4@z900_kmo_a
$LN2@z900_kmo_a:
  003bb	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  003bf	83 c0 10	 add	 eax, 16
  003c2	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@z900_kmo_a:
  003c6	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  003ce	0f 8d 57 06 00
	00		 jge	 $LN3@z900_kmo_a

; 3398 :   {
; 3399 :     rijndael_encrypt(&context, parameter_block, parameter_block);

  003d4	4c 8d 84 24 e0
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  003dc	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  003e4	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  003ec	e8 00 00 00 00	 call	 rijndael_encrypt

; 3400 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  003f1	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003f9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003ff	83 e0 01	 and	 eax, 1
  00402	85 c0		 test	 eax, eax
  00404	74 22		 je	 SHORT $LN56@z900_kmo_a
  00406	48 63 84 24 58
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0040e	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00416	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0041e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  00426	eb 1f		 jmp	 SHORT $LN57@z900_kmo_a
$LN56@z900_kmo_a:
  00428	48 63 84 24 58
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00430	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00438	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0043f	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
$LN57@z900_kmo_a:
  00447	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00456	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv279[rsp]
  0045e	48 23 c8	 and	 rcx, rax
  00461	48 8b c1	 mov	 rax, rcx
  00464	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00471	44 8b 8c 24 58
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00479	4c 8b c0	 mov	 r8, rax
  0047c	b2 0f		 mov	 dl, 15
  0047e	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00486	e8 00 00 00 00	 call	 z900_vfetchc

; 3401 : 
; 3402 : #ifdef OPTION_KMO_DEBUG
; 3403 :     LOGBYTE("input :", message_block, 16);
; 3404 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3405 : 
; 3406 :     for(i = 0; i < 16; i++)

  0048b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00493	eb 0a		 jmp	 SHORT $LN7@z900_kmo_a
$LN5@z900_kmo_a:
  00495	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00499	ff c0		 inc	 eax
  0049b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_kmo_a:
  0049f	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  004a4	7d 2a		 jge	 SHORT $LN6@z900_kmo_a

; 3407 :       message_block[i] ^= parameter_block[i];

  004a6	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004ab	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004b0	0f b6 8c 0c e0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  004b8	0f b6 84 04 d0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  004c0	33 c1		 xor	 eax, ecx
  004c2	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004c7	88 84 0c d0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  004ce	eb c5		 jmp	 SHORT $LN5@z900_kmo_a
$LN6@z900_kmo_a:

; 3408 : 
; 3409 :     /* Store the output */
; 3410 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  004d0	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004de	83 e0 01	 and	 eax, 1
  004e1	85 c0		 test	 eax, eax
  004e3	74 22		 je	 SHORT $LN58@z900_kmo_a
  004e5	48 63 84 24 50
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004ed	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  004fd	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv316[rsp], rax
  00505	eb 1f		 jmp	 SHORT $LN59@z900_kmo_a
$LN58@z900_kmo_a:
  00507	48 63 84 24 50
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0050f	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00517	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0051e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv316[rsp], rax
$LN59@z900_kmo_a:
  00526	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00535	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv316[rsp]
  0053d	48 23 c8	 and	 rcx, rax
  00540	48 8b c1	 mov	 rax, rcx
  00543	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00550	44 8b 8c 24 50
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  00558	4c 8b c0	 mov	 r8, rax
  0055b	b2 0f		 mov	 dl, 15
  0055d	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00565	e8 00 00 00 00	 call	 z900_vstorec

; 3411 : 
; 3412 : #ifdef OPTION_KMO_DEBUG
; 3413 :     LOGBYTE("output:", message_block, 16);
; 3414 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3415 : 
; 3416 :     /* Store the chaining value */
; 3417 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0056a	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00572	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00578	83 e0 01	 and	 eax, 1
  0057b	85 c0		 test	 eax, eax
  0057d	74 23		 je	 SHORT $LN60@z900_kmo_a
  0057f	b8 08 00 00 00	 mov	 eax, 8
  00584	48 6b c0 01	 imul	 rax, rax, 1
  00588	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00590	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00598	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  005a0	eb 20		 jmp	 SHORT $LN61@z900_kmo_a
$LN60@z900_kmo_a:
  005a2	b8 08 00 00 00	 mov	 eax, 8
  005a7	48 6b c0 01	 imul	 rax, rax, 1
  005ab	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  005ba	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
$LN61@z900_kmo_a:
  005c2	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ca	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  005d1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv336[rsp]
  005d9	48 23 c8	 and	 rcx, rax
  005dc	48 8b c1	 mov	 rax, rcx
  005df	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005ec	41 b9 01 00 00
	00		 mov	 r9d, 1
  005f2	4c 8b c0	 mov	 r8, rax
  005f5	b2 0f		 mov	 dl, 15
  005f7	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  005ff	e8 00 00 00 00	 call	 z900_vstorec
$LN10@z900_kmo_a:

; 3418 : 
; 3419 : #ifdef OPTION_KMO_DEBUG
; 3420 :     LOGBYTE("cv    :", parameter_block, 16);
; 3421 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3422 : 
; 3423 :     /* Update the registers */
; 3424 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  00604	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0060c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00612	83 e0 01	 and	 eax, 1
  00615	85 c0		 test	 eax, eax
  00617	74 7c		 je	 SHORT $LN21@z900_kmo_a
  00619	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00621	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00627	83 e0 01	 and	 eax, 1
  0062a	85 c0		 test	 eax, eax
  0062c	74 22		 je	 SHORT $LN62@z900_kmo_a
  0062e	48 63 84 24 50
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00636	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0063e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00646	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv364[rsp], rax
  0064e	eb 1f		 jmp	 SHORT $LN63@z900_kmo_a
$LN62@z900_kmo_a:
  00650	48 63 84 24 50
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00658	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00660	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00667	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv364[rsp], rax
$LN63@z900_kmo_a:
  0066f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv364[rsp]
  00677	48 83 c0 10	 add	 rax, 16
  0067b	48 63 8c 24 50
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00683	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0068b	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00693	eb 79		 jmp	 SHORT $LN22@z900_kmo_a
$LN21@z900_kmo_a:
  00695	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0069d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006a3	83 e0 01	 and	 eax, 1
  006a6	85 c0		 test	 eax, eax
  006a8	74 22		 je	 SHORT $LN64@z900_kmo_a
  006aa	48 63 84 24 50
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006b2	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ba	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  006c2	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv385[rsp], rax
  006ca	eb 1f		 jmp	 SHORT $LN65@z900_kmo_a
$LN64@z900_kmo_a:
  006cc	48 63 84 24 50
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006d4	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006dc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006e3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv385[rsp], rax
$LN65@z900_kmo_a:
  006eb	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv385[rsp]
  006f3	48 83 c0 10	 add	 rax, 16
  006f7	48 63 8c 24 50
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  006ff	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00707	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN22@z900_kmo_a:
  0070e	33 c0		 xor	 eax, eax
  00710	85 c0		 test	 eax, eax
  00712	0f 85 ec fe ff
	ff		 jne	 $LN10@z900_kmo_a

; 3425 :     if(likely(r1_is_not_r2))

  00718	83 7c 24 68 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  0071d	74 0a		 je	 SHORT $LN66@z900_kmo_a
  0071f	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv390[rsp], 1
  00727	eb 08		 jmp	 SHORT $LN67@z900_kmo_a
$LN66@z900_kmo_a:
  00729	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv390[rsp], 0
$LN67@z900_kmo_a:
  00731	83 7c 24 58 00	 cmp	 DWORD PTR tv390[rsp], 0
  00736	0f 84 14 01 00
	00		 je	 $LN23@z900_kmo_a
$LN13@z900_kmo_a:

; 3426 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  0073c	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00744	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0074a	83 e0 01	 and	 eax, 1
  0074d	85 c0		 test	 eax, eax
  0074f	74 7c		 je	 SHORT $LN24@z900_kmo_a
  00751	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00759	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0075f	83 e0 01	 and	 eax, 1
  00762	85 c0		 test	 eax, eax
  00764	74 22		 je	 SHORT $LN68@z900_kmo_a
  00766	48 63 84 24 58
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0076e	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00776	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0077e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv414[rsp], rax
  00786	eb 1f		 jmp	 SHORT $LN69@z900_kmo_a
$LN68@z900_kmo_a:
  00788	48 63 84 24 58
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00790	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00798	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0079f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv414[rsp], rax
$LN69@z900_kmo_a:
  007a7	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv414[rsp]
  007af	48 83 c0 10	 add	 rax, 16
  007b3	48 63 8c 24 58
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  007bb	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007c3	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  007cb	eb 79		 jmp	 SHORT $LN25@z900_kmo_a
$LN24@z900_kmo_a:
  007cd	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007d5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007db	83 e0 01	 and	 eax, 1
  007de	85 c0		 test	 eax, eax
  007e0	74 22		 je	 SHORT $LN70@z900_kmo_a
  007e2	48 63 84 24 58
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  007ea	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007fa	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv435[rsp], rax
  00802	eb 1f		 jmp	 SHORT $LN71@z900_kmo_a
$LN70@z900_kmo_a:
  00804	48 63 84 24 58
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0080c	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00814	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0081b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv435[rsp], rax
$LN71@z900_kmo_a:
  00823	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv435[rsp]
  0082b	48 83 c0 10	 add	 rax, 16
  0082f	48 63 8c 24 58
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00837	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0083f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN25@z900_kmo_a:
  00846	33 c0		 xor	 eax, eax
  00848	85 c0		 test	 eax, eax
  0084a	0f 85 ec fe ff
	ff		 jne	 $LN13@z900_kmo_a
$LN23@z900_kmo_a:
$LN16@z900_kmo_a:

; 3427 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00850	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00858	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0085e	83 e0 01	 and	 eax, 1
  00861	85 c0		 test	 eax, eax
  00863	0f 84 89 00 00
	00		 je	 $LN26@z900_kmo_a
  00869	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00871	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00877	83 e0 01	 and	 eax, 1
  0087a	85 c0		 test	 eax, eax
  0087c	74 25		 je	 SHORT $LN72@z900_kmo_a
  0087e	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00885	ff c0		 inc	 eax
  00887	48 98		 cdqe
  00889	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00891	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00899	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv464[rsp], rax
  008a1	eb 22		 jmp	 SHORT $LN73@z900_kmo_a
$LN72@z900_kmo_a:
  008a3	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008aa	ff c0		 inc	 eax
  008ac	48 98		 cdqe
  008ae	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008bd	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv464[rsp], rax
$LN73@z900_kmo_a:
  008c5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv464[rsp]
  008cd	48 83 e8 10	 sub	 rax, 16
  008d1	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  008d8	ff c1		 inc	 ecx
  008da	48 63 c9	 movsxd	 rcx, ecx
  008dd	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008e5	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  008ed	e9 83 00 00 00	 jmp	 $LN27@z900_kmo_a
$LN26@z900_kmo_a:
  008f2	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fa	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00900	83 e0 01	 and	 eax, 1
  00903	85 c0		 test	 eax, eax
  00905	74 25		 je	 SHORT $LN74@z900_kmo_a
  00907	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0090e	ff c0		 inc	 eax
  00910	48 98		 cdqe
  00912	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00922	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv488[rsp], rax
  0092a	eb 22		 jmp	 SHORT $LN75@z900_kmo_a
$LN74@z900_kmo_a:
  0092c	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00933	ff c0		 inc	 eax
  00935	48 98		 cdqe
  00937	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0093f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00946	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv488[rsp], rax
$LN75@z900_kmo_a:
  0094e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv488[rsp]
  00956	48 83 e8 10	 sub	 rax, 16
  0095a	8b 8c 24 58 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00961	ff c1		 inc	 ecx
  00963	48 63 c9	 movsxd	 rcx, ecx
  00966	48 8b 94 24 60
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0096e	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN27@z900_kmo_a:
  00975	33 c0		 xor	 eax, eax
  00977	85 c0		 test	 eax, eax
  00979	0f 85 d1 fe ff
	ff		 jne	 $LN16@z900_kmo_a

; 3428 : 
; 3429 : #ifdef OPTION_KMO_DEBUG
; 3430 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3431 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3432 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3433 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3434 : 
; 3435 :     /* check for end of data */
; 3436 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0097f	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00987	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0098d	83 e0 01	 and	 eax, 1
  00990	85 c0		 test	 eax, eax
  00992	74 25		 je	 SHORT $LN76@z900_kmo_a
  00994	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0099b	ff c0		 inc	 eax
  0099d	48 98		 cdqe
  0099f	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  009af	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv508[rsp], rax
  009b7	eb 22		 jmp	 SHORT $LN77@z900_kmo_a
$LN76@z900_kmo_a:
  009b9	8b 84 24 58 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009c0	ff c0		 inc	 eax
  009c2	48 98		 cdqe
  009c4	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009cc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009d3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv508[rsp], rax
$LN77@z900_kmo_a:
  009db	48 83 bc 24 d8
	00 00 00 00	 cmp	 QWORD PTR tv508[rsp], 0
  009e4	75 0a		 jne	 SHORT $LN78@z900_kmo_a
  009e6	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv510[rsp], 1
  009ee	eb 08		 jmp	 SHORT $LN79@z900_kmo_a
$LN78@z900_kmo_a:
  009f0	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv510[rsp], 0
$LN79@z900_kmo_a:
  009f8	83 7c 24 5c 00	 cmp	 DWORD PTR tv510[rsp], 0
  009fd	74 0a		 je	 SHORT $LN84@z900_kmo_a
  009ff	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv531[rsp], 1
  00a07	eb 08		 jmp	 SHORT $LN85@z900_kmo_a
$LN84@z900_kmo_a:
  00a09	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv531[rsp], 0
$LN85@z900_kmo_a:
  00a11	83 7c 24 60 00	 cmp	 DWORD PTR tv531[rsp], 0
  00a16	74 0e		 je	 SHORT $LN28@z900_kmo_a

; 3437 :     {
; 3438 :       regs->psw.cc = 0;

  00a18	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a20	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3439 :       return;

  00a24	eb 11		 jmp	 SHORT $LN1@z900_kmo_a
$LN28@z900_kmo_a:

; 3440 :     }
; 3441 :   }

  00a26	e9 90 f9 ff ff	 jmp	 $LN2@z900_kmo_a
$LN3@z900_kmo_a:

; 3442 : 
; 3443 :   /* CPU-determined amount of data processed */
; 3444 :   regs->psw.cc = 3;

  00a2b	48 8b 84 24 60
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a33	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmo_a:

; 3445 : }

  00a37	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a3f	48 33 cc	 xor	 rcx, rsp
  00a42	e8 00 00 00 00	 call	 __security_check_cookie
  00a47	48 81 c4 48 03
	00 00		 add	 rsp, 840		; 00000348H
  00a4e	c3		 ret	 0
z900_kmo_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv248 = 56
crypted$ = 60
tfc$ = 64
tv280 = 68
tv135 = 72
tv157 = 76
tv178 = 80
tv193 = 84
wrap$ = 88
keylen$ = 92
tv277 = 96
tv432 = 100
tv552 = 104
tv573 = 108
r1_is_not_r2$ = 112
tv550 = 120
tv80 = 128
tv155 = 136
tv214 = 144
tv232 = 152
tv321 = 160
tv358 = 168
tv378 = 176
tv406 = 184
tv427 = 192
tv456 = 200
tv477 = 208
tv506 = 216
tv530 = 224
context1$ = 240
context2$ = 384
context3$ = 528
message_block$ = 672
parameter_block$ = 680
__$ArrayPad$ = 736
r1$ = 768
r2$ = 776
regs$ = 784
z900_kmo_dea PROC

; 3157 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3158 :   des_context context1;
; 3159 :   des_context context2;
; 3160 :   des_context context3;
; 3161 :   int crypted;
; 3162 :   int i;
; 3163 :   int keylen;
; 3164 :   BYTE message_block[8];
; 3165 :   BYTE parameter_block[56];
; 3166 :   int parameter_blocklen;
; 3167 :   int r1_is_not_r2;
; 3168 :   int tfc;
; 3169 :   int wrap;
; 3170 : 
; 3171 :   /* Check special conditions */
; 3172 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 25		 je	 SHORT $LN40@z900_kmo_d
  0003b	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00042	ff c0		 inc	 eax
  00044	48 98		 cdqe
  00046	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00056	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  0005e	eb 22		 jmp	 SHORT $LN41@z900_kmo_d
$LN40@z900_kmo_d:
  00060	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00067	ff c0		 inc	 eax
  00069	48 98		 cdqe
  0006b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
$LN41@z900_kmo_d:
  00082	33 d2		 xor	 edx, edx
  00084	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  0008c	b9 08 00 00 00	 mov	 ecx, 8
  00091	48 f7 f1	 div	 rcx
  00094	48 8b c2	 mov	 rax, rdx
  00097	48 85 c0	 test	 rax, rax
  0009a	74 0a		 je	 SHORT $LN46@z900_kmo_d
  0009c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN47@z900_kmo_d
$LN46@z900_kmo_d:
  000a6	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN47@z900_kmo_d:
  000ae	83 7c 24 48 00	 cmp	 DWORD PTR tv135[rsp], 0
  000b3	74 13		 je	 SHORT $LN21@z900_kmo_d

; 3173 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000b5	ba 06 00 00 00	 mov	 edx, 6
  000ba	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN21@z900_kmo_d:

; 3174 : 
; 3175 :   /* Return with cc 0 on zero length */
; 3176 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000c8	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d6	83 e0 01	 and	 eax, 1
  000d9	85 c0		 test	 eax, eax
  000db	74 25		 je	 SHORT $LN48@z900_kmo_d
  000dd	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000e4	ff c0		 inc	 eax
  000e6	48 98		 cdqe
  000e8	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00100	eb 22		 jmp	 SHORT $LN49@z900_kmo_d
$LN48@z900_kmo_d:
  00102	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00109	ff c0		 inc	 eax
  0010b	48 98		 cdqe
  0010d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00115	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0011c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN49@z900_kmo_d:
  00124	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR tv155[rsp], 0
  0012d	75 0a		 jne	 SHORT $LN50@z900_kmo_d
  0012f	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  00137	eb 08		 jmp	 SHORT $LN51@z900_kmo_d
$LN50@z900_kmo_d:
  00139	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN51@z900_kmo_d:
  00141	83 7c 24 4c 00	 cmp	 DWORD PTR tv157[rsp], 0
  00146	74 0a		 je	 SHORT $LN56@z900_kmo_d
  00148	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00150	eb 08		 jmp	 SHORT $LN57@z900_kmo_d
$LN56@z900_kmo_d:
  00152	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN57@z900_kmo_d:
  0015a	83 7c 24 50 00	 cmp	 DWORD PTR tv178[rsp], 0
  0015f	74 11		 je	 SHORT $LN22@z900_kmo_d

; 3177 :   {
; 3178 :     regs->psw.cc = 0;

  00161	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3179 :     return;

  0016d	e9 69 0a 00 00	 jmp	 $LN1@z900_kmo_d
$LN22@z900_kmo_d:

; 3180 :   }
; 3181 : 
; 3182 :   /* Initialize values */
; 3183 :   tfc = GR0_tfc(regs);

  00172	b8 08 00 00 00	 mov	 eax, 8
  00177	48 6b c0 00	 imul	 rax, rax, 0
  0017b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0018a	83 e0 7f	 and	 eax, 127		; 0000007fH
  0018d	83 e0 77	 and	 eax, 119		; 00000077H
  00190	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 3184 :   wrap = GR0_wrap(regs);

  00194	b8 08 00 00 00	 mov	 eax, 8
  00199	48 6b c0 00	 imul	 rax, rax, 0
  0019d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ac	83 e0 08	 and	 eax, 8
  001af	85 c0		 test	 eax, eax
  001b1	74 0a		 je	 SHORT $LN58@z900_kmo_d
  001b3	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001bb	eb 08		 jmp	 SHORT $LN59@z900_kmo_d
$LN58@z900_kmo_d:
  001bd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN59@z900_kmo_d:
  001c5	8b 44 24 54	 mov	 eax, DWORD PTR tv193[rsp]
  001c9	89 44 24 58	 mov	 DWORD PTR wrap$[rsp], eax

; 3185 :   keylen = tfc * 8;

  001cd	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  001d1	c1 e0 03	 shl	 eax, 3
  001d4	89 44 24 5c	 mov	 DWORD PTR keylen$[rsp], eax

; 3186 :   parameter_blocklen = keylen + 8;

  001d8	8b 44 24 5c	 mov	 eax, DWORD PTR keylen$[rsp]
  001dc	83 c0 08	 add	 eax, 8
  001df	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3187 :   if(wrap)

  001e3	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001e8	74 0b		 je	 SHORT $LN23@z900_kmo_d

; 3188 :     parameter_blocklen += 24;

  001ea	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001ee	83 c0 18	 add	 eax, 24
  001f1	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN23@z900_kmo_d:

; 3189 : 
; 3190 :   /* Test writeability output chaining value */
; 3191 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  001f5	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00203	83 e0 01	 and	 eax, 1
  00206	85 c0		 test	 eax, eax
  00208	74 23		 je	 SHORT $LN60@z900_kmo_d
  0020a	b8 08 00 00 00	 mov	 eax, 8
  0020f	48 6b c0 01	 imul	 rax, rax, 1
  00213	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00223	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
  0022b	eb 20		 jmp	 SHORT $LN61@z900_kmo_d
$LN60@z900_kmo_d:
  0022d	b8 08 00 00 00	 mov	 eax, 8
  00232	48 6b c0 01	 imul	 rax, rax, 1
  00236	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00245	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
$LN61@z900_kmo_d:
  0024d	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00255	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0025c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv214[rsp]
  00264	48 23 c8	 and	 rcx, rax
  00267	48 8b c1	 mov	 rax, rcx
  0026a	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00277	41 b9 02 00 00
	00		 mov	 r9d, 2
  0027d	41 b8 07 00 00
	00		 mov	 r8d, 7
  00283	ba 01 00 00 00	 mov	 edx, 1
  00288	48 8b c8	 mov	 rcx, rax
  0028b	e8 00 00 00 00	 call	 z900_validate_operand

; 3192 : 
; 3193 :   /* Fetch the parameter block */
; 3194 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00290	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00298	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0029e	83 e0 01	 and	 eax, 1
  002a1	85 c0		 test	 eax, eax
  002a3	74 23		 je	 SHORT $LN62@z900_kmo_d
  002a5	b8 08 00 00 00	 mov	 eax, 8
  002aa	48 6b c0 01	 imul	 rax, rax, 1
  002ae	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b6	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002be	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv232[rsp], rax
  002c6	eb 20		 jmp	 SHORT $LN63@z900_kmo_d
$LN62@z900_kmo_d:
  002c8	b8 08 00 00 00	 mov	 eax, 8
  002cd	48 6b c0 01	 imul	 rax, rax, 1
  002d1	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002e0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv232[rsp], rax
$LN63@z900_kmo_d:
  002e8	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002f7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv232[rsp]
  002ff	48 23 c8	 and	 rcx, rax
  00302	48 8b c1	 mov	 rax, rcx
  00305	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00309	ff c9		 dec	 ecx
  0030b	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00313	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00318	41 b9 01 00 00
	00		 mov	 r9d, 1
  0031e	4c 8b c0	 mov	 r8, rax
  00321	0f b6 d1	 movzx	 edx, cl
  00324	48 8d 8c 24 a8
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0032c	e8 00 00 00 00	 call	 z900_vfetchc

; 3195 : 
; 3196 : #ifdef OPTION_KMO_DEBUG
; 3197 :   LOGBYTE("cv    :", parameter_block, 8);
; 3198 :   switch(tfc)
; 3199 :   {
; 3200 :     case 1: /* dea */
; 3201 :     {
; 3202 :       LOGBYTE("k     :", &parameter_block[8], 8);
; 3203 :       break;
; 3204 :     }
; 3205 :     case 2: /* tdea-128 */
; 3206 :     {
; 3207 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 3208 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 3209 :       break;
; 3210 :     }
; 3211 :     case 3: /* tdea-192 */
; 3212 :     {
; 3213 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 3214 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 3215 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 3216 :       break;
; 3217 :     }
; 3218 :   }
; 3219 :   if(wrap)
; 3220 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 3221 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3222 : 
; 3223 :   /* Verify and unwrap */
; 3224 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  00331	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00336	74 32		 je	 SHORT $LN24@z900_kmo_d
  00338	b8 01 00 00 00	 mov	 eax, 1
  0033d	48 6b c0 08	 imul	 rax, rax, 8
  00341	48 8d 84 04 a8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00349	8b 54 24 5c	 mov	 edx, DWORD PTR keylen$[rsp]
  0034d	48 8b c8	 mov	 rcx, rax
  00350	e8 00 00 00 00	 call	 unwrap_dea
  00355	85 c0		 test	 eax, eax
  00357	74 11		 je	 SHORT $LN24@z900_kmo_d

; 3225 :   {
; 3226 : 
; 3227 : #ifdef OPTION_KMO_DEBUG
; 3228 :     WRMSG(HHC90111, "D");
; 3229 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3230 : 
; 3231 :     regs->psw.cc = 1;

  00359	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00361	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3232 :     return;

  00365	e9 71 08 00 00	 jmp	 $LN1@z900_kmo_d
$LN24@z900_kmo_d:

; 3233 :   }
; 3234 : 
; 3235 :   /* Set the cryptographic key */
; 3236 :   switch(tfc)

  0036a	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0036e	89 44 24 38	 mov	 DWORD PTR tv248[rsp], eax
  00372	83 7c 24 38 01	 cmp	 DWORD PTR tv248[rsp], 1
  00377	74 13		 je	 SHORT $LN25@z900_kmo_d
  00379	83 7c 24 38 02	 cmp	 DWORD PTR tv248[rsp], 2
  0037e	74 32		 je	 SHORT $LN26@z900_kmo_d
  00380	83 7c 24 38 03	 cmp	 DWORD PTR tv248[rsp], 3
  00385	74 6f		 je	 SHORT $LN27@z900_kmo_d
  00387	e9 cd 00 00 00	 jmp	 $LN2@z900_kmo_d
$LN25@z900_kmo_d:

; 3237 :   {
; 3238 :     case 1: /* dea */
; 3239 :     {
; 3240 :       des_set_key(&context1, &parameter_block[8]);

  0038c	b8 01 00 00 00	 mov	 eax, 1
  00391	48 6b c0 08	 imul	 rax, rax, 8
  00395	48 8d 84 04 a8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0039d	48 8b d0	 mov	 rdx, rax
  003a0	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003a8	e8 00 00 00 00	 call	 des_set_key

; 3241 :       break;

  003ad	e9 a7 00 00 00	 jmp	 $LN2@z900_kmo_d
$LN26@z900_kmo_d:

; 3242 :     }
; 3243 :     case 2: /* tdea-128 */
; 3244 :     {
; 3245 :       des_set_key(&context1, &parameter_block[8]);

  003b2	b8 01 00 00 00	 mov	 eax, 1
  003b7	48 6b c0 08	 imul	 rax, rax, 8
  003bb	48 8d 84 04 a8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003c3	48 8b d0	 mov	 rdx, rax
  003c6	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003ce	e8 00 00 00 00	 call	 des_set_key

; 3246 :       des_set_key(&context2, &parameter_block[16]);

  003d3	b8 01 00 00 00	 mov	 eax, 1
  003d8	48 6b c0 10	 imul	 rax, rax, 16
  003dc	48 8d 84 04 a8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003e4	48 8b d0	 mov	 rdx, rax
  003e7	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  003ef	e8 00 00 00 00	 call	 des_set_key

; 3247 :       break;

  003f4	eb 63		 jmp	 SHORT $LN2@z900_kmo_d
$LN27@z900_kmo_d:

; 3248 :     }
; 3249 :     case 3: /* tdea-192 */
; 3250 :     {
; 3251 :       des_set_key(&context1, &parameter_block[8]);

  003f6	b8 01 00 00 00	 mov	 eax, 1
  003fb	48 6b c0 08	 imul	 rax, rax, 8
  003ff	48 8d 84 04 a8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00407	48 8b d0	 mov	 rdx, rax
  0040a	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00412	e8 00 00 00 00	 call	 des_set_key

; 3252 :       des_set_key(&context2, &parameter_block[16]);

  00417	b8 01 00 00 00	 mov	 eax, 1
  0041c	48 6b c0 10	 imul	 rax, rax, 16
  00420	48 8d 84 04 a8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00428	48 8b d0	 mov	 rdx, rax
  0042b	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00433	e8 00 00 00 00	 call	 des_set_key

; 3253 :       des_set_key(&context3, &parameter_block[24]);

  00438	b8 01 00 00 00	 mov	 eax, 1
  0043d	48 6b c0 18	 imul	 rax, rax, 24
  00441	48 8d 84 04 a8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00449	48 8b d0	 mov	 rdx, rax
  0044c	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00454	e8 00 00 00 00	 call	 des_set_key
$LN2@z900_kmo_d:

; 3254 :       break;
; 3255 :     }
; 3256 :   }
; 3257 : 
; 3258 :   /* Try to process the CPU-determined amount of data */
; 3259 :   r1_is_not_r2 = r1 != r2;

  00459	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00460	39 84 24 00 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00467	74 0a		 je	 SHORT $LN64@z900_kmo_d
  00469	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv277[rsp], 1
  00471	eb 08		 jmp	 SHORT $LN65@z900_kmo_d
$LN64@z900_kmo_d:
  00473	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv277[rsp], 0
$LN65@z900_kmo_d:
  0047b	8b 44 24 60	 mov	 eax, DWORD PTR tv277[rsp]
  0047f	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 3260 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  00483	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0048b	eb 0b		 jmp	 SHORT $LN6@z900_kmo_d
$LN4@z900_kmo_d:
  0048d	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00491	83 c0 08	 add	 eax, 8
  00494	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@z900_kmo_d:
  00498	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  004a0	0f 8d 29 07 00
	00		 jge	 $LN5@z900_kmo_d

; 3261 :   {
; 3262 :     /* Do the job */
; 3263 :     switch(tfc)

  004a6	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  004aa	89 44 24 44	 mov	 DWORD PTR tv280[rsp], eax
  004ae	83 7c 24 44 01	 cmp	 DWORD PTR tv280[rsp], 1
  004b3	74 17		 je	 SHORT $LN28@z900_kmo_d
  004b5	83 7c 24 44 02	 cmp	 DWORD PTR tv280[rsp], 2
  004ba	74 32		 je	 SHORT $LN29@z900_kmo_d
  004bc	83 7c 24 44 03	 cmp	 DWORD PTR tv280[rsp], 3
  004c1	0f 84 80 00 00
	00		 je	 $LN30@z900_kmo_d
  004c7	e9 d2 00 00 00	 jmp	 $LN7@z900_kmo_d
$LN28@z900_kmo_d:

; 3264 :     {
; 3265 :       case 1: /* dea */
; 3266 :       {
; 3267 :         des_encrypt(&context1, parameter_block, parameter_block);

  004cc	4c 8d 84 24 a8
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  004d4	48 8d 94 24 a8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  004dc	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  004e4	e8 00 00 00 00	 call	 des_encrypt

; 3268 :         break;

  004e9	e9 b0 00 00 00	 jmp	 $LN7@z900_kmo_d
$LN29@z900_kmo_d:

; 3269 :       }
; 3270 :       case 2: /* tdea-128 */
; 3271 :       {
; 3272 :         des_encrypt(&context1, parameter_block, parameter_block);

  004ee	4c 8d 84 24 a8
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  004f6	48 8d 94 24 a8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  004fe	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00506	e8 00 00 00 00	 call	 des_encrypt

; 3273 :         des_decrypt(&context2, parameter_block, parameter_block);

  0050b	4c 8d 84 24 a8
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00513	48 8d 94 24 a8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0051b	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00523	e8 00 00 00 00	 call	 des_decrypt

; 3274 :         des_encrypt(&context1, parameter_block, parameter_block);

  00528	4c 8d 84 24 a8
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00530	48 8d 94 24 a8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00538	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00540	e8 00 00 00 00	 call	 des_encrypt

; 3275 :         break;

  00545	eb 57		 jmp	 SHORT $LN7@z900_kmo_d
$LN30@z900_kmo_d:

; 3276 :       }
; 3277 :       case 3: /* tdea-192 */
; 3278 :       {
; 3279 :         des_encrypt(&context1, parameter_block, parameter_block);

  00547	4c 8d 84 24 a8
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0054f	48 8d 94 24 a8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00557	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0055f	e8 00 00 00 00	 call	 des_encrypt

; 3280 :         des_decrypt(&context2, parameter_block, parameter_block);

  00564	4c 8d 84 24 a8
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0056c	48 8d 94 24 a8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00574	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0057c	e8 00 00 00 00	 call	 des_decrypt

; 3281 :         des_encrypt(&context3, parameter_block, parameter_block);

  00581	4c 8d 84 24 a8
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00589	48 8d 94 24 a8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00591	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00599	e8 00 00 00 00	 call	 des_encrypt
$LN7@z900_kmo_d:

; 3282 :         break;
; 3283 :       }
; 3284 :     }
; 3285 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0059e	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005ac	83 e0 01	 and	 eax, 1
  005af	85 c0		 test	 eax, eax
  005b1	74 22		 je	 SHORT $LN66@z900_kmo_d
  005b3	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005bb	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c3	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  005cb	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv321[rsp], rax
  005d3	eb 1f		 jmp	 SHORT $LN67@z900_kmo_d
$LN66@z900_kmo_d:
  005d5	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005dd	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005ec	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv321[rsp], rax
$LN67@z900_kmo_d:
  005f4	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005fc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00603	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv321[rsp]
  0060b	48 23 c8	 and	 rcx, rax
  0060e	48 8b c1	 mov	 rax, rcx
  00611	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00619	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0061e	44 8b 8c 24 08
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00626	4c 8b c0	 mov	 r8, rax
  00629	b2 07		 mov	 dl, 7
  0062b	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00633	e8 00 00 00 00	 call	 z900_vfetchc

; 3286 : 
; 3287 : #ifdef OPTION_KMO_DEBUG
; 3288 :     LOGBYTE("input :", message_block, 8);
; 3289 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3290 : 
; 3291 :     for(i = 0; i < 8; i++)

  00638	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00640	eb 0a		 jmp	 SHORT $LN11@z900_kmo_d
$LN9@z900_kmo_d:
  00642	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00646	ff c0		 inc	 eax
  00648	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@z900_kmo_d:
  0064c	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00651	7d 2a		 jge	 SHORT $LN10@z900_kmo_d

; 3292 :       message_block[i] ^= parameter_block[i];

  00653	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00658	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0065d	0f b6 8c 0c a8
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00665	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0066d	33 c1		 xor	 eax, ecx
  0066f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00674	88 84 0c a0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0067b	eb c5		 jmp	 SHORT $LN9@z900_kmo_d
$LN10@z900_kmo_d:

; 3293 : 
; 3294 :     /* Store the output */
; 3295 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0067d	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00685	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0068b	83 e0 01	 and	 eax, 1
  0068e	85 c0		 test	 eax, eax
  00690	74 22		 je	 SHORT $LN68@z900_kmo_d
  00692	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0069a	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  006aa	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv358[rsp], rax
  006b2	eb 1f		 jmp	 SHORT $LN69@z900_kmo_d
$LN68@z900_kmo_d:
  006b4	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006bc	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006cb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv358[rsp], rax
$LN69@z900_kmo_d:
  006d3	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006db	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  006e2	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv358[rsp]
  006ea	48 23 c8	 and	 rcx, rax
  006ed	48 8b c1	 mov	 rax, rcx
  006f0	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006f8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006fd	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  00705	4c 8b c0	 mov	 r8, rax
  00708	b2 07		 mov	 dl, 7
  0070a	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00712	e8 00 00 00 00	 call	 z900_vstorec

; 3296 : 
; 3297 : #ifdef OPTION_KMO_DEBUG
; 3298 :     LOGBYTE("output:", message_block, 8);
; 3299 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3300 : 
; 3301 :     /* Store the chaining value */
; 3302 :     ARCH_DEP(vstorec)(parameter_block, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00717	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0071f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00725	83 e0 01	 and	 eax, 1
  00728	85 c0		 test	 eax, eax
  0072a	74 23		 je	 SHORT $LN70@z900_kmo_d
  0072c	b8 08 00 00 00	 mov	 eax, 8
  00731	48 6b c0 01	 imul	 rax, rax, 1
  00735	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0073d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00745	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv378[rsp], rax
  0074d	eb 20		 jmp	 SHORT $LN71@z900_kmo_d
$LN70@z900_kmo_d:
  0074f	b8 08 00 00 00	 mov	 eax, 8
  00754	48 6b c0 01	 imul	 rax, rax, 1
  00758	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00760	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00767	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv378[rsp], rax
$LN71@z900_kmo_d:
  0076f	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00777	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0077e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv378[rsp]
  00786	48 23 c8	 and	 rcx, rax
  00789	48 8b c1	 mov	 rax, rcx
  0078c	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00794	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00799	41 b9 01 00 00
	00		 mov	 r9d, 1
  0079f	4c 8b c0	 mov	 r8, rax
  007a2	b2 07		 mov	 dl, 7
  007a4	48 8d 8c 24 a8
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  007ac	e8 00 00 00 00	 call	 z900_vstorec
$LN14@z900_kmo_d:

; 3303 : 
; 3304 : #ifdef OPTION_KMO_DEBUG
; 3305 :     LOGBYTE("cv    :", parameter_block, 8);
; 3306 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3307 : 
; 3308 :     /* Update the registers */
; 3309 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  007b1	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007b9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007bf	83 e0 01	 and	 eax, 1
  007c2	85 c0		 test	 eax, eax
  007c4	74 7c		 je	 SHORT $LN31@z900_kmo_d
  007c6	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007ce	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007d4	83 e0 01	 and	 eax, 1
  007d7	85 c0		 test	 eax, eax
  007d9	74 22		 je	 SHORT $LN72@z900_kmo_d
  007db	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007e3	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007eb	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007f3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv406[rsp], rax
  007fb	eb 1f		 jmp	 SHORT $LN73@z900_kmo_d
$LN72@z900_kmo_d:
  007fd	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00805	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00814	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv406[rsp], rax
$LN73@z900_kmo_d:
  0081c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv406[rsp]
  00824	48 83 c0 08	 add	 rax, 8
  00828	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00830	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00838	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00840	eb 79		 jmp	 SHORT $LN32@z900_kmo_d
$LN31@z900_kmo_d:
  00842	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0084a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00850	83 e0 01	 and	 eax, 1
  00853	85 c0		 test	 eax, eax
  00855	74 22		 je	 SHORT $LN74@z900_kmo_d
  00857	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0085f	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00867	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0086f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv427[rsp], rax
  00877	eb 1f		 jmp	 SHORT $LN75@z900_kmo_d
$LN74@z900_kmo_d:
  00879	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00881	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00889	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00890	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv427[rsp], rax
$LN75@z900_kmo_d:
  00898	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv427[rsp]
  008a0	48 83 c0 08	 add	 rax, 8
  008a4	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  008ac	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008b4	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN32@z900_kmo_d:
  008bb	33 c0		 xor	 eax, eax
  008bd	85 c0		 test	 eax, eax
  008bf	0f 85 ec fe ff
	ff		 jne	 $LN14@z900_kmo_d

; 3310 :     if(likely(r1_is_not_r2))

  008c5	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  008ca	74 0a		 je	 SHORT $LN76@z900_kmo_d
  008cc	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv432[rsp], 1
  008d4	eb 08		 jmp	 SHORT $LN77@z900_kmo_d
$LN76@z900_kmo_d:
  008d6	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv432[rsp], 0
$LN77@z900_kmo_d:
  008de	83 7c 24 64 00	 cmp	 DWORD PTR tv432[rsp], 0
  008e3	0f 84 14 01 00
	00		 je	 $LN33@z900_kmo_d
$LN17@z900_kmo_d:

; 3311 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  008e9	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008f1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008f7	83 e0 01	 and	 eax, 1
  008fa	85 c0		 test	 eax, eax
  008fc	74 7c		 je	 SHORT $LN34@z900_kmo_d
  008fe	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00906	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0090c	83 e0 01	 and	 eax, 1
  0090f	85 c0		 test	 eax, eax
  00911	74 22		 je	 SHORT $LN78@z900_kmo_d
  00913	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0091b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00923	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0092b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv456[rsp], rax
  00933	eb 1f		 jmp	 SHORT $LN79@z900_kmo_d
$LN78@z900_kmo_d:
  00935	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0093d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00945	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0094c	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv456[rsp], rax
$LN79@z900_kmo_d:
  00954	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv456[rsp]
  0095c	48 83 c0 08	 add	 rax, 8
  00960	48 63 8c 24 08
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00968	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00970	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00978	eb 79		 jmp	 SHORT $LN35@z900_kmo_d
$LN34@z900_kmo_d:
  0097a	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00982	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00988	83 e0 01	 and	 eax, 1
  0098b	85 c0		 test	 eax, eax
  0098d	74 22		 je	 SHORT $LN80@z900_kmo_d
  0098f	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00997	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0099f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  009a7	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv477[rsp], rax
  009af	eb 1f		 jmp	 SHORT $LN81@z900_kmo_d
$LN80@z900_kmo_d:
  009b1	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  009b9	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009c8	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv477[rsp], rax
$LN81@z900_kmo_d:
  009d0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv477[rsp]
  009d8	48 83 c0 08	 add	 rax, 8
  009dc	48 63 8c 24 08
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  009e4	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009ec	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN35@z900_kmo_d:
  009f3	33 c0		 xor	 eax, eax
  009f5	85 c0		 test	 eax, eax
  009f7	0f 85 ec fe ff
	ff		 jne	 $LN17@z900_kmo_d
$LN33@z900_kmo_d:
$LN20@z900_kmo_d:

; 3312 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  009fd	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a05	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a0b	83 e0 01	 and	 eax, 1
  00a0e	85 c0		 test	 eax, eax
  00a10	0f 84 89 00 00
	00		 je	 $LN36@z900_kmo_d
  00a16	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a1e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a24	83 e0 01	 and	 eax, 1
  00a27	85 c0		 test	 eax, eax
  00a29	74 25		 je	 SHORT $LN82@z900_kmo_d
  00a2b	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a32	ff c0		 inc	 eax
  00a34	48 98		 cdqe
  00a36	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a3e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a46	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv506[rsp], rax
  00a4e	eb 22		 jmp	 SHORT $LN83@z900_kmo_d
$LN82@z900_kmo_d:
  00a50	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a57	ff c0		 inc	 eax
  00a59	48 98		 cdqe
  00a5b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a63	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a6a	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv506[rsp], rax
$LN83@z900_kmo_d:
  00a72	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv506[rsp]
  00a7a	48 83 e8 08	 sub	 rax, 8
  00a7e	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00a85	ff c1		 inc	 ecx
  00a87	48 63 c9	 movsxd	 rcx, ecx
  00a8a	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a92	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00a9a	e9 83 00 00 00	 jmp	 $LN37@z900_kmo_d
$LN36@z900_kmo_d:
  00a9f	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00aad	83 e0 01	 and	 eax, 1
  00ab0	85 c0		 test	 eax, eax
  00ab2	74 25		 je	 SHORT $LN84@z900_kmo_d
  00ab4	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00abb	ff c0		 inc	 eax
  00abd	48 98		 cdqe
  00abf	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00acf	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv530[rsp], rax
  00ad7	eb 22		 jmp	 SHORT $LN85@z900_kmo_d
$LN84@z900_kmo_d:
  00ad9	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00ae0	ff c0		 inc	 eax
  00ae2	48 98		 cdqe
  00ae4	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aec	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00af3	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv530[rsp], rax
$LN85@z900_kmo_d:
  00afb	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv530[rsp]
  00b03	48 83 e8 08	 sub	 rax, 8
  00b07	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00b0e	ff c1		 inc	 ecx
  00b10	48 63 c9	 movsxd	 rcx, ecx
  00b13	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b1b	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN37@z900_kmo_d:
  00b22	33 c0		 xor	 eax, eax
  00b24	85 c0		 test	 eax, eax
  00b26	0f 85 d1 fe ff
	ff		 jne	 $LN20@z900_kmo_d

; 3313 : 
; 3314 : #ifdef OPTION_KMO_DEBUG
; 3315 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3316 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3317 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3318 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3319 : 
; 3320 :     /* check for end of data */
; 3321 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00b2c	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b34	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b3a	83 e0 01	 and	 eax, 1
  00b3d	85 c0		 test	 eax, eax
  00b3f	74 22		 je	 SHORT $LN86@z900_kmo_d
  00b41	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00b48	ff c0		 inc	 eax
  00b4a	48 98		 cdqe
  00b4c	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b54	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00b5c	48 89 44 24 78	 mov	 QWORD PTR tv550[rsp], rax
  00b61	eb 1f		 jmp	 SHORT $LN87@z900_kmo_d
$LN86@z900_kmo_d:
  00b63	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00b6a	ff c0		 inc	 eax
  00b6c	48 98		 cdqe
  00b6e	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b76	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00b7d	48 89 44 24 78	 mov	 QWORD PTR tv550[rsp], rax
$LN87@z900_kmo_d:
  00b82	48 83 7c 24 78
	00		 cmp	 QWORD PTR tv550[rsp], 0
  00b88	75 0a		 jne	 SHORT $LN88@z900_kmo_d
  00b8a	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv552[rsp], 1
  00b92	eb 08		 jmp	 SHORT $LN89@z900_kmo_d
$LN88@z900_kmo_d:
  00b94	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv552[rsp], 0
$LN89@z900_kmo_d:
  00b9c	83 7c 24 68 00	 cmp	 DWORD PTR tv552[rsp], 0
  00ba1	74 0a		 je	 SHORT $LN94@z900_kmo_d
  00ba3	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv573[rsp], 1
  00bab	eb 08		 jmp	 SHORT $LN95@z900_kmo_d
$LN94@z900_kmo_d:
  00bad	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv573[rsp], 0
$LN95@z900_kmo_d:
  00bb5	83 7c 24 6c 00	 cmp	 DWORD PTR tv573[rsp], 0
  00bba	74 0e		 je	 SHORT $LN38@z900_kmo_d

; 3322 :     {
; 3323 :       regs->psw.cc = 0;

  00bbc	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bc4	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3324 :       return;

  00bc8	eb 11		 jmp	 SHORT $LN1@z900_kmo_d
$LN38@z900_kmo_d:

; 3325 :     }
; 3326 :   }

  00bca	e9 be f8 ff ff	 jmp	 $LN4@z900_kmo_d
$LN5@z900_kmo_d:

; 3327 : 
; 3328 :   /* CPU-determined amount of data processed */
; 3329 :   regs->psw.cc = 3;

  00bcf	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bd7	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmo_d:

; 3330 : }

  00bdb	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00be3	48 33 cc	 xor	 rcx, rsp
  00be6	e8 00 00 00 00	 call	 __security_check_cookie
  00beb	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  00bf2	c3		 ret	 0
z900_kmo_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
lcfb$ = 52
parameter_blocklen$ = 56
keylen$ = 60
crypted$ = 64
tv146 = 68
tv168 = 72
tv189 = 76
tv204 = 80
wrap$ = 84
tv273 = 88
tv275 = 92
tv445 = 96
tv569 = 100
tv590 = 104
tfc$ = 108
modifier_bit$ = 112
r1_is_not_r2$ = 116
tv85 = 120
tv166 = 128
tv227 = 136
tv245 = 144
tv297 = 152
tv367 = 160
tv389 = 168
tv417 = 176
tv439 = 184
tv469 = 192
tv491 = 200
tv521 = 208
tv546 = 216
tv567 = 224
tv86 = 232
context$ = 240
output_block$ = 736
message_block$ = 752
parameter_block$ = 768
__$ArrayPad$ = 848
r1$ = 880
r2$ = 888
regs$ = 896
z900_kmf_aes PROC

; 3021 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3022 :   rijndael_ctx context;
; 3023 :   int crypted;
; 3024 :   int i;
; 3025 :   int keylen;
; 3026 :   int lcfb;
; 3027 :   BYTE message_block[16];
; 3028 :   int modifier_bit;
; 3029 :   BYTE output_block[16];
; 3030 :   BYTE parameter_block[80];
; 3031 :   int parameter_blocklen;
; 3032 :   int r1_is_not_r2;
; 3033 :   int tfc;
; 3034 :   int wrap;
; 3035 : 
; 3036 :   /* Initialize values */
; 3037 :   lcfb = GR0_lcfb(regs);

  00026	b8 08 00 00 00	 mov	 eax, 8
  0002b	48 6b c0 00	 imul	 rax, rax, 0
  0002f	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0003e	c1 e8 18	 shr	 eax, 24
  00041	89 44 24 34	 mov	 DWORD PTR lcfb$[rsp], eax

; 3038 : 
; 3039 :   /* Check special conditions */
; 3040 :   if(unlikely(GR_A(r2 + 1, regs) % lcfb || !lcfb || lcfb > 16))

  00045	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0004d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00053	83 e0 01	 and	 eax, 1
  00056	85 c0		 test	 eax, eax
  00058	74 22		 je	 SHORT $LN41@z900_kmf_a
  0005a	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00061	ff c0		 inc	 eax
  00063	48 98		 cdqe
  00065	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0006d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00075	48 89 44 24 78	 mov	 QWORD PTR tv85[rsp], rax
  0007a	eb 1f		 jmp	 SHORT $LN42@z900_kmf_a
$LN41@z900_kmf_a:
  0007c	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00083	ff c0		 inc	 eax
  00085	48 98		 cdqe
  00087	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00096	48 89 44 24 78	 mov	 QWORD PTR tv85[rsp], rax
$LN42@z900_kmf_a:
  0009b	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  000a0	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv86[rsp], rax
  000a8	33 d2		 xor	 edx, edx
  000aa	48 8b 44 24 78	 mov	 rax, QWORD PTR tv85[rsp]
  000af	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv86[rsp]
  000b7	48 f7 f1	 div	 rcx
  000ba	48 8b c2	 mov	 rax, rdx
  000bd	48 85 c0	 test	 rax, rax
  000c0	75 18		 jne	 SHORT $LN43@z900_kmf_a
  000c2	83 7c 24 34 00	 cmp	 DWORD PTR lcfb$[rsp], 0
  000c7	74 11		 je	 SHORT $LN43@z900_kmf_a
  000c9	83 7c 24 34 10	 cmp	 DWORD PTR lcfb$[rsp], 16
  000ce	7f 0a		 jg	 SHORT $LN43@z900_kmf_a
  000d0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
  000d8	eb 08		 jmp	 SHORT $LN48@z900_kmf_a
$LN43@z900_kmf_a:
  000da	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
$LN48@z900_kmf_a:
  000e2	83 7c 24 44 00	 cmp	 DWORD PTR tv146[rsp], 0
  000e7	74 13		 je	 SHORT $LN26@z900_kmf_a

; 3041 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000e9	ba 06 00 00 00	 mov	 edx, 6
  000ee	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN26@z900_kmf_a:

; 3042 : 
; 3043 :   /* Return with cc 0 on zero length */
; 3044 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000fc	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00104	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0010a	83 e0 01	 and	 eax, 1
  0010d	85 c0		 test	 eax, eax
  0010f	74 25		 je	 SHORT $LN49@z900_kmf_a
  00111	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00118	ff c0		 inc	 eax
  0011a	48 98		 cdqe
  0011c	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00124	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0012c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  00134	eb 22		 jmp	 SHORT $LN50@z900_kmf_a
$LN49@z900_kmf_a:
  00136	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0013d	ff c0		 inc	 eax
  0013f	48 98		 cdqe
  00141	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00149	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00150	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
$LN50@z900_kmf_a:
  00158	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv166[rsp], 0
  00161	75 0a		 jne	 SHORT $LN51@z900_kmf_a
  00163	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
  0016b	eb 08		 jmp	 SHORT $LN52@z900_kmf_a
$LN51@z900_kmf_a:
  0016d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv168[rsp], 0
$LN52@z900_kmf_a:
  00175	83 7c 24 48 00	 cmp	 DWORD PTR tv168[rsp], 0
  0017a	74 0a		 je	 SHORT $LN57@z900_kmf_a
  0017c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
  00184	eb 08		 jmp	 SHORT $LN58@z900_kmf_a
$LN57@z900_kmf_a:
  00186	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv189[rsp], 0
$LN58@z900_kmf_a:
  0018e	83 7c 24 4c 00	 cmp	 DWORD PTR tv189[rsp], 0
  00193	74 11		 je	 SHORT $LN27@z900_kmf_a

; 3045 :   {
; 3046 :     regs->psw.cc = 0;

  00195	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0019d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3047 :     return;

  001a1	e9 34 0a 00 00	 jmp	 $LN1@z900_kmf_a
$LN27@z900_kmf_a:

; 3048 :   }
; 3049 : 
; 3050 :   /* Initialize values */
; 3051 :   tfc = GR0_tfc(regs);

  001a6	b8 08 00 00 00	 mov	 eax, 8
  001ab	48 6b c0 00	 imul	 rax, rax, 0
  001af	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001be	83 e0 7f	 and	 eax, 127		; 0000007fH
  001c1	83 e0 77	 and	 eax, 119		; 00000077H
  001c4	89 44 24 6c	 mov	 DWORD PTR tfc$[rsp], eax

; 3052 :   wrap = GR0_wrap(regs);

  001c8	b8 08 00 00 00	 mov	 eax, 8
  001cd	48 6b c0 00	 imul	 rax, rax, 0
  001d1	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d9	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e0	83 e0 08	 and	 eax, 8
  001e3	85 c0		 test	 eax, eax
  001e5	74 0a		 je	 SHORT $LN59@z900_kmf_a
  001e7	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  001ef	eb 08		 jmp	 SHORT $LN60@z900_kmf_a
$LN59@z900_kmf_a:
  001f1	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN60@z900_kmf_a:
  001f9	8b 44 24 50	 mov	 eax, DWORD PTR tv204[rsp]
  001fd	89 44 24 54	 mov	 DWORD PTR wrap$[rsp], eax

; 3053 :   keylen = (tfc - 17) * 8 + 8;

  00201	8b 44 24 6c	 mov	 eax, DWORD PTR tfc$[rsp]
  00205	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  0020c	89 44 24 3c	 mov	 DWORD PTR keylen$[rsp], eax

; 3054 :   parameter_blocklen = keylen + 16;

  00210	8b 44 24 3c	 mov	 eax, DWORD PTR keylen$[rsp]
  00214	83 c0 10	 add	 eax, 16
  00217	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3055 :   if(wrap)

  0021b	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00220	74 0b		 je	 SHORT $LN28@z900_kmf_a

; 3056 :     parameter_blocklen += 32;

  00222	8b 44 24 38	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00226	83 c0 20	 add	 eax, 32			; 00000020H
  00229	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN28@z900_kmf_a:

; 3057 : 
; 3058 :   /* Test writeability output chaining value */
; 3059 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  0022d	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00235	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0023b	83 e0 01	 and	 eax, 1
  0023e	85 c0		 test	 eax, eax
  00240	74 23		 je	 SHORT $LN61@z900_kmf_a
  00242	b8 08 00 00 00	 mov	 eax, 8
  00247	48 6b c0 01	 imul	 rax, rax, 1
  0024b	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00253	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0025b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
  00263	eb 20		 jmp	 SHORT $LN62@z900_kmf_a
$LN61@z900_kmf_a:
  00265	b8 08 00 00 00	 mov	 eax, 8
  0026a	48 6b c0 01	 imul	 rax, rax, 1
  0026e	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00276	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0027d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv227[rsp], rax
$LN62@z900_kmf_a:
  00285	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00294	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv227[rsp]
  0029c	48 23 c8	 and	 rcx, rax
  0029f	48 8b c1	 mov	 rax, rcx
  002a2	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002aa	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002af	41 b9 02 00 00
	00		 mov	 r9d, 2
  002b5	41 b8 0f 00 00
	00		 mov	 r8d, 15
  002bb	ba 01 00 00 00	 mov	 edx, 1
  002c0	48 8b c8	 mov	 rcx, rax
  002c3	e8 00 00 00 00	 call	 z900_validate_operand

; 3060 : 
; 3061 :   /* Fetch the parameter block */
; 3062 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  002c8	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002d6	83 e0 01	 and	 eax, 1
  002d9	85 c0		 test	 eax, eax
  002db	74 23		 je	 SHORT $LN63@z900_kmf_a
  002dd	b8 08 00 00 00	 mov	 eax, 8
  002e2	48 6b c0 01	 imul	 rax, rax, 1
  002e6	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ee	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002f6	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv245[rsp], rax
  002fe	eb 20		 jmp	 SHORT $LN64@z900_kmf_a
$LN63@z900_kmf_a:
  00300	b8 08 00 00 00	 mov	 eax, 8
  00305	48 6b c0 01	 imul	 rax, rax, 1
  00309	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00318	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv245[rsp], rax
$LN64@z900_kmf_a:
  00320	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00328	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0032f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv245[rsp]
  00337	48 23 c8	 and	 rcx, rax
  0033a	48 8b c1	 mov	 rax, rcx
  0033d	8b 4c 24 38	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00341	ff c9		 dec	 ecx
  00343	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0034b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00350	41 b9 01 00 00
	00		 mov	 r9d, 1
  00356	4c 8b c0	 mov	 r8, rax
  00359	0f b6 d1	 movzx	 edx, cl
  0035c	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00364	e8 00 00 00 00	 call	 z900_vfetchc

; 3063 : 
; 3064 : #ifdef OPTION_KMF_DEBUG
; 3065 :   LOGBYTE("cv    :", parameter_block, 16);
; 3066 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 3067 :   if(wrap)
; 3068 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 32], 32);
; 3069 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3070 : 
; 3071 :   /* Verify and unwrap */
; 3072 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  00369	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0036e	74 32		 je	 SHORT $LN29@z900_kmf_a
  00370	b8 01 00 00 00	 mov	 eax, 1
  00375	48 6b c0 10	 imul	 rax, rax, 16
  00379	48 8d 84 04 00
	03 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00381	8b 54 24 3c	 mov	 edx, DWORD PTR keylen$[rsp]
  00385	48 8b c8	 mov	 rcx, rax
  00388	e8 00 00 00 00	 call	 unwrap_aes
  0038d	85 c0		 test	 eax, eax
  0038f	74 11		 je	 SHORT $LN29@z900_kmf_a

; 3073 :   {
; 3074 : 
; 3075 : #ifdef OPTION_KMF_DEBUG
; 3076 :     WRMSG(HHC90111, "D");
; 3077 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3078 : 
; 3079 :     regs->psw.cc = 1;

  00391	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00399	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3080 :     return;

  0039d	e9 38 08 00 00	 jmp	 $LN1@z900_kmf_a
$LN29@z900_kmf_a:

; 3081 :   }
; 3082 : 
; 3083 :   /* Set the cryptographic key */
; 3084 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  003a2	8b 44 24 3c	 mov	 eax, DWORD PTR keylen$[rsp]
  003a6	c1 e0 03	 shl	 eax, 3
  003a9	b9 01 00 00 00	 mov	 ecx, 1
  003ae	48 6b c9 10	 imul	 rcx, rcx, 16
  003b2	48 8d 8c 0c 00
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  003ba	44 8b c0	 mov	 r8d, eax
  003bd	48 8b d1	 mov	 rdx, rcx
  003c0	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  003c8	e8 00 00 00 00	 call	 rijndael_set_key

; 3085 : 
; 3086 :   /* Try to process the CPU-determined amount of data */
; 3087 :   modifier_bit = GR0_m(regs);

  003cd	b8 08 00 00 00	 mov	 eax, 8
  003d2	48 6b c0 00	 imul	 rax, rax, 0
  003d6	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003de	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003e5	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003ea	85 c0		 test	 eax, eax
  003ec	74 0a		 je	 SHORT $LN65@z900_kmf_a
  003ee	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv273[rsp], 1
  003f6	eb 08		 jmp	 SHORT $LN66@z900_kmf_a
$LN65@z900_kmf_a:
  003f8	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv273[rsp], 0
$LN66@z900_kmf_a:
  00400	8b 44 24 58	 mov	 eax, DWORD PTR tv273[rsp]
  00404	89 44 24 70	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 3088 :   r1_is_not_r2 = r1 != r2;

  00408	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0040f	39 84 24 70 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00416	74 0a		 je	 SHORT $LN67@z900_kmf_a
  00418	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv275[rsp], 1
  00420	eb 08		 jmp	 SHORT $LN68@z900_kmf_a
$LN67@z900_kmf_a:
  00422	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv275[rsp], 0
$LN68@z900_kmf_a:
  0042a	8b 44 24 5c	 mov	 eax, DWORD PTR tv275[rsp]
  0042e	89 44 24 74	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 3089 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += lcfb)

  00432	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0043a	eb 10		 jmp	 SHORT $LN4@z900_kmf_a
$LN2@z900_kmf_a:
  0043c	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00440	8b 4c 24 40	 mov	 ecx, DWORD PTR crypted$[rsp]
  00444	03 c8		 add	 ecx, eax
  00446	8b c1		 mov	 eax, ecx
  00448	89 44 24 40	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@z900_kmf_a:
  0044c	81 7c 24 40 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00454	0f 8d 74 07 00
	00		 jge	 $LN3@z900_kmf_a

; 3090 :   {
; 3091 :     rijndael_encrypt(&context, parameter_block, output_block);

  0045a	4c 8d 84 24 e0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00462	48 8d 94 24 00
	03 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0046a	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00472	e8 00 00 00 00	 call	 rijndael_encrypt

; 3092 :     ARCH_DEP(vfetchc)(message_block, lcfb - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00477	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00485	83 e0 01	 and	 eax, 1
  00488	85 c0		 test	 eax, eax
  0048a	74 22		 je	 SHORT $LN69@z900_kmf_a
  0048c	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00494	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  004a4	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv297[rsp], rax
  004ac	eb 1f		 jmp	 SHORT $LN70@z900_kmf_a
$LN69@z900_kmf_a:
  004ae	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004b6	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004be	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004c5	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv297[rsp], rax
$LN70@z900_kmf_a:
  004cd	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004dc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv297[rsp]
  004e4	48 23 c8	 and	 rcx, rax
  004e7	48 8b c1	 mov	 rax, rcx
  004ea	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  004ee	ff c9		 dec	 ecx
  004f0	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004f8	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  004fd	44 8b 8c 24 78
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00505	4c 8b c0	 mov	 r8, rax
  00508	0f b6 d1	 movzx	 edx, cl
  0050b	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00513	e8 00 00 00 00	 call	 z900_vfetchc

; 3093 : 
; 3094 : #ifdef OPTION_KMF_DEBUG
; 3095 :     LOGBYTE("input :", message_block, lcfb);
; 3096 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3097 : 
; 3098 :     for(i = 0; i < lcfb; i++)

  00518	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00520	eb 0a		 jmp	 SHORT $LN7@z900_kmf_a
$LN5@z900_kmf_a:
  00522	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00526	ff c0		 inc	 eax
  00528	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_kmf_a:
  0052c	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00530	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00534	7d 2a		 jge	 SHORT $LN6@z900_kmf_a

; 3099 :       output_block[i] ^= message_block[i];

  00536	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0053b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00540	0f b6 8c 0c f0
	02 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  00548	0f b6 84 04 e0
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  00550	33 c1		 xor	 eax, ecx
  00552	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00557	88 84 0c e0 02
	00 00		 mov	 BYTE PTR output_block$[rsp+rcx], al
  0055e	eb c2		 jmp	 SHORT $LN5@z900_kmf_a
$LN6@z900_kmf_a:

; 3100 :     for(i = 0; i < 16 - lcfb; i++)

  00560	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00568	eb 0a		 jmp	 SHORT $LN10@z900_kmf_a
$LN8@z900_kmf_a:
  0056a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0056e	ff c0		 inc	 eax
  00570	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_kmf_a:
  00574	b8 10 00 00 00	 mov	 eax, 16
  00579	2b 44 24 34	 sub	 eax, DWORD PTR lcfb$[rsp]
  0057d	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00581	7d 24		 jge	 SHORT $LN9@z900_kmf_a

; 3101 :       parameter_block[i] = parameter_block[i + lcfb];

  00583	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00587	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0058b	03 c8		 add	 ecx, eax
  0058d	8b c1		 mov	 eax, ecx
  0058f	48 98		 cdqe
  00591	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00596	0f b6 84 04 00
	03 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0059e	88 84 0c 00 03
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  005a5	eb c3		 jmp	 SHORT $LN8@z900_kmf_a
$LN9@z900_kmf_a:

; 3102 :     if(modifier_bit)

  005a7	83 7c 24 70 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  005ac	74 44		 je	 SHORT $LN30@z900_kmf_a

; 3103 :     {
; 3104 :       /* Decipher */
; 3105 :       for(i = 0; i < lcfb; i++)

  005ae	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005b6	eb 0a		 jmp	 SHORT $LN13@z900_kmf_a
$LN11@z900_kmf_a:
  005b8	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005bc	ff c0		 inc	 eax
  005be	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@z900_kmf_a:
  005c2	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  005c6	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  005ca	7d 24		 jge	 SHORT $LN12@z900_kmf_a

; 3106 :         parameter_block[i + 16 - lcfb] = message_block[i];

  005cc	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005d1	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  005d5	83 c1 10	 add	 ecx, 16
  005d8	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  005dc	48 63 c9	 movsxd	 rcx, ecx
  005df	0f b6 84 04 f0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  005e7	88 84 0c 00 03
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  005ee	eb c8		 jmp	 SHORT $LN11@z900_kmf_a
$LN12@z900_kmf_a:

; 3107 :     }

  005f0	eb 42		 jmp	 SHORT $LN31@z900_kmf_a
$LN30@z900_kmf_a:

; 3108 :     else
; 3109 :     {
; 3110 :       /* Encipher */
; 3111 :       for(i = 0; i < lcfb; i++)

  005f2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005fa	eb 0a		 jmp	 SHORT $LN16@z900_kmf_a
$LN14@z900_kmf_a:
  005fc	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00600	ff c0		 inc	 eax
  00602	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@z900_kmf_a:
  00606	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  0060a	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0060e	7d 24		 jge	 SHORT $LN15@z900_kmf_a

; 3112 :         parameter_block[i + 16 - lcfb] = output_block[i];

  00610	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00615	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00619	83 c1 10	 add	 ecx, 16
  0061c	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  00620	48 63 c9	 movsxd	 rcx, ecx
  00623	0f b6 84 04 e0
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  0062b	88 84 0c 00 03
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  00632	eb c8		 jmp	 SHORT $LN14@z900_kmf_a
$LN15@z900_kmf_a:
$LN31@z900_kmf_a:

; 3113 :     }
; 3114 : 
; 3115 :     /* Store the output */
; 3116 :     ARCH_DEP(vstorec)(output_block, lcfb - 1, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00634	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0063c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00642	83 e0 01	 and	 eax, 1
  00645	85 c0		 test	 eax, eax
  00647	74 22		 je	 SHORT $LN71@z900_kmf_a
  00649	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00651	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00659	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00661	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv367[rsp], rax
  00669	eb 1f		 jmp	 SHORT $LN72@z900_kmf_a
$LN71@z900_kmf_a:
  0066b	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00673	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00682	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv367[rsp], rax
$LN72@z900_kmf_a:
  0068a	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00692	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00699	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv367[rsp]
  006a1	48 23 c8	 and	 rcx, rax
  006a4	48 8b c1	 mov	 rax, rcx
  006a7	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  006ab	ff c9		 dec	 ecx
  006ad	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006b5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  006ba	44 8b 8c 24 70
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  006c2	4c 8b c0	 mov	 r8, rax
  006c5	0f b6 d1	 movzx	 edx, cl
  006c8	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR output_block$[rsp]
  006d0	e8 00 00 00 00	 call	 z900_vstorec

; 3117 : 
; 3118 : #ifdef OPTION_KMF_DEBUG
; 3119 :     LOGBYTE("output:", output_block, lcfb);
; 3120 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3121 : 
; 3122 :     /* Store the chaining value */
; 3123 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  006d5	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006dd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006e3	83 e0 01	 and	 eax, 1
  006e6	85 c0		 test	 eax, eax
  006e8	74 23		 je	 SHORT $LN73@z900_kmf_a
  006ea	b8 08 00 00 00	 mov	 eax, 8
  006ef	48 6b c0 01	 imul	 rax, rax, 1
  006f3	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006fb	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00703	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv389[rsp], rax
  0070b	eb 20		 jmp	 SHORT $LN74@z900_kmf_a
$LN73@z900_kmf_a:
  0070d	b8 08 00 00 00	 mov	 eax, 8
  00712	48 6b c0 01	 imul	 rax, rax, 1
  00716	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0071e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00725	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv389[rsp], rax
$LN74@z900_kmf_a:
  0072d	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00735	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0073c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv389[rsp]
  00744	48 23 c8	 and	 rcx, rax
  00747	48 8b c1	 mov	 rax, rcx
  0074a	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00752	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00757	41 b9 01 00 00
	00		 mov	 r9d, 1
  0075d	4c 8b c0	 mov	 r8, rax
  00760	b2 0f		 mov	 dl, 15
  00762	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0076a	e8 00 00 00 00	 call	 z900_vstorec
$LN19@z900_kmf_a:

; 3124 : 
; 3125 : #ifdef OPTION_KMF_DEBUG
; 3126 :     LOGBYTE("cv    :", parameter_block, 16);
; 3127 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3128 : 
; 3129 :     /* Update the registers */
; 3130 :     SET_GR_A(r1, regs, GR_A(r1, regs) + lcfb);

  0076f	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00777	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0077d	83 e0 01	 and	 eax, 1
  00780	85 c0		 test	 eax, eax
  00782	0f 84 86 00 00
	00		 je	 $LN32@z900_kmf_a
  00788	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00790	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00796	83 e0 01	 and	 eax, 1
  00799	85 c0		 test	 eax, eax
  0079b	74 22		 je	 SHORT $LN75@z900_kmf_a
  0079d	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007a5	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ad	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007b5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv417[rsp], rax
  007bd	eb 1f		 jmp	 SHORT $LN76@z900_kmf_a
$LN75@z900_kmf_a:
  007bf	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007c7	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cf	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007d6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv417[rsp], rax
$LN76@z900_kmf_a:
  007de	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  007e3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv417[rsp]
  007eb	48 03 c8	 add	 rcx, rax
  007ee	48 8b c1	 mov	 rax, rcx
  007f1	48 63 8c 24 70
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  007f9	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00801	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00809	e9 80 00 00 00	 jmp	 $LN33@z900_kmf_a
$LN32@z900_kmf_a:
  0080e	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00816	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0081c	83 e0 01	 and	 eax, 1
  0081f	85 c0		 test	 eax, eax
  00821	74 22		 je	 SHORT $LN77@z900_kmf_a
  00823	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0082b	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00833	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0083b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
  00843	eb 1f		 jmp	 SHORT $LN78@z900_kmf_a
$LN77@z900_kmf_a:
  00845	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0084d	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00855	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0085c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
$LN78@z900_kmf_a:
  00864	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00869	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv439[rsp]
  00871	48 03 c8	 add	 rcx, rax
  00874	48 8b c1	 mov	 rax, rcx
  00877	48 63 8c 24 70
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0087f	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00887	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN33@z900_kmf_a:
  0088e	33 c0		 xor	 eax, eax
  00890	85 c0		 test	 eax, eax
  00892	0f 85 d7 fe ff
	ff		 jne	 $LN19@z900_kmf_a

; 3131 :     if(likely(r1_is_not_r2))

  00898	83 7c 24 74 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  0089d	74 0a		 je	 SHORT $LN79@z900_kmf_a
  0089f	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv445[rsp], 1
  008a7	eb 08		 jmp	 SHORT $LN80@z900_kmf_a
$LN79@z900_kmf_a:
  008a9	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv445[rsp], 0
$LN80@z900_kmf_a:
  008b1	83 7c 24 60 00	 cmp	 DWORD PTR tv445[rsp], 0
  008b6	0f 84 29 01 00
	00		 je	 $LN34@z900_kmf_a
$LN22@z900_kmf_a:

; 3132 :       SET_GR_A(r2, regs, GR_A(r2, regs) + lcfb);

  008bc	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008ca	83 e0 01	 and	 eax, 1
  008cd	85 c0		 test	 eax, eax
  008cf	0f 84 86 00 00
	00		 je	 $LN35@z900_kmf_a
  008d5	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008dd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008e3	83 e0 01	 and	 eax, 1
  008e6	85 c0		 test	 eax, eax
  008e8	74 22		 je	 SHORT $LN81@z900_kmf_a
  008ea	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008f2	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008fa	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00902	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv469[rsp], rax
  0090a	eb 1f		 jmp	 SHORT $LN82@z900_kmf_a
$LN81@z900_kmf_a:
  0090c	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00914	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00923	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv469[rsp], rax
$LN82@z900_kmf_a:
  0092b	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00930	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv469[rsp]
  00938	48 03 c8	 add	 rcx, rax
  0093b	48 8b c1	 mov	 rax, rcx
  0093e	48 63 8c 24 78
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00946	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0094e	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00956	e9 80 00 00 00	 jmp	 $LN36@z900_kmf_a
$LN35@z900_kmf_a:
  0095b	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00963	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00969	83 e0 01	 and	 eax, 1
  0096c	85 c0		 test	 eax, eax
  0096e	74 22		 je	 SHORT $LN83@z900_kmf_a
  00970	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00978	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00980	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00988	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv491[rsp], rax
  00990	eb 1f		 jmp	 SHORT $LN84@z900_kmf_a
$LN83@z900_kmf_a:
  00992	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0099a	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009a9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv491[rsp], rax
$LN84@z900_kmf_a:
  009b1	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  009b6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv491[rsp]
  009be	48 03 c8	 add	 rcx, rax
  009c1	48 8b c1	 mov	 rax, rcx
  009c4	48 63 8c 24 78
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  009cc	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009d4	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN36@z900_kmf_a:
  009db	33 c0		 xor	 eax, eax
  009dd	85 c0		 test	 eax, eax
  009df	0f 85 d7 fe ff
	ff		 jne	 $LN22@z900_kmf_a
$LN34@z900_kmf_a:
$LN25@z900_kmf_a:

; 3133 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - lcfb);

  009e5	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009ed	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  009f3	83 e0 01	 and	 eax, 1
  009f6	85 c0		 test	 eax, eax
  009f8	0f 84 90 00 00
	00		 je	 $LN37@z900_kmf_a
  009fe	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a06	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a0c	83 e0 01	 and	 eax, 1
  00a0f	85 c0		 test	 eax, eax
  00a11	74 25		 je	 SHORT $LN85@z900_kmf_a
  00a13	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a1a	ff c0		 inc	 eax
  00a1c	48 98		 cdqe
  00a1e	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a26	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a2e	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv521[rsp], rax
  00a36	eb 22		 jmp	 SHORT $LN86@z900_kmf_a
$LN85@z900_kmf_a:
  00a38	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a3f	ff c0		 inc	 eax
  00a41	48 98		 cdqe
  00a43	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a4b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a52	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv521[rsp], rax
$LN86@z900_kmf_a:
  00a5a	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00a5f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv521[rsp]
  00a67	48 2b c8	 sub	 rcx, rax
  00a6a	48 8b c1	 mov	 rax, rcx
  00a6d	8b 8c 24 78 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00a74	ff c1		 inc	 ecx
  00a76	48 63 c9	 movsxd	 rcx, ecx
  00a79	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a81	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00a89	e9 8a 00 00 00	 jmp	 $LN38@z900_kmf_a
$LN37@z900_kmf_a:
  00a8e	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a96	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a9c	83 e0 01	 and	 eax, 1
  00a9f	85 c0		 test	 eax, eax
  00aa1	74 25		 je	 SHORT $LN87@z900_kmf_a
  00aa3	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00aaa	ff c0		 inc	 eax
  00aac	48 98		 cdqe
  00aae	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ab6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00abe	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv546[rsp], rax
  00ac6	eb 22		 jmp	 SHORT $LN88@z900_kmf_a
$LN87@z900_kmf_a:
  00ac8	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00acf	ff c0		 inc	 eax
  00ad1	48 98		 cdqe
  00ad3	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00adb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00ae2	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv546[rsp], rax
$LN88@z900_kmf_a:
  00aea	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00aef	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv546[rsp]
  00af7	48 2b c8	 sub	 rcx, rax
  00afa	48 8b c1	 mov	 rax, rcx
  00afd	8b 8c 24 78 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00b04	ff c1		 inc	 ecx
  00b06	48 63 c9	 movsxd	 rcx, ecx
  00b09	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b11	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN38@z900_kmf_a:
  00b18	33 c0		 xor	 eax, eax
  00b1a	85 c0		 test	 eax, eax
  00b1c	0f 85 c3 fe ff
	ff		 jne	 $LN25@z900_kmf_a

; 3134 : 
; 3135 : #ifdef OPTION_KMF_DEBUG
; 3136 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3137 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3138 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3139 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3140 : 
; 3141 :     /* check for end of data */
; 3142 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00b22	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b2a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b30	83 e0 01	 and	 eax, 1
  00b33	85 c0		 test	 eax, eax
  00b35	74 25		 je	 SHORT $LN89@z900_kmf_a
  00b37	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00b3e	ff c0		 inc	 eax
  00b40	48 98		 cdqe
  00b42	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b4a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00b52	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv567[rsp], rax
  00b5a	eb 22		 jmp	 SHORT $LN90@z900_kmf_a
$LN89@z900_kmf_a:
  00b5c	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00b63	ff c0		 inc	 eax
  00b65	48 98		 cdqe
  00b67	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b6f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00b76	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv567[rsp], rax
$LN90@z900_kmf_a:
  00b7e	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR tv567[rsp], 0
  00b87	75 0a		 jne	 SHORT $LN91@z900_kmf_a
  00b89	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv569[rsp], 1
  00b91	eb 08		 jmp	 SHORT $LN92@z900_kmf_a
$LN91@z900_kmf_a:
  00b93	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv569[rsp], 0
$LN92@z900_kmf_a:
  00b9b	83 7c 24 64 00	 cmp	 DWORD PTR tv569[rsp], 0
  00ba0	74 0a		 je	 SHORT $LN97@z900_kmf_a
  00ba2	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv590[rsp], 1
  00baa	eb 08		 jmp	 SHORT $LN98@z900_kmf_a
$LN97@z900_kmf_a:
  00bac	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv590[rsp], 0
$LN98@z900_kmf_a:
  00bb4	83 7c 24 68 00	 cmp	 DWORD PTR tv590[rsp], 0
  00bb9	74 0e		 je	 SHORT $LN39@z900_kmf_a

; 3143 :     {
; 3144 :       regs->psw.cc = 0;

  00bbb	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bc3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3145 :       return;

  00bc7	eb 11		 jmp	 SHORT $LN1@z900_kmf_a
$LN39@z900_kmf_a:

; 3146 :     }
; 3147 :   }

  00bc9	e9 6e f8 ff ff	 jmp	 $LN2@z900_kmf_a
$LN3@z900_kmf_a:

; 3148 : 
; 3149 :   /* CPU-determined amount of data processed */
; 3150 :   regs->psw.cc = 3;

  00bce	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bd6	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmf_a:

; 3151 : }

  00bda	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00be2	48 33 cc	 xor	 rcx, rsp
  00be5	e8 00 00 00 00	 call	 __security_check_cookie
  00bea	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  00bf1	c3		 ret	 0
z900_kmf_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
lcfb$ = 52
parameter_blocklen$ = 56
tv259 = 60
crypted$ = 64
tfc$ = 68
tv298 = 72
tv146 = 76
tv168 = 80
tv189 = 84
tv204 = 88
wrap$ = 92
keylen$ = 96
tv293 = 100
tv295 = 104
tv487 = 108
tv611 = 112
tv632 = 116
modifier_bit$ = 120
r1_is_not_r2$ = 124
tv87 = 128
tv166 = 136
tv225 = 144
tv243 = 152
tv339 = 160
tv409 = 168
tv431 = 176
tv459 = 184
tv481 = 192
tv511 = 200
tv533 = 208
tv563 = 216
tv588 = 224
tv609 = 232
tv88 = 240
context1$ = 256
context2$ = 400
context3$ = 544
output_block$ = 688
message_block$ = 696
parameter_block$ = 704
__$ArrayPad$ = 760
r1$ = 784
r2$ = 792
regs$ = 800
z900_kmf_dea PROC

; 2821 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 08 03
	00 00		 sub	 rsp, 776		; 00000308H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 f8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2822 :   des_context context1;
; 2823 :   des_context context2;
; 2824 :   des_context context3;
; 2825 :   int crypted;
; 2826 :   int i;
; 2827 :   int keylen;
; 2828 :   int lcfb;
; 2829 :   BYTE message_block[8];
; 2830 :   int modifier_bit;
; 2831 :   BYTE output_block[8];
; 2832 :   BYTE parameter_block[56];
; 2833 :   int parameter_blocklen;
; 2834 :   int r1_is_not_r2;
; 2835 :   int tfc;
; 2836 :   int wrap;
; 2837 : 
; 2838 :   /* Initialize values */
; 2839 :   lcfb = GR0_lcfb(regs);

  00026	b8 08 00 00 00	 mov	 eax, 8
  0002b	48 6b c0 00	 imul	 rax, rax, 0
  0002f	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0003e	c1 e8 18	 shr	 eax, 24
  00041	89 44 24 34	 mov	 DWORD PTR lcfb$[rsp], eax

; 2840 : 
; 2841 :   /* Check special conditions */
; 2842 :   if(unlikely(!lcfb || lcfb > 8 || GR_A(r2 + 1, regs) % lcfb))

  00045	83 7c 24 34 00	 cmp	 DWORD PTR lcfb$[rsp], 0
  0004a	0f 84 9b 00 00
	00		 je	 $LN51@z900_kmf_d
  00050	83 7c 24 34 08	 cmp	 DWORD PTR lcfb$[rsp], 8
  00055	0f 8f 90 00 00
	00		 jg	 $LN51@z900_kmf_d
  0005b	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00063	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00069	83 e0 01	 and	 eax, 1
  0006c	85 c0		 test	 eax, eax
  0006e	74 25		 je	 SHORT $LN52@z900_kmf_d
  00070	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00077	ff c0		 inc	 eax
  00079	48 98		 cdqe
  0007b	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0008b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
  00093	eb 22		 jmp	 SHORT $LN53@z900_kmf_d
$LN52@z900_kmf_d:
  00095	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0009c	ff c0		 inc	 eax
  0009e	48 98		 cdqe
  000a0	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000af	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv87[rsp], rax
$LN53@z900_kmf_d:
  000b7	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  000bc	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv88[rsp], rax
  000c4	33 d2		 xor	 edx, edx
  000c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv87[rsp]
  000ce	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  000d6	48 f7 f1	 div	 rcx
  000d9	48 8b c2	 mov	 rax, rdx
  000dc	48 85 c0	 test	 rax, rax
  000df	75 0a		 jne	 SHORT $LN51@z900_kmf_d
  000e1	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
  000e9	eb 08		 jmp	 SHORT $LN58@z900_kmf_d
$LN51@z900_kmf_d:
  000eb	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
$LN58@z900_kmf_d:
  000f3	83 7c 24 4c 00	 cmp	 DWORD PTR tv146[rsp], 0
  000f8	74 13		 je	 SHORT $LN30@z900_kmf_d

; 2843 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000fa	ba 06 00 00 00	 mov	 edx, 6
  000ff	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN30@z900_kmf_d:

; 2844 : 
; 2845 :   /* Return with cc 0 on zero length */
; 2846 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0010d	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00115	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0011b	83 e0 01	 and	 eax, 1
  0011e	85 c0		 test	 eax, eax
  00120	74 25		 je	 SHORT $LN59@z900_kmf_d
  00122	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00129	ff c0		 inc	 eax
  0012b	48 98		 cdqe
  0012d	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00135	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0013d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
  00145	eb 22		 jmp	 SHORT $LN60@z900_kmf_d
$LN59@z900_kmf_d:
  00147	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0014e	ff c0		 inc	 eax
  00150	48 98		 cdqe
  00152	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0015a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00161	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv166[rsp], rax
$LN60@z900_kmf_d:
  00169	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR tv166[rsp], 0
  00172	75 0a		 jne	 SHORT $LN61@z900_kmf_d
  00174	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv168[rsp], 1
  0017c	eb 08		 jmp	 SHORT $LN62@z900_kmf_d
$LN61@z900_kmf_d:
  0017e	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv168[rsp], 0
$LN62@z900_kmf_d:
  00186	83 7c 24 50 00	 cmp	 DWORD PTR tv168[rsp], 0
  0018b	74 0a		 je	 SHORT $LN67@z900_kmf_d
  0018d	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv189[rsp], 1
  00195	eb 08		 jmp	 SHORT $LN68@z900_kmf_d
$LN67@z900_kmf_d:
  00197	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv189[rsp], 0
$LN68@z900_kmf_d:
  0019f	83 7c 24 54 00	 cmp	 DWORD PTR tv189[rsp], 0
  001a4	74 11		 je	 SHORT $LN31@z900_kmf_d

; 2847 :   {
; 2848 :     regs->psw.cc = 0;

  001a6	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ae	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2849 :     return;

  001b2	e9 cf 0b 00 00	 jmp	 $LN1@z900_kmf_d
$LN31@z900_kmf_d:

; 2850 :   }
; 2851 : 
; 2852 :   /* Initialize values */
; 2853 :   tfc = GR0_tfc(regs);

  001b7	b8 08 00 00 00	 mov	 eax, 8
  001bc	48 6b c0 00	 imul	 rax, rax, 0
  001c0	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001cf	83 e0 7f	 and	 eax, 127		; 0000007fH
  001d2	83 e0 77	 and	 eax, 119		; 00000077H
  001d5	89 44 24 44	 mov	 DWORD PTR tfc$[rsp], eax

; 2854 :   wrap = GR0_wrap(regs);

  001d9	b8 08 00 00 00	 mov	 eax, 8
  001de	48 6b c0 00	 imul	 rax, rax, 0
  001e2	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ea	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001f1	83 e0 08	 and	 eax, 8
  001f4	85 c0		 test	 eax, eax
  001f6	74 0a		 je	 SHORT $LN69@z900_kmf_d
  001f8	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  00200	eb 08		 jmp	 SHORT $LN70@z900_kmf_d
$LN69@z900_kmf_d:
  00202	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN70@z900_kmf_d:
  0020a	8b 44 24 58	 mov	 eax, DWORD PTR tv204[rsp]
  0020e	89 44 24 5c	 mov	 DWORD PTR wrap$[rsp], eax

; 2855 :   keylen = tfc * 8;

  00212	8b 44 24 44	 mov	 eax, DWORD PTR tfc$[rsp]
  00216	c1 e0 03	 shl	 eax, 3
  00219	89 44 24 60	 mov	 DWORD PTR keylen$[rsp], eax

; 2856 :   parameter_blocklen = keylen + 8;

  0021d	8b 44 24 60	 mov	 eax, DWORD PTR keylen$[rsp]
  00221	83 c0 08	 add	 eax, 8
  00224	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2857 :   if(wrap)

  00228	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0022d	74 0b		 je	 SHORT $LN32@z900_kmf_d

; 2858 :     parameter_blocklen += 24;

  0022f	8b 44 24 38	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00233	83 c0 18	 add	 eax, 24
  00236	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN32@z900_kmf_d:

; 2859 : 
; 2860 :   /* Test writeability output chaining value */
; 2861 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  0023a	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00242	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00248	83 e0 01	 and	 eax, 1
  0024b	85 c0		 test	 eax, eax
  0024d	74 23		 je	 SHORT $LN71@z900_kmf_d
  0024f	b8 08 00 00 00	 mov	 eax, 8
  00254	48 6b c0 01	 imul	 rax, rax, 1
  00258	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00260	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00268	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
  00270	eb 20		 jmp	 SHORT $LN72@z900_kmf_d
$LN71@z900_kmf_d:
  00272	b8 08 00 00 00	 mov	 eax, 8
  00277	48 6b c0 01	 imul	 rax, rax, 1
  0027b	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00283	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0028a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv225[rsp], rax
$LN72@z900_kmf_d:
  00292	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0029a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002a1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv225[rsp]
  002a9	48 23 c8	 and	 rcx, rax
  002ac	48 8b c1	 mov	 rax, rcx
  002af	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002bc	41 b9 02 00 00
	00		 mov	 r9d, 2
  002c2	41 b8 07 00 00
	00		 mov	 r8d, 7
  002c8	ba 01 00 00 00	 mov	 edx, 1
  002cd	48 8b c8	 mov	 rcx, rax
  002d0	e8 00 00 00 00	 call	 z900_validate_operand

; 2862 : 
; 2863 :   /* Fetch the parameter block */
; 2864 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  002d5	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002dd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002e3	83 e0 01	 and	 eax, 1
  002e6	85 c0		 test	 eax, eax
  002e8	74 23		 je	 SHORT $LN73@z900_kmf_d
  002ea	b8 08 00 00 00	 mov	 eax, 8
  002ef	48 6b c0 01	 imul	 rax, rax, 1
  002f3	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002fb	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00303	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv243[rsp], rax
  0030b	eb 20		 jmp	 SHORT $LN74@z900_kmf_d
$LN73@z900_kmf_d:
  0030d	b8 08 00 00 00	 mov	 eax, 8
  00312	48 6b c0 01	 imul	 rax, rax, 1
  00316	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00325	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv243[rsp], rax
$LN74@z900_kmf_d:
  0032d	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00335	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0033c	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv243[rsp]
  00344	48 23 c8	 and	 rcx, rax
  00347	48 8b c1	 mov	 rax, rcx
  0034a	8b 4c 24 38	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0034e	ff c9		 dec	 ecx
  00350	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00358	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0035d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00363	4c 8b c0	 mov	 r8, rax
  00366	0f b6 d1	 movzx	 edx, cl
  00369	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00371	e8 00 00 00 00	 call	 z900_vfetchc

; 2865 : 
; 2866 : #ifdef OPTION_KMF_DEBUG
; 2867 :   LOGBYTE("cv    :", parameter_block, 8);
; 2868 :   switch(tfc)
; 2869 :   {
; 2870 :     case 1: /* dea */
; 2871 :     {
; 2872 :       LOGBYTE("k     :", &parameter_block[8], 8);
; 2873 :       break;
; 2874 :     }
; 2875 :     case 2: /* tdea-128 */
; 2876 :     {
; 2877 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2878 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2879 :       break;
; 2880 :     }
; 2881 :     case 3: /* tdea-192 */
; 2882 :     {
; 2883 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2884 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2885 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 2886 :       break;
; 2887 :     }
; 2888 :   }
; 2889 :   if(wrap)
; 2890 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 24], 24);
; 2891 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2892 : 
; 2893 :   /* Verify and unwrap */
; 2894 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  00376	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0037b	74 32		 je	 SHORT $LN33@z900_kmf_d
  0037d	b8 01 00 00 00	 mov	 eax, 1
  00382	48 6b c0 08	 imul	 rax, rax, 8
  00386	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0038e	8b 54 24 60	 mov	 edx, DWORD PTR keylen$[rsp]
  00392	48 8b c8	 mov	 rcx, rax
  00395	e8 00 00 00 00	 call	 unwrap_dea
  0039a	85 c0		 test	 eax, eax
  0039c	74 11		 je	 SHORT $LN33@z900_kmf_d

; 2895 :   {
; 2896 : 
; 2897 : #ifdef OPTION_KMF_DEBUG
; 2898 :     WRMSG(HHC90111, "D");
; 2899 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2900 : 
; 2901 :     regs->psw.cc = 1;

  0039e	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a6	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2902 :     return;

  003aa	e9 d7 09 00 00	 jmp	 $LN1@z900_kmf_d
$LN33@z900_kmf_d:

; 2903 :   }
; 2904 : 
; 2905 :   /* Set the cryptographic key */
; 2906 :   switch(tfc)

  003af	8b 44 24 44	 mov	 eax, DWORD PTR tfc$[rsp]
  003b3	89 44 24 3c	 mov	 DWORD PTR tv259[rsp], eax
  003b7	83 7c 24 3c 01	 cmp	 DWORD PTR tv259[rsp], 1
  003bc	74 13		 je	 SHORT $LN34@z900_kmf_d
  003be	83 7c 24 3c 02	 cmp	 DWORD PTR tv259[rsp], 2
  003c3	74 32		 je	 SHORT $LN35@z900_kmf_d
  003c5	83 7c 24 3c 03	 cmp	 DWORD PTR tv259[rsp], 3
  003ca	74 6f		 je	 SHORT $LN36@z900_kmf_d
  003cc	e9 cd 00 00 00	 jmp	 $LN2@z900_kmf_d
$LN34@z900_kmf_d:

; 2907 :   {
; 2908 :     case 1: /* dea */
; 2909 :     {
; 2910 :       des_set_key(&context1, &parameter_block[8]);

  003d1	b8 01 00 00 00	 mov	 eax, 1
  003d6	48 6b c0 08	 imul	 rax, rax, 8
  003da	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003e2	48 8b d0	 mov	 rdx, rax
  003e5	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003ed	e8 00 00 00 00	 call	 des_set_key

; 2911 :       break;

  003f2	e9 a7 00 00 00	 jmp	 $LN2@z900_kmf_d
$LN35@z900_kmf_d:

; 2912 :     }
; 2913 :     case 2: /* tdea-128 */
; 2914 :     {
; 2915 :       des_set_key(&context1, &parameter_block[8]);

  003f7	b8 01 00 00 00	 mov	 eax, 1
  003fc	48 6b c0 08	 imul	 rax, rax, 8
  00400	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00408	48 8b d0	 mov	 rdx, rax
  0040b	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00413	e8 00 00 00 00	 call	 des_set_key

; 2916 :       des_set_key(&context2, &parameter_block[16]);

  00418	b8 01 00 00 00	 mov	 eax, 1
  0041d	48 6b c0 10	 imul	 rax, rax, 16
  00421	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00429	48 8b d0	 mov	 rdx, rax
  0042c	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00434	e8 00 00 00 00	 call	 des_set_key

; 2917 :       break;

  00439	eb 63		 jmp	 SHORT $LN2@z900_kmf_d
$LN36@z900_kmf_d:

; 2918 :     }
; 2919 :     case 3: /* tdea-192 */
; 2920 :     {
; 2921 :       des_set_key(&context1, &parameter_block[8]);

  0043b	b8 01 00 00 00	 mov	 eax, 1
  00440	48 6b c0 08	 imul	 rax, rax, 8
  00444	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0044c	48 8b d0	 mov	 rdx, rax
  0044f	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00457	e8 00 00 00 00	 call	 des_set_key

; 2922 :       des_set_key(&context2, &parameter_block[16]);

  0045c	b8 01 00 00 00	 mov	 eax, 1
  00461	48 6b c0 10	 imul	 rax, rax, 16
  00465	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0046d	48 8b d0	 mov	 rdx, rax
  00470	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00478	e8 00 00 00 00	 call	 des_set_key

; 2923 :       des_set_key(&context3, &parameter_block[24]);

  0047d	b8 01 00 00 00	 mov	 eax, 1
  00482	48 6b c0 18	 imul	 rax, rax, 24
  00486	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0048e	48 8b d0	 mov	 rdx, rax
  00491	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00499	e8 00 00 00 00	 call	 des_set_key
$LN2@z900_kmf_d:

; 2924 :       break;
; 2925 :     }
; 2926 :   }
; 2927 : 
; 2928 :   /* Try to process the CPU-determined amount of data */
; 2929 :   modifier_bit = GR0_m(regs);

  0049e	b8 08 00 00 00	 mov	 eax, 8
  004a3	48 6b c0 00	 imul	 rax, rax, 0
  004a7	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004af	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004b6	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004bb	85 c0		 test	 eax, eax
  004bd	74 0a		 je	 SHORT $LN75@z900_kmf_d
  004bf	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv293[rsp], 1
  004c7	eb 08		 jmp	 SHORT $LN76@z900_kmf_d
$LN75@z900_kmf_d:
  004c9	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv293[rsp], 0
$LN76@z900_kmf_d:
  004d1	8b 44 24 64	 mov	 eax, DWORD PTR tv293[rsp]
  004d5	89 44 24 78	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2930 :   r1_is_not_r2 = r1 != r2;

  004d9	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004e0	39 84 24 10 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  004e7	74 0a		 je	 SHORT $LN77@z900_kmf_d
  004e9	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv295[rsp], 1
  004f1	eb 08		 jmp	 SHORT $LN78@z900_kmf_d
$LN77@z900_kmf_d:
  004f3	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv295[rsp], 0
$LN78@z900_kmf_d:
  004fb	8b 44 24 68	 mov	 eax, DWORD PTR tv295[rsp]
  004ff	89 44 24 7c	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2931 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += lcfb)

  00503	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0050b	eb 10		 jmp	 SHORT $LN6@z900_kmf_d
$LN4@z900_kmf_d:
  0050d	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00511	8b 4c 24 40	 mov	 ecx, DWORD PTR crypted$[rsp]
  00515	03 c8		 add	 ecx, eax
  00517	8b c1		 mov	 eax, ecx
  00519	89 44 24 40	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@z900_kmf_d:
  0051d	81 7c 24 40 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00525	0f 8d 4f 08 00
	00		 jge	 $LN5@z900_kmf_d

; 2932 :   {
; 2933 :     /* Do the job */
; 2934 :     switch(tfc)

  0052b	8b 44 24 44	 mov	 eax, DWORD PTR tfc$[rsp]
  0052f	89 44 24 48	 mov	 DWORD PTR tv298[rsp], eax
  00533	83 7c 24 48 01	 cmp	 DWORD PTR tv298[rsp], 1
  00538	74 17		 je	 SHORT $LN37@z900_kmf_d
  0053a	83 7c 24 48 02	 cmp	 DWORD PTR tv298[rsp], 2
  0053f	74 32		 je	 SHORT $LN38@z900_kmf_d
  00541	83 7c 24 48 03	 cmp	 DWORD PTR tv298[rsp], 3
  00546	0f 84 80 00 00
	00		 je	 $LN39@z900_kmf_d
  0054c	e9 d2 00 00 00	 jmp	 $LN7@z900_kmf_d
$LN37@z900_kmf_d:

; 2935 :     {
; 2936 :       case 1: /* dea */
; 2937 :       {
; 2938 :         des_encrypt(&context1, parameter_block, output_block);

  00551	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00559	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00561	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00569	e8 00 00 00 00	 call	 des_encrypt

; 2939 :         break;

  0056e	e9 b0 00 00 00	 jmp	 $LN7@z900_kmf_d
$LN38@z900_kmf_d:

; 2940 :       }
; 2941 :       case 2: /* tdea-128 */
; 2942 :       {
; 2943 :         des_encrypt(&context1, parameter_block, output_block);

  00573	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  0057b	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00583	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0058b	e8 00 00 00 00	 call	 des_encrypt

; 2944 :         des_decrypt(&context2, output_block, output_block);

  00590	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00598	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  005a0	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  005a8	e8 00 00 00 00	 call	 des_decrypt

; 2945 :         des_encrypt(&context1, output_block, output_block);

  005ad	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  005b5	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  005bd	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005c5	e8 00 00 00 00	 call	 des_encrypt

; 2946 :         break;

  005ca	eb 57		 jmp	 SHORT $LN7@z900_kmf_d
$LN39@z900_kmf_d:

; 2947 :       }
; 2948 :       case 3: /* tdea-192 */
; 2949 :       {
; 2950 :         des_encrypt(&context1, parameter_block, output_block);

  005cc	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  005d4	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  005dc	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005e4	e8 00 00 00 00	 call	 des_encrypt

; 2951 :         des_decrypt(&context2, output_block, output_block);

  005e9	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  005f1	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  005f9	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00601	e8 00 00 00 00	 call	 des_decrypt

; 2952 :         des_encrypt(&context3, output_block, output_block);

  00606	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  0060e	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  00616	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0061e	e8 00 00 00 00	 call	 des_encrypt
$LN7@z900_kmf_d:

; 2953 :         break;
; 2954 :       }
; 2955 :     }
; 2956 :     ARCH_DEP(vfetchc)(message_block, lcfb - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00623	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00631	83 e0 01	 and	 eax, 1
  00634	85 c0		 test	 eax, eax
  00636	74 22		 je	 SHORT $LN79@z900_kmf_d
  00638	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00640	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00648	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00650	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv339[rsp], rax
  00658	eb 1f		 jmp	 SHORT $LN80@z900_kmf_d
$LN79@z900_kmf_d:
  0065a	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00662	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0066a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00671	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv339[rsp], rax
$LN80@z900_kmf_d:
  00679	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00681	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00688	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv339[rsp]
  00690	48 23 c8	 and	 rcx, rax
  00693	48 8b c1	 mov	 rax, rcx
  00696	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  0069a	ff c9		 dec	 ecx
  0069c	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006a4	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  006a9	44 8b 8c 24 18
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  006b1	4c 8b c0	 mov	 r8, rax
  006b4	0f b6 d1	 movzx	 edx, cl
  006b7	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  006bf	e8 00 00 00 00	 call	 z900_vfetchc

; 2957 : 
; 2958 : #ifdef OPTION_KMF_DEBUG
; 2959 :     LOGBYTE("input :", message_block, lcfb);
; 2960 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2961 : 
; 2962 :     for(i = 0; i < lcfb; i++)

  006c4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006cc	eb 0a		 jmp	 SHORT $LN11@z900_kmf_d
$LN9@z900_kmf_d:
  006ce	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006d2	ff c0		 inc	 eax
  006d4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@z900_kmf_d:
  006d8	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  006dc	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  006e0	7d 2a		 jge	 SHORT $LN10@z900_kmf_d

; 2963 :       output_block[i] ^= message_block[i];

  006e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  006e7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006ec	0f b6 8c 0c b8
	02 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  006f4	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  006fc	33 c1		 xor	 eax, ecx
  006fe	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00703	88 84 0c b0 02
	00 00		 mov	 BYTE PTR output_block$[rsp+rcx], al
  0070a	eb c2		 jmp	 SHORT $LN9@z900_kmf_d
$LN10@z900_kmf_d:

; 2964 :     for(i = 0; i < 8 - lcfb; i++)

  0070c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00714	eb 0a		 jmp	 SHORT $LN14@z900_kmf_d
$LN12@z900_kmf_d:
  00716	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0071a	ff c0		 inc	 eax
  0071c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN14@z900_kmf_d:
  00720	b8 08 00 00 00	 mov	 eax, 8
  00725	2b 44 24 34	 sub	 eax, DWORD PTR lcfb$[rsp]
  00729	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0072d	7d 24		 jge	 SHORT $LN13@z900_kmf_d

; 2965 :        parameter_block[i] = parameter_block[i + lcfb];

  0072f	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00733	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00737	03 c8		 add	 ecx, eax
  00739	8b c1		 mov	 eax, ecx
  0073b	48 98		 cdqe
  0073d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00742	0f b6 84 04 c0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0074a	88 84 0c c0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  00751	eb c3		 jmp	 SHORT $LN12@z900_kmf_d
$LN13@z900_kmf_d:

; 2966 :     if(modifier_bit)

  00753	83 7c 24 78 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  00758	74 44		 je	 SHORT $LN40@z900_kmf_d

; 2967 :     {
; 2968 :       /* Decipher */
; 2969 :       for(i = 0; i < lcfb; i++)

  0075a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00762	eb 0a		 jmp	 SHORT $LN17@z900_kmf_d
$LN15@z900_kmf_d:
  00764	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00768	ff c0		 inc	 eax
  0076a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN17@z900_kmf_d:
  0076e	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00772	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00776	7d 24		 jge	 SHORT $LN16@z900_kmf_d

; 2970 :         parameter_block[i + 8 - lcfb] = message_block[i];

  00778	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0077d	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00781	83 c1 08	 add	 ecx, 8
  00784	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  00788	48 63 c9	 movsxd	 rcx, ecx
  0078b	0f b6 84 04 b8
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00793	88 84 0c c0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  0079a	eb c8		 jmp	 SHORT $LN15@z900_kmf_d
$LN16@z900_kmf_d:

; 2971 :     }

  0079c	eb 42		 jmp	 SHORT $LN41@z900_kmf_d
$LN40@z900_kmf_d:

; 2972 :     else
; 2973 :     {
; 2974 :       /* Encipher */
; 2975 :       for(i = 0; i < lcfb; i++)

  0079e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  007a6	eb 0a		 jmp	 SHORT $LN20@z900_kmf_d
$LN18@z900_kmf_d:
  007a8	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007ac	ff c0		 inc	 eax
  007ae	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN20@z900_kmf_d:
  007b2	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  007b6	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  007ba	7d 24		 jge	 SHORT $LN19@z900_kmf_d

; 2976 :         parameter_block[i + 8 - lcfb] = output_block[i];

  007bc	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  007c1	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  007c5	83 c1 08	 add	 ecx, 8
  007c8	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  007cc	48 63 c9	 movsxd	 rcx, ecx
  007cf	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  007d7	88 84 0c c0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  007de	eb c8		 jmp	 SHORT $LN18@z900_kmf_d
$LN19@z900_kmf_d:
$LN41@z900_kmf_d:

; 2977 :     }
; 2978 : 
; 2979 :     /* Store the output */
; 2980 :     ARCH_DEP(vstorec)(output_block, lcfb - 1, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  007e0	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007ee	83 e0 01	 and	 eax, 1
  007f1	85 c0		 test	 eax, eax
  007f3	74 22		 je	 SHORT $LN81@z900_kmf_d
  007f5	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007fd	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00805	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0080d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv409[rsp], rax
  00815	eb 1f		 jmp	 SHORT $LN82@z900_kmf_d
$LN81@z900_kmf_d:
  00817	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0081f	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00827	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0082e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv409[rsp], rax
$LN82@z900_kmf_d:
  00836	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0083e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00845	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv409[rsp]
  0084d	48 23 c8	 and	 rcx, rax
  00850	48 8b c1	 mov	 rax, rcx
  00853	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  00857	ff c9		 dec	 ecx
  00859	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00861	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00866	44 8b 8c 24 10
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0086e	4c 8b c0	 mov	 r8, rax
  00871	0f b6 d1	 movzx	 edx, cl
  00874	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR output_block$[rsp]
  0087c	e8 00 00 00 00	 call	 z900_vstorec

; 2981 : 
; 2982 : #ifdef OPTION_KMF_DEBUG
; 2983 :     LOGBYTE("output:", output_block, lcfb);
; 2984 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2985 : 
; 2986 :     /* Store the chaining value */
; 2987 :     ARCH_DEP(vstorec)(parameter_block, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00881	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00889	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0088f	83 e0 01	 and	 eax, 1
  00892	85 c0		 test	 eax, eax
  00894	74 23		 je	 SHORT $LN83@z900_kmf_d
  00896	b8 08 00 00 00	 mov	 eax, 8
  0089b	48 6b c0 01	 imul	 rax, rax, 1
  0089f	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008a7	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  008af	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv431[rsp], rax
  008b7	eb 20		 jmp	 SHORT $LN84@z900_kmf_d
$LN83@z900_kmf_d:
  008b9	b8 08 00 00 00	 mov	 eax, 8
  008be	48 6b c0 01	 imul	 rax, rax, 1
  008c2	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ca	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  008d1	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv431[rsp], rax
$LN84@z900_kmf_d:
  008d9	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008e1	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  008e8	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv431[rsp]
  008f0	48 23 c8	 and	 rcx, rax
  008f3	48 8b c1	 mov	 rax, rcx
  008f6	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008fe	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00903	41 b9 01 00 00
	00		 mov	 r9d, 1
  00909	4c 8b c0	 mov	 r8, rax
  0090c	b2 07		 mov	 dl, 7
  0090e	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00916	e8 00 00 00 00	 call	 z900_vstorec
$LN23@z900_kmf_d:

; 2988 : 
; 2989 : #ifdef OPTION_KMF_DEBUG
; 2990 :     LOGBYTE("cv    :", parameter_block, 8);
; 2991 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2992 : 
; 2993 :     /* Update the registers */
; 2994 :     SET_GR_A(r1, regs, GR_A(r1, regs) + lcfb);

  0091b	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00923	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00929	83 e0 01	 and	 eax, 1
  0092c	85 c0		 test	 eax, eax
  0092e	0f 84 86 00 00
	00		 je	 $LN42@z900_kmf_d
  00934	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0093c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00942	83 e0 01	 and	 eax, 1
  00945	85 c0		 test	 eax, eax
  00947	74 22		 je	 SHORT $LN85@z900_kmf_d
  00949	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00951	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00959	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00961	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv459[rsp], rax
  00969	eb 1f		 jmp	 SHORT $LN86@z900_kmf_d
$LN85@z900_kmf_d:
  0096b	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00973	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0097b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00982	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv459[rsp], rax
$LN86@z900_kmf_d:
  0098a	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  0098f	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv459[rsp]
  00997	48 03 c8	 add	 rcx, rax
  0099a	48 8b c1	 mov	 rax, rcx
  0099d	48 63 8c 24 10
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  009a5	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009ad	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  009b5	e9 80 00 00 00	 jmp	 $LN43@z900_kmf_d
$LN42@z900_kmf_d:
  009ba	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009c2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  009c8	83 e0 01	 and	 eax, 1
  009cb	85 c0		 test	 eax, eax
  009cd	74 22		 je	 SHORT $LN87@z900_kmf_d
  009cf	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  009d7	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009df	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  009e7	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv481[rsp], rax
  009ef	eb 1f		 jmp	 SHORT $LN88@z900_kmf_d
$LN87@z900_kmf_d:
  009f1	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  009f9	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a01	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a08	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv481[rsp], rax
$LN88@z900_kmf_d:
  00a10	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00a15	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv481[rsp]
  00a1d	48 03 c8	 add	 rcx, rax
  00a20	48 8b c1	 mov	 rax, rcx
  00a23	48 63 8c 24 10
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00a2b	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a33	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN43@z900_kmf_d:
  00a3a	33 c0		 xor	 eax, eax
  00a3c	85 c0		 test	 eax, eax
  00a3e	0f 85 d7 fe ff
	ff		 jne	 $LN23@z900_kmf_d

; 2995 :     if(likely(r1_is_not_r2))

  00a44	83 7c 24 7c 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00a49	74 0a		 je	 SHORT $LN89@z900_kmf_d
  00a4b	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv487[rsp], 1
  00a53	eb 08		 jmp	 SHORT $LN90@z900_kmf_d
$LN89@z900_kmf_d:
  00a55	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv487[rsp], 0
$LN90@z900_kmf_d:
  00a5d	83 7c 24 6c 00	 cmp	 DWORD PTR tv487[rsp], 0
  00a62	0f 84 29 01 00
	00		 je	 $LN44@z900_kmf_d
$LN26@z900_kmf_d:

; 2996 :       SET_GR_A(r2, regs, GR_A(r2, regs) + lcfb);

  00a68	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a70	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a76	83 e0 01	 and	 eax, 1
  00a79	85 c0		 test	 eax, eax
  00a7b	0f 84 86 00 00
	00		 je	 $LN45@z900_kmf_d
  00a81	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a89	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a8f	83 e0 01	 and	 eax, 1
  00a92	85 c0		 test	 eax, eax
  00a94	74 22		 je	 SHORT $LN91@z900_kmf_d
  00a96	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00a9e	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00aae	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv511[rsp], rax
  00ab6	eb 1f		 jmp	 SHORT $LN92@z900_kmf_d
$LN91@z900_kmf_d:
  00ab8	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00ac0	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ac8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00acf	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv511[rsp], rax
$LN92@z900_kmf_d:
  00ad7	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00adc	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv511[rsp]
  00ae4	48 03 c8	 add	 rcx, rax
  00ae7	48 8b c1	 mov	 rax, rcx
  00aea	48 63 8c 24 18
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00af2	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00afa	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00b02	e9 80 00 00 00	 jmp	 $LN46@z900_kmf_d
$LN45@z900_kmf_d:
  00b07	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b15	83 e0 01	 and	 eax, 1
  00b18	85 c0		 test	 eax, eax
  00b1a	74 22		 je	 SHORT $LN93@z900_kmf_d
  00b1c	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00b24	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b2c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00b34	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv533[rsp], rax
  00b3c	eb 1f		 jmp	 SHORT $LN94@z900_kmf_d
$LN93@z900_kmf_d:
  00b3e	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00b46	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b4e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00b55	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv533[rsp], rax
$LN94@z900_kmf_d:
  00b5d	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00b62	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv533[rsp]
  00b6a	48 03 c8	 add	 rcx, rax
  00b6d	48 8b c1	 mov	 rax, rcx
  00b70	48 63 8c 24 18
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00b78	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b80	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN46@z900_kmf_d:
  00b87	33 c0		 xor	 eax, eax
  00b89	85 c0		 test	 eax, eax
  00b8b	0f 85 d7 fe ff
	ff		 jne	 $LN26@z900_kmf_d
$LN44@z900_kmf_d:
$LN29@z900_kmf_d:

; 2997 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - lcfb);

  00b91	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b99	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b9f	83 e0 01	 and	 eax, 1
  00ba2	85 c0		 test	 eax, eax
  00ba4	0f 84 90 00 00
	00		 je	 $LN47@z900_kmf_d
  00baa	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bb2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00bb8	83 e0 01	 and	 eax, 1
  00bbb	85 c0		 test	 eax, eax
  00bbd	74 25		 je	 SHORT $LN95@z900_kmf_d
  00bbf	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00bc6	ff c0		 inc	 eax
  00bc8	48 98		 cdqe
  00bca	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bd2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00bda	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv563[rsp], rax
  00be2	eb 22		 jmp	 SHORT $LN96@z900_kmf_d
$LN95@z900_kmf_d:
  00be4	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00beb	ff c0		 inc	 eax
  00bed	48 98		 cdqe
  00bef	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bf7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00bfe	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv563[rsp], rax
$LN96@z900_kmf_d:
  00c06	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00c0b	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv563[rsp]
  00c13	48 2b c8	 sub	 rcx, rax
  00c16	48 8b c1	 mov	 rax, rcx
  00c19	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00c20	ff c1		 inc	 ecx
  00c22	48 63 c9	 movsxd	 rcx, ecx
  00c25	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c2d	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00c35	e9 8a 00 00 00	 jmp	 $LN48@z900_kmf_d
$LN47@z900_kmf_d:
  00c3a	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c42	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00c48	83 e0 01	 and	 eax, 1
  00c4b	85 c0		 test	 eax, eax
  00c4d	74 25		 je	 SHORT $LN97@z900_kmf_d
  00c4f	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00c56	ff c0		 inc	 eax
  00c58	48 98		 cdqe
  00c5a	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c62	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00c6a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv588[rsp], rax
  00c72	eb 22		 jmp	 SHORT $LN98@z900_kmf_d
$LN97@z900_kmf_d:
  00c74	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00c7b	ff c0		 inc	 eax
  00c7d	48 98		 cdqe
  00c7f	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c87	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00c8e	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv588[rsp], rax
$LN98@z900_kmf_d:
  00c96	48 63 44 24 34	 movsxd	 rax, DWORD PTR lcfb$[rsp]
  00c9b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv588[rsp]
  00ca3	48 2b c8	 sub	 rcx, rax
  00ca6	48 8b c1	 mov	 rax, rcx
  00ca9	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00cb0	ff c1		 inc	 ecx
  00cb2	48 63 c9	 movsxd	 rcx, ecx
  00cb5	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00cbd	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN48@z900_kmf_d:
  00cc4	33 c0		 xor	 eax, eax
  00cc6	85 c0		 test	 eax, eax
  00cc8	0f 85 c3 fe ff
	ff		 jne	 $LN29@z900_kmf_d

; 2998 : 
; 2999 : #ifdef OPTION_KMF_DEBUG
; 3000 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3001 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3002 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3003 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3004 : 
; 3005 :     /* check for end of data */
; 3006 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00cce	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cd6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00cdc	83 e0 01	 and	 eax, 1
  00cdf	85 c0		 test	 eax, eax
  00ce1	74 25		 je	 SHORT $LN99@z900_kmf_d
  00ce3	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00cea	ff c0		 inc	 eax
  00cec	48 98		 cdqe
  00cee	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cf6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00cfe	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv609[rsp], rax
  00d06	eb 22		 jmp	 SHORT $LN100@z900_kmf_d
$LN99@z900_kmf_d:
  00d08	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00d0f	ff c0		 inc	 eax
  00d11	48 98		 cdqe
  00d13	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d1b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00d22	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv609[rsp], rax
$LN100@z900_kmf_d:
  00d2a	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR tv609[rsp], 0
  00d33	75 0a		 jne	 SHORT $LN101@z900_kmf_d
  00d35	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv611[rsp], 1
  00d3d	eb 08		 jmp	 SHORT $LN102@z900_kmf_d
$LN101@z900_kmf_d:
  00d3f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv611[rsp], 0
$LN102@z900_kmf_d:
  00d47	83 7c 24 70 00	 cmp	 DWORD PTR tv611[rsp], 0
  00d4c	74 0a		 je	 SHORT $LN107@z900_kmf_d
  00d4e	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv632[rsp], 1
  00d56	eb 08		 jmp	 SHORT $LN108@z900_kmf_d
$LN107@z900_kmf_d:
  00d58	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv632[rsp], 0
$LN108@z900_kmf_d:
  00d60	83 7c 24 74 00	 cmp	 DWORD PTR tv632[rsp], 0
  00d65	74 0e		 je	 SHORT $LN49@z900_kmf_d

; 3007 :     {
; 3008 :       regs->psw.cc = 0;

  00d67	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d6f	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3009 :       return;

  00d73	eb 11		 jmp	 SHORT $LN1@z900_kmf_d
$LN49@z900_kmf_d:

; 3010 :     }
; 3011 :   }

  00d75	e9 93 f7 ff ff	 jmp	 $LN4@z900_kmf_d
$LN5@z900_kmf_d:

; 3012 : 
; 3013 :   /* CPU-determined amount of data processed */
; 3014 :   regs->psw.cc = 3;

  00d7a	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d82	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmf_d:

; 3015 : }

  00d86	48 8b 8c 24 f8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d8e	48 33 cc	 xor	 rcx, rsp
  00d91	e8 00 00 00 00	 call	 __security_check_cookie
  00d96	48 81 c4 08 03
	00 00		 add	 rsp, 776		; 00000308H
  00d9d	c3		 ret	 0
z900_kmf_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
fc$ = 52
crypted$ = 56
tv135 = 60
tv157 = 64
tv178 = 68
keylen$ = 72
tv234 = 76
tv236 = 80
tv238 = 84
tv373 = 88
tv482 = 92
tv549 = 96
tv570 = 100
parameter_blocklen$ = 104
wrap$ = 108
r1_is_not_r2$ = 112
r1_is_not_r3$ = 116
r2_is_not_r3$ = 120
tv80 = 128
tv155 = 136
tv215 = 144
tv257 = 152
tv279 = 160
tv319 = 168
tv347 = 176
tv368 = 184
tv397 = 192
tv418 = 200
tv447 = 208
tv471 = 216
tv506 = 224
tv527 = 232
tv547 = 240
tfc$ = 248
context$ = 256
countervalue_block$ = 752
message_block$ = 768
parameter_block$ = 784
__$ArrayPad$ = 848
r1$ = 880
r2$ = 888
r3$ = 896
regs$ = 904
z900_kmctr_aes PROC

; 2701 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2702 :   rijndael_ctx context;
; 2703 :   BYTE countervalue_block[16];
; 2704 :   int crypted;
; 2705 :   int i;
; 2706 :   int keylen;
; 2707 :   BYTE message_block[16];
; 2708 :   BYTE parameter_block[64];
; 2709 :   int parameter_blocklen;
; 2710 :   int r1_is_not_r2;
; 2711 :   int r1_is_not_r3;
; 2712 :   int r2_is_not_r3;
; 2713 :   int fc;
; 2714 :   int tfc;
; 2715 :   int wrap;
; 2716 : 
; 2717 :   /* Check special conditions */
; 2718 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  0002b	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00033	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00039	83 e0 01	 and	 eax, 1
  0003c	85 c0		 test	 eax, eax
  0003e	74 25		 je	 SHORT $LN35@z900_kmctr
  00040	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00047	ff c0		 inc	 eax
  00049	48 98		 cdqe
  0004b	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  00063	eb 22		 jmp	 SHORT $LN36@z900_kmctr
$LN35@z900_kmctr:
  00065	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	48 98		 cdqe
  00070	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
$LN36@z900_kmctr:
  00087	33 d2		 xor	 edx, edx
  00089	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  00091	b9 10 00 00 00	 mov	 ecx, 16
  00096	48 f7 f1	 div	 rcx
  00099	48 8b c2	 mov	 rax, rdx
  0009c	48 85 c0	 test	 rax, rax
  0009f	74 0a		 je	 SHORT $LN41@z900_kmctr
  000a1	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  000a9	eb 08		 jmp	 SHORT $LN42@z900_kmctr
$LN41@z900_kmctr:
  000ab	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN42@z900_kmctr:
  000b3	83 7c 24 3c 00	 cmp	 DWORD PTR tv135[rsp], 0
  000b8	74 13		 je	 SHORT $LN20@z900_kmctr

; 2719 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ba	ba 06 00 00 00	 mov	 edx, 6
  000bf	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_kmctr:

; 2720 : 
; 2721 :   /* Return with cc 0 on zero length */
; 2722 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000cd	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000db	83 e0 01	 and	 eax, 1
  000de	85 c0		 test	 eax, eax
  000e0	74 25		 je	 SHORT $LN43@z900_kmctr
  000e2	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000e9	ff c0		 inc	 eax
  000eb	48 98		 cdqe
  000ed	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000fd	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00105	eb 22		 jmp	 SHORT $LN44@z900_kmctr
$LN43@z900_kmctr:
  00107	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0010e	ff c0		 inc	 eax
  00110	48 98		 cdqe
  00112	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00121	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN44@z900_kmctr:
  00129	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR tv155[rsp], 0
  00132	75 0a		 jne	 SHORT $LN45@z900_kmctr
  00134	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  0013c	eb 08		 jmp	 SHORT $LN46@z900_kmctr
$LN45@z900_kmctr:
  0013e	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN46@z900_kmctr:
  00146	83 7c 24 40 00	 cmp	 DWORD PTR tv157[rsp], 0
  0014b	74 0a		 je	 SHORT $LN51@z900_kmctr
  0014d	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00155	eb 08		 jmp	 SHORT $LN52@z900_kmctr
$LN51@z900_kmctr:
  00157	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN52@z900_kmctr:
  0015f	83 7c 24 44 00	 cmp	 DWORD PTR tv178[rsp], 0
  00164	74 11		 je	 SHORT $LN21@z900_kmctr

; 2723 :   {
; 2724 :     regs->psw.cc = 0;

  00166	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2725 :     return;

  00172	e9 ad 09 00 00	 jmp	 $LN1@z900_kmctr
$LN21@z900_kmctr:

; 2726 :   }
; 2727 : 
; 2728 :   /* Initialize values */
; 2729 :   fc = GR0_fc(regs);

  00177	b8 08 00 00 00	 mov	 eax, 8
  0017c	48 6b c0 00	 imul	 rax, rax, 0
  00180	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00188	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0018f	83 e0 7f	 and	 eax, 127		; 0000007fH
  00192	89 44 24 34	 mov	 DWORD PTR fc$[rsp], eax

; 2730 :   tfc = GR0_tfc(regs);

  00196	b8 08 00 00 00	 mov	 eax, 8
  0019b	48 6b c0 00	 imul	 rax, rax, 0
  0019f	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ae	83 e0 7f	 and	 eax, 127		; 0000007fH
  001b1	83 e0 77	 and	 eax, 119		; 00000077H
  001b4	89 84 24 f8 00
	00 00		 mov	 DWORD PTR tfc$[rsp], eax

; 2731 :   wrap = kmctr_wrap[fc];

  001bb	48 63 44 24 34	 movsxd	 rax, DWORD PTR fc$[rsp]
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kmctr_wrap
  001c7	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001ca	89 44 24 6c	 mov	 DWORD PTR wrap$[rsp], eax

; 2732 :   keylen = kmctr_keylengths[fc];

  001ce	48 63 44 24 34	 movsxd	 rax, DWORD PTR fc$[rsp]
  001d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kmctr_keylengths
  001da	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001dd	89 44 24 48	 mov	 DWORD PTR keylen$[rsp], eax

; 2733 :   parameter_blocklen = kmctr_pblens[fc];

  001e1	48 63 44 24 34	 movsxd	 rax, DWORD PTR fc$[rsp]
  001e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kmctr_pblens
  001ed	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  001f0	89 44 24 68	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2734 : #ifdef OPTION_KMCTR_DEBUG
; 2735 :   logmsg("Feature code %d wrap %d keylen %d pblen %d\n",
; 2736 :    tfc, wrap, keylen, parameter_blocklen);
; 2737 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2738 : 
; 2739 :   /* Fetch the parameter block */
; 2740 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001f4	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fc	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00202	83 e0 01	 and	 eax, 1
  00205	85 c0		 test	 eax, eax
  00207	74 23		 je	 SHORT $LN53@z900_kmctr
  00209	b8 08 00 00 00	 mov	 eax, 8
  0020e	48 6b c0 01	 imul	 rax, rax, 1
  00212	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021a	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00222	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
  0022a	eb 20		 jmp	 SHORT $LN54@z900_kmctr
$LN53@z900_kmctr:
  0022c	b8 08 00 00 00	 mov	 eax, 8
  00231	48 6b c0 01	 imul	 rax, rax, 1
  00235	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00244	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv215[rsp], rax
$LN54@z900_kmctr:
  0024c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00254	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0025b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv215[rsp]
  00263	48 23 c8	 and	 rcx, rax
  00266	48 8b c1	 mov	 rax, rcx
  00269	8b 4c 24 68	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0026d	ff c9		 dec	 ecx
  0026f	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00277	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0027c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00282	4c 8b c0	 mov	 r8, rax
  00285	0f b6 d1	 movzx	 edx, cl
  00288	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00290	e8 00 00 00 00	 call	 z900_vfetchc

; 2741 : 
; 2742 : #ifdef OPTION_KMCTR_DEBUG
; 2743 :   LOGBYTE("k     :", parameter_block, keylen);
; 2744 :   if(wrap)
; 2745 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 32], 32);
; 2746 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2747 : 
; 2748 :   if(wrap && unwrap_aes(parameter_block, keylen))

  00295	83 7c 24 6c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0029a	74 26		 je	 SHORT $LN22@z900_kmctr
  0029c	8b 54 24 48	 mov	 edx, DWORD PTR keylen$[rsp]
  002a0	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  002a8	e8 00 00 00 00	 call	 unwrap_aes
  002ad	85 c0		 test	 eax, eax
  002af	74 11		 je	 SHORT $LN22@z900_kmctr

; 2749 :   {
; 2750 : 
; 2751 : #ifdef OPTION_KMCTR_DEBUG
; 2752 :     WRMSG(HHC90111, "D");
; 2753 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2754 : 
; 2755 :     regs->psw.cc = 1;

  002b1	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b9	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2756 :     return;

  002bd	e9 62 08 00 00	 jmp	 $LN1@z900_kmctr
$LN22@z900_kmctr:

; 2757 :   }
; 2758 : 
; 2759 :   /* Set the cryptographic key */
; 2760 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  002c2	8b 44 24 48	 mov	 eax, DWORD PTR keylen$[rsp]
  002c6	c1 e0 03	 shl	 eax, 3
  002c9	44 8b c0	 mov	 r8d, eax
  002cc	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002d4	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  002dc	e8 00 00 00 00	 call	 rijndael_set_key

; 2761 : 
; 2762 :   /* Try to process the CPU-determined amount of data */
; 2763 :   r1_is_not_r2 = r1 != r2;

  002e1	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002e8	39 84 24 70 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002ef	74 0a		 je	 SHORT $LN55@z900_kmctr
  002f1	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv234[rsp], 1
  002f9	eb 08		 jmp	 SHORT $LN56@z900_kmctr
$LN55@z900_kmctr:
  002fb	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
$LN56@z900_kmctr:
  00303	8b 44 24 4c	 mov	 eax, DWORD PTR tv234[rsp]
  00307	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2764 :   r1_is_not_r3 = r1 != r3;

  0030b	8b 84 24 80 03
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00312	39 84 24 70 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00319	74 0a		 je	 SHORT $LN57@z900_kmctr
  0031b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv236[rsp], 1
  00323	eb 08		 jmp	 SHORT $LN58@z900_kmctr
$LN57@z900_kmctr:
  00325	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv236[rsp], 0
$LN58@z900_kmctr:
  0032d	8b 44 24 50	 mov	 eax, DWORD PTR tv236[rsp]
  00331	89 44 24 74	 mov	 DWORD PTR r1_is_not_r3$[rsp], eax

; 2765 :   r2_is_not_r3 = r1 != r2;

  00335	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0033c	39 84 24 70 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00343	74 0a		 je	 SHORT $LN59@z900_kmctr
  00345	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv238[rsp], 1
  0034d	eb 08		 jmp	 SHORT $LN60@z900_kmctr
$LN59@z900_kmctr:
  0034f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv238[rsp], 0
$LN60@z900_kmctr:
  00357	8b 44 24 54	 mov	 eax, DWORD PTR tv238[rsp]
  0035b	89 44 24 78	 mov	 DWORD PTR r2_is_not_r3$[rsp], eax

; 2766 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  0035f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00367	eb 0b		 jmp	 SHORT $LN4@z900_kmctr
$LN2@z900_kmctr:
  00369	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  0036d	83 c0 10	 add	 eax, 16
  00370	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@z900_kmctr:
  00374	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  0037c	0f 8d 96 07 00
	00		 jge	 $LN3@z900_kmctr

; 2767 :   {
; 2768 :     /* Fetch a block of data and counter-value */
; 2769 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00382	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00390	83 e0 01	 and	 eax, 1
  00393	85 c0		 test	 eax, eax
  00395	74 22		 je	 SHORT $LN61@z900_kmctr
  00397	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0039f	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003af	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv257[rsp], rax
  003b7	eb 1f		 jmp	 SHORT $LN62@z900_kmctr
$LN61@z900_kmctr:
  003b9	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003c1	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003d0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv257[rsp], rax
$LN62@z900_kmctr:
  003d8	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003e7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv257[rsp]
  003ef	48 23 c8	 and	 rcx, rax
  003f2	48 8b c1	 mov	 rax, rcx
  003f5	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fd	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00402	44 8b 8c 24 78
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0040a	4c 8b c0	 mov	 r8, rax
  0040d	b2 0f		 mov	 dl, 15
  0040f	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00417	e8 00 00 00 00	 call	 z900_vfetchc

; 2770 :     ARCH_DEP(vfetchc)(countervalue_block, 15, GR_A(r3, regs) & ADDRESS_MAXWRAP(regs), r3, regs);

  0041c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00424	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0042a	83 e0 01	 and	 eax, 1
  0042d	85 c0		 test	 eax, eax
  0042f	74 22		 je	 SHORT $LN63@z900_kmctr
  00431	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00439	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00441	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00449	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
  00451	eb 1f		 jmp	 SHORT $LN64@z900_kmctr
$LN63@z900_kmctr:
  00453	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0045b	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00463	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0046a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv279[rsp], rax
$LN64@z900_kmctr:
  00472	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047a	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00481	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv279[rsp]
  00489	48 23 c8	 and	 rcx, rax
  0048c	48 8b c1	 mov	 rax, rcx
  0048f	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00497	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0049c	44 8b 8c 24 80
	03 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  004a4	4c 8b c0	 mov	 r8, rax
  004a7	b2 0f		 mov	 dl, 15
  004a9	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  004b1	e8 00 00 00 00	 call	 z900_vfetchc

; 2771 : 
; 2772 : #ifdef OPTION_KMCTR_DEBUG
; 2773 :     LOGBYTE("input :", message_block, 16);
; 2774 :     LOGBYTE("cv    :", countervalue_block, 16);
; 2775 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2776 : 
; 2777 :     /* Do the job */
; 2778 :     /* Encrypt and XOR */
; 2779 :     rijndael_encrypt(&context, countervalue_block, countervalue_block);

  004b6	4c 8d 84 24 f0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  004be	48 8d 94 24 f0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  004c6	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  004ce	e8 00 00 00 00	 call	 rijndael_encrypt

; 2780 :     for(i = 0; i < 16; i++)

  004d3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004db	eb 0a		 jmp	 SHORT $LN7@z900_kmctr
$LN5@z900_kmctr:
  004dd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004e1	ff c0		 inc	 eax
  004e3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_kmctr:
  004e7	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  004ec	7d 2a		 jge	 SHORT $LN6@z900_kmctr

; 2781 :       countervalue_block[i] ^= message_block[i];

  004ee	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004f3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004f8	0f b6 8c 0c 00
	03 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  00500	0f b6 84 04 f0
	02 00 00	 movzx	 eax, BYTE PTR countervalue_block$[rsp+rax]
  00508	33 c1		 xor	 eax, ecx
  0050a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0050f	88 84 0c f0 02
	00 00		 mov	 BYTE PTR countervalue_block$[rsp+rcx], al
  00516	eb c5		 jmp	 SHORT $LN5@z900_kmctr
$LN6@z900_kmctr:

; 2782 : 
; 2783 :     /* Store the output */
; 2784 :     ARCH_DEP(vstorec)(countervalue_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00518	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00520	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00526	83 e0 01	 and	 eax, 1
  00529	85 c0		 test	 eax, eax
  0052b	74 22		 je	 SHORT $LN65@z900_kmctr
  0052d	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00535	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0053d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00545	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv319[rsp], rax
  0054d	eb 1f		 jmp	 SHORT $LN66@z900_kmctr
$LN65@z900_kmctr:
  0054f	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00557	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00566	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv319[rsp], rax
$LN66@z900_kmctr:
  0056e	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00576	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0057d	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv319[rsp]
  00585	48 23 c8	 and	 rcx, rax
  00588	48 8b c1	 mov	 rax, rcx
  0058b	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00593	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00598	44 8b 8c 24 70
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  005a0	4c 8b c0	 mov	 r8, rax
  005a3	b2 0f		 mov	 dl, 15
  005a5	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  005ad	e8 00 00 00 00	 call	 z900_vstorec
$LN10@z900_kmctr:

; 2785 : 
; 2786 : #ifdef OPTION_KMCTR_DEBUG
; 2787 :     LOGBYTE("output:", countervalue_block, 16);
; 2788 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2789 : 
; 2790 :     /* Update the registers */
; 2791 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  005b2	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ba	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005c0	83 e0 01	 and	 eax, 1
  005c3	85 c0		 test	 eax, eax
  005c5	74 7c		 je	 SHORT $LN23@z900_kmctr
  005c7	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005cf	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005d5	83 e0 01	 and	 eax, 1
  005d8	85 c0		 test	 eax, eax
  005da	74 22		 je	 SHORT $LN67@z900_kmctr
  005dc	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  005e4	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ec	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  005f4	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv347[rsp], rax
  005fc	eb 1f		 jmp	 SHORT $LN68@z900_kmctr
$LN67@z900_kmctr:
  005fe	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00606	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00615	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv347[rsp], rax
$LN68@z900_kmctr:
  0061d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv347[rsp]
  00625	48 83 c0 10	 add	 rax, 16
  00629	48 63 8c 24 70
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00631	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00639	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00641	eb 79		 jmp	 SHORT $LN24@z900_kmctr
$LN23@z900_kmctr:
  00643	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0064b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00651	83 e0 01	 and	 eax, 1
  00654	85 c0		 test	 eax, eax
  00656	74 22		 je	 SHORT $LN69@z900_kmctr
  00658	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00660	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00668	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00670	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv368[rsp], rax
  00678	eb 1f		 jmp	 SHORT $LN70@z900_kmctr
$LN69@z900_kmctr:
  0067a	48 63 84 24 70
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00682	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00691	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv368[rsp], rax
$LN70@z900_kmctr:
  00699	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv368[rsp]
  006a1	48 83 c0 10	 add	 rax, 16
  006a5	48 63 8c 24 70
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  006ad	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006b5	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN24@z900_kmctr:
  006bc	33 c0		 xor	 eax, eax
  006be	85 c0		 test	 eax, eax
  006c0	0f 85 ec fe ff
	ff		 jne	 $LN10@z900_kmctr

; 2792 :     if(likely(r1_is_not_r2))

  006c6	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  006cb	74 0a		 je	 SHORT $LN71@z900_kmctr
  006cd	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv373[rsp], 1
  006d5	eb 08		 jmp	 SHORT $LN72@z900_kmctr
$LN71@z900_kmctr:
  006d7	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv373[rsp], 0
$LN72@z900_kmctr:
  006df	83 7c 24 58 00	 cmp	 DWORD PTR tv373[rsp], 0
  006e4	0f 84 14 01 00
	00		 je	 $LN25@z900_kmctr
$LN13@z900_kmctr:

; 2793 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  006ea	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006f8	83 e0 01	 and	 eax, 1
  006fb	85 c0		 test	 eax, eax
  006fd	74 7c		 je	 SHORT $LN26@z900_kmctr
  006ff	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00707	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0070d	83 e0 01	 and	 eax, 1
  00710	85 c0		 test	 eax, eax
  00712	74 22		 je	 SHORT $LN73@z900_kmctr
  00714	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0071c	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00724	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0072c	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv397[rsp], rax
  00734	eb 1f		 jmp	 SHORT $LN74@z900_kmctr
$LN73@z900_kmctr:
  00736	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0073e	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00746	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0074d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv397[rsp], rax
$LN74@z900_kmctr:
  00755	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv397[rsp]
  0075d	48 83 c0 10	 add	 rax, 16
  00761	48 63 8c 24 78
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00769	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00771	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00779	eb 79		 jmp	 SHORT $LN27@z900_kmctr
$LN26@z900_kmctr:
  0077b	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00783	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00789	83 e0 01	 and	 eax, 1
  0078c	85 c0		 test	 eax, eax
  0078e	74 22		 je	 SHORT $LN75@z900_kmctr
  00790	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00798	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a0	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007a8	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv418[rsp], rax
  007b0	eb 1f		 jmp	 SHORT $LN76@z900_kmctr
$LN75@z900_kmctr:
  007b2	48 63 84 24 78
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  007ba	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007c9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv418[rsp], rax
$LN76@z900_kmctr:
  007d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv418[rsp]
  007d9	48 83 c0 10	 add	 rax, 16
  007dd	48 63 8c 24 78
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  007e5	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007ed	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN27@z900_kmctr:
  007f4	33 c0		 xor	 eax, eax
  007f6	85 c0		 test	 eax, eax
  007f8	0f 85 ec fe ff
	ff		 jne	 $LN13@z900_kmctr
$LN25@z900_kmctr:
$LN16@z900_kmctr:

; 2794 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  007fe	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00806	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0080c	83 e0 01	 and	 eax, 1
  0080f	85 c0		 test	 eax, eax
  00811	0f 84 89 00 00
	00		 je	 $LN28@z900_kmctr
  00817	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00825	83 e0 01	 and	 eax, 1
  00828	85 c0		 test	 eax, eax
  0082a	74 25		 je	 SHORT $LN77@z900_kmctr
  0082c	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00833	ff c0		 inc	 eax
  00835	48 98		 cdqe
  00837	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0083f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00847	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv447[rsp], rax
  0084f	eb 22		 jmp	 SHORT $LN78@z900_kmctr
$LN77@z900_kmctr:
  00851	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00858	ff c0		 inc	 eax
  0085a	48 98		 cdqe
  0085c	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00864	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0086b	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv447[rsp], rax
$LN78@z900_kmctr:
  00873	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv447[rsp]
  0087b	48 83 e8 10	 sub	 rax, 16
  0087f	8b 8c 24 78 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00886	ff c1		 inc	 ecx
  00888	48 63 c9	 movsxd	 rcx, ecx
  0088b	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00893	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  0089b	e9 83 00 00 00	 jmp	 $LN29@z900_kmctr
$LN28@z900_kmctr:
  008a0	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008a8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008ae	83 e0 01	 and	 eax, 1
  008b1	85 c0		 test	 eax, eax
  008b3	74 25		 je	 SHORT $LN79@z900_kmctr
  008b5	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008bc	ff c0		 inc	 eax
  008be	48 98		 cdqe
  008c0	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008c8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008d0	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv471[rsp], rax
  008d8	eb 22		 jmp	 SHORT $LN80@z900_kmctr
$LN79@z900_kmctr:
  008da	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008e1	ff c0		 inc	 eax
  008e3	48 98		 cdqe
  008e5	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ed	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008f4	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv471[rsp], rax
$LN80@z900_kmctr:
  008fc	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv471[rsp]
  00904	48 83 e8 10	 sub	 rax, 16
  00908	8b 8c 24 78 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0090f	ff c1		 inc	 ecx
  00911	48 63 c9	 movsxd	 rcx, ecx
  00914	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0091c	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN29@z900_kmctr:
  00923	33 c0		 xor	 eax, eax
  00925	85 c0		 test	 eax, eax
  00927	0f 85 d1 fe ff
	ff		 jne	 $LN16@z900_kmctr

; 2795 :     if(likely(r1_is_not_r3 && r2_is_not_r3))

  0092d	83 7c 24 74 00	 cmp	 DWORD PTR r1_is_not_r3$[rsp], 0
  00932	74 11		 je	 SHORT $LN81@z900_kmctr
  00934	83 7c 24 78 00	 cmp	 DWORD PTR r2_is_not_r3$[rsp], 0
  00939	74 0a		 je	 SHORT $LN81@z900_kmctr
  0093b	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv482[rsp], 1
  00943	eb 08		 jmp	 SHORT $LN84@z900_kmctr
$LN81@z900_kmctr:
  00945	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv482[rsp], 0
$LN84@z900_kmctr:
  0094d	83 7c 24 5c 00	 cmp	 DWORD PTR tv482[rsp], 0
  00952	0f 84 14 01 00
	00		 je	 $LN30@z900_kmctr
$LN19@z900_kmctr:

; 2796 :       SET_GR_A(r3, regs, GR_A(r3, regs) + 16);

  00958	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00960	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00966	83 e0 01	 and	 eax, 1
  00969	85 c0		 test	 eax, eax
  0096b	74 7c		 je	 SHORT $LN31@z900_kmctr
  0096d	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00975	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0097b	83 e0 01	 and	 eax, 1
  0097e	85 c0		 test	 eax, eax
  00980	74 22		 je	 SHORT $LN85@z900_kmctr
  00982	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0098a	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00992	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0099a	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv506[rsp], rax
  009a2	eb 1f		 jmp	 SHORT $LN86@z900_kmctr
$LN85@z900_kmctr:
  009a4	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  009ac	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009b4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009bb	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv506[rsp], rax
$LN86@z900_kmctr:
  009c3	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv506[rsp]
  009cb	48 83 c0 10	 add	 rax, 16
  009cf	48 63 8c 24 80
	03 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  009d7	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009df	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  009e7	eb 79		 jmp	 SHORT $LN32@z900_kmctr
$LN31@z900_kmctr:
  009e9	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009f1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  009f7	83 e0 01	 and	 eax, 1
  009fa	85 c0		 test	 eax, eax
  009fc	74 22		 je	 SHORT $LN87@z900_kmctr
  009fe	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00a06	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a0e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a16	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv527[rsp], rax
  00a1e	eb 1f		 jmp	 SHORT $LN88@z900_kmctr
$LN87@z900_kmctr:
  00a20	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00a28	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a30	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a37	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv527[rsp], rax
$LN88@z900_kmctr:
  00a3f	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv527[rsp]
  00a47	48 83 c0 10	 add	 rax, 16
  00a4b	48 63 8c 24 80
	03 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00a53	48 8b 94 24 88
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a5b	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN32@z900_kmctr:
  00a62	33 c0		 xor	 eax, eax
  00a64	85 c0		 test	 eax, eax
  00a66	0f 85 ec fe ff
	ff		 jne	 $LN19@z900_kmctr
$LN30@z900_kmctr:

; 2797 : 
; 2798 : #ifdef OPTION_KMCTR_DEBUG
; 2799 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2800 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2801 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2802 :     WRMSG(HHC90108, "D", r3, (regs)->GR(r3));
; 2803 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2804 : 
; 2805 :     /* check for end of data */
; 2806 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00a6c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a74	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a7a	83 e0 01	 and	 eax, 1
  00a7d	85 c0		 test	 eax, eax
  00a7f	74 25		 je	 SHORT $LN89@z900_kmctr
  00a81	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a88	ff c0		 inc	 eax
  00a8a	48 98		 cdqe
  00a8c	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a94	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a9c	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv547[rsp], rax
  00aa4	eb 22		 jmp	 SHORT $LN90@z900_kmctr
$LN89@z900_kmctr:
  00aa6	8b 84 24 78 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00aad	ff c0		 inc	 eax
  00aaf	48 98		 cdqe
  00ab1	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ab9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00ac0	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv547[rsp], rax
$LN90@z900_kmctr:
  00ac8	48 83 bc 24 f0
	00 00 00 00	 cmp	 QWORD PTR tv547[rsp], 0
  00ad1	75 0a		 jne	 SHORT $LN91@z900_kmctr
  00ad3	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv549[rsp], 1
  00adb	eb 08		 jmp	 SHORT $LN92@z900_kmctr
$LN91@z900_kmctr:
  00add	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv549[rsp], 0
$LN92@z900_kmctr:
  00ae5	83 7c 24 60 00	 cmp	 DWORD PTR tv549[rsp], 0
  00aea	74 0a		 je	 SHORT $LN97@z900_kmctr
  00aec	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv570[rsp], 1
  00af4	eb 08		 jmp	 SHORT $LN98@z900_kmctr
$LN97@z900_kmctr:
  00af6	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv570[rsp], 0
$LN98@z900_kmctr:
  00afe	83 7c 24 64 00	 cmp	 DWORD PTR tv570[rsp], 0
  00b03	74 0e		 je	 SHORT $LN33@z900_kmctr

; 2807 :     {
; 2808 :       regs->psw.cc = 0;

  00b05	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2809 :       return;

  00b11	eb 11		 jmp	 SHORT $LN1@z900_kmctr
$LN33@z900_kmctr:

; 2810 :     }
; 2811 :   }

  00b13	e9 51 f8 ff ff	 jmp	 $LN2@z900_kmctr
$LN3@z900_kmctr:

; 2812 : 
; 2813 :   /* CPU-determined amount of data processed */
; 2814 :   regs->psw.cc = 3;

  00b18	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b20	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmctr:

; 2815 : }

  00b24	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b2c	48 33 cc	 xor	 rcx, rsp
  00b2f	e8 00 00 00 00	 call	 __security_check_cookie
  00b34	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  00b3b	c3		 ret	 0
z900_kmctr_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv225 = 56
crypted$ = 60
tfc$ = 64
tv299 = 68
tv135 = 72
tv157 = 76
tv178 = 80
tv193 = 84
wrap$ = 88
keylen$ = 92
tv248 = 96
tv250 = 100
tv252 = 104
tv409 = 108
tv518 = 112
tv585 = 116
tv606 = 120
r1_is_not_r2$ = 124
r1_is_not_r3$ = 128
r2_is_not_r3$ = 132
tv80 = 136
tv155 = 144
tv211 = 152
tv271 = 160
tv293 = 168
tv355 = 176
tv383 = 184
tv404 = 192
tv433 = 200
tv454 = 208
tv483 = 216
tv507 = 224
tv542 = 232
tv563 = 240
tv583 = 248
context1$ = 256
context2$ = 400
context3$ = 544
countervalue_block$ = 688
message_block$ = 696
parameter_block$ = 704
__$ArrayPad$ = 752
r1$ = 784
r2$ = 792
r3$ = 800
regs$ = 808
z900_kmctr_dea PROC

; 2519 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 08 03
	00 00		 sub	 rsp, 776		; 00000308H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 f0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2520 :   des_context context1;
; 2521 :   des_context context2;
; 2522 :   des_context context3;
; 2523 :   BYTE countervalue_block[8];
; 2524 :   int crypted;
; 2525 :   int i;
; 2526 :   int keylen;
; 2527 :   BYTE message_block[8];
; 2528 :   BYTE parameter_block[48];
; 2529 :   int parameter_blocklen;
; 2530 :   int r1_is_not_r2;
; 2531 :   int r1_is_not_r3;
; 2532 :   int r2_is_not_r3;
; 2533 :   int tfc;
; 2534 :   int wrap;
; 2535 : 
; 2536 :   /* Check special conditions */
; 2537 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  0002b	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00033	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00039	83 e0 01	 and	 eax, 1
  0003c	85 c0		 test	 eax, eax
  0003e	74 25		 je	 SHORT $LN46@z900_kmctr
  00040	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00047	ff c0		 inc	 eax
  00049	48 98		 cdqe
  0004b	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00053	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  00063	eb 22		 jmp	 SHORT $LN47@z900_kmctr
$LN46@z900_kmctr:
  00065	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0006c	ff c0		 inc	 eax
  0006e	48 98		 cdqe
  00070	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00078	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
$LN47@z900_kmctr:
  00087	33 d2		 xor	 edx, edx
  00089	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  00091	b9 08 00 00 00	 mov	 ecx, 8
  00096	48 f7 f1	 div	 rcx
  00099	48 8b c2	 mov	 rax, rdx
  0009c	48 85 c0	 test	 rax, rax
  0009f	74 0a		 je	 SHORT $LN52@z900_kmctr
  000a1	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  000a9	eb 08		 jmp	 SHORT $LN53@z900_kmctr
$LN52@z900_kmctr:
  000ab	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN53@z900_kmctr:
  000b3	83 7c 24 48 00	 cmp	 DWORD PTR tv135[rsp], 0
  000b8	74 13		 je	 SHORT $LN24@z900_kmctr

; 2538 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ba	ba 06 00 00 00	 mov	 edx, 6
  000bf	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN24@z900_kmctr:

; 2539 : 
; 2540 :   /* Return with cc 0 on zero length */
; 2541 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000cd	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000db	83 e0 01	 and	 eax, 1
  000de	85 c0		 test	 eax, eax
  000e0	74 25		 je	 SHORT $LN54@z900_kmctr
  000e2	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000e9	ff c0		 inc	 eax
  000eb	48 98		 cdqe
  000ed	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000fd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00105	eb 22		 jmp	 SHORT $LN55@z900_kmctr
$LN54@z900_kmctr:
  00107	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0010e	ff c0		 inc	 eax
  00110	48 98		 cdqe
  00112	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00121	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN55@z900_kmctr:
  00129	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR tv155[rsp], 0
  00132	75 0a		 jne	 SHORT $LN56@z900_kmctr
  00134	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  0013c	eb 08		 jmp	 SHORT $LN57@z900_kmctr
$LN56@z900_kmctr:
  0013e	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN57@z900_kmctr:
  00146	83 7c 24 4c 00	 cmp	 DWORD PTR tv157[rsp], 0
  0014b	74 0a		 je	 SHORT $LN62@z900_kmctr
  0014d	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00155	eb 08		 jmp	 SHORT $LN63@z900_kmctr
$LN62@z900_kmctr:
  00157	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN63@z900_kmctr:
  0015f	83 7c 24 50 00	 cmp	 DWORD PTR tv178[rsp], 0
  00164	74 11		 je	 SHORT $LN25@z900_kmctr

; 2542 :   {
; 2543 :     regs->psw.cc = 0;

  00166	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2544 :     return;

  00172	e9 43 0b 00 00	 jmp	 $LN1@z900_kmctr
$LN25@z900_kmctr:

; 2545 :   }
; 2546 : 
; 2547 :   /* Initialize values */
; 2548 :   tfc = GR0_tfc(regs);

  00177	b8 08 00 00 00	 mov	 eax, 8
  0017c	48 6b c0 00	 imul	 rax, rax, 0
  00180	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00188	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0018f	83 e0 7f	 and	 eax, 127		; 0000007fH
  00192	83 e0 77	 and	 eax, 119		; 00000077H
  00195	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 2549 :   wrap = GR0_wrap(regs);

  00199	b8 08 00 00 00	 mov	 eax, 8
  0019e	48 6b c0 00	 imul	 rax, rax, 0
  001a2	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001aa	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001b1	83 e0 08	 and	 eax, 8
  001b4	85 c0		 test	 eax, eax
  001b6	74 0a		 je	 SHORT $LN64@z900_kmctr
  001b8	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001c0	eb 08		 jmp	 SHORT $LN65@z900_kmctr
$LN64@z900_kmctr:
  001c2	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN65@z900_kmctr:
  001ca	8b 44 24 54	 mov	 eax, DWORD PTR tv193[rsp]
  001ce	89 44 24 58	 mov	 DWORD PTR wrap$[rsp], eax

; 2550 :   keylen = tfc * 8;

  001d2	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  001d6	c1 e0 03	 shl	 eax, 3
  001d9	89 44 24 5c	 mov	 DWORD PTR keylen$[rsp], eax

; 2551 :   parameter_blocklen = keylen;

  001dd	8b 44 24 5c	 mov	 eax, DWORD PTR keylen$[rsp]
  001e1	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2552 :   if(wrap)

  001e5	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001ea	74 0b		 je	 SHORT $LN26@z900_kmctr

; 2553 :     parameter_blocklen += 24;

  001ec	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001f0	83 c0 18	 add	 eax, 24
  001f3	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN26@z900_kmctr:

; 2554 : 
; 2555 :   /* Fetch the parameter block */
; 2556 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001f7	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ff	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00205	83 e0 01	 and	 eax, 1
  00208	85 c0		 test	 eax, eax
  0020a	74 23		 je	 SHORT $LN66@z900_kmctr
  0020c	b8 08 00 00 00	 mov	 eax, 8
  00211	48 6b c0 01	 imul	 rax, rax, 1
  00215	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021d	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00225	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
  0022d	eb 20		 jmp	 SHORT $LN67@z900_kmctr
$LN66@z900_kmctr:
  0022f	b8 08 00 00 00	 mov	 eax, 8
  00234	48 6b c0 01	 imul	 rax, rax, 1
  00238	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00240	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00247	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
$LN67@z900_kmctr:
  0024f	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00257	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0025e	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv211[rsp]
  00266	48 23 c8	 and	 rcx, rax
  00269	48 8b c1	 mov	 rax, rcx
  0026c	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00270	ff c9		 dec	 ecx
  00272	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0027a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0027f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00285	4c 8b c0	 mov	 r8, rax
  00288	0f b6 d1	 movzx	 edx, cl
  0028b	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00293	e8 00 00 00 00	 call	 z900_vfetchc

; 2557 : 
; 2558 : #ifdef OPTION_KMCTR_DEBUG
; 2559 :   switch(tfc)
; 2560 :   {
; 2561 :     case 1: /* dea */
; 2562 :     {
; 2563 :       LOGBYTE("k     :", parameter_block, 8);
; 2564 :       break;
; 2565 :     }
; 2566 :     case 2: /* tdea-128 */
; 2567 :     {
; 2568 :       LOGBYTE("k1    :", parameter_block, 8);
; 2569 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 2570 :       break;
; 2571 :     }
; 2572 :     case 3: /* tdea-192 */
; 2573 :     {
; 2574 :       LOGBYTE("k1    :", parameter_block, 8);
; 2575 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 2576 :       LOGBYTE("k3    :", &parameter_block[16], 8);
; 2577 :       break;
; 2578 :     }
; 2579 :   }
; 2580 :   if(wrap)
; 2581 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 24], 24);
; 2582 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2583 : 
; 2584 :   /* Verify and unwrap */
; 2585 :   if(wrap && unwrap_dea(parameter_block, keylen))

  00298	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0029d	74 26		 je	 SHORT $LN27@z900_kmctr
  0029f	8b 54 24 5c	 mov	 edx, DWORD PTR keylen$[rsp]
  002a3	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  002ab	e8 00 00 00 00	 call	 unwrap_dea
  002b0	85 c0		 test	 eax, eax
  002b2	74 11		 je	 SHORT $LN27@z900_kmctr

; 2586 :   {
; 2587 : 
; 2588 : #ifdef OPTION_KMCTR_DEBUG
; 2589 :     WRMSG(HHC90111, "D");
; 2590 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2591 : 
; 2592 :     regs->psw.cc = 1;

  002b4	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bc	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2593 :     return;

  002c0	e9 f5 09 00 00	 jmp	 $LN1@z900_kmctr
$LN27@z900_kmctr:

; 2594 :   }
; 2595 : 
; 2596 :   /* Set the cryptographic key */
; 2597 :   switch(tfc)

  002c5	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  002c9	89 44 24 38	 mov	 DWORD PTR tv225[rsp], eax
  002cd	83 7c 24 38 01	 cmp	 DWORD PTR tv225[rsp], 1
  002d2	74 13		 je	 SHORT $LN28@z900_kmctr
  002d4	83 7c 24 38 02	 cmp	 DWORD PTR tv225[rsp], 2
  002d9	74 26		 je	 SHORT $LN29@z900_kmctr
  002db	83 7c 24 38 03	 cmp	 DWORD PTR tv225[rsp], 3
  002e0	74 57		 je	 SHORT $LN30@z900_kmctr
  002e2	e9 a9 00 00 00	 jmp	 $LN2@z900_kmctr
$LN28@z900_kmctr:

; 2598 :   {
; 2599 :     case 1: /* dea */
; 2600 :     {
; 2601 :       des_set_key(&context1, parameter_block);

  002e7	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002ef	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002f7	e8 00 00 00 00	 call	 des_set_key

; 2602 :       break;

  002fc	e9 8f 00 00 00	 jmp	 $LN2@z900_kmctr
$LN29@z900_kmctr:

; 2603 :     }
; 2604 :     case 2: /* tdea-128 */
; 2605 :     {
; 2606 :       des_set_key(&context1, parameter_block);

  00301	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00309	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00311	e8 00 00 00 00	 call	 des_set_key

; 2607 :       des_set_key(&context2, &parameter_block[8]);

  00316	b8 01 00 00 00	 mov	 eax, 1
  0031b	48 6b c0 08	 imul	 rax, rax, 8
  0031f	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00327	48 8b d0	 mov	 rdx, rax
  0032a	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00332	e8 00 00 00 00	 call	 des_set_key

; 2608 :       break;

  00337	eb 57		 jmp	 SHORT $LN2@z900_kmctr
$LN30@z900_kmctr:

; 2609 :     }
; 2610 :     case 3: /* tdea-192 */
; 2611 :     {
; 2612 :       des_set_key(&context1, parameter_block);

  00339	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00341	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00349	e8 00 00 00 00	 call	 des_set_key

; 2613 :       des_set_key(&context2, &parameter_block[8]);

  0034e	b8 01 00 00 00	 mov	 eax, 1
  00353	48 6b c0 08	 imul	 rax, rax, 8
  00357	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0035f	48 8b d0	 mov	 rdx, rax
  00362	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0036a	e8 00 00 00 00	 call	 des_set_key

; 2614 :       des_set_key(&context3, &parameter_block[16]);

  0036f	b8 01 00 00 00	 mov	 eax, 1
  00374	48 6b c0 10	 imul	 rax, rax, 16
  00378	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00380	48 8b d0	 mov	 rdx, rax
  00383	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0038b	e8 00 00 00 00	 call	 des_set_key
$LN2@z900_kmctr:

; 2615 :       break;
; 2616 :     }
; 2617 :   }
; 2618 : 
; 2619 :   /* Try to process the CPU-determined amount of data */
; 2620 :   r1_is_not_r2 = r1 != r2;

  00390	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00397	39 84 24 10 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0039e	74 0a		 je	 SHORT $LN68@z900_kmctr
  003a0	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv248[rsp], 1
  003a8	eb 08		 jmp	 SHORT $LN69@z900_kmctr
$LN68@z900_kmctr:
  003aa	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv248[rsp], 0
$LN69@z900_kmctr:
  003b2	8b 44 24 60	 mov	 eax, DWORD PTR tv248[rsp]
  003b6	89 44 24 7c	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2621 :   r1_is_not_r3 = r1 != r3;

  003ba	8b 84 24 20 03
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  003c1	39 84 24 10 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  003c8	74 0a		 je	 SHORT $LN70@z900_kmctr
  003ca	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv250[rsp], 1
  003d2	eb 08		 jmp	 SHORT $LN71@z900_kmctr
$LN70@z900_kmctr:
  003d4	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv250[rsp], 0
$LN71@z900_kmctr:
  003dc	8b 44 24 64	 mov	 eax, DWORD PTR tv250[rsp]
  003e0	89 84 24 80 00
	00 00		 mov	 DWORD PTR r1_is_not_r3$[rsp], eax

; 2622 :   r2_is_not_r3 = r2 != r3;

  003e7	8b 84 24 20 03
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  003ee	39 84 24 18 03
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  003f5	74 0a		 je	 SHORT $LN72@z900_kmctr
  003f7	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv252[rsp], 1
  003ff	eb 08		 jmp	 SHORT $LN73@z900_kmctr
$LN72@z900_kmctr:
  00401	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN73@z900_kmctr:
  00409	8b 44 24 68	 mov	 eax, DWORD PTR tv252[rsp]
  0040d	89 84 24 84 00
	00 00		 mov	 DWORD PTR r2_is_not_r3$[rsp], eax

; 2623 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  00414	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0041c	eb 0b		 jmp	 SHORT $LN6@z900_kmctr
$LN4@z900_kmctr:
  0041e	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00422	83 c0 08	 add	 eax, 8
  00425	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@z900_kmctr:
  00429	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00431	0f 8d 77 08 00
	00		 jge	 $LN5@z900_kmctr

; 2624 :   {
; 2625 :     /* Fetch a block of data and counter-value */
; 2626 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00437	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00445	83 e0 01	 and	 eax, 1
  00448	85 c0		 test	 eax, eax
  0044a	74 22		 je	 SHORT $LN74@z900_kmctr
  0044c	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00454	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00464	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
  0046c	eb 1f		 jmp	 SHORT $LN75@z900_kmctr
$LN74@z900_kmctr:
  0046e	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00476	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00485	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
$LN75@z900_kmctr:
  0048d	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00495	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0049c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv271[rsp]
  004a4	48 23 c8	 and	 rcx, rax
  004a7	48 8b c1	 mov	 rax, rcx
  004aa	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004b7	44 8b 8c 24 18
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  004bf	4c 8b c0	 mov	 r8, rax
  004c2	b2 07		 mov	 dl, 7
  004c4	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  004cc	e8 00 00 00 00	 call	 z900_vfetchc

; 2627 :     ARCH_DEP(vfetchc)(countervalue_block, 7, GR_A(r3, regs) & ADDRESS_MAXWRAP(regs), r3, regs);

  004d1	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004df	83 e0 01	 and	 eax, 1
  004e2	85 c0		 test	 eax, eax
  004e4	74 22		 je	 SHORT $LN76@z900_kmctr
  004e6	48 63 84 24 20
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004ee	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  004fe	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv293[rsp], rax
  00506	eb 1f		 jmp	 SHORT $LN77@z900_kmctr
$LN76@z900_kmctr:
  00508	48 63 84 24 20
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00510	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00518	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0051f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv293[rsp], rax
$LN77@z900_kmctr:
  00527	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00536	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv293[rsp]
  0053e	48 23 c8	 and	 rcx, rax
  00541	48 8b c1	 mov	 rax, rcx
  00544	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00551	44 8b 8c 24 20
	03 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  00559	4c 8b c0	 mov	 r8, rax
  0055c	b2 07		 mov	 dl, 7
  0055e	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  00566	e8 00 00 00 00	 call	 z900_vfetchc

; 2628 : 
; 2629 : #ifdef OPTION_KMCTR_DEBUG
; 2630 :     LOGBYTE("input :", message_block, 8);
; 2631 :     LOGBYTE("cv    :", countervalue_block, 8);
; 2632 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2633 : 
; 2634 :     /* Do the job */
; 2635 :     switch(tfc)

  0056b	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0056f	89 44 24 44	 mov	 DWORD PTR tv299[rsp], eax
  00573	83 7c 24 44 01	 cmp	 DWORD PTR tv299[rsp], 1
  00578	74 17		 je	 SHORT $LN31@z900_kmctr
  0057a	83 7c 24 44 02	 cmp	 DWORD PTR tv299[rsp], 2
  0057f	74 32		 je	 SHORT $LN32@z900_kmctr
  00581	83 7c 24 44 03	 cmp	 DWORD PTR tv299[rsp], 3
  00586	0f 84 80 00 00
	00		 je	 $LN33@z900_kmctr
  0058c	e9 d2 00 00 00	 jmp	 $LN7@z900_kmctr
$LN31@z900_kmctr:

; 2636 :     {
; 2637 :       /* Encrypt */
; 2638 :       case 1: /* dea */
; 2639 :       {
; 2640 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  00591	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  00599	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  005a1	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005a9	e8 00 00 00 00	 call	 des_encrypt

; 2641 :         break;

  005ae	e9 b0 00 00 00	 jmp	 $LN7@z900_kmctr
$LN32@z900_kmctr:

; 2642 :       }
; 2643 :       case 2: /* tdea-128 */
; 2644 :       {
; 2645 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  005b3	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  005bb	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  005c3	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005cb	e8 00 00 00 00	 call	 des_encrypt

; 2646 :         des_decrypt(&context2, countervalue_block, countervalue_block);

  005d0	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  005d8	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  005e0	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  005e8	e8 00 00 00 00	 call	 des_decrypt

; 2647 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  005ed	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  005f5	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  005fd	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00605	e8 00 00 00 00	 call	 des_encrypt

; 2648 :         break;

  0060a	eb 57		 jmp	 SHORT $LN7@z900_kmctr
$LN33@z900_kmctr:

; 2649 :       }
; 2650 :       case 3: /* tdea-192 */
; 2651 :       {
; 2652 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  0060c	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  00614	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  0061c	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00624	e8 00 00 00 00	 call	 des_encrypt

; 2653 :         des_decrypt(&context2, countervalue_block, countervalue_block);

  00629	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  00631	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  00639	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00641	e8 00 00 00 00	 call	 des_decrypt

; 2654 :         des_encrypt(&context3, countervalue_block, countervalue_block);

  00646	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  0064e	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  00656	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0065e	e8 00 00 00 00	 call	 des_encrypt
$LN7@z900_kmctr:

; 2655 :         break;
; 2656 :       }
; 2657 :     }
; 2658 : 
; 2659 :     /* XOR */
; 2660 :     for(i = 0; i < 8; i++)

  00663	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0066b	eb 0a		 jmp	 SHORT $LN11@z900_kmctr
$LN9@z900_kmctr:
  0066d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00671	ff c0		 inc	 eax
  00673	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@z900_kmctr:
  00677	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0067c	7d 2a		 jge	 SHORT $LN10@z900_kmctr

; 2661 :       countervalue_block[i] ^= message_block[i];

  0067e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00683	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00688	0f b6 8c 0c b8
	02 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  00690	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR countervalue_block$[rsp+rax]
  00698	33 c1		 xor	 eax, ecx
  0069a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0069f	88 84 0c b0 02
	00 00		 mov	 BYTE PTR countervalue_block$[rsp+rcx], al
  006a6	eb c5		 jmp	 SHORT $LN9@z900_kmctr
$LN10@z900_kmctr:

; 2662 : 
; 2663 :     /* Store the output */
; 2664 :     ARCH_DEP(vstorec)(countervalue_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  006a8	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006b6	83 e0 01	 and	 eax, 1
  006b9	85 c0		 test	 eax, eax
  006bb	74 22		 je	 SHORT $LN78@z900_kmctr
  006bd	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006c5	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006cd	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  006d5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv355[rsp], rax
  006dd	eb 1f		 jmp	 SHORT $LN79@z900_kmctr
$LN78@z900_kmctr:
  006df	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006e7	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ef	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006f6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv355[rsp], rax
$LN79@z900_kmctr:
  006fe	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00706	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0070d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv355[rsp]
  00715	48 23 c8	 and	 rcx, rax
  00718	48 8b c1	 mov	 rax, rcx
  0071b	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00723	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00728	44 8b 8c 24 10
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  00730	4c 8b c0	 mov	 r8, rax
  00733	b2 07		 mov	 dl, 7
  00735	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  0073d	e8 00 00 00 00	 call	 z900_vstorec
$LN14@z900_kmctr:

; 2665 : 
; 2666 : #ifdef OPTION_KMCTR_DEBUG
; 2667 :     LOGBYTE("output:", countervalue_block, 8);
; 2668 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2669 : 
; 2670 :     /* Update the registers */
; 2671 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  00742	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0074a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00750	83 e0 01	 and	 eax, 1
  00753	85 c0		 test	 eax, eax
  00755	74 7c		 je	 SHORT $LN34@z900_kmctr
  00757	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0075f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00765	83 e0 01	 and	 eax, 1
  00768	85 c0		 test	 eax, eax
  0076a	74 22		 je	 SHORT $LN80@z900_kmctr
  0076c	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00774	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00784	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv383[rsp], rax
  0078c	eb 1f		 jmp	 SHORT $LN81@z900_kmctr
$LN80@z900_kmctr:
  0078e	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00796	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007a5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv383[rsp], rax
$LN81@z900_kmctr:
  007ad	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv383[rsp]
  007b5	48 83 c0 08	 add	 rax, 8
  007b9	48 63 8c 24 10
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  007c1	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007c9	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  007d1	eb 79		 jmp	 SHORT $LN35@z900_kmctr
$LN34@z900_kmctr:
  007d3	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007db	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007e1	83 e0 01	 and	 eax, 1
  007e4	85 c0		 test	 eax, eax
  007e6	74 22		 je	 SHORT $LN82@z900_kmctr
  007e8	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007f0	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00800	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
  00808	eb 1f		 jmp	 SHORT $LN83@z900_kmctr
$LN82@z900_kmctr:
  0080a	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00812	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0081a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00821	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
$LN83@z900_kmctr:
  00829	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv404[rsp]
  00831	48 83 c0 08	 add	 rax, 8
  00835	48 63 8c 24 10
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0083d	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00845	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN35@z900_kmctr:
  0084c	33 c0		 xor	 eax, eax
  0084e	85 c0		 test	 eax, eax
  00850	0f 85 ec fe ff
	ff		 jne	 $LN14@z900_kmctr

; 2672 :     if(likely(r1_is_not_r2))

  00856	83 7c 24 7c 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  0085b	74 0a		 je	 SHORT $LN84@z900_kmctr
  0085d	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv409[rsp], 1
  00865	eb 08		 jmp	 SHORT $LN85@z900_kmctr
$LN84@z900_kmctr:
  00867	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv409[rsp], 0
$LN85@z900_kmctr:
  0086f	83 7c 24 6c 00	 cmp	 DWORD PTR tv409[rsp], 0
  00874	0f 84 14 01 00
	00		 je	 $LN36@z900_kmctr
$LN17@z900_kmctr:

; 2673 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  0087a	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00882	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00888	83 e0 01	 and	 eax, 1
  0088b	85 c0		 test	 eax, eax
  0088d	74 7c		 je	 SHORT $LN37@z900_kmctr
  0088f	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00897	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0089d	83 e0 01	 and	 eax, 1
  008a0	85 c0		 test	 eax, eax
  008a2	74 22		 je	 SHORT $LN86@z900_kmctr
  008a4	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008ac	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008bc	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv433[rsp], rax
  008c4	eb 1f		 jmp	 SHORT $LN87@z900_kmctr
$LN86@z900_kmctr:
  008c6	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008ce	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008dd	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv433[rsp], rax
$LN87@z900_kmctr:
  008e5	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv433[rsp]
  008ed	48 83 c0 08	 add	 rax, 8
  008f1	48 63 8c 24 18
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  008f9	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00901	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00909	eb 79		 jmp	 SHORT $LN38@z900_kmctr
$LN37@z900_kmctr:
  0090b	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00913	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00919	83 e0 01	 and	 eax, 1
  0091c	85 c0		 test	 eax, eax
  0091e	74 22		 je	 SHORT $LN88@z900_kmctr
  00920	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00928	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00930	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00938	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv454[rsp], rax
  00940	eb 1f		 jmp	 SHORT $LN89@z900_kmctr
$LN88@z900_kmctr:
  00942	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0094a	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00952	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00959	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv454[rsp], rax
$LN89@z900_kmctr:
  00961	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv454[rsp]
  00969	48 83 c0 08	 add	 rax, 8
  0096d	48 63 8c 24 18
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00975	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0097d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN38@z900_kmctr:
  00984	33 c0		 xor	 eax, eax
  00986	85 c0		 test	 eax, eax
  00988	0f 85 ec fe ff
	ff		 jne	 $LN17@z900_kmctr
$LN36@z900_kmctr:
$LN20@z900_kmctr:

; 2674 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  0098e	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00996	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0099c	83 e0 01	 and	 eax, 1
  0099f	85 c0		 test	 eax, eax
  009a1	0f 84 89 00 00
	00		 je	 $LN39@z900_kmctr
  009a7	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009af	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  009b5	83 e0 01	 and	 eax, 1
  009b8	85 c0		 test	 eax, eax
  009ba	74 25		 je	 SHORT $LN90@z900_kmctr
  009bc	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009c3	ff c0		 inc	 eax
  009c5	48 98		 cdqe
  009c7	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009cf	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  009d7	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv483[rsp], rax
  009df	eb 22		 jmp	 SHORT $LN91@z900_kmctr
$LN90@z900_kmctr:
  009e1	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009e8	ff c0		 inc	 eax
  009ea	48 98		 cdqe
  009ec	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009f4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009fb	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv483[rsp], rax
$LN91@z900_kmctr:
  00a03	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv483[rsp]
  00a0b	48 83 e8 08	 sub	 rax, 8
  00a0f	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00a16	ff c1		 inc	 ecx
  00a18	48 63 c9	 movsxd	 rcx, ecx
  00a1b	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a23	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00a2b	e9 83 00 00 00	 jmp	 $LN40@z900_kmctr
$LN39@z900_kmctr:
  00a30	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a38	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a3e	83 e0 01	 and	 eax, 1
  00a41	85 c0		 test	 eax, eax
  00a43	74 25		 je	 SHORT $LN92@z900_kmctr
  00a45	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a4c	ff c0		 inc	 eax
  00a4e	48 98		 cdqe
  00a50	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a58	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a60	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv507[rsp], rax
  00a68	eb 22		 jmp	 SHORT $LN93@z900_kmctr
$LN92@z900_kmctr:
  00a6a	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a71	ff c0		 inc	 eax
  00a73	48 98		 cdqe
  00a75	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a7d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a84	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv507[rsp], rax
$LN93@z900_kmctr:
  00a8c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv507[rsp]
  00a94	48 83 e8 08	 sub	 rax, 8
  00a98	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00a9f	ff c1		 inc	 ecx
  00aa1	48 63 c9	 movsxd	 rcx, ecx
  00aa4	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00aac	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN40@z900_kmctr:
  00ab3	33 c0		 xor	 eax, eax
  00ab5	85 c0		 test	 eax, eax
  00ab7	0f 85 d1 fe ff
	ff		 jne	 $LN20@z900_kmctr

; 2675 :     if(likely(r1_is_not_r3 && r2_is_not_r3))

  00abd	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR r1_is_not_r3$[rsp], 0
  00ac5	74 14		 je	 SHORT $LN94@z900_kmctr
  00ac7	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR r2_is_not_r3$[rsp], 0
  00acf	74 0a		 je	 SHORT $LN94@z900_kmctr
  00ad1	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv518[rsp], 1
  00ad9	eb 08		 jmp	 SHORT $LN97@z900_kmctr
$LN94@z900_kmctr:
  00adb	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv518[rsp], 0
$LN97@z900_kmctr:
  00ae3	83 7c 24 70 00	 cmp	 DWORD PTR tv518[rsp], 0
  00ae8	0f 84 14 01 00
	00		 je	 $LN41@z900_kmctr
$LN23@z900_kmctr:

; 2676 :       SET_GR_A(r3, regs, GR_A(r3, regs) + 8);

  00aee	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00af6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00afc	83 e0 01	 and	 eax, 1
  00aff	85 c0		 test	 eax, eax
  00b01	74 7c		 je	 SHORT $LN42@z900_kmctr
  00b03	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b11	83 e0 01	 and	 eax, 1
  00b14	85 c0		 test	 eax, eax
  00b16	74 22		 je	 SHORT $LN98@z900_kmctr
  00b18	48 63 84 24 20
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00b20	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b28	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00b30	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv542[rsp], rax
  00b38	eb 1f		 jmp	 SHORT $LN99@z900_kmctr
$LN98@z900_kmctr:
  00b3a	48 63 84 24 20
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00b42	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b4a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00b51	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv542[rsp], rax
$LN99@z900_kmctr:
  00b59	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv542[rsp]
  00b61	48 83 c0 08	 add	 rax, 8
  00b65	48 63 8c 24 20
	03 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00b6d	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b75	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00b7d	eb 79		 jmp	 SHORT $LN43@z900_kmctr
$LN42@z900_kmctr:
  00b7f	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b87	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b8d	83 e0 01	 and	 eax, 1
  00b90	85 c0		 test	 eax, eax
  00b92	74 22		 je	 SHORT $LN100@z900_kmctr
  00b94	48 63 84 24 20
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00b9c	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ba4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00bac	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv563[rsp], rax
  00bb4	eb 1f		 jmp	 SHORT $LN101@z900_kmctr
$LN100@z900_kmctr:
  00bb6	48 63 84 24 20
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00bbe	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bc6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00bcd	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv563[rsp], rax
$LN101@z900_kmctr:
  00bd5	48 8b 84 24 f0
	00 00 00	 mov	 rax, QWORD PTR tv563[rsp]
  00bdd	48 83 c0 08	 add	 rax, 8
  00be1	48 63 8c 24 20
	03 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00be9	48 8b 94 24 28
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00bf1	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN43@z900_kmctr:
  00bf8	33 c0		 xor	 eax, eax
  00bfa	85 c0		 test	 eax, eax
  00bfc	0f 85 ec fe ff
	ff		 jne	 $LN23@z900_kmctr
$LN41@z900_kmctr:

; 2677 : 
; 2678 : #ifdef OPTION_KMCTR_DEBUG
; 2679 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2680 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2681 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2682 :     WRMSG(HHC90108, "D", r3, (regs)->GR(r3));
; 2683 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2684 : 
; 2685 :     /* check for end of data */
; 2686 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00c02	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c0a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00c10	83 e0 01	 and	 eax, 1
  00c13	85 c0		 test	 eax, eax
  00c15	74 25		 je	 SHORT $LN102@z900_kmctr
  00c17	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00c1e	ff c0		 inc	 eax
  00c20	48 98		 cdqe
  00c22	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c2a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00c32	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv583[rsp], rax
  00c3a	eb 22		 jmp	 SHORT $LN103@z900_kmctr
$LN102@z900_kmctr:
  00c3c	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00c43	ff c0		 inc	 eax
  00c45	48 98		 cdqe
  00c47	48 8b 8c 24 28
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c4f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00c56	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv583[rsp], rax
$LN103@z900_kmctr:
  00c5e	48 83 bc 24 f8
	00 00 00 00	 cmp	 QWORD PTR tv583[rsp], 0
  00c67	75 0a		 jne	 SHORT $LN104@z900_kmctr
  00c69	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv585[rsp], 1
  00c71	eb 08		 jmp	 SHORT $LN105@z900_kmctr
$LN104@z900_kmctr:
  00c73	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv585[rsp], 0
$LN105@z900_kmctr:
  00c7b	83 7c 24 74 00	 cmp	 DWORD PTR tv585[rsp], 0
  00c80	74 0a		 je	 SHORT $LN110@z900_kmctr
  00c82	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv606[rsp], 1
  00c8a	eb 08		 jmp	 SHORT $LN111@z900_kmctr
$LN110@z900_kmctr:
  00c8c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv606[rsp], 0
$LN111@z900_kmctr:
  00c94	83 7c 24 78 00	 cmp	 DWORD PTR tv606[rsp], 0
  00c99	74 0e		 je	 SHORT $LN44@z900_kmctr

; 2687 :     {
; 2688 :       regs->psw.cc = 0;

  00c9b	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ca3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2689 :       return;

  00ca7	eb 11		 jmp	 SHORT $LN1@z900_kmctr
$LN44@z900_kmctr:

; 2690 :     }
; 2691 :   }

  00ca9	e9 70 f7 ff ff	 jmp	 $LN4@z900_kmctr
$LN5@z900_kmctr:

; 2692 : 
; 2693 :   /* CPU-determined amount of data processed */
; 2694 :   regs->psw.cc = 3;

  00cae	48 8b 84 24 28
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cb6	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmctr:

; 2695 : }

  00cba	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00cc2	48 33 cc	 xor	 rcx, rsp
  00cc5	e8 00 00 00 00	 call	 __security_check_cookie
  00cca	48 81 c4 08 03
	00 00		 add	 rsp, 776		; 00000308H
  00cd1	c3		 ret	 0
z900_kmctr_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
crypted$ = 52
tv135 = 56
tv157 = 60
tv178 = 64
tv234 = 68
tv420 = 72
tv540 = 76
tv561 = 80
r1_is_not_r2$ = 84
tv80 = 88
tv155 = 96
tv197 = 104
tv215 = 112
tv253 = 120
tv315 = 128
tv366 = 136
tv394 = 144
tv415 = 152
tv444 = 160
tv465 = 168
tv494 = 176
tv518 = 184
tv538 = 192
context1$ = 208
context2$ = 352
context3$ = 496
message_block$ = 640
ocv$ = 648
tcv$ = 656
parameter_block$ = 664
__$ArrayPad$ = 696
r1$ = 720
r2$ = 728
regs$ = 736
z900_kmc_prng PROC

; 2393 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 b8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2394 :   des_context context1;
; 2395 :   des_context context2;
; 2396 :   des_context context3;
; 2397 :   int i;
; 2398 :   int crypted;
; 2399 :   BYTE message_block[8];
; 2400 :   BYTE parameter_block[32];
; 2401 :   BYTE ocv[8];
; 2402 :   BYTE tcv[8];
; 2403 :   int r1_is_not_r2;
; 2404 : 
; 2405 :   /* Check special conditions */
; 2406 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 22		 je	 SHORT $LN31@z900_kmc_p
  0003b	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00042	ff c0		 inc	 eax
  00044	48 98		 cdqe
  00046	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00056	48 89 44 24 58	 mov	 QWORD PTR tv80[rsp], rax
  0005b	eb 1f		 jmp	 SHORT $LN32@z900_kmc_p
$LN31@z900_kmc_p:
  0005d	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00064	ff c0		 inc	 eax
  00066	48 98		 cdqe
  00068	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	48 89 44 24 58	 mov	 QWORD PTR tv80[rsp], rax
$LN32@z900_kmc_p:
  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b 44 24 58	 mov	 rax, QWORD PTR tv80[rsp]
  00083	b9 08 00 00 00	 mov	 ecx, 8
  00088	48 f7 f1	 div	 rcx
  0008b	48 8b c2	 mov	 rax, rdx
  0008e	48 85 c0	 test	 rax, rax
  00091	74 0a		 je	 SHORT $LN37@z900_kmc_p
  00093	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0009b	eb 08		 jmp	 SHORT $LN38@z900_kmc_p
$LN37@z900_kmc_p:
  0009d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN38@z900_kmc_p:
  000a5	83 7c 24 38 00	 cmp	 DWORD PTR tv135[rsp], 0
  000aa	74 13		 je	 SHORT $LN20@z900_kmc_p

; 2407 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ac	ba 06 00 00 00	 mov	 edx, 6
  000b1	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_kmc_p:

; 2408 : 
; 2409 :   /* Return with cc 0 on zero length */
; 2410 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000bf	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 22		 je	 SHORT $LN39@z900_kmc_p
  000d4	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000db	ff c0		 inc	 eax
  000dd	48 98		 cdqe
  000df	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000ef	48 89 44 24 60	 mov	 QWORD PTR tv155[rsp], rax
  000f4	eb 1f		 jmp	 SHORT $LN40@z900_kmc_p
$LN39@z900_kmc_p:
  000f6	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000fd	ff c0		 inc	 eax
  000ff	48 98		 cdqe
  00101	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00110	48 89 44 24 60	 mov	 QWORD PTR tv155[rsp], rax
$LN40@z900_kmc_p:
  00115	48 83 7c 24 60
	00		 cmp	 QWORD PTR tv155[rsp], 0
  0011b	75 0a		 jne	 SHORT $LN41@z900_kmc_p
  0011d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  00125	eb 08		 jmp	 SHORT $LN42@z900_kmc_p
$LN41@z900_kmc_p:
  00127	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN42@z900_kmc_p:
  0012f	83 7c 24 3c 00	 cmp	 DWORD PTR tv157[rsp], 0
  00134	74 0a		 je	 SHORT $LN47@z900_kmc_p
  00136	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  0013e	eb 08		 jmp	 SHORT $LN48@z900_kmc_p
$LN47@z900_kmc_p:
  00140	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN48@z900_kmc_p:
  00148	83 7c 24 40 00	 cmp	 DWORD PTR tv178[rsp], 0
  0014d	74 11		 je	 SHORT $LN21@z900_kmc_p

; 2411 :   {
; 2412 :     regs->psw.cc = 0;

  0014f	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2413 :     return;

  0015b	e9 8a 09 00 00	 jmp	 $LN1@z900_kmc_p
$LN21@z900_kmc_p:

; 2414 :   }
; 2415 : 
; 2416 :   /* Test writeability output chaining value */
; 2417 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  00160	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00168	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0016e	83 e0 01	 and	 eax, 1
  00171	85 c0		 test	 eax, eax
  00173	74 20		 je	 SHORT $LN49@z900_kmc_p
  00175	b8 08 00 00 00	 mov	 eax, 8
  0017a	48 6b c0 01	 imul	 rax, rax, 1
  0017e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00186	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0018e	48 89 44 24 68	 mov	 QWORD PTR tv197[rsp], rax
  00193	eb 1d		 jmp	 SHORT $LN50@z900_kmc_p
$LN49@z900_kmc_p:
  00195	b8 08 00 00 00	 mov	 eax, 8
  0019a	48 6b c0 01	 imul	 rax, rax, 1
  0019e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ad	48 89 44 24 68	 mov	 QWORD PTR tv197[rsp], rax
$LN50@z900_kmc_p:
  001b2	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ba	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001c1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv197[rsp]
  001c6	48 23 c8	 and	 rcx, rax
  001c9	48 8b c1	 mov	 rax, rcx
  001cc	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001d9	41 b9 02 00 00
	00		 mov	 r9d, 2
  001df	41 b8 07 00 00
	00		 mov	 r8d, 7
  001e5	ba 01 00 00 00	 mov	 edx, 1
  001ea	48 8b c8	 mov	 rcx, rax
  001ed	e8 00 00 00 00	 call	 z900_validate_operand

; 2418 : 
; 2419 :   /* Fetch the parameter block */
; 2420 :   ARCH_DEP(vfetchc)(parameter_block, 31, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001f2	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fa	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	74 20		 je	 SHORT $LN51@z900_kmc_p
  00207	b8 08 00 00 00	 mov	 eax, 8
  0020c	48 6b c0 01	 imul	 rax, rax, 1
  00210	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00220	48 89 44 24 70	 mov	 QWORD PTR tv215[rsp], rax
  00225	eb 1d		 jmp	 SHORT $LN52@z900_kmc_p
$LN51@z900_kmc_p:
  00227	b8 08 00 00 00	 mov	 eax, 8
  0022c	48 6b c0 01	 imul	 rax, rax, 1
  00230	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00238	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0023f	48 89 44 24 70	 mov	 QWORD PTR tv215[rsp], rax
$LN52@z900_kmc_p:
  00244	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00253	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv215[rsp]
  00258	48 23 c8	 and	 rcx, rax
  0025b	48 8b c1	 mov	 rax, rcx
  0025e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00266	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0026b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00271	4c 8b c0	 mov	 r8, rax
  00274	b2 1f		 mov	 dl, 31
  00276	48 8d 8c 24 98
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0027e	e8 00 00 00 00	 call	 z900_vfetchc

; 2421 : 
; 2422 : #ifdef OPTION_KMC_DEBUG
; 2423 :   LOGBYTE("icv   :", parameter_block, 8);
; 2424 :   LOGBYTE("k1    :", &parameter_block[8], 8);
; 2425 :   LOGBYTE("k2    :", &parameter_block[16], 8);
; 2426 :   LOGBYTE("k3    :", &parameter_block[24], 8);
; 2427 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2428 : 
; 2429 :   /* Set the cryptographic keys */
; 2430 :   des_set_key(&context1, &parameter_block[8]);

  00283	b8 01 00 00 00	 mov	 eax, 1
  00288	48 6b c0 08	 imul	 rax, rax, 8
  0028c	48 8d 84 04 98
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00294	48 8b d0	 mov	 rdx, rax
  00297	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0029f	e8 00 00 00 00	 call	 des_set_key

; 2431 :   des_set_key(&context2, &parameter_block[16]);

  002a4	b8 01 00 00 00	 mov	 eax, 1
  002a9	48 6b c0 10	 imul	 rax, rax, 16
  002ad	48 8d 84 04 98
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002b5	48 8b d0	 mov	 rdx, rax
  002b8	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002c0	e8 00 00 00 00	 call	 des_set_key

; 2432 :   des_set_key(&context3, &parameter_block[24]);

  002c5	b8 01 00 00 00	 mov	 eax, 1
  002ca	48 6b c0 18	 imul	 rax, rax, 24
  002ce	48 8d 84 04 98
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002d6	48 8b d0	 mov	 rdx, rax
  002d9	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  002e1	e8 00 00 00 00	 call	 des_set_key

; 2433 : 
; 2434 :   /* Try to process the CPU-determined amount of data */
; 2435 :   r1_is_not_r2 = r1 != r2;

  002e6	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002ed	39 84 24 d0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002f4	74 0a		 je	 SHORT $LN53@z900_kmc_p
  002f6	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv234[rsp], 1
  002fe	eb 08		 jmp	 SHORT $LN54@z900_kmc_p
$LN53@z900_kmc_p:
  00300	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
$LN54@z900_kmc_p:
  00308	8b 44 24 44	 mov	 eax, DWORD PTR tv234[rsp]
  0030c	89 44 24 54	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2436 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  00310	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00318	eb 0b		 jmp	 SHORT $LN4@z900_kmc_p
$LN2@z900_kmc_p:
  0031a	8b 44 24 34	 mov	 eax, DWORD PTR crypted$[rsp]
  0031e	83 c0 08	 add	 eax, 8
  00321	89 44 24 34	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@z900_kmc_p:
  00325	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  0032d	0f 8d ab 07 00
	00		 jge	 $LN3@z900_kmc_p

; 2437 :   {
; 2438 :     /* Fetch a block of data */
; 2439 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00333	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0033b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00341	83 e0 01	 and	 eax, 1
  00344	85 c0		 test	 eax, eax
  00346	74 1f		 je	 SHORT $LN55@z900_kmc_p
  00348	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00350	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00358	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00360	48 89 44 24 78	 mov	 QWORD PTR tv253[rsp], rax
  00365	eb 1c		 jmp	 SHORT $LN56@z900_kmc_p
$LN55@z900_kmc_p:
  00367	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0036f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00377	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0037e	48 89 44 24 78	 mov	 QWORD PTR tv253[rsp], rax
$LN56@z900_kmc_p:
  00383	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0038b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00392	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv253[rsp]
  00397	48 23 c8	 and	 rcx, rax
  0039a	48 8b c1	 mov	 rax, rcx
  0039d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003aa	44 8b 8c 24 d8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  003b2	4c 8b c0	 mov	 r8, rax
  003b5	b2 07		 mov	 dl, 7
  003b7	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  003bf	e8 00 00 00 00	 call	 z900_vfetchc

; 2440 : 
; 2441 : #ifdef OPTION_KMC_DEBUG
; 2442 :     LOGBYTE("input :", message_block, 8);
; 2443 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2444 : 
; 2445 :     /* Do the job */
; 2446 :     des_encrypt(&context1, message_block, message_block);

  003c4	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003cc	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003d4	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003dc	e8 00 00 00 00	 call	 des_encrypt

; 2447 :     des_decrypt(&context2, message_block, message_block);

  003e1	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003e9	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003f1	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  003f9	e8 00 00 00 00	 call	 des_decrypt

; 2448 :     des_encrypt(&context3, message_block, message_block);

  003fe	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00406	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0040e	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00416	e8 00 00 00 00	 call	 des_encrypt

; 2449 : 
; 2450 :     /* Save the temporary cv */
; 2451 :     memcpy(tcv, message_block, 8);

  0041b	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00423	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR tcv$[rsp], rax

; 2452 : 
; 2453 :     /* XOR */
; 2454 :     for(i = 0; i < 8; i++)

  0042b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00433	eb 0a		 jmp	 SHORT $LN7@z900_kmc_p
$LN5@z900_kmc_p:
  00435	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00439	ff c0		 inc	 eax
  0043b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_kmc_p:
  0043f	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00444	7d 2a		 jge	 SHORT $LN6@z900_kmc_p

; 2455 :       message_block[i] ^= parameter_block[i];

  00446	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0044b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00450	0f b6 8c 0c 98
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00458	0f b6 84 04 80
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00460	33 c1		 xor	 eax, ecx
  00462	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00467	88 84 0c 80 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0046e	eb c5		 jmp	 SHORT $LN5@z900_kmc_p
$LN6@z900_kmc_p:

; 2456 : 
; 2457 :     des_encrypt(&context1, message_block, message_block);

  00470	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00478	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00480	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00488	e8 00 00 00 00	 call	 des_encrypt

; 2458 :     des_decrypt(&context2, message_block, message_block);

  0048d	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00495	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0049d	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  004a5	e8 00 00 00 00	 call	 des_decrypt

; 2459 :     des_encrypt(&context3, message_block, message_block);

  004aa	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  004b2	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004ba	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  004c2	e8 00 00 00 00	 call	 des_encrypt

; 2460 : 
; 2461 :     /* Store the output */
; 2462 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  004c7	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004cf	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004d5	83 e0 01	 and	 eax, 1
  004d8	85 c0		 test	 eax, eax
  004da	74 22		 je	 SHORT $LN57@z900_kmc_p
  004dc	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004e4	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ec	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  004f4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv315[rsp], rax
  004fc	eb 1f		 jmp	 SHORT $LN58@z900_kmc_p
$LN57@z900_kmc_p:
  004fe	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00506	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00515	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv315[rsp], rax
$LN58@z900_kmc_p:
  0051d	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00525	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0052c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv315[rsp]
  00534	48 23 c8	 and	 rcx, rax
  00537	48 8b c1	 mov	 rax, rcx
  0053a	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00542	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00547	44 8b 8c 24 d0
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0054f	4c 8b c0	 mov	 r8, rax
  00552	b2 07		 mov	 dl, 7
  00554	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0055c	e8 00 00 00 00	 call	 z900_vstorec

; 2463 : 
; 2464 : #ifdef OPTION_KMC_DEBUG
; 2465 :     LOGBYTE("output:", message_block, 8);
; 2466 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2467 : 
; 2468 :     /* XOR */
; 2469 :     for(i = 0; i < 8; i++)

  00561	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00569	eb 0a		 jmp	 SHORT $LN10@z900_kmc_p
$LN8@z900_kmc_p:
  0056b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0056f	ff c0		 inc	 eax
  00571	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_kmc_p:
  00575	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0057a	7d 2a		 jge	 SHORT $LN9@z900_kmc_p

; 2470 :       message_block[i] ^= tcv[i];

  0057c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00581	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00586	0f b6 8c 0c 90
	02 00 00	 movzx	 ecx, BYTE PTR tcv$[rsp+rcx]
  0058e	0f b6 84 04 80
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00596	33 c1		 xor	 eax, ecx
  00598	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0059d	88 84 0c 80 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  005a4	eb c5		 jmp	 SHORT $LN8@z900_kmc_p
$LN9@z900_kmc_p:

; 2471 : 
; 2472 :     des_encrypt(&context1, message_block, message_block);

  005a6	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  005ae	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005b6	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005be	e8 00 00 00 00	 call	 des_encrypt

; 2473 :     des_decrypt(&context2, message_block, message_block);

  005c3	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  005cb	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005d3	48 8d 8c 24 60
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  005db	e8 00 00 00 00	 call	 des_decrypt

; 2474 :     des_encrypt(&context3, message_block, message_block);

  005e0	4c 8d 84 24 80
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  005e8	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005f0	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  005f8	e8 00 00 00 00	 call	 des_encrypt

; 2475 : 
; 2476 :     /* Save the ocv */
; 2477 :     memcpy(ocv, message_block, 8);

  005fd	48 8b 84 24 80
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00605	48 89 84 24 88
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2478 : 
; 2479 :     /* Store the output chaining value */
; 2480 :     ARCH_DEP(vstorec)(ocv, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0060d	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00615	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0061b	83 e0 01	 and	 eax, 1
  0061e	85 c0		 test	 eax, eax
  00620	74 23		 je	 SHORT $LN59@z900_kmc_p
  00622	b8 08 00 00 00	 mov	 eax, 8
  00627	48 6b c0 01	 imul	 rax, rax, 1
  0062b	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00633	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0063b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv366[rsp], rax
  00643	eb 20		 jmp	 SHORT $LN60@z900_kmc_p
$LN59@z900_kmc_p:
  00645	b8 08 00 00 00	 mov	 eax, 8
  0064a	48 6b c0 01	 imul	 rax, rax, 1
  0064e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00656	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0065d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv366[rsp], rax
$LN60@z900_kmc_p:
  00665	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0066d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00674	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv366[rsp]
  0067c	48 23 c8	 and	 rcx, rax
  0067f	48 8b c1	 mov	 rax, rcx
  00682	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0068f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00695	4c 8b c0	 mov	 r8, rax
  00698	b2 07		 mov	 dl, 7
  0069a	48 8d 8c 24 88
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  006a2	e8 00 00 00 00	 call	 z900_vstorec
$LN13@z900_kmc_p:

; 2481 : 
; 2482 : #ifdef OPTION_KMC_DEBUG
; 2483 :     LOGBYTE("ocv   :", ocv, 8);
; 2484 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2485 : 
; 2486 :     /* Update the registers */
; 2487 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  006a7	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006af	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006b5	83 e0 01	 and	 eax, 1
  006b8	85 c0		 test	 eax, eax
  006ba	74 7c		 je	 SHORT $LN22@z900_kmc_p
  006bc	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006c4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006ca	83 e0 01	 and	 eax, 1
  006cd	85 c0		 test	 eax, eax
  006cf	74 22		 je	 SHORT $LN61@z900_kmc_p
  006d1	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006d9	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  006e9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv394[rsp], rax
  006f1	eb 1f		 jmp	 SHORT $LN62@z900_kmc_p
$LN61@z900_kmc_p:
  006f3	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006fb	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00703	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0070a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv394[rsp], rax
$LN62@z900_kmc_p:
  00712	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv394[rsp]
  0071a	48 83 c0 08	 add	 rax, 8
  0071e	48 63 8c 24 d0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00726	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0072e	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00736	eb 79		 jmp	 SHORT $LN23@z900_kmc_p
$LN22@z900_kmc_p:
  00738	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00740	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00746	83 e0 01	 and	 eax, 1
  00749	85 c0		 test	 eax, eax
  0074b	74 22		 je	 SHORT $LN63@z900_kmc_p
  0074d	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00755	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00765	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv415[rsp], rax
  0076d	eb 1f		 jmp	 SHORT $LN64@z900_kmc_p
$LN63@z900_kmc_p:
  0076f	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00777	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0077f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00786	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv415[rsp], rax
$LN64@z900_kmc_p:
  0078e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv415[rsp]
  00796	48 83 c0 08	 add	 rax, 8
  0079a	48 63 8c 24 d0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  007a2	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007aa	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN23@z900_kmc_p:
  007b1	33 c0		 xor	 eax, eax
  007b3	85 c0		 test	 eax, eax
  007b5	0f 85 ec fe ff
	ff		 jne	 $LN13@z900_kmc_p

; 2488 :     if(likely(r1_is_not_r2))

  007bb	83 7c 24 54 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  007c0	74 0a		 je	 SHORT $LN65@z900_kmc_p
  007c2	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv420[rsp], 1
  007ca	eb 08		 jmp	 SHORT $LN66@z900_kmc_p
$LN65@z900_kmc_p:
  007cc	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv420[rsp], 0
$LN66@z900_kmc_p:
  007d4	83 7c 24 48 00	 cmp	 DWORD PTR tv420[rsp], 0
  007d9	0f 84 14 01 00
	00		 je	 $LN24@z900_kmc_p
$LN16@z900_kmc_p:

; 2489 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  007df	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007ed	83 e0 01	 and	 eax, 1
  007f0	85 c0		 test	 eax, eax
  007f2	74 7c		 je	 SHORT $LN25@z900_kmc_p
  007f4	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007fc	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00802	83 e0 01	 and	 eax, 1
  00805	85 c0		 test	 eax, eax
  00807	74 22		 je	 SHORT $LN67@z900_kmc_p
  00809	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00811	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00819	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00821	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv444[rsp], rax
  00829	eb 1f		 jmp	 SHORT $LN68@z900_kmc_p
$LN67@z900_kmc_p:
  0082b	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00833	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0083b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00842	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv444[rsp], rax
$LN68@z900_kmc_p:
  0084a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv444[rsp]
  00852	48 83 c0 08	 add	 rax, 8
  00856	48 63 8c 24 d8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0085e	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00866	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  0086e	eb 79		 jmp	 SHORT $LN26@z900_kmc_p
$LN25@z900_kmc_p:
  00870	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00878	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0087e	83 e0 01	 and	 eax, 1
  00881	85 c0		 test	 eax, eax
  00883	74 22		 je	 SHORT $LN69@z900_kmc_p
  00885	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0088d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00895	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0089d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv465[rsp], rax
  008a5	eb 1f		 jmp	 SHORT $LN70@z900_kmc_p
$LN69@z900_kmc_p:
  008a7	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008af	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008be	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv465[rsp], rax
$LN70@z900_kmc_p:
  008c6	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv465[rsp]
  008ce	48 83 c0 08	 add	 rax, 8
  008d2	48 63 8c 24 d8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  008da	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008e2	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN26@z900_kmc_p:
  008e9	33 c0		 xor	 eax, eax
  008eb	85 c0		 test	 eax, eax
  008ed	0f 85 ec fe ff
	ff		 jne	 $LN16@z900_kmc_p
$LN24@z900_kmc_p:
$LN19@z900_kmc_p:

; 2490 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  008f3	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008fb	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00901	83 e0 01	 and	 eax, 1
  00904	85 c0		 test	 eax, eax
  00906	0f 84 89 00 00
	00		 je	 $LN27@z900_kmc_p
  0090c	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00914	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0091a	83 e0 01	 and	 eax, 1
  0091d	85 c0		 test	 eax, eax
  0091f	74 25		 je	 SHORT $LN71@z900_kmc_p
  00921	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00928	ff c0		 inc	 eax
  0092a	48 98		 cdqe
  0092c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00934	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0093c	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv494[rsp], rax
  00944	eb 22		 jmp	 SHORT $LN72@z900_kmc_p
$LN71@z900_kmc_p:
  00946	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0094d	ff c0		 inc	 eax
  0094f	48 98		 cdqe
  00951	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00959	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00960	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv494[rsp], rax
$LN72@z900_kmc_p:
  00968	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv494[rsp]
  00970	48 83 e8 08	 sub	 rax, 8
  00974	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0097b	ff c1		 inc	 ecx
  0097d	48 63 c9	 movsxd	 rcx, ecx
  00980	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00988	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00990	e9 83 00 00 00	 jmp	 $LN28@z900_kmc_p
$LN27@z900_kmc_p:
  00995	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0099d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  009a3	83 e0 01	 and	 eax, 1
  009a6	85 c0		 test	 eax, eax
  009a8	74 25		 je	 SHORT $LN73@z900_kmc_p
  009aa	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009b1	ff c0		 inc	 eax
  009b3	48 98		 cdqe
  009b5	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009bd	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  009c5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv518[rsp], rax
  009cd	eb 22		 jmp	 SHORT $LN74@z900_kmc_p
$LN73@z900_kmc_p:
  009cf	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009d6	ff c0		 inc	 eax
  009d8	48 98		 cdqe
  009da	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009e2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009e9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv518[rsp], rax
$LN74@z900_kmc_p:
  009f1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv518[rsp]
  009f9	48 83 e8 08	 sub	 rax, 8
  009fd	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00a04	ff c1		 inc	 ecx
  00a06	48 63 c9	 movsxd	 rcx, ecx
  00a09	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a11	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN28@z900_kmc_p:
  00a18	33 c0		 xor	 eax, eax
  00a1a	85 c0		 test	 eax, eax
  00a1c	0f 85 d1 fe ff
	ff		 jne	 $LN19@z900_kmc_p

; 2491 : 
; 2492 : #ifdef OPTION_KMC_DEBUG
; 2493 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2494 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2495 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2496 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2497 : 
; 2498 :     /* check for end of data */
; 2499 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00a22	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a2a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a30	83 e0 01	 and	 eax, 1
  00a33	85 c0		 test	 eax, eax
  00a35	74 25		 je	 SHORT $LN75@z900_kmc_p
  00a37	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a3e	ff c0		 inc	 eax
  00a40	48 98		 cdqe
  00a42	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a4a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a52	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv538[rsp], rax
  00a5a	eb 22		 jmp	 SHORT $LN76@z900_kmc_p
$LN75@z900_kmc_p:
  00a5c	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a63	ff c0		 inc	 eax
  00a65	48 98		 cdqe
  00a67	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a6f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a76	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv538[rsp], rax
$LN76@z900_kmc_p:
  00a7e	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR tv538[rsp], 0
  00a87	75 0a		 jne	 SHORT $LN77@z900_kmc_p
  00a89	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv540[rsp], 1
  00a91	eb 08		 jmp	 SHORT $LN78@z900_kmc_p
$LN77@z900_kmc_p:
  00a93	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv540[rsp], 0
$LN78@z900_kmc_p:
  00a9b	83 7c 24 4c 00	 cmp	 DWORD PTR tv540[rsp], 0
  00aa0	74 0a		 je	 SHORT $LN83@z900_kmc_p
  00aa2	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv561[rsp], 1
  00aaa	eb 08		 jmp	 SHORT $LN84@z900_kmc_p
$LN83@z900_kmc_p:
  00aac	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv561[rsp], 0
$LN84@z900_kmc_p:
  00ab4	83 7c 24 50 00	 cmp	 DWORD PTR tv561[rsp], 0
  00ab9	74 0e		 je	 SHORT $LN29@z900_kmc_p

; 2500 :     {
; 2501 :       regs->psw.cc = 0;

  00abb	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ac3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2502 :       return;

  00ac7	eb 21		 jmp	 SHORT $LN1@z900_kmc_p
$LN29@z900_kmc_p:

; 2503 :     }
; 2504 : 
; 2505 :     /* Set cv for next 8 bytes */
; 2506 :     memcpy(parameter_block, ocv, 8);

  00ac9	48 8b 84 24 88
	02 00 00	 mov	 rax, QWORD PTR ocv$[rsp]
  00ad1	48 89 84 24 98
	02 00 00	 mov	 QWORD PTR parameter_block$[rsp], rax

; 2507 :   }

  00ad9	e9 3c f8 ff ff	 jmp	 $LN2@z900_kmc_p
$LN3@z900_kmc_p:

; 2508 : 
; 2509 :   /* CPU-determined amount of data processed */
; 2510 :   regs->psw.cc = 3;

  00ade	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ae6	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmc_p:

; 2511 : }

  00aea	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00af2	48 33 cc	 xor	 rcx, rsp
  00af5	e8 00 00 00 00	 call	 __security_check_cookie
  00afa	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  00b01	c3		 ret	 0
z900_kmc_prng ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv135 = 64
tv157 = 68
tv178 = 72
tv193 = 76
wrap$ = 80
tv262 = 84
tv264 = 88
tv430 = 92
tv550 = 96
tv571 = 100
tfc$ = 104
modifier_bit$ = 108
r1_is_not_r2$ = 112
tv80 = 120
tv155 = 128
tv216 = 136
tv234 = 144
tv283 = 152
tv356 = 160
tv376 = 168
tv404 = 176
tv425 = 184
tv454 = 192
tv475 = 200
tv504 = 208
tv528 = 216
tv548 = 224
context$ = 240
message_block$ = 736
ocv$ = 752
parameter_block$ = 768
__$ArrayPad$ = 848
r1$ = 896
r2$ = 904
regs$ = 912
z900_kmc_aes PROC

; 2252 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2253 :   rijndael_ctx context;
; 2254 :   int crypted;
; 2255 :   int i;
; 2256 :   int keylen;
; 2257 :   BYTE message_block[16];
; 2258 :   int modifier_bit;
; 2259 :   BYTE ocv[16];
; 2260 :   BYTE parameter_block[80];
; 2261 :   int parameter_blocklen;
; 2262 :   int r1_is_not_r2;
; 2263 :   int tfc;
; 2264 :   int wrap;
; 2265 : 
; 2266 :   /* Check special conditions */
; 2267 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00028	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00030	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00036	83 e0 01	 and	 eax, 1
  00039	85 c0		 test	 eax, eax
  0003b	74 22		 je	 SHORT $LN35@z900_kmc_a
  0003d	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00044	ff c0		 inc	 eax
  00046	48 98		 cdqe
  00048	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00050	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00058	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
  0005d	eb 1f		 jmp	 SHORT $LN36@z900_kmc_a
$LN35@z900_kmc_a:
  0005f	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00066	ff c0		 inc	 eax
  00068	48 98		 cdqe
  0006a	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00072	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00079	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
$LN36@z900_kmc_a:
  0007e	33 d2		 xor	 edx, edx
  00080	48 8b 44 24 78	 mov	 rax, QWORD PTR tv80[rsp]
  00085	b9 10 00 00 00	 mov	 ecx, 16
  0008a	48 f7 f1	 div	 rcx
  0008d	48 8b c2	 mov	 rax, rdx
  00090	48 85 c0	 test	 rax, rax
  00093	74 0a		 je	 SHORT $LN41@z900_kmc_a
  00095	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0009d	eb 08		 jmp	 SHORT $LN42@z900_kmc_a
$LN41@z900_kmc_a:
  0009f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN42@z900_kmc_a:
  000a7	83 7c 24 40 00	 cmp	 DWORD PTR tv135[rsp], 0
  000ac	74 13		 je	 SHORT $LN20@z900_kmc_a

; 2268 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ae	ba 06 00 00 00	 mov	 edx, 6
  000b3	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_kmc_a:

; 2269 : 
; 2270 :   /* Return with cc 0 on zero length */
; 2271 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000c1	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000cf	83 e0 01	 and	 eax, 1
  000d2	85 c0		 test	 eax, eax
  000d4	74 25		 je	 SHORT $LN43@z900_kmc_a
  000d6	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000dd	ff c0		 inc	 eax
  000df	48 98		 cdqe
  000e1	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f1	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  000f9	eb 22		 jmp	 SHORT $LN44@z900_kmc_a
$LN43@z900_kmc_a:
  000fb	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00102	ff c0		 inc	 eax
  00104	48 98		 cdqe
  00106	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00115	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN44@z900_kmc_a:
  0011d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv155[rsp], 0
  00126	75 0a		 jne	 SHORT $LN45@z900_kmc_a
  00128	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  00130	eb 08		 jmp	 SHORT $LN46@z900_kmc_a
$LN45@z900_kmc_a:
  00132	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN46@z900_kmc_a:
  0013a	83 7c 24 44 00	 cmp	 DWORD PTR tv157[rsp], 0
  0013f	74 0a		 je	 SHORT $LN51@z900_kmc_a
  00141	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00149	eb 08		 jmp	 SHORT $LN52@z900_kmc_a
$LN51@z900_kmc_a:
  0014b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN52@z900_kmc_a:
  00153	83 7c 24 48 00	 cmp	 DWORD PTR tv178[rsp], 0
  00158	74 11		 je	 SHORT $LN21@z900_kmc_a

; 2272 :   {
; 2273 :     regs->psw.cc = 0;

  0015a	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00162	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2274 :     return;

  00166	e9 d8 09 00 00	 jmp	 $LN1@z900_kmc_a
$LN21@z900_kmc_a:

; 2275 :   }
; 2276 : 
; 2277 :   /* Initialize values */
; 2278 :   tfc = GR0_tfc(regs);

  0016b	b8 08 00 00 00	 mov	 eax, 8
  00170	48 6b c0 00	 imul	 rax, rax, 0
  00174	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017c	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00183	83 e0 7f	 and	 eax, 127		; 0000007fH
  00186	83 e0 77	 and	 eax, 119		; 00000077H
  00189	89 44 24 68	 mov	 DWORD PTR tfc$[rsp], eax

; 2279 :   wrap = GR0_wrap(regs);

  0018d	b8 08 00 00 00	 mov	 eax, 8
  00192	48 6b c0 00	 imul	 rax, rax, 0
  00196	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a5	83 e0 08	 and	 eax, 8
  001a8	85 c0		 test	 eax, eax
  001aa	74 0a		 je	 SHORT $LN53@z900_kmc_a
  001ac	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001b4	eb 08		 jmp	 SHORT $LN54@z900_kmc_a
$LN53@z900_kmc_a:
  001b6	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN54@z900_kmc_a:
  001be	8b 44 24 4c	 mov	 eax, DWORD PTR tv193[rsp]
  001c2	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 2280 :   keylen = (tfc - 17) * 8 + 8;

  001c6	8b 44 24 68	 mov	 eax, DWORD PTR tfc$[rsp]
  001ca	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  001d1	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 2281 :   parameter_blocklen = keylen + 16;

  001d5	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  001d9	83 c0 10	 add	 eax, 16
  001dc	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2282 :   if(wrap)

  001e0	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001e5	74 0b		 je	 SHORT $LN22@z900_kmc_a

; 2283 :     parameter_blocklen += 32;

  001e7	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001eb	83 c0 20	 add	 eax, 32			; 00000020H
  001ee	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN22@z900_kmc_a:

; 2284 : 
; 2285 :   /* Test writeability output chaining value */
; 2286 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  001f2	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fa	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00200	83 e0 01	 and	 eax, 1
  00203	85 c0		 test	 eax, eax
  00205	74 23		 je	 SHORT $LN55@z900_kmc_a
  00207	b8 08 00 00 00	 mov	 eax, 8
  0020c	48 6b c0 01	 imul	 rax, rax, 1
  00210	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00218	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00220	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv216[rsp], rax
  00228	eb 20		 jmp	 SHORT $LN56@z900_kmc_a
$LN55@z900_kmc_a:
  0022a	b8 08 00 00 00	 mov	 eax, 8
  0022f	48 6b c0 01	 imul	 rax, rax, 1
  00233	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023b	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00242	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv216[rsp], rax
$LN56@z900_kmc_a:
  0024a	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00252	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00259	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv216[rsp]
  00261	48 23 c8	 and	 rcx, rax
  00264	48 8b c1	 mov	 rax, rcx
  00267	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00274	41 b9 02 00 00
	00		 mov	 r9d, 2
  0027a	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00280	ba 01 00 00 00	 mov	 edx, 1
  00285	48 8b c8	 mov	 rcx, rax
  00288	e8 00 00 00 00	 call	 z900_validate_operand

; 2287 : 
; 2288 :   /* Fetch the parameter block */
; 2289 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0028d	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00295	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0029b	83 e0 01	 and	 eax, 1
  0029e	85 c0		 test	 eax, eax
  002a0	74 23		 je	 SHORT $LN57@z900_kmc_a
  002a2	b8 08 00 00 00	 mov	 eax, 8
  002a7	48 6b c0 01	 imul	 rax, rax, 1
  002ab	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b3	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002bb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv234[rsp], rax
  002c3	eb 20		 jmp	 SHORT $LN58@z900_kmc_a
$LN57@z900_kmc_a:
  002c5	b8 08 00 00 00	 mov	 eax, 8
  002ca	48 6b c0 01	 imul	 rax, rax, 1
  002ce	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002dd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv234[rsp], rax
$LN58@z900_kmc_a:
  002e5	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ed	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002f4	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv234[rsp]
  002fc	48 23 c8	 and	 rcx, rax
  002ff	48 8b c1	 mov	 rax, rcx
  00302	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00306	ff c9		 dec	 ecx
  00308	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00310	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00315	41 b9 01 00 00
	00		 mov	 r9d, 1
  0031b	4c 8b c0	 mov	 r8, rax
  0031e	0f b6 d1	 movzx	 edx, cl
  00321	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00329	e8 00 00 00 00	 call	 z900_vfetchc

; 2290 : 
; 2291 : #ifdef OPTION_KMC_DEBUG
; 2292 :   LOGBYTE("icv   :", parameter_block, 16);
; 2293 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 2294 :   if(wrap)
; 2295 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 16], 32);
; 2296 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2297 : 
; 2298 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 2299 :   /* Verify and unwrap */
; 2300 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  0032e	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00333	74 32		 je	 SHORT $LN23@z900_kmc_a
  00335	b8 01 00 00 00	 mov	 eax, 1
  0033a	48 6b c0 10	 imul	 rax, rax, 16
  0033e	48 8d 84 04 00
	03 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00346	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  0034a	48 8b c8	 mov	 rcx, rax
  0034d	e8 00 00 00 00	 call	 unwrap_aes
  00352	85 c0		 test	 eax, eax
  00354	74 11		 je	 SHORT $LN23@z900_kmc_a

; 2301 :   {
; 2302 : 
; 2303 : #ifdef OPTION_KM_DEBUG
; 2304 :     WRMSG(HHC90111, "D");
; 2305 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2306 : 
; 2307 :     regs->psw.cc = 1;

  00356	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035e	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2308 :     return;

  00362	e9 dc 07 00 00	 jmp	 $LN1@z900_kmc_a
$LN23@z900_kmc_a:

; 2309 :   }
; 2310 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 2311 : 
; 2312 :   /* Set the cryptographic key */
; 2313 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  00367	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0036b	c1 e0 03	 shl	 eax, 3
  0036e	b9 01 00 00 00	 mov	 ecx, 1
  00373	48 6b c9 10	 imul	 rcx, rcx, 16
  00377	48 8d 8c 0c 00
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0037f	44 8b c0	 mov	 r8d, eax
  00382	48 8b d1	 mov	 rdx, rcx
  00385	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0038d	e8 00 00 00 00	 call	 rijndael_set_key

; 2314 : 
; 2315 :   /* Try to process the CPU-determined amount of data */
; 2316 :   modifier_bit = GR0_m(regs);

  00392	b8 08 00 00 00	 mov	 eax, 8
  00397	48 6b c0 00	 imul	 rax, rax, 0
  0039b	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003aa	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003af	85 c0		 test	 eax, eax
  003b1	74 0a		 je	 SHORT $LN59@z900_kmc_a
  003b3	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv262[rsp], 1
  003bb	eb 08		 jmp	 SHORT $LN60@z900_kmc_a
$LN59@z900_kmc_a:
  003bd	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv262[rsp], 0
$LN60@z900_kmc_a:
  003c5	8b 44 24 54	 mov	 eax, DWORD PTR tv262[rsp]
  003c9	89 44 24 6c	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2317 :   r1_is_not_r2 = r1 != r2;

  003cd	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003d4	39 84 24 80 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  003db	74 0a		 je	 SHORT $LN61@z900_kmc_a
  003dd	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv264[rsp], 1
  003e5	eb 08		 jmp	 SHORT $LN62@z900_kmc_a
$LN61@z900_kmc_a:
  003e7	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv264[rsp], 0
$LN62@z900_kmc_a:
  003ef	8b 44 24 58	 mov	 eax, DWORD PTR tv264[rsp]
  003f3	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2318 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  003f7	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  003ff	eb 0b		 jmp	 SHORT $LN4@z900_kmc_a
$LN2@z900_kmc_a:
  00401	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00405	83 c0 10	 add	 eax, 16
  00408	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@z900_kmc_a:
  0040c	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00414	0f 8d 1d 07 00
	00		 jge	 $LN3@z900_kmc_a

; 2319 :   {
; 2320 :     /* Fetch a block of data */
; 2321 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0041a	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00422	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00428	83 e0 01	 and	 eax, 1
  0042b	85 c0		 test	 eax, eax
  0042d	74 22		 je	 SHORT $LN63@z900_kmc_a
  0042f	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00437	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0043f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00447	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv283[rsp], rax
  0044f	eb 1f		 jmp	 SHORT $LN64@z900_kmc_a
$LN63@z900_kmc_a:
  00451	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00459	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00461	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00468	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv283[rsp], rax
$LN64@z900_kmc_a:
  00470	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00478	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0047f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv283[rsp]
  00487	48 23 c8	 and	 rcx, rax
  0048a	48 8b c1	 mov	 rax, rcx
  0048d	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00495	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0049a	44 8b 8c 24 88
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  004a2	4c 8b c0	 mov	 r8, rax
  004a5	b2 0f		 mov	 dl, 15
  004a7	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  004af	e8 00 00 00 00	 call	 z900_vfetchc

; 2322 : 
; 2323 : #ifdef OPTION_KMC_DEBUG
; 2324 :     LOGBYTE("input :", message_block, 16);
; 2325 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2326 : 
; 2327 :     /* Do the job */
; 2328 :     if(modifier_bit)

  004b4	83 7c 24 6c 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  004b9	0f 84 81 00 00
	00		 je	 $LN24@z900_kmc_a

; 2329 :     {
; 2330 : 
; 2331 :       /* Save, decrypt and XOR */
; 2332 :       memcpy(ocv, message_block, 16);

  004bf	48 8d 84 24 f0
	02 00 00	 lea	 rax, QWORD PTR ocv$[rsp]
  004c7	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  004cf	48 8b f8	 mov	 rdi, rax
  004d2	48 8b f1	 mov	 rsi, rcx
  004d5	b9 10 00 00 00	 mov	 ecx, 16
  004da	f3 a4		 rep movsb

; 2333 :       rijndael_decrypt(&context, message_block, message_block);

  004dc	4c 8d 84 24 e0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  004e4	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004ec	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  004f4	e8 00 00 00 00	 call	 rijndael_decrypt

; 2334 :       for(i = 0; i < 16; i++)

  004f9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00501	eb 0a		 jmp	 SHORT $LN7@z900_kmc_a
$LN5@z900_kmc_a:
  00503	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00507	ff c0		 inc	 eax
  00509	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_kmc_a:
  0050d	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00512	7d 2a		 jge	 SHORT $LN6@z900_kmc_a

; 2335 :         message_block[i] ^= parameter_block[i];

  00514	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00519	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0051e	0f b6 8c 0c 00
	03 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00526	0f b6 84 04 e0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0052e	33 c1		 xor	 eax, ecx
  00530	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00535	88 84 0c e0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0053c	eb c5		 jmp	 SHORT $LN5@z900_kmc_a
$LN6@z900_kmc_a:

; 2336 :     }

  0053e	eb 7f		 jmp	 SHORT $LN25@z900_kmc_a
$LN24@z900_kmc_a:

; 2337 :     else
; 2338 :     {
; 2339 :       /* XOR, encrypt and save */
; 2340 :       for(i = 0; i < 16; i++)

  00540	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00548	eb 0a		 jmp	 SHORT $LN10@z900_kmc_a
$LN8@z900_kmc_a:
  0054a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0054e	ff c0		 inc	 eax
  00550	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_kmc_a:
  00554	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00559	7d 2a		 jge	 SHORT $LN9@z900_kmc_a

; 2341 :         message_block[i] ^= parameter_block[i];

  0055b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00560	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00565	0f b6 8c 0c 00
	03 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0056d	0f b6 84 04 e0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00575	33 c1		 xor	 eax, ecx
  00577	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0057c	88 84 0c e0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00583	eb c5		 jmp	 SHORT $LN8@z900_kmc_a
$LN9@z900_kmc_a:

; 2342 :       rijndael_encrypt(&context, message_block, message_block);

  00585	4c 8d 84 24 e0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0058d	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00595	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0059d	e8 00 00 00 00	 call	 rijndael_encrypt

; 2343 :       memcpy(ocv, message_block, 16);

  005a2	48 8d 84 24 f0
	02 00 00	 lea	 rax, QWORD PTR ocv$[rsp]
  005aa	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  005b2	48 8b f8	 mov	 rdi, rax
  005b5	48 8b f1	 mov	 rsi, rcx
  005b8	b9 10 00 00 00	 mov	 ecx, 16
  005bd	f3 a4		 rep movsb
$LN25@z900_kmc_a:

; 2344 :     }
; 2345 : 
; 2346 :     /* Store the output */
; 2347 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  005bf	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005cd	83 e0 01	 and	 eax, 1
  005d0	85 c0		 test	 eax, eax
  005d2	74 22		 je	 SHORT $LN65@z900_kmc_a
  005d4	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  005dc	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  005ec	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
  005f4	eb 1f		 jmp	 SHORT $LN66@z900_kmc_a
$LN65@z900_kmc_a:
  005f6	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  005fe	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00606	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0060d	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
$LN66@z900_kmc_a:
  00615	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0061d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00624	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv356[rsp]
  0062c	48 23 c8	 and	 rcx, rax
  0062f	48 8b c1	 mov	 rax, rcx
  00632	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0063a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0063f	44 8b 8c 24 80
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  00647	4c 8b c0	 mov	 r8, rax
  0064a	b2 0f		 mov	 dl, 15
  0064c	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00654	e8 00 00 00 00	 call	 z900_vstorec

; 2348 : 
; 2349 : #ifdef OPTION_KMC_DEBUG
; 2350 :     LOGBYTE("output:", message_block, 16);
; 2351 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2352 : 
; 2353 :     /* Store the output chaining value */
; 2354 :     ARCH_DEP(vstorec)(ocv, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00659	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00661	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00667	83 e0 01	 and	 eax, 1
  0066a	85 c0		 test	 eax, eax
  0066c	74 23		 je	 SHORT $LN67@z900_kmc_a
  0066e	b8 08 00 00 00	 mov	 eax, 8
  00673	48 6b c0 01	 imul	 rax, rax, 1
  00677	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0067f	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00687	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv376[rsp], rax
  0068f	eb 20		 jmp	 SHORT $LN68@z900_kmc_a
$LN67@z900_kmc_a:
  00691	b8 08 00 00 00	 mov	 eax, 8
  00696	48 6b c0 01	 imul	 rax, rax, 1
  0069a	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  006a9	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv376[rsp], rax
$LN68@z900_kmc_a:
  006b1	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006b9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  006c0	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv376[rsp]
  006c8	48 23 c8	 and	 rcx, rax
  006cb	48 8b c1	 mov	 rax, rcx
  006ce	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006d6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006db	41 b9 01 00 00
	00		 mov	 r9d, 1
  006e1	4c 8b c0	 mov	 r8, rax
  006e4	b2 0f		 mov	 dl, 15
  006e6	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  006ee	e8 00 00 00 00	 call	 z900_vstorec
$LN13@z900_kmc_a:

; 2355 : 
; 2356 : #ifdef OPTION_KMC_DEBUG
; 2357 :     LOGBYTE("ocv   :", ocv, 16);
; 2358 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2359 : 
; 2360 :     /* Update the registers */
; 2361 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  006f3	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fb	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00701	83 e0 01	 and	 eax, 1
  00704	85 c0		 test	 eax, eax
  00706	74 7c		 je	 SHORT $LN26@z900_kmc_a
  00708	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00710	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00716	83 e0 01	 and	 eax, 1
  00719	85 c0		 test	 eax, eax
  0071b	74 22		 je	 SHORT $LN69@z900_kmc_a
  0071d	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00725	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0072d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00735	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
  0073d	eb 1f		 jmp	 SHORT $LN70@z900_kmc_a
$LN69@z900_kmc_a:
  0073f	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00747	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0074f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00756	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
$LN70@z900_kmc_a:
  0075e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv404[rsp]
  00766	48 83 c0 10	 add	 rax, 16
  0076a	48 63 8c 24 80
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00772	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0077a	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00782	eb 79		 jmp	 SHORT $LN27@z900_kmc_a
$LN26@z900_kmc_a:
  00784	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00792	83 e0 01	 and	 eax, 1
  00795	85 c0		 test	 eax, eax
  00797	74 22		 je	 SHORT $LN71@z900_kmc_a
  00799	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007a1	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007b1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv425[rsp], rax
  007b9	eb 1f		 jmp	 SHORT $LN72@z900_kmc_a
$LN71@z900_kmc_a:
  007bb	48 63 84 24 80
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007c3	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007d2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv425[rsp], rax
$LN72@z900_kmc_a:
  007da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv425[rsp]
  007e2	48 83 c0 10	 add	 rax, 16
  007e6	48 63 8c 24 80
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  007ee	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007f6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN27@z900_kmc_a:
  007fd	33 c0		 xor	 eax, eax
  007ff	85 c0		 test	 eax, eax
  00801	0f 85 ec fe ff
	ff		 jne	 $LN13@z900_kmc_a

; 2362 :     if(likely(r1_is_not_r2))

  00807	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  0080c	74 0a		 je	 SHORT $LN73@z900_kmc_a
  0080e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv430[rsp], 1
  00816	eb 08		 jmp	 SHORT $LN74@z900_kmc_a
$LN73@z900_kmc_a:
  00818	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv430[rsp], 0
$LN74@z900_kmc_a:
  00820	83 7c 24 5c 00	 cmp	 DWORD PTR tv430[rsp], 0
  00825	0f 84 14 01 00
	00		 je	 $LN28@z900_kmc_a
$LN16@z900_kmc_a:

; 2363 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  0082b	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00833	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00839	83 e0 01	 and	 eax, 1
  0083c	85 c0		 test	 eax, eax
  0083e	74 7c		 je	 SHORT $LN29@z900_kmc_a
  00840	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00848	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0084e	83 e0 01	 and	 eax, 1
  00851	85 c0		 test	 eax, eax
  00853	74 22		 je	 SHORT $LN75@z900_kmc_a
  00855	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0085d	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00865	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0086d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv454[rsp], rax
  00875	eb 1f		 jmp	 SHORT $LN76@z900_kmc_a
$LN75@z900_kmc_a:
  00877	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0087f	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00887	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0088e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv454[rsp], rax
$LN76@z900_kmc_a:
  00896	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv454[rsp]
  0089e	48 83 c0 10	 add	 rax, 16
  008a2	48 63 8c 24 88
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  008aa	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008b2	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  008ba	eb 79		 jmp	 SHORT $LN30@z900_kmc_a
$LN29@z900_kmc_a:
  008bc	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008c4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008ca	83 e0 01	 and	 eax, 1
  008cd	85 c0		 test	 eax, eax
  008cf	74 22		 je	 SHORT $LN77@z900_kmc_a
  008d1	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008d9	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008e9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv475[rsp], rax
  008f1	eb 1f		 jmp	 SHORT $LN78@z900_kmc_a
$LN77@z900_kmc_a:
  008f3	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008fb	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00903	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0090a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv475[rsp], rax
$LN78@z900_kmc_a:
  00912	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv475[rsp]
  0091a	48 83 c0 10	 add	 rax, 16
  0091e	48 63 8c 24 88
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00926	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0092e	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN30@z900_kmc_a:
  00935	33 c0		 xor	 eax, eax
  00937	85 c0		 test	 eax, eax
  00939	0f 85 ec fe ff
	ff		 jne	 $LN16@z900_kmc_a
$LN28@z900_kmc_a:
$LN19@z900_kmc_a:

; 2364 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  0093f	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00947	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0094d	83 e0 01	 and	 eax, 1
  00950	85 c0		 test	 eax, eax
  00952	0f 84 89 00 00
	00		 je	 $LN31@z900_kmc_a
  00958	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00960	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00966	83 e0 01	 and	 eax, 1
  00969	85 c0		 test	 eax, eax
  0096b	74 25		 je	 SHORT $LN79@z900_kmc_a
  0096d	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00974	ff c0		 inc	 eax
  00976	48 98		 cdqe
  00978	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00980	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00988	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv504[rsp], rax
  00990	eb 22		 jmp	 SHORT $LN80@z900_kmc_a
$LN79@z900_kmc_a:
  00992	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00999	ff c0		 inc	 eax
  0099b	48 98		 cdqe
  0099d	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009ac	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv504[rsp], rax
$LN80@z900_kmc_a:
  009b4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv504[rsp]
  009bc	48 83 e8 10	 sub	 rax, 16
  009c0	8b 8c 24 88 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  009c7	ff c1		 inc	 ecx
  009c9	48 63 c9	 movsxd	 rcx, ecx
  009cc	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009d4	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  009dc	e9 83 00 00 00	 jmp	 $LN32@z900_kmc_a
$LN31@z900_kmc_a:
  009e1	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009e9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  009ef	83 e0 01	 and	 eax, 1
  009f2	85 c0		 test	 eax, eax
  009f4	74 25		 je	 SHORT $LN81@z900_kmc_a
  009f6	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009fd	ff c0		 inc	 eax
  009ff	48 98		 cdqe
  00a01	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a09	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a11	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv528[rsp], rax
  00a19	eb 22		 jmp	 SHORT $LN82@z900_kmc_a
$LN81@z900_kmc_a:
  00a1b	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a22	ff c0		 inc	 eax
  00a24	48 98		 cdqe
  00a26	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a2e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a35	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv528[rsp], rax
$LN82@z900_kmc_a:
  00a3d	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv528[rsp]
  00a45	48 83 e8 10	 sub	 rax, 16
  00a49	8b 8c 24 88 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00a50	ff c1		 inc	 ecx
  00a52	48 63 c9	 movsxd	 rcx, ecx
  00a55	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a5d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN32@z900_kmc_a:
  00a64	33 c0		 xor	 eax, eax
  00a66	85 c0		 test	 eax, eax
  00a68	0f 85 d1 fe ff
	ff		 jne	 $LN19@z900_kmc_a

; 2365 : 
; 2366 : #ifdef OPTION_KMC_DEBUG
; 2367 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2368 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2369 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2370 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2371 : 
; 2372 :     /* check for end of data */
; 2373 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00a6e	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a76	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a7c	83 e0 01	 and	 eax, 1
  00a7f	85 c0		 test	 eax, eax
  00a81	74 25		 je	 SHORT $LN83@z900_kmc_a
  00a83	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a8a	ff c0		 inc	 eax
  00a8c	48 98		 cdqe
  00a8e	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a96	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a9e	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv548[rsp], rax
  00aa6	eb 22		 jmp	 SHORT $LN84@z900_kmc_a
$LN83@z900_kmc_a:
  00aa8	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00aaf	ff c0		 inc	 eax
  00ab1	48 98		 cdqe
  00ab3	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00abb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00ac2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv548[rsp], rax
$LN84@z900_kmc_a:
  00aca	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR tv548[rsp], 0
  00ad3	75 0a		 jne	 SHORT $LN85@z900_kmc_a
  00ad5	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv550[rsp], 1
  00add	eb 08		 jmp	 SHORT $LN86@z900_kmc_a
$LN85@z900_kmc_a:
  00adf	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv550[rsp], 0
$LN86@z900_kmc_a:
  00ae7	83 7c 24 60 00	 cmp	 DWORD PTR tv550[rsp], 0
  00aec	74 0a		 je	 SHORT $LN91@z900_kmc_a
  00aee	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv571[rsp], 1
  00af6	eb 08		 jmp	 SHORT $LN92@z900_kmc_a
$LN91@z900_kmc_a:
  00af8	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv571[rsp], 0
$LN92@z900_kmc_a:
  00b00	83 7c 24 64 00	 cmp	 DWORD PTR tv571[rsp], 0
  00b05	74 0e		 je	 SHORT $LN33@z900_kmc_a

; 2374 :     {
; 2375 :       regs->psw.cc = 0;

  00b07	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0f	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2376 :       return;

  00b13	eb 2e		 jmp	 SHORT $LN1@z900_kmc_a
$LN33@z900_kmc_a:

; 2377 :     }
; 2378 : 
; 2379 :     /* Set cv for next 16 bytes */
; 2380 :     memcpy(parameter_block, ocv, 16);

  00b15	48 8d 84 24 00
	03 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp]
  00b1d	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  00b25	48 8b f8	 mov	 rdi, rax
  00b28	48 8b f1	 mov	 rsi, rcx
  00b2b	b9 10 00 00 00	 mov	 ecx, 16
  00b30	f3 a4		 rep movsb

; 2381 :   }

  00b32	e9 ca f8 ff ff	 jmp	 $LN2@z900_kmc_a
$LN3@z900_kmc_a:

; 2382 : 
; 2383 :   /* CPU-determined amount of data processed */
; 2384 :   regs->psw.cc = 3;

  00b37	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b3f	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmc_a:

; 2385 : }

  00b43	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b4b	48 33 cc	 xor	 rcx, rsp
  00b4e	e8 00 00 00 00	 call	 __security_check_cookie
  00b53	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  00b5a	5f		 pop	 rdi
  00b5b	5e		 pop	 rsi
  00b5c	c3		 ret	 0
z900_kmc_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv248 = 56
crypted$ = 60
tfc$ = 64
tv309 = 68
modifier_bit$ = 72
tv135 = 76
tv157 = 80
tv178 = 84
tv193 = 88
wrap$ = 92
keylen$ = 96
tv282 = 100
tv284 = 104
tv580 = 108
tv700 = 112
tv721 = 116
r1_is_not_r2$ = 120
tv80 = 128
tv155 = 136
tv214 = 144
tv232 = 152
tv303 = 160
tv506 = 168
tv526 = 176
tv554 = 184
tv575 = 192
tv604 = 200
tv625 = 208
tv654 = 216
tv678 = 224
tv698 = 232
context1$ = 240
context2$ = 384
context3$ = 528
message_block$ = 672
ocv$ = 680
parameter_block$ = 688
__$ArrayPad$ = 744
r1$ = 768
r2$ = 776
regs$ = 784
z900_kmc_dea PROC

; 2016 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2017 :   des_context context1;
; 2018 :   des_context context2;
; 2019 :   des_context context3;
; 2020 :   int crypted;
; 2021 :   int i;
; 2022 :   int keylen;
; 2023 :   BYTE message_block[8];
; 2024 :   int modifier_bit;
; 2025 :   BYTE ocv[8];
; 2026 :   BYTE parameter_block[56];
; 2027 :   int parameter_blocklen;
; 2028 :   int r1_is_not_r2;
; 2029 :   int tfc;
; 2030 :   int wrap;
; 2031 : 
; 2032 :   /* Check special conditions */
; 2033 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 25		 je	 SHORT $LN61@z900_kmc_d
  0003b	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00042	ff c0		 inc	 eax
  00044	48 98		 cdqe
  00046	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00056	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
  0005e	eb 22		 jmp	 SHORT $LN62@z900_kmc_d
$LN61@z900_kmc_d:
  00060	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00067	ff c0		 inc	 eax
  00069	48 98		 cdqe
  0006b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00073	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv80[rsp], rax
$LN62@z900_kmc_d:
  00082	33 d2		 xor	 edx, edx
  00084	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv80[rsp]
  0008c	b9 08 00 00 00	 mov	 ecx, 8
  00091	48 f7 f1	 div	 rcx
  00094	48 8b c2	 mov	 rax, rdx
  00097	48 85 c0	 test	 rax, rax
  0009a	74 0a		 je	 SHORT $LN67@z900_kmc_d
  0009c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  000a4	eb 08		 jmp	 SHORT $LN68@z900_kmc_d
$LN67@z900_kmc_d:
  000a6	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN68@z900_kmc_d:
  000ae	83 7c 24 4c 00	 cmp	 DWORD PTR tv135[rsp], 0
  000b3	74 13		 je	 SHORT $LN36@z900_kmc_d

; 2034 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000b5	ba 06 00 00 00	 mov	 edx, 6
  000ba	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN36@z900_kmc_d:

; 2035 : 
; 2036 :   /* Return with cc 0 on zero length */
; 2037 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000c8	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d6	83 e0 01	 and	 eax, 1
  000d9	85 c0		 test	 eax, eax
  000db	74 25		 je	 SHORT $LN69@z900_kmc_d
  000dd	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000e4	ff c0		 inc	 eax
  000e6	48 98		 cdqe
  000e8	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  00100	eb 22		 jmp	 SHORT $LN70@z900_kmc_d
$LN69@z900_kmc_d:
  00102	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00109	ff c0		 inc	 eax
  0010b	48 98		 cdqe
  0010d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00115	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0011c	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN70@z900_kmc_d:
  00124	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR tv155[rsp], 0
  0012d	75 0a		 jne	 SHORT $LN71@z900_kmc_d
  0012f	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  00137	eb 08		 jmp	 SHORT $LN72@z900_kmc_d
$LN71@z900_kmc_d:
  00139	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN72@z900_kmc_d:
  00141	83 7c 24 50 00	 cmp	 DWORD PTR tv157[rsp], 0
  00146	74 0a		 je	 SHORT $LN77@z900_kmc_d
  00148	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00150	eb 08		 jmp	 SHORT $LN78@z900_kmc_d
$LN77@z900_kmc_d:
  00152	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN78@z900_kmc_d:
  0015a	83 7c 24 54 00	 cmp	 DWORD PTR tv178[rsp], 0
  0015f	74 11		 je	 SHORT $LN37@z900_kmc_d

; 2038 :   {
; 2039 :     regs->psw.cc = 0;

  00161	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00169	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2040 :     return;

  0016d	e9 71 0d 00 00	 jmp	 $LN1@z900_kmc_d
$LN37@z900_kmc_d:

; 2041 :   }
; 2042 : 
; 2043 :   /* Initialize values */
; 2044 :   tfc = GR0_tfc(regs);

  00172	b8 08 00 00 00	 mov	 eax, 8
  00177	48 6b c0 00	 imul	 rax, rax, 0
  0017b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0018a	83 e0 7f	 and	 eax, 127		; 0000007fH
  0018d	83 e0 77	 and	 eax, 119		; 00000077H
  00190	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 2045 :   wrap = GR0_wrap(regs);

  00194	b8 08 00 00 00	 mov	 eax, 8
  00199	48 6b c0 00	 imul	 rax, rax, 0
  0019d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a5	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ac	83 e0 08	 and	 eax, 8
  001af	85 c0		 test	 eax, eax
  001b1	74 0a		 je	 SHORT $LN79@z900_kmc_d
  001b3	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001bb	eb 08		 jmp	 SHORT $LN80@z900_kmc_d
$LN79@z900_kmc_d:
  001bd	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN80@z900_kmc_d:
  001c5	8b 44 24 58	 mov	 eax, DWORD PTR tv193[rsp]
  001c9	89 44 24 5c	 mov	 DWORD PTR wrap$[rsp], eax

; 2046 :   keylen = tfc * 8;

  001cd	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  001d1	c1 e0 03	 shl	 eax, 3
  001d4	89 44 24 60	 mov	 DWORD PTR keylen$[rsp], eax

; 2047 :   parameter_blocklen = keylen + 8;

  001d8	8b 44 24 60	 mov	 eax, DWORD PTR keylen$[rsp]
  001dc	83 c0 08	 add	 eax, 8
  001df	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2048 :   if(wrap)

  001e3	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001e8	74 0b		 je	 SHORT $LN38@z900_kmc_d

; 2049 :     parameter_blocklen += 24;

  001ea	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001ee	83 c0 18	 add	 eax, 24
  001f1	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN38@z900_kmc_d:

; 2050 : 
; 2051 :   /* Test writeability output chaining value */
; 2052 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  001f5	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001fd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00203	83 e0 01	 and	 eax, 1
  00206	85 c0		 test	 eax, eax
  00208	74 23		 je	 SHORT $LN81@z900_kmc_d
  0020a	b8 08 00 00 00	 mov	 eax, 8
  0020f	48 6b c0 01	 imul	 rax, rax, 1
  00213	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021b	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00223	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
  0022b	eb 20		 jmp	 SHORT $LN82@z900_kmc_d
$LN81@z900_kmc_d:
  0022d	b8 08 00 00 00	 mov	 eax, 8
  00232	48 6b c0 01	 imul	 rax, rax, 1
  00236	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00245	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv214[rsp], rax
$LN82@z900_kmc_d:
  0024d	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00255	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0025c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv214[rsp]
  00264	48 23 c8	 and	 rcx, rax
  00267	48 8b c1	 mov	 rax, rcx
  0026a	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00272	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00277	41 b9 02 00 00
	00		 mov	 r9d, 2
  0027d	41 b8 07 00 00
	00		 mov	 r8d, 7
  00283	ba 01 00 00 00	 mov	 edx, 1
  00288	48 8b c8	 mov	 rcx, rax
  0028b	e8 00 00 00 00	 call	 z900_validate_operand

; 2053 : 
; 2054 :   /* Fetch the parameter block */
; 2055 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00290	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00298	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0029e	83 e0 01	 and	 eax, 1
  002a1	85 c0		 test	 eax, eax
  002a3	74 23		 je	 SHORT $LN83@z900_kmc_d
  002a5	b8 08 00 00 00	 mov	 eax, 8
  002aa	48 6b c0 01	 imul	 rax, rax, 1
  002ae	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b6	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002be	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv232[rsp], rax
  002c6	eb 20		 jmp	 SHORT $LN84@z900_kmc_d
$LN83@z900_kmc_d:
  002c8	b8 08 00 00 00	 mov	 eax, 8
  002cd	48 6b c0 01	 imul	 rax, rax, 1
  002d1	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002e0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv232[rsp], rax
$LN84@z900_kmc_d:
  002e8	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002f7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv232[rsp]
  002ff	48 23 c8	 and	 rcx, rax
  00302	48 8b c1	 mov	 rax, rcx
  00305	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00309	ff c9		 dec	 ecx
  0030b	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00313	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00318	41 b9 01 00 00
	00		 mov	 r9d, 1
  0031e	4c 8b c0	 mov	 r8, rax
  00321	0f b6 d1	 movzx	 edx, cl
  00324	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0032c	e8 00 00 00 00	 call	 z900_vfetchc

; 2056 : 
; 2057 : #ifdef OPTION_KMC_DEBUG
; 2058 :   LOGBYTE("icv   :", parameter_block, 8);
; 2059 :   switch(tfc)
; 2060 :   {
; 2061 :     case 1: /* dea */
; 2062 :     {
; 2063 :       LOGBYTE("k     :", &parameter_block[8], 8);
; 2064 :       break;
; 2065 :     }
; 2066 :     case 2: /* tdea-128 */
; 2067 :     {
; 2068 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2069 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2070 :       break;
; 2071 :     }
; 2072 :     case 3: /* tdea-192 */
; 2073 :     {
; 2074 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2075 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2076 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 2077 :       break;
; 2078 :     }
; 2079 :   }
; 2080 :   if(wrap)
; 2081 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 2082 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2083 : 
; 2084 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 2085 :   /* Verify and unwrap */
; 2086 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  00331	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00336	74 32		 je	 SHORT $LN39@z900_kmc_d
  00338	b8 01 00 00 00	 mov	 eax, 1
  0033d	48 6b c0 08	 imul	 rax, rax, 8
  00341	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00349	8b 54 24 60	 mov	 edx, DWORD PTR keylen$[rsp]
  0034d	48 8b c8	 mov	 rcx, rax
  00350	e8 00 00 00 00	 call	 unwrap_dea
  00355	85 c0		 test	 eax, eax
  00357	74 11		 je	 SHORT $LN39@z900_kmc_d

; 2087 :   {
; 2088 : 
; 2089 : #ifdef OPTION_KMC_DEBUG
; 2090 :     WRMSG(HHC90111, "D");
; 2091 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2092 : 
; 2093 :     regs->psw.cc = 1;

  00359	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00361	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2094 :     return;

  00365	e9 79 0b 00 00	 jmp	 $LN1@z900_kmc_d
$LN39@z900_kmc_d:

; 2095 :   }
; 2096 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 2097 : 
; 2098 :   /* Set the cryptographic key */
; 2099 :   switch(tfc)

  0036a	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0036e	89 44 24 38	 mov	 DWORD PTR tv248[rsp], eax
  00372	83 7c 24 38 01	 cmp	 DWORD PTR tv248[rsp], 1
  00377	74 13		 je	 SHORT $LN40@z900_kmc_d
  00379	83 7c 24 38 02	 cmp	 DWORD PTR tv248[rsp], 2
  0037e	74 32		 je	 SHORT $LN41@z900_kmc_d
  00380	83 7c 24 38 03	 cmp	 DWORD PTR tv248[rsp], 3
  00385	74 6f		 je	 SHORT $LN42@z900_kmc_d
  00387	e9 cd 00 00 00	 jmp	 $LN2@z900_kmc_d
$LN40@z900_kmc_d:

; 2100 :   {
; 2101 :     case 1: /* dea */
; 2102 :     {
; 2103 :       des_set_key(&context1, &parameter_block[8]);

  0038c	b8 01 00 00 00	 mov	 eax, 1
  00391	48 6b c0 08	 imul	 rax, rax, 8
  00395	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0039d	48 8b d0	 mov	 rdx, rax
  003a0	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003a8	e8 00 00 00 00	 call	 des_set_key

; 2104 :       break;

  003ad	e9 a7 00 00 00	 jmp	 $LN2@z900_kmc_d
$LN41@z900_kmc_d:

; 2105 :     }
; 2106 :     case 2: /* tdea-128 */
; 2107 :     {
; 2108 :       des_set_key(&context1, &parameter_block[8]);

  003b2	b8 01 00 00 00	 mov	 eax, 1
  003b7	48 6b c0 08	 imul	 rax, rax, 8
  003bb	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003c3	48 8b d0	 mov	 rdx, rax
  003c6	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003ce	e8 00 00 00 00	 call	 des_set_key

; 2109 :       des_set_key(&context2, &parameter_block[16]);

  003d3	b8 01 00 00 00	 mov	 eax, 1
  003d8	48 6b c0 10	 imul	 rax, rax, 16
  003dc	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003e4	48 8b d0	 mov	 rdx, rax
  003e7	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  003ef	e8 00 00 00 00	 call	 des_set_key

; 2110 :       break;

  003f4	eb 63		 jmp	 SHORT $LN2@z900_kmc_d
$LN42@z900_kmc_d:

; 2111 :     }
; 2112 :     case 3: /* tdea-192 */
; 2113 :     {
; 2114 :       des_set_key(&context1, &parameter_block[8]);

  003f6	b8 01 00 00 00	 mov	 eax, 1
  003fb	48 6b c0 08	 imul	 rax, rax, 8
  003ff	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00407	48 8b d0	 mov	 rdx, rax
  0040a	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00412	e8 00 00 00 00	 call	 des_set_key

; 2115 :       des_set_key(&context2, &parameter_block[16]);

  00417	b8 01 00 00 00	 mov	 eax, 1
  0041c	48 6b c0 10	 imul	 rax, rax, 16
  00420	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00428	48 8b d0	 mov	 rdx, rax
  0042b	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00433	e8 00 00 00 00	 call	 des_set_key

; 2116 :       des_set_key(&context3, &parameter_block[24]);

  00438	b8 01 00 00 00	 mov	 eax, 1
  0043d	48 6b c0 18	 imul	 rax, rax, 24
  00441	48 8d 84 04 b0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00449	48 8b d0	 mov	 rdx, rax
  0044c	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00454	e8 00 00 00 00	 call	 des_set_key
$LN2@z900_kmc_d:

; 2117 :       break;
; 2118 :     }
; 2119 :   }
; 2120 : 
; 2121 :   /* Try to process the CPU-determined amount of data */
; 2122 :   modifier_bit = GR0_m(regs);

  00459	b8 08 00 00 00	 mov	 eax, 8
  0045e	48 6b c0 00	 imul	 rax, rax, 0
  00462	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0046a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00471	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00476	85 c0		 test	 eax, eax
  00478	74 0a		 je	 SHORT $LN85@z900_kmc_d
  0047a	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv282[rsp], 1
  00482	eb 08		 jmp	 SHORT $LN86@z900_kmc_d
$LN85@z900_kmc_d:
  00484	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv282[rsp], 0
$LN86@z900_kmc_d:
  0048c	8b 44 24 64	 mov	 eax, DWORD PTR tv282[rsp]
  00490	89 44 24 48	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2123 :   r1_is_not_r2 = r1 != r2;

  00494	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0049b	39 84 24 00 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  004a2	74 0a		 je	 SHORT $LN87@z900_kmc_d
  004a4	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv284[rsp], 1
  004ac	eb 08		 jmp	 SHORT $LN88@z900_kmc_d
$LN87@z900_kmc_d:
  004ae	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv284[rsp], 0
$LN88@z900_kmc_d:
  004b6	8b 44 24 68	 mov	 eax, DWORD PTR tv284[rsp]
  004ba	89 44 24 78	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2124 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  004be	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  004c6	eb 0b		 jmp	 SHORT $LN6@z900_kmc_d
$LN4@z900_kmc_d:
  004c8	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  004cc	83 c0 08	 add	 eax, 8
  004cf	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@z900_kmc_d:
  004d3	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  004db	0f 8d f6 09 00
	00		 jge	 $LN5@z900_kmc_d

; 2125 :   {
; 2126 :     /* Fetch a block of data */
; 2127 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  004e1	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004ef	83 e0 01	 and	 eax, 1
  004f2	85 c0		 test	 eax, eax
  004f4	74 22		 je	 SHORT $LN89@z900_kmc_d
  004f6	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004fe	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00506	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0050e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv303[rsp], rax
  00516	eb 1f		 jmp	 SHORT $LN90@z900_kmc_d
$LN89@z900_kmc_d:
  00518	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00520	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00528	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0052f	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv303[rsp], rax
$LN90@z900_kmc_d:
  00537	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00546	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv303[rsp]
  0054e	48 23 c8	 and	 rcx, rax
  00551	48 8b c1	 mov	 rax, rcx
  00554	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00561	44 8b 8c 24 08
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00569	4c 8b c0	 mov	 r8, rax
  0056c	b2 07		 mov	 dl, 7
  0056e	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00576	e8 00 00 00 00	 call	 z900_vfetchc

; 2128 : 
; 2129 : #ifdef OPTION_KMC_DEBUG
; 2130 :     LOGBYTE("input :", message_block, 8);
; 2131 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2132 : 
; 2133 :     /* Do the job */
; 2134 :     switch(tfc)

  0057b	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0057f	89 44 24 44	 mov	 DWORD PTR tv309[rsp], eax
  00583	83 7c 24 44 01	 cmp	 DWORD PTR tv309[rsp], 1
  00588	74 1b		 je	 SHORT $LN43@z900_kmc_d
  0058a	83 7c 24 44 02	 cmp	 DWORD PTR tv309[rsp], 2
  0058f	0f 84 02 01 00
	00		 je	 $LN46@z900_kmc_d
  00595	83 7c 24 44 03	 cmp	 DWORD PTR tv309[rsp], 3
  0059a	0f 84 64 02 00
	00		 je	 $LN49@z900_kmc_d
  005a0	e9 c7 03 00 00	 jmp	 $LN7@z900_kmc_d
$LN43@z900_kmc_d:

; 2135 :     {
; 2136 :       case 1: /* dea */
; 2137 :       {
; 2138 :         if(modifier_bit)

  005a5	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  005aa	74 74		 je	 SHORT $LN44@z900_kmc_d

; 2139 :         {
; 2140 :           /* Save, decrypt and XOR */
; 2141 :           memcpy(ocv, message_block, 8);

  005ac	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  005b4	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2142 :           des_decrypt(&context1, message_block, message_block);

  005bc	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  005c4	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005cc	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005d4	e8 00 00 00 00	 call	 des_decrypt

; 2143 :           for(i = 0; i < 8; i++)

  005d9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005e1	eb 0a		 jmp	 SHORT $LN11@z900_kmc_d
$LN9@z900_kmc_d:
  005e3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005e7	ff c0		 inc	 eax
  005e9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@z900_kmc_d:
  005ed	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  005f2	7d 2a		 jge	 SHORT $LN10@z900_kmc_d

; 2144 :             message_block[i] ^= parameter_block[i];

  005f4	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005f9	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005fe	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00606	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0060e	33 c1		 xor	 eax, ecx
  00610	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00615	88 84 0c a0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0061c	eb c5		 jmp	 SHORT $LN9@z900_kmc_d
$LN10@z900_kmc_d:

; 2145 :         }

  0061e	eb 72		 jmp	 SHORT $LN45@z900_kmc_d
$LN44@z900_kmc_d:

; 2146 :         else
; 2147 :         {
; 2148 :           /* XOR, encrypt and save */
; 2149 :           for(i = 0; i < 8; i++)

  00620	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00628	eb 0a		 jmp	 SHORT $LN14@z900_kmc_d
$LN12@z900_kmc_d:
  0062a	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0062e	ff c0		 inc	 eax
  00630	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN14@z900_kmc_d:
  00634	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00639	7d 2a		 jge	 SHORT $LN13@z900_kmc_d

; 2150 :             message_block[i] ^= parameter_block[i];

  0063b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00640	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00645	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0064d	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00655	33 c1		 xor	 eax, ecx
  00657	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0065c	88 84 0c a0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00663	eb c5		 jmp	 SHORT $LN12@z900_kmc_d
$LN13@z900_kmc_d:

; 2151 :           des_encrypt(&context1, message_block, message_block);

  00665	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0066d	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00675	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0067d	e8 00 00 00 00	 call	 des_encrypt

; 2152 :           memcpy(ocv, message_block, 8);

  00682	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  0068a	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN45@z900_kmc_d:

; 2153 :         }
; 2154 :         break;

  00692	e9 d5 02 00 00	 jmp	 $LN7@z900_kmc_d
$LN46@z900_kmc_d:

; 2155 :       }
; 2156 :       case 2: /* tdea-128 */
; 2157 :       {
; 2158 :         if(modifier_bit)

  00697	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0069c	0f 84 b1 00 00
	00		 je	 $LN47@z900_kmc_d

; 2159 :         {
; 2160 :           /* Save, decrypt and XOR */
; 2161 :           memcpy(ocv, message_block, 8);

  006a2	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  006aa	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2162 :           des_decrypt(&context1, message_block, message_block);

  006b2	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  006ba	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  006c2	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  006ca	e8 00 00 00 00	 call	 des_decrypt

; 2163 :           des_encrypt(&context2, message_block, message_block);

  006cf	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  006d7	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  006df	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  006e7	e8 00 00 00 00	 call	 des_encrypt

; 2164 :           des_decrypt(&context1, message_block, message_block);

  006ec	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  006f4	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  006fc	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00704	e8 00 00 00 00	 call	 des_decrypt

; 2165 :           for(i = 0; i < 8; i++)

  00709	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00711	eb 0a		 jmp	 SHORT $LN17@z900_kmc_d
$LN15@z900_kmc_d:
  00713	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00717	ff c0		 inc	 eax
  00719	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN17@z900_kmc_d:
  0071d	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00722	7d 2a		 jge	 SHORT $LN16@z900_kmc_d

; 2166 :             message_block[i] ^= parameter_block[i];

  00724	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00729	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0072e	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00736	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0073e	33 c1		 xor	 eax, ecx
  00740	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00745	88 84 0c a0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0074c	eb c5		 jmp	 SHORT $LN15@z900_kmc_d
$LN16@z900_kmc_d:

; 2167 :         }

  0074e	e9 ac 00 00 00	 jmp	 $LN48@z900_kmc_d
$LN47@z900_kmc_d:

; 2168 :         else
; 2169 :         {
; 2170 :           /* XOR, encrypt and save */
; 2171 :           for(i = 0 ; i < 8; i++)

  00753	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0075b	eb 0a		 jmp	 SHORT $LN20@z900_kmc_d
$LN18@z900_kmc_d:
  0075d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00761	ff c0		 inc	 eax
  00763	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN20@z900_kmc_d:
  00767	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0076c	7d 2a		 jge	 SHORT $LN19@z900_kmc_d

; 2172 :             message_block[i] ^= parameter_block[i];

  0076e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00773	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00778	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00780	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00788	33 c1		 xor	 eax, ecx
  0078a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0078f	88 84 0c a0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00796	eb c5		 jmp	 SHORT $LN18@z900_kmc_d
$LN19@z900_kmc_d:

; 2173 :           des_encrypt(&context1, message_block, message_block);

  00798	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  007a0	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  007a8	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  007b0	e8 00 00 00 00	 call	 des_encrypt

; 2174 :           des_decrypt(&context2, message_block, message_block);

  007b5	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  007bd	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  007c5	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  007cd	e8 00 00 00 00	 call	 des_decrypt

; 2175 :           des_encrypt(&context1, message_block, message_block);

  007d2	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  007da	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  007e2	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  007ea	e8 00 00 00 00	 call	 des_encrypt

; 2176 :           memcpy(ocv, message_block, 8);

  007ef	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  007f7	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN48@z900_kmc_d:

; 2177 :         }
; 2178 :         break;

  007ff	e9 68 01 00 00	 jmp	 $LN7@z900_kmc_d
$LN49@z900_kmc_d:

; 2179 :       }
; 2180 :       case 3: /* tdea-192 */
; 2181 :       {
; 2182 :         if(modifier_bit)

  00804	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  00809	0f 84 b1 00 00
	00		 je	 $LN50@z900_kmc_d

; 2183 :         {
; 2184 :           /* Save, decrypt and XOR */
; 2185 :           memcpy(ocv, message_block, 8);

  0080f	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00817	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2186 :           des_decrypt(&context3, message_block, message_block);

  0081f	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00827	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0082f	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00837	e8 00 00 00 00	 call	 des_decrypt

; 2187 :           des_encrypt(&context2, message_block, message_block);

  0083c	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00844	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0084c	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00854	e8 00 00 00 00	 call	 des_encrypt

; 2188 :           des_decrypt(&context1, message_block, message_block);

  00859	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00861	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00869	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00871	e8 00 00 00 00	 call	 des_decrypt

; 2189 :           for(i = 0; i < 8; i++)

  00876	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0087e	eb 0a		 jmp	 SHORT $LN23@z900_kmc_d
$LN21@z900_kmc_d:
  00880	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00884	ff c0		 inc	 eax
  00886	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN23@z900_kmc_d:
  0088a	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0088f	7d 2a		 jge	 SHORT $LN22@z900_kmc_d

; 2190 :             message_block[i] ^= parameter_block[i];

  00891	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00896	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0089b	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  008a3	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  008ab	33 c1		 xor	 eax, ecx
  008ad	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  008b2	88 84 0c a0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  008b9	eb c5		 jmp	 SHORT $LN21@z900_kmc_d
$LN22@z900_kmc_d:

; 2191 :         }

  008bb	e9 ac 00 00 00	 jmp	 $LN51@z900_kmc_d
$LN50@z900_kmc_d:

; 2192 :         else
; 2193 :         {
; 2194 :           /* XOR, encrypt and save */
; 2195 :           for(i = 0; i < 8; i++)

  008c0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  008c8	eb 0a		 jmp	 SHORT $LN26@z900_kmc_d
$LN24@z900_kmc_d:
  008ca	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  008ce	ff c0		 inc	 eax
  008d0	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN26@z900_kmc_d:
  008d4	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  008d9	7d 2a		 jge	 SHORT $LN25@z900_kmc_d

; 2196 :             message_block[i] ^= parameter_block[i];

  008db	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  008e0	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  008e5	0f b6 8c 0c b0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  008ed	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  008f5	33 c1		 xor	 eax, ecx
  008f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  008fc	88 84 0c a0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00903	eb c5		 jmp	 SHORT $LN24@z900_kmc_d
$LN25@z900_kmc_d:

; 2197 :           des_encrypt(&context1, message_block, message_block);

  00905	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0090d	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00915	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0091d	e8 00 00 00 00	 call	 des_encrypt

; 2198 :           des_decrypt(&context2, message_block, message_block);

  00922	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0092a	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00932	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0093a	e8 00 00 00 00	 call	 des_decrypt

; 2199 :           des_encrypt(&context3, message_block, message_block);

  0093f	4c 8d 84 24 a0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00947	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0094f	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00957	e8 00 00 00 00	 call	 des_encrypt

; 2200 :           memcpy(ocv, message_block, 8);

  0095c	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00964	48 89 84 24 a8
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN51@z900_kmc_d:
$LN7@z900_kmc_d:

; 2201 :         }
; 2202 :         break;
; 2203 :       }
; 2204 :     }
; 2205 : 
; 2206 :     /* Store the output */
; 2207 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0096c	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00974	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0097a	83 e0 01	 and	 eax, 1
  0097d	85 c0		 test	 eax, eax
  0097f	74 22		 je	 SHORT $LN91@z900_kmc_d
  00981	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00989	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00991	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00999	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv506[rsp], rax
  009a1	eb 1f		 jmp	 SHORT $LN92@z900_kmc_d
$LN91@z900_kmc_d:
  009a3	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  009ab	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009b3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009ba	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv506[rsp], rax
$LN92@z900_kmc_d:
  009c2	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009ca	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  009d1	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv506[rsp]
  009d9	48 23 c8	 and	 rcx, rax
  009dc	48 8b c1	 mov	 rax, rcx
  009df	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  009ec	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  009f4	4c 8b c0	 mov	 r8, rax
  009f7	b2 07		 mov	 dl, 7
  009f9	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00a01	e8 00 00 00 00	 call	 z900_vstorec

; 2208 : 
; 2209 : #ifdef OPTION_KMC_DEBUG
; 2210 :     LOGBYTE("output:", message_block, 8);
; 2211 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2212 : 
; 2213 :     /* Store the output chaining value */
; 2214 :     ARCH_DEP(vstorec)(ocv, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00a06	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a0e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a14	83 e0 01	 and	 eax, 1
  00a17	85 c0		 test	 eax, eax
  00a19	74 23		 je	 SHORT $LN93@z900_kmc_d
  00a1b	b8 08 00 00 00	 mov	 eax, 8
  00a20	48 6b c0 01	 imul	 rax, rax, 1
  00a24	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a2c	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00a34	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv526[rsp], rax
  00a3c	eb 20		 jmp	 SHORT $LN94@z900_kmc_d
$LN93@z900_kmc_d:
  00a3e	b8 08 00 00 00	 mov	 eax, 8
  00a43	48 6b c0 01	 imul	 rax, rax, 1
  00a47	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a4f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00a56	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv526[rsp], rax
$LN94@z900_kmc_d:
  00a5e	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a66	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00a6d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv526[rsp]
  00a75	48 23 c8	 and	 rcx, rax
  00a78	48 8b c1	 mov	 rax, rcx
  00a7b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a83	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00a88	41 b9 01 00 00
	00		 mov	 r9d, 1
  00a8e	4c 8b c0	 mov	 r8, rax
  00a91	b2 07		 mov	 dl, 7
  00a93	48 8d 8c 24 a8
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  00a9b	e8 00 00 00 00	 call	 z900_vstorec
$LN29@z900_kmc_d:

; 2215 : 
; 2216 : #ifdef OPTION_KMC_DEBUG
; 2217 :     LOGBYTE("ocv   :", ocv, 8);
; 2218 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2219 : 
; 2220 :     /* Update the registers */
; 2221 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  00aa0	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00aa8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00aae	83 e0 01	 and	 eax, 1
  00ab1	85 c0		 test	 eax, eax
  00ab3	74 7c		 je	 SHORT $LN52@z900_kmc_d
  00ab5	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00abd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00ac3	83 e0 01	 and	 eax, 1
  00ac6	85 c0		 test	 eax, eax
  00ac8	74 22		 je	 SHORT $LN95@z900_kmc_d
  00aca	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00ad2	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ada	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00ae2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv554[rsp], rax
  00aea	eb 1f		 jmp	 SHORT $LN96@z900_kmc_d
$LN95@z900_kmc_d:
  00aec	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00af4	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00afc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00b03	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv554[rsp], rax
$LN96@z900_kmc_d:
  00b0b	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv554[rsp]
  00b13	48 83 c0 08	 add	 rax, 8
  00b17	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00b1f	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00b27	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00b2f	eb 79		 jmp	 SHORT $LN53@z900_kmc_d
$LN52@z900_kmc_d:
  00b31	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b39	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00b3f	83 e0 01	 and	 eax, 1
  00b42	85 c0		 test	 eax, eax
  00b44	74 22		 je	 SHORT $LN97@z900_kmc_d
  00b46	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00b4e	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b56	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00b5e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv575[rsp], rax
  00b66	eb 1f		 jmp	 SHORT $LN98@z900_kmc_d
$LN97@z900_kmc_d:
  00b68	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00b70	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00b78	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00b7f	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv575[rsp], rax
$LN98@z900_kmc_d:
  00b87	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv575[rsp]
  00b8f	48 83 c0 08	 add	 rax, 8
  00b93	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00b9b	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00ba3	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN53@z900_kmc_d:
  00baa	33 c0		 xor	 eax, eax
  00bac	85 c0		 test	 eax, eax
  00bae	0f 85 ec fe ff
	ff		 jne	 $LN29@z900_kmc_d

; 2222 :     if(likely(r1_is_not_r2))

  00bb4	83 7c 24 78 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00bb9	74 0a		 je	 SHORT $LN99@z900_kmc_d
  00bbb	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv580[rsp], 1
  00bc3	eb 08		 jmp	 SHORT $LN100@z900_kmc_d
$LN99@z900_kmc_d:
  00bc5	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv580[rsp], 0
$LN100@z900_kmc_d:
  00bcd	83 7c 24 6c 00	 cmp	 DWORD PTR tv580[rsp], 0
  00bd2	0f 84 14 01 00
	00		 je	 $LN54@z900_kmc_d
$LN32@z900_kmc_d:

; 2223 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  00bd8	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00be0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00be6	83 e0 01	 and	 eax, 1
  00be9	85 c0		 test	 eax, eax
  00beb	74 7c		 je	 SHORT $LN55@z900_kmc_d
  00bed	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00bf5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00bfb	83 e0 01	 and	 eax, 1
  00bfe	85 c0		 test	 eax, eax
  00c00	74 22		 je	 SHORT $LN101@z900_kmc_d
  00c02	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00c0a	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c12	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00c1a	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv604[rsp], rax
  00c22	eb 1f		 jmp	 SHORT $LN102@z900_kmc_d
$LN101@z900_kmc_d:
  00c24	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00c2c	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c34	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00c3b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv604[rsp], rax
$LN102@z900_kmc_d:
  00c43	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv604[rsp]
  00c4b	48 83 c0 08	 add	 rax, 8
  00c4f	48 63 8c 24 08
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00c57	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00c5f	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00c67	eb 79		 jmp	 SHORT $LN56@z900_kmc_d
$LN55@z900_kmc_d:
  00c69	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00c71	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00c77	83 e0 01	 and	 eax, 1
  00c7a	85 c0		 test	 eax, eax
  00c7c	74 22		 je	 SHORT $LN103@z900_kmc_d
  00c7e	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00c86	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c8e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00c96	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv625[rsp], rax
  00c9e	eb 1f		 jmp	 SHORT $LN104@z900_kmc_d
$LN103@z900_kmc_d:
  00ca0	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00ca8	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00cb0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00cb7	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv625[rsp], rax
$LN104@z900_kmc_d:
  00cbf	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv625[rsp]
  00cc7	48 83 c0 08	 add	 rax, 8
  00ccb	48 63 8c 24 08
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00cd3	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00cdb	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN56@z900_kmc_d:
  00ce2	33 c0		 xor	 eax, eax
  00ce4	85 c0		 test	 eax, eax
  00ce6	0f 85 ec fe ff
	ff		 jne	 $LN32@z900_kmc_d
$LN54@z900_kmc_d:
$LN35@z900_kmc_d:

; 2224 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  00cec	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00cf4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00cfa	83 e0 01	 and	 eax, 1
  00cfd	85 c0		 test	 eax, eax
  00cff	0f 84 89 00 00
	00		 je	 $LN57@z900_kmc_d
  00d05	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d0d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00d13	83 e0 01	 and	 eax, 1
  00d16	85 c0		 test	 eax, eax
  00d18	74 25		 je	 SHORT $LN105@z900_kmc_d
  00d1a	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00d21	ff c0		 inc	 eax
  00d23	48 98		 cdqe
  00d25	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d2d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00d35	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv654[rsp], rax
  00d3d	eb 22		 jmp	 SHORT $LN106@z900_kmc_d
$LN105@z900_kmc_d:
  00d3f	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00d46	ff c0		 inc	 eax
  00d48	48 98		 cdqe
  00d4a	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d52	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00d59	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv654[rsp], rax
$LN106@z900_kmc_d:
  00d61	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv654[rsp]
  00d69	48 83 e8 08	 sub	 rax, 8
  00d6d	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00d74	ff c1		 inc	 ecx
  00d76	48 63 c9	 movsxd	 rcx, ecx
  00d79	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00d81	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00d89	e9 83 00 00 00	 jmp	 $LN58@z900_kmc_d
$LN57@z900_kmc_d:
  00d8e	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00d96	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00d9c	83 e0 01	 and	 eax, 1
  00d9f	85 c0		 test	 eax, eax
  00da1	74 25		 je	 SHORT $LN107@z900_kmc_d
  00da3	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00daa	ff c0		 inc	 eax
  00dac	48 98		 cdqe
  00dae	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00db6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00dbe	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv678[rsp], rax
  00dc6	eb 22		 jmp	 SHORT $LN108@z900_kmc_d
$LN107@z900_kmc_d:
  00dc8	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00dcf	ff c0		 inc	 eax
  00dd1	48 98		 cdqe
  00dd3	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00ddb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00de2	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv678[rsp], rax
$LN108@z900_kmc_d:
  00dea	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv678[rsp]
  00df2	48 83 e8 08	 sub	 rax, 8
  00df6	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00dfd	ff c1		 inc	 ecx
  00dff	48 63 c9	 movsxd	 rcx, ecx
  00e02	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00e0a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN58@z900_kmc_d:
  00e11	33 c0		 xor	 eax, eax
  00e13	85 c0		 test	 eax, eax
  00e15	0f 85 d1 fe ff
	ff		 jne	 $LN35@z900_kmc_d

; 2225 : 
; 2226 : #ifdef OPTION_KMC_DEBUG
; 2227 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2228 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2229 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2230 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2231 : 
; 2232 :     /* check for end of data */
; 2233 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00e1b	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00e23	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00e29	83 e0 01	 and	 eax, 1
  00e2c	85 c0		 test	 eax, eax
  00e2e	74 25		 je	 SHORT $LN109@z900_kmc_d
  00e30	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00e37	ff c0		 inc	 eax
  00e39	48 98		 cdqe
  00e3b	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e43	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00e4b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv698[rsp], rax
  00e53	eb 22		 jmp	 SHORT $LN110@z900_kmc_d
$LN109@z900_kmc_d:
  00e55	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00e5c	ff c0		 inc	 eax
  00e5e	48 98		 cdqe
  00e60	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e68	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00e6f	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv698[rsp], rax
$LN110@z900_kmc_d:
  00e77	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR tv698[rsp], 0
  00e80	75 0a		 jne	 SHORT $LN111@z900_kmc_d
  00e82	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv700[rsp], 1
  00e8a	eb 08		 jmp	 SHORT $LN112@z900_kmc_d
$LN111@z900_kmc_d:
  00e8c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv700[rsp], 0
$LN112@z900_kmc_d:
  00e94	83 7c 24 70 00	 cmp	 DWORD PTR tv700[rsp], 0
  00e99	74 0a		 je	 SHORT $LN117@z900_kmc_d
  00e9b	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv721[rsp], 1
  00ea3	eb 08		 jmp	 SHORT $LN118@z900_kmc_d
$LN117@z900_kmc_d:
  00ea5	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv721[rsp], 0
$LN118@z900_kmc_d:
  00ead	83 7c 24 74 00	 cmp	 DWORD PTR tv721[rsp], 0
  00eb2	74 0e		 je	 SHORT $LN59@z900_kmc_d

; 2234 :     {
; 2235 :       regs->psw.cc = 0;

  00eb4	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00ebc	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2236 :       return;

  00ec0	eb 21		 jmp	 SHORT $LN1@z900_kmc_d
$LN59@z900_kmc_d:

; 2237 :     }
; 2238 : 
; 2239 :     /* Set cv for next 8 bytes */
; 2240 :     memcpy(parameter_block, ocv, 8);

  00ec2	48 8b 84 24 a8
	02 00 00	 mov	 rax, QWORD PTR ocv$[rsp]
  00eca	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR parameter_block$[rsp], rax

; 2241 :   }

  00ed2	e9 f1 f5 ff ff	 jmp	 $LN4@z900_kmc_d
$LN5@z900_kmc_d:

; 2242 : 
; 2243 :   /* CPU-determined amount of data processed */
; 2244 :   regs->psw.cc = 3;

  00ed7	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00edf	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmc_d:

; 2245 : }

  00ee3	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00eeb	48 33 cc	 xor	 rcx, rsp
  00eee	e8 00 00 00 00	 call	 __security_check_cookie
  00ef3	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  00efa	c3		 ret	 0
z900_kmc_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv136 = 64
tv158 = 68
tv179 = 72
tv194 = 76
wrap$ = 80
tv437 = 84
tv458 = 88
tfc$ = 92
tv81 = 96
tv156 = 104
tv217 = 112
tv235 = 120
tv275 = 128
tv313 = 136
tv341 = 144
tv362 = 152
tv391 = 160
tv415 = 168
tv435 = 176
context$ = 192
message_block$ = 688
parameter_block$ = 704
__$ArrayPad$ = 784
r1$ = 816
r2$ = 824
regs$ = 832
z900_kmac_aes PROC

; 1906 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 28 03
	00 00		 sub	 rsp, 808		; 00000328H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_kmac_:

; 1907 :   rijndael_ctx context;
; 1908 :   int crypted;
; 1909 :   int i;
; 1910 :   int keylen;
; 1911 :   BYTE message_block[16];
; 1912 :   BYTE parameter_block[80];
; 1913 :   int parameter_blocklen;
; 1914 :   int tfc;
; 1915 :   int wrap;
; 1916 : 
; 1917 :   UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@z900_kmac_

; 1918 : 
; 1919 :   /* Check special conditions */
; 1920 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  0002c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00034	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0003a	83 e0 01	 and	 eax, 1
  0003d	85 c0		 test	 eax, eax
  0003f	74 22		 je	 SHORT $LN27@z900_kmac_
  00041	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00048	ff c0		 inc	 eax
  0004a	48 98		 cdqe
  0004c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005c	48 89 44 24 60	 mov	 QWORD PTR tv81[rsp], rax
  00061	eb 1f		 jmp	 SHORT $LN28@z900_kmac_
$LN27@z900_kmac_:
  00063	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007d	48 89 44 24 60	 mov	 QWORD PTR tv81[rsp], rax
$LN28@z900_kmac_:
  00082	33 d2		 xor	 edx, edx
  00084	48 8b 44 24 60	 mov	 rax, QWORD PTR tv81[rsp]
  00089	b9 10 00 00 00	 mov	 ecx, 16
  0008e	48 f7 f1	 div	 rcx
  00091	48 8b c2	 mov	 rax, rdx
  00094	48 85 c0	 test	 rax, rax
  00097	74 0a		 je	 SHORT $LN33@z900_kmac_
  00099	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000a1	eb 08		 jmp	 SHORT $LN34@z900_kmac_
$LN33@z900_kmac_:
  000a3	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN34@z900_kmac_:
  000ab	83 7c 24 40 00	 cmp	 DWORD PTR tv136[rsp], 0
  000b0	74 13		 je	 SHORT $LN17@z900_kmac_

; 1921 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000b2	ba 06 00 00 00	 mov	 edx, 6
  000b7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN17@z900_kmac_:

; 1922 : 
; 1923 :   /* Return with cc 0 on zero length */
; 1924 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000c5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d3	83 e0 01	 and	 eax, 1
  000d6	85 c0		 test	 eax, eax
  000d8	74 22		 je	 SHORT $LN35@z900_kmac_
  000da	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000e1	ff c0		 inc	 eax
  000e3	48 98		 cdqe
  000e5	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f5	48 89 44 24 68	 mov	 QWORD PTR tv156[rsp], rax
  000fa	eb 1f		 jmp	 SHORT $LN36@z900_kmac_
$LN35@z900_kmac_:
  000fc	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00103	ff c0		 inc	 eax
  00105	48 98		 cdqe
  00107	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 68	 mov	 QWORD PTR tv156[rsp], rax
$LN36@z900_kmac_:
  0011b	48 83 7c 24 68
	00		 cmp	 QWORD PTR tv156[rsp], 0
  00121	75 0a		 jne	 SHORT $LN37@z900_kmac_
  00123	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv158[rsp], 1
  0012b	eb 08		 jmp	 SHORT $LN38@z900_kmac_
$LN37@z900_kmac_:
  0012d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN38@z900_kmac_:
  00135	83 7c 24 44 00	 cmp	 DWORD PTR tv158[rsp], 0
  0013a	74 0a		 je	 SHORT $LN43@z900_kmac_
  0013c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  00144	eb 08		 jmp	 SHORT $LN44@z900_kmac_
$LN43@z900_kmac_:
  00146	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN44@z900_kmac_:
  0014e	83 7c 24 48 00	 cmp	 DWORD PTR tv179[rsp], 0
  00153	74 11		 je	 SHORT $LN18@z900_kmac_

; 1925 :   {
; 1926 :     regs->psw.cc = 0;

  00155	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1927 :     return;

  00161	e9 c9 06 00 00	 jmp	 $LN1@z900_kmac_
$LN18@z900_kmac_:

; 1928 :   }
; 1929 : 
; 1930 :   /* Initialize values */
; 1931 :   tfc = GR0_tfc(regs);

  00166	b8 08 00 00 00	 mov	 eax, 8
  0016b	48 6b c0 00	 imul	 rax, rax, 0
  0016f	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00181	83 e0 77	 and	 eax, 119		; 00000077H
  00184	89 44 24 5c	 mov	 DWORD PTR tfc$[rsp], eax

; 1932 :   wrap = GR0_wrap(regs);

  00188	b8 08 00 00 00	 mov	 eax, 8
  0018d	48 6b c0 00	 imul	 rax, rax, 0
  00191	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a0	83 e0 08	 and	 eax, 8
  001a3	85 c0		 test	 eax, eax
  001a5	74 0a		 je	 SHORT $LN45@z900_kmac_
  001a7	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN46@z900_kmac_
$LN45@z900_kmac_:
  001b1	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN46@z900_kmac_:
  001b9	8b 44 24 4c	 mov	 eax, DWORD PTR tv194[rsp]
  001bd	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 1933 :   keylen = (tfc - 17) * 8 + 8;

  001c1	8b 44 24 5c	 mov	 eax, DWORD PTR tfc$[rsp]
  001c5	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  001cc	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 1934 :   parameter_blocklen = keylen + 16;

  001d0	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  001d4	83 c0 10	 add	 eax, 16
  001d7	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1935 :   if(wrap)

  001db	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001e0	74 0b		 je	 SHORT $LN19@z900_kmac_

; 1936 :     parameter_blocklen += 32;

  001e2	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001e6	83 c0 20	 add	 eax, 32			; 00000020H
  001e9	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN19@z900_kmac_:

; 1937 : 
; 1938 :   /* Test writeability output chaining value */
; 1939 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  001ed	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001fb	83 e0 01	 and	 eax, 1
  001fe	85 c0		 test	 eax, eax
  00200	74 20		 je	 SHORT $LN47@z900_kmac_
  00202	b8 08 00 00 00	 mov	 eax, 8
  00207	48 6b c0 01	 imul	 rax, rax, 1
  0020b	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00213	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0021b	48 89 44 24 70	 mov	 QWORD PTR tv217[rsp], rax
  00220	eb 1d		 jmp	 SHORT $LN48@z900_kmac_
$LN47@z900_kmac_:
  00222	b8 08 00 00 00	 mov	 eax, 8
  00227	48 6b c0 01	 imul	 rax, rax, 1
  0022b	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00233	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0023a	48 89 44 24 70	 mov	 QWORD PTR tv217[rsp], rax
$LN48@z900_kmac_:
  0023f	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0024e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv217[rsp]
  00253	48 23 c8	 and	 rcx, rax
  00256	48 8b c1	 mov	 rax, rcx
  00259	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00261	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00266	41 b9 02 00 00
	00		 mov	 r9d, 2
  0026c	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00272	ba 01 00 00 00	 mov	 edx, 1
  00277	48 8b c8	 mov	 rcx, rax
  0027a	e8 00 00 00 00	 call	 z900_validate_operand

; 1940 : 
; 1941 :   /* Fetch the parameter block */
; 1942 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0027f	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00287	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0028d	83 e0 01	 and	 eax, 1
  00290	85 c0		 test	 eax, eax
  00292	74 20		 je	 SHORT $LN49@z900_kmac_
  00294	b8 08 00 00 00	 mov	 eax, 8
  00299	48 6b c0 01	 imul	 rax, rax, 1
  0029d	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a5	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002ad	48 89 44 24 78	 mov	 QWORD PTR tv235[rsp], rax
  002b2	eb 1d		 jmp	 SHORT $LN50@z900_kmac_
$LN49@z900_kmac_:
  002b4	b8 08 00 00 00	 mov	 eax, 8
  002b9	48 6b c0 01	 imul	 rax, rax, 1
  002bd	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c5	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002cc	48 89 44 24 78	 mov	 QWORD PTR tv235[rsp], rax
$LN50@z900_kmac_:
  002d1	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d9	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002e0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv235[rsp]
  002e5	48 23 c8	 and	 rcx, rax
  002e8	48 8b c1	 mov	 rax, rcx
  002eb	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  002ef	ff c9		 dec	 ecx
  002f1	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002f9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002fe	41 b9 01 00 00
	00		 mov	 r9d, 1
  00304	4c 8b c0	 mov	 r8, rax
  00307	0f b6 d1	 movzx	 edx, cl
  0030a	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00312	e8 00 00 00 00	 call	 z900_vfetchc

; 1943 : 
; 1944 : #ifdef OPTION_KMAC_DEBUG
; 1945 :   LOGBYTE("icv   :", parameter_block, 16);
; 1946 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 1947 :   if(wrap)
; 1948 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 16], 32);
; 1949 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1950 : 
; 1951 :   /* Verify and unwrap */
; 1952 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  00317	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0031c	74 32		 je	 SHORT $LN20@z900_kmac_
  0031e	b8 01 00 00 00	 mov	 eax, 1
  00323	48 6b c0 10	 imul	 rax, rax, 16
  00327	48 8d 84 04 c0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0032f	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  00333	48 8b c8	 mov	 rcx, rax
  00336	e8 00 00 00 00	 call	 unwrap_aes
  0033b	85 c0		 test	 eax, eax
  0033d	74 11		 je	 SHORT $LN20@z900_kmac_

; 1953 :   {
; 1954 : 
; 1955 : #ifdef OPTION_KMAC_DEBUG
; 1956 :     WRMSG(HHC90111, "D");
; 1957 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1958 : 
; 1959 :     regs->psw.cc = 1;

  0033f	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00347	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1960 :     return;

  0034b	e9 df 04 00 00	 jmp	 $LN1@z900_kmac_
$LN20@z900_kmac_:

; 1961 :   }
; 1962 : 
; 1963 :   /* Set the cryptographic key */
; 1964 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  00350	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00354	c1 e0 03	 shl	 eax, 3
  00357	b9 01 00 00 00	 mov	 ecx, 1
  0035c	48 6b c9 10	 imul	 rcx, rcx, 16
  00360	48 8d 8c 0c c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00368	44 8b c0	 mov	 r8d, eax
  0036b	48 8b d1	 mov	 rdx, rcx
  0036e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00376	e8 00 00 00 00	 call	 rijndael_set_key

; 1965 : 
; 1966 :   /* Try to process the CPU-determined amount of data */
; 1967 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  0037b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00383	eb 0b		 jmp	 SHORT $LN7@z900_kmac_
$LN5@z900_kmac_:
  00385	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00389	83 c0 10	 add	 eax, 16
  0038c	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN7@z900_kmac_:
  00390	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00398	0f 8d 85 04 00
	00		 jge	 $LN6@z900_kmac_

; 1968 :   {
; 1969 :     /* Fetch a block of data */
; 1970 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0039e	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003ac	83 e0 01	 and	 eax, 1
  003af	85 c0		 test	 eax, eax
  003b1	74 22		 je	 SHORT $LN51@z900_kmac_
  003b3	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003bb	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c3	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003cb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
  003d3	eb 1f		 jmp	 SHORT $LN52@z900_kmac_
$LN51@z900_kmac_:
  003d5	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003dd	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003ec	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv275[rsp], rax
$LN52@z900_kmac_:
  003f4	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003fc	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00403	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv275[rsp]
  0040b	48 23 c8	 and	 rcx, rax
  0040e	48 8b c1	 mov	 rax, rcx
  00411	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00419	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0041e	44 8b 8c 24 38
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00426	4c 8b c0	 mov	 r8, rax
  00429	b2 0f		 mov	 dl, 15
  0042b	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00433	e8 00 00 00 00	 call	 z900_vfetchc

; 1971 : 
; 1972 : #ifdef OPTION_KMAC_DEBUG
; 1973 :     LOGBYTE("input :", message_block, 16);
; 1974 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1975 : 
; 1976 :     /* XOR the message with chaining value */
; 1977 :     for(i = 0; i < 16; i++)

  00438	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00440	eb 0a		 jmp	 SHORT $LN10@z900_kmac_
$LN8@z900_kmac_:
  00442	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00446	ff c0		 inc	 eax
  00448	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_kmac_:
  0044c	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00451	7d 2a		 jge	 SHORT $LN9@z900_kmac_

; 1978 :       message_block[i] ^= parameter_block[i];

  00453	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00458	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0045d	0f b6 8c 0c c0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00465	0f b6 84 04 b0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0046d	33 c1		 xor	 eax, ecx
  0046f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00474	88 84 0c b0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0047b	eb c5		 jmp	 SHORT $LN8@z900_kmac_
$LN9@z900_kmac_:

; 1979 : 
; 1980 :     /* Calculate the output chaining value */
; 1981 :     rijndael_encrypt(&context, message_block, parameter_block);

  0047d	4c 8d 84 24 c0
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00485	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0048d	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00495	e8 00 00 00 00	 call	 rijndael_encrypt

; 1982 : 
; 1983 :     /* Store the output chaining value */
; 1984 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0049a	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004a2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004a8	83 e0 01	 and	 eax, 1
  004ab	85 c0		 test	 eax, eax
  004ad	74 23		 je	 SHORT $LN53@z900_kmac_
  004af	b8 08 00 00 00	 mov	 eax, 8
  004b4	48 6b c0 01	 imul	 rax, rax, 1
  004b8	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c0	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  004c8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv313[rsp], rax
  004d0	eb 20		 jmp	 SHORT $LN54@z900_kmac_
$LN53@z900_kmac_:
  004d2	b8 08 00 00 00	 mov	 eax, 8
  004d7	48 6b c0 01	 imul	 rax, rax, 1
  004db	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004ea	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv313[rsp], rax
$LN54@z900_kmac_:
  004f2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004fa	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00501	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv313[rsp]
  00509	48 23 c8	 and	 rcx, rax
  0050c	48 8b c1	 mov	 rax, rcx
  0050f	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00517	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0051c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00522	4c 8b c0	 mov	 r8, rax
  00525	b2 0f		 mov	 dl, 15
  00527	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0052f	e8 00 00 00 00	 call	 z900_vstorec
$LN13@z900_kmac_:

; 1985 : 
; 1986 : #ifdef OPTION_KMAC_DEBUG
; 1987 :     LOGBYTE("ocv   :", parameter_block, 16);
; 1988 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1989 : 
; 1990 :     /* Update the registers */
; 1991 :     SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  00534	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00542	83 e0 01	 and	 eax, 1
  00545	85 c0		 test	 eax, eax
  00547	74 7c		 je	 SHORT $LN21@z900_kmac_
  00549	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00551	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00557	83 e0 01	 and	 eax, 1
  0055a	85 c0		 test	 eax, eax
  0055c	74 22		 je	 SHORT $LN55@z900_kmac_
  0055e	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00566	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00576	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv341[rsp], rax
  0057e	eb 1f		 jmp	 SHORT $LN56@z900_kmac_
$LN55@z900_kmac_:
  00580	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00588	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00590	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00597	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv341[rsp], rax
$LN56@z900_kmac_:
  0059f	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv341[rsp]
  005a7	48 83 c0 10	 add	 rax, 16
  005ab	48 63 8c 24 38
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  005b3	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005bb	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  005c3	eb 79		 jmp	 SHORT $LN22@z900_kmac_
$LN21@z900_kmac_:
  005c5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005cd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005d3	83 e0 01	 and	 eax, 1
  005d6	85 c0		 test	 eax, eax
  005d8	74 22		 je	 SHORT $LN57@z900_kmac_
  005da	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005e2	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ea	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  005f2	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv362[rsp], rax
  005fa	eb 1f		 jmp	 SHORT $LN58@z900_kmac_
$LN57@z900_kmac_:
  005fc	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00604	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0060c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00613	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv362[rsp], rax
$LN58@z900_kmac_:
  0061b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv362[rsp]
  00623	48 83 c0 10	 add	 rax, 16
  00627	48 63 8c 24 38
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0062f	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00637	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN22@z900_kmac_:
  0063e	33 c0		 xor	 eax, eax
  00640	85 c0		 test	 eax, eax
  00642	0f 85 ec fe ff
	ff		 jne	 $LN13@z900_kmac_
$LN16@z900_kmac_:

; 1992 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00648	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00650	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00656	83 e0 01	 and	 eax, 1
  00659	85 c0		 test	 eax, eax
  0065b	0f 84 89 00 00
	00		 je	 $LN23@z900_kmac_
  00661	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00669	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0066f	83 e0 01	 and	 eax, 1
  00672	85 c0		 test	 eax, eax
  00674	74 25		 je	 SHORT $LN59@z900_kmac_
  00676	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0067d	ff c0		 inc	 eax
  0067f	48 98		 cdqe
  00681	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00689	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00691	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv391[rsp], rax
  00699	eb 22		 jmp	 SHORT $LN60@z900_kmac_
$LN59@z900_kmac_:
  0069b	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  006a2	ff c0		 inc	 eax
  006a4	48 98		 cdqe
  006a6	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006ae	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006b5	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv391[rsp], rax
$LN60@z900_kmac_:
  006bd	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv391[rsp]
  006c5	48 83 e8 10	 sub	 rax, 16
  006c9	8b 8c 24 38 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  006d0	ff c1		 inc	 ecx
  006d2	48 63 c9	 movsxd	 rcx, ecx
  006d5	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006dd	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  006e5	e9 83 00 00 00	 jmp	 $LN24@z900_kmac_
$LN23@z900_kmac_:
  006ea	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f2	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006f8	83 e0 01	 and	 eax, 1
  006fb	85 c0		 test	 eax, eax
  006fd	74 25		 je	 SHORT $LN61@z900_kmac_
  006ff	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00706	ff c0		 inc	 eax
  00708	48 98		 cdqe
  0070a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00712	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0071a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv415[rsp], rax
  00722	eb 22		 jmp	 SHORT $LN62@z900_kmac_
$LN61@z900_kmac_:
  00724	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0072b	ff c0		 inc	 eax
  0072d	48 98		 cdqe
  0072f	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00737	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0073e	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv415[rsp], rax
$LN62@z900_kmac_:
  00746	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv415[rsp]
  0074e	48 83 e8 10	 sub	 rax, 16
  00752	8b 8c 24 38 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00759	ff c1		 inc	 ecx
  0075b	48 63 c9	 movsxd	 rcx, ecx
  0075e	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00766	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN24@z900_kmac_:
  0076d	33 c0		 xor	 eax, eax
  0076f	85 c0		 test	 eax, eax
  00771	0f 85 d1 fe ff
	ff		 jne	 $LN16@z900_kmac_

; 1993 : 
; 1994 : #ifdef OPTION_KMAC_DEBUG
; 1995 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1996 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1997 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1998 : 
; 1999 :     /* check for end of data */
; 2000 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00777	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0077f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00785	83 e0 01	 and	 eax, 1
  00788	85 c0		 test	 eax, eax
  0078a	74 25		 je	 SHORT $LN63@z900_kmac_
  0078c	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00793	ff c0		 inc	 eax
  00795	48 98		 cdqe
  00797	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007a7	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv435[rsp], rax
  007af	eb 22		 jmp	 SHORT $LN64@z900_kmac_
$LN63@z900_kmac_:
  007b1	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  007b8	ff c0		 inc	 eax
  007ba	48 98		 cdqe
  007bc	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007cb	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv435[rsp], rax
$LN64@z900_kmac_:
  007d3	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR tv435[rsp], 0
  007dc	75 0a		 jne	 SHORT $LN65@z900_kmac_
  007de	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv437[rsp], 1
  007e6	eb 08		 jmp	 SHORT $LN66@z900_kmac_
$LN65@z900_kmac_:
  007e8	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv437[rsp], 0
$LN66@z900_kmac_:
  007f0	83 7c 24 54 00	 cmp	 DWORD PTR tv437[rsp], 0
  007f5	74 0a		 je	 SHORT $LN71@z900_kmac_
  007f7	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv458[rsp], 1
  007ff	eb 08		 jmp	 SHORT $LN72@z900_kmac_
$LN71@z900_kmac_:
  00801	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv458[rsp], 0
$LN72@z900_kmac_:
  00809	83 7c 24 58 00	 cmp	 DWORD PTR tv458[rsp], 0
  0080e	74 0e		 je	 SHORT $LN25@z900_kmac_

; 2001 :     {
; 2002 :       regs->psw.cc = 0;

  00810	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00818	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2003 :       return;

  0081c	eb 11		 jmp	 SHORT $LN1@z900_kmac_
$LN25@z900_kmac_:

; 2004 :     }
; 2005 :   }

  0081e	e9 62 fb ff ff	 jmp	 $LN5@z900_kmac_
$LN6@z900_kmac_:

; 2006 : 
; 2007 :   /* CPU-determined amount of data processed */
; 2008 :   regs->psw.cc = 3;

  00823	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0082b	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmac_:

; 2009 : }

  0082f	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00837	48 33 cc	 xor	 rcx, rsp
  0083a	e8 00 00 00 00	 call	 __security_check_cookie
  0083f	48 81 c4 28 03
	00 00		 add	 rsp, 808		; 00000328H
  00846	c3		 ret	 0
z900_kmac_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv249 = 56
crypted$ = 60
tfc$ = 64
tv316 = 68
tv136 = 72
tv158 = 76
tv179 = 80
tv194 = 84
wrap$ = 88
keylen$ = 92
tv479 = 96
tv500 = 100
tv81 = 104
tv156 = 112
tv215 = 120
tv233 = 128
tv295 = 136
tv355 = 144
tv383 = 152
tv404 = 160
tv433 = 168
tv457 = 176
tv477 = 184
context1$ = 192
context2$ = 336
context3$ = 480
message_block$ = 624
parameter_block$ = 632
__$ArrayPad$ = 688
r1$ = 720
r2$ = 728
regs$ = 736
z900_kmac_dea PROC

; 1731 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_kmac_:

; 1732 :   des_context context1;
; 1733 :   des_context context2;
; 1734 :   des_context context3;
; 1735 :   int crypted;
; 1736 :   int i;
; 1737 :   int keylen;
; 1738 :   BYTE message_block[8];
; 1739 :   BYTE parameter_block[56];
; 1740 :   int parameter_blocklen;
; 1741 :   int tfc;
; 1742 :   int wrap;
; 1743 : 
; 1744 :   UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@z900_kmac_

; 1745 : 
; 1746 :   /* Check special conditions */
; 1747 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  0002c	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00034	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0003a	83 e0 01	 and	 eax, 1
  0003d	85 c0		 test	 eax, eax
  0003f	74 22		 je	 SHORT $LN37@z900_kmac_
  00041	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00048	ff c0		 inc	 eax
  0004a	48 98		 cdqe
  0004c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005c	48 89 44 24 68	 mov	 QWORD PTR tv81[rsp], rax
  00061	eb 1f		 jmp	 SHORT $LN38@z900_kmac_
$LN37@z900_kmac_:
  00063	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007d	48 89 44 24 68	 mov	 QWORD PTR tv81[rsp], rax
$LN38@z900_kmac_:
  00082	33 d2		 xor	 edx, edx
  00084	48 8b 44 24 68	 mov	 rax, QWORD PTR tv81[rsp]
  00089	b9 08 00 00 00	 mov	 ecx, 8
  0008e	48 f7 f1	 div	 rcx
  00091	48 8b c2	 mov	 rax, rdx
  00094	48 85 c0	 test	 rax, rax
  00097	74 0a		 je	 SHORT $LN43@z900_kmac_
  00099	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000a1	eb 08		 jmp	 SHORT $LN44@z900_kmac_
$LN43@z900_kmac_:
  000a3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN44@z900_kmac_:
  000ab	83 7c 24 48 00	 cmp	 DWORD PTR tv136[rsp], 0
  000b0	74 13		 je	 SHORT $LN21@z900_kmac_

; 1748 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000b2	ba 06 00 00 00	 mov	 edx, 6
  000b7	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN21@z900_kmac_:

; 1749 : 
; 1750 :   /* Return with cc 0 on zero length */
; 1751 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000c5	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d3	83 e0 01	 and	 eax, 1
  000d6	85 c0		 test	 eax, eax
  000d8	74 22		 je	 SHORT $LN45@z900_kmac_
  000da	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000e1	ff c0		 inc	 eax
  000e3	48 98		 cdqe
  000e5	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f5	48 89 44 24 70	 mov	 QWORD PTR tv156[rsp], rax
  000fa	eb 1f		 jmp	 SHORT $LN46@z900_kmac_
$LN45@z900_kmac_:
  000fc	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00103	ff c0		 inc	 eax
  00105	48 98		 cdqe
  00107	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 70	 mov	 QWORD PTR tv156[rsp], rax
$LN46@z900_kmac_:
  0011b	48 83 7c 24 70
	00		 cmp	 QWORD PTR tv156[rsp], 0
  00121	75 0a		 jne	 SHORT $LN47@z900_kmac_
  00123	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv158[rsp], 1
  0012b	eb 08		 jmp	 SHORT $LN48@z900_kmac_
$LN47@z900_kmac_:
  0012d	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN48@z900_kmac_:
  00135	83 7c 24 4c 00	 cmp	 DWORD PTR tv158[rsp], 0
  0013a	74 0a		 je	 SHORT $LN53@z900_kmac_
  0013c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  00144	eb 08		 jmp	 SHORT $LN54@z900_kmac_
$LN53@z900_kmac_:
  00146	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN54@z900_kmac_:
  0014e	83 7c 24 50 00	 cmp	 DWORD PTR tv179[rsp], 0
  00153	74 11		 je	 SHORT $LN22@z900_kmac_

; 1752 :   {
; 1753 :     regs->psw.cc = 0;

  00155	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1754 :     return;

  00161	e9 6d 08 00 00	 jmp	 $LN1@z900_kmac_
$LN22@z900_kmac_:

; 1755 :   }
; 1756 : 
; 1757 :   /* Initialize values */
; 1758 :   tfc = GR0_tfc(regs);

  00166	b8 08 00 00 00	 mov	 eax, 8
  0016b	48 6b c0 00	 imul	 rax, rax, 0
  0016f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00177	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00181	83 e0 77	 and	 eax, 119		; 00000077H
  00184	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 1759 :   wrap = GR0_wrap(regs);

  00188	b8 08 00 00 00	 mov	 eax, 8
  0018d	48 6b c0 00	 imul	 rax, rax, 0
  00191	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a0	83 e0 08	 and	 eax, 8
  001a3	85 c0		 test	 eax, eax
  001a5	74 0a		 je	 SHORT $LN55@z900_kmac_
  001a7	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  001af	eb 08		 jmp	 SHORT $LN56@z900_kmac_
$LN55@z900_kmac_:
  001b1	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN56@z900_kmac_:
  001b9	8b 44 24 54	 mov	 eax, DWORD PTR tv194[rsp]
  001bd	89 44 24 58	 mov	 DWORD PTR wrap$[rsp], eax

; 1760 :   keylen = tfc * 8;

  001c1	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  001c5	c1 e0 03	 shl	 eax, 3
  001c8	89 44 24 5c	 mov	 DWORD PTR keylen$[rsp], eax

; 1761 :   parameter_blocklen = keylen + 8;

  001cc	8b 44 24 5c	 mov	 eax, DWORD PTR keylen$[rsp]
  001d0	83 c0 08	 add	 eax, 8
  001d3	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1762 :   if(wrap)

  001d7	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001dc	74 0b		 je	 SHORT $LN23@z900_kmac_

; 1763 :     parameter_blocklen += 24;

  001de	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001e2	83 c0 18	 add	 eax, 24
  001e5	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN23@z900_kmac_:

; 1764 : 
; 1765 :   /* Test writeability output chaining value */
; 1766 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  001e9	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001f7	83 e0 01	 and	 eax, 1
  001fa	85 c0		 test	 eax, eax
  001fc	74 20		 je	 SHORT $LN57@z900_kmac_
  001fe	b8 08 00 00 00	 mov	 eax, 8
  00203	48 6b c0 01	 imul	 rax, rax, 1
  00207	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00217	48 89 44 24 78	 mov	 QWORD PTR tv215[rsp], rax
  0021c	eb 1d		 jmp	 SHORT $LN58@z900_kmac_
$LN57@z900_kmac_:
  0021e	b8 08 00 00 00	 mov	 eax, 8
  00223	48 6b c0 01	 imul	 rax, rax, 1
  00227	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00236	48 89 44 24 78	 mov	 QWORD PTR tv215[rsp], rax
$LN58@z900_kmac_:
  0023b	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00243	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0024a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv215[rsp]
  0024f	48 23 c8	 and	 rcx, rax
  00252	48 8b c1	 mov	 rax, rcx
  00255	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00262	41 b9 02 00 00
	00		 mov	 r9d, 2
  00268	41 b8 07 00 00
	00		 mov	 r8d, 7
  0026e	ba 01 00 00 00	 mov	 edx, 1
  00273	48 8b c8	 mov	 rcx, rax
  00276	e8 00 00 00 00	 call	 z900_validate_operand

; 1767 : 
; 1768 :   /* Fetch the parameter block */
; 1769 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0027b	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00283	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00289	83 e0 01	 and	 eax, 1
  0028c	85 c0		 test	 eax, eax
  0028e	74 23		 je	 SHORT $LN59@z900_kmac_
  00290	b8 08 00 00 00	 mov	 eax, 8
  00295	48 6b c0 01	 imul	 rax, rax, 1
  00299	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a1	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002a9	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv233[rsp], rax
  002b1	eb 20		 jmp	 SHORT $LN60@z900_kmac_
$LN59@z900_kmac_:
  002b3	b8 08 00 00 00	 mov	 eax, 8
  002b8	48 6b c0 01	 imul	 rax, rax, 1
  002bc	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c4	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002cb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv233[rsp], rax
$LN60@z900_kmac_:
  002d3	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002db	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002e2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv233[rsp]
  002ea	48 23 c8	 and	 rcx, rax
  002ed	48 8b c1	 mov	 rax, rcx
  002f0	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  002f4	ff c9		 dec	 ecx
  002f6	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002fe	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00303	41 b9 01 00 00
	00		 mov	 r9d, 1
  00309	4c 8b c0	 mov	 r8, rax
  0030c	0f b6 d1	 movzx	 edx, cl
  0030f	48 8d 8c 24 78
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00317	e8 00 00 00 00	 call	 z900_vfetchc

; 1770 : 
; 1771 : #ifdef OPTION_KMAC_DEBUG
; 1772 :   LOGBYTE("icv   :", parameter_block, 8);
; 1773 :   switch(tfc)
; 1774 :   {
; 1775 :     case 1: /* dea */
; 1776 :     {
; 1777 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1778 :       break;
; 1779 :     }
; 1780 :     case 2: /* tdea-128 */
; 1781 :     {
; 1782 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1783 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 1784 :       break;
; 1785 :     }
; 1786 :     case 3: /* tdea-192 */
; 1787 :     {
; 1788 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1789 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 1790 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 1791 :       break;
; 1792 :     }
; 1793 :   }
; 1794 :   if(wrap)
; 1795 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 1796 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1797 : 
; 1798 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1799 :   /* Verify and unwrap */
; 1800 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  0031c	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00321	74 32		 je	 SHORT $LN24@z900_kmac_
  00323	b8 01 00 00 00	 mov	 eax, 1
  00328	48 6b c0 08	 imul	 rax, rax, 8
  0032c	48 8d 84 04 78
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00334	8b 54 24 5c	 mov	 edx, DWORD PTR keylen$[rsp]
  00338	48 8b c8	 mov	 rcx, rax
  0033b	e8 00 00 00 00	 call	 unwrap_dea
  00340	85 c0		 test	 eax, eax
  00342	74 11		 je	 SHORT $LN24@z900_kmac_

; 1801 :   {
; 1802 : 
; 1803 : #ifdef OPTION_KM_DEBUG
; 1804 :     WRMSG(HHC90111, "D");
; 1805 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1806 : 
; 1807 :     regs->psw.cc = 1;

  00344	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0034c	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1808 :     return;

  00350	e9 7e 06 00 00	 jmp	 $LN1@z900_kmac_
$LN24@z900_kmac_:

; 1809 :   }
; 1810 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1811 : 
; 1812 :   /* Set the cryptographic key */
; 1813 :   switch(tfc)

  00355	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00359	89 44 24 38	 mov	 DWORD PTR tv249[rsp], eax
  0035d	83 7c 24 38 01	 cmp	 DWORD PTR tv249[rsp], 1
  00362	74 13		 je	 SHORT $LN25@z900_kmac_
  00364	83 7c 24 38 02	 cmp	 DWORD PTR tv249[rsp], 2
  00369	74 32		 je	 SHORT $LN26@z900_kmac_
  0036b	83 7c 24 38 03	 cmp	 DWORD PTR tv249[rsp], 3
  00370	74 6f		 je	 SHORT $LN27@z900_kmac_
  00372	e9 cd 00 00 00	 jmp	 $LN5@z900_kmac_
$LN25@z900_kmac_:

; 1814 :   {
; 1815 :     case 1: /* dea */
; 1816 :     {
; 1817 :       des_set_key(&context1, &parameter_block[8]);

  00377	b8 01 00 00 00	 mov	 eax, 1
  0037c	48 6b c0 08	 imul	 rax, rax, 8
  00380	48 8d 84 04 78
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00388	48 8b d0	 mov	 rdx, rax
  0038b	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00393	e8 00 00 00 00	 call	 des_set_key

; 1818 :       break;

  00398	e9 a7 00 00 00	 jmp	 $LN5@z900_kmac_
$LN26@z900_kmac_:

; 1819 :     }
; 1820 :     case 2: /* tdea-128 */
; 1821 :     {
; 1822 :       des_set_key(&context1, &parameter_block[8]);

  0039d	b8 01 00 00 00	 mov	 eax, 1
  003a2	48 6b c0 08	 imul	 rax, rax, 8
  003a6	48 8d 84 04 78
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003ae	48 8b d0	 mov	 rdx, rax
  003b1	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003b9	e8 00 00 00 00	 call	 des_set_key

; 1823 :       des_set_key(&context2, &parameter_block[16]);

  003be	b8 01 00 00 00	 mov	 eax, 1
  003c3	48 6b c0 10	 imul	 rax, rax, 16
  003c7	48 8d 84 04 78
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003cf	48 8b d0	 mov	 rdx, rax
  003d2	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  003da	e8 00 00 00 00	 call	 des_set_key

; 1824 :       break;

  003df	eb 63		 jmp	 SHORT $LN5@z900_kmac_
$LN27@z900_kmac_:

; 1825 :     }
; 1826 :     case 3: /* tdea-192 */
; 1827 :     {
; 1828 :       des_set_key(&context1, &parameter_block[8]);

  003e1	b8 01 00 00 00	 mov	 eax, 1
  003e6	48 6b c0 08	 imul	 rax, rax, 8
  003ea	48 8d 84 04 78
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  003f2	48 8b d0	 mov	 rdx, rax
  003f5	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003fd	e8 00 00 00 00	 call	 des_set_key

; 1829 :       des_set_key(&context2, &parameter_block[16]);

  00402	b8 01 00 00 00	 mov	 eax, 1
  00407	48 6b c0 10	 imul	 rax, rax, 16
  0040b	48 8d 84 04 78
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00413	48 8b d0	 mov	 rdx, rax
  00416	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0041e	e8 00 00 00 00	 call	 des_set_key

; 1830 :       des_set_key(&context3, &parameter_block[24]);

  00423	b8 01 00 00 00	 mov	 eax, 1
  00428	48 6b c0 18	 imul	 rax, rax, 24
  0042c	48 8d 84 04 78
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00434	48 8b d0	 mov	 rdx, rax
  00437	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0043f	e8 00 00 00 00	 call	 des_set_key
$LN5@z900_kmac_:

; 1831 :       break;
; 1832 :     }
; 1833 :   }
; 1834 : 
; 1835 :   /* Try to process the CPU-determined amount of data */
; 1836 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  00444	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0044c	eb 0b		 jmp	 SHORT $LN9@z900_kmac_
$LN7@z900_kmac_:
  0044e	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00452	83 c0 08	 add	 eax, 8
  00455	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN9@z900_kmac_:
  00459	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00461	0f 8d 60 05 00
	00		 jge	 $LN8@z900_kmac_

; 1837 :   {
; 1838 :     /* Fetch a block of data */
; 1839 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00467	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0046f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00475	83 e0 01	 and	 eax, 1
  00478	85 c0		 test	 eax, eax
  0047a	74 22		 je	 SHORT $LN61@z900_kmac_
  0047c	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00484	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00494	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv295[rsp], rax
  0049c	eb 1f		 jmp	 SHORT $LN62@z900_kmac_
$LN61@z900_kmac_:
  0049e	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004a6	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ae	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004b5	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv295[rsp], rax
$LN62@z900_kmac_:
  004bd	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  004cc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv295[rsp]
  004d4	48 23 c8	 and	 rcx, rax
  004d7	48 8b c1	 mov	 rax, rcx
  004da	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004e7	44 8b 8c 24 d8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  004ef	4c 8b c0	 mov	 r8, rax
  004f2	b2 07		 mov	 dl, 7
  004f4	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  004fc	e8 00 00 00 00	 call	 z900_vfetchc

; 1840 : 
; 1841 : #ifdef OPTION_KMAC_DEBUG
; 1842 :     LOGBYTE("input :", message_block, 8);
; 1843 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1844 : 
; 1845 :     /* XOR the message with chaining value */
; 1846 :     for(i = 0; i < 8; i++)

  00501	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00509	eb 0a		 jmp	 SHORT $LN12@z900_kmac_
$LN10@z900_kmac_:
  0050b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0050f	ff c0		 inc	 eax
  00511	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN12@z900_kmac_:
  00515	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0051a	7d 2a		 jge	 SHORT $LN11@z900_kmac_

; 1847 :       message_block[i] ^= parameter_block[i];

  0051c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00521	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00526	0f b6 8c 0c 78
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0052e	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00536	33 c1		 xor	 eax, ecx
  00538	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0053d	88 84 0c 70 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00544	eb c5		 jmp	 SHORT $LN10@z900_kmac_
$LN11@z900_kmac_:

; 1848 : 
; 1849 :     /* Calculate the output chaining value */
; 1850 :     switch(tfc)

  00546	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0054a	89 44 24 44	 mov	 DWORD PTR tv316[rsp], eax
  0054e	83 7c 24 44 01	 cmp	 DWORD PTR tv316[rsp], 1
  00553	74 17		 je	 SHORT $LN28@z900_kmac_
  00555	83 7c 24 44 02	 cmp	 DWORD PTR tv316[rsp], 2
  0055a	74 32		 je	 SHORT $LN29@z900_kmac_
  0055c	83 7c 24 44 03	 cmp	 DWORD PTR tv316[rsp], 3
  00561	0f 84 80 00 00
	00		 je	 $LN30@z900_kmac_
  00567	e9 d2 00 00 00	 jmp	 $LN13@z900_kmac_
$LN28@z900_kmac_:

; 1851 :     {
; 1852 :       case 1: /* dea */
; 1853 :       {
; 1854 :         des_encrypt(&context1, message_block, parameter_block);

  0056c	4c 8d 84 24 78
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00574	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0057c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00584	e8 00 00 00 00	 call	 des_encrypt

; 1855 :         break;

  00589	e9 b0 00 00 00	 jmp	 $LN13@z900_kmac_
$LN29@z900_kmac_:

; 1856 :       }
; 1857 :       case 2: /* tdea-128 */
; 1858 :       {
; 1859 :         des_encrypt(&context1, message_block, parameter_block);

  0058e	4c 8d 84 24 78
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00596	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0059e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005a6	e8 00 00 00 00	 call	 des_encrypt

; 1860 :         des_decrypt(&context2, parameter_block, parameter_block);

  005ab	4c 8d 84 24 78
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  005b3	48 8d 94 24 78
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  005bb	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  005c3	e8 00 00 00 00	 call	 des_decrypt

; 1861 :         des_encrypt(&context1, parameter_block, parameter_block);

  005c8	4c 8d 84 24 78
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  005d0	48 8d 94 24 78
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  005d8	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005e0	e8 00 00 00 00	 call	 des_encrypt

; 1862 :         break;

  005e5	eb 57		 jmp	 SHORT $LN13@z900_kmac_
$LN30@z900_kmac_:

; 1863 :       }
; 1864 :       case 3: /* tdea-192 */
; 1865 :       {
; 1866 :         des_encrypt(&context1, message_block, parameter_block);

  005e7	4c 8d 84 24 78
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  005ef	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005f7	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005ff	e8 00 00 00 00	 call	 des_encrypt

; 1867 :         des_decrypt(&context2, parameter_block, parameter_block);

  00604	4c 8d 84 24 78
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0060c	48 8d 94 24 78
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00614	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0061c	e8 00 00 00 00	 call	 des_decrypt

; 1868 :         des_encrypt(&context3, parameter_block, parameter_block);

  00621	4c 8d 84 24 78
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00629	48 8d 94 24 78
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00631	48 8d 8c 24 e0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00639	e8 00 00 00 00	 call	 des_encrypt
$LN13@z900_kmac_:

; 1869 :         break;
; 1870 :       }
; 1871 :     }
; 1872 : 
; 1873 :     /* Store the output chaining value */
; 1874 :     ARCH_DEP(vstorec)(parameter_block, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0063e	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00646	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0064c	83 e0 01	 and	 eax, 1
  0064f	85 c0		 test	 eax, eax
  00651	74 23		 je	 SHORT $LN63@z900_kmac_
  00653	b8 08 00 00 00	 mov	 eax, 8
  00658	48 6b c0 01	 imul	 rax, rax, 1
  0065c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00664	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0066c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv355[rsp], rax
  00674	eb 20		 jmp	 SHORT $LN64@z900_kmac_
$LN63@z900_kmac_:
  00676	b8 08 00 00 00	 mov	 eax, 8
  0067b	48 6b c0 01	 imul	 rax, rax, 1
  0067f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00687	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0068e	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv355[rsp], rax
$LN64@z900_kmac_:
  00696	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0069e	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  006a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv355[rsp]
  006ad	48 23 c8	 and	 rcx, rax
  006b0	48 8b c1	 mov	 rax, rcx
  006b3	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006bb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006c0	41 b9 01 00 00
	00		 mov	 r9d, 1
  006c6	4c 8b c0	 mov	 r8, rax
  006c9	b2 07		 mov	 dl, 7
  006cb	48 8d 8c 24 78
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  006d3	e8 00 00 00 00	 call	 z900_vstorec
$LN17@z900_kmac_:

; 1875 : 
; 1876 : #ifdef OPTION_KMAC_DEBUG
; 1877 :     LOGBYTE("ocv   :", parameter_block, 8);
; 1878 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1879 : 
; 1880 :     /* Update the registers */
; 1881 :     SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  006d8	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e0	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006e6	83 e0 01	 and	 eax, 1
  006e9	85 c0		 test	 eax, eax
  006eb	74 7c		 je	 SHORT $LN31@z900_kmac_
  006ed	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006f5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006fb	83 e0 01	 and	 eax, 1
  006fe	85 c0		 test	 eax, eax
  00700	74 22		 je	 SHORT $LN65@z900_kmac_
  00702	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0070a	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00712	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0071a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv383[rsp], rax
  00722	eb 1f		 jmp	 SHORT $LN66@z900_kmac_
$LN65@z900_kmac_:
  00724	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0072c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00734	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0073b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv383[rsp], rax
$LN66@z900_kmac_:
  00743	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv383[rsp]
  0074b	48 83 c0 08	 add	 rax, 8
  0074f	48 63 8c 24 d8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00757	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0075f	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00767	eb 79		 jmp	 SHORT $LN32@z900_kmac_
$LN31@z900_kmac_:
  00769	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00771	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00777	83 e0 01	 and	 eax, 1
  0077a	85 c0		 test	 eax, eax
  0077c	74 22		 je	 SHORT $LN67@z900_kmac_
  0077e	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00786	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0078e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00796	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
  0079e	eb 1f		 jmp	 SHORT $LN68@z900_kmac_
$LN67@z900_kmac_:
  007a0	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  007a8	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007b7	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv404[rsp], rax
$LN68@z900_kmac_:
  007bf	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv404[rsp]
  007c7	48 83 c0 08	 add	 rax, 8
  007cb	48 63 8c 24 d8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  007d3	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007db	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN32@z900_kmac_:
  007e2	33 c0		 xor	 eax, eax
  007e4	85 c0		 test	 eax, eax
  007e6	0f 85 ec fe ff
	ff		 jne	 $LN17@z900_kmac_
$LN20@z900_kmac_:

; 1882 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  007ec	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007f4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007fa	83 e0 01	 and	 eax, 1
  007fd	85 c0		 test	 eax, eax
  007ff	0f 84 89 00 00
	00		 je	 $LN33@z900_kmac_
  00805	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00813	83 e0 01	 and	 eax, 1
  00816	85 c0		 test	 eax, eax
  00818	74 25		 je	 SHORT $LN69@z900_kmac_
  0081a	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00821	ff c0		 inc	 eax
  00823	48 98		 cdqe
  00825	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0082d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00835	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv433[rsp], rax
  0083d	eb 22		 jmp	 SHORT $LN70@z900_kmac_
$LN69@z900_kmac_:
  0083f	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00846	ff c0		 inc	 eax
  00848	48 98		 cdqe
  0084a	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00852	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00859	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv433[rsp], rax
$LN70@z900_kmac_:
  00861	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv433[rsp]
  00869	48 83 e8 08	 sub	 rax, 8
  0086d	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00874	ff c1		 inc	 ecx
  00876	48 63 c9	 movsxd	 rcx, ecx
  00879	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00881	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00889	e9 83 00 00 00	 jmp	 $LN34@z900_kmac_
$LN33@z900_kmac_:
  0088e	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00896	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0089c	83 e0 01	 and	 eax, 1
  0089f	85 c0		 test	 eax, eax
  008a1	74 25		 je	 SHORT $LN71@z900_kmac_
  008a3	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008aa	ff c0		 inc	 eax
  008ac	48 98		 cdqe
  008ae	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008be	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv457[rsp], rax
  008c6	eb 22		 jmp	 SHORT $LN72@z900_kmac_
$LN71@z900_kmac_:
  008c8	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008cf	ff c0		 inc	 eax
  008d1	48 98		 cdqe
  008d3	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008db	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008e2	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv457[rsp], rax
$LN72@z900_kmac_:
  008ea	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv457[rsp]
  008f2	48 83 e8 08	 sub	 rax, 8
  008f6	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  008fd	ff c1		 inc	 ecx
  008ff	48 63 c9	 movsxd	 rcx, ecx
  00902	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0090a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN34@z900_kmac_:
  00911	33 c0		 xor	 eax, eax
  00913	85 c0		 test	 eax, eax
  00915	0f 85 d1 fe ff
	ff		 jne	 $LN20@z900_kmac_

; 1883 : 
; 1884 : #ifdef OPTION_KMAC_DEBUG
; 1885 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1886 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1887 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1888 : 
; 1889 :     /* check for end of data */
; 1890 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0091b	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00923	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00929	83 e0 01	 and	 eax, 1
  0092c	85 c0		 test	 eax, eax
  0092e	74 25		 je	 SHORT $LN73@z900_kmac_
  00930	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00937	ff c0		 inc	 eax
  00939	48 98		 cdqe
  0093b	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00943	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0094b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv477[rsp], rax
  00953	eb 22		 jmp	 SHORT $LN74@z900_kmac_
$LN73@z900_kmac_:
  00955	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0095c	ff c0		 inc	 eax
  0095e	48 98		 cdqe
  00960	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00968	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0096f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv477[rsp], rax
$LN74@z900_kmac_:
  00977	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR tv477[rsp], 0
  00980	75 0a		 jne	 SHORT $LN75@z900_kmac_
  00982	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv479[rsp], 1
  0098a	eb 08		 jmp	 SHORT $LN76@z900_kmac_
$LN75@z900_kmac_:
  0098c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv479[rsp], 0
$LN76@z900_kmac_:
  00994	83 7c 24 60 00	 cmp	 DWORD PTR tv479[rsp], 0
  00999	74 0a		 je	 SHORT $LN81@z900_kmac_
  0099b	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv500[rsp], 1
  009a3	eb 08		 jmp	 SHORT $LN82@z900_kmac_
$LN81@z900_kmac_:
  009a5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv500[rsp], 0
$LN82@z900_kmac_:
  009ad	83 7c 24 64 00	 cmp	 DWORD PTR tv500[rsp], 0
  009b2	74 0e		 je	 SHORT $LN35@z900_kmac_

; 1891 :     {
; 1892 :       regs->psw.cc = 0;

  009b4	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009bc	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1893 :       return;

  009c0	eb 11		 jmp	 SHORT $LN1@z900_kmac_
$LN35@z900_kmac_:

; 1894 :     }
; 1895 :   }

  009c2	e9 87 fa ff ff	 jmp	 $LN7@z900_kmac_
$LN8@z900_kmac_:

; 1896 : 
; 1897 :   /* CPU-determined amount of data processed */
; 1898 :   regs->psw.cc = 3;

  009c7	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009cf	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kmac_:

; 1899 : }

  009d3	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009db	48 33 cc	 xor	 rcx, rsp
  009de	e8 00 00 00 00	 call	 __security_check_cookie
  009e3	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  009ea	c3		 ret	 0
z900_kmac_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv135 = 64
tv157 = 68
tv178 = 72
tv193 = 76
wrap$ = 80
tv265 = 84
tv267 = 88
tv427 = 92
tv547 = 96
tv568 = 100
tfc$ = 104
modifier_bit$ = 108
r1_is_not_r2$ = 112
tv80 = 120
tv155 = 128
tv216 = 136
tv237 = 144
tv286 = 152
tv350 = 160
tv370 = 168
xts$ = 176
tv401 = 184
tv422 = 192
tv451 = 200
tv472 = 208
tv501 = 216
tv525 = 224
tv545 = 232
context$ = 240
message_block$ = 736
parameter_block$ = 752
__$ArrayPad$ = 832
r1$ = 864
r2$ = 872
regs$ = 880
z900_km_xts_aes PROC

; 1606 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 58 03
	00 00		 sub	 rsp, 856		; 00000358H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 40
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1607 :   rijndael_ctx context;
; 1608 :   int crypted;
; 1609 :   int i;
; 1610 :   int keylen;
; 1611 :   BYTE message_block[16];
; 1612 :   int modifier_bit;
; 1613 :   BYTE parameter_block[80];
; 1614 :   int parameter_blocklen;
; 1615 :   int r1_is_not_r2;
; 1616 :   int tfc;
; 1617 :   int wrap;
; 1618 :   BYTE *xts;
; 1619 : 
; 1620 :   /* Check special conditions */
; 1621 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00026	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 22		 je	 SHORT $LN35@z900_km_xt
  0003b	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00042	ff c0		 inc	 eax
  00044	48 98		 cdqe
  00046	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00056	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
  0005b	eb 1f		 jmp	 SHORT $LN36@z900_km_xt
$LN35@z900_km_xt:
  0005d	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00064	ff c0		 inc	 eax
  00066	48 98		 cdqe
  00068	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
$LN36@z900_km_xt:
  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b 44 24 78	 mov	 rax, QWORD PTR tv80[rsp]
  00083	b9 10 00 00 00	 mov	 ecx, 16
  00088	48 f7 f1	 div	 rcx
  0008b	48 8b c2	 mov	 rax, rdx
  0008e	48 85 c0	 test	 rax, rax
  00091	74 0a		 je	 SHORT $LN41@z900_km_xt
  00093	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0009b	eb 08		 jmp	 SHORT $LN42@z900_km_xt
$LN41@z900_km_xt:
  0009d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN42@z900_km_xt:
  000a5	83 7c 24 40 00	 cmp	 DWORD PTR tv135[rsp], 0
  000aa	74 13		 je	 SHORT $LN20@z900_km_xt

; 1622 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ac	ba 06 00 00 00	 mov	 edx, 6
  000b1	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN20@z900_km_xt:

; 1623 : 
; 1624 :   /* Return with cc 0 on zero length */
; 1625 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000bf	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 25		 je	 SHORT $LN43@z900_km_xt
  000d4	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000db	ff c0		 inc	 eax
  000dd	48 98		 cdqe
  000df	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000ef	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  000f7	eb 22		 jmp	 SHORT $LN44@z900_km_xt
$LN43@z900_km_xt:
  000f9	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00100	ff c0		 inc	 eax
  00102	48 98		 cdqe
  00104	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00113	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN44@z900_km_xt:
  0011b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv155[rsp], 0
  00124	75 0a		 jne	 SHORT $LN45@z900_km_xt
  00126	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  0012e	eb 08		 jmp	 SHORT $LN46@z900_km_xt
$LN45@z900_km_xt:
  00130	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN46@z900_km_xt:
  00138	83 7c 24 44 00	 cmp	 DWORD PTR tv157[rsp], 0
  0013d	74 0a		 je	 SHORT $LN51@z900_km_xt
  0013f	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00147	eb 08		 jmp	 SHORT $LN52@z900_km_xt
$LN51@z900_km_xt:
  00149	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN52@z900_km_xt:
  00151	83 7c 24 48 00	 cmp	 DWORD PTR tv178[rsp], 0
  00156	74 11		 je	 SHORT $LN21@z900_km_xt

; 1626 :   {
; 1627 :     regs->psw.cc = 0;

  00158	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1628 :     return;

  00164	e9 a7 09 00 00	 jmp	 $LN1@z900_km_xt
$LN21@z900_km_xt:

; 1629 :   }
; 1630 : 
; 1631 :   /* Initialize values */
; 1632 :   tfc = GR0_tfc(regs);

  00169	b8 08 00 00 00	 mov	 eax, 8
  0016e	48 6b c0 00	 imul	 rax, rax, 0
  00172	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00181	83 e0 7f	 and	 eax, 127		; 0000007fH
  00184	83 e0 77	 and	 eax, 119		; 00000077H
  00187	89 44 24 68	 mov	 DWORD PTR tfc$[rsp], eax

; 1633 :   wrap = GR0_wrap(regs);

  0018b	b8 08 00 00 00	 mov	 eax, 8
  00190	48 6b c0 00	 imul	 rax, rax, 0
  00194	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a3	83 e0 08	 and	 eax, 8
  001a6	85 c0		 test	 eax, eax
  001a8	74 0a		 je	 SHORT $LN53@z900_km_xt
  001aa	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001b2	eb 08		 jmp	 SHORT $LN54@z900_km_xt
$LN53@z900_km_xt:
  001b4	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN54@z900_km_xt:
  001bc	8b 44 24 4c	 mov	 eax, DWORD PTR tv193[rsp]
  001c0	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 1634 :   keylen = (tfc - 49) * 8 + 8;

  001c4	8b 44 24 68	 mov	 eax, DWORD PTR tfc$[rsp]
  001c8	8d 04 c5 80 fe
	ff ff		 lea	 eax, DWORD PTR [rax*8-384]
  001cf	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 1635 :   parameter_blocklen = keylen + 16;

  001d3	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  001d7	83 c0 10	 add	 eax, 16
  001da	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1636 :   if(wrap)

  001de	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001e3	74 0b		 je	 SHORT $LN22@z900_km_xt

; 1637 :     parameter_blocklen += 32;

  001e5	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001e9	83 c0 20	 add	 eax, 32			; 00000020H
  001ec	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN22@z900_km_xt:

; 1638 : 
; 1639 :   /* Test writeability output chaining value */
; 1640 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + parameter_blocklen - 16) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  001f0	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001fe	83 e0 01	 and	 eax, 1
  00201	85 c0		 test	 eax, eax
  00203	74 23		 je	 SHORT $LN55@z900_km_xt
  00205	b8 08 00 00 00	 mov	 eax, 8
  0020a	48 6b c0 01	 imul	 rax, rax, 1
  0020e	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00216	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0021e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv216[rsp], rax
  00226	eb 20		 jmp	 SHORT $LN56@z900_km_xt
$LN55@z900_km_xt:
  00228	b8 08 00 00 00	 mov	 eax, 8
  0022d	48 6b c0 01	 imul	 rax, rax, 1
  00231	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00240	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv216[rsp], rax
$LN56@z900_km_xt:
  00248	48 63 44 24 34	 movsxd	 rax, DWORD PTR parameter_blocklen$[rsp]
  0024d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv216[rsp]
  00255	48 8d 44 01 f0	 lea	 rax, QWORD PTR [rcx+rax-16]
  0025a	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00262	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00269	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00271	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00276	41 b9 02 00 00
	00		 mov	 r9d, 2
  0027c	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00282	ba 01 00 00 00	 mov	 edx, 1
  00287	48 8b c8	 mov	 rcx, rax
  0028a	e8 00 00 00 00	 call	 z900_validate_operand

; 1641 : 
; 1642 :   /* Fetch the parameter block */
; 1643 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0028f	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00297	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0029d	83 e0 01	 and	 eax, 1
  002a0	85 c0		 test	 eax, eax
  002a2	74 23		 je	 SHORT $LN57@z900_km_xt
  002a4	b8 08 00 00 00	 mov	 eax, 8
  002a9	48 6b c0 01	 imul	 rax, rax, 1
  002ad	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b5	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002bd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv237[rsp], rax
  002c5	eb 20		 jmp	 SHORT $LN58@z900_km_xt
$LN57@z900_km_xt:
  002c7	b8 08 00 00 00	 mov	 eax, 8
  002cc	48 6b c0 01	 imul	 rax, rax, 1
  002d0	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002df	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv237[rsp], rax
$LN58@z900_km_xt:
  002e7	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ef	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002f6	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv237[rsp]
  002fe	48 23 c8	 and	 rcx, rax
  00301	48 8b c1	 mov	 rax, rcx
  00304	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00308	ff c9		 dec	 ecx
  0030a	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00312	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00317	41 b9 01 00 00
	00		 mov	 r9d, 1
  0031d	4c 8b c0	 mov	 r8, rax
  00320	0f b6 d1	 movzx	 edx, cl
  00323	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0032b	e8 00 00 00 00	 call	 z900_vfetchc

; 1644 :   xts = &parameter_block[parameter_blocklen - 16];

  00330	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00334	83 e8 10	 sub	 eax, 16
  00337	48 98		 cdqe
  00339	48 8d 84 04 f0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00341	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR xts$[rsp], rax

; 1645 : 
; 1646 : #ifdef OPTION_KM_DEBUG
; 1647 :   LOGBYTE("k     :", parameter_block, keylen);
; 1648 :   if(wrap)
; 1649 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 32);
; 1650 :   LOGBYTE("xts   :", xts, 16);
; 1651 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1652 : 
; 1653 :   /* Verify and unwrap */
; 1654 :   if(wrap && unwrap_aes(parameter_block, keylen))

  00349	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0034e	74 26		 je	 SHORT $LN23@z900_km_xt
  00350	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  00354	48 8d 8c 24 f0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0035c	e8 00 00 00 00	 call	 unwrap_aes
  00361	85 c0		 test	 eax, eax
  00363	74 11		 je	 SHORT $LN23@z900_km_xt

; 1655 :   {
; 1656 : 
; 1657 : #ifdef OPTION_KM_DEBUG
; 1658 :     WRMSG(HHC90111, "D");
; 1659 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1660 : 
; 1661 :     regs->psw.cc = 1;

  00365	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0036d	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1662 :     return;

  00371	e9 9a 07 00 00	 jmp	 $LN1@z900_km_xt
$LN23@z900_km_xt:

; 1663 :   }
; 1664 : 
; 1665 :   /* Set the cryptographic keys */
; 1666 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  00376	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0037a	c1 e0 03	 shl	 eax, 3
  0037d	44 8b c0	 mov	 r8d, eax
  00380	48 8d 94 24 f0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00388	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00390	e8 00 00 00 00	 call	 rijndael_set_key

; 1667 : 
; 1668 :   /* Try to process the CPU-determined amount of data */
; 1669 :   modifier_bit = GR0_m(regs);

  00395	b8 08 00 00 00	 mov	 eax, 8
  0039a	48 6b c0 00	 imul	 rax, rax, 0
  0039e	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003ad	25 80 00 00 00	 and	 eax, 128		; 00000080H
  003b2	85 c0		 test	 eax, eax
  003b4	74 0a		 je	 SHORT $LN59@z900_km_xt
  003b6	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv265[rsp], 1
  003be	eb 08		 jmp	 SHORT $LN60@z900_km_xt
$LN59@z900_km_xt:
  003c0	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv265[rsp], 0
$LN60@z900_km_xt:
  003c8	8b 44 24 54	 mov	 eax, DWORD PTR tv265[rsp]
  003cc	89 44 24 6c	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1670 :   r1_is_not_r2 = r1 != r2;

  003d0	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003d7	39 84 24 60 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  003de	74 0a		 je	 SHORT $LN61@z900_km_xt
  003e0	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv267[rsp], 1
  003e8	eb 08		 jmp	 SHORT $LN62@z900_km_xt
$LN61@z900_km_xt:
  003ea	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv267[rsp], 0
$LN62@z900_km_xt:
  003f2	8b 44 24 58	 mov	 eax, DWORD PTR tv267[rsp]
  003f6	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1671 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  003fa	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00402	eb 0b		 jmp	 SHORT $LN4@z900_km_xt
$LN2@z900_km_xt:
  00404	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00408	83 c0 10	 add	 eax, 16
  0040b	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@z900_km_xt:
  0040f	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00417	0f 8d e7 06 00
	00		 jge	 $LN3@z900_km_xt

; 1672 :   {
; 1673 :     /* Fetch a block of data */
; 1674 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0041d	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00425	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0042b	83 e0 01	 and	 eax, 1
  0042e	85 c0		 test	 eax, eax
  00430	74 22		 je	 SHORT $LN63@z900_km_xt
  00432	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0043a	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00442	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0044a	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv286[rsp], rax
  00452	eb 1f		 jmp	 SHORT $LN64@z900_km_xt
$LN63@z900_km_xt:
  00454	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0045c	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00464	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0046b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv286[rsp], rax
$LN64@z900_km_xt:
  00473	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0047b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00482	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv286[rsp]
  0048a	48 23 c8	 and	 rcx, rax
  0048d	48 8b c1	 mov	 rax, rcx
  00490	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00498	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0049d	44 8b 8c 24 68
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  004a5	4c 8b c0	 mov	 r8, rax
  004a8	b2 0f		 mov	 dl, 15
  004aa	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  004b2	e8 00 00 00 00	 call	 z900_vfetchc

; 1675 : 
; 1676 : #ifdef OPTION_KM_DEBUG
; 1677 :     LOGBYTE("input :", message_block, 16);
; 1678 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1679 : 
; 1680 :     /* XOR, decrypt/encrypt and XOR again*/
; 1681 :     for(i = 0; i < 16; i++)

  004b7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004bf	eb 0a		 jmp	 SHORT $LN7@z900_km_xt
$LN5@z900_km_xt:
  004c1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004c5	ff c0		 inc	 eax
  004c7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@z900_km_xt:
  004cb	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  004d0	7d 34		 jge	 SHORT $LN6@z900_km_xt

; 1682 :       message_block[i] ^= parameter_block[parameter_blocklen - 16 + i];

  004d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004d7	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  004db	8b 54 24 30	 mov	 edx, DWORD PTR i$[rsp]
  004df	8d 4c 11 f0	 lea	 ecx, DWORD PTR [rcx+rdx-16]
  004e3	48 63 c9	 movsxd	 rcx, ecx
  004e6	0f b6 8c 0c f0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  004ee	0f b6 84 04 e0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  004f6	33 c1		 xor	 eax, ecx
  004f8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004fd	88 84 0c e0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00504	eb bb		 jmp	 SHORT $LN5@z900_km_xt
$LN6@z900_km_xt:

; 1683 :     if(modifier_bit)

  00506	83 7c 24 6c 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0050b	74 1f		 je	 SHORT $LN24@z900_km_xt

; 1684 :       rijndael_decrypt(&context, message_block, message_block);

  0050d	4c 8d 84 24 e0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00515	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0051d	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00525	e8 00 00 00 00	 call	 rijndael_decrypt
  0052a	eb 1d		 jmp	 SHORT $LN25@z900_km_xt
$LN24@z900_km_xt:

; 1685 :     else
; 1686 :       rijndael_encrypt(&context, message_block, message_block);

  0052c	4c 8d 84 24 e0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00534	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0053c	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00544	e8 00 00 00 00	 call	 rijndael_encrypt
$LN25@z900_km_xt:

; 1687 :     for(i = 0; i < 16; i++)

  00549	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00551	eb 0a		 jmp	 SHORT $LN10@z900_km_xt
$LN8@z900_km_xt:
  00553	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00557	ff c0		 inc	 eax
  00559	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_km_xt:
  0055d	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00562	7d 34		 jge	 SHORT $LN9@z900_km_xt

; 1688 :       message_block[i] ^= parameter_block[parameter_blocklen - 16 + i];

  00564	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00569	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0056d	8b 54 24 30	 mov	 edx, DWORD PTR i$[rsp]
  00571	8d 4c 11 f0	 lea	 ecx, DWORD PTR [rcx+rdx-16]
  00575	48 63 c9	 movsxd	 rcx, ecx
  00578	0f b6 8c 0c f0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00580	0f b6 84 04 e0
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00588	33 c1		 xor	 eax, ecx
  0058a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0058f	88 84 0c e0 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00596	eb bb		 jmp	 SHORT $LN8@z900_km_xt
$LN9@z900_km_xt:

; 1689 : 
; 1690 :     /* Calculate output XTS */
; 1691 :     xts_mult_x(xts);

  00598	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xts$[rsp]
  005a0	e8 00 00 00 00	 call	 xts_mult_x

; 1692 : 
; 1693 :     /* Store the output and XTS */
; 1694 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  005a5	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ad	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005b3	83 e0 01	 and	 eax, 1
  005b6	85 c0		 test	 eax, eax
  005b8	74 22		 je	 SHORT $LN65@z900_km_xt
  005ba	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  005c2	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ca	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  005d2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv350[rsp], rax
  005da	eb 1f		 jmp	 SHORT $LN66@z900_km_xt
$LN65@z900_km_xt:
  005dc	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  005e4	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ec	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005f3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv350[rsp], rax
$LN66@z900_km_xt:
  005fb	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00603	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0060a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv350[rsp]
  00612	48 23 c8	 and	 rcx, rax
  00615	48 8b c1	 mov	 rax, rcx
  00618	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00620	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00625	44 8b 8c 24 60
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0062d	4c 8b c0	 mov	 r8, rax
  00630	b2 0f		 mov	 dl, 15
  00632	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0063a	e8 00 00 00 00	 call	 z900_vstorec

; 1695 :     ARCH_DEP(vstorec)(xts, 15, (GR_A(1, regs) + parameter_blocklen - 16) & ADDRESS_MAXWRAP(regs), 1, regs);

  0063f	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00647	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0064d	83 e0 01	 and	 eax, 1
  00650	85 c0		 test	 eax, eax
  00652	74 23		 je	 SHORT $LN67@z900_km_xt
  00654	b8 08 00 00 00	 mov	 eax, 8
  00659	48 6b c0 01	 imul	 rax, rax, 1
  0065d	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00665	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  0066d	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv370[rsp], rax
  00675	eb 20		 jmp	 SHORT $LN68@z900_km_xt
$LN67@z900_km_xt:
  00677	b8 08 00 00 00	 mov	 eax, 8
  0067c	48 6b c0 01	 imul	 rax, rax, 1
  00680	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00688	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0068f	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv370[rsp], rax
$LN68@z900_km_xt:
  00697	48 63 44 24 34	 movsxd	 rax, DWORD PTR parameter_blocklen$[rsp]
  0069c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv370[rsp]
  006a4	48 8d 44 01 f0	 lea	 rax, QWORD PTR [rcx+rax-16]
  006a9	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006b1	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  006b8	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  006c5	41 b9 01 00 00
	00		 mov	 r9d, 1
  006cb	4c 8b c0	 mov	 r8, rax
  006ce	b2 0f		 mov	 dl, 15
  006d0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR xts$[rsp]
  006d8	e8 00 00 00 00	 call	 z900_vstorec
$LN13@z900_km_xt:

; 1696 : 
; 1697 : #ifdef OPTION_KM_DEBUG
; 1698 :     LOGBYTE("output:", message_block, 16);
; 1699 :     LOGBYTE("xts   :", xts, 16);
; 1700 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1701 : 
; 1702 :     /* Update the registers */
; 1703 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  006dd	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006e5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006eb	83 e0 01	 and	 eax, 1
  006ee	85 c0		 test	 eax, eax
  006f0	74 7c		 je	 SHORT $LN26@z900_km_xt
  006f2	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fa	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00700	83 e0 01	 and	 eax, 1
  00703	85 c0		 test	 eax, eax
  00705	74 22		 je	 SHORT $LN69@z900_km_xt
  00707	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0070f	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00717	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0071f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv401[rsp], rax
  00727	eb 1f		 jmp	 SHORT $LN70@z900_km_xt
$LN69@z900_km_xt:
  00729	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00731	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00739	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00740	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv401[rsp], rax
$LN70@z900_km_xt:
  00748	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv401[rsp]
  00750	48 83 c0 10	 add	 rax, 16
  00754	48 63 8c 24 60
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0075c	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00764	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  0076c	eb 79		 jmp	 SHORT $LN27@z900_km_xt
$LN26@z900_km_xt:
  0076e	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00776	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0077c	83 e0 01	 and	 eax, 1
  0077f	85 c0		 test	 eax, eax
  00781	74 22		 je	 SHORT $LN71@z900_km_xt
  00783	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0078b	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00793	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0079b	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv422[rsp], rax
  007a3	eb 1f		 jmp	 SHORT $LN72@z900_km_xt
$LN71@z900_km_xt:
  007a5	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007ad	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007b5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007bc	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv422[rsp], rax
$LN72@z900_km_xt:
  007c4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv422[rsp]
  007cc	48 83 c0 10	 add	 rax, 16
  007d0	48 63 8c 24 60
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  007d8	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007e0	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN27@z900_km_xt:
  007e7	33 c0		 xor	 eax, eax
  007e9	85 c0		 test	 eax, eax
  007eb	0f 85 ec fe ff
	ff		 jne	 $LN13@z900_km_xt

; 1704 :     if(likely(r1_is_not_r2))

  007f1	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  007f6	74 0a		 je	 SHORT $LN73@z900_km_xt
  007f8	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv427[rsp], 1
  00800	eb 08		 jmp	 SHORT $LN74@z900_km_xt
$LN73@z900_km_xt:
  00802	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv427[rsp], 0
$LN74@z900_km_xt:
  0080a	83 7c 24 5c 00	 cmp	 DWORD PTR tv427[rsp], 0
  0080f	0f 84 14 01 00
	00		 je	 $LN28@z900_km_xt
$LN16@z900_km_xt:

; 1705 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  00815	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0081d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00823	83 e0 01	 and	 eax, 1
  00826	85 c0		 test	 eax, eax
  00828	74 7c		 je	 SHORT $LN29@z900_km_xt
  0082a	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00832	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00838	83 e0 01	 and	 eax, 1
  0083b	85 c0		 test	 eax, eax
  0083d	74 22		 je	 SHORT $LN75@z900_km_xt
  0083f	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00847	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0084f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00857	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv451[rsp], rax
  0085f	eb 1f		 jmp	 SHORT $LN76@z900_km_xt
$LN75@z900_km_xt:
  00861	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00869	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00871	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00878	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv451[rsp], rax
$LN76@z900_km_xt:
  00880	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv451[rsp]
  00888	48 83 c0 10	 add	 rax, 16
  0088c	48 63 8c 24 68
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00894	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0089c	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  008a4	eb 79		 jmp	 SHORT $LN30@z900_km_xt
$LN29@z900_km_xt:
  008a6	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ae	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008b4	83 e0 01	 and	 eax, 1
  008b7	85 c0		 test	 eax, eax
  008b9	74 22		 je	 SHORT $LN77@z900_km_xt
  008bb	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008c3	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008cb	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008d3	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv472[rsp], rax
  008db	eb 1f		 jmp	 SHORT $LN78@z900_km_xt
$LN77@z900_km_xt:
  008dd	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008e5	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008ed	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008f4	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv472[rsp], rax
$LN78@z900_km_xt:
  008fc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR tv472[rsp]
  00904	48 83 c0 10	 add	 rax, 16
  00908	48 63 8c 24 68
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00910	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00918	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN30@z900_km_xt:
  0091f	33 c0		 xor	 eax, eax
  00921	85 c0		 test	 eax, eax
  00923	0f 85 ec fe ff
	ff		 jne	 $LN16@z900_km_xt
$LN28@z900_km_xt:
$LN19@z900_km_xt:

; 1706 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00929	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00931	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00937	83 e0 01	 and	 eax, 1
  0093a	85 c0		 test	 eax, eax
  0093c	0f 84 89 00 00
	00		 je	 $LN31@z900_km_xt
  00942	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0094a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00950	83 e0 01	 and	 eax, 1
  00953	85 c0		 test	 eax, eax
  00955	74 25		 je	 SHORT $LN79@z900_km_xt
  00957	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0095e	ff c0		 inc	 eax
  00960	48 98		 cdqe
  00962	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0096a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00972	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv501[rsp], rax
  0097a	eb 22		 jmp	 SHORT $LN80@z900_km_xt
$LN79@z900_km_xt:
  0097c	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00983	ff c0		 inc	 eax
  00985	48 98		 cdqe
  00987	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0098f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00996	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv501[rsp], rax
$LN80@z900_km_xt:
  0099e	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR tv501[rsp]
  009a6	48 83 e8 10	 sub	 rax, 16
  009aa	8b 8c 24 68 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  009b1	ff c1		 inc	 ecx
  009b3	48 63 c9	 movsxd	 rcx, ecx
  009b6	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009be	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  009c6	e9 83 00 00 00	 jmp	 $LN32@z900_km_xt
$LN31@z900_km_xt:
  009cb	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  009d9	83 e0 01	 and	 eax, 1
  009dc	85 c0		 test	 eax, eax
  009de	74 25		 je	 SHORT $LN81@z900_km_xt
  009e0	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009e7	ff c0		 inc	 eax
  009e9	48 98		 cdqe
  009eb	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009f3	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  009fb	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv525[rsp], rax
  00a03	eb 22		 jmp	 SHORT $LN82@z900_km_xt
$LN81@z900_km_xt:
  00a05	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a0c	ff c0		 inc	 eax
  00a0e	48 98		 cdqe
  00a10	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a18	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00a1f	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv525[rsp], rax
$LN82@z900_km_xt:
  00a27	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv525[rsp]
  00a2f	48 83 e8 10	 sub	 rax, 16
  00a33	8b 8c 24 68 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00a3a	ff c1		 inc	 ecx
  00a3c	48 63 c9	 movsxd	 rcx, ecx
  00a3f	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00a47	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN32@z900_km_xt:
  00a4e	33 c0		 xor	 eax, eax
  00a50	85 c0		 test	 eax, eax
  00a52	0f 85 d1 fe ff
	ff		 jne	 $LN19@z900_km_xt

; 1707 : 
; 1708 : #ifdef OPTION_KM_DEBUG
; 1709 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1710 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1711 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1712 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1713 : 
; 1714 :     /* check for end of data */
; 1715 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00a58	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a60	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a66	83 e0 01	 and	 eax, 1
  00a69	85 c0		 test	 eax, eax
  00a6b	74 25		 je	 SHORT $LN83@z900_km_xt
  00a6d	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a74	ff c0		 inc	 eax
  00a76	48 98		 cdqe
  00a78	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a80	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00a88	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv545[rsp], rax
  00a90	eb 22		 jmp	 SHORT $LN84@z900_km_xt
$LN83@z900_km_xt:
  00a92	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a99	ff c0		 inc	 eax
  00a9b	48 98		 cdqe
  00a9d	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00aa5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00aac	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv545[rsp], rax
$LN84@z900_km_xt:
  00ab4	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR tv545[rsp], 0
  00abd	75 0a		 jne	 SHORT $LN85@z900_km_xt
  00abf	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv547[rsp], 1
  00ac7	eb 08		 jmp	 SHORT $LN86@z900_km_xt
$LN85@z900_km_xt:
  00ac9	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv547[rsp], 0
$LN86@z900_km_xt:
  00ad1	83 7c 24 60 00	 cmp	 DWORD PTR tv547[rsp], 0
  00ad6	74 0a		 je	 SHORT $LN91@z900_km_xt
  00ad8	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv568[rsp], 1
  00ae0	eb 08		 jmp	 SHORT $LN92@z900_km_xt
$LN91@z900_km_xt:
  00ae2	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv568[rsp], 0
$LN92@z900_km_xt:
  00aea	83 7c 24 64 00	 cmp	 DWORD PTR tv568[rsp], 0
  00aef	74 0e		 je	 SHORT $LN33@z900_km_xt

; 1716 :     {
; 1717 :       regs->psw.cc = 0;

  00af1	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00af9	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1718 :       return;

  00afd	eb 11		 jmp	 SHORT $LN1@z900_km_xt
$LN33@z900_km_xt:

; 1719 :     }
; 1720 :   }

  00aff	e9 00 f9 ff ff	 jmp	 $LN2@z900_km_xt
$LN3@z900_km_xt:

; 1721 : 
; 1722 :   /* CPU-determined amount of data processed */
; 1723 :   regs->psw.cc = 3;

  00b04	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00b0c	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_km_xt:

; 1724 : }

  00b10	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b18	48 33 cc	 xor	 rcx, rsp
  00b1b	e8 00 00 00 00	 call	 __security_check_cookie
  00b20	48 81 c4 58 03
	00 00		 add	 rsp, 856		; 00000358H
  00b27	c3		 ret	 0
z900_km_xts_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
keylen$ = 52
crypted$ = 56
tv135 = 60
tv157 = 64
tv178 = 68
tv193 = 72
wrap$ = 76
tv237 = 80
tv239 = 84
tv341 = 88
tv461 = 92
tv482 = 96
tfc$ = 100
modifier_bit$ = 104
r1_is_not_r2$ = 108
tv80 = 112
tv155 = 120
tv213 = 128
tv258 = 136
tv287 = 144
tv315 = 152
tv336 = 160
tv365 = 168
tv386 = 176
tv415 = 184
tv439 = 192
tv459 = 200
context$ = 208
message_block$ = 704
parameter_block$ = 720
__$ArrayPad$ = 784
r1$ = 816
r2$ = 824
regs$ = 832
z900_km_aes PROC

; 1494 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 28 03
	00 00		 sub	 rsp, 808		; 00000328H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1495 :   rijndael_ctx context;
; 1496 :   int crypted;
; 1497 :   int keylen;
; 1498 :   BYTE message_block[16];
; 1499 :   int modifier_bit;
; 1500 :   BYTE parameter_block[64];
; 1501 :   int parameter_blocklen;
; 1502 :   int r1_is_not_r2;
; 1503 :   int tfc;
; 1504 :   int wrap;
; 1505 : 
; 1506 :   /* Check special conditions */
; 1507 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00026	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 22		 je	 SHORT $LN29@z900_km_ae
  0003b	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00042	ff c0		 inc	 eax
  00044	48 98		 cdqe
  00046	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00056	48 89 44 24 70	 mov	 QWORD PTR tv80[rsp], rax
  0005b	eb 1f		 jmp	 SHORT $LN30@z900_km_ae
$LN29@z900_km_ae:
  0005d	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00064	ff c0		 inc	 eax
  00066	48 98		 cdqe
  00068	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	48 89 44 24 70	 mov	 QWORD PTR tv80[rsp], rax
$LN30@z900_km_ae:
  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b 44 24 70	 mov	 rax, QWORD PTR tv80[rsp]
  00083	b9 10 00 00 00	 mov	 ecx, 16
  00088	48 f7 f1	 div	 rcx
  0008b	48 8b c2	 mov	 rax, rdx
  0008e	48 85 c0	 test	 rax, rax
  00091	74 0a		 je	 SHORT $LN35@z900_km_ae
  00093	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0009b	eb 08		 jmp	 SHORT $LN36@z900_km_ae
$LN35@z900_km_ae:
  0009d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN36@z900_km_ae:
  000a5	83 7c 24 3c 00	 cmp	 DWORD PTR tv135[rsp], 0
  000aa	74 13		 je	 SHORT $LN14@z900_km_ae

; 1508 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ac	ba 06 00 00 00	 mov	 edx, 6
  000b1	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN14@z900_km_ae:

; 1509 : 
; 1510 :   /* Return with cc 0 on zero length */
; 1511 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000bf	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 22		 je	 SHORT $LN37@z900_km_ae
  000d4	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000db	ff c0		 inc	 eax
  000dd	48 98		 cdqe
  000df	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000ef	48 89 44 24 78	 mov	 QWORD PTR tv155[rsp], rax
  000f4	eb 1f		 jmp	 SHORT $LN38@z900_km_ae
$LN37@z900_km_ae:
  000f6	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000fd	ff c0		 inc	 eax
  000ff	48 98		 cdqe
  00101	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00110	48 89 44 24 78	 mov	 QWORD PTR tv155[rsp], rax
$LN38@z900_km_ae:
  00115	48 83 7c 24 78
	00		 cmp	 QWORD PTR tv155[rsp], 0
  0011b	75 0a		 jne	 SHORT $LN39@z900_km_ae
  0011d	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  00125	eb 08		 jmp	 SHORT $LN40@z900_km_ae
$LN39@z900_km_ae:
  00127	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN40@z900_km_ae:
  0012f	83 7c 24 40 00	 cmp	 DWORD PTR tv157[rsp], 0
  00134	74 0a		 je	 SHORT $LN45@z900_km_ae
  00136	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  0013e	eb 08		 jmp	 SHORT $LN46@z900_km_ae
$LN45@z900_km_ae:
  00140	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN46@z900_km_ae:
  00148	83 7c 24 44 00	 cmp	 DWORD PTR tv178[rsp], 0
  0014d	74 11		 je	 SHORT $LN15@z900_km_ae

; 1512 :   {
; 1513 :     regs->psw.cc = 0;

  0014f	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00157	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1514 :     return;

  0015b	e9 a3 07 00 00	 jmp	 $LN1@z900_km_ae
$LN15@z900_km_ae:

; 1515 :   }
; 1516 : 
; 1517 :   /* Initialize values */
; 1518 :   tfc = GR0_tfc(regs);

  00160	b8 08 00 00 00	 mov	 eax, 8
  00165	48 6b c0 00	 imul	 rax, rax, 0
  00169	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00178	83 e0 7f	 and	 eax, 127		; 0000007fH
  0017b	83 e0 77	 and	 eax, 119		; 00000077H
  0017e	89 44 24 64	 mov	 DWORD PTR tfc$[rsp], eax

; 1519 :   wrap = GR0_wrap(regs);

  00182	b8 08 00 00 00	 mov	 eax, 8
  00187	48 6b c0 00	 imul	 rax, rax, 0
  0018b	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00193	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0019a	83 e0 08	 and	 eax, 8
  0019d	85 c0		 test	 eax, eax
  0019f	74 0a		 je	 SHORT $LN47@z900_km_ae
  001a1	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001a9	eb 08		 jmp	 SHORT $LN48@z900_km_ae
$LN47@z900_km_ae:
  001ab	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN48@z900_km_ae:
  001b3	8b 44 24 48	 mov	 eax, DWORD PTR tv193[rsp]
  001b7	89 44 24 4c	 mov	 DWORD PTR wrap$[rsp], eax

; 1520 :   keylen = (tfc - 17) * 8 + 8;

  001bb	8b 44 24 64	 mov	 eax, DWORD PTR tfc$[rsp]
  001bf	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  001c6	89 44 24 34	 mov	 DWORD PTR keylen$[rsp], eax

; 1521 :   parameter_blocklen = keylen;

  001ca	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  001ce	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1522 :   if(wrap)

  001d2	83 7c 24 4c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001d7	74 0b		 je	 SHORT $LN16@z900_km_ae

; 1523 :     parameter_blocklen += 32;

  001d9	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001dd	83 c0 20	 add	 eax, 32			; 00000020H
  001e0	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN16@z900_km_ae:

; 1524 : 
; 1525 :   /* Fetch the parameter block */
; 1526 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001e4	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001ec	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001f2	83 e0 01	 and	 eax, 1
  001f5	85 c0		 test	 eax, eax
  001f7	74 23		 je	 SHORT $LN49@z900_km_ae
  001f9	b8 08 00 00 00	 mov	 eax, 8
  001fe	48 6b c0 01	 imul	 rax, rax, 1
  00202	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020a	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00212	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv213[rsp], rax
  0021a	eb 20		 jmp	 SHORT $LN50@z900_km_ae
$LN49@z900_km_ae:
  0021c	b8 08 00 00 00	 mov	 eax, 8
  00221	48 6b c0 01	 imul	 rax, rax, 1
  00225	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0022d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00234	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv213[rsp], rax
$LN50@z900_km_ae:
  0023c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00244	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0024b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv213[rsp]
  00253	48 23 c8	 and	 rcx, rax
  00256	48 8b c1	 mov	 rax, rcx
  00259	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0025d	ff c9		 dec	 ecx
  0025f	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00267	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0026c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00272	4c 8b c0	 mov	 r8, rax
  00275	0f b6 d1	 movzx	 edx, cl
  00278	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00280	e8 00 00 00 00	 call	 z900_vfetchc

; 1527 : 
; 1528 : #ifdef OPTION_KM_DEBUG
; 1529 :   LOGBYTE("k     :", parameter_block, keylen);
; 1530 :   if(wrap)
; 1531 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 32);
; 1532 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1533 : 
; 1534 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1535 :   /* Verify and unwrap */
; 1536 :   if(wrap && unwrap_aes(parameter_block, keylen))

  00285	83 7c 24 4c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0028a	74 26		 je	 SHORT $LN17@z900_km_ae
  0028c	8b 54 24 34	 mov	 edx, DWORD PTR keylen$[rsp]
  00290	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00298	e8 00 00 00 00	 call	 unwrap_aes
  0029d	85 c0		 test	 eax, eax
  0029f	74 11		 je	 SHORT $LN17@z900_km_ae

; 1537 :   {
; 1538 : 
; 1539 : #ifdef OPTION_KM_DEBUG
; 1540 :     WRMSG(HHC90111, "D");
; 1541 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1542 : 
; 1543 :     regs->psw.cc = 1;

  002a1	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a9	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1544 :     return;

  002ad	e9 51 06 00 00	 jmp	 $LN1@z900_km_ae
$LN17@z900_km_ae:

; 1545 :   }
; 1546 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1547 : 
; 1548 :   /* Set the cryptographic keys */
; 1549 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  002b2	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  002b6	c1 e0 03	 shl	 eax, 3
  002b9	44 8b c0	 mov	 r8d, eax
  002bc	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002c4	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  002cc	e8 00 00 00 00	 call	 rijndael_set_key

; 1550 : 
; 1551 :   /* Try to process the CPU-determined amount of data */
; 1552 :   modifier_bit = GR0_m(regs);

  002d1	b8 08 00 00 00	 mov	 eax, 8
  002d6	48 6b c0 00	 imul	 rax, rax, 0
  002da	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002e9	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002ee	85 c0		 test	 eax, eax
  002f0	74 0a		 je	 SHORT $LN51@z900_km_ae
  002f2	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv237[rsp], 1
  002fa	eb 08		 jmp	 SHORT $LN52@z900_km_ae
$LN51@z900_km_ae:
  002fc	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv237[rsp], 0
$LN52@z900_km_ae:
  00304	8b 44 24 50	 mov	 eax, DWORD PTR tv237[rsp]
  00308	89 44 24 68	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1553 :   r1_is_not_r2 = r1 != r2;

  0030c	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00313	39 84 24 30 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0031a	74 0a		 je	 SHORT $LN53@z900_km_ae
  0031c	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv239[rsp], 1
  00324	eb 08		 jmp	 SHORT $LN54@z900_km_ae
$LN53@z900_km_ae:
  00326	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv239[rsp], 0
$LN54@z900_km_ae:
  0032e	8b 44 24 54	 mov	 eax, DWORD PTR tv239[rsp]
  00332	89 44 24 6c	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1554 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00336	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0033e	eb 0b		 jmp	 SHORT $LN4@z900_km_ae
$LN2@z900_km_ae:
  00340	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  00344	83 c0 10	 add	 eax, 16
  00347	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@z900_km_ae:
  0034b	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00353	0f 8d 9e 05 00
	00		 jge	 $LN3@z900_km_ae

; 1555 :   {
; 1556 :     /* Fetch a block of data */
; 1557 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00359	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00361	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00367	83 e0 01	 and	 eax, 1
  0036a	85 c0		 test	 eax, eax
  0036c	74 22		 je	 SHORT $LN55@z900_km_ae
  0036e	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00376	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00386	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv258[rsp], rax
  0038e	eb 1f		 jmp	 SHORT $LN56@z900_km_ae
$LN55@z900_km_ae:
  00390	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00398	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003a7	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv258[rsp], rax
$LN56@z900_km_ae:
  003af	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  003be	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv258[rsp]
  003c6	48 23 c8	 and	 rcx, rax
  003c9	48 8b c1	 mov	 rax, rcx
  003cc	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003d9	44 8b 8c 24 38
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  003e1	4c 8b c0	 mov	 r8, rax
  003e4	b2 0f		 mov	 dl, 15
  003e6	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  003ee	e8 00 00 00 00	 call	 z900_vfetchc

; 1558 : 
; 1559 : #ifdef OPTION_KM_DEBUG
; 1560 :     LOGBYTE("input :", message_block, 16);
; 1561 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1562 : 
; 1563 :     /* Do the job */
; 1564 :     if(modifier_bit)

  003f3	83 7c 24 68 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  003f8	74 1f		 je	 SHORT $LN18@z900_km_ae

; 1565 :       rijndael_decrypt(&context, message_block, message_block);

  003fa	4c 8d 84 24 c0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00402	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0040a	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00412	e8 00 00 00 00	 call	 rijndael_decrypt
  00417	eb 1d		 jmp	 SHORT $LN19@z900_km_ae
$LN18@z900_km_ae:

; 1566 :     else
; 1567 :       rijndael_encrypt(&context, message_block, message_block);

  00419	4c 8d 84 24 c0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00421	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00429	48 8d 8c 24 d0
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00431	e8 00 00 00 00	 call	 rijndael_encrypt
$LN19@z900_km_ae:

; 1568 : 
; 1569 :     /* Store the output */
; 1570 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00436	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00444	83 e0 01	 and	 eax, 1
  00447	85 c0		 test	 eax, eax
  00449	74 22		 je	 SHORT $LN57@z900_km_ae
  0044b	48 63 84 24 30
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00453	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00463	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
  0046b	eb 1f		 jmp	 SHORT $LN58@z900_km_ae
$LN57@z900_km_ae:
  0046d	48 63 84 24 30
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00475	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00484	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv287[rsp], rax
$LN58@z900_km_ae:
  0048c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00494	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0049b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv287[rsp]
  004a3	48 23 c8	 and	 rcx, rax
  004a6	48 8b c1	 mov	 rax, rcx
  004a9	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004b6	44 8b 8c 24 30
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  004be	4c 8b c0	 mov	 r8, rax
  004c1	b2 0f		 mov	 dl, 15
  004c3	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  004cb	e8 00 00 00 00	 call	 z900_vstorec
$LN7@z900_km_ae:

; 1571 : 
; 1572 : #ifdef OPTION_KM_DEBUG
; 1573 :     LOGBYTE("output:", message_block, 16);
; 1574 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1575 : 
; 1576 :     /* Update the registers */
; 1577 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  004d0	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004de	83 e0 01	 and	 eax, 1
  004e1	85 c0		 test	 eax, eax
  004e3	74 7c		 je	 SHORT $LN20@z900_km_ae
  004e5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004ed	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004f3	83 e0 01	 and	 eax, 1
  004f6	85 c0		 test	 eax, eax
  004f8	74 22		 je	 SHORT $LN59@z900_km_ae
  004fa	48 63 84 24 30
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00502	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00512	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv315[rsp], rax
  0051a	eb 1f		 jmp	 SHORT $LN60@z900_km_ae
$LN59@z900_km_ae:
  0051c	48 63 84 24 30
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00524	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00533	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv315[rsp], rax
$LN60@z900_km_ae:
  0053b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv315[rsp]
  00543	48 83 c0 10	 add	 rax, 16
  00547	48 63 8c 24 30
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0054f	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00557	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  0055f	eb 79		 jmp	 SHORT $LN21@z900_km_ae
$LN20@z900_km_ae:
  00561	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00569	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0056f	83 e0 01	 and	 eax, 1
  00572	85 c0		 test	 eax, eax
  00574	74 22		 je	 SHORT $LN61@z900_km_ae
  00576	48 63 84 24 30
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0057e	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00586	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0058e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
  00596	eb 1f		 jmp	 SHORT $LN62@z900_km_ae
$LN61@z900_km_ae:
  00598	48 63 84 24 30
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  005a0	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005a8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005af	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv336[rsp], rax
$LN62@z900_km_ae:
  005b7	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv336[rsp]
  005bf	48 83 c0 10	 add	 rax, 16
  005c3	48 63 8c 24 30
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  005cb	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005d3	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN21@z900_km_ae:
  005da	33 c0		 xor	 eax, eax
  005dc	85 c0		 test	 eax, eax
  005de	0f 85 ec fe ff
	ff		 jne	 $LN7@z900_km_ae

; 1578 :     if(likely(r1_is_not_r2))

  005e4	83 7c 24 6c 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  005e9	74 0a		 je	 SHORT $LN63@z900_km_ae
  005eb	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv341[rsp], 1
  005f3	eb 08		 jmp	 SHORT $LN64@z900_km_ae
$LN63@z900_km_ae:
  005f5	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv341[rsp], 0
$LN64@z900_km_ae:
  005fd	83 7c 24 58 00	 cmp	 DWORD PTR tv341[rsp], 0
  00602	0f 84 14 01 00
	00		 je	 $LN22@z900_km_ae
$LN10@z900_km_ae:

; 1579 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  00608	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00610	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00616	83 e0 01	 and	 eax, 1
  00619	85 c0		 test	 eax, eax
  0061b	74 7c		 je	 SHORT $LN23@z900_km_ae
  0061d	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00625	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0062b	83 e0 01	 and	 eax, 1
  0062e	85 c0		 test	 eax, eax
  00630	74 22		 je	 SHORT $LN65@z900_km_ae
  00632	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0063a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00642	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0064a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
  00652	eb 1f		 jmp	 SHORT $LN66@z900_km_ae
$LN65@z900_km_ae:
  00654	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0065c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00664	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0066b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv365[rsp], rax
$LN66@z900_km_ae:
  00673	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv365[rsp]
  0067b	48 83 c0 10	 add	 rax, 16
  0067f	48 63 8c 24 38
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00687	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0068f	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00697	eb 79		 jmp	 SHORT $LN24@z900_km_ae
$LN23@z900_km_ae:
  00699	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006a1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006a7	83 e0 01	 and	 eax, 1
  006aa	85 c0		 test	 eax, eax
  006ac	74 22		 je	 SHORT $LN67@z900_km_ae
  006ae	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  006b6	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006be	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  006c6	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv386[rsp], rax
  006ce	eb 1f		 jmp	 SHORT $LN68@z900_km_ae
$LN67@z900_km_ae:
  006d0	48 63 84 24 38
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  006d8	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006e7	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv386[rsp], rax
$LN68@z900_km_ae:
  006ef	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv386[rsp]
  006f7	48 83 c0 10	 add	 rax, 16
  006fb	48 63 8c 24 38
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00703	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0070b	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN24@z900_km_ae:
  00712	33 c0		 xor	 eax, eax
  00714	85 c0		 test	 eax, eax
  00716	0f 85 ec fe ff
	ff		 jne	 $LN10@z900_km_ae
$LN22@z900_km_ae:
$LN13@z900_km_ae:

; 1580 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  0071c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00724	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0072a	83 e0 01	 and	 eax, 1
  0072d	85 c0		 test	 eax, eax
  0072f	0f 84 89 00 00
	00		 je	 $LN25@z900_km_ae
  00735	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0073d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00743	83 e0 01	 and	 eax, 1
  00746	85 c0		 test	 eax, eax
  00748	74 25		 je	 SHORT $LN69@z900_km_ae
  0074a	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00751	ff c0		 inc	 eax
  00753	48 98		 cdqe
  00755	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0075d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00765	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv415[rsp], rax
  0076d	eb 22		 jmp	 SHORT $LN70@z900_km_ae
$LN69@z900_km_ae:
  0076f	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00776	ff c0		 inc	 eax
  00778	48 98		 cdqe
  0077a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00782	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00789	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv415[rsp], rax
$LN70@z900_km_ae:
  00791	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv415[rsp]
  00799	48 83 e8 10	 sub	 rax, 16
  0079d	8b 8c 24 38 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  007a4	ff c1		 inc	 ecx
  007a6	48 63 c9	 movsxd	 rcx, ecx
  007a9	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007b1	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  007b9	e9 83 00 00 00	 jmp	 $LN26@z900_km_ae
$LN25@z900_km_ae:
  007be	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  007cc	83 e0 01	 and	 eax, 1
  007cf	85 c0		 test	 eax, eax
  007d1	74 25		 je	 SHORT $LN71@z900_km_ae
  007d3	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  007da	ff c0		 inc	 eax
  007dc	48 98		 cdqe
  007de	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007e6	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007ee	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
  007f6	eb 22		 jmp	 SHORT $LN72@z900_km_ae
$LN71@z900_km_ae:
  007f8	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  007ff	ff c0		 inc	 eax
  00801	48 98		 cdqe
  00803	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0080b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00812	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
$LN72@z900_km_ae:
  0081a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv439[rsp]
  00822	48 83 e8 10	 sub	 rax, 16
  00826	8b 8c 24 38 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0082d	ff c1		 inc	 ecx
  0082f	48 63 c9	 movsxd	 rcx, ecx
  00832	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0083a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN26@z900_km_ae:
  00841	33 c0		 xor	 eax, eax
  00843	85 c0		 test	 eax, eax
  00845	0f 85 d1 fe ff
	ff		 jne	 $LN13@z900_km_ae

; 1581 : 
; 1582 : #ifdef OPTION_KM_DEBUG
; 1583 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1584 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1585 :     WRMSG(HHC90108, "D", (regs)->GR(r2 + 1));
; 1586 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1587 : 
; 1588 :     /* check for end of data */
; 1589 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0084b	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00853	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00859	83 e0 01	 and	 eax, 1
  0085c	85 c0		 test	 eax, eax
  0085e	74 25		 je	 SHORT $LN73@z900_km_ae
  00860	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00867	ff c0		 inc	 eax
  00869	48 98		 cdqe
  0086b	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00873	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0087b	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv459[rsp], rax
  00883	eb 22		 jmp	 SHORT $LN74@z900_km_ae
$LN73@z900_km_ae:
  00885	8b 84 24 38 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0088c	ff c0		 inc	 eax
  0088e	48 98		 cdqe
  00890	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00898	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0089f	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv459[rsp], rax
$LN74@z900_km_ae:
  008a7	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR tv459[rsp], 0
  008b0	75 0a		 jne	 SHORT $LN75@z900_km_ae
  008b2	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv461[rsp], 1
  008ba	eb 08		 jmp	 SHORT $LN76@z900_km_ae
$LN75@z900_km_ae:
  008bc	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv461[rsp], 0
$LN76@z900_km_ae:
  008c4	83 7c 24 5c 00	 cmp	 DWORD PTR tv461[rsp], 0
  008c9	74 0a		 je	 SHORT $LN81@z900_km_ae
  008cb	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv482[rsp], 1
  008d3	eb 08		 jmp	 SHORT $LN82@z900_km_ae
$LN81@z900_km_ae:
  008d5	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv482[rsp], 0
$LN82@z900_km_ae:
  008dd	83 7c 24 60 00	 cmp	 DWORD PTR tv482[rsp], 0
  008e2	74 0e		 je	 SHORT $LN27@z900_km_ae

; 1590 :     {
; 1591 :       regs->psw.cc = 0;

  008e4	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ec	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1592 :       return;

  008f0	eb 11		 jmp	 SHORT $LN1@z900_km_ae
$LN27@z900_km_ae:

; 1593 :     }
; 1594 :   }

  008f2	e9 49 fa ff ff	 jmp	 $LN2@z900_km_ae
$LN3@z900_km_ae:

; 1595 : 
; 1596 :   /* CPU-determined amount of data processed */
; 1597 :   regs->psw.cc = 3;

  008f7	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ff	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_km_ae:

; 1598 : }

  00903	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0090b	48 33 cc	 xor	 rcx, rsp
  0090e	e8 00 00 00 00	 call	 __security_check_cookie
  00913	48 81 c4 28 03
	00 00		 add	 rsp, 808		; 00000328H
  0091a	c3		 ret	 0
z900_km_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
tv225 = 52
crypted$ = 56
tfc$ = 60
tv277 = 64
tv135 = 68
tv157 = 72
tv178 = 76
tv193 = 80
wrap$ = 84
keylen$ = 88
tv250 = 92
tv252 = 96
modifier_bit$ = 100
tv365 = 104
tv485 = 108
tv506 = 112
r1_is_not_r2$ = 116
tv80 = 120
tv155 = 128
tv211 = 136
tv271 = 144
tv311 = 152
tv339 = 160
tv360 = 168
tv389 = 176
tv410 = 184
tv439 = 192
tv463 = 200
tv483 = 208
des_ctx$ = 224
des3_ctx$ = 368
message_block$ = 784
parameter_block$ = 792
__$ArrayPad$ = 840
r1$ = 864
r2$ = 872
regs$ = 880
z900_km_dea PROC

; 1329 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 58 03
	00 00		 sub	 rsp, 856		; 00000358H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 48
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1330 :   int crypted;
; 1331 :   des_context des_ctx;
; 1332 :   des3_context des3_ctx;
; 1333 :   int keylen;
; 1334 :   BYTE message_block[8];
; 1335 :   int modifier_bit;
; 1336 :   BYTE parameter_block[48];
; 1337 :   int parameter_blocklen;
; 1338 :   int r1_is_not_r2;
; 1339 :   int tfc;
; 1340 :   int wrap;
; 1341 : 
; 1342 :   /* Check special conditions */
; 1343 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0002e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00034	83 e0 01	 and	 eax, 1
  00037	85 c0		 test	 eax, eax
  00039	74 22		 je	 SHORT $LN41@z900_km_de
  0003b	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00042	ff c0		 inc	 eax
  00044	48 98		 cdqe
  00046	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00056	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
  0005b	eb 1f		 jmp	 SHORT $LN42@z900_km_de
$LN41@z900_km_de:
  0005d	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00064	ff c0		 inc	 eax
  00066	48 98		 cdqe
  00068	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00070	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00077	48 89 44 24 78	 mov	 QWORD PTR tv80[rsp], rax
$LN42@z900_km_de:
  0007c	33 d2		 xor	 edx, edx
  0007e	48 8b 44 24 78	 mov	 rax, QWORD PTR tv80[rsp]
  00083	b9 08 00 00 00	 mov	 ecx, 8
  00088	48 f7 f1	 div	 rcx
  0008b	48 8b c2	 mov	 rax, rdx
  0008e	48 85 c0	 test	 rax, rax
  00091	74 0a		 je	 SHORT $LN47@z900_km_de
  00093	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv135[rsp], 1
  0009b	eb 08		 jmp	 SHORT $LN48@z900_km_de
$LN47@z900_km_de:
  0009d	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN48@z900_km_de:
  000a5	83 7c 24 44 00	 cmp	 DWORD PTR tv135[rsp], 0
  000aa	74 13		 je	 SHORT $LN18@z900_km_de

; 1344 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000ac	ba 06 00 00 00	 mov	 edx, 6
  000b1	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN18@z900_km_de:

; 1345 : 
; 1346 :   /* Return with cc 0 on zero length */
; 1347 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000bf	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000cd	83 e0 01	 and	 eax, 1
  000d0	85 c0		 test	 eax, eax
  000d2	74 25		 je	 SHORT $LN49@z900_km_de
  000d4	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000db	ff c0		 inc	 eax
  000dd	48 98		 cdqe
  000df	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000ef	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
  000f7	eb 22		 jmp	 SHORT $LN50@z900_km_de
$LN49@z900_km_de:
  000f9	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00100	ff c0		 inc	 eax
  00102	48 98		 cdqe
  00104	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00113	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv155[rsp], rax
$LN50@z900_km_de:
  0011b	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR tv155[rsp], 0
  00124	75 0a		 jne	 SHORT $LN51@z900_km_de
  00126	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv157[rsp], 1
  0012e	eb 08		 jmp	 SHORT $LN52@z900_km_de
$LN51@z900_km_de:
  00130	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv157[rsp], 0
$LN52@z900_km_de:
  00138	83 7c 24 48 00	 cmp	 DWORD PTR tv157[rsp], 0
  0013d	74 0a		 je	 SHORT $LN57@z900_km_de
  0013f	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  00147	eb 08		 jmp	 SHORT $LN58@z900_km_de
$LN57@z900_km_de:
  00149	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN58@z900_km_de:
  00151	83 7c 24 4c 00	 cmp	 DWORD PTR tv178[rsp], 0
  00156	74 11		 je	 SHORT $LN19@z900_km_de

; 1348 :   {
; 1349 :     regs->psw.cc = 0;

  00158	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00160	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1350 :     return;

  00164	e9 85 08 00 00	 jmp	 $LN1@z900_km_de
$LN19@z900_km_de:

; 1351 :   }
; 1352 : 
; 1353 :   /* Initialize values */
; 1354 :   tfc = GR0_tfc(regs);

  00169	b8 08 00 00 00	 mov	 eax, 8
  0016e	48 6b c0 00	 imul	 rax, rax, 0
  00172	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0017a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00181	83 e0 7f	 and	 eax, 127		; 0000007fH
  00184	83 e0 77	 and	 eax, 119		; 00000077H
  00187	89 44 24 3c	 mov	 DWORD PTR tfc$[rsp], eax

; 1355 :   wrap = GR0_wrap(regs);

  0018b	b8 08 00 00 00	 mov	 eax, 8
  00190	48 6b c0 00	 imul	 rax, rax, 0
  00194	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019c	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a3	83 e0 08	 and	 eax, 8
  001a6	85 c0		 test	 eax, eax
  001a8	74 0a		 je	 SHORT $LN59@z900_km_de
  001aa	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  001b2	eb 08		 jmp	 SHORT $LN60@z900_km_de
$LN59@z900_km_de:
  001b4	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN60@z900_km_de:
  001bc	8b 44 24 50	 mov	 eax, DWORD PTR tv193[rsp]
  001c0	89 44 24 54	 mov	 DWORD PTR wrap$[rsp], eax

; 1356 :   keylen = tfc * 8;

  001c4	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  001c8	c1 e0 03	 shl	 eax, 3
  001cb	89 44 24 58	 mov	 DWORD PTR keylen$[rsp], eax

; 1357 :   parameter_blocklen = keylen;

  001cf	8b 44 24 58	 mov	 eax, DWORD PTR keylen$[rsp]
  001d3	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1358 :   if(wrap)

  001d7	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001dc	74 0b		 je	 SHORT $LN20@z900_km_de

; 1359 :     parameter_blocklen += 24;

  001de	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001e2	83 c0 18	 add	 eax, 24
  001e5	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN20@z900_km_de:

; 1360 : 
; 1361 :   /* Fetch the parameter block */
; 1362 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001e9	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001f1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  001f7	83 e0 01	 and	 eax, 1
  001fa	85 c0		 test	 eax, eax
  001fc	74 23		 je	 SHORT $LN61@z900_km_de
  001fe	b8 08 00 00 00	 mov	 eax, 8
  00203	48 6b c0 01	 imul	 rax, rax, 1
  00207	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0020f	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00217	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
  0021f	eb 20		 jmp	 SHORT $LN62@z900_km_de
$LN61@z900_km_de:
  00221	b8 08 00 00 00	 mov	 eax, 8
  00226	48 6b c0 01	 imul	 rax, rax, 1
  0022a	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00239	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv211[rsp], rax
$LN62@z900_km_de:
  00241	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00249	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00250	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv211[rsp]
  00258	48 23 c8	 and	 rcx, rax
  0025b	48 8b c1	 mov	 rax, rcx
  0025e	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00262	ff c9		 dec	 ecx
  00264	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0026c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00271	41 b9 01 00 00
	00		 mov	 r9d, 1
  00277	4c 8b c0	 mov	 r8, rax
  0027a	0f b6 d1	 movzx	 edx, cl
  0027d	48 8d 8c 24 18
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00285	e8 00 00 00 00	 call	 z900_vfetchc

; 1363 : 
; 1364 : #ifdef OPTION_KM_DEBUG
; 1365 :   switch(tfc)
; 1366 :   {
; 1367 :     case 1: /* dea */
; 1368 :     {
; 1369 :       LOGBYTE("k     :", parameter_block, 8);
; 1370 :       break;
; 1371 :     }
; 1372 :     case 2: /* tdea-128 */
; 1373 :     {
; 1374 :       LOGBYTE("k1    :", parameter_block, 8);
; 1375 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 1376 :       break;
; 1377 :     }
; 1378 :     case 3: /* tdea-192 */
; 1379 :     {
; 1380 :       LOGBYTE("k1    :", parameter_block, 8);
; 1381 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 1382 :       LOGBYTE("k3    :", &parameter_block[16], 8);
; 1383 :       break;
; 1384 :     }
; 1385 :   }
; 1386 :   if(wrap)
; 1387 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 24);
; 1388 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1389 : 
; 1390 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1391 :   /* Verify and unwrap */
; 1392 :   if(wrap && unwrap_dea(parameter_block, keylen))

  0028a	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0028f	74 26		 je	 SHORT $LN21@z900_km_de
  00291	8b 54 24 58	 mov	 edx, DWORD PTR keylen$[rsp]
  00295	48 8d 8c 24 18
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0029d	e8 00 00 00 00	 call	 unwrap_dea
  002a2	85 c0		 test	 eax, eax
  002a4	74 11		 je	 SHORT $LN21@z900_km_de

; 1393 :   {
; 1394 : 
; 1395 : #ifdef OPTION_KM_DEBUG
; 1396 :     WRMSG(HHC90111, "D");
; 1397 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1398 : 
; 1399 :     regs->psw.cc = 1;

  002a6	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002ae	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1400 :     return;

  002b2	e9 37 07 00 00	 jmp	 $LN1@z900_km_de
$LN21@z900_km_de:

; 1401 :   }
; 1402 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1403 : 
; 1404 :   /* Set the cryptographic key */
; 1405 :   switch(tfc)

  002b7	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  002bb	89 44 24 34	 mov	 DWORD PTR tv225[rsp], eax
  002bf	83 7c 24 34 01	 cmp	 DWORD PTR tv225[rsp], 1
  002c4	74 10		 je	 SHORT $LN22@z900_km_de
  002c6	83 7c 24 34 02	 cmp	 DWORD PTR tv225[rsp], 2
  002cb	74 20		 je	 SHORT $LN23@z900_km_de
  002cd	83 7c 24 34 03	 cmp	 DWORD PTR tv225[rsp], 3
  002d2	74 44		 je	 SHORT $LN24@z900_km_de
  002d4	eb 7f		 jmp	 SHORT $LN2@z900_km_de
$LN22@z900_km_de:

; 1406 :   {
; 1407 :     case 1: /* dea */
; 1408 :     {
; 1409 :       des_set_key(&des_ctx, parameter_block);

  002d6	48 8d 94 24 18
	03 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002de	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  002e6	e8 00 00 00 00	 call	 des_set_key

; 1410 :       break;

  002eb	eb 68		 jmp	 SHORT $LN2@z900_km_de
$LN23@z900_km_de:

; 1411 :     }
; 1412 :     case 2: /* tdea-128 */
; 1413 :     {
; 1414 :       des3_set_2keys(&des3_ctx, parameter_block, &parameter_block[8]);

  002ed	b8 01 00 00 00	 mov	 eax, 1
  002f2	48 6b c0 08	 imul	 rax, rax, 8
  002f6	48 8d 84 04 18
	03 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002fe	4c 8b c0	 mov	 r8, rax
  00301	48 8d 94 24 18
	03 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00309	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  00311	e8 00 00 00 00	 call	 des3_set_2keys

; 1415 :       break;

  00316	eb 3d		 jmp	 SHORT $LN2@z900_km_de
$LN24@z900_km_de:

; 1416 :     }
; 1417 :     case 3: /* tdea-192 */
; 1418 :     {
; 1419 :       des3_set_3keys(&des3_ctx, parameter_block, &parameter_block[8], &parameter_block[16]);

  00318	b8 01 00 00 00	 mov	 eax, 1
  0031d	48 6b c0 10	 imul	 rax, rax, 16
  00321	48 8d 84 04 18
	03 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00329	b9 01 00 00 00	 mov	 ecx, 1
  0032e	48 6b c9 08	 imul	 rcx, rcx, 8
  00332	48 8d 8c 0c 18
	03 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0033a	4c 8b c8	 mov	 r9, rax
  0033d	4c 8b c1	 mov	 r8, rcx
  00340	48 8d 94 24 18
	03 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00348	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  00350	e8 00 00 00 00	 call	 des3_set_3keys
$LN2@z900_km_de:

; 1420 :       break;
; 1421 :     }
; 1422 :   }
; 1423 : 
; 1424 :   /* Try to process the CPU-determined amount of data */
; 1425 :   modifier_bit = GR0_m(regs);

  00355	b8 08 00 00 00	 mov	 eax, 8
  0035a	48 6b c0 00	 imul	 rax, rax, 0
  0035e	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00366	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0036d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00372	85 c0		 test	 eax, eax
  00374	74 0a		 je	 SHORT $LN63@z900_km_de
  00376	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv250[rsp], 1
  0037e	eb 08		 jmp	 SHORT $LN64@z900_km_de
$LN63@z900_km_de:
  00380	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv250[rsp], 0
$LN64@z900_km_de:
  00388	8b 44 24 5c	 mov	 eax, DWORD PTR tv250[rsp]
  0038c	89 44 24 64	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1426 :   r1_is_not_r2 = r1 != r2;

  00390	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00397	39 84 24 60 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0039e	74 0a		 je	 SHORT $LN65@z900_km_de
  003a0	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv252[rsp], 1
  003a8	eb 08		 jmp	 SHORT $LN66@z900_km_de
$LN65@z900_km_de:
  003aa	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN66@z900_km_de:
  003b2	8b 44 24 60	 mov	 eax, DWORD PTR tv252[rsp]
  003b6	89 44 24 74	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1427 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  003ba	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  003c2	eb 0b		 jmp	 SHORT $LN6@z900_km_de
$LN4@z900_km_de:
  003c4	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  003c8	83 c0 08	 add	 eax, 8
  003cb	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@z900_km_de:
  003cf	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  003d7	0f 8d 05 06 00
	00		 jge	 $LN5@z900_km_de

; 1428 :   {
; 1429 :     /* Fetch a block of data */
; 1430 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  003dd	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003e5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003eb	83 e0 01	 and	 eax, 1
  003ee	85 c0		 test	 eax, eax
  003f0	74 22		 je	 SHORT $LN67@z900_km_de
  003f2	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003fa	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0040a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
  00412	eb 1f		 jmp	 SHORT $LN68@z900_km_de
$LN67@z900_km_de:
  00414	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0041c	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00424	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0042b	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv271[rsp], rax
$LN68@z900_km_de:
  00433	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0043b	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00442	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv271[rsp]
  0044a	48 23 c8	 and	 rcx, rax
  0044d	48 8b c1	 mov	 rax, rcx
  00450	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00458	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0045d	44 8b 8c 24 68
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00465	4c 8b c0	 mov	 r8, rax
  00468	b2 07		 mov	 dl, 7
  0046a	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00472	e8 00 00 00 00	 call	 z900_vfetchc

; 1431 : 
; 1432 : #ifdef OPTION_KM_DEBUG
; 1433 :     LOGBYTE("input :", message_block, 8);
; 1434 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1435 : 
; 1436 :     /* Do the job */
; 1437 :     switch(tfc)

  00477	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  0047b	89 44 24 40	 mov	 DWORD PTR tv277[rsp], eax
  0047f	83 7c 24 40 01	 cmp	 DWORD PTR tv277[rsp], 1
  00484	74 13		 je	 SHORT $LN25@z900_km_de
  00486	83 7c 24 40 02	 cmp	 DWORD PTR tv277[rsp], 2
  0048b	74 51		 je	 SHORT $LN28@z900_km_de
  0048d	83 7c 24 40 03	 cmp	 DWORD PTR tv277[rsp], 3
  00492	74 4a		 je	 SHORT $LN29@z900_km_de
  00494	e9 88 00 00 00	 jmp	 $LN7@z900_km_de
$LN25@z900_km_de:

; 1438 :     {
; 1439 :       case 1: /* dea */
; 1440 :       {
; 1441 :         if(modifier_bit)

  00499	83 7c 24 64 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0049e	74 1f		 je	 SHORT $LN26@z900_km_de

; 1442 :           des_decrypt(&des_ctx, message_block, message_block);

  004a0	4c 8d 84 24 10
	03 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  004a8	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004b0	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  004b8	e8 00 00 00 00	 call	 des_decrypt
  004bd	eb 1d		 jmp	 SHORT $LN27@z900_km_de
$LN26@z900_km_de:

; 1443 :         else
; 1444 :           des_encrypt(&des_ctx, message_block, message_block);

  004bf	4c 8d 84 24 10
	03 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  004c7	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004cf	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  004d7	e8 00 00 00 00	 call	 des_encrypt
$LN27@z900_km_de:

; 1445 :         break;

  004dc	eb 43		 jmp	 SHORT $LN7@z900_km_de
$LN28@z900_km_de:
$LN29@z900_km_de:

; 1446 :       }
; 1447 :       case 2: /* tdea-128 */
; 1448 :       case 3: /* tdea-192 */
; 1449 :       {
; 1450 :         if(modifier_bit)

  004de	83 7c 24 64 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  004e3	74 1f		 je	 SHORT $LN30@z900_km_de

; 1451 :           des3_decrypt(&des3_ctx, message_block, message_block);

  004e5	4c 8d 84 24 10
	03 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  004ed	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004f5	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  004fd	e8 00 00 00 00	 call	 des3_decrypt
  00502	eb 1d		 jmp	 SHORT $LN31@z900_km_de
$LN30@z900_km_de:

; 1452 :         else
; 1453 :           des3_encrypt(&des3_ctx, message_block, message_block);

  00504	4c 8d 84 24 10
	03 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0050c	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00514	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  0051c	e8 00 00 00 00	 call	 des3_encrypt
$LN31@z900_km_de:
$LN7@z900_km_de:

; 1454 :         break;
; 1455 :       }
; 1456 :     }
; 1457 : 
; 1458 :     /* Store the output */
; 1459 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00521	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00529	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0052f	83 e0 01	 and	 eax, 1
  00532	85 c0		 test	 eax, eax
  00534	74 22		 je	 SHORT $LN69@z900_km_de
  00536	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0053e	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00546	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0054e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv311[rsp], rax
  00556	eb 1f		 jmp	 SHORT $LN70@z900_km_de
$LN69@z900_km_de:
  00558	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00560	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00568	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0056f	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv311[rsp], rax
$LN70@z900_km_de:
  00577	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00586	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv311[rsp]
  0058e	48 23 c8	 and	 rcx, rax
  00591	48 8b c1	 mov	 rax, rcx
  00594	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0059c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  005a1	44 8b 8c 24 60
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  005a9	4c 8b c0	 mov	 r8, rax
  005ac	b2 07		 mov	 dl, 7
  005ae	48 8d 8c 24 10
	03 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  005b6	e8 00 00 00 00	 call	 z900_vstorec
$LN11@z900_km_de:

; 1460 : 
; 1461 : #ifdef OPTION_KM_DEBUG
; 1462 :     LOGBYTE("output:", message_block, 8);
; 1463 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1464 : 
; 1465 :     /* Update the registers */
; 1466 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  005bb	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005c9	83 e0 01	 and	 eax, 1
  005cc	85 c0		 test	 eax, eax
  005ce	74 7c		 je	 SHORT $LN32@z900_km_de
  005d0	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005de	83 e0 01	 and	 eax, 1
  005e1	85 c0		 test	 eax, eax
  005e3	74 22		 je	 SHORT $LN71@z900_km_de
  005e5	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  005ed	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f5	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  005fd	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv339[rsp], rax
  00605	eb 1f		 jmp	 SHORT $LN72@z900_km_de
$LN71@z900_km_de:
  00607	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0060f	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00617	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0061e	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv339[rsp], rax
$LN72@z900_km_de:
  00626	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR tv339[rsp]
  0062e	48 83 c0 08	 add	 rax, 8
  00632	48 63 8c 24 60
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0063a	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00642	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  0064a	eb 79		 jmp	 SHORT $LN33@z900_km_de
$LN32@z900_km_de:
  0064c	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00654	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0065a	83 e0 01	 and	 eax, 1
  0065d	85 c0		 test	 eax, eax
  0065f	74 22		 je	 SHORT $LN73@z900_km_de
  00661	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00669	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00671	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00679	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv360[rsp], rax
  00681	eb 1f		 jmp	 SHORT $LN74@z900_km_de
$LN73@z900_km_de:
  00683	48 63 84 24 60
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0068b	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00693	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0069a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv360[rsp], rax
$LN74@z900_km_de:
  006a2	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv360[rsp]
  006aa	48 83 c0 08	 add	 rax, 8
  006ae	48 63 8c 24 60
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  006b6	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006be	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN33@z900_km_de:
  006c5	33 c0		 xor	 eax, eax
  006c7	85 c0		 test	 eax, eax
  006c9	0f 85 ec fe ff
	ff		 jne	 $LN11@z900_km_de

; 1467 :     if(likely(r1_is_not_r2))

  006cf	83 7c 24 74 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  006d4	74 0a		 je	 SHORT $LN75@z900_km_de
  006d6	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv365[rsp], 1
  006de	eb 08		 jmp	 SHORT $LN76@z900_km_de
$LN75@z900_km_de:
  006e0	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv365[rsp], 0
$LN76@z900_km_de:
  006e8	83 7c 24 68 00	 cmp	 DWORD PTR tv365[rsp], 0
  006ed	0f 84 14 01 00
	00		 je	 $LN34@z900_km_de
$LN14@z900_km_de:

; 1468 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  006f3	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006fb	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00701	83 e0 01	 and	 eax, 1
  00704	85 c0		 test	 eax, eax
  00706	74 7c		 je	 SHORT $LN35@z900_km_de
  00708	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00710	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00716	83 e0 01	 and	 eax, 1
  00719	85 c0		 test	 eax, eax
  0071b	74 22		 je	 SHORT $LN77@z900_km_de
  0071d	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00725	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0072d	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00735	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv389[rsp], rax
  0073d	eb 1f		 jmp	 SHORT $LN78@z900_km_de
$LN77@z900_km_de:
  0073f	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00747	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0074f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00756	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv389[rsp], rax
$LN78@z900_km_de:
  0075e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR tv389[rsp]
  00766	48 83 c0 08	 add	 rax, 8
  0076a	48 63 8c 24 68
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00772	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0077a	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00782	eb 79		 jmp	 SHORT $LN36@z900_km_de
$LN35@z900_km_de:
  00784	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00792	83 e0 01	 and	 eax, 1
  00795	85 c0		 test	 eax, eax
  00797	74 22		 je	 SHORT $LN79@z900_km_de
  00799	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  007a1	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007a9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007b1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv410[rsp], rax
  007b9	eb 1f		 jmp	 SHORT $LN80@z900_km_de
$LN79@z900_km_de:
  007bb	48 63 84 24 68
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  007c3	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007cb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007d2	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv410[rsp], rax
$LN80@z900_km_de:
  007da	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv410[rsp]
  007e2	48 83 c0 08	 add	 rax, 8
  007e6	48 63 8c 24 68
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  007ee	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007f6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN36@z900_km_de:
  007fd	33 c0		 xor	 eax, eax
  007ff	85 c0		 test	 eax, eax
  00801	0f 85 ec fe ff
	ff		 jne	 $LN14@z900_km_de
$LN34@z900_km_de:
$LN17@z900_km_de:

; 1469 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  00807	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0080f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00815	83 e0 01	 and	 eax, 1
  00818	85 c0		 test	 eax, eax
  0081a	0f 84 89 00 00
	00		 je	 $LN37@z900_km_de
  00820	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00828	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0082e	83 e0 01	 and	 eax, 1
  00831	85 c0		 test	 eax, eax
  00833	74 25		 je	 SHORT $LN81@z900_km_de
  00835	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0083c	ff c0		 inc	 eax
  0083e	48 98		 cdqe
  00840	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00848	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00850	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
  00858	eb 22		 jmp	 SHORT $LN82@z900_km_de
$LN81@z900_km_de:
  0085a	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00861	ff c0		 inc	 eax
  00863	48 98		 cdqe
  00865	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0086d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00874	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
$LN82@z900_km_de:
  0087c	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR tv439[rsp]
  00884	48 83 e8 08	 sub	 rax, 8
  00888	8b 8c 24 68 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0088f	ff c1		 inc	 ecx
  00891	48 63 c9	 movsxd	 rcx, ecx
  00894	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0089c	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  008a4	e9 83 00 00 00	 jmp	 $LN38@z900_km_de
$LN37@z900_km_de:
  008a9	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008b1	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008b7	83 e0 01	 and	 eax, 1
  008ba	85 c0		 test	 eax, eax
  008bc	74 25		 je	 SHORT $LN83@z900_km_de
  008be	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008c5	ff c0		 inc	 eax
  008c7	48 98		 cdqe
  008c9	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008d1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008d9	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv463[rsp], rax
  008e1	eb 22		 jmp	 SHORT $LN84@z900_km_de
$LN83@z900_km_de:
  008e3	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008ea	ff c0		 inc	 eax
  008ec	48 98		 cdqe
  008ee	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008f6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008fd	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv463[rsp], rax
$LN84@z900_km_de:
  00905	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv463[rsp]
  0090d	48 83 e8 08	 sub	 rax, 8
  00911	8b 8c 24 68 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00918	ff c1		 inc	 ecx
  0091a	48 63 c9	 movsxd	 rcx, ecx
  0091d	48 8b 94 24 70
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00925	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN38@z900_km_de:
  0092c	33 c0		 xor	 eax, eax
  0092e	85 c0		 test	 eax, eax
  00930	0f 85 d1 fe ff
	ff		 jne	 $LN17@z900_km_de

; 1470 : 
; 1471 : #ifdef OPTION_KM_DEBUG
; 1472 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1473 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1474 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1475 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1476 : 
; 1477 :     /* check for end of data */
; 1478 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00936	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0093e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00944	83 e0 01	 and	 eax, 1
  00947	85 c0		 test	 eax, eax
  00949	74 25		 je	 SHORT $LN85@z900_km_de
  0094b	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00952	ff c0		 inc	 eax
  00954	48 98		 cdqe
  00956	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0095e	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00966	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv483[rsp], rax
  0096e	eb 22		 jmp	 SHORT $LN86@z900_km_de
$LN85@z900_km_de:
  00970	8b 84 24 68 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00977	ff c0		 inc	 eax
  00979	48 98		 cdqe
  0097b	48 8b 8c 24 70
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00983	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0098a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv483[rsp], rax
$LN86@z900_km_de:
  00992	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR tv483[rsp], 0
  0099b	75 0a		 jne	 SHORT $LN87@z900_km_de
  0099d	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv485[rsp], 1
  009a5	eb 08		 jmp	 SHORT $LN88@z900_km_de
$LN87@z900_km_de:
  009a7	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv485[rsp], 0
$LN88@z900_km_de:
  009af	83 7c 24 6c 00	 cmp	 DWORD PTR tv485[rsp], 0
  009b4	74 0a		 je	 SHORT $LN93@z900_km_de
  009b6	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv506[rsp], 1
  009be	eb 08		 jmp	 SHORT $LN94@z900_km_de
$LN93@z900_km_de:
  009c0	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv506[rsp], 0
$LN94@z900_km_de:
  009c8	83 7c 24 70 00	 cmp	 DWORD PTR tv506[rsp], 0
  009cd	74 0e		 je	 SHORT $LN39@z900_km_de

; 1479 :     {
; 1480 :       regs->psw.cc = 0;

  009cf	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009d7	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1481 :       return;

  009db	eb 11		 jmp	 SHORT $LN1@z900_km_de
$LN39@z900_km_de:

; 1482 :     }
; 1483 :   }

  009dd	e9 e2 f9 ff ff	 jmp	 $LN4@z900_km_de
$LN5@z900_km_de:

; 1484 : 
; 1485 :   /* CPU-determined amount of data processed */
; 1486 :   regs->psw.cc = 3;

  009e2	48 8b 84 24 70
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009ea	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_km_de:

; 1487 : }

  009ee	48 8b 8c 24 48
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009f6	48 33 cc	 xor	 rcx, rsp
  009f9	e8 00 00 00 00	 call	 __security_check_cookie
  009fe	48 81 c4 58 03
	00 00		 add	 rsp, 856		; 00000358H
  00a05	c3		 ret	 0
z900_km_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
mbllen$ = 52
message_blocklen$ = 56
parameter_blocklen$ = 60
fc$ = 64
tv70 = 68
tv198 = 72
tv322 = 76
tv349 = 80
tv145 = 84
tv243 = 88
tv310 = 92
tv90 = 96
tv171 = 104
tv189 = 112
tv224 = 120
tv261 = 128
tv281 = 136
tv302 = 144
$T1 = 152
$T2 = 160
$T3 = 168
tv392 = 176
tv439 = 184
tv422 = 192
tv477 = 200
tv460 = 208
sha1_ctx$ = 224
sha2_ctx$ = 320
sha512_ctx$ = 528
parameter_block$ = 736
message_block$ = 816
__$ArrayPad$ = 944
r1$ = 992
r2$ = 1000
regs$ = 1008
z900_klmd_sha PROC

; 1101 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec c8 03
	00 00		 sub	 rsp, 968		; 000003c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1102 :   SHA1_CTX sha1_ctx;
; 1103 : 
; 1104 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1105 :   SHA2_CTX sha2_ctx;
; 1106 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1107 : 
; 1108 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1109 :   SHA2_CTX sha512_ctx;
; 1110 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1111 : 
; 1112 :   int fc;
; 1113 :   int i;
; 1114 :   int mbllen = 0;

  00028	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 0

; 1115 :   BYTE message_block[128];
; 1116 :   int message_blocklen = 0;

  00030	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 0

; 1117 :   BYTE parameter_block[80];
; 1118 :   int parameter_blocklen = 0;

  00038	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 0
$LN4@z900_klmd_:

; 1119 : 
; 1120 :   UNREFERENCED(r1);

  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 fa		 jne	 SHORT $LN4@z900_klmd_

; 1121 : 
; 1122 :   /* Initialize values */
; 1123 :   fc = GR0_fc(regs);

  00046	b8 08 00 00 00	 mov	 eax, 8
  0004b	48 6b c0 00	 imul	 rax, rax, 0
  0004f	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0005e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00061	89 44 24 40	 mov	 DWORD PTR fc$[rsp], eax

; 1124 :   switch(fc)

  00065	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  00069	89 44 24 44	 mov	 DWORD PTR tv70[rsp], eax
  0006d	83 7c 24 44 01	 cmp	 DWORD PTR tv70[rsp], 1
  00072	74 10		 je	 SHORT $LN26@z900_klmd_
  00074	83 7c 24 44 02	 cmp	 DWORD PTR tv70[rsp], 2
  00079	74 23		 je	 SHORT $LN27@z900_klmd_
  0007b	83 7c 24 44 03	 cmp	 DWORD PTR tv70[rsp], 3
  00080	74 36		 je	 SHORT $LN28@z900_klmd_
  00082	eb 4c		 jmp	 SHORT $LN5@z900_klmd_
$LN26@z900_klmd_:

; 1125 :   {
; 1126 :     case 1: /* sha-1 */
; 1127 :     {
; 1128 :       mbllen = 8;

  00084	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 8

; 1129 :       message_blocklen = 64;

  0008c	c7 44 24 38 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 1130 :       parameter_blocklen = 20;

  00094	c7 44 24 3c 14
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 20

; 1131 :       break;

  0009c	eb 32		 jmp	 SHORT $LN5@z900_klmd_
$LN27@z900_klmd_:

; 1132 :     }
; 1133 : 
; 1134 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1135 :     case 2: /* sha-256 */
; 1136 :     {
; 1137 :       mbllen = 8;

  0009e	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 8

; 1138 :       message_blocklen = 64;

  000a6	c7 44 24 38 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 1139 :       parameter_blocklen = 32;

  000ae	c7 44 24 3c 20
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 32 ; 00000020H

; 1140 :       break;

  000b6	eb 18		 jmp	 SHORT $LN5@z900_klmd_
$LN28@z900_klmd_:

; 1141 :     }
; 1142 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1143 : 
; 1144 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1145 :     case 3: /* sha-512 */
; 1146 :     {
; 1147 :       mbllen = 16;

  000b8	c7 44 24 34 10
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 16

; 1148 :       message_blocklen = 128;

  000c0	c7 44 24 38 80
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 128 ; 00000080H

; 1149 :       parameter_blocklen = 64;

  000c8	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 64 ; 00000040H
$LN5@z900_klmd_:

; 1150 :     }
; 1151 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1152 : 
; 1153 :   }
; 1154 : 
; 1155 :   /* Process intermediate message blocks */
; 1156 :   if(unlikely(GR_A(r2 + 1, regs) >= (unsigned) message_blocklen))

  000d0	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000de	83 e0 01	 and	 eax, 1
  000e1	85 c0		 test	 eax, eax
  000e3	74 22		 je	 SHORT $LN48@z900_klmd_
  000e5	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000ec	ff c0		 inc	 eax
  000ee	48 98		 cdqe
  000f0	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00100	48 89 44 24 60	 mov	 QWORD PTR tv90[rsp], rax
  00105	eb 1f		 jmp	 SHORT $LN49@z900_klmd_
$LN48@z900_klmd_:
  00107	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0010e	ff c0		 inc	 eax
  00110	48 98		 cdqe
  00112	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00121	48 89 44 24 60	 mov	 QWORD PTR tv90[rsp], rax
$LN49@z900_klmd_:
  00126	8b 44 24 38	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  0012a	48 39 44 24 60	 cmp	 QWORD PTR tv90[rsp], rax
  0012f	72 0a		 jb	 SHORT $LN54@z900_klmd_
  00131	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00139	eb 08		 jmp	 SHORT $LN55@z900_klmd_
$LN54@z900_klmd_:
  0013b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN55@z900_klmd_:
  00143	83 7c 24 54 00	 cmp	 DWORD PTR tv145[rsp], 0
  00148	74 37		 je	 SHORT $LN29@z900_klmd_

; 1157 :   {
; 1158 :     ARCH_DEP(kimd_sha)(r1, r2, regs, 1);

  0014a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00150	4c 8b 84 24 f0
	03 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00158	8b 94 24 e8 03
	00 00		 mov	 edx, DWORD PTR r2$[rsp]
  0015f	8b 8c 24 e0 03
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00166	e8 00 00 00 00	 call	 z900_kimd_sha

; 1159 :     if(regs->psw.cc == 3)

  0016b	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00173	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00177	83 f8 03	 cmp	 eax, 3
  0017a	75 05		 jne	 SHORT $LN30@z900_klmd_

; 1160 :       return;

  0017c	e9 f2 08 00 00	 jmp	 $LN1@z900_klmd_
$LN30@z900_klmd_:
$LN29@z900_klmd_:

; 1161 :   }
; 1162 : 
; 1163 :   /* Test writeability output chaining value */
; 1164 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  00181	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00189	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0018f	83 e0 01	 and	 eax, 1
  00192	85 c0		 test	 eax, eax
  00194	74 20		 je	 SHORT $LN56@z900_klmd_
  00196	b8 08 00 00 00	 mov	 eax, 8
  0019b	48 6b c0 01	 imul	 rax, rax, 1
  0019f	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a7	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  001af	48 89 44 24 68	 mov	 QWORD PTR tv171[rsp], rax
  001b4	eb 1d		 jmp	 SHORT $LN57@z900_klmd_
$LN56@z900_klmd_:
  001b6	b8 08 00 00 00	 mov	 eax, 8
  001bb	48 6b c0 01	 imul	 rax, rax, 1
  001bf	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c7	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001ce	48 89 44 24 68	 mov	 QWORD PTR tv171[rsp], rax
$LN57@z900_klmd_:
  001d3	8b 44 24 3c	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001d7	ff c8		 dec	 eax
  001d9	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e1	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  001e8	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv171[rsp]
  001ed	48 23 d1	 and	 rdx, rcx
  001f0	48 8b ca	 mov	 rcx, rdx
  001f3	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001fb	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00200	41 b9 02 00 00
	00		 mov	 r9d, 2
  00206	44 8b c0	 mov	 r8d, eax
  00209	ba 01 00 00 00	 mov	 edx, 1
  0020e	e8 00 00 00 00	 call	 z900_validate_operand

; 1165 : 
; 1166 :   /* Fetch the parameter block */
; 1167 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen + mbllen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00213	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00221	83 e0 01	 and	 eax, 1
  00224	85 c0		 test	 eax, eax
  00226	74 20		 je	 SHORT $LN58@z900_klmd_
  00228	b8 08 00 00 00	 mov	 eax, 8
  0022d	48 6b c0 01	 imul	 rax, rax, 1
  00231	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00239	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00241	48 89 44 24 70	 mov	 QWORD PTR tv189[rsp], rax
  00246	eb 1d		 jmp	 SHORT $LN59@z900_klmd_
$LN58@z900_klmd_:
  00248	b8 08 00 00 00	 mov	 eax, 8
  0024d	48 6b c0 01	 imul	 rax, rax, 1
  00251	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00259	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00260	48 89 44 24 70	 mov	 QWORD PTR tv189[rsp], rax
$LN59@z900_klmd_:
  00265	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0026d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00274	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv189[rsp]
  00279	48 23 c8	 and	 rcx, rax
  0027c	48 8b c1	 mov	 rax, rcx
  0027f	8b 4c 24 3c	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00283	8b 54 24 34	 mov	 edx, DWORD PTR mbllen$[rsp]
  00287	8d 4c 11 ff	 lea	 ecx, DWORD PTR [rcx+rdx-1]
  0028b	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00293	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00298	41 b9 01 00 00
	00		 mov	 r9d, 1
  0029e	4c 8b c0	 mov	 r8, rax
  002a1	0f b6 d1	 movzx	 edx, cl
  002a4	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  002ac	e8 00 00 00 00	 call	 z900_vfetchc

; 1168 : 
; 1169 : #ifdef OPTION_KLMD_DEBUG
; 1170 :   if(parameter_blocklen > 32)
; 1171 :   {
; 1172 :     LOGBYTE2("icv   :", parameter_block, 16, parameter_blocklen / 16);
; 1173 :   }
; 1174 :   else
; 1175 :   {
; 1176 :     LOGBYTE("icv   :", parameter_block, parameter_blocklen);
; 1177 :   }
; 1178 :   LOGBYTE("mbl   :", &parameter_block[parameter_blocklen], mbllen);
; 1179 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1180 : 
; 1181 :   /* Set initial chaining value */
; 1182 :   switch(fc)

  002b1	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  002b5	89 44 24 48	 mov	 DWORD PTR tv198[rsp], eax
  002b9	83 7c 24 48 01	 cmp	 DWORD PTR tv198[rsp], 1
  002be	74 10		 je	 SHORT $LN31@z900_klmd_
  002c0	83 7c 24 48 02	 cmp	 DWORD PTR tv198[rsp], 2
  002c5	74 20		 je	 SHORT $LN32@z900_klmd_
  002c7	83 7c 24 48 03	 cmp	 DWORD PTR tv198[rsp], 3
  002cc	74 30		 je	 SHORT $LN33@z900_klmd_
  002ce	eb 43		 jmp	 SHORT $LN7@z900_klmd_
$LN31@z900_klmd_:

; 1183 :   {
; 1184 :     case 1: /* sha-1 */
; 1185 :     {
; 1186 :       sha1_seticv(&sha1_ctx, parameter_block);

  002d0	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002d8	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  002e0	e8 00 00 00 00	 call	 sha1_seticv

; 1187 :       break;

  002e5	eb 2c		 jmp	 SHORT $LN7@z900_klmd_
$LN32@z900_klmd_:

; 1188 :     }
; 1189 : 
; 1190 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1191 :     case 2: /* sha-256 */
; 1192 :     {
; 1193 :       sha256_seticv(&sha2_ctx, parameter_block);

  002e7	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002ef	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  002f7	e8 00 00 00 00	 call	 sha256_seticv

; 1194 :       break;

  002fc	eb 15		 jmp	 SHORT $LN7@z900_klmd_
$LN33@z900_klmd_:

; 1195 :     }
; 1196 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1197 : 
; 1198 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1199 :     case 3: /* sha-512 */
; 1200 :     {
; 1201 :       sha512_seticv(&sha512_ctx, parameter_block);

  002fe	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00306	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  0030e	e8 00 00 00 00	 call	 sha512_seticv
$LN7@z900_klmd_:

; 1202 :       break;
; 1203 :     }
; 1204 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1205 : 
; 1206 :   }
; 1207 : 
; 1208 :   /* Fetch and process possible last block of data */
; 1209 :   if(likely(GR_A(r2 + 1, regs)))

  00313	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0031b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00321	83 e0 01	 and	 eax, 1
  00324	85 c0		 test	 eax, eax
  00326	74 22		 je	 SHORT $LN60@z900_klmd_
  00328	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0032f	ff c0		 inc	 eax
  00331	48 98		 cdqe
  00333	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033b	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00343	48 89 44 24 78	 mov	 QWORD PTR tv224[rsp], rax
  00348	eb 1f		 jmp	 SHORT $LN61@z900_klmd_
$LN60@z900_klmd_:
  0034a	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00351	ff c0		 inc	 eax
  00353	48 98		 cdqe
  00355	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00364	48 89 44 24 78	 mov	 QWORD PTR tv224[rsp], rax
$LN61@z900_klmd_:
  00369	48 83 7c 24 78
	00		 cmp	 QWORD PTR tv224[rsp], 0
  0036f	74 0a		 je	 SHORT $LN64@z900_klmd_
  00371	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv243[rsp], 1
  00379	eb 08		 jmp	 SHORT $LN65@z900_klmd_
$LN64@z900_klmd_:
  0037b	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv243[rsp], 0
$LN65@z900_klmd_:
  00383	83 7c 24 58 00	 cmp	 DWORD PTR tv243[rsp], 0
  00388	0f 84 02 01 00
	00		 je	 $LN34@z900_klmd_

; 1210 :   {
; 1211 :     ARCH_DEP(vfetchc)(message_block, GR_A(r2 + 1, regs) - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0038e	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00396	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0039c	83 e0 01	 and	 eax, 1
  0039f	85 c0		 test	 eax, eax
  003a1	74 22		 je	 SHORT $LN66@z900_klmd_
  003a3	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003ab	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003b3	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003bb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv261[rsp], rax
  003c3	eb 1f		 jmp	 SHORT $LN67@z900_klmd_
$LN66@z900_klmd_:
  003c5	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003cd	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003dc	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv261[rsp], rax
$LN67@z900_klmd_:
  003e4	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003ec	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003f2	83 e0 01	 and	 eax, 1
  003f5	85 c0		 test	 eax, eax
  003f7	74 25		 je	 SHORT $LN68@z900_klmd_
  003f9	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00400	ff c0		 inc	 eax
  00402	48 98		 cdqe
  00404	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040c	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00414	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv281[rsp], rax
  0041c	eb 22		 jmp	 SHORT $LN69@z900_klmd_
$LN68@z900_klmd_:
  0041e	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00425	ff c0		 inc	 eax
  00427	48 98		 cdqe
  00429	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00431	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00438	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv281[rsp], rax
$LN69@z900_klmd_:
  00440	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00448	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0044f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv261[rsp]
  00457	48 23 c8	 and	 rcx, rax
  0045a	48 8b c1	 mov	 rax, rcx
  0045d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv281[rsp]
  00465	48 ff c9	 dec	 rcx
  00468	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00470	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00475	44 8b 8c 24 e8
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0047d	4c 8b c0	 mov	 r8, rax
  00480	0f b6 d1	 movzx	 edx, cl
  00483	48 8d 8c 24 30
	03 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0048b	e8 00 00 00 00	 call	 z900_vfetchc
$LN34@z900_klmd_:

; 1212 : 
; 1213 : #ifdef OPTION_KLMD_DEBUG
; 1214 :     if(GR_A(r2 + 1, regs) > 32)
; 1215 :     {
; 1216 :       LOGBYTE("input :", message_block, 32);
; 1217 :       LOGBYTE("       ", &message_block[32], (int) GR_A(r2 + 1, regs) - 32);
; 1218 :     }
; 1219 :     else
; 1220 :       LOGBYTE("input :", message_block, (int) GR_A(r2 + 1, regs));
; 1221 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1222 : 
; 1223 :   }
; 1224 : 
; 1225 :   /* Do the padding */
; 1226 :   i = GR_A(r2 + 1, regs);

  00490	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00498	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0049e	83 e0 01	 and	 eax, 1
  004a1	85 c0		 test	 eax, eax
  004a3	74 25		 je	 SHORT $LN70@z900_klmd_
  004a5	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004ac	ff c0		 inc	 eax
  004ae	48 98		 cdqe
  004b0	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b8	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  004c0	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv302[rsp], rax
  004c8	eb 22		 jmp	 SHORT $LN71@z900_klmd_
$LN70@z900_klmd_:
  004ca	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004d1	ff c0		 inc	 eax
  004d3	48 98		 cdqe
  004d5	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004dd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004e4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv302[rsp], rax
$LN71@z900_klmd_:
  004ec	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR tv302[rsp]
  004f3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 1227 :   if(unlikely(i >= (message_blocklen - mbllen)))

  004f7	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  004fb	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  004ff	2b c8		 sub	 ecx, eax
  00501	8b c1		 mov	 eax, ecx
  00503	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00507	7c 0a		 jl	 SHORT $LN74@z900_klmd_
  00509	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv310[rsp], 1
  00511	eb 08		 jmp	 SHORT $LN75@z900_klmd_
$LN74@z900_klmd_:
  00513	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv310[rsp], 0
$LN75@z900_klmd_:
  0051b	83 7c 24 5c 00	 cmp	 DWORD PTR tv310[rsp], 0
  00520	0f 84 1d 01 00
	00		 je	 $LN35@z900_klmd_

; 1228 :   {
; 1229 :     message_block[i++] = 0x80;

  00526	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0052b	c6 84 04 30 03
	00 00 80	 mov	 BYTE PTR message_block$[rsp+rax], 128 ; 00000080H
  00533	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00537	ff c0		 inc	 eax
  00539	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN9@z900_klmd_:

; 1230 :     while(i < message_blocklen)

  0053d	8b 44 24 38	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  00541	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00545	7d 3e		 jge	 SHORT $LN10@z900_klmd_

; 1231 :       message_block[i++] = 0x00;

  00547	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0054c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR $T1[rsp], rax
  00554	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00558	ff c0		 inc	 eax
  0055a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0055e	48 81 bc 24 98
	00 00 00 80 00
	00 00		 cmp	 QWORD PTR $T1[rsp], 128	; 00000080H
  0056a	73 02		 jae	 SHORT $LN76@z900_klmd_
  0056c	eb 05		 jmp	 SHORT $LN77@z900_klmd_
$LN76@z900_klmd_:
  0056e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN77@z900_klmd_:
  00573	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR $T1[rsp]
  0057b	c6 84 04 30 03
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  00583	eb b8		 jmp	 SHORT $LN9@z900_klmd_
$LN10@z900_klmd_:

; 1232 :     switch(fc)

  00585	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  00589	89 44 24 4c	 mov	 DWORD PTR tv322[rsp], eax
  0058d	83 7c 24 4c 01	 cmp	 DWORD PTR tv322[rsp], 1
  00592	74 10		 je	 SHORT $LN37@z900_klmd_
  00594	83 7c 24 4c 02	 cmp	 DWORD PTR tv322[rsp], 2
  00599	74 20		 je	 SHORT $LN38@z900_klmd_
  0059b	83 7c 24 4c 03	 cmp	 DWORD PTR tv322[rsp], 3
  005a0	74 30		 je	 SHORT $LN39@z900_klmd_
  005a2	eb 43		 jmp	 SHORT $LN11@z900_klmd_
$LN37@z900_klmd_:

; 1233 :     {
; 1234 :       case 1: /* sha-1 */
; 1235 :       {
; 1236 :         SHA1Transform(sha1_ctx.state, message_block);

  005a4	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005ac	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  005b4	e8 00 00 00 00	 call	 SHA1Transform

; 1237 :         break;

  005b9	eb 2c		 jmp	 SHORT $LN11@z900_klmd_
$LN38@z900_klmd_:

; 1238 :       }
; 1239 : 
; 1240 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1241 :       case 2: /* sha-256 */
; 1242 :       {
; 1243 :         SHA256Transform(sha2_ctx.state.st32, message_block);

  005bb	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005c3	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  005cb	e8 00 00 00 00	 call	 SHA256Transform

; 1244 :         break;

  005d0	eb 15		 jmp	 SHORT $LN11@z900_klmd_
$LN39@z900_klmd_:

; 1245 :       }
; 1246 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1247 : 
; 1248 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1249 :       case 3: /* sha-512 */
; 1250 :       {
; 1251 :         SHA512Transform(sha512_ctx.state.st64, message_block);

  005d2	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005da	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  005e2	e8 00 00 00 00	 call	 SHA512Transform
$LN11@z900_klmd_:

; 1252 :         break;
; 1253 :       }
; 1254 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1255 : 
; 1256 :     }
; 1257 :     for(i = 0; i < message_blocklen - mbllen; i++)

  005e7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005ef	eb 0a		 jmp	 SHORT $LN15@z900_klmd_
$LN13@z900_klmd_:
  005f1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005f5	ff c0		 inc	 eax
  005f7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN15@z900_klmd_:
  005fb	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  005ff	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  00603	2b c8		 sub	 ecx, eax
  00605	8b c1		 mov	 eax, ecx
  00607	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0060b	7d 34		 jge	 SHORT $LN14@z900_klmd_

; 1258 :       message_block[i] = 0x00;

  0060d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00612	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR $T2[rsp], rax
  0061a	48 81 bc 24 a0
	00 00 00 80 00
	00 00		 cmp	 QWORD PTR $T2[rsp], 128	; 00000080H
  00626	73 02		 jae	 SHORT $LN78@z900_klmd_
  00628	eb 05		 jmp	 SHORT $LN79@z900_klmd_
$LN78@z900_klmd_:
  0062a	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN79@z900_klmd_:
  0062f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR $T2[rsp]
  00637	c6 84 04 30 03
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  0063f	eb b0		 jmp	 SHORT $LN13@z900_klmd_
$LN14@z900_klmd_:

; 1259 :   }

  00641	eb 67		 jmp	 SHORT $LN36@z900_klmd_
$LN35@z900_klmd_:

; 1260 :   else
; 1261 :   {
; 1262 :     message_block[i++] = 0x80;

  00643	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00648	c6 84 04 30 03
	00 00 80	 mov	 BYTE PTR message_block$[rsp+rax], 128 ; 00000080H
  00650	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00654	ff c0		 inc	 eax
  00656	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@z900_klmd_:

; 1263 :     while(i < message_blocklen - mbllen)

  0065a	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  0065e	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  00662	2b c8		 sub	 ecx, eax
  00664	8b c1		 mov	 eax, ecx
  00666	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0066a	7d 3e		 jge	 SHORT $LN17@z900_klmd_

; 1264 :       message_block[i++] = 0x00;

  0066c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00671	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR $T3[rsp], rax
  00679	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0067d	ff c0		 inc	 eax
  0067f	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00683	48 81 bc 24 a8
	00 00 00 80 00
	00 00		 cmp	 QWORD PTR $T3[rsp], 128	; 00000080H
  0068f	73 02		 jae	 SHORT $LN80@z900_klmd_
  00691	eb 05		 jmp	 SHORT $LN81@z900_klmd_
$LN80@z900_klmd_:
  00693	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN81@z900_klmd_:
  00698	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  006a0	c6 84 04 30 03
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  006a8	eb b0		 jmp	 SHORT $LN16@z900_klmd_
$LN17@z900_klmd_:
$LN36@z900_klmd_:

; 1265 :   }
; 1266 : 
; 1267 :   /* Set the message bit length */
; 1268 :   memcpy(&message_block[message_blocklen - mbllen], &parameter_block[parameter_blocklen], mbllen);

  006aa	48 63 44 24 34	 movsxd	 rax, DWORD PTR mbllen$[rsp]
  006af	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR parameter_blocklen$[rsp]
  006b4	48 8d 8c 0c e0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  006bc	8b 54 24 34	 mov	 edx, DWORD PTR mbllen$[rsp]
  006c0	44 8b 44 24 38	 mov	 r8d, DWORD PTR message_blocklen$[rsp]
  006c5	44 2b c2	 sub	 r8d, edx
  006c8	41 8b d0	 mov	 edx, r8d
  006cb	48 63 d2	 movsxd	 rdx, edx
  006ce	48 8d 94 14 30
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp+rdx]
  006d6	48 8b fa	 mov	 rdi, rdx
  006d9	48 8b f1	 mov	 rsi, rcx
  006dc	48 8b c8	 mov	 rcx, rax
  006df	f3 a4		 rep movsb

; 1269 : 
; 1270 :   /* Calculate and store the message digest */
; 1271 :   switch(fc)

  006e1	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  006e5	89 44 24 50	 mov	 DWORD PTR tv349[rsp], eax
  006e9	83 7c 24 50 01	 cmp	 DWORD PTR tv349[rsp], 1
  006ee	74 13		 je	 SHORT $LN40@z900_klmd_
  006f0	83 7c 24 50 02	 cmp	 DWORD PTR tv349[rsp], 2
  006f5	74 38		 je	 SHORT $LN41@z900_klmd_
  006f7	83 7c 24 50 03	 cmp	 DWORD PTR tv349[rsp], 3
  006fc	74 5d		 je	 SHORT $LN42@z900_klmd_
  006fe	e9 82 00 00 00	 jmp	 $LN18@z900_klmd_
$LN40@z900_klmd_:

; 1272 :   {
; 1273 :     case 1: /* sha-1 */
; 1274 :     {
; 1275 :       SHA1Transform(sha1_ctx.state, message_block);

  00703	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0070b	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00713	e8 00 00 00 00	 call	 SHA1Transform

; 1276 :       sha1_getcv(&sha1_ctx, parameter_block);

  00718	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00720	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00728	e8 00 00 00 00	 call	 sha1_getcv

; 1277 :       break;

  0072d	eb 56		 jmp	 SHORT $LN18@z900_klmd_
$LN41@z900_klmd_:

; 1278 :     }
; 1279 : 
; 1280 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1281 :     case 2: /* sha-256 */
; 1282 :     {
; 1283 :       SHA256Transform(sha2_ctx.state.st32, message_block);

  0072f	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00737	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  0073f	e8 00 00 00 00	 call	 SHA256Transform

; 1284 :       sha256_getcv(&sha2_ctx, parameter_block);

  00744	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0074c	48 8d 8c 24 40
	01 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00754	e8 00 00 00 00	 call	 sha256_getcv

; 1285 :       break;

  00759	eb 2a		 jmp	 SHORT $LN18@z900_klmd_
$LN42@z900_klmd_:

; 1286 :     }
; 1287 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1288 : 
; 1289 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1290 :     case 3: /* sha-512 */
; 1291 :     {
; 1292 :       SHA512Transform(sha512_ctx.state.st64, message_block);

  0075b	48 8d 94 24 30
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00763	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  0076b	e8 00 00 00 00	 call	 SHA512Transform

; 1293 :       sha512_getcv(&sha512_ctx, parameter_block);

  00770	48 8d 94 24 e0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00778	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00780	e8 00 00 00 00	 call	 sha512_getcv
$LN18@z900_klmd_:

; 1294 :       break;
; 1295 :     }
; 1296 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1297 : 
; 1298 :   }
; 1299 :   ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00785	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0078d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00793	83 e0 01	 and	 eax, 1
  00796	85 c0		 test	 eax, eax
  00798	74 23		 je	 SHORT $LN82@z900_klmd_
  0079a	b8 08 00 00 00	 mov	 eax, 8
  0079f	48 6b c0 01	 imul	 rax, rax, 1
  007a3	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ab	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  007b3	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv392[rsp], rax
  007bb	eb 20		 jmp	 SHORT $LN83@z900_klmd_
$LN82@z900_klmd_:
  007bd	b8 08 00 00 00	 mov	 eax, 8
  007c2	48 6b c0 01	 imul	 rax, rax, 1
  007c6	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007ce	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  007d5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv392[rsp], rax
$LN83@z900_klmd_:
  007dd	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007e5	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  007ec	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv392[rsp]
  007f4	48 23 c8	 and	 rcx, rax
  007f7	48 8b c1	 mov	 rax, rcx
  007fa	8b 4c 24 3c	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  007fe	ff c9		 dec	 ecx
  00800	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00808	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0080d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00813	4c 8b c0	 mov	 r8, rax
  00816	0f b6 d1	 movzx	 edx, cl
  00819	48 8d 8c 24 e0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00821	e8 00 00 00 00	 call	 z900_vstorec
$LN22@z900_klmd_:

; 1300 : 
; 1301 : #ifdef OPTION_KLMD_DEBUG
; 1302 :   if(parameter_blocklen > 32)
; 1303 :   {
; 1304 :     LOGBYTE2("md    :", parameter_block, 16, parameter_blocklen / 16);
; 1305 :   }
; 1306 :   else
; 1307 :   {
; 1308 :     LOGBYTE("md    :", parameter_block, parameter_blocklen);
; 1309 :   }
; 1310 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1311 : 
; 1312 :   /* Update registers */
; 1313 :   SET_GR_A(r2, regs, GR_A(r2, regs) + GR_A(r2 + 1, regs));

  00826	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0082e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00834	83 e0 01	 and	 eax, 1
  00837	85 c0		 test	 eax, eax
  00839	0f 84 e5 00 00
	00		 je	 $LN43@z900_klmd_
  0083f	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00847	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0084d	83 e0 01	 and	 eax, 1
  00850	85 c0		 test	 eax, eax
  00852	74 22		 je	 SHORT $LN84@z900_klmd_
  00854	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0085c	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00864	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0086c	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv422[rsp], rax
  00874	eb 1f		 jmp	 SHORT $LN85@z900_klmd_
$LN84@z900_klmd_:
  00876	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0087e	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00886	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0088d	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv422[rsp], rax
$LN85@z900_klmd_:
  00895	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0089d	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  008a3	83 e0 01	 and	 eax, 1
  008a6	85 c0		 test	 eax, eax
  008a8	74 25		 je	 SHORT $LN86@z900_klmd_
  008aa	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008b1	ff c0		 inc	 eax
  008b3	48 98		 cdqe
  008b5	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008bd	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  008c5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
  008cd	eb 22		 jmp	 SHORT $LN87@z900_klmd_
$LN86@z900_klmd_:
  008cf	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008d6	ff c0		 inc	 eax
  008d8	48 98		 cdqe
  008da	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008e9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv439[rsp], rax
$LN87@z900_klmd_:
  008f1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv439[rsp]
  008f9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv422[rsp]
  00901	48 03 c8	 add	 rcx, rax
  00904	48 8b c1	 mov	 rax, rcx
  00907	48 63 8c 24 e8
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0090f	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00917	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  0091f	e9 df 00 00 00	 jmp	 $LN44@z900_klmd_
$LN43@z900_klmd_:
  00924	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0092c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00932	83 e0 01	 and	 eax, 1
  00935	85 c0		 test	 eax, eax
  00937	74 22		 je	 SHORT $LN88@z900_klmd_
  00939	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00941	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00949	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00951	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv460[rsp], rax
  00959	eb 1f		 jmp	 SHORT $LN89@z900_klmd_
$LN88@z900_klmd_:
  0095b	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00963	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0096b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00972	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv460[rsp], rax
$LN89@z900_klmd_:
  0097a	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00982	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00988	83 e0 01	 and	 eax, 1
  0098b	85 c0		 test	 eax, eax
  0098d	74 25		 je	 SHORT $LN90@z900_klmd_
  0098f	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00996	ff c0		 inc	 eax
  00998	48 98		 cdqe
  0099a	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  009aa	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv477[rsp], rax
  009b2	eb 22		 jmp	 SHORT $LN91@z900_klmd_
$LN90@z900_klmd_:
  009b4	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  009bb	ff c0		 inc	 eax
  009bd	48 98		 cdqe
  009bf	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  009ce	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv477[rsp], rax
$LN91@z900_klmd_:
  009d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tv477[rsp]
  009de	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv460[rsp]
  009e6	48 03 c8	 add	 rcx, rax
  009e9	48 8b c1	 mov	 rax, rcx
  009ec	48 63 8c 24 e8
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  009f4	48 8b 94 24 f0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009fc	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN44@z900_klmd_:
  00a03	33 c0		 xor	 eax, eax
  00a05	85 c0		 test	 eax, eax
  00a07	0f 85 19 fe ff
	ff		 jne	 $LN22@z900_klmd_
$LN25@z900_klmd_:

; 1314 :   SET_GR_A(r2 + 1, regs, 0);

  00a0d	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a15	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00a1b	83 e0 01	 and	 eax, 1
  00a1e	85 c0		 test	 eax, eax
  00a20	74 21		 je	 SHORT $LN45@z900_klmd_
  00a22	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a29	ff c0		 inc	 eax
  00a2b	48 98		 cdqe
  00a2d	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a35	48 c7 84 c1 80
	02 00 00 00 00
	00 00		 mov	 QWORD PTR [rcx+rax*8+640], 0
  00a41	eb 1e		 jmp	 SHORT $LN46@z900_klmd_
$LN45@z900_klmd_:
  00a43	8b 84 24 e8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00a4a	ff c0		 inc	 eax
  00a4c	48 98		 cdqe
  00a4e	48 8b 8c 24 f0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00a56	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0
$LN46@z900_klmd_:
  00a61	33 c0		 xor	 eax, eax
  00a63	85 c0		 test	 eax, eax
  00a65	75 a6		 jne	 SHORT $LN25@z900_klmd_

; 1315 : 
; 1316 : #ifdef OPTION_KLMD_DEBUG
; 1317 :   WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1318 :   WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1319 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1320 : 
; 1321 :   /* Set condition code */
; 1322 :   regs->psw.cc = 0;

  00a67	48 8b 84 24 f0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00a6f	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@z900_klmd_:
$LN47@z900_klmd_:

; 1323 : }

  00a73	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00a7b	48 33 cc	 xor	 rcx, rsp
  00a7e	e8 00 00 00 00	 call	 __security_check_cookie
  00a83	48 81 c4 c8 03
	00 00		 add	 rsp, 968		; 000003c8H
  00a8a	5f		 pop	 rdi
  00a8b	5e		 pop	 rsi
  00a8c	c3		 ret	 0
z900_klmd_sha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
crypted$ = 52
tv136 = 56
tv158 = 60
tv179 = 64
tv404 = 68
tv425 = 72
tv81 = 80
tv156 = 88
tv198 = 96
tv216 = 104
tv240 = 112
tv280 = 120
tv308 = 128
tv329 = 136
tv358 = 144
tv382 = 152
tv402 = 160
parameter_block$ = 168
message_block$ = 200
__$ArrayPad$ = 216
r1$ = 240
r2$ = 248
regs$ = 256
z900_kimd_ghash PROC

; 1023 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@z900_kimd_:

; 1024 :   int crypted;
; 1025 :   int i;
; 1026 :   BYTE message_block[16];
; 1027 :   BYTE parameter_block[32];
; 1028 : 
; 1029 :   UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@z900_kimd_

; 1030 : 
; 1031 :   /* Check special conditions */
; 1032 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  0002c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00034	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0003a	83 e0 01	 and	 eax, 1
  0003d	85 c0		 test	 eax, eax
  0003f	74 22		 je	 SHORT $LN25@z900_kimd_
  00041	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00048	ff c0		 inc	 eax
  0004a	48 98		 cdqe
  0004c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00054	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0005c	48 89 44 24 50	 mov	 QWORD PTR tv81[rsp], rax
  00061	eb 1f		 jmp	 SHORT $LN26@z900_kimd_
$LN25@z900_kimd_:
  00063	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00076	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0007d	48 89 44 24 50	 mov	 QWORD PTR tv81[rsp], rax
$LN26@z900_kimd_:
  00082	33 d2		 xor	 edx, edx
  00084	48 8b 44 24 50	 mov	 rax, QWORD PTR tv81[rsp]
  00089	b9 10 00 00 00	 mov	 ecx, 16
  0008e	48 f7 f1	 div	 rcx
  00091	48 8b c2	 mov	 rax, rdx
  00094	48 85 c0	 test	 rax, rax
  00097	74 0a		 je	 SHORT $LN31@z900_kimd_
  00099	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000a1	eb 08		 jmp	 SHORT $LN32@z900_kimd_
$LN31@z900_kimd_:
  000a3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN32@z900_kimd_:
  000ab	83 7c 24 38 00	 cmp	 DWORD PTR tv136[rsp], 0
  000b0	74 13		 je	 SHORT $LN17@z900_kimd_

; 1033 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000b2	ba 06 00 00 00	 mov	 edx, 6
  000b7	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN17@z900_kimd_:

; 1034 : 
; 1035 :   /* Return with cc 0 on zero length */
; 1036 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000c5	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000cd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000d3	83 e0 01	 and	 eax, 1
  000d6	85 c0		 test	 eax, eax
  000d8	74 22		 je	 SHORT $LN33@z900_kimd_
  000da	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000e1	ff c0		 inc	 eax
  000e3	48 98		 cdqe
  000e5	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ed	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f5	48 89 44 24 58	 mov	 QWORD PTR tv156[rsp], rax
  000fa	eb 1f		 jmp	 SHORT $LN34@z900_kimd_
$LN33@z900_kimd_:
  000fc	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00103	ff c0		 inc	 eax
  00105	48 98		 cdqe
  00107	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00116	48 89 44 24 58	 mov	 QWORD PTR tv156[rsp], rax
$LN34@z900_kimd_:
  0011b	48 83 7c 24 58
	00		 cmp	 QWORD PTR tv156[rsp], 0
  00121	75 0a		 jne	 SHORT $LN35@z900_kimd_
  00123	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv158[rsp], 1
  0012b	eb 08		 jmp	 SHORT $LN36@z900_kimd_
$LN35@z900_kimd_:
  0012d	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv158[rsp], 0
$LN36@z900_kimd_:
  00135	83 7c 24 3c 00	 cmp	 DWORD PTR tv158[rsp], 0
  0013a	74 0a		 je	 SHORT $LN41@z900_kimd_
  0013c	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv179[rsp], 1
  00144	eb 08		 jmp	 SHORT $LN42@z900_kimd_
$LN41@z900_kimd_:
  00146	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv179[rsp], 0
$LN42@z900_kimd_:
  0014e	83 7c 24 40 00	 cmp	 DWORD PTR tv179[rsp], 0
  00153	74 11		 je	 SHORT $LN18@z900_kimd_

; 1037 :   {
; 1038 :     regs->psw.cc = 0;

  00155	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0015d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1039 :     return;

  00161	e9 d1 05 00 00	 jmp	 $LN1@z900_kimd_
$LN18@z900_kimd_:

; 1040 :   }
; 1041 : 
; 1042 :   /* Test writeability output chaining value */
; 1043 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  00166	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0016e	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00174	83 e0 01	 and	 eax, 1
  00177	85 c0		 test	 eax, eax
  00179	74 20		 je	 SHORT $LN43@z900_kimd_
  0017b	b8 08 00 00 00	 mov	 eax, 8
  00180	48 6b c0 01	 imul	 rax, rax, 1
  00184	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018c	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00194	48 89 44 24 60	 mov	 QWORD PTR tv198[rsp], rax
  00199	eb 1d		 jmp	 SHORT $LN44@z900_kimd_
$LN43@z900_kimd_:
  0019b	b8 08 00 00 00	 mov	 eax, 8
  001a0	48 6b c0 01	 imul	 rax, rax, 1
  001a4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ac	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001b3	48 89 44 24 60	 mov	 QWORD PTR tv198[rsp], rax
$LN44@z900_kimd_:
  001b8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c0	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv198[rsp]
  001cc	48 23 c8	 and	 rcx, rax
  001cf	48 8b c1	 mov	 rax, rcx
  001d2	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001da	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001df	41 b9 02 00 00
	00		 mov	 r9d, 2
  001e5	41 b8 0f 00 00
	00		 mov	 r8d, 15
  001eb	ba 01 00 00 00	 mov	 edx, 1
  001f0	48 8b c8	 mov	 rcx, rax
  001f3	e8 00 00 00 00	 call	 z900_validate_operand

; 1044 : 
; 1045 :   /* Fetch the parameter block */
; 1046 :   ARCH_DEP(vfetchc)(parameter_block, 31, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001f8	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00200	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00206	83 e0 01	 and	 eax, 1
  00209	85 c0		 test	 eax, eax
  0020b	74 20		 je	 SHORT $LN45@z900_kimd_
  0020d	b8 08 00 00 00	 mov	 eax, 8
  00212	48 6b c0 01	 imul	 rax, rax, 1
  00216	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021e	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00226	48 89 44 24 68	 mov	 QWORD PTR tv216[rsp], rax
  0022b	eb 1d		 jmp	 SHORT $LN46@z900_kimd_
$LN45@z900_kimd_:
  0022d	b8 08 00 00 00	 mov	 eax, 8
  00232	48 6b c0 01	 imul	 rax, rax, 1
  00236	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0023e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00245	48 89 44 24 68	 mov	 QWORD PTR tv216[rsp], rax
$LN46@z900_kimd_:
  0024a	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00252	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00259	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv216[rsp]
  0025e	48 23 c8	 and	 rcx, rax
  00261	48 8b c1	 mov	 rax, rcx
  00264	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00271	41 b9 01 00 00
	00		 mov	 r9d, 1
  00277	4c 8b c0	 mov	 r8, rax
  0027a	b2 1f		 mov	 dl, 31
  0027c	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00284	e8 00 00 00 00	 call	 z900_vfetchc

; 1047 : 
; 1048 : #ifdef OPTION_KIMD_DEBUG
; 1049 :   LOGBYTE("icv   :", parameter_block, 16);
; 1050 :   LOGBYTE("h     :", &parameter_block[16], 16);
; 1051 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1052 : 
; 1053 :   /* Try to process the CPU-determined amount of data */
; 1054 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00289	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00291	eb 0b		 jmp	 SHORT $LN7@z900_kimd_
$LN5@z900_kimd_:
  00293	8b 44 24 34	 mov	 eax, DWORD PTR crypted$[rsp]
  00297	83 c0 10	 add	 eax, 16
  0029a	89 44 24 34	 mov	 DWORD PTR crypted$[rsp], eax
$LN7@z900_kimd_:
  0029e	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  002a6	0f 8d 7f 04 00
	00		 jge	 $LN6@z900_kimd_

; 1055 :   {
; 1056 :     /* Fetch and process a block of data */
; 1057 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  002ac	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b4	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002ba	83 e0 01	 and	 eax, 1
  002bd	85 c0		 test	 eax, eax
  002bf	74 1f		 je	 SHORT $LN47@z900_kimd_
  002c1	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002c9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d1	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  002d9	48 89 44 24 70	 mov	 QWORD PTR tv240[rsp], rax
  002de	eb 1c		 jmp	 SHORT $LN48@z900_kimd_
$LN47@z900_kimd_:
  002e0	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002e8	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002f7	48 89 44 24 70	 mov	 QWORD PTR tv240[rsp], rax
$LN48@z900_kimd_:
  002fc	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00304	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0030b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv240[rsp]
  00310	48 23 c8	 and	 rcx, rax
  00313	48 8b c1	 mov	 rax, rcx
  00316	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00323	44 8b 8c 24 f8
	00 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0032b	4c 8b c0	 mov	 r8, rax
  0032e	b2 0f		 mov	 dl, 15
  00330	48 8d 8c 24 c8
	00 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00338	e8 00 00 00 00	 call	 z900_vfetchc

; 1058 : 
; 1059 : #ifdef OPTION_KIMD_DEBUG
; 1060 :     LOGBYTE("input :", message_block, 16);
; 1061 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1062 : 
; 1063 :     /* XOR and multiply */
; 1064 :     for(i = 0; i < 16; i++)

  0033d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00345	eb 0a		 jmp	 SHORT $LN10@z900_kimd_
$LN8@z900_kimd_:
  00347	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0034b	ff c0		 inc	 eax
  0034d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@z900_kimd_:
  00351	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00356	7d 2a		 jge	 SHORT $LN9@z900_kimd_

; 1065 :       parameter_block[i] ^= message_block[i];

  00358	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0035d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00362	0f b6 8c 0c c8
	00 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  0036a	0f b6 84 04 a8
	00 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00372	33 c1		 xor	 eax, ecx
  00374	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00379	88 84 0c a8 00
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  00380	eb c5		 jmp	 SHORT $LN8@z900_kimd_
$LN9@z900_kimd_:

; 1066 :     gcm_gf_mult(parameter_block, &parameter_block[16], parameter_block);

  00382	b8 01 00 00 00	 mov	 eax, 1
  00387	48 6b c0 10	 imul	 rax, rax, 16
  0038b	48 8d 84 04 a8
	00 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00393	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0039b	48 8b d0	 mov	 rdx, rax
  0039e	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  003a6	e8 00 00 00 00	 call	 gcm_gf_mult

; 1067 : 
; 1068 :     /* Store the output chaining value */
; 1069 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  003ab	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b3	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003b9	83 e0 01	 and	 eax, 1
  003bc	85 c0		 test	 eax, eax
  003be	74 20		 je	 SHORT $LN49@z900_kimd_
  003c0	b8 08 00 00 00	 mov	 eax, 8
  003c5	48 6b c0 01	 imul	 rax, rax, 1
  003c9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d1	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  003d9	48 89 44 24 78	 mov	 QWORD PTR tv280[rsp], rax
  003de	eb 1d		 jmp	 SHORT $LN50@z900_kimd_
$LN49@z900_kimd_:
  003e0	b8 08 00 00 00	 mov	 eax, 8
  003e5	48 6b c0 01	 imul	 rax, rax, 1
  003e9	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003f8	48 89 44 24 78	 mov	 QWORD PTR tv280[rsp], rax
$LN50@z900_kimd_:
  003fd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00405	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0040c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv280[rsp]
  00411	48 23 c8	 and	 rcx, rax
  00414	48 8b c1	 mov	 rax, rcx
  00417	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00424	41 b9 01 00 00
	00		 mov	 r9d, 1
  0042a	4c 8b c0	 mov	 r8, rax
  0042d	b2 0f		 mov	 dl, 15
  0042f	48 8d 8c 24 a8
	00 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00437	e8 00 00 00 00	 call	 z900_vstorec
$LN13@z900_kimd_:

; 1070 : 
; 1071 : #ifdef OPTION_KIMD_DEBUG
; 1072 :     LOGBYTE("ocv   :", parameter_block, 16);
; 1073 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1074 : 
; 1075 :     /* Update the registers */
; 1076 :     SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  0043c	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00444	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0044a	83 e0 01	 and	 eax, 1
  0044d	85 c0		 test	 eax, eax
  0044f	74 7c		 je	 SHORT $LN19@z900_kimd_
  00451	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00459	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0045f	83 e0 01	 and	 eax, 1
  00462	85 c0		 test	 eax, eax
  00464	74 22		 je	 SHORT $LN51@z900_kimd_
  00466	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0046e	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00476	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0047e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv308[rsp], rax
  00486	eb 1f		 jmp	 SHORT $LN52@z900_kimd_
$LN51@z900_kimd_:
  00488	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00490	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00498	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0049f	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv308[rsp], rax
$LN52@z900_kimd_:
  004a7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv308[rsp]
  004af	48 83 c0 10	 add	 rax, 16
  004b3	48 63 8c 24 f8
	00 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  004bb	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004c3	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  004cb	eb 79		 jmp	 SHORT $LN20@z900_kimd_
$LN19@z900_kimd_:
  004cd	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  004db	83 e0 01	 and	 eax, 1
  004de	85 c0		 test	 eax, eax
  004e0	74 22		 je	 SHORT $LN53@z900_kimd_
  004e2	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004ea	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f2	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  004fa	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
  00502	eb 1f		 jmp	 SHORT $LN54@z900_kimd_
$LN53@z900_kimd_:
  00504	48 63 84 24 f8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0050c	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00514	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0051b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv329[rsp], rax
$LN54@z900_kimd_:
  00523	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR tv329[rsp]
  0052b	48 83 c0 10	 add	 rax, 16
  0052f	48 63 8c 24 f8
	00 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00537	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0053f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN20@z900_kimd_:
  00546	33 c0		 xor	 eax, eax
  00548	85 c0		 test	 eax, eax
  0054a	0f 85 ec fe ff
	ff		 jne	 $LN13@z900_kimd_
$LN16@z900_kimd_:

; 1077 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00550	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00558	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0055e	83 e0 01	 and	 eax, 1
  00561	85 c0		 test	 eax, eax
  00563	0f 84 89 00 00
	00		 je	 $LN21@z900_kimd_
  00569	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00571	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00577	83 e0 01	 and	 eax, 1
  0057a	85 c0		 test	 eax, eax
  0057c	74 25		 je	 SHORT $LN55@z900_kimd_
  0057e	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00585	ff c0		 inc	 eax
  00587	48 98		 cdqe
  00589	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00591	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00599	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv358[rsp], rax
  005a1	eb 22		 jmp	 SHORT $LN56@z900_kimd_
$LN55@z900_kimd_:
  005a3	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  005aa	ff c0		 inc	 eax
  005ac	48 98		 cdqe
  005ae	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005b6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005bd	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv358[rsp], rax
$LN56@z900_kimd_:
  005c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR tv358[rsp]
  005cd	48 83 e8 10	 sub	 rax, 16
  005d1	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005d8	ff c1		 inc	 ecx
  005da	48 63 c9	 movsxd	 rcx, ecx
  005dd	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005e5	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  005ed	e9 83 00 00 00	 jmp	 $LN22@z900_kimd_
$LN21@z900_kimd_:
  005f2	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005fa	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00600	83 e0 01	 and	 eax, 1
  00603	85 c0		 test	 eax, eax
  00605	74 25		 je	 SHORT $LN57@z900_kimd_
  00607	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0060e	ff c0		 inc	 eax
  00610	48 98		 cdqe
  00612	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0061a	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00622	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv382[rsp], rax
  0062a	eb 22		 jmp	 SHORT $LN58@z900_kimd_
$LN57@z900_kimd_:
  0062c	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00633	ff c0		 inc	 eax
  00635	48 98		 cdqe
  00637	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0063f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00646	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv382[rsp], rax
$LN58@z900_kimd_:
  0064e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR tv382[rsp]
  00656	48 83 e8 10	 sub	 rax, 16
  0065a	8b 8c 24 f8 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00661	ff c1		 inc	 ecx
  00663	48 63 c9	 movsxd	 rcx, ecx
  00666	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0066e	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN22@z900_kimd_:
  00675	33 c0		 xor	 eax, eax
  00677	85 c0		 test	 eax, eax
  00679	0f 85 d1 fe ff
	ff		 jne	 $LN16@z900_kimd_

; 1078 : 
; 1079 : #ifdef OPTION_KIMD_DEBUG
; 1080 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1081 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1082 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1083 : 
; 1084 :     /* check for end of data */
; 1085 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0067f	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00687	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0068d	83 e0 01	 and	 eax, 1
  00690	85 c0		 test	 eax, eax
  00692	74 25		 je	 SHORT $LN59@z900_kimd_
  00694	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0069b	ff c0		 inc	 eax
  0069d	48 98		 cdqe
  0069f	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006a7	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  006af	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv402[rsp], rax
  006b7	eb 22		 jmp	 SHORT $LN60@z900_kimd_
$LN59@z900_kimd_:
  006b9	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  006c0	ff c0		 inc	 eax
  006c2	48 98		 cdqe
  006c4	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006cc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006d3	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv402[rsp], rax
$LN60@z900_kimd_:
  006db	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR tv402[rsp], 0
  006e4	75 0a		 jne	 SHORT $LN61@z900_kimd_
  006e6	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv404[rsp], 1
  006ee	eb 08		 jmp	 SHORT $LN62@z900_kimd_
$LN61@z900_kimd_:
  006f0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv404[rsp], 0
$LN62@z900_kimd_:
  006f8	83 7c 24 44 00	 cmp	 DWORD PTR tv404[rsp], 0
  006fd	74 0a		 je	 SHORT $LN67@z900_kimd_
  006ff	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv425[rsp], 1
  00707	eb 08		 jmp	 SHORT $LN68@z900_kimd_
$LN67@z900_kimd_:
  00709	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv425[rsp], 0
$LN68@z900_kimd_:
  00711	83 7c 24 48 00	 cmp	 DWORD PTR tv425[rsp], 0
  00716	74 0e		 je	 SHORT $LN23@z900_kimd_

; 1086 :     {
; 1087 :       regs->psw.cc = 0;

  00718	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00720	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1088 :       return;

  00724	eb 11		 jmp	 SHORT $LN1@z900_kimd_
$LN23@z900_kimd_:

; 1089 :     }
; 1090 :   }

  00726	e9 68 fb ff ff	 jmp	 $LN5@z900_kimd_
$LN6@z900_kimd_:

; 1091 : 
; 1092 :   /* CPU-determined amount of data processed */
; 1093 :   regs->psw.cc = 3;

  0072b	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00733	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kimd_:

; 1094 : }

  00737	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0073f	48 33 cc	 xor	 rcx, rsp
  00742	e8 00 00 00 00	 call	 __security_check_cookie
  00747	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  0074e	c3		 ret	 0
z900_kimd_ghash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
message_blocklen$ = 48
parameter_blocklen$ = 52
tv70 = 56
tv238 = 60
crypted$ = 64
fc$ = 68
tv274 = 72
tv149 = 76
tv171 = 80
tv192 = 84
tv455 = 88
tv461 = 92
tv91 = 96
tv169 = 104
tv212 = 112
tv230 = 120
tv266 = 128
tv304 = 136
tv334 = 144
tv356 = 152
tv386 = 160
tv411 = 168
tv432 = 176
tv92 = 184
sha1_ctx$ = 192
sha2_ctx$ = 288
sha512_ctx$ = 496
parameter_block$ = 704
message_block$ = 768
__$ArrayPad$ = 896
r1$ = 928
r2$ = 936
regs$ = 944
klmd$ = 952
z900_kimd_sha PROC

; 837  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 98 03
	00 00		 sub	 rsp, 920		; 00000398H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 80
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 838  :   SHA1_CTX sha1_ctx;
; 839  : 
; 840  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 841  :   SHA2_CTX sha2_ctx;
; 842  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 843  : 
; 844  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 845  :   SHA2_CTX sha512_ctx;
; 846  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 847  : 
; 848  :   int crypted;
; 849  :   int fc;
; 850  :   BYTE message_block[128];
; 851  :   int message_blocklen = 0;

  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 0

; 852  :   BYTE parameter_block[64];
; 853  :   int parameter_blocklen = 0;

  00033	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 0
$LN4@z900_kimd_:

; 854  : 
; 855  :   UNREFERENCED(r1);

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN4@z900_kimd_

; 856  : 
; 857  :   /* Initialize values */
; 858  :   fc = GR0_fc(regs);

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	48 6b c0 00	 imul	 rax, rax, 0
  0004a	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00059	83 e0 7f	 and	 eax, 127		; 0000007fH
  0005c	89 44 24 44	 mov	 DWORD PTR fc$[rsp], eax

; 859  :   switch(fc)

  00060	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  00064	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
  00068	83 7c 24 38 01	 cmp	 DWORD PTR tv70[rsp], 1
  0006d	74 10		 je	 SHORT $LN20@z900_kimd_
  0006f	83 7c 24 38 02	 cmp	 DWORD PTR tv70[rsp], 2
  00074	74 1b		 je	 SHORT $LN21@z900_kimd_
  00076	83 7c 24 38 03	 cmp	 DWORD PTR tv70[rsp], 3
  0007b	74 26		 je	 SHORT $LN22@z900_kimd_
  0007d	eb 34		 jmp	 SHORT $LN5@z900_kimd_
$LN20@z900_kimd_:

; 860  :   {
; 861  :     case 1: /* sha-1 */
; 862  :     {
; 863  :       message_blocklen = 64;

  0007f	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 864  :       parameter_blocklen = 20;

  00087	c7 44 24 34 14
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 20

; 865  :       break;

  0008f	eb 22		 jmp	 SHORT $LN5@z900_kimd_
$LN21@z900_kimd_:

; 866  :     }
; 867  : 
; 868  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 869  :     case 2: /* sha-256 */
; 870  :     {
; 871  :       message_blocklen = 64;

  00091	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 872  :       parameter_blocklen = 32;

  00099	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 32 ; 00000020H

; 873  :       break;

  000a1	eb 10		 jmp	 SHORT $LN5@z900_kimd_
$LN22@z900_kimd_:

; 874  :     }
; 875  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 876  : 
; 877  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 878  :     case 3: /* sha-512 */
; 879  :     {
; 880  :       message_blocklen = 128;

  000a3	c7 44 24 30 80
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 128 ; 00000080H

; 881  :       parameter_blocklen = 64;

  000ab	c7 44 24 34 40
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 64 ; 00000040H
$LN5@z900_kimd_:

; 882  :     }
; 883  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 884  : 
; 885  :   }
; 886  : 
; 887  :   /* Check special conditions */
; 888  :   if(unlikely(!klmd && (GR_A(r2 + 1, regs) % message_blocklen)))

  000b3	83 bc 24 b8 03
	00 00 00	 cmp	 DWORD PTR klmd$[rsp], 0
  000bb	0f 85 87 00 00
	00		 jne	 $LN40@z900_kimd_
  000c1	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000c9	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  000cf	83 e0 01	 and	 eax, 1
  000d2	85 c0		 test	 eax, eax
  000d4	74 22		 je	 SHORT $LN38@z900_kimd_
  000d6	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000dd	ff c0		 inc	 eax
  000df	48 98		 cdqe
  000e1	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e9	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  000f1	48 89 44 24 60	 mov	 QWORD PTR tv91[rsp], rax
  000f6	eb 1f		 jmp	 SHORT $LN39@z900_kimd_
$LN38@z900_kimd_:
  000f8	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000ff	ff c0		 inc	 eax
  00101	48 98		 cdqe
  00103	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00112	48 89 44 24 60	 mov	 QWORD PTR tv91[rsp], rax
$LN39@z900_kimd_:
  00117	48 63 44 24 30	 movsxd	 rax, DWORD PTR message_blocklen$[rsp]
  0011c	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00124	33 d2		 xor	 edx, edx
  00126	48 8b 44 24 60	 mov	 rax, QWORD PTR tv91[rsp]
  0012b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  00133	48 f7 f1	 div	 rcx
  00136	48 8b c2	 mov	 rax, rdx
  00139	48 85 c0	 test	 rax, rax
  0013c	74 0a		 je	 SHORT $LN40@z900_kimd_
  0013e	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv149[rsp], 1
  00146	eb 08		 jmp	 SHORT $LN45@z900_kimd_
$LN40@z900_kimd_:
  00148	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN45@z900_kimd_:
  00150	83 7c 24 4c 00	 cmp	 DWORD PTR tv149[rsp], 0
  00155	74 13		 je	 SHORT $LN23@z900_kimd_

; 889  :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00157	ba 06 00 00 00	 mov	 edx, 6
  0015c	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_program_interrupt
$LN23@z900_kimd_:

; 890  : 
; 891  :   /* Return with cc 0 on zero length */
; 892  :   if(unlikely(!GR_A(r2 + 1, regs)))

  0016a	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00172	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00178	83 e0 01	 and	 eax, 1
  0017b	85 c0		 test	 eax, eax
  0017d	74 22		 je	 SHORT $LN46@z900_kimd_
  0017f	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00186	ff c0		 inc	 eax
  00188	48 98		 cdqe
  0018a	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00192	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0019a	48 89 44 24 68	 mov	 QWORD PTR tv169[rsp], rax
  0019f	eb 1f		 jmp	 SHORT $LN47@z900_kimd_
$LN46@z900_kimd_:
  001a1	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  001a8	ff c0		 inc	 eax
  001aa	48 98		 cdqe
  001ac	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  001bb	48 89 44 24 68	 mov	 QWORD PTR tv169[rsp], rax
$LN47@z900_kimd_:
  001c0	48 83 7c 24 68
	00		 cmp	 QWORD PTR tv169[rsp], 0
  001c6	75 0a		 jne	 SHORT $LN48@z900_kimd_
  001c8	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv171[rsp], 1
  001d0	eb 08		 jmp	 SHORT $LN49@z900_kimd_
$LN48@z900_kimd_:
  001d2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv171[rsp], 0
$LN49@z900_kimd_:
  001da	83 7c 24 50 00	 cmp	 DWORD PTR tv171[rsp], 0
  001df	74 0a		 je	 SHORT $LN54@z900_kimd_
  001e1	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
  001e9	eb 08		 jmp	 SHORT $LN55@z900_kimd_
$LN54@z900_kimd_:
  001eb	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv192[rsp], 0
$LN55@z900_kimd_:
  001f3	83 7c 24 54 00	 cmp	 DWORD PTR tv192[rsp], 0
  001f8	74 11		 je	 SHORT $LN24@z900_kimd_

; 893  :   {
; 894  :     regs->psw.cc = 0;

  001fa	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00202	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 895  :     return;

  00206	e9 c7 06 00 00	 jmp	 $LN1@z900_kimd_
$LN24@z900_kimd_:

; 896  :   }
; 897  : 
; 898  :   /* Test writeability output chaining value */
; 899  :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  0020b	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00213	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00219	83 e0 01	 and	 eax, 1
  0021c	85 c0		 test	 eax, eax
  0021e	74 20		 je	 SHORT $LN56@z900_kimd_
  00220	b8 08 00 00 00	 mov	 eax, 8
  00225	48 6b c0 01	 imul	 rax, rax, 1
  00229	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00231	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00239	48 89 44 24 70	 mov	 QWORD PTR tv212[rsp], rax
  0023e	eb 1d		 jmp	 SHORT $LN57@z900_kimd_
$LN56@z900_kimd_:
  00240	b8 08 00 00 00	 mov	 eax, 8
  00245	48 6b c0 01	 imul	 rax, rax, 1
  00249	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00258	48 89 44 24 70	 mov	 QWORD PTR tv212[rsp], rax
$LN57@z900_kimd_:
  0025d	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00261	ff c8		 dec	 eax
  00263	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026b	48 8b 89 90 00
	00 00		 mov	 rcx, QWORD PTR [rcx+144]
  00272	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv212[rsp]
  00277	48 23 d1	 and	 rdx, rcx
  0027a	48 8b ca	 mov	 rcx, rdx
  0027d	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00285	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0028a	41 b9 02 00 00
	00		 mov	 r9d, 2
  00290	44 8b c0	 mov	 r8d, eax
  00293	ba 01 00 00 00	 mov	 edx, 1
  00298	e8 00 00 00 00	 call	 z900_validate_operand

; 900  : 
; 901  :   /* Fetch the parameter block */
; 902  :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0029d	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002a5	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  002ab	83 e0 01	 and	 eax, 1
  002ae	85 c0		 test	 eax, eax
  002b0	74 20		 je	 SHORT $LN58@z900_kimd_
  002b2	b8 08 00 00 00	 mov	 eax, 8
  002b7	48 6b c0 01	 imul	 rax, rax, 1
  002bb	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c3	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  002cb	48 89 44 24 78	 mov	 QWORD PTR tv230[rsp], rax
  002d0	eb 1d		 jmp	 SHORT $LN59@z900_kimd_
$LN58@z900_kimd_:
  002d2	b8 08 00 00 00	 mov	 eax, 8
  002d7	48 6b c0 01	 imul	 rax, rax, 1
  002db	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002ea	48 89 44 24 78	 mov	 QWORD PTR tv230[rsp], rax
$LN59@z900_kimd_:
  002ef	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002f7	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  002fe	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv230[rsp]
  00303	48 23 c8	 and	 rcx, rax
  00306	48 8b c1	 mov	 rax, rcx
  00309	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0030d	ff c9		 dec	 ecx
  0030f	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00317	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0031c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00322	4c 8b c0	 mov	 r8, rax
  00325	0f b6 d1	 movzx	 edx, cl
  00328	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00330	e8 00 00 00 00	 call	 z900_vfetchc

; 903  : 
; 904  : #ifdef OPTION_KIMD_DEBUG
; 905  :   if(parameter_blocklen > 32)
; 906  :   {
; 907  :     LOGBYTE2("icv   :", parameter_block, 16, parameter_blocklen / 16);
; 908  :   }
; 909  :   else
; 910  :   {
; 911  :     LOGBYTE("icv   :", parameter_block, parameter_blocklen);
; 912  :   }
; 913  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 914  : 
; 915  :   /* Set initial chaining value */
; 916  :   switch(fc)

  00335	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  00339	89 44 24 3c	 mov	 DWORD PTR tv238[rsp], eax
  0033d	83 7c 24 3c 01	 cmp	 DWORD PTR tv238[rsp], 1
  00342	74 10		 je	 SHORT $LN25@z900_kimd_
  00344	83 7c 24 3c 02	 cmp	 DWORD PTR tv238[rsp], 2
  00349	74 20		 je	 SHORT $LN26@z900_kimd_
  0034b	83 7c 24 3c 03	 cmp	 DWORD PTR tv238[rsp], 3
  00350	74 30		 je	 SHORT $LN27@z900_kimd_
  00352	eb 43		 jmp	 SHORT $LN7@z900_kimd_
$LN25@z900_kimd_:

; 917  :   {
; 918  :     case 1: /* sha-1 */
; 919  :     {
; 920  :       sha1_seticv(&sha1_ctx, parameter_block);

  00354	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0035c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00364	e8 00 00 00 00	 call	 sha1_seticv

; 921  :       break;

  00369	eb 2c		 jmp	 SHORT $LN7@z900_kimd_
$LN26@z900_kimd_:

; 922  :     }
; 923  : 
; 924  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 925  :     case 2: /* sha-256 */
; 926  :     {
; 927  :       sha256_seticv(&sha2_ctx, parameter_block);

  0036b	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00373	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  0037b	e8 00 00 00 00	 call	 sha256_seticv

; 928  :       break;

  00380	eb 15		 jmp	 SHORT $LN7@z900_kimd_
$LN27@z900_kimd_:

; 929  :     }
; 930  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 931  : 
; 932  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 933  :     case 3: /* sha-512 */
; 934  :     {
; 935  :       sha512_seticv(&sha512_ctx, parameter_block);

  00382	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0038a	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00392	e8 00 00 00 00	 call	 sha512_seticv
$LN7@z900_kimd_:

; 936  :       break;
; 937  :     }
; 938  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 939  : 
; 940  :   }
; 941  : 
; 942  :   /* Try to process the CPU-determined amount of data */
; 943  :   for(crypted = 0; crypted < PROCESS_MAX; crypted += message_blocklen)

  00397	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0039f	eb 10		 jmp	 SHORT $LN11@z900_kimd_
$LN9@z900_kimd_:
  003a1	8b 44 24 30	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  003a5	8b 4c 24 40	 mov	 ecx, DWORD PTR crypted$[rsp]
  003a9	03 c8		 add	 ecx, eax
  003ab	8b c1		 mov	 eax, ecx
  003ad	89 44 24 40	 mov	 DWORD PTR crypted$[rsp], eax
$LN11@z900_kimd_:
  003b1	81 7c 24 40 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  003b9	0f 8d 07 05 00
	00		 jge	 $LN10@z900_kimd_

; 944  :   {
; 945  :     /* Fetch and process a block of data */
; 946  :     ARCH_DEP(vfetchc)(message_block, message_blocklen - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  003bf	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c7	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  003cd	83 e0 01	 and	 eax, 1
  003d0	85 c0		 test	 eax, eax
  003d2	74 22		 je	 SHORT $LN60@z900_kimd_
  003d4	48 63 84 24 a8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003dc	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e4	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  003ec	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv266[rsp], rax
  003f4	eb 1f		 jmp	 SHORT $LN61@z900_kimd_
$LN60@z900_kimd_:
  003f6	48 63 84 24 a8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003fe	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00406	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0040d	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv266[rsp], rax
$LN61@z900_kimd_:
  00415	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041d	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00424	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv266[rsp]
  0042c	48 23 c8	 and	 rcx, rax
  0042f	48 8b c1	 mov	 rax, rcx
  00432	8b 4c 24 30	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  00436	ff c9		 dec	 ecx
  00438	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00440	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00445	44 8b 8c 24 a8
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0044d	4c 8b c0	 mov	 r8, rax
  00450	0f b6 d1	 movzx	 edx, cl
  00453	48 8d 8c 24 00
	03 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0045b	e8 00 00 00 00	 call	 z900_vfetchc

; 947  : 
; 948  : #ifdef OPTION_KIMD_DEBUG
; 949  :     LOGBYTE2("input :", message_block, 16, message_blocklen / 16);
; 950  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 951  : 
; 952  :     switch(fc)

  00460	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  00464	89 44 24 48	 mov	 DWORD PTR tv274[rsp], eax
  00468	83 7c 24 48 01	 cmp	 DWORD PTR tv274[rsp], 1
  0046d	74 13		 je	 SHORT $LN28@z900_kimd_
  0046f	83 7c 24 48 02	 cmp	 DWORD PTR tv274[rsp], 2
  00474	74 38		 je	 SHORT $LN29@z900_kimd_
  00476	83 7c 24 48 03	 cmp	 DWORD PTR tv274[rsp], 3
  0047b	74 5d		 je	 SHORT $LN30@z900_kimd_
  0047d	e9 82 00 00 00	 jmp	 $LN12@z900_kimd_
$LN28@z900_kimd_:

; 953  :     {
; 954  :       case 1: /* sha-1 */
; 955  :       {
; 956  :         SHA1Transform(sha1_ctx.state, message_block);

  00482	48 8d 94 24 00
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0048a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00492	e8 00 00 00 00	 call	 SHA1Transform

; 957  :         sha1_getcv(&sha1_ctx, parameter_block);

  00497	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0049f	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  004a7	e8 00 00 00 00	 call	 sha1_getcv

; 958  :         break;

  004ac	eb 56		 jmp	 SHORT $LN12@z900_kimd_
$LN29@z900_kimd_:

; 959  :       }
; 960  : 
; 961  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 962  :       case 2: /* sha-256 */
; 963  :       {
; 964  :         SHA256Transform(sha2_ctx.state.st32, message_block);

  004ae	48 8d 94 24 00
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004b6	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  004be	e8 00 00 00 00	 call	 SHA256Transform

; 965  :         sha256_getcv(&sha2_ctx, parameter_block);

  004c3	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  004cb	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  004d3	e8 00 00 00 00	 call	 sha256_getcv

; 966  :         break;

  004d8	eb 2a		 jmp	 SHORT $LN12@z900_kimd_
$LN30@z900_kimd_:

; 967  :       }
; 968  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 969  : 
; 970  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 971  :       case 3: /* sha-512 */
; 972  :       {
; 973  :         SHA512Transform(sha512_ctx.state.st64, message_block);

  004da	48 8d 94 24 00
	03 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004e2	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  004ea	e8 00 00 00 00	 call	 SHA512Transform

; 974  :         sha512_getcv(&sha512_ctx, parameter_block);

  004ef	48 8d 94 24 c0
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  004f7	48 8d 8c 24 f0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  004ff	e8 00 00 00 00	 call	 sha512_getcv
$LN12@z900_kimd_:

; 975  :         break;
; 976  :       }
; 977  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 978  : 
; 979  :     }
; 980  : 
; 981  :     /* Store the output chaining value */
; 982  :     ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00504	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0050c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00512	83 e0 01	 and	 eax, 1
  00515	85 c0		 test	 eax, eax
  00517	74 23		 je	 SHORT $LN62@z900_kimd_
  00519	b8 08 00 00 00	 mov	 eax, 8
  0051e	48 6b c0 01	 imul	 rax, rax, 1
  00522	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052a	48 8b 84 01 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax+640]
  00532	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv304[rsp], rax
  0053a	eb 20		 jmp	 SHORT $LN63@z900_kimd_
$LN62@z900_kimd_:
  0053c	b8 08 00 00 00	 mov	 eax, 8
  00541	48 6b c0 01	 imul	 rax, rax, 1
  00545	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0054d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00554	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv304[rsp], rax
$LN63@z900_kimd_:
  0055c	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00564	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0056b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv304[rsp]
  00573	48 23 c8	 and	 rcx, rax
  00576	48 8b c1	 mov	 rax, rcx
  00579	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0057d	ff c9		 dec	 ecx
  0057f	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00587	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0058c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00592	4c 8b c0	 mov	 r8, rax
  00595	0f b6 d1	 movzx	 edx, cl
  00598	48 8d 8c 24 c0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  005a0	e8 00 00 00 00	 call	 z900_vstorec
$LN16@z900_kimd_:

; 983  : 
; 984  : #ifdef OPTION_KIMD_DEBUG
; 985  :     if(parameter_blocklen > 32)
; 986  :     {
; 987  :       LOGBYTE2("ocv   :", parameter_block, 16, parameter_blocklen / 16);
; 988  :     }
; 989  :     else
; 990  :     {
; 991  :       LOGBYTE("ocv   :", parameter_block, parameter_blocklen);
; 992  :     }
; 993  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 994  : 
; 995  :     /* Update the registers */
; 996  :     SET_GR_A(r2, regs, GR_A(r2, regs) + message_blocklen);

  005a5	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ad	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005b3	83 e0 01	 and	 eax, 1
  005b6	85 c0		 test	 eax, eax
  005b8	0f 84 86 00 00
	00		 je	 $LN31@z900_kimd_
  005be	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  005cc	83 e0 01	 and	 eax, 1
  005cf	85 c0		 test	 eax, eax
  005d1	74 22		 je	 SHORT $LN64@z900_kimd_
  005d3	48 63 84 24 a8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005db	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e3	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  005eb	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv334[rsp], rax
  005f3	eb 1f		 jmp	 SHORT $LN65@z900_kimd_
$LN64@z900_kimd_:
  005f5	48 63 84 24 a8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005fd	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00605	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0060c	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv334[rsp], rax
$LN65@z900_kimd_:
  00614	48 63 44 24 30	 movsxd	 rax, DWORD PTR message_blocklen$[rsp]
  00619	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv334[rsp]
  00621	48 03 c8	 add	 rcx, rax
  00624	48 8b c1	 mov	 rax, rcx
  00627	48 63 8c 24 a8
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0062f	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00637	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  0063f	e9 80 00 00 00	 jmp	 $LN32@z900_kimd_
$LN31@z900_kimd_:
  00644	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0064c	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00652	83 e0 01	 and	 eax, 1
  00655	85 c0		 test	 eax, eax
  00657	74 22		 je	 SHORT $LN66@z900_kimd_
  00659	48 63 84 24 a8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00661	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00669	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00671	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
  00679	eb 1f		 jmp	 SHORT $LN67@z900_kimd_
$LN66@z900_kimd_:
  0067b	48 63 84 24 a8
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00683	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0068b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00692	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv356[rsp], rax
$LN67@z900_kimd_:
  0069a	48 63 44 24 30	 movsxd	 rax, DWORD PTR message_blocklen$[rsp]
  0069f	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv356[rsp]
  006a7	48 03 c8	 add	 rcx, rax
  006aa	48 8b c1	 mov	 rax, rcx
  006ad	48 63 8c 24 a8
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  006b5	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006bd	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN32@z900_kimd_:
  006c4	33 c0		 xor	 eax, eax
  006c6	85 c0		 test	 eax, eax
  006c8	0f 85 d7 fe ff
	ff		 jne	 $LN16@z900_kimd_
$LN19@z900_kimd_:

; 997  :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - message_blocklen);

  006ce	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d6	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006dc	83 e0 01	 and	 eax, 1
  006df	85 c0		 test	 eax, eax
  006e1	0f 84 90 00 00
	00		 je	 $LN33@z900_kimd_
  006e7	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006ef	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006f5	83 e0 01	 and	 eax, 1
  006f8	85 c0		 test	 eax, eax
  006fa	74 25		 je	 SHORT $LN68@z900_kimd_
  006fc	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00703	ff c0		 inc	 eax
  00705	48 98		 cdqe
  00707	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0070f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00717	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv386[rsp], rax
  0071f	eb 22		 jmp	 SHORT $LN69@z900_kimd_
$LN68@z900_kimd_:
  00721	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00728	ff c0		 inc	 eax
  0072a	48 98		 cdqe
  0072c	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00734	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0073b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv386[rsp], rax
$LN69@z900_kimd_:
  00743	48 63 44 24 30	 movsxd	 rax, DWORD PTR message_blocklen$[rsp]
  00748	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv386[rsp]
  00750	48 2b c8	 sub	 rcx, rax
  00753	48 8b c1	 mov	 rax, rcx
  00756	8b 8c 24 a8 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0075d	ff c1		 inc	 ecx
  0075f	48 63 c9	 movsxd	 rcx, ecx
  00762	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0076a	48 89 84 ca 80
	02 00 00	 mov	 QWORD PTR [rdx+rcx*8+640], rax
  00772	e9 8a 00 00 00	 jmp	 $LN34@z900_kimd_
$LN33@z900_kimd_:
  00777	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0077f	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00785	83 e0 01	 and	 eax, 1
  00788	85 c0		 test	 eax, eax
  0078a	74 25		 je	 SHORT $LN70@z900_kimd_
  0078c	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00793	ff c0		 inc	 eax
  00795	48 98		 cdqe
  00797	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0079f	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  007a7	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv411[rsp], rax
  007af	eb 22		 jmp	 SHORT $LN71@z900_kimd_
$LN70@z900_kimd_:
  007b1	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  007b8	ff c0		 inc	 eax
  007ba	48 98		 cdqe
  007bc	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007cb	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv411[rsp], rax
$LN71@z900_kimd_:
  007d3	48 63 44 24 30	 movsxd	 rax, DWORD PTR message_blocklen$[rsp]
  007d8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv411[rsp]
  007e0	48 2b c8	 sub	 rcx, rax
  007e3	48 8b c1	 mov	 rax, rcx
  007e6	8b 8c 24 a8 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  007ed	ff c1		 inc	 ecx
  007ef	48 63 c9	 movsxd	 rcx, ecx
  007f2	48 8b 94 24 b0
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007fa	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN34@z900_kimd_:
  00801	33 c0		 xor	 eax, eax
  00803	85 c0		 test	 eax, eax
  00805	0f 85 c3 fe ff
	ff		 jne	 $LN19@z900_kimd_

; 998  : 
; 999  : #ifdef OPTION_KIMD_DEBUG
; 1000 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1001 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1002 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1003 : 
; 1004 :     /* check for end of data */
; 1005 :     if(unlikely(GR_A(r2 + 1, regs) < (unsigned) message_blocklen))

  0080b	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00813	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00819	83 e0 01	 and	 eax, 1
  0081c	85 c0		 test	 eax, eax
  0081e	74 25		 je	 SHORT $LN72@z900_kimd_
  00820	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00827	ff c0		 inc	 eax
  00829	48 98		 cdqe
  0082b	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00833	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0083b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv432[rsp], rax
  00843	eb 22		 jmp	 SHORT $LN73@z900_kimd_
$LN72@z900_kimd_:
  00845	8b 84 24 a8 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0084c	ff c0		 inc	 eax
  0084e	48 98		 cdqe
  00850	48 8b 8c 24 b0
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00858	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0085f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv432[rsp], rax
$LN73@z900_kimd_:
  00867	8b 44 24 30	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  0086b	48 39 84 24 b0
	00 00 00	 cmp	 QWORD PTR tv432[rsp], rax
  00873	73 0a		 jae	 SHORT $LN78@z900_kimd_
  00875	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv455[rsp], 1
  0087d	eb 08		 jmp	 SHORT $LN79@z900_kimd_
$LN78@z900_kimd_:
  0087f	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv455[rsp], 0
$LN79@z900_kimd_:
  00887	83 7c 24 58 00	 cmp	 DWORD PTR tv455[rsp], 0
  0088c	74 33		 je	 SHORT $LN35@z900_kimd_

; 1006 :     {
; 1007 :       if(unlikely(klmd))

  0088e	83 bc 24 b8 03
	00 00 00	 cmp	 DWORD PTR klmd$[rsp], 0
  00896	74 0a		 je	 SHORT $LN82@z900_kimd_
  00898	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv461[rsp], 1
  008a0	eb 08		 jmp	 SHORT $LN83@z900_kimd_
$LN82@z900_kimd_:
  008a2	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv461[rsp], 0
$LN83@z900_kimd_:
  008aa	83 7c 24 5c 00	 cmp	 DWORD PTR tv461[rsp], 0
  008af	74 02		 je	 SHORT $LN36@z900_kimd_

; 1008 :         return;

  008b1	eb 1f		 jmp	 SHORT $LN1@z900_kimd_
$LN36@z900_kimd_:

; 1009 :       regs->psw.cc = 0;

  008b3	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008bb	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1010 :       return;

  008bf	eb 11		 jmp	 SHORT $LN1@z900_kimd_
$LN35@z900_kimd_:

; 1011 :     }
; 1012 :   }

  008c1	e9 db fa ff ff	 jmp	 $LN9@z900_kimd_
$LN10@z900_kimd_:

; 1013 : 
; 1014 :   /* CPU-determined amount of data processed */
; 1015 :   regs->psw.cc = 3;

  008c6	48 8b 84 24 b0
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  008ce	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@z900_kimd_:

; 1016 : }

  008d2	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  008da	48 33 cc	 xor	 rcx, rsp
  008dd	e8 00 00 00 00	 call	 __security_check_cookie
  008e2	48 81 c4 98 03
	00 00		 add	 rsp, 920		; 00000398H
  008e9	c3		 ret	 0
z900_kimd_sha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_validate_operand
_TEXT	SEGMENT
tv81 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
z900_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00017	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001c	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  00020	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00024	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00028	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00031	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00036	ba 01 00 00 00	 mov	 edx, 1
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00040	e8 00 00 00 00	 call	 z900_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00045	48 8b 44 24 50	 mov	 rax, QWORD PTR addr$[rsp]
  0004a	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00050	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00055	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00059	3b c1		 cmp	 eax, ecx
  0005b	7e 0a		 jle	 SHORT $LN6@z900_valid
  0005d	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00065	eb 08		 jmp	 SHORT $LN7@z900_valid
$LN6@z900_valid:
  00067	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN7@z900_valid:
  0006f	83 7c 24 30 00	 cmp	 DWORD PTR tv81[rsp], 0
  00074	74 48		 je	 SHORT $LN2@z900_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00076	48 63 44 24 60	 movsxd	 rax, DWORD PTR len$[rsp]
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR addr$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008b	48 23 81 90 00
	00 00		 and	 rax, QWORD PTR [rcx+144]
  00092	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00097	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0009b	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  000a3	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  000a7	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000ac	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000b1	ba 01 00 00 00	 mov	 edx, 1
  000b6	48 8b c8	 mov	 rcx, rax
  000b9	e8 00 00 00 00	 call	 z900_maddr_l
$LN2@z900_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000be	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000c2	c3		 ret	 0
z900_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
z900_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002c	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00031	2b d1		 sub	 edx, ecx
  00033	8b ca		 mov	 ecx, edx
  00035	3b c1		 cmp	 eax, ecx
  00037	7f 0a		 jg	 SHORT $LN7@z900_vfetc
  00039	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00041	eb 08		 jmp	 SHORT $LN8@z900_vfetc
$LN7@z900_vfetc:
  00043	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vfetc:
  0004b	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00050	74 63		 je	 SHORT $LN2@z900_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00052	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00057	ff c0		 inc	 eax
  00059	48 98		 cdqe
  0005b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00063	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00067	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0006b	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00073	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0007b	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00083	48 8b d0	 mov	 rdx, rax
  00086	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0008e	e8 00 00 00 00	 call	 z900_maddr_l
  00093	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00098	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009d	ff c0		 inc	 eax
  0009f	48 98		 cdqe
  000a1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a6	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	f3 a4		 rep movsb

; 640  :     }

  000b0	e9 01 01 00 00	 jmp	 $LN3@z900_vfetc
$LN2@z900_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000bd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000c3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c8	48 2b c8	 sub	 rcx, rax
  000cb	48 8b c1	 mov	 rax, rcx
  000ce	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000d2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000df	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000e3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000ef	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ff	48 8b d0	 mov	 rdx, rax
  00102	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0010a	e8 00 00 00 00	 call	 z900_maddr_l
  0010f	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00114	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00119	ff c0		 inc	 eax
  0011b	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0011f	48 98		 cdqe
  00121	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00126	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  0012e	48 03 d1	 add	 rdx, rcx
  00131	48 8b ca	 mov	 rcx, rdx
  00134	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013c	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  00143	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0014b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0014f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00153	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0015b	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00163	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0016b	48 8b d0	 mov	 rdx, rax
  0016e	e8 00 00 00 00	 call	 z900_maddr_l
  00173	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  00178	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0017d	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00182	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  00187	48 8b c8	 mov	 rcx, rax
  0018a	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0018c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00191	ff c0		 inc	 eax
  00193	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00197	48 98		 cdqe
  00199	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0019e	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001a3	48 03 d1	 add	 rdx, rcx
  001a6	48 8b ca	 mov	 rcx, rdx
  001a9	48 8b f9	 mov	 rdi, rcx
  001ac	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	f3 a4		 rep movsb
$LN3@z900_vfetc:

; 649  :     }
; 650  : }

  001b6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
z900_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT z900_vstorec
_TEXT	SEGMENT
len2$ = 48
tv76 = 52
sk$ = 56
tv83 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
z900_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  00021	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  00027	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002f	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00034	2b d1		 sub	 edx, ecx
  00036	8b ca		 mov	 ecx, edx
  00038	3b c1		 cmp	 eax, ecx
  0003a	7f 0a		 jg	 SHORT $LN7@z900_vstor
  0003c	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00044	eb 08		 jmp	 SHORT $LN8@z900_vstor
$LN7@z900_vstor:
  00046	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN8@z900_vstor:
  0004e	83 7c 24 34 00	 cmp	 DWORD PTR tv76[rsp], 0
  00053	74 70		 je	 SHORT $LN2@z900_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00055	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005d	ff c0		 inc	 eax
  0005f	48 98		 cdqe
  00061	48 89 44 24 40	 mov	 QWORD PTR tv83[rsp], rax
  00066	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006e	ff c1		 inc	 ecx
  00070	48 63 c9	 movsxd	 rcx, ecx
  00073	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007b	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007f	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00083	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008b	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00093	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009b	48 8b d1	 mov	 rdx, rcx
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  000a6	e8 00 00 00 00	 call	 z900_maddr_l
  000ab	48 8b f8	 mov	 rdi, rax
  000ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR tv83[rsp]
  000bb	48 8b c8	 mov	 rcx, rax
  000be	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000c0	e9 33 01 00 00	 jmp	 $LN3@z900_vstor
$LN2@z900_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c5	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR addr$[rsp]
  000cd	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000d3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d8	48 2b c8	 sub	 rcx, rax
  000db	48 8b c1	 mov	 rax, rcx
  000de	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000e2	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ef	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000f3	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f7	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000ff	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00107	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0010f	48 8b d0	 mov	 rdx, rax
  00112	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR addr$[rsp]
  0011a	e8 00 00 00 00	 call	 z900_maddr_l
  0011f	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00124	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0012c	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00133	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00138	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00140	ff c0		 inc	 eax
  00142	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00146	48 98		 cdqe
  00148	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  0014d	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR addr$[rsp]
  00155	48 03 d1	 add	 rdx, rcx
  00158	48 8b ca	 mov	 rcx, rdx
  0015b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00163	48 23 8a 90 00
	00 00		 and	 rcx, QWORD PTR [rdx+144]
  0016a	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00172	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00176	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0017a	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00182	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0018a	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00192	48 8b d0	 mov	 rdx, rax
  00195	e8 00 00 00 00	 call	 z900_maddr_l
  0019a	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  0019f	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  001a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a7	83 c8 06	 or	 eax, 6
  001aa	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001af	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001b1	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001b6	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001bb	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001c3	48 8b c8	 mov	 rcx, rax
  001c6	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001c8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001d0	ff c0		 inc	 eax
  001d2	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001d6	48 98		 cdqe
  001d8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001dd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001e5	48 03 d1	 add	 rdx, rcx
  001e8	48 8b ca	 mov	 rcx, rdx
  001eb	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001f0	48 8b f1	 mov	 rsi, rcx
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	f3 a4		 rep movsb
$LN3@z900_vstor:

; 512  :     }
; 513  : }

  001f8	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001fc	5f		 pop	 rdi
  001fd	5e		 pop	 rsi
  001fe	c3		 ret	 0
z900_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT z900_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
z900_maddr_l PROC					; COMDAT

; 307  : {

$LN18:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00018	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001d	7c 0a		 jl	 SHORT $LN16@z900_maddr
  0001f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00027	eb 19		 jmp	 SHORT $LN17@z900_maddr
$LN16@z900_maddr:
  00029	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002d	83 c0 05	 add	 eax, 5
  00030	48 98		 cdqe
  00032	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003e	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN17@z900_maddr:
  00042	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00046	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  0004a	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0004f	48 c1 e8 0c	 shr	 rax, 12
  00053	48 25 ff 03 00
	00		 and	 rax, 1023		; 000003ffH
  00059	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005e	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00067	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  0006c	0f 84 2d 01 00
	00		 je	 $LN2@z900_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  00072	33 c0		 xor	 eax, eax
  00074	85 c0		 test	 eax, eax
  00076	75 5a		 jne	 SHORT $LN4@z900_maddr
  00078	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  0007c	ff c0		 inc	 eax
  0007e	48 98		 cdqe
  00080	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00085	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0008a	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008f	49 8b 8c c8 60
	b0 00 00	 mov	 rcx, QWORD PTR [r8+rcx*8+45152]
  00097	48 39 8c c2 00
	06 00 00	 cmp	 QWORD PTR [rdx+rax*8+1536], rcx
  0009f	74 31		 je	 SHORT $LN4@z900_maddr
  000a1	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a5	ff c0		 inc	 eax
  000a7	48 98		 cdqe
  000a9	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000ae	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b6	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000bb	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000c0	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c8	23 c1		 and	 eax, ecx
  000ca	85 c0		 test	 eax, eax
  000cc	0f 84 cd 00 00
	00		 je	 $LN3@z900_maddr
$LN4@z900_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000d2	33 c0		 xor	 eax, eax
  000d4	85 c0		 test	 eax, eax
  000d6	75 2e		 jne	 SHORT $LN6@z900_maddr
  000d8	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e0	85 c0		 test	 eax, eax
  000e2	74 22		 je	 SHORT $LN6@z900_maddr
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000ec	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000f1	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f6	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000fe	3b c1		 cmp	 eax, ecx
  00100	0f 85 99 00 00
	00		 jne	 $LN5@z900_maddr
$LN6@z900_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR addr$[rsp]
  0010b	48 25 00 00 c0
	ff		 and	 rax, -4194304		; ffffffffffc00000H
  00111	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 89 58 b0 00
	00		 mov	 ecx, DWORD PTR [rcx+45144]
  0011c	48 0b c1	 or	 rax, rcx
  0011f	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00124	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00129	48 3b 84 ca 60
	d0 00 00	 cmp	 rax, QWORD PTR [rdx+rcx*8+53344]
  00131	75 6c		 jne	 SHORT $LN7@z900_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00133	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00138	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0013d	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  00145	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  0014c	23 c8		 and	 ecx, eax
  0014e	8b c1		 mov	 eax, ecx
  00150	85 c0		 test	 eax, eax
  00152	74 4b		 je	 SHORT $LN8@z900_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00154	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 1e		 je	 SHORT $LN9@z900_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00162	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00167	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00171	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  00179	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@z900_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00180	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  00185	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0018a	48 8b 54 24 60	 mov	 rdx, QWORD PTR addr$[rsp]
  0018f	48 8b 84 c1 60
	10 01 00	 mov	 rax, QWORD PTR [rcx+rax*8+69728]
  00197	48 33 c2	 xor	 rax, rdx
  0019a	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@z900_maddr:
$LN7@z900_maddr:
$LN5@z900_maddr:
$LN3@z900_maddr:
$LN2@z900_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  0019f	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  001a5	75 37		 jne	 SHORT $LN10@z900_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  001a7	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001ac	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b1	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001b9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001bd	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001c5	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001ca	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  001d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_z900_logical_to_main_l
  001d9	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@z900_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))

  001de	b8 01 00 00 00	 mov	 eax, 1
  001e3	48 6b c0 09	 imul	 rax, rax, 9
  001e7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  001ec	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  001f4	83 e0 40	 and	 eax, 64			; 00000040H
  001f7	85 c0		 test	 eax, eax
  001f9	0f 84 8a 00 00
	00		 je	 $LN11@z900_maddr

; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */

  001ff	33 c0		 xor	 eax, eax
  00201	85 c0		 test	 eax, eax
  00203	75 26		 jne	 SHORT $LN13@z900_maddr
  00205	48 83 7c 24 78
	00		 cmp	 QWORD PTR regs$[rsp], 0
  0020b	74 1e		 je	 SHORT $LN13@z900_maddr
  0020d	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00212	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00219	85 c0		 test	 eax, eax
  0021b	74 0e		 je	 SHORT $LN13@z900_maddr
  0021d	83 7c 24 70 ff	 cmp	 DWORD PTR arn$[rsp], -1
  00222	74 07		 je	 SHORT $LN13@z900_maddr
  00224	83 7c 24 70 fe	 cmp	 DWORD PTR arn$[rsp], -2
  00229	75 07		 jne	 SHORT $LN12@z900_maddr
$LN13@z900_maddr:

; 385  :         )
; 386  :             return maddr;

  0022b	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00230	eb 5c		 jmp	 SHORT $LN1@z900_maddr
$LN12@z900_maddr:

; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)

  00232	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00237	0f b6 80 4b 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3659]
  0023e	85 c0		 test	 eax, eax
  00240	74 13		 je	 SHORT $LN14@z900_maddr

; 390  :         {
; 391  :             regs->txf_NTSTG = false;

  00242	48 8b 44 24 78	 mov	 rax, QWORD PTR regs$[rsp]
  00247	c6 80 4b 0e 00
	00 00		 mov	 BYTE PTR [rax+3659], 0

; 392  :             return maddr;

  0024e	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  00253	eb 39		 jmp	 SHORT $LN1@z900_maddr
$LN14@z900_maddr:

; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );

  00255	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
  0025a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0025f	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00266	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0026a	4c 8b 4c 24 78	 mov	 r9, QWORD PTR regs$[rsp]
  0026f	44 8b 44 24 70	 mov	 r8d, DWORD PTR arn$[rsp]
  00274	48 8b 54 24 68	 mov	 rdx, QWORD PTR len$[rsp]
  00279	48 8b 4c 24 60	 mov	 rcx, QWORD PTR addr$[rsp]
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_txf_maddr_l
  00284	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN11@z900_maddr:

; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  00289	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]
$LN1@z900_maddr:

; 401  : }

  0028e	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00292	c3		 ret	 0
z900_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_lcheck
_TEXT	SEGMENT
tv79 = 32
tv95 = 40
regs$ = 64
r1$ = 72
l1$ = 80
z900_per3_zero_lcheck PROC				; COMDAT

; 662  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 663  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 664  :     if (1
; 665  :         && GR_A( l1, regs ) != 0
; 666  :         && GR_A( r1, regs ) == 0

  00012	33 c0		 xor	 eax, eax
  00014	83 f8 01	 cmp	 eax, 1
  00017	0f 84 9c 00 00
	00		 je	 $LN2@z900_per3_
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00022	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00028	83 e0 01	 and	 eax, 1
  0002b	85 c0		 test	 eax, eax
  0002d	74 19		 je	 SHORT $LN4@z900_per3_
  0002f	48 63 44 24 50	 movsxd	 rax, DWORD PTR l1$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00039	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00041	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  00046	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  00048	48 63 44 24 50	 movsxd	 rax, DWORD PTR l1$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00059	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN5@z900_per3_:
  0005e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  00064	74 53		 je	 SHORT $LN2@z900_per3_
  00066	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006b	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00071	83 e0 01	 and	 eax, 1
  00074	85 c0		 test	 eax, eax
  00076	74 19		 je	 SHORT $LN6@z900_per3_
  00078	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0007d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  0008a	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
  0008f	eb 16		 jmp	 SHORT $LN7@z900_per3_
$LN6@z900_per3_:
  00091	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00096	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0009b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a2	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
$LN7@z900_per3_:
  000a7	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv95[rsp], 0
  000ad	75 0a		 jne	 SHORT $LN2@z900_per3_

; 667  :     )
; 668  :         ARCH_DEP( per3_zero )( regs );

  000af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b4	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 669  : #else
; 670  :     UNREFERENCED( regs );
; 671  :     UNREFERENCED( r1 );
; 672  :     UNREFERENCED( l1 );
; 673  : #endif
; 674  : }

  000b9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bd	c3		 ret	 0
z900_per3_zero_lcheck ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check2
_TEXT	SEGMENT
tv79 = 32
tv95 = 40
regs$ = 64
r1$ = 72
r2$ = 80
z900_per3_zero_check2 PROC				; COMDAT

; 640  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 641  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 642  :     if (0
; 643  :         || GR_A( r1, regs ) == 0
; 644  :         || GR_A( r2, regs ) == 0

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	0f 85 92 00 00
	00		 jne	 $LN3@z900_per3_
  0001c	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00021	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	74 19		 je	 SHORT $LN5@z900_per3_
  0002e	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00033	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00038	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00040	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
  00045	eb 16		 jmp	 SHORT $LN6@z900_per3_
$LN5@z900_per3_:
  00047	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00051	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00058	48 89 44 24 20	 mov	 QWORD PTR tv79[rsp], rax
$LN6@z900_per3_:
  0005d	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv79[rsp], 0
  00063	74 49		 je	 SHORT $LN3@z900_per3_
  00065	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0006a	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00070	83 e0 01	 and	 eax, 1
  00073	85 c0		 test	 eax, eax
  00075	74 19		 je	 SHORT $LN7@z900_per3_
  00077	48 63 44 24 50	 movsxd	 rax, DWORD PTR r2$[rsp]
  0007c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00081	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00089	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
  0008e	eb 16		 jmp	 SHORT $LN8@z900_per3_
$LN7@z900_per3_:
  00090	48 63 44 24 50	 movsxd	 rax, DWORD PTR r2$[rsp]
  00095	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0009a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000a1	48 89 44 24 28	 mov	 QWORD PTR tv95[rsp], rax
$LN8@z900_per3_:
  000a6	48 83 7c 24 28
	00		 cmp	 QWORD PTR tv95[rsp], 0
  000ac	75 0a		 jne	 SHORT $LN2@z900_per3_
$LN3@z900_per3_:

; 645  :     )
; 646  :         ARCH_DEP( per3_zero )( regs );

  000ae	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000b3	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 647  : #else
; 648  :     UNREFERENCED( regs );
; 649  :     UNREFERENCED( r1 );
; 650  :     UNREFERENCED( r2 );
; 651  : #endif
; 652  : }

  000b8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bc	c3		 ret	 0
z900_per3_zero_check2 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero_check
_TEXT	SEGMENT
tv78 = 32
regs$ = 64
r1$ = 72
z900_per3_zero_check PROC				; COMDAT

; 629  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 630  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 631  :     if (GR_A( r1, regs ) == 0)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00012	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 19		 je	 SHORT $LN4@z900_per3_
  0001f	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  00024	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00029	48 8b 84 c1 80
	02 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+640]
  00031	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
  00036	eb 16		 jmp	 SHORT $LN5@z900_per3_
$LN4@z900_per3_:
  00038	48 63 44 24 48	 movsxd	 rax, DWORD PTR r1$[rsp]
  0003d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00042	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00049	48 89 44 24 20	 mov	 QWORD PTR tv78[rsp], rax
$LN5@z900_per3_:
  0004e	48 83 7c 24 20
	00		 cmp	 QWORD PTR tv78[rsp], 0
  00054	75 0a		 jne	 SHORT $LN2@z900_per3_

; 632  :         ARCH_DEP( per3_zero )( regs );

  00056	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  0005b	e8 00 00 00 00	 call	 z900_per3_zero
$LN2@z900_per3_:

; 633  : #else
; 634  :     UNREFERENCED( regs );
; 635  :     UNREFERENCED( r1 );
; 636  : #endif
; 637  : }

  00060	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00064	c3		 ret	 0
z900_per3_zero_check ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_per3_zero
_TEXT	SEGMENT
tv75 = 32
regs$ = 64
z900_per3_zero PROC					; COMDAT

; 602  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 603  : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 604  :     if (1
; 605  :         && EN_IC_PER_ZEROADDR( regs )
; 606  :         && !IS_PER_SUPRESS( regs, CR9_ZEROADDR )

  00009	33 c0		 xor	 eax, eax
  0000b	83 f8 01	 cmp	 eax, 1
  0000e	0f 84 be 00 00
	00		 je	 $LN5@z900_per3_
  00014	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00019	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0001f	c1 e8 02	 shr	 eax, 2
  00022	83 e0 01	 and	 eax, 1
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN10@z900_per3_
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN11@z900_per3_
$LN10@z900_per3_:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN11@z900_per3_:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	0f 84 8c 00 00
	00		 je	 $LN5@z900_per3_
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0004b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0004e	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00053	85 c0		 test	 eax, eax
  00055	74 7b		 je	 SHORT $LN5@z900_per3_
  00057	ba 00 00 00 04	 mov	 edx, 67108864		; 04000000H
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	e8 00 00 00 00	 call	 z900_is_per3_event_suppressed
  00066	0f b6 c0	 movzx	 eax, al
  00069	85 c0		 test	 eax, eax
  0006b	75 65		 jne	 SHORT $LN5@z900_per3_

; 607  :     )
; 608  :     {
; 609  :         regs->peradr = regs->periaddr;

  0006d	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	48 8b 89 e8 08
	00 00		 mov	 rcx, QWORD PTR [rcx+2280]
  0007e	48 89 88 d8 08
	00 00		 mov	 QWORD PTR [rax+2264], rcx
$LN4@z900_per3_:

; 610  :         ON_IC_PER_ZEROADDR( regs );

  00085	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  0008a	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0008d	0f ba e8 12	 bts	 eax, 18
  00091	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  00096	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
  00099	33 c0		 xor	 eax, eax
  0009b	85 c0		 test	 eax, eax
  0009d	75 e6		 jne	 SHORT $LN4@z900_per3_

; 611  :         if (OPEN_IC_PER_ZEROADDR( regs ))

  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000a4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	8b 49 4c	 mov	 ecx, DWORD PTR [rcx+76]
  000ac	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  000af	23 c1		 and	 eax, ecx
  000b1	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  000b6	85 c0		 test	 eax, eax
  000b8	74 18		 je	 SHORT $LN6@z900_per3_

; 612  :             RETURN_INTCHECK( regs );

  000ba	48 8b 44 24 40	 mov	 rax, QWORD PTR regs$[rsp]
  000bf	48 05 80 09 00
	00		 add	 rax, 2432		; 00000980H
  000c5	ba ff ff ff ff	 mov	 edx, -1
  000ca	48 8b c8	 mov	 rcx, rax
  000cd	e8 00 00 00 00	 call	 longjmp
$LN6@z900_per3_:
$LN5@z900_per3_:
$LN7@z900_per3_:

; 613  :     }
; 614  : #else
; 615  :     UNREFERENCED( regs );
; 616  : #endif
; 617  : }

  000d2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d6	c3		 ret	 0
z900_per3_zero ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\inline.h
;	COMDAT z900_is_per3_event_suppressed
_TEXT	SEGMENT
regs$ = 8
cr9_per_event$ = 16
z900_is_per3_event_suppressed PROC			; COMDAT

; 566  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 567  : #if !defined( FEATURE_PER3 )
; 568  :     UNREFERENCED( regs );
; 569  :     UNREFERENCED( cr9_per_event );
; 570  : #else
; 571  :     /* DON'T suppress this event if Event Suppression isn't enabled */
; 572  :     if (!(regs->CR_L(9) & CR9_SUPPRESS))

  00009	b8 08 00 00 00	 mov	 eax, 8
  0000e	48 6b c0 0a	 imul	 rax, rax, 10
  00012	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00017	8b 84 01 00 06
	00 00		 mov	 eax, DWORD PTR [rcx+rax+1536]
  0001e	25 00 00 40 00	 and	 eax, 4194304		; 00400000H
  00023	85 c0		 test	 eax, eax
  00025	75 04		 jne	 SHORT $LN2@z900_is_pe

; 573  :         return false;

  00027	32 c0		 xor	 al, al
  00029	eb 78		 jmp	 SHORT $LN1@z900_is_pe
$LN2@z900_is_pe:

; 574  : 
; 575  :     /* Is this PER event one that is ALLOWED to be suppressed? */
; 576  :     if (cr9_per_event & CR9_SUPPRESSABLE)

  0002b	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  0002f	25 00 00 00 ed	 and	 eax, -318767104		; ed000000H
  00034	85 c0		 test	 eax, eax
  00036	74 69		 je	 SHORT $LN3@z900_is_pe

; 577  :     {
; 578  :         /* Is there an active transaction? */
; 579  :         if (regs->txf_tnd)

  00038	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0003d	0f b6 80 58 0e
	00 00		 movzx	 eax, BYTE PTR [rax+3672]
  00044	85 c0		 test	 eax, eax
  00046	74 04		 je	 SHORT $LN4@z900_is_pe

; 580  :             return true;        /* Yes, then suppress it! */

  00048	b0 01		 mov	 al, 1
  0004a	eb 57		 jmp	 SHORT $LN1@z900_is_pe
$LN4@z900_is_pe:

; 581  : 
; 582  :         /* Suppress instruction-fetch events for TBEGIN/TBEGINC */
; 583  :         if (1
; 584  :             && cr9_per_event & CR9_IF
; 585  :             && *(regs->ip+0) == 0xE5
; 586  :             && (0

  0004c	33 c0		 xor	 eax, eax
  0004e	83 f8 01	 cmp	 eax, 1
  00051	74 4e		 je	 SHORT $LN5@z900_is_pe
  00053	8b 44 24 10	 mov	 eax, DWORD PTR cr9_per_event$[rsp]
  00057	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0005c	85 c0		 test	 eax, eax
  0005e	74 41		 je	 SHORT $LN5@z900_is_pe
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00065	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00069	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006c	3d e5 00 00 00	 cmp	 eax, 229		; 000000e5H
  00071	75 2e		 jne	 SHORT $LN5@z900_is_pe
  00073	33 c0		 xor	 eax, eax
  00075	85 c0		 test	 eax, eax
  00077	75 24		 jne	 SHORT $LN6@z900_is_pe
  00079	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  0007e	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00082	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00086	83 f8 60	 cmp	 eax, 96			; 00000060H
  00089	74 12		 je	 SHORT $LN6@z900_is_pe
  0008b	48 8b 44 24 08	 mov	 rax, QWORD PTR regs$[rsp]
  00090	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00094	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00098	83 f8 61	 cmp	 eax, 97			; 00000061H
  0009b	75 04		 jne	 SHORT $LN5@z900_is_pe
$LN6@z900_is_pe:

; 587  :                 || *(regs->ip+1) == 0x60
; 588  :                 || *(regs->ip+1) == 0x61
; 589  :                )
; 590  :         )
; 591  :             return true;        /* TBEGIN/TBEGINC: suppress it! */

  0009d	b0 01		 mov	 al, 1
  0009f	eb 02		 jmp	 SHORT $LN1@z900_is_pe
$LN5@z900_is_pe:
$LN3@z900_is_pe:

; 592  :     }
; 593  : #endif
; 594  :     /* Otherwise DON'T suppress this PER event */
; 595  :     return false;

  000a1	32 c0		 xor	 al, al
$LN1@z900_is_pe:

; 596  : }

  000a3	c3		 ret	 0
z900_is_per3_event_suppressed ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
tv73 = 32
tv74 = 36
tv86 = 40
tv87 = 44
tv130 = 48
tv131 = 52
inst$ = 80
regs$ = 88
s390_dyn_cipher_message_with_counter PROC

; 5044 :  HDL_UNDEF_INST( dyn_cipher_message_with_counter         )

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_dyn_c:
  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 00	 imul	 rax, rax, 0
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	83 f8 40	 cmp	 eax, 64			; 00000040H
  00023	7d 0a		 jge	 SHORT $LN9@s390_dyn_c
  00025	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0002d	eb 33		 jmp	 SHORT $LN10@s390_dyn_c
$LN9@s390_dyn_c:
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00046	7d 0a		 jge	 SHORT $LN7@s390_dyn_c
  00048	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv73[rsp], 4
  00050	eb 08		 jmp	 SHORT $LN8@s390_dyn_c
$LN7@s390_dyn_c:
  00052	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR tv73[rsp], 6
$LN8@s390_dyn_c:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  0005e	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
$LN10@s390_dyn_c:
  00062	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 00	 imul	 rax, rax, 0
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008e	7d 0a		 jge	 SHORT $LN13@s390_dyn_c
  00090	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv87[rsp], 2
  00098	eb 33		 jmp	 SHORT $LN14@s390_dyn_c
$LN13@s390_dyn_c:
  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	48 6b c0 00	 imul	 rax, rax, 0
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000b1	7d 0a		 jge	 SHORT $LN11@s390_dyn_c
  000b3	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv86[rsp], 4
  000bb	eb 08		 jmp	 SHORT $LN12@s390_dyn_c
$LN11@s390_dyn_c:
  000bd	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR tv86[rsp], 6
$LN12@s390_dyn_c:
  000c5	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000c9	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
$LN14@s390_dyn_c:
  000cd	83 7c 24 2c 00	 cmp	 DWORD PTR tv87[rsp], 0
  000d2	74 64		 je	 SHORT $LN5@s390_dyn_c
  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	48 6b c0 00	 imul	 rax, rax, 0
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e6	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e9	7d 0a		 jge	 SHORT $LN17@s390_dyn_c
  000eb	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000f3	eb 33		 jmp	 SHORT $LN18@s390_dyn_c
$LN17@s390_dyn_c:
  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 00	 imul	 rax, rax, 0
  000fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0010c	7d 0a		 jge	 SHORT $LN15@s390_dyn_c
  0010e	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR tv130[rsp], 4
  00116	eb 08		 jmp	 SHORT $LN16@s390_dyn_c
$LN15@s390_dyn_c:
  00118	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR tv130[rsp], 6
$LN16@s390_dyn_c:
  00120	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  00124	89 44 24 34	 mov	 DWORD PTR tv131[rsp], eax
$LN18@s390_dyn_c:
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012d	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv131[rsp]
  00132	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl
$LN5@s390_dyn_c:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 cc fe ff
	ff		 jne	 $LN4@s390_dyn_c
  00142	ba 01 00 00 00	 mov	 edx, 1
  00147	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00151	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
  00157	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015b	c3		 ret	 0
s390_dyn_cipher_message_with_counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
tv73 = 32
tv74 = 36
tv86 = 40
tv87 = 44
tv130 = 48
tv131 = 52
inst$ = 80
regs$ = 88
s390_dyn_cipher_message_with_output_feedback PROC

; 5043 :  HDL_UNDEF_INST( dyn_cipher_message_with_output_feedback )

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_dyn_c:
  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 00	 imul	 rax, rax, 0
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	83 f8 40	 cmp	 eax, 64			; 00000040H
  00023	7d 0a		 jge	 SHORT $LN9@s390_dyn_c
  00025	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0002d	eb 33		 jmp	 SHORT $LN10@s390_dyn_c
$LN9@s390_dyn_c:
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00046	7d 0a		 jge	 SHORT $LN7@s390_dyn_c
  00048	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv73[rsp], 4
  00050	eb 08		 jmp	 SHORT $LN8@s390_dyn_c
$LN7@s390_dyn_c:
  00052	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR tv73[rsp], 6
$LN8@s390_dyn_c:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  0005e	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
$LN10@s390_dyn_c:
  00062	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 00	 imul	 rax, rax, 0
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008e	7d 0a		 jge	 SHORT $LN13@s390_dyn_c
  00090	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv87[rsp], 2
  00098	eb 33		 jmp	 SHORT $LN14@s390_dyn_c
$LN13@s390_dyn_c:
  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	48 6b c0 00	 imul	 rax, rax, 0
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000b1	7d 0a		 jge	 SHORT $LN11@s390_dyn_c
  000b3	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv86[rsp], 4
  000bb	eb 08		 jmp	 SHORT $LN12@s390_dyn_c
$LN11@s390_dyn_c:
  000bd	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR tv86[rsp], 6
$LN12@s390_dyn_c:
  000c5	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000c9	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
$LN14@s390_dyn_c:
  000cd	83 7c 24 2c 00	 cmp	 DWORD PTR tv87[rsp], 0
  000d2	74 64		 je	 SHORT $LN5@s390_dyn_c
  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	48 6b c0 00	 imul	 rax, rax, 0
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e6	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e9	7d 0a		 jge	 SHORT $LN17@s390_dyn_c
  000eb	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000f3	eb 33		 jmp	 SHORT $LN18@s390_dyn_c
$LN17@s390_dyn_c:
  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 00	 imul	 rax, rax, 0
  000fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0010c	7d 0a		 jge	 SHORT $LN15@s390_dyn_c
  0010e	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR tv130[rsp], 4
  00116	eb 08		 jmp	 SHORT $LN16@s390_dyn_c
$LN15@s390_dyn_c:
  00118	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR tv130[rsp], 6
$LN16@s390_dyn_c:
  00120	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  00124	89 44 24 34	 mov	 DWORD PTR tv131[rsp], eax
$LN18@s390_dyn_c:
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012d	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv131[rsp]
  00132	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl
$LN5@s390_dyn_c:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 cc fe ff
	ff		 jne	 $LN4@s390_dyn_c
  00142	ba 01 00 00 00	 mov	 edx, 1
  00147	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00151	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
  00157	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015b	c3		 ret	 0
s390_dyn_cipher_message_with_output_feedback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
tv73 = 32
tv74 = 36
tv86 = 40
tv87 = 44
tv130 = 48
tv131 = 52
inst$ = 80
regs$ = 88
s390_dyn_cipher_message_with_cipher_feedback PROC

; 5042 :  HDL_UNDEF_INST( dyn_cipher_message_with_cipher_feedback )

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_dyn_c:
  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 00	 imul	 rax, rax, 0
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	83 f8 40	 cmp	 eax, 64			; 00000040H
  00023	7d 0a		 jge	 SHORT $LN9@s390_dyn_c
  00025	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0002d	eb 33		 jmp	 SHORT $LN10@s390_dyn_c
$LN9@s390_dyn_c:
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00046	7d 0a		 jge	 SHORT $LN7@s390_dyn_c
  00048	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv73[rsp], 4
  00050	eb 08		 jmp	 SHORT $LN8@s390_dyn_c
$LN7@s390_dyn_c:
  00052	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR tv73[rsp], 6
$LN8@s390_dyn_c:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  0005e	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
$LN10@s390_dyn_c:
  00062	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 00	 imul	 rax, rax, 0
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008e	7d 0a		 jge	 SHORT $LN13@s390_dyn_c
  00090	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv87[rsp], 2
  00098	eb 33		 jmp	 SHORT $LN14@s390_dyn_c
$LN13@s390_dyn_c:
  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	48 6b c0 00	 imul	 rax, rax, 0
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000b1	7d 0a		 jge	 SHORT $LN11@s390_dyn_c
  000b3	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv86[rsp], 4
  000bb	eb 08		 jmp	 SHORT $LN12@s390_dyn_c
$LN11@s390_dyn_c:
  000bd	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR tv86[rsp], 6
$LN12@s390_dyn_c:
  000c5	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000c9	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
$LN14@s390_dyn_c:
  000cd	83 7c 24 2c 00	 cmp	 DWORD PTR tv87[rsp], 0
  000d2	74 64		 je	 SHORT $LN5@s390_dyn_c
  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	48 6b c0 00	 imul	 rax, rax, 0
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e6	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e9	7d 0a		 jge	 SHORT $LN17@s390_dyn_c
  000eb	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000f3	eb 33		 jmp	 SHORT $LN18@s390_dyn_c
$LN17@s390_dyn_c:
  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 00	 imul	 rax, rax, 0
  000fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0010c	7d 0a		 jge	 SHORT $LN15@s390_dyn_c
  0010e	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR tv130[rsp], 4
  00116	eb 08		 jmp	 SHORT $LN16@s390_dyn_c
$LN15@s390_dyn_c:
  00118	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR tv130[rsp], 6
$LN16@s390_dyn_c:
  00120	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  00124	89 44 24 34	 mov	 DWORD PTR tv131[rsp], eax
$LN18@s390_dyn_c:
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012d	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv131[rsp]
  00132	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl
$LN5@s390_dyn_c:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 cc fe ff
	ff		 jne	 $LN4@s390_dyn_c
  00142	ba 01 00 00 00	 mov	 edx, 1
  00147	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00151	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
  00157	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015b	c3		 ret	 0
s390_dyn_cipher_message_with_cipher_feedback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
tv73 = 32
tv74 = 36
tv86 = 40
tv87 = 44
tv130 = 48
tv131 = 52
inst$ = 80
regs$ = 88
s390_dyn_perform_cryptographic_computation PROC

; 5041 :  HDL_UNDEF_INST( dyn_perform_cryptographic_computation   )

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_dyn_p:
  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 00	 imul	 rax, rax, 0
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	83 f8 40	 cmp	 eax, 64			; 00000040H
  00023	7d 0a		 jge	 SHORT $LN9@s390_dyn_p
  00025	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0002d	eb 33		 jmp	 SHORT $LN10@s390_dyn_p
$LN9@s390_dyn_p:
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00046	7d 0a		 jge	 SHORT $LN7@s390_dyn_p
  00048	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv73[rsp], 4
  00050	eb 08		 jmp	 SHORT $LN8@s390_dyn_p
$LN7@s390_dyn_p:
  00052	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR tv73[rsp], 6
$LN8@s390_dyn_p:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  0005e	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
$LN10@s390_dyn_p:
  00062	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 00	 imul	 rax, rax, 0
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008e	7d 0a		 jge	 SHORT $LN13@s390_dyn_p
  00090	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv87[rsp], 2
  00098	eb 33		 jmp	 SHORT $LN14@s390_dyn_p
$LN13@s390_dyn_p:
  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	48 6b c0 00	 imul	 rax, rax, 0
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000b1	7d 0a		 jge	 SHORT $LN11@s390_dyn_p
  000b3	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv86[rsp], 4
  000bb	eb 08		 jmp	 SHORT $LN12@s390_dyn_p
$LN11@s390_dyn_p:
  000bd	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR tv86[rsp], 6
$LN12@s390_dyn_p:
  000c5	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000c9	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
$LN14@s390_dyn_p:
  000cd	83 7c 24 2c 00	 cmp	 DWORD PTR tv87[rsp], 0
  000d2	74 64		 je	 SHORT $LN5@s390_dyn_p
  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	48 6b c0 00	 imul	 rax, rax, 0
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e6	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e9	7d 0a		 jge	 SHORT $LN17@s390_dyn_p
  000eb	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000f3	eb 33		 jmp	 SHORT $LN18@s390_dyn_p
$LN17@s390_dyn_p:
  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 00	 imul	 rax, rax, 0
  000fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0010c	7d 0a		 jge	 SHORT $LN15@s390_dyn_p
  0010e	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR tv130[rsp], 4
  00116	eb 08		 jmp	 SHORT $LN16@s390_dyn_p
$LN15@s390_dyn_p:
  00118	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR tv130[rsp], 6
$LN16@s390_dyn_p:
  00120	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  00124	89 44 24 34	 mov	 DWORD PTR tv131[rsp], eax
$LN18@s390_dyn_p:
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012d	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv131[rsp]
  00132	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl
$LN5@s390_dyn_p:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 cc fe ff
	ff		 jne	 $LN4@s390_dyn_p
  00142	ba 01 00 00 00	 mov	 edx, 1
  00147	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00151	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
  00157	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015b	c3		 ret	 0
s390_dyn_perform_cryptographic_computation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
tv73 = 32
tv74 = 36
tv86 = 40
tv87 = 44
tv130 = 48
tv131 = 52
inst$ = 80
regs$ = 88
s390_dyn_perform_cryptographic_key_management_operation PROC

; 5037 :  HDL_UNDEF_INST( dyn_perform_cryptographic_key_management_operation )

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390_dyn_p:
  0000e	b8 01 00 00 00	 mov	 eax, 1
  00013	48 6b c0 00	 imul	 rax, rax, 0
  00017	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0001c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00020	83 f8 40	 cmp	 eax, 64			; 00000040H
  00023	7d 0a		 jge	 SHORT $LN9@s390_dyn_p
  00025	c7 44 24 24 02
	00 00 00	 mov	 DWORD PTR tv74[rsp], 2
  0002d	eb 33		 jmp	 SHORT $LN10@s390_dyn_p
$LN9@s390_dyn_p:
  0002f	b8 01 00 00 00	 mov	 eax, 1
  00034	48 6b c0 00	 imul	 rax, rax, 0
  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  00046	7d 0a		 jge	 SHORT $LN7@s390_dyn_p
  00048	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR tv73[rsp], 4
  00050	eb 08		 jmp	 SHORT $LN8@s390_dyn_p
$LN7@s390_dyn_p:
  00052	c7 44 24 20 06
	00 00 00	 mov	 DWORD PTR tv73[rsp], 6
$LN8@s390_dyn_p:
  0005a	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  0005e	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
$LN10@s390_dyn_p:
  00062	48 63 44 24 24	 movsxd	 rax, DWORD PTR tv74[rsp]
  00067	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0006c	48 03 41 68	 add	 rax, QWORD PTR [rcx+104]
  00070	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00079	b8 01 00 00 00	 mov	 eax, 1
  0007e	48 6b c0 00	 imul	 rax, rax, 0
  00082	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00087	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008b	83 f8 40	 cmp	 eax, 64			; 00000040H
  0008e	7d 0a		 jge	 SHORT $LN13@s390_dyn_p
  00090	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR tv87[rsp], 2
  00098	eb 33		 jmp	 SHORT $LN14@s390_dyn_p
$LN13@s390_dyn_p:
  0009a	b8 01 00 00 00	 mov	 eax, 1
  0009f	48 6b c0 00	 imul	 rax, rax, 0
  000a3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000ac	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  000b1	7d 0a		 jge	 SHORT $LN11@s390_dyn_p
  000b3	c7 44 24 28 04
	00 00 00	 mov	 DWORD PTR tv86[rsp], 4
  000bb	eb 08		 jmp	 SHORT $LN12@s390_dyn_p
$LN11@s390_dyn_p:
  000bd	c7 44 24 28 06
	00 00 00	 mov	 DWORD PTR tv86[rsp], 6
$LN12@s390_dyn_p:
  000c5	8b 44 24 28	 mov	 eax, DWORD PTR tv86[rsp]
  000c9	89 44 24 2c	 mov	 DWORD PTR tv87[rsp], eax
$LN14@s390_dyn_p:
  000cd	83 7c 24 2c 00	 cmp	 DWORD PTR tv87[rsp], 0
  000d2	74 64		 je	 SHORT $LN5@s390_dyn_p
  000d4	b8 01 00 00 00	 mov	 eax, 1
  000d9	48 6b c0 00	 imul	 rax, rax, 0
  000dd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  000e2	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e6	83 f8 40	 cmp	 eax, 64			; 00000040H
  000e9	7d 0a		 jge	 SHORT $LN17@s390_dyn_p
  000eb	c7 44 24 34 02
	00 00 00	 mov	 DWORD PTR tv131[rsp], 2
  000f3	eb 33		 jmp	 SHORT $LN18@s390_dyn_p
$LN17@s390_dyn_p:
  000f5	b8 01 00 00 00	 mov	 eax, 1
  000fa	48 6b c0 00	 imul	 rax, rax, 0
  000fe	48 8b 4c 24 50	 mov	 rcx, QWORD PTR inst$[rsp]
  00103	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00107	3d c0 00 00 00	 cmp	 eax, 192		; 000000c0H
  0010c	7d 0a		 jge	 SHORT $LN15@s390_dyn_p
  0010e	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR tv130[rsp], 4
  00116	eb 08		 jmp	 SHORT $LN16@s390_dyn_p
$LN15@s390_dyn_p:
  00118	c7 44 24 30 06
	00 00 00	 mov	 DWORD PTR tv130[rsp], 6
$LN16@s390_dyn_p:
  00120	8b 44 24 30	 mov	 eax, DWORD PTR tv130[rsp]
  00124	89 44 24 34	 mov	 DWORD PTR tv131[rsp], eax
$LN18@s390_dyn_p:
  00128	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  0012d	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR tv131[rsp]
  00132	88 88 9a 00 00
	00		 mov	 BYTE PTR [rax+154], cl
$LN5@s390_dyn_p:
  00138	33 c0		 xor	 eax, eax
  0013a	85 c0		 test	 eax, eax
  0013c	0f 85 cc fe ff
	ff		 jne	 $LN4@s390_dyn_p
  00142	ba 01 00 00 00	 mov	 edx, 1
  00147	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0014c	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00151	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
  00157	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015b	c3		 ret	 0
s390_dyn_perform_cryptographic_key_management_operation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv290 = 64
tv299 = 68
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s390_dyn_cipher_message_with_chaining PROC

; 4434 : {

$LN32:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4435 :   int msa;
; 4436 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 20	 mov	 BYTE PTR query_bits$[rsp+18], 32 ; 00000020H
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 10	 mov	 BYTE PTR query_bits$[rsp+24], 16
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 38	 mov	 BYTE PTR query_bits$[rsp+34], 56 ; 00000038H
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 10	 mov	 BYTE PTR query_bits$[rsp+40], 16
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00123	c6 84 24 82 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0012b	c6 84 24 83 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+51], 56 ; 00000038H
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+56], 16
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+72], 16
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4437 :   {
; 4438 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4439 :     { 0xf0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4440 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4441 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4442 :     /**/ { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4443 :   };
; 4444 :   int r1;
; 4445 :   int r2;
; 4446 : 
; 4447 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s390_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s390_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s390_dyn_c

; 4448 : 
; 4449 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4450 :     if (0
; 4451 :         || GR_A( 1,  regs ) == 0
; 4452 :         || GR_A( r1, regs ) == 0
; 4453 :         || GR_A( r2, regs ) == 0
; 4454 :     )
; 4455 :         ARCH_DEP( per3_zero )( regs );
; 4456 : #endif
; 4457 : 
; 4458 :   /* The following is the same as doing a FACILITY_CHECK */
; 4459 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4460 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s390_dyn_c

; 4461 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN8@s390_dyn_c:

; 4462 : 
; 4463 : #ifdef OPTION_KMC_DEBUG
; 4464 :   WRMSG(HHC90100, "D", "KMC: cipher message with chaining");
; 4465 :   WRMSG(HHC90101, "D", 1, r1);
; 4466 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4467 :   WRMSG(HHC90101, "D", 2, r2);
; 4468 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4469 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4470 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4471 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4472 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4473 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4474 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 4475 : 
; 4476 :   /* Check special conditions */
; 4477 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  002a8	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  002ad	74 27		 je	 SHORT $LN26@s390_dyn_c
  002af	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 1c		 jne	 SHORT $LN26@s390_dyn_c
  002ba	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002bf	74 15		 je	 SHORT $LN26@s390_dyn_c
  002c1	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002c5	83 e0 01	 and	 eax, 1
  002c8	85 c0		 test	 eax, eax
  002ca	75 0a		 jne	 SHORT $LN26@s390_dyn_c
  002cc	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN29@s390_dyn_c
$LN26@s390_dyn_c:
  002d6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
$LN29@s390_dyn_c:
  002de	83 7c 24 40 00	 cmp	 DWORD PTR tv290[rsp], 0
  002e3	74 13		 je	 SHORT $LN9@s390_dyn_c

; 4478 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  002e5	ba 06 00 00 00	 mov	 edx, 6
  002ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN9@s390_dyn_c:

; 4479 : 
; 4480 :   switch(GR0_fc(regs))

  002f8	b8 08 00 00 00	 mov	 eax, 8
  002fd	48 6b c0 00	 imul	 rax, rax, 0
  00301	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00310	83 e0 7f	 and	 eax, 127		; 0000007fH
  00313	89 44 24 44	 mov	 DWORD PTR tv299[rsp], eax
  00317	83 7c 24 44 43	 cmp	 DWORD PTR tv299[rsp], 67 ; 00000043H
  0031c	0f 87 36 01 00
	00		 ja	 $LN24@s390_dyn_c
  00322	8b 44 24 44	 mov	 eax, DWORD PTR tv299[rsp]
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0032d	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN30@s390_dyn_c[rcx+rax]
  00335	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN31@s390_dyn_c[rcx+rax*4]
  0033c	48 03 c1	 add	 rax, rcx
  0033f	ff e0		 jmp	 rax
$LN10@s390_dyn_c:

; 4481 :   {
; 4482 :     case 0: /* Query */
; 4483 :     {
; 4484 :       /* Store the parameter block */
; 4485 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00341	b8 08 00 00 00	 mov	 eax, 8
  00346	48 6b c0 01	 imul	 rax, rax, 1
  0034a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0035a	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00360	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00367	23 c2		 and	 eax, edx
  00369	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0036e	48 6b c9 10	 imul	 rcx, rcx, 16
  00372	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00377	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0037f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00384	41 b9 01 00 00
	00		 mov	 r9d, 1
  0038a	44 8b c0	 mov	 r8d, eax
  0038d	b2 0f		 mov	 dl, 15
  0038f	e8 00 00 00 00	 call	 s390_vstorec

; 4486 : 
; 4487 : #ifdef OPTION_KMC_DEBUG
; 4488 :       LOGBYTE("output:", query_bits[msa], 16);
; 4489 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 4490 : 
; 4491 :       /* Set condition code 0 */
; 4492 :       regs->psw.cc = 0;

  00394	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0039c	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4493 :       return;

  003a0	e9 c6 00 00 00	 jmp	 $LN1@s390_dyn_c
$LN11@s390_dyn_c:
$LN12@s390_dyn_c:
$LN13@s390_dyn_c:

; 4494 :     }
; 4495 :     case 1: /* dea */
; 4496 :     case 2: /* tdea-128 */
; 4497 :     case 3: /* tdea-192 */
; 4498 :     {
; 4499 :       ARCH_DEP(kmc_dea)(r1, r2, regs);

  003a5	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ad	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003b1	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003b5	e8 00 00 00 00	 call	 s390_kmc_dea

; 4500 :       break;

  003ba	e9 ac 00 00 00	 jmp	 $LN5@s390_dyn_c
$LN14@s390_dyn_c:

; 4501 :     }
; 4502 : 
; 4503 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4504 :     case 9: /* encrypted dea */
; 4505 :     case 10: /* encrypted tdea-128 */
; 4506 :     case 11: /* encrypted tdea-192 */
; 4507 :     {
; 4508 :       if(msa >= 3)
; 4509 :         ARCH_DEP(kmc_dea)(r1, r2, regs);
; 4510 :       else
; 4511 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4512 :       break;
; 4513 :     }
; 4514 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4515 : 
; 4516 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4517 :     case 18: /* aes-128 */
; 4518 :     {
; 4519 :       if(msa >= 1)

  003bf	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003c4	7c 17		 jl	 SHORT $LN15@s390_dyn_c

; 4520 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  003c6	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003ce	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003d2	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003d6	e8 00 00 00 00	 call	 s390_kmc_aes
  003db	eb 13		 jmp	 SHORT $LN16@s390_dyn_c
$LN15@s390_dyn_c:

; 4521 :       else
; 4522 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003dd	ba 06 00 00 00	 mov	 edx, 6
  003e2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN16@s390_dyn_c:

; 4523 :       break;

  003f0	eb 79		 jmp	 SHORT $LN5@s390_dyn_c
$LN17@s390_dyn_c:
$LN18@s390_dyn_c:

; 4524 :     }
; 4525 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4526 : 
; 4527 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4528 :     case 19: /* aes-192 */
; 4529 :     case 20: /* aes-256 */
; 4530 :     {
; 4531 :       if(msa >= 2)

  003f2	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  003f7	7c 17		 jl	 SHORT $LN19@s390_dyn_c

; 4532 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  003f9	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00401	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00405	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00409	e8 00 00 00 00	 call	 s390_kmc_aes
  0040e	eb 13		 jmp	 SHORT $LN20@s390_dyn_c
$LN19@s390_dyn_c:

; 4533 :       else
; 4534 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00410	ba 06 00 00 00	 mov	 edx, 6
  00415	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN20@s390_dyn_c:

; 4535 :       break;

  00423	eb 46		 jmp	 SHORT $LN5@s390_dyn_c
$LN21@s390_dyn_c:

; 4536 :     }
; 4537 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4538 : 
; 4539 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4540 :     case 26: /* encrypted aes-128 */
; 4541 :     case 27: /* encrypted aes-192 */
; 4542 :     case 28: /* encrypted aes-256 */
; 4543 :     {
; 4544 :       if(msa >= 3)
; 4545 :         ARCH_DEP(kmc_aes)(r1, r2, regs);
; 4546 :       else
; 4547 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4548 :       break;
; 4549 :     }
; 4550 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4551 : 
; 4552 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4553 :     case 67: /* prng */
; 4554 :     {
; 4555 :       if(msa >= 1)

  00425	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  0042a	7c 17		 jl	 SHORT $LN22@s390_dyn_c

; 4556 :         ARCH_DEP(kmc_prng)(r1, r2, regs);

  0042c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00434	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00438	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0043c	e8 00 00 00 00	 call	 s390_kmc_prng
  00441	eb 13		 jmp	 SHORT $LN23@s390_dyn_c
$LN22@s390_dyn_c:

; 4557 :       else
; 4558 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00443	ba 06 00 00 00	 mov	 edx, 6
  00448	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00450	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN23@s390_dyn_c:

; 4559 :       break;

  00456	eb 13		 jmp	 SHORT $LN5@s390_dyn_c
$LN24@s390_dyn_c:

; 4560 :     }
; 4561 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4562 : 
; 4563 :     default:
; 4564 :     {
; 4565 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00458	ba 06 00 00 00	 mov	 edx, 6
  0045d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00465	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN5@s390_dyn_c:
$LN1@s390_dyn_c:

; 4566 :       break;
; 4567 :     }
; 4568 :   }
; 4569 : }

  0046b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00473	48 33 cc	 xor	 rcx, rsp
  00476	e8 00 00 00 00	 call	 __security_check_cookie
  0047b	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00482	c3		 ret	 0
  00483	90		 npad	 1
$LN31@s390_dyn_c:
  00484	00 00 00 00	 DD	 $LN10@s390_dyn_c
  00488	00 00 00 00	 DD	 $LN11@s390_dyn_c
  0048c	00 00 00 00	 DD	 $LN12@s390_dyn_c
  00490	00 00 00 00	 DD	 $LN13@s390_dyn_c
  00494	00 00 00 00	 DD	 $LN14@s390_dyn_c
  00498	00 00 00 00	 DD	 $LN17@s390_dyn_c
  0049c	00 00 00 00	 DD	 $LN18@s390_dyn_c
  004a0	00 00 00 00	 DD	 $LN21@s390_dyn_c
  004a4	00 00 00 00	 DD	 $LN24@s390_dyn_c
$LN30@s390_dyn_c:
  004a8	00		 DB	 0
  004a9	01		 DB	 1
  004aa	02		 DB	 2
  004ab	03		 DB	 3
  004ac	08		 DB	 8
  004ad	08		 DB	 8
  004ae	08		 DB	 8
  004af	08		 DB	 8
  004b0	08		 DB	 8
  004b1	08		 DB	 8
  004b2	08		 DB	 8
  004b3	08		 DB	 8
  004b4	08		 DB	 8
  004b5	08		 DB	 8
  004b6	08		 DB	 8
  004b7	08		 DB	 8
  004b8	08		 DB	 8
  004b9	08		 DB	 8
  004ba	04		 DB	 4
  004bb	05		 DB	 5
  004bc	06		 DB	 6
  004bd	08		 DB	 8
  004be	08		 DB	 8
  004bf	08		 DB	 8
  004c0	08		 DB	 8
  004c1	08		 DB	 8
  004c2	08		 DB	 8
  004c3	08		 DB	 8
  004c4	08		 DB	 8
  004c5	08		 DB	 8
  004c6	08		 DB	 8
  004c7	08		 DB	 8
  004c8	08		 DB	 8
  004c9	08		 DB	 8
  004ca	08		 DB	 8
  004cb	08		 DB	 8
  004cc	08		 DB	 8
  004cd	08		 DB	 8
  004ce	08		 DB	 8
  004cf	08		 DB	 8
  004d0	08		 DB	 8
  004d1	08		 DB	 8
  004d2	08		 DB	 8
  004d3	08		 DB	 8
  004d4	08		 DB	 8
  004d5	08		 DB	 8
  004d6	08		 DB	 8
  004d7	08		 DB	 8
  004d8	08		 DB	 8
  004d9	08		 DB	 8
  004da	08		 DB	 8
  004db	08		 DB	 8
  004dc	08		 DB	 8
  004dd	08		 DB	 8
  004de	08		 DB	 8
  004df	08		 DB	 8
  004e0	08		 DB	 8
  004e1	08		 DB	 8
  004e2	08		 DB	 8
  004e3	08		 DB	 8
  004e4	08		 DB	 8
  004e5	08		 DB	 8
  004e6	08		 DB	 8
  004e7	08		 DB	 8
  004e8	08		 DB	 8
  004e9	08		 DB	 8
  004ea	08		 DB	 8
  004eb	07		 DB	 7
s390_dyn_cipher_message_with_chaining ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
tv305 = 48
r2$ = 52
i$1 = 56
tv90 = 60
tv296 = 64
msa$ = 68
r1$ = 72
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s390_dyn_compute_message_authentication_code PROC

; 4334 : {

$LN24:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4335 :   int msa;
; 4336 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4337 :   {
; 4338 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4339 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4340 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4341 :     { 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4342 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4343 :   };
; 4344 :   int r1;
; 4345 :   int r2;
; 4346 : 
; 4347 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 38	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 38	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 38	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 48	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s390_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s390_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s390_dyn_c

; 4348 :   PER_ZEROADDR_CHECK2( regs, 1, r2 );
; 4349 : 
; 4350 :   /* The following is the same as doing a FACILITY_CHECK */
; 4351 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 44	 mov	 DWORD PTR msa$[rsp], eax

; 4352 :   if(msa < 0)

  0028e	83 7c 24 44 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s390_dyn_c

; 4353 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN8@s390_dyn_c:

; 4354 : 
; 4355 : #ifdef OPTION_KMAC_DEBUG
; 4356 :   WRMSG(HHC90100, "D", "KMAC: compute message authentication code");
; 4357 :   WRMSG(HHC90101, "D", 2, r2);
; 4358 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4359 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4360 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4361 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4362 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4363 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4364 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 4365 : 
; 4366 :   /* Check special conditions */
; 4367 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002a8	83 7c 24 34 00	 cmp	 DWORD PTR r2$[rsp], 0
  002ad	74 4f		 je	 SHORT $LN16@s390_dyn_c
  002af	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 44		 jne	 SHORT $LN16@s390_dyn_c
  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d7	85 c0		 test	 eax, eax
  002d9	74 0a		 je	 SHORT $LN17@s390_dyn_c
  002db	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN18@s390_dyn_c
$LN17@s390_dyn_c:
  002e5	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN18@s390_dyn_c:
  002ed	83 7c 24 3c 00	 cmp	 DWORD PTR tv90[rsp], 0
  002f2	75 0a		 jne	 SHORT $LN16@s390_dyn_c
  002f4	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
  002fc	eb 08		 jmp	 SHORT $LN23@s390_dyn_c
$LN16@s390_dyn_c:
  002fe	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv296[rsp], 1
$LN23@s390_dyn_c:
  00306	83 7c 24 40 00	 cmp	 DWORD PTR tv296[rsp], 0
  0030b	74 13		 je	 SHORT $LN9@s390_dyn_c

; 4368 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0030d	ba 06 00 00 00	 mov	 edx, 6
  00312	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN9@s390_dyn_c:

; 4369 : 
; 4370 :   switch(GR0_fc(regs))

  00320	b8 08 00 00 00	 mov	 eax, 8
  00325	48 6b c0 00	 imul	 rax, rax, 0
  00329	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00338	83 e0 7f	 and	 eax, 127		; 0000007fH
  0033b	89 44 24 30	 mov	 DWORD PTR tv305[rsp], eax
  0033f	83 7c 24 30 00	 cmp	 DWORD PTR tv305[rsp], 0
  00344	74 17		 je	 SHORT $LN10@s390_dyn_c
  00346	83 7c 24 30 01	 cmp	 DWORD PTR tv305[rsp], 1
  0034b	74 71		 je	 SHORT $LN11@s390_dyn_c
  0034d	83 7c 24 30 02	 cmp	 DWORD PTR tv305[rsp], 2
  00352	74 6a		 je	 SHORT $LN12@s390_dyn_c
  00354	83 7c 24 30 03	 cmp	 DWORD PTR tv305[rsp], 3
  00359	74 63		 je	 SHORT $LN13@s390_dyn_c
  0035b	eb 78		 jmp	 SHORT $LN14@s390_dyn_c
$LN10@s390_dyn_c:

; 4371 :   {
; 4372 :     case 0: /* Query */
; 4373 :     {
; 4374 :       /* Store the parameter block */
; 4375 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0035d	b8 08 00 00 00	 mov	 eax, 8
  00362	48 6b c0 01	 imul	 rax, rax, 1
  00366	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00376	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0037c	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00383	23 c2		 and	 eax, edx
  00385	48 63 4c 24 44	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0038a	48 6b c9 10	 imul	 rcx, rcx, 16
  0038e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00393	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0039b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003a0	41 b9 01 00 00
	00		 mov	 r9d, 1
  003a6	44 8b c0	 mov	 r8d, eax
  003a9	b2 0f		 mov	 dl, 15
  003ab	e8 00 00 00 00	 call	 s390_vstorec

; 4376 : 
; 4377 : #ifdef OPTION_KMAC_DEBUG
; 4378 :       LOGBYTE("output:", query_bits[msa], 16);
; 4379 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 4380 : 
; 4381 :       /* Set condition code 0 */
; 4382 :       regs->psw.cc = 0;

  003b0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4383 :       return;

  003bc	eb 2a		 jmp	 SHORT $LN1@s390_dyn_c
$LN11@s390_dyn_c:
$LN12@s390_dyn_c:
$LN13@s390_dyn_c:

; 4384 :     }
; 4385 :     case 1: /* dea */
; 4386 :     case 2: /* tdea-128 */
; 4387 :     case 3: /* tdea-192 */
; 4388 :     {
; 4389 :       ARCH_DEP(kmac_dea)(r1, r2, regs);

  003be	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c6	8b 54 24 34	 mov	 edx, DWORD PTR r2$[rsp]
  003ca	8b 4c 24 48	 mov	 ecx, DWORD PTR r1$[rsp]
  003ce	e8 00 00 00 00	 call	 s390_kmac_dea

; 4390 :       break;

  003d3	eb 13		 jmp	 SHORT $LN5@s390_dyn_c
$LN14@s390_dyn_c:

; 4391 :     }
; 4392 : 
; 4393 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4394 :     case 9: /* encrypted dea */
; 4395 :     case 10: /* encrypted tdea-128 */
; 4396 :     case 11: /* encrypted tdea-192 */
; 4397 :     {
; 4398 :       if(msa >= 3)
; 4399 :         ARCH_DEP(kmac_dea)(r1, r2, regs);
; 4400 :       else
; 4401 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4402 :       break;
; 4403 :     }
; 4404 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4405 : 
; 4406 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4407 :     case 18: /* aes */
; 4408 :     case 19: /* aes-192 */
; 4409 :     case 20: /* aes-256 */
; 4410 :     case 26: /* encrypted aes */
; 4411 :     case 27: /* encrypted aes-192 */
; 4412 :     case 28: /* encrypted aes-256 */
; 4413 :     {
; 4414 :       if(msa >= 4)
; 4415 :         ARCH_DEP(kmac_aes)(r1, r2, regs);
; 4416 :       else
; 4417 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4418 :       break;
; 4419 :     }
; 4420 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4421 : 
; 4422 :     default:
; 4423 :     {
; 4424 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003d5	ba 06 00 00 00	 mov	 edx, 6
  003da	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN5@s390_dyn_c:
$LN1@s390_dyn_c:

; 4425 :       break;
; 4426 :     }
; 4427 :   }
; 4428 : }

  003e8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003f0	48 33 cc	 xor	 rcx, rsp
  003f3	e8 00 00 00 00	 call	 __security_check_cookie
  003f8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  003ff	c3		 ret	 0
s390_dyn_compute_message_authentication_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv290 = 64
tv299 = 68
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s390_dyn_cipher_message PROC

; 4190 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4191 :   int msa;
; 4192 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 20	 mov	 BYTE PTR query_bits$[rsp+18], 32 ; 00000020H
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 38	 mov	 BYTE PTR query_bits$[rsp+34], 56 ; 00000038H
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00123	c6 84 24 82 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0012b	c6 84 24 83 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+51], 56 ; 00000038H
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 28	 mov	 BYTE PTR query_bits$[rsp+70], 40 ; 00000028H
  001cb	c6 84 24 97 00
	00 00 28	 mov	 BYTE PTR query_bits$[rsp+71], 40 ; 00000028H
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4193 :   {
; 4194 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4195 :     { 0xf0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4196 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4197 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4198 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4199 :   };
; 4200 :   int r1;
; 4201 :   int r2;
; 4202 : 
; 4203 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s390_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s390_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s390_dyn_c

; 4204 : 
; 4205 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4206 :     if (0
; 4207 :         || GR_A( 1,  regs ) == 0
; 4208 :         || GR_A( r1, regs ) == 0
; 4209 :         || GR_A( r2, regs ) == 0
; 4210 :     )
; 4211 :         ARCH_DEP( per3_zero )( regs );
; 4212 : #endif
; 4213 : 
; 4214 :   /* The following is the same as doing a FACILITY_CHECK */
; 4215 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4216 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s390_dyn_c

; 4217 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN8@s390_dyn_c:

; 4218 : 
; 4219 : #ifdef OPTION_KM_DEBUG
; 4220 :   WRMSG(HHC90100, "D", "KM: cipher message");
; 4221 :   WRMSG(HHC90101, "D", 1, r1);
; 4222 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4223 :   WRMSG(HHC90101, "D", 2, r2);
; 4224 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4225 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4226 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4227 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4228 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4229 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4230 : #endif /* #ifdef OPTION_KM_DEBUG */
; 4231 : 
; 4232 :   /* Check special conditions */
; 4233 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  002a8	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  002ad	74 27		 je	 SHORT $LN23@s390_dyn_c
  002af	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 1c		 jne	 SHORT $LN23@s390_dyn_c
  002ba	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002bf	74 15		 je	 SHORT $LN23@s390_dyn_c
  002c1	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002c5	83 e0 01	 and	 eax, 1
  002c8	85 c0		 test	 eax, eax
  002ca	75 0a		 jne	 SHORT $LN23@s390_dyn_c
  002cc	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN26@s390_dyn_c
$LN23@s390_dyn_c:
  002d6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
$LN26@s390_dyn_c:
  002de	83 7c 24 40 00	 cmp	 DWORD PTR tv290[rsp], 0
  002e3	74 13		 je	 SHORT $LN9@s390_dyn_c

; 4234 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  002e5	ba 06 00 00 00	 mov	 edx, 6
  002ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN9@s390_dyn_c:

; 4235 : 
; 4236 :   switch(GR0_fc(regs))

  002f8	b8 08 00 00 00	 mov	 eax, 8
  002fd	48 6b c0 00	 imul	 rax, rax, 0
  00301	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00310	83 e0 7f	 and	 eax, 127		; 0000007fH
  00313	89 44 24 44	 mov	 DWORD PTR tv299[rsp], eax
  00317	83 7c 24 44 14	 cmp	 DWORD PTR tv299[rsp], 20
  0031c	0f 87 f8 00 00
	00		 ja	 $LN21@s390_dyn_c
  00322	8b 44 24 44	 mov	 eax, DWORD PTR tv299[rsp]
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0032d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN27@s390_dyn_c[rcx+rax*4]
  00334	48 03 c1	 add	 rax, rcx
  00337	ff e0		 jmp	 rax
$LN10@s390_dyn_c:

; 4237 :   {
; 4238 :     case 0: /* Query */
; 4239 :     {
; 4240 :       /* Store the parameter block */
; 4241 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00339	b8 08 00 00 00	 mov	 eax, 8
  0033e	48 6b c0 01	 imul	 rax, rax, 1
  00342	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034a	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00352	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00358	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0035f	23 c2		 and	 eax, edx
  00361	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00366	48 6b c9 10	 imul	 rcx, rcx, 16
  0036a	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0036f	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00377	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0037c	41 b9 01 00 00
	00		 mov	 r9d, 1
  00382	44 8b c0	 mov	 r8d, eax
  00385	b2 0f		 mov	 dl, 15
  00387	e8 00 00 00 00	 call	 s390_vstorec

; 4242 : 
; 4243 : #ifdef OPTION_KM_DEBUG
; 4244 :       LOGBYTE("output:", query_bits[msa], 16);
; 4245 : #endif /* #ifdef OPTION_KM_DEBUG */
; 4246 : 
; 4247 :       /* Set condition code 0 */
; 4248 :       regs->psw.cc = 0;

  0038c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00394	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4249 :       return;

  00398	e9 90 00 00 00	 jmp	 $LN1@s390_dyn_c
$LN11@s390_dyn_c:
$LN12@s390_dyn_c:
$LN13@s390_dyn_c:

; 4250 :     }
; 4251 :     case 1: /* dea */
; 4252 :     case 2: /* tdea-128 */
; 4253 :     case 3: /* tdea-192 */
; 4254 :     {
; 4255 :       ARCH_DEP(km_dea)(r1, r2, regs);

  0039d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003a5	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003a9	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003ad	e8 00 00 00 00	 call	 s390_km_dea

; 4256 :       break;

  003b2	eb 79		 jmp	 SHORT $LN5@s390_dyn_c
$LN14@s390_dyn_c:

; 4257 :     }
; 4258 : 
; 4259 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4260 :     case 9: /* encrypted dea */
; 4261 :     case 10: /* encrypted tdea-128 */
; 4262 :     case 11: /* encrypted tdea-192 */
; 4263 :     {
; 4264 :       if(msa >= 3)
; 4265 :         ARCH_DEP(km_dea)(r1, r2, regs);
; 4266 :       else
; 4267 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4268 :       break;
; 4269 :     }
; 4270 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4271 : 
; 4272 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4273 :     case 18: /* aes-128 */
; 4274 :     {
; 4275 :       if(msa >= 1)

  003b4	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003b9	7c 17		 jl	 SHORT $LN15@s390_dyn_c

; 4276 :         ARCH_DEP(km_aes)(r1, r2, regs);

  003bb	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c3	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003c7	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003cb	e8 00 00 00 00	 call	 s390_km_aes
  003d0	eb 13		 jmp	 SHORT $LN16@s390_dyn_c
$LN15@s390_dyn_c:

; 4277 :       else
; 4278 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003d2	ba 06 00 00 00	 mov	 edx, 6
  003d7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN16@s390_dyn_c:

; 4279 :       break;

  003e5	eb 46		 jmp	 SHORT $LN5@s390_dyn_c
$LN17@s390_dyn_c:
$LN18@s390_dyn_c:

; 4280 :     }
; 4281 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4282 : 
; 4283 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4284 :     case 19: /* aes-192 */
; 4285 :     case 20: /* aes-256 */
; 4286 :     {
; 4287 :       if(msa >= 2)

  003e7	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  003ec	7c 17		 jl	 SHORT $LN19@s390_dyn_c

; 4288 :         ARCH_DEP(km_aes)(r1, r2, regs);

  003ee	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f6	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003fa	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003fe	e8 00 00 00 00	 call	 s390_km_aes
  00403	eb 13		 jmp	 SHORT $LN20@s390_dyn_c
$LN19@s390_dyn_c:

; 4289 :       else
; 4290 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00405	ba 06 00 00 00	 mov	 edx, 6
  0040a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00412	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN20@s390_dyn_c:

; 4291 :       break;

  00418	eb 13		 jmp	 SHORT $LN5@s390_dyn_c
$LN21@s390_dyn_c:

; 4292 :     }
; 4293 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4294 : 
; 4295 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4296 :     case 26: /* encrypted aes-128 */
; 4297 :     case 27: /* encrypted aes-192 */
; 4298 :     case 28: /* encrypted aes-256 */
; 4299 :     {
; 4300 :       if(msa >= 3)
; 4301 :         ARCH_DEP(km_aes)(r1, r2, regs);
; 4302 :       else
; 4303 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4304 :       break;
; 4305 :     }
; 4306 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4307 : 
; 4308 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4309 :     case 50: /* xts aes-128 */
; 4310 :     case 52: /* xts aes-256 */
; 4311 :     case 58: /* encrypted xts aes-128 */
; 4312 :     case 60: /* encrypted xts aes-256 */
; 4313 :     {
; 4314 :       if(msa >= 4)
; 4315 :         ARCH_DEP(km_xts_aes)(r1, r2, regs);
; 4316 :       else
; 4317 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4318 :       break;
; 4319 :     }
; 4320 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4321 : 
; 4322 :     default:
; 4323 :     {
; 4324 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0041a	ba 06 00 00 00	 mov	 edx, 6
  0041f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00427	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN5@s390_dyn_c:
$LN1@s390_dyn_c:

; 4325 :       break;
; 4326 :     }
; 4327 :   }
; 4328 : }

  0042d	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00435	48 33 cc	 xor	 rcx, rsp
  00438	e8 00 00 00 00	 call	 __security_check_cookie
  0043d	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00444	c3		 ret	 0
  00445	0f 1f 00	 npad	 3
$LN27@s390_dyn_c:
  00448	00 00 00 00	 DD	 $LN10@s390_dyn_c
  0044c	00 00 00 00	 DD	 $LN11@s390_dyn_c
  00450	00 00 00 00	 DD	 $LN12@s390_dyn_c
  00454	00 00 00 00	 DD	 $LN13@s390_dyn_c
  00458	00 00 00 00	 DD	 $LN21@s390_dyn_c
  0045c	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00460	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00464	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00468	00 00 00 00	 DD	 $LN21@s390_dyn_c
  0046c	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00470	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00474	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00478	00 00 00 00	 DD	 $LN21@s390_dyn_c
  0047c	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00480	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00484	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00488	00 00 00 00	 DD	 $LN21@s390_dyn_c
  0048c	00 00 00 00	 DD	 $LN21@s390_dyn_c
  00490	00 00 00 00	 DD	 $LN14@s390_dyn_c
  00494	00 00 00 00	 DD	 $LN17@s390_dyn_c
  00498	00 00 00 00	 DD	 $LN18@s390_dyn_c
s390_dyn_cipher_message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
tv305 = 52
msa$ = 56
r1$ = 60
i$1 = 64
tv90 = 68
tv296 = 72
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s390_dyn_compute_last_message_digest PROC

; 4090 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4091 :   int msa;
; 4092 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 c0	 mov	 BYTE PTR query_bits$[rsp], 192 ; 000000c0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 e0	 mov	 BYTE PTR query_bits$[rsp+16], 224 ; 000000e0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  001a3	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+66], 0
  001ab	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4093 :   {
; 4094 :     { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4095 :     { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4096 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4097 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4098 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4099 :   };
; 4100 :   int r1;
; 4101 :   int r2;
; 4102 : 
; 4103 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s390_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s390_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s390_dyn_c

; 4104 : 
; 4105 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4106 :     if (0
; 4107 :         || GR_A( 1,  regs ) == 0
; 4108 :         || GR_A( r1, regs ) == 0
; 4109 :         || GR_A( r2, regs ) == 0
; 4110 :     )
; 4111 :         ARCH_DEP( per3_zero )( regs );
; 4112 : #endif
; 4113 : 
; 4114 :   /* The following is the same as doing a FACILITY_CHECK */
; 4115 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4116 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s390_dyn_c

; 4117 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN8@s390_dyn_c:

; 4118 : 
; 4119 : #ifdef OPTION_KLMD_DEBUG
; 4120 :   WRMSG(HHC90100, "D", "KLMD: compute last message digest");
; 4121 :   WRMSG(HHC90101, "D", 1, r1);
; 4122 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4123 :   WRMSG(HHC90101, "D", 2, r2);
; 4124 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4125 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4126 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4127 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4128 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4129 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4130 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 4131 : 
; 4132 :   /* Check special conditions */
; 4133 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002a8	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002ad	74 4f		 je	 SHORT $LN20@s390_dyn_c
  002af	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 44		 jne	 SHORT $LN20@s390_dyn_c
  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d7	85 c0		 test	 eax, eax
  002d9	74 0a		 je	 SHORT $LN21@s390_dyn_c
  002db	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN22@s390_dyn_c
$LN21@s390_dyn_c:
  002e5	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN22@s390_dyn_c:
  002ed	83 7c 24 44 00	 cmp	 DWORD PTR tv90[rsp], 0
  002f2	75 0a		 jne	 SHORT $LN20@s390_dyn_c
  002f4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
  002fc	eb 08		 jmp	 SHORT $LN27@s390_dyn_c
$LN20@s390_dyn_c:
  002fe	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv296[rsp], 1
$LN27@s390_dyn_c:
  00306	83 7c 24 48 00	 cmp	 DWORD PTR tv296[rsp], 0
  0030b	74 13		 je	 SHORT $LN9@s390_dyn_c

; 4134 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0030d	ba 06 00 00 00	 mov	 edx, 6
  00312	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN9@s390_dyn_c:

; 4135 : 
; 4136 :   switch(GR0_fc(regs))

  00320	b8 08 00 00 00	 mov	 eax, 8
  00325	48 6b c0 00	 imul	 rax, rax, 0
  00329	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00338	83 e0 7f	 and	 eax, 127		; 0000007fH
  0033b	89 44 24 34	 mov	 DWORD PTR tv305[rsp], eax
  0033f	83 7c 24 34 00	 cmp	 DWORD PTR tv305[rsp], 0
  00344	74 22		 je	 SHORT $LN10@s390_dyn_c
  00346	83 7c 24 34 01	 cmp	 DWORD PTR tv305[rsp], 1
  0034b	74 7f		 je	 SHORT $LN11@s390_dyn_c
  0034d	83 7c 24 34 02	 cmp	 DWORD PTR tv305[rsp], 2
  00352	0f 84 8b 00 00
	00		 je	 $LN12@s390_dyn_c
  00358	83 7c 24 34 03	 cmp	 DWORD PTR tv305[rsp], 3
  0035d	0f 84 b3 00 00
	00		 je	 $LN15@s390_dyn_c
  00363	e9 e1 00 00 00	 jmp	 $LN18@s390_dyn_c
$LN10@s390_dyn_c:

; 4137 :   {
; 4138 :     case 0: /* Query */
; 4139 :     {
; 4140 :       /* Store the parameter block */
; 4141 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00368	b8 08 00 00 00	 mov	 eax, 8
  0036d	48 6b c0 01	 imul	 rax, rax, 1
  00371	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00379	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00381	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00387	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0038e	23 c2		 and	 eax, edx
  00390	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00395	48 6b c9 10	 imul	 rcx, rcx, 16
  00399	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0039e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003a6	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003ab	41 b9 01 00 00
	00		 mov	 r9d, 1
  003b1	44 8b c0	 mov	 r8d, eax
  003b4	b2 0f		 mov	 dl, 15
  003b6	e8 00 00 00 00	 call	 s390_vstorec

; 4142 : 
; 4143 : #ifdef OPTION_KLMD_DEBUG
; 4144 :       LOGBYTE("output:", query_bits[msa], 16);
; 4145 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 4146 : 
; 4147 :       /* Set condition code 0 */
; 4148 :       regs->psw.cc = 0;

  003bb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4149 :       return;

  003c7	e9 90 00 00 00	 jmp	 $LN1@s390_dyn_c
$LN11@s390_dyn_c:

; 4150 :     }
; 4151 :     case 1: /* sha-1 */
; 4152 :     {
; 4153 :       ARCH_DEP(klmd_sha)(r1, r2, regs);

  003cc	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d4	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003d8	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003dc	e8 00 00 00 00	 call	 s390_klmd_sha

; 4154 :       break;

  003e1	eb 79		 jmp	 SHORT $LN5@s390_dyn_c
$LN12@s390_dyn_c:

; 4155 :     }
; 4156 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4157 :     case 2: /* sha-256 */
; 4158 :     {
; 4159 :       if(msa >= 1)

  003e3	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003e8	7c 17		 jl	 SHORT $LN13@s390_dyn_c

; 4160 :         ARCH_DEP(klmd_sha)(r1, r2, regs);

  003ea	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f2	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003f6	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003fa	e8 00 00 00 00	 call	 s390_klmd_sha
  003ff	eb 13		 jmp	 SHORT $LN14@s390_dyn_c
$LN13@s390_dyn_c:

; 4161 :       else
; 4162 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00401	ba 06 00 00 00	 mov	 edx, 6
  00406	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN14@s390_dyn_c:

; 4163 :       break;

  00414	eb 46		 jmp	 SHORT $LN5@s390_dyn_c
$LN15@s390_dyn_c:

; 4164 :     }
; 4165 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4166 : 
; 4167 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4168 :     case 3: /* sha-512 */
; 4169 :     {
; 4170 :       if(msa >= 2)

  00416	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  0041b	7c 17		 jl	 SHORT $LN16@s390_dyn_c

; 4171 :         ARCH_DEP(klmd_sha)(r1, r2, regs);

  0041d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00425	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00429	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0042d	e8 00 00 00 00	 call	 s390_klmd_sha
  00432	eb 13		 jmp	 SHORT $LN17@s390_dyn_c
$LN16@s390_dyn_c:

; 4172 :       else
; 4173 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00434	ba 06 00 00 00	 mov	 edx, 6
  00439	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00441	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN17@s390_dyn_c:

; 4174 :       break;

  00447	eb 13		 jmp	 SHORT $LN5@s390_dyn_c
$LN18@s390_dyn_c:

; 4175 :     }
; 4176 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4177 : 
; 4178 :     default:
; 4179 :     {
; 4180 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00449	ba 06 00 00 00	 mov	 edx, 6
  0044e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00456	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN5@s390_dyn_c:
$LN1@s390_dyn_c:

; 4181 :       break;
; 4182 :     }
; 4183 :   }
; 4184 : }

  0045c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00464	48 33 cc	 xor	 rcx, rsp
  00467	e8 00 00 00 00	 call	 __security_check_cookie
  0046c	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00473	c3		 ret	 0
s390_dyn_compute_last_message_digest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
tv305 = 52
msa$ = 56
r1$ = 60
i$1 = 64
tv90 = 68
tv296 = 72
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s390_dyn_compute_intermediate_message_digest PROC

; 3986 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3987 :   int msa;
; 3988 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 c0	 mov	 BYTE PTR query_bits$[rsp], 192 ; 000000c0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 e0	 mov	 BYTE PTR query_bits$[rsp+16], 224 ; 000000e0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  001a3	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+66], 0
  001ab	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 40	 mov	 BYTE PTR query_bits$[rsp+72], 64 ; 00000040H
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 3989 :   {
; 3990 :     { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3991 :     { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3992 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3993 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3994 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 3995 :   };
; 3996 :   int r1;
; 3997 :   int r2;
; 3998 : 
; 3999 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s390_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s390_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s390_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s390_dyn_c

; 4000 :   PER_ZEROADDR_CHECK2( regs, 1, r2 );
; 4001 : 
; 4002 :   /* The following is the same as doing a FACILITY_CHECK */
; 4003 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4004 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s390_dyn_c

; 4005 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN8@s390_dyn_c:

; 4006 : 
; 4007 : #ifdef OPTION_KIMD_DEBUG
; 4008 :   WRMSG(HHC90100, "D", "KIMD: compute intermediate message digest");
; 4009 :   WRMSG(HHC90101, "D", 1, r1);
; 4010 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4011 :   WRMSG(HHC90101, "D", 2, r2);
; 4012 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4013 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4014 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4015 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4016 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4017 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4018 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 4019 : 
; 4020 :   /* Check special conditions */
; 4021 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002a8	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002ad	74 4f		 je	 SHORT $LN20@s390_dyn_c
  002af	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 44		 jne	 SHORT $LN20@s390_dyn_c
  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d7	85 c0		 test	 eax, eax
  002d9	74 0a		 je	 SHORT $LN21@s390_dyn_c
  002db	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN22@s390_dyn_c
$LN21@s390_dyn_c:
  002e5	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN22@s390_dyn_c:
  002ed	83 7c 24 44 00	 cmp	 DWORD PTR tv90[rsp], 0
  002f2	75 0a		 jne	 SHORT $LN20@s390_dyn_c
  002f4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
  002fc	eb 08		 jmp	 SHORT $LN27@s390_dyn_c
$LN20@s390_dyn_c:
  002fe	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv296[rsp], 1
$LN27@s390_dyn_c:
  00306	83 7c 24 48 00	 cmp	 DWORD PTR tv296[rsp], 0
  0030b	74 13		 je	 SHORT $LN9@s390_dyn_c

; 4022 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0030d	ba 06 00 00 00	 mov	 edx, 6
  00312	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN9@s390_dyn_c:

; 4023 : 
; 4024 :   switch(GR0_fc(regs))

  00320	b8 08 00 00 00	 mov	 eax, 8
  00325	48 6b c0 00	 imul	 rax, rax, 0
  00329	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00338	83 e0 7f	 and	 eax, 127		; 0000007fH
  0033b	89 44 24 34	 mov	 DWORD PTR tv305[rsp], eax
  0033f	83 7c 24 34 00	 cmp	 DWORD PTR tv305[rsp], 0
  00344	74 22		 je	 SHORT $LN10@s390_dyn_c
  00346	83 7c 24 34 01	 cmp	 DWORD PTR tv305[rsp], 1
  0034b	74 7f		 je	 SHORT $LN11@s390_dyn_c
  0034d	83 7c 24 34 02	 cmp	 DWORD PTR tv305[rsp], 2
  00352	0f 84 8e 00 00
	00		 je	 $LN12@s390_dyn_c
  00358	83 7c 24 34 03	 cmp	 DWORD PTR tv305[rsp], 3
  0035d	0f 84 b9 00 00
	00		 je	 $LN15@s390_dyn_c
  00363	e9 ea 00 00 00	 jmp	 $LN18@s390_dyn_c
$LN10@s390_dyn_c:

; 4025 :   {
; 4026 :     case 0: /* Query */
; 4027 :     {
; 4028 :       /* Store the parameter block */
; 4029 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00368	b8 08 00 00 00	 mov	 eax, 8
  0036d	48 6b c0 01	 imul	 rax, rax, 1
  00371	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00379	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00381	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00387	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0038e	23 c2		 and	 eax, edx
  00390	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00395	48 6b c9 10	 imul	 rcx, rcx, 16
  00399	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0039e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003a6	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003ab	41 b9 01 00 00
	00		 mov	 r9d, 1
  003b1	44 8b c0	 mov	 r8d, eax
  003b4	b2 0f		 mov	 dl, 15
  003b6	e8 00 00 00 00	 call	 s390_vstorec

; 4030 : 
; 4031 : #ifdef OPTION_KIMD_DEBUG
; 4032 :       LOGBYTE("output:", query_bits[msa], 16);
; 4033 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 4034 : 
; 4035 :       /* Set condition code 0 */
; 4036 :       regs->psw.cc = 0;

  003bb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4037 :       return;

  003c7	e9 99 00 00 00	 jmp	 $LN1@s390_dyn_c
$LN11@s390_dyn_c:

; 4038 :     }
; 4039 :     case 1: /* sha-1 */
; 4040 :     {
; 4041 :       ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  003cc	45 33 c9	 xor	 r9d, r9d
  003cf	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d7	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003db	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003df	e8 00 00 00 00	 call	 s390_kimd_sha

; 4042 :       break;

  003e4	eb 7f		 jmp	 SHORT $LN5@s390_dyn_c
$LN12@s390_dyn_c:

; 4043 :     }
; 4044 : 
; 4045 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4046 :     case 2: /* sha-256 */
; 4047 :     {
; 4048 :       if(msa >= 1)

  003e6	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003eb	7c 1a		 jl	 SHORT $LN13@s390_dyn_c

; 4049 :         ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  003ed	45 33 c9	 xor	 r9d, r9d
  003f0	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f8	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003fc	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00400	e8 00 00 00 00	 call	 s390_kimd_sha
  00405	eb 13		 jmp	 SHORT $LN14@s390_dyn_c
$LN13@s390_dyn_c:

; 4050 :       else
; 4051 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00407	ba 06 00 00 00	 mov	 edx, 6
  0040c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN14@s390_dyn_c:

; 4052 :       break;

  0041a	eb 49		 jmp	 SHORT $LN5@s390_dyn_c
$LN15@s390_dyn_c:

; 4053 :     }
; 4054 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4055 : 
; 4056 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4057 :     case 3: /* sha-512 */
; 4058 :     {
; 4059 :       if(msa >= 2)

  0041c	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  00421	7c 1a		 jl	 SHORT $LN16@s390_dyn_c

; 4060 :         ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  00423	45 33 c9	 xor	 r9d, r9d
  00426	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0042e	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00432	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00436	e8 00 00 00 00	 call	 s390_kimd_sha
  0043b	eb 13		 jmp	 SHORT $LN17@s390_dyn_c
$LN16@s390_dyn_c:

; 4061 :       else
; 4062 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0043d	ba 06 00 00 00	 mov	 edx, 6
  00442	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN17@s390_dyn_c:

; 4063 :       break;

  00450	eb 13		 jmp	 SHORT $LN5@s390_dyn_c
$LN18@s390_dyn_c:

; 4064 :     }
; 4065 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4066 : 
; 4067 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4068 :     case 65: /* ghash */
; 4069 :     {
; 4070 :       if(msa >= 4)
; 4071 :         ARCH_DEP(kimd_ghash)(r1, r2, regs);
; 4072 :       else
; 4073 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);
; 4074 :       break;
; 4075 :     }
; 4076 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4077 : 
; 4078 :     default:
; 4079 :     {
; 4080 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00452	ba 06 00 00 00	 mov	 edx, 6
  00457	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN5@s390_dyn_c:
$LN1@s390_dyn_c:

; 4081 :       break;
; 4082 :     }
; 4083 :   }
; 4084 : }

  00465	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0046d	48 33 cc	 xor	 rcx, rsp
  00470	e8 00 00 00 00	 call	 __security_check_cookie
  00475	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0047c	c3		 ret	 0
s390_dyn_compute_intermediate_message_digest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
crypted$ = 52
tv82 = 56
tv93 = 60
tv136 = 64
tv174 = 68
tv295 = 72
tv328 = 76
tv339 = 80
r1_is_not_r2$ = 84
context1$ = 96
context2$ = 240
context3$ = 384
message_block$ = 528
ocv$ = 536
tcv$ = 544
parameter_block$ = 552
__$ArrayPad$ = 584
r1$ = 608
r2$ = 616
regs$ = 624
s390_kmc_prng PROC

; 2393 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2394 :   des_context context1;
; 2395 :   des_context context2;
; 2396 :   des_context context3;
; 2397 :   int i;
; 2398 :   int crypted;
; 2399 :   BYTE message_block[8];
; 2400 :   BYTE parameter_block[32];
; 2401 :   BYTE ocv[8];
; 2402 :   BYTE tcv[8];
; 2403 :   int r1_is_not_r2;
; 2404 : 
; 2405 :   /* Check special conditions */
; 2406 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 08 00 00 00	 mov	 ecx, 8
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN18@s390_kmc_p
  0004f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN19@s390_kmc_p
$LN18@s390_kmc_p:
  00059	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN19@s390_kmc_p:
  00061	83 7c 24 38 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN11@s390_kmc_p

; 2407 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN11@s390_kmc_p:

; 2408 : 
; 2409 :   /* Return with cc 0 on zero length */
; 2410 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN20@s390_kmc_p
  00098	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN21@s390_kmc_p
$LN20@s390_kmc_p:
  000a2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN21@s390_kmc_p:
  000aa	83 7c 24 3c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN24@s390_kmc_p
  000b1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN25@s390_kmc_p
$LN24@s390_kmc_p:
  000bb	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN25@s390_kmc_p:
  000c3	83 7c 24 40 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN12@s390_kmc_p

; 2411 :   {
; 2412 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2413 :     return;

  000d6	e9 0e 05 00 00	 jmp	 $LN1@s390_kmc_p
$LN12@s390_kmc_p:

; 2414 :   }
; 2415 : 
; 2416 :   /* Test writeability output chaining value */
; 2417 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 01	 imul	 rax, rax, 1
  000e4	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000f4	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  000fa	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00101	23 c2		 and	 eax, edx
  00103	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00110	41 b9 02 00 00
	00		 mov	 r9d, 2
  00116	41 b8 07 00 00
	00		 mov	 r8d, 7
  0011c	ba 01 00 00 00	 mov	 edx, 1
  00121	8b c8		 mov	 ecx, eax
  00123	e8 00 00 00 00	 call	 s390_validate_operand

; 2418 : 
; 2419 :   /* Fetch the parameter block */
; 2420 :   ARCH_DEP(vfetchc)(parameter_block, 31, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00128	b8 08 00 00 00	 mov	 eax, 8
  0012d	48 6b c0 01	 imul	 rax, rax, 1
  00131	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00139	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00141	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00147	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0014e	23 c2		 and	 eax, edx
  00150	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00158	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0015d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00163	44 8b c0	 mov	 r8d, eax
  00166	b2 1f		 mov	 dl, 31
  00168	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00170	e8 00 00 00 00	 call	 s390_vfetchc

; 2421 : 
; 2422 : #ifdef OPTION_KMC_DEBUG
; 2423 :   LOGBYTE("icv   :", parameter_block, 8);
; 2424 :   LOGBYTE("k1    :", &parameter_block[8], 8);
; 2425 :   LOGBYTE("k2    :", &parameter_block[16], 8);
; 2426 :   LOGBYTE("k3    :", &parameter_block[24], 8);
; 2427 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2428 : 
; 2429 :   /* Set the cryptographic keys */
; 2430 :   des_set_key(&context1, &parameter_block[8]);

  00175	b8 01 00 00 00	 mov	 eax, 1
  0017a	48 6b c0 08	 imul	 rax, rax, 8
  0017e	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00186	48 8b d0	 mov	 rdx, rax
  00189	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  0018e	e8 00 00 00 00	 call	 des_set_key

; 2431 :   des_set_key(&context2, &parameter_block[16]);

  00193	b8 01 00 00 00	 mov	 eax, 1
  00198	48 6b c0 10	 imul	 rax, rax, 16
  0019c	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  001a4	48 8b d0	 mov	 rdx, rax
  001a7	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  001af	e8 00 00 00 00	 call	 des_set_key

; 2432 :   des_set_key(&context3, &parameter_block[24]);

  001b4	b8 01 00 00 00	 mov	 eax, 1
  001b9	48 6b c0 18	 imul	 rax, rax, 24
  001bd	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  001c5	48 8b d0	 mov	 rdx, rax
  001c8	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  001d0	e8 00 00 00 00	 call	 des_set_key

; 2433 : 
; 2434 :   /* Try to process the CPU-determined amount of data */
; 2435 :   r1_is_not_r2 = r1 != r2;

  001d5	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  001dc	39 84 24 60 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  001e3	74 0a		 je	 SHORT $LN26@s390_kmc_p
  001e5	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  001ed	eb 08		 jmp	 SHORT $LN27@s390_kmc_p
$LN26@s390_kmc_p:
  001ef	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN27@s390_kmc_p:
  001f7	8b 44 24 44	 mov	 eax, DWORD PTR tv174[rsp]
  001fb	89 44 24 54	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2436 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  001ff	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00207	eb 0b		 jmp	 SHORT $LN4@s390_kmc_p
$LN2@s390_kmc_p:
  00209	8b 44 24 34	 mov	 eax, DWORD PTR crypted$[rsp]
  0020d	83 c0 08	 add	 eax, 8
  00210	89 44 24 34	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s390_kmc_p:
  00214	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  0021c	0f 8d bb 03 00
	00		 jge	 $LN3@s390_kmc_p

; 2437 :   {
; 2438 :     /* Fetch a block of data */
; 2439 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00222	48 63 84 24 68
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0022a	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023a	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00240	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00247	23 c2		 and	 eax, edx
  00249	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00251	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00256	44 8b 8c 24 68
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0025e	44 8b c0	 mov	 r8d, eax
  00261	b2 07		 mov	 dl, 7
  00263	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0026b	e8 00 00 00 00	 call	 s390_vfetchc

; 2440 : 
; 2441 : #ifdef OPTION_KMC_DEBUG
; 2442 :     LOGBYTE("input :", message_block, 8);
; 2443 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2444 : 
; 2445 :     /* Do the job */
; 2446 :     des_encrypt(&context1, message_block, message_block);

  00270	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00278	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00280	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  00285	e8 00 00 00 00	 call	 des_encrypt

; 2447 :     des_decrypt(&context2, message_block, message_block);

  0028a	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00292	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0029a	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002a2	e8 00 00 00 00	 call	 des_decrypt

; 2448 :     des_encrypt(&context3, message_block, message_block);

  002a7	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  002af	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  002b7	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  002bf	e8 00 00 00 00	 call	 des_encrypt

; 2449 : 
; 2450 :     /* Save the temporary cv */
; 2451 :     memcpy(tcv, message_block, 8);

  002c4	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  002cc	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR tcv$[rsp], rax

; 2452 : 
; 2453 :     /* XOR */
; 2454 :     for(i = 0; i < 8; i++)

  002d4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002dc	eb 0a		 jmp	 SHORT $LN7@s390_kmc_p
$LN5@s390_kmc_p:
  002de	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  002e2	ff c0		 inc	 eax
  002e4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_kmc_p:
  002e8	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  002ed	7d 2a		 jge	 SHORT $LN6@s390_kmc_p

; 2455 :       message_block[i] ^= parameter_block[i];

  002ef	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  002f4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  002f9	0f b6 8c 0c 28
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00301	0f b6 84 04 10
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00309	33 c1		 xor	 eax, ecx
  0030b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00310	88 84 0c 10 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00317	eb c5		 jmp	 SHORT $LN5@s390_kmc_p
$LN6@s390_kmc_p:

; 2456 : 
; 2457 :     des_encrypt(&context1, message_block, message_block);

  00319	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00321	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00329	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  0032e	e8 00 00 00 00	 call	 des_encrypt

; 2458 :     des_decrypt(&context2, message_block, message_block);

  00333	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0033b	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00343	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0034b	e8 00 00 00 00	 call	 des_decrypt

; 2459 :     des_encrypt(&context3, message_block, message_block);

  00350	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00358	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00360	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00368	e8 00 00 00 00	 call	 des_encrypt

; 2460 : 
; 2461 :     /* Store the output */
; 2462 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0036d	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00375	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0037d	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00385	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0038b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00392	23 c2		 and	 eax, edx
  00394	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003a1	44 8b 8c 24 60
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  003a9	44 8b c0	 mov	 r8d, eax
  003ac	b2 07		 mov	 dl, 7
  003ae	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  003b6	e8 00 00 00 00	 call	 s390_vstorec

; 2463 : 
; 2464 : #ifdef OPTION_KMC_DEBUG
; 2465 :     LOGBYTE("output:", message_block, 8);
; 2466 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2467 : 
; 2468 :     /* XOR */
; 2469 :     for(i = 0; i < 8; i++)

  003bb	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003c3	eb 0a		 jmp	 SHORT $LN10@s390_kmc_p
$LN8@s390_kmc_p:
  003c5	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003c9	ff c0		 inc	 eax
  003cb	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_kmc_p:
  003cf	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  003d4	7d 2a		 jge	 SHORT $LN9@s390_kmc_p

; 2470 :       message_block[i] ^= tcv[i];

  003d6	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003db	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003e0	0f b6 8c 0c 20
	02 00 00	 movzx	 ecx, BYTE PTR tcv$[rsp+rcx]
  003e8	0f b6 84 04 10
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  003f0	33 c1		 xor	 eax, ecx
  003f2	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003f7	88 84 0c 10 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  003fe	eb c5		 jmp	 SHORT $LN8@s390_kmc_p
$LN9@s390_kmc_p:

; 2471 : 
; 2472 :     des_encrypt(&context1, message_block, message_block);

  00400	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00408	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00410	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  00415	e8 00 00 00 00	 call	 des_encrypt

; 2473 :     des_decrypt(&context2, message_block, message_block);

  0041a	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00422	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0042a	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00432	e8 00 00 00 00	 call	 des_decrypt

; 2474 :     des_encrypt(&context3, message_block, message_block);

  00437	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0043f	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00447	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0044f	e8 00 00 00 00	 call	 des_encrypt

; 2475 : 
; 2476 :     /* Save the ocv */
; 2477 :     memcpy(ocv, message_block, 8);

  00454	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  0045c	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2478 : 
; 2479 :     /* Store the output chaining value */
; 2480 :     ARCH_DEP(vstorec)(ocv, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00464	b8 08 00 00 00	 mov	 eax, 8
  00469	48 6b c0 01	 imul	 rax, rax, 1
  0046d	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00475	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0047d	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00483	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0048a	23 c2		 and	 eax, edx
  0048c	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00494	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00499	41 b9 01 00 00
	00		 mov	 r9d, 1
  0049f	44 8b c0	 mov	 r8d, eax
  004a2	b2 07		 mov	 dl, 7
  004a4	48 8d 8c 24 18
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  004ac	e8 00 00 00 00	 call	 s390_vstorec

; 2481 : 
; 2482 : #ifdef OPTION_KMC_DEBUG
; 2483 :     LOGBYTE("ocv   :", ocv, 8);
; 2484 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2485 : 
; 2486 :     /* Update the registers */
; 2487 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  004b1	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004b9	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004c8	83 c0 08	 add	 eax, 8
  004cb	48 63 8c 24 60
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  004d3	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004db	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2488 :     if(likely(r1_is_not_r2))

  004e2	83 7c 24 54 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  004e7	74 0a		 je	 SHORT $LN28@s390_kmc_p
  004e9	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv295[rsp], 1
  004f1	eb 08		 jmp	 SHORT $LN29@s390_kmc_p
$LN28@s390_kmc_p:
  004f3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv295[rsp], 0
$LN29@s390_kmc_p:
  004fb	83 7c 24 48 00	 cmp	 DWORD PTR tv295[rsp], 0
  00500	74 31		 je	 SHORT $LN13@s390_kmc_p

; 2489 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  00502	48 63 84 24 68
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0050a	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00512	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00519	83 c0 08	 add	 eax, 8
  0051c	48 63 8c 24 68
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00524	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0052c	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN13@s390_kmc_p:

; 2490 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  00533	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0053a	ff c0		 inc	 eax
  0053c	48 98		 cdqe
  0053e	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00546	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0054d	83 e8 08	 sub	 eax, 8
  00550	8b 8c 24 68 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00557	ff c1		 inc	 ecx
  00559	48 63 c9	 movsxd	 rcx, ecx
  0055c	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00564	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2491 : 
; 2492 : #ifdef OPTION_KMC_DEBUG
; 2493 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2494 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2495 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2496 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2497 : 
; 2498 :     /* check for end of data */
; 2499 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0056b	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00572	ff c0		 inc	 eax
  00574	48 98		 cdqe
  00576	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00586	75 0a		 jne	 SHORT $LN30@s390_kmc_p
  00588	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv328[rsp], 1
  00590	eb 08		 jmp	 SHORT $LN31@s390_kmc_p
$LN30@s390_kmc_p:
  00592	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv328[rsp], 0
$LN31@s390_kmc_p:
  0059a	83 7c 24 4c 00	 cmp	 DWORD PTR tv328[rsp], 0
  0059f	74 0a		 je	 SHORT $LN34@s390_kmc_p
  005a1	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv339[rsp], 1
  005a9	eb 08		 jmp	 SHORT $LN35@s390_kmc_p
$LN34@s390_kmc_p:
  005ab	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv339[rsp], 0
$LN35@s390_kmc_p:
  005b3	83 7c 24 50 00	 cmp	 DWORD PTR tv339[rsp], 0
  005b8	74 0e		 je	 SHORT $LN14@s390_kmc_p

; 2500 :     {
; 2501 :       regs->psw.cc = 0;

  005ba	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005c2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2502 :       return;

  005c6	eb 21		 jmp	 SHORT $LN1@s390_kmc_p
$LN14@s390_kmc_p:

; 2503 :     }
; 2504 : 
; 2505 :     /* Set cv for next 8 bytes */
; 2506 :     memcpy(parameter_block, ocv, 8);

  005c8	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR ocv$[rsp]
  005d0	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR parameter_block$[rsp], rax

; 2507 :   }

  005d8	e9 2c fc ff ff	 jmp	 $LN2@s390_kmc_p
$LN3@s390_kmc_p:

; 2508 : 
; 2509 :   /* CPU-determined amount of data processed */
; 2510 :   regs->psw.cc = 3;

  005dd	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005e5	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s390_kmc_p:

; 2511 : }

  005e9	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005f1	48 33 cc	 xor	 rcx, rsp
  005f4	e8 00 00 00 00	 call	 __security_check_cookie
  005f9	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00600	c3		 ret	 0
s390_kmc_prng ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
crypted$ = 56
tv82 = 60
tv93 = 64
tv136 = 68
tv151 = 72
keylen$ = 76
tv194 = 80
tv196 = 84
tv297 = 88
tv330 = 92
tv341 = 96
tfc$ = 100
wrap$ = 104
modifier_bit$ = 108
r1_is_not_r2$ = 112
context$ = 128
message_block$ = 624
ocv$ = 640
parameter_block$ = 656
__$ArrayPad$ = 736
r1$ = 784
r2$ = 792
regs$ = 800
s390_kmc_aes PROC

; 2252 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2253 :   rijndael_ctx context;
; 2254 :   int crypted;
; 2255 :   int i;
; 2256 :   int keylen;
; 2257 :   BYTE message_block[16];
; 2258 :   int modifier_bit;
; 2259 :   BYTE ocv[16];
; 2260 :   BYTE parameter_block[80];
; 2261 :   int parameter_blocklen;
; 2262 :   int r1_is_not_r2;
; 2263 :   int tfc;
; 2264 :   int wrap;
; 2265 : 
; 2266 :   /* Check special conditions */
; 2267 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00028	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002f	ff c0		 inc	 eax
  00031	48 98		 cdqe
  00033	33 d2		 xor	 edx, edx
  00035	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00044	b9 10 00 00 00	 mov	 ecx, 16
  00049	f7 f1		 div	 ecx
  0004b	8b c2		 mov	 eax, edx
  0004d	85 c0		 test	 eax, eax
  0004f	74 0a		 je	 SHORT $LN21@s390_kmc_a
  00051	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00059	eb 08		 jmp	 SHORT $LN22@s390_kmc_a
$LN21@s390_kmc_a:
  0005b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN22@s390_kmc_a:
  00063	83 7c 24 3c 00	 cmp	 DWORD PTR tv82[rsp], 0
  00068	74 13		 je	 SHORT $LN11@s390_kmc_a

; 2268 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006a	ba 06 00 00 00	 mov	 edx, 6
  0006f	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN11@s390_kmc_a:

; 2269 : 
; 2270 :   /* Return with cc 0 on zero length */
; 2271 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007d	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00084	ff c0		 inc	 eax
  00086	48 98		 cdqe
  00088	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00098	75 0a		 jne	 SHORT $LN23@s390_kmc_a
  0009a	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a2	eb 08		 jmp	 SHORT $LN24@s390_kmc_a
$LN23@s390_kmc_a:
  000a4	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN24@s390_kmc_a:
  000ac	83 7c 24 40 00	 cmp	 DWORD PTR tv93[rsp], 0
  000b1	74 0a		 je	 SHORT $LN27@s390_kmc_a
  000b3	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000bb	eb 08		 jmp	 SHORT $LN28@s390_kmc_a
$LN27@s390_kmc_a:
  000bd	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN28@s390_kmc_a:
  000c5	83 7c 24 44 00	 cmp	 DWORD PTR tv136[rsp], 0
  000ca	74 11		 je	 SHORT $LN12@s390_kmc_a

; 2272 :   {
; 2273 :     regs->psw.cc = 0;

  000cc	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2274 :     return;

  000d8	e9 14 05 00 00	 jmp	 $LN1@s390_kmc_a
$LN12@s390_kmc_a:

; 2275 :   }
; 2276 : 
; 2277 :   /* Initialize values */
; 2278 :   tfc = GR0_tfc(regs);

  000dd	b8 08 00 00 00	 mov	 eax, 8
  000e2	48 6b c0 00	 imul	 rax, rax, 0
  000e6	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f5	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f8	83 e0 77	 and	 eax, 119		; 00000077H
  000fb	89 44 24 64	 mov	 DWORD PTR tfc$[rsp], eax

; 2279 :   wrap = GR0_wrap(regs);

  000ff	b8 08 00 00 00	 mov	 eax, 8
  00104	48 6b c0 00	 imul	 rax, rax, 0
  00108	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00117	83 e0 08	 and	 eax, 8
  0011a	85 c0		 test	 eax, eax
  0011c	74 0a		 je	 SHORT $LN29@s390_kmc_a
  0011e	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00126	eb 08		 jmp	 SHORT $LN30@s390_kmc_a
$LN29@s390_kmc_a:
  00128	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN30@s390_kmc_a:
  00130	8b 44 24 48	 mov	 eax, DWORD PTR tv151[rsp]
  00134	89 44 24 68	 mov	 DWORD PTR wrap$[rsp], eax

; 2280 :   keylen = (tfc - 17) * 8 + 8;

  00138	8b 44 24 64	 mov	 eax, DWORD PTR tfc$[rsp]
  0013c	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00143	89 44 24 4c	 mov	 DWORD PTR keylen$[rsp], eax

; 2281 :   parameter_blocklen = keylen + 16;

  00147	8b 44 24 4c	 mov	 eax, DWORD PTR keylen$[rsp]
  0014b	83 c0 10	 add	 eax, 16
  0014e	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2282 :   if(wrap)

  00152	83 7c 24 68 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00157	74 0b		 je	 SHORT $LN13@s390_kmc_a

; 2283 :     parameter_blocklen += 32;

  00159	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0015d	83 c0 20	 add	 eax, 32			; 00000020H
  00160	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN13@s390_kmc_a:

; 2284 : 
; 2285 :   /* Test writeability output chaining value */
; 2286 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  00164	b8 08 00 00 00	 mov	 eax, 8
  00169	48 6b c0 01	 imul	 rax, rax, 1
  0016d	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0017d	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00183	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0018a	23 c2		 and	 eax, edx
  0018c	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00199	41 b9 02 00 00
	00		 mov	 r9d, 2
  0019f	41 b8 0f 00 00
	00		 mov	 r8d, 15
  001a5	ba 01 00 00 00	 mov	 edx, 1
  001aa	8b c8		 mov	 ecx, eax
  001ac	e8 00 00 00 00	 call	 s390_validate_operand

; 2287 : 
; 2288 :   /* Fetch the parameter block */
; 2289 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001b1	b8 08 00 00 00	 mov	 eax, 8
  001b6	48 6b c0 01	 imul	 rax, rax, 1
  001ba	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c2	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001ca	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  001d0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001d7	23 c2		 and	 eax, edx
  001d9	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001dd	ff c9		 dec	 ecx
  001df	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e7	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ec	41 b9 01 00 00
	00		 mov	 r9d, 1
  001f2	44 8b c0	 mov	 r8d, eax
  001f5	0f b6 d1	 movzx	 edx, cl
  001f8	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00200	e8 00 00 00 00	 call	 s390_vfetchc

; 2290 : 
; 2291 : #ifdef OPTION_KMC_DEBUG
; 2292 :   LOGBYTE("icv   :", parameter_block, 16);
; 2293 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 2294 :   if(wrap)
; 2295 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 16], 32);
; 2296 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2297 : 
; 2298 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 2299 :   /* Verify and unwrap */
; 2300 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))
; 2301 :   {
; 2302 : 
; 2303 : #ifdef OPTION_KM_DEBUG
; 2304 :     WRMSG(HHC90111, "D");
; 2305 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2306 : 
; 2307 :     regs->psw.cc = 1;
; 2308 :     return;
; 2309 :   }
; 2310 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 2311 : 
; 2312 :   /* Set the cryptographic key */
; 2313 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  00205	8b 44 24 4c	 mov	 eax, DWORD PTR keylen$[rsp]
  00209	c1 e0 03	 shl	 eax, 3
  0020c	b9 01 00 00 00	 mov	 ecx, 1
  00211	48 6b c9 10	 imul	 rcx, rcx, 16
  00215	48 8d 8c 0c 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0021d	44 8b c0	 mov	 r8d, eax
  00220	48 8b d1	 mov	 rdx, rcx
  00223	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0022b	e8 00 00 00 00	 call	 rijndael_set_key

; 2314 : 
; 2315 :   /* Try to process the CPU-determined amount of data */
; 2316 :   modifier_bit = GR0_m(regs);

  00230	b8 08 00 00 00	 mov	 eax, 8
  00235	48 6b c0 00	 imul	 rax, rax, 0
  00239	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00241	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00248	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0024d	85 c0		 test	 eax, eax
  0024f	74 0a		 je	 SHORT $LN31@s390_kmc_a
  00251	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv194[rsp], 1
  00259	eb 08		 jmp	 SHORT $LN32@s390_kmc_a
$LN31@s390_kmc_a:
  0025b	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv194[rsp], 0
$LN32@s390_kmc_a:
  00263	8b 44 24 50	 mov	 eax, DWORD PTR tv194[rsp]
  00267	89 44 24 6c	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2317 :   r1_is_not_r2 = r1 != r2;

  0026b	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00272	39 84 24 10 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00279	74 0a		 je	 SHORT $LN33@s390_kmc_a
  0027b	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv196[rsp], 1
  00283	eb 08		 jmp	 SHORT $LN34@s390_kmc_a
$LN33@s390_kmc_a:
  00285	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv196[rsp], 0
$LN34@s390_kmc_a:
  0028d	8b 44 24 54	 mov	 eax, DWORD PTR tv196[rsp]
  00291	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2318 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00295	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0029d	eb 0b		 jmp	 SHORT $LN4@s390_kmc_a
$LN2@s390_kmc_a:
  0029f	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  002a3	83 c0 10	 add	 eax, 16
  002a6	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s390_kmc_a:
  002aa	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  002b2	0f 8d 2d 03 00
	00		 jge	 $LN3@s390_kmc_a

; 2319 :   {
; 2320 :     /* Fetch a block of data */
; 2321 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  002b8	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002c0	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002d0	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  002d6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002dd	23 c2		 and	 eax, edx
  002df	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002ec	44 8b 8c 24 18
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002f4	44 8b c0	 mov	 r8d, eax
  002f7	b2 0f		 mov	 dl, 15
  002f9	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00301	e8 00 00 00 00	 call	 s390_vfetchc

; 2322 : 
; 2323 : #ifdef OPTION_KMC_DEBUG
; 2324 :     LOGBYTE("input :", message_block, 16);
; 2325 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2326 : 
; 2327 :     /* Do the job */
; 2328 :     if(modifier_bit)

  00306	83 7c 24 6c 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0030b	0f 84 81 00 00
	00		 je	 $LN14@s390_kmc_a

; 2329 :     {
; 2330 : 
; 2331 :       /* Save, decrypt and XOR */
; 2332 :       memcpy(ocv, message_block, 16);

  00311	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR ocv$[rsp]
  00319	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00321	48 8b f8	 mov	 rdi, rax
  00324	48 8b f1	 mov	 rsi, rcx
  00327	b9 10 00 00 00	 mov	 ecx, 16
  0032c	f3 a4		 rep movsb

; 2333 :       rijndael_decrypt(&context, message_block, message_block);

  0032e	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00336	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0033e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00346	e8 00 00 00 00	 call	 rijndael_decrypt

; 2334 :       for(i = 0; i < 16; i++)

  0034b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00353	eb 0a		 jmp	 SHORT $LN7@s390_kmc_a
$LN5@s390_kmc_a:
  00355	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00359	ff c0		 inc	 eax
  0035b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s390_kmc_a:
  0035f	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00364	7d 2a		 jge	 SHORT $LN6@s390_kmc_a

; 2335 :         message_block[i] ^= parameter_block[i];

  00366	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0036b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00370	0f b6 8c 0c 90
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00378	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00380	33 c1		 xor	 eax, ecx
  00382	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00387	88 84 0c 70 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0038e	eb c5		 jmp	 SHORT $LN5@s390_kmc_a
$LN6@s390_kmc_a:

; 2336 :     }

  00390	eb 7f		 jmp	 SHORT $LN15@s390_kmc_a
$LN14@s390_kmc_a:

; 2337 :     else
; 2338 :     {
; 2339 :       /* XOR, encrypt and save */
; 2340 :       for(i = 0; i < 16; i++)

  00392	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0039a	eb 0a		 jmp	 SHORT $LN10@s390_kmc_a
$LN8@s390_kmc_a:
  0039c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003a0	ff c0		 inc	 eax
  003a2	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s390_kmc_a:
  003a6	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  003ab	7d 2a		 jge	 SHORT $LN9@s390_kmc_a

; 2341 :         message_block[i] ^= parameter_block[i];

  003ad	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003b2	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003b7	0f b6 8c 0c 90
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003bf	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  003c7	33 c1		 xor	 eax, ecx
  003c9	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003ce	88 84 0c 70 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  003d5	eb c5		 jmp	 SHORT $LN8@s390_kmc_a
$LN9@s390_kmc_a:

; 2342 :       rijndael_encrypt(&context, message_block, message_block);

  003d7	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003df	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003e7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  003ef	e8 00 00 00 00	 call	 rijndael_encrypt

; 2343 :       memcpy(ocv, message_block, 16);

  003f4	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR ocv$[rsp]
  003fc	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00404	48 8b f8	 mov	 rdi, rax
  00407	48 8b f1	 mov	 rsi, rcx
  0040a	b9 10 00 00 00	 mov	 ecx, 16
  0040f	f3 a4		 rep movsb
$LN15@s390_kmc_a:

; 2344 :     }
; 2345 : 
; 2346 :     /* Store the output */
; 2347 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00411	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00419	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00421	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00429	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0042f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00436	23 c2		 and	 eax, edx
  00438	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00440	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00445	44 8b 8c 24 10
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0044d	44 8b c0	 mov	 r8d, eax
  00450	b2 0f		 mov	 dl, 15
  00452	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0045a	e8 00 00 00 00	 call	 s390_vstorec

; 2348 : 
; 2349 : #ifdef OPTION_KMC_DEBUG
; 2350 :     LOGBYTE("output:", message_block, 16);
; 2351 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2352 : 
; 2353 :     /* Store the output chaining value */
; 2354 :     ARCH_DEP(vstorec)(ocv, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0045f	b8 08 00 00 00	 mov	 eax, 8
  00464	48 6b c0 01	 imul	 rax, rax, 1
  00468	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00470	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00478	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0047e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00485	23 c2		 and	 eax, edx
  00487	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00494	41 b9 01 00 00
	00		 mov	 r9d, 1
  0049a	44 8b c0	 mov	 r8d, eax
  0049d	b2 0f		 mov	 dl, 15
  0049f	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  004a7	e8 00 00 00 00	 call	 s390_vstorec

; 2355 : 
; 2356 : #ifdef OPTION_KMC_DEBUG
; 2357 :     LOGBYTE("ocv   :", ocv, 16);
; 2358 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2359 : 
; 2360 :     /* Update the registers */
; 2361 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  004ac	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004b4	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004c3	83 c0 10	 add	 eax, 16
  004c6	48 63 8c 24 10
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  004ce	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004d6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2362 :     if(likely(r1_is_not_r2))

  004dd	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  004e2	74 0a		 je	 SHORT $LN35@s390_kmc_a
  004e4	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv297[rsp], 1
  004ec	eb 08		 jmp	 SHORT $LN36@s390_kmc_a
$LN35@s390_kmc_a:
  004ee	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv297[rsp], 0
$LN36@s390_kmc_a:
  004f6	83 7c 24 58 00	 cmp	 DWORD PTR tv297[rsp], 0
  004fb	74 31		 je	 SHORT $LN16@s390_kmc_a

; 2363 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  004fd	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00505	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00514	83 c0 10	 add	 eax, 16
  00517	48 63 8c 24 18
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0051f	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00527	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN16@s390_kmc_a:

; 2364 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  0052e	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00535	ff c0		 inc	 eax
  00537	48 98		 cdqe
  00539	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00541	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00548	83 e8 10	 sub	 eax, 16
  0054b	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00552	ff c1		 inc	 ecx
  00554	48 63 c9	 movsxd	 rcx, ecx
  00557	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0055f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2365 : 
; 2366 : #ifdef OPTION_KMC_DEBUG
; 2367 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2368 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2369 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2370 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2371 : 
; 2372 :     /* check for end of data */
; 2373 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00566	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0056d	ff c0		 inc	 eax
  0056f	48 98		 cdqe
  00571	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00579	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00581	75 0a		 jne	 SHORT $LN37@s390_kmc_a
  00583	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv330[rsp], 1
  0058b	eb 08		 jmp	 SHORT $LN38@s390_kmc_a
$LN37@s390_kmc_a:
  0058d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv330[rsp], 0
$LN38@s390_kmc_a:
  00595	83 7c 24 5c 00	 cmp	 DWORD PTR tv330[rsp], 0
  0059a	74 0a		 je	 SHORT $LN41@s390_kmc_a
  0059c	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv341[rsp], 1
  005a4	eb 08		 jmp	 SHORT $LN42@s390_kmc_a
$LN41@s390_kmc_a:
  005a6	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv341[rsp], 0
$LN42@s390_kmc_a:
  005ae	83 7c 24 60 00	 cmp	 DWORD PTR tv341[rsp], 0
  005b3	74 0e		 je	 SHORT $LN17@s390_kmc_a

; 2374 :     {
; 2375 :       regs->psw.cc = 0;

  005b5	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bd	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2376 :       return;

  005c1	eb 2e		 jmp	 SHORT $LN1@s390_kmc_a
$LN17@s390_kmc_a:

; 2377 :     }
; 2378 : 
; 2379 :     /* Set cv for next 16 bytes */
; 2380 :     memcpy(parameter_block, ocv, 16);

  005c3	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp]
  005cb	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  005d3	48 8b f8	 mov	 rdi, rax
  005d6	48 8b f1	 mov	 rsi, rcx
  005d9	b9 10 00 00 00	 mov	 ecx, 16
  005de	f3 a4		 rep movsb

; 2381 :   }

  005e0	e9 ba fc ff ff	 jmp	 $LN2@s390_kmc_a
$LN3@s390_kmc_a:

; 2382 : 
; 2383 :   /* CPU-determined amount of data processed */
; 2384 :   regs->psw.cc = 3;

  005e5	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ed	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s390_kmc_a:

; 2385 : }

  005f1	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005f9	48 33 cc	 xor	 rcx, rsp
  005fc	e8 00 00 00 00	 call	 __security_check_cookie
  00601	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  00608	5f		 pop	 rdi
  00609	5e		 pop	 rsi
  0060a	c3		 ret	 0
s390_kmc_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv180 = 56
crypted$ = 60
tfc$ = 64
tv231 = 68
modifier_bit$ = 72
tv82 = 76
tv93 = 80
tv136 = 84
tv151 = 88
tv214 = 92
tv216 = 96
tv447 = 100
tv480 = 104
tv491 = 108
keylen$ = 112
wrap$ = 116
r1_is_not_r2$ = 120
context1$ = 128
context2$ = 272
context3$ = 416
message_block$ = 560
ocv$ = 568
parameter_block$ = 576
__$ArrayPad$ = 632
r1$ = 656
r2$ = 664
regs$ = 672
s390_kmc_dea PROC

; 2016 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2017 :   des_context context1;
; 2018 :   des_context context2;
; 2019 :   des_context context3;
; 2020 :   int crypted;
; 2021 :   int i;
; 2022 :   int keylen;
; 2023 :   BYTE message_block[8];
; 2024 :   int modifier_bit;
; 2025 :   BYTE ocv[8];
; 2026 :   BYTE parameter_block[56];
; 2027 :   int parameter_blocklen;
; 2028 :   int r1_is_not_r2;
; 2029 :   int tfc;
; 2030 :   int wrap;
; 2031 : 
; 2032 :   /* Check special conditions */
; 2033 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 08 00 00 00	 mov	 ecx, 8
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN47@s390_kmc_d
  0004f	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN48@s390_kmc_d
$LN47@s390_kmc_d:
  00059	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN48@s390_kmc_d:
  00061	83 7c 24 4c 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN27@s390_kmc_d

; 2034 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN27@s390_kmc_d:

; 2035 : 
; 2036 :   /* Return with cc 0 on zero length */
; 2037 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN49@s390_kmc_d
  00098	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN50@s390_kmc_d
$LN49@s390_kmc_d:
  000a2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN50@s390_kmc_d:
  000aa	83 7c 24 50 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN53@s390_kmc_d
  000b1	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN54@s390_kmc_d
$LN53@s390_kmc_d:
  000bb	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN54@s390_kmc_d:
  000c3	83 7c 24 54 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN28@s390_kmc_d

; 2038 :   {
; 2039 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2040 :     return;

  000d6	e9 ad 08 00 00	 jmp	 $LN1@s390_kmc_d
$LN28@s390_kmc_d:

; 2041 :   }
; 2042 : 
; 2043 :   /* Initialize values */
; 2044 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 2045 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN55@s390_kmc_d
  0011c	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN56@s390_kmc_d
$LN55@s390_kmc_d:
  00126	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN56@s390_kmc_d:
  0012e	8b 44 24 58	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 74	 mov	 DWORD PTR wrap$[rsp], eax

; 2046 :   keylen = tfc * 8;

  00136	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	c1 e0 03	 shl	 eax, 3
  0013d	89 44 24 70	 mov	 DWORD PTR keylen$[rsp], eax

; 2047 :   parameter_blocklen = keylen + 8;

  00141	8b 44 24 70	 mov	 eax, DWORD PTR keylen$[rsp]
  00145	83 c0 08	 add	 eax, 8
  00148	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2048 :   if(wrap)

  0014c	83 7c 24 74 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00151	74 0b		 je	 SHORT $LN29@s390_kmc_d

; 2049 :     parameter_blocklen += 24;

  00153	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00157	83 c0 18	 add	 eax, 24
  0015a	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN29@s390_kmc_d:

; 2050 : 
; 2051 :   /* Test writeability output chaining value */
; 2052 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  0015e	b8 08 00 00 00	 mov	 eax, 8
  00163	48 6b c0 01	 imul	 rax, rax, 1
  00167	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00177	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0017d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00184	23 c2		 and	 eax, edx
  00186	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00193	41 b9 02 00 00
	00		 mov	 r9d, 2
  00199	41 b8 07 00 00
	00		 mov	 r8d, 7
  0019f	ba 01 00 00 00	 mov	 edx, 1
  001a4	8b c8		 mov	 ecx, eax
  001a6	e8 00 00 00 00	 call	 s390_validate_operand

; 2053 : 
; 2054 :   /* Fetch the parameter block */
; 2055 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001ab	b8 08 00 00 00	 mov	 eax, 8
  001b0	48 6b c0 01	 imul	 rax, rax, 1
  001b4	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bc	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c4	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  001ca	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001d1	23 c2		 and	 eax, edx
  001d3	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001d7	ff c9		 dec	 ecx
  001d9	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001e6	41 b9 01 00 00
	00		 mov	 r9d, 1
  001ec	44 8b c0	 mov	 r8d, eax
  001ef	0f b6 d1	 movzx	 edx, cl
  001f2	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001fa	e8 00 00 00 00	 call	 s390_vfetchc

; 2056 : 
; 2057 : #ifdef OPTION_KMC_DEBUG
; 2058 :   LOGBYTE("icv   :", parameter_block, 8);
; 2059 :   switch(tfc)
; 2060 :   {
; 2061 :     case 1: /* dea */
; 2062 :     {
; 2063 :       LOGBYTE("k     :", &parameter_block[8], 8);
; 2064 :       break;
; 2065 :     }
; 2066 :     case 2: /* tdea-128 */
; 2067 :     {
; 2068 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2069 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2070 :       break;
; 2071 :     }
; 2072 :     case 3: /* tdea-192 */
; 2073 :     {
; 2074 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2075 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2076 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 2077 :       break;
; 2078 :     }
; 2079 :   }
; 2080 :   if(wrap)
; 2081 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 2082 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2083 : 
; 2084 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 2085 :   /* Verify and unwrap */
; 2086 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))
; 2087 :   {
; 2088 : 
; 2089 : #ifdef OPTION_KMC_DEBUG
; 2090 :     WRMSG(HHC90111, "D");
; 2091 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2092 : 
; 2093 :     regs->psw.cc = 1;
; 2094 :     return;
; 2095 :   }
; 2096 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 2097 : 
; 2098 :   /* Set the cryptographic key */
; 2099 :   switch(tfc)

  001ff	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00203	89 44 24 38	 mov	 DWORD PTR tv180[rsp], eax
  00207	83 7c 24 38 01	 cmp	 DWORD PTR tv180[rsp], 1
  0020c	74 13		 je	 SHORT $LN30@s390_kmc_d
  0020e	83 7c 24 38 02	 cmp	 DWORD PTR tv180[rsp], 2
  00213	74 32		 je	 SHORT $LN31@s390_kmc_d
  00215	83 7c 24 38 03	 cmp	 DWORD PTR tv180[rsp], 3
  0021a	74 6f		 je	 SHORT $LN32@s390_kmc_d
  0021c	e9 cd 00 00 00	 jmp	 $LN2@s390_kmc_d
$LN30@s390_kmc_d:

; 2100 :   {
; 2101 :     case 1: /* dea */
; 2102 :     {
; 2103 :       des_set_key(&context1, &parameter_block[8]);

  00221	b8 01 00 00 00	 mov	 eax, 1
  00226	48 6b c0 08	 imul	 rax, rax, 8
  0022a	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00232	48 8b d0	 mov	 rdx, rax
  00235	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0023d	e8 00 00 00 00	 call	 des_set_key

; 2104 :       break;

  00242	e9 a7 00 00 00	 jmp	 $LN2@s390_kmc_d
$LN31@s390_kmc_d:

; 2105 :     }
; 2106 :     case 2: /* tdea-128 */
; 2107 :     {
; 2108 :       des_set_key(&context1, &parameter_block[8]);

  00247	b8 01 00 00 00	 mov	 eax, 1
  0024c	48 6b c0 08	 imul	 rax, rax, 8
  00250	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00258	48 8b d0	 mov	 rdx, rax
  0025b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00263	e8 00 00 00 00	 call	 des_set_key

; 2109 :       des_set_key(&context2, &parameter_block[16]);

  00268	b8 01 00 00 00	 mov	 eax, 1
  0026d	48 6b c0 10	 imul	 rax, rax, 16
  00271	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00279	48 8b d0	 mov	 rdx, rax
  0027c	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00284	e8 00 00 00 00	 call	 des_set_key

; 2110 :       break;

  00289	eb 63		 jmp	 SHORT $LN2@s390_kmc_d
$LN32@s390_kmc_d:

; 2111 :     }
; 2112 :     case 3: /* tdea-192 */
; 2113 :     {
; 2114 :       des_set_key(&context1, &parameter_block[8]);

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	48 6b c0 08	 imul	 rax, rax, 8
  00294	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0029c	48 8b d0	 mov	 rdx, rax
  0029f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002a7	e8 00 00 00 00	 call	 des_set_key

; 2115 :       des_set_key(&context2, &parameter_block[16]);

  002ac	b8 01 00 00 00	 mov	 eax, 1
  002b1	48 6b c0 10	 imul	 rax, rax, 16
  002b5	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002bd	48 8b d0	 mov	 rdx, rax
  002c0	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002c8	e8 00 00 00 00	 call	 des_set_key

; 2116 :       des_set_key(&context3, &parameter_block[24]);

  002cd	b8 01 00 00 00	 mov	 eax, 1
  002d2	48 6b c0 18	 imul	 rax, rax, 24
  002d6	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002de	48 8b d0	 mov	 rdx, rax
  002e1	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  002e9	e8 00 00 00 00	 call	 des_set_key
$LN2@s390_kmc_d:

; 2117 :       break;
; 2118 :     }
; 2119 :   }
; 2120 : 
; 2121 :   /* Try to process the CPU-determined amount of data */
; 2122 :   modifier_bit = GR0_m(regs);

  002ee	b8 08 00 00 00	 mov	 eax, 8
  002f3	48 6b c0 00	 imul	 rax, rax, 0
  002f7	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ff	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00306	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0030b	85 c0		 test	 eax, eax
  0030d	74 0a		 je	 SHORT $LN57@s390_kmc_d
  0030f	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  00317	eb 08		 jmp	 SHORT $LN58@s390_kmc_d
$LN57@s390_kmc_d:
  00319	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN58@s390_kmc_d:
  00321	8b 44 24 5c	 mov	 eax, DWORD PTR tv214[rsp]
  00325	89 44 24 48	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2123 :   r1_is_not_r2 = r1 != r2;

  00329	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00330	39 84 24 90 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00337	74 0a		 je	 SHORT $LN59@s390_kmc_d
  00339	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv216[rsp], 1
  00341	eb 08		 jmp	 SHORT $LN60@s390_kmc_d
$LN59@s390_kmc_d:
  00343	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv216[rsp], 0
$LN60@s390_kmc_d:
  0034b	8b 44 24 60	 mov	 eax, DWORD PTR tv216[rsp]
  0034f	89 44 24 78	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2124 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  00353	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0035b	eb 0b		 jmp	 SHORT $LN6@s390_kmc_d
$LN4@s390_kmc_d:
  0035d	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00361	83 c0 08	 add	 eax, 8
  00364	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@s390_kmc_d:
  00368	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00370	0f 8d 06 06 00
	00		 jge	 $LN5@s390_kmc_d

; 2125 :   {
; 2126 :     /* Fetch a block of data */
; 2127 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00376	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0037e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00386	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0038e	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00394	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0039b	23 c2		 and	 eax, edx
  0039d	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003aa	44 8b 8c 24 98
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  003b2	44 8b c0	 mov	 r8d, eax
  003b5	b2 07		 mov	 dl, 7
  003b7	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  003bf	e8 00 00 00 00	 call	 s390_vfetchc

; 2128 : 
; 2129 : #ifdef OPTION_KMC_DEBUG
; 2130 :     LOGBYTE("input :", message_block, 8);
; 2131 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2132 : 
; 2133 :     /* Do the job */
; 2134 :     switch(tfc)

  003c4	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  003c8	89 44 24 44	 mov	 DWORD PTR tv231[rsp], eax
  003cc	83 7c 24 44 01	 cmp	 DWORD PTR tv231[rsp], 1
  003d1	74 1b		 je	 SHORT $LN33@s390_kmc_d
  003d3	83 7c 24 44 02	 cmp	 DWORD PTR tv231[rsp], 2
  003d8	0f 84 02 01 00
	00		 je	 $LN36@s390_kmc_d
  003de	83 7c 24 44 03	 cmp	 DWORD PTR tv231[rsp], 3
  003e3	0f 84 64 02 00
	00		 je	 $LN39@s390_kmc_d
  003e9	e9 c7 03 00 00	 jmp	 $LN7@s390_kmc_d
$LN33@s390_kmc_d:

; 2135 :     {
; 2136 :       case 1: /* dea */
; 2137 :       {
; 2138 :         if(modifier_bit)

  003ee	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  003f3	74 74		 je	 SHORT $LN34@s390_kmc_d

; 2139 :         {
; 2140 :           /* Save, decrypt and XOR */
; 2141 :           memcpy(ocv, message_block, 8);

  003f5	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  003fd	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2142 :           des_decrypt(&context1, message_block, message_block);

  00405	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0040d	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00415	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0041d	e8 00 00 00 00	 call	 des_decrypt

; 2143 :           for(i = 0; i < 8; i++)

  00422	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0042a	eb 0a		 jmp	 SHORT $LN11@s390_kmc_d
$LN9@s390_kmc_d:
  0042c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00430	ff c0		 inc	 eax
  00432	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@s390_kmc_d:
  00436	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0043b	7d 2a		 jge	 SHORT $LN10@s390_kmc_d

; 2144 :             message_block[i] ^= parameter_block[i];

  0043d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00442	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00447	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0044f	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00457	33 c1		 xor	 eax, ecx
  00459	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0045e	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00465	eb c5		 jmp	 SHORT $LN9@s390_kmc_d
$LN10@s390_kmc_d:

; 2145 :         }

  00467	eb 72		 jmp	 SHORT $LN35@s390_kmc_d
$LN34@s390_kmc_d:

; 2146 :         else
; 2147 :         {
; 2148 :           /* XOR, encrypt and save */
; 2149 :           for(i = 0; i < 8; i++)

  00469	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00471	eb 0a		 jmp	 SHORT $LN14@s390_kmc_d
$LN12@s390_kmc_d:
  00473	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00477	ff c0		 inc	 eax
  00479	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN14@s390_kmc_d:
  0047d	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00482	7d 2a		 jge	 SHORT $LN13@s390_kmc_d

; 2150 :             message_block[i] ^= parameter_block[i];

  00484	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00489	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0048e	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00496	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0049e	33 c1		 xor	 eax, ecx
  004a0	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004a5	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  004ac	eb c5		 jmp	 SHORT $LN12@s390_kmc_d
$LN13@s390_kmc_d:

; 2151 :           des_encrypt(&context1, message_block, message_block);

  004ae	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  004b6	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004be	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  004c6	e8 00 00 00 00	 call	 des_encrypt

; 2152 :           memcpy(ocv, message_block, 8);

  004cb	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  004d3	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN35@s390_kmc_d:

; 2153 :         }
; 2154 :         break;

  004db	e9 d5 02 00 00	 jmp	 $LN7@s390_kmc_d
$LN36@s390_kmc_d:

; 2155 :       }
; 2156 :       case 2: /* tdea-128 */
; 2157 :       {
; 2158 :         if(modifier_bit)

  004e0	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  004e5	0f 84 b1 00 00
	00		 je	 $LN37@s390_kmc_d

; 2159 :         {
; 2160 :           /* Save, decrypt and XOR */
; 2161 :           memcpy(ocv, message_block, 8);

  004eb	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  004f3	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2162 :           des_decrypt(&context1, message_block, message_block);

  004fb	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00503	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0050b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00513	e8 00 00 00 00	 call	 des_decrypt

; 2163 :           des_encrypt(&context2, message_block, message_block);

  00518	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00520	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00528	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00530	e8 00 00 00 00	 call	 des_encrypt

; 2164 :           des_decrypt(&context1, message_block, message_block);

  00535	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0053d	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00545	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0054d	e8 00 00 00 00	 call	 des_decrypt

; 2165 :           for(i = 0; i < 8; i++)

  00552	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0055a	eb 0a		 jmp	 SHORT $LN17@s390_kmc_d
$LN15@s390_kmc_d:
  0055c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00560	ff c0		 inc	 eax
  00562	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN17@s390_kmc_d:
  00566	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0056b	7d 2a		 jge	 SHORT $LN16@s390_kmc_d

; 2166 :             message_block[i] ^= parameter_block[i];

  0056d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00572	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00577	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0057f	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00587	33 c1		 xor	 eax, ecx
  00589	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0058e	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00595	eb c5		 jmp	 SHORT $LN15@s390_kmc_d
$LN16@s390_kmc_d:

; 2167 :         }

  00597	e9 ac 00 00 00	 jmp	 $LN38@s390_kmc_d
$LN37@s390_kmc_d:

; 2168 :         else
; 2169 :         {
; 2170 :           /* XOR, encrypt and save */
; 2171 :           for(i = 0 ; i < 8; i++)

  0059c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a4	eb 0a		 jmp	 SHORT $LN20@s390_kmc_d
$LN18@s390_kmc_d:
  005a6	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005aa	ff c0		 inc	 eax
  005ac	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN20@s390_kmc_d:
  005b0	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  005b5	7d 2a		 jge	 SHORT $LN19@s390_kmc_d

; 2172 :             message_block[i] ^= parameter_block[i];

  005b7	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005bc	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005c1	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  005c9	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  005d1	33 c1		 xor	 eax, ecx
  005d3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005d8	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  005df	eb c5		 jmp	 SHORT $LN18@s390_kmc_d
$LN19@s390_kmc_d:

; 2173 :           des_encrypt(&context1, message_block, message_block);

  005e1	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  005e9	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  005f1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005f9	e8 00 00 00 00	 call	 des_encrypt

; 2174 :           des_decrypt(&context2, message_block, message_block);

  005fe	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00606	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0060e	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00616	e8 00 00 00 00	 call	 des_decrypt

; 2175 :           des_encrypt(&context1, message_block, message_block);

  0061b	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00623	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0062b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00633	e8 00 00 00 00	 call	 des_encrypt

; 2176 :           memcpy(ocv, message_block, 8);

  00638	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00640	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN38@s390_kmc_d:

; 2177 :         }
; 2178 :         break;

  00648	e9 68 01 00 00	 jmp	 $LN7@s390_kmc_d
$LN39@s390_kmc_d:

; 2179 :       }
; 2180 :       case 3: /* tdea-192 */
; 2181 :       {
; 2182 :         if(modifier_bit)

  0064d	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  00652	0f 84 b1 00 00
	00		 je	 $LN40@s390_kmc_d

; 2183 :         {
; 2184 :           /* Save, decrypt and XOR */
; 2185 :           memcpy(ocv, message_block, 8);

  00658	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00660	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2186 :           des_decrypt(&context3, message_block, message_block);

  00668	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00670	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00678	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00680	e8 00 00 00 00	 call	 des_decrypt

; 2187 :           des_encrypt(&context2, message_block, message_block);

  00685	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0068d	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00695	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0069d	e8 00 00 00 00	 call	 des_encrypt

; 2188 :           des_decrypt(&context1, message_block, message_block);

  006a2	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  006aa	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  006b2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  006ba	e8 00 00 00 00	 call	 des_decrypt

; 2189 :           for(i = 0; i < 8; i++)

  006bf	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006c7	eb 0a		 jmp	 SHORT $LN23@s390_kmc_d
$LN21@s390_kmc_d:
  006c9	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006cd	ff c0		 inc	 eax
  006cf	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN23@s390_kmc_d:
  006d3	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  006d8	7d 2a		 jge	 SHORT $LN22@s390_kmc_d

; 2190 :             message_block[i] ^= parameter_block[i];

  006da	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  006df	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006e4	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  006ec	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  006f4	33 c1		 xor	 eax, ecx
  006f6	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006fb	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00702	eb c5		 jmp	 SHORT $LN21@s390_kmc_d
$LN22@s390_kmc_d:

; 2191 :         }

  00704	e9 ac 00 00 00	 jmp	 $LN41@s390_kmc_d
$LN40@s390_kmc_d:

; 2192 :         else
; 2193 :         {
; 2194 :           /* XOR, encrypt and save */
; 2195 :           for(i = 0; i < 8; i++)

  00709	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00711	eb 0a		 jmp	 SHORT $LN26@s390_kmc_d
$LN24@s390_kmc_d:
  00713	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00717	ff c0		 inc	 eax
  00719	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN26@s390_kmc_d:
  0071d	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00722	7d 2a		 jge	 SHORT $LN25@s390_kmc_d

; 2196 :             message_block[i] ^= parameter_block[i];

  00724	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00729	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0072e	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00736	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0073e	33 c1		 xor	 eax, ecx
  00740	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00745	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0074c	eb c5		 jmp	 SHORT $LN24@s390_kmc_d
$LN25@s390_kmc_d:

; 2197 :           des_encrypt(&context1, message_block, message_block);

  0074e	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00756	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0075e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00766	e8 00 00 00 00	 call	 des_encrypt

; 2198 :           des_decrypt(&context2, message_block, message_block);

  0076b	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00773	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0077b	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00783	e8 00 00 00 00	 call	 des_decrypt

; 2199 :           des_encrypt(&context3, message_block, message_block);

  00788	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00790	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00798	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  007a0	e8 00 00 00 00	 call	 des_encrypt

; 2200 :           memcpy(ocv, message_block, 8);

  007a5	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  007ad	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN41@s390_kmc_d:
$LN7@s390_kmc_d:

; 2201 :         }
; 2202 :         break;
; 2203 :       }
; 2204 :     }
; 2205 : 
; 2206 :     /* Store the output */
; 2207 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  007b5	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007bd	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007c5	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  007cd	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  007d3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007da	23 c2		 and	 eax, edx
  007dc	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007e4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007e9	44 8b 8c 24 90
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  007f1	44 8b c0	 mov	 r8d, eax
  007f4	b2 07		 mov	 dl, 7
  007f6	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  007fe	e8 00 00 00 00	 call	 s390_vstorec

; 2208 : 
; 2209 : #ifdef OPTION_KMC_DEBUG
; 2210 :     LOGBYTE("output:", message_block, 8);
; 2211 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2212 : 
; 2213 :     /* Store the output chaining value */
; 2214 :     ARCH_DEP(vstorec)(ocv, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00803	b8 08 00 00 00	 mov	 eax, 8
  00808	48 6b c0 01	 imul	 rax, rax, 1
  0080c	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00814	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0081c	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00822	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00829	23 c2		 and	 eax, edx
  0082b	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00833	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00838	41 b9 01 00 00
	00		 mov	 r9d, 1
  0083e	44 8b c0	 mov	 r8d, eax
  00841	b2 07		 mov	 dl, 7
  00843	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  0084b	e8 00 00 00 00	 call	 s390_vstorec

; 2215 : 
; 2216 : #ifdef OPTION_KMC_DEBUG
; 2217 :     LOGBYTE("ocv   :", ocv, 8);
; 2218 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2219 : 
; 2220 :     /* Update the registers */
; 2221 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  00850	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00858	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00860	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00867	83 c0 08	 add	 eax, 8
  0086a	48 63 8c 24 90
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00872	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0087a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2222 :     if(likely(r1_is_not_r2))

  00881	83 7c 24 78 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00886	74 0a		 je	 SHORT $LN61@s390_kmc_d
  00888	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv447[rsp], 1
  00890	eb 08		 jmp	 SHORT $LN62@s390_kmc_d
$LN61@s390_kmc_d:
  00892	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv447[rsp], 0
$LN62@s390_kmc_d:
  0089a	83 7c 24 64 00	 cmp	 DWORD PTR tv447[rsp], 0
  0089f	74 31		 je	 SHORT $LN42@s390_kmc_d

; 2223 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  008a1	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008a9	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008b8	83 c0 08	 add	 eax, 8
  008bb	48 63 8c 24 98
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  008c3	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008cb	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN42@s390_kmc_d:

; 2224 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  008d2	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008d9	ff c0		 inc	 eax
  008db	48 98		 cdqe
  008dd	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008ec	83 e8 08	 sub	 eax, 8
  008ef	8b 8c 24 98 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  008f6	ff c1		 inc	 ecx
  008f8	48 63 c9	 movsxd	 rcx, ecx
  008fb	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00903	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2225 : 
; 2226 : #ifdef OPTION_KMC_DEBUG
; 2227 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2228 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2229 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2230 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2231 : 
; 2232 :     /* check for end of data */
; 2233 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0090a	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00911	ff c0		 inc	 eax
  00913	48 98		 cdqe
  00915	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091d	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00925	75 0a		 jne	 SHORT $LN63@s390_kmc_d
  00927	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv480[rsp], 1
  0092f	eb 08		 jmp	 SHORT $LN64@s390_kmc_d
$LN63@s390_kmc_d:
  00931	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv480[rsp], 0
$LN64@s390_kmc_d:
  00939	83 7c 24 68 00	 cmp	 DWORD PTR tv480[rsp], 0
  0093e	74 0a		 je	 SHORT $LN67@s390_kmc_d
  00940	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv491[rsp], 1
  00948	eb 08		 jmp	 SHORT $LN68@s390_kmc_d
$LN67@s390_kmc_d:
  0094a	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv491[rsp], 0
$LN68@s390_kmc_d:
  00952	83 7c 24 6c 00	 cmp	 DWORD PTR tv491[rsp], 0
  00957	74 0e		 je	 SHORT $LN43@s390_kmc_d

; 2234 :     {
; 2235 :       regs->psw.cc = 0;

  00959	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00961	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2236 :       return;

  00965	eb 21		 jmp	 SHORT $LN1@s390_kmc_d
$LN43@s390_kmc_d:

; 2237 :     }
; 2238 : 
; 2239 :     /* Set cv for next 8 bytes */
; 2240 :     memcpy(parameter_block, ocv, 8);

  00967	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR ocv$[rsp]
  0096f	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR parameter_block$[rsp], rax

; 2241 :   }

  00977	e9 e1 f9 ff ff	 jmp	 $LN4@s390_kmc_d
$LN5@s390_kmc_d:

; 2242 : 
; 2243 :   /* CPU-determined amount of data processed */
; 2244 :   regs->psw.cc = 3;

  0097c	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00984	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s390_kmc_d:

; 2245 : }

  00988	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00990	48 33 cc	 xor	 rcx, rsp
  00993	e8 00 00 00 00	 call	 __security_check_cookie
  00998	48 81 c4 88 02
	00 00		 add	 rsp, 648		; 00000288H
  0099f	c3		 ret	 0
s390_kmc_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv181 = 56
crypted$ = 60
tfc$ = 64
tv238 = 68
tv83 = 72
tv94 = 76
tv137 = 80
tv152 = 84
tv305 = 88
tv316 = 92
keylen$ = 96
wrap$ = 100
context1$ = 112
context2$ = 256
context3$ = 400
message_block$ = 544
parameter_block$ = 552
__$ArrayPad$ = 608
r1$ = 640
r2$ = 648
regs$ = 656
s390_kmac_dea PROC

; 1731 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 78 02
	00 00		 sub	 rsp, 632		; 00000278H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s390_kmac_:

; 1732 :   des_context context1;
; 1733 :   des_context context2;
; 1734 :   des_context context3;
; 1735 :   int crypted;
; 1736 :   int i;
; 1737 :   int keylen;
; 1738 :   BYTE message_block[8];
; 1739 :   BYTE parameter_block[56];
; 1740 :   int parameter_blocklen;
; 1741 :   int tfc;
; 1742 :   int wrap;
; 1743 : 
; 1744 :   UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@s390_kmac_

; 1745 : 
; 1746 :   /* Check special conditions */
; 1747 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  0002c	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00033	ff c0		 inc	 eax
  00035	48 98		 cdqe
  00037	33 d2		 xor	 edx, edx
  00039	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00041	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00048	b9 08 00 00 00	 mov	 ecx, 8
  0004d	f7 f1		 div	 ecx
  0004f	8b c2		 mov	 eax, edx
  00051	85 c0		 test	 eax, eax
  00053	74 0a		 je	 SHORT $LN28@s390_kmac_
  00055	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  0005d	eb 08		 jmp	 SHORT $LN29@s390_kmac_
$LN28@s390_kmac_:
  0005f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN29@s390_kmac_:
  00067	83 7c 24 48 00	 cmp	 DWORD PTR tv83[rsp], 0
  0006c	74 13		 je	 SHORT $LN15@s390_kmac_

; 1748 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006e	ba 06 00 00 00	 mov	 edx, 6
  00073	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN15@s390_kmac_:

; 1749 : 
; 1750 :   /* Return with cc 0 on zero length */
; 1751 :   if(unlikely(!GR_A(r2 + 1, regs)))

  00081	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00088	ff c0		 inc	 eax
  0008a	48 98		 cdqe
  0008c	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0009c	75 0a		 jne	 SHORT $LN30@s390_kmac_
  0009e	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000a6	eb 08		 jmp	 SHORT $LN31@s390_kmac_
$LN30@s390_kmac_:
  000a8	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN31@s390_kmac_:
  000b0	83 7c 24 4c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000b5	74 0a		 je	 SHORT $LN34@s390_kmac_
  000b7	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN35@s390_kmac_
$LN34@s390_kmac_:
  000c1	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN35@s390_kmac_:
  000c9	83 7c 24 50 00	 cmp	 DWORD PTR tv137[rsp], 0
  000ce	74 11		 je	 SHORT $LN16@s390_kmac_

; 1752 :   {
; 1753 :     regs->psw.cc = 0;

  000d0	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1754 :     return;

  000dc	e9 cc 04 00 00	 jmp	 $LN1@s390_kmac_
$LN16@s390_kmac_:

; 1755 :   }
; 1756 : 
; 1757 :   /* Initialize values */
; 1758 :   tfc = GR0_tfc(regs);

  000e1	b8 08 00 00 00	 mov	 eax, 8
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f9	83 e0 7f	 and	 eax, 127		; 0000007fH
  000fc	83 e0 77	 and	 eax, 119		; 00000077H
  000ff	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 1759 :   wrap = GR0_wrap(regs);

  00103	b8 08 00 00 00	 mov	 eax, 8
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011b	83 e0 08	 and	 eax, 8
  0011e	85 c0		 test	 eax, eax
  00120	74 0a		 je	 SHORT $LN36@s390_kmac_
  00122	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
  0012a	eb 08		 jmp	 SHORT $LN37@s390_kmac_
$LN36@s390_kmac_:
  0012c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN37@s390_kmac_:
  00134	8b 44 24 54	 mov	 eax, DWORD PTR tv152[rsp]
  00138	89 44 24 64	 mov	 DWORD PTR wrap$[rsp], eax

; 1760 :   keylen = tfc * 8;

  0013c	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00140	c1 e0 03	 shl	 eax, 3
  00143	89 44 24 60	 mov	 DWORD PTR keylen$[rsp], eax

; 1761 :   parameter_blocklen = keylen + 8;

  00147	8b 44 24 60	 mov	 eax, DWORD PTR keylen$[rsp]
  0014b	83 c0 08	 add	 eax, 8
  0014e	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1762 :   if(wrap)

  00152	83 7c 24 64 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00157	74 0b		 je	 SHORT $LN17@s390_kmac_

; 1763 :     parameter_blocklen += 24;

  00159	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0015d	83 c0 18	 add	 eax, 24
  00160	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN17@s390_kmac_:

; 1764 : 
; 1765 :   /* Test writeability output chaining value */
; 1766 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  00164	b8 08 00 00 00	 mov	 eax, 8
  00169	48 6b c0 01	 imul	 rax, rax, 1
  0016d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0017d	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00183	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0018a	23 c2		 and	 eax, edx
  0018c	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00194	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00199	41 b9 02 00 00
	00		 mov	 r9d, 2
  0019f	41 b8 07 00 00
	00		 mov	 r8d, 7
  001a5	ba 01 00 00 00	 mov	 edx, 1
  001aa	8b c8		 mov	 ecx, eax
  001ac	e8 00 00 00 00	 call	 s390_validate_operand

; 1767 : 
; 1768 :   /* Fetch the parameter block */
; 1769 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001b1	b8 08 00 00 00	 mov	 eax, 8
  001b6	48 6b c0 01	 imul	 rax, rax, 1
  001ba	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c2	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001ca	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  001d0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001d7	23 c2		 and	 eax, edx
  001d9	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001dd	ff c9		 dec	 ecx
  001df	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001e7	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ec	41 b9 01 00 00
	00		 mov	 r9d, 1
  001f2	44 8b c0	 mov	 r8d, eax
  001f5	0f b6 d1	 movzx	 edx, cl
  001f8	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00200	e8 00 00 00 00	 call	 s390_vfetchc

; 1770 : 
; 1771 : #ifdef OPTION_KMAC_DEBUG
; 1772 :   LOGBYTE("icv   :", parameter_block, 8);
; 1773 :   switch(tfc)
; 1774 :   {
; 1775 :     case 1: /* dea */
; 1776 :     {
; 1777 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1778 :       break;
; 1779 :     }
; 1780 :     case 2: /* tdea-128 */
; 1781 :     {
; 1782 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1783 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 1784 :       break;
; 1785 :     }
; 1786 :     case 3: /* tdea-192 */
; 1787 :     {
; 1788 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1789 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 1790 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 1791 :       break;
; 1792 :     }
; 1793 :   }
; 1794 :   if(wrap)
; 1795 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 1796 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1797 : 
; 1798 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1799 :   /* Verify and unwrap */
; 1800 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))
; 1801 :   {
; 1802 : 
; 1803 : #ifdef OPTION_KM_DEBUG
; 1804 :     WRMSG(HHC90111, "D");
; 1805 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1806 : 
; 1807 :     regs->psw.cc = 1;
; 1808 :     return;
; 1809 :   }
; 1810 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1811 : 
; 1812 :   /* Set the cryptographic key */
; 1813 :   switch(tfc)

  00205	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00209	89 44 24 38	 mov	 DWORD PTR tv181[rsp], eax
  0020d	83 7c 24 38 01	 cmp	 DWORD PTR tv181[rsp], 1
  00212	74 13		 je	 SHORT $LN18@s390_kmac_
  00214	83 7c 24 38 02	 cmp	 DWORD PTR tv181[rsp], 2
  00219	74 2f		 je	 SHORT $LN19@s390_kmac_
  0021b	83 7c 24 38 03	 cmp	 DWORD PTR tv181[rsp], 3
  00220	74 69		 je	 SHORT $LN20@s390_kmac_
  00222	e9 c4 00 00 00	 jmp	 $LN5@s390_kmac_
$LN18@s390_kmac_:

; 1814 :   {
; 1815 :     case 1: /* dea */
; 1816 :     {
; 1817 :       des_set_key(&context1, &parameter_block[8]);

  00227	b8 01 00 00 00	 mov	 eax, 1
  0022c	48 6b c0 08	 imul	 rax, rax, 8
  00230	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00238	48 8b d0	 mov	 rdx, rax
  0023b	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  00240	e8 00 00 00 00	 call	 des_set_key

; 1818 :       break;

  00245	e9 a1 00 00 00	 jmp	 $LN5@s390_kmac_
$LN19@s390_kmac_:

; 1819 :     }
; 1820 :     case 2: /* tdea-128 */
; 1821 :     {
; 1822 :       des_set_key(&context1, &parameter_block[8]);

  0024a	b8 01 00 00 00	 mov	 eax, 1
  0024f	48 6b c0 08	 imul	 rax, rax, 8
  00253	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0025b	48 8b d0	 mov	 rdx, rax
  0025e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  00263	e8 00 00 00 00	 call	 des_set_key

; 1823 :       des_set_key(&context2, &parameter_block[16]);

  00268	b8 01 00 00 00	 mov	 eax, 1
  0026d	48 6b c0 10	 imul	 rax, rax, 16
  00271	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00279	48 8b d0	 mov	 rdx, rax
  0027c	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00284	e8 00 00 00 00	 call	 des_set_key

; 1824 :       break;

  00289	eb 60		 jmp	 SHORT $LN5@s390_kmac_
$LN20@s390_kmac_:

; 1825 :     }
; 1826 :     case 3: /* tdea-192 */
; 1827 :     {
; 1828 :       des_set_key(&context1, &parameter_block[8]);

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	48 6b c0 08	 imul	 rax, rax, 8
  00294	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0029c	48 8b d0	 mov	 rdx, rax
  0029f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  002a4	e8 00 00 00 00	 call	 des_set_key

; 1829 :       des_set_key(&context2, &parameter_block[16]);

  002a9	b8 01 00 00 00	 mov	 eax, 1
  002ae	48 6b c0 10	 imul	 rax, rax, 16
  002b2	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002ba	48 8b d0	 mov	 rdx, rax
  002bd	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002c5	e8 00 00 00 00	 call	 des_set_key

; 1830 :       des_set_key(&context3, &parameter_block[24]);

  002ca	b8 01 00 00 00	 mov	 eax, 1
  002cf	48 6b c0 18	 imul	 rax, rax, 24
  002d3	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002db	48 8b d0	 mov	 rdx, rax
  002de	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  002e6	e8 00 00 00 00	 call	 des_set_key
$LN5@s390_kmac_:

; 1831 :       break;
; 1832 :     }
; 1833 :   }
; 1834 : 
; 1835 :   /* Try to process the CPU-determined amount of data */
; 1836 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  002eb	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  002f3	eb 0b		 jmp	 SHORT $LN9@s390_kmac_
$LN7@s390_kmac_:
  002f5	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  002f9	83 c0 08	 add	 eax, 8
  002fc	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN9@s390_kmac_:
  00300	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00308	0f 8d 93 02 00
	00		 jge	 $LN8@s390_kmac_

; 1837 :   {
; 1838 :     /* Fetch a block of data */
; 1839 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0030e	48 63 84 24 88
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00316	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031e	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00326	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0032c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00333	23 c2		 and	 eax, edx
  00335	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00342	44 8b 8c 24 88
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0034a	44 8b c0	 mov	 r8d, eax
  0034d	b2 07		 mov	 dl, 7
  0034f	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00357	e8 00 00 00 00	 call	 s390_vfetchc

; 1840 : 
; 1841 : #ifdef OPTION_KMAC_DEBUG
; 1842 :     LOGBYTE("input :", message_block, 8);
; 1843 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1844 : 
; 1845 :     /* XOR the message with chaining value */
; 1846 :     for(i = 0; i < 8; i++)

  0035c	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00364	eb 0a		 jmp	 SHORT $LN12@s390_kmac_
$LN10@s390_kmac_:
  00366	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0036a	ff c0		 inc	 eax
  0036c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN12@s390_kmac_:
  00370	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00375	7d 2a		 jge	 SHORT $LN11@s390_kmac_

; 1847 :       message_block[i] ^= parameter_block[i];

  00377	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0037c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00381	0f b6 8c 0c 28
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00389	0f b6 84 04 20
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00391	33 c1		 xor	 eax, ecx
  00393	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00398	88 84 0c 20 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0039f	eb c5		 jmp	 SHORT $LN10@s390_kmac_
$LN11@s390_kmac_:

; 1848 : 
; 1849 :     /* Calculate the output chaining value */
; 1850 :     switch(tfc)

  003a1	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  003a5	89 44 24 44	 mov	 DWORD PTR tv238[rsp], eax
  003a9	83 7c 24 44 01	 cmp	 DWORD PTR tv238[rsp], 1
  003ae	74 13		 je	 SHORT $LN21@s390_kmac_
  003b0	83 7c 24 44 02	 cmp	 DWORD PTR tv238[rsp], 2
  003b5	74 2b		 je	 SHORT $LN22@s390_kmac_
  003b7	83 7c 24 44 03	 cmp	 DWORD PTR tv238[rsp], 3
  003bc	74 77		 je	 SHORT $LN23@s390_kmac_
  003be	e9 c6 00 00 00	 jmp	 $LN13@s390_kmac_
$LN21@s390_kmac_:

; 1851 :     {
; 1852 :       case 1: /* dea */
; 1853 :       {
; 1854 :         des_encrypt(&context1, message_block, parameter_block);

  003c3	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  003cb	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003d3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  003d8	e8 00 00 00 00	 call	 des_encrypt

; 1855 :         break;

  003dd	e9 a7 00 00 00	 jmp	 $LN13@s390_kmac_
$LN22@s390_kmac_:

; 1856 :       }
; 1857 :       case 2: /* tdea-128 */
; 1858 :       {
; 1859 :         des_encrypt(&context1, message_block, parameter_block);

  003e2	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  003ea	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003f2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  003f7	e8 00 00 00 00	 call	 des_encrypt

; 1860 :         des_decrypt(&context2, parameter_block, parameter_block);

  003fc	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00404	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0040c	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00414	e8 00 00 00 00	 call	 des_decrypt

; 1861 :         des_encrypt(&context1, parameter_block, parameter_block);

  00419	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00421	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00429	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  0042e	e8 00 00 00 00	 call	 des_encrypt

; 1862 :         break;

  00433	eb 54		 jmp	 SHORT $LN13@s390_kmac_
$LN23@s390_kmac_:

; 1863 :       }
; 1864 :       case 3: /* tdea-192 */
; 1865 :       {
; 1866 :         des_encrypt(&context1, message_block, parameter_block);

  00435	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0043d	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00445	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  0044a	e8 00 00 00 00	 call	 des_encrypt

; 1867 :         des_decrypt(&context2, parameter_block, parameter_block);

  0044f	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00457	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0045f	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00467	e8 00 00 00 00	 call	 des_decrypt

; 1868 :         des_encrypt(&context3, parameter_block, parameter_block);

  0046c	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00474	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0047c	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00484	e8 00 00 00 00	 call	 des_encrypt
$LN13@s390_kmac_:

; 1869 :         break;
; 1870 :       }
; 1871 :     }
; 1872 : 
; 1873 :     /* Store the output chaining value */
; 1874 :     ARCH_DEP(vstorec)(parameter_block, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00489	b8 08 00 00 00	 mov	 eax, 8
  0048e	48 6b c0 01	 imul	 rax, rax, 1
  00492	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049a	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004a2	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  004a8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004af	23 c2		 and	 eax, edx
  004b1	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004be	41 b9 01 00 00
	00		 mov	 r9d, 1
  004c4	44 8b c0	 mov	 r8d, eax
  004c7	b2 07		 mov	 dl, 7
  004c9	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  004d1	e8 00 00 00 00	 call	 s390_vstorec

; 1875 : 
; 1876 : #ifdef OPTION_KMAC_DEBUG
; 1877 :     LOGBYTE("ocv   :", parameter_block, 8);
; 1878 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1879 : 
; 1880 :     /* Update the registers */
; 1881 :     SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  004d6	48 63 84 24 88
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004de	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e6	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004ed	83 c0 08	 add	 eax, 8
  004f0	48 63 8c 24 88
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  004f8	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00500	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1882 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  00507	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0050e	ff c0		 inc	 eax
  00510	48 98		 cdqe
  00512	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00521	83 e8 08	 sub	 eax, 8
  00524	8b 8c 24 88 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0052b	ff c1		 inc	 ecx
  0052d	48 63 c9	 movsxd	 rcx, ecx
  00530	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00538	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1883 : 
; 1884 : #ifdef OPTION_KMAC_DEBUG
; 1885 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1886 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1887 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1888 : 
; 1889 :     /* check for end of data */
; 1890 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0053f	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00546	ff c0		 inc	 eax
  00548	48 98		 cdqe
  0054a	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00552	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0055a	75 0a		 jne	 SHORT $LN38@s390_kmac_
  0055c	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv305[rsp], 1
  00564	eb 08		 jmp	 SHORT $LN39@s390_kmac_
$LN38@s390_kmac_:
  00566	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv305[rsp], 0
$LN39@s390_kmac_:
  0056e	83 7c 24 58 00	 cmp	 DWORD PTR tv305[rsp], 0
  00573	74 0a		 je	 SHORT $LN42@s390_kmac_
  00575	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv316[rsp], 1
  0057d	eb 08		 jmp	 SHORT $LN43@s390_kmac_
$LN42@s390_kmac_:
  0057f	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv316[rsp], 0
$LN43@s390_kmac_:
  00587	83 7c 24 5c 00	 cmp	 DWORD PTR tv316[rsp], 0
  0058c	74 0e		 je	 SHORT $LN24@s390_kmac_

; 1891 :     {
; 1892 :       regs->psw.cc = 0;

  0058e	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00596	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1893 :       return;

  0059a	eb 11		 jmp	 SHORT $LN1@s390_kmac_
$LN24@s390_kmac_:

; 1894 :     }
; 1895 :   }

  0059c	e9 54 fd ff ff	 jmp	 $LN7@s390_kmac_
$LN8@s390_kmac_:

; 1896 : 
; 1897 :   /* CPU-determined amount of data processed */
; 1898 :   regs->psw.cc = 3;

  005a1	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a9	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s390_kmac_:

; 1899 : }

  005ad	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005b5	48 33 cc	 xor	 rcx, rsp
  005b8	e8 00 00 00 00	 call	 __security_check_cookie
  005bd	48 81 c4 78 02
	00 00		 add	 rsp, 632		; 00000278H
  005c4	c3		 ret	 0
s390_kmac_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
crypted$ = 52
tv82 = 56
tv93 = 60
tv136 = 64
tv151 = 68
keylen$ = 72
tv180 = 76
tv182 = 80
tv228 = 84
tv261 = 88
tv272 = 92
tfc$ = 96
wrap$ = 100
modifier_bit$ = 104
r1_is_not_r2$ = 108
context$ = 112
message_block$ = 608
parameter_block$ = 624
__$ArrayPad$ = 688
r1$ = 720
r2$ = 728
regs$ = 736
s390_km_aes PROC

; 1494 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1495 :   rijndael_ctx context;
; 1496 :   int crypted;
; 1497 :   int keylen;
; 1498 :   BYTE message_block[16];
; 1499 :   int modifier_bit;
; 1500 :   BYTE parameter_block[64];
; 1501 :   int parameter_blocklen;
; 1502 :   int r1_is_not_r2;
; 1503 :   int tfc;
; 1504 :   int wrap;
; 1505 : 
; 1506 :   /* Check special conditions */
; 1507 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00026	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 10 00 00 00	 mov	 ecx, 16
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN15@s390_km_ae
  0004f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN16@s390_km_ae
$LN15@s390_km_ae:
  00059	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN16@s390_km_ae:
  00061	83 7c 24 38 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN5@s390_km_ae

; 1508 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN5@s390_km_ae:

; 1509 : 
; 1510 :   /* Return with cc 0 on zero length */
; 1511 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN17@s390_km_ae
  00098	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN18@s390_km_ae
$LN17@s390_km_ae:
  000a2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN18@s390_km_ae:
  000aa	83 7c 24 3c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN21@s390_km_ae
  000b1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN22@s390_km_ae
$LN21@s390_km_ae:
  000bb	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN22@s390_km_ae:
  000c3	83 7c 24 40 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN6@s390_km_ae

; 1512 :   {
; 1513 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1514 :     return;

  000d6	e9 7d 03 00 00	 jmp	 $LN1@s390_km_ae
$LN6@s390_km_ae:

; 1515 :   }
; 1516 : 
; 1517 :   /* Initialize values */
; 1518 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 60	 mov	 DWORD PTR tfc$[rsp], eax

; 1519 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN23@s390_km_ae
  0011c	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN24@s390_km_ae
$LN23@s390_km_ae:
  00126	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN24@s390_km_ae:
  0012e	8b 44 24 44	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 64	 mov	 DWORD PTR wrap$[rsp], eax

; 1520 :   keylen = (tfc - 17) * 8 + 8;

  00136	8b 44 24 60	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00141	89 44 24 48	 mov	 DWORD PTR keylen$[rsp], eax

; 1521 :   parameter_blocklen = keylen;

  00145	8b 44 24 48	 mov	 eax, DWORD PTR keylen$[rsp]
  00149	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1522 :   if(wrap)

  0014d	83 7c 24 64 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00152	74 0b		 je	 SHORT $LN7@s390_km_ae

; 1523 :     parameter_blocklen += 32;

  00154	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00158	83 c0 20	 add	 eax, 32			; 00000020H
  0015b	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN7@s390_km_ae:

; 1524 : 
; 1525 :   /* Fetch the parameter block */
; 1526 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0015f	b8 08 00 00 00	 mov	 eax, 8
  00164	48 6b c0 01	 imul	 rax, rax, 1
  00168	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00178	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0017e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00185	23 c2		 and	 eax, edx
  00187	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0018b	ff c9		 dec	 ecx
  0018d	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00195	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0019a	41 b9 01 00 00
	00		 mov	 r9d, 1
  001a0	44 8b c0	 mov	 r8d, eax
  001a3	0f b6 d1	 movzx	 edx, cl
  001a6	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001ae	e8 00 00 00 00	 call	 s390_vfetchc

; 1527 : 
; 1528 : #ifdef OPTION_KM_DEBUG
; 1529 :   LOGBYTE("k     :", parameter_block, keylen);
; 1530 :   if(wrap)
; 1531 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 32);
; 1532 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1533 : 
; 1534 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1535 :   /* Verify and unwrap */
; 1536 :   if(wrap && unwrap_aes(parameter_block, keylen))
; 1537 :   {
; 1538 : 
; 1539 : #ifdef OPTION_KM_DEBUG
; 1540 :     WRMSG(HHC90111, "D");
; 1541 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1542 : 
; 1543 :     regs->psw.cc = 1;
; 1544 :     return;
; 1545 :   }
; 1546 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1547 : 
; 1548 :   /* Set the cryptographic keys */
; 1549 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  001b3	8b 44 24 48	 mov	 eax, DWORD PTR keylen$[rsp]
  001b7	c1 e0 03	 shl	 eax, 3
  001ba	44 8b c0	 mov	 r8d, eax
  001bd	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  001c5	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  001ca	e8 00 00 00 00	 call	 rijndael_set_key

; 1550 : 
; 1551 :   /* Try to process the CPU-determined amount of data */
; 1552 :   modifier_bit = GR0_m(regs);

  001cf	b8 08 00 00 00	 mov	 eax, 8
  001d4	48 6b c0 00	 imul	 rax, rax, 0
  001d8	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001e0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  001ec	85 c0		 test	 eax, eax
  001ee	74 0a		 je	 SHORT $LN25@s390_km_ae
  001f0	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  001f8	eb 08		 jmp	 SHORT $LN26@s390_km_ae
$LN25@s390_km_ae:
  001fa	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN26@s390_km_ae:
  00202	8b 44 24 4c	 mov	 eax, DWORD PTR tv180[rsp]
  00206	89 44 24 68	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1553 :   r1_is_not_r2 = r1 != r2;

  0020a	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00211	39 84 24 d0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00218	74 0a		 je	 SHORT $LN27@s390_km_ae
  0021a	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv182[rsp], 1
  00222	eb 08		 jmp	 SHORT $LN28@s390_km_ae
$LN27@s390_km_ae:
  00224	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
$LN28@s390_km_ae:
  0022c	8b 44 24 50	 mov	 eax, DWORD PTR tv182[rsp]
  00230	89 44 24 6c	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1554 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00234	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0023c	eb 0b		 jmp	 SHORT $LN4@s390_km_ae
$LN2@s390_km_ae:
  0023e	8b 44 24 34	 mov	 eax, DWORD PTR crypted$[rsp]
  00242	83 c0 10	 add	 eax, 16
  00245	89 44 24 34	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s390_km_ae:
  00249	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00251	0f 8d f5 01 00
	00		 jge	 $LN3@s390_km_ae

; 1555 :   {
; 1556 :     /* Fetch a block of data */
; 1557 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00257	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0025f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00267	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0026f	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00275	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0027c	23 c2		 and	 eax, edx
  0027e	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00286	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0028b	44 8b 8c 24 d8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00293	44 8b c0	 mov	 r8d, eax
  00296	b2 0f		 mov	 dl, 15
  00298	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002a0	e8 00 00 00 00	 call	 s390_vfetchc

; 1558 : 
; 1559 : #ifdef OPTION_KM_DEBUG
; 1560 :     LOGBYTE("input :", message_block, 16);
; 1561 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1562 : 
; 1563 :     /* Do the job */
; 1564 :     if(modifier_bit)

  002a5	83 7c 24 68 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  002aa	74 1c		 je	 SHORT $LN8@s390_km_ae

; 1565 :       rijndael_decrypt(&context, message_block, message_block);

  002ac	4c 8d 84 24 60
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  002b4	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  002bc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  002c1	e8 00 00 00 00	 call	 rijndael_decrypt
  002c6	eb 1a		 jmp	 SHORT $LN9@s390_km_ae
$LN8@s390_km_ae:

; 1566 :     else
; 1567 :       rijndael_encrypt(&context, message_block, message_block);

  002c8	4c 8d 84 24 60
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  002d0	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  002d8	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  002dd	e8 00 00 00 00	 call	 rijndael_encrypt
$LN9@s390_km_ae:

; 1568 : 
; 1569 :     /* Store the output */
; 1570 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  002e2	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  002ea	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002fa	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  00300	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00307	23 c2		 and	 eax, edx
  00309	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00316	44 8b 8c 24 d0
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0031e	44 8b c0	 mov	 r8d, eax
  00321	b2 0f		 mov	 dl, 15
  00323	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0032b	e8 00 00 00 00	 call	 s390_vstorec

; 1571 : 
; 1572 : #ifdef OPTION_KM_DEBUG
; 1573 :     LOGBYTE("output:", message_block, 16);
; 1574 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1575 : 
; 1576 :     /* Update the registers */
; 1577 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  00330	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00338	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00340	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00347	83 c0 10	 add	 eax, 16
  0034a	48 63 8c 24 d0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00352	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0035a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1578 :     if(likely(r1_is_not_r2))

  00361	83 7c 24 6c 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00366	74 0a		 je	 SHORT $LN29@s390_km_ae
  00368	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv228[rsp], 1
  00370	eb 08		 jmp	 SHORT $LN30@s390_km_ae
$LN29@s390_km_ae:
  00372	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN30@s390_km_ae:
  0037a	83 7c 24 54 00	 cmp	 DWORD PTR tv228[rsp], 0
  0037f	74 31		 je	 SHORT $LN10@s390_km_ae

; 1579 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  00381	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00389	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00391	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00398	83 c0 10	 add	 eax, 16
  0039b	48 63 8c 24 d8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  003a3	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003ab	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN10@s390_km_ae:

; 1580 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  003b2	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003b9	ff c0		 inc	 eax
  003bb	48 98		 cdqe
  003bd	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003cc	83 e8 10	 sub	 eax, 16
  003cf	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  003d6	ff c1		 inc	 ecx
  003d8	48 63 c9	 movsxd	 rcx, ecx
  003db	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003e3	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1581 : 
; 1582 : #ifdef OPTION_KM_DEBUG
; 1583 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1584 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1585 :     WRMSG(HHC90108, "D", (regs)->GR(r2 + 1));
; 1586 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1587 : 
; 1588 :     /* check for end of data */
; 1589 :     if(unlikely(!GR_A(r2 + 1, regs)))

  003ea	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003f1	ff c0		 inc	 eax
  003f3	48 98		 cdqe
  003f5	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fd	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00405	75 0a		 jne	 SHORT $LN31@s390_km_ae
  00407	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv261[rsp], 1
  0040f	eb 08		 jmp	 SHORT $LN32@s390_km_ae
$LN31@s390_km_ae:
  00411	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv261[rsp], 0
$LN32@s390_km_ae:
  00419	83 7c 24 58 00	 cmp	 DWORD PTR tv261[rsp], 0
  0041e	74 0a		 je	 SHORT $LN35@s390_km_ae
  00420	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv272[rsp], 1
  00428	eb 08		 jmp	 SHORT $LN36@s390_km_ae
$LN35@s390_km_ae:
  0042a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv272[rsp], 0
$LN36@s390_km_ae:
  00432	83 7c 24 5c 00	 cmp	 DWORD PTR tv272[rsp], 0
  00437	74 0e		 je	 SHORT $LN11@s390_km_ae

; 1590 :     {
; 1591 :       regs->psw.cc = 0;

  00439	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00441	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1592 :       return;

  00445	eb 11		 jmp	 SHORT $LN1@s390_km_ae
$LN11@s390_km_ae:

; 1593 :     }
; 1594 :   }

  00447	e9 f2 fd ff ff	 jmp	 $LN2@s390_km_ae
$LN3@s390_km_ae:

; 1595 : 
; 1596 :   /* CPU-determined amount of data processed */
; 1597 :   regs->psw.cc = 3;

  0044c	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00454	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s390_km_ae:

; 1598 : }

  00458	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00460	48 33 cc	 xor	 rcx, rsp
  00463	e8 00 00 00 00	 call	 __security_check_cookie
  00468	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  0046f	c3		 ret	 0
s390_km_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
tv168 = 52
crypted$ = 56
tfc$ = 60
tv210 = 64
tv82 = 68
tv93 = 72
tv136 = 76
tv151 = 80
tv193 = 84
tv195 = 88
modifier_bit$ = 92
tv252 = 96
tv285 = 100
tv296 = 104
keylen$ = 108
wrap$ = 112
r1_is_not_r2$ = 116
des_ctx$ = 128
des3_ctx$ = 272
message_block$ = 688
parameter_block$ = 696
__$ArrayPad$ = 744
r1$ = 768
r2$ = 776
regs$ = 784
s390_km_dea PROC

; 1329 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1330 :   int crypted;
; 1331 :   des_context des_ctx;
; 1332 :   des3_context des3_ctx;
; 1333 :   int keylen;
; 1334 :   BYTE message_block[8];
; 1335 :   int modifier_bit;
; 1336 :   BYTE parameter_block[48];
; 1337 :   int parameter_blocklen;
; 1338 :   int r1_is_not_r2;
; 1339 :   int tfc;
; 1340 :   int wrap;
; 1341 : 
; 1342 :   /* Check special conditions */
; 1343 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 08 00 00 00	 mov	 ecx, 8
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN27@s390_km_de
  0004f	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN28@s390_km_de
$LN27@s390_km_de:
  00059	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN28@s390_km_de:
  00061	83 7c 24 44 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN9@s390_km_de

; 1344 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN9@s390_km_de:

; 1345 : 
; 1346 :   /* Return with cc 0 on zero length */
; 1347 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN29@s390_km_de
  00098	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN30@s390_km_de
$LN29@s390_km_de:
  000a2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN30@s390_km_de:
  000aa	83 7c 24 48 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN33@s390_km_de
  000b1	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN34@s390_km_de
$LN33@s390_km_de:
  000bb	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN34@s390_km_de:
  000c3	83 7c 24 4c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN10@s390_km_de

; 1348 :   {
; 1349 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1350 :     return;

  000d6	e9 68 04 00 00	 jmp	 $LN1@s390_km_de
$LN10@s390_km_de:

; 1351 :   }
; 1352 : 
; 1353 :   /* Initialize values */
; 1354 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 3c	 mov	 DWORD PTR tfc$[rsp], eax

; 1355 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN35@s390_km_de
  0011c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN36@s390_km_de
$LN35@s390_km_de:
  00126	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN36@s390_km_de:
  0012e	8b 44 24 50	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 70	 mov	 DWORD PTR wrap$[rsp], eax

; 1356 :   keylen = tfc * 8;

  00136	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	c1 e0 03	 shl	 eax, 3
  0013d	89 44 24 6c	 mov	 DWORD PTR keylen$[rsp], eax

; 1357 :   parameter_blocklen = keylen;

  00141	8b 44 24 6c	 mov	 eax, DWORD PTR keylen$[rsp]
  00145	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1358 :   if(wrap)

  00149	83 7c 24 70 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0014e	74 0b		 je	 SHORT $LN11@s390_km_de

; 1359 :     parameter_blocklen += 24;

  00150	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00154	83 c0 18	 add	 eax, 24
  00157	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN11@s390_km_de:

; 1360 : 
; 1361 :   /* Fetch the parameter block */
; 1362 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0015b	b8 08 00 00 00	 mov	 eax, 8
  00160	48 6b c0 01	 imul	 rax, rax, 1
  00164	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00174	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0017a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00181	23 c2		 and	 eax, edx
  00183	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00187	ff c9		 dec	 ecx
  00189	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00191	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00196	41 b9 01 00 00
	00		 mov	 r9d, 1
  0019c	44 8b c0	 mov	 r8d, eax
  0019f	0f b6 d1	 movzx	 edx, cl
  001a2	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001aa	e8 00 00 00 00	 call	 s390_vfetchc

; 1363 : 
; 1364 : #ifdef OPTION_KM_DEBUG
; 1365 :   switch(tfc)
; 1366 :   {
; 1367 :     case 1: /* dea */
; 1368 :     {
; 1369 :       LOGBYTE("k     :", parameter_block, 8);
; 1370 :       break;
; 1371 :     }
; 1372 :     case 2: /* tdea-128 */
; 1373 :     {
; 1374 :       LOGBYTE("k1    :", parameter_block, 8);
; 1375 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 1376 :       break;
; 1377 :     }
; 1378 :     case 3: /* tdea-192 */
; 1379 :     {
; 1380 :       LOGBYTE("k1    :", parameter_block, 8);
; 1381 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 1382 :       LOGBYTE("k3    :", &parameter_block[16], 8);
; 1383 :       break;
; 1384 :     }
; 1385 :   }
; 1386 :   if(wrap)
; 1387 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 24);
; 1388 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1389 : 
; 1390 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1391 :   /* Verify and unwrap */
; 1392 :   if(wrap && unwrap_dea(parameter_block, keylen))
; 1393 :   {
; 1394 : 
; 1395 : #ifdef OPTION_KM_DEBUG
; 1396 :     WRMSG(HHC90111, "D");
; 1397 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1398 : 
; 1399 :     regs->psw.cc = 1;
; 1400 :     return;
; 1401 :   }
; 1402 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1403 : 
; 1404 :   /* Set the cryptographic key */
; 1405 :   switch(tfc)

  001af	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  001b3	89 44 24 34	 mov	 DWORD PTR tv168[rsp], eax
  001b7	83 7c 24 34 01	 cmp	 DWORD PTR tv168[rsp], 1
  001bc	74 10		 je	 SHORT $LN12@s390_km_de
  001be	83 7c 24 34 02	 cmp	 DWORD PTR tv168[rsp], 2
  001c3	74 20		 je	 SHORT $LN13@s390_km_de
  001c5	83 7c 24 34 03	 cmp	 DWORD PTR tv168[rsp], 3
  001ca	74 44		 je	 SHORT $LN14@s390_km_de
  001cc	eb 7f		 jmp	 SHORT $LN2@s390_km_de
$LN12@s390_km_de:

; 1406 :   {
; 1407 :     case 1: /* dea */
; 1408 :     {
; 1409 :       des_set_key(&des_ctx, parameter_block);

  001ce	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  001d6	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  001de	e8 00 00 00 00	 call	 des_set_key

; 1410 :       break;

  001e3	eb 68		 jmp	 SHORT $LN2@s390_km_de
$LN13@s390_km_de:

; 1411 :     }
; 1412 :     case 2: /* tdea-128 */
; 1413 :     {
; 1414 :       des3_set_2keys(&des3_ctx, parameter_block, &parameter_block[8]);

  001e5	b8 01 00 00 00	 mov	 eax, 1
  001ea	48 6b c0 08	 imul	 rax, rax, 8
  001ee	48 8d 84 04 b8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  001f6	4c 8b c0	 mov	 r8, rax
  001f9	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00201	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  00209	e8 00 00 00 00	 call	 des3_set_2keys

; 1415 :       break;

  0020e	eb 3d		 jmp	 SHORT $LN2@s390_km_de
$LN14@s390_km_de:

; 1416 :     }
; 1417 :     case 3: /* tdea-192 */
; 1418 :     {
; 1419 :       des3_set_3keys(&des3_ctx, parameter_block, &parameter_block[8], &parameter_block[16]);

  00210	b8 01 00 00 00	 mov	 eax, 1
  00215	48 6b c0 10	 imul	 rax, rax, 16
  00219	48 8d 84 04 b8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00221	b9 01 00 00 00	 mov	 ecx, 1
  00226	48 6b c9 08	 imul	 rcx, rcx, 8
  0022a	48 8d 8c 0c b8
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00232	4c 8b c8	 mov	 r9, rax
  00235	4c 8b c1	 mov	 r8, rcx
  00238	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00240	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  00248	e8 00 00 00 00	 call	 des3_set_3keys
$LN2@s390_km_de:

; 1420 :       break;
; 1421 :     }
; 1422 :   }
; 1423 : 
; 1424 :   /* Try to process the CPU-determined amount of data */
; 1425 :   modifier_bit = GR0_m(regs);

  0024d	b8 08 00 00 00	 mov	 eax, 8
  00252	48 6b c0 00	 imul	 rax, rax, 0
  00256	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00265	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0026a	85 c0		 test	 eax, eax
  0026c	74 0a		 je	 SHORT $LN37@s390_km_de
  0026e	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv193[rsp], 1
  00276	eb 08		 jmp	 SHORT $LN38@s390_km_de
$LN37@s390_km_de:
  00278	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv193[rsp], 0
$LN38@s390_km_de:
  00280	8b 44 24 54	 mov	 eax, DWORD PTR tv193[rsp]
  00284	89 44 24 5c	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1426 :   r1_is_not_r2 = r1 != r2;

  00288	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0028f	39 84 24 00 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00296	74 0a		 je	 SHORT $LN39@s390_km_de
  00298	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  002a0	eb 08		 jmp	 SHORT $LN40@s390_km_de
$LN39@s390_km_de:
  002a2	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN40@s390_km_de:
  002aa	8b 44 24 58	 mov	 eax, DWORD PTR tv195[rsp]
  002ae	89 44 24 74	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1427 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  002b2	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  002ba	eb 0b		 jmp	 SHORT $LN6@s390_km_de
$LN4@s390_km_de:
  002bc	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  002c0	83 c0 08	 add	 eax, 8
  002c3	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@s390_km_de:
  002c7	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  002cf	0f 8d 62 02 00
	00		 jge	 $LN5@s390_km_de

; 1428 :   {
; 1429 :     /* Fetch a block of data */
; 1430 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  002d5	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002dd	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e5	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002ed	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  002f3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002fa	23 c2		 and	 eax, edx
  002fc	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00304	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00309	44 8b 8c 24 08
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00311	44 8b c0	 mov	 r8d, eax
  00314	b2 07		 mov	 dl, 7
  00316	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0031e	e8 00 00 00 00	 call	 s390_vfetchc

; 1431 : 
; 1432 : #ifdef OPTION_KM_DEBUG
; 1433 :     LOGBYTE("input :", message_block, 8);
; 1434 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1435 : 
; 1436 :     /* Do the job */
; 1437 :     switch(tfc)

  00323	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  00327	89 44 24 40	 mov	 DWORD PTR tv210[rsp], eax
  0032b	83 7c 24 40 01	 cmp	 DWORD PTR tv210[rsp], 1
  00330	74 13		 je	 SHORT $LN15@s390_km_de
  00332	83 7c 24 40 02	 cmp	 DWORD PTR tv210[rsp], 2
  00337	74 51		 je	 SHORT $LN18@s390_km_de
  00339	83 7c 24 40 03	 cmp	 DWORD PTR tv210[rsp], 3
  0033e	74 4a		 je	 SHORT $LN19@s390_km_de
  00340	e9 88 00 00 00	 jmp	 $LN7@s390_km_de
$LN15@s390_km_de:

; 1438 :     {
; 1439 :       case 1: /* dea */
; 1440 :       {
; 1441 :         if(modifier_bit)

  00345	83 7c 24 5c 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0034a	74 1f		 je	 SHORT $LN16@s390_km_de

; 1442 :           des_decrypt(&des_ctx, message_block, message_block);

  0034c	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00354	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0035c	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  00364	e8 00 00 00 00	 call	 des_decrypt
  00369	eb 1d		 jmp	 SHORT $LN17@s390_km_de
$LN16@s390_km_de:

; 1443 :         else
; 1444 :           des_encrypt(&des_ctx, message_block, message_block);

  0036b	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00373	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0037b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  00383	e8 00 00 00 00	 call	 des_encrypt
$LN17@s390_km_de:

; 1445 :         break;

  00388	eb 43		 jmp	 SHORT $LN7@s390_km_de
$LN18@s390_km_de:
$LN19@s390_km_de:

; 1446 :       }
; 1447 :       case 2: /* tdea-128 */
; 1448 :       case 3: /* tdea-192 */
; 1449 :       {
; 1450 :         if(modifier_bit)

  0038a	83 7c 24 5c 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0038f	74 1f		 je	 SHORT $LN20@s390_km_de

; 1451 :           des3_decrypt(&des3_ctx, message_block, message_block);

  00391	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00399	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003a1	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  003a9	e8 00 00 00 00	 call	 des3_decrypt
  003ae	eb 1d		 jmp	 SHORT $LN21@s390_km_de
$LN20@s390_km_de:

; 1452 :         else
; 1453 :           des3_encrypt(&des3_ctx, message_block, message_block);

  003b0	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003b8	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003c0	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  003c8	e8 00 00 00 00	 call	 des3_encrypt
$LN21@s390_km_de:
$LN7@s390_km_de:

; 1454 :         break;
; 1455 :       }
; 1456 :     }
; 1457 : 
; 1458 :     /* Store the output */
; 1459 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  003cd	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  003d5	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003dd	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003e5	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  003eb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003f2	23 c2		 and	 eax, edx
  003f4	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00401	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  00409	44 8b c0	 mov	 r8d, eax
  0040c	b2 07		 mov	 dl, 7
  0040e	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00416	e8 00 00 00 00	 call	 s390_vstorec

; 1460 : 
; 1461 : #ifdef OPTION_KM_DEBUG
; 1462 :     LOGBYTE("output:", message_block, 8);
; 1463 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1464 : 
; 1465 :     /* Update the registers */
; 1466 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  0041b	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00423	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00432	83 c0 08	 add	 eax, 8
  00435	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0043d	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00445	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1467 :     if(likely(r1_is_not_r2))

  0044c	83 7c 24 74 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00451	74 0a		 je	 SHORT $LN41@s390_km_de
  00453	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv252[rsp], 1
  0045b	eb 08		 jmp	 SHORT $LN42@s390_km_de
$LN41@s390_km_de:
  0045d	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN42@s390_km_de:
  00465	83 7c 24 60 00	 cmp	 DWORD PTR tv252[rsp], 0
  0046a	74 31		 je	 SHORT $LN22@s390_km_de

; 1468 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  0046c	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00474	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00483	83 c0 08	 add	 eax, 8
  00486	48 63 8c 24 08
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0048e	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00496	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN22@s390_km_de:

; 1469 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  0049d	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004a4	ff c0		 inc	 eax
  004a6	48 98		 cdqe
  004a8	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004b7	83 e8 08	 sub	 eax, 8
  004ba	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  004c1	ff c1		 inc	 ecx
  004c3	48 63 c9	 movsxd	 rcx, ecx
  004c6	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004ce	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1470 : 
; 1471 : #ifdef OPTION_KM_DEBUG
; 1472 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1473 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1474 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1475 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1476 : 
; 1477 :     /* check for end of data */
; 1478 :     if(unlikely(!GR_A(r2 + 1, regs)))

  004d5	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004dc	ff c0		 inc	 eax
  004de	48 98		 cdqe
  004e0	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e8	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  004f0	75 0a		 jne	 SHORT $LN43@s390_km_de
  004f2	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv285[rsp], 1
  004fa	eb 08		 jmp	 SHORT $LN44@s390_km_de
$LN43@s390_km_de:
  004fc	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv285[rsp], 0
$LN44@s390_km_de:
  00504	83 7c 24 64 00	 cmp	 DWORD PTR tv285[rsp], 0
  00509	74 0a		 je	 SHORT $LN47@s390_km_de
  0050b	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv296[rsp], 1
  00513	eb 08		 jmp	 SHORT $LN48@s390_km_de
$LN47@s390_km_de:
  00515	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
$LN48@s390_km_de:
  0051d	83 7c 24 68 00	 cmp	 DWORD PTR tv296[rsp], 0
  00522	74 0e		 je	 SHORT $LN23@s390_km_de

; 1479 :     {
; 1480 :       regs->psw.cc = 0;

  00524	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0052c	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1481 :       return;

  00530	eb 11		 jmp	 SHORT $LN1@s390_km_de
$LN23@s390_km_de:

; 1482 :     }
; 1483 :   }

  00532	e9 85 fd ff ff	 jmp	 $LN4@s390_km_de
$LN5@s390_km_de:

; 1484 : 
; 1485 :   /* CPU-determined amount of data processed */
; 1486 :   regs->psw.cc = 3;

  00537	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0053f	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s390_km_de:

; 1487 : }

  00543	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0054b	48 33 cc	 xor	 rcx, rsp
  0054e	e8 00 00 00 00	 call	 __security_check_cookie
  00553	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  0055a	c3		 ret	 0
s390_km_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
mbllen$ = 52
message_blocklen$ = 56
parameter_blocklen$ = 60
fc$ = 64
tv70 = 68
tv157 = 72
tv226 = 76
tv253 = 80
tv90 = 84
tv180 = 88
tv214 = 92
$T1 = 96
$T2 = 104
$T3 = 112
sha1_ctx$ = 128
sha2_ctx$ = 224
sha512_ctx$ = 432
parameter_block$ = 640
message_block$ = 720
__$ArrayPad$ = 848
r1$ = 896
r2$ = 904
regs$ = 912
s390_klmd_sha PROC

; 1101 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1102 :   SHA1_CTX sha1_ctx;
; 1103 : 
; 1104 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1105 :   SHA2_CTX sha2_ctx;
; 1106 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1107 : 
; 1108 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1109 :   SHA2_CTX sha512_ctx;
; 1110 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1111 : 
; 1112 :   int fc;
; 1113 :   int i;
; 1114 :   int mbllen = 0;

  00028	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 0

; 1115 :   BYTE message_block[128];
; 1116 :   int message_blocklen = 0;

  00030	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 0

; 1117 :   BYTE parameter_block[80];
; 1118 :   int parameter_blocklen = 0;

  00038	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 0
$LN4@s390_klmd_:

; 1119 : 
; 1120 :   UNREFERENCED(r1);

  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 fa		 jne	 SHORT $LN4@s390_klmd_

; 1121 : 
; 1122 :   /* Initialize values */
; 1123 :   fc = GR0_fc(regs);

  00046	b8 08 00 00 00	 mov	 eax, 8
  0004b	48 6b c0 00	 imul	 rax, rax, 0
  0004f	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0005e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00061	89 44 24 40	 mov	 DWORD PTR fc$[rsp], eax

; 1124 :   switch(fc)

  00065	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  00069	89 44 24 44	 mov	 DWORD PTR tv70[rsp], eax
  0006d	83 7c 24 44 01	 cmp	 DWORD PTR tv70[rsp], 1
  00072	74 10		 je	 SHORT $LN20@s390_klmd_
  00074	83 7c 24 44 02	 cmp	 DWORD PTR tv70[rsp], 2
  00079	74 23		 je	 SHORT $LN21@s390_klmd_
  0007b	83 7c 24 44 03	 cmp	 DWORD PTR tv70[rsp], 3
  00080	74 36		 je	 SHORT $LN22@s390_klmd_
  00082	eb 4c		 jmp	 SHORT $LN5@s390_klmd_
$LN20@s390_klmd_:

; 1125 :   {
; 1126 :     case 1: /* sha-1 */
; 1127 :     {
; 1128 :       mbllen = 8;

  00084	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 8

; 1129 :       message_blocklen = 64;

  0008c	c7 44 24 38 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 1130 :       parameter_blocklen = 20;

  00094	c7 44 24 3c 14
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 20

; 1131 :       break;

  0009c	eb 32		 jmp	 SHORT $LN5@s390_klmd_
$LN21@s390_klmd_:

; 1132 :     }
; 1133 : 
; 1134 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1135 :     case 2: /* sha-256 */
; 1136 :     {
; 1137 :       mbllen = 8;

  0009e	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 8

; 1138 :       message_blocklen = 64;

  000a6	c7 44 24 38 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 1139 :       parameter_blocklen = 32;

  000ae	c7 44 24 3c 20
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 32 ; 00000020H

; 1140 :       break;

  000b6	eb 18		 jmp	 SHORT $LN5@s390_klmd_
$LN22@s390_klmd_:

; 1141 :     }
; 1142 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1143 : 
; 1144 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1145 :     case 3: /* sha-512 */
; 1146 :     {
; 1147 :       mbllen = 16;

  000b8	c7 44 24 34 10
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 16

; 1148 :       message_blocklen = 128;

  000c0	c7 44 24 38 80
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 128 ; 00000080H

; 1149 :       parameter_blocklen = 64;

  000c8	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 64 ; 00000040H
$LN5@s390_klmd_:

; 1150 :     }
; 1151 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1152 : 
; 1153 :   }
; 1154 : 
; 1155 :   /* Process intermediate message blocks */
; 1156 :   if(unlikely(GR_A(r2 + 1, regs) >= (unsigned) message_blocklen))

  000d0	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000d7	ff c0		 inc	 eax
  000d9	48 98		 cdqe
  000db	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	8b 54 24 38	 mov	 edx, DWORD PTR message_blocklen$[rsp]
  000e7	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  000ee	72 0a		 jb	 SHORT $LN40@s390_klmd_
  000f0	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000f8	eb 08		 jmp	 SHORT $LN41@s390_klmd_
$LN40@s390_klmd_:
  000fa	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN41@s390_klmd_:
  00102	83 7c 24 54 00	 cmp	 DWORD PTR tv90[rsp], 0
  00107	74 37		 je	 SHORT $LN23@s390_klmd_

; 1157 :   {
; 1158 :     ARCH_DEP(kimd_sha)(r1, r2, regs, 1);

  00109	41 b9 01 00 00
	00		 mov	 r9d, 1
  0010f	4c 8b 84 24 90
	03 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00117	8b 94 24 88 03
	00 00		 mov	 edx, DWORD PTR r2$[rsp]
  0011e	8b 8c 24 80 03
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00125	e8 00 00 00 00	 call	 s390_kimd_sha

; 1159 :     if(regs->psw.cc == 3)

  0012a	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00132	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00136	83 f8 03	 cmp	 eax, 3
  00139	75 05		 jne	 SHORT $LN24@s390_klmd_

; 1160 :       return;

  0013b	e9 06 05 00 00	 jmp	 $LN1@s390_klmd_
$LN24@s390_klmd_:
$LN23@s390_klmd_:

; 1161 :   }
; 1162 : 
; 1163 :   /* Test writeability output chaining value */
; 1164 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  00140	8b 44 24 3c	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00144	ff c8		 dec	 eax
  00146	b9 08 00 00 00	 mov	 ecx, 8
  0014b	48 6b c9 01	 imul	 rcx, rcx, 1
  0014f	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	4c 8b 84 24 90
	03 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0015f	45 8b 80 90 00
	00 00		 mov	 r8d, DWORD PTR [r8+144]
  00166	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  0016d	41 23 c8	 and	 ecx, r8d
  00170	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00178	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0017d	41 b9 02 00 00
	00		 mov	 r9d, 2
  00183	44 8b c0	 mov	 r8d, eax
  00186	ba 01 00 00 00	 mov	 edx, 1
  0018b	e8 00 00 00 00	 call	 s390_validate_operand

; 1165 : 
; 1166 :   /* Fetch the parameter block */
; 1167 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen + mbllen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00190	b8 08 00 00 00	 mov	 eax, 8
  00195	48 6b c0 01	 imul	 rax, rax, 1
  00199	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a1	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a9	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  001af	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001b6	23 c2		 and	 eax, edx
  001b8	8b 4c 24 3c	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001bc	8b 54 24 34	 mov	 edx, DWORD PTR mbllen$[rsp]
  001c0	8d 4c 11 ff	 lea	 ecx, DWORD PTR [rcx+rdx-1]
  001c4	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001cc	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001d1	41 b9 01 00 00
	00		 mov	 r9d, 1
  001d7	44 8b c0	 mov	 r8d, eax
  001da	0f b6 d1	 movzx	 edx, cl
  001dd	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001e5	e8 00 00 00 00	 call	 s390_vfetchc

; 1168 : 
; 1169 : #ifdef OPTION_KLMD_DEBUG
; 1170 :   if(parameter_blocklen > 32)
; 1171 :   {
; 1172 :     LOGBYTE2("icv   :", parameter_block, 16, parameter_blocklen / 16);
; 1173 :   }
; 1174 :   else
; 1175 :   {
; 1176 :     LOGBYTE("icv   :", parameter_block, parameter_blocklen);
; 1177 :   }
; 1178 :   LOGBYTE("mbl   :", &parameter_block[parameter_blocklen], mbllen);
; 1179 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1180 : 
; 1181 :   /* Set initial chaining value */
; 1182 :   switch(fc)

  001ea	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  001ee	89 44 24 48	 mov	 DWORD PTR tv157[rsp], eax
  001f2	83 7c 24 48 01	 cmp	 DWORD PTR tv157[rsp], 1
  001f7	74 10		 je	 SHORT $LN25@s390_klmd_
  001f9	83 7c 24 48 02	 cmp	 DWORD PTR tv157[rsp], 2
  001fe	74 20		 je	 SHORT $LN26@s390_klmd_
  00200	83 7c 24 48 03	 cmp	 DWORD PTR tv157[rsp], 3
  00205	74 30		 je	 SHORT $LN27@s390_klmd_
  00207	eb 43		 jmp	 SHORT $LN7@s390_klmd_
$LN25@s390_klmd_:

; 1183 :   {
; 1184 :     case 1: /* sha-1 */
; 1185 :     {
; 1186 :       sha1_seticv(&sha1_ctx, parameter_block);

  00209	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00211	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00219	e8 00 00 00 00	 call	 sha1_seticv

; 1187 :       break;

  0021e	eb 2c		 jmp	 SHORT $LN7@s390_klmd_
$LN26@s390_klmd_:

; 1188 :     }
; 1189 : 
; 1190 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1191 :     case 2: /* sha-256 */
; 1192 :     {
; 1193 :       sha256_seticv(&sha2_ctx, parameter_block);

  00220	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00228	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00230	e8 00 00 00 00	 call	 sha256_seticv

; 1194 :       break;

  00235	eb 15		 jmp	 SHORT $LN7@s390_klmd_
$LN27@s390_klmd_:

; 1195 :     }
; 1196 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1197 : 
; 1198 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1199 :     case 3: /* sha-512 */
; 1200 :     {
; 1201 :       sha512_seticv(&sha512_ctx, parameter_block);

  00237	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0023f	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00247	e8 00 00 00 00	 call	 sha512_seticv
$LN7@s390_klmd_:

; 1202 :       break;
; 1203 :     }
; 1204 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1205 : 
; 1206 :   }
; 1207 : 
; 1208 :   /* Fetch and process possible last block of data */
; 1209 :   if(likely(GR_A(r2 + 1, regs)))

  0024c	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00253	ff c0		 inc	 eax
  00255	48 98		 cdqe
  00257	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025f	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00267	74 0a		 je	 SHORT $LN42@s390_klmd_
  00269	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv180[rsp], 1
  00271	eb 08		 jmp	 SHORT $LN43@s390_klmd_
$LN42@s390_klmd_:
  00273	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv180[rsp], 0
$LN43@s390_klmd_:
  0027b	83 7c 24 58 00	 cmp	 DWORD PTR tv180[rsp], 0
  00280	74 6c		 je	 SHORT $LN28@s390_klmd_

; 1210 :   {
; 1211 :     ARCH_DEP(vfetchc)(message_block, GR_A(r2 + 1, regs) - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00282	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0028a	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00292	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0029a	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  002a0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002a7	23 c2		 and	 eax, edx
  002a9	8b 8c 24 88 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  002b0	ff c1		 inc	 ecx
  002b2	48 63 c9	 movsxd	 rcx, ecx
  002b5	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002bd	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  002c4	ff c9		 dec	 ecx
  002c6	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002ce	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002d3	44 8b 8c 24 88
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002db	44 8b c0	 mov	 r8d, eax
  002de	0f b6 d1	 movzx	 edx, cl
  002e1	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002e9	e8 00 00 00 00	 call	 s390_vfetchc
$LN28@s390_klmd_:

; 1212 : 
; 1213 : #ifdef OPTION_KLMD_DEBUG
; 1214 :     if(GR_A(r2 + 1, regs) > 32)
; 1215 :     {
; 1216 :       LOGBYTE("input :", message_block, 32);
; 1217 :       LOGBYTE("       ", &message_block[32], (int) GR_A(r2 + 1, regs) - 32);
; 1218 :     }
; 1219 :     else
; 1220 :       LOGBYTE("input :", message_block, (int) GR_A(r2 + 1, regs));
; 1221 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1222 : 
; 1223 :   }
; 1224 : 
; 1225 :   /* Do the padding */
; 1226 :   i = GR_A(r2 + 1, regs);

  002ee	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002f5	ff c0		 inc	 eax
  002f7	48 98		 cdqe
  002f9	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00301	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00308	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 1227 :   if(unlikely(i >= (message_blocklen - mbllen)))

  0030c	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  00310	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  00314	2b c8		 sub	 ecx, eax
  00316	8b c1		 mov	 eax, ecx
  00318	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0031c	7c 0a		 jl	 SHORT $LN46@s390_klmd_
  0031e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
  00326	eb 08		 jmp	 SHORT $LN47@s390_klmd_
$LN46@s390_klmd_:
  00328	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
$LN47@s390_klmd_:
  00330	83 7c 24 5c 00	 cmp	 DWORD PTR tv214[rsp], 0
  00335	0f 84 0b 01 00
	00		 je	 $LN29@s390_klmd_

; 1228 :   {
; 1229 :     message_block[i++] = 0x80;

  0033b	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00340	c6 84 04 d0 02
	00 00 80	 mov	 BYTE PTR message_block$[rsp+rax], 128 ; 00000080H
  00348	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0034c	ff c0		 inc	 eax
  0034e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN9@s390_klmd_:

; 1230 :     while(i < message_blocklen)

  00352	8b 44 24 38	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  00356	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0035a	7d 35		 jge	 SHORT $LN10@s390_klmd_

; 1231 :       message_block[i++] = 0x00;

  0035c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00361	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  00366	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0036a	ff c0		 inc	 eax
  0036c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00370	48 81 7c 24 60
	80 00 00 00	 cmp	 QWORD PTR $T1[rsp], 128	; 00000080H
  00379	73 02		 jae	 SHORT $LN48@s390_klmd_
  0037b	eb 05		 jmp	 SHORT $LN49@s390_klmd_
$LN48@s390_klmd_:
  0037d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN49@s390_klmd_:
  00382	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  00387	c6 84 04 d0 02
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  0038f	eb c1		 jmp	 SHORT $LN9@s390_klmd_
$LN10@s390_klmd_:

; 1232 :     switch(fc)

  00391	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  00395	89 44 24 4c	 mov	 DWORD PTR tv226[rsp], eax
  00399	83 7c 24 4c 01	 cmp	 DWORD PTR tv226[rsp], 1
  0039e	74 10		 je	 SHORT $LN31@s390_klmd_
  003a0	83 7c 24 4c 02	 cmp	 DWORD PTR tv226[rsp], 2
  003a5	74 20		 je	 SHORT $LN32@s390_klmd_
  003a7	83 7c 24 4c 03	 cmp	 DWORD PTR tv226[rsp], 3
  003ac	74 30		 je	 SHORT $LN33@s390_klmd_
  003ae	eb 43		 jmp	 SHORT $LN11@s390_klmd_
$LN31@s390_klmd_:

; 1233 :     {
; 1234 :       case 1: /* sha-1 */
; 1235 :       {
; 1236 :         SHA1Transform(sha1_ctx.state, message_block);

  003b0	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003b8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  003c0	e8 00 00 00 00	 call	 SHA1Transform

; 1237 :         break;

  003c5	eb 2c		 jmp	 SHORT $LN11@s390_klmd_
$LN32@s390_klmd_:

; 1238 :       }
; 1239 : 
; 1240 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1241 :       case 2: /* sha-256 */
; 1242 :       {
; 1243 :         SHA256Transform(sha2_ctx.state.st32, message_block);

  003c7	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003cf	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  003d7	e8 00 00 00 00	 call	 SHA256Transform

; 1244 :         break;

  003dc	eb 15		 jmp	 SHORT $LN11@s390_klmd_
$LN33@s390_klmd_:

; 1245 :       }
; 1246 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1247 : 
; 1248 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1249 :       case 3: /* sha-512 */
; 1250 :       {
; 1251 :         SHA512Transform(sha512_ctx.state.st64, message_block);

  003de	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003e6	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  003ee	e8 00 00 00 00	 call	 SHA512Transform
$LN11@s390_klmd_:

; 1252 :         break;
; 1253 :       }
; 1254 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1255 : 
; 1256 :     }
; 1257 :     for(i = 0; i < message_blocklen - mbllen; i++)

  003f3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003fb	eb 0a		 jmp	 SHORT $LN15@s390_klmd_
$LN13@s390_klmd_:
  003fd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00401	ff c0		 inc	 eax
  00403	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN15@s390_klmd_:
  00407	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  0040b	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  0040f	2b c8		 sub	 ecx, eax
  00411	8b c1		 mov	 eax, ecx
  00413	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00417	7d 2b		 jge	 SHORT $LN14@s390_klmd_

; 1258 :       message_block[i] = 0x00;

  00419	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0041e	48 89 44 24 68	 mov	 QWORD PTR $T2[rsp], rax
  00423	48 81 7c 24 68
	80 00 00 00	 cmp	 QWORD PTR $T2[rsp], 128	; 00000080H
  0042c	73 02		 jae	 SHORT $LN50@s390_klmd_
  0042e	eb 05		 jmp	 SHORT $LN51@s390_klmd_
$LN50@s390_klmd_:
  00430	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN51@s390_klmd_:
  00435	48 8b 44 24 68	 mov	 rax, QWORD PTR $T2[rsp]
  0043a	c6 84 04 d0 02
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  00442	eb b9		 jmp	 SHORT $LN13@s390_klmd_
$LN14@s390_klmd_:

; 1259 :   }

  00444	eb 5e		 jmp	 SHORT $LN30@s390_klmd_
$LN29@s390_klmd_:

; 1260 :   else
; 1261 :   {
; 1262 :     message_block[i++] = 0x80;

  00446	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0044b	c6 84 04 d0 02
	00 00 80	 mov	 BYTE PTR message_block$[rsp+rax], 128 ; 00000080H
  00453	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00457	ff c0		 inc	 eax
  00459	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@s390_klmd_:

; 1263 :     while(i < message_blocklen - mbllen)

  0045d	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  00461	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  00465	2b c8		 sub	 ecx, eax
  00467	8b c1		 mov	 eax, ecx
  00469	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0046d	7d 35		 jge	 SHORT $LN17@s390_klmd_

; 1264 :       message_block[i++] = 0x00;

  0046f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00474	48 89 44 24 70	 mov	 QWORD PTR $T3[rsp], rax
  00479	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0047d	ff c0		 inc	 eax
  0047f	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00483	48 81 7c 24 70
	80 00 00 00	 cmp	 QWORD PTR $T3[rsp], 128	; 00000080H
  0048c	73 02		 jae	 SHORT $LN52@s390_klmd_
  0048e	eb 05		 jmp	 SHORT $LN53@s390_klmd_
$LN52@s390_klmd_:
  00490	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN53@s390_klmd_:
  00495	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
  0049a	c6 84 04 d0 02
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  004a2	eb b9		 jmp	 SHORT $LN16@s390_klmd_
$LN17@s390_klmd_:
$LN30@s390_klmd_:

; 1265 :   }
; 1266 : 
; 1267 :   /* Set the message bit length */
; 1268 :   memcpy(&message_block[message_blocklen - mbllen], &parameter_block[parameter_blocklen], mbllen);

  004a4	48 63 44 24 34	 movsxd	 rax, DWORD PTR mbllen$[rsp]
  004a9	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR parameter_blocklen$[rsp]
  004ae	48 8d 8c 0c 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  004b6	8b 54 24 34	 mov	 edx, DWORD PTR mbllen$[rsp]
  004ba	44 8b 44 24 38	 mov	 r8d, DWORD PTR message_blocklen$[rsp]
  004bf	44 2b c2	 sub	 r8d, edx
  004c2	41 8b d0	 mov	 edx, r8d
  004c5	48 63 d2	 movsxd	 rdx, edx
  004c8	48 8d 94 14 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp+rdx]
  004d0	48 8b fa	 mov	 rdi, rdx
  004d3	48 8b f1	 mov	 rsi, rcx
  004d6	48 8b c8	 mov	 rcx, rax
  004d9	f3 a4		 rep movsb

; 1269 : 
; 1270 :   /* Calculate and store the message digest */
; 1271 :   switch(fc)

  004db	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  004df	89 44 24 50	 mov	 DWORD PTR tv253[rsp], eax
  004e3	83 7c 24 50 01	 cmp	 DWORD PTR tv253[rsp], 1
  004e8	74 13		 je	 SHORT $LN34@s390_klmd_
  004ea	83 7c 24 50 02	 cmp	 DWORD PTR tv253[rsp], 2
  004ef	74 38		 je	 SHORT $LN35@s390_klmd_
  004f1	83 7c 24 50 03	 cmp	 DWORD PTR tv253[rsp], 3
  004f6	74 5d		 je	 SHORT $LN36@s390_klmd_
  004f8	e9 82 00 00 00	 jmp	 $LN18@s390_klmd_
$LN34@s390_klmd_:

; 1272 :   {
; 1273 :     case 1: /* sha-1 */
; 1274 :     {
; 1275 :       SHA1Transform(sha1_ctx.state, message_block);

  004fd	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00505	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  0050d	e8 00 00 00 00	 call	 SHA1Transform

; 1276 :       sha1_getcv(&sha1_ctx, parameter_block);

  00512	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0051a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00522	e8 00 00 00 00	 call	 sha1_getcv

; 1277 :       break;

  00527	eb 56		 jmp	 SHORT $LN18@s390_klmd_
$LN35@s390_klmd_:

; 1278 :     }
; 1279 : 
; 1280 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1281 :     case 2: /* sha-256 */
; 1282 :     {
; 1283 :       SHA256Transform(sha2_ctx.state.st32, message_block);

  00529	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00531	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00539	e8 00 00 00 00	 call	 SHA256Transform

; 1284 :       sha256_getcv(&sha2_ctx, parameter_block);

  0053e	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00546	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  0054e	e8 00 00 00 00	 call	 sha256_getcv

; 1285 :       break;

  00553	eb 2a		 jmp	 SHORT $LN18@s390_klmd_
$LN36@s390_klmd_:

; 1286 :     }
; 1287 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1288 : 
; 1289 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1290 :     case 3: /* sha-512 */
; 1291 :     {
; 1292 :       SHA512Transform(sha512_ctx.state.st64, message_block);

  00555	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0055d	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00565	e8 00 00 00 00	 call	 SHA512Transform

; 1293 :       sha512_getcv(&sha512_ctx, parameter_block);

  0056a	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00572	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  0057a	e8 00 00 00 00	 call	 sha512_getcv
$LN18@s390_klmd_:

; 1294 :       break;
; 1295 :     }
; 1296 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1297 : 
; 1298 :   }
; 1299 :   ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0057f	b8 08 00 00 00	 mov	 eax, 8
  00584	48 6b c0 01	 imul	 rax, rax, 1
  00588	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00590	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00598	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  0059e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  005a5	23 c2		 and	 eax, edx
  005a7	8b 4c 24 3c	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  005ab	ff c9		 dec	 ecx
  005ad	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005b5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  005ba	41 b9 01 00 00
	00		 mov	 r9d, 1
  005c0	44 8b c0	 mov	 r8d, eax
  005c3	0f b6 d1	 movzx	 edx, cl
  005c6	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  005ce	e8 00 00 00 00	 call	 s390_vstorec

; 1300 : 
; 1301 : #ifdef OPTION_KLMD_DEBUG
; 1302 :   if(parameter_blocklen > 32)
; 1303 :   {
; 1304 :     LOGBYTE2("md    :", parameter_block, 16, parameter_blocklen / 16);
; 1305 :   }
; 1306 :   else
; 1307 :   {
; 1308 :     LOGBYTE("md    :", parameter_block, parameter_blocklen);
; 1309 :   }
; 1310 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1311 : 
; 1312 :   /* Update registers */
; 1313 :   SET_GR_A(r2, regs, GR_A(r2, regs) + GR_A(r2 + 1, regs));

  005d3	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005db	8b 8c 24 88 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005e2	ff c1		 inc	 ecx
  005e4	48 63 c9	 movsxd	 rcx, ecx
  005e7	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005ef	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  005f6	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005fe	03 84 ca 80 02
	00 00		 add	 eax, DWORD PTR [rdx+rcx*8+640]
  00605	48 63 8c 24 88
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0060d	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00615	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1314 :   SET_GR_A(r2 + 1, regs, 0);

  0061c	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00623	ff c0		 inc	 eax
  00625	48 98		 cdqe
  00627	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0062f	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1315 : 
; 1316 : #ifdef OPTION_KLMD_DEBUG
; 1317 :   WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1318 :   WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1319 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1320 : 
; 1321 :   /* Set condition code */
; 1322 :   regs->psw.cc = 0;

  0063a	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00642	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s390_klmd_:
$LN37@s390_klmd_:

; 1323 : }

  00646	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0064e	48 33 cc	 xor	 rcx, rsp
  00651	e8 00 00 00 00	 call	 __security_check_cookie
  00656	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  0065d	5f		 pop	 rdi
  0065e	5e		 pop	 rsi
  0065f	c3		 ret	 0
s390_klmd_sha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
message_blocklen$ = 48
parameter_blocklen$ = 52
tv70 = 56
tv175 = 60
crypted$ = 64
fc$ = 68
tv201 = 72
tv93 = 76
tv136 = 80
tv147 = 84
tv270 = 88
tv276 = 92
sha1_ctx$ = 96
sha2_ctx$ = 192
sha512_ctx$ = 400
parameter_block$ = 608
message_block$ = 672
__$ArrayPad$ = 800
r1$ = 832
r2$ = 840
regs$ = 848
klmd$ = 856
s390_kimd_sha PROC

; 837  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 38 03
	00 00		 sub	 rsp, 824		; 00000338H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 838  :   SHA1_CTX sha1_ctx;
; 839  : 
; 840  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 841  :   SHA2_CTX sha2_ctx;
; 842  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 843  : 
; 844  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 845  :   SHA2_CTX sha512_ctx;
; 846  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 847  : 
; 848  :   int crypted;
; 849  :   int fc;
; 850  :   BYTE message_block[128];
; 851  :   int message_blocklen = 0;

  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 0

; 852  :   BYTE parameter_block[64];
; 853  :   int parameter_blocklen = 0;

  00033	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 0
$LN4@s390_kimd_:

; 854  : 
; 855  :   UNREFERENCED(r1);

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN4@s390_kimd_

; 856  : 
; 857  :   /* Initialize values */
; 858  :   fc = GR0_fc(regs);

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	48 6b c0 00	 imul	 rax, rax, 0
  0004a	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00059	83 e0 7f	 and	 eax, 127		; 0000007fH
  0005c	89 44 24 44	 mov	 DWORD PTR fc$[rsp], eax

; 859  :   switch(fc)

  00060	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  00064	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
  00068	83 7c 24 38 01	 cmp	 DWORD PTR tv70[rsp], 1
  0006d	74 10		 je	 SHORT $LN14@s390_kimd_
  0006f	83 7c 24 38 02	 cmp	 DWORD PTR tv70[rsp], 2
  00074	74 1b		 je	 SHORT $LN15@s390_kimd_
  00076	83 7c 24 38 03	 cmp	 DWORD PTR tv70[rsp], 3
  0007b	74 26		 je	 SHORT $LN16@s390_kimd_
  0007d	eb 34		 jmp	 SHORT $LN5@s390_kimd_
$LN14@s390_kimd_:

; 860  :   {
; 861  :     case 1: /* sha-1 */
; 862  :     {
; 863  :       message_blocklen = 64;

  0007f	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 864  :       parameter_blocklen = 20;

  00087	c7 44 24 34 14
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 20

; 865  :       break;

  0008f	eb 22		 jmp	 SHORT $LN5@s390_kimd_
$LN15@s390_kimd_:

; 866  :     }
; 867  : 
; 868  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 869  :     case 2: /* sha-256 */
; 870  :     {
; 871  :       message_blocklen = 64;

  00091	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 872  :       parameter_blocklen = 32;

  00099	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 32 ; 00000020H

; 873  :       break;

  000a1	eb 10		 jmp	 SHORT $LN5@s390_kimd_
$LN16@s390_kimd_:

; 874  :     }
; 875  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 876  : 
; 877  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 878  :     case 3: /* sha-512 */
; 879  :     {
; 880  :       message_blocklen = 128;

  000a3	c7 44 24 30 80
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 128 ; 00000080H

; 881  :       parameter_blocklen = 64;

  000ab	c7 44 24 34 40
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 64 ; 00000040H
$LN5@s390_kimd_:

; 882  :     }
; 883  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 884  : 
; 885  :   }
; 886  : 
; 887  :   /* Check special conditions */
; 888  :   if(unlikely(!klmd && (GR_A(r2 + 1, regs) % message_blocklen)))

  000b3	83 bc 24 58 03
	00 00 00	 cmp	 DWORD PTR klmd$[rsp], 0
  000bb	75 30		 jne	 SHORT $LN28@s390_kimd_
  000bd	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000c4	ff c0		 inc	 eax
  000c6	48 98		 cdqe
  000c8	33 d2		 xor	 edx, edx
  000ca	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d9	f7 74 24 30	 div	 DWORD PTR message_blocklen$[rsp]
  000dd	8b c2		 mov	 eax, edx
  000df	85 c0		 test	 eax, eax
  000e1	74 0a		 je	 SHORT $LN28@s390_kimd_
  000e3	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000eb	eb 08		 jmp	 SHORT $LN31@s390_kimd_
$LN28@s390_kimd_:
  000ed	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN31@s390_kimd_:
  000f5	83 7c 24 4c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000fa	74 13		 je	 SHORT $LN17@s390_kimd_

; 889  :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000fc	ba 06 00 00 00	 mov	 edx, 6
  00101	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_program_interrupt
$LN17@s390_kimd_:

; 890  : 
; 891  :   /* Return with cc 0 on zero length */
; 892  :   if(unlikely(!GR_A(r2 + 1, regs)))

  0010f	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00116	ff c0		 inc	 eax
  00118	48 98		 cdqe
  0011a	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0012a	75 0a		 jne	 SHORT $LN32@s390_kimd_
  0012c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00134	eb 08		 jmp	 SHORT $LN33@s390_kimd_
$LN32@s390_kimd_:
  00136	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN33@s390_kimd_:
  0013e	83 7c 24 50 00	 cmp	 DWORD PTR tv136[rsp], 0
  00143	74 0a		 je	 SHORT $LN36@s390_kimd_
  00145	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  0014d	eb 08		 jmp	 SHORT $LN37@s390_kimd_
$LN36@s390_kimd_:
  0014f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN37@s390_kimd_:
  00157	83 7c 24 54 00	 cmp	 DWORD PTR tv147[rsp], 0
  0015c	74 11		 je	 SHORT $LN18@s390_kimd_

; 893  :   {
; 894  :     regs->psw.cc = 0;

  0015e	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 895  :     return;

  0016a	e9 59 03 00 00	 jmp	 $LN1@s390_kimd_
$LN18@s390_kimd_:

; 896  :   }
; 897  : 
; 898  :   /* Test writeability output chaining value */
; 899  :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  0016f	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00173	ff c8		 dec	 eax
  00175	b9 08 00 00 00	 mov	 ecx, 8
  0017a	48 6b c9 01	 imul	 rcx, rcx, 1
  0017e	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00186	4c 8b 84 24 50
	03 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0018e	45 8b 80 90 00
	00 00		 mov	 r8d, DWORD PTR [r8+144]
  00195	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  0019c	41 23 c8	 and	 ecx, r8d
  0019f	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001a7	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ac	41 b9 02 00 00
	00		 mov	 r9d, 2
  001b2	44 8b c0	 mov	 r8d, eax
  001b5	ba 01 00 00 00	 mov	 edx, 1
  001ba	e8 00 00 00 00	 call	 s390_validate_operand

; 900  : 
; 901  :   /* Fetch the parameter block */
; 902  :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001bf	b8 08 00 00 00	 mov	 eax, 8
  001c4	48 6b c0 01	 imul	 rax, rax, 1
  001c8	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001d0	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d8	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  001de	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e5	23 c2		 and	 eax, edx
  001e7	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001eb	ff c9		 dec	 ecx
  001ed	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001fa	41 b9 01 00 00
	00		 mov	 r9d, 1
  00200	44 8b c0	 mov	 r8d, eax
  00203	0f b6 d1	 movzx	 edx, cl
  00206	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0020e	e8 00 00 00 00	 call	 s390_vfetchc

; 903  : 
; 904  : #ifdef OPTION_KIMD_DEBUG
; 905  :   if(parameter_blocklen > 32)
; 906  :   {
; 907  :     LOGBYTE2("icv   :", parameter_block, 16, parameter_blocklen / 16);
; 908  :   }
; 909  :   else
; 910  :   {
; 911  :     LOGBYTE("icv   :", parameter_block, parameter_blocklen);
; 912  :   }
; 913  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 914  : 
; 915  :   /* Set initial chaining value */
; 916  :   switch(fc)

  00213	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  00217	89 44 24 3c	 mov	 DWORD PTR tv175[rsp], eax
  0021b	83 7c 24 3c 01	 cmp	 DWORD PTR tv175[rsp], 1
  00220	74 10		 je	 SHORT $LN19@s390_kimd_
  00222	83 7c 24 3c 02	 cmp	 DWORD PTR tv175[rsp], 2
  00227	74 1d		 je	 SHORT $LN20@s390_kimd_
  00229	83 7c 24 3c 03	 cmp	 DWORD PTR tv175[rsp], 3
  0022e	74 2d		 je	 SHORT $LN21@s390_kimd_
  00230	eb 40		 jmp	 SHORT $LN7@s390_kimd_
$LN19@s390_kimd_:

; 917  :   {
; 918  :     case 1: /* sha-1 */
; 919  :     {
; 920  :       sha1_seticv(&sha1_ctx, parameter_block);

  00232	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0023a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  0023f	e8 00 00 00 00	 call	 sha1_seticv

; 921  :       break;

  00244	eb 2c		 jmp	 SHORT $LN7@s390_kimd_
$LN20@s390_kimd_:

; 922  :     }
; 923  : 
; 924  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 925  :     case 2: /* sha-256 */
; 926  :     {
; 927  :       sha256_seticv(&sha2_ctx, parameter_block);

  00246	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0024e	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00256	e8 00 00 00 00	 call	 sha256_seticv

; 928  :       break;

  0025b	eb 15		 jmp	 SHORT $LN7@s390_kimd_
$LN21@s390_kimd_:

; 929  :     }
; 930  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 931  : 
; 932  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 933  :     case 3: /* sha-512 */
; 934  :     {
; 935  :       sha512_seticv(&sha512_ctx, parameter_block);

  0025d	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00265	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  0026d	e8 00 00 00 00	 call	 sha512_seticv
$LN7@s390_kimd_:

; 936  :       break;
; 937  :     }
; 938  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 939  : 
; 940  :   }
; 941  : 
; 942  :   /* Try to process the CPU-determined amount of data */
; 943  :   for(crypted = 0; crypted < PROCESS_MAX; crypted += message_blocklen)

  00272	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0027a	eb 10		 jmp	 SHORT $LN11@s390_kimd_
$LN9@s390_kimd_:
  0027c	8b 44 24 30	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  00280	8b 4c 24 40	 mov	 ecx, DWORD PTR crypted$[rsp]
  00284	03 c8		 add	 ecx, eax
  00286	8b c1		 mov	 eax, ecx
  00288	89 44 24 40	 mov	 DWORD PTR crypted$[rsp], eax
$LN11@s390_kimd_:
  0028c	81 7c 24 40 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00294	0f 8d 22 02 00
	00		 jge	 $LN10@s390_kimd_

; 944  :   {
; 945  :     /* Fetch and process a block of data */
; 946  :     ARCH_DEP(vfetchc)(message_block, message_blocklen - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0029a	48 63 84 24 48
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002a2	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002aa	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002b2	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  002b8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002bf	23 c2		 and	 eax, edx
  002c1	8b 4c 24 30	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  002c5	ff c9		 dec	 ecx
  002c7	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002cf	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002d4	44 8b 8c 24 48
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002dc	44 8b c0	 mov	 r8d, eax
  002df	0f b6 d1	 movzx	 edx, cl
  002e2	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002ea	e8 00 00 00 00	 call	 s390_vfetchc

; 947  : 
; 948  : #ifdef OPTION_KIMD_DEBUG
; 949  :     LOGBYTE2("input :", message_block, 16, message_blocklen / 16);
; 950  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 951  : 
; 952  :     switch(fc)

  002ef	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  002f3	89 44 24 48	 mov	 DWORD PTR tv201[rsp], eax
  002f7	83 7c 24 48 01	 cmp	 DWORD PTR tv201[rsp], 1
  002fc	74 10		 je	 SHORT $LN22@s390_kimd_
  002fe	83 7c 24 48 02	 cmp	 DWORD PTR tv201[rsp], 2
  00303	74 2f		 je	 SHORT $LN23@s390_kimd_
  00305	83 7c 24 48 03	 cmp	 DWORD PTR tv201[rsp], 3
  0030a	74 54		 je	 SHORT $LN24@s390_kimd_
  0030c	eb 7c		 jmp	 SHORT $LN12@s390_kimd_
$LN22@s390_kimd_:

; 953  :     {
; 954  :       case 1: /* sha-1 */
; 955  :       {
; 956  :         SHA1Transform(sha1_ctx.state, message_block);

  0030e	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00316	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  0031b	e8 00 00 00 00	 call	 SHA1Transform

; 957  :         sha1_getcv(&sha1_ctx, parameter_block);

  00320	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00328	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  0032d	e8 00 00 00 00	 call	 sha1_getcv

; 958  :         break;

  00332	eb 56		 jmp	 SHORT $LN12@s390_kimd_
$LN23@s390_kimd_:

; 959  :       }
; 960  : 
; 961  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 962  :       case 2: /* sha-256 */
; 963  :       {
; 964  :         SHA256Transform(sha2_ctx.state.st32, message_block);

  00334	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0033c	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00344	e8 00 00 00 00	 call	 SHA256Transform

; 965  :         sha256_getcv(&sha2_ctx, parameter_block);

  00349	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00351	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00359	e8 00 00 00 00	 call	 sha256_getcv

; 966  :         break;

  0035e	eb 2a		 jmp	 SHORT $LN12@s390_kimd_
$LN24@s390_kimd_:

; 967  :       }
; 968  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 969  : 
; 970  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 971  :       case 3: /* sha-512 */
; 972  :       {
; 973  :         SHA512Transform(sha512_ctx.state.st64, message_block);

  00360	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00368	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00370	e8 00 00 00 00	 call	 SHA512Transform

; 974  :         sha512_getcv(&sha512_ctx, parameter_block);

  00375	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0037d	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00385	e8 00 00 00 00	 call	 sha512_getcv
$LN12@s390_kimd_:

; 975  :         break;
; 976  :       }
; 977  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 978  : 
; 979  :     }
; 980  : 
; 981  :     /* Store the output chaining value */
; 982  :     ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0038a	b8 08 00 00 00	 mov	 eax, 8
  0038f	48 6b c0 01	 imul	 rax, rax, 1
  00393	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039b	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003a3	8b 92 90 00 00
	00		 mov	 edx, DWORD PTR [rdx+144]
  003a9	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  003b0	23 c2		 and	 eax, edx
  003b2	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  003b6	ff c9		 dec	 ecx
  003b8	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003c0	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003c5	41 b9 01 00 00
	00		 mov	 r9d, 1
  003cb	44 8b c0	 mov	 r8d, eax
  003ce	0f b6 d1	 movzx	 edx, cl
  003d1	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  003d9	e8 00 00 00 00	 call	 s390_vstorec

; 983  : 
; 984  : #ifdef OPTION_KIMD_DEBUG
; 985  :     if(parameter_blocklen > 32)
; 986  :     {
; 987  :       LOGBYTE2("ocv   :", parameter_block, 16, parameter_blocklen / 16);
; 988  :     }
; 989  :     else
; 990  :     {
; 991  :       LOGBYTE("ocv   :", parameter_block, parameter_blocklen);
; 992  :     }
; 993  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 994  : 
; 995  :     /* Update the registers */
; 996  :     SET_GR_A(r2, regs, GR_A(r2, regs) + message_blocklen);

  003de	48 63 84 24 48
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003e6	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ee	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003f5	03 44 24 30	 add	 eax, DWORD PTR message_blocklen$[rsp]
  003f9	48 63 8c 24 48
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00401	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00409	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 997  :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - message_blocklen);

  00410	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00417	ff c0		 inc	 eax
  00419	48 98		 cdqe
  0041b	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00423	8b 54 24 30	 mov	 edx, DWORD PTR message_blocklen$[rsp]
  00427	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0042e	2b c2		 sub	 eax, edx
  00430	8b 8c 24 48 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00437	ff c1		 inc	 ecx
  00439	48 63 c9	 movsxd	 rcx, ecx
  0043c	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00444	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 998  : 
; 999  : #ifdef OPTION_KIMD_DEBUG
; 1000 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1001 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1002 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1003 : 
; 1004 :     /* check for end of data */
; 1005 :     if(unlikely(GR_A(r2 + 1, regs) < (unsigned) message_blocklen))

  0044b	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00452	ff c0		 inc	 eax
  00454	48 98		 cdqe
  00456	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045e	8b 54 24 30	 mov	 edx, DWORD PTR message_blocklen$[rsp]
  00462	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  00469	73 0a		 jae	 SHORT $LN40@s390_kimd_
  0046b	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv270[rsp], 1
  00473	eb 08		 jmp	 SHORT $LN41@s390_kimd_
$LN40@s390_kimd_:
  00475	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv270[rsp], 0
$LN41@s390_kimd_:
  0047d	83 7c 24 58 00	 cmp	 DWORD PTR tv270[rsp], 0
  00482	74 33		 je	 SHORT $LN25@s390_kimd_

; 1006 :     {
; 1007 :       if(unlikely(klmd))

  00484	83 bc 24 58 03
	00 00 00	 cmp	 DWORD PTR klmd$[rsp], 0
  0048c	74 0a		 je	 SHORT $LN44@s390_kimd_
  0048e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv276[rsp], 1
  00496	eb 08		 jmp	 SHORT $LN45@s390_kimd_
$LN44@s390_kimd_:
  00498	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv276[rsp], 0
$LN45@s390_kimd_:
  004a0	83 7c 24 5c 00	 cmp	 DWORD PTR tv276[rsp], 0
  004a5	74 02		 je	 SHORT $LN26@s390_kimd_

; 1008 :         return;

  004a7	eb 1f		 jmp	 SHORT $LN1@s390_kimd_
$LN26@s390_kimd_:

; 1009 :       regs->psw.cc = 0;

  004a9	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004b1	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1010 :       return;

  004b5	eb 11		 jmp	 SHORT $LN1@s390_kimd_
$LN25@s390_kimd_:

; 1011 :     }
; 1012 :   }

  004b7	e9 c0 fd ff ff	 jmp	 $LN9@s390_kimd_
$LN10@s390_kimd_:

; 1013 : 
; 1014 :   /* CPU-determined amount of data processed */
; 1015 :   regs->psw.cc = 3;

  004bc	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004c4	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s390_kimd_:

; 1016 : }

  004c8	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004d0	48 33 cc	 xor	 rcx, rsp
  004d3	e8 00 00 00 00	 call	 __security_check_cookie
  004d8	48 81 c4 38 03
	00 00		 add	 rsp, 824		; 00000338H
  004df	c3		 ret	 0
s390_kimd_sha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_validate_operand
_TEXT	SEGMENT
tv79 = 48
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s390_validate_operand PROC				; COMDAT

; 1376 : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s390_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0004c	b9 ff 0f 00 00	 mov	 ecx, 4095		; 00000fffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN6@s390_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN7@s390_valid
$LN6@s390_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@s390_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 42		 je	 SHORT $LN2@s390_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00083	23 81 90 00 00
	00		 and	 eax, DWORD PTR [rcx+144]
  00089	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00092	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00096	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  0009a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0009e	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  000a3	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a8	ba 01 00 00 00	 mov	 edx, 1
  000ad	8b c8		 mov	 ecx, eax
  000af	e8 00 00 00 00	 call	 s390_maddr_l
$LN2@s390_valid:

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }
; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );
; 1389 : #endif
; 1390 : }

  000b4	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000b8	c3		 ret	 0
s390_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
main1$ = 56
main2$ = 64
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s390_vfetchc PROC					; COMDAT

; 631  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN7@s390_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN8@s390_vfetc
$LN7@s390_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	74 62		 je	 SHORT $LN2@s390_vfetc

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );
; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00050	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00055	ff c0		 inc	 eax
  00057	48 98		 cdqe
  00059	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00061	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00065	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00069	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00071	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00079	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00081	48 8b d0	 mov	 rdx, rax
  00084	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0008b	e8 00 00 00 00	 call	 s390_maddr_l
  00090	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  00095	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0009a	ff c0		 inc	 eax
  0009c	48 98		 cdqe
  0009e	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  000a3	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  000a8	48 8b c8	 mov	 rcx, rax
  000ab	f3 a4		 rep movsb

; 640  :     }

  000ad	e9 f7 00 00 00	 jmp	 $LN3@s390_vfetc
$LN2@s390_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000b9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000be	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000c3	2b c8		 sub	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000cb	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000d0	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000dc	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000e0	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000e8	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000f0	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000f8	48 8b d0	 mov	 rdx, rax
  000fb	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00102	e8 00 00 00 00	 call	 s390_maddr_l
  00107	48 89 44 24 38	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  0010c	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00111	ff c0		 inc	 eax
  00113	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00117	48 98		 cdqe
  00119	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  0011d	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  00124	03 d1		 add	 edx, ecx
  00126	8b ca		 mov	 ecx, edx
  00128	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00130	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  00136	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0013e	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00142	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00146	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  0014e	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00156	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0015e	48 8b d0	 mov	 rdx, rax
  00161	e8 00 00 00 00	 call	 s390_maddr_l
  00166	48 89 44 24 40	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  0016b	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00170	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  00175	48 8b 74 24 38	 mov	 rsi, QWORD PTR main1$[rsp]
  0017a	48 8b c8	 mov	 rcx, rax
  0017d	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  0017f	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00184	ff c0		 inc	 eax
  00186	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0018a	48 98		 cdqe
  0018c	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00191	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  00196	48 03 d1	 add	 rdx, rcx
  00199	48 8b ca	 mov	 rcx, rdx
  0019c	48 8b f9	 mov	 rdi, rcx
  0019f	48 8b 74 24 40	 mov	 rsi, QWORD PTR main2$[rsp]
  001a4	48 8b c8	 mov	 rcx, rax
  001a7	f3 a4		 rep movsb
$LN3@s390_vfetc:

; 649  :     }
; 650  : }

  001a9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001ad	5f		 pop	 rdi
  001ae	5e		 pop	 rsi
  001af	c3		 ret	 0
s390_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s390_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
sk$ = 56
tv81 = 64
main1$ = 72
main2$ = 80
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s390_vstorec PROC					; COMDAT

; 489  : {

$LN9:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 0f 00 00	 mov	 edx, 4095		; 00000fffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN7@s390_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN8@s390_vstor
$LN7@s390_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN8@s390_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	74 6f		 je	 SHORT $LN2@s390_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00053	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005b	ff c0		 inc	 eax
  0005d	48 98		 cdqe
  0005f	48 89 44 24 40	 mov	 QWORD PTR tv81[rsp], rax
  00064	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0006c	ff c1		 inc	 ecx
  0006e	48 63 c9	 movsxd	 rcx, ecx
  00071	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00079	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  0007d	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00081	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00089	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00091	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00099	48 8b d1	 mov	 rdx, rcx
  0009c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a3	e8 00 00 00 00	 call	 s390_maddr_l
  000a8	48 8b f8	 mov	 rdi, rax
  000ab	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b3	48 8b 44 24 40	 mov	 rax, QWORD PTR tv81[rsp]
  000b8	48 8b c8	 mov	 rcx, rax
  000bb	f3 a4		 rep movsb

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );
; 499  :     }

  000bd	e9 29 01 00 00	 jmp	 $LN3@s390_vstor
$LN2@s390_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  000c2	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  000c9	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  000ce	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000d3	2b c8		 sub	 ecx, eax
  000d5	8b c1		 mov	 eax, ecx
  000d7	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  000db	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  000e0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e8	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ec	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000f0	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  000f8	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00100	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00108	48 8b d0	 mov	 rdx, rax
  0010b	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00112	e8 00 00 00 00	 call	 s390_maddr_l
  00117	48 89 44 24 48	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  0011c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00124	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  0012b	48 89 44 24 38	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  00130	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00138	ff c0		 inc	 eax
  0013a	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0013e	48 98		 cdqe
  00140	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00144	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0014b	03 d1		 add	 edx, ecx
  0014d	8b ca		 mov	 ecx, edx
  0014f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	23 8a 90 00 00
	00		 and	 ecx, DWORD PTR [rdx+144]
  0015d	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00165	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00169	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  0016d	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  00175	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0017d	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00185	48 8b d0	 mov	 rdx, rax
  00188	e8 00 00 00 00	 call	 s390_maddr_l
  0018d	48 89 44 24 50	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  00192	48 8b 44 24 38	 mov	 rax, QWORD PTR sk$[rsp]
  00197	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0019a	83 c8 06	 or	 eax, 6
  0019d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sk$[rsp]
  001a2	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  001a4	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001a9	48 8b 7c 24 48	 mov	 rdi, QWORD PTR main1$[rsp]
  001ae	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  001b6	48 8b c8	 mov	 rcx, rax
  001b9	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  001bb	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001c3	ff c0		 inc	 eax
  001c5	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001c9	48 98		 cdqe
  001cb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001d0	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  001d8	48 03 d1	 add	 rdx, rcx
  001db	48 8b ca	 mov	 rcx, rdx
  001de	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main2$[rsp]
  001e3	48 8b f1	 mov	 rsi, rcx
  001e6	48 8b c8	 mov	 rcx, rax
  001e9	f3 a4		 rep movsb
$LN3@s390_vstor:

; 512  :     }
; 513  : }

  001eb	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001ef	5f		 pop	 rdi
  001f0	5e		 pop	 rsi
  001f1	c3		 ret	 0
s390_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s390_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s390_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s390_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s390_maddr
$LN12@s390_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s390_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0c	 shr	 eax, 12
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s390_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s390_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s390_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s390_maddr
$LN4@s390_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s390_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s390_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s390_maddr
$LN6@s390_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 c0 7f	 and	 eax, 2143289344		; 7fc00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s390_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s390_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s390_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s390_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s390_maddr:
$LN7@s390_maddr:
$LN5@s390_maddr:
$LN3@s390_maddr:
$LN2@s390_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 36		 jne	 SHORT $LN10@s390_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s390_logical_to_main_l
  001cc	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s390_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d1	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001da	c3		 ret	 0
s390_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
msa$ = 48
i$1 = 52
tv94 = 56
tv297 = 60
tv306 = 64
fc$ = 68
r2$ = 72
r1$ = 76
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_perform_cryptographic_key_management_operation PROC

; 4940 : {

$LN33:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4941 :   int fc;
; 4942 :   int msa;
; 4943 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4944 :   {
; 4945 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4946 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4947 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4948 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4949 :     /**/ { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4950 :   };
; 4951 :   int r1;
; 4952 :   int r2;
; 4953 : 
; 4954 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 48	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 4c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_p:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_p
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_p:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_p

; 4955 :   PER_ZEROADDR_CHECK( regs, 1 );
; 4956 :   TXF_INSTR_CHECK( regs );
; 4957 : 
; 4958 :   /* The following is the same as doing a FACILITY_CHECK */
; 4959 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 30	 mov	 DWORD PTR msa$[rsp], eax

; 4960 :   if(msa < 3)

  0028e	83 7c 24 30 03	 cmp	 DWORD PTR msa$[rsp], 3
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_p

; 4961 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_p:

; 4962 : 
; 4963 : #ifdef OPTION_PCKMO_DEBUG
; 4964 :   WRMSG(HHC90100, "D", "PCKMO: perform cryptographic key management operation");
; 4965 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4966 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4967 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4968 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4969 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 4970 : 
; 4971 :   /* Privileged operation */
; 4972 :   PRIV_CHECK(regs);

  002a8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b0	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  002b4	83 e0 01	 and	 eax, 1
  002b7	85 c0		 test	 eax, eax
  002b9	74 1b		 je	 SHORT $LN9@s370_dyn_p
  002bb	ba 02 00 00 00	 mov	 edx, 2
  002c0	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d0	ff 90 20 0d 00
	00		 call	 QWORD PTR [rax+3360]
$LN9@s370_dyn_p:

; 4973 : 
; 4974 :   /* Check special conditions */
; 4975 :   if(unlikely(GR0_m(regs)))

  002d6	b8 08 00 00 00	 mov	 eax, 8
  002db	48 6b c0 00	 imul	 rax, rax, 0
  002df	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e7	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002ee	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002f3	85 c0		 test	 eax, eax
  002f5	74 0a		 je	 SHORT $LN24@s370_dyn_p
  002f7	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  002ff	eb 08		 jmp	 SHORT $LN25@s370_dyn_p
$LN24@s370_dyn_p:
  00301	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN25@s370_dyn_p:
  00309	83 7c 24 38 00	 cmp	 DWORD PTR tv94[rsp], 0
  0030e	74 0a		 je	 SHORT $LN30@s370_dyn_p
  00310	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv297[rsp], 1
  00318	eb 08		 jmp	 SHORT $LN31@s370_dyn_p
$LN30@s370_dyn_p:
  0031a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv297[rsp], 0
$LN31@s370_dyn_p:
  00322	83 7c 24 3c 00	 cmp	 DWORD PTR tv297[rsp], 0
  00327	74 13		 je	 SHORT $LN10@s370_dyn_p

; 4976 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00329	ba 06 00 00 00	 mov	 edx, 6
  0032e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN10@s370_dyn_p:

; 4977 : 
; 4978 :   /* Initialize values */
; 4979 :   fc = GR0_fc(regs);

  0033c	b8 08 00 00 00	 mov	 eax, 8
  00341	48 6b c0 00	 imul	 rax, rax, 0
  00345	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00354	83 e0 7f	 and	 eax, 127		; 0000007fH
  00357	89 44 24 44	 mov	 DWORD PTR fc$[rsp], eax

; 4980 :   switch(fc)

  0035b	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  0035f	89 44 24 40	 mov	 DWORD PTR tv306[rsp], eax
  00363	83 7c 24 40 14	 cmp	 DWORD PTR tv306[rsp], 20
  00368	0f 87 b8 00 00
	00		 ja	 $LN22@s370_dyn_p
  0036e	48 63 44 24 40	 movsxd	 rax, DWORD PTR tv306[rsp]
  00373	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0037a	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN32@s370_dyn_p[rcx+rax*4]
  00381	48 03 c1	 add	 rax, rcx
  00384	ff e0		 jmp	 rax
$LN11@s370_dyn_p:

; 4981 :   {
; 4982 :     case 0: /* Query */
; 4983 :     {
; 4984 :       /* Store the parameter block */
; 4985 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00386	b8 08 00 00 00	 mov	 eax, 8
  0038b	48 6b c0 01	 imul	 rax, rax, 1
  0038f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00397	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0039e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003a3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR msa$[rsp]
  003a8	48 6b c9 10	 imul	 rcx, rcx, 16
  003ac	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  003b1	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003b9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003be	41 b9 01 00 00
	00		 mov	 r9d, 1
  003c4	44 8b c0	 mov	 r8d, eax
  003c7	b2 0f		 mov	 dl, 15
  003c9	e8 00 00 00 00	 call	 s370_vstorec

; 4986 : 
; 4987 : #ifdef OPTION_PCKMO_DEBUG
; 4988 :       LOGBYTE("output:", query_bits[msa], 16);
; 4989 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 4990 : 
; 4991 :       return;

  003ce	eb 69		 jmp	 SHORT $LN1@s370_dyn_p
$LN12@s370_dyn_p:
$LN13@s370_dyn_p:
$LN14@s370_dyn_p:

; 4992 :     }
; 4993 :     case 1: /* encrypt-dea */
; 4994 :     case 2: /* encrypt-tdea-128 */
; 4995 :     case 3: /* encrypt-tdea-192 */
; 4996 :     {
; 4997 :       if(msa >= 3)

  003d0	83 7c 24 30 03	 cmp	 DWORD PTR msa$[rsp], 3
  003d5	7c 0f		 jl	 SHORT $LN15@s370_dyn_p

; 4998 :         ARCH_DEP(pckmo_dea)(regs);

  003d7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	e8 00 00 00 00	 call	 s370_pckmo_dea
  003e4	eb 13		 jmp	 SHORT $LN16@s370_dyn_p
$LN15@s370_dyn_p:

; 4999 :       else
; 5000 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003e6	ba 06 00 00 00	 mov	 edx, 6
  003eb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN16@s370_dyn_p:

; 5001 :       break;

  003f9	eb 3e		 jmp	 SHORT $LN5@s370_dyn_p
$LN17@s370_dyn_p:
$LN18@s370_dyn_p:
$LN19@s370_dyn_p:

; 5002 :     }
; 5003 :     case 18: /* encrypt-aes-128 */
; 5004 :     case 19: /* encrypt-aes-192 */
; 5005 :     case 20: /* encrypt-aes-256 */
; 5006 :     {
; 5007 :       if(msa >= 3)

  003fb	83 7c 24 30 03	 cmp	 DWORD PTR msa$[rsp], 3
  00400	7c 0f		 jl	 SHORT $LN20@s370_dyn_p

; 5008 :         ARCH_DEP(pckmo_aes)(regs);

  00402	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0040a	e8 00 00 00 00	 call	 s370_pckmo_aes
  0040f	eb 13		 jmp	 SHORT $LN21@s370_dyn_p
$LN20@s370_dyn_p:

; 5009 :       else
; 5010 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00411	ba 06 00 00 00	 mov	 edx, 6
  00416	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN21@s370_dyn_p:

; 5011 :       break;

  00424	eb 13		 jmp	 SHORT $LN5@s370_dyn_p
$LN22@s370_dyn_p:

; 5012 :     }
; 5013 :     default:
; 5014 :     {
; 5015 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00426	ba 06 00 00 00	 mov	 edx, 6
  0042b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00433	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_p:
$LN1@s370_dyn_p:

; 5016 :       break;
; 5017 :     }
; 5018 :   }
; 5019 : }

  00439	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00441	48 33 cc	 xor	 rcx, rsp
  00444	e8 00 00 00 00	 call	 __security_check_cookie
  00449	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00450	c3		 ret	 0
  00451	0f 1f 00	 npad	 3
$LN32@s370_dyn_p:
  00454	00 00 00 00	 DD	 $LN11@s370_dyn_p
  00458	00 00 00 00	 DD	 $LN12@s370_dyn_p
  0045c	00 00 00 00	 DD	 $LN13@s370_dyn_p
  00460	00 00 00 00	 DD	 $LN14@s370_dyn_p
  00464	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00468	00 00 00 00	 DD	 $LN22@s370_dyn_p
  0046c	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00470	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00474	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00478	00 00 00 00	 DD	 $LN22@s370_dyn_p
  0047c	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00480	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00484	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00488	00 00 00 00	 DD	 $LN22@s370_dyn_p
  0048c	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00490	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00494	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00498	00 00 00 00	 DD	 $LN22@s370_dyn_p
  0049c	00 00 00 00	 DD	 $LN17@s370_dyn_p
  004a0	00 00 00 00	 DD	 $LN18@s370_dyn_p
  004a4	00 00 00 00	 DD	 $LN19@s370_dyn_p
s370_dyn_perform_cryptographic_key_management_operation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
msa$ = 48
tv82 = 52
inst$ = 80
regs$ = 88
s370_dyn_perform_cryptographic_computation PROC

; 4870 : {

$LN35:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4871 :   int msa = get_msa(regs);

  0000e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00013	e8 00 00 00 00	 call	 get_msa
  00018	89 44 24 30	 mov	 DWORD PTR msa$[rsp], eax
$LN4@s370_dyn_p:

; 4872 :   static const BYTE query_bits[][16] =
; 4873 :   {
; 4874 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4875 :   };
; 4876 : 
; 4877 :   UNREFERENCED(inst);              /* This operation has no operands */

  0001c	33 c0		 xor	 eax, eax
  0001e	85 c0		 test	 eax, eax
  00020	75 fa		 jne	 SHORT $LN4@s370_dyn_p
$LN7@s370_dyn_p:

; 4878 :   INST_UPDATE_PSW(regs, 4, 4);        /* All operands implied        */

  00022	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00027	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0002b	48 83 c0 04	 add	 rax, 4
  0002f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00034	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00038	33 c0		 xor	 eax, eax
  0003a	83 f8 04	 cmp	 eax, 4
  0003d	74 0c		 je	 SHORT $LN10@s370_dyn_p
  0003f	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00044	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN10@s370_dyn_p:
  0004b	33 c0		 xor	 eax, eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 d1		 jne	 SHORT $LN7@s370_dyn_p

; 4879 :   PER_ZEROADDR_CHECK( regs, 1 );
; 4880 : 
; 4881 :   /* The following is the same as doing a FACILITY_CHECK */
; 4882 :   if(msa < 4)

  00051	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  00056	7d 12		 jge	 SHORT $LN11@s370_dyn_p

; 4883 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00058	ba 01 00 00 00	 mov	 edx, 1
  0005d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
  00068	eb 0f		 jmp	 SHORT $LN12@s370_dyn_p
$LN11@s370_dyn_p:

; 4884 :   else if (msa > 4) msa = 4;

  0006a	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  0006f	7e 08		 jle	 SHORT $LN13@s370_dyn_p
  00071	c7 44 24 30 04
	00 00 00	 mov	 DWORD PTR msa$[rsp], 4
$LN13@s370_dyn_p:
$LN12@s370_dyn_p:

; 4885 : 
; 4886 : #ifdef OPTION_PCC_DEBUG
; 4887 :   WRMSG(HHC90100, "D", "PCC: perform cryptographic computation");
; 4888 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4889 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4890 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4891 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 4892 : 
; 4893 :   switch(GR0_fc(regs))

  00079	b8 08 00 00 00	 mov	 eax, 8
  0007e	48 6b c0 00	 imul	 rax, rax, 0
  00082	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00087	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0008e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00091	89 44 24 34	 mov	 DWORD PTR tv82[rsp], eax
  00095	83 7c 24 34 3c	 cmp	 DWORD PTR tv82[rsp], 60	; 0000003cH
  0009a	0f 87 9d 00 00
	00		 ja	 $LN31@s370_dyn_p
  000a0	8b 44 24 34	 mov	 eax, DWORD PTR tv82[rsp]
  000a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000ab	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN33@s370_dyn_p[rcx+rax]
  000b3	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN34@s370_dyn_p[rcx+rax*4]
  000ba	48 03 c1	 add	 rax, rcx
  000bd	ff e0		 jmp	 rax
$LN14@s370_dyn_p:

; 4894 :   {
; 4895 :     case 0: /* Query */
; 4896 :       /* Store the parameter block */
; 4897 :       ARCH_DEP(vstorec)(query_bits[msa - 4], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  000bf	b8 08 00 00 00	 mov	 eax, 8
  000c4	48 6b c0 01	 imul	 rax, rax, 1
  000c8	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  000cd	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000d4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000d9	8b 4c 24 30	 mov	 ecx, DWORD PTR msa$[rsp]
  000dd	83 e9 04	 sub	 ecx, 4
  000e0	48 63 c9	 movsxd	 rcx, ecx
  000e3	48 6b c9 10	 imul	 rcx, rcx, 16
  000e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?query_bits@?1??s370_dyn_perform_cryptographic_computation@@9@9
  000ee	48 03 d1	 add	 rdx, rcx
  000f1	48 8b ca	 mov	 rcx, rdx
  000f4	48 8b 54 24 58	 mov	 rdx, QWORD PTR regs$[rsp]
  000f9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000fe	41 b9 01 00 00
	00		 mov	 r9d, 1
  00104	44 8b c0	 mov	 r8d, eax
  00107	b2 0f		 mov	 dl, 15
  00109	e8 00 00 00 00	 call	 s370_vstorec

; 4898 : 
; 4899 : #ifdef OPTION_PCC_DEBUG
; 4900 :       LOGBYTE("output:", query_bits[msa - 4], 16);
; 4901 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 4902 : 
; 4903 :       /* Set condition code 0 */
; 4904 :       regs->psw.cc = 0;

  0010e	48 8b 44 24 58	 mov	 rax, QWORD PTR regs$[rsp]
  00113	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4905 :       return;

  00117	eb 34		 jmp	 SHORT $LN1@s370_dyn_p
$LN15@s370_dyn_p:
$LN16@s370_dyn_p:
$LN17@s370_dyn_p:
$LN18@s370_dyn_p:
$LN19@s370_dyn_p:
$LN20@s370_dyn_p:

; 4906 :     case  1: /* dea */
; 4907 :     case  2: /* tdea-128 */
; 4908 :     case  3: /* tdea-192 */
; 4909 :     case  9: /* encrypted dea */
; 4910 :     case 10: /* encrypted tdea-128 */
; 4911 :     case 11: /* encrypted tdea-192 */
; 4912 :       ARCH_DEP(pcc_cmac_dea)(regs);

  00119	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0011e	e8 00 00 00 00	 call	 s370_pcc_cmac_dea

; 4913 :       break;

  00123	eb 28		 jmp	 SHORT $LN8@s370_dyn_p
$LN21@s370_dyn_p:
$LN22@s370_dyn_p:
$LN23@s370_dyn_p:
$LN24@s370_dyn_p:
$LN25@s370_dyn_p:
$LN26@s370_dyn_p:

; 4914 :     case 18: /* aes-128 */
; 4915 :     case 19: /* aes-192 */
; 4916 :     case 20: /* aes-256 */
; 4917 :     case 26: /* encrypted aes-128 */
; 4918 :     case 27: /* encrypted aes-192 */
; 4919 :     case 28: /* encrypted aes-256 */
; 4920 :       ARCH_DEP(pcc_cmac_aes)(regs);

  00125	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  0012a	e8 00 00 00 00	 call	 s370_pcc_cmac_aes

; 4921 :       break;

  0012f	eb 1c		 jmp	 SHORT $LN8@s370_dyn_p
$LN27@s370_dyn_p:
$LN28@s370_dyn_p:
$LN29@s370_dyn_p:
$LN30@s370_dyn_p:

; 4922 :     case 50: /* aes-128 */
; 4923 :     case 52: /* aes-256 */
; 4924 :     case 58: /* encrypted aes-128 */
; 4925 :     case 60: /* encrypted aes-256 */
; 4926 :       ARCH_DEP(pcc_xts_aes)(regs);

  00131	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00136	e8 00 00 00 00	 call	 s370_pcc_xts_aes

; 4927 :       break;

  0013b	eb 10		 jmp	 SHORT $LN8@s370_dyn_p
$LN31@s370_dyn_p:

; 4928 :     default:
; 4929 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0013d	ba 06 00 00 00	 mov	 edx, 6
  00142	48 8b 4c 24 58	 mov	 rcx, QWORD PTR regs$[rsp]
  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_p:
$LN1@s370_dyn_p:

; 4930 :       break;
; 4931 :   }
; 4932 : }

  0014d	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00151	c3		 ret	 0
  00152	66 90		 npad	 2
$LN34@s370_dyn_p:
  00154	00 00 00 00	 DD	 $LN14@s370_dyn_p
  00158	00 00 00 00	 DD	 $LN15@s370_dyn_p
  0015c	00 00 00 00	 DD	 $LN16@s370_dyn_p
  00160	00 00 00 00	 DD	 $LN17@s370_dyn_p
  00164	00 00 00 00	 DD	 $LN18@s370_dyn_p
  00168	00 00 00 00	 DD	 $LN19@s370_dyn_p
  0016c	00 00 00 00	 DD	 $LN20@s370_dyn_p
  00170	00 00 00 00	 DD	 $LN21@s370_dyn_p
  00174	00 00 00 00	 DD	 $LN22@s370_dyn_p
  00178	00 00 00 00	 DD	 $LN23@s370_dyn_p
  0017c	00 00 00 00	 DD	 $LN24@s370_dyn_p
  00180	00 00 00 00	 DD	 $LN25@s370_dyn_p
  00184	00 00 00 00	 DD	 $LN26@s370_dyn_p
  00188	00 00 00 00	 DD	 $LN27@s370_dyn_p
  0018c	00 00 00 00	 DD	 $LN28@s370_dyn_p
  00190	00 00 00 00	 DD	 $LN29@s370_dyn_p
  00194	00 00 00 00	 DD	 $LN30@s370_dyn_p
  00198	00 00 00 00	 DD	 $LN31@s370_dyn_p
$LN33@s370_dyn_p:
  0019c	00		 DB	 0
  0019d	01		 DB	 1
  0019e	02		 DB	 2
  0019f	03		 DB	 3
  001a0	11		 DB	 17
  001a1	11		 DB	 17
  001a2	11		 DB	 17
  001a3	11		 DB	 17
  001a4	11		 DB	 17
  001a5	04		 DB	 4
  001a6	05		 DB	 5
  001a7	06		 DB	 6
  001a8	11		 DB	 17
  001a9	11		 DB	 17
  001aa	11		 DB	 17
  001ab	11		 DB	 17
  001ac	11		 DB	 17
  001ad	11		 DB	 17
  001ae	07		 DB	 7
  001af	08		 DB	 8
  001b0	09		 DB	 9
  001b1	11		 DB	 17
  001b2	11		 DB	 17
  001b3	11		 DB	 17
  001b4	11		 DB	 17
  001b5	11		 DB	 17
  001b6	0a		 DB	 10
  001b7	0b		 DB	 11
  001b8	0c		 DB	 12
  001b9	11		 DB	 17
  001ba	11		 DB	 17
  001bb	11		 DB	 17
  001bc	11		 DB	 17
  001bd	11		 DB	 17
  001be	11		 DB	 17
  001bf	11		 DB	 17
  001c0	11		 DB	 17
  001c1	11		 DB	 17
  001c2	11		 DB	 17
  001c3	11		 DB	 17
  001c4	11		 DB	 17
  001c5	11		 DB	 17
  001c6	11		 DB	 17
  001c7	11		 DB	 17
  001c8	11		 DB	 17
  001c9	11		 DB	 17
  001ca	11		 DB	 17
  001cb	11		 DB	 17
  001cc	11		 DB	 17
  001cd	11		 DB	 17
  001ce	0d		 DB	 13
  001cf	11		 DB	 17
  001d0	0e		 DB	 14
  001d1	11		 DB	 17
  001d2	11		 DB	 17
  001d3	11		 DB	 17
  001d4	11		 DB	 17
  001d5	11		 DB	 17
  001d6	0f		 DB	 15
  001d7	11		 DB	 17
  001d8	10		 DB	 16
s370_dyn_perform_cryptographic_computation ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
msa$ = 48
r2$ = 52
r1$ = 56
i$1 = 60
tv290 = 64
tv299 = 68
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_cipher_message_with_output_feedback PROC

; 4772 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4773 :   int msa;
; 4774 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+48], 0
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4775 :   {
; 4776 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4777 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4778 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4779 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4780 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4781 :   };
; 4782 :   int r1;
; 4783 :   int r2;
; 4784 : 
; 4785 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4786 : 
; 4787 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4788 :     if (0
; 4789 :         || GR_A( 1,  regs ) == 0
; 4790 :         || GR_A( r1, regs ) == 0
; 4791 :         || GR_A( r2, regs ) == 0
; 4792 :     )
; 4793 :         ARCH_DEP( per3_zero )( regs );
; 4794 : #endif
; 4795 : 
; 4796 :   /* The following is the same as doing a FACILITY_CHECK */
; 4797 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 30	 mov	 DWORD PTR msa$[rsp], eax

; 4798 :   if(msa < 4)

  0028e	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4799 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4800 : 
; 4801 : #ifdef OPTION_KMO_DEBUG
; 4802 :   WRMSG(HHC90100, "D", "KMO: cipher message with output feedback");
; 4803 :   WRMSG(HHC90101, "D", 1, r1);
; 4804 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4805 :   WRMSG(HHC90101, "D", 2, r2);
; 4806 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4807 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4808 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4809 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4810 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4811 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 4812 : 
; 4813 :   /* Check special conditions */
; 4814 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  002a8	83 7c 24 38 00	 cmp	 DWORD PTR r1$[rsp], 0
  002ad	74 27		 je	 SHORT $LN29@s370_dyn_c
  002af	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 1c		 jne	 SHORT $LN29@s370_dyn_c
  002ba	83 7c 24 34 00	 cmp	 DWORD PTR r2$[rsp], 0
  002bf	74 15		 je	 SHORT $LN29@s370_dyn_c
  002c1	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  002c5	83 e0 01	 and	 eax, 1
  002c8	85 c0		 test	 eax, eax
  002ca	75 0a		 jne	 SHORT $LN29@s370_dyn_c
  002cc	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN32@s370_dyn_c
$LN29@s370_dyn_c:
  002d6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
$LN32@s370_dyn_c:
  002de	83 7c 24 40 00	 cmp	 DWORD PTR tv290[rsp], 0
  002e3	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4815 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  002e5	ba 06 00 00 00	 mov	 edx, 6
  002ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4816 : 
; 4817 :   switch(GR0_fc(regs))

  002f8	b8 08 00 00 00	 mov	 eax, 8
  002fd	48 6b c0 00	 imul	 rax, rax, 0
  00301	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00310	83 e0 7f	 and	 eax, 127		; 0000007fH
  00313	89 44 24 44	 mov	 DWORD PTR tv299[rsp], eax
  00317	83 7c 24 44 1c	 cmp	 DWORD PTR tv299[rsp], 28
  0031c	0f 87 d3 00 00
	00		 ja	 $LN27@s370_dyn_c
  00322	8b 44 24 44	 mov	 eax, DWORD PTR tv299[rsp]
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0032d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN33@s370_dyn_c[rcx+rax*4]
  00334	48 03 c1	 add	 rax, rcx
  00337	ff e0		 jmp	 rax
$LN10@s370_dyn_c:

; 4818 :   {
; 4819 :     case 0: /* Query */
; 4820 :     {
; 4821 :       /* Store the parameter block */
; 4822 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00339	b8 08 00 00 00	 mov	 eax, 8
  0033e	48 6b c0 01	 imul	 rax, rax, 1
  00342	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00351	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00356	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0035b	48 6b c9 10	 imul	 rcx, rcx, 16
  0035f	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00364	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0036c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00371	41 b9 01 00 00
	00		 mov	 r9d, 1
  00377	44 8b c0	 mov	 r8d, eax
  0037a	b2 0f		 mov	 dl, 15
  0037c	e8 00 00 00 00	 call	 s370_vstorec

; 4823 : 
; 4824 : #ifdef OPTION_KMO_DEBUG
; 4825 :       LOGBYTE("output:", query_bits[msa], 16);
; 4826 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 4827 : 
; 4828 :       /* Set condition code 0 */
; 4829 :       regs->psw.cc = 0;

  00381	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00389	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4830 :       return;

  0038d	eb 79		 jmp	 SHORT $LN1@s370_dyn_c
$LN11@s370_dyn_c:
$LN12@s370_dyn_c:
$LN13@s370_dyn_c:
$LN14@s370_dyn_c:
$LN15@s370_dyn_c:
$LN16@s370_dyn_c:

; 4831 :     }
; 4832 :     case 1: /* dea */
; 4833 :     case 2: /* tdea-128 */
; 4834 :     case 3: /* tdea-192 */
; 4835 :     case 9: /* encrypted dea */
; 4836 :     case 10: /* encrypted tdea-128 */
; 4837 :     case 11: /* encrypted tdea-192 */
; 4838 :     {
; 4839 :       if(msa >= 4)

  0038f	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  00394	7c 17		 jl	 SHORT $LN17@s370_dyn_c

; 4840 :         ARCH_DEP(kmo_dea)(r1, r2, regs);

  00396	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0039e	8b 54 24 34	 mov	 edx, DWORD PTR r2$[rsp]
  003a2	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  003a6	e8 00 00 00 00	 call	 s370_kmo_dea
  003ab	eb 13		 jmp	 SHORT $LN18@s370_dyn_c
$LN17@s370_dyn_c:

; 4841 :       else
; 4842 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003ad	ba 06 00 00 00	 mov	 edx, 6
  003b2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN18@s370_dyn_c:

; 4843 :       break;

  003c0	eb 46		 jmp	 SHORT $LN5@s370_dyn_c
$LN19@s370_dyn_c:
$LN20@s370_dyn_c:
$LN21@s370_dyn_c:
$LN22@s370_dyn_c:
$LN23@s370_dyn_c:
$LN24@s370_dyn_c:

; 4844 :     }
; 4845 :     case 18: /* aes-128 */
; 4846 :     case 19: /* aes-192 */
; 4847 :     case 20: /* aes-256 */
; 4848 :     case 26: /* encrypted aes-128 */
; 4849 :     case 27: /* encrypted aes-192 */
; 4850 :     case 28: /* encrypted aes-256 */
; 4851 :     {
; 4852 :       if(msa >= 4)

  003c2	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  003c7	7c 17		 jl	 SHORT $LN25@s370_dyn_c

; 4853 :         ARCH_DEP(kmo_aes)(r1, r2, regs);

  003c9	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d1	8b 54 24 34	 mov	 edx, DWORD PTR r2$[rsp]
  003d5	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  003d9	e8 00 00 00 00	 call	 s370_kmo_aes
  003de	eb 13		 jmp	 SHORT $LN26@s370_dyn_c
$LN25@s370_dyn_c:

; 4854 :       else
; 4855 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003e0	ba 06 00 00 00	 mov	 edx, 6
  003e5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN26@s370_dyn_c:

; 4856 :       break;

  003f3	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN27@s370_dyn_c:

; 4857 :     }
; 4858 :     default:
; 4859 :     {
; 4860 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003f5	ba 06 00 00 00	 mov	 edx, 6
  003fa	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4861 :       break;
; 4862 :     }
; 4863 :   }
; 4864 : }

  00408	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00410	48 33 cc	 xor	 rcx, rsp
  00413	e8 00 00 00 00	 call	 __security_check_cookie
  00418	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0041f	c3		 ret	 0
$LN33@s370_dyn_c:
  00420	00 00 00 00	 DD	 $LN10@s370_dyn_c
  00424	00 00 00 00	 DD	 $LN11@s370_dyn_c
  00428	00 00 00 00	 DD	 $LN12@s370_dyn_c
  0042c	00 00 00 00	 DD	 $LN13@s370_dyn_c
  00430	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00434	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00438	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0043c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00440	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00444	00 00 00 00	 DD	 $LN14@s370_dyn_c
  00448	00 00 00 00	 DD	 $LN15@s370_dyn_c
  0044c	00 00 00 00	 DD	 $LN16@s370_dyn_c
  00450	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00454	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00458	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0045c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00460	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00464	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00468	00 00 00 00	 DD	 $LN19@s370_dyn_c
  0046c	00 00 00 00	 DD	 $LN20@s370_dyn_c
  00470	00 00 00 00	 DD	 $LN21@s370_dyn_c
  00474	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00478	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0047c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00480	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00484	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00488	00 00 00 00	 DD	 $LN22@s370_dyn_c
  0048c	00 00 00 00	 DD	 $LN23@s370_dyn_c
  00490	00 00 00 00	 DD	 $LN24@s370_dyn_c
s370_dyn_cipher_message_with_output_feedback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
msa$ = 48
r2$ = 52
r1$ = 56
i$1 = 60
tv290 = 64
tv299 = 68
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_cipher_message_with_cipher_feedback PROC

; 4671 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4672 :   int msa;
; 4673 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+48], 0
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4674 :   {
; 4675 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4676 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4677 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4678 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4679 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4680 :   };
; 4681 :   int r1;
; 4682 :   int r2;
; 4683 : 
; 4684 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 34	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4685 : 
; 4686 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4687 :     if (0
; 4688 :         || GR_A( 1,  regs ) == 0
; 4689 :         || GR_A( r1, regs ) == 0
; 4690 :         || GR_A( r2, regs ) == 0
; 4691 :     )
; 4692 :         ARCH_DEP( per3_zero )( regs );
; 4693 : #endif
; 4694 : 
; 4695 :   /* The following is the same as doing a FACILITY_CHECK */
; 4696 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 30	 mov	 DWORD PTR msa$[rsp], eax

; 4697 :   if(msa < 4)

  0028e	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4698 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4699 : 
; 4700 : #ifdef OPTION_KMF_DEBUG
; 4701 :   WRMSG(HHC90100, "D", "KMF: cipher message with cipher feedback");
; 4702 :   WRMSG(HHC90101, "D", 1, r1);
; 4703 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4704 :   WRMSG(HHC90101, "D", 2, r2);
; 4705 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4706 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4707 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4708 :   WRMSG(HHC90112, "D", GR0_lcfb(regs));
; 4709 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4710 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4711 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4712 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 4713 : 
; 4714 :   /* Check special conditions */
; 4715 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  002a8	83 7c 24 38 00	 cmp	 DWORD PTR r1$[rsp], 0
  002ad	74 27		 je	 SHORT $LN29@s370_dyn_c
  002af	8b 44 24 38	 mov	 eax, DWORD PTR r1$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 1c		 jne	 SHORT $LN29@s370_dyn_c
  002ba	83 7c 24 34 00	 cmp	 DWORD PTR r2$[rsp], 0
  002bf	74 15		 je	 SHORT $LN29@s370_dyn_c
  002c1	8b 44 24 34	 mov	 eax, DWORD PTR r2$[rsp]
  002c5	83 e0 01	 and	 eax, 1
  002c8	85 c0		 test	 eax, eax
  002ca	75 0a		 jne	 SHORT $LN29@s370_dyn_c
  002cc	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN32@s370_dyn_c
$LN29@s370_dyn_c:
  002d6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
$LN32@s370_dyn_c:
  002de	83 7c 24 40 00	 cmp	 DWORD PTR tv290[rsp], 0
  002e3	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4716 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  002e5	ba 06 00 00 00	 mov	 edx, 6
  002ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4717 : 
; 4718 :   switch(GR0_fc(regs))

  002f8	b8 08 00 00 00	 mov	 eax, 8
  002fd	48 6b c0 00	 imul	 rax, rax, 0
  00301	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00310	83 e0 7f	 and	 eax, 127		; 0000007fH
  00313	89 44 24 44	 mov	 DWORD PTR tv299[rsp], eax
  00317	83 7c 24 44 1c	 cmp	 DWORD PTR tv299[rsp], 28
  0031c	0f 87 d3 00 00
	00		 ja	 $LN27@s370_dyn_c
  00322	8b 44 24 44	 mov	 eax, DWORD PTR tv299[rsp]
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0032d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN33@s370_dyn_c[rcx+rax*4]
  00334	48 03 c1	 add	 rax, rcx
  00337	ff e0		 jmp	 rax
$LN10@s370_dyn_c:

; 4719 :   {
; 4720 :     case 0: /* Query */
; 4721 :     {
; 4722 :       /* Store the parameter block */
; 4723 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00339	b8 08 00 00 00	 mov	 eax, 8
  0033e	48 6b c0 01	 imul	 rax, rax, 1
  00342	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00351	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00356	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0035b	48 6b c9 10	 imul	 rcx, rcx, 16
  0035f	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00364	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0036c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00371	41 b9 01 00 00
	00		 mov	 r9d, 1
  00377	44 8b c0	 mov	 r8d, eax
  0037a	b2 0f		 mov	 dl, 15
  0037c	e8 00 00 00 00	 call	 s370_vstorec

; 4724 : 
; 4725 : #ifdef OPTION_KMF_DEBUG
; 4726 :       LOGBYTE("output:", query_bits[msa], 16);
; 4727 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 4728 : 
; 4729 :       /* Set condition code 0 */
; 4730 :       regs->psw.cc = 0;

  00381	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00389	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4731 :       return;

  0038d	eb 79		 jmp	 SHORT $LN1@s370_dyn_c
$LN11@s370_dyn_c:
$LN12@s370_dyn_c:
$LN13@s370_dyn_c:
$LN14@s370_dyn_c:
$LN15@s370_dyn_c:
$LN16@s370_dyn_c:

; 4732 :     }
; 4733 : 
; 4734 :     case 1: /* dea */
; 4735 :     case 2: /* tdea-128 */
; 4736 :     case 3: /* tdea-192 */
; 4737 :     case 9: /* encrypted dea */
; 4738 :     case 10: /* encrypted tdea-128 */
; 4739 :     case 11: /* encrypted tdea-192 */
; 4740 :     {
; 4741 :       if(msa >= 4)

  0038f	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  00394	7c 17		 jl	 SHORT $LN17@s370_dyn_c

; 4742 :         ARCH_DEP(kmf_dea)(r1, r2, regs);

  00396	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0039e	8b 54 24 34	 mov	 edx, DWORD PTR r2$[rsp]
  003a2	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  003a6	e8 00 00 00 00	 call	 s370_kmf_dea
  003ab	eb 13		 jmp	 SHORT $LN18@s370_dyn_c
$LN17@s370_dyn_c:

; 4743 :       else
; 4744 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003ad	ba 06 00 00 00	 mov	 edx, 6
  003b2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN18@s370_dyn_c:

; 4745 :       break;

  003c0	eb 46		 jmp	 SHORT $LN5@s370_dyn_c
$LN19@s370_dyn_c:
$LN20@s370_dyn_c:
$LN21@s370_dyn_c:
$LN22@s370_dyn_c:
$LN23@s370_dyn_c:
$LN24@s370_dyn_c:

; 4746 :     }
; 4747 :     case 18: /* aes-128 */
; 4748 :     case 19: /* aes-192 */
; 4749 :     case 20: /* aes-256 */
; 4750 :     case 26: /* encrypted aes-128 */
; 4751 :     case 27: /* encrypted aes-192 */
; 4752 :     case 28: /* encrypted aes-256 */
; 4753 :     {
; 4754 :       if(msa >= 4)

  003c2	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  003c7	7c 17		 jl	 SHORT $LN25@s370_dyn_c

; 4755 :         ARCH_DEP(kmf_aes)(r1, r2, regs);

  003c9	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d1	8b 54 24 34	 mov	 edx, DWORD PTR r2$[rsp]
  003d5	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  003d9	e8 00 00 00 00	 call	 s370_kmf_aes
  003de	eb 13		 jmp	 SHORT $LN26@s370_dyn_c
$LN25@s370_dyn_c:

; 4756 :       else
; 4757 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003e0	ba 06 00 00 00	 mov	 edx, 6
  003e5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN26@s370_dyn_c:

; 4758 :       break;

  003f3	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN27@s370_dyn_c:

; 4759 :     }
; 4760 :     default:
; 4761 :     {
; 4762 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003f5	ba 06 00 00 00	 mov	 edx, 6
  003fa	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4763 :       break;
; 4764 :     }
; 4765 :   }
; 4766 : }

  00408	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00410	48 33 cc	 xor	 rcx, rsp
  00413	e8 00 00 00 00	 call	 __security_check_cookie
  00418	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0041f	c3		 ret	 0
$LN33@s370_dyn_c:
  00420	00 00 00 00	 DD	 $LN10@s370_dyn_c
  00424	00 00 00 00	 DD	 $LN11@s370_dyn_c
  00428	00 00 00 00	 DD	 $LN12@s370_dyn_c
  0042c	00 00 00 00	 DD	 $LN13@s370_dyn_c
  00430	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00434	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00438	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0043c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00440	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00444	00 00 00 00	 DD	 $LN14@s370_dyn_c
  00448	00 00 00 00	 DD	 $LN15@s370_dyn_c
  0044c	00 00 00 00	 DD	 $LN16@s370_dyn_c
  00450	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00454	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00458	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0045c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00460	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00464	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00468	00 00 00 00	 DD	 $LN19@s370_dyn_c
  0046c	00 00 00 00	 DD	 $LN20@s370_dyn_c
  00470	00 00 00 00	 DD	 $LN21@s370_dyn_c
  00474	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00478	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0047c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00480	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00484	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00488	00 00 00 00	 DD	 $LN22@s370_dyn_c
  0048c	00 00 00 00	 DD	 $LN23@s370_dyn_c
  00490	00 00 00 00	 DD	 $LN24@s370_dyn_c
s370_dyn_cipher_message_with_cipher_feedback ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
msa$ = 48
r3$ = 52
r2$ = 56
r1$ = 60
temp$1 = 64
tv301 = 68
tv310 = 72
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_cipher_message_with_counter PROC

; 4576 : {

$LN34:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4577 :   int msa;
; 4578 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 00	 mov	 BYTE PTR query_bits$[rsp], 0
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 00	 mov	 BYTE PTR query_bits$[rsp+16], 0
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 00	 mov	 BYTE PTR query_bits$[rsp+32], 0
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+48], 0
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4579 :   {
; 4580 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4581 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4582 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4583 :     { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
; 4584 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4585 :   };
; 4586 :   int r1;
; 4587 :   int r2;
; 4588 :   int r3;
; 4589 : 
; 4590 :   RRF_M(inst, regs, r1, r2, r3);

  00213	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  0021b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00220	8b c8		 mov	 ecx, eax
  00222	e8 00 00 00 00	 call	 _byteswap_ulong
  00227	89 44 24 40	 mov	 DWORD PTR temp$1[rsp], eax
  0022b	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0022f	83 e0 0f	 and	 eax, 15
  00232	89 44 24 38	 mov	 DWORD PTR r2$[rsp], eax
  00236	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  0023a	c1 e8 04	 shr	 eax, 4
  0023d	83 e0 0f	 and	 eax, 15
  00240	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
  00244	8b 44 24 40	 mov	 eax, DWORD PTR temp$1[rsp]
  00248	c1 e8 0c	 shr	 eax, 12
  0024b	83 e0 0f	 and	 eax, 15
  0024e	89 44 24 34	 mov	 DWORD PTR r3$[rsp], eax
$LN4@s370_dyn_c:
  00252	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025a	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  0025e	48 83 c0 04	 add	 rax, 4
  00262	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0026a	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  0026e	33 c0		 xor	 eax, eax
  00270	83 f8 04	 cmp	 eax, 4
  00273	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00275	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0027d	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00284	33 c0		 xor	 eax, eax
  00286	85 c0		 test	 eax, eax
  00288	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4591 :   PER_ZEROADDR_CHECK( regs, 1 );
; 4592 :   PER_ZEROADDR_CHECK2( regs, r1, r3 );
; 4593 :   PER_ZEROADDR_LCHECK( regs, r2, r2+1 );
; 4594 : 
; 4595 :   /* The following is the same as doing a FACILITY_CHECK */
; 4596 :   msa = get_msa(regs);

  0028a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00292	e8 00 00 00 00	 call	 get_msa
  00297	89 44 24 30	 mov	 DWORD PTR msa$[rsp], eax

; 4597 :   if(msa < 4)

  0029b	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  002a0	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4598 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  002a2	ba 01 00 00 00	 mov	 edx, 1
  002a7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4599 : 
; 4600 : #ifdef OPTION_KMCTR_DEBUG
; 4601 :   WRMSG(HHC90100, "D", "KMCTR: cipher message with counter");
; 4602 :   WRMSG(HHC90101, "D", 1, r1);
; 4603 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4604 :   WRMSG(HHC90101, "D", 2, r2);
; 4605 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4606 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4607 :   WRMSG(HHC90101, "D", 3, r3);
; 4608 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4609 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4610 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4611 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 4612 : 
; 4613 :   /* Check special conditions */
; 4614 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01 || !r3 || r3 & 0x01))

  002b5	83 7c 24 3c 00	 cmp	 DWORD PTR r1$[rsp], 0
  002ba	74 39		 je	 SHORT $LN29@s370_dyn_c
  002bc	8b 44 24 3c	 mov	 eax, DWORD PTR r1$[rsp]
  002c0	83 e0 01	 and	 eax, 1
  002c3	85 c0		 test	 eax, eax
  002c5	75 2e		 jne	 SHORT $LN29@s370_dyn_c
  002c7	83 7c 24 38 00	 cmp	 DWORD PTR r2$[rsp], 0
  002cc	74 27		 je	 SHORT $LN29@s370_dyn_c
  002ce	8b 44 24 38	 mov	 eax, DWORD PTR r2$[rsp]
  002d2	83 e0 01	 and	 eax, 1
  002d5	85 c0		 test	 eax, eax
  002d7	75 1c		 jne	 SHORT $LN29@s370_dyn_c
  002d9	83 7c 24 34 00	 cmp	 DWORD PTR r3$[rsp], 0
  002de	74 15		 je	 SHORT $LN29@s370_dyn_c
  002e0	8b 44 24 34	 mov	 eax, DWORD PTR r3$[rsp]
  002e4	83 e0 01	 and	 eax, 1
  002e7	85 c0		 test	 eax, eax
  002e9	75 0a		 jne	 SHORT $LN29@s370_dyn_c
  002eb	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv301[rsp], 0
  002f3	eb 08		 jmp	 SHORT $LN32@s370_dyn_c
$LN29@s370_dyn_c:
  002f5	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv301[rsp], 1
$LN32@s370_dyn_c:
  002fd	83 7c 24 44 00	 cmp	 DWORD PTR tv301[rsp], 0
  00302	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4615 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00304	ba 06 00 00 00	 mov	 edx, 6
  00309	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00311	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4616 : 
; 4617 :   switch(GR0_fc(regs))

  00317	b8 08 00 00 00	 mov	 eax, 8
  0031c	48 6b c0 00	 imul	 rax, rax, 0
  00320	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00328	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0032f	83 e0 7f	 and	 eax, 127		; 0000007fH
  00332	89 44 24 48	 mov	 DWORD PTR tv310[rsp], eax
  00336	83 7c 24 48 1c	 cmp	 DWORD PTR tv310[rsp], 28
  0033b	0f 87 e0 00 00
	00		 ja	 $LN27@s370_dyn_c
  00341	8b 44 24 48	 mov	 eax, DWORD PTR tv310[rsp]
  00345	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0034c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN33@s370_dyn_c[rcx+rax*4]
  00353	48 03 c1	 add	 rax, rcx
  00356	ff e0		 jmp	 rax
$LN10@s370_dyn_c:

; 4618 :   {
; 4619 :     case 0: /* Query */
; 4620 :     {
; 4621 :       /* Store the parameter block */
; 4622 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00358	b8 08 00 00 00	 mov	 eax, 8
  0035d	48 6b c0 01	 imul	 rax, rax, 1
  00361	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00369	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00370	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00375	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0037a	48 6b c9 10	 imul	 rcx, rcx, 16
  0037e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00383	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0038b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00390	41 b9 01 00 00
	00		 mov	 r9d, 1
  00396	44 8b c0	 mov	 r8d, eax
  00399	b2 0f		 mov	 dl, 15
  0039b	e8 00 00 00 00	 call	 s370_vstorec

; 4623 : 
; 4624 : #ifdef OPTION_KMCTR_DEBUG
; 4625 :       LOGBYTE("output:", query_bits[msa], 16);
; 4626 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 4627 : 
; 4628 :       /* Set condition code 0 */
; 4629 :       regs->psw.cc = 0;

  003a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4630 :       return;

  003ac	e9 83 00 00 00	 jmp	 $LN1@s370_dyn_c
$LN11@s370_dyn_c:
$LN12@s370_dyn_c:
$LN13@s370_dyn_c:
$LN14@s370_dyn_c:
$LN15@s370_dyn_c:
$LN16@s370_dyn_c:

; 4631 :     }
; 4632 : 
; 4633 :     case 1: /* dea */
; 4634 :     case 2: /* tdea-128 */
; 4635 :     case 3: /* tdea-192 */
; 4636 :     case 9: /* encrypted dea */
; 4637 :     case 10: /* encrypted tdea-128 */
; 4638 :     case 11: /* encrypted tdea-192 */
; 4639 :     {
; 4640 :       if(msa >= 4)

  003b1	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  003b6	7c 1c		 jl	 SHORT $LN17@s370_dyn_c

; 4641 :         ARCH_DEP(kmctr_dea)(r1, r2, r3, regs);

  003b8	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003c0	44 8b 44 24 34	 mov	 r8d, DWORD PTR r3$[rsp]
  003c5	8b 54 24 38	 mov	 edx, DWORD PTR r2$[rsp]
  003c9	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003cd	e8 00 00 00 00	 call	 s370_kmctr_dea
  003d2	eb 13		 jmp	 SHORT $LN18@s370_dyn_c
$LN17@s370_dyn_c:

; 4642 :       else
; 4643 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003d4	ba 06 00 00 00	 mov	 edx, 6
  003d9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN18@s370_dyn_c:

; 4644 :       break;

  003e7	eb 4b		 jmp	 SHORT $LN5@s370_dyn_c
$LN19@s370_dyn_c:
$LN20@s370_dyn_c:
$LN21@s370_dyn_c:
$LN22@s370_dyn_c:
$LN23@s370_dyn_c:
$LN24@s370_dyn_c:

; 4645 :     }
; 4646 :     case 18: /* aes-128 */
; 4647 :     case 19: /* aes-192 */
; 4648 :     case 20: /* aes-256 */
; 4649 :     case 26: /* encrypted aes-128 */
; 4650 :     case 27: /* encrypted aes-192 */
; 4651 :     case 28: /* encrypted aes-256 */
; 4652 :     {
; 4653 :       if(msa >= 4)

  003e9	83 7c 24 30 04	 cmp	 DWORD PTR msa$[rsp], 4
  003ee	7c 1c		 jl	 SHORT $LN25@s370_dyn_c

; 4654 :         ARCH_DEP(kmctr_aes)(r1, r2, r3, regs);

  003f0	4c 8b 8c 24 c8
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  003f8	44 8b 44 24 34	 mov	 r8d, DWORD PTR r3$[rsp]
  003fd	8b 54 24 38	 mov	 edx, DWORD PTR r2$[rsp]
  00401	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00405	e8 00 00 00 00	 call	 s370_kmctr_aes
  0040a	eb 13		 jmp	 SHORT $LN26@s370_dyn_c
$LN25@s370_dyn_c:

; 4655 :       else
; 4656 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0040c	ba 06 00 00 00	 mov	 edx, 6
  00411	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00419	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN26@s370_dyn_c:

; 4657 :       break;

  0041f	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN27@s370_dyn_c:

; 4658 :     }
; 4659 :     default:
; 4660 :     {
; 4661 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00421	ba 06 00 00 00	 mov	 edx, 6
  00426	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4662 :       break;
; 4663 :     }
; 4664 :   }
; 4665 : }

  00434	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043c	48 33 cc	 xor	 rcx, rsp
  0043f	e8 00 00 00 00	 call	 __security_check_cookie
  00444	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0044b	c3		 ret	 0
$LN33@s370_dyn_c:
  0044c	00 00 00 00	 DD	 $LN10@s370_dyn_c
  00450	00 00 00 00	 DD	 $LN11@s370_dyn_c
  00454	00 00 00 00	 DD	 $LN12@s370_dyn_c
  00458	00 00 00 00	 DD	 $LN13@s370_dyn_c
  0045c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00460	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00464	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00468	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0046c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00470	00 00 00 00	 DD	 $LN14@s370_dyn_c
  00474	00 00 00 00	 DD	 $LN15@s370_dyn_c
  00478	00 00 00 00	 DD	 $LN16@s370_dyn_c
  0047c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00480	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00484	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00488	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0048c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00490	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00494	00 00 00 00	 DD	 $LN19@s370_dyn_c
  00498	00 00 00 00	 DD	 $LN20@s370_dyn_c
  0049c	00 00 00 00	 DD	 $LN21@s370_dyn_c
  004a0	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004a4	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004a8	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004ac	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004b0	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004b4	00 00 00 00	 DD	 $LN22@s370_dyn_c
  004b8	00 00 00 00	 DD	 $LN23@s370_dyn_c
  004bc	00 00 00 00	 DD	 $LN24@s370_dyn_c
s370_dyn_cipher_message_with_counter ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv290 = 64
tv299 = 68
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_cipher_message_with_chaining PROC

; 4434 : {

$LN42:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4435 :   int msa;
; 4436 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 20	 mov	 BYTE PTR query_bits$[rsp+18], 32 ; 00000020H
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 10	 mov	 BYTE PTR query_bits$[rsp+24], 16
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 38	 mov	 BYTE PTR query_bits$[rsp+34], 56 ; 00000038H
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 10	 mov	 BYTE PTR query_bits$[rsp+40], 16
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00123	c6 84 24 82 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0012b	c6 84 24 83 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+51], 56 ; 00000038H
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+56], 16
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 10	 mov	 BYTE PTR query_bits$[rsp+72], 16
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4437 :   {
; 4438 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4439 :     { 0xf0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4440 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4441 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4442 :     /**/ { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4443 :   };
; 4444 :   int r1;
; 4445 :   int r2;
; 4446 : 
; 4447 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4448 : 
; 4449 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4450 :     if (0
; 4451 :         || GR_A( 1,  regs ) == 0
; 4452 :         || GR_A( r1, regs ) == 0
; 4453 :         || GR_A( r2, regs ) == 0
; 4454 :     )
; 4455 :         ARCH_DEP( per3_zero )( regs );
; 4456 : #endif
; 4457 : 
; 4458 :   /* The following is the same as doing a FACILITY_CHECK */
; 4459 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4460 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4461 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4462 : 
; 4463 : #ifdef OPTION_KMC_DEBUG
; 4464 :   WRMSG(HHC90100, "D", "KMC: cipher message with chaining");
; 4465 :   WRMSG(HHC90101, "D", 1, r1);
; 4466 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4467 :   WRMSG(HHC90101, "D", 2, r2);
; 4468 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4469 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4470 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4471 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4472 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4473 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4474 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 4475 : 
; 4476 :   /* Check special conditions */
; 4477 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  002a8	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  002ad	74 27		 je	 SHORT $LN36@s370_dyn_c
  002af	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 1c		 jne	 SHORT $LN36@s370_dyn_c
  002ba	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002bf	74 15		 je	 SHORT $LN36@s370_dyn_c
  002c1	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002c5	83 e0 01	 and	 eax, 1
  002c8	85 c0		 test	 eax, eax
  002ca	75 0a		 jne	 SHORT $LN36@s370_dyn_c
  002cc	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN39@s370_dyn_c
$LN36@s370_dyn_c:
  002d6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
$LN39@s370_dyn_c:
  002de	83 7c 24 40 00	 cmp	 DWORD PTR tv290[rsp], 0
  002e3	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4478 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  002e5	ba 06 00 00 00	 mov	 edx, 6
  002ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4479 : 
; 4480 :   switch(GR0_fc(regs))

  002f8	b8 08 00 00 00	 mov	 eax, 8
  002fd	48 6b c0 00	 imul	 rax, rax, 0
  00301	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00310	83 e0 7f	 and	 eax, 127		; 0000007fH
  00313	89 44 24 44	 mov	 DWORD PTR tv299[rsp], eax
  00317	83 7c 24 44 43	 cmp	 DWORD PTR tv299[rsp], 67 ; 00000043H
  0031c	0f 87 97 01 00
	00		 ja	 $LN34@s370_dyn_c
  00322	8b 44 24 44	 mov	 eax, DWORD PTR tv299[rsp]
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0032d	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN40@s370_dyn_c[rcx+rax]
  00335	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN41@s370_dyn_c[rcx+rax*4]
  0033c	48 03 c1	 add	 rax, rcx
  0033f	ff e0		 jmp	 rax
$LN10@s370_dyn_c:

; 4481 :   {
; 4482 :     case 0: /* Query */
; 4483 :     {
; 4484 :       /* Store the parameter block */
; 4485 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00341	b8 08 00 00 00	 mov	 eax, 8
  00346	48 6b c0 01	 imul	 rax, rax, 1
  0034a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00359	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0035e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00363	48 6b c9 10	 imul	 rcx, rcx, 16
  00367	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0036c	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00374	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00379	41 b9 01 00 00
	00		 mov	 r9d, 1
  0037f	44 8b c0	 mov	 r8d, eax
  00382	b2 0f		 mov	 dl, 15
  00384	e8 00 00 00 00	 call	 s370_vstorec

; 4486 : 
; 4487 : #ifdef OPTION_KMC_DEBUG
; 4488 :       LOGBYTE("output:", query_bits[msa], 16);
; 4489 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 4490 : 
; 4491 :       /* Set condition code 0 */
; 4492 :       regs->psw.cc = 0;

  00389	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00391	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4493 :       return;

  00395	e9 32 01 00 00	 jmp	 $LN1@s370_dyn_c
$LN11@s370_dyn_c:
$LN12@s370_dyn_c:
$LN13@s370_dyn_c:

; 4494 :     }
; 4495 :     case 1: /* dea */
; 4496 :     case 2: /* tdea-128 */
; 4497 :     case 3: /* tdea-192 */
; 4498 :     {
; 4499 :       ARCH_DEP(kmc_dea)(r1, r2, regs);

  0039a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003a2	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003a6	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003aa	e8 00 00 00 00	 call	 s370_kmc_dea

; 4500 :       break;

  003af	e9 18 01 00 00	 jmp	 $LN5@s370_dyn_c
$LN14@s370_dyn_c:
$LN15@s370_dyn_c:
$LN16@s370_dyn_c:

; 4501 :     }
; 4502 : 
; 4503 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4504 :     case 9: /* encrypted dea */
; 4505 :     case 10: /* encrypted tdea-128 */
; 4506 :     case 11: /* encrypted tdea-192 */
; 4507 :     {
; 4508 :       if(msa >= 3)

  003b4	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  003b9	7c 17		 jl	 SHORT $LN17@s370_dyn_c

; 4509 :         ARCH_DEP(kmc_dea)(r1, r2, regs);

  003bb	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c3	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003c7	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003cb	e8 00 00 00 00	 call	 s370_kmc_dea
  003d0	eb 13		 jmp	 SHORT $LN18@s370_dyn_c
$LN17@s370_dyn_c:

; 4510 :       else
; 4511 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003d2	ba 06 00 00 00	 mov	 edx, 6
  003d7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN18@s370_dyn_c:

; 4512 :       break;

  003e5	e9 e2 00 00 00	 jmp	 $LN5@s370_dyn_c
$LN19@s370_dyn_c:

; 4513 :     }
; 4514 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4515 : 
; 4516 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4517 :     case 18: /* aes-128 */
; 4518 :     {
; 4519 :       if(msa >= 1)

  003ea	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003ef	7c 17		 jl	 SHORT $LN20@s370_dyn_c

; 4520 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  003f1	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f9	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003fd	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00401	e8 00 00 00 00	 call	 s370_kmc_aes
  00406	eb 13		 jmp	 SHORT $LN21@s370_dyn_c
$LN20@s370_dyn_c:

; 4521 :       else
; 4522 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00408	ba 06 00 00 00	 mov	 edx, 6
  0040d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN21@s370_dyn_c:

; 4523 :       break;

  0041b	e9 ac 00 00 00	 jmp	 $LN5@s370_dyn_c
$LN22@s370_dyn_c:
$LN23@s370_dyn_c:

; 4524 :     }
; 4525 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4526 : 
; 4527 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4528 :     case 19: /* aes-192 */
; 4529 :     case 20: /* aes-256 */
; 4530 :     {
; 4531 :       if(msa >= 2)

  00420	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  00425	7c 17		 jl	 SHORT $LN24@s370_dyn_c

; 4532 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  00427	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0042f	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00433	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00437	e8 00 00 00 00	 call	 s370_kmc_aes
  0043c	eb 13		 jmp	 SHORT $LN25@s370_dyn_c
$LN24@s370_dyn_c:

; 4533 :       else
; 4534 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0043e	ba 06 00 00 00	 mov	 edx, 6
  00443	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN25@s370_dyn_c:

; 4535 :       break;

  00451	eb 79		 jmp	 SHORT $LN5@s370_dyn_c
$LN26@s370_dyn_c:
$LN27@s370_dyn_c:
$LN28@s370_dyn_c:

; 4536 :     }
; 4537 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4538 : 
; 4539 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4540 :     case 26: /* encrypted aes-128 */
; 4541 :     case 27: /* encrypted aes-192 */
; 4542 :     case 28: /* encrypted aes-256 */
; 4543 :     {
; 4544 :       if(msa >= 3)

  00453	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  00458	7c 17		 jl	 SHORT $LN29@s370_dyn_c

; 4545 :         ARCH_DEP(kmc_aes)(r1, r2, regs);

  0045a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00462	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00466	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0046a	e8 00 00 00 00	 call	 s370_kmc_aes
  0046f	eb 13		 jmp	 SHORT $LN30@s370_dyn_c
$LN29@s370_dyn_c:

; 4546 :       else
; 4547 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00471	ba 06 00 00 00	 mov	 edx, 6
  00476	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN30@s370_dyn_c:

; 4548 :       break;

  00484	eb 46		 jmp	 SHORT $LN5@s370_dyn_c
$LN31@s370_dyn_c:

; 4549 :     }
; 4550 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4551 : 
; 4552 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4553 :     case 67: /* prng */
; 4554 :     {
; 4555 :       if(msa >= 1)

  00486	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  0048b	7c 17		 jl	 SHORT $LN32@s370_dyn_c

; 4556 :         ARCH_DEP(kmc_prng)(r1, r2, regs);

  0048d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00495	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00499	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0049d	e8 00 00 00 00	 call	 s370_kmc_prng
  004a2	eb 13		 jmp	 SHORT $LN33@s370_dyn_c
$LN32@s370_dyn_c:

; 4557 :       else
; 4558 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004a4	ba 06 00 00 00	 mov	 edx, 6
  004a9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN33@s370_dyn_c:

; 4559 :       break;

  004b7	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN34@s370_dyn_c:

; 4560 :     }
; 4561 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4562 : 
; 4563 :     default:
; 4564 :     {
; 4565 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004b9	ba 06 00 00 00	 mov	 edx, 6
  004be	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4566 :       break;
; 4567 :     }
; 4568 :   }
; 4569 : }

  004cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004d4	48 33 cc	 xor	 rcx, rsp
  004d7	e8 00 00 00 00	 call	 __security_check_cookie
  004dc	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  004e3	c3		 ret	 0
$LN41@s370_dyn_c:
  004e4	00 00 00 00	 DD	 $LN10@s370_dyn_c
  004e8	00 00 00 00	 DD	 $LN11@s370_dyn_c
  004ec	00 00 00 00	 DD	 $LN12@s370_dyn_c
  004f0	00 00 00 00	 DD	 $LN13@s370_dyn_c
  004f4	00 00 00 00	 DD	 $LN14@s370_dyn_c
  004f8	00 00 00 00	 DD	 $LN15@s370_dyn_c
  004fc	00 00 00 00	 DD	 $LN16@s370_dyn_c
  00500	00 00 00 00	 DD	 $LN19@s370_dyn_c
  00504	00 00 00 00	 DD	 $LN22@s370_dyn_c
  00508	00 00 00 00	 DD	 $LN23@s370_dyn_c
  0050c	00 00 00 00	 DD	 $LN26@s370_dyn_c
  00510	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00514	00 00 00 00	 DD	 $LN28@s370_dyn_c
  00518	00 00 00 00	 DD	 $LN31@s370_dyn_c
  0051c	00 00 00 00	 DD	 $LN34@s370_dyn_c
$LN40@s370_dyn_c:
  00520	00		 DB	 0
  00521	01		 DB	 1
  00522	02		 DB	 2
  00523	03		 DB	 3
  00524	0e		 DB	 14
  00525	0e		 DB	 14
  00526	0e		 DB	 14
  00527	0e		 DB	 14
  00528	0e		 DB	 14
  00529	04		 DB	 4
  0052a	05		 DB	 5
  0052b	06		 DB	 6
  0052c	0e		 DB	 14
  0052d	0e		 DB	 14
  0052e	0e		 DB	 14
  0052f	0e		 DB	 14
  00530	0e		 DB	 14
  00531	0e		 DB	 14
  00532	07		 DB	 7
  00533	08		 DB	 8
  00534	09		 DB	 9
  00535	0e		 DB	 14
  00536	0e		 DB	 14
  00537	0e		 DB	 14
  00538	0e		 DB	 14
  00539	0e		 DB	 14
  0053a	0a		 DB	 10
  0053b	0b		 DB	 11
  0053c	0c		 DB	 12
  0053d	0e		 DB	 14
  0053e	0e		 DB	 14
  0053f	0e		 DB	 14
  00540	0e		 DB	 14
  00541	0e		 DB	 14
  00542	0e		 DB	 14
  00543	0e		 DB	 14
  00544	0e		 DB	 14
  00545	0e		 DB	 14
  00546	0e		 DB	 14
  00547	0e		 DB	 14
  00548	0e		 DB	 14
  00549	0e		 DB	 14
  0054a	0e		 DB	 14
  0054b	0e		 DB	 14
  0054c	0e		 DB	 14
  0054d	0e		 DB	 14
  0054e	0e		 DB	 14
  0054f	0e		 DB	 14
  00550	0e		 DB	 14
  00551	0e		 DB	 14
  00552	0e		 DB	 14
  00553	0e		 DB	 14
  00554	0e		 DB	 14
  00555	0e		 DB	 14
  00556	0e		 DB	 14
  00557	0e		 DB	 14
  00558	0e		 DB	 14
  00559	0e		 DB	 14
  0055a	0e		 DB	 14
  0055b	0e		 DB	 14
  0055c	0e		 DB	 14
  0055d	0e		 DB	 14
  0055e	0e		 DB	 14
  0055f	0e		 DB	 14
  00560	0e		 DB	 14
  00561	0e		 DB	 14
  00562	0e		 DB	 14
  00563	0d		 DB	 13
s370_dyn_cipher_message_with_chaining ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
msa$ = 52
r1$ = 56
i$1 = 60
tv90 = 64
tv296 = 68
tv305 = 72
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_compute_message_authentication_code PROC

; 4334 : {

$LN38:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4335 :   int msa;
; 4336 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4337 :   {
; 4338 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4339 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4340 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4341 :     { 0xf0, 0x70, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4342 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4343 :   };
; 4344 :   int r1;
; 4345 :   int r2;
; 4346 : 
; 4347 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 38	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4348 :   PER_ZEROADDR_CHECK2( regs, 1, r2 );
; 4349 : 
; 4350 :   /* The following is the same as doing a FACILITY_CHECK */
; 4351 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 34	 mov	 DWORD PTR msa$[rsp], eax

; 4352 :   if(msa < 0)

  0028e	83 7c 24 34 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4353 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4354 : 
; 4355 : #ifdef OPTION_KMAC_DEBUG
; 4356 :   WRMSG(HHC90100, "D", "KMAC: compute message authentication code");
; 4357 :   WRMSG(HHC90101, "D", 2, r2);
; 4358 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4359 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4360 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4361 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4362 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4363 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4364 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 4365 : 
; 4366 :   /* Check special conditions */
; 4367 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002a8	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002ad	74 4f		 je	 SHORT $LN29@s370_dyn_c
  002af	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 44		 jne	 SHORT $LN29@s370_dyn_c
  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d7	85 c0		 test	 eax, eax
  002d9	74 0a		 je	 SHORT $LN30@s370_dyn_c
  002db	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN31@s370_dyn_c
$LN30@s370_dyn_c:
  002e5	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN31@s370_dyn_c:
  002ed	83 7c 24 40 00	 cmp	 DWORD PTR tv90[rsp], 0
  002f2	75 0a		 jne	 SHORT $LN29@s370_dyn_c
  002f4	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
  002fc	eb 08		 jmp	 SHORT $LN36@s370_dyn_c
$LN29@s370_dyn_c:
  002fe	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv296[rsp], 1
$LN36@s370_dyn_c:
  00306	83 7c 24 44 00	 cmp	 DWORD PTR tv296[rsp], 0
  0030b	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4368 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0030d	ba 06 00 00 00	 mov	 edx, 6
  00312	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4369 : 
; 4370 :   switch(GR0_fc(regs))

  00320	b8 08 00 00 00	 mov	 eax, 8
  00325	48 6b c0 00	 imul	 rax, rax, 0
  00329	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00338	83 e0 7f	 and	 eax, 127		; 0000007fH
  0033b	89 44 24 48	 mov	 DWORD PTR tv305[rsp], eax
  0033f	83 7c 24 48 1c	 cmp	 DWORD PTR tv305[rsp], 28
  00344	0f 87 ed 00 00
	00		 ja	 $LN27@s370_dyn_c
  0034a	8b 44 24 48	 mov	 eax, DWORD PTR tv305[rsp]
  0034e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00355	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN37@s370_dyn_c[rcx+rax*4]
  0035c	48 03 c1	 add	 rax, rcx
  0035f	ff e0		 jmp	 rax
$LN10@s370_dyn_c:

; 4371 :   {
; 4372 :     case 0: /* Query */
; 4373 :     {
; 4374 :       /* Store the parameter block */
; 4375 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00361	b8 08 00 00 00	 mov	 eax, 8
  00366	48 6b c0 01	 imul	 rax, rax, 1
  0036a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00372	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00379	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0037e	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00383	48 6b c9 10	 imul	 rcx, rcx, 16
  00387	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0038c	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00394	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00399	41 b9 01 00 00
	00		 mov	 r9d, 1
  0039f	44 8b c0	 mov	 r8d, eax
  003a2	b2 0f		 mov	 dl, 15
  003a4	e8 00 00 00 00	 call	 s370_vstorec

; 4376 : 
; 4377 : #ifdef OPTION_KMAC_DEBUG
; 4378 :       LOGBYTE("output:", query_bits[msa], 16);
; 4379 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 4380 : 
; 4381 :       /* Set condition code 0 */
; 4382 :       regs->psw.cc = 0;

  003a9	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b1	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4383 :       return;

  003b5	e9 90 00 00 00	 jmp	 $LN1@s370_dyn_c
$LN11@s370_dyn_c:
$LN12@s370_dyn_c:
$LN13@s370_dyn_c:

; 4384 :     }
; 4385 :     case 1: /* dea */
; 4386 :     case 2: /* tdea-128 */
; 4387 :     case 3: /* tdea-192 */
; 4388 :     {
; 4389 :       ARCH_DEP(kmac_dea)(r1, r2, regs);

  003ba	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c2	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003c6	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  003ca	e8 00 00 00 00	 call	 s370_kmac_dea

; 4390 :       break;

  003cf	eb 79		 jmp	 SHORT $LN5@s370_dyn_c
$LN14@s370_dyn_c:
$LN15@s370_dyn_c:
$LN16@s370_dyn_c:

; 4391 :     }
; 4392 : 
; 4393 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4394 :     case 9: /* encrypted dea */
; 4395 :     case 10: /* encrypted tdea-128 */
; 4396 :     case 11: /* encrypted tdea-192 */
; 4397 :     {
; 4398 :       if(msa >= 3)

  003d1	83 7c 24 34 03	 cmp	 DWORD PTR msa$[rsp], 3
  003d6	7c 17		 jl	 SHORT $LN17@s370_dyn_c

; 4399 :         ARCH_DEP(kmac_dea)(r1, r2, regs);

  003d8	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003e0	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003e4	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  003e8	e8 00 00 00 00	 call	 s370_kmac_dea
  003ed	eb 13		 jmp	 SHORT $LN18@s370_dyn_c
$LN17@s370_dyn_c:

; 4400 :       else
; 4401 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003ef	ba 06 00 00 00	 mov	 edx, 6
  003f4	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN18@s370_dyn_c:

; 4402 :       break;

  00402	eb 46		 jmp	 SHORT $LN5@s370_dyn_c
$LN19@s370_dyn_c:
$LN20@s370_dyn_c:
$LN21@s370_dyn_c:
$LN22@s370_dyn_c:
$LN23@s370_dyn_c:
$LN24@s370_dyn_c:

; 4403 :     }
; 4404 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4405 : 
; 4406 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4407 :     case 18: /* aes */
; 4408 :     case 19: /* aes-192 */
; 4409 :     case 20: /* aes-256 */
; 4410 :     case 26: /* encrypted aes */
; 4411 :     case 27: /* encrypted aes-192 */
; 4412 :     case 28: /* encrypted aes-256 */
; 4413 :     {
; 4414 :       if(msa >= 4)

  00404	83 7c 24 34 04	 cmp	 DWORD PTR msa$[rsp], 4
  00409	7c 17		 jl	 SHORT $LN25@s370_dyn_c

; 4415 :         ARCH_DEP(kmac_aes)(r1, r2, regs);

  0040b	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00413	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00417	8b 4c 24 38	 mov	 ecx, DWORD PTR r1$[rsp]
  0041b	e8 00 00 00 00	 call	 s370_kmac_aes
  00420	eb 13		 jmp	 SHORT $LN26@s370_dyn_c
$LN25@s370_dyn_c:

; 4416 :       else
; 4417 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00422	ba 06 00 00 00	 mov	 edx, 6
  00427	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0042f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN26@s370_dyn_c:

; 4418 :       break;

  00435	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN27@s370_dyn_c:

; 4419 :     }
; 4420 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4421 : 
; 4422 :     default:
; 4423 :     {
; 4424 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00437	ba 06 00 00 00	 mov	 edx, 6
  0043c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00444	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4425 :       break;
; 4426 :     }
; 4427 :   }
; 4428 : }

  0044a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00452	48 33 cc	 xor	 rcx, rsp
  00455	e8 00 00 00 00	 call	 __security_check_cookie
  0045a	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00461	c3		 ret	 0
  00462	66 90		 npad	 2
$LN37@s370_dyn_c:
  00464	00 00 00 00	 DD	 $LN10@s370_dyn_c
  00468	00 00 00 00	 DD	 $LN11@s370_dyn_c
  0046c	00 00 00 00	 DD	 $LN12@s370_dyn_c
  00470	00 00 00 00	 DD	 $LN13@s370_dyn_c
  00474	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00478	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0047c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00480	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00484	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00488	00 00 00 00	 DD	 $LN14@s370_dyn_c
  0048c	00 00 00 00	 DD	 $LN15@s370_dyn_c
  00490	00 00 00 00	 DD	 $LN16@s370_dyn_c
  00494	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00498	00 00 00 00	 DD	 $LN27@s370_dyn_c
  0049c	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004a0	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004a4	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004a8	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004ac	00 00 00 00	 DD	 $LN19@s370_dyn_c
  004b0	00 00 00 00	 DD	 $LN20@s370_dyn_c
  004b4	00 00 00 00	 DD	 $LN21@s370_dyn_c
  004b8	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004bc	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004c0	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004c4	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004c8	00 00 00 00	 DD	 $LN27@s370_dyn_c
  004cc	00 00 00 00	 DD	 $LN22@s370_dyn_c
  004d0	00 00 00 00	 DD	 $LN23@s370_dyn_c
  004d4	00 00 00 00	 DD	 $LN24@s370_dyn_c
s370_dyn_compute_message_authentication_code ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
r1$ = 52
msa$ = 56
i$1 = 60
tv290 = 64
tv299 = 68
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_cipher_message PROC

; 4190 : {

$LN45:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4191 :   int msa;
; 4192 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 f0	 mov	 BYTE PTR query_bits$[rsp], 240 ; 000000f0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 f0	 mov	 BYTE PTR query_bits$[rsp+16], 240 ; 000000f0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 20	 mov	 BYTE PTR query_bits$[rsp+18], 32 ; 00000020H
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 38	 mov	 BYTE PTR query_bits$[rsp+34], 56 ; 00000038H
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+49], 112 ; 00000070H
  00123	c6 84 24 82 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+50], 56 ; 00000038H
  0012b	c6 84 24 83 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+51], 56 ; 00000038H
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 70	 mov	 BYTE PTR query_bits$[rsp+65], 112 ; 00000070H
  001a3	c6 84 24 92 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+66], 56 ; 00000038H
  001ab	c6 84 24 93 00
	00 00 38	 mov	 BYTE PTR query_bits$[rsp+67], 56 ; 00000038H
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 28	 mov	 BYTE PTR query_bits$[rsp+70], 40 ; 00000028H
  001cb	c6 84 24 97 00
	00 00 28	 mov	 BYTE PTR query_bits$[rsp+71], 40 ; 00000028H
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4193 :   {
; 4194 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4195 :     { 0xf0, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4196 :     { 0xf0, 0x00, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4197 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4198 :     { 0xf0, 0x70, 0x38, 0x38, 0x00, 0x00, 0x28, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4199 :   };
; 4200 :   int r1;
; 4201 :   int r2;
; 4202 : 
; 4203 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 3c	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 3c	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 34	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4204 : 
; 4205 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4206 :     if (0
; 4207 :         || GR_A( 1,  regs ) == 0
; 4208 :         || GR_A( r1, regs ) == 0
; 4209 :         || GR_A( r2, regs ) == 0
; 4210 :     )
; 4211 :         ARCH_DEP( per3_zero )( regs );
; 4212 : #endif
; 4213 : 
; 4214 :   /* The following is the same as doing a FACILITY_CHECK */
; 4215 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4216 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4217 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4218 : 
; 4219 : #ifdef OPTION_KM_DEBUG
; 4220 :   WRMSG(HHC90100, "D", "KM: cipher message");
; 4221 :   WRMSG(HHC90101, "D", 1, r1);
; 4222 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4223 :   WRMSG(HHC90101, "D", 2, r2);
; 4224 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4225 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4226 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4227 :   WRMSG(HHC90107, "D", TRUEFALSE(GR0_m(regs)));
; 4228 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4229 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4230 : #endif /* #ifdef OPTION_KM_DEBUG */
; 4231 : 
; 4232 :   /* Check special conditions */
; 4233 :   if(unlikely(!r1 || r1 & 0x01 || !r2 || r2 & 0x01))

  002a8	83 7c 24 34 00	 cmp	 DWORD PTR r1$[rsp], 0
  002ad	74 27		 je	 SHORT $LN39@s370_dyn_c
  002af	8b 44 24 34	 mov	 eax, DWORD PTR r1$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 1c		 jne	 SHORT $LN39@s370_dyn_c
  002ba	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002bf	74 15		 je	 SHORT $LN39@s370_dyn_c
  002c1	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002c5	83 e0 01	 and	 eax, 1
  002c8	85 c0		 test	 eax, eax
  002ca	75 0a		 jne	 SHORT $LN39@s370_dyn_c
  002cc	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN42@s370_dyn_c
$LN39@s370_dyn_c:
  002d6	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
$LN42@s370_dyn_c:
  002de	83 7c 24 40 00	 cmp	 DWORD PTR tv290[rsp], 0
  002e3	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4234 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  002e5	ba 06 00 00 00	 mov	 edx, 6
  002ea	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4235 : 
; 4236 :   switch(GR0_fc(regs))

  002f8	b8 08 00 00 00	 mov	 eax, 8
  002fd	48 6b c0 00	 imul	 rax, rax, 0
  00301	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00310	83 e0 7f	 and	 eax, 127		; 0000007fH
  00313	89 44 24 44	 mov	 DWORD PTR tv299[rsp], eax
  00317	83 7c 24 44 3c	 cmp	 DWORD PTR tv299[rsp], 60 ; 0000003cH
  0031c	0f 87 97 01 00
	00		 ja	 $LN37@s370_dyn_c
  00322	8b 44 24 44	 mov	 eax, DWORD PTR tv299[rsp]
  00326	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0032d	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN43@s370_dyn_c[rcx+rax]
  00335	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN44@s370_dyn_c[rcx+rax*4]
  0033c	48 03 c1	 add	 rax, rcx
  0033f	ff e0		 jmp	 rax
$LN10@s370_dyn_c:

; 4237 :   {
; 4238 :     case 0: /* Query */
; 4239 :     {
; 4240 :       /* Store the parameter block */
; 4241 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00341	b8 08 00 00 00	 mov	 eax, 8
  00346	48 6b c0 01	 imul	 rax, rax, 1
  0034a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00352	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00359	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0035e	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00363	48 6b c9 10	 imul	 rcx, rcx, 16
  00367	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0036c	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00374	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00379	41 b9 01 00 00
	00		 mov	 r9d, 1
  0037f	44 8b c0	 mov	 r8d, eax
  00382	b2 0f		 mov	 dl, 15
  00384	e8 00 00 00 00	 call	 s370_vstorec

; 4242 : 
; 4243 : #ifdef OPTION_KM_DEBUG
; 4244 :       LOGBYTE("output:", query_bits[msa], 16);
; 4245 : #endif /* #ifdef OPTION_KM_DEBUG */
; 4246 : 
; 4247 :       /* Set condition code 0 */
; 4248 :       regs->psw.cc = 0;

  00389	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00391	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4249 :       return;

  00395	e9 32 01 00 00	 jmp	 $LN1@s370_dyn_c
$LN11@s370_dyn_c:
$LN12@s370_dyn_c:
$LN13@s370_dyn_c:

; 4250 :     }
; 4251 :     case 1: /* dea */
; 4252 :     case 2: /* tdea-128 */
; 4253 :     case 3: /* tdea-192 */
; 4254 :     {
; 4255 :       ARCH_DEP(km_dea)(r1, r2, regs);

  0039a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003a2	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003a6	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003aa	e8 00 00 00 00	 call	 s370_km_dea

; 4256 :       break;

  003af	e9 18 01 00 00	 jmp	 $LN5@s370_dyn_c
$LN14@s370_dyn_c:
$LN15@s370_dyn_c:
$LN16@s370_dyn_c:

; 4257 :     }
; 4258 : 
; 4259 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4260 :     case 9: /* encrypted dea */
; 4261 :     case 10: /* encrypted tdea-128 */
; 4262 :     case 11: /* encrypted tdea-192 */
; 4263 :     {
; 4264 :       if(msa >= 3)

  003b4	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  003b9	7c 17		 jl	 SHORT $LN17@s370_dyn_c

; 4265 :         ARCH_DEP(km_dea)(r1, r2, regs);

  003bb	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c3	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003c7	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  003cb	e8 00 00 00 00	 call	 s370_km_dea
  003d0	eb 13		 jmp	 SHORT $LN18@s370_dyn_c
$LN17@s370_dyn_c:

; 4266 :       else
; 4267 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003d2	ba 06 00 00 00	 mov	 edx, 6
  003d7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN18@s370_dyn_c:

; 4268 :       break;

  003e5	e9 e2 00 00 00	 jmp	 $LN5@s370_dyn_c
$LN19@s370_dyn_c:

; 4269 :     }
; 4270 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4271 : 
; 4272 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4273 :     case 18: /* aes-128 */
; 4274 :     {
; 4275 :       if(msa >= 1)

  003ea	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003ef	7c 17		 jl	 SHORT $LN20@s370_dyn_c

; 4276 :         ARCH_DEP(km_aes)(r1, r2, regs);

  003f1	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003f9	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003fd	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00401	e8 00 00 00 00	 call	 s370_km_aes
  00406	eb 13		 jmp	 SHORT $LN21@s370_dyn_c
$LN20@s370_dyn_c:

; 4277 :       else
; 4278 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00408	ba 06 00 00 00	 mov	 edx, 6
  0040d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00415	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN21@s370_dyn_c:

; 4279 :       break;

  0041b	e9 ac 00 00 00	 jmp	 $LN5@s370_dyn_c
$LN22@s370_dyn_c:
$LN23@s370_dyn_c:

; 4280 :     }
; 4281 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4282 : 
; 4283 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4284 :     case 19: /* aes-192 */
; 4285 :     case 20: /* aes-256 */
; 4286 :     {
; 4287 :       if(msa >= 2)

  00420	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  00425	7c 17		 jl	 SHORT $LN24@s370_dyn_c

; 4288 :         ARCH_DEP(km_aes)(r1, r2, regs);

  00427	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0042f	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00433	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  00437	e8 00 00 00 00	 call	 s370_km_aes
  0043c	eb 13		 jmp	 SHORT $LN25@s370_dyn_c
$LN24@s370_dyn_c:

; 4289 :       else
; 4290 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0043e	ba 06 00 00 00	 mov	 edx, 6
  00443	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN25@s370_dyn_c:

; 4291 :       break;

  00451	eb 79		 jmp	 SHORT $LN5@s370_dyn_c
$LN26@s370_dyn_c:
$LN27@s370_dyn_c:
$LN28@s370_dyn_c:

; 4292 :     }
; 4293 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4294 : 
; 4295 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 4296 :     case 26: /* encrypted aes-128 */
; 4297 :     case 27: /* encrypted aes-192 */
; 4298 :     case 28: /* encrypted aes-256 */
; 4299 :     {
; 4300 :       if(msa >= 3)

  00453	83 7c 24 38 03	 cmp	 DWORD PTR msa$[rsp], 3
  00458	7c 17		 jl	 SHORT $LN29@s370_dyn_c

; 4301 :         ARCH_DEP(km_aes)(r1, r2, regs);

  0045a	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00462	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00466	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0046a	e8 00 00 00 00	 call	 s370_km_aes
  0046f	eb 13		 jmp	 SHORT $LN30@s370_dyn_c
$LN29@s370_dyn_c:

; 4302 :       else
; 4303 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00471	ba 06 00 00 00	 mov	 edx, 6
  00476	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN30@s370_dyn_c:

; 4304 :       break;

  00484	eb 46		 jmp	 SHORT $LN5@s370_dyn_c
$LN31@s370_dyn_c:
$LN32@s370_dyn_c:
$LN33@s370_dyn_c:
$LN34@s370_dyn_c:

; 4305 :     }
; 4306 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 4307 : 
; 4308 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4309 :     case 50: /* xts aes-128 */
; 4310 :     case 52: /* xts aes-256 */
; 4311 :     case 58: /* encrypted xts aes-128 */
; 4312 :     case 60: /* encrypted xts aes-256 */
; 4313 :     {
; 4314 :       if(msa >= 4)

  00486	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0048b	7c 17		 jl	 SHORT $LN35@s370_dyn_c

; 4315 :         ARCH_DEP(km_xts_aes)(r1, r2, regs);

  0048d	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00495	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00499	8b 4c 24 34	 mov	 ecx, DWORD PTR r1$[rsp]
  0049d	e8 00 00 00 00	 call	 s370_km_xts_aes
  004a2	eb 13		 jmp	 SHORT $LN36@s370_dyn_c
$LN35@s370_dyn_c:

; 4316 :       else
; 4317 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004a4	ba 06 00 00 00	 mov	 edx, 6
  004a9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN36@s370_dyn_c:

; 4318 :       break;

  004b7	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN37@s370_dyn_c:

; 4319 :     }
; 4320 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4321 : 
; 4322 :     default:
; 4323 :     {
; 4324 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  004b9	ba 06 00 00 00	 mov	 edx, 6
  004be	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4325 :       break;
; 4326 :     }
; 4327 :   }
; 4328 : }

  004cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004d4	48 33 cc	 xor	 rcx, rsp
  004d7	e8 00 00 00 00	 call	 __security_check_cookie
  004dc	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  004e3	c3		 ret	 0
$LN44@s370_dyn_c:
  004e4	00 00 00 00	 DD	 $LN10@s370_dyn_c
  004e8	00 00 00 00	 DD	 $LN11@s370_dyn_c
  004ec	00 00 00 00	 DD	 $LN12@s370_dyn_c
  004f0	00 00 00 00	 DD	 $LN13@s370_dyn_c
  004f4	00 00 00 00	 DD	 $LN14@s370_dyn_c
  004f8	00 00 00 00	 DD	 $LN15@s370_dyn_c
  004fc	00 00 00 00	 DD	 $LN16@s370_dyn_c
  00500	00 00 00 00	 DD	 $LN19@s370_dyn_c
  00504	00 00 00 00	 DD	 $LN22@s370_dyn_c
  00508	00 00 00 00	 DD	 $LN23@s370_dyn_c
  0050c	00 00 00 00	 DD	 $LN26@s370_dyn_c
  00510	00 00 00 00	 DD	 $LN27@s370_dyn_c
  00514	00 00 00 00	 DD	 $LN28@s370_dyn_c
  00518	00 00 00 00	 DD	 $LN31@s370_dyn_c
  0051c	00 00 00 00	 DD	 $LN32@s370_dyn_c
  00520	00 00 00 00	 DD	 $LN33@s370_dyn_c
  00524	00 00 00 00	 DD	 $LN34@s370_dyn_c
  00528	00 00 00 00	 DD	 $LN37@s370_dyn_c
$LN43@s370_dyn_c:
  0052c	00		 DB	 0
  0052d	01		 DB	 1
  0052e	02		 DB	 2
  0052f	03		 DB	 3
  00530	11		 DB	 17
  00531	11		 DB	 17
  00532	11		 DB	 17
  00533	11		 DB	 17
  00534	11		 DB	 17
  00535	04		 DB	 4
  00536	05		 DB	 5
  00537	06		 DB	 6
  00538	11		 DB	 17
  00539	11		 DB	 17
  0053a	11		 DB	 17
  0053b	11		 DB	 17
  0053c	11		 DB	 17
  0053d	11		 DB	 17
  0053e	07		 DB	 7
  0053f	08		 DB	 8
  00540	09		 DB	 9
  00541	11		 DB	 17
  00542	11		 DB	 17
  00543	11		 DB	 17
  00544	11		 DB	 17
  00545	11		 DB	 17
  00546	0a		 DB	 10
  00547	0b		 DB	 11
  00548	0c		 DB	 12
  00549	11		 DB	 17
  0054a	11		 DB	 17
  0054b	11		 DB	 17
  0054c	11		 DB	 17
  0054d	11		 DB	 17
  0054e	11		 DB	 17
  0054f	11		 DB	 17
  00550	11		 DB	 17
  00551	11		 DB	 17
  00552	11		 DB	 17
  00553	11		 DB	 17
  00554	11		 DB	 17
  00555	11		 DB	 17
  00556	11		 DB	 17
  00557	11		 DB	 17
  00558	11		 DB	 17
  00559	11		 DB	 17
  0055a	11		 DB	 17
  0055b	11		 DB	 17
  0055c	11		 DB	 17
  0055d	11		 DB	 17
  0055e	0d		 DB	 13
  0055f	11		 DB	 17
  00560	0e		 DB	 14
  00561	11		 DB	 17
  00562	11		 DB	 17
  00563	11		 DB	 17
  00564	11		 DB	 17
  00565	11		 DB	 17
  00566	0f		 DB	 15
  00567	11		 DB	 17
  00568	10		 DB	 16
s370_dyn_cipher_message ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
tv305 = 52
msa$ = 56
r1$ = 60
i$1 = 64
tv90 = 68
tv296 = 72
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_compute_last_message_digest PROC

; 4090 : {

$LN28:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4091 :   int msa;
; 4092 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 c0	 mov	 BYTE PTR query_bits$[rsp], 192 ; 000000c0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 e0	 mov	 BYTE PTR query_bits$[rsp+16], 224 ; 000000e0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  001a3	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+66], 0
  001ab	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+72], 0
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 4093 :   {
; 4094 :     { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4095 :     { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4096 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4097 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 4098 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 4099 :   };
; 4100 :   int r1;
; 4101 :   int r2;
; 4102 : 
; 4103 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4104 : 
; 4105 : #if defined( FEATURE_PER_ZERO_ADDRESS_DETECTION_FACILITY )
; 4106 :     if (0
; 4107 :         || GR_A( 1,  regs ) == 0
; 4108 :         || GR_A( r1, regs ) == 0
; 4109 :         || GR_A( r2, regs ) == 0
; 4110 :     )
; 4111 :         ARCH_DEP( per3_zero )( regs );
; 4112 : #endif
; 4113 : 
; 4114 :   /* The following is the same as doing a FACILITY_CHECK */
; 4115 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4116 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4117 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4118 : 
; 4119 : #ifdef OPTION_KLMD_DEBUG
; 4120 :   WRMSG(HHC90100, "D", "KLMD: compute last message digest");
; 4121 :   WRMSG(HHC90101, "D", 1, r1);
; 4122 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4123 :   WRMSG(HHC90101, "D", 2, r2);
; 4124 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4125 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4126 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4127 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4128 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4129 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4130 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 4131 : 
; 4132 :   /* Check special conditions */
; 4133 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002a8	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002ad	74 4f		 je	 SHORT $LN20@s370_dyn_c
  002af	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 44		 jne	 SHORT $LN20@s370_dyn_c
  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d7	85 c0		 test	 eax, eax
  002d9	74 0a		 je	 SHORT $LN21@s370_dyn_c
  002db	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN22@s370_dyn_c
$LN21@s370_dyn_c:
  002e5	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN22@s370_dyn_c:
  002ed	83 7c 24 44 00	 cmp	 DWORD PTR tv90[rsp], 0
  002f2	75 0a		 jne	 SHORT $LN20@s370_dyn_c
  002f4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
  002fc	eb 08		 jmp	 SHORT $LN27@s370_dyn_c
$LN20@s370_dyn_c:
  002fe	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv296[rsp], 1
$LN27@s370_dyn_c:
  00306	83 7c 24 48 00	 cmp	 DWORD PTR tv296[rsp], 0
  0030b	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4134 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0030d	ba 06 00 00 00	 mov	 edx, 6
  00312	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4135 : 
; 4136 :   switch(GR0_fc(regs))

  00320	b8 08 00 00 00	 mov	 eax, 8
  00325	48 6b c0 00	 imul	 rax, rax, 0
  00329	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00338	83 e0 7f	 and	 eax, 127		; 0000007fH
  0033b	89 44 24 34	 mov	 DWORD PTR tv305[rsp], eax
  0033f	83 7c 24 34 00	 cmp	 DWORD PTR tv305[rsp], 0
  00344	74 22		 je	 SHORT $LN10@s370_dyn_c
  00346	83 7c 24 34 01	 cmp	 DWORD PTR tv305[rsp], 1
  0034b	74 74		 je	 SHORT $LN11@s370_dyn_c
  0034d	83 7c 24 34 02	 cmp	 DWORD PTR tv305[rsp], 2
  00352	0f 84 80 00 00
	00		 je	 $LN12@s370_dyn_c
  00358	83 7c 24 34 03	 cmp	 DWORD PTR tv305[rsp], 3
  0035d	0f 84 a8 00 00
	00		 je	 $LN15@s370_dyn_c
  00363	e9 d6 00 00 00	 jmp	 $LN18@s370_dyn_c
$LN10@s370_dyn_c:

; 4137 :   {
; 4138 :     case 0: /* Query */
; 4139 :     {
; 4140 :       /* Store the parameter block */
; 4141 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00368	b8 08 00 00 00	 mov	 eax, 8
  0036d	48 6b c0 01	 imul	 rax, rax, 1
  00371	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00379	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00380	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00385	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  0038a	48 6b c9 10	 imul	 rcx, rcx, 16
  0038e	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  00393	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0039b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003a0	41 b9 01 00 00
	00		 mov	 r9d, 1
  003a6	44 8b c0	 mov	 r8d, eax
  003a9	b2 0f		 mov	 dl, 15
  003ab	e8 00 00 00 00	 call	 s370_vstorec

; 4142 : 
; 4143 : #ifdef OPTION_KLMD_DEBUG
; 4144 :       LOGBYTE("output:", query_bits[msa], 16);
; 4145 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 4146 : 
; 4147 :       /* Set condition code 0 */
; 4148 :       regs->psw.cc = 0;

  003b0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4149 :       return;

  003bc	e9 90 00 00 00	 jmp	 $LN1@s370_dyn_c
$LN11@s370_dyn_c:

; 4150 :     }
; 4151 :     case 1: /* sha-1 */
; 4152 :     {
; 4153 :       ARCH_DEP(klmd_sha)(r1, r2, regs);

  003c1	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003c9	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003cd	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003d1	e8 00 00 00 00	 call	 s370_klmd_sha

; 4154 :       break;

  003d6	eb 79		 jmp	 SHORT $LN5@s370_dyn_c
$LN12@s370_dyn_c:

; 4155 :     }
; 4156 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4157 :     case 2: /* sha-256 */
; 4158 :     {
; 4159 :       if(msa >= 1)

  003d8	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003dd	7c 17		 jl	 SHORT $LN13@s370_dyn_c

; 4160 :         ARCH_DEP(klmd_sha)(r1, r2, regs);

  003df	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003e7	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003eb	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003ef	e8 00 00 00 00	 call	 s370_klmd_sha
  003f4	eb 13		 jmp	 SHORT $LN14@s370_dyn_c
$LN13@s370_dyn_c:

; 4161 :       else
; 4162 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  003f6	ba 06 00 00 00	 mov	 edx, 6
  003fb	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00403	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN14@s370_dyn_c:

; 4163 :       break;

  00409	eb 46		 jmp	 SHORT $LN5@s370_dyn_c
$LN15@s370_dyn_c:

; 4164 :     }
; 4165 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4166 : 
; 4167 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4168 :     case 3: /* sha-512 */
; 4169 :     {
; 4170 :       if(msa >= 2)

  0040b	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  00410	7c 17		 jl	 SHORT $LN16@s370_dyn_c

; 4171 :         ARCH_DEP(klmd_sha)(r1, r2, regs);

  00412	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  0041a	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  0041e	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00422	e8 00 00 00 00	 call	 s370_klmd_sha
  00427	eb 13		 jmp	 SHORT $LN17@s370_dyn_c
$LN16@s370_dyn_c:

; 4172 :       else
; 4173 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00429	ba 06 00 00 00	 mov	 edx, 6
  0042e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN17@s370_dyn_c:

; 4174 :       break;

  0043c	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN18@s370_dyn_c:

; 4175 :     }
; 4176 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4177 : 
; 4178 :     default:
; 4179 :     {
; 4180 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0043e	ba 06 00 00 00	 mov	 edx, 6
  00443	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4181 :       break;
; 4182 :     }
; 4183 :   }
; 4184 : }

  00451	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00459	48 33 cc	 xor	 rcx, rsp
  0045c	e8 00 00 00 00	 call	 __security_check_cookie
  00461	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00468	c3		 ret	 0
s370_dyn_compute_last_message_digest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
r2$ = 48
tv305 = 52
msa$ = 56
r1$ = 60
i$1 = 64
tv90 = 68
tv296 = 72
query_bits$ = 80
__$ArrayPad$ = 160
inst$ = 192
regs$ = 200
s370_dyn_compute_intermediate_message_digest PROC

; 3986 : {

$LN31:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3987 :   int msa;
; 3988 :   BYTE query_bits[][16] =

  00023	c6 44 24 50 c0	 mov	 BYTE PTR query_bits$[rsp], 192 ; 000000c0H
  00028	c6 44 24 51 00	 mov	 BYTE PTR query_bits$[rsp+1], 0
  0002d	c6 44 24 52 00	 mov	 BYTE PTR query_bits$[rsp+2], 0
  00032	c6 44 24 53 00	 mov	 BYTE PTR query_bits$[rsp+3], 0
  00037	c6 44 24 54 00	 mov	 BYTE PTR query_bits$[rsp+4], 0
  0003c	c6 44 24 55 00	 mov	 BYTE PTR query_bits$[rsp+5], 0
  00041	c6 44 24 56 00	 mov	 BYTE PTR query_bits$[rsp+6], 0
  00046	c6 44 24 57 00	 mov	 BYTE PTR query_bits$[rsp+7], 0
  0004b	c6 44 24 58 00	 mov	 BYTE PTR query_bits$[rsp+8], 0
  00050	c6 44 24 59 00	 mov	 BYTE PTR query_bits$[rsp+9], 0
  00055	c6 44 24 5a 00	 mov	 BYTE PTR query_bits$[rsp+10], 0
  0005a	c6 44 24 5b 00	 mov	 BYTE PTR query_bits$[rsp+11], 0
  0005f	c6 44 24 5c 00	 mov	 BYTE PTR query_bits$[rsp+12], 0
  00064	c6 44 24 5d 00	 mov	 BYTE PTR query_bits$[rsp+13], 0
  00069	c6 44 24 5e 00	 mov	 BYTE PTR query_bits$[rsp+14], 0
  0006e	c6 44 24 5f 00	 mov	 BYTE PTR query_bits$[rsp+15], 0
  00073	c6 44 24 60 e0	 mov	 BYTE PTR query_bits$[rsp+16], 224 ; 000000e0H
  00078	c6 44 24 61 00	 mov	 BYTE PTR query_bits$[rsp+17], 0
  0007d	c6 44 24 62 00	 mov	 BYTE PTR query_bits$[rsp+18], 0
  00082	c6 44 24 63 00	 mov	 BYTE PTR query_bits$[rsp+19], 0
  00087	c6 44 24 64 00	 mov	 BYTE PTR query_bits$[rsp+20], 0
  0008c	c6 44 24 65 00	 mov	 BYTE PTR query_bits$[rsp+21], 0
  00091	c6 44 24 66 00	 mov	 BYTE PTR query_bits$[rsp+22], 0
  00096	c6 44 24 67 00	 mov	 BYTE PTR query_bits$[rsp+23], 0
  0009b	c6 44 24 68 00	 mov	 BYTE PTR query_bits$[rsp+24], 0
  000a0	c6 44 24 69 00	 mov	 BYTE PTR query_bits$[rsp+25], 0
  000a5	c6 44 24 6a 00	 mov	 BYTE PTR query_bits$[rsp+26], 0
  000aa	c6 44 24 6b 00	 mov	 BYTE PTR query_bits$[rsp+27], 0
  000af	c6 44 24 6c 00	 mov	 BYTE PTR query_bits$[rsp+28], 0
  000b4	c6 44 24 6d 00	 mov	 BYTE PTR query_bits$[rsp+29], 0
  000b9	c6 44 24 6e 00	 mov	 BYTE PTR query_bits$[rsp+30], 0
  000be	c6 44 24 6f 00	 mov	 BYTE PTR query_bits$[rsp+31], 0
  000c3	c6 44 24 70 f0	 mov	 BYTE PTR query_bits$[rsp+32], 240 ; 000000f0H
  000c8	c6 44 24 71 00	 mov	 BYTE PTR query_bits$[rsp+33], 0
  000cd	c6 44 24 72 00	 mov	 BYTE PTR query_bits$[rsp+34], 0
  000d2	c6 44 24 73 00	 mov	 BYTE PTR query_bits$[rsp+35], 0
  000d7	c6 44 24 74 00	 mov	 BYTE PTR query_bits$[rsp+36], 0
  000dc	c6 44 24 75 00	 mov	 BYTE PTR query_bits$[rsp+37], 0
  000e1	c6 44 24 76 00	 mov	 BYTE PTR query_bits$[rsp+38], 0
  000e6	c6 44 24 77 00	 mov	 BYTE PTR query_bits$[rsp+39], 0
  000eb	c6 44 24 78 00	 mov	 BYTE PTR query_bits$[rsp+40], 0
  000f0	c6 44 24 79 00	 mov	 BYTE PTR query_bits$[rsp+41], 0
  000f5	c6 44 24 7a 00	 mov	 BYTE PTR query_bits$[rsp+42], 0
  000fa	c6 44 24 7b 00	 mov	 BYTE PTR query_bits$[rsp+43], 0
  000ff	c6 44 24 7c 00	 mov	 BYTE PTR query_bits$[rsp+44], 0
  00104	c6 44 24 7d 00	 mov	 BYTE PTR query_bits$[rsp+45], 0
  00109	c6 44 24 7e 00	 mov	 BYTE PTR query_bits$[rsp+46], 0
  0010e	c6 44 24 7f 00	 mov	 BYTE PTR query_bits$[rsp+47], 0
  00113	c6 84 24 80 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+48], 240 ; 000000f0H
  0011b	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+49], 0
  00123	c6 84 24 82 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+50], 0
  0012b	c6 84 24 83 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+51], 0
  00133	c6 84 24 84 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+52], 0
  0013b	c6 84 24 85 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+53], 0
  00143	c6 84 24 86 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+54], 0
  0014b	c6 84 24 87 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+55], 0
  00153	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+56], 0
  0015b	c6 84 24 89 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+57], 0
  00163	c6 84 24 8a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+58], 0
  0016b	c6 84 24 8b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+59], 0
  00173	c6 84 24 8c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+60], 0
  0017b	c6 84 24 8d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+61], 0
  00183	c6 84 24 8e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+62], 0
  0018b	c6 84 24 8f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+63], 0
  00193	c6 84 24 90 00
	00 00 f0	 mov	 BYTE PTR query_bits$[rsp+64], 240 ; 000000f0H
  0019b	c6 84 24 91 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+65], 0
  001a3	c6 84 24 92 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+66], 0
  001ab	c6 84 24 93 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+67], 0
  001b3	c6 84 24 94 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+68], 0
  001bb	c6 84 24 95 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+69], 0
  001c3	c6 84 24 96 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+70], 0
  001cb	c6 84 24 97 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+71], 0
  001d3	c6 84 24 98 00
	00 00 40	 mov	 BYTE PTR query_bits$[rsp+72], 64 ; 00000040H
  001db	c6 84 24 99 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+73], 0
  001e3	c6 84 24 9a 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+74], 0
  001eb	c6 84 24 9b 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+75], 0
  001f3	c6 84 24 9c 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+76], 0
  001fb	c6 84 24 9d 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+77], 0
  00203	c6 84 24 9e 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+78], 0
  0020b	c6 84 24 9f 00
	00 00 00	 mov	 BYTE PTR query_bits$[rsp+79], 0

; 3989 :   {
; 3990 :     { 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3991 :     { 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3992 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3993 :     /**/ { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
; 3994 :     { 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }
; 3995 :   };
; 3996 :   int r1;
; 3997 :   int r2;
; 3998 : 
; 3999 :   RRE(inst, regs, r1, r2);

  00213	b8 01 00 00 00	 mov	 eax, 1
  00218	48 6b c0 03	 imul	 rax, rax, 3
  0021c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR inst$[rsp]
  00224	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00228	89 44 24 40	 mov	 DWORD PTR i$1[rsp], eax
  0022c	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  00230	83 e0 0f	 and	 eax, 15
  00233	89 44 24 30	 mov	 DWORD PTR r2$[rsp], eax
  00237	8b 44 24 40	 mov	 eax, DWORD PTR i$1[rsp]
  0023b	c1 f8 04	 sar	 eax, 4
  0023e	83 e0 0f	 and	 eax, 15
  00241	89 44 24 3c	 mov	 DWORD PTR r1$[rsp], eax
$LN4@s370_dyn_c:
  00245	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0024d	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00251	48 83 c0 04	 add	 rax, 4
  00255	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0025d	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
  00261	33 c0		 xor	 eax, eax
  00263	83 f8 04	 cmp	 eax, 4
  00266	74 0f		 je	 SHORT $LN7@s370_dyn_c
  00268	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	c6 80 9a 00 00
	00 04		 mov	 BYTE PTR [rax+154], 4
$LN7@s370_dyn_c:
  00277	33 c0		 xor	 eax, eax
  00279	85 c0		 test	 eax, eax
  0027b	75 c8		 jne	 SHORT $LN4@s370_dyn_c

; 4000 :   PER_ZEROADDR_CHECK2( regs, 1, r2 );
; 4001 : 
; 4002 :   /* The following is the same as doing a FACILITY_CHECK */
; 4003 :   msa = get_msa(regs);

  0027d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00285	e8 00 00 00 00	 call	 get_msa
  0028a	89 44 24 38	 mov	 DWORD PTR msa$[rsp], eax

; 4004 :   if(msa < 0)

  0028e	83 7c 24 38 00	 cmp	 DWORD PTR msa$[rsp], 0
  00293	7d 13		 jge	 SHORT $LN8@s370_dyn_c

; 4005 :     ARCH_DEP(program_interrupt)(regs, PGM_OPERATION_EXCEPTION);

  00295	ba 01 00 00 00	 mov	 edx, 1
  0029a	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_dyn_c:

; 4006 : 
; 4007 : #ifdef OPTION_KIMD_DEBUG
; 4008 :   WRMSG(HHC90100, "D", "KIMD: compute intermediate message digest");
; 4009 :   WRMSG(HHC90101, "D", 1, r1);
; 4010 :   WRMSG(HHC90102, "D", regs->GR(r1));
; 4011 :   WRMSG(HHC90101, "D", 2, r2);
; 4012 :   WRMSG(HHC90102, "D", regs->GR(r2));
; 4013 :   WRMSG(HHC90103, "D", regs->GR(r2 + 1));
; 4014 :   WRMSG(HHC90104, "D", 0, regs->GR(0));
; 4015 :   WRMSG(HHC90105, "D", TRUEFALSE(GR0_m(regs)));
; 4016 :   WRMSG(HHC90106, "D", GR0_fc(regs));
; 4017 :   WRMSG(HHC90104, "D", 1, regs->GR(1));
; 4018 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 4019 : 
; 4020 :   /* Check special conditions */
; 4021 :   if(unlikely(!r2 || r2 & 0x01 || GR0_m(regs)))

  002a8	83 7c 24 30 00	 cmp	 DWORD PTR r2$[rsp], 0
  002ad	74 4f		 je	 SHORT $LN23@s370_dyn_c
  002af	8b 44 24 30	 mov	 eax, DWORD PTR r2$[rsp]
  002b3	83 e0 01	 and	 eax, 1
  002b6	85 c0		 test	 eax, eax
  002b8	75 44		 jne	 SHORT $LN23@s370_dyn_c
  002ba	b8 08 00 00 00	 mov	 eax, 8
  002bf	48 6b c0 00	 imul	 rax, rax, 0
  002c3	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002cb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  002d2	25 80 00 00 00	 and	 eax, 128		; 00000080H
  002d7	85 c0		 test	 eax, eax
  002d9	74 0a		 je	 SHORT $LN24@s370_dyn_c
  002db	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN25@s370_dyn_c
$LN24@s370_dyn_c:
  002e5	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN25@s370_dyn_c:
  002ed	83 7c 24 44 00	 cmp	 DWORD PTR tv90[rsp], 0
  002f2	75 0a		 jne	 SHORT $LN23@s370_dyn_c
  002f4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv296[rsp], 0
  002fc	eb 08		 jmp	 SHORT $LN30@s370_dyn_c
$LN23@s370_dyn_c:
  002fe	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv296[rsp], 1
$LN30@s370_dyn_c:
  00306	83 7c 24 48 00	 cmp	 DWORD PTR tv296[rsp], 0
  0030b	74 13		 je	 SHORT $LN9@s370_dyn_c

; 4022 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0030d	ba 06 00 00 00	 mov	 edx, 6
  00312	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_dyn_c:

; 4023 : 
; 4024 :   switch(GR0_fc(regs))

  00320	b8 08 00 00 00	 mov	 eax, 8
  00325	48 6b c0 00	 imul	 rax, rax, 0
  00329	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00331	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00338	83 e0 7f	 and	 eax, 127		; 0000007fH
  0033b	89 44 24 34	 mov	 DWORD PTR tv305[rsp], eax
  0033f	83 7c 24 34 00	 cmp	 DWORD PTR tv305[rsp], 0
  00344	74 2d		 je	 SHORT $LN10@s370_dyn_c
  00346	83 7c 24 34 01	 cmp	 DWORD PTR tv305[rsp], 1
  0034b	74 7f		 je	 SHORT $LN11@s370_dyn_c
  0034d	83 7c 24 34 02	 cmp	 DWORD PTR tv305[rsp], 2
  00352	0f 84 91 00 00
	00		 je	 $LN12@s370_dyn_c
  00358	83 7c 24 34 03	 cmp	 DWORD PTR tv305[rsp], 3
  0035d	0f 84 bc 00 00
	00		 je	 $LN15@s370_dyn_c
  00363	83 7c 24 34 41	 cmp	 DWORD PTR tv305[rsp], 65 ; 00000041H
  00368	0f 84 e7 00 00
	00		 je	 $LN18@s370_dyn_c
  0036e	e9 15 01 00 00	 jmp	 $LN21@s370_dyn_c
$LN10@s370_dyn_c:

; 4025 :   {
; 4026 :     case 0: /* Query */
; 4027 :     {
; 4028 :       /* Store the parameter block */
; 4029 :       ARCH_DEP(vstorec)(query_bits[msa], 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00373	b8 08 00 00 00	 mov	 eax, 8
  00378	48 6b c0 01	 imul	 rax, rax, 1
  0037c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00384	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0038b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00390	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR msa$[rsp]
  00395	48 6b c9 10	 imul	 rcx, rcx, 16
  00399	48 8d 4c 0c 50	 lea	 rcx, QWORD PTR query_bits$[rsp+rcx]
  0039e	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003a6	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  003ab	41 b9 01 00 00
	00		 mov	 r9d, 1
  003b1	44 8b c0	 mov	 r8d, eax
  003b4	b2 0f		 mov	 dl, 15
  003b6	e8 00 00 00 00	 call	 s370_vstorec

; 4030 : 
; 4031 : #ifdef OPTION_KIMD_DEBUG
; 4032 :       LOGBYTE("output:", query_bits[msa], 16);
; 4033 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 4034 : 
; 4035 :       /* Set condition code 0 */
; 4036 :       regs->psw.cc = 0;

  003bb	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 4037 :       return;

  003c7	e9 cf 00 00 00	 jmp	 $LN1@s370_dyn_c
$LN11@s370_dyn_c:

; 4038 :     }
; 4039 :     case 1: /* sha-1 */
; 4040 :     {
; 4041 :       ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  003cc	45 33 c9	 xor	 r9d, r9d
  003cf	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003d7	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003db	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  003df	e8 00 00 00 00	 call	 s370_kimd_sha

; 4042 :       break;

  003e4	e9 b2 00 00 00	 jmp	 $LN5@s370_dyn_c
$LN12@s370_dyn_c:

; 4043 :     }
; 4044 : 
; 4045 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 4046 :     case 2: /* sha-256 */
; 4047 :     {
; 4048 :       if(msa >= 1)

  003e9	83 7c 24 38 01	 cmp	 DWORD PTR msa$[rsp], 1
  003ee	7c 1a		 jl	 SHORT $LN13@s370_dyn_c

; 4049 :         ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  003f0	45 33 c9	 xor	 r9d, r9d
  003f3	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  003fb	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  003ff	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00403	e8 00 00 00 00	 call	 s370_kimd_sha
  00408	eb 13		 jmp	 SHORT $LN14@s370_dyn_c
$LN13@s370_dyn_c:

; 4050 :       else
; 4051 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0040a	ba 06 00 00 00	 mov	 edx, 6
  0040f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00417	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN14@s370_dyn_c:

; 4052 :       break;

  0041d	eb 7c		 jmp	 SHORT $LN5@s370_dyn_c
$LN15@s370_dyn_c:

; 4053 :     }
; 4054 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 4055 : 
; 4056 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 4057 :     case 3: /* sha-512 */
; 4058 :     {
; 4059 :       if(msa >= 2)

  0041f	83 7c 24 38 02	 cmp	 DWORD PTR msa$[rsp], 2
  00424	7c 1a		 jl	 SHORT $LN16@s370_dyn_c

; 4060 :         ARCH_DEP(kimd_sha)(r1, r2, regs, 0);

  00426	45 33 c9	 xor	 r9d, r9d
  00429	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00431	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00435	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  00439	e8 00 00 00 00	 call	 s370_kimd_sha
  0043e	eb 13		 jmp	 SHORT $LN17@s370_dyn_c
$LN16@s370_dyn_c:

; 4061 :       else
; 4062 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00440	ba 06 00 00 00	 mov	 edx, 6
  00445	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN17@s370_dyn_c:

; 4063 :       break;

  00453	eb 46		 jmp	 SHORT $LN5@s370_dyn_c
$LN18@s370_dyn_c:

; 4064 :     }
; 4065 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 4066 : 
; 4067 : #if defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 )
; 4068 :     case 65: /* ghash */
; 4069 :     {
; 4070 :       if(msa >= 4)

  00455	83 7c 24 38 04	 cmp	 DWORD PTR msa$[rsp], 4
  0045a	7c 17		 jl	 SHORT $LN19@s370_dyn_c

; 4071 :         ARCH_DEP(kimd_ghash)(r1, r2, regs);

  0045c	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00464	8b 54 24 30	 mov	 edx, DWORD PTR r2$[rsp]
  00468	8b 4c 24 3c	 mov	 ecx, DWORD PTR r1$[rsp]
  0046c	e8 00 00 00 00	 call	 s370_kimd_ghash
  00471	eb 13		 jmp	 SHORT $LN20@s370_dyn_c
$LN19@s370_dyn_c:

; 4072 :       else
; 4073 :         ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00473	ba 06 00 00 00	 mov	 edx, 6
  00478	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN20@s370_dyn_c:

; 4074 :       break;

  00486	eb 13		 jmp	 SHORT $LN5@s370_dyn_c
$LN21@s370_dyn_c:

; 4075 :     }
; 4076 : #endif /* defined( FEATURE_077_MSA_EXTENSION_FACILITY_4 ) */
; 4077 : 
; 4078 :     default:
; 4079 :     {
; 4080 :       ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00488	ba 06 00 00 00	 mov	 edx, 6
  0048d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00495	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_dyn_c:
$LN1@s370_dyn_c:

; 4081 :       break;
; 4082 :     }
; 4083 :   }
; 4084 : }

  0049b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a3	48 33 cc	 xor	 rcx, rsp
  004a6	e8 00 00 00 00	 call	 __security_check_cookie
  004ab	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  004b2	c3		 ret	 0
s370_dyn_compute_intermediate_message_digest ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
keylen$ = 52
fc$ = 56
parameter_block$ = 64
__$ArrayPad$ = 128
regs$ = 160
s370_pckmo_aes PROC

; 3947 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3948 :   int fc;
; 3949 :   int keylen;
; 3950 :   BYTE parameter_block[64];
; 3951 :   int parameter_blocklen;
; 3952 : 
; 3953 :   /* Initialize values */
; 3954 :   fc = GR0_fc(regs);

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 00	 imul	 rax, rax, 0
  00027	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00036	83 e0 7f	 and	 eax, 127		; 0000007fH
  00039	89 44 24 38	 mov	 DWORD PTR fc$[rsp], eax

; 3955 :   keylen = (fc - 16) * 8;

  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fc$[rsp]
  00041	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00048	89 44 24 34	 mov	 DWORD PTR keylen$[rsp], eax

; 3956 :   parameter_blocklen = keylen + 32;

  0004c	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  00050	83 c0 20	 add	 eax, 32			; 00000020H
  00053	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3957 : 
; 3958 :   /* Test writeability */
; 3959 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  00057	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0005b	ff c8		 dec	 eax
  0005d	b9 08 00 00 00	 mov	 ecx, 8
  00062	48 6b c9 01	 imul	 rcx, rcx, 1
  00066	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0006e	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  00075	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  0007b	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00083	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00088	41 b9 02 00 00
	00		 mov	 r9d, 2
  0008e	44 8b c0	 mov	 r8d, eax
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	e8 00 00 00 00	 call	 s370_validate_operand

; 3960 : 
; 3961 :   /* Fetch the parameter block */
; 3962 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0009b	b8 08 00 00 00	 mov	 eax, 8
  000a0	48 6b c0 01	 imul	 rax, rax, 1
  000a4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ac	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000b3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b8	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  000bc	ff c9		 dec	 ecx
  000be	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c6	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000cb	41 b9 01 00 00
	00		 mov	 r9d, 1
  000d1	44 8b c0	 mov	 r8d, eax
  000d4	0f b6 d1	 movzx	 edx, cl
  000d7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  000dc	e8 00 00 00 00	 call	 s370_vfetchc

; 3963 : 
; 3964 : #ifdef OPTION_PCKMO_DEBUG
; 3965 :   LOGBYTE("key in : ", parameter_block, keylen);
; 3966 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3967 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3968 : 
; 3969 :   /* Encrypt the key and fill the wrapping key verification pattern */
; 3970 :   wrap_aes(parameter_block, keylen);

  000e1	8b 54 24 34	 mov	 edx, DWORD PTR keylen$[rsp]
  000e5	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  000ea	e8 00 00 00 00	 call	 wrap_aes

; 3971 : 
; 3972 :   /* Store the parameterblock */
; 3973 :   ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  000ef	b8 08 00 00 00	 mov	 eax, 8
  000f4	48 6b c0 01	 imul	 rax, rax, 1
  000f8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00107	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0010c	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00110	ff c9		 dec	 ecx
  00112	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0011a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0011f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00125	44 8b c0	 mov	 r8d, eax
  00128	0f b6 d1	 movzx	 edx, cl
  0012b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00130	e8 00 00 00 00	 call	 s370_vstorec

; 3974 : 
; 3975 : #ifdef OPTION_PCKMO_DEBUG
; 3976 :   LOGBYTE("key out: ", parameter_block, keylen);
; 3977 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3978 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3979 : }

  00135	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0013d	48 33 cc	 xor	 rcx, rsp
  00140	e8 00 00 00 00	 call	 __security_check_cookie
  00145	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0014c	c3		 ret	 0
s370_pckmo_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
keylen$ = 52
fc$ = 56
parameter_block$ = 64
__$ArrayPad$ = 128
regs$ = 160
s370_pckmo_dea PROC

; 3909 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3910 :   int fc;
; 3911 :   int keylen;
; 3912 :   BYTE parameter_block[64];
; 3913 :   int parameter_blocklen;
; 3914 : 
; 3915 :   /* Initialize values */
; 3916 :   fc = GR0_fc(regs);

  0001e	b8 08 00 00 00	 mov	 eax, 8
  00023	48 6b c0 00	 imul	 rax, rax, 0
  00027	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0002f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00036	83 e0 7f	 and	 eax, 127		; 0000007fH
  00039	89 44 24 38	 mov	 DWORD PTR fc$[rsp], eax

; 3917 :   keylen = fc * 8;

  0003d	8b 44 24 38	 mov	 eax, DWORD PTR fc$[rsp]
  00041	c1 e0 03	 shl	 eax, 3
  00044	89 44 24 34	 mov	 DWORD PTR keylen$[rsp], eax

; 3918 :   parameter_blocklen = keylen + 24;

  00048	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  0004c	83 c0 18	 add	 eax, 24
  0004f	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3919 : 
; 3920 :   /* Test writeability */
; 3921 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  00053	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00057	ff c8		 dec	 eax
  00059	b9 08 00 00 00	 mov	 ecx, 8
  0005e	48 6b c9 01	 imul	 rcx, rcx, 1
  00062	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0006a	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  00071	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00077	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00084	41 b9 02 00 00
	00		 mov	 r9d, 2
  0008a	44 8b c0	 mov	 r8d, eax
  0008d	ba 01 00 00 00	 mov	 edx, 1
  00092	e8 00 00 00 00	 call	 s370_validate_operand

; 3922 : 
; 3923 :   /* Fetch the parameter block */
; 3924 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00097	b8 08 00 00 00	 mov	 eax, 8
  0009c	48 6b c0 01	 imul	 rax, rax, 1
  000a0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000a8	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000af	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000b4	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  000b8	ff c9		 dec	 ecx
  000ba	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  000c2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000c7	41 b9 01 00 00
	00		 mov	 r9d, 1
  000cd	44 8b c0	 mov	 r8d, eax
  000d0	0f b6 d1	 movzx	 edx, cl
  000d3	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  000d8	e8 00 00 00 00	 call	 s370_vfetchc

; 3925 : 
; 3926 : #ifdef OPTION_PCKMO_DEBUG
; 3927 :   LOGBYTE("key in : ", parameter_block, keylen);
; 3928 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3929 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3930 : 
; 3931 :   /* Encrypt the key and fill the wrapping key verification pattern */
; 3932 :   wrap_dea(parameter_block, keylen);

  000dd	8b 54 24 34	 mov	 edx, DWORD PTR keylen$[rsp]
  000e1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  000e6	e8 00 00 00 00	 call	 wrap_dea

; 3933 : 
; 3934 :   /* Store the parameterblock */
; 3935 :   ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  000eb	b8 08 00 00 00	 mov	 eax, 8
  000f0	48 6b c0 01	 imul	 rax, rax, 1
  000f4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000fc	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00103	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00108	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0010c	ff c9		 dec	 ecx
  0010e	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00116	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0011b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00121	44 8b c0	 mov	 r8d, eax
  00124	0f b6 d1	 movzx	 edx, cl
  00127	48 8d 4c 24 40	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0012c	e8 00 00 00 00	 call	 s370_vstorec

; 3936 : 
; 3937 : #ifdef OPTION_PCKMO_DEBUG
; 3938 :   LOGBYTE("key out: ", parameter_block, keylen);
; 3939 :   LOGBYTE("wkvp   : ", &parameter_block[keylen], parameter_blocklen - keylen);
; 3940 : #endif /* #ifdef OPTION_PCKMO_DEBUG */
; 3941 : }

  00131	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00139	48 33 cc	 xor	 rcx, rsp
  0013c	e8 00 00 00 00	 call	 __security_check_cookie
  00141	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00148	c3		 ret	 0
s370_pckmo_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
ibi$ = 56
keylen$ = 64
tv70 = 68
tv81 = 72
tv161 = 76
wrap$ = 80
tweak$ = 88
xts$ = 96
tfc$ = 104
tv271 = 108
bsn$ = 112
context$ = 128
mask$ = 624
zero$ = 632
parameter_block$ = 656
__$ArrayPad$ = 784
regs$ = 832
s370_pcc_xts_aes PROC

; 3793 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 28 03
	00 00		 sub	 rsp, 808		; 00000328H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3794 :   BYTE *bsn;
; 3795 :   rijndael_ctx context;
; 3796 :   BYTE *ibi;
; 3797 :   int keylen;
; 3798 :   BYTE mask[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

  00020	c6 84 24 70 02
	00 00 80	 mov	 BYTE PTR mask$[rsp], 128 ; 00000080H
  00028	c6 84 24 71 02
	00 00 40	 mov	 BYTE PTR mask$[rsp+1], 64 ; 00000040H
  00030	c6 84 24 72 02
	00 00 20	 mov	 BYTE PTR mask$[rsp+2], 32 ; 00000020H
  00038	c6 84 24 73 02
	00 00 10	 mov	 BYTE PTR mask$[rsp+3], 16
  00040	c6 84 24 74 02
	00 00 08	 mov	 BYTE PTR mask$[rsp+4], 8
  00048	c6 84 24 75 02
	00 00 04	 mov	 BYTE PTR mask$[rsp+5], 4
  00050	c6 84 24 76 02
	00 00 02	 mov	 BYTE PTR mask$[rsp+6], 2
  00058	c6 84 24 77 02
	00 00 01	 mov	 BYTE PTR mask$[rsp+7], 1

; 3799 :   BYTE parameter_block[128];
; 3800 :   int parameter_blocklen;
; 3801 :   int tfc;
; 3802 :   BYTE *tweak;
; 3803 :   int wrap;
; 3804 :   BYTE *xts;
; 3805 :   BYTE zero[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

  00060	c6 84 24 78 02
	00 00 00	 mov	 BYTE PTR zero$[rsp], 0
  00068	c6 84 24 79 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+1], 0
  00070	c6 84 24 7a 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+2], 0
  00078	c6 84 24 7b 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+3], 0
  00080	c6 84 24 7c 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+4], 0
  00088	c6 84 24 7d 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+5], 0
  00090	c6 84 24 7e 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+6], 0
  00098	c6 84 24 7f 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+7], 0
  000a0	c6 84 24 80 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+8], 0
  000a8	c6 84 24 81 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+9], 0
  000b0	c6 84 24 82 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+10], 0
  000b8	c6 84 24 83 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+11], 0
  000c0	c6 84 24 84 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+12], 0
  000c8	c6 84 24 85 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+13], 0
  000d0	c6 84 24 86 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+14], 0
  000d8	c6 84 24 87 02
	00 00 00	 mov	 BYTE PTR zero$[rsp+15], 0

; 3806 : 
; 3807 :   /* Check special conditions */
; 3808 :   if(unlikely(GR0_m(regs)))

  000e0	b8 08 00 00 00	 mov	 eax, 8
  000e5	48 6b c0 00	 imul	 rax, rax, 0
  000e9	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fd	85 c0		 test	 eax, eax
  000ff	74 0a		 je	 SHORT $LN15@s370_pcc_x
  00101	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00109	eb 08		 jmp	 SHORT $LN16@s370_pcc_x
$LN15@s370_pcc_x:
  0010b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN16@s370_pcc_x:
  00113	83 7c 24 44 00	 cmp	 DWORD PTR tv70[rsp], 0
  00118	74 0a		 je	 SHORT $LN21@s370_pcc_x
  0011a	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00122	eb 08		 jmp	 SHORT $LN22@s370_pcc_x
$LN21@s370_pcc_x:
  00124	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN22@s370_pcc_x:
  0012c	83 7c 24 48 00	 cmp	 DWORD PTR tv81[rsp], 0
  00131	74 13		 je	 SHORT $LN5@s370_pcc_x

; 3809 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00133	ba 06 00 00 00	 mov	 edx, 6
  00138	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_pcc_x:

; 3810 : 
; 3811 :   /* Initialize values */
; 3812 :   tfc = GR0_tfc(regs);

  00146	b8 08 00 00 00	 mov	 eax, 8
  0014b	48 6b c0 00	 imul	 rax, rax, 0
  0014f	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00157	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0015e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00161	83 e0 77	 and	 eax, 119		; 00000077H
  00164	89 44 24 68	 mov	 DWORD PTR tfc$[rsp], eax

; 3813 :   wrap = GR0_wrap(regs);

  00168	b8 08 00 00 00	 mov	 eax, 8
  0016d	48 6b c0 00	 imul	 rax, rax, 0
  00171	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00180	83 e0 08	 and	 eax, 8
  00183	85 c0		 test	 eax, eax
  00185	74 0a		 je	 SHORT $LN23@s370_pcc_x
  00187	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0018f	eb 08		 jmp	 SHORT $LN24@s370_pcc_x
$LN23@s370_pcc_x:
  00191	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN24@s370_pcc_x:
  00199	8b 44 24 4c	 mov	 eax, DWORD PTR tv161[rsp]
  0019d	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 3814 :   keylen = (tfc - 49) * 8 + 8;

  001a1	8b 44 24 68	 mov	 eax, DWORD PTR tfc$[rsp]
  001a5	8d 04 c5 80 fe
	ff ff		 lea	 eax, DWORD PTR [rax*8-384]
  001ac	89 44 24 40	 mov	 DWORD PTR keylen$[rsp], eax

; 3815 :   parameter_blocklen = keylen + 64;

  001b0	8b 44 24 40	 mov	 eax, DWORD PTR keylen$[rsp]
  001b4	83 c0 40	 add	 eax, 64			; 00000040H
  001b7	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3816 :   if(wrap)

  001bb	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001c0	74 0b		 je	 SHORT $LN6@s370_pcc_x

; 3817 :     parameter_blocklen += 32;

  001c2	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001c6	83 c0 20	 add	 eax, 32			; 00000020H
  001c9	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN6@s370_pcc_x:

; 3818 : 
; 3819 :   /* Test writeability XTS parameter */
; 3820 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + parameter_blocklen - 16) & ADDRESS_MAXWRAP(regs), 1, 31, ACCTYPE_WRITE, regs);

  001cd	b8 08 00 00 00	 mov	 eax, 8
  001d2	48 6b c0 01	 imul	 rax, rax, 1
  001d6	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001de	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e5	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001e9	8d 44 08 f0	 lea	 eax, DWORD PTR [rax+rcx-16]
  001ed	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001f2	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001fa	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001ff	41 b9 02 00 00
	00		 mov	 r9d, 2
  00205	41 b8 1f 00 00
	00		 mov	 r8d, 31
  0020b	ba 01 00 00 00	 mov	 edx, 1
  00210	8b c8		 mov	 ecx, eax
  00212	e8 00 00 00 00	 call	 s370_validate_operand

; 3821 : 
; 3822 :   /* Fetch the parameter block */
; 3823 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00217	b8 08 00 00 00	 mov	 eax, 8
  0021c	48 6b c0 01	 imul	 rax, rax, 1
  00220	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00228	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0022f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00234	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00238	ff c9		 dec	 ecx
  0023a	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00242	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00247	41 b9 01 00 00
	00		 mov	 r9d, 1
  0024d	44 8b c0	 mov	 r8d, eax
  00250	0f b6 d1	 movzx	 edx, cl
  00253	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0025b	e8 00 00 00 00	 call	 s370_vfetchc

; 3824 :   tweak = &parameter_block[parameter_blocklen - 64];

  00260	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00264	83 e8 40	 sub	 eax, 64			; 00000040H
  00267	48 98		 cdqe
  00269	48 8d 84 04 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00271	48 89 44 24 58	 mov	 QWORD PTR tweak$[rsp], rax

; 3825 :   bsn = &parameter_block[parameter_blocklen - 48];

  00276	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0027a	83 e8 30	 sub	 eax, 48			; 00000030H
  0027d	48 98		 cdqe
  0027f	48 8d 84 04 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00287	48 89 44 24 70	 mov	 QWORD PTR bsn$[rsp], rax

; 3826 :   ibi = &parameter_block[parameter_blocklen - 32];

  0028c	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00290	83 e8 20	 sub	 eax, 32			; 00000020H
  00293	48 98		 cdqe
  00295	48 8d 84 04 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0029d	48 89 44 24 38	 mov	 QWORD PTR ibi$[rsp], rax

; 3827 :   xts = &parameter_block[parameter_blocklen - 16];

  002a2	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  002a6	83 e8 10	 sub	 eax, 16
  002a9	48 98		 cdqe
  002ab	48 8d 84 04 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002b3	48 89 44 24 60	 mov	 QWORD PTR xts$[rsp], rax

; 3828 : 
; 3829 : #ifdef OPTION_PCC_DEBUG
; 3830 :   LOGBYTE("k     :", parameter_block, keylen);
; 3831 :   if(wrap)
; 3832 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 32);
; 3833 :   LOGBYTE("tweak :", tweak, 16);
; 3834 :   LOGBYTE("bsn   :", bsn, 16);
; 3835 :   LOGBYTE("ibi   :", ibi, 16);
; 3836 :   LOGBYTE("xts   :", xts, 16);
; 3837 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3838 : 
; 3839 :   /* Verify and unwrap */
; 3840 :   if(wrap && unwrap_aes(parameter_block, keylen))

  002b8	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  002bd	74 26		 je	 SHORT $LN7@s370_pcc_x
  002bf	8b 54 24 40	 mov	 edx, DWORD PTR keylen$[rsp]
  002c3	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  002cb	e8 00 00 00 00	 call	 unwrap_aes
  002d0	85 c0		 test	 eax, eax
  002d2	74 11		 je	 SHORT $LN7@s370_pcc_x

; 3841 :   {
; 3842 : 
; 3843 : #ifdef OPTION_PCC_DEBUG
; 3844 :     WRMSG(HHC90111, "D");
; 3845 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3846 : 
; 3847 :     regs->psw.cc = 1;

  002d4	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002dc	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3848 :     return;

  002e0	e9 1c 02 00 00	 jmp	 $LN1@s370_pcc_x
$LN7@s370_pcc_x:

; 3849 :   }
; 3850 : 
; 3851 :   /* Encrypt tweak */
; 3852 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  002e5	8b 44 24 40	 mov	 eax, DWORD PTR keylen$[rsp]
  002e9	c1 e0 03	 shl	 eax, 3
  002ec	44 8b c0	 mov	 r8d, eax
  002ef	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002f7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  002ff	e8 00 00 00 00	 call	 rijndael_set_key

; 3853 :   rijndael_encrypt(&context, tweak, tweak);

  00304	4c 8b 44 24 58	 mov	 r8, QWORD PTR tweak$[rsp]
  00309	48 8b 54 24 58	 mov	 rdx, QWORD PTR tweak$[rsp]
  0030e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00316	e8 00 00 00 00	 call	 rijndael_encrypt

; 3854 : 
; 3855 :   /* Check block sequential number (j) == 0 */
; 3856 :   if(!memcmp(bsn, zero, 16))

  0031b	41 b8 10 00 00
	00		 mov	 r8d, 16
  00321	48 8d 94 24 78
	02 00 00	 lea	 rdx, QWORD PTR zero$[rsp]
  00329	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bsn$[rsp]
  0032e	e8 00 00 00 00	 call	 memcmp
  00333	85 c0		 test	 eax, eax
  00335	75 36		 jne	 SHORT $LN8@s370_pcc_x

; 3857 :   {
; 3858 :     zeromem(ibi, 15);

  00337	48 8b 7c 24 38	 mov	 rdi, QWORD PTR ibi$[rsp]
  0033c	33 c0		 xor	 eax, eax
  0033e	b9 0f 00 00 00	 mov	 ecx, 15
  00343	f3 aa		 rep stosb

; 3859 :     ibi[15] = 128;

  00345	b8 01 00 00 00	 mov	 eax, 1
  0034a	48 6b c0 0f	 imul	 rax, rax, 15
  0034e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00353	c6 04 01 80	 mov	 BYTE PTR [rcx+rax], 128	; 00000080H

; 3860 :     memcpy(xts, tweak, 16);

  00357	48 8b 7c 24 60	 mov	 rdi, QWORD PTR xts$[rsp]
  0035c	48 8b 74 24 58	 mov	 rsi, QWORD PTR tweak$[rsp]
  00361	b9 10 00 00 00	 mov	 ecx, 16
  00366	f3 a4		 rep movsb

; 3861 :   }

  00368	e9 41 01 00 00	 jmp	 $LN9@s370_pcc_x
$LN8@s370_pcc_x:

; 3862 :   else
; 3863 :   {
; 3864 :     /* Check intermediate block index (t) > 127 */
; 3865 :     if(memcmp(ibi, zero, 15) || ibi[15] > 127)

  0036d	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00373	48 8d 94 24 78
	02 00 00	 lea	 rdx, QWORD PTR zero$[rsp]
  0037b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00380	e8 00 00 00 00	 call	 memcmp
  00385	85 c0		 test	 eax, eax
  00387	75 17		 jne	 SHORT $LN11@s370_pcc_x
  00389	b8 01 00 00 00	 mov	 eax, 1
  0038e	48 6b c0 0f	 imul	 rax, rax, 15
  00392	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00397	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0039b	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  0039e	7e 11		 jle	 SHORT $LN10@s370_pcc_x
$LN11@s370_pcc_x:

; 3866 :     {
; 3867 :       /* Invalid imtermediate block index, return with cc2 */
; 3868 :       regs->psw.cc = 2;

  003a0	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003a8	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 3869 :       return;

  003ac	e9 50 01 00 00	 jmp	 $LN1@s370_pcc_x
$LN10@s370_pcc_x:

; 3870 :     }
; 3871 : 
; 3872 :     /* Intitial execution? */
; 3873 :     if(!ibi[15]) memcpy(xts, tweak, 16);

  003b1	b8 01 00 00 00	 mov	 eax, 1
  003b6	48 6b c0 0f	 imul	 rax, rax, 15
  003ba	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  003bf	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003c3	85 c0		 test	 eax, eax
  003c5	75 11		 jne	 SHORT $LN12@s370_pcc_x
  003c7	48 8b 7c 24 60	 mov	 rdi, QWORD PTR xts$[rsp]
  003cc	48 8b 74 24 58	 mov	 rsi, QWORD PTR tweak$[rsp]
  003d1	b9 10 00 00 00	 mov	 ecx, 16
  003d6	f3 a4		 rep movsb
$LN12@s370_pcc_x:
$LN4@s370_pcc_x:

; 3874 : 
; 3875 :     /* Calculate xts parameter */
; 3876 :     do
; 3877 :     {
; 3878 :       if(bsn[ibi[15] / 8] & mask[ibi[15] % 8])

  003d8	b8 01 00 00 00	 mov	 eax, 1
  003dd	48 6b c0 0f	 imul	 rax, rax, 15
  003e1	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  003e6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003ea	99		 cdq
  003eb	83 e2 07	 and	 edx, 7
  003ee	03 c2		 add	 eax, edx
  003f0	c1 f8 03	 sar	 eax, 3
  003f3	48 98		 cdqe
  003f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR bsn$[rsp]
  003fa	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  003fe	89 44 24 6c	 mov	 DWORD PTR tv271[rsp], eax
  00402	b9 01 00 00 00	 mov	 ecx, 1
  00407	48 6b c9 0f	 imul	 rcx, rcx, 15
  0040b	48 8b 54 24 38	 mov	 rdx, QWORD PTR ibi$[rsp]
  00410	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00414	8b c1		 mov	 eax, ecx
  00416	99		 cdq
  00417	83 e2 07	 and	 edx, 7
  0041a	03 c2		 add	 eax, edx
  0041c	83 e0 07	 and	 eax, 7
  0041f	2b c2		 sub	 eax, edx
  00421	48 98		 cdqe
  00423	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR mask$[rsp+rax]
  0042b	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv271[rsp]
  0042f	23 c8		 and	 ecx, eax
  00431	8b c1		 mov	 eax, ecx
  00433	85 c0		 test	 eax, eax
  00435	74 35		 je	 SHORT $LN13@s370_pcc_x

; 3879 :       {
; 3880 : #ifdef OPTION_PCC_DEBUG
; 3881 :         LOGBYTE("ibi   :", ibi, 16);
; 3882 :         LOGBYTE("xts   :", xts, 16);
; 3883 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3884 :         xts_gf_mult(xts, exp_table[ibi[15]], xts);

  00437	b8 01 00 00 00	 mov	 eax, 1
  0043c	48 6b c0 0f	 imul	 rax, rax, 15
  00440	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  00445	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00449	48 6b c0 10	 imul	 rax, rax, 16
  0044d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:exp_table
  00454	48 03 c8	 add	 rcx, rax
  00457	48 8b c1	 mov	 rax, rcx
  0045a	4c 8b 44 24 60	 mov	 r8, QWORD PTR xts$[rsp]
  0045f	48 8b d0	 mov	 rdx, rax
  00462	48 8b 4c 24 60	 mov	 rcx, QWORD PTR xts$[rsp]
  00467	e8 00 00 00 00	 call	 xts_gf_mult
$LN13@s370_pcc_x:

; 3885 :       }
; 3886 :       ibi[15]++;

  0046c	b8 01 00 00 00	 mov	 eax, 1
  00471	48 6b c0 0f	 imul	 rax, rax, 15
  00475	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  0047a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0047e	fe c0		 inc	 al
  00480	b9 01 00 00 00	 mov	 ecx, 1
  00485	48 6b c9 0f	 imul	 rcx, rcx, 15
  00489	48 8b 54 24 38	 mov	 rdx, QWORD PTR ibi$[rsp]
  0048e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 3887 :     }
; 3888 :     while(ibi[15] != 128);

  00491	b8 01 00 00 00	 mov	 eax, 1
  00496	48 6b c0 0f	 imul	 rax, rax, 15
  0049a	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  0049f	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  004a3	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  004a8	0f 85 2a ff ff
	ff		 jne	 $LN4@s370_pcc_x
$LN9@s370_pcc_x:

; 3889 :   }
; 3890 : 
; 3891 : #ifdef OPTION_PCC_DEBUG
; 3892 :   LOGBYTE("ibi   :", ibi, 16);
; 3893 :   LOGBYTE("xts   :", xts, 16);
; 3894 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3895 : 
; 3896 :   /* Store Intermediate Bit Index and XTS */
; 3897 :   ARCH_DEP(vstorec)(ibi, 31, (GR_A(1, regs) + parameter_blocklen - 32) & ADDRESS_MAXWRAP(regs), 1, regs);

  004ae	b8 08 00 00 00	 mov	 eax, 8
  004b3	48 6b c0 01	 imul	 rax, rax, 1
  004b7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bf	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004c6	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  004ca	8d 44 08 e0	 lea	 eax, DWORD PTR [rax+rcx-32]
  004ce	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  004d3	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004db	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004e0	41 b9 01 00 00
	00		 mov	 r9d, 1
  004e6	44 8b c0	 mov	 r8d, eax
  004e9	b2 1f		 mov	 dl, 31
  004eb	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ibi$[rsp]
  004f0	e8 00 00 00 00	 call	 s370_vstorec

; 3898 : 
; 3899 :   /* Normal completion */
; 3900 :   regs->psw.cc = 0;

  004f5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004fd	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s370_pcc_x:

; 3901 : }

  00501	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00509	48 33 cc	 xor	 rcx, rsp
  0050c	e8 00 00 00 00	 call	 __security_check_cookie
  00511	48 81 c4 28 03
	00 00		 add	 rsp, 808		; 00000328H
  00518	5f		 pop	 rdi
  00519	5e		 pop	 rsi
  0051a	c3		 ret	 0
s370_pcc_xts_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
tv70 = 60
tv81 = 64
tv161 = 68
wrap$ = 72
tfc$ = 76
tv453 = 80
tv236 = 84
tv267 = 88
$T1 = 96
tv219 = 104
tv247 = 112
context$ = 128
mask$ = 624
r128$ = 632
k$ = 648
parameter_block$ = 672
__$ArrayPad$ = 784
regs$ = 816
s370_pcc_cmac_aes PROC

; 3664 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 20 03
	00 00		 sub	 rsp, 800		; 00000320H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3665 :   rijndael_ctx context;
; 3666 :   int i;
; 3667 :   BYTE k[16];
; 3668 :   int keylen;
; 3669 :   BYTE mask[8] = { 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };

  0001f	c6 84 24 70 02
	00 00 80	 mov	 BYTE PTR mask$[rsp], 128 ; 00000080H
  00027	c6 84 24 71 02
	00 00 c0	 mov	 BYTE PTR mask$[rsp+1], 192 ; 000000c0H
  0002f	c6 84 24 72 02
	00 00 e0	 mov	 BYTE PTR mask$[rsp+2], 224 ; 000000e0H
  00037	c6 84 24 73 02
	00 00 f0	 mov	 BYTE PTR mask$[rsp+3], 240 ; 000000f0H
  0003f	c6 84 24 74 02
	00 00 f8	 mov	 BYTE PTR mask$[rsp+4], 248 ; 000000f8H
  00047	c6 84 24 75 02
	00 00 fc	 mov	 BYTE PTR mask$[rsp+5], 252 ; 000000fcH
  0004f	c6 84 24 76 02
	00 00 fe	 mov	 BYTE PTR mask$[rsp+6], 254 ; 000000feH
  00057	c6 84 24 77 02
	00 00 ff	 mov	 BYTE PTR mask$[rsp+7], 255 ; 000000ffH

; 3670 :   BYTE parameter_block[104];
; 3671 :   int parameter_blocklen;
; 3672 :   BYTE r128[16] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x87 };

  0005f	c6 84 24 78 02
	00 00 00	 mov	 BYTE PTR r128$[rsp], 0
  00067	c6 84 24 79 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+1], 0
  0006f	c6 84 24 7a 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+2], 0
  00077	c6 84 24 7b 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+3], 0
  0007f	c6 84 24 7c 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+4], 0
  00087	c6 84 24 7d 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+5], 0
  0008f	c6 84 24 7e 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+6], 0
  00097	c6 84 24 7f 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+7], 0
  0009f	c6 84 24 80 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+8], 0
  000a7	c6 84 24 81 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+9], 0
  000af	c6 84 24 82 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+10], 0
  000b7	c6 84 24 83 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+11], 0
  000bf	c6 84 24 84 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+12], 0
  000c7	c6 84 24 85 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+13], 0
  000cf	c6 84 24 86 02
	00 00 00	 mov	 BYTE PTR r128$[rsp+14], 0
  000d7	c6 84 24 87 02
	00 00 87	 mov	 BYTE PTR r128$[rsp+15], 135 ; 00000087H

; 3673 :   int tfc;
; 3674 :   int wrap;
; 3675 : 
; 3676 :   /* Check special conditions */
; 3677 :   if(unlikely(GR0_m(regs)))

  000df	b8 08 00 00 00	 mov	 eax, 8
  000e4	48 6b c0 00	 imul	 rax, rax, 0
  000e8	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000fc	85 c0		 test	 eax, eax
  000fe	74 0a		 je	 SHORT $LN26@s370_pcc_c
  00100	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00108	eb 08		 jmp	 SHORT $LN27@s370_pcc_c
$LN26@s370_pcc_c:
  0010a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN27@s370_pcc_c:
  00112	83 7c 24 3c 00	 cmp	 DWORD PTR tv70[rsp], 0
  00117	74 0a		 je	 SHORT $LN32@s370_pcc_c
  00119	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  00121	eb 08		 jmp	 SHORT $LN33@s370_pcc_c
$LN32@s370_pcc_c:
  00123	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN33@s370_pcc_c:
  0012b	83 7c 24 40 00	 cmp	 DWORD PTR tv81[rsp], 0
  00130	74 13		 je	 SHORT $LN14@s370_pcc_c

; 3678 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00132	ba 06 00 00 00	 mov	 edx, 6
  00137	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN14@s370_pcc_c:

; 3679 : 
; 3680 :   /* Initialize values */
; 3681 :   tfc = GR0_tfc(regs);

  00145	b8 08 00 00 00	 mov	 eax, 8
  0014a	48 6b c0 00	 imul	 rax, rax, 0
  0014e	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00156	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0015d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00160	83 e0 77	 and	 eax, 119		; 00000077H
  00163	89 44 24 4c	 mov	 DWORD PTR tfc$[rsp], eax

; 3682 :   wrap = GR0_wrap(regs);

  00167	b8 08 00 00 00	 mov	 eax, 8
  0016c	48 6b c0 00	 imul	 rax, rax, 0
  00170	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00178	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017f	83 e0 08	 and	 eax, 8
  00182	85 c0		 test	 eax, eax
  00184	74 0a		 je	 SHORT $LN34@s370_pcc_c
  00186	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0018e	eb 08		 jmp	 SHORT $LN35@s370_pcc_c
$LN34@s370_pcc_c:
  00190	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN35@s370_pcc_c:
  00198	8b 44 24 44	 mov	 eax, DWORD PTR tv161[rsp]
  0019c	89 44 24 48	 mov	 DWORD PTR wrap$[rsp], eax

; 3683 :   keylen = (tfc - 17) * 8 + 8;

  001a0	8b 44 24 4c	 mov	 eax, DWORD PTR tfc$[rsp]
  001a4	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  001ab	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 3684 :   parameter_blocklen = keylen + 40;

  001af	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  001b3	83 c0 28	 add	 eax, 40			; 00000028H
  001b6	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3685 :   if(wrap)

  001ba	83 7c 24 48 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001bf	74 0b		 je	 SHORT $LN15@s370_pcc_c

; 3686 :     parameter_blocklen += 32;

  001c1	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001c5	83 c0 20	 add	 eax, 32			; 00000020H
  001c8	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN15@s370_pcc_c:

; 3687 : 
; 3688 :   /* Test writeability output chaining value */
; 3689 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + 24) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  001cc	b8 08 00 00 00	 mov	 eax, 8
  001d1	48 6b c0 01	 imul	 rax, rax, 1
  001d5	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001dd	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e4	83 c0 18	 add	 eax, 24
  001e7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001ec	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001f4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001f9	41 b9 02 00 00
	00		 mov	 r9d, 2
  001ff	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00205	ba 01 00 00 00	 mov	 edx, 1
  0020a	8b c8		 mov	 ecx, eax
  0020c	e8 00 00 00 00	 call	 s370_validate_operand

; 3690 : 
; 3691 :   /* Fetch the parameter block */
; 3692 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00211	b8 08 00 00 00	 mov	 eax, 8
  00216	48 6b c0 01	 imul	 rax, rax, 1
  0021a	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00222	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00229	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0022e	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00232	ff c9		 dec	 ecx
  00234	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0023c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00241	41 b9 01 00 00
	00		 mov	 r9d, 1
  00247	44 8b c0	 mov	 r8d, eax
  0024a	0f b6 d1	 movzx	 edx, cl
  0024d	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00255	e8 00 00 00 00	 call	 s370_vfetchc

; 3693 : 
; 3694 : #ifdef OPTION_PCC_DEBUG
; 3695 :   LOGBYTE("ml    :", parameter_block, 1);
; 3696 :   LOGBYTE("msg   :", &parameter_block[8], 16);
; 3697 :   LOGBYTE("icv   :", &parameter_block[24], 16);
; 3698 :   LOGBYTE("k     :", &parameter_block[40], keylen);
; 3699 :   if(wrap)
; 3700 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 40], 32);
; 3701 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3702 : 
; 3703 :   /* Verify and unwrap */
; 3704 :   if(wrap && unwrap_aes(&parameter_block[40], keylen))

  0025a	83 7c 24 48 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0025f	74 32		 je	 SHORT $LN16@s370_pcc_c
  00261	b8 01 00 00 00	 mov	 eax, 1
  00266	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0026a	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00272	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  00276	48 8b c8	 mov	 rcx, rax
  00279	e8 00 00 00 00	 call	 unwrap_aes
  0027e	85 c0		 test	 eax, eax
  00280	74 11		 je	 SHORT $LN16@s370_pcc_c

; 3705 :   {
; 3706 : 
; 3707 : #ifdef OPTION_PCC_DEBUG
; 3708 :     WRMSG(HHC90111, "D");
; 3709 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3710 : 
; 3711 :     regs->psw.cc = 1;

  00282	48 8b 84 24 30
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0028a	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3712 :     return;

  0028e	e9 99 04 00 00	 jmp	 $LN1@s370_pcc_c
$LN16@s370_pcc_c:

; 3713 :   }
; 3714 : 
; 3715 :   /* Set the cryptographic key */
; 3716 :   rijndael_set_key(&context, &parameter_block[40], keylen * 8);

  00293	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00297	c1 e0 03	 shl	 eax, 3
  0029a	b9 01 00 00 00	 mov	 ecx, 1
  0029f	48 6b c9 28	 imul	 rcx, rcx, 40		; 00000028H
  002a3	48 8d 8c 0c a0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  002ab	44 8b c0	 mov	 r8d, eax
  002ae	48 8b d1	 mov	 rdx, rcx
  002b1	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  002b9	e8 00 00 00 00	 call	 rijndael_set_key

; 3717 : 
; 3718 :   /* Check validity ML value */
; 3719 :   if(parameter_block[0] > 128)

  002be	b8 01 00 00 00	 mov	 eax, 1
  002c3	48 6b c0 00	 imul	 rax, rax, 0
  002c7	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  002cf	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002d4	7e 11		 jle	 SHORT $LN17@s370_pcc_c

; 3720 :   {
; 3721 :     regs->psw.cc = 2;

  002d6	48 8b 84 24 30
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002de	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 3722 :     return;

  002e2	e9 45 04 00 00	 jmp	 $LN1@s370_pcc_c
$LN17@s370_pcc_c:

; 3723 :   }
; 3724 : 
; 3725 :   /* Place the one bit */
; 3726 :   if(parameter_block[0] != 128)

  002e7	b8 01 00 00 00	 mov	 eax, 1
  002ec	48 6b c0 00	 imul	 rax, rax, 0
  002f0	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  002f8	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  002fd	0f 84 95 00 00
	00		 je	 $LN18@s370_pcc_c

; 3727 :     parameter_block[(parameter_block[0] / 8) + 8] |= (0x80 >> (parameter_block[0] % 8));

  00303	b8 01 00 00 00	 mov	 eax, 1
  00308	48 6b c0 00	 imul	 rax, rax, 0
  0030c	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00314	99		 cdq
  00315	83 e2 07	 and	 edx, 7
  00318	03 c2		 add	 eax, edx
  0031a	c1 f8 03	 sar	 eax, 3
  0031d	83 c0 08	 add	 eax, 8
  00320	48 98		 cdqe
  00322	48 89 44 24 68	 mov	 QWORD PTR tv219[rsp], rax
  00327	b9 01 00 00 00	 mov	 ecx, 1
  0032c	48 6b c9 00	 imul	 rcx, rcx, 0
  00330	0f b6 8c 0c a0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00338	8b c1		 mov	 eax, ecx
  0033a	99		 cdq
  0033b	83 e2 07	 and	 edx, 7
  0033e	03 c2		 add	 eax, edx
  00340	83 e0 07	 and	 eax, 7
  00343	2b c2		 sub	 eax, edx
  00345	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0034a	89 4c 24 50	 mov	 DWORD PTR tv453[rsp], ecx
  0034e	0f b6 c8	 movzx	 ecx, al
  00351	8b 44 24 50	 mov	 eax, DWORD PTR tv453[rsp]
  00355	d3 f8		 sar	 eax, cl
  00357	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv219[rsp]
  0035c	0f b6 8c 0c a0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00364	0b c8		 or	 ecx, eax
  00366	8b c1		 mov	 eax, ecx
  00368	89 44 24 54	 mov	 DWORD PTR tv236[rsp], eax
  0036c	b9 01 00 00 00	 mov	 ecx, 1
  00371	48 6b c9 00	 imul	 rcx, rcx, 0
  00375	0f b6 8c 0c a0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0037d	8b c1		 mov	 eax, ecx
  0037f	99		 cdq
  00380	83 e2 07	 and	 edx, 7
  00383	03 c2		 add	 eax, edx
  00385	c1 f8 03	 sar	 eax, 3
  00388	83 c0 08	 add	 eax, 8
  0038b	48 98		 cdqe
  0038d	8b 4c 24 54	 mov	 ecx, DWORD PTR tv236[rsp]
  00391	88 8c 04 a0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl
$LN18@s370_pcc_c:

; 3728 : 
; 3729 :   /* Pad with zeroes */
; 3730 :   if(parameter_block[0] < 127)

  00398	b8 01 00 00 00	 mov	 eax, 1
  0039d	48 6b c0 00	 imul	 rax, rax, 0
  003a1	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  003a9	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  003ac	0f 8d ec 00 00
	00		 jge	 $LN19@s370_pcc_c

; 3731 :   {
; 3732 :     parameter_block[(parameter_block[0] / 8) + 8] &= mask[parameter_block[0] % 8];

  003b2	b8 01 00 00 00	 mov	 eax, 1
  003b7	48 6b c0 00	 imul	 rax, rax, 0
  003bb	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  003c3	99		 cdq
  003c4	83 e2 07	 and	 edx, 7
  003c7	03 c2		 add	 eax, edx
  003c9	c1 f8 03	 sar	 eax, 3
  003cc	83 c0 08	 add	 eax, 8
  003cf	48 98		 cdqe
  003d1	48 89 44 24 70	 mov	 QWORD PTR tv247[rsp], rax
  003d6	b9 01 00 00 00	 mov	 ecx, 1
  003db	48 6b c9 00	 imul	 rcx, rcx, 0
  003df	0f b6 8c 0c a0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003e7	8b c1		 mov	 eax, ecx
  003e9	99		 cdq
  003ea	83 e2 07	 and	 edx, 7
  003ed	03 c2		 add	 eax, edx
  003ef	83 e0 07	 and	 eax, 7
  003f2	2b c2		 sub	 eax, edx
  003f4	48 98		 cdqe
  003f6	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR mask$[rsp+rax]
  003fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv247[rsp]
  00403	0f b6 8c 0c a0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0040b	23 c8		 and	 ecx, eax
  0040d	8b c1		 mov	 eax, ecx
  0040f	89 44 24 58	 mov	 DWORD PTR tv267[rsp], eax
  00413	b9 01 00 00 00	 mov	 ecx, 1
  00418	48 6b c9 00	 imul	 rcx, rcx, 0
  0041c	0f b6 8c 0c a0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00424	8b c1		 mov	 eax, ecx
  00426	99		 cdq
  00427	83 e2 07	 and	 edx, 7
  0042a	03 c2		 add	 eax, edx
  0042c	c1 f8 03	 sar	 eax, 3
  0042f	83 c0 08	 add	 eax, 8
  00432	48 98		 cdqe
  00434	8b 4c 24 58	 mov	 ecx, DWORD PTR tv267[rsp]
  00438	88 8c 04 a0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl

; 3733 :     for(i = (parameter_block[0] / 8) + 1; i < 16; i++)

  0043f	b8 01 00 00 00	 mov	 eax, 1
  00444	48 6b c0 00	 imul	 rax, rax, 0
  00448	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00450	99		 cdq
  00451	83 e2 07	 and	 edx, 7
  00454	03 c2		 add	 eax, edx
  00456	c1 f8 03	 sar	 eax, 3
  00459	ff c0		 inc	 eax
  0045b	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0045f	eb 0a		 jmp	 SHORT $LN4@s370_pcc_c
$LN2@s370_pcc_c:
  00461	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00465	ff c0		 inc	 eax
  00467	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@s370_pcc_c:
  0046b	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00470	7d 2c		 jge	 SHORT $LN3@s370_pcc_c

; 3734 :       parameter_block[i + 8] = 0x00;

  00472	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00476	83 c0 08	 add	 eax, 8
  00479	48 98		 cdqe
  0047b	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  00480	48 83 7c 24 60
	68		 cmp	 QWORD PTR $T1[rsp], 104	; 00000068H
  00486	73 02		 jae	 SHORT $LN36@s370_pcc_c
  00488	eb 05		 jmp	 SHORT $LN37@s370_pcc_c
$LN36@s370_pcc_c:
  0048a	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN37@s370_pcc_c:
  0048f	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  00494	c6 84 04 a0 02
	00 00 00	 mov	 BYTE PTR parameter_block$[rsp+rax], 0
  0049c	eb c3		 jmp	 SHORT $LN2@s370_pcc_c
$LN3@s370_pcc_c:
$LN19@s370_pcc_c:

; 3735 :   }
; 3736 : 
; 3737 : #ifdef OPTION_PCC_DEBUG
; 3738 :   LOGBYTE("msg   :", &parameter_block[8], 16);
; 3739 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3740 : 
; 3741 :   /* Calculate subkeys */
; 3742 :   zeromem(k, 16);

  0049e	48 8d 84 24 88
	02 00 00	 lea	 rax, QWORD PTR k$[rsp]
  004a6	48 8b f8	 mov	 rdi, rax
  004a9	33 c0		 xor	 eax, eax
  004ab	b9 10 00 00 00	 mov	 ecx, 16
  004b0	f3 aa		 rep stosb

; 3743 :   rijndael_encrypt(&context, k, k);

  004b2	4c 8d 84 24 88
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  004ba	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  004c2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  004ca	e8 00 00 00 00	 call	 rijndael_encrypt

; 3744 : 
; 3745 :   /* Calculate subkeys Kx and Ky */
; 3746 :   if(!(k[0] & 0x80))

  004cf	b8 01 00 00 00	 mov	 eax, 1
  004d4	48 6b c0 00	 imul	 rax, rax, 0
  004d8	0f b6 84 04 88
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  004e0	25 80 00 00 00	 and	 eax, 128		; 00000080H
  004e5	85 c0		 test	 eax, eax
  004e7	75 1d		 jne	 SHORT $LN20@s370_pcc_c

; 3747 :     shift_left(k, k, 16);

  004e9	41 b8 10 00 00
	00		 mov	 r8d, 16
  004ef	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  004f7	48 8d 8c 24 88
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  004ff	e8 00 00 00 00	 call	 shift_left
  00504	eb 60		 jmp	 SHORT $LN21@s370_pcc_c
$LN20@s370_pcc_c:

; 3748 :   else
; 3749 :   {
; 3750 :     shift_left(k, k, 16);

  00506	41 b8 10 00 00
	00		 mov	 r8d, 16
  0050c	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00514	48 8d 8c 24 88
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  0051c	e8 00 00 00 00	 call	 shift_left

; 3751 :     for(i = 0; i < 16; i++)

  00521	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00529	eb 0a		 jmp	 SHORT $LN7@s370_pcc_c
$LN5@s370_pcc_c:
  0052b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0052f	ff c0		 inc	 eax
  00531	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_pcc_c:
  00535	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  0053a	7d 2a		 jge	 SHORT $LN6@s370_pcc_c

; 3752 :       k[i] ^= r128[i];

  0053c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00541	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00546	0f b6 8c 0c 78
	02 00 00	 movzx	 ecx, BYTE PTR r128$[rsp+rcx]
  0054e	0f b6 84 04 88
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00556	33 c1		 xor	 eax, ecx
  00558	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0055d	88 84 0c 88 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  00564	eb c5		 jmp	 SHORT $LN5@s370_pcc_c
$LN6@s370_pcc_c:
$LN21@s370_pcc_c:

; 3753 :   }
; 3754 :   if(parameter_block[0] != 128)

  00566	b8 01 00 00 00	 mov	 eax, 1
  0056b	48 6b c0 00	 imul	 rax, rax, 0
  0056f	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00577	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0057c	0f 84 97 00 00
	00		 je	 $LN22@s370_pcc_c

; 3755 :   {
; 3756 :     if(!(k[0] & 0x80))

  00582	b8 01 00 00 00	 mov	 eax, 1
  00587	48 6b c0 00	 imul	 rax, rax, 0
  0058b	0f b6 84 04 88
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00593	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00598	85 c0		 test	 eax, eax
  0059a	75 1d		 jne	 SHORT $LN23@s370_pcc_c

; 3757 :       shift_left(k, k, 16);

  0059c	41 b8 10 00 00
	00		 mov	 r8d, 16
  005a2	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  005aa	48 8d 8c 24 88
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  005b2	e8 00 00 00 00	 call	 shift_left
  005b7	eb 60		 jmp	 SHORT $LN24@s370_pcc_c
$LN23@s370_pcc_c:

; 3758 :     else
; 3759 :     {
; 3760 :       shift_left(k, k, 16);

  005b9	41 b8 10 00 00
	00		 mov	 r8d, 16
  005bf	48 8d 94 24 88
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  005c7	48 8d 8c 24 88
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  005cf	e8 00 00 00 00	 call	 shift_left

; 3761 :       for(i = 0; i < 16; i++)

  005d4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005dc	eb 0a		 jmp	 SHORT $LN10@s370_pcc_c
$LN8@s370_pcc_c:
  005de	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005e2	ff c0		 inc	 eax
  005e4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_pcc_c:
  005e8	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  005ed	7d 2a		 jge	 SHORT $LN9@s370_pcc_c

; 3762 :         k[i] ^= r128[i];

  005ef	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005f4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005f9	0f b6 8c 0c 78
	02 00 00	 movzx	 ecx, BYTE PTR r128$[rsp+rcx]
  00601	0f b6 84 04 88
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00609	33 c1		 xor	 eax, ecx
  0060b	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00610	88 84 0c 88 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  00617	eb c5		 jmp	 SHORT $LN8@s370_pcc_c
$LN9@s370_pcc_c:
$LN24@s370_pcc_c:
$LN22@s370_pcc_c:

; 3763 :     }
; 3764 :   }
; 3765 : 
; 3766 : #ifdef OPTION_PCC_DEBUG
; 3767 :   LOGBYTE("Subkey:", k, 16);
; 3768 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3769 : 
; 3770 :   /* XOR with kx or ky and encrypt */
; 3771 :   for(i = 0; i < 16; i++)

  00619	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00621	eb 0a		 jmp	 SHORT $LN13@s370_pcc_c
$LN11@s370_pcc_c:
  00623	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00627	ff c0		 inc	 eax
  00629	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@s370_pcc_c:
  0062d	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00632	7d 69		 jge	 SHORT $LN12@s370_pcc_c

; 3772 :   {
; 3773 :     parameter_block[i + 8] ^= k[i];

  00634	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00638	83 c0 08	 add	 eax, 8
  0063b	48 98		 cdqe
  0063d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00642	0f b6 8c 0c 88
	02 00 00	 movzx	 ecx, BYTE PTR k$[rsp+rcx]
  0064a	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00652	33 c1		 xor	 eax, ecx
  00654	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00658	83 c1 08	 add	 ecx, 8
  0065b	48 63 c9	 movsxd	 rcx, ecx
  0065e	88 84 0c a0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3774 :     parameter_block[i + 8] ^= parameter_block[i + 24];

  00665	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00669	83 c0 08	 add	 eax, 8
  0066c	48 98		 cdqe
  0066e	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00672	83 c1 18	 add	 ecx, 24
  00675	48 63 c9	 movsxd	 rcx, ecx
  00678	0f b6 8c 0c a0
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00680	0f b6 84 04 a0
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00688	33 c1		 xor	 eax, ecx
  0068a	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0068e	83 c1 08	 add	 ecx, 8
  00691	48 63 c9	 movsxd	 rcx, ecx
  00694	88 84 0c a0 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3775 :   }

  0069b	eb 86		 jmp	 SHORT $LN11@s370_pcc_c
$LN12@s370_pcc_c:

; 3776 :   rijndael_encrypt(&context, &parameter_block[8], &parameter_block[8]);

  0069d	b8 01 00 00 00	 mov	 eax, 1
  006a2	48 6b c0 08	 imul	 rax, rax, 8
  006a6	48 8d 84 04 a0
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  006ae	b9 01 00 00 00	 mov	 ecx, 1
  006b3	48 6b c9 08	 imul	 rcx, rcx, 8
  006b7	48 8d 8c 0c a0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  006bf	4c 8b c0	 mov	 r8, rax
  006c2	48 8b d1	 mov	 rdx, rcx
  006c5	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  006cd	e8 00 00 00 00	 call	 rijndael_encrypt

; 3777 : 
; 3778 : #ifdef OPTION_PCC_DEBUG
; 3779 :   LOGBYTE("cmac  :", &parameter_block[8], 16);
; 3780 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3781 : 
; 3782 :   /* Store the CMAC */
; 3783 :   ARCH_DEP(vstorec)(&parameter_block[8], 15, (GR_A(1, regs) + 24) & ADDRESS_MAXWRAP(regs), 1, regs);

  006d2	b8 08 00 00 00	 mov	 eax, 8
  006d7	48 6b c0 01	 imul	 rax, rax, 1
  006db	48 8b 8c 24 30
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006e3	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  006ea	83 c0 18	 add	 eax, 24
  006ed	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  006f2	b9 01 00 00 00	 mov	 ecx, 1
  006f7	48 6b c9 08	 imul	 rcx, rcx, 8
  006fb	48 8d 8c 0c a0
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00703	48 8b 94 24 30
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0070b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00710	41 b9 01 00 00
	00		 mov	 r9d, 1
  00716	44 8b c0	 mov	 r8d, eax
  00719	b2 0f		 mov	 dl, 15
  0071b	e8 00 00 00 00	 call	 s370_vstorec

; 3784 : 
; 3785 :   /* Normal completion */
; 3786 :   regs->psw.cc = 0;

  00720	48 8b 84 24 30
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00728	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s370_pcc_c:
$LN25@s370_pcc_c:

; 3787 : }

  0072c	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00734	48 33 cc	 xor	 rcx, rsp
  00737	e8 00 00 00 00	 call	 __security_check_cookie
  0073c	48 81 c4 20 03
	00 00		 add	 rsp, 800		; 00000320H
  00743	5f		 pop	 rdi
  00744	c3		 ret	 0
s370_pcc_cmac_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
tfc$ = 52
parameter_blocklen$ = 56
tv197 = 60
tv300 = 64
tv418 = 68
tv70 = 72
tv81 = 76
tv161 = 80
wrap$ = 84
keylen$ = 88
tv546 = 92
tv256 = 96
tv287 = 100
$T1 = 104
tv239 = 112
tv267 = 120
context1$ = 128
context2$ = 272
context3$ = 416
k$ = 560
r64$ = 568
mask$ = 576
parameter_block$ = 592
__$ArrayPad$ = 672
regs$ = 704
s370_pcc_cmac_dea PROC

; 3451 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec b0 02
	00 00		 sub	 rsp, 688		; 000002b0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3452 :   des_context context1;
; 3453 :   des_context context2;
; 3454 :   des_context context3;
; 3455 :   int i;
; 3456 :   BYTE k[8];
; 3457 :   int keylen;
; 3458 :   BYTE mask[8] = { 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff };

  0001f	c6 84 24 40 02
	00 00 80	 mov	 BYTE PTR mask$[rsp], 128 ; 00000080H
  00027	c6 84 24 41 02
	00 00 c0	 mov	 BYTE PTR mask$[rsp+1], 192 ; 000000c0H
  0002f	c6 84 24 42 02
	00 00 e0	 mov	 BYTE PTR mask$[rsp+2], 224 ; 000000e0H
  00037	c6 84 24 43 02
	00 00 f0	 mov	 BYTE PTR mask$[rsp+3], 240 ; 000000f0H
  0003f	c6 84 24 44 02
	00 00 f8	 mov	 BYTE PTR mask$[rsp+4], 248 ; 000000f8H
  00047	c6 84 24 45 02
	00 00 fc	 mov	 BYTE PTR mask$[rsp+5], 252 ; 000000fcH
  0004f	c6 84 24 46 02
	00 00 fe	 mov	 BYTE PTR mask$[rsp+6], 254 ; 000000feH
  00057	c6 84 24 47 02
	00 00 ff	 mov	 BYTE PTR mask$[rsp+7], 255 ; 000000ffH

; 3459 :   BYTE parameter_block[72];
; 3460 :   int parameter_blocklen;
; 3461 :   BYTE r64[8] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1b };

  0005f	c6 84 24 38 02
	00 00 00	 mov	 BYTE PTR r64$[rsp], 0
  00067	c6 84 24 39 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+1], 0
  0006f	c6 84 24 3a 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+2], 0
  00077	c6 84 24 3b 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+3], 0
  0007f	c6 84 24 3c 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+4], 0
  00087	c6 84 24 3d 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+5], 0
  0008f	c6 84 24 3e 02
	00 00 00	 mov	 BYTE PTR r64$[rsp+6], 0
  00097	c6 84 24 3f 02
	00 00 1b	 mov	 BYTE PTR r64$[rsp+7], 27

; 3462 :   int tfc;
; 3463 :   int wrap;
; 3464 : 
; 3465 :   /* Check special conditions */
; 3466 :   if(unlikely(GR0_m(regs)))

  0009f	b8 08 00 00 00	 mov	 eax, 8
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b0	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000b7	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000bc	85 c0		 test	 eax, eax
  000be	74 0a		 je	 SHORT $LN41@s370_pcc_c
  000c0	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  000c8	eb 08		 jmp	 SHORT $LN42@s370_pcc_c
$LN41@s370_pcc_c:
  000ca	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN42@s370_pcc_c:
  000d2	83 7c 24 48 00	 cmp	 DWORD PTR tv70[rsp], 0
  000d7	74 0a		 je	 SHORT $LN47@s370_pcc_c
  000d9	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv81[rsp], 1
  000e1	eb 08		 jmp	 SHORT $LN48@s370_pcc_c
$LN47@s370_pcc_c:
  000e3	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN48@s370_pcc_c:
  000eb	83 7c 24 4c 00	 cmp	 DWORD PTR tv81[rsp], 0
  000f0	74 13		 je	 SHORT $LN20@s370_pcc_c

; 3467 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000f2	ba 06 00 00 00	 mov	 edx, 6
  000f7	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN20@s370_pcc_c:

; 3468 : 
; 3469 :   /* Initialize values */
; 3470 :   tfc = GR0_tfc(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 00	 imul	 rax, rax, 0
  0010e	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00120	83 e0 77	 and	 eax, 119		; 00000077H
  00123	89 44 24 34	 mov	 DWORD PTR tfc$[rsp], eax

; 3471 :   wrap = GR0_wrap(regs);

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 00	 imul	 rax, rax, 0
  00130	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0013f	83 e0 08	 and	 eax, 8
  00142	85 c0		 test	 eax, eax
  00144	74 0a		 je	 SHORT $LN49@s370_pcc_c
  00146	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv161[rsp], 1
  0014e	eb 08		 jmp	 SHORT $LN50@s370_pcc_c
$LN49@s370_pcc_c:
  00150	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN50@s370_pcc_c:
  00158	8b 44 24 50	 mov	 eax, DWORD PTR tv161[rsp]
  0015c	89 44 24 54	 mov	 DWORD PTR wrap$[rsp], eax

; 3472 :   keylen = tfc * 8;

  00160	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  00164	c1 e0 03	 shl	 eax, 3
  00167	89 44 24 58	 mov	 DWORD PTR keylen$[rsp], eax

; 3473 :   parameter_blocklen = keylen + 24;

  0016b	8b 44 24 58	 mov	 eax, DWORD PTR keylen$[rsp]
  0016f	83 c0 18	 add	 eax, 24
  00172	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3474 :   if(wrap)

  00176	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0017b	74 0b		 je	 SHORT $LN21@s370_pcc_c

; 3475 :     parameter_blocklen += 24;

  0017d	8b 44 24 38	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00181	83 c0 18	 add	 eax, 24
  00184	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN21@s370_pcc_c:

; 3476 : 
; 3477 :   /* Test writeability output chaining value */
; 3478 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + 16) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  00188	b8 08 00 00 00	 mov	 eax, 8
  0018d	48 6b c0 01	 imul	 rax, rax, 1
  00191	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a0	83 c0 10	 add	 eax, 16
  001a3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001a8	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b0	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001b5	41 b9 02 00 00
	00		 mov	 r9d, 2
  001bb	41 b8 07 00 00
	00		 mov	 r8d, 7
  001c1	ba 01 00 00 00	 mov	 edx, 1
  001c6	8b c8		 mov	 ecx, eax
  001c8	e8 00 00 00 00	 call	 s370_validate_operand

; 3479 : 
; 3480 :   /* Fetch the parameter block */
; 3481 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001cd	b8 08 00 00 00	 mov	 eax, 8
  001d2	48 6b c0 01	 imul	 rax, rax, 1
  001d6	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001de	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e5	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001ea	8b 4c 24 38	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001ee	ff c9		 dec	 ecx
  001f0	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f8	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001fd	41 b9 01 00 00
	00		 mov	 r9d, 1
  00203	44 8b c0	 mov	 r8d, eax
  00206	0f b6 d1	 movzx	 edx, cl
  00209	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00211	e8 00 00 00 00	 call	 s370_vfetchc

; 3482 : 
; 3483 : #ifdef OPTION_PCC_DEBUG
; 3484 :   LOGBYTE("ml    :", parameter_block, 1);
; 3485 :   LOGBYTE("msg   :", &parameter_block[8], 8);
; 3486 :   LOGBYTE("icv   :", &parameter_block[16], 8);
; 3487 :   switch(tfc)
; 3488 :   {
; 3489 :     case 1: /* dea */
; 3490 :     {
; 3491 :       LOGBYTE("k     :", &parameter_block[24], 8);
; 3492 :       break;
; 3493 :     }
; 3494 :     case 2: /* tdea-128 */
; 3495 :     {
; 3496 :       LOGBYTE("k1    :", &parameter_block[24], 8);
; 3497 :       LOGBYTE("k2    :", &parameter_block[32], 8);
; 3498 :       break;
; 3499 :     }
; 3500 :     case 3: /* tdea-192 */
; 3501 :     {
; 3502 :       LOGBYTE("k1    :", &parameter_block[24], 8);
; 3503 :       LOGBYTE("k2    :", &parameter_block[32], 8);
; 3504 :       LOGBYTE("k3    :", &parameter_block[40], 8);
; 3505 :       break;
; 3506 :     }
; 3507 :   }
; 3508 :   if(wrap)
; 3509 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 24], 24);
; 3510 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3511 : 
; 3512 :   /* Verify and unwrap */
; 3513 :   if(wrap && unwrap_dea(&parameter_block[24], keylen))

  00216	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0021b	74 32		 je	 SHORT $LN22@s370_pcc_c
  0021d	b8 01 00 00 00	 mov	 eax, 1
  00222	48 6b c0 18	 imul	 rax, rax, 24
  00226	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0022e	8b 54 24 58	 mov	 edx, DWORD PTR keylen$[rsp]
  00232	48 8b c8	 mov	 rcx, rax
  00235	e8 00 00 00 00	 call	 unwrap_dea
  0023a	85 c0		 test	 eax, eax
  0023c	74 11		 je	 SHORT $LN22@s370_pcc_c

; 3514 :   {
; 3515 : 
; 3516 : #ifdef OPTION_PCC_DEBUG
; 3517 :     WRMSG(HHC90111, "D");
; 3518 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3519 : 
; 3520 :     regs->psw.cc = 1;

  0023e	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00246	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3521 :     return;

  0024a	e9 a0 07 00 00	 jmp	 $LN1@s370_pcc_c
$LN22@s370_pcc_c:

; 3522 :   }
; 3523 : 
; 3524 :   /* Set the cryptographic key */
; 3525 :   switch(tfc)

  0024f	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  00253	89 44 24 3c	 mov	 DWORD PTR tv197[rsp], eax
  00257	83 7c 24 3c 01	 cmp	 DWORD PTR tv197[rsp], 1
  0025c	74 13		 je	 SHORT $LN23@s370_pcc_c
  0025e	83 7c 24 3c 02	 cmp	 DWORD PTR tv197[rsp], 2
  00263	74 32		 je	 SHORT $LN24@s370_pcc_c
  00265	83 7c 24 3c 03	 cmp	 DWORD PTR tv197[rsp], 3
  0026a	74 6f		 je	 SHORT $LN25@s370_pcc_c
  0026c	e9 cd 00 00 00	 jmp	 $LN2@s370_pcc_c
$LN23@s370_pcc_c:

; 3526 :   {
; 3527 :     case 1: /* dea */
; 3528 :     {
; 3529 :       des_set_key(&context1, &parameter_block[24]);

  00271	b8 01 00 00 00	 mov	 eax, 1
  00276	48 6b c0 18	 imul	 rax, rax, 24
  0027a	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00282	48 8b d0	 mov	 rdx, rax
  00285	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0028d	e8 00 00 00 00	 call	 des_set_key

; 3530 :       break;

  00292	e9 a7 00 00 00	 jmp	 $LN2@s370_pcc_c
$LN24@s370_pcc_c:

; 3531 :     }
; 3532 :     case 2: /* tdea-128 */
; 3533 :     {
; 3534 :       des_set_key(&context1, &parameter_block[24]);

  00297	b8 01 00 00 00	 mov	 eax, 1
  0029c	48 6b c0 18	 imul	 rax, rax, 24
  002a0	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002a8	48 8b d0	 mov	 rdx, rax
  002ab	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002b3	e8 00 00 00 00	 call	 des_set_key

; 3535 :       des_set_key(&context2, &parameter_block[32]);

  002b8	b8 01 00 00 00	 mov	 eax, 1
  002bd	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  002c1	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002c9	48 8b d0	 mov	 rdx, rax
  002cc	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002d4	e8 00 00 00 00	 call	 des_set_key

; 3536 :       break;

  002d9	eb 63		 jmp	 SHORT $LN2@s370_pcc_c
$LN25@s370_pcc_c:

; 3537 :     }
; 3538 :     case 3: /* tdea-192 */
; 3539 :     {
; 3540 :       des_set_key(&context1, &parameter_block[24]);

  002db	b8 01 00 00 00	 mov	 eax, 1
  002e0	48 6b c0 18	 imul	 rax, rax, 24
  002e4	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002ec	48 8b d0	 mov	 rdx, rax
  002ef	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002f7	e8 00 00 00 00	 call	 des_set_key

; 3541 :       des_set_key(&context2, &parameter_block[32]);

  002fc	b8 01 00 00 00	 mov	 eax, 1
  00301	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00305	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0030d	48 8b d0	 mov	 rdx, rax
  00310	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00318	e8 00 00 00 00	 call	 des_set_key

; 3542 :       des_set_key(&context3, &parameter_block[40]);

  0031d	b8 01 00 00 00	 mov	 eax, 1
  00322	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00326	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0032e	48 8b d0	 mov	 rdx, rax
  00331	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00339	e8 00 00 00 00	 call	 des_set_key
$LN2@s370_pcc_c:

; 3543 :       break;
; 3544 :     }
; 3545 :   }
; 3546 : 
; 3547 :   /* Check validity ML value */
; 3548 :   if(parameter_block[0] > 64)

  0033e	b8 01 00 00 00	 mov	 eax, 1
  00343	48 6b c0 00	 imul	 rax, rax, 0
  00347	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0034f	83 f8 40	 cmp	 eax, 64			; 00000040H
  00352	7e 11		 jle	 SHORT $LN26@s370_pcc_c

; 3549 :   {
; 3550 :     regs->psw.cc = 2;

  00354	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0035c	c6 40 7c 02	 mov	 BYTE PTR [rax+124], 2

; 3551 :     return;

  00360	e9 8a 06 00 00	 jmp	 $LN1@s370_pcc_c
$LN26@s370_pcc_c:

; 3552 :   }
; 3553 : 
; 3554 :   /* Place the one bit */
; 3555 :   if(parameter_block[0] != 64)

  00365	b8 01 00 00 00	 mov	 eax, 1
  0036a	48 6b c0 00	 imul	 rax, rax, 0
  0036e	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00376	83 f8 40	 cmp	 eax, 64			; 00000040H
  00379	0f 84 95 00 00
	00		 je	 $LN27@s370_pcc_c

; 3556 :     parameter_block[(parameter_block[0] / 8) + 8] |= (0x80 >> (parameter_block[0] % 8));

  0037f	b8 01 00 00 00	 mov	 eax, 1
  00384	48 6b c0 00	 imul	 rax, rax, 0
  00388	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00390	99		 cdq
  00391	83 e2 07	 and	 edx, 7
  00394	03 c2		 add	 eax, edx
  00396	c1 f8 03	 sar	 eax, 3
  00399	83 c0 08	 add	 eax, 8
  0039c	48 98		 cdqe
  0039e	48 89 44 24 70	 mov	 QWORD PTR tv239[rsp], rax
  003a3	b9 01 00 00 00	 mov	 ecx, 1
  003a8	48 6b c9 00	 imul	 rcx, rcx, 0
  003ac	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003b4	8b c1		 mov	 eax, ecx
  003b6	99		 cdq
  003b7	83 e2 07	 and	 edx, 7
  003ba	03 c2		 add	 eax, edx
  003bc	83 e0 07	 and	 eax, 7
  003bf	2b c2		 sub	 eax, edx
  003c1	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  003c6	89 4c 24 5c	 mov	 DWORD PTR tv546[rsp], ecx
  003ca	0f b6 c8	 movzx	 ecx, al
  003cd	8b 44 24 5c	 mov	 eax, DWORD PTR tv546[rsp]
  003d1	d3 f8		 sar	 eax, cl
  003d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv239[rsp]
  003d8	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003e0	0b c8		 or	 ecx, eax
  003e2	8b c1		 mov	 eax, ecx
  003e4	89 44 24 60	 mov	 DWORD PTR tv256[rsp], eax
  003e8	b9 01 00 00 00	 mov	 ecx, 1
  003ed	48 6b c9 00	 imul	 rcx, rcx, 0
  003f1	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003f9	8b c1		 mov	 eax, ecx
  003fb	99		 cdq
  003fc	83 e2 07	 and	 edx, 7
  003ff	03 c2		 add	 eax, edx
  00401	c1 f8 03	 sar	 eax, 3
  00404	83 c0 08	 add	 eax, 8
  00407	48 98		 cdqe
  00409	8b 4c 24 60	 mov	 ecx, DWORD PTR tv256[rsp]
  0040d	88 8c 04 50 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl
$LN27@s370_pcc_c:

; 3557 : 
; 3558 :   /* Pad with zeroes */
; 3559 :   if(parameter_block[0] < 63)

  00414	b8 01 00 00 00	 mov	 eax, 1
  00419	48 6b c0 00	 imul	 rax, rax, 0
  0041d	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00425	83 f8 3f	 cmp	 eax, 63			; 0000003fH
  00428	0f 8d ec 00 00
	00		 jge	 $LN28@s370_pcc_c

; 3560 :   {
; 3561 :     parameter_block[(parameter_block[0] / 8) + 8] &= mask[parameter_block[0] % 8];

  0042e	b8 01 00 00 00	 mov	 eax, 1
  00433	48 6b c0 00	 imul	 rax, rax, 0
  00437	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  0043f	99		 cdq
  00440	83 e2 07	 and	 edx, 7
  00443	03 c2		 add	 eax, edx
  00445	c1 f8 03	 sar	 eax, 3
  00448	83 c0 08	 add	 eax, 8
  0044b	48 98		 cdqe
  0044d	48 89 44 24 78	 mov	 QWORD PTR tv267[rsp], rax
  00452	b9 01 00 00 00	 mov	 ecx, 1
  00457	48 6b c9 00	 imul	 rcx, rcx, 0
  0045b	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00463	8b c1		 mov	 eax, ecx
  00465	99		 cdq
  00466	83 e2 07	 and	 edx, 7
  00469	03 c2		 add	 eax, edx
  0046b	83 e0 07	 and	 eax, 7
  0046e	2b c2		 sub	 eax, edx
  00470	48 98		 cdqe
  00472	0f b6 84 04 40
	02 00 00	 movzx	 eax, BYTE PTR mask$[rsp+rax]
  0047a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv267[rsp]
  0047f	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00487	23 c8		 and	 ecx, eax
  00489	8b c1		 mov	 eax, ecx
  0048b	89 44 24 64	 mov	 DWORD PTR tv287[rsp], eax
  0048f	b9 01 00 00 00	 mov	 ecx, 1
  00494	48 6b c9 00	 imul	 rcx, rcx, 0
  00498	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  004a0	8b c1		 mov	 eax, ecx
  004a2	99		 cdq
  004a3	83 e2 07	 and	 edx, 7
  004a6	03 c2		 add	 eax, edx
  004a8	c1 f8 03	 sar	 eax, 3
  004ab	83 c0 08	 add	 eax, 8
  004ae	48 98		 cdqe
  004b0	8b 4c 24 64	 mov	 ecx, DWORD PTR tv287[rsp]
  004b4	88 8c 04 50 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rax], cl

; 3562 :     for(i = (parameter_block[0] / 8) + 1; i < 8; i++)

  004bb	b8 01 00 00 00	 mov	 eax, 1
  004c0	48 6b c0 00	 imul	 rax, rax, 0
  004c4	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  004cc	99		 cdq
  004cd	83 e2 07	 and	 edx, 7
  004d0	03 c2		 add	 eax, edx
  004d2	c1 f8 03	 sar	 eax, 3
  004d5	ff c0		 inc	 eax
  004d7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  004db	eb 0a		 jmp	 SHORT $LN6@s370_pcc_c
$LN4@s370_pcc_c:
  004dd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004e1	ff c0		 inc	 eax
  004e3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN6@s370_pcc_c:
  004e7	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  004ec	7d 2c		 jge	 SHORT $LN5@s370_pcc_c

; 3563 :       parameter_block[i + 8] = 0x00;

  004ee	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004f2	83 c0 08	 add	 eax, 8
  004f5	48 98		 cdqe
  004f7	48 89 44 24 68	 mov	 QWORD PTR $T1[rsp], rax
  004fc	48 83 7c 24 68
	48		 cmp	 QWORD PTR $T1[rsp], 72	; 00000048H
  00502	73 02		 jae	 SHORT $LN51@s370_pcc_c
  00504	eb 05		 jmp	 SHORT $LN52@s370_pcc_c
$LN51@s370_pcc_c:
  00506	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN52@s370_pcc_c:
  0050b	48 8b 44 24 68	 mov	 rax, QWORD PTR $T1[rsp]
  00510	c6 84 04 50 02
	00 00 00	 mov	 BYTE PTR parameter_block$[rsp+rax], 0
  00518	eb c3		 jmp	 SHORT $LN4@s370_pcc_c
$LN5@s370_pcc_c:
$LN28@s370_pcc_c:

; 3564 :   }
; 3565 : 
; 3566 : #ifdef OPTION_PCC_DEBUG
; 3567 :   LOGBYTE("msg   :", &parameter_block[8], 8);
; 3568 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3569 : 
; 3570 :   /* Calculate subkey */
; 3571 :   zeromem(k, 8);

  0051a	48 8d 84 24 30
	02 00 00	 lea	 rax, QWORD PTR k$[rsp]
  00522	48 8b f8	 mov	 rdi, rax
  00525	33 c0		 xor	 eax, eax
  00527	b9 08 00 00 00	 mov	 ecx, 8
  0052c	f3 aa		 rep stosb

; 3572 :   switch(tfc)

  0052e	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  00532	89 44 24 40	 mov	 DWORD PTR tv300[rsp], eax
  00536	83 7c 24 40 01	 cmp	 DWORD PTR tv300[rsp], 1
  0053b	74 17		 je	 SHORT $LN29@s370_pcc_c
  0053d	83 7c 24 40 02	 cmp	 DWORD PTR tv300[rsp], 2
  00542	74 32		 je	 SHORT $LN30@s370_pcc_c
  00544	83 7c 24 40 03	 cmp	 DWORD PTR tv300[rsp], 3
  00549	0f 84 80 00 00
	00		 je	 $LN31@s370_pcc_c
  0054f	e9 d2 00 00 00	 jmp	 $LN7@s370_pcc_c
$LN29@s370_pcc_c:

; 3573 :   {
; 3574 :     case 1: /* dea */
; 3575 :     {
; 3576 :       des_encrypt(&context1, k, k);

  00554	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  0055c	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00564	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0056c	e8 00 00 00 00	 call	 des_encrypt

; 3577 :       break;

  00571	e9 b0 00 00 00	 jmp	 $LN7@s370_pcc_c
$LN30@s370_pcc_c:

; 3578 :     }
; 3579 :     case 2: /* tdea-128 */
; 3580 :     {
; 3581 :       des_encrypt(&context1, k, k);

  00576	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  0057e	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00586	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0058e	e8 00 00 00 00	 call	 des_encrypt

; 3582 :       des_decrypt(&context2, k, k);

  00593	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  0059b	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  005a3	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  005ab	e8 00 00 00 00	 call	 des_decrypt

; 3583 :       des_encrypt(&context1, k, k);

  005b0	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  005b8	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  005c0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005c8	e8 00 00 00 00	 call	 des_encrypt

; 3584 :       break;

  005cd	eb 57		 jmp	 SHORT $LN7@s370_pcc_c
$LN31@s370_pcc_c:

; 3585 :     }
; 3586 :     case 3: /* tdea-192 */
; 3587 :     {
; 3588 :       des_encrypt(&context1, k, k);

  005cf	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  005d7	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  005df	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  005e7	e8 00 00 00 00	 call	 des_encrypt

; 3589 :       des_decrypt(&context2, k, k);

  005ec	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  005f4	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  005fc	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00604	e8 00 00 00 00	 call	 des_decrypt

; 3590 :       des_encrypt(&context3, k, k);

  00609	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR k$[rsp]
  00611	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  00619	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00621	e8 00 00 00 00	 call	 des_encrypt
$LN7@s370_pcc_c:

; 3591 :       break;
; 3592 :     }
; 3593 :   }
; 3594 : 
; 3595 :   /* Calculate subkeys Kx and Ky */
; 3596 :   if(!(k[0] & 0x80))

  00626	b8 01 00 00 00	 mov	 eax, 1
  0062b	48 6b c0 00	 imul	 rax, rax, 0
  0062f	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  00637	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0063c	85 c0		 test	 eax, eax
  0063e	75 1d		 jne	 SHORT $LN32@s370_pcc_c

; 3597 :     shift_left(k, k, 8);

  00640	41 b8 08 00 00
	00		 mov	 r8d, 8
  00646	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0064e	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00656	e8 00 00 00 00	 call	 shift_left
  0065b	eb 60		 jmp	 SHORT $LN33@s370_pcc_c
$LN32@s370_pcc_c:

; 3598 :   else
; 3599 :   {
; 3600 :     shift_left(k, k, 8);

  0065d	41 b8 08 00 00
	00		 mov	 r8d, 8
  00663	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0066b	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00673	e8 00 00 00 00	 call	 shift_left

; 3601 :     for(i = 0; i < 8; i++)

  00678	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00680	eb 0a		 jmp	 SHORT $LN11@s370_pcc_c
$LN9@s370_pcc_c:
  00682	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00686	ff c0		 inc	 eax
  00688	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@s370_pcc_c:
  0068c	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00691	7d 2a		 jge	 SHORT $LN10@s370_pcc_c

; 3602 :       k[i] ^= r64[i];

  00693	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00698	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0069d	0f b6 8c 0c 38
	02 00 00	 movzx	 ecx, BYTE PTR r64$[rsp+rcx]
  006a5	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  006ad	33 c1		 xor	 eax, ecx
  006af	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006b4	88 84 0c 30 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  006bb	eb c5		 jmp	 SHORT $LN9@s370_pcc_c
$LN10@s370_pcc_c:
$LN33@s370_pcc_c:

; 3603 :   }
; 3604 :   if(parameter_block[0] != 64)

  006bd	b8 01 00 00 00	 mov	 eax, 1
  006c2	48 6b c0 00	 imul	 rax, rax, 0
  006c6	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  006ce	83 f8 40	 cmp	 eax, 64			; 00000040H
  006d1	0f 84 97 00 00
	00		 je	 $LN34@s370_pcc_c

; 3605 :   {
; 3606 :     if(!(k[0] & 0x80))

  006d7	b8 01 00 00 00	 mov	 eax, 1
  006dc	48 6b c0 00	 imul	 rax, rax, 0
  006e0	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  006e8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  006ed	85 c0		 test	 eax, eax
  006ef	75 1d		 jne	 SHORT $LN35@s370_pcc_c

; 3607 :       shift_left(k, k, 8);

  006f1	41 b8 08 00 00
	00		 mov	 r8d, 8
  006f7	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  006ff	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00707	e8 00 00 00 00	 call	 shift_left
  0070c	eb 60		 jmp	 SHORT $LN36@s370_pcc_c
$LN35@s370_pcc_c:

; 3608 :     else
; 3609 :     {
; 3610 :       shift_left(k, k, 8);

  0070e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00714	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR k$[rsp]
  0071c	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR k$[rsp]
  00724	e8 00 00 00 00	 call	 shift_left

; 3611 :       for(i = 0; i < 8; i++)

  00729	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00731	eb 0a		 jmp	 SHORT $LN14@s370_pcc_c
$LN12@s370_pcc_c:
  00733	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00737	ff c0		 inc	 eax
  00739	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN14@s370_pcc_c:
  0073d	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00742	7d 2a		 jge	 SHORT $LN13@s370_pcc_c

; 3612 :         k[i] ^= r64[i];

  00744	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00749	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0074e	0f b6 8c 0c 38
	02 00 00	 movzx	 ecx, BYTE PTR r64$[rsp+rcx]
  00756	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR k$[rsp+rax]
  0075e	33 c1		 xor	 eax, ecx
  00760	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00765	88 84 0c 30 02
	00 00		 mov	 BYTE PTR k$[rsp+rcx], al
  0076c	eb c5		 jmp	 SHORT $LN12@s370_pcc_c
$LN13@s370_pcc_c:
$LN36@s370_pcc_c:
$LN34@s370_pcc_c:

; 3613 :     }
; 3614 :   }
; 3615 : 
; 3616 : #ifdef OPTION_PCC_DEBUG
; 3617 :   LOGBYTE("Subkey:", k, 8);
; 3618 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3619 : 
; 3620 :   /* XOR with kx or ky and encrypt */
; 3621 :   for(i = 0; i < 8; i++)

  0076e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00776	eb 0a		 jmp	 SHORT $LN17@s370_pcc_c
$LN15@s370_pcc_c:
  00778	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0077c	ff c0		 inc	 eax
  0077e	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN17@s370_pcc_c:
  00782	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00787	7d 69		 jge	 SHORT $LN16@s370_pcc_c

; 3622 :   {
; 3623 :     parameter_block[i + 8] ^= k[i];

  00789	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0078d	83 c0 08	 add	 eax, 8
  00790	48 98		 cdqe
  00792	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00797	0f b6 8c 0c 30
	02 00 00	 movzx	 ecx, BYTE PTR k$[rsp+rcx]
  0079f	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  007a7	33 c1		 xor	 eax, ecx
  007a9	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  007ad	83 c1 08	 add	 ecx, 8
  007b0	48 63 c9	 movsxd	 rcx, ecx
  007b3	88 84 0c 50 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3624 :     parameter_block[i + 8] ^= parameter_block[i + 16];

  007ba	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  007be	83 c0 08	 add	 eax, 8
  007c1	48 98		 cdqe
  007c3	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  007c7	83 c1 10	 add	 ecx, 16
  007ca	48 63 c9	 movsxd	 rcx, ecx
  007cd	0f b6 8c 0c 50
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  007d5	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  007dd	33 c1		 xor	 eax, ecx
  007df	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  007e3	83 c1 08	 add	 ecx, 8
  007e6	48 63 c9	 movsxd	 rcx, ecx
  007e9	88 84 0c 50 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al

; 3625 :   }

  007f0	eb 86		 jmp	 SHORT $LN15@s370_pcc_c
$LN16@s370_pcc_c:

; 3626 :   switch(tfc)

  007f2	8b 44 24 34	 mov	 eax, DWORD PTR tfc$[rsp]
  007f6	89 44 24 44	 mov	 DWORD PTR tv418[rsp], eax
  007fa	83 7c 24 44 01	 cmp	 DWORD PTR tv418[rsp], 1
  007ff	74 17		 je	 SHORT $LN37@s370_pcc_c
  00801	83 7c 24 44 02	 cmp	 DWORD PTR tv418[rsp], 2
  00806	74 4a		 je	 SHORT $LN38@s370_pcc_c
  00808	83 7c 24 44 03	 cmp	 DWORD PTR tv418[rsp], 3
  0080d	0f 84 e3 00 00
	00		 je	 $LN39@s370_pcc_c
  00813	e9 7d 01 00 00	 jmp	 $LN18@s370_pcc_c
$LN37@s370_pcc_c:

; 3627 :   {
; 3628 :     case 1: /* dea */
; 3629 :     {
; 3630 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  00818	b8 01 00 00 00	 mov	 eax, 1
  0081d	48 6b c0 08	 imul	 rax, rax, 8
  00821	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00829	b9 01 00 00 00	 mov	 ecx, 1
  0082e	48 6b c9 08	 imul	 rcx, rcx, 8
  00832	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0083a	4c 8b c0	 mov	 r8, rax
  0083d	48 8b d1	 mov	 rdx, rcx
  00840	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00848	e8 00 00 00 00	 call	 des_encrypt

; 3631 :       break;

  0084d	e9 43 01 00 00	 jmp	 $LN18@s370_pcc_c
$LN38@s370_pcc_c:

; 3632 :     }
; 3633 :     case 2: /* tdea-128 */
; 3634 :     {
; 3635 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  00852	b8 01 00 00 00	 mov	 eax, 1
  00857	48 6b c0 08	 imul	 rax, rax, 8
  0085b	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00863	b9 01 00 00 00	 mov	 ecx, 1
  00868	48 6b c9 08	 imul	 rcx, rcx, 8
  0086c	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00874	4c 8b c0	 mov	 r8, rax
  00877	48 8b d1	 mov	 rdx, rcx
  0087a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00882	e8 00 00 00 00	 call	 des_encrypt

; 3636 :       des_decrypt(&context2, &parameter_block[8], &parameter_block[8]);

  00887	b8 01 00 00 00	 mov	 eax, 1
  0088c	48 6b c0 08	 imul	 rax, rax, 8
  00890	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00898	b9 01 00 00 00	 mov	 ecx, 1
  0089d	48 6b c9 08	 imul	 rcx, rcx, 8
  008a1	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  008a9	4c 8b c0	 mov	 r8, rax
  008ac	48 8b d1	 mov	 rdx, rcx
  008af	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  008b7	e8 00 00 00 00	 call	 des_decrypt

; 3637 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  008bc	b8 01 00 00 00	 mov	 eax, 1
  008c1	48 6b c0 08	 imul	 rax, rax, 8
  008c5	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  008cd	b9 01 00 00 00	 mov	 ecx, 1
  008d2	48 6b c9 08	 imul	 rcx, rcx, 8
  008d6	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  008de	4c 8b c0	 mov	 r8, rax
  008e1	48 8b d1	 mov	 rdx, rcx
  008e4	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  008ec	e8 00 00 00 00	 call	 des_encrypt

; 3638 :       break;

  008f1	e9 9f 00 00 00	 jmp	 $LN18@s370_pcc_c
$LN39@s370_pcc_c:

; 3639 :     }
; 3640 :     case 3: /* tdea-192 */
; 3641 :     {
; 3642 :       des_encrypt(&context1, &parameter_block[8], &parameter_block[8]);

  008f6	b8 01 00 00 00	 mov	 eax, 1
  008fb	48 6b c0 08	 imul	 rax, rax, 8
  008ff	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00907	b9 01 00 00 00	 mov	 ecx, 1
  0090c	48 6b c9 08	 imul	 rcx, rcx, 8
  00910	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00918	4c 8b c0	 mov	 r8, rax
  0091b	48 8b d1	 mov	 rdx, rcx
  0091e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00926	e8 00 00 00 00	 call	 des_encrypt

; 3643 :       des_decrypt(&context2, &parameter_block[8], &parameter_block[8]);

  0092b	b8 01 00 00 00	 mov	 eax, 1
  00930	48 6b c0 08	 imul	 rax, rax, 8
  00934	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0093c	b9 01 00 00 00	 mov	 ecx, 1
  00941	48 6b c9 08	 imul	 rcx, rcx, 8
  00945	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0094d	4c 8b c0	 mov	 r8, rax
  00950	48 8b d1	 mov	 rdx, rcx
  00953	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0095b	e8 00 00 00 00	 call	 des_decrypt

; 3644 :       des_encrypt(&context3, &parameter_block[8], &parameter_block[8]);

  00960	b8 01 00 00 00	 mov	 eax, 1
  00965	48 6b c0 08	 imul	 rax, rax, 8
  00969	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00971	b9 01 00 00 00	 mov	 ecx, 1
  00976	48 6b c9 08	 imul	 rcx, rcx, 8
  0097a	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00982	4c 8b c0	 mov	 r8, rax
  00985	48 8b d1	 mov	 rdx, rcx
  00988	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00990	e8 00 00 00 00	 call	 des_encrypt
$LN18@s370_pcc_c:

; 3645 :       break;
; 3646 :     }
; 3647 :   }
; 3648 : 
; 3649 : #ifdef OPTION_PCC_DEBUG
; 3650 :   LOGBYTE("cmac  :", &parameter_block[8], 8);
; 3651 : #endif /* #ifdef OPTION_PCC_DEBUG */
; 3652 : 
; 3653 :   /* Store the CMAC */
; 3654 :   ARCH_DEP(vstorec)(&parameter_block[8], 7, (GR_A(1, regs) + 16) & ADDRESS_MAXWRAP(regs), 1, regs);

  00995	b8 08 00 00 00	 mov	 eax, 8
  0099a	48 6b c0 01	 imul	 rax, rax, 1
  0099e	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009a6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  009ad	83 c0 10	 add	 eax, 16
  009b0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  009b5	b9 01 00 00 00	 mov	 ecx, 1
  009ba	48 6b c9 08	 imul	 rcx, rcx, 8
  009be	48 8d 8c 0c 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  009c6	48 8b 94 24 c0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009ce	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  009d3	41 b9 01 00 00
	00		 mov	 r9d, 1
  009d9	44 8b c0	 mov	 r8d, eax
  009dc	b2 07		 mov	 dl, 7
  009de	e8 00 00 00 00	 call	 s370_vstorec

; 3655 : 
; 3656 :   /* Normal completion */
; 3657 :   regs->psw.cc = 0;

  009e3	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  009eb	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s370_pcc_c:
$LN40@s370_pcc_c:

; 3658 : }

  009ef	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  009f7	48 33 cc	 xor	 rcx, rsp
  009fa	e8 00 00 00 00	 call	 __security_check_cookie
  009ff	48 81 c4 b0 02
	00 00		 add	 rsp, 688		; 000002b0H
  00a06	5f		 pop	 rdi
  00a07	c3		 ret	 0
s370_pcc_cmac_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv82 = 64
tv93 = 68
tv136 = 72
tv151 = 76
wrap$ = 80
tv195 = 84
tv260 = 88
tv293 = 92
tv304 = 96
tfc$ = 100
r1_is_not_r2$ = 104
context$ = 112
message_block$ = 608
parameter_block$ = 624
__$ArrayPad$ = 704
r1$ = 736
r2$ = 744
regs$ = 752
s370_kmo_aes PROC

; 3336 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec d8 02
	00 00		 sub	 rsp, 728		; 000002d8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 c0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3337 :   rijndael_ctx context;
; 3338 :   int crypted;
; 3339 :   int i;
; 3340 :   int keylen;
; 3341 :   BYTE message_block[16];
; 3342 :   BYTE parameter_block[80];
; 3343 :   int parameter_blocklen;
; 3344 :   int r1_is_not_r2;
; 3345 :   int tfc;
; 3346 :   int wrap;
; 3347 : 
; 3348 :   /* Check special conditions */
; 3349 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00026	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 10 00 00 00	 mov	 ecx, 16
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN17@s370_kmo_a
  0004f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN18@s370_kmo_a
$LN17@s370_kmo_a:
  00059	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN18@s370_kmo_a:
  00061	83 7c 24 40 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN8@s370_kmo_a

; 3350 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_kmo_a:

; 3351 : 
; 3352 :   /* Return with cc 0 on zero length */
; 3353 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN19@s370_kmo_a
  00098	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN20@s370_kmo_a
$LN19@s370_kmo_a:
  000a2	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN20@s370_kmo_a:
  000aa	83 7c 24 44 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN23@s370_kmo_a
  000b1	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN24@s370_kmo_a
$LN23@s370_kmo_a:
  000bb	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN24@s370_kmo_a:
  000c3	83 7c 24 48 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN9@s370_kmo_a

; 3354 :   {
; 3355 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3356 :     return;

  000d6	e9 0f 04 00 00	 jmp	 $LN1@s370_kmo_a
$LN9@s370_kmo_a:

; 3357 :   }
; 3358 : 
; 3359 :   /* Initialize values */
; 3360 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 64	 mov	 DWORD PTR tfc$[rsp], eax

; 3361 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN25@s370_kmo_a
  0011c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN26@s370_kmo_a
$LN25@s370_kmo_a:
  00126	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN26@s370_kmo_a:
  0012e	8b 44 24 4c	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 3362 :   keylen = (tfc - 17) * 8 + 8;

  00136	8b 44 24 64	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00141	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 3363 :   parameter_blocklen = keylen + 16;

  00145	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00149	83 c0 10	 add	 eax, 16
  0014c	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3364 :   if(wrap)

  00150	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00155	74 0b		 je	 SHORT $LN10@s370_kmo_a

; 3365 :     parameter_blocklen += 32;

  00157	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0015b	83 c0 20	 add	 eax, 32			; 00000020H
  0015e	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN10@s370_kmo_a:

; 3366 : 
; 3367 :   /* Test writeability output chaining value */
; 3368 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  00162	b8 08 00 00 00	 mov	 eax, 8
  00167	48 6b c0 01	 imul	 rax, rax, 1
  0016b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017a	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0017f	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00187	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0018c	41 b9 02 00 00
	00		 mov	 r9d, 2
  00192	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00198	ba 01 00 00 00	 mov	 edx, 1
  0019d	8b c8		 mov	 ecx, eax
  0019f	e8 00 00 00 00	 call	 s370_validate_operand

; 3369 : 
; 3370 :   /* Fetch the parameter block */
; 3371 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001a4	b8 08 00 00 00	 mov	 eax, 8
  001a9	48 6b c0 01	 imul	 rax, rax, 1
  001ad	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b5	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001bc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001c1	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001c5	ff c9		 dec	 ecx
  001c7	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001cf	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001d4	41 b9 01 00 00
	00		 mov	 r9d, 1
  001da	44 8b c0	 mov	 r8d, eax
  001dd	0f b6 d1	 movzx	 edx, cl
  001e0	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001e8	e8 00 00 00 00	 call	 s370_vfetchc

; 3372 : 
; 3373 : #ifdef OPTION_KMO_DEBUG
; 3374 :   LOGBYTE("cv    :", parameter_block, 16);
; 3375 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 3376 :   if(wrap)
; 3377 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 16], 32);
; 3378 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3379 : 
; 3380 :   /* Verify and unwrap */
; 3381 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  001ed	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001f2	74 32		 je	 SHORT $LN11@s370_kmo_a
  001f4	b8 01 00 00 00	 mov	 eax, 1
  001f9	48 6b c0 10	 imul	 rax, rax, 16
  001fd	48 8d 84 04 70
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00205	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  00209	48 8b c8	 mov	 rcx, rax
  0020c	e8 00 00 00 00	 call	 unwrap_aes
  00211	85 c0		 test	 eax, eax
  00213	74 11		 je	 SHORT $LN11@s370_kmo_a

; 3382 :   {
; 3383 : 
; 3384 : #ifdef OPTION_KMO_DEBUG
; 3385 :     WRMSG(HHC90111, "D");
; 3386 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3387 : 
; 3388 :     regs->psw.cc = 1;

  00215	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021d	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3389 :     return;

  00221	e9 c4 02 00 00	 jmp	 $LN1@s370_kmo_a
$LN11@s370_kmo_a:

; 3390 :   }
; 3391 : 
; 3392 :   /* Set the cryptographic key */
; 3393 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  00226	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0022a	c1 e0 03	 shl	 eax, 3
  0022d	b9 01 00 00 00	 mov	 ecx, 1
  00232	48 6b c9 10	 imul	 rcx, rcx, 16
  00236	48 8d 8c 0c 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  0023e	44 8b c0	 mov	 r8d, eax
  00241	48 8b d1	 mov	 rdx, rcx
  00244	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  00249	e8 00 00 00 00	 call	 rijndael_set_key

; 3394 : 
; 3395 :   /* Try to process the CPU-determined amount of data */
; 3396 :   r1_is_not_r2 = r1 != r2;

  0024e	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00255	39 84 24 e0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0025c	74 0a		 je	 SHORT $LN27@s370_kmo_a
  0025e	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv195[rsp], 1
  00266	eb 08		 jmp	 SHORT $LN28@s370_kmo_a
$LN27@s370_kmo_a:
  00268	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv195[rsp], 0
$LN28@s370_kmo_a:
  00270	8b 44 24 54	 mov	 eax, DWORD PTR tv195[rsp]
  00274	89 44 24 68	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 3397 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00278	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00280	eb 0b		 jmp	 SHORT $LN4@s370_kmo_a
$LN2@s370_kmo_a:
  00282	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00286	83 c0 10	 add	 eax, 16
  00289	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s370_kmo_a:
  0028d	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00295	0f 8d 43 02 00
	00		 jge	 $LN3@s370_kmo_a

; 3398 :   {
; 3399 :     rijndael_encrypt(&context, parameter_block, parameter_block);

  0029b	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  002a3	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  002ab	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  002b0	e8 00 00 00 00	 call	 rijndael_encrypt

; 3400 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  002b5	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002bd	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002c5	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002cc	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002d1	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002d9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002de	44 8b 8c 24 e8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002e6	44 8b c0	 mov	 r8d, eax
  002e9	b2 0f		 mov	 dl, 15
  002eb	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002f3	e8 00 00 00 00	 call	 s370_vfetchc

; 3401 : 
; 3402 : #ifdef OPTION_KMO_DEBUG
; 3403 :     LOGBYTE("input :", message_block, 16);
; 3404 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3405 : 
; 3406 :     for(i = 0; i < 16; i++)

  002f8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00300	eb 0a		 jmp	 SHORT $LN7@s370_kmo_a
$LN5@s370_kmo_a:
  00302	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00306	ff c0		 inc	 eax
  00308	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_kmo_a:
  0030c	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  00311	7d 2a		 jge	 SHORT $LN6@s370_kmo_a

; 3407 :       message_block[i] ^= parameter_block[i];

  00313	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00318	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0031d	0f b6 8c 0c 70
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00325	0f b6 84 04 60
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0032d	33 c1		 xor	 eax, ecx
  0032f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00334	88 84 0c 60 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0033b	eb c5		 jmp	 SHORT $LN5@s370_kmo_a
$LN6@s370_kmo_a:

; 3408 : 
; 3409 :     /* Store the output */
; 3410 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0033d	48 63 84 24 e0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00345	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00354	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00359	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00361	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00366	44 8b 8c 24 e0
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0036e	44 8b c0	 mov	 r8d, eax
  00371	b2 0f		 mov	 dl, 15
  00373	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0037b	e8 00 00 00 00	 call	 s370_vstorec

; 3411 : 
; 3412 : #ifdef OPTION_KMO_DEBUG
; 3413 :     LOGBYTE("output:", message_block, 16);
; 3414 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3415 : 
; 3416 :     /* Store the chaining value */
; 3417 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00380	b8 08 00 00 00	 mov	 eax, 8
  00385	48 6b c0 01	 imul	 rax, rax, 1
  00389	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00391	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00398	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0039d	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a5	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003aa	41 b9 01 00 00
	00		 mov	 r9d, 1
  003b0	44 8b c0	 mov	 r8d, eax
  003b3	b2 0f		 mov	 dl, 15
  003b5	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  003bd	e8 00 00 00 00	 call	 s370_vstorec

; 3418 : 
; 3419 : #ifdef OPTION_KMO_DEBUG
; 3420 :     LOGBYTE("cv    :", parameter_block, 16);
; 3421 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3422 : 
; 3423 :     /* Update the registers */
; 3424 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  003c2	48 63 84 24 e0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  003ca	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003d9	83 c0 10	 add	 eax, 16
  003dc	48 63 8c 24 e0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  003e4	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003ec	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3425 :     if(likely(r1_is_not_r2))

  003f3	83 7c 24 68 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  003f8	74 0a		 je	 SHORT $LN29@s370_kmo_a
  003fa	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv260[rsp], 1
  00402	eb 08		 jmp	 SHORT $LN30@s370_kmo_a
$LN29@s370_kmo_a:
  00404	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv260[rsp], 0
$LN30@s370_kmo_a:
  0040c	83 7c 24 58 00	 cmp	 DWORD PTR tv260[rsp], 0
  00411	74 31		 je	 SHORT $LN12@s370_kmo_a

; 3426 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  00413	48 63 84 24 e8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0041b	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00423	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0042a	83 c0 10	 add	 eax, 16
  0042d	48 63 8c 24 e8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00435	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0043d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN12@s370_kmo_a:

; 3427 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00444	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0044b	ff c0		 inc	 eax
  0044d	48 98		 cdqe
  0044f	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00457	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0045e	83 e8 10	 sub	 eax, 16
  00461	8b 8c 24 e8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00468	ff c1		 inc	 ecx
  0046a	48 63 c9	 movsxd	 rcx, ecx
  0046d	48 8b 94 24 f0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00475	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3428 : 
; 3429 : #ifdef OPTION_KMO_DEBUG
; 3430 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3431 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3432 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3433 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3434 : 
; 3435 :     /* check for end of data */
; 3436 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0047c	8b 84 24 e8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00483	ff c0		 inc	 eax
  00485	48 98		 cdqe
  00487	48 8b 8c 24 f0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048f	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00497	75 0a		 jne	 SHORT $LN31@s370_kmo_a
  00499	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv293[rsp], 1
  004a1	eb 08		 jmp	 SHORT $LN32@s370_kmo_a
$LN31@s370_kmo_a:
  004a3	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv293[rsp], 0
$LN32@s370_kmo_a:
  004ab	83 7c 24 5c 00	 cmp	 DWORD PTR tv293[rsp], 0
  004b0	74 0a		 je	 SHORT $LN35@s370_kmo_a
  004b2	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv304[rsp], 1
  004ba	eb 08		 jmp	 SHORT $LN36@s370_kmo_a
$LN35@s370_kmo_a:
  004bc	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv304[rsp], 0
$LN36@s370_kmo_a:
  004c4	83 7c 24 60 00	 cmp	 DWORD PTR tv304[rsp], 0
  004c9	74 0e		 je	 SHORT $LN13@s370_kmo_a

; 3437 :     {
; 3438 :       regs->psw.cc = 0;

  004cb	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004d3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3439 :       return;

  004d7	eb 11		 jmp	 SHORT $LN1@s370_kmo_a
$LN13@s370_kmo_a:

; 3440 :     }
; 3441 :   }

  004d9	e9 a4 fd ff ff	 jmp	 $LN2@s370_kmo_a
$LN3@s370_kmo_a:

; 3442 : 
; 3443 :   /* CPU-determined amount of data processed */
; 3444 :   regs->psw.cc = 3;

  004de	48 8b 84 24 f0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  004e6	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmo_a:

; 3445 : }

  004ea	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004f2	48 33 cc	 xor	 rcx, rsp
  004f5	e8 00 00 00 00	 call	 __security_check_cookie
  004fa	48 81 c4 d8 02
	00 00		 add	 rsp, 728		; 000002d8H
  00501	c3		 ret	 0
s370_kmo_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv186 = 56
crypted$ = 60
tfc$ = 64
tv218 = 68
tv82 = 72
tv93 = 76
tv136 = 80
tv151 = 84
wrap$ = 88
keylen$ = 92
tv215 = 96
tv302 = 100
tv335 = 104
tv346 = 108
r1_is_not_r2$ = 112
context1$ = 128
context2$ = 272
context3$ = 416
message_block$ = 560
parameter_block$ = 568
__$ArrayPad$ = 624
r1$ = 656
r2$ = 664
regs$ = 672
s370_kmo_dea PROC

; 3157 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3158 :   des_context context1;
; 3159 :   des_context context2;
; 3160 :   des_context context3;
; 3161 :   int crypted;
; 3162 :   int i;
; 3163 :   int keylen;
; 3164 :   BYTE message_block[8];
; 3165 :   BYTE parameter_block[56];
; 3166 :   int parameter_blocklen;
; 3167 :   int r1_is_not_r2;
; 3168 :   int tfc;
; 3169 :   int wrap;
; 3170 : 
; 3171 :   /* Check special conditions */
; 3172 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 08 00 00 00	 mov	 ecx, 8
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN27@s370_kmo_d
  0004f	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN28@s370_kmo_d
$LN27@s370_kmo_d:
  00059	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN28@s370_kmo_d:
  00061	83 7c 24 48 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN12@s370_kmo_d

; 3173 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN12@s370_kmo_d:

; 3174 : 
; 3175 :   /* Return with cc 0 on zero length */
; 3176 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN29@s370_kmo_d
  00098	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN30@s370_kmo_d
$LN29@s370_kmo_d:
  000a2	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN30@s370_kmo_d:
  000aa	83 7c 24 4c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN33@s370_kmo_d
  000b1	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN34@s370_kmo_d
$LN33@s370_kmo_d:
  000bb	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN34@s370_kmo_d:
  000c3	83 7c 24 50 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN13@s370_kmo_d

; 3177 :   {
; 3178 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3179 :     return;

  000d6	e9 b0 05 00 00	 jmp	 $LN1@s370_kmo_d
$LN13@s370_kmo_d:

; 3180 :   }
; 3181 : 
; 3182 :   /* Initialize values */
; 3183 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 3184 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN35@s370_kmo_d
  0011c	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN36@s370_kmo_d
$LN35@s370_kmo_d:
  00126	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN36@s370_kmo_d:
  0012e	8b 44 24 54	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 58	 mov	 DWORD PTR wrap$[rsp], eax

; 3185 :   keylen = tfc * 8;

  00136	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	c1 e0 03	 shl	 eax, 3
  0013d	89 44 24 5c	 mov	 DWORD PTR keylen$[rsp], eax

; 3186 :   parameter_blocklen = keylen + 8;

  00141	8b 44 24 5c	 mov	 eax, DWORD PTR keylen$[rsp]
  00145	83 c0 08	 add	 eax, 8
  00148	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3187 :   if(wrap)

  0014c	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00151	74 0b		 je	 SHORT $LN14@s370_kmo_d

; 3188 :     parameter_blocklen += 24;

  00153	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00157	83 c0 18	 add	 eax, 24
  0015a	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN14@s370_kmo_d:

; 3189 : 
; 3190 :   /* Test writeability output chaining value */
; 3191 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  0015e	b8 08 00 00 00	 mov	 eax, 8
  00163	48 6b c0 01	 imul	 rax, rax, 1
  00167	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00176	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0017b	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00188	41 b9 02 00 00
	00		 mov	 r9d, 2
  0018e	41 b8 07 00 00
	00		 mov	 r8d, 7
  00194	ba 01 00 00 00	 mov	 edx, 1
  00199	8b c8		 mov	 ecx, eax
  0019b	e8 00 00 00 00	 call	 s370_validate_operand

; 3192 : 
; 3193 :   /* Fetch the parameter block */
; 3194 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001a0	b8 08 00 00 00	 mov	 eax, 8
  001a5	48 6b c0 01	 imul	 rax, rax, 1
  001a9	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001b8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001bd	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001c1	ff c9		 dec	 ecx
  001c3	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001cb	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  001d6	44 8b c0	 mov	 r8d, eax
  001d9	0f b6 d1	 movzx	 edx, cl
  001dc	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001e4	e8 00 00 00 00	 call	 s370_vfetchc

; 3195 : 
; 3196 : #ifdef OPTION_KMO_DEBUG
; 3197 :   LOGBYTE("cv    :", parameter_block, 8);
; 3198 :   switch(tfc)
; 3199 :   {
; 3200 :     case 1: /* dea */
; 3201 :     {
; 3202 :       LOGBYTE("k     :", &parameter_block[8], 8);
; 3203 :       break;
; 3204 :     }
; 3205 :     case 2: /* tdea-128 */
; 3206 :     {
; 3207 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 3208 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 3209 :       break;
; 3210 :     }
; 3211 :     case 3: /* tdea-192 */
; 3212 :     {
; 3213 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 3214 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 3215 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 3216 :       break;
; 3217 :     }
; 3218 :   }
; 3219 :   if(wrap)
; 3220 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 3221 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3222 : 
; 3223 :   /* Verify and unwrap */
; 3224 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  001e9	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001ee	74 32		 je	 SHORT $LN15@s370_kmo_d
  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	48 6b c0 08	 imul	 rax, rax, 8
  001f9	48 8d 84 04 38
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00201	8b 54 24 5c	 mov	 edx, DWORD PTR keylen$[rsp]
  00205	48 8b c8	 mov	 rcx, rax
  00208	e8 00 00 00 00	 call	 unwrap_dea
  0020d	85 c0		 test	 eax, eax
  0020f	74 11		 je	 SHORT $LN15@s370_kmo_d

; 3225 :   {
; 3226 : 
; 3227 : #ifdef OPTION_KMO_DEBUG
; 3228 :     WRMSG(HHC90111, "D");
; 3229 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3230 : 
; 3231 :     regs->psw.cc = 1;

  00211	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3232 :     return;

  0021d	e9 69 04 00 00	 jmp	 $LN1@s370_kmo_d
$LN15@s370_kmo_d:

; 3233 :   }
; 3234 : 
; 3235 :   /* Set the cryptographic key */
; 3236 :   switch(tfc)

  00222	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00226	89 44 24 38	 mov	 DWORD PTR tv186[rsp], eax
  0022a	83 7c 24 38 01	 cmp	 DWORD PTR tv186[rsp], 1
  0022f	74 13		 je	 SHORT $LN16@s370_kmo_d
  00231	83 7c 24 38 02	 cmp	 DWORD PTR tv186[rsp], 2
  00236	74 32		 je	 SHORT $LN17@s370_kmo_d
  00238	83 7c 24 38 03	 cmp	 DWORD PTR tv186[rsp], 3
  0023d	74 6f		 je	 SHORT $LN18@s370_kmo_d
  0023f	e9 cd 00 00 00	 jmp	 $LN2@s370_kmo_d
$LN16@s370_kmo_d:

; 3237 :   {
; 3238 :     case 1: /* dea */
; 3239 :     {
; 3240 :       des_set_key(&context1, &parameter_block[8]);

  00244	b8 01 00 00 00	 mov	 eax, 1
  00249	48 6b c0 08	 imul	 rax, rax, 8
  0024d	48 8d 84 04 38
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00255	48 8b d0	 mov	 rdx, rax
  00258	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00260	e8 00 00 00 00	 call	 des_set_key

; 3241 :       break;

  00265	e9 a7 00 00 00	 jmp	 $LN2@s370_kmo_d
$LN17@s370_kmo_d:

; 3242 :     }
; 3243 :     case 2: /* tdea-128 */
; 3244 :     {
; 3245 :       des_set_key(&context1, &parameter_block[8]);

  0026a	b8 01 00 00 00	 mov	 eax, 1
  0026f	48 6b c0 08	 imul	 rax, rax, 8
  00273	48 8d 84 04 38
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0027b	48 8b d0	 mov	 rdx, rax
  0027e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00286	e8 00 00 00 00	 call	 des_set_key

; 3246 :       des_set_key(&context2, &parameter_block[16]);

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	48 6b c0 10	 imul	 rax, rax, 16
  00294	48 8d 84 04 38
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0029c	48 8b d0	 mov	 rdx, rax
  0029f	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002a7	e8 00 00 00 00	 call	 des_set_key

; 3247 :       break;

  002ac	eb 63		 jmp	 SHORT $LN2@s370_kmo_d
$LN18@s370_kmo_d:

; 3248 :     }
; 3249 :     case 3: /* tdea-192 */
; 3250 :     {
; 3251 :       des_set_key(&context1, &parameter_block[8]);

  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	48 6b c0 08	 imul	 rax, rax, 8
  002b7	48 8d 84 04 38
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002bf	48 8b d0	 mov	 rdx, rax
  002c2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002ca	e8 00 00 00 00	 call	 des_set_key

; 3252 :       des_set_key(&context2, &parameter_block[16]);

  002cf	b8 01 00 00 00	 mov	 eax, 1
  002d4	48 6b c0 10	 imul	 rax, rax, 16
  002d8	48 8d 84 04 38
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002e0	48 8b d0	 mov	 rdx, rax
  002e3	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002eb	e8 00 00 00 00	 call	 des_set_key

; 3253 :       des_set_key(&context3, &parameter_block[24]);

  002f0	b8 01 00 00 00	 mov	 eax, 1
  002f5	48 6b c0 18	 imul	 rax, rax, 24
  002f9	48 8d 84 04 38
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00301	48 8b d0	 mov	 rdx, rax
  00304	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0030c	e8 00 00 00 00	 call	 des_set_key
$LN2@s370_kmo_d:

; 3254 :       break;
; 3255 :     }
; 3256 :   }
; 3257 : 
; 3258 :   /* Try to process the CPU-determined amount of data */
; 3259 :   r1_is_not_r2 = r1 != r2;

  00311	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00318	39 84 24 90 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0031f	74 0a		 je	 SHORT $LN37@s370_kmo_d
  00321	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv215[rsp], 1
  00329	eb 08		 jmp	 SHORT $LN38@s370_kmo_d
$LN37@s370_kmo_d:
  0032b	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv215[rsp], 0
$LN38@s370_kmo_d:
  00333	8b 44 24 60	 mov	 eax, DWORD PTR tv215[rsp]
  00337	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 3260 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  0033b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00343	eb 0b		 jmp	 SHORT $LN6@s370_kmo_d
$LN4@s370_kmo_d:
  00345	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00349	83 c0 08	 add	 eax, 8
  0034c	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@s370_kmo_d:
  00350	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00358	0f 8d 21 03 00
	00		 jge	 $LN5@s370_kmo_d

; 3261 :   {
; 3262 :     /* Do the job */
; 3263 :     switch(tfc)

  0035e	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00362	89 44 24 44	 mov	 DWORD PTR tv218[rsp], eax
  00366	83 7c 24 44 01	 cmp	 DWORD PTR tv218[rsp], 1
  0036b	74 17		 je	 SHORT $LN19@s370_kmo_d
  0036d	83 7c 24 44 02	 cmp	 DWORD PTR tv218[rsp], 2
  00372	74 32		 je	 SHORT $LN20@s370_kmo_d
  00374	83 7c 24 44 03	 cmp	 DWORD PTR tv218[rsp], 3
  00379	0f 84 80 00 00
	00		 je	 $LN21@s370_kmo_d
  0037f	e9 d2 00 00 00	 jmp	 $LN7@s370_kmo_d
$LN19@s370_kmo_d:

; 3264 :     {
; 3265 :       case 1: /* dea */
; 3266 :       {
; 3267 :         des_encrypt(&context1, parameter_block, parameter_block);

  00384	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0038c	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00394	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0039c	e8 00 00 00 00	 call	 des_encrypt

; 3268 :         break;

  003a1	e9 b0 00 00 00	 jmp	 $LN7@s370_kmo_d
$LN20@s370_kmo_d:

; 3269 :       }
; 3270 :       case 2: /* tdea-128 */
; 3271 :       {
; 3272 :         des_encrypt(&context1, parameter_block, parameter_block);

  003a6	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  003ae	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  003b6	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003be	e8 00 00 00 00	 call	 des_encrypt

; 3273 :         des_decrypt(&context2, parameter_block, parameter_block);

  003c3	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  003cb	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  003d3	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  003db	e8 00 00 00 00	 call	 des_decrypt

; 3274 :         des_encrypt(&context1, parameter_block, parameter_block);

  003e0	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  003e8	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  003f0	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  003f8	e8 00 00 00 00	 call	 des_encrypt

; 3275 :         break;

  003fd	eb 57		 jmp	 SHORT $LN7@s370_kmo_d
$LN21@s370_kmo_d:

; 3276 :       }
; 3277 :       case 3: /* tdea-192 */
; 3278 :       {
; 3279 :         des_encrypt(&context1, parameter_block, parameter_block);

  003ff	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00407	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0040f	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00417	e8 00 00 00 00	 call	 des_encrypt

; 3280 :         des_decrypt(&context2, parameter_block, parameter_block);

  0041c	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00424	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0042c	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00434	e8 00 00 00 00	 call	 des_decrypt

; 3281 :         des_encrypt(&context3, parameter_block, parameter_block);

  00439	4c 8d 84 24 38
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00441	48 8d 94 24 38
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00449	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00451	e8 00 00 00 00	 call	 des_encrypt
$LN7@s370_kmo_d:

; 3282 :         break;
; 3283 :       }
; 3284 :     }
; 3285 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00456	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0045e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00466	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0046d	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00472	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0047f	44 8b 8c 24 98
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00487	44 8b c0	 mov	 r8d, eax
  0048a	b2 07		 mov	 dl, 7
  0048c	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00494	e8 00 00 00 00	 call	 s370_vfetchc

; 3286 : 
; 3287 : #ifdef OPTION_KMO_DEBUG
; 3288 :     LOGBYTE("input :", message_block, 8);
; 3289 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3290 : 
; 3291 :     for(i = 0; i < 8; i++)

  00499	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004a1	eb 0a		 jmp	 SHORT $LN11@s370_kmo_d
$LN9@s370_kmo_d:
  004a3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004a7	ff c0		 inc	 eax
  004a9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@s370_kmo_d:
  004ad	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  004b2	7d 2a		 jge	 SHORT $LN10@s370_kmo_d

; 3292 :       message_block[i] ^= parameter_block[i];

  004b4	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004b9	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004be	0f b6 8c 0c 38
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  004c6	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  004ce	33 c1		 xor	 eax, ecx
  004d0	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004d5	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  004dc	eb c5		 jmp	 SHORT $LN9@s370_kmo_d
$LN10@s370_kmo_d:

; 3293 : 
; 3294 :     /* Store the output */
; 3295 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  004de	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004e6	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ee	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004f5	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  004fa	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00502	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00507	44 8b 8c 24 90
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0050f	44 8b c0	 mov	 r8d, eax
  00512	b2 07		 mov	 dl, 7
  00514	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0051c	e8 00 00 00 00	 call	 s370_vstorec

; 3296 : 
; 3297 : #ifdef OPTION_KMO_DEBUG
; 3298 :     LOGBYTE("output:", message_block, 8);
; 3299 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3300 : 
; 3301 :     /* Store the chaining value */
; 3302 :     ARCH_DEP(vstorec)(parameter_block, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00521	b8 08 00 00 00	 mov	 eax, 8
  00526	48 6b c0 01	 imul	 rax, rax, 1
  0052a	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00532	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00539	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0053e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00546	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0054b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00551	44 8b c0	 mov	 r8d, eax
  00554	b2 07		 mov	 dl, 7
  00556	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0055e	e8 00 00 00 00	 call	 s370_vstorec

; 3303 : 
; 3304 : #ifdef OPTION_KMO_DEBUG
; 3305 :     LOGBYTE("cv    :", parameter_block, 8);
; 3306 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3307 : 
; 3308 :     /* Update the registers */
; 3309 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  00563	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0056b	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00573	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0057a	83 c0 08	 add	 eax, 8
  0057d	48 63 8c 24 90
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00585	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0058d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3310 :     if(likely(r1_is_not_r2))

  00594	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00599	74 0a		 je	 SHORT $LN39@s370_kmo_d
  0059b	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv302[rsp], 1
  005a3	eb 08		 jmp	 SHORT $LN40@s370_kmo_d
$LN39@s370_kmo_d:
  005a5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv302[rsp], 0
$LN40@s370_kmo_d:
  005ad	83 7c 24 64 00	 cmp	 DWORD PTR tv302[rsp], 0
  005b2	74 31		 je	 SHORT $LN22@s370_kmo_d

; 3311 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  005b4	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005bc	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005c4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005cb	83 c0 08	 add	 eax, 8
  005ce	48 63 8c 24 98
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  005d6	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005de	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN22@s370_kmo_d:

; 3312 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  005e5	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  005ec	ff c0		 inc	 eax
  005ee	48 98		 cdqe
  005f0	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005f8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005ff	83 e8 08	 sub	 eax, 8
  00602	8b 8c 24 98 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00609	ff c1		 inc	 ecx
  0060b	48 63 c9	 movsxd	 rcx, ecx
  0060e	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00616	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3313 : 
; 3314 : #ifdef OPTION_KMO_DEBUG
; 3315 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3316 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3317 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3318 : #endif /* #ifdef OPTION_KMO_DEBUG */
; 3319 : 
; 3320 :     /* check for end of data */
; 3321 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0061d	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00624	ff c0		 inc	 eax
  00626	48 98		 cdqe
  00628	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00630	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00638	75 0a		 jne	 SHORT $LN41@s370_kmo_d
  0063a	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv335[rsp], 1
  00642	eb 08		 jmp	 SHORT $LN42@s370_kmo_d
$LN41@s370_kmo_d:
  00644	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv335[rsp], 0
$LN42@s370_kmo_d:
  0064c	83 7c 24 68 00	 cmp	 DWORD PTR tv335[rsp], 0
  00651	74 0a		 je	 SHORT $LN45@s370_kmo_d
  00653	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv346[rsp], 1
  0065b	eb 08		 jmp	 SHORT $LN46@s370_kmo_d
$LN45@s370_kmo_d:
  0065d	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv346[rsp], 0
$LN46@s370_kmo_d:
  00665	83 7c 24 6c 00	 cmp	 DWORD PTR tv346[rsp], 0
  0066a	74 0e		 je	 SHORT $LN23@s370_kmo_d

; 3322 :     {
; 3323 :       regs->psw.cc = 0;

  0066c	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00674	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3324 :       return;

  00678	eb 11		 jmp	 SHORT $LN1@s370_kmo_d
$LN23@s370_kmo_d:

; 3325 :     }
; 3326 :   }

  0067a	e9 c6 fc ff ff	 jmp	 $LN4@s370_kmo_d
$LN5@s370_kmo_d:

; 3327 : 
; 3328 :   /* CPU-determined amount of data processed */
; 3329 :   regs->psw.cc = 3;

  0067f	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00687	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmo_d:

; 3330 : }

  0068b	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00693	48 33 cc	 xor	 rcx, rsp
  00696	e8 00 00 00 00	 call	 __security_check_cookie
  0069b	48 81 c4 88 02
	00 00		 add	 rsp, 648		; 00000288H
  006a2	c3		 ret	 0
s370_kmo_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
lcfb$ = 52
parameter_blocklen$ = 56
keylen$ = 60
crypted$ = 64
tv93 = 68
tv136 = 72
tv147 = 76
tv162 = 80
wrap$ = 84
tv211 = 88
tv213 = 92
tv313 = 96
tv346 = 100
tv357 = 104
tfc$ = 108
modifier_bit$ = 112
r1_is_not_r2$ = 116
context$ = 128
output_block$ = 624
message_block$ = 640
parameter_block$ = 656
__$ArrayPad$ = 736
r1$ = 768
r2$ = 776
regs$ = 784
s370_kmf_aes PROC

; 3021 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3022 :   rijndael_ctx context;
; 3023 :   int crypted;
; 3024 :   int i;
; 3025 :   int keylen;
; 3026 :   int lcfb;
; 3027 :   BYTE message_block[16];
; 3028 :   int modifier_bit;
; 3029 :   BYTE output_block[16];
; 3030 :   BYTE parameter_block[80];
; 3031 :   int parameter_blocklen;
; 3032 :   int r1_is_not_r2;
; 3033 :   int tfc;
; 3034 :   int wrap;
; 3035 : 
; 3036 :   /* Initialize values */
; 3037 :   lcfb = GR0_lcfb(regs);

  00026	b8 08 00 00 00	 mov	 eax, 8
  0002b	48 6b c0 00	 imul	 rax, rax, 0
  0002f	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0003e	c1 e8 18	 shr	 eax, 24
  00041	89 44 24 34	 mov	 DWORD PTR lcfb$[rsp], eax

; 3038 : 
; 3039 :   /* Check special conditions */
; 3040 :   if(unlikely(GR_A(r2 + 1, regs) % lcfb || !lcfb || lcfb > 16))

  00045	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0004c	ff c0		 inc	 eax
  0004e	48 98		 cdqe
  00050	33 d2		 xor	 edx, edx
  00052	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0005a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00061	f7 74 24 34	 div	 DWORD PTR lcfb$[rsp]
  00065	8b c2		 mov	 eax, edx
  00067	85 c0		 test	 eax, eax
  00069	75 18		 jne	 SHORT $LN26@s370_kmf_a
  0006b	83 7c 24 34 00	 cmp	 DWORD PTR lcfb$[rsp], 0
  00070	74 11		 je	 SHORT $LN26@s370_kmf_a
  00072	83 7c 24 34 10	 cmp	 DWORD PTR lcfb$[rsp], 16
  00077	7f 0a		 jg	 SHORT $LN26@s370_kmf_a
  00079	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
  00081	eb 08		 jmp	 SHORT $LN29@s370_kmf_a
$LN26@s370_kmf_a:
  00083	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
$LN29@s370_kmf_a:
  0008b	83 7c 24 44 00	 cmp	 DWORD PTR tv93[rsp], 0
  00090	74 13		 je	 SHORT $LN17@s370_kmf_a

; 3041 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00092	ba 06 00 00 00	 mov	 edx, 6
  00097	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN17@s370_kmf_a:

; 3042 : 
; 3043 :   /* Return with cc 0 on zero length */
; 3044 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000a5	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000ac	ff c0		 inc	 eax
  000ae	48 98		 cdqe
  000b0	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c0	75 0a		 jne	 SHORT $LN30@s370_kmf_a
  000c2	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000ca	eb 08		 jmp	 SHORT $LN31@s370_kmf_a
$LN30@s370_kmf_a:
  000cc	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN31@s370_kmf_a:
  000d4	83 7c 24 48 00	 cmp	 DWORD PTR tv136[rsp], 0
  000d9	74 0a		 je	 SHORT $LN34@s370_kmf_a
  000db	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  000e3	eb 08		 jmp	 SHORT $LN35@s370_kmf_a
$LN34@s370_kmf_a:
  000e5	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN35@s370_kmf_a:
  000ed	83 7c 24 4c 00	 cmp	 DWORD PTR tv147[rsp], 0
  000f2	74 11		 je	 SHORT $LN18@s370_kmf_a

; 3045 :   {
; 3046 :     regs->psw.cc = 0;

  000f4	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3047 :     return;

  00100	e9 3f 05 00 00	 jmp	 $LN1@s370_kmf_a
$LN18@s370_kmf_a:

; 3048 :   }
; 3049 : 
; 3050 :   /* Initialize values */
; 3051 :   tfc = GR0_tfc(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 00	 imul	 rax, rax, 0
  0010e	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00120	83 e0 77	 and	 eax, 119		; 00000077H
  00123	89 44 24 6c	 mov	 DWORD PTR tfc$[rsp], eax

; 3052 :   wrap = GR0_wrap(regs);

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 00	 imul	 rax, rax, 0
  00130	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0013f	83 e0 08	 and	 eax, 8
  00142	85 c0		 test	 eax, eax
  00144	74 0a		 je	 SHORT $LN36@s370_kmf_a
  00146	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  0014e	eb 08		 jmp	 SHORT $LN37@s370_kmf_a
$LN36@s370_kmf_a:
  00150	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN37@s370_kmf_a:
  00158	8b 44 24 50	 mov	 eax, DWORD PTR tv162[rsp]
  0015c	89 44 24 54	 mov	 DWORD PTR wrap$[rsp], eax

; 3053 :   keylen = (tfc - 17) * 8 + 8;

  00160	8b 44 24 6c	 mov	 eax, DWORD PTR tfc$[rsp]
  00164	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  0016b	89 44 24 3c	 mov	 DWORD PTR keylen$[rsp], eax

; 3054 :   parameter_blocklen = keylen + 16;

  0016f	8b 44 24 3c	 mov	 eax, DWORD PTR keylen$[rsp]
  00173	83 c0 10	 add	 eax, 16
  00176	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 3055 :   if(wrap)

  0017a	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0017f	74 0b		 je	 SHORT $LN19@s370_kmf_a

; 3056 :     parameter_blocklen += 32;

  00181	8b 44 24 38	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00185	83 c0 20	 add	 eax, 32			; 00000020H
  00188	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN19@s370_kmf_a:

; 3057 : 
; 3058 :   /* Test writeability output chaining value */
; 3059 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  0018c	b8 08 00 00 00	 mov	 eax, 8
  00191	48 6b c0 01	 imul	 rax, rax, 1
  00195	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0019d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001a9	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001b6	41 b9 02 00 00
	00		 mov	 r9d, 2
  001bc	41 b8 0f 00 00
	00		 mov	 r8d, 15
  001c2	ba 01 00 00 00	 mov	 edx, 1
  001c7	8b c8		 mov	 ecx, eax
  001c9	e8 00 00 00 00	 call	 s370_validate_operand

; 3060 : 
; 3061 :   /* Fetch the parameter block */
; 3062 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001ce	b8 08 00 00 00	 mov	 eax, 8
  001d3	48 6b c0 01	 imul	 rax, rax, 1
  001d7	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001df	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001eb	8b 4c 24 38	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001ef	ff c9		 dec	 ecx
  001f1	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f9	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001fe	41 b9 01 00 00
	00		 mov	 r9d, 1
  00204	44 8b c0	 mov	 r8d, eax
  00207	0f b6 d1	 movzx	 edx, cl
  0020a	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00212	e8 00 00 00 00	 call	 s370_vfetchc

; 3063 : 
; 3064 : #ifdef OPTION_KMF_DEBUG
; 3065 :   LOGBYTE("cv    :", parameter_block, 16);
; 3066 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 3067 :   if(wrap)
; 3068 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 32], 32);
; 3069 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3070 : 
; 3071 :   /* Verify and unwrap */
; 3072 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  00217	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0021c	74 32		 je	 SHORT $LN20@s370_kmf_a
  0021e	b8 01 00 00 00	 mov	 eax, 1
  00223	48 6b c0 10	 imul	 rax, rax, 16
  00227	48 8d 84 04 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0022f	8b 54 24 3c	 mov	 edx, DWORD PTR keylen$[rsp]
  00233	48 8b c8	 mov	 rcx, rax
  00236	e8 00 00 00 00	 call	 unwrap_aes
  0023b	85 c0		 test	 eax, eax
  0023d	74 11		 je	 SHORT $LN20@s370_kmf_a

; 3073 :   {
; 3074 : 
; 3075 : #ifdef OPTION_KMF_DEBUG
; 3076 :     WRMSG(HHC90111, "D");
; 3077 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3078 : 
; 3079 :     regs->psw.cc = 1;

  0023f	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00247	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 3080 :     return;

  0024b	e9 f4 03 00 00	 jmp	 $LN1@s370_kmf_a
$LN20@s370_kmf_a:

; 3081 :   }
; 3082 : 
; 3083 :   /* Set the cryptographic key */
; 3084 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  00250	8b 44 24 3c	 mov	 eax, DWORD PTR keylen$[rsp]
  00254	c1 e0 03	 shl	 eax, 3
  00257	b9 01 00 00 00	 mov	 ecx, 1
  0025c	48 6b c9 10	 imul	 rcx, rcx, 16
  00260	48 8d 8c 0c 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00268	44 8b c0	 mov	 r8d, eax
  0026b	48 8b d1	 mov	 rdx, rcx
  0026e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00276	e8 00 00 00 00	 call	 rijndael_set_key

; 3085 : 
; 3086 :   /* Try to process the CPU-determined amount of data */
; 3087 :   modifier_bit = GR0_m(regs);

  0027b	b8 08 00 00 00	 mov	 eax, 8
  00280	48 6b c0 00	 imul	 rax, rax, 0
  00284	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0028c	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00293	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00298	85 c0		 test	 eax, eax
  0029a	74 0a		 je	 SHORT $LN38@s370_kmf_a
  0029c	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv211[rsp], 1
  002a4	eb 08		 jmp	 SHORT $LN39@s370_kmf_a
$LN38@s370_kmf_a:
  002a6	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv211[rsp], 0
$LN39@s370_kmf_a:
  002ae	8b 44 24 58	 mov	 eax, DWORD PTR tv211[rsp]
  002b2	89 44 24 70	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 3088 :   r1_is_not_r2 = r1 != r2;

  002b6	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002bd	39 84 24 00 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002c4	74 0a		 je	 SHORT $LN40@s370_kmf_a
  002c6	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv213[rsp], 1
  002ce	eb 08		 jmp	 SHORT $LN41@s370_kmf_a
$LN40@s370_kmf_a:
  002d0	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv213[rsp], 0
$LN41@s370_kmf_a:
  002d8	8b 44 24 5c	 mov	 eax, DWORD PTR tv213[rsp]
  002dc	89 44 24 74	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 3089 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += lcfb)

  002e0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  002e8	eb 10		 jmp	 SHORT $LN4@s370_kmf_a
$LN2@s370_kmf_a:
  002ea	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  002ee	8b 4c 24 40	 mov	 ecx, DWORD PTR crypted$[rsp]
  002f2	03 c8		 add	 ecx, eax
  002f4	8b c1		 mov	 eax, ecx
  002f6	89 44 24 40	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s370_kmf_a:
  002fa	81 7c 24 40 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00302	0f 8d 30 03 00
	00		 jge	 $LN3@s370_kmf_a

; 3090 :   {
; 3091 :     rijndael_encrypt(&context, parameter_block, output_block);

  00308	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00310	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00318	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00320	e8 00 00 00 00	 call	 rijndael_encrypt

; 3092 :     ARCH_DEP(vfetchc)(message_block, lcfb - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00325	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0032d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00335	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0033c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00341	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  00345	ff c9		 dec	 ecx
  00347	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0034f	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00354	44 8b 8c 24 08
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0035c	44 8b c0	 mov	 r8d, eax
  0035f	0f b6 d1	 movzx	 edx, cl
  00362	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0036a	e8 00 00 00 00	 call	 s370_vfetchc

; 3093 : 
; 3094 : #ifdef OPTION_KMF_DEBUG
; 3095 :     LOGBYTE("input :", message_block, lcfb);
; 3096 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3097 : 
; 3098 :     for(i = 0; i < lcfb; i++)

  0036f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00377	eb 0a		 jmp	 SHORT $LN7@s370_kmf_a
$LN5@s370_kmf_a:
  00379	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0037d	ff c0		 inc	 eax
  0037f	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_kmf_a:
  00383	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00387	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0038b	7d 2a		 jge	 SHORT $LN6@s370_kmf_a

; 3099 :       output_block[i] ^= message_block[i];

  0038d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00392	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00397	0f b6 8c 0c 80
	02 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  0039f	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  003a7	33 c1		 xor	 eax, ecx
  003a9	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003ae	88 84 0c 70 02
	00 00		 mov	 BYTE PTR output_block$[rsp+rcx], al
  003b5	eb c2		 jmp	 SHORT $LN5@s370_kmf_a
$LN6@s370_kmf_a:

; 3100 :     for(i = 0; i < 16 - lcfb; i++)

  003b7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003bf	eb 0a		 jmp	 SHORT $LN10@s370_kmf_a
$LN8@s370_kmf_a:
  003c1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003c5	ff c0		 inc	 eax
  003c7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_kmf_a:
  003cb	b8 10 00 00 00	 mov	 eax, 16
  003d0	2b 44 24 34	 sub	 eax, DWORD PTR lcfb$[rsp]
  003d4	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  003d8	7d 24		 jge	 SHORT $LN9@s370_kmf_a

; 3101 :       parameter_block[i] = parameter_block[i + lcfb];

  003da	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  003de	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  003e2	03 c8		 add	 ecx, eax
  003e4	8b c1		 mov	 eax, ecx
  003e6	48 98		 cdqe
  003e8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003ed	0f b6 84 04 90
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  003f5	88 84 0c 90 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  003fc	eb c3		 jmp	 SHORT $LN8@s370_kmf_a
$LN9@s370_kmf_a:

; 3102 :     if(modifier_bit)

  003fe	83 7c 24 70 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  00403	74 44		 je	 SHORT $LN21@s370_kmf_a

; 3103 :     {
; 3104 :       /* Decipher */
; 3105 :       for(i = 0; i < lcfb; i++)

  00405	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0040d	eb 0a		 jmp	 SHORT $LN13@s370_kmf_a
$LN11@s370_kmf_a:
  0040f	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00413	ff c0		 inc	 eax
  00415	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@s370_kmf_a:
  00419	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  0041d	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00421	7d 24		 jge	 SHORT $LN12@s370_kmf_a

; 3106 :         parameter_block[i + 16 - lcfb] = message_block[i];

  00423	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00428	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0042c	83 c1 10	 add	 ecx, 16
  0042f	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  00433	48 63 c9	 movsxd	 rcx, ecx
  00436	0f b6 84 04 80
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0043e	88 84 0c 90 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  00445	eb c8		 jmp	 SHORT $LN11@s370_kmf_a
$LN12@s370_kmf_a:

; 3107 :     }

  00447	eb 42		 jmp	 SHORT $LN22@s370_kmf_a
$LN21@s370_kmf_a:

; 3108 :     else
; 3109 :     {
; 3110 :       /* Encipher */
; 3111 :       for(i = 0; i < lcfb; i++)

  00449	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00451	eb 0a		 jmp	 SHORT $LN16@s370_kmf_a
$LN14@s370_kmf_a:
  00453	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00457	ff c0		 inc	 eax
  00459	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@s370_kmf_a:
  0045d	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00461	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00465	7d 24		 jge	 SHORT $LN15@s370_kmf_a

; 3112 :         parameter_block[i + 16 - lcfb] = output_block[i];

  00467	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0046c	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00470	83 c1 10	 add	 ecx, 16
  00473	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  00477	48 63 c9	 movsxd	 rcx, ecx
  0047a	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  00482	88 84 0c 90 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  00489	eb c8		 jmp	 SHORT $LN14@s370_kmf_a
$LN15@s370_kmf_a:
$LN22@s370_kmf_a:

; 3113 :     }
; 3114 : 
; 3115 :     /* Store the output */
; 3116 :     ARCH_DEP(vstorec)(output_block, lcfb - 1, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0048b	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00493	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0049b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004a2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  004a7	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  004ab	ff c9		 dec	 ecx
  004ad	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004b5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  004ba	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  004c2	44 8b c0	 mov	 r8d, eax
  004c5	0f b6 d1	 movzx	 edx, cl
  004c8	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR output_block$[rsp]
  004d0	e8 00 00 00 00	 call	 s370_vstorec

; 3117 : 
; 3118 : #ifdef OPTION_KMF_DEBUG
; 3119 :     LOGBYTE("output:", output_block, lcfb);
; 3120 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3121 : 
; 3122 :     /* Store the chaining value */
; 3123 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  004d5	b8 08 00 00 00	 mov	 eax, 8
  004da	48 6b c0 01	 imul	 rax, rax, 1
  004de	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e6	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004ed	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  004f2	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004fa	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004ff	41 b9 01 00 00
	00		 mov	 r9d, 1
  00505	44 8b c0	 mov	 r8d, eax
  00508	b2 0f		 mov	 dl, 15
  0050a	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00512	e8 00 00 00 00	 call	 s370_vstorec

; 3124 : 
; 3125 : #ifdef OPTION_KMF_DEBUG
; 3126 :     LOGBYTE("cv    :", parameter_block, 16);
; 3127 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3128 : 
; 3129 :     /* Update the registers */
; 3130 :     SET_GR_A(r1, regs, GR_A(r1, regs) + lcfb);

  00517	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0051f	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00527	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0052e	03 44 24 34	 add	 eax, DWORD PTR lcfb$[rsp]
  00532	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0053a	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00542	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3131 :     if(likely(r1_is_not_r2))

  00549	83 7c 24 74 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  0054e	74 0a		 je	 SHORT $LN42@s370_kmf_a
  00550	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv313[rsp], 1
  00558	eb 08		 jmp	 SHORT $LN43@s370_kmf_a
$LN42@s370_kmf_a:
  0055a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv313[rsp], 0
$LN43@s370_kmf_a:
  00562	83 7c 24 60 00	 cmp	 DWORD PTR tv313[rsp], 0
  00567	74 32		 je	 SHORT $LN23@s370_kmf_a

; 3132 :       SET_GR_A(r2, regs, GR_A(r2, regs) + lcfb);

  00569	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00571	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00579	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00580	03 44 24 34	 add	 eax, DWORD PTR lcfb$[rsp]
  00584	48 63 8c 24 08
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0058c	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00594	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN23@s370_kmf_a:

; 3133 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - lcfb);

  0059b	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  005a2	ff c0		 inc	 eax
  005a4	48 98		 cdqe
  005a6	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005ae	8b 54 24 34	 mov	 edx, DWORD PTR lcfb$[rsp]
  005b2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005b9	2b c2		 sub	 eax, edx
  005bb	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005c2	ff c1		 inc	 ecx
  005c4	48 63 c9	 movsxd	 rcx, ecx
  005c7	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005cf	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 3134 : 
; 3135 : #ifdef OPTION_KMF_DEBUG
; 3136 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3137 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3138 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3139 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3140 : 
; 3141 :     /* check for end of data */
; 3142 :     if(unlikely(!GR_A(r2 + 1, regs)))

  005d6	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  005dd	ff c0		 inc	 eax
  005df	48 98		 cdqe
  005e1	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e9	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  005f1	75 0a		 jne	 SHORT $LN44@s370_kmf_a
  005f3	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv346[rsp], 1
  005fb	eb 08		 jmp	 SHORT $LN45@s370_kmf_a
$LN44@s370_kmf_a:
  005fd	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv346[rsp], 0
$LN45@s370_kmf_a:
  00605	83 7c 24 64 00	 cmp	 DWORD PTR tv346[rsp], 0
  0060a	74 0a		 je	 SHORT $LN48@s370_kmf_a
  0060c	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv357[rsp], 1
  00614	eb 08		 jmp	 SHORT $LN49@s370_kmf_a
$LN48@s370_kmf_a:
  00616	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv357[rsp], 0
$LN49@s370_kmf_a:
  0061e	83 7c 24 68 00	 cmp	 DWORD PTR tv357[rsp], 0
  00623	74 0e		 je	 SHORT $LN24@s370_kmf_a

; 3143 :     {
; 3144 :       regs->psw.cc = 0;

  00625	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0062d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3145 :       return;

  00631	eb 11		 jmp	 SHORT $LN1@s370_kmf_a
$LN24@s370_kmf_a:

; 3146 :     }
; 3147 :   }

  00633	e9 b2 fc ff ff	 jmp	 $LN2@s370_kmf_a
$LN3@s370_kmf_a:

; 3148 : 
; 3149 :   /* CPU-determined amount of data processed */
; 3150 :   regs->psw.cc = 3;

  00638	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00640	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmf_a:

; 3151 : }

  00644	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0064c	48 33 cc	 xor	 rcx, rsp
  0064f	e8 00 00 00 00	 call	 __security_check_cookie
  00654	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  0065b	c3		 ret	 0
s370_kmf_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
lcfb$ = 52
parameter_blocklen$ = 56
tv197 = 60
crypted$ = 64
tfc$ = 68
tv236 = 72
tv93 = 76
tv136 = 80
tv147 = 84
tv162 = 88
wrap$ = 92
keylen$ = 96
tv231 = 100
tv233 = 104
tv355 = 108
tv388 = 112
tv399 = 116
modifier_bit$ = 120
r1_is_not_r2$ = 124
context1$ = 128
context2$ = 272
context3$ = 416
output_block$ = 560
message_block$ = 568
parameter_block$ = 576
__$ArrayPad$ = 632
r1$ = 656
r2$ = 664
regs$ = 672
s370_kmf_dea PROC

; 2821 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2822 :   des_context context1;
; 2823 :   des_context context2;
; 2824 :   des_context context3;
; 2825 :   int crypted;
; 2826 :   int i;
; 2827 :   int keylen;
; 2828 :   int lcfb;
; 2829 :   BYTE message_block[8];
; 2830 :   int modifier_bit;
; 2831 :   BYTE output_block[8];
; 2832 :   BYTE parameter_block[56];
; 2833 :   int parameter_blocklen;
; 2834 :   int r1_is_not_r2;
; 2835 :   int tfc;
; 2836 :   int wrap;
; 2837 : 
; 2838 :   /* Initialize values */
; 2839 :   lcfb = GR0_lcfb(regs);

  00026	b8 08 00 00 00	 mov	 eax, 8
  0002b	48 6b c0 00	 imul	 rax, rax, 0
  0002f	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00037	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0003e	c1 e8 18	 shr	 eax, 24
  00041	89 44 24 34	 mov	 DWORD PTR lcfb$[rsp], eax

; 2840 : 
; 2841 :   /* Check special conditions */
; 2842 :   if(unlikely(!lcfb || lcfb > 8 || GR_A(r2 + 1, regs) % lcfb))

  00045	83 7c 24 34 00	 cmp	 DWORD PTR lcfb$[rsp], 0
  0004a	74 37		 je	 SHORT $LN36@s370_kmf_d
  0004c	83 7c 24 34 08	 cmp	 DWORD PTR lcfb$[rsp], 8
  00051	7f 30		 jg	 SHORT $LN36@s370_kmf_d
  00053	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0005a	ff c0		 inc	 eax
  0005c	48 98		 cdqe
  0005e	33 d2		 xor	 edx, edx
  00060	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00068	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0006f	f7 74 24 34	 div	 DWORD PTR lcfb$[rsp]
  00073	8b c2		 mov	 eax, edx
  00075	85 c0		 test	 eax, eax
  00077	75 0a		 jne	 SHORT $LN36@s370_kmf_d
  00079	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
  00081	eb 08		 jmp	 SHORT $LN39@s370_kmf_d
$LN36@s370_kmf_d:
  00083	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
$LN39@s370_kmf_d:
  0008b	83 7c 24 4c 00	 cmp	 DWORD PTR tv93[rsp], 0
  00090	74 13		 je	 SHORT $LN21@s370_kmf_d

; 2843 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00092	ba 06 00 00 00	 mov	 edx, 6
  00097	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN21@s370_kmf_d:

; 2844 : 
; 2845 :   /* Return with cc 0 on zero length */
; 2846 :   if(unlikely(!GR_A(r2 + 1, regs)))

  000a5	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000ac	ff c0		 inc	 eax
  000ae	48 98		 cdqe
  000b0	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000b8	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  000c0	75 0a		 jne	 SHORT $LN40@s370_kmf_d
  000c2	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000ca	eb 08		 jmp	 SHORT $LN41@s370_kmf_d
$LN40@s370_kmf_d:
  000cc	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN41@s370_kmf_d:
  000d4	83 7c 24 50 00	 cmp	 DWORD PTR tv136[rsp], 0
  000d9	74 0a		 je	 SHORT $LN44@s370_kmf_d
  000db	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  000e3	eb 08		 jmp	 SHORT $LN45@s370_kmf_d
$LN44@s370_kmf_d:
  000e5	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN45@s370_kmf_d:
  000ed	83 7c 24 54 00	 cmp	 DWORD PTR tv147[rsp], 0
  000f2	74 11		 je	 SHORT $LN22@s370_kmf_d

; 2847 :   {
; 2848 :     regs->psw.cc = 0;

  000f4	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000fc	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2849 :     return;

  00100	e9 da 06 00 00	 jmp	 $LN1@s370_kmf_d
$LN22@s370_kmf_d:

; 2850 :   }
; 2851 : 
; 2852 :   /* Initialize values */
; 2853 :   tfc = GR0_tfc(regs);

  00105	b8 08 00 00 00	 mov	 eax, 8
  0010a	48 6b c0 00	 imul	 rax, rax, 0
  0010e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00116	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011d	83 e0 7f	 and	 eax, 127		; 0000007fH
  00120	83 e0 77	 and	 eax, 119		; 00000077H
  00123	89 44 24 44	 mov	 DWORD PTR tfc$[rsp], eax

; 2854 :   wrap = GR0_wrap(regs);

  00127	b8 08 00 00 00	 mov	 eax, 8
  0012c	48 6b c0 00	 imul	 rax, rax, 0
  00130	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00138	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0013f	83 e0 08	 and	 eax, 8
  00142	85 c0		 test	 eax, eax
  00144	74 0a		 je	 SHORT $LN46@s370_kmf_d
  00146	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv162[rsp], 1
  0014e	eb 08		 jmp	 SHORT $LN47@s370_kmf_d
$LN46@s370_kmf_d:
  00150	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv162[rsp], 0
$LN47@s370_kmf_d:
  00158	8b 44 24 58	 mov	 eax, DWORD PTR tv162[rsp]
  0015c	89 44 24 5c	 mov	 DWORD PTR wrap$[rsp], eax

; 2855 :   keylen = tfc * 8;

  00160	8b 44 24 44	 mov	 eax, DWORD PTR tfc$[rsp]
  00164	c1 e0 03	 shl	 eax, 3
  00167	89 44 24 60	 mov	 DWORD PTR keylen$[rsp], eax

; 2856 :   parameter_blocklen = keylen + 8;

  0016b	8b 44 24 60	 mov	 eax, DWORD PTR keylen$[rsp]
  0016f	83 c0 08	 add	 eax, 8
  00172	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2857 :   if(wrap)

  00176	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0017b	74 0b		 je	 SHORT $LN23@s370_kmf_d

; 2858 :     parameter_blocklen += 24;

  0017d	8b 44 24 38	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00181	83 c0 18	 add	 eax, 24
  00184	89 44 24 38	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN23@s370_kmf_d:

; 2859 : 
; 2860 :   /* Test writeability output chaining value */
; 2861 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  00188	b8 08 00 00 00	 mov	 eax, 8
  0018d	48 6b c0 01	 imul	 rax, rax, 1
  00191	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00199	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001a0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001a5	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001ad	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001b2	41 b9 02 00 00
	00		 mov	 r9d, 2
  001b8	41 b8 07 00 00
	00		 mov	 r8d, 7
  001be	ba 01 00 00 00	 mov	 edx, 1
  001c3	8b c8		 mov	 ecx, eax
  001c5	e8 00 00 00 00	 call	 s370_validate_operand

; 2862 : 
; 2863 :   /* Fetch the parameter block */
; 2864 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001ca	b8 08 00 00 00	 mov	 eax, 8
  001cf	48 6b c0 01	 imul	 rax, rax, 1
  001d3	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001db	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001e2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001e7	8b 4c 24 38	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001eb	ff c9		 dec	 ecx
  001ed	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001f5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001fa	41 b9 01 00 00
	00		 mov	 r9d, 1
  00200	44 8b c0	 mov	 r8d, eax
  00203	0f b6 d1	 movzx	 edx, cl
  00206	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0020e	e8 00 00 00 00	 call	 s370_vfetchc

; 2865 : 
; 2866 : #ifdef OPTION_KMF_DEBUG
; 2867 :   LOGBYTE("cv    :", parameter_block, 8);
; 2868 :   switch(tfc)
; 2869 :   {
; 2870 :     case 1: /* dea */
; 2871 :     {
; 2872 :       LOGBYTE("k     :", &parameter_block[8], 8);
; 2873 :       break;
; 2874 :     }
; 2875 :     case 2: /* tdea-128 */
; 2876 :     {
; 2877 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2878 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2879 :       break;
; 2880 :     }
; 2881 :     case 3: /* tdea-192 */
; 2882 :     {
; 2883 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2884 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2885 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 2886 :       break;
; 2887 :     }
; 2888 :   }
; 2889 :   if(wrap)
; 2890 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 24], 24);
; 2891 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2892 : 
; 2893 :   /* Verify and unwrap */
; 2894 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  00213	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00218	74 32		 je	 SHORT $LN24@s370_kmf_d
  0021a	b8 01 00 00 00	 mov	 eax, 1
  0021f	48 6b c0 08	 imul	 rax, rax, 8
  00223	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0022b	8b 54 24 60	 mov	 edx, DWORD PTR keylen$[rsp]
  0022f	48 8b c8	 mov	 rcx, rax
  00232	e8 00 00 00 00	 call	 unwrap_dea
  00237	85 c0		 test	 eax, eax
  00239	74 11		 je	 SHORT $LN24@s370_kmf_d

; 2895 :   {
; 2896 : 
; 2897 : #ifdef OPTION_KMF_DEBUG
; 2898 :     WRMSG(HHC90111, "D");
; 2899 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2900 : 
; 2901 :     regs->psw.cc = 1;

  0023b	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00243	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2902 :     return;

  00247	e9 93 05 00 00	 jmp	 $LN1@s370_kmf_d
$LN24@s370_kmf_d:

; 2903 :   }
; 2904 : 
; 2905 :   /* Set the cryptographic key */
; 2906 :   switch(tfc)

  0024c	8b 44 24 44	 mov	 eax, DWORD PTR tfc$[rsp]
  00250	89 44 24 3c	 mov	 DWORD PTR tv197[rsp], eax
  00254	83 7c 24 3c 01	 cmp	 DWORD PTR tv197[rsp], 1
  00259	74 13		 je	 SHORT $LN25@s370_kmf_d
  0025b	83 7c 24 3c 02	 cmp	 DWORD PTR tv197[rsp], 2
  00260	74 32		 je	 SHORT $LN26@s370_kmf_d
  00262	83 7c 24 3c 03	 cmp	 DWORD PTR tv197[rsp], 3
  00267	74 6f		 je	 SHORT $LN27@s370_kmf_d
  00269	e9 cd 00 00 00	 jmp	 $LN2@s370_kmf_d
$LN25@s370_kmf_d:

; 2907 :   {
; 2908 :     case 1: /* dea */
; 2909 :     {
; 2910 :       des_set_key(&context1, &parameter_block[8]);

  0026e	b8 01 00 00 00	 mov	 eax, 1
  00273	48 6b c0 08	 imul	 rax, rax, 8
  00277	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0027f	48 8b d0	 mov	 rdx, rax
  00282	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0028a	e8 00 00 00 00	 call	 des_set_key

; 2911 :       break;

  0028f	e9 a7 00 00 00	 jmp	 $LN2@s370_kmf_d
$LN26@s370_kmf_d:

; 2912 :     }
; 2913 :     case 2: /* tdea-128 */
; 2914 :     {
; 2915 :       des_set_key(&context1, &parameter_block[8]);

  00294	b8 01 00 00 00	 mov	 eax, 1
  00299	48 6b c0 08	 imul	 rax, rax, 8
  0029d	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002a5	48 8b d0	 mov	 rdx, rax
  002a8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002b0	e8 00 00 00 00	 call	 des_set_key

; 2916 :       des_set_key(&context2, &parameter_block[16]);

  002b5	b8 01 00 00 00	 mov	 eax, 1
  002ba	48 6b c0 10	 imul	 rax, rax, 16
  002be	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002c6	48 8b d0	 mov	 rdx, rax
  002c9	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002d1	e8 00 00 00 00	 call	 des_set_key

; 2917 :       break;

  002d6	eb 63		 jmp	 SHORT $LN2@s370_kmf_d
$LN27@s370_kmf_d:

; 2918 :     }
; 2919 :     case 3: /* tdea-192 */
; 2920 :     {
; 2921 :       des_set_key(&context1, &parameter_block[8]);

  002d8	b8 01 00 00 00	 mov	 eax, 1
  002dd	48 6b c0 08	 imul	 rax, rax, 8
  002e1	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002e9	48 8b d0	 mov	 rdx, rax
  002ec	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002f4	e8 00 00 00 00	 call	 des_set_key

; 2922 :       des_set_key(&context2, &parameter_block[16]);

  002f9	b8 01 00 00 00	 mov	 eax, 1
  002fe	48 6b c0 10	 imul	 rax, rax, 16
  00302	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0030a	48 8b d0	 mov	 rdx, rax
  0030d	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00315	e8 00 00 00 00	 call	 des_set_key

; 2923 :       des_set_key(&context3, &parameter_block[24]);

  0031a	b8 01 00 00 00	 mov	 eax, 1
  0031f	48 6b c0 18	 imul	 rax, rax, 24
  00323	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0032b	48 8b d0	 mov	 rdx, rax
  0032e	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00336	e8 00 00 00 00	 call	 des_set_key
$LN2@s370_kmf_d:

; 2924 :       break;
; 2925 :     }
; 2926 :   }
; 2927 : 
; 2928 :   /* Try to process the CPU-determined amount of data */
; 2929 :   modifier_bit = GR0_m(regs);

  0033b	b8 08 00 00 00	 mov	 eax, 8
  00340	48 6b c0 00	 imul	 rax, rax, 0
  00344	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00353	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00358	85 c0		 test	 eax, eax
  0035a	74 0a		 je	 SHORT $LN48@s370_kmf_d
  0035c	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv231[rsp], 1
  00364	eb 08		 jmp	 SHORT $LN49@s370_kmf_d
$LN48@s370_kmf_d:
  00366	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
$LN49@s370_kmf_d:
  0036e	8b 44 24 64	 mov	 eax, DWORD PTR tv231[rsp]
  00372	89 44 24 78	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2930 :   r1_is_not_r2 = r1 != r2;

  00376	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0037d	39 84 24 90 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00384	74 0a		 je	 SHORT $LN50@s370_kmf_d
  00386	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv233[rsp], 1
  0038e	eb 08		 jmp	 SHORT $LN51@s370_kmf_d
$LN50@s370_kmf_d:
  00390	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
$LN51@s370_kmf_d:
  00398	8b 44 24 68	 mov	 eax, DWORD PTR tv233[rsp]
  0039c	89 44 24 7c	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2931 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += lcfb)

  003a0	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  003a8	eb 10		 jmp	 SHORT $LN6@s370_kmf_d
$LN4@s370_kmf_d:
  003aa	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  003ae	8b 4c 24 40	 mov	 ecx, DWORD PTR crypted$[rsp]
  003b2	03 c8		 add	 ecx, eax
  003b4	8b c1		 mov	 eax, ecx
  003b6	89 44 24 40	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@s370_kmf_d:
  003ba	81 7c 24 40 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  003c2	0f 8d 0b 04 00
	00		 jge	 $LN5@s370_kmf_d

; 2932 :   {
; 2933 :     /* Do the job */
; 2934 :     switch(tfc)

  003c8	8b 44 24 44	 mov	 eax, DWORD PTR tfc$[rsp]
  003cc	89 44 24 48	 mov	 DWORD PTR tv236[rsp], eax
  003d0	83 7c 24 48 01	 cmp	 DWORD PTR tv236[rsp], 1
  003d5	74 17		 je	 SHORT $LN28@s370_kmf_d
  003d7	83 7c 24 48 02	 cmp	 DWORD PTR tv236[rsp], 2
  003dc	74 32		 je	 SHORT $LN29@s370_kmf_d
  003de	83 7c 24 48 03	 cmp	 DWORD PTR tv236[rsp], 3
  003e3	0f 84 80 00 00
	00		 je	 $LN30@s370_kmf_d
  003e9	e9 d2 00 00 00	 jmp	 $LN7@s370_kmf_d
$LN28@s370_kmf_d:

; 2935 :     {
; 2936 :       case 1: /* dea */
; 2937 :       {
; 2938 :         des_encrypt(&context1, parameter_block, output_block);

  003ee	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  003f6	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  003fe	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00406	e8 00 00 00 00	 call	 des_encrypt

; 2939 :         break;

  0040b	e9 b0 00 00 00	 jmp	 $LN7@s370_kmf_d
$LN29@s370_kmf_d:

; 2940 :       }
; 2941 :       case 2: /* tdea-128 */
; 2942 :       {
; 2943 :         des_encrypt(&context1, parameter_block, output_block);

  00410	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00418	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00420	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00428	e8 00 00 00 00	 call	 des_encrypt

; 2944 :         des_decrypt(&context2, output_block, output_block);

  0042d	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00435	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  0043d	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00445	e8 00 00 00 00	 call	 des_decrypt

; 2945 :         des_encrypt(&context1, output_block, output_block);

  0044a	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00452	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  0045a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00462	e8 00 00 00 00	 call	 des_encrypt

; 2946 :         break;

  00467	eb 57		 jmp	 SHORT $LN7@s370_kmf_d
$LN30@s370_kmf_d:

; 2947 :       }
; 2948 :       case 3: /* tdea-192 */
; 2949 :       {
; 2950 :         des_encrypt(&context1, parameter_block, output_block);

  00469	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  00471	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00479	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00481	e8 00 00 00 00	 call	 des_encrypt

; 2951 :         des_decrypt(&context2, output_block, output_block);

  00486	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  0048e	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  00496	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0049e	e8 00 00 00 00	 call	 des_decrypt

; 2952 :         des_encrypt(&context3, output_block, output_block);

  004a3	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR output_block$[rsp]
  004ab	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR output_block$[rsp]
  004b3	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  004bb	e8 00 00 00 00	 call	 des_encrypt
$LN7@s370_kmf_d:

; 2953 :         break;
; 2954 :       }
; 2955 :     }
; 2956 :     ARCH_DEP(vfetchc)(message_block, lcfb - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  004c0	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004c8	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004d0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004d7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  004dc	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  004e0	ff c9		 dec	 ecx
  004e2	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004ea	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  004ef	44 8b 8c 24 98
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  004f7	44 8b c0	 mov	 r8d, eax
  004fa	0f b6 d1	 movzx	 edx, cl
  004fd	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00505	e8 00 00 00 00	 call	 s370_vfetchc

; 2957 : 
; 2958 : #ifdef OPTION_KMF_DEBUG
; 2959 :     LOGBYTE("input :", message_block, lcfb);
; 2960 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2961 : 
; 2962 :     for(i = 0; i < lcfb; i++)

  0050a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00512	eb 0a		 jmp	 SHORT $LN11@s370_kmf_d
$LN9@s370_kmf_d:
  00514	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00518	ff c0		 inc	 eax
  0051a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@s370_kmf_d:
  0051e	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00522	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00526	7d 2a		 jge	 SHORT $LN10@s370_kmf_d

; 2963 :       output_block[i] ^= message_block[i];

  00528	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0052d	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00532	0f b6 8c 0c 38
	02 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  0053a	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  00542	33 c1		 xor	 eax, ecx
  00544	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00549	88 84 0c 30 02
	00 00		 mov	 BYTE PTR output_block$[rsp+rcx], al
  00550	eb c2		 jmp	 SHORT $LN9@s370_kmf_d
$LN10@s370_kmf_d:

; 2964 :     for(i = 0; i < 8 - lcfb; i++)

  00552	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0055a	eb 0a		 jmp	 SHORT $LN14@s370_kmf_d
$LN12@s370_kmf_d:
  0055c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00560	ff c0		 inc	 eax
  00562	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN14@s370_kmf_d:
  00566	b8 08 00 00 00	 mov	 eax, 8
  0056b	2b 44 24 34	 sub	 eax, DWORD PTR lcfb$[rsp]
  0056f	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00573	7d 24		 jge	 SHORT $LN13@s370_kmf_d

; 2965 :        parameter_block[i] = parameter_block[i + lcfb];

  00575	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  00579	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0057d	03 c8		 add	 ecx, eax
  0057f	8b c1		 mov	 eax, ecx
  00581	48 98		 cdqe
  00583	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00588	0f b6 84 04 40
	02 00 00	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  00590	88 84 0c 40 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  00597	eb c3		 jmp	 SHORT $LN12@s370_kmf_d
$LN13@s370_kmf_d:

; 2966 :     if(modifier_bit)

  00599	83 7c 24 78 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0059e	74 44		 je	 SHORT $LN31@s370_kmf_d

; 2967 :     {
; 2968 :       /* Decipher */
; 2969 :       for(i = 0; i < lcfb; i++)

  005a0	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005a8	eb 0a		 jmp	 SHORT $LN17@s370_kmf_d
$LN15@s370_kmf_d:
  005aa	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005ae	ff c0		 inc	 eax
  005b0	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN17@s370_kmf_d:
  005b4	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  005b8	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  005bc	7d 24		 jge	 SHORT $LN16@s370_kmf_d

; 2970 :         parameter_block[i + 8 - lcfb] = message_block[i];

  005be	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005c3	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  005c7	83 c1 08	 add	 ecx, 8
  005ca	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  005ce	48 63 c9	 movsxd	 rcx, ecx
  005d1	0f b6 84 04 38
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  005d9	88 84 0c 40 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  005e0	eb c8		 jmp	 SHORT $LN15@s370_kmf_d
$LN16@s370_kmf_d:

; 2971 :     }

  005e2	eb 42		 jmp	 SHORT $LN32@s370_kmf_d
$LN31@s370_kmf_d:

; 2972 :     else
; 2973 :     {
; 2974 :       /* Encipher */
; 2975 :       for(i = 0; i < lcfb; i++)

  005e4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005ec	eb 0a		 jmp	 SHORT $LN20@s370_kmf_d
$LN18@s370_kmf_d:
  005ee	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005f2	ff c0		 inc	 eax
  005f4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN20@s370_kmf_d:
  005f8	8b 44 24 34	 mov	 eax, DWORD PTR lcfb$[rsp]
  005fc	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00600	7d 24		 jge	 SHORT $LN19@s370_kmf_d

; 2976 :         parameter_block[i + 8 - lcfb] = output_block[i];

  00602	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00607	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  0060b	83 c1 08	 add	 ecx, 8
  0060e	2b 4c 24 34	 sub	 ecx, DWORD PTR lcfb$[rsp]
  00612	48 63 c9	 movsxd	 rcx, ecx
  00615	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR output_block$[rsp+rax]
  0061d	88 84 0c 40 02
	00 00		 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  00624	eb c8		 jmp	 SHORT $LN18@s370_kmf_d
$LN19@s370_kmf_d:
$LN32@s370_kmf_d:

; 2977 :     }
; 2978 : 
; 2979 :     /* Store the output */
; 2980 :     ARCH_DEP(vstorec)(output_block, lcfb - 1, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00626	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0062e	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00636	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0063d	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00642	8b 4c 24 34	 mov	 ecx, DWORD PTR lcfb$[rsp]
  00646	ff c9		 dec	 ecx
  00648	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00650	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00655	44 8b 8c 24 90
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0065d	44 8b c0	 mov	 r8d, eax
  00660	0f b6 d1	 movzx	 edx, cl
  00663	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR output_block$[rsp]
  0066b	e8 00 00 00 00	 call	 s370_vstorec

; 2981 : 
; 2982 : #ifdef OPTION_KMF_DEBUG
; 2983 :     LOGBYTE("output:", output_block, lcfb);
; 2984 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2985 : 
; 2986 :     /* Store the chaining value */
; 2987 :     ARCH_DEP(vstorec)(parameter_block, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00670	b8 08 00 00 00	 mov	 eax, 8
  00675	48 6b c0 01	 imul	 rax, rax, 1
  00679	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00681	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00688	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0068d	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00695	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0069a	41 b9 01 00 00
	00		 mov	 r9d, 1
  006a0	44 8b c0	 mov	 r8d, eax
  006a3	b2 07		 mov	 dl, 7
  006a5	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  006ad	e8 00 00 00 00	 call	 s370_vstorec

; 2988 : 
; 2989 : #ifdef OPTION_KMF_DEBUG
; 2990 :     LOGBYTE("cv    :", parameter_block, 8);
; 2991 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 2992 : 
; 2993 :     /* Update the registers */
; 2994 :     SET_GR_A(r1, regs, GR_A(r1, regs) + lcfb);

  006b2	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  006ba	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  006c2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  006c9	03 44 24 34	 add	 eax, DWORD PTR lcfb$[rsp]
  006cd	48 63 8c 24 90
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  006d5	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  006dd	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2995 :     if(likely(r1_is_not_r2))

  006e4	83 7c 24 7c 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  006e9	74 0a		 je	 SHORT $LN52@s370_kmf_d
  006eb	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv355[rsp], 1
  006f3	eb 08		 jmp	 SHORT $LN53@s370_kmf_d
$LN52@s370_kmf_d:
  006f5	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv355[rsp], 0
$LN53@s370_kmf_d:
  006fd	83 7c 24 6c 00	 cmp	 DWORD PTR tv355[rsp], 0
  00702	74 32		 je	 SHORT $LN33@s370_kmf_d

; 2996 :       SET_GR_A(r2, regs, GR_A(r2, regs) + lcfb);

  00704	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0070c	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00714	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0071b	03 44 24 34	 add	 eax, DWORD PTR lcfb$[rsp]
  0071f	48 63 8c 24 98
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00727	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0072f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN33@s370_kmf_d:

; 2997 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - lcfb);

  00736	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0073d	ff c0		 inc	 eax
  0073f	48 98		 cdqe
  00741	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00749	8b 54 24 34	 mov	 edx, DWORD PTR lcfb$[rsp]
  0074d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00754	2b c2		 sub	 eax, edx
  00756	8b 8c 24 98 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0075d	ff c1		 inc	 ecx
  0075f	48 63 c9	 movsxd	 rcx, ecx
  00762	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0076a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2998 : 
; 2999 : #ifdef OPTION_KMF_DEBUG
; 3000 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 3001 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 3002 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 3003 : #endif /* #ifdef OPTION_KMF_DEBUG */
; 3004 : 
; 3005 :     /* check for end of data */
; 3006 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00771	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00778	ff c0		 inc	 eax
  0077a	48 98		 cdqe
  0077c	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00784	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0078c	75 0a		 jne	 SHORT $LN54@s370_kmf_d
  0078e	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv388[rsp], 1
  00796	eb 08		 jmp	 SHORT $LN55@s370_kmf_d
$LN54@s370_kmf_d:
  00798	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv388[rsp], 0
$LN55@s370_kmf_d:
  007a0	83 7c 24 70 00	 cmp	 DWORD PTR tv388[rsp], 0
  007a5	74 0a		 je	 SHORT $LN58@s370_kmf_d
  007a7	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv399[rsp], 1
  007af	eb 08		 jmp	 SHORT $LN59@s370_kmf_d
$LN58@s370_kmf_d:
  007b1	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv399[rsp], 0
$LN59@s370_kmf_d:
  007b9	83 7c 24 74 00	 cmp	 DWORD PTR tv399[rsp], 0
  007be	74 0e		 je	 SHORT $LN34@s370_kmf_d

; 3007 :     {
; 3008 :       regs->psw.cc = 0;

  007c0	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007c8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 3009 :       return;

  007cc	eb 11		 jmp	 SHORT $LN1@s370_kmf_d
$LN34@s370_kmf_d:

; 3010 :     }
; 3011 :   }

  007ce	e9 d7 fb ff ff	 jmp	 $LN4@s370_kmf_d
$LN5@s370_kmf_d:

; 3012 : 
; 3013 :   /* CPU-determined amount of data processed */
; 3014 :   regs->psw.cc = 3;

  007d3	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  007db	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmf_d:

; 3015 : }

  007df	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  007e7	48 33 cc	 xor	 rcx, rsp
  007ea	e8 00 00 00 00	 call	 __security_check_cookie
  007ef	48 81 c4 88 02
	00 00		 add	 rsp, 648		; 00000288H
  007f6	c3		 ret	 0
s370_kmf_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
fc$ = 52
crypted$ = 56
tv82 = 60
tv93 = 64
tv136 = 68
keylen$ = 72
tv182 = 76
tv184 = 80
tv186 = 84
tv252 = 88
tv285 = 92
tv305 = 96
tv316 = 100
parameter_blocklen$ = 104
wrap$ = 108
r1_is_not_r2$ = 112
r1_is_not_r3$ = 116
r2_is_not_r3$ = 120
tfc$ = 124
context$ = 128
countervalue_block$ = 624
message_block$ = 640
parameter_block$ = 656
__$ArrayPad$ = 720
r1$ = 752
r2$ = 760
r3$ = 768
regs$ = 776
s370_kmctr_aes PROC

; 2701 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2702 :   rijndael_ctx context;
; 2703 :   BYTE countervalue_block[16];
; 2704 :   int crypted;
; 2705 :   int i;
; 2706 :   int keylen;
; 2707 :   BYTE message_block[16];
; 2708 :   BYTE parameter_block[64];
; 2709 :   int parameter_blocklen;
; 2710 :   int r1_is_not_r2;
; 2711 :   int r1_is_not_r3;
; 2712 :   int r2_is_not_r3;
; 2713 :   int fc;
; 2714 :   int tfc;
; 2715 :   int wrap;
; 2716 : 
; 2717 :   /* Check special conditions */
; 2718 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  0002b	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00032	ff c0		 inc	 eax
  00034	48 98		 cdqe
  00036	33 d2		 xor	 edx, edx
  00038	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00047	b9 10 00 00 00	 mov	 ecx, 16
  0004c	f7 f1		 div	 ecx
  0004e	8b c2		 mov	 eax, edx
  00050	85 c0		 test	 eax, eax
  00052	74 0a		 je	 SHORT $LN17@s370_kmctr
  00054	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0005c	eb 08		 jmp	 SHORT $LN18@s370_kmctr
$LN17@s370_kmctr:
  0005e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN18@s370_kmctr:
  00066	83 7c 24 3c 00	 cmp	 DWORD PTR tv82[rsp], 0
  0006b	74 13		 je	 SHORT $LN8@s370_kmctr

; 2719 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006d	ba 06 00 00 00	 mov	 edx, 6
  00072	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN8@s370_kmctr:

; 2720 : 
; 2721 :   /* Return with cc 0 on zero length */
; 2722 :   if(unlikely(!GR_A(r2 + 1, regs)))

  00080	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00087	ff c0		 inc	 eax
  00089	48 98		 cdqe
  0008b	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0009b	75 0a		 jne	 SHORT $LN19@s370_kmctr
  0009d	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a5	eb 08		 jmp	 SHORT $LN20@s370_kmctr
$LN19@s370_kmctr:
  000a7	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN20@s370_kmctr:
  000af	83 7c 24 40 00	 cmp	 DWORD PTR tv93[rsp], 0
  000b4	74 0a		 je	 SHORT $LN23@s370_kmctr
  000b6	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000be	eb 08		 jmp	 SHORT $LN24@s370_kmctr
$LN23@s370_kmctr:
  000c0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN24@s370_kmctr:
  000c8	83 7c 24 44 00	 cmp	 DWORD PTR tv136[rsp], 0
  000cd	74 11		 je	 SHORT $LN9@s370_kmctr

; 2723 :   {
; 2724 :     regs->psw.cc = 0;

  000cf	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2725 :     return;

  000db	e9 5b 04 00 00	 jmp	 $LN1@s370_kmctr
$LN9@s370_kmctr:

; 2726 :   }
; 2727 : 
; 2728 :   /* Initialize values */
; 2729 :   fc = GR0_fc(regs);

  000e0	b8 08 00 00 00	 mov	 eax, 8
  000e5	48 6b c0 00	 imul	 rax, rax, 0
  000e9	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f8	83 e0 7f	 and	 eax, 127		; 0000007fH
  000fb	89 44 24 34	 mov	 DWORD PTR fc$[rsp], eax

; 2730 :   tfc = GR0_tfc(regs);

  000ff	b8 08 00 00 00	 mov	 eax, 8
  00104	48 6b c0 00	 imul	 rax, rax, 0
  00108	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00117	83 e0 7f	 and	 eax, 127		; 0000007fH
  0011a	83 e0 77	 and	 eax, 119		; 00000077H
  0011d	89 44 24 7c	 mov	 DWORD PTR tfc$[rsp], eax

; 2731 :   wrap = kmctr_wrap[fc];

  00121	48 63 44 24 34	 movsxd	 rax, DWORD PTR fc$[rsp]
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kmctr_wrap
  0012d	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00130	89 44 24 6c	 mov	 DWORD PTR wrap$[rsp], eax

; 2732 :   keylen = kmctr_keylengths[fc];

  00134	48 63 44 24 34	 movsxd	 rax, DWORD PTR fc$[rsp]
  00139	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kmctr_keylengths
  00140	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00143	89 44 24 48	 mov	 DWORD PTR keylen$[rsp], eax

; 2733 :   parameter_blocklen = kmctr_pblens[fc];

  00147	48 63 44 24 34	 movsxd	 rax, DWORD PTR fc$[rsp]
  0014c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kmctr_pblens
  00153	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00156	89 44 24 68	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2734 : #ifdef OPTION_KMCTR_DEBUG
; 2735 :   logmsg("Feature code %d wrap %d keylen %d pblen %d\n",
; 2736 :    tfc, wrap, keylen, parameter_blocklen);
; 2737 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2738 : 
; 2739 :   /* Fetch the parameter block */
; 2740 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0015a	b8 08 00 00 00	 mov	 eax, 8
  0015f	48 6b c0 01	 imul	 rax, rax, 1
  00163	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016b	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00172	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00177	8b 4c 24 68	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0017b	ff c9		 dec	 ecx
  0017d	48 8b 94 24 08
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00185	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0018a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00190	44 8b c0	 mov	 r8d, eax
  00193	0f b6 d1	 movzx	 edx, cl
  00196	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0019e	e8 00 00 00 00	 call	 s370_vfetchc

; 2741 : 
; 2742 : #ifdef OPTION_KMCTR_DEBUG
; 2743 :   LOGBYTE("k     :", parameter_block, keylen);
; 2744 :   if(wrap)
; 2745 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 32], 32);
; 2746 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2747 : 
; 2748 :   if(wrap && unwrap_aes(parameter_block, keylen))

  001a3	83 7c 24 6c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001a8	74 26		 je	 SHORT $LN10@s370_kmctr
  001aa	8b 54 24 48	 mov	 edx, DWORD PTR keylen$[rsp]
  001ae	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001b6	e8 00 00 00 00	 call	 unwrap_aes
  001bb	85 c0		 test	 eax, eax
  001bd	74 11		 je	 SHORT $LN10@s370_kmctr

; 2749 :   {
; 2750 : 
; 2751 : #ifdef OPTION_KMCTR_DEBUG
; 2752 :     WRMSG(HHC90111, "D");
; 2753 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2754 : 
; 2755 :     regs->psw.cc = 1;

  001bf	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c7	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2756 :     return;

  001cb	e9 6b 03 00 00	 jmp	 $LN1@s370_kmctr
$LN10@s370_kmctr:

; 2757 :   }
; 2758 : 
; 2759 :   /* Set the cryptographic key */
; 2760 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  001d0	8b 44 24 48	 mov	 eax, DWORD PTR keylen$[rsp]
  001d4	c1 e0 03	 shl	 eax, 3
  001d7	44 8b c0	 mov	 r8d, eax
  001da	48 8d 94 24 90
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  001e2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  001ea	e8 00 00 00 00	 call	 rijndael_set_key

; 2761 : 
; 2762 :   /* Try to process the CPU-determined amount of data */
; 2763 :   r1_is_not_r2 = r1 != r2;

  001ef	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  001f6	39 84 24 f0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  001fd	74 0a		 je	 SHORT $LN25@s370_kmctr
  001ff	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv182[rsp], 1
  00207	eb 08		 jmp	 SHORT $LN26@s370_kmctr
$LN25@s370_kmctr:
  00209	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv182[rsp], 0
$LN26@s370_kmctr:
  00211	8b 44 24 4c	 mov	 eax, DWORD PTR tv182[rsp]
  00215	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2764 :   r1_is_not_r3 = r1 != r3;

  00219	8b 84 24 00 03
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  00220	39 84 24 f0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00227	74 0a		 je	 SHORT $LN27@s370_kmctr
  00229	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv184[rsp], 1
  00231	eb 08		 jmp	 SHORT $LN28@s370_kmctr
$LN27@s370_kmctr:
  00233	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv184[rsp], 0
$LN28@s370_kmctr:
  0023b	8b 44 24 50	 mov	 eax, DWORD PTR tv184[rsp]
  0023f	89 44 24 74	 mov	 DWORD PTR r1_is_not_r3$[rsp], eax

; 2765 :   r2_is_not_r3 = r1 != r2;

  00243	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0024a	39 84 24 f0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  00251	74 0a		 je	 SHORT $LN29@s370_kmctr
  00253	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv186[rsp], 1
  0025b	eb 08		 jmp	 SHORT $LN30@s370_kmctr
$LN29@s370_kmctr:
  0025d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv186[rsp], 0
$LN30@s370_kmctr:
  00265	8b 44 24 54	 mov	 eax, DWORD PTR tv186[rsp]
  00269	89 44 24 78	 mov	 DWORD PTR r2_is_not_r3$[rsp], eax

; 2766 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  0026d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00275	eb 0b		 jmp	 SHORT $LN4@s370_kmctr
$LN2@s370_kmctr:
  00277	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  0027b	83 c0 10	 add	 eax, 16
  0027e	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s370_kmctr:
  00282	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  0028a	0f 8d 9f 02 00
	00		 jge	 $LN3@s370_kmctr

; 2767 :   {
; 2768 :     /* Fetch a block of data and counter-value */
; 2769 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00290	48 63 84 24 f8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00298	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a0	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002a7	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002ac	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002b4	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002b9	44 8b 8c 24 f8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002c1	44 8b c0	 mov	 r8d, eax
  002c4	b2 0f		 mov	 dl, 15
  002c6	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002ce	e8 00 00 00 00	 call	 s370_vfetchc

; 2770 :     ARCH_DEP(vfetchc)(countervalue_block, 15, GR_A(r3, regs) & ADDRESS_MAXWRAP(regs), r3, regs);

  002d3	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  002db	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002e3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002ea	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002ef	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002f7	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002fc	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  00304	44 8b c0	 mov	 r8d, eax
  00307	b2 0f		 mov	 dl, 15
  00309	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  00311	e8 00 00 00 00	 call	 s370_vfetchc

; 2771 : 
; 2772 : #ifdef OPTION_KMCTR_DEBUG
; 2773 :     LOGBYTE("input :", message_block, 16);
; 2774 :     LOGBYTE("cv    :", countervalue_block, 16);
; 2775 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2776 : 
; 2777 :     /* Do the job */
; 2778 :     /* Encrypt and XOR */
; 2779 :     rijndael_encrypt(&context, countervalue_block, countervalue_block);

  00316	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  0031e	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  00326	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0032e	e8 00 00 00 00	 call	 rijndael_encrypt

; 2780 :     for(i = 0; i < 16; i++)

  00333	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0033b	eb 0a		 jmp	 SHORT $LN7@s370_kmctr
$LN5@s370_kmctr:
  0033d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00341	ff c0		 inc	 eax
  00343	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_kmctr:
  00347	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  0034c	7d 2a		 jge	 SHORT $LN6@s370_kmctr

; 2781 :       countervalue_block[i] ^= message_block[i];

  0034e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00353	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00358	0f b6 8c 0c 80
	02 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  00360	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR countervalue_block$[rsp+rax]
  00368	33 c1		 xor	 eax, ecx
  0036a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0036f	88 84 0c 70 02
	00 00		 mov	 BYTE PTR countervalue_block$[rsp+rcx], al
  00376	eb c5		 jmp	 SHORT $LN5@s370_kmctr
$LN6@s370_kmctr:

; 2782 : 
; 2783 :     /* Store the output */
; 2784 :     ARCH_DEP(vstorec)(countervalue_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00378	48 63 84 24 f0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00380	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00388	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0038f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00394	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003a1	44 8b 8c 24 f0
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  003a9	44 8b c0	 mov	 r8d, eax
  003ac	b2 0f		 mov	 dl, 15
  003ae	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  003b6	e8 00 00 00 00	 call	 s370_vstorec

; 2785 : 
; 2786 : #ifdef OPTION_KMCTR_DEBUG
; 2787 :     LOGBYTE("output:", countervalue_block, 16);
; 2788 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2789 : 
; 2790 :     /* Update the registers */
; 2791 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  003bb	48 63 84 24 f0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  003c3	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003cb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003d2	83 c0 10	 add	 eax, 16
  003d5	48 63 8c 24 f0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  003dd	48 8b 94 24 08
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003e5	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2792 :     if(likely(r1_is_not_r2))

  003ec	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  003f1	74 0a		 je	 SHORT $LN31@s370_kmctr
  003f3	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv252[rsp], 1
  003fb	eb 08		 jmp	 SHORT $LN32@s370_kmctr
$LN31@s370_kmctr:
  003fd	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN32@s370_kmctr:
  00405	83 7c 24 58 00	 cmp	 DWORD PTR tv252[rsp], 0
  0040a	74 31		 je	 SHORT $LN11@s370_kmctr

; 2793 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  0040c	48 63 84 24 f8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00414	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00423	83 c0 10	 add	 eax, 16
  00426	48 63 8c 24 f8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0042e	48 8b 94 24 08
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00436	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN11@s370_kmctr:

; 2794 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  0043d	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00444	ff c0		 inc	 eax
  00446	48 98		 cdqe
  00448	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00450	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00457	83 e8 10	 sub	 eax, 16
  0045a	8b 8c 24 f8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00461	ff c1		 inc	 ecx
  00463	48 63 c9	 movsxd	 rcx, ecx
  00466	48 8b 94 24 08
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0046e	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2795 :     if(likely(r1_is_not_r3 && r2_is_not_r3))

  00475	83 7c 24 74 00	 cmp	 DWORD PTR r1_is_not_r3$[rsp], 0
  0047a	74 11		 je	 SHORT $LN33@s370_kmctr
  0047c	83 7c 24 78 00	 cmp	 DWORD PTR r2_is_not_r3$[rsp], 0
  00481	74 0a		 je	 SHORT $LN33@s370_kmctr
  00483	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv285[rsp], 1
  0048b	eb 08		 jmp	 SHORT $LN36@s370_kmctr
$LN33@s370_kmctr:
  0048d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv285[rsp], 0
$LN36@s370_kmctr:
  00495	83 7c 24 5c 00	 cmp	 DWORD PTR tv285[rsp], 0
  0049a	74 31		 je	 SHORT $LN12@s370_kmctr

; 2796 :       SET_GR_A(r3, regs, GR_A(r3, regs) + 16);

  0049c	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  004a4	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004ac	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004b3	83 c0 10	 add	 eax, 16
  004b6	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  004be	48 8b 94 24 08
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004c6	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN12@s370_kmctr:

; 2797 : 
; 2798 : #ifdef OPTION_KMCTR_DEBUG
; 2799 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2800 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2801 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2802 :     WRMSG(HHC90108, "D", r3, (regs)->GR(r3));
; 2803 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2804 : 
; 2805 :     /* check for end of data */
; 2806 :     if(unlikely(!GR_A(r2 + 1, regs)))

  004cd	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004d4	ff c0		 inc	 eax
  004d6	48 98		 cdqe
  004d8	48 8b 8c 24 08
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004e0	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  004e8	75 0a		 jne	 SHORT $LN37@s370_kmctr
  004ea	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv305[rsp], 1
  004f2	eb 08		 jmp	 SHORT $LN38@s370_kmctr
$LN37@s370_kmctr:
  004f4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv305[rsp], 0
$LN38@s370_kmctr:
  004fc	83 7c 24 60 00	 cmp	 DWORD PTR tv305[rsp], 0
  00501	74 0a		 je	 SHORT $LN41@s370_kmctr
  00503	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv316[rsp], 1
  0050b	eb 08		 jmp	 SHORT $LN42@s370_kmctr
$LN41@s370_kmctr:
  0050d	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv316[rsp], 0
$LN42@s370_kmctr:
  00515	83 7c 24 64 00	 cmp	 DWORD PTR tv316[rsp], 0
  0051a	74 0e		 je	 SHORT $LN13@s370_kmctr

; 2807 :     {
; 2808 :       regs->psw.cc = 0;

  0051c	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00524	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2809 :       return;

  00528	eb 11		 jmp	 SHORT $LN1@s370_kmctr
$LN13@s370_kmctr:

; 2810 :     }
; 2811 :   }

  0052a	e9 48 fd ff ff	 jmp	 $LN2@s370_kmctr
$LN3@s370_kmctr:

; 2812 : 
; 2813 :   /* CPU-determined amount of data processed */
; 2814 :   regs->psw.cc = 3;

  0052f	48 8b 84 24 08
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00537	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmctr:

; 2815 : }

  0053b	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00543	48 33 cc	 xor	 rcx, rsp
  00546	e8 00 00 00 00	 call	 __security_check_cookie
  0054b	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  00552	c3		 ret	 0
s370_kmctr_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv173 = 56
crypted$ = 60
tfc$ = 64
tv225 = 68
tv82 = 72
tv93 = 76
tv136 = 80
tv151 = 84
wrap$ = 88
keylen$ = 92
tv196 = 96
tv198 = 100
tv200 = 104
tv288 = 108
tv321 = 112
tv341 = 116
tv352 = 120
r1_is_not_r2$ = 124
r1_is_not_r3$ = 128
r2_is_not_r3$ = 132
context1$ = 144
context2$ = 288
context3$ = 432
countervalue_block$ = 576
message_block$ = 584
parameter_block$ = 592
__$ArrayPad$ = 640
r1$ = 672
r2$ = 680
r3$ = 688
regs$ = 696
s370_kmctr_dea PROC

; 2519 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2520 :   des_context context1;
; 2521 :   des_context context2;
; 2522 :   des_context context3;
; 2523 :   BYTE countervalue_block[8];
; 2524 :   int crypted;
; 2525 :   int i;
; 2526 :   int keylen;
; 2527 :   BYTE message_block[8];
; 2528 :   BYTE parameter_block[48];
; 2529 :   int parameter_blocklen;
; 2530 :   int r1_is_not_r2;
; 2531 :   int r1_is_not_r3;
; 2532 :   int r2_is_not_r3;
; 2533 :   int tfc;
; 2534 :   int wrap;
; 2535 : 
; 2536 :   /* Check special conditions */
; 2537 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  0002b	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00032	ff c0		 inc	 eax
  00034	48 98		 cdqe
  00036	33 d2		 xor	 edx, edx
  00038	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00040	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00047	b9 08 00 00 00	 mov	 ecx, 8
  0004c	f7 f1		 div	 ecx
  0004e	8b c2		 mov	 eax, edx
  00050	85 c0		 test	 eax, eax
  00052	74 0a		 je	 SHORT $LN28@s370_kmctr
  00054	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  0005c	eb 08		 jmp	 SHORT $LN29@s370_kmctr
$LN28@s370_kmctr:
  0005e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN29@s370_kmctr:
  00066	83 7c 24 48 00	 cmp	 DWORD PTR tv82[rsp], 0
  0006b	74 13		 je	 SHORT $LN12@s370_kmctr

; 2538 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006d	ba 06 00 00 00	 mov	 edx, 6
  00072	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN12@s370_kmctr:

; 2539 : 
; 2540 :   /* Return with cc 0 on zero length */
; 2541 :   if(unlikely(!GR_A(r2 + 1, regs)))

  00080	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00087	ff c0		 inc	 eax
  00089	48 98		 cdqe
  0008b	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00093	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0009b	75 0a		 jne	 SHORT $LN30@s370_kmctr
  0009d	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a5	eb 08		 jmp	 SHORT $LN31@s370_kmctr
$LN30@s370_kmctr:
  000a7	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN31@s370_kmctr:
  000af	83 7c 24 4c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000b4	74 0a		 je	 SHORT $LN34@s370_kmctr
  000b6	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000be	eb 08		 jmp	 SHORT $LN35@s370_kmctr
$LN34@s370_kmctr:
  000c0	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN35@s370_kmctr:
  000c8	83 7c 24 50 00	 cmp	 DWORD PTR tv136[rsp], 0
  000cd	74 11		 je	 SHORT $LN13@s370_kmctr

; 2542 :   {
; 2543 :     regs->psw.cc = 0;

  000cf	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2544 :     return;

  000db	e9 f4 05 00 00	 jmp	 $LN1@s370_kmctr
$LN13@s370_kmctr:

; 2545 :   }
; 2546 : 
; 2547 :   /* Initialize values */
; 2548 :   tfc = GR0_tfc(regs);

  000e0	b8 08 00 00 00	 mov	 eax, 8
  000e5	48 6b c0 00	 imul	 rax, rax, 0
  000e9	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f8	83 e0 7f	 and	 eax, 127		; 0000007fH
  000fb	83 e0 77	 and	 eax, 119		; 00000077H
  000fe	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 2549 :   wrap = GR0_wrap(regs);

  00102	b8 08 00 00 00	 mov	 eax, 8
  00107	48 6b c0 00	 imul	 rax, rax, 0
  0010b	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00113	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011a	83 e0 08	 and	 eax, 8
  0011d	85 c0		 test	 eax, eax
  0011f	74 0a		 je	 SHORT $LN36@s370_kmctr
  00121	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00129	eb 08		 jmp	 SHORT $LN37@s370_kmctr
$LN36@s370_kmctr:
  0012b	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN37@s370_kmctr:
  00133	8b 44 24 54	 mov	 eax, DWORD PTR tv151[rsp]
  00137	89 44 24 58	 mov	 DWORD PTR wrap$[rsp], eax

; 2550 :   keylen = tfc * 8;

  0013b	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0013f	c1 e0 03	 shl	 eax, 3
  00142	89 44 24 5c	 mov	 DWORD PTR keylen$[rsp], eax

; 2551 :   parameter_blocklen = keylen;

  00146	8b 44 24 5c	 mov	 eax, DWORD PTR keylen$[rsp]
  0014a	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2552 :   if(wrap)

  0014e	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00153	74 0b		 je	 SHORT $LN14@s370_kmctr

; 2553 :     parameter_blocklen += 24;

  00155	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00159	83 c0 18	 add	 eax, 24
  0015c	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN14@s370_kmctr:

; 2554 : 
; 2555 :   /* Fetch the parameter block */
; 2556 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00160	b8 08 00 00 00	 mov	 eax, 8
  00165	48 6b c0 01	 imul	 rax, rax, 1
  00169	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00171	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00178	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0017d	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00181	ff c9		 dec	 ecx
  00183	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0018b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00190	41 b9 01 00 00
	00		 mov	 r9d, 1
  00196	44 8b c0	 mov	 r8d, eax
  00199	0f b6 d1	 movzx	 edx, cl
  0019c	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001a4	e8 00 00 00 00	 call	 s370_vfetchc

; 2557 : 
; 2558 : #ifdef OPTION_KMCTR_DEBUG
; 2559 :   switch(tfc)
; 2560 :   {
; 2561 :     case 1: /* dea */
; 2562 :     {
; 2563 :       LOGBYTE("k     :", parameter_block, 8);
; 2564 :       break;
; 2565 :     }
; 2566 :     case 2: /* tdea-128 */
; 2567 :     {
; 2568 :       LOGBYTE("k1    :", parameter_block, 8);
; 2569 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 2570 :       break;
; 2571 :     }
; 2572 :     case 3: /* tdea-192 */
; 2573 :     {
; 2574 :       LOGBYTE("k1    :", parameter_block, 8);
; 2575 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 2576 :       LOGBYTE("k3    :", &parameter_block[16], 8);
; 2577 :       break;
; 2578 :     }
; 2579 :   }
; 2580 :   if(wrap)
; 2581 :     LOGBYTE("wkvp  :", &parameter_block[parameter_blocklen - 24], 24);
; 2582 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2583 : 
; 2584 :   /* Verify and unwrap */
; 2585 :   if(wrap && unwrap_dea(parameter_block, keylen))

  001a9	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001ae	74 26		 je	 SHORT $LN15@s370_kmctr
  001b0	8b 54 24 5c	 mov	 edx, DWORD PTR keylen$[rsp]
  001b4	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001bc	e8 00 00 00 00	 call	 unwrap_dea
  001c1	85 c0		 test	 eax, eax
  001c3	74 11		 je	 SHORT $LN15@s370_kmctr

; 2586 :   {
; 2587 : 
; 2588 : #ifdef OPTION_KMCTR_DEBUG
; 2589 :     WRMSG(HHC90111, "D");
; 2590 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2591 : 
; 2592 :     regs->psw.cc = 1;

  001c5	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cd	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2593 :     return;

  001d1	e9 fe 04 00 00	 jmp	 $LN1@s370_kmctr
$LN15@s370_kmctr:

; 2594 :   }
; 2595 : 
; 2596 :   /* Set the cryptographic key */
; 2597 :   switch(tfc)

  001d6	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  001da	89 44 24 38	 mov	 DWORD PTR tv173[rsp], eax
  001de	83 7c 24 38 01	 cmp	 DWORD PTR tv173[rsp], 1
  001e3	74 13		 je	 SHORT $LN16@s370_kmctr
  001e5	83 7c 24 38 02	 cmp	 DWORD PTR tv173[rsp], 2
  001ea	74 26		 je	 SHORT $LN17@s370_kmctr
  001ec	83 7c 24 38 03	 cmp	 DWORD PTR tv173[rsp], 3
  001f1	74 57		 je	 SHORT $LN18@s370_kmctr
  001f3	e9 a9 00 00 00	 jmp	 $LN2@s370_kmctr
$LN16@s370_kmctr:

; 2598 :   {
; 2599 :     case 1: /* dea */
; 2600 :     {
; 2601 :       des_set_key(&context1, parameter_block);

  001f8	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00200	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00208	e8 00 00 00 00	 call	 des_set_key

; 2602 :       break;

  0020d	e9 8f 00 00 00	 jmp	 $LN2@s370_kmctr
$LN17@s370_kmctr:

; 2603 :     }
; 2604 :     case 2: /* tdea-128 */
; 2605 :     {
; 2606 :       des_set_key(&context1, parameter_block);

  00212	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0021a	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00222	e8 00 00 00 00	 call	 des_set_key

; 2607 :       des_set_key(&context2, &parameter_block[8]);

  00227	b8 01 00 00 00	 mov	 eax, 1
  0022c	48 6b c0 08	 imul	 rax, rax, 8
  00230	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00238	48 8b d0	 mov	 rdx, rax
  0023b	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00243	e8 00 00 00 00	 call	 des_set_key

; 2608 :       break;

  00248	eb 57		 jmp	 SHORT $LN2@s370_kmctr
$LN18@s370_kmctr:

; 2609 :     }
; 2610 :     case 3: /* tdea-192 */
; 2611 :     {
; 2612 :       des_set_key(&context1, parameter_block);

  0024a	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00252	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0025a	e8 00 00 00 00	 call	 des_set_key

; 2613 :       des_set_key(&context2, &parameter_block[8]);

  0025f	b8 01 00 00 00	 mov	 eax, 1
  00264	48 6b c0 08	 imul	 rax, rax, 8
  00268	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00270	48 8b d0	 mov	 rdx, rax
  00273	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0027b	e8 00 00 00 00	 call	 des_set_key

; 2614 :       des_set_key(&context3, &parameter_block[16]);

  00280	b8 01 00 00 00	 mov	 eax, 1
  00285	48 6b c0 10	 imul	 rax, rax, 16
  00289	48 8d 84 04 50
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00291	48 8b d0	 mov	 rdx, rax
  00294	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0029c	e8 00 00 00 00	 call	 des_set_key
$LN2@s370_kmctr:

; 2615 :       break;
; 2616 :     }
; 2617 :   }
; 2618 : 
; 2619 :   /* Try to process the CPU-determined amount of data */
; 2620 :   r1_is_not_r2 = r1 != r2;

  002a1	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002a8	39 84 24 a0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002af	74 0a		 je	 SHORT $LN38@s370_kmctr
  002b1	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv196[rsp], 1
  002b9	eb 08		 jmp	 SHORT $LN39@s370_kmctr
$LN38@s370_kmctr:
  002bb	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv196[rsp], 0
$LN39@s370_kmctr:
  002c3	8b 44 24 60	 mov	 eax, DWORD PTR tv196[rsp]
  002c7	89 44 24 7c	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2621 :   r1_is_not_r3 = r1 != r3;

  002cb	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002d2	39 84 24 a0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002d9	74 0a		 je	 SHORT $LN40@s370_kmctr
  002db	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv198[rsp], 1
  002e3	eb 08		 jmp	 SHORT $LN41@s370_kmctr
$LN40@s370_kmctr:
  002e5	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
$LN41@s370_kmctr:
  002ed	8b 44 24 64	 mov	 eax, DWORD PTR tv198[rsp]
  002f1	89 84 24 80 00
	00 00		 mov	 DWORD PTR r1_is_not_r3$[rsp], eax

; 2622 :   r2_is_not_r3 = r2 != r3;

  002f8	8b 84 24 b0 02
	00 00		 mov	 eax, DWORD PTR r3$[rsp]
  002ff	39 84 24 a8 02
	00 00		 cmp	 DWORD PTR r2$[rsp], eax
  00306	74 0a		 je	 SHORT $LN42@s370_kmctr
  00308	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  00310	eb 08		 jmp	 SHORT $LN43@s370_kmctr
$LN42@s370_kmctr:
  00312	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv200[rsp], 0
$LN43@s370_kmctr:
  0031a	8b 44 24 68	 mov	 eax, DWORD PTR tv200[rsp]
  0031e	89 84 24 84 00
	00 00		 mov	 DWORD PTR r2_is_not_r3$[rsp], eax

; 2623 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  00325	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0032d	eb 0b		 jmp	 SHORT $LN6@s370_kmctr
$LN4@s370_kmctr:
  0032f	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00333	83 c0 08	 add	 eax, 8
  00336	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@s370_kmctr:
  0033a	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00342	0f 8d 80 03 00
	00		 jge	 $LN5@s370_kmctr

; 2624 :   {
; 2625 :     /* Fetch a block of data and counter-value */
; 2626 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00348	48 63 84 24 a8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00350	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00358	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0035f	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00364	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00371	44 8b 8c 24 a8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00379	44 8b c0	 mov	 r8d, eax
  0037c	b2 07		 mov	 dl, 7
  0037e	48 8d 8c 24 48
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00386	e8 00 00 00 00	 call	 s370_vfetchc

; 2627 :     ARCH_DEP(vfetchc)(countervalue_block, 7, GR_A(r3, regs) & ADDRESS_MAXWRAP(regs), r3, regs);

  0038b	48 63 84 24 b0
	02 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  00393	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003a2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003a7	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003af	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003b4	44 8b 8c 24 b0
	02 00 00	 mov	 r9d, DWORD PTR r3$[rsp]
  003bc	44 8b c0	 mov	 r8d, eax
  003bf	b2 07		 mov	 dl, 7
  003c1	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  003c9	e8 00 00 00 00	 call	 s370_vfetchc

; 2628 : 
; 2629 : #ifdef OPTION_KMCTR_DEBUG
; 2630 :     LOGBYTE("input :", message_block, 8);
; 2631 :     LOGBYTE("cv    :", countervalue_block, 8);
; 2632 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2633 : 
; 2634 :     /* Do the job */
; 2635 :     switch(tfc)

  003ce	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  003d2	89 44 24 44	 mov	 DWORD PTR tv225[rsp], eax
  003d6	83 7c 24 44 01	 cmp	 DWORD PTR tv225[rsp], 1
  003db	74 17		 je	 SHORT $LN19@s370_kmctr
  003dd	83 7c 24 44 02	 cmp	 DWORD PTR tv225[rsp], 2
  003e2	74 32		 je	 SHORT $LN20@s370_kmctr
  003e4	83 7c 24 44 03	 cmp	 DWORD PTR tv225[rsp], 3
  003e9	0f 84 80 00 00
	00		 je	 $LN21@s370_kmctr
  003ef	e9 d2 00 00 00	 jmp	 $LN7@s370_kmctr
$LN19@s370_kmctr:

; 2636 :     {
; 2637 :       /* Encrypt */
; 2638 :       case 1: /* dea */
; 2639 :       {
; 2640 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  003f4	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  003fc	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  00404	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0040c	e8 00 00 00 00	 call	 des_encrypt

; 2641 :         break;

  00411	e9 b0 00 00 00	 jmp	 $LN7@s370_kmctr
$LN20@s370_kmctr:

; 2642 :       }
; 2643 :       case 2: /* tdea-128 */
; 2644 :       {
; 2645 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  00416	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  0041e	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  00426	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0042e	e8 00 00 00 00	 call	 des_encrypt

; 2646 :         des_decrypt(&context2, countervalue_block, countervalue_block);

  00433	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  0043b	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  00443	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0044b	e8 00 00 00 00	 call	 des_decrypt

; 2647 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  00450	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  00458	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  00460	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00468	e8 00 00 00 00	 call	 des_encrypt

; 2648 :         break;

  0046d	eb 57		 jmp	 SHORT $LN7@s370_kmctr
$LN21@s370_kmctr:

; 2649 :       }
; 2650 :       case 3: /* tdea-192 */
; 2651 :       {
; 2652 :         des_encrypt(&context1, countervalue_block, countervalue_block);

  0046f	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  00477	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  0047f	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00487	e8 00 00 00 00	 call	 des_encrypt

; 2653 :         des_decrypt(&context2, countervalue_block, countervalue_block);

  0048c	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  00494	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  0049c	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  004a4	e8 00 00 00 00	 call	 des_decrypt

; 2654 :         des_encrypt(&context3, countervalue_block, countervalue_block);

  004a9	4c 8d 84 24 40
	02 00 00	 lea	 r8, QWORD PTR countervalue_block$[rsp]
  004b1	48 8d 94 24 40
	02 00 00	 lea	 rdx, QWORD PTR countervalue_block$[rsp]
  004b9	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  004c1	e8 00 00 00 00	 call	 des_encrypt
$LN7@s370_kmctr:

; 2655 :         break;
; 2656 :       }
; 2657 :     }
; 2658 : 
; 2659 :     /* XOR */
; 2660 :     for(i = 0; i < 8; i++)

  004c6	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004ce	eb 0a		 jmp	 SHORT $LN11@s370_kmctr
$LN9@s370_kmctr:
  004d0	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004d4	ff c0		 inc	 eax
  004d6	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@s370_kmctr:
  004da	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  004df	7d 2a		 jge	 SHORT $LN10@s370_kmctr

; 2661 :       countervalue_block[i] ^= message_block[i];

  004e1	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004e6	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004eb	0f b6 8c 0c 48
	02 00 00	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  004f3	0f b6 84 04 40
	02 00 00	 movzx	 eax, BYTE PTR countervalue_block$[rsp+rax]
  004fb	33 c1		 xor	 eax, ecx
  004fd	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00502	88 84 0c 40 02
	00 00		 mov	 BYTE PTR countervalue_block$[rsp+rcx], al
  00509	eb c5		 jmp	 SHORT $LN9@s370_kmctr
$LN10@s370_kmctr:

; 2662 : 
; 2663 :     /* Store the output */
; 2664 :     ARCH_DEP(vstorec)(countervalue_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0050b	48 63 84 24 a0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00513	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0051b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00522	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00527	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00534	44 8b 8c 24 a0
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0053c	44 8b c0	 mov	 r8d, eax
  0053f	b2 07		 mov	 dl, 7
  00541	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR countervalue_block$[rsp]
  00549	e8 00 00 00 00	 call	 s370_vstorec

; 2665 : 
; 2666 : #ifdef OPTION_KMCTR_DEBUG
; 2667 :     LOGBYTE("output:", countervalue_block, 8);
; 2668 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2669 : 
; 2670 :     /* Update the registers */
; 2671 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  0054e	48 63 84 24 a0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00556	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055e	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00565	83 c0 08	 add	 eax, 8
  00568	48 63 8c 24 a0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00570	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00578	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2672 :     if(likely(r1_is_not_r2))

  0057f	83 7c 24 7c 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00584	74 0a		 je	 SHORT $LN44@s370_kmctr
  00586	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv288[rsp], 1
  0058e	eb 08		 jmp	 SHORT $LN45@s370_kmctr
$LN44@s370_kmctr:
  00590	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv288[rsp], 0
$LN45@s370_kmctr:
  00598	83 7c 24 6c 00	 cmp	 DWORD PTR tv288[rsp], 0
  0059d	74 31		 je	 SHORT $LN22@s370_kmctr

; 2673 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  0059f	48 63 84 24 a8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005a7	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005af	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005b6	83 c0 08	 add	 eax, 8
  005b9	48 63 8c 24 a8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  005c1	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005c9	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN22@s370_kmctr:

; 2674 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  005d0	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  005d7	ff c0		 inc	 eax
  005d9	48 98		 cdqe
  005db	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  005e3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  005ea	83 e8 08	 sub	 eax, 8
  005ed	8b 8c 24 a8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005f4	ff c1		 inc	 ecx
  005f6	48 63 c9	 movsxd	 rcx, ecx
  005f9	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00601	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2675 :     if(likely(r1_is_not_r3 && r2_is_not_r3))

  00608	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR r1_is_not_r3$[rsp], 0
  00610	74 14		 je	 SHORT $LN46@s370_kmctr
  00612	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR r2_is_not_r3$[rsp], 0
  0061a	74 0a		 je	 SHORT $LN46@s370_kmctr
  0061c	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv321[rsp], 1
  00624	eb 08		 jmp	 SHORT $LN49@s370_kmctr
$LN46@s370_kmctr:
  00626	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv321[rsp], 0
$LN49@s370_kmctr:
  0062e	83 7c 24 70 00	 cmp	 DWORD PTR tv321[rsp], 0
  00633	74 31		 je	 SHORT $LN23@s370_kmctr

; 2676 :       SET_GR_A(r3, regs, GR_A(r3, regs) + 8);

  00635	48 63 84 24 b0
	02 00 00	 movsxd	 rax, DWORD PTR r3$[rsp]
  0063d	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00645	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0064c	83 c0 08	 add	 eax, 8
  0064f	48 63 8c 24 b0
	02 00 00	 movsxd	 rcx, DWORD PTR r3$[rsp]
  00657	48 8b 94 24 b8
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0065f	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN23@s370_kmctr:

; 2677 : 
; 2678 : #ifdef OPTION_KMCTR_DEBUG
; 2679 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2680 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2681 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2682 :     WRMSG(HHC90108, "D", r3, (regs)->GR(r3));
; 2683 : #endif /* #ifdef OPTION_KMCTR_DEBUG */
; 2684 : 
; 2685 :     /* check for end of data */
; 2686 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00666	8b 84 24 a8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0066d	ff c0		 inc	 eax
  0066f	48 98		 cdqe
  00671	48 8b 8c 24 b8
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00679	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00681	75 0a		 jne	 SHORT $LN50@s370_kmctr
  00683	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv341[rsp], 1
  0068b	eb 08		 jmp	 SHORT $LN51@s370_kmctr
$LN50@s370_kmctr:
  0068d	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv341[rsp], 0
$LN51@s370_kmctr:
  00695	83 7c 24 74 00	 cmp	 DWORD PTR tv341[rsp], 0
  0069a	74 0a		 je	 SHORT $LN54@s370_kmctr
  0069c	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv352[rsp], 1
  006a4	eb 08		 jmp	 SHORT $LN55@s370_kmctr
$LN54@s370_kmctr:
  006a6	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv352[rsp], 0
$LN55@s370_kmctr:
  006ae	83 7c 24 78 00	 cmp	 DWORD PTR tv352[rsp], 0
  006b3	74 0e		 je	 SHORT $LN24@s370_kmctr

; 2687 :     {
; 2688 :       regs->psw.cc = 0;

  006b5	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006bd	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2689 :       return;

  006c1	eb 11		 jmp	 SHORT $LN1@s370_kmctr
$LN24@s370_kmctr:

; 2690 :     }
; 2691 :   }

  006c3	e9 67 fc ff ff	 jmp	 $LN4@s370_kmctr
$LN5@s370_kmctr:

; 2692 : 
; 2693 :   /* CPU-determined amount of data processed */
; 2694 :   regs->psw.cc = 3;

  006c8	48 8b 84 24 b8
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006d0	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmctr:

; 2695 : }

  006d4	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  006dc	48 33 cc	 xor	 rcx, rsp
  006df	e8 00 00 00 00	 call	 __security_check_cookie
  006e4	48 81 c4 98 02
	00 00		 add	 rsp, 664		; 00000298H
  006eb	c3		 ret	 0
s370_kmctr_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
crypted$ = 52
tv82 = 56
tv93 = 60
tv136 = 64
tv172 = 68
tv290 = 72
tv323 = 76
tv334 = 80
r1_is_not_r2$ = 84
context1$ = 96
context2$ = 240
context3$ = 384
message_block$ = 528
ocv$ = 536
tcv$ = 544
parameter_block$ = 552
__$ArrayPad$ = 584
r1$ = 608
r2$ = 616
regs$ = 624
s370_kmc_prng PROC

; 2393 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 48
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2394 :   des_context context1;
; 2395 :   des_context context2;
; 2396 :   des_context context3;
; 2397 :   int i;
; 2398 :   int crypted;
; 2399 :   BYTE message_block[8];
; 2400 :   BYTE parameter_block[32];
; 2401 :   BYTE ocv[8];
; 2402 :   BYTE tcv[8];
; 2403 :   int r1_is_not_r2;
; 2404 : 
; 2405 :   /* Check special conditions */
; 2406 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 08 00 00 00	 mov	 ecx, 8
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN18@s370_kmc_p
  0004f	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN19@s370_kmc_p
$LN18@s370_kmc_p:
  00059	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN19@s370_kmc_p:
  00061	83 7c 24 38 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN11@s370_kmc_p

; 2407 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN11@s370_kmc_p:

; 2408 : 
; 2409 :   /* Return with cc 0 on zero length */
; 2410 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN20@s370_kmc_p
  00098	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN21@s370_kmc_p
$LN20@s370_kmc_p:
  000a2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN21@s370_kmc_p:
  000aa	83 7c 24 3c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN24@s370_kmc_p
  000b1	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN25@s370_kmc_p
$LN24@s370_kmc_p:
  000bb	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN25@s370_kmc_p:
  000c3	83 7c 24 40 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN12@s370_kmc_p

; 2411 :   {
; 2412 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2413 :     return;

  000d6	e9 d7 04 00 00	 jmp	 $LN1@s370_kmc_p
$LN12@s370_kmc_p:

; 2414 :   }
; 2415 : 
; 2416 :   /* Test writeability output chaining value */
; 2417 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 01	 imul	 rax, rax, 1
  000e4	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000f8	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00100	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00105	41 b9 02 00 00
	00		 mov	 r9d, 2
  0010b	41 b8 07 00 00
	00		 mov	 r8d, 7
  00111	ba 01 00 00 00	 mov	 edx, 1
  00116	8b c8		 mov	 ecx, eax
  00118	e8 00 00 00 00	 call	 s370_validate_operand

; 2418 : 
; 2419 :   /* Fetch the parameter block */
; 2420 :   ARCH_DEP(vfetchc)(parameter_block, 31, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0011d	b8 08 00 00 00	 mov	 eax, 8
  00122	48 6b c0 01	 imul	 rax, rax, 1
  00126	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0012e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00135	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0013a	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00142	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00147	41 b9 01 00 00
	00		 mov	 r9d, 1
  0014d	44 8b c0	 mov	 r8d, eax
  00150	b2 1f		 mov	 dl, 31
  00152	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0015a	e8 00 00 00 00	 call	 s370_vfetchc

; 2421 : 
; 2422 : #ifdef OPTION_KMC_DEBUG
; 2423 :   LOGBYTE("icv   :", parameter_block, 8);
; 2424 :   LOGBYTE("k1    :", &parameter_block[8], 8);
; 2425 :   LOGBYTE("k2    :", &parameter_block[16], 8);
; 2426 :   LOGBYTE("k3    :", &parameter_block[24], 8);
; 2427 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2428 : 
; 2429 :   /* Set the cryptographic keys */
; 2430 :   des_set_key(&context1, &parameter_block[8]);

  0015f	b8 01 00 00 00	 mov	 eax, 1
  00164	48 6b c0 08	 imul	 rax, rax, 8
  00168	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00170	48 8b d0	 mov	 rdx, rax
  00173	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  00178	e8 00 00 00 00	 call	 des_set_key

; 2431 :   des_set_key(&context2, &parameter_block[16]);

  0017d	b8 01 00 00 00	 mov	 eax, 1
  00182	48 6b c0 10	 imul	 rax, rax, 16
  00186	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0018e	48 8b d0	 mov	 rdx, rax
  00191	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00199	e8 00 00 00 00	 call	 des_set_key

; 2432 :   des_set_key(&context3, &parameter_block[24]);

  0019e	b8 01 00 00 00	 mov	 eax, 1
  001a3	48 6b c0 18	 imul	 rax, rax, 24
  001a7	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  001af	48 8b d0	 mov	 rdx, rax
  001b2	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  001ba	e8 00 00 00 00	 call	 des_set_key

; 2433 : 
; 2434 :   /* Try to process the CPU-determined amount of data */
; 2435 :   r1_is_not_r2 = r1 != r2;

  001bf	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  001c6	39 84 24 60 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  001cd	74 0a		 je	 SHORT $LN26@s370_kmc_p
  001cf	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv172[rsp], 1
  001d7	eb 08		 jmp	 SHORT $LN27@s370_kmc_p
$LN26@s370_kmc_p:
  001d9	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv172[rsp], 0
$LN27@s370_kmc_p:
  001e1	8b 44 24 44	 mov	 eax, DWORD PTR tv172[rsp]
  001e5	89 44 24 54	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2436 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  001e9	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  001f1	eb 0b		 jmp	 SHORT $LN4@s370_kmc_p
$LN2@s370_kmc_p:
  001f3	8b 44 24 34	 mov	 eax, DWORD PTR crypted$[rsp]
  001f7	83 c0 08	 add	 eax, 8
  001fa	89 44 24 34	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s370_kmc_p:
  001fe	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00206	0f 8d 9a 03 00
	00		 jge	 $LN3@s370_kmc_p

; 2437 :   {
; 2438 :     /* Fetch a block of data */
; 2439 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0020c	48 63 84 24 68
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00214	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0021c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00223	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00228	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00230	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00235	44 8b 8c 24 68
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0023d	44 8b c0	 mov	 r8d, eax
  00240	b2 07		 mov	 dl, 7
  00242	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0024a	e8 00 00 00 00	 call	 s370_vfetchc

; 2440 : 
; 2441 : #ifdef OPTION_KMC_DEBUG
; 2442 :     LOGBYTE("input :", message_block, 8);
; 2443 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2444 : 
; 2445 :     /* Do the job */
; 2446 :     des_encrypt(&context1, message_block, message_block);

  0024f	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00257	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0025f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  00264	e8 00 00 00 00	 call	 des_encrypt

; 2447 :     des_decrypt(&context2, message_block, message_block);

  00269	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00271	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00279	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00281	e8 00 00 00 00	 call	 des_decrypt

; 2448 :     des_encrypt(&context3, message_block, message_block);

  00286	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0028e	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00296	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0029e	e8 00 00 00 00	 call	 des_encrypt

; 2449 : 
; 2450 :     /* Save the temporary cv */
; 2451 :     memcpy(tcv, message_block, 8);

  002a3	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  002ab	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR tcv$[rsp], rax

; 2452 : 
; 2453 :     /* XOR */
; 2454 :     for(i = 0; i < 8; i++)

  002b3	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002bb	eb 0a		 jmp	 SHORT $LN7@s370_kmc_p
$LN5@s370_kmc_p:
  002bd	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  002c1	ff c0		 inc	 eax
  002c3	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_kmc_p:
  002c7	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  002cc	7d 2a		 jge	 SHORT $LN6@s370_kmc_p

; 2455 :       message_block[i] ^= parameter_block[i];

  002ce	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  002d3	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  002d8	0f b6 8c 0c 28
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  002e0	0f b6 84 04 10
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  002e8	33 c1		 xor	 eax, ecx
  002ea	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  002ef	88 84 0c 10 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  002f6	eb c5		 jmp	 SHORT $LN5@s370_kmc_p
$LN6@s370_kmc_p:

; 2456 : 
; 2457 :     des_encrypt(&context1, message_block, message_block);

  002f8	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00300	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00308	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  0030d	e8 00 00 00 00	 call	 des_encrypt

; 2458 :     des_decrypt(&context2, message_block, message_block);

  00312	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0031a	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00322	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0032a	e8 00 00 00 00	 call	 des_decrypt

; 2459 :     des_encrypt(&context3, message_block, message_block);

  0032f	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00337	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0033f	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00347	e8 00 00 00 00	 call	 des_encrypt

; 2460 : 
; 2461 :     /* Store the output */
; 2462 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0034c	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00354	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0035c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00363	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00368	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00370	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00375	44 8b 8c 24 60
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0037d	44 8b c0	 mov	 r8d, eax
  00380	b2 07		 mov	 dl, 7
  00382	48 8d 8c 24 10
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0038a	e8 00 00 00 00	 call	 s370_vstorec

; 2463 : 
; 2464 : #ifdef OPTION_KMC_DEBUG
; 2465 :     LOGBYTE("output:", message_block, 8);
; 2466 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2467 : 
; 2468 :     /* XOR */
; 2469 :     for(i = 0; i < 8; i++)

  0038f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00397	eb 0a		 jmp	 SHORT $LN10@s370_kmc_p
$LN8@s370_kmc_p:
  00399	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0039d	ff c0		 inc	 eax
  0039f	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_kmc_p:
  003a3	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  003a8	7d 2a		 jge	 SHORT $LN9@s370_kmc_p

; 2470 :       message_block[i] ^= tcv[i];

  003aa	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003af	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003b4	0f b6 8c 0c 20
	02 00 00	 movzx	 ecx, BYTE PTR tcv$[rsp+rcx]
  003bc	0f b6 84 04 10
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  003c4	33 c1		 xor	 eax, ecx
  003c6	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003cb	88 84 0c 10 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  003d2	eb c5		 jmp	 SHORT $LN8@s370_kmc_p
$LN9@s370_kmc_p:

; 2471 : 
; 2472 :     des_encrypt(&context1, message_block, message_block);

  003d4	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003dc	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003e4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context1$[rsp]
  003e9	e8 00 00 00 00	 call	 des_encrypt

; 2473 :     des_decrypt(&context2, message_block, message_block);

  003ee	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003f6	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003fe	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00406	e8 00 00 00 00	 call	 des_decrypt

; 2474 :     des_encrypt(&context3, message_block, message_block);

  0040b	4c 8d 84 24 10
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00413	48 8d 94 24 10
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0041b	48 8d 8c 24 80
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00423	e8 00 00 00 00	 call	 des_encrypt

; 2475 : 
; 2476 :     /* Save the ocv */
; 2477 :     memcpy(ocv, message_block, 8);

  00428	48 8b 84 24 10
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00430	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2478 : 
; 2479 :     /* Store the output chaining value */
; 2480 :     ARCH_DEP(vstorec)(ocv, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00438	b8 08 00 00 00	 mov	 eax, 8
  0043d	48 6b c0 01	 imul	 rax, rax, 1
  00441	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00449	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00450	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00455	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0045d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00462	41 b9 01 00 00
	00		 mov	 r9d, 1
  00468	44 8b c0	 mov	 r8d, eax
  0046b	b2 07		 mov	 dl, 7
  0046d	48 8d 8c 24 18
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  00475	e8 00 00 00 00	 call	 s370_vstorec

; 2481 : 
; 2482 : #ifdef OPTION_KMC_DEBUG
; 2483 :     LOGBYTE("ocv   :", ocv, 8);
; 2484 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2485 : 
; 2486 :     /* Update the registers */
; 2487 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  0047a	48 63 84 24 60
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00482	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0048a	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00491	83 c0 08	 add	 eax, 8
  00494	48 63 8c 24 60
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0049c	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004a4	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2488 :     if(likely(r1_is_not_r2))

  004ab	83 7c 24 54 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  004b0	74 0a		 je	 SHORT $LN28@s370_kmc_p
  004b2	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv290[rsp], 1
  004ba	eb 08		 jmp	 SHORT $LN29@s370_kmc_p
$LN28@s370_kmc_p:
  004bc	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv290[rsp], 0
$LN29@s370_kmc_p:
  004c4	83 7c 24 48 00	 cmp	 DWORD PTR tv290[rsp], 0
  004c9	74 31		 je	 SHORT $LN13@s370_kmc_p

; 2489 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  004cb	48 63 84 24 68
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004d3	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004db	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004e2	83 c0 08	 add	 eax, 8
  004e5	48 63 8c 24 68
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  004ed	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004f5	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN13@s370_kmc_p:

; 2490 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  004fc	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00503	ff c0		 inc	 eax
  00505	48 98		 cdqe
  00507	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00516	83 e8 08	 sub	 eax, 8
  00519	8b 8c 24 68 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00520	ff c1		 inc	 ecx
  00522	48 63 c9	 movsxd	 rcx, ecx
  00525	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0052d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2491 : 
; 2492 : #ifdef OPTION_KMC_DEBUG
; 2493 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2494 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2495 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2496 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2497 : 
; 2498 :     /* check for end of data */
; 2499 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00534	8b 84 24 68 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0053b	ff c0		 inc	 eax
  0053d	48 98		 cdqe
  0053f	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00547	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0054f	75 0a		 jne	 SHORT $LN30@s370_kmc_p
  00551	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv323[rsp], 1
  00559	eb 08		 jmp	 SHORT $LN31@s370_kmc_p
$LN30@s370_kmc_p:
  0055b	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv323[rsp], 0
$LN31@s370_kmc_p:
  00563	83 7c 24 4c 00	 cmp	 DWORD PTR tv323[rsp], 0
  00568	74 0a		 je	 SHORT $LN34@s370_kmc_p
  0056a	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv334[rsp], 1
  00572	eb 08		 jmp	 SHORT $LN35@s370_kmc_p
$LN34@s370_kmc_p:
  00574	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv334[rsp], 0
$LN35@s370_kmc_p:
  0057c	83 7c 24 50 00	 cmp	 DWORD PTR tv334[rsp], 0
  00581	74 0e		 je	 SHORT $LN14@s370_kmc_p

; 2500 :     {
; 2501 :       regs->psw.cc = 0;

  00583	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0058b	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2502 :       return;

  0058f	eb 21		 jmp	 SHORT $LN1@s370_kmc_p
$LN14@s370_kmc_p:

; 2503 :     }
; 2504 : 
; 2505 :     /* Set cv for next 8 bytes */
; 2506 :     memcpy(parameter_block, ocv, 8);

  00591	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR ocv$[rsp]
  00599	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR parameter_block$[rsp], rax

; 2507 :   }

  005a1	e9 4d fc ff ff	 jmp	 $LN2@s370_kmc_p
$LN3@s370_kmc_p:

; 2508 : 
; 2509 :   /* CPU-determined amount of data processed */
; 2510 :   regs->psw.cc = 3;

  005a6	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ae	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmc_p:

; 2511 : }

  005b2	48 8b 8c 24 48
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005ba	48 33 cc	 xor	 rcx, rsp
  005bd	e8 00 00 00 00	 call	 __security_check_cookie
  005c2	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  005c9	c3		 ret	 0
s370_kmc_prng ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv82 = 64
tv93 = 68
tv136 = 72
tv151 = 76
wrap$ = 80
tv200 = 84
tv202 = 88
tv300 = 92
tv333 = 96
tv344 = 100
tfc$ = 104
modifier_bit$ = 108
r1_is_not_r2$ = 112
context$ = 128
message_block$ = 624
ocv$ = 640
parameter_block$ = 656
__$ArrayPad$ = 736
r1$ = 784
r2$ = 792
regs$ = 800
s370_kmc_aes PROC

; 2252 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 e0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2253 :   rijndael_ctx context;
; 2254 :   int crypted;
; 2255 :   int i;
; 2256 :   int keylen;
; 2257 :   BYTE message_block[16];
; 2258 :   int modifier_bit;
; 2259 :   BYTE ocv[16];
; 2260 :   BYTE parameter_block[80];
; 2261 :   int parameter_blocklen;
; 2262 :   int r1_is_not_r2;
; 2263 :   int tfc;
; 2264 :   int wrap;
; 2265 : 
; 2266 :   /* Check special conditions */
; 2267 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00028	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002f	ff c0		 inc	 eax
  00031	48 98		 cdqe
  00033	33 d2		 xor	 edx, edx
  00035	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00044	b9 10 00 00 00	 mov	 ecx, 16
  00049	f7 f1		 div	 ecx
  0004b	8b c2		 mov	 eax, edx
  0004d	85 c0		 test	 eax, eax
  0004f	74 0a		 je	 SHORT $LN22@s370_kmc_a
  00051	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00059	eb 08		 jmp	 SHORT $LN23@s370_kmc_a
$LN22@s370_kmc_a:
  0005b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN23@s370_kmc_a:
  00063	83 7c 24 40 00	 cmp	 DWORD PTR tv82[rsp], 0
  00068	74 13		 je	 SHORT $LN11@s370_kmc_a

; 2268 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006a	ba 06 00 00 00	 mov	 edx, 6
  0006f	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN11@s370_kmc_a:

; 2269 : 
; 2270 :   /* Return with cc 0 on zero length */
; 2271 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007d	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00084	ff c0		 inc	 eax
  00086	48 98		 cdqe
  00088	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00090	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00098	75 0a		 jne	 SHORT $LN24@s370_kmc_a
  0009a	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a2	eb 08		 jmp	 SHORT $LN25@s370_kmc_a
$LN24@s370_kmc_a:
  000a4	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN25@s370_kmc_a:
  000ac	83 7c 24 44 00	 cmp	 DWORD PTR tv93[rsp], 0
  000b1	74 0a		 je	 SHORT $LN28@s370_kmc_a
  000b3	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000bb	eb 08		 jmp	 SHORT $LN29@s370_kmc_a
$LN28@s370_kmc_a:
  000bd	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN29@s370_kmc_a:
  000c5	83 7c 24 48 00	 cmp	 DWORD PTR tv136[rsp], 0
  000ca	74 11		 je	 SHORT $LN12@s370_kmc_a

; 2272 :   {
; 2273 :     regs->psw.cc = 0;

  000cc	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d4	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2274 :     return;

  000d8	e9 16 05 00 00	 jmp	 $LN1@s370_kmc_a
$LN12@s370_kmc_a:

; 2275 :   }
; 2276 : 
; 2277 :   /* Initialize values */
; 2278 :   tfc = GR0_tfc(regs);

  000dd	b8 08 00 00 00	 mov	 eax, 8
  000e2	48 6b c0 00	 imul	 rax, rax, 0
  000e6	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ee	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f5	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f8	83 e0 77	 and	 eax, 119		; 00000077H
  000fb	89 44 24 68	 mov	 DWORD PTR tfc$[rsp], eax

; 2279 :   wrap = GR0_wrap(regs);

  000ff	b8 08 00 00 00	 mov	 eax, 8
  00104	48 6b c0 00	 imul	 rax, rax, 0
  00108	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00110	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00117	83 e0 08	 and	 eax, 8
  0011a	85 c0		 test	 eax, eax
  0011c	74 0a		 je	 SHORT $LN30@s370_kmc_a
  0011e	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00126	eb 08		 jmp	 SHORT $LN31@s370_kmc_a
$LN30@s370_kmc_a:
  00128	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN31@s370_kmc_a:
  00130	8b 44 24 4c	 mov	 eax, DWORD PTR tv151[rsp]
  00134	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 2280 :   keylen = (tfc - 17) * 8 + 8;

  00138	8b 44 24 68	 mov	 eax, DWORD PTR tfc$[rsp]
  0013c	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00143	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 2281 :   parameter_blocklen = keylen + 16;

  00147	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0014b	83 c0 10	 add	 eax, 16
  0014e	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2282 :   if(wrap)

  00152	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00157	74 0b		 je	 SHORT $LN13@s370_kmc_a

; 2283 :     parameter_blocklen += 32;

  00159	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0015d	83 c0 20	 add	 eax, 32			; 00000020H
  00160	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN13@s370_kmc_a:

; 2284 : 
; 2285 :   /* Test writeability output chaining value */
; 2286 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  00164	b8 08 00 00 00	 mov	 eax, 8
  00169	48 6b c0 01	 imul	 rax, rax, 1
  0016d	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00181	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0018e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00194	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0019a	ba 01 00 00 00	 mov	 edx, 1
  0019f	8b c8		 mov	 ecx, eax
  001a1	e8 00 00 00 00	 call	 s370_validate_operand

; 2287 : 
; 2288 :   /* Fetch the parameter block */
; 2289 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001a6	b8 08 00 00 00	 mov	 eax, 8
  001ab	48 6b c0 01	 imul	 rax, rax, 1
  001af	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001be	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001c3	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001c7	ff c9		 dec	 ecx
  001c9	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001d6	41 b9 01 00 00
	00		 mov	 r9d, 1
  001dc	44 8b c0	 mov	 r8d, eax
  001df	0f b6 d1	 movzx	 edx, cl
  001e2	48 8d 8c 24 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001ea	e8 00 00 00 00	 call	 s370_vfetchc

; 2290 : 
; 2291 : #ifdef OPTION_KMC_DEBUG
; 2292 :   LOGBYTE("icv   :", parameter_block, 16);
; 2293 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 2294 :   if(wrap)
; 2295 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 16], 32);
; 2296 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2297 : 
; 2298 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 2299 :   /* Verify and unwrap */
; 2300 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  001ef	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001f4	74 32		 je	 SHORT $LN14@s370_kmc_a
  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	48 6b c0 10	 imul	 rax, rax, 16
  001ff	48 8d 84 04 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00207	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  0020b	48 8b c8	 mov	 rcx, rax
  0020e	e8 00 00 00 00	 call	 unwrap_aes
  00213	85 c0		 test	 eax, eax
  00215	74 11		 je	 SHORT $LN14@s370_kmc_a

; 2301 :   {
; 2302 : 
; 2303 : #ifdef OPTION_KM_DEBUG
; 2304 :     WRMSG(HHC90111, "D");
; 2305 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2306 : 
; 2307 :     regs->psw.cc = 1;

  00217	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021f	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2308 :     return;

  00223	e9 cb 03 00 00	 jmp	 $LN1@s370_kmc_a
$LN14@s370_kmc_a:

; 2309 :   }
; 2310 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 2311 : 
; 2312 :   /* Set the cryptographic key */
; 2313 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  00228	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0022c	c1 e0 03	 shl	 eax, 3
  0022f	b9 01 00 00 00	 mov	 ecx, 1
  00234	48 6b c9 10	 imul	 rcx, rcx, 16
  00238	48 8d 8c 0c 90
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00240	44 8b c0	 mov	 r8d, eax
  00243	48 8b d1	 mov	 rdx, rcx
  00246	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0024e	e8 00 00 00 00	 call	 rijndael_set_key

; 2314 : 
; 2315 :   /* Try to process the CPU-determined amount of data */
; 2316 :   modifier_bit = GR0_m(regs);

  00253	b8 08 00 00 00	 mov	 eax, 8
  00258	48 6b c0 00	 imul	 rax, rax, 0
  0025c	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00264	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0026b	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00270	85 c0		 test	 eax, eax
  00272	74 0a		 je	 SHORT $LN32@s370_kmc_a
  00274	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  0027c	eb 08		 jmp	 SHORT $LN33@s370_kmc_a
$LN32@s370_kmc_a:
  0027e	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv200[rsp], 0
$LN33@s370_kmc_a:
  00286	8b 44 24 54	 mov	 eax, DWORD PTR tv200[rsp]
  0028a	89 44 24 6c	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2317 :   r1_is_not_r2 = r1 != r2;

  0028e	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00295	39 84 24 10 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0029c	74 0a		 je	 SHORT $LN34@s370_kmc_a
  0029e	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  002a6	eb 08		 jmp	 SHORT $LN35@s370_kmc_a
$LN34@s370_kmc_a:
  002a8	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN35@s370_kmc_a:
  002b0	8b 44 24 58	 mov	 eax, DWORD PTR tv202[rsp]
  002b4	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2318 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  002b8	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  002c0	eb 0b		 jmp	 SHORT $LN4@s370_kmc_a
$LN2@s370_kmc_a:
  002c2	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  002c6	83 c0 10	 add	 eax, 16
  002c9	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s370_kmc_a:
  002cd	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  002d5	0f 8d 0c 03 00
	00		 jge	 $LN3@s370_kmc_a

; 2319 :   {
; 2320 :     /* Fetch a block of data */
; 2321 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  002db	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002e3	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002eb	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002f2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002f7	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ff	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00304	44 8b 8c 24 18
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  0030c	44 8b c0	 mov	 r8d, eax
  0030f	b2 0f		 mov	 dl, 15
  00311	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00319	e8 00 00 00 00	 call	 s370_vfetchc

; 2322 : 
; 2323 : #ifdef OPTION_KMC_DEBUG
; 2324 :     LOGBYTE("input :", message_block, 16);
; 2325 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2326 : 
; 2327 :     /* Do the job */
; 2328 :     if(modifier_bit)

  0031e	83 7c 24 6c 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  00323	0f 84 81 00 00
	00		 je	 $LN15@s370_kmc_a

; 2329 :     {
; 2330 : 
; 2331 :       /* Save, decrypt and XOR */
; 2332 :       memcpy(ocv, message_block, 16);

  00329	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR ocv$[rsp]
  00331	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00339	48 8b f8	 mov	 rdi, rax
  0033c	48 8b f1	 mov	 rsi, rcx
  0033f	b9 10 00 00 00	 mov	 ecx, 16
  00344	f3 a4		 rep movsb

; 2333 :       rijndael_decrypt(&context, message_block, message_block);

  00346	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0034e	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00356	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  0035e	e8 00 00 00 00	 call	 rijndael_decrypt

; 2334 :       for(i = 0; i < 16; i++)

  00363	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0036b	eb 0a		 jmp	 SHORT $LN7@s370_kmc_a
$LN5@s370_kmc_a:
  0036d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00371	ff c0		 inc	 eax
  00373	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_kmc_a:
  00377	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  0037c	7d 2a		 jge	 SHORT $LN6@s370_kmc_a

; 2335 :         message_block[i] ^= parameter_block[i];

  0037e	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00383	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00388	0f b6 8c 0c 90
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00390	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00398	33 c1		 xor	 eax, ecx
  0039a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0039f	88 84 0c 70 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  003a6	eb c5		 jmp	 SHORT $LN5@s370_kmc_a
$LN6@s370_kmc_a:

; 2336 :     }

  003a8	eb 7f		 jmp	 SHORT $LN16@s370_kmc_a
$LN15@s370_kmc_a:

; 2337 :     else
; 2338 :     {
; 2339 :       /* XOR, encrypt and save */
; 2340 :       for(i = 0; i < 16; i++)

  003aa	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003b2	eb 0a		 jmp	 SHORT $LN10@s370_kmc_a
$LN8@s370_kmc_a:
  003b4	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003b8	ff c0		 inc	 eax
  003ba	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_kmc_a:
  003be	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  003c3	7d 2a		 jge	 SHORT $LN9@s370_kmc_a

; 2341 :         message_block[i] ^= parameter_block[i];

  003c5	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003ca	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003cf	0f b6 8c 0c 90
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003d7	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  003df	33 c1		 xor	 eax, ecx
  003e1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003e6	88 84 0c 70 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  003ed	eb c5		 jmp	 SHORT $LN8@s370_kmc_a
$LN9@s370_kmc_a:

; 2342 :       rijndael_encrypt(&context, message_block, message_block);

  003ef	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003f7	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003ff	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00407	e8 00 00 00 00	 call	 rijndael_encrypt

; 2343 :       memcpy(ocv, message_block, 16);

  0040c	48 8d 84 24 80
	02 00 00	 lea	 rax, QWORD PTR ocv$[rsp]
  00414	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0041c	48 8b f8	 mov	 rdi, rax
  0041f	48 8b f1	 mov	 rsi, rcx
  00422	b9 10 00 00 00	 mov	 ecx, 16
  00427	f3 a4		 rep movsb
$LN16@s370_kmc_a:

; 2344 :     }
; 2345 : 
; 2346 :     /* Store the output */
; 2347 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  00429	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00431	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00439	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00440	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00445	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0044d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00452	44 8b 8c 24 10
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0045a	44 8b c0	 mov	 r8d, eax
  0045d	b2 0f		 mov	 dl, 15
  0045f	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00467	e8 00 00 00 00	 call	 s370_vstorec

; 2348 : 
; 2349 : #ifdef OPTION_KMC_DEBUG
; 2350 :     LOGBYTE("output:", message_block, 16);
; 2351 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2352 : 
; 2353 :     /* Store the output chaining value */
; 2354 :     ARCH_DEP(vstorec)(ocv, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0046c	b8 08 00 00 00	 mov	 eax, 8
  00471	48 6b c0 01	 imul	 rax, rax, 1
  00475	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047d	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00484	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00489	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00491	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00496	41 b9 01 00 00
	00		 mov	 r9d, 1
  0049c	44 8b c0	 mov	 r8d, eax
  0049f	b2 0f		 mov	 dl, 15
  004a1	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  004a9	e8 00 00 00 00	 call	 s370_vstorec

; 2355 : 
; 2356 : #ifdef OPTION_KMC_DEBUG
; 2357 :     LOGBYTE("ocv   :", ocv, 16);
; 2358 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2359 : 
; 2360 :     /* Update the registers */
; 2361 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  004ae	48 63 84 24 10
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  004b6	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004be	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004c5	83 c0 10	 add	 eax, 16
  004c8	48 63 8c 24 10
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  004d0	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004d8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2362 :     if(likely(r1_is_not_r2))

  004df	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  004e4	74 0a		 je	 SHORT $LN36@s370_kmc_a
  004e6	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv300[rsp], 1
  004ee	eb 08		 jmp	 SHORT $LN37@s370_kmc_a
$LN36@s370_kmc_a:
  004f0	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv300[rsp], 0
$LN37@s370_kmc_a:
  004f8	83 7c 24 5c 00	 cmp	 DWORD PTR tv300[rsp], 0
  004fd	74 31		 je	 SHORT $LN17@s370_kmc_a

; 2363 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  004ff	48 63 84 24 18
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00507	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0050f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00516	83 c0 10	 add	 eax, 16
  00519	48 63 8c 24 18
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00521	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00529	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN17@s370_kmc_a:

; 2364 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00530	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00537	ff c0		 inc	 eax
  00539	48 98		 cdqe
  0053b	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00543	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0054a	83 e8 10	 sub	 eax, 16
  0054d	8b 8c 24 18 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00554	ff c1		 inc	 ecx
  00556	48 63 c9	 movsxd	 rcx, ecx
  00559	48 8b 94 24 20
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00561	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2365 : 
; 2366 : #ifdef OPTION_KMC_DEBUG
; 2367 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2368 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2369 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2370 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2371 : 
; 2372 :     /* check for end of data */
; 2373 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00568	8b 84 24 18 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0056f	ff c0		 inc	 eax
  00571	48 98		 cdqe
  00573	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0057b	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00583	75 0a		 jne	 SHORT $LN38@s370_kmc_a
  00585	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv333[rsp], 1
  0058d	eb 08		 jmp	 SHORT $LN39@s370_kmc_a
$LN38@s370_kmc_a:
  0058f	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv333[rsp], 0
$LN39@s370_kmc_a:
  00597	83 7c 24 60 00	 cmp	 DWORD PTR tv333[rsp], 0
  0059c	74 0a		 je	 SHORT $LN42@s370_kmc_a
  0059e	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv344[rsp], 1
  005a6	eb 08		 jmp	 SHORT $LN43@s370_kmc_a
$LN42@s370_kmc_a:
  005a8	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv344[rsp], 0
$LN43@s370_kmc_a:
  005b0	83 7c 24 64 00	 cmp	 DWORD PTR tv344[rsp], 0
  005b5	74 0e		 je	 SHORT $LN18@s370_kmc_a

; 2374 :     {
; 2375 :       regs->psw.cc = 0;

  005b7	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bf	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2376 :       return;

  005c3	eb 2e		 jmp	 SHORT $LN1@s370_kmc_a
$LN18@s370_kmc_a:

; 2377 :     }
; 2378 : 
; 2379 :     /* Set cv for next 16 bytes */
; 2380 :     memcpy(parameter_block, ocv, 16);

  005c5	48 8d 84 24 90
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp]
  005cd	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  005d5	48 8b f8	 mov	 rdi, rax
  005d8	48 8b f1	 mov	 rsi, rcx
  005db	b9 10 00 00 00	 mov	 ecx, 16
  005e0	f3 a4		 rep movsb

; 2381 :   }

  005e2	e9 db fc ff ff	 jmp	 $LN2@s370_kmc_a
$LN3@s370_kmc_a:

; 2382 : 
; 2383 :   /* CPU-determined amount of data processed */
; 2384 :   regs->psw.cc = 3;

  005e7	48 8b 84 24 20
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ef	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmc_a:

; 2385 : }

  005f3	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005fb	48 33 cc	 xor	 rcx, rsp
  005fe	e8 00 00 00 00	 call	 __security_check_cookie
  00603	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  0060a	5f		 pop	 rdi
  0060b	5e		 pop	 rsi
  0060c	c3		 ret	 0
s370_kmc_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv186 = 56
crypted$ = 60
tfc$ = 64
tv236 = 68
modifier_bit$ = 72
tv82 = 76
tv93 = 80
tv136 = 84
tv151 = 88
wrap$ = 92
keylen$ = 96
tv220 = 100
tv222 = 104
tv450 = 108
tv483 = 112
tv494 = 116
r1_is_not_r2$ = 120
context1$ = 128
context2$ = 272
context3$ = 416
message_block$ = 560
ocv$ = 568
parameter_block$ = 576
__$ArrayPad$ = 632
r1$ = 656
r2$ = 664
regs$ = 672
s370_kmc_dea PROC

; 2016 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 78
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2017 :   des_context context1;
; 2018 :   des_context context2;
; 2019 :   des_context context3;
; 2020 :   int crypted;
; 2021 :   int i;
; 2022 :   int keylen;
; 2023 :   BYTE message_block[8];
; 2024 :   int modifier_bit;
; 2025 :   BYTE ocv[8];
; 2026 :   BYTE parameter_block[56];
; 2027 :   int parameter_blocklen;
; 2028 :   int r1_is_not_r2;
; 2029 :   int tfc;
; 2030 :   int wrap;
; 2031 : 
; 2032 :   /* Check special conditions */
; 2033 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 08 00 00 00	 mov	 ecx, 8
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN48@s370_kmc_d
  0004f	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN49@s370_kmc_d
$LN48@s370_kmc_d:
  00059	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN49@s370_kmc_d:
  00061	83 7c 24 4c 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN27@s370_kmc_d

; 2034 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN27@s370_kmc_d:

; 2035 : 
; 2036 :   /* Return with cc 0 on zero length */
; 2037 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN50@s370_kmc_d
  00098	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN51@s370_kmc_d
$LN50@s370_kmc_d:
  000a2	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN51@s370_kmc_d:
  000aa	83 7c 24 50 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN54@s370_kmc_d
  000b1	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN55@s370_kmc_d
$LN54@s370_kmc_d:
  000bb	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN55@s370_kmc_d:
  000c3	83 7c 24 54 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN28@s370_kmc_d

; 2038 :   {
; 2039 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2040 :     return;

  000d6	e9 af 08 00 00	 jmp	 $LN1@s370_kmc_d
$LN28@s370_kmc_d:

; 2041 :   }
; 2042 : 
; 2043 :   /* Initialize values */
; 2044 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 2045 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN56@s370_kmc_d
  0011c	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN57@s370_kmc_d
$LN56@s370_kmc_d:
  00126	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN57@s370_kmc_d:
  0012e	8b 44 24 58	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 5c	 mov	 DWORD PTR wrap$[rsp], eax

; 2046 :   keylen = tfc * 8;

  00136	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	c1 e0 03	 shl	 eax, 3
  0013d	89 44 24 60	 mov	 DWORD PTR keylen$[rsp], eax

; 2047 :   parameter_blocklen = keylen + 8;

  00141	8b 44 24 60	 mov	 eax, DWORD PTR keylen$[rsp]
  00145	83 c0 08	 add	 eax, 8
  00148	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 2048 :   if(wrap)

  0014c	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00151	74 0b		 je	 SHORT $LN29@s370_kmc_d

; 2049 :     parameter_blocklen += 24;

  00153	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00157	83 c0 18	 add	 eax, 24
  0015a	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN29@s370_kmc_d:

; 2050 : 
; 2051 :   /* Test writeability output chaining value */
; 2052 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  0015e	b8 08 00 00 00	 mov	 eax, 8
  00163	48 6b c0 01	 imul	 rax, rax, 1
  00167	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016f	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00176	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0017b	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00183	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00188	41 b9 02 00 00
	00		 mov	 r9d, 2
  0018e	41 b8 07 00 00
	00		 mov	 r8d, 7
  00194	ba 01 00 00 00	 mov	 edx, 1
  00199	8b c8		 mov	 ecx, eax
  0019b	e8 00 00 00 00	 call	 s370_validate_operand

; 2053 : 
; 2054 :   /* Fetch the parameter block */
; 2055 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001a0	b8 08 00 00 00	 mov	 eax, 8
  001a5	48 6b c0 01	 imul	 rax, rax, 1
  001a9	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b1	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001b8	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001bd	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001c1	ff c9		 dec	 ecx
  001c3	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001cb	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001d0	41 b9 01 00 00
	00		 mov	 r9d, 1
  001d6	44 8b c0	 mov	 r8d, eax
  001d9	0f b6 d1	 movzx	 edx, cl
  001dc	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001e4	e8 00 00 00 00	 call	 s370_vfetchc

; 2056 : 
; 2057 : #ifdef OPTION_KMC_DEBUG
; 2058 :   LOGBYTE("icv   :", parameter_block, 8);
; 2059 :   switch(tfc)
; 2060 :   {
; 2061 :     case 1: /* dea */
; 2062 :     {
; 2063 :       LOGBYTE("k     :", &parameter_block[8], 8);
; 2064 :       break;
; 2065 :     }
; 2066 :     case 2: /* tdea-128 */
; 2067 :     {
; 2068 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2069 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2070 :       break;
; 2071 :     }
; 2072 :     case 3: /* tdea-192 */
; 2073 :     {
; 2074 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 2075 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 2076 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 2077 :       break;
; 2078 :     }
; 2079 :   }
; 2080 :   if(wrap)
; 2081 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 2082 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2083 : 
; 2084 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 2085 :   /* Verify and unwrap */
; 2086 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  001e9	83 7c 24 5c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001ee	74 32		 je	 SHORT $LN30@s370_kmc_d
  001f0	b8 01 00 00 00	 mov	 eax, 1
  001f5	48 6b c0 08	 imul	 rax, rax, 8
  001f9	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00201	8b 54 24 60	 mov	 edx, DWORD PTR keylen$[rsp]
  00205	48 8b c8	 mov	 rcx, rax
  00208	e8 00 00 00 00	 call	 unwrap_dea
  0020d	85 c0		 test	 eax, eax
  0020f	74 11		 je	 SHORT $LN30@s370_kmc_d

; 2087 :   {
; 2088 : 
; 2089 : #ifdef OPTION_KMC_DEBUG
; 2090 :     WRMSG(HHC90111, "D");
; 2091 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2092 : 
; 2093 :     regs->psw.cc = 1;

  00211	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00219	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 2094 :     return;

  0021d	e9 68 07 00 00	 jmp	 $LN1@s370_kmc_d
$LN30@s370_kmc_d:

; 2095 :   }
; 2096 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 2097 : 
; 2098 :   /* Set the cryptographic key */
; 2099 :   switch(tfc)

  00222	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00226	89 44 24 38	 mov	 DWORD PTR tv186[rsp], eax
  0022a	83 7c 24 38 01	 cmp	 DWORD PTR tv186[rsp], 1
  0022f	74 13		 je	 SHORT $LN31@s370_kmc_d
  00231	83 7c 24 38 02	 cmp	 DWORD PTR tv186[rsp], 2
  00236	74 32		 je	 SHORT $LN32@s370_kmc_d
  00238	83 7c 24 38 03	 cmp	 DWORD PTR tv186[rsp], 3
  0023d	74 6f		 je	 SHORT $LN33@s370_kmc_d
  0023f	e9 cd 00 00 00	 jmp	 $LN2@s370_kmc_d
$LN31@s370_kmc_d:

; 2100 :   {
; 2101 :     case 1: /* dea */
; 2102 :     {
; 2103 :       des_set_key(&context1, &parameter_block[8]);

  00244	b8 01 00 00 00	 mov	 eax, 1
  00249	48 6b c0 08	 imul	 rax, rax, 8
  0024d	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00255	48 8b d0	 mov	 rdx, rax
  00258	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00260	e8 00 00 00 00	 call	 des_set_key

; 2104 :       break;

  00265	e9 a7 00 00 00	 jmp	 $LN2@s370_kmc_d
$LN32@s370_kmc_d:

; 2105 :     }
; 2106 :     case 2: /* tdea-128 */
; 2107 :     {
; 2108 :       des_set_key(&context1, &parameter_block[8]);

  0026a	b8 01 00 00 00	 mov	 eax, 1
  0026f	48 6b c0 08	 imul	 rax, rax, 8
  00273	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0027b	48 8b d0	 mov	 rdx, rax
  0027e	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00286	e8 00 00 00 00	 call	 des_set_key

; 2109 :       des_set_key(&context2, &parameter_block[16]);

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	48 6b c0 10	 imul	 rax, rax, 16
  00294	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0029c	48 8b d0	 mov	 rdx, rax
  0029f	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002a7	e8 00 00 00 00	 call	 des_set_key

; 2110 :       break;

  002ac	eb 63		 jmp	 SHORT $LN2@s370_kmc_d
$LN33@s370_kmc_d:

; 2111 :     }
; 2112 :     case 3: /* tdea-192 */
; 2113 :     {
; 2114 :       des_set_key(&context1, &parameter_block[8]);

  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	48 6b c0 08	 imul	 rax, rax, 8
  002b7	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002bf	48 8b d0	 mov	 rdx, rax
  002c2	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  002ca	e8 00 00 00 00	 call	 des_set_key

; 2115 :       des_set_key(&context2, &parameter_block[16]);

  002cf	b8 01 00 00 00	 mov	 eax, 1
  002d4	48 6b c0 10	 imul	 rax, rax, 16
  002d8	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002e0	48 8b d0	 mov	 rdx, rax
  002e3	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002eb	e8 00 00 00 00	 call	 des_set_key

; 2116 :       des_set_key(&context3, &parameter_block[24]);

  002f0	b8 01 00 00 00	 mov	 eax, 1
  002f5	48 6b c0 18	 imul	 rax, rax, 24
  002f9	48 8d 84 04 40
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00301	48 8b d0	 mov	 rdx, rax
  00304	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0030c	e8 00 00 00 00	 call	 des_set_key
$LN2@s370_kmc_d:

; 2117 :       break;
; 2118 :     }
; 2119 :   }
; 2120 : 
; 2121 :   /* Try to process the CPU-determined amount of data */
; 2122 :   modifier_bit = GR0_m(regs);

  00311	b8 08 00 00 00	 mov	 eax, 8
  00316	48 6b c0 00	 imul	 rax, rax, 0
  0031a	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00322	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00329	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0032e	85 c0		 test	 eax, eax
  00330	74 0a		 je	 SHORT $LN58@s370_kmc_d
  00332	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv220[rsp], 1
  0033a	eb 08		 jmp	 SHORT $LN59@s370_kmc_d
$LN58@s370_kmc_d:
  0033c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv220[rsp], 0
$LN59@s370_kmc_d:
  00344	8b 44 24 64	 mov	 eax, DWORD PTR tv220[rsp]
  00348	89 44 24 48	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 2123 :   r1_is_not_r2 = r1 != r2;

  0034c	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00353	39 84 24 90 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0035a	74 0a		 je	 SHORT $LN60@s370_kmc_d
  0035c	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv222[rsp], 1
  00364	eb 08		 jmp	 SHORT $LN61@s370_kmc_d
$LN60@s370_kmc_d:
  00366	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv222[rsp], 0
$LN61@s370_kmc_d:
  0036e	8b 44 24 68	 mov	 eax, DWORD PTR tv222[rsp]
  00372	89 44 24 78	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 2124 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  00376	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0037e	eb 0b		 jmp	 SHORT $LN6@s370_kmc_d
$LN4@s370_kmc_d:
  00380	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00384	83 c0 08	 add	 eax, 8
  00387	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@s370_kmc_d:
  0038b	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00393	0f 8d e5 05 00
	00		 jge	 $LN5@s370_kmc_d

; 2125 :   {
; 2126 :     /* Fetch a block of data */
; 2127 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00399	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003a1	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003a9	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003b0	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  003b5	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003bd	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  003c2	44 8b 8c 24 98
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  003ca	44 8b c0	 mov	 r8d, eax
  003cd	b2 07		 mov	 dl, 7
  003cf	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  003d7	e8 00 00 00 00	 call	 s370_vfetchc

; 2128 : 
; 2129 : #ifdef OPTION_KMC_DEBUG
; 2130 :     LOGBYTE("input :", message_block, 8);
; 2131 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2132 : 
; 2133 :     /* Do the job */
; 2134 :     switch(tfc)

  003dc	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  003e0	89 44 24 44	 mov	 DWORD PTR tv236[rsp], eax
  003e4	83 7c 24 44 01	 cmp	 DWORD PTR tv236[rsp], 1
  003e9	74 1b		 je	 SHORT $LN34@s370_kmc_d
  003eb	83 7c 24 44 02	 cmp	 DWORD PTR tv236[rsp], 2
  003f0	0f 84 02 01 00
	00		 je	 $LN37@s370_kmc_d
  003f6	83 7c 24 44 03	 cmp	 DWORD PTR tv236[rsp], 3
  003fb	0f 84 64 02 00
	00		 je	 $LN40@s370_kmc_d
  00401	e9 c7 03 00 00	 jmp	 $LN7@s370_kmc_d
$LN34@s370_kmc_d:

; 2135 :     {
; 2136 :       case 1: /* dea */
; 2137 :       {
; 2138 :         if(modifier_bit)

  00406	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0040b	74 74		 je	 SHORT $LN35@s370_kmc_d

; 2139 :         {
; 2140 :           /* Save, decrypt and XOR */
; 2141 :           memcpy(ocv, message_block, 8);

  0040d	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00415	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2142 :           des_decrypt(&context1, message_block, message_block);

  0041d	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00425	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0042d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00435	e8 00 00 00 00	 call	 des_decrypt

; 2143 :           for(i = 0; i < 8; i++)

  0043a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00442	eb 0a		 jmp	 SHORT $LN11@s370_kmc_d
$LN9@s370_kmc_d:
  00444	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00448	ff c0		 inc	 eax
  0044a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN11@s370_kmc_d:
  0044e	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00453	7d 2a		 jge	 SHORT $LN10@s370_kmc_d

; 2144 :             message_block[i] ^= parameter_block[i];

  00455	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0045a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0045f	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00467	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0046f	33 c1		 xor	 eax, ecx
  00471	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00476	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0047d	eb c5		 jmp	 SHORT $LN9@s370_kmc_d
$LN10@s370_kmc_d:

; 2145 :         }

  0047f	eb 72		 jmp	 SHORT $LN36@s370_kmc_d
$LN35@s370_kmc_d:

; 2146 :         else
; 2147 :         {
; 2148 :           /* XOR, encrypt and save */
; 2149 :           for(i = 0; i < 8; i++)

  00481	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00489	eb 0a		 jmp	 SHORT $LN14@s370_kmc_d
$LN12@s370_kmc_d:
  0048b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0048f	ff c0		 inc	 eax
  00491	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN14@s370_kmc_d:
  00495	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0049a	7d 2a		 jge	 SHORT $LN13@s370_kmc_d

; 2150 :             message_block[i] ^= parameter_block[i];

  0049c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  004a1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004a6	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  004ae	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  004b6	33 c1		 xor	 eax, ecx
  004b8	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  004bd	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  004c4	eb c5		 jmp	 SHORT $LN12@s370_kmc_d
$LN13@s370_kmc_d:

; 2151 :           des_encrypt(&context1, message_block, message_block);

  004c6	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  004ce	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004d6	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  004de	e8 00 00 00 00	 call	 des_encrypt

; 2152 :           memcpy(ocv, message_block, 8);

  004e3	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  004eb	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN36@s370_kmc_d:

; 2153 :         }
; 2154 :         break;

  004f3	e9 d5 02 00 00	 jmp	 $LN7@s370_kmc_d
$LN37@s370_kmc_d:

; 2155 :       }
; 2156 :       case 2: /* tdea-128 */
; 2157 :       {
; 2158 :         if(modifier_bit)

  004f8	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  004fd	0f 84 b1 00 00
	00		 je	 $LN38@s370_kmc_d

; 2159 :         {
; 2160 :           /* Save, decrypt and XOR */
; 2161 :           memcpy(ocv, message_block, 8);

  00503	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  0050b	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2162 :           des_decrypt(&context1, message_block, message_block);

  00513	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0051b	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00523	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0052b	e8 00 00 00 00	 call	 des_decrypt

; 2163 :           des_encrypt(&context2, message_block, message_block);

  00530	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00538	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00540	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  00548	e8 00 00 00 00	 call	 des_encrypt

; 2164 :           des_decrypt(&context1, message_block, message_block);

  0054d	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00555	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0055d	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00565	e8 00 00 00 00	 call	 des_decrypt

; 2165 :           for(i = 0; i < 8; i++)

  0056a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00572	eb 0a		 jmp	 SHORT $LN17@s370_kmc_d
$LN15@s370_kmc_d:
  00574	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00578	ff c0		 inc	 eax
  0057a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN17@s370_kmc_d:
  0057e	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00583	7d 2a		 jge	 SHORT $LN16@s370_kmc_d

; 2166 :             message_block[i] ^= parameter_block[i];

  00585	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0058a	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0058f	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00597	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0059f	33 c1		 xor	 eax, ecx
  005a1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005a6	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  005ad	eb c5		 jmp	 SHORT $LN15@s370_kmc_d
$LN16@s370_kmc_d:

; 2167 :         }

  005af	e9 ac 00 00 00	 jmp	 $LN39@s370_kmc_d
$LN38@s370_kmc_d:

; 2168 :         else
; 2169 :         {
; 2170 :           /* XOR, encrypt and save */
; 2171 :           for(i = 0 ; i < 8; i++)

  005b4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  005bc	eb 0a		 jmp	 SHORT $LN20@s370_kmc_d
$LN18@s370_kmc_d:
  005be	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  005c2	ff c0		 inc	 eax
  005c4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN20@s370_kmc_d:
  005c8	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  005cd	7d 2a		 jge	 SHORT $LN19@s370_kmc_d

; 2172 :             message_block[i] ^= parameter_block[i];

  005cf	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  005d4	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005d9	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  005e1	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  005e9	33 c1		 xor	 eax, ecx
  005eb	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  005f0	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  005f7	eb c5		 jmp	 SHORT $LN18@s370_kmc_d
$LN19@s370_kmc_d:

; 2173 :           des_encrypt(&context1, message_block, message_block);

  005f9	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00601	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00609	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  00611	e8 00 00 00 00	 call	 des_encrypt

; 2174 :           des_decrypt(&context2, message_block, message_block);

  00616	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0061e	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00626	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0062e	e8 00 00 00 00	 call	 des_decrypt

; 2175 :           des_encrypt(&context1, message_block, message_block);

  00633	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0063b	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00643	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0064b	e8 00 00 00 00	 call	 des_encrypt

; 2176 :           memcpy(ocv, message_block, 8);

  00650	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00658	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN39@s370_kmc_d:

; 2177 :         }
; 2178 :         break;

  00660	e9 68 01 00 00	 jmp	 $LN7@s370_kmc_d
$LN40@s370_kmc_d:

; 2179 :       }
; 2180 :       case 3: /* tdea-192 */
; 2181 :       {
; 2182 :         if(modifier_bit)

  00665	83 7c 24 48 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  0066a	0f 84 b1 00 00
	00		 je	 $LN41@s370_kmc_d

; 2183 :         {
; 2184 :           /* Save, decrypt and XOR */
; 2185 :           memcpy(ocv, message_block, 8);

  00670	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  00678	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax

; 2186 :           des_decrypt(&context3, message_block, message_block);

  00680	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00688	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00690	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00698	e8 00 00 00 00	 call	 des_decrypt

; 2187 :           des_encrypt(&context2, message_block, message_block);

  0069d	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  006a5	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  006ad	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  006b5	e8 00 00 00 00	 call	 des_encrypt

; 2188 :           des_decrypt(&context1, message_block, message_block);

  006ba	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  006c2	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  006ca	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  006d2	e8 00 00 00 00	 call	 des_decrypt

; 2189 :           for(i = 0; i < 8; i++)

  006d7	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  006df	eb 0a		 jmp	 SHORT $LN23@s370_kmc_d
$LN21@s370_kmc_d:
  006e1	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  006e5	ff c0		 inc	 eax
  006e7	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN23@s370_kmc_d:
  006eb	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  006f0	7d 2a		 jge	 SHORT $LN22@s370_kmc_d

; 2190 :             message_block[i] ^= parameter_block[i];

  006f2	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  006f7	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  006fc	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00704	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  0070c	33 c1		 xor	 eax, ecx
  0070e	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00713	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0071a	eb c5		 jmp	 SHORT $LN21@s370_kmc_d
$LN22@s370_kmc_d:

; 2191 :         }

  0071c	e9 ac 00 00 00	 jmp	 $LN42@s370_kmc_d
$LN41@s370_kmc_d:

; 2192 :         else
; 2193 :         {
; 2194 :           /* XOR, encrypt and save */
; 2195 :           for(i = 0; i < 8; i++)

  00721	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00729	eb 0a		 jmp	 SHORT $LN26@s370_kmc_d
$LN24@s370_kmc_d:
  0072b	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0072f	ff c0		 inc	 eax
  00731	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN26@s370_kmc_d:
  00735	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0073a	7d 2a		 jge	 SHORT $LN25@s370_kmc_d

; 2196 :             message_block[i] ^= parameter_block[i];

  0073c	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00741	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00746	0f b6 8c 0c 40
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  0074e	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00756	33 c1		 xor	 eax, ecx
  00758	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  0075d	88 84 0c 30 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00764	eb c5		 jmp	 SHORT $LN24@s370_kmc_d
$LN25@s370_kmc_d:

; 2197 :           des_encrypt(&context1, message_block, message_block);

  00766	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0076e	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00776	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context1$[rsp]
  0077e	e8 00 00 00 00	 call	 des_encrypt

; 2198 :           des_decrypt(&context2, message_block, message_block);

  00783	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0078b	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00793	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0079b	e8 00 00 00 00	 call	 des_decrypt

; 2199 :           des_encrypt(&context3, message_block, message_block);

  007a0	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  007a8	48 8d 94 24 30
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  007b0	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  007b8	e8 00 00 00 00	 call	 des_encrypt

; 2200 :           memcpy(ocv, message_block, 8);

  007bd	48 8b 84 24 30
	02 00 00	 mov	 rax, QWORD PTR message_block$[rsp]
  007c5	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR ocv$[rsp], rax
$LN42@s370_kmc_d:
$LN7@s370_kmc_d:

; 2201 :         }
; 2202 :         break;
; 2203 :       }
; 2204 :     }
; 2205 : 
; 2206 :     /* Store the output */
; 2207 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  007cd	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  007d5	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007dd	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  007e4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  007e9	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  007f1	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  007f6	44 8b 8c 24 90
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  007fe	44 8b c0	 mov	 r8d, eax
  00801	b2 07		 mov	 dl, 7
  00803	48 8d 8c 24 30
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0080b	e8 00 00 00 00	 call	 s370_vstorec

; 2208 : 
; 2209 : #ifdef OPTION_KMC_DEBUG
; 2210 :     LOGBYTE("output:", message_block, 8);
; 2211 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2212 : 
; 2213 :     /* Store the output chaining value */
; 2214 :     ARCH_DEP(vstorec)(ocv, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00810	b8 08 00 00 00	 mov	 eax, 8
  00815	48 6b c0 01	 imul	 rax, rax, 1
  00819	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00821	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00828	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0082d	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00835	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0083a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00840	44 8b c0	 mov	 r8d, eax
  00843	b2 07		 mov	 dl, 7
  00845	48 8d 8c 24 38
	02 00 00	 lea	 rcx, QWORD PTR ocv$[rsp]
  0084d	e8 00 00 00 00	 call	 s370_vstorec

; 2215 : 
; 2216 : #ifdef OPTION_KMC_DEBUG
; 2217 :     LOGBYTE("ocv   :", ocv, 8);
; 2218 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2219 : 
; 2220 :     /* Update the registers */
; 2221 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  00852	48 63 84 24 90
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0085a	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00862	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00869	83 c0 08	 add	 eax, 8
  0086c	48 63 8c 24 90
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00874	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0087c	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2222 :     if(likely(r1_is_not_r2))

  00883	83 7c 24 78 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00888	74 0a		 je	 SHORT $LN62@s370_kmc_d
  0088a	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv450[rsp], 1
  00892	eb 08		 jmp	 SHORT $LN63@s370_kmc_d
$LN62@s370_kmc_d:
  00894	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv450[rsp], 0
$LN63@s370_kmc_d:
  0089c	83 7c 24 6c 00	 cmp	 DWORD PTR tv450[rsp], 0
  008a1	74 31		 je	 SHORT $LN43@s370_kmc_d

; 2223 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  008a3	48 63 84 24 98
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  008ab	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008b3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008ba	83 c0 08	 add	 eax, 8
  008bd	48 63 8c 24 98
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  008c5	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  008cd	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN43@s370_kmc_d:

; 2224 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  008d4	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  008db	ff c0		 inc	 eax
  008dd	48 98		 cdqe
  008df	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  008e7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  008ee	83 e8 08	 sub	 eax, 8
  008f1	8b 8c 24 98 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  008f8	ff c1		 inc	 ecx
  008fa	48 63 c9	 movsxd	 rcx, ecx
  008fd	48 8b 94 24 a0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00905	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 2225 : 
; 2226 : #ifdef OPTION_KMC_DEBUG
; 2227 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 2228 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 2229 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 2230 : #endif /* #ifdef OPTION_KMC_DEBUG */
; 2231 : 
; 2232 :     /* check for end of data */
; 2233 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0090c	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00913	ff c0		 inc	 eax
  00915	48 98		 cdqe
  00917	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0091f	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00927	75 0a		 jne	 SHORT $LN64@s370_kmc_d
  00929	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv483[rsp], 1
  00931	eb 08		 jmp	 SHORT $LN65@s370_kmc_d
$LN64@s370_kmc_d:
  00933	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv483[rsp], 0
$LN65@s370_kmc_d:
  0093b	83 7c 24 70 00	 cmp	 DWORD PTR tv483[rsp], 0
  00940	74 0a		 je	 SHORT $LN68@s370_kmc_d
  00942	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv494[rsp], 1
  0094a	eb 08		 jmp	 SHORT $LN69@s370_kmc_d
$LN68@s370_kmc_d:
  0094c	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv494[rsp], 0
$LN69@s370_kmc_d:
  00954	83 7c 24 74 00	 cmp	 DWORD PTR tv494[rsp], 0
  00959	74 0e		 je	 SHORT $LN44@s370_kmc_d

; 2234 :     {
; 2235 :       regs->psw.cc = 0;

  0095b	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00963	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2236 :       return;

  00967	eb 21		 jmp	 SHORT $LN1@s370_kmc_d
$LN44@s370_kmc_d:

; 2237 :     }
; 2238 : 
; 2239 :     /* Set cv for next 8 bytes */
; 2240 :     memcpy(parameter_block, ocv, 8);

  00969	48 8b 84 24 38
	02 00 00	 mov	 rax, QWORD PTR ocv$[rsp]
  00971	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR parameter_block$[rsp], rax

; 2241 :   }

  00979	e9 02 fa ff ff	 jmp	 $LN4@s370_kmc_d
$LN5@s370_kmc_d:

; 2242 : 
; 2243 :   /* CPU-determined amount of data processed */
; 2244 :   regs->psw.cc = 3;

  0097e	48 8b 84 24 a0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00986	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmc_d:

; 2245 : }

  0098a	48 8b 8c 24 78
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00992	48 33 cc	 xor	 rcx, rsp
  00995	e8 00 00 00 00	 call	 __security_check_cookie
  0099a	48 81 c4 88 02
	00 00		 add	 rsp, 648		; 00000288H
  009a1	c3		 ret	 0
s370_kmc_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv83 = 64
tv94 = 68
tv137 = 72
tv152 = 76
wrap$ = 80
tv267 = 84
tv278 = 88
tfc$ = 92
context$ = 96
message_block$ = 592
parameter_block$ = 608
__$ArrayPad$ = 688
r1$ = 720
r2$ = 728
regs$ = 736
s370_kmac_aes PROC

; 1906 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s370_kmac_:

; 1907 :   rijndael_ctx context;
; 1908 :   int crypted;
; 1909 :   int i;
; 1910 :   int keylen;
; 1911 :   BYTE message_block[16];
; 1912 :   BYTE parameter_block[80];
; 1913 :   int parameter_blocklen;
; 1914 :   int tfc;
; 1915 :   int wrap;
; 1916 : 
; 1917 :   UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@s370_kmac_

; 1918 : 
; 1919 :   /* Check special conditions */
; 1920 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  0002c	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00033	ff c0		 inc	 eax
  00035	48 98		 cdqe
  00037	33 d2		 xor	 edx, edx
  00039	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00041	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00048	b9 10 00 00 00	 mov	 ecx, 16
  0004d	f7 f1		 div	 ecx
  0004f	8b c2		 mov	 eax, edx
  00051	85 c0		 test	 eax, eax
  00053	74 0a		 je	 SHORT $LN19@s370_kmac_
  00055	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  0005d	eb 08		 jmp	 SHORT $LN20@s370_kmac_
$LN19@s370_kmac_:
  0005f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN20@s370_kmac_:
  00067	83 7c 24 40 00	 cmp	 DWORD PTR tv83[rsp], 0
  0006c	74 13		 je	 SHORT $LN11@s370_kmac_

; 1921 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006e	ba 06 00 00 00	 mov	 edx, 6
  00073	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN11@s370_kmac_:

; 1922 : 
; 1923 :   /* Return with cc 0 on zero length */
; 1924 :   if(unlikely(!GR_A(r2 + 1, regs)))

  00081	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00088	ff c0		 inc	 eax
  0008a	48 98		 cdqe
  0008c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0009c	75 0a		 jne	 SHORT $LN21@s370_kmac_
  0009e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000a6	eb 08		 jmp	 SHORT $LN22@s370_kmac_
$LN21@s370_kmac_:
  000a8	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN22@s370_kmac_:
  000b0	83 7c 24 44 00	 cmp	 DWORD PTR tv94[rsp], 0
  000b5	74 0a		 je	 SHORT $LN25@s370_kmac_
  000b7	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN26@s370_kmac_
$LN25@s370_kmac_:
  000c1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN26@s370_kmac_:
  000c9	83 7c 24 48 00	 cmp	 DWORD PTR tv137[rsp], 0
  000ce	74 11		 je	 SHORT $LN12@s370_kmac_

; 1925 :   {
; 1926 :     regs->psw.cc = 0;

  000d0	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1927 :     return;

  000dc	e9 51 03 00 00	 jmp	 $LN1@s370_kmac_
$LN12@s370_kmac_:

; 1928 :   }
; 1929 : 
; 1930 :   /* Initialize values */
; 1931 :   tfc = GR0_tfc(regs);

  000e1	b8 08 00 00 00	 mov	 eax, 8
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f9	83 e0 7f	 and	 eax, 127		; 0000007fH
  000fc	83 e0 77	 and	 eax, 119		; 00000077H
  000ff	89 44 24 5c	 mov	 DWORD PTR tfc$[rsp], eax

; 1932 :   wrap = GR0_wrap(regs);

  00103	b8 08 00 00 00	 mov	 eax, 8
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011b	83 e0 08	 and	 eax, 8
  0011e	85 c0		 test	 eax, eax
  00120	74 0a		 je	 SHORT $LN27@s370_kmac_
  00122	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
  0012a	eb 08		 jmp	 SHORT $LN28@s370_kmac_
$LN27@s370_kmac_:
  0012c	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN28@s370_kmac_:
  00134	8b 44 24 4c	 mov	 eax, DWORD PTR tv152[rsp]
  00138	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 1933 :   keylen = (tfc - 17) * 8 + 8;

  0013c	8b 44 24 5c	 mov	 eax, DWORD PTR tfc$[rsp]
  00140	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00147	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 1934 :   parameter_blocklen = keylen + 16;

  0014b	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0014f	83 c0 10	 add	 eax, 16
  00152	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1935 :   if(wrap)

  00156	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0015b	74 0b		 je	 SHORT $LN13@s370_kmac_

; 1936 :     parameter_blocklen += 32;

  0015d	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00161	83 c0 20	 add	 eax, 32			; 00000020H
  00164	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN13@s370_kmac_:

; 1937 : 
; 1938 :   /* Test writeability output chaining value */
; 1939 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  00168	b8 08 00 00 00	 mov	 eax, 8
  0016d	48 6b c0 01	 imul	 rax, rax, 1
  00171	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00179	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00180	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00185	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00192	41 b9 02 00 00
	00		 mov	 r9d, 2
  00198	41 b8 0f 00 00
	00		 mov	 r8d, 15
  0019e	ba 01 00 00 00	 mov	 edx, 1
  001a3	8b c8		 mov	 ecx, eax
  001a5	e8 00 00 00 00	 call	 s370_validate_operand

; 1940 : 
; 1941 :   /* Fetch the parameter block */
; 1942 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001aa	b8 08 00 00 00	 mov	 eax, 8
  001af	48 6b c0 01	 imul	 rax, rax, 1
  001b3	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bb	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001c2	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001c7	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001cb	ff c9		 dec	 ecx
  001cd	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001da	41 b9 01 00 00
	00		 mov	 r9d, 1
  001e0	44 8b c0	 mov	 r8d, eax
  001e3	0f b6 d1	 movzx	 edx, cl
  001e6	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001ee	e8 00 00 00 00	 call	 s370_vfetchc

; 1943 : 
; 1944 : #ifdef OPTION_KMAC_DEBUG
; 1945 :   LOGBYTE("icv   :", parameter_block, 16);
; 1946 :   LOGBYTE("k     :", &parameter_block[16], keylen);
; 1947 :   if(wrap)
; 1948 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 16], 32);
; 1949 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1950 : 
; 1951 :   /* Verify and unwrap */
; 1952 :   if(wrap && unwrap_aes(&parameter_block[16], keylen))

  001f3	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001f8	74 32		 je	 SHORT $LN14@s370_kmac_
  001fa	b8 01 00 00 00	 mov	 eax, 1
  001ff	48 6b c0 10	 imul	 rax, rax, 16
  00203	48 8d 84 04 60
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0020b	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  0020f	48 8b c8	 mov	 rcx, rax
  00212	e8 00 00 00 00	 call	 unwrap_aes
  00217	85 c0		 test	 eax, eax
  00219	74 11		 je	 SHORT $LN14@s370_kmac_

; 1953 :   {
; 1954 : 
; 1955 : #ifdef OPTION_KMAC_DEBUG
; 1956 :     WRMSG(HHC90111, "D");
; 1957 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1958 : 
; 1959 :     regs->psw.cc = 1;

  0021b	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00223	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1960 :     return;

  00227	e9 06 02 00 00	 jmp	 $LN1@s370_kmac_
$LN14@s370_kmac_:

; 1961 :   }
; 1962 : 
; 1963 :   /* Set the cryptographic key */
; 1964 :   rijndael_set_key(&context, &parameter_block[16], keylen * 8);

  0022c	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00230	c1 e0 03	 shl	 eax, 3
  00233	b9 01 00 00 00	 mov	 ecx, 1
  00238	48 6b c9 10	 imul	 rcx, rcx, 16
  0023c	48 8d 8c 0c 60
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00244	44 8b c0	 mov	 r8d, eax
  00247	48 8b d1	 mov	 rdx, rcx
  0024a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context$[rsp]
  0024f	e8 00 00 00 00	 call	 rijndael_set_key

; 1965 : 
; 1966 :   /* Try to process the CPU-determined amount of data */
; 1967 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00254	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0025c	eb 0b		 jmp	 SHORT $LN7@s370_kmac_
$LN5@s370_kmac_:
  0025e	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  00262	83 c0 10	 add	 eax, 16
  00265	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN7@s370_kmac_:
  00269	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00271	0f 8d af 01 00
	00		 jge	 $LN6@s370_kmac_

; 1968 :   {
; 1969 :     /* Fetch a block of data */
; 1970 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00277	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0027f	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00287	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0028e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00293	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002a0	44 8b 8c 24 d8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002a8	44 8b c0	 mov	 r8d, eax
  002ab	b2 0f		 mov	 dl, 15
  002ad	48 8d 8c 24 50
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002b5	e8 00 00 00 00	 call	 s370_vfetchc

; 1971 : 
; 1972 : #ifdef OPTION_KMAC_DEBUG
; 1973 :     LOGBYTE("input :", message_block, 16);
; 1974 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1975 : 
; 1976 :     /* XOR the message with chaining value */
; 1977 :     for(i = 0; i < 16; i++)

  002ba	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002c2	eb 0a		 jmp	 SHORT $LN10@s370_kmac_
$LN8@s370_kmac_:
  002c4	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  002c8	ff c0		 inc	 eax
  002ca	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_kmac_:
  002ce	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  002d3	7d 2a		 jge	 SHORT $LN9@s370_kmac_

; 1978 :       message_block[i] ^= parameter_block[i];

  002d5	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  002da	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  002df	0f b6 8c 0c 60
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  002e7	0f b6 84 04 50
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  002ef	33 c1		 xor	 eax, ecx
  002f1	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  002f6	88 84 0c 50 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  002fd	eb c5		 jmp	 SHORT $LN8@s370_kmac_
$LN9@s370_kmac_:

; 1979 : 
; 1980 :     /* Calculate the output chaining value */
; 1981 :     rijndael_encrypt(&context, message_block, parameter_block);

  002ff	4c 8d 84 24 60
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00307	48 8d 94 24 50
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0030f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR context$[rsp]
  00314	e8 00 00 00 00	 call	 rijndael_encrypt

; 1982 : 
; 1983 :     /* Store the output chaining value */
; 1984 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00319	b8 08 00 00 00	 mov	 eax, 8
  0031e	48 6b c0 01	 imul	 rax, rax, 1
  00322	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0032a	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00331	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00336	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0033e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00343	41 b9 01 00 00
	00		 mov	 r9d, 1
  00349	44 8b c0	 mov	 r8d, eax
  0034c	b2 0f		 mov	 dl, 15
  0034e	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  00356	e8 00 00 00 00	 call	 s370_vstorec

; 1985 : 
; 1986 : #ifdef OPTION_KMAC_DEBUG
; 1987 :     LOGBYTE("ocv   :", parameter_block, 16);
; 1988 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1989 : 
; 1990 :     /* Update the registers */
; 1991 :     SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  0035b	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00363	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0036b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00372	83 c0 10	 add	 eax, 16
  00375	48 63 8c 24 d8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0037d	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00385	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1992 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  0038c	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00393	ff c0		 inc	 eax
  00395	48 98		 cdqe
  00397	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039f	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003a6	83 e8 10	 sub	 eax, 16
  003a9	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  003b0	ff c1		 inc	 ecx
  003b2	48 63 c9	 movsxd	 rcx, ecx
  003b5	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003bd	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1993 : 
; 1994 : #ifdef OPTION_KMAC_DEBUG
; 1995 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1996 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1997 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1998 : 
; 1999 :     /* check for end of data */
; 2000 :     if(unlikely(!GR_A(r2 + 1, regs)))

  003c4	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003cb	ff c0		 inc	 eax
  003cd	48 98		 cdqe
  003cf	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d7	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  003df	75 0a		 jne	 SHORT $LN29@s370_kmac_
  003e1	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv267[rsp], 1
  003e9	eb 08		 jmp	 SHORT $LN30@s370_kmac_
$LN29@s370_kmac_:
  003eb	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv267[rsp], 0
$LN30@s370_kmac_:
  003f3	83 7c 24 54 00	 cmp	 DWORD PTR tv267[rsp], 0
  003f8	74 0a		 je	 SHORT $LN33@s370_kmac_
  003fa	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv278[rsp], 1
  00402	eb 08		 jmp	 SHORT $LN34@s370_kmac_
$LN33@s370_kmac_:
  00404	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv278[rsp], 0
$LN34@s370_kmac_:
  0040c	83 7c 24 58 00	 cmp	 DWORD PTR tv278[rsp], 0
  00411	74 0e		 je	 SHORT $LN15@s370_kmac_

; 2001 :     {
; 2002 :       regs->psw.cc = 0;

  00413	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0041b	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 2003 :       return;

  0041f	eb 11		 jmp	 SHORT $LN1@s370_kmac_
$LN15@s370_kmac_:

; 2004 :     }
; 2005 :   }

  00421	e9 38 fe ff ff	 jmp	 $LN5@s370_kmac_
$LN6@s370_kmac_:

; 2006 : 
; 2007 :   /* CPU-determined amount of data processed */
; 2008 :   regs->psw.cc = 3;

  00426	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0042e	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmac_:

; 2009 : }

  00432	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043a	48 33 cc	 xor	 rcx, rsp
  0043d	e8 00 00 00 00	 call	 __security_check_cookie
  00442	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  00449	c3		 ret	 0
s370_kmac_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
tv187 = 56
crypted$ = 60
tfc$ = 64
tv243 = 68
tv83 = 72
tv94 = 76
tv137 = 80
tv152 = 84
wrap$ = 88
keylen$ = 92
tv309 = 96
tv320 = 100
context1$ = 112
context2$ = 256
context3$ = 400
message_block$ = 544
parameter_block$ = 552
__$ArrayPad$ = 608
r1$ = 640
r2$ = 648
regs$ = 656
s370_kmac_dea PROC

; 1731 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 78 02
	00 00		 sub	 rsp, 632		; 00000278H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 60
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s370_kmac_:

; 1732 :   des_context context1;
; 1733 :   des_context context2;
; 1734 :   des_context context3;
; 1735 :   int crypted;
; 1736 :   int i;
; 1737 :   int keylen;
; 1738 :   BYTE message_block[8];
; 1739 :   BYTE parameter_block[56];
; 1740 :   int parameter_blocklen;
; 1741 :   int tfc;
; 1742 :   int wrap;
; 1743 : 
; 1744 :   UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@s370_kmac_

; 1745 : 
; 1746 :   /* Check special conditions */
; 1747 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  0002c	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00033	ff c0		 inc	 eax
  00035	48 98		 cdqe
  00037	33 d2		 xor	 edx, edx
  00039	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00041	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00048	b9 08 00 00 00	 mov	 ecx, 8
  0004d	f7 f1		 div	 ecx
  0004f	8b c2		 mov	 eax, edx
  00051	85 c0		 test	 eax, eax
  00053	74 0a		 je	 SHORT $LN29@s370_kmac_
  00055	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  0005d	eb 08		 jmp	 SHORT $LN30@s370_kmac_
$LN29@s370_kmac_:
  0005f	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN30@s370_kmac_:
  00067	83 7c 24 48 00	 cmp	 DWORD PTR tv83[rsp], 0
  0006c	74 13		 je	 SHORT $LN15@s370_kmac_

; 1748 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006e	ba 06 00 00 00	 mov	 edx, 6
  00073	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN15@s370_kmac_:

; 1749 : 
; 1750 :   /* Return with cc 0 on zero length */
; 1751 :   if(unlikely(!GR_A(r2 + 1, regs)))

  00081	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00088	ff c0		 inc	 eax
  0008a	48 98		 cdqe
  0008c	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0009c	75 0a		 jne	 SHORT $LN31@s370_kmac_
  0009e	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000a6	eb 08		 jmp	 SHORT $LN32@s370_kmac_
$LN31@s370_kmac_:
  000a8	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN32@s370_kmac_:
  000b0	83 7c 24 4c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000b5	74 0a		 je	 SHORT $LN35@s370_kmac_
  000b7	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN36@s370_kmac_
$LN35@s370_kmac_:
  000c1	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN36@s370_kmac_:
  000c9	83 7c 24 50 00	 cmp	 DWORD PTR tv137[rsp], 0
  000ce	74 11		 je	 SHORT $LN16@s370_kmac_

; 1752 :   {
; 1753 :     regs->psw.cc = 0;

  000d0	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1754 :     return;

  000dc	e9 d9 04 00 00	 jmp	 $LN1@s370_kmac_
$LN16@s370_kmac_:

; 1755 :   }
; 1756 : 
; 1757 :   /* Initialize values */
; 1758 :   tfc = GR0_tfc(regs);

  000e1	b8 08 00 00 00	 mov	 eax, 8
  000e6	48 6b c0 00	 imul	 rax, rax, 0
  000ea	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f9	83 e0 7f	 and	 eax, 127		; 0000007fH
  000fc	83 e0 77	 and	 eax, 119		; 00000077H
  000ff	89 44 24 40	 mov	 DWORD PTR tfc$[rsp], eax

; 1759 :   wrap = GR0_wrap(regs);

  00103	b8 08 00 00 00	 mov	 eax, 8
  00108	48 6b c0 00	 imul	 rax, rax, 0
  0010c	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00114	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0011b	83 e0 08	 and	 eax, 8
  0011e	85 c0		 test	 eax, eax
  00120	74 0a		 je	 SHORT $LN37@s370_kmac_
  00122	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
  0012a	eb 08		 jmp	 SHORT $LN38@s370_kmac_
$LN37@s370_kmac_:
  0012c	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN38@s370_kmac_:
  00134	8b 44 24 54	 mov	 eax, DWORD PTR tv152[rsp]
  00138	89 44 24 58	 mov	 DWORD PTR wrap$[rsp], eax

; 1760 :   keylen = tfc * 8;

  0013c	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  00140	c1 e0 03	 shl	 eax, 3
  00143	89 44 24 5c	 mov	 DWORD PTR keylen$[rsp], eax

; 1761 :   parameter_blocklen = keylen + 8;

  00147	8b 44 24 5c	 mov	 eax, DWORD PTR keylen$[rsp]
  0014b	83 c0 08	 add	 eax, 8
  0014e	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1762 :   if(wrap)

  00152	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00157	74 0b		 je	 SHORT $LN17@s370_kmac_

; 1763 :     parameter_blocklen += 24;

  00159	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0015d	83 c0 18	 add	 eax, 24
  00160	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN17@s370_kmac_:

; 1764 : 
; 1765 :   /* Test writeability output chaining value */
; 1766 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 7, ACCTYPE_WRITE, regs);

  00164	b8 08 00 00 00	 mov	 eax, 8
  00169	48 6b c0 01	 imul	 rax, rax, 1
  0016d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00175	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00181	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00189	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0018e	41 b9 02 00 00
	00		 mov	 r9d, 2
  00194	41 b8 07 00 00
	00		 mov	 r8d, 7
  0019a	ba 01 00 00 00	 mov	 edx, 1
  0019f	8b c8		 mov	 ecx, eax
  001a1	e8 00 00 00 00	 call	 s370_validate_operand

; 1767 : 
; 1768 :   /* Fetch the parameter block */
; 1769 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001a6	b8 08 00 00 00	 mov	 eax, 8
  001ab	48 6b c0 01	 imul	 rax, rax, 1
  001af	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001b7	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001be	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001c3	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001c7	ff c9		 dec	 ecx
  001c9	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d1	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001d6	41 b9 01 00 00
	00		 mov	 r9d, 1
  001dc	44 8b c0	 mov	 r8d, eax
  001df	0f b6 d1	 movzx	 edx, cl
  001e2	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001ea	e8 00 00 00 00	 call	 s370_vfetchc

; 1770 : 
; 1771 : #ifdef OPTION_KMAC_DEBUG
; 1772 :   LOGBYTE("icv   :", parameter_block, 8);
; 1773 :   switch(tfc)
; 1774 :   {
; 1775 :     case 1: /* dea */
; 1776 :     {
; 1777 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1778 :       break;
; 1779 :     }
; 1780 :     case 2: /* tdea-128 */
; 1781 :     {
; 1782 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1783 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 1784 :       break;
; 1785 :     }
; 1786 :     case 3: /* tdea-192 */
; 1787 :     {
; 1788 :       LOGBYTE("k1    :", &parameter_block[8], 8);
; 1789 :       LOGBYTE("k2    :", &parameter_block[16], 8);
; 1790 :       LOGBYTE("k3    :", &parameter_block[24], 8);
; 1791 :       break;
; 1792 :     }
; 1793 :   }
; 1794 :   if(wrap)
; 1795 :     LOGBYTE("wkvp  :", &parameter_block[keylen + 8], 24);
; 1796 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1797 : 
; 1798 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1799 :   /* Verify and unwrap */
; 1800 :   if(wrap && unwrap_dea(&parameter_block[8], keylen))

  001ef	83 7c 24 58 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001f4	74 32		 je	 SHORT $LN18@s370_kmac_
  001f6	b8 01 00 00 00	 mov	 eax, 1
  001fb	48 6b c0 08	 imul	 rax, rax, 8
  001ff	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00207	8b 54 24 5c	 mov	 edx, DWORD PTR keylen$[rsp]
  0020b	48 8b c8	 mov	 rcx, rax
  0020e	e8 00 00 00 00	 call	 unwrap_dea
  00213	85 c0		 test	 eax, eax
  00215	74 11		 je	 SHORT $LN18@s370_kmac_

; 1801 :   {
; 1802 : 
; 1803 : #ifdef OPTION_KM_DEBUG
; 1804 :     WRMSG(HHC90111, "D");
; 1805 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1806 : 
; 1807 :     regs->psw.cc = 1;

  00217	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0021f	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1808 :     return;

  00223	e9 92 03 00 00	 jmp	 $LN1@s370_kmac_
$LN18@s370_kmac_:

; 1809 :   }
; 1810 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1811 : 
; 1812 :   /* Set the cryptographic key */
; 1813 :   switch(tfc)

  00228	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  0022c	89 44 24 38	 mov	 DWORD PTR tv187[rsp], eax
  00230	83 7c 24 38 01	 cmp	 DWORD PTR tv187[rsp], 1
  00235	74 13		 je	 SHORT $LN19@s370_kmac_
  00237	83 7c 24 38 02	 cmp	 DWORD PTR tv187[rsp], 2
  0023c	74 2f		 je	 SHORT $LN20@s370_kmac_
  0023e	83 7c 24 38 03	 cmp	 DWORD PTR tv187[rsp], 3
  00243	74 69		 je	 SHORT $LN21@s370_kmac_
  00245	e9 c4 00 00 00	 jmp	 $LN5@s370_kmac_
$LN19@s370_kmac_:

; 1814 :   {
; 1815 :     case 1: /* dea */
; 1816 :     {
; 1817 :       des_set_key(&context1, &parameter_block[8]);

  0024a	b8 01 00 00 00	 mov	 eax, 1
  0024f	48 6b c0 08	 imul	 rax, rax, 8
  00253	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0025b	48 8b d0	 mov	 rdx, rax
  0025e	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  00263	e8 00 00 00 00	 call	 des_set_key

; 1818 :       break;

  00268	e9 a1 00 00 00	 jmp	 $LN5@s370_kmac_
$LN20@s370_kmac_:

; 1819 :     }
; 1820 :     case 2: /* tdea-128 */
; 1821 :     {
; 1822 :       des_set_key(&context1, &parameter_block[8]);

  0026d	b8 01 00 00 00	 mov	 eax, 1
  00272	48 6b c0 08	 imul	 rax, rax, 8
  00276	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0027e	48 8b d0	 mov	 rdx, rax
  00281	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  00286	e8 00 00 00 00	 call	 des_set_key

; 1823 :       des_set_key(&context2, &parameter_block[16]);

  0028b	b8 01 00 00 00	 mov	 eax, 1
  00290	48 6b c0 10	 imul	 rax, rax, 16
  00294	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0029c	48 8b d0	 mov	 rdx, rax
  0029f	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002a7	e8 00 00 00 00	 call	 des_set_key

; 1824 :       break;

  002ac	eb 60		 jmp	 SHORT $LN5@s370_kmac_
$LN21@s370_kmac_:

; 1825 :     }
; 1826 :     case 3: /* tdea-192 */
; 1827 :     {
; 1828 :       des_set_key(&context1, &parameter_block[8]);

  002ae	b8 01 00 00 00	 mov	 eax, 1
  002b3	48 6b c0 08	 imul	 rax, rax, 8
  002b7	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002bf	48 8b d0	 mov	 rdx, rax
  002c2	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  002c7	e8 00 00 00 00	 call	 des_set_key

; 1829 :       des_set_key(&context2, &parameter_block[16]);

  002cc	b8 01 00 00 00	 mov	 eax, 1
  002d1	48 6b c0 10	 imul	 rax, rax, 16
  002d5	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002dd	48 8b d0	 mov	 rdx, rax
  002e0	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  002e8	e8 00 00 00 00	 call	 des_set_key

; 1830 :       des_set_key(&context3, &parameter_block[24]);

  002ed	b8 01 00 00 00	 mov	 eax, 1
  002f2	48 6b c0 18	 imul	 rax, rax, 24
  002f6	48 8d 84 04 28
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  002fe	48 8b d0	 mov	 rdx, rax
  00301	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  00309	e8 00 00 00 00	 call	 des_set_key
$LN5@s370_kmac_:

; 1831 :       break;
; 1832 :     }
; 1833 :   }
; 1834 : 
; 1835 :   /* Try to process the CPU-determined amount of data */
; 1836 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  0030e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00316	eb 0b		 jmp	 SHORT $LN9@s370_kmac_
$LN7@s370_kmac_:
  00318	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  0031c	83 c0 08	 add	 eax, 8
  0031f	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN9@s370_kmac_:
  00323	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  0032b	0f 8d 7d 02 00
	00		 jge	 $LN8@s370_kmac_

; 1837 :   {
; 1838 :     /* Fetch a block of data */
; 1839 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00331	48 63 84 24 88
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00339	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00341	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00348	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0034d	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00355	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0035a	44 8b 8c 24 88
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00362	44 8b c0	 mov	 r8d, eax
  00365	b2 07		 mov	 dl, 7
  00367	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0036f	e8 00 00 00 00	 call	 s370_vfetchc

; 1840 : 
; 1841 : #ifdef OPTION_KMAC_DEBUG
; 1842 :     LOGBYTE("input :", message_block, 8);
; 1843 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1844 : 
; 1845 :     /* XOR the message with chaining value */
; 1846 :     for(i = 0; i < 8; i++)

  00374	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0037c	eb 0a		 jmp	 SHORT $LN12@s370_kmac_
$LN10@s370_kmac_:
  0037e	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00382	ff c0		 inc	 eax
  00384	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN12@s370_kmac_:
  00388	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  0038d	7d 2a		 jge	 SHORT $LN11@s370_kmac_

; 1847 :       message_block[i] ^= parameter_block[i];

  0038f	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00394	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00399	0f b6 8c 0c 28
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003a1	0f b6 84 04 20
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  003a9	33 c1		 xor	 eax, ecx
  003ab	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003b0	88 84 0c 20 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  003b7	eb c5		 jmp	 SHORT $LN10@s370_kmac_
$LN11@s370_kmac_:

; 1848 : 
; 1849 :     /* Calculate the output chaining value */
; 1850 :     switch(tfc)

  003b9	8b 44 24 40	 mov	 eax, DWORD PTR tfc$[rsp]
  003bd	89 44 24 44	 mov	 DWORD PTR tv243[rsp], eax
  003c1	83 7c 24 44 01	 cmp	 DWORD PTR tv243[rsp], 1
  003c6	74 13		 je	 SHORT $LN22@s370_kmac_
  003c8	83 7c 24 44 02	 cmp	 DWORD PTR tv243[rsp], 2
  003cd	74 2b		 je	 SHORT $LN23@s370_kmac_
  003cf	83 7c 24 44 03	 cmp	 DWORD PTR tv243[rsp], 3
  003d4	74 77		 je	 SHORT $LN24@s370_kmac_
  003d6	e9 c6 00 00 00	 jmp	 $LN13@s370_kmac_
$LN22@s370_kmac_:

; 1851 :     {
; 1852 :       case 1: /* dea */
; 1853 :       {
; 1854 :         des_encrypt(&context1, message_block, parameter_block);

  003db	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  003e3	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003eb	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  003f0	e8 00 00 00 00	 call	 des_encrypt

; 1855 :         break;

  003f5	e9 a7 00 00 00	 jmp	 $LN13@s370_kmac_
$LN23@s370_kmac_:

; 1856 :       }
; 1857 :       case 2: /* tdea-128 */
; 1858 :       {
; 1859 :         des_encrypt(&context1, message_block, parameter_block);

  003fa	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00402	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0040a	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  0040f	e8 00 00 00 00	 call	 des_encrypt

; 1860 :         des_decrypt(&context2, parameter_block, parameter_block);

  00414	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0041c	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00424	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0042c	e8 00 00 00 00	 call	 des_decrypt

; 1861 :         des_encrypt(&context1, parameter_block, parameter_block);

  00431	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00439	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00441	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  00446	e8 00 00 00 00	 call	 des_encrypt

; 1862 :         break;

  0044b	eb 54		 jmp	 SHORT $LN13@s370_kmac_
$LN24@s370_kmac_:

; 1863 :       }
; 1864 :       case 3: /* tdea-192 */
; 1865 :       {
; 1866 :         des_encrypt(&context1, message_block, parameter_block);

  0044d	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00455	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0045d	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context1$[rsp]
  00462	e8 00 00 00 00	 call	 des_encrypt

; 1867 :         des_decrypt(&context2, parameter_block, parameter_block);

  00467	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0046f	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00477	48 8d 8c 24 00
	01 00 00	 lea	 rcx, QWORD PTR context2$[rsp]
  0047f	e8 00 00 00 00	 call	 des_decrypt

; 1868 :         des_encrypt(&context3, parameter_block, parameter_block);

  00484	4c 8d 84 24 28
	02 00 00	 lea	 r8, QWORD PTR parameter_block$[rsp]
  0048c	48 8d 94 24 28
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00494	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR context3$[rsp]
  0049c	e8 00 00 00 00	 call	 des_encrypt
$LN13@s370_kmac_:

; 1869 :         break;
; 1870 :       }
; 1871 :     }
; 1872 : 
; 1873 :     /* Store the output chaining value */
; 1874 :     ARCH_DEP(vstorec)(parameter_block, 7, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  004a1	b8 08 00 00 00	 mov	 eax, 8
  004a6	48 6b c0 01	 imul	 rax, rax, 1
  004aa	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004b2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  004b9	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  004be	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004c6	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  004cb	41 b9 01 00 00
	00		 mov	 r9d, 1
  004d1	44 8b c0	 mov	 r8d, eax
  004d4	b2 07		 mov	 dl, 7
  004d6	48 8d 8c 24 28
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  004de	e8 00 00 00 00	 call	 s370_vstorec

; 1875 : 
; 1876 : #ifdef OPTION_KMAC_DEBUG
; 1877 :     LOGBYTE("ocv   :", parameter_block, 8);
; 1878 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1879 : 
; 1880 :     /* Update the registers */
; 1881 :     SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  004e3	48 63 84 24 88
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004eb	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f3	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004fa	83 c0 08	 add	 eax, 8
  004fd	48 63 8c 24 88
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00505	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0050d	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1882 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  00514	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0051b	ff c0		 inc	 eax
  0051d	48 98		 cdqe
  0051f	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00527	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0052e	83 e8 08	 sub	 eax, 8
  00531	8b 8c 24 88 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  00538	ff c1		 inc	 ecx
  0053a	48 63 c9	 movsxd	 rcx, ecx
  0053d	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00545	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1883 : 
; 1884 : #ifdef OPTION_KMAC_DEBUG
; 1885 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1886 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1887 : #endif /* #ifdef OPTION_KMAC_DEBUG */
; 1888 : 
; 1889 :     /* check for end of data */
; 1890 :     if(unlikely(!GR_A(r2 + 1, regs)))

  0054c	8b 84 24 88 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00553	ff c0		 inc	 eax
  00555	48 98		 cdqe
  00557	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0055f	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00567	75 0a		 jne	 SHORT $LN39@s370_kmac_
  00569	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv309[rsp], 1
  00571	eb 08		 jmp	 SHORT $LN40@s370_kmac_
$LN39@s370_kmac_:
  00573	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv309[rsp], 0
$LN40@s370_kmac_:
  0057b	83 7c 24 60 00	 cmp	 DWORD PTR tv309[rsp], 0
  00580	74 0a		 je	 SHORT $LN43@s370_kmac_
  00582	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv320[rsp], 1
  0058a	eb 08		 jmp	 SHORT $LN44@s370_kmac_
$LN43@s370_kmac_:
  0058c	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv320[rsp], 0
$LN44@s370_kmac_:
  00594	83 7c 24 64 00	 cmp	 DWORD PTR tv320[rsp], 0
  00599	74 0e		 je	 SHORT $LN25@s370_kmac_

; 1891 :     {
; 1892 :       regs->psw.cc = 0;

  0059b	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a3	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1893 :       return;

  005a7	eb 11		 jmp	 SHORT $LN1@s370_kmac_
$LN25@s370_kmac_:

; 1894 :     }
; 1895 :   }

  005a9	e9 6a fd ff ff	 jmp	 $LN7@s370_kmac_
$LN8@s370_kmac_:

; 1896 : 
; 1897 :   /* CPU-determined amount of data processed */
; 1898 :   regs->psw.cc = 3;

  005ae	48 8b 84 24 90
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005b6	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kmac_:

; 1899 : }

  005ba	48 8b 8c 24 60
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c2	48 33 cc	 xor	 rcx, rsp
  005c5	e8 00 00 00 00	 call	 __security_check_cookie
  005ca	48 81 c4 78 02
	00 00		 add	 rsp, 632		; 00000278H
  005d1	c3		 ret	 0
s370_kmac_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
parameter_blocklen$ = 52
keylen$ = 56
crypted$ = 60
tv82 = 64
tv93 = 68
tv136 = 72
tv151 = 76
wrap$ = 80
tv202 = 84
tv204 = 88
tv295 = 92
tv328 = 96
tv339 = 100
tfc$ = 104
modifier_bit$ = 108
r1_is_not_r2$ = 112
xts$ = 120
context$ = 128
message_block$ = 624
parameter_block$ = 640
__$ArrayPad$ = 720
r1$ = 752
r2$ = 760
regs$ = 768
s370_km_xts_aes PROC

; 1606 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec e8 02
	00 00		 sub	 rsp, 744		; 000002e8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 d0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1607 :   rijndael_ctx context;
; 1608 :   int crypted;
; 1609 :   int i;
; 1610 :   int keylen;
; 1611 :   BYTE message_block[16];
; 1612 :   int modifier_bit;
; 1613 :   BYTE parameter_block[80];
; 1614 :   int parameter_blocklen;
; 1615 :   int r1_is_not_r2;
; 1616 :   int tfc;
; 1617 :   int wrap;
; 1618 :   BYTE *xts;
; 1619 : 
; 1620 :   /* Check special conditions */
; 1621 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00026	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 10 00 00 00	 mov	 ecx, 16
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN22@s370_km_xt
  0004f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN23@s370_km_xt
$LN22@s370_km_xt:
  00059	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN23@s370_km_xt:
  00061	83 7c 24 40 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN11@s370_km_xt

; 1622 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN11@s370_km_xt:

; 1623 : 
; 1624 :   /* Return with cc 0 on zero length */
; 1625 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN24@s370_km_xt
  00098	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN25@s370_km_xt
$LN24@s370_km_xt:
  000a2	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN25@s370_km_xt:
  000aa	83 7c 24 44 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN28@s370_km_xt
  000b1	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN29@s370_km_xt
$LN28@s370_km_xt:
  000bb	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN29@s370_km_xt:
  000c3	83 7c 24 48 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN12@s370_km_xt

; 1626 :   {
; 1627 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1628 :     return;

  000d6	e9 e4 04 00 00	 jmp	 $LN1@s370_km_xt
$LN12@s370_km_xt:

; 1629 :   }
; 1630 : 
; 1631 :   /* Initialize values */
; 1632 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 68	 mov	 DWORD PTR tfc$[rsp], eax

; 1633 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN30@s370_km_xt
  0011c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN31@s370_km_xt
$LN30@s370_km_xt:
  00126	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN31@s370_km_xt:
  0012e	8b 44 24 4c	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 50	 mov	 DWORD PTR wrap$[rsp], eax

; 1634 :   keylen = (tfc - 49) * 8 + 8;

  00136	8b 44 24 68	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	8d 04 c5 80 fe
	ff ff		 lea	 eax, DWORD PTR [rax*8-384]
  00141	89 44 24 38	 mov	 DWORD PTR keylen$[rsp], eax

; 1635 :   parameter_blocklen = keylen + 16;

  00145	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  00149	83 c0 10	 add	 eax, 16
  0014c	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1636 :   if(wrap)

  00150	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00155	74 0b		 je	 SHORT $LN13@s370_km_xt

; 1637 :     parameter_blocklen += 32;

  00157	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  0015b	83 c0 20	 add	 eax, 32			; 00000020H
  0015e	89 44 24 34	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN13@s370_km_xt:

; 1638 : 
; 1639 :   /* Test writeability output chaining value */
; 1640 :   ARCH_DEP(validate_operand)((GR_A(1, regs) + parameter_blocklen - 16) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  00162	b8 08 00 00 00	 mov	 eax, 8
  00167	48 6b c0 01	 imul	 rax, rax, 1
  0016b	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00173	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0017a	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0017e	8d 44 08 f0	 lea	 eax, DWORD PTR [rax+rcx-16]
  00182	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00187	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0018f	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00194	41 b9 02 00 00
	00		 mov	 r9d, 2
  0019a	41 b8 0f 00 00
	00		 mov	 r8d, 15
  001a0	ba 01 00 00 00	 mov	 edx, 1
  001a5	8b c8		 mov	 ecx, eax
  001a7	e8 00 00 00 00	 call	 s370_validate_operand

; 1641 : 
; 1642 :   /* Fetch the parameter block */
; 1643 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001ac	b8 08 00 00 00	 mov	 eax, 8
  001b1	48 6b c0 01	 imul	 rax, rax, 1
  001b5	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001bd	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001c4	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001c9	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001cd	ff c9		 dec	 ecx
  001cf	48 8b 94 24 00
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001d7	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001dc	41 b9 01 00 00
	00		 mov	 r9d, 1
  001e2	44 8b c0	 mov	 r8d, eax
  001e5	0f b6 d1	 movzx	 edx, cl
  001e8	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001f0	e8 00 00 00 00	 call	 s370_vfetchc

; 1644 :   xts = &parameter_block[parameter_blocklen - 16];

  001f5	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  001f9	83 e8 10	 sub	 eax, 16
  001fc	48 98		 cdqe
  001fe	48 8d 84 04 80
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00206	48 89 44 24 78	 mov	 QWORD PTR xts$[rsp], rax

; 1645 : 
; 1646 : #ifdef OPTION_KM_DEBUG
; 1647 :   LOGBYTE("k     :", parameter_block, keylen);
; 1648 :   if(wrap)
; 1649 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 32);
; 1650 :   LOGBYTE("xts   :", xts, 16);
; 1651 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1652 : 
; 1653 :   /* Verify and unwrap */
; 1654 :   if(wrap && unwrap_aes(parameter_block, keylen))

  0020b	83 7c 24 50 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00210	74 26		 je	 SHORT $LN14@s370_km_xt
  00212	8b 54 24 38	 mov	 edx, DWORD PTR keylen$[rsp]
  00216	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0021e	e8 00 00 00 00	 call	 unwrap_aes
  00223	85 c0		 test	 eax, eax
  00225	74 11		 je	 SHORT $LN14@s370_km_xt

; 1655 :   {
; 1656 : 
; 1657 : #ifdef OPTION_KM_DEBUG
; 1658 :     WRMSG(HHC90111, "D");
; 1659 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1660 : 
; 1661 :     regs->psw.cc = 1;

  00227	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0022f	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1662 :     return;

  00233	e9 87 03 00 00	 jmp	 $LN1@s370_km_xt
$LN14@s370_km_xt:

; 1663 :   }
; 1664 : 
; 1665 :   /* Set the cryptographic keys */
; 1666 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  00238	8b 44 24 38	 mov	 eax, DWORD PTR keylen$[rsp]
  0023c	c1 e0 03	 shl	 eax, 3
  0023f	44 8b c0	 mov	 r8d, eax
  00242	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0024a	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00252	e8 00 00 00 00	 call	 rijndael_set_key

; 1667 : 
; 1668 :   /* Try to process the CPU-determined amount of data */
; 1669 :   modifier_bit = GR0_m(regs);

  00257	b8 08 00 00 00	 mov	 eax, 8
  0025c	48 6b c0 00	 imul	 rax, rax, 0
  00260	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00268	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0026f	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00274	85 c0		 test	 eax, eax
  00276	74 0a		 je	 SHORT $LN32@s370_km_xt
  00278	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  00280	eb 08		 jmp	 SHORT $LN33@s370_km_xt
$LN32@s370_km_xt:
  00282	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN33@s370_km_xt:
  0028a	8b 44 24 54	 mov	 eax, DWORD PTR tv202[rsp]
  0028e	89 44 24 6c	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1670 :   r1_is_not_r2 = r1 != r2;

  00292	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00299	39 84 24 f0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002a0	74 0a		 je	 SHORT $LN34@s370_km_xt
  002a2	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  002aa	eb 08		 jmp	 SHORT $LN35@s370_km_xt
$LN34@s370_km_xt:
  002ac	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN35@s370_km_xt:
  002b4	8b 44 24 58	 mov	 eax, DWORD PTR tv204[rsp]
  002b8	89 44 24 70	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1671 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  002bc	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  002c4	eb 0b		 jmp	 SHORT $LN4@s370_km_xt
$LN2@s370_km_xt:
  002c6	8b 44 24 3c	 mov	 eax, DWORD PTR crypted$[rsp]
  002ca	83 c0 10	 add	 eax, 16
  002cd	89 44 24 3c	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s370_km_xt:
  002d1	81 7c 24 3c 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  002d9	0f 8d d4 02 00
	00		 jge	 $LN3@s370_km_xt

; 1672 :   {
; 1673 :     /* Fetch a block of data */
; 1674 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  002df	48 63 84 24 f8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002e7	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002ef	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002f6	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  002fb	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00303	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00308	44 8b 8c 24 f8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00310	44 8b c0	 mov	 r8d, eax
  00313	b2 0f		 mov	 dl, 15
  00315	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0031d	e8 00 00 00 00	 call	 s370_vfetchc

; 1675 : 
; 1676 : #ifdef OPTION_KM_DEBUG
; 1677 :     LOGBYTE("input :", message_block, 16);
; 1678 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1679 : 
; 1680 :     /* XOR, decrypt/encrypt and XOR again*/
; 1681 :     for(i = 0; i < 16; i++)

  00322	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0032a	eb 0a		 jmp	 SHORT $LN7@s370_km_xt
$LN5@s370_km_xt:
  0032c	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00330	ff c0		 inc	 eax
  00332	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@s370_km_xt:
  00336	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  0033b	7d 34		 jge	 SHORT $LN6@s370_km_xt

; 1682 :       message_block[i] ^= parameter_block[parameter_blocklen - 16 + i];

  0033d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00342	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00346	8b 54 24 30	 mov	 edx, DWORD PTR i$[rsp]
  0034a	8d 4c 11 f0	 lea	 ecx, DWORD PTR [rcx+rdx-16]
  0034e	48 63 c9	 movsxd	 rcx, ecx
  00351	0f b6 8c 0c 80
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  00359	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  00361	33 c1		 xor	 eax, ecx
  00363	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  00368	88 84 0c 70 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  0036f	eb bb		 jmp	 SHORT $LN5@s370_km_xt
$LN6@s370_km_xt:

; 1683 :     if(modifier_bit)

  00371	83 7c 24 6c 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  00376	74 1f		 je	 SHORT $LN15@s370_km_xt

; 1684 :       rijndael_decrypt(&context, message_block, message_block);

  00378	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  00380	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00388	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  00390	e8 00 00 00 00	 call	 rijndael_decrypt
  00395	eb 1d		 jmp	 SHORT $LN16@s370_km_xt
$LN15@s370_km_xt:

; 1685 :     else
; 1686 :       rijndael_encrypt(&context, message_block, message_block);

  00397	4c 8d 84 24 70
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0039f	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003a7	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR context$[rsp]
  003af	e8 00 00 00 00	 call	 rijndael_encrypt
$LN16@s370_km_xt:

; 1687 :     for(i = 0; i < 16; i++)

  003b4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003bc	eb 0a		 jmp	 SHORT $LN10@s370_km_xt
$LN8@s370_km_xt:
  003be	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003c2	ff c0		 inc	 eax
  003c4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_km_xt:
  003c8	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  003cd	7d 34		 jge	 SHORT $LN9@s370_km_xt

; 1688 :       message_block[i] ^= parameter_block[parameter_blocklen - 16 + i];

  003cf	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003d4	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  003d8	8b 54 24 30	 mov	 edx, DWORD PTR i$[rsp]
  003dc	8d 4c 11 f0	 lea	 ecx, DWORD PTR [rcx+rdx-16]
  003e0	48 63 c9	 movsxd	 rcx, ecx
  003e3	0f b6 8c 0c 80
	02 00 00	 movzx	 ecx, BYTE PTR parameter_block$[rsp+rcx]
  003eb	0f b6 84 04 70
	02 00 00	 movzx	 eax, BYTE PTR message_block$[rsp+rax]
  003f3	33 c1		 xor	 eax, ecx
  003f5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  003fa	88 84 0c 70 02
	00 00		 mov	 BYTE PTR message_block$[rsp+rcx], al
  00401	eb bb		 jmp	 SHORT $LN8@s370_km_xt
$LN9@s370_km_xt:

; 1689 : 
; 1690 :     /* Calculate output XTS */
; 1691 :     xts_mult_x(xts);

  00403	48 8b 4c 24 78	 mov	 rcx, QWORD PTR xts$[rsp]
  00408	e8 00 00 00 00	 call	 xts_mult_x

; 1692 : 
; 1693 :     /* Store the output and XTS */
; 1694 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  0040d	48 63 84 24 f0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00415	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0041d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00424	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00429	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00431	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00436	44 8b 8c 24 f0
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0043e	44 8b c0	 mov	 r8d, eax
  00441	b2 0f		 mov	 dl, 15
  00443	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  0044b	e8 00 00 00 00	 call	 s370_vstorec

; 1695 :     ARCH_DEP(vstorec)(xts, 15, (GR_A(1, regs) + parameter_blocklen - 16) & ADDRESS_MAXWRAP(regs), 1, regs);

  00450	b8 08 00 00 00	 mov	 eax, 8
  00455	48 6b c0 01	 imul	 rax, rax, 1
  00459	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00461	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00468	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0046c	8d 44 08 f0	 lea	 eax, DWORD PTR [rax+rcx-16]
  00470	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00475	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0047d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00482	41 b9 01 00 00
	00		 mov	 r9d, 1
  00488	44 8b c0	 mov	 r8d, eax
  0048b	b2 0f		 mov	 dl, 15
  0048d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR xts$[rsp]
  00492	e8 00 00 00 00	 call	 s370_vstorec

; 1696 : 
; 1697 : #ifdef OPTION_KM_DEBUG
; 1698 :     LOGBYTE("output:", message_block, 16);
; 1699 :     LOGBYTE("xts   :", xts, 16);
; 1700 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1701 : 
; 1702 :     /* Update the registers */
; 1703 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  00497	48 63 84 24 f0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0049f	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004a7	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004ae	83 c0 10	 add	 eax, 16
  004b1	48 63 8c 24 f0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  004b9	48 8b 94 24 00
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004c1	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1704 :     if(likely(r1_is_not_r2))

  004c8	83 7c 24 70 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  004cd	74 0a		 je	 SHORT $LN36@s370_km_xt
  004cf	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv295[rsp], 1
  004d7	eb 08		 jmp	 SHORT $LN37@s370_km_xt
$LN36@s370_km_xt:
  004d9	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv295[rsp], 0
$LN37@s370_km_xt:
  004e1	83 7c 24 5c 00	 cmp	 DWORD PTR tv295[rsp], 0
  004e6	74 31		 je	 SHORT $LN17@s370_km_xt

; 1705 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  004e8	48 63 84 24 f8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  004f0	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f8	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004ff	83 c0 10	 add	 eax, 16
  00502	48 63 8c 24 f8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0050a	48 8b 94 24 00
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00512	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN17@s370_km_xt:

; 1706 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00519	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00520	ff c0		 inc	 eax
  00522	48 98		 cdqe
  00524	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0052c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00533	83 e8 10	 sub	 eax, 16
  00536	8b 8c 24 f8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0053d	ff c1		 inc	 ecx
  0053f	48 63 c9	 movsxd	 rcx, ecx
  00542	48 8b 94 24 00
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0054a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1707 : 
; 1708 : #ifdef OPTION_KM_DEBUG
; 1709 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1710 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1711 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1712 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1713 : 
; 1714 :     /* check for end of data */
; 1715 :     if(unlikely(!GR_A(r2 + 1, regs)))

  00551	8b 84 24 f8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00558	ff c0		 inc	 eax
  0055a	48 98		 cdqe
  0055c	48 8b 8c 24 00
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00564	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0056c	75 0a		 jne	 SHORT $LN38@s370_km_xt
  0056e	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv328[rsp], 1
  00576	eb 08		 jmp	 SHORT $LN39@s370_km_xt
$LN38@s370_km_xt:
  00578	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv328[rsp], 0
$LN39@s370_km_xt:
  00580	83 7c 24 60 00	 cmp	 DWORD PTR tv328[rsp], 0
  00585	74 0a		 je	 SHORT $LN42@s370_km_xt
  00587	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv339[rsp], 1
  0058f	eb 08		 jmp	 SHORT $LN43@s370_km_xt
$LN42@s370_km_xt:
  00591	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv339[rsp], 0
$LN43@s370_km_xt:
  00599	83 7c 24 64 00	 cmp	 DWORD PTR tv339[rsp], 0
  0059e	74 0e		 je	 SHORT $LN18@s370_km_xt

; 1716 :     {
; 1717 :       regs->psw.cc = 0;

  005a0	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005a8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1718 :       return;

  005ac	eb 11		 jmp	 SHORT $LN1@s370_km_xt
$LN18@s370_km_xt:

; 1719 :     }
; 1720 :   }

  005ae	e9 13 fd ff ff	 jmp	 $LN2@s370_km_xt
$LN3@s370_km_xt:

; 1721 : 
; 1722 :   /* CPU-determined amount of data processed */
; 1723 :   regs->psw.cc = 3;

  005b3	48 8b 84 24 00
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005bb	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_km_xt:

; 1724 : }

  005bf	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005c7	48 33 cc	 xor	 rcx, rsp
  005ca	e8 00 00 00 00	 call	 __security_check_cookie
  005cf	48 81 c4 e8 02
	00 00		 add	 rsp, 744		; 000002e8H
  005d6	c3		 ret	 0
s370_km_xts_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
keylen$ = 52
crypted$ = 56
tv82 = 60
tv93 = 64
tv136 = 68
tv151 = 72
wrap$ = 76
tv185 = 80
tv187 = 84
tv231 = 88
tv264 = 92
tv275 = 96
tfc$ = 100
modifier_bit$ = 104
r1_is_not_r2$ = 108
context$ = 112
message_block$ = 608
parameter_block$ = 624
__$ArrayPad$ = 688
r1$ = 720
r2$ = 728
regs$ = 736
s370_km_aes PROC

; 1494 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec c8 02
	00 00		 sub	 rsp, 712		; 000002c8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1495 :   rijndael_ctx context;
; 1496 :   int crypted;
; 1497 :   int keylen;
; 1498 :   BYTE message_block[16];
; 1499 :   int modifier_bit;
; 1500 :   BYTE parameter_block[64];
; 1501 :   int parameter_blocklen;
; 1502 :   int r1_is_not_r2;
; 1503 :   int tfc;
; 1504 :   int wrap;
; 1505 : 
; 1506 :   /* Check special conditions */
; 1507 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  00026	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 10 00 00 00	 mov	 ecx, 16
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN16@s370_km_ae
  0004f	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN17@s370_km_ae
$LN16@s370_km_ae:
  00059	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN17@s370_km_ae:
  00061	83 7c 24 3c 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN5@s370_km_ae

; 1508 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN5@s370_km_ae:

; 1509 : 
; 1510 :   /* Return with cc 0 on zero length */
; 1511 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN18@s370_km_ae
  00098	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN19@s370_km_ae
$LN18@s370_km_ae:
  000a2	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN19@s370_km_ae:
  000aa	83 7c 24 40 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN22@s370_km_ae
  000b1	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN23@s370_km_ae
$LN22@s370_km_ae:
  000bb	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN23@s370_km_ae:
  000c3	83 7c 24 44 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN6@s370_km_ae

; 1512 :   {
; 1513 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1514 :     return;

  000d6	e9 89 03 00 00	 jmp	 $LN1@s370_km_ae
$LN6@s370_km_ae:

; 1515 :   }
; 1516 : 
; 1517 :   /* Initialize values */
; 1518 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 64	 mov	 DWORD PTR tfc$[rsp], eax

; 1519 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN24@s370_km_ae
  0011c	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN25@s370_km_ae
$LN24@s370_km_ae:
  00126	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN25@s370_km_ae:
  0012e	8b 44 24 48	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 4c	 mov	 DWORD PTR wrap$[rsp], eax

; 1520 :   keylen = (tfc - 17) * 8 + 8;

  00136	8b 44 24 64	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	8d 04 c5 80 ff
	ff ff		 lea	 eax, DWORD PTR [rax*8-128]
  00141	89 44 24 34	 mov	 DWORD PTR keylen$[rsp], eax

; 1521 :   parameter_blocklen = keylen;

  00145	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  00149	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1522 :   if(wrap)

  0014d	83 7c 24 4c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  00152	74 0b		 je	 SHORT $LN7@s370_km_ae

; 1523 :     parameter_blocklen += 32;

  00154	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00158	83 c0 20	 add	 eax, 32			; 00000020H
  0015b	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN7@s370_km_ae:

; 1524 : 
; 1525 :   /* Fetch the parameter block */
; 1526 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0015f	b8 08 00 00 00	 mov	 eax, 8
  00164	48 6b c0 01	 imul	 rax, rax, 1
  00168	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00170	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00177	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0017c	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00180	ff c9		 dec	 ecx
  00182	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0018a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0018f	41 b9 01 00 00
	00		 mov	 r9d, 1
  00195	44 8b c0	 mov	 r8d, eax
  00198	0f b6 d1	 movzx	 edx, cl
  0019b	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001a3	e8 00 00 00 00	 call	 s370_vfetchc

; 1527 : 
; 1528 : #ifdef OPTION_KM_DEBUG
; 1529 :   LOGBYTE("k     :", parameter_block, keylen);
; 1530 :   if(wrap)
; 1531 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 32);
; 1532 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1533 : 
; 1534 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1535 :   /* Verify and unwrap */
; 1536 :   if(wrap && unwrap_aes(parameter_block, keylen))

  001a8	83 7c 24 4c 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001ad	74 26		 je	 SHORT $LN8@s370_km_ae
  001af	8b 54 24 34	 mov	 edx, DWORD PTR keylen$[rsp]
  001b3	48 8d 8c 24 70
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001bb	e8 00 00 00 00	 call	 unwrap_aes
  001c0	85 c0		 test	 eax, eax
  001c2	74 11		 je	 SHORT $LN8@s370_km_ae

; 1537 :   {
; 1538 : 
; 1539 : #ifdef OPTION_KM_DEBUG
; 1540 :     WRMSG(HHC90111, "D");
; 1541 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1542 : 
; 1543 :     regs->psw.cc = 1;

  001c4	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001cc	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1544 :     return;

  001d0	e9 8f 02 00 00	 jmp	 $LN1@s370_km_ae
$LN8@s370_km_ae:

; 1545 :   }
; 1546 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1547 : 
; 1548 :   /* Set the cryptographic keys */
; 1549 :   rijndael_set_key(&context, parameter_block, keylen * 8);

  001d5	8b 44 24 34	 mov	 eax, DWORD PTR keylen$[rsp]
  001d9	c1 e0 03	 shl	 eax, 3
  001dc	44 8b c0	 mov	 r8d, eax
  001df	48 8d 94 24 70
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  001e7	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  001ec	e8 00 00 00 00	 call	 rijndael_set_key

; 1550 : 
; 1551 :   /* Try to process the CPU-determined amount of data */
; 1552 :   modifier_bit = GR0_m(regs);

  001f1	b8 08 00 00 00	 mov	 eax, 8
  001f6	48 6b c0 00	 imul	 rax, rax, 0
  001fa	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00202	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00209	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0020e	85 c0		 test	 eax, eax
  00210	74 0a		 je	 SHORT $LN26@s370_km_ae
  00212	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv185[rsp], 1
  0021a	eb 08		 jmp	 SHORT $LN27@s370_km_ae
$LN26@s370_km_ae:
  0021c	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN27@s370_km_ae:
  00224	8b 44 24 50	 mov	 eax, DWORD PTR tv185[rsp]
  00228	89 44 24 68	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1553 :   r1_is_not_r2 = r1 != r2;

  0022c	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00233	39 84 24 d0 02
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  0023a	74 0a		 je	 SHORT $LN28@s370_km_ae
  0023c	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv187[rsp], 1
  00244	eb 08		 jmp	 SHORT $LN29@s370_km_ae
$LN28@s370_km_ae:
  00246	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv187[rsp], 0
$LN29@s370_km_ae:
  0024e	8b 44 24 54	 mov	 eax, DWORD PTR tv187[rsp]
  00252	89 44 24 6c	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1554 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00256	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0025e	eb 0b		 jmp	 SHORT $LN4@s370_km_ae
$LN2@s370_km_ae:
  00260	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  00264	83 c0 10	 add	 eax, 16
  00267	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN4@s370_km_ae:
  0026b	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  00273	0f 8d df 01 00
	00		 jge	 $LN3@s370_km_ae

; 1555 :   {
; 1556 :     /* Fetch a block of data */
; 1557 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00279	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00281	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00289	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00290	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00295	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0029d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002a2	44 8b 8c 24 d8
	02 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002aa	44 8b c0	 mov	 r8d, eax
  002ad	b2 0f		 mov	 dl, 15
  002af	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002b7	e8 00 00 00 00	 call	 s370_vfetchc

; 1558 : 
; 1559 : #ifdef OPTION_KM_DEBUG
; 1560 :     LOGBYTE("input :", message_block, 16);
; 1561 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1562 : 
; 1563 :     /* Do the job */
; 1564 :     if(modifier_bit)

  002bc	83 7c 24 68 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  002c1	74 1c		 je	 SHORT $LN9@s370_km_ae

; 1565 :       rijndael_decrypt(&context, message_block, message_block);

  002c3	4c 8d 84 24 60
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  002cb	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  002d3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  002d8	e8 00 00 00 00	 call	 rijndael_decrypt
  002dd	eb 1a		 jmp	 SHORT $LN10@s370_km_ae
$LN9@s370_km_ae:

; 1566 :     else
; 1567 :       rijndael_encrypt(&context, message_block, message_block);

  002df	4c 8d 84 24 60
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  002e7	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  002ef	48 8d 4c 24 70	 lea	 rcx, QWORD PTR context$[rsp]
  002f4	e8 00 00 00 00	 call	 rijndael_encrypt
$LN10@s370_km_ae:

; 1568 : 
; 1569 :     /* Store the output */
; 1570 :     ARCH_DEP(vstorec)(message_block, 15, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  002f9	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00301	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00309	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00310	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00315	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031d	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00322	44 8b 8c 24 d0
	02 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  0032a	44 8b c0	 mov	 r8d, eax
  0032d	b2 0f		 mov	 dl, 15
  0032f	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00337	e8 00 00 00 00	 call	 s370_vstorec

; 1571 : 
; 1572 : #ifdef OPTION_KM_DEBUG
; 1573 :     LOGBYTE("output:", message_block, 16);
; 1574 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1575 : 
; 1576 :     /* Update the registers */
; 1577 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 16);

  0033c	48 63 84 24 d0
	02 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  00344	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0034c	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00353	83 c0 10	 add	 eax, 16
  00356	48 63 8c 24 d0
	02 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  0035e	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00366	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1578 :     if(likely(r1_is_not_r2))

  0036d	83 7c 24 6c 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  00372	74 0a		 je	 SHORT $LN30@s370_km_ae
  00374	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv231[rsp], 1
  0037c	eb 08		 jmp	 SHORT $LN31@s370_km_ae
$LN30@s370_km_ae:
  0037e	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv231[rsp], 0
$LN31@s370_km_ae:
  00386	83 7c 24 58 00	 cmp	 DWORD PTR tv231[rsp], 0
  0038b	74 31		 je	 SHORT $LN11@s370_km_ae

; 1579 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  0038d	48 63 84 24 d8
	02 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00395	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0039d	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003a4	83 c0 10	 add	 eax, 16
  003a7	48 63 8c 24 d8
	02 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  003af	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003b7	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN11@s370_km_ae:

; 1580 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  003be	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003c5	ff c0		 inc	 eax
  003c7	48 98		 cdqe
  003c9	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003d1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003d8	83 e8 10	 sub	 eax, 16
  003db	8b 8c 24 d8 02
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  003e2	ff c1		 inc	 ecx
  003e4	48 63 c9	 movsxd	 rcx, ecx
  003e7	48 8b 94 24 e0
	02 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003ef	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1581 : 
; 1582 : #ifdef OPTION_KM_DEBUG
; 1583 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1584 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1585 :     WRMSG(HHC90108, "D", (regs)->GR(r2 + 1));
; 1586 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1587 : 
; 1588 :     /* check for end of data */
; 1589 :     if(unlikely(!GR_A(r2 + 1, regs)))

  003f6	8b 84 24 d8 02
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003fd	ff c0		 inc	 eax
  003ff	48 98		 cdqe
  00401	48 8b 8c 24 e0
	02 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00409	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00411	75 0a		 jne	 SHORT $LN32@s370_km_ae
  00413	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv264[rsp], 1
  0041b	eb 08		 jmp	 SHORT $LN33@s370_km_ae
$LN32@s370_km_ae:
  0041d	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv264[rsp], 0
$LN33@s370_km_ae:
  00425	83 7c 24 5c 00	 cmp	 DWORD PTR tv264[rsp], 0
  0042a	74 0a		 je	 SHORT $LN36@s370_km_ae
  0042c	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv275[rsp], 1
  00434	eb 08		 jmp	 SHORT $LN37@s370_km_ae
$LN36@s370_km_ae:
  00436	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv275[rsp], 0
$LN37@s370_km_ae:
  0043e	83 7c 24 60 00	 cmp	 DWORD PTR tv275[rsp], 0
  00443	74 0e		 je	 SHORT $LN12@s370_km_ae

; 1590 :     {
; 1591 :       regs->psw.cc = 0;

  00445	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0044d	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1592 :       return;

  00451	eb 11		 jmp	 SHORT $LN1@s370_km_ae
$LN12@s370_km_ae:

; 1593 :     }
; 1594 :   }

  00453	e9 08 fe ff ff	 jmp	 $LN2@s370_km_ae
$LN3@s370_km_ae:

; 1595 : 
; 1596 :   /* CPU-determined amount of data processed */
; 1597 :   regs->psw.cc = 3;

  00458	48 8b 84 24 e0
	02 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00460	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_km_ae:

; 1598 : }

  00464	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0046c	48 33 cc	 xor	 rcx, rsp
  0046f	e8 00 00 00 00	 call	 __security_check_cookie
  00474	48 81 c4 c8 02
	00 00		 add	 rsp, 712		; 000002c8H
  0047b	c3		 ret	 0
s370_km_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
parameter_blocklen$ = 48
tv173 = 52
crypted$ = 56
tfc$ = 60
tv214 = 64
tv82 = 68
tv93 = 72
tv136 = 76
tv151 = 80
wrap$ = 84
keylen$ = 88
tv198 = 92
tv200 = 96
modifier_bit$ = 100
tv255 = 104
tv288 = 108
tv299 = 112
r1_is_not_r2$ = 116
des_ctx$ = 128
des3_ctx$ = 272
message_block$ = 688
parameter_block$ = 696
__$ArrayPad$ = 744
r1$ = 768
r2$ = 776
regs$ = 784
s370_km_dea PROC

; 1329 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec f8 02
	00 00		 sub	 rsp, 760		; 000002f8H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 e8
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1330 :   int crypted;
; 1331 :   des_context des_ctx;
; 1332 :   des3_context des3_ctx;
; 1333 :   int keylen;
; 1334 :   BYTE message_block[8];
; 1335 :   int modifier_bit;
; 1336 :   BYTE parameter_block[48];
; 1337 :   int parameter_blocklen;
; 1338 :   int r1_is_not_r2;
; 1339 :   int tfc;
; 1340 :   int wrap;
; 1341 : 
; 1342 :   /* Check special conditions */
; 1343 :   if(unlikely(GR_A(r2 + 1, regs) % 8))

  00026	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0002d	ff c0		 inc	 eax
  0002f	48 98		 cdqe
  00031	33 d2		 xor	 edx, edx
  00033	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0003b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00042	b9 08 00 00 00	 mov	 ecx, 8
  00047	f7 f1		 div	 ecx
  00049	8b c2		 mov	 eax, edx
  0004b	85 c0		 test	 eax, eax
  0004d	74 0a		 je	 SHORT $LN28@s370_km_de
  0004f	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00057	eb 08		 jmp	 SHORT $LN29@s370_km_de
$LN28@s370_km_de:
  00059	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN29@s370_km_de:
  00061	83 7c 24 44 00	 cmp	 DWORD PTR tv82[rsp], 0
  00066	74 13		 je	 SHORT $LN9@s370_km_de

; 1344 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  00068	ba 06 00 00 00	 mov	 edx, 6
  0006d	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN9@s370_km_de:

; 1345 : 
; 1346 :   /* Return with cc 0 on zero length */
; 1347 :   if(unlikely(!GR_A(r2 + 1, regs)))

  0007b	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00082	ff c0		 inc	 eax
  00084	48 98		 cdqe
  00086	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0008e	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00096	75 0a		 jne	 SHORT $LN30@s370_km_de
  00098	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000a0	eb 08		 jmp	 SHORT $LN31@s370_km_de
$LN30@s370_km_de:
  000a2	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN31@s370_km_de:
  000aa	83 7c 24 48 00	 cmp	 DWORD PTR tv93[rsp], 0
  000af	74 0a		 je	 SHORT $LN34@s370_km_de
  000b1	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN35@s370_km_de
$LN34@s370_km_de:
  000bb	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN35@s370_km_de:
  000c3	83 7c 24 4c 00	 cmp	 DWORD PTR tv136[rsp], 0
  000c8	74 11		 je	 SHORT $LN10@s370_km_de

; 1348 :   {
; 1349 :     regs->psw.cc = 0;

  000ca	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d2	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1350 :     return;

  000d6	e9 74 04 00 00	 jmp	 $LN1@s370_km_de
$LN10@s370_km_de:

; 1351 :   }
; 1352 : 
; 1353 :   /* Initialize values */
; 1354 :   tfc = GR0_tfc(regs);

  000db	b8 08 00 00 00	 mov	 eax, 8
  000e0	48 6b c0 00	 imul	 rax, rax, 0
  000e4	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ec	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f3	83 e0 7f	 and	 eax, 127		; 0000007fH
  000f6	83 e0 77	 and	 eax, 119		; 00000077H
  000f9	89 44 24 3c	 mov	 DWORD PTR tfc$[rsp], eax

; 1355 :   wrap = GR0_wrap(regs);

  000fd	b8 08 00 00 00	 mov	 eax, 8
  00102	48 6b c0 00	 imul	 rax, rax, 0
  00106	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0010e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00115	83 e0 08	 and	 eax, 8
  00118	85 c0		 test	 eax, eax
  0011a	74 0a		 je	 SHORT $LN36@s370_km_de
  0011c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv151[rsp], 1
  00124	eb 08		 jmp	 SHORT $LN37@s370_km_de
$LN36@s370_km_de:
  00126	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN37@s370_km_de:
  0012e	8b 44 24 50	 mov	 eax, DWORD PTR tv151[rsp]
  00132	89 44 24 54	 mov	 DWORD PTR wrap$[rsp], eax

; 1356 :   keylen = tfc * 8;

  00136	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  0013a	c1 e0 03	 shl	 eax, 3
  0013d	89 44 24 58	 mov	 DWORD PTR keylen$[rsp], eax

; 1357 :   parameter_blocklen = keylen;

  00141	8b 44 24 58	 mov	 eax, DWORD PTR keylen$[rsp]
  00145	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax

; 1358 :   if(wrap)

  00149	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  0014e	74 0b		 je	 SHORT $LN11@s370_km_de

; 1359 :     parameter_blocklen += 24;

  00150	8b 44 24 30	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00154	83 c0 18	 add	 eax, 24
  00157	89 44 24 30	 mov	 DWORD PTR parameter_blocklen$[rsp], eax
$LN11@s370_km_de:

; 1360 : 
; 1361 :   /* Fetch the parameter block */
; 1362 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0015b	b8 08 00 00 00	 mov	 eax, 8
  00160	48 6b c0 01	 imul	 rax, rax, 1
  00164	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0016c	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00173	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00178	8b 4c 24 30	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0017c	ff c9		 dec	 ecx
  0017e	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00186	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0018b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00191	44 8b c0	 mov	 r8d, eax
  00194	0f b6 d1	 movzx	 edx, cl
  00197	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0019f	e8 00 00 00 00	 call	 s370_vfetchc

; 1363 : 
; 1364 : #ifdef OPTION_KM_DEBUG
; 1365 :   switch(tfc)
; 1366 :   {
; 1367 :     case 1: /* dea */
; 1368 :     {
; 1369 :       LOGBYTE("k     :", parameter_block, 8);
; 1370 :       break;
; 1371 :     }
; 1372 :     case 2: /* tdea-128 */
; 1373 :     {
; 1374 :       LOGBYTE("k1    :", parameter_block, 8);
; 1375 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 1376 :       break;
; 1377 :     }
; 1378 :     case 3: /* tdea-192 */
; 1379 :     {
; 1380 :       LOGBYTE("k1    :", parameter_block, 8);
; 1381 :       LOGBYTE("k2    :", &parameter_block[8], 8);
; 1382 :       LOGBYTE("k3    :", &parameter_block[16], 8);
; 1383 :       break;
; 1384 :     }
; 1385 :   }
; 1386 :   if(wrap)
; 1387 :     LOGBYTE("wkvp  :", &parameter_block[keylen], 24);
; 1388 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1389 : 
; 1390 : #if defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 )
; 1391 :   /* Verify and unwrap */
; 1392 :   if(wrap && unwrap_dea(parameter_block, keylen))

  001a4	83 7c 24 54 00	 cmp	 DWORD PTR wrap$[rsp], 0
  001a9	74 26		 je	 SHORT $LN12@s370_km_de
  001ab	8b 54 24 58	 mov	 edx, DWORD PTR keylen$[rsp]
  001af	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001b7	e8 00 00 00 00	 call	 unwrap_dea
  001bc	85 c0		 test	 eax, eax
  001be	74 11		 je	 SHORT $LN12@s370_km_de

; 1393 :   {
; 1394 : 
; 1395 : #ifdef OPTION_KM_DEBUG
; 1396 :     WRMSG(HHC90111, "D");
; 1397 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1398 : 
; 1399 :     regs->psw.cc = 1;

  001c0	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  001c8	c6 40 7c 01	 mov	 BYTE PTR [rax+124], 1

; 1400 :     return;

  001cc	e9 7e 03 00 00	 jmp	 $LN1@s370_km_de
$LN12@s370_km_de:

; 1401 :   }
; 1402 : #endif /* defined( FEATURE_076_MSA_EXTENSION_FACILITY_3 ) */
; 1403 : 
; 1404 :   /* Set the cryptographic key */
; 1405 :   switch(tfc)

  001d1	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  001d5	89 44 24 34	 mov	 DWORD PTR tv173[rsp], eax
  001d9	83 7c 24 34 01	 cmp	 DWORD PTR tv173[rsp], 1
  001de	74 10		 je	 SHORT $LN13@s370_km_de
  001e0	83 7c 24 34 02	 cmp	 DWORD PTR tv173[rsp], 2
  001e5	74 20		 je	 SHORT $LN14@s370_km_de
  001e7	83 7c 24 34 03	 cmp	 DWORD PTR tv173[rsp], 3
  001ec	74 44		 je	 SHORT $LN15@s370_km_de
  001ee	eb 7f		 jmp	 SHORT $LN2@s370_km_de
$LN13@s370_km_de:

; 1406 :   {
; 1407 :     case 1: /* dea */
; 1408 :     {
; 1409 :       des_set_key(&des_ctx, parameter_block);

  001f0	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  001f8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  00200	e8 00 00 00 00	 call	 des_set_key

; 1410 :       break;

  00205	eb 68		 jmp	 SHORT $LN2@s370_km_de
$LN14@s370_km_de:

; 1411 :     }
; 1412 :     case 2: /* tdea-128 */
; 1413 :     {
; 1414 :       des3_set_2keys(&des3_ctx, parameter_block, &parameter_block[8]);

  00207	b8 01 00 00 00	 mov	 eax, 1
  0020c	48 6b c0 08	 imul	 rax, rax, 8
  00210	48 8d 84 04 b8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00218	4c 8b c0	 mov	 r8, rax
  0021b	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00223	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  0022b	e8 00 00 00 00	 call	 des3_set_2keys

; 1415 :       break;

  00230	eb 3d		 jmp	 SHORT $LN2@s370_km_de
$LN15@s370_km_de:

; 1416 :     }
; 1417 :     case 3: /* tdea-192 */
; 1418 :     {
; 1419 :       des3_set_3keys(&des3_ctx, parameter_block, &parameter_block[8], &parameter_block[16]);

  00232	b8 01 00 00 00	 mov	 eax, 1
  00237	48 6b c0 10	 imul	 rax, rax, 16
  0023b	48 8d 84 04 b8
	02 00 00	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  00243	b9 01 00 00 00	 mov	 ecx, 1
  00248	48 6b c9 08	 imul	 rcx, rcx, 8
  0024c	48 8d 8c 0c b8
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00254	4c 8b c8	 mov	 r9, rax
  00257	4c 8b c1	 mov	 r8, rcx
  0025a	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00262	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  0026a	e8 00 00 00 00	 call	 des3_set_3keys
$LN2@s370_km_de:

; 1420 :       break;
; 1421 :     }
; 1422 :   }
; 1423 : 
; 1424 :   /* Try to process the CPU-determined amount of data */
; 1425 :   modifier_bit = GR0_m(regs);

  0026f	b8 08 00 00 00	 mov	 eax, 8
  00274	48 6b c0 00	 imul	 rax, rax, 0
  00278	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00280	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00287	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0028c	85 c0		 test	 eax, eax
  0028e	74 0a		 je	 SHORT $LN38@s370_km_de
  00290	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv198[rsp], 1
  00298	eb 08		 jmp	 SHORT $LN39@s370_km_de
$LN38@s370_km_de:
  0029a	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
$LN39@s370_km_de:
  002a2	8b 44 24 5c	 mov	 eax, DWORD PTR tv198[rsp]
  002a6	89 44 24 64	 mov	 DWORD PTR modifier_bit$[rsp], eax

; 1426 :   r1_is_not_r2 = r1 != r2;

  002aa	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002b1	39 84 24 00 03
	00 00		 cmp	 DWORD PTR r1$[rsp], eax
  002b8	74 0a		 je	 SHORT $LN40@s370_km_de
  002ba	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv200[rsp], 1
  002c2	eb 08		 jmp	 SHORT $LN41@s370_km_de
$LN40@s370_km_de:
  002c4	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv200[rsp], 0
$LN41@s370_km_de:
  002cc	8b 44 24 60	 mov	 eax, DWORD PTR tv200[rsp]
  002d0	89 44 24 74	 mov	 DWORD PTR r1_is_not_r2$[rsp], eax

; 1427 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 8)

  002d4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  002dc	eb 0b		 jmp	 SHORT $LN6@s370_km_de
$LN4@s370_km_de:
  002de	8b 44 24 38	 mov	 eax, DWORD PTR crypted$[rsp]
  002e2	83 c0 08	 add	 eax, 8
  002e5	89 44 24 38	 mov	 DWORD PTR crypted$[rsp], eax
$LN6@s370_km_de:
  002e9	81 7c 24 38 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  002f1	0f 8d 4c 02 00
	00		 jge	 $LN5@s370_km_de

; 1428 :   {
; 1429 :     /* Fetch a block of data */
; 1430 :     ARCH_DEP(vfetchc)(message_block, 7, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  002f7	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  002ff	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00307	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0030e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00313	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0031b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00320	44 8b 8c 24 08
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  00328	44 8b c0	 mov	 r8d, eax
  0032b	b2 07		 mov	 dl, 7
  0032d	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00335	e8 00 00 00 00	 call	 s370_vfetchc

; 1431 : 
; 1432 : #ifdef OPTION_KM_DEBUG
; 1433 :     LOGBYTE("input :", message_block, 8);
; 1434 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1435 : 
; 1436 :     /* Do the job */
; 1437 :     switch(tfc)

  0033a	8b 44 24 3c	 mov	 eax, DWORD PTR tfc$[rsp]
  0033e	89 44 24 40	 mov	 DWORD PTR tv214[rsp], eax
  00342	83 7c 24 40 01	 cmp	 DWORD PTR tv214[rsp], 1
  00347	74 13		 je	 SHORT $LN16@s370_km_de
  00349	83 7c 24 40 02	 cmp	 DWORD PTR tv214[rsp], 2
  0034e	74 51		 je	 SHORT $LN19@s370_km_de
  00350	83 7c 24 40 03	 cmp	 DWORD PTR tv214[rsp], 3
  00355	74 4a		 je	 SHORT $LN20@s370_km_de
  00357	e9 88 00 00 00	 jmp	 $LN7@s370_km_de
$LN16@s370_km_de:

; 1438 :     {
; 1439 :       case 1: /* dea */
; 1440 :       {
; 1441 :         if(modifier_bit)

  0035c	83 7c 24 64 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  00361	74 1f		 je	 SHORT $LN17@s370_km_de

; 1442 :           des_decrypt(&des_ctx, message_block, message_block);

  00363	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0036b	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00373	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  0037b	e8 00 00 00 00	 call	 des_decrypt
  00380	eb 1d		 jmp	 SHORT $LN18@s370_km_de
$LN17@s370_km_de:

; 1443 :         else
; 1444 :           des_encrypt(&des_ctx, message_block, message_block);

  00382	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  0038a	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00392	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR des_ctx$[rsp]
  0039a	e8 00 00 00 00	 call	 des_encrypt
$LN18@s370_km_de:

; 1445 :         break;

  0039f	eb 43		 jmp	 SHORT $LN7@s370_km_de
$LN19@s370_km_de:
$LN20@s370_km_de:

; 1446 :       }
; 1447 :       case 2: /* tdea-128 */
; 1448 :       case 3: /* tdea-192 */
; 1449 :       {
; 1450 :         if(modifier_bit)

  003a1	83 7c 24 64 00	 cmp	 DWORD PTR modifier_bit$[rsp], 0
  003a6	74 1f		 je	 SHORT $LN21@s370_km_de

; 1451 :           des3_decrypt(&des3_ctx, message_block, message_block);

  003a8	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003b0	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003b8	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  003c0	e8 00 00 00 00	 call	 des3_decrypt
  003c5	eb 1d		 jmp	 SHORT $LN22@s370_km_de
$LN21@s370_km_de:

; 1452 :         else
; 1453 :           des3_encrypt(&des3_ctx, message_block, message_block);

  003c7	4c 8d 84 24 b0
	02 00 00	 lea	 r8, QWORD PTR message_block$[rsp]
  003cf	48 8d 94 24 b0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003d7	48 8d 8c 24 10
	01 00 00	 lea	 rcx, QWORD PTR des3_ctx$[rsp]
  003df	e8 00 00 00 00	 call	 des3_encrypt
$LN22@s370_km_de:
$LN7@s370_km_de:

; 1454 :         break;
; 1455 :       }
; 1456 :     }
; 1457 : 
; 1458 :     /* Store the output */
; 1459 :     ARCH_DEP(vstorec)(message_block, 7, GR_A(r1, regs) & ADDRESS_MAXWRAP(regs), r1, regs);

  003e4	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  003ec	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003fb	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00400	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00408	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0040d	44 8b 8c 24 00
	03 00 00	 mov	 r9d, DWORD PTR r1$[rsp]
  00415	44 8b c0	 mov	 r8d, eax
  00418	b2 07		 mov	 dl, 7
  0041a	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  00422	e8 00 00 00 00	 call	 s370_vstorec

; 1460 : 
; 1461 : #ifdef OPTION_KM_DEBUG
; 1462 :     LOGBYTE("output:", message_block, 8);
; 1463 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1464 : 
; 1465 :     /* Update the registers */
; 1466 :     SET_GR_A(r1, regs, GR_A(r1, regs) + 8);

  00427	48 63 84 24 00
	03 00 00	 movsxd	 rax, DWORD PTR r1$[rsp]
  0042f	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00437	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0043e	83 c0 08	 add	 eax, 8
  00441	48 63 8c 24 00
	03 00 00	 movsxd	 rcx, DWORD PTR r1$[rsp]
  00449	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00451	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1467 :     if(likely(r1_is_not_r2))

  00458	83 7c 24 74 00	 cmp	 DWORD PTR r1_is_not_r2$[rsp], 0
  0045d	74 0a		 je	 SHORT $LN42@s370_km_de
  0045f	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv255[rsp], 1
  00467	eb 08		 jmp	 SHORT $LN43@s370_km_de
$LN42@s370_km_de:
  00469	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv255[rsp], 0
$LN43@s370_km_de:
  00471	83 7c 24 68 00	 cmp	 DWORD PTR tv255[rsp], 0
  00476	74 31		 je	 SHORT $LN23@s370_km_de

; 1468 :       SET_GR_A(r2, regs, GR_A(r2, regs) + 8);

  00478	48 63 84 24 08
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00480	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00488	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0048f	83 c0 08	 add	 eax, 8
  00492	48 63 8c 24 08
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  0049a	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004a2	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax
$LN23@s370_km_de:

; 1469 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 8);

  004a9	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004b0	ff c0		 inc	 eax
  004b2	48 98		 cdqe
  004b4	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004bc	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  004c3	83 e8 08	 sub	 eax, 8
  004c6	8b 8c 24 08 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  004cd	ff c1		 inc	 ecx
  004cf	48 63 c9	 movsxd	 rcx, ecx
  004d2	48 8b 94 24 10
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  004da	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1470 : 
; 1471 : #ifdef OPTION_KM_DEBUG
; 1472 :     WRMSG(HHC90108, "D", r1, (regs)->GR(r1));
; 1473 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1474 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1475 : #endif /* #ifdef OPTION_KM_DEBUG */
; 1476 : 
; 1477 :     /* check for end of data */
; 1478 :     if(unlikely(!GR_A(r2 + 1, regs)))

  004e1	8b 84 24 08 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  004e8	ff c0		 inc	 eax
  004ea	48 98		 cdqe
  004ec	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  004f4	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  004fc	75 0a		 jne	 SHORT $LN44@s370_km_de
  004fe	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv288[rsp], 1
  00506	eb 08		 jmp	 SHORT $LN45@s370_km_de
$LN44@s370_km_de:
  00508	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv288[rsp], 0
$LN45@s370_km_de:
  00510	83 7c 24 6c 00	 cmp	 DWORD PTR tv288[rsp], 0
  00515	74 0a		 je	 SHORT $LN48@s370_km_de
  00517	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv299[rsp], 1
  0051f	eb 08		 jmp	 SHORT $LN49@s370_km_de
$LN48@s370_km_de:
  00521	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv299[rsp], 0
$LN49@s370_km_de:
  00529	83 7c 24 70 00	 cmp	 DWORD PTR tv299[rsp], 0
  0052e	74 0e		 je	 SHORT $LN24@s370_km_de

; 1479 :     {
; 1480 :       regs->psw.cc = 0;

  00530	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00538	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1481 :       return;

  0053c	eb 11		 jmp	 SHORT $LN1@s370_km_de
$LN24@s370_km_de:

; 1482 :     }
; 1483 :   }

  0053e	e9 9b fd ff ff	 jmp	 $LN4@s370_km_de
$LN5@s370_km_de:

; 1484 : 
; 1485 :   /* CPU-determined amount of data processed */
; 1486 :   regs->psw.cc = 3;

  00543	48 8b 84 24 10
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0054b	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_km_de:

; 1487 : }

  0054f	48 8b 8c 24 e8
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00557	48 33 cc	 xor	 rcx, rsp
  0055a	e8 00 00 00 00	 call	 __security_check_cookie
  0055f	48 81 c4 f8 02
	00 00		 add	 rsp, 760		; 000002f8H
  00566	c3		 ret	 0
s370_km_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
mbllen$ = 52
message_blocklen$ = 56
parameter_blocklen$ = 60
fc$ = 64
tv70 = 68
tv155 = 72
tv223 = 76
tv250 = 80
tv90 = 84
tv178 = 88
tv211 = 92
$T1 = 96
$T2 = 104
$T3 = 112
sha1_ctx$ = 128
sha2_ctx$ = 224
sha512_ctx$ = 432
parameter_block$ = 640
message_block$ = 720
__$ArrayPad$ = 848
r1$ = 896
r2$ = 904
regs$ = 912
s370_klmd_sha PROC

; 1101 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	56		 push	 rsi
  0000e	57		 push	 rdi
  0000f	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1102 :   SHA1_CTX sha1_ctx;
; 1103 : 
; 1104 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1105 :   SHA2_CTX sha2_ctx;
; 1106 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1107 : 
; 1108 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1109 :   SHA2_CTX sha512_ctx;
; 1110 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1111 : 
; 1112 :   int fc;
; 1113 :   int i;
; 1114 :   int mbllen = 0;

  00028	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 0

; 1115 :   BYTE message_block[128];
; 1116 :   int message_blocklen = 0;

  00030	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 0

; 1117 :   BYTE parameter_block[80];
; 1118 :   int parameter_blocklen = 0;

  00038	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 0
$LN4@s370_klmd_:

; 1119 : 
; 1120 :   UNREFERENCED(r1);

  00040	33 c0		 xor	 eax, eax
  00042	85 c0		 test	 eax, eax
  00044	75 fa		 jne	 SHORT $LN4@s370_klmd_

; 1121 : 
; 1122 :   /* Initialize values */
; 1123 :   fc = GR0_fc(regs);

  00046	b8 08 00 00 00	 mov	 eax, 8
  0004b	48 6b c0 00	 imul	 rax, rax, 0
  0004f	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00057	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0005e	83 e0 7f	 and	 eax, 127		; 0000007fH
  00061	89 44 24 40	 mov	 DWORD PTR fc$[rsp], eax

; 1124 :   switch(fc)

  00065	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  00069	89 44 24 44	 mov	 DWORD PTR tv70[rsp], eax
  0006d	83 7c 24 44 01	 cmp	 DWORD PTR tv70[rsp], 1
  00072	74 10		 je	 SHORT $LN20@s370_klmd_
  00074	83 7c 24 44 02	 cmp	 DWORD PTR tv70[rsp], 2
  00079	74 23		 je	 SHORT $LN21@s370_klmd_
  0007b	83 7c 24 44 03	 cmp	 DWORD PTR tv70[rsp], 3
  00080	74 36		 je	 SHORT $LN22@s370_klmd_
  00082	eb 4c		 jmp	 SHORT $LN5@s370_klmd_
$LN20@s370_klmd_:

; 1125 :   {
; 1126 :     case 1: /* sha-1 */
; 1127 :     {
; 1128 :       mbllen = 8;

  00084	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 8

; 1129 :       message_blocklen = 64;

  0008c	c7 44 24 38 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 1130 :       parameter_blocklen = 20;

  00094	c7 44 24 3c 14
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 20

; 1131 :       break;

  0009c	eb 32		 jmp	 SHORT $LN5@s370_klmd_
$LN21@s370_klmd_:

; 1132 :     }
; 1133 : 
; 1134 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1135 :     case 2: /* sha-256 */
; 1136 :     {
; 1137 :       mbllen = 8;

  0009e	c7 44 24 34 08
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 8

; 1138 :       message_blocklen = 64;

  000a6	c7 44 24 38 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 1139 :       parameter_blocklen = 32;

  000ae	c7 44 24 3c 20
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 32 ; 00000020H

; 1140 :       break;

  000b6	eb 18		 jmp	 SHORT $LN5@s370_klmd_
$LN22@s370_klmd_:

; 1141 :     }
; 1142 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1143 : 
; 1144 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1145 :     case 3: /* sha-512 */
; 1146 :     {
; 1147 :       mbllen = 16;

  000b8	c7 44 24 34 10
	00 00 00	 mov	 DWORD PTR mbllen$[rsp], 16

; 1148 :       message_blocklen = 128;

  000c0	c7 44 24 38 80
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 128 ; 00000080H

; 1149 :       parameter_blocklen = 64;

  000c8	c7 44 24 3c 40
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 64 ; 00000040H
$LN5@s370_klmd_:

; 1150 :     }
; 1151 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1152 : 
; 1153 :   }
; 1154 : 
; 1155 :   /* Process intermediate message blocks */
; 1156 :   if(unlikely(GR_A(r2 + 1, regs) >= (unsigned) message_blocklen))

  000d0	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000d7	ff c0		 inc	 eax
  000d9	48 98		 cdqe
  000db	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000e3	8b 54 24 38	 mov	 edx, DWORD PTR message_blocklen$[rsp]
  000e7	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  000ee	72 0a		 jb	 SHORT $LN40@s370_klmd_
  000f0	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000f8	eb 08		 jmp	 SHORT $LN41@s370_klmd_
$LN40@s370_klmd_:
  000fa	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN41@s370_klmd_:
  00102	83 7c 24 54 00	 cmp	 DWORD PTR tv90[rsp], 0
  00107	74 37		 je	 SHORT $LN23@s370_klmd_

; 1157 :   {
; 1158 :     ARCH_DEP(kimd_sha)(r1, r2, regs, 1);

  00109	41 b9 01 00 00
	00		 mov	 r9d, 1
  0010f	4c 8b 84 24 90
	03 00 00	 mov	 r8, QWORD PTR regs$[rsp]
  00117	8b 94 24 88 03
	00 00		 mov	 edx, DWORD PTR r2$[rsp]
  0011e	8b 8c 24 80 03
	00 00		 mov	 ecx, DWORD PTR r1$[rsp]
  00125	e8 00 00 00 00	 call	 s370_kimd_sha

; 1159 :     if(regs->psw.cc == 3)

  0012a	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00132	0f b6 40 7c	 movzx	 eax, BYTE PTR [rax+124]
  00136	83 f8 03	 cmp	 eax, 3
  00139	75 05		 jne	 SHORT $LN24@s370_klmd_

; 1160 :       return;

  0013b	e9 d9 04 00 00	 jmp	 $LN1@s370_klmd_
$LN24@s370_klmd_:
$LN23@s370_klmd_:

; 1161 :   }
; 1162 : 
; 1163 :   /* Test writeability output chaining value */
; 1164 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  00140	8b 44 24 3c	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00144	ff c8		 dec	 eax
  00146	b9 08 00 00 00	 mov	 ecx, 8
  0014b	48 6b c9 01	 imul	 rcx, rcx, 1
  0014f	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00157	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  0015e	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00164	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0016c	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00171	41 b9 02 00 00
	00		 mov	 r9d, 2
  00177	44 8b c0	 mov	 r8d, eax
  0017a	ba 01 00 00 00	 mov	 edx, 1
  0017f	e8 00 00 00 00	 call	 s370_validate_operand

; 1165 : 
; 1166 :   /* Fetch the parameter block */
; 1167 :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen + mbllen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00184	b8 08 00 00 00	 mov	 eax, 8
  00189	48 6b c0 01	 imul	 rax, rax, 1
  0018d	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00195	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0019c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001a1	8b 4c 24 3c	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001a5	8b 54 24 34	 mov	 edx, DWORD PTR mbllen$[rsp]
  001a9	8d 4c 11 ff	 lea	 ecx, DWORD PTR [rcx+rdx-1]
  001ad	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001b5	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001ba	41 b9 01 00 00
	00		 mov	 r9d, 1
  001c0	44 8b c0	 mov	 r8d, eax
  001c3	0f b6 d1	 movzx	 edx, cl
  001c6	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001ce	e8 00 00 00 00	 call	 s370_vfetchc

; 1168 : 
; 1169 : #ifdef OPTION_KLMD_DEBUG
; 1170 :   if(parameter_blocklen > 32)
; 1171 :   {
; 1172 :     LOGBYTE2("icv   :", parameter_block, 16, parameter_blocklen / 16);
; 1173 :   }
; 1174 :   else
; 1175 :   {
; 1176 :     LOGBYTE("icv   :", parameter_block, parameter_blocklen);
; 1177 :   }
; 1178 :   LOGBYTE("mbl   :", &parameter_block[parameter_blocklen], mbllen);
; 1179 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1180 : 
; 1181 :   /* Set initial chaining value */
; 1182 :   switch(fc)

  001d3	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  001d7	89 44 24 48	 mov	 DWORD PTR tv155[rsp], eax
  001db	83 7c 24 48 01	 cmp	 DWORD PTR tv155[rsp], 1
  001e0	74 10		 je	 SHORT $LN25@s370_klmd_
  001e2	83 7c 24 48 02	 cmp	 DWORD PTR tv155[rsp], 2
  001e7	74 20		 je	 SHORT $LN26@s370_klmd_
  001e9	83 7c 24 48 03	 cmp	 DWORD PTR tv155[rsp], 3
  001ee	74 30		 je	 SHORT $LN27@s370_klmd_
  001f0	eb 43		 jmp	 SHORT $LN7@s370_klmd_
$LN25@s370_klmd_:

; 1183 :   {
; 1184 :     case 1: /* sha-1 */
; 1185 :     {
; 1186 :       sha1_seticv(&sha1_ctx, parameter_block);

  001f2	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  001fa	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00202	e8 00 00 00 00	 call	 sha1_seticv

; 1187 :       break;

  00207	eb 2c		 jmp	 SHORT $LN7@s370_klmd_
$LN26@s370_klmd_:

; 1188 :     }
; 1189 : 
; 1190 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1191 :     case 2: /* sha-256 */
; 1192 :     {
; 1193 :       sha256_seticv(&sha2_ctx, parameter_block);

  00209	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00211	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00219	e8 00 00 00 00	 call	 sha256_seticv

; 1194 :       break;

  0021e	eb 15		 jmp	 SHORT $LN7@s370_klmd_
$LN27@s370_klmd_:

; 1195 :     }
; 1196 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1197 : 
; 1198 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1199 :     case 3: /* sha-512 */
; 1200 :     {
; 1201 :       sha512_seticv(&sha512_ctx, parameter_block);

  00220	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00228	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00230	e8 00 00 00 00	 call	 sha512_seticv
$LN7@s370_klmd_:

; 1202 :       break;
; 1203 :     }
; 1204 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1205 : 
; 1206 :   }
; 1207 : 
; 1208 :   /* Fetch and process possible last block of data */
; 1209 :   if(likely(GR_A(r2 + 1, regs)))

  00235	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  0023c	ff c0		 inc	 eax
  0023e	48 98		 cdqe
  00240	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00248	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  00250	74 0a		 je	 SHORT $LN42@s370_klmd_
  00252	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv178[rsp], 1
  0025a	eb 08		 jmp	 SHORT $LN43@s370_klmd_
$LN42@s370_klmd_:
  0025c	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv178[rsp], 0
$LN43@s370_klmd_:
  00264	83 7c 24 58 00	 cmp	 DWORD PTR tv178[rsp], 0
  00269	74 61		 je	 SHORT $LN28@s370_klmd_

; 1210 :   {
; 1211 :     ARCH_DEP(vfetchc)(message_block, GR_A(r2 + 1, regs) - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  0026b	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00273	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0027b	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00282	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00287	8b 8c 24 88 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0028e	ff c1		 inc	 ecx
  00290	48 63 c9	 movsxd	 rcx, ecx
  00293	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0029b	8b 8c ca 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx*8+640]
  002a2	ff c9		 dec	 ecx
  002a4	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002ac	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002b1	44 8b 8c 24 88
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002b9	44 8b c0	 mov	 r8d, eax
  002bc	0f b6 d1	 movzx	 edx, cl
  002bf	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002c7	e8 00 00 00 00	 call	 s370_vfetchc
$LN28@s370_klmd_:

; 1212 : 
; 1213 : #ifdef OPTION_KLMD_DEBUG
; 1214 :     if(GR_A(r2 + 1, regs) > 32)
; 1215 :     {
; 1216 :       LOGBYTE("input :", message_block, 32);
; 1217 :       LOGBYTE("       ", &message_block[32], (int) GR_A(r2 + 1, regs) - 32);
; 1218 :     }
; 1219 :     else
; 1220 :       LOGBYTE("input :", message_block, (int) GR_A(r2 + 1, regs));
; 1221 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1222 : 
; 1223 :   }
; 1224 : 
; 1225 :   /* Do the padding */
; 1226 :   i = GR_A(r2 + 1, regs);

  002cc	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002d3	ff c0		 inc	 eax
  002d5	48 98		 cdqe
  002d7	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002df	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002e6	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 1227 :   if(unlikely(i >= (message_blocklen - mbllen)))

  002ea	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  002ee	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  002f2	2b c8		 sub	 ecx, eax
  002f4	8b c1		 mov	 eax, ecx
  002f6	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  002fa	7c 0a		 jl	 SHORT $LN46@s370_klmd_
  002fc	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv211[rsp], 1
  00304	eb 08		 jmp	 SHORT $LN47@s370_klmd_
$LN46@s370_klmd_:
  00306	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv211[rsp], 0
$LN47@s370_klmd_:
  0030e	83 7c 24 5c 00	 cmp	 DWORD PTR tv211[rsp], 0
  00313	0f 84 0b 01 00
	00		 je	 $LN29@s370_klmd_

; 1228 :   {
; 1229 :     message_block[i++] = 0x80;

  00319	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0031e	c6 84 04 d0 02
	00 00 80	 mov	 BYTE PTR message_block$[rsp+rax], 128 ; 00000080H
  00326	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0032a	ff c0		 inc	 eax
  0032c	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN9@s370_klmd_:

; 1230 :     while(i < message_blocklen)

  00330	8b 44 24 38	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  00334	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00338	7d 35		 jge	 SHORT $LN10@s370_klmd_

; 1231 :       message_block[i++] = 0x00;

  0033a	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  0033f	48 89 44 24 60	 mov	 QWORD PTR $T1[rsp], rax
  00344	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00348	ff c0		 inc	 eax
  0034a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  0034e	48 81 7c 24 60
	80 00 00 00	 cmp	 QWORD PTR $T1[rsp], 128	; 00000080H
  00357	73 02		 jae	 SHORT $LN48@s370_klmd_
  00359	eb 05		 jmp	 SHORT $LN49@s370_klmd_
$LN48@s370_klmd_:
  0035b	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN49@s370_klmd_:
  00360	48 8b 44 24 60	 mov	 rax, QWORD PTR $T1[rsp]
  00365	c6 84 04 d0 02
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  0036d	eb c1		 jmp	 SHORT $LN9@s370_klmd_
$LN10@s370_klmd_:

; 1232 :     switch(fc)

  0036f	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  00373	89 44 24 4c	 mov	 DWORD PTR tv223[rsp], eax
  00377	83 7c 24 4c 01	 cmp	 DWORD PTR tv223[rsp], 1
  0037c	74 10		 je	 SHORT $LN31@s370_klmd_
  0037e	83 7c 24 4c 02	 cmp	 DWORD PTR tv223[rsp], 2
  00383	74 20		 je	 SHORT $LN32@s370_klmd_
  00385	83 7c 24 4c 03	 cmp	 DWORD PTR tv223[rsp], 3
  0038a	74 30		 je	 SHORT $LN33@s370_klmd_
  0038c	eb 43		 jmp	 SHORT $LN11@s370_klmd_
$LN31@s370_klmd_:

; 1233 :     {
; 1234 :       case 1: /* sha-1 */
; 1235 :       {
; 1236 :         SHA1Transform(sha1_ctx.state, message_block);

  0038e	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00396	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  0039e	e8 00 00 00 00	 call	 SHA1Transform

; 1237 :         break;

  003a3	eb 2c		 jmp	 SHORT $LN11@s370_klmd_
$LN32@s370_klmd_:

; 1238 :       }
; 1239 : 
; 1240 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1241 :       case 2: /* sha-256 */
; 1242 :       {
; 1243 :         SHA256Transform(sha2_ctx.state.st32, message_block);

  003a5	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003ad	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  003b5	e8 00 00 00 00	 call	 SHA256Transform

; 1244 :         break;

  003ba	eb 15		 jmp	 SHORT $LN11@s370_klmd_
$LN33@s370_klmd_:

; 1245 :       }
; 1246 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1247 : 
; 1248 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1249 :       case 3: /* sha-512 */
; 1250 :       {
; 1251 :         SHA512Transform(sha512_ctx.state.st64, message_block);

  003bc	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  003c4	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  003cc	e8 00 00 00 00	 call	 SHA512Transform
$LN11@s370_klmd_:

; 1252 :         break;
; 1253 :       }
; 1254 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1255 : 
; 1256 :     }
; 1257 :     for(i = 0; i < message_blocklen - mbllen; i++)

  003d1	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  003d9	eb 0a		 jmp	 SHORT $LN15@s370_klmd_
$LN13@s370_klmd_:
  003db	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  003df	ff c0		 inc	 eax
  003e1	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN15@s370_klmd_:
  003e5	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  003e9	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  003ed	2b c8		 sub	 ecx, eax
  003ef	8b c1		 mov	 eax, ecx
  003f1	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  003f5	7d 2b		 jge	 SHORT $LN14@s370_klmd_

; 1258 :       message_block[i] = 0x00;

  003f7	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  003fc	48 89 44 24 68	 mov	 QWORD PTR $T2[rsp], rax
  00401	48 81 7c 24 68
	80 00 00 00	 cmp	 QWORD PTR $T2[rsp], 128	; 00000080H
  0040a	73 02		 jae	 SHORT $LN50@s370_klmd_
  0040c	eb 05		 jmp	 SHORT $LN51@s370_klmd_
$LN50@s370_klmd_:
  0040e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN51@s370_klmd_:
  00413	48 8b 44 24 68	 mov	 rax, QWORD PTR $T2[rsp]
  00418	c6 84 04 d0 02
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  00420	eb b9		 jmp	 SHORT $LN13@s370_klmd_
$LN14@s370_klmd_:

; 1259 :   }

  00422	eb 5e		 jmp	 SHORT $LN30@s370_klmd_
$LN29@s370_klmd_:

; 1260 :   else
; 1261 :   {
; 1262 :     message_block[i++] = 0x80;

  00424	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00429	c6 84 04 d0 02
	00 00 80	 mov	 BYTE PTR message_block$[rsp+rax], 128 ; 00000080H
  00431	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00435	ff c0		 inc	 eax
  00437	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN16@s370_klmd_:

; 1263 :     while(i < message_blocklen - mbllen)

  0043b	8b 44 24 34	 mov	 eax, DWORD PTR mbllen$[rsp]
  0043f	8b 4c 24 38	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  00443	2b c8		 sub	 ecx, eax
  00445	8b c1		 mov	 eax, ecx
  00447	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  0044b	7d 35		 jge	 SHORT $LN17@s370_klmd_

; 1264 :       message_block[i++] = 0x00;

  0044d	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00452	48 89 44 24 70	 mov	 QWORD PTR $T3[rsp], rax
  00457	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0045b	ff c0		 inc	 eax
  0045d	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
  00461	48 81 7c 24 70
	80 00 00 00	 cmp	 QWORD PTR $T3[rsp], 128	; 00000080H
  0046a	73 02		 jae	 SHORT $LN52@s370_klmd_
  0046c	eb 05		 jmp	 SHORT $LN53@s370_klmd_
$LN52@s370_klmd_:
  0046e	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN53@s370_klmd_:
  00473	48 8b 44 24 70	 mov	 rax, QWORD PTR $T3[rsp]
  00478	c6 84 04 d0 02
	00 00 00	 mov	 BYTE PTR message_block$[rsp+rax], 0
  00480	eb b9		 jmp	 SHORT $LN16@s370_klmd_
$LN17@s370_klmd_:
$LN30@s370_klmd_:

; 1265 :   }
; 1266 : 
; 1267 :   /* Set the message bit length */
; 1268 :   memcpy(&message_block[message_blocklen - mbllen], &parameter_block[parameter_blocklen], mbllen);

  00482	48 63 44 24 34	 movsxd	 rax, DWORD PTR mbllen$[rsp]
  00487	48 63 4c 24 3c	 movsxd	 rcx, DWORD PTR parameter_blocklen$[rsp]
  0048c	48 8d 8c 0c 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp+rcx]
  00494	8b 54 24 34	 mov	 edx, DWORD PTR mbllen$[rsp]
  00498	44 8b 44 24 38	 mov	 r8d, DWORD PTR message_blocklen$[rsp]
  0049d	44 2b c2	 sub	 r8d, edx
  004a0	41 8b d0	 mov	 edx, r8d
  004a3	48 63 d2	 movsxd	 rdx, edx
  004a6	48 8d 94 14 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp+rdx]
  004ae	48 8b fa	 mov	 rdi, rdx
  004b1	48 8b f1	 mov	 rsi, rcx
  004b4	48 8b c8	 mov	 rcx, rax
  004b7	f3 a4		 rep movsb

; 1269 : 
; 1270 :   /* Calculate and store the message digest */
; 1271 :   switch(fc)

  004b9	8b 44 24 40	 mov	 eax, DWORD PTR fc$[rsp]
  004bd	89 44 24 50	 mov	 DWORD PTR tv250[rsp], eax
  004c1	83 7c 24 50 01	 cmp	 DWORD PTR tv250[rsp], 1
  004c6	74 13		 je	 SHORT $LN34@s370_klmd_
  004c8	83 7c 24 50 02	 cmp	 DWORD PTR tv250[rsp], 2
  004cd	74 38		 je	 SHORT $LN35@s370_klmd_
  004cf	83 7c 24 50 03	 cmp	 DWORD PTR tv250[rsp], 3
  004d4	74 5d		 je	 SHORT $LN36@s370_klmd_
  004d6	e9 82 00 00 00	 jmp	 $LN18@s370_klmd_
$LN34@s370_klmd_:

; 1272 :   {
; 1273 :     case 1: /* sha-1 */
; 1274 :     {
; 1275 :       SHA1Transform(sha1_ctx.state, message_block);

  004db	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  004e3	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  004eb	e8 00 00 00 00	 call	 SHA1Transform

; 1276 :       sha1_getcv(&sha1_ctx, parameter_block);

  004f0	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  004f8	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00500	e8 00 00 00 00	 call	 sha1_getcv

; 1277 :       break;

  00505	eb 56		 jmp	 SHORT $LN18@s370_klmd_
$LN35@s370_klmd_:

; 1278 :     }
; 1279 : 
; 1280 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 1281 :     case 2: /* sha-256 */
; 1282 :     {
; 1283 :       SHA256Transform(sha2_ctx.state.st32, message_block);

  00507	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0050f	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00517	e8 00 00 00 00	 call	 SHA256Transform

; 1284 :       sha256_getcv(&sha2_ctx, parameter_block);

  0051c	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00524	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  0052c	e8 00 00 00 00	 call	 sha256_getcv

; 1285 :       break;

  00531	eb 2a		 jmp	 SHORT $LN18@s370_klmd_
$LN36@s370_klmd_:

; 1286 :     }
; 1287 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 1288 : 
; 1289 : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 1290 :     case 3: /* sha-512 */
; 1291 :     {
; 1292 :       SHA512Transform(sha512_ctx.state.st64, message_block);

  00533	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0053b	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00543	e8 00 00 00 00	 call	 SHA512Transform

; 1293 :       sha512_getcv(&sha512_ctx, parameter_block);

  00548	48 8d 94 24 80
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00550	48 8d 8c 24 b0
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00558	e8 00 00 00 00	 call	 sha512_getcv
$LN18@s370_klmd_:

; 1294 :       break;
; 1295 :     }
; 1296 : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 1297 : 
; 1298 :   }
; 1299 :   ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  0055d	b8 08 00 00 00	 mov	 eax, 8
  00562	48 6b c0 01	 imul	 rax, rax, 1
  00566	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0056e	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00575	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0057a	8b 4c 24 3c	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  0057e	ff c9		 dec	 ecx
  00580	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00588	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0058d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00593	44 8b c0	 mov	 r8d, eax
  00596	0f b6 d1	 movzx	 edx, cl
  00599	48 8d 8c 24 80
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  005a1	e8 00 00 00 00	 call	 s370_vstorec

; 1300 : 
; 1301 : #ifdef OPTION_KLMD_DEBUG
; 1302 :   if(parameter_blocklen > 32)
; 1303 :   {
; 1304 :     LOGBYTE2("md    :", parameter_block, 16, parameter_blocklen / 16);
; 1305 :   }
; 1306 :   else
; 1307 :   {
; 1308 :     LOGBYTE("md    :", parameter_block, parameter_blocklen);
; 1309 :   }
; 1310 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1311 : 
; 1312 :   /* Update registers */
; 1313 :   SET_GR_A(r2, regs, GR_A(r2, regs) + GR_A(r2 + 1, regs));

  005a6	48 63 84 24 88
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  005ae	8b 8c 24 88 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  005b5	ff c1		 inc	 ecx
  005b7	48 63 c9	 movsxd	 rcx, ecx
  005ba	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005c2	8b 84 c2 80 02
	00 00		 mov	 eax, DWORD PTR [rdx+rax*8+640]
  005c9	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005d1	03 84 ca 80 02
	00 00		 add	 eax, DWORD PTR [rdx+rcx*8+640]
  005d8	48 63 8c 24 88
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  005e0	48 8b 94 24 90
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  005e8	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1314 :   SET_GR_A(r2 + 1, regs, 0);

  005ef	8b 84 24 88 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  005f6	ff c0		 inc	 eax
  005f8	48 98		 cdqe
  005fa	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00602	c7 84 c1 80 02
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*8+640], 0

; 1315 : 
; 1316 : #ifdef OPTION_KLMD_DEBUG
; 1317 :   WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1318 :   WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1319 : #endif /* #ifdef OPTION_KLMD_DEBUG */
; 1320 : 
; 1321 :   /* Set condition code */
; 1322 :   regs->psw.cc = 0;

  0060d	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00615	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0
$LN1@s370_klmd_:
$LN37@s370_klmd_:

; 1323 : }

  00619	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00621	48 33 cc	 xor	 rcx, rsp
  00624	e8 00 00 00 00	 call	 __security_check_cookie
  00629	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  00630	5f		 pop	 rdi
  00631	5e		 pop	 rsi
  00632	c3		 ret	 0
s370_klmd_sha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 48
crypted$ = 52
tv83 = 56
tv94 = 60
tv137 = 64
tv234 = 68
tv245 = 72
parameter_block$ = 80
message_block$ = 112
__$ArrayPad$ = 128
r1$ = 160
r2$ = 168
regs$ = 176
s370_kimd_ghash PROC

; 1023 : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@s370_kimd_:

; 1024 :   int crypted;
; 1025 :   int i;
; 1026 :   BYTE message_block[16];
; 1027 :   BYTE parameter_block[32];
; 1028 : 
; 1029 :   UNREFERENCED(r1);

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@s370_kimd_

; 1030 : 
; 1031 :   /* Check special conditions */
; 1032 :   if(unlikely(GR_A(r2 + 1, regs) % 16))

  0002c	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00033	ff c0		 inc	 eax
  00035	48 98		 cdqe
  00037	33 d2		 xor	 edx, edx
  00039	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00041	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00048	b9 10 00 00 00	 mov	 ecx, 16
  0004d	f7 f1		 div	 ecx
  0004f	8b c2		 mov	 eax, edx
  00051	85 c0		 test	 eax, eax
  00053	74 0a		 je	 SHORT $LN17@s370_kimd_
  00055	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  0005d	eb 08		 jmp	 SHORT $LN18@s370_kimd_
$LN17@s370_kimd_:
  0005f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN18@s370_kimd_:
  00067	83 7c 24 38 00	 cmp	 DWORD PTR tv83[rsp], 0
  0006c	74 13		 je	 SHORT $LN11@s370_kimd_

; 1033 :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  0006e	ba 06 00 00 00	 mov	 edx, 6
  00073	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN11@s370_kimd_:

; 1034 : 
; 1035 :   /* Return with cc 0 on zero length */
; 1036 :   if(unlikely(!GR_A(r2 + 1, regs)))

  00081	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00088	ff c0		 inc	 eax
  0008a	48 98		 cdqe
  0008c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00094	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0009c	75 0a		 jne	 SHORT $LN19@s370_kimd_
  0009e	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000a6	eb 08		 jmp	 SHORT $LN20@s370_kimd_
$LN19@s370_kimd_:
  000a8	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN20@s370_kimd_:
  000b0	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000b5	74 0a		 je	 SHORT $LN23@s370_kimd_
  000b7	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN24@s370_kimd_
$LN23@s370_kimd_:
  000c1	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN24@s370_kimd_:
  000c9	83 7c 24 40 00	 cmp	 DWORD PTR tv137[rsp], 0
  000ce	74 11		 je	 SHORT $LN12@s370_kimd_

; 1037 :   {
; 1038 :     regs->psw.cc = 0;

  000d0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000d8	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1039 :     return;

  000dc	e9 56 02 00 00	 jmp	 $LN1@s370_kimd_
$LN12@s370_kimd_:

; 1040 :   }
; 1041 : 
; 1042 :   /* Test writeability output chaining value */
; 1043 :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, 15, ACCTYPE_WRITE, regs);

  000e1	b8 08 00 00 00	 mov	 eax, 8
  000e6	48 6b c0 01	 imul	 rax, rax, 1
  000ea	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000f2	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  000f9	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  000fe	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00106	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0010b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00111	41 b8 0f 00 00
	00		 mov	 r8d, 15
  00117	ba 01 00 00 00	 mov	 edx, 1
  0011c	8b c8		 mov	 ecx, eax
  0011e	e8 00 00 00 00	 call	 s370_validate_operand

; 1044 : 
; 1045 :   /* Fetch the parameter block */
; 1046 :   ARCH_DEP(vfetchc)(parameter_block, 31, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00123	b8 08 00 00 00	 mov	 eax, 8
  00128	48 6b c0 01	 imul	 rax, rax, 1
  0012c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00134	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  0013b	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00140	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00148	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0014d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00153	44 8b c0	 mov	 r8d, eax
  00156	b2 1f		 mov	 dl, 31
  00158	48 8d 4c 24 50	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0015d	e8 00 00 00 00	 call	 s370_vfetchc

; 1047 : 
; 1048 : #ifdef OPTION_KIMD_DEBUG
; 1049 :   LOGBYTE("icv   :", parameter_block, 16);
; 1050 :   LOGBYTE("h     :", &parameter_block[16], 16);
; 1051 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1052 : 
; 1053 :   /* Try to process the CPU-determined amount of data */
; 1054 :   for(crypted = 0; crypted < PROCESS_MAX; crypted += 16)

  00162	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  0016a	eb 0b		 jmp	 SHORT $LN7@s370_kimd_
$LN5@s370_kimd_:
  0016c	8b 44 24 34	 mov	 eax, DWORD PTR crypted$[rsp]
  00170	83 c0 10	 add	 eax, 16
  00173	89 44 24 34	 mov	 DWORD PTR crypted$[rsp], eax
$LN7@s370_kimd_:
  00177	81 7c 24 34 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  0017f	0f 8d a6 01 00
	00		 jge	 $LN6@s370_kimd_

; 1055 :   {
; 1056 :     /* Fetch and process a block of data */
; 1057 :     ARCH_DEP(vfetchc)(message_block, 15, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00185	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0018d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00195	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0019c	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001a1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001a9	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001ae	44 8b 8c 24 a8
	00 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  001b6	44 8b c0	 mov	 r8d, eax
  001b9	b2 0f		 mov	 dl, 15
  001bb	48 8d 4c 24 70	 lea	 rcx, QWORD PTR message_block$[rsp]
  001c0	e8 00 00 00 00	 call	 s370_vfetchc

; 1058 : 
; 1059 : #ifdef OPTION_KIMD_DEBUG
; 1060 :     LOGBYTE("input :", message_block, 16);
; 1061 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1062 : 
; 1063 :     /* XOR and multiply */
; 1064 :     for(i = 0; i < 16; i++)

  001c5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001cd	eb 0a		 jmp	 SHORT $LN10@s370_kimd_
$LN8@s370_kimd_:
  001cf	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001d3	ff c0		 inc	 eax
  001d5	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@s370_kimd_:
  001d9	83 7c 24 30 10	 cmp	 DWORD PTR i$[rsp], 16
  001de	7d 21		 jge	 SHORT $LN9@s370_kimd_

; 1065 :       parameter_block[i] ^= message_block[i];

  001e0	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  001e5	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ea	0f b6 4c 0c 70	 movzx	 ecx, BYTE PTR message_block$[rsp+rcx]
  001ef	0f b6 44 04 50	 movzx	 eax, BYTE PTR parameter_block$[rsp+rax]
  001f4	33 c1		 xor	 eax, ecx
  001f6	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR i$[rsp]
  001fb	88 44 0c 50	 mov	 BYTE PTR parameter_block$[rsp+rcx], al
  001ff	eb ce		 jmp	 SHORT $LN8@s370_kimd_
$LN9@s370_kimd_:

; 1066 :     gcm_gf_mult(parameter_block, &parameter_block[16], parameter_block);

  00201	b8 01 00 00 00	 mov	 eax, 1
  00206	48 6b c0 10	 imul	 rax, rax, 16
  0020a	48 8d 44 04 50	 lea	 rax, QWORD PTR parameter_block$[rsp+rax]
  0020f	4c 8d 44 24 50	 lea	 r8, QWORD PTR parameter_block$[rsp]
  00214	48 8b d0	 mov	 rdx, rax
  00217	48 8d 4c 24 50	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0021c	e8 00 00 00 00	 call	 gcm_gf_mult

; 1067 : 
; 1068 :     /* Store the output chaining value */
; 1069 :     ARCH_DEP(vstorec)(parameter_block, 15, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00221	b8 08 00 00 00	 mov	 eax, 8
  00226	48 6b c0 01	 imul	 rax, rax, 1
  0022a	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00232	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00239	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0023e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00246	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0024b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00251	44 8b c0	 mov	 r8d, eax
  00254	b2 0f		 mov	 dl, 15
  00256	48 8d 4c 24 50	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  0025b	e8 00 00 00 00	 call	 s370_vstorec

; 1070 : 
; 1071 : #ifdef OPTION_KIMD_DEBUG
; 1072 :     LOGBYTE("ocv   :", parameter_block, 16);
; 1073 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1074 : 
; 1075 :     /* Update the registers */
; 1076 :     SET_GR_A(r2, regs, GR_A(r2, regs) + 16);

  00260	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  00268	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00270	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00277	83 c0 10	 add	 eax, 16
  0027a	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  00282	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0028a	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1077 :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - 16);

  00291	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00298	ff c0		 inc	 eax
  0029a	48 98		 cdqe
  0029c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002a4	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  002ab	83 e8 10	 sub	 eax, 16
  002ae	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  002b5	ff c1		 inc	 ecx
  002b7	48 63 c9	 movsxd	 rcx, ecx
  002ba	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002c2	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 1078 : 
; 1079 : #ifdef OPTION_KIMD_DEBUG
; 1080 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1081 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1082 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1083 : 
; 1084 :     /* check for end of data */
; 1085 :     if(unlikely(!GR_A(r2 + 1, regs)))

  002c9	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  002d0	ff c0		 inc	 eax
  002d2	48 98		 cdqe
  002d4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  002dc	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  002e4	75 0a		 jne	 SHORT $LN25@s370_kimd_
  002e6	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv234[rsp], 1
  002ee	eb 08		 jmp	 SHORT $LN26@s370_kimd_
$LN25@s370_kimd_:
  002f0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv234[rsp], 0
$LN26@s370_kimd_:
  002f8	83 7c 24 44 00	 cmp	 DWORD PTR tv234[rsp], 0
  002fd	74 0a		 je	 SHORT $LN29@s370_kimd_
  002ff	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv245[rsp], 1
  00307	eb 08		 jmp	 SHORT $LN30@s370_kimd_
$LN29@s370_kimd_:
  00309	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv245[rsp], 0
$LN30@s370_kimd_:
  00311	83 7c 24 48 00	 cmp	 DWORD PTR tv245[rsp], 0
  00316	74 0e		 je	 SHORT $LN13@s370_kimd_

; 1086 :     {
; 1087 :       regs->psw.cc = 0;

  00318	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00320	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1088 :       return;

  00324	eb 11		 jmp	 SHORT $LN1@s370_kimd_
$LN13@s370_kimd_:

; 1089 :     }
; 1090 :   }

  00326	e9 41 fe ff ff	 jmp	 $LN5@s370_kimd_
$LN6@s370_kimd_:

; 1091 : 
; 1092 :   /* CPU-determined amount of data processed */
; 1093 :   regs->psw.cc = 3;

  0032b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00333	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kimd_:

; 1094 : }

  00337	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0033f	48 33 cc	 xor	 rcx, rsp
  00342	e8 00 00 00 00	 call	 __security_check_cookie
  00347	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  0034e	c3		 ret	 0
s370_kimd_ghash ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
message_blocklen$ = 48
parameter_blocklen$ = 52
tv70 = 56
tv173 = 60
crypted$ = 64
fc$ = 68
tv198 = 72
tv93 = 76
tv136 = 80
tv147 = 84
tv266 = 88
tv272 = 92
sha1_ctx$ = 96
sha2_ctx$ = 192
sha512_ctx$ = 400
parameter_block$ = 608
message_block$ = 672
__$ArrayPad$ = 800
r1$ = 832
r2$ = 840
regs$ = 848
klmd$ = 856
s370_kimd_sha PROC

; 837  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 38 03
	00 00		 sub	 rsp, 824		; 00000338H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 20
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 838  :   SHA1_CTX sha1_ctx;
; 839  : 
; 840  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 841  :   SHA2_CTX sha2_ctx;
; 842  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 843  : 
; 844  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 845  :   SHA2_CTX sha512_ctx;
; 846  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 847  : 
; 848  :   int crypted;
; 849  :   int fc;
; 850  :   BYTE message_block[128];
; 851  :   int message_blocklen = 0;

  0002b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 0

; 852  :   BYTE parameter_block[64];
; 853  :   int parameter_blocklen = 0;

  00033	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 0
$LN4@s370_kimd_:

; 854  : 
; 855  :   UNREFERENCED(r1);

  0003b	33 c0		 xor	 eax, eax
  0003d	85 c0		 test	 eax, eax
  0003f	75 fa		 jne	 SHORT $LN4@s370_kimd_

; 856  : 
; 857  :   /* Initialize values */
; 858  :   fc = GR0_fc(regs);

  00041	b8 08 00 00 00	 mov	 eax, 8
  00046	48 6b c0 00	 imul	 rax, rax, 0
  0004a	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00052	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00059	83 e0 7f	 and	 eax, 127		; 0000007fH
  0005c	89 44 24 44	 mov	 DWORD PTR fc$[rsp], eax

; 859  :   switch(fc)

  00060	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  00064	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
  00068	83 7c 24 38 01	 cmp	 DWORD PTR tv70[rsp], 1
  0006d	74 10		 je	 SHORT $LN14@s370_kimd_
  0006f	83 7c 24 38 02	 cmp	 DWORD PTR tv70[rsp], 2
  00074	74 1b		 je	 SHORT $LN15@s370_kimd_
  00076	83 7c 24 38 03	 cmp	 DWORD PTR tv70[rsp], 3
  0007b	74 26		 je	 SHORT $LN16@s370_kimd_
  0007d	eb 34		 jmp	 SHORT $LN5@s370_kimd_
$LN14@s370_kimd_:

; 860  :   {
; 861  :     case 1: /* sha-1 */
; 862  :     {
; 863  :       message_blocklen = 64;

  0007f	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 864  :       parameter_blocklen = 20;

  00087	c7 44 24 34 14
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 20

; 865  :       break;

  0008f	eb 22		 jmp	 SHORT $LN5@s370_kimd_
$LN15@s370_kimd_:

; 866  :     }
; 867  : 
; 868  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 869  :     case 2: /* sha-256 */
; 870  :     {
; 871  :       message_blocklen = 64;

  00091	c7 44 24 30 40
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 64 ; 00000040H

; 872  :       parameter_blocklen = 32;

  00099	c7 44 24 34 20
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 32 ; 00000020H

; 873  :       break;

  000a1	eb 10		 jmp	 SHORT $LN5@s370_kimd_
$LN16@s370_kimd_:

; 874  :     }
; 875  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 876  : 
; 877  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 878  :     case 3: /* sha-512 */
; 879  :     {
; 880  :       message_blocklen = 128;

  000a3	c7 44 24 30 80
	00 00 00	 mov	 DWORD PTR message_blocklen$[rsp], 128 ; 00000080H

; 881  :       parameter_blocklen = 64;

  000ab	c7 44 24 34 40
	00 00 00	 mov	 DWORD PTR parameter_blocklen$[rsp], 64 ; 00000040H
$LN5@s370_kimd_:

; 882  :     }
; 883  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 884  : 
; 885  :   }
; 886  : 
; 887  :   /* Check special conditions */
; 888  :   if(unlikely(!klmd && (GR_A(r2 + 1, regs) % message_blocklen)))

  000b3	83 bc 24 58 03
	00 00 00	 cmp	 DWORD PTR klmd$[rsp], 0
  000bb	75 30		 jne	 SHORT $LN28@s370_kimd_
  000bd	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  000c4	ff c0		 inc	 eax
  000c6	48 98		 cdqe
  000c8	33 d2		 xor	 edx, edx
  000ca	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000d2	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  000d9	f7 74 24 30	 div	 DWORD PTR message_blocklen$[rsp]
  000dd	8b c2		 mov	 eax, edx
  000df	85 c0		 test	 eax, eax
  000e1	74 0a		 je	 SHORT $LN28@s370_kimd_
  000e3	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv93[rsp], 1
  000eb	eb 08		 jmp	 SHORT $LN31@s370_kimd_
$LN28@s370_kimd_:
  000ed	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN31@s370_kimd_:
  000f5	83 7c 24 4c 00	 cmp	 DWORD PTR tv93[rsp], 0
  000fa	74 13		 je	 SHORT $LN17@s370_kimd_

; 889  :     ARCH_DEP(program_interrupt)(regs, PGM_SPECIFICATION_EXCEPTION);

  000fc	ba 06 00 00 00	 mov	 edx, 6
  00101	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_program_interrupt
$LN17@s370_kimd_:

; 890  : 
; 891  :   /* Return with cc 0 on zero length */
; 892  :   if(unlikely(!GR_A(r2 + 1, regs)))

  0010f	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00116	ff c0		 inc	 eax
  00118	48 98		 cdqe
  0011a	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00122	83 bc c1 80 02
	00 00 00	 cmp	 DWORD PTR [rcx+rax*8+640], 0
  0012a	75 0a		 jne	 SHORT $LN32@s370_kimd_
  0012c	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  00134	eb 08		 jmp	 SHORT $LN33@s370_kimd_
$LN32@s370_kimd_:
  00136	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN33@s370_kimd_:
  0013e	83 7c 24 50 00	 cmp	 DWORD PTR tv136[rsp], 0
  00143	74 0a		 je	 SHORT $LN36@s370_kimd_
  00145	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv147[rsp], 1
  0014d	eb 08		 jmp	 SHORT $LN37@s370_kimd_
$LN36@s370_kimd_:
  0014f	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
$LN37@s370_kimd_:
  00157	83 7c 24 54 00	 cmp	 DWORD PTR tv147[rsp], 0
  0015c	74 11		 je	 SHORT $LN18@s370_kimd_

; 893  :   {
; 894  :     regs->psw.cc = 0;

  0015e	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00166	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 895  :     return;

  0016a	e9 2c 03 00 00	 jmp	 $LN1@s370_kimd_
$LN18@s370_kimd_:

; 896  :   }
; 897  : 
; 898  :   /* Test writeability output chaining value */
; 899  :   ARCH_DEP(validate_operand)(GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, parameter_blocklen - 1, ACCTYPE_WRITE, regs);

  0016f	8b 44 24 34	 mov	 eax, DWORD PTR parameter_blocklen$[rsp]
  00173	ff c8		 dec	 eax
  00175	b9 08 00 00 00	 mov	 ecx, 8
  0017a	48 6b c9 01	 imul	 rcx, rcx, 1
  0017e	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00186	8b 8c 0a 80 02
	00 00		 mov	 ecx, DWORD PTR [rdx+rcx+640]
  0018d	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00193	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001a0	41 b9 02 00 00
	00		 mov	 r9d, 2
  001a6	44 8b c0	 mov	 r8d, eax
  001a9	ba 01 00 00 00	 mov	 edx, 1
  001ae	e8 00 00 00 00	 call	 s370_validate_operand

; 900  : 
; 901  :   /* Fetch the parameter block */
; 902  :   ARCH_DEP(vfetchc)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  001b3	b8 08 00 00 00	 mov	 eax, 8
  001b8	48 6b c0 01	 imul	 rax, rax, 1
  001bc	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  001c4	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  001cb	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  001d0	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  001d4	ff c9		 dec	 ecx
  001d6	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001de	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  001e3	41 b9 01 00 00
	00		 mov	 r9d, 1
  001e9	44 8b c0	 mov	 r8d, eax
  001ec	0f b6 d1	 movzx	 edx, cl
  001ef	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  001f7	e8 00 00 00 00	 call	 s370_vfetchc

; 903  : 
; 904  : #ifdef OPTION_KIMD_DEBUG
; 905  :   if(parameter_blocklen > 32)
; 906  :   {
; 907  :     LOGBYTE2("icv   :", parameter_block, 16, parameter_blocklen / 16);
; 908  :   }
; 909  :   else
; 910  :   {
; 911  :     LOGBYTE("icv   :", parameter_block, parameter_blocklen);
; 912  :   }
; 913  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 914  : 
; 915  :   /* Set initial chaining value */
; 916  :   switch(fc)

  001fc	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  00200	89 44 24 3c	 mov	 DWORD PTR tv173[rsp], eax
  00204	83 7c 24 3c 01	 cmp	 DWORD PTR tv173[rsp], 1
  00209	74 10		 je	 SHORT $LN19@s370_kimd_
  0020b	83 7c 24 3c 02	 cmp	 DWORD PTR tv173[rsp], 2
  00210	74 1d		 je	 SHORT $LN20@s370_kimd_
  00212	83 7c 24 3c 03	 cmp	 DWORD PTR tv173[rsp], 3
  00217	74 2d		 je	 SHORT $LN21@s370_kimd_
  00219	eb 40		 jmp	 SHORT $LN7@s370_kimd_
$LN19@s370_kimd_:

; 917  :   {
; 918  :     case 1: /* sha-1 */
; 919  :     {
; 920  :       sha1_seticv(&sha1_ctx, parameter_block);

  0021b	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00223	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  00228	e8 00 00 00 00	 call	 sha1_seticv

; 921  :       break;

  0022d	eb 2c		 jmp	 SHORT $LN7@s370_kimd_
$LN20@s370_kimd_:

; 922  :     }
; 923  : 
; 924  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 925  :     case 2: /* sha-256 */
; 926  :     {
; 927  :       sha256_seticv(&sha2_ctx, parameter_block);

  0022f	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00237	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  0023f	e8 00 00 00 00	 call	 sha256_seticv

; 928  :       break;

  00244	eb 15		 jmp	 SHORT $LN7@s370_kimd_
$LN21@s370_kimd_:

; 929  :     }
; 930  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 931  : 
; 932  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 933  :     case 3: /* sha-512 */
; 934  :     {
; 935  :       sha512_seticv(&sha512_ctx, parameter_block);

  00246	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0024e	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00256	e8 00 00 00 00	 call	 sha512_seticv
$LN7@s370_kimd_:

; 936  :       break;
; 937  :     }
; 938  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 939  : 
; 940  :   }
; 941  : 
; 942  :   /* Try to process the CPU-determined amount of data */
; 943  :   for(crypted = 0; crypted < PROCESS_MAX; crypted += message_blocklen)

  0025b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR crypted$[rsp], 0
  00263	eb 10		 jmp	 SHORT $LN11@s370_kimd_
$LN9@s370_kimd_:
  00265	8b 44 24 30	 mov	 eax, DWORD PTR message_blocklen$[rsp]
  00269	8b 4c 24 40	 mov	 ecx, DWORD PTR crypted$[rsp]
  0026d	03 c8		 add	 ecx, eax
  0026f	8b c1		 mov	 eax, ecx
  00271	89 44 24 40	 mov	 DWORD PTR crypted$[rsp], eax
$LN11@s370_kimd_:
  00275	81 7c 24 40 00
	40 00 00	 cmp	 DWORD PTR crypted$[rsp], 16384 ; 00004000H
  0027d	0f 8d 0c 02 00
	00		 jge	 $LN10@s370_kimd_

; 944  :   {
; 945  :     /* Fetch and process a block of data */
; 946  :     ARCH_DEP(vfetchc)(message_block, message_blocklen - 1, GR_A(r2, regs) & ADDRESS_MAXWRAP(regs), r2, regs);

  00283	48 63 84 24 48
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  0028b	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00293	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  0029a	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  0029f	8b 4c 24 30	 mov	 ecx, DWORD PTR message_blocklen$[rsp]
  002a3	ff c9		 dec	 ecx
  002a5	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  002ad	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002b2	44 8b 8c 24 48
	03 00 00	 mov	 r9d, DWORD PTR r2$[rsp]
  002ba	44 8b c0	 mov	 r8d, eax
  002bd	0f b6 d1	 movzx	 edx, cl
  002c0	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR message_block$[rsp]
  002c8	e8 00 00 00 00	 call	 s370_vfetchc

; 947  : 
; 948  : #ifdef OPTION_KIMD_DEBUG
; 949  :     LOGBYTE2("input :", message_block, 16, message_blocklen / 16);
; 950  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 951  : 
; 952  :     switch(fc)

  002cd	8b 44 24 44	 mov	 eax, DWORD PTR fc$[rsp]
  002d1	89 44 24 48	 mov	 DWORD PTR tv198[rsp], eax
  002d5	83 7c 24 48 01	 cmp	 DWORD PTR tv198[rsp], 1
  002da	74 10		 je	 SHORT $LN22@s370_kimd_
  002dc	83 7c 24 48 02	 cmp	 DWORD PTR tv198[rsp], 2
  002e1	74 2f		 je	 SHORT $LN23@s370_kimd_
  002e3	83 7c 24 48 03	 cmp	 DWORD PTR tv198[rsp], 3
  002e8	74 54		 je	 SHORT $LN24@s370_kimd_
  002ea	eb 7c		 jmp	 SHORT $LN12@s370_kimd_
$LN22@s370_kimd_:

; 953  :     {
; 954  :       case 1: /* sha-1 */
; 955  :       {
; 956  :         SHA1Transform(sha1_ctx.state, message_block);

  002ec	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  002f4	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  002f9	e8 00 00 00 00	 call	 SHA1Transform

; 957  :         sha1_getcv(&sha1_ctx, parameter_block);

  002fe	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  00306	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sha1_ctx$[rsp]
  0030b	e8 00 00 00 00	 call	 sha1_getcv

; 958  :         break;

  00310	eb 56		 jmp	 SHORT $LN12@s370_kimd_
$LN23@s370_kimd_:

; 959  :       }
; 960  : 
; 961  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_1 )
; 962  :       case 2: /* sha-256 */
; 963  :       {
; 964  :         SHA256Transform(sha2_ctx.state.st32, message_block);

  00312	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  0031a	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00322	e8 00 00 00 00	 call	 SHA256Transform

; 965  :         sha256_getcv(&sha2_ctx, parameter_block);

  00327	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0032f	48 8d 8c 24 c0
	00 00 00	 lea	 rcx, QWORD PTR sha2_ctx$[rsp]
  00337	e8 00 00 00 00	 call	 sha256_getcv

; 966  :         break;

  0033c	eb 2a		 jmp	 SHORT $LN12@s370_kimd_
$LN24@s370_kimd_:

; 967  :       }
; 968  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_1 ) */
; 969  : 
; 970  : #if defined( FEATURE_MSA_EXTENSION_FACILITY_2 )
; 971  :       case 3: /* sha-512 */
; 972  :       {
; 973  :         SHA512Transform(sha512_ctx.state.st64, message_block);

  0033e	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR message_block$[rsp]
  00346	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  0034e	e8 00 00 00 00	 call	 SHA512Transform

; 974  :         sha512_getcv(&sha512_ctx, parameter_block);

  00353	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR parameter_block$[rsp]
  0035b	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR sha512_ctx$[rsp]
  00363	e8 00 00 00 00	 call	 sha512_getcv
$LN12@s370_kimd_:

; 975  :         break;
; 976  :       }
; 977  : #endif /* defined( FEATURE_MSA_EXTENSION_FACILITY_2 ) */
; 978  : 
; 979  :     }
; 980  : 
; 981  :     /* Store the output chaining value */
; 982  :     ARCH_DEP(vstorec)(parameter_block, parameter_blocklen - 1, GR_A(1, regs) & ADDRESS_MAXWRAP(regs), 1, regs);

  00368	b8 08 00 00 00	 mov	 eax, 8
  0036d	48 6b c0 01	 imul	 rax, rax, 1
  00371	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00379	8b 84 01 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax+640]
  00380	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00385	8b 4c 24 34	 mov	 ecx, DWORD PTR parameter_blocklen$[rsp]
  00389	ff c9		 dec	 ecx
  0038b	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00393	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00398	41 b9 01 00 00
	00		 mov	 r9d, 1
  0039e	44 8b c0	 mov	 r8d, eax
  003a1	0f b6 d1	 movzx	 edx, cl
  003a4	48 8d 8c 24 60
	02 00 00	 lea	 rcx, QWORD PTR parameter_block$[rsp]
  003ac	e8 00 00 00 00	 call	 s370_vstorec

; 983  : 
; 984  : #ifdef OPTION_KIMD_DEBUG
; 985  :     if(parameter_blocklen > 32)
; 986  :     {
; 987  :       LOGBYTE2("ocv   :", parameter_block, 16, parameter_blocklen / 16);
; 988  :     }
; 989  :     else
; 990  :     {
; 991  :       LOGBYTE("ocv   :", parameter_block, parameter_blocklen);
; 992  :     }
; 993  : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 994  : 
; 995  :     /* Update the registers */
; 996  :     SET_GR_A(r2, regs, GR_A(r2, regs) + message_blocklen);

  003b1	48 63 84 24 48
	03 00 00	 movsxd	 rax, DWORD PTR r2$[rsp]
  003b9	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003c1	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  003c8	03 44 24 30	 add	 eax, DWORD PTR message_blocklen$[rsp]
  003cc	48 63 8c 24 48
	03 00 00	 movsxd	 rcx, DWORD PTR r2$[rsp]
  003d4	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  003dc	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 997  :     SET_GR_A(r2 + 1, regs, GR_A(r2 + 1, regs) - message_blocklen);

  003e3	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  003ea	ff c0		 inc	 eax
  003ec	48 98		 cdqe
  003ee	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f6	8b 54 24 30	 mov	 edx, DWORD PTR message_blocklen$[rsp]
  003fa	8b 84 c1 80 02
	00 00		 mov	 eax, DWORD PTR [rcx+rax*8+640]
  00401	2b c2		 sub	 eax, edx
  00403	8b 8c 24 48 03
	00 00		 mov	 ecx, DWORD PTR r2$[rsp]
  0040a	ff c1		 inc	 ecx
  0040c	48 63 c9	 movsxd	 rcx, ecx
  0040f	48 8b 94 24 50
	03 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  00417	89 84 ca 80 02
	00 00		 mov	 DWORD PTR [rdx+rcx*8+640], eax

; 998  : 
; 999  : #ifdef OPTION_KIMD_DEBUG
; 1000 :     WRMSG(HHC90108, "D", r2, (regs)->GR(r2));
; 1001 :     WRMSG(HHC90108, "D", r2 + 1, (regs)->GR(r2 + 1));
; 1002 : #endif /* #ifdef OPTION_KIMD_DEBUG */
; 1003 : 
; 1004 :     /* check for end of data */
; 1005 :     if(unlikely(GR_A(r2 + 1, regs) < (unsigned) message_blocklen))

  0041e	8b 84 24 48 03
	00 00		 mov	 eax, DWORD PTR r2$[rsp]
  00425	ff c0		 inc	 eax
  00427	48 98		 cdqe
  00429	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00431	8b 54 24 30	 mov	 edx, DWORD PTR message_blocklen$[rsp]
  00435	39 94 c1 80 02
	00 00		 cmp	 DWORD PTR [rcx+rax*8+640], edx
  0043c	73 0a		 jae	 SHORT $LN40@s370_kimd_
  0043e	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv266[rsp], 1
  00446	eb 08		 jmp	 SHORT $LN41@s370_kimd_
$LN40@s370_kimd_:
  00448	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv266[rsp], 0
$LN41@s370_kimd_:
  00450	83 7c 24 58 00	 cmp	 DWORD PTR tv266[rsp], 0
  00455	74 33		 je	 SHORT $LN25@s370_kimd_

; 1006 :     {
; 1007 :       if(unlikely(klmd))

  00457	83 bc 24 58 03
	00 00 00	 cmp	 DWORD PTR klmd$[rsp], 0
  0045f	74 0a		 je	 SHORT $LN44@s370_kimd_
  00461	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv272[rsp], 1
  00469	eb 08		 jmp	 SHORT $LN45@s370_kimd_
$LN44@s370_kimd_:
  0046b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv272[rsp], 0
$LN45@s370_kimd_:
  00473	83 7c 24 5c 00	 cmp	 DWORD PTR tv272[rsp], 0
  00478	74 02		 je	 SHORT $LN26@s370_kimd_

; 1008 :         return;

  0047a	eb 1f		 jmp	 SHORT $LN1@s370_kimd_
$LN26@s370_kimd_:

; 1009 :       regs->psw.cc = 0;

  0047c	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00484	c6 40 7c 00	 mov	 BYTE PTR [rax+124], 0

; 1010 :       return;

  00488	eb 11		 jmp	 SHORT $LN1@s370_kimd_
$LN25@s370_kimd_:

; 1011 :     }
; 1012 :   }

  0048a	e9 d6 fd ff ff	 jmp	 $LN9@s370_kimd_
$LN10@s370_kimd_:

; 1013 : 
; 1014 :   /* CPU-determined amount of data processed */
; 1015 :   regs->psw.cc = 3;

  0048f	48 8b 84 24 50
	03 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00497	c6 40 7c 03	 mov	 BYTE PTR [rax+124], 3
$LN1@s370_kimd_:

; 1016 : }

  0049b	48 8b 8c 24 20
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a3	48 33 cc	 xor	 rcx, rsp
  004a6	e8 00 00 00 00	 call	 __security_check_cookie
  004ab	48 81 c4 38 03
	00 00		 add	 rsp, 824		; 00000338H
  004b2	c3		 ret	 0
s370_kimd_sha ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
context$ = 48
__$ArrayPad$ = 464
key$ = 512
keylen$ = 520
wrap_dea PROC

; 668  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 669  :   des3_context context;
; 670  :   int i;
; 671  :   int j;
; 672  : 
; 673  :   memcpy(&key[keylen], sysblk.wkvpdea_reg, 24);

  00024	48 63 84 24 08
	02 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  0002c	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00034	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0003b	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  0003f	48 8d b2 80 0e
	00 00		 lea	 rsi, QWORD PTR [rdx+3712]
  00046	b9 18 00 00 00	 mov	 ecx, 24
  0004b	f3 a4		 rep movsb

; 674  : 
; 675  :   des3_set_3keys(&context, sysblk.wkdea_reg, &sysblk.wkdea_reg[8], &sysblk.wkdea_reg[16]);

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	48 6b c0 10	 imul	 rax, rax, 16
  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005d	48 8d 84 01 48
	0e 00 00	 lea	 rax, QWORD PTR [rcx+rax+3656]
  00065	b9 01 00 00 00	 mov	 ecx, 1
  0006a	48 6b c9 08	 imul	 rcx, rcx, 8
  0006e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00075	48 8d 8c 0a 48
	0e 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+3656]
  0007d	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00084	48 81 c2 48 0e
	00 00		 add	 rdx, 3656		; 00000e48H
  0008b	4c 8b c8	 mov	 r9, rax
  0008e	4c 8b c1	 mov	 r8, rcx
  00091	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00096	e8 00 00 00 00	 call	 des3_set_3keys

; 676  : 
; 677  :   for(i = 0; i < keylen; i += 8)

  0009b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000a3	eb 0b		 jmp	 SHORT $LN4@wrap_dea
$LN2@wrap_dea:
  000a5	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000a9	83 c0 08	 add	 eax, 8
  000ac	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@wrap_dea:
  000b0	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  000b7	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000bb	0f 8d 1c 01 00
	00		 jge	 $LN3@wrap_dea

; 678  :   {
; 679  :     if(i)

  000c1	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  000c6	74 6e		 je	 SHORT $LN8@wrap_dea

; 680  :     {
; 681  :       /* XOR */
; 682  :       for(j = 0; j < 8; j++)

  000c8	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  000d0	eb 0a		 jmp	 SHORT $LN7@wrap_dea
$LN5@wrap_dea:
  000d2	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  000d6	ff c0		 inc	 eax
  000d8	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN7@wrap_dea:
  000dc	83 7c 24 24 08	 cmp	 DWORD PTR j$[rsp], 8
  000e1	7d 53		 jge	 SHORT $LN6@wrap_dea

; 683  :         key[i + j] ^= key[i + j - 8];

  000e3	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  000e7	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000eb	03 c8		 add	 ecx, eax
  000ed	8b c1		 mov	 eax, ecx
  000ef	48 98		 cdqe
  000f1	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  000f5	8b 54 24 24	 mov	 edx, DWORD PTR j$[rsp]
  000f9	8d 4c 11 f8	 lea	 ecx, DWORD PTR [rcx+rdx-8]
  000fd	48 63 c9	 movsxd	 rcx, ecx
  00100	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00108	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0010c	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00114	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00118	33 c1		 xor	 eax, ecx
  0011a	8b 4c 24 24	 mov	 ecx, DWORD PTR j$[rsp]
  0011e	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  00122	03 d1		 add	 edx, ecx
  00124	8b ca		 mov	 ecx, edx
  00126	48 63 c9	 movsxd	 rcx, ecx
  00129	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00131	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00134	eb 9c		 jmp	 SHORT $LN5@wrap_dea
$LN6@wrap_dea:
$LN8@wrap_dea:

; 684  :     }
; 685  :     des3_encrypt(&context, &key[i], &key[i]);

  00136	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0013b	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00143	48 03 c8	 add	 rcx, rax
  00146	48 8b c1	 mov	 rax, rcx
  00149	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0014e	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00156	48 03 d1	 add	 rdx, rcx
  00159	48 8b ca	 mov	 rcx, rdx
  0015c	4c 8b c0	 mov	 r8, rax
  0015f	48 8b d1	 mov	 rdx, rcx
  00162	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00167	e8 00 00 00 00	 call	 des3_encrypt

; 686  :     des3_decrypt(&context, &key[i], &key[i]);

  0016c	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00171	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00179	48 03 c8	 add	 rcx, rax
  0017c	48 8b c1	 mov	 rax, rcx
  0017f	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00184	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0018c	48 03 d1	 add	 rdx, rcx
  0018f	48 8b ca	 mov	 rcx, rdx
  00192	4c 8b c0	 mov	 r8, rax
  00195	48 8b d1	 mov	 rdx, rcx
  00198	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0019d	e8 00 00 00 00	 call	 des3_decrypt

; 687  :     des3_encrypt(&context, &key[i], &key[i]);

  001a2	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  001a7	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  001af	48 03 c8	 add	 rcx, rax
  001b2	48 8b c1	 mov	 rax, rcx
  001b5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ba	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001c2	48 03 d1	 add	 rdx, rcx
  001c5	48 8b ca	 mov	 rcx, rdx
  001c8	4c 8b c0	 mov	 r8, rax
  001cb	48 8b d1	 mov	 rdx, rcx
  001ce	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  001d3	e8 00 00 00 00	 call	 des3_encrypt

; 688  :   }

  001d8	e9 c8 fe ff ff	 jmp	 $LN2@wrap_dea
$LN3@wrap_dea:

; 689  : }

  001dd	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001e5	48 33 cc	 xor	 rcx, rsp
  001e8	e8 00 00 00 00	 call	 __security_check_cookie
  001ed	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  001f4	5f		 pop	 rdi
  001f5	5e		 pop	 rsi
  001f6	c3		 ret	 0
wrap_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 32
tv75 = 36
context$ = 48
buf$ = 544
cv$ = 560
__$ArrayPad$ = 576
key$ = 624
keylen$ = 632
wrap_aes PROC

; 624  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 625  :   BYTE buf[16];
; 626  :   rijndael_ctx context;
; 627  :   BYTE cv[16];
; 628  :   int i;
; 629  : 
; 630  :   memcpy(&key[keylen], sysblk.wkvpaes_reg, 32);

  00024	48 63 84 24 78
	02 00 00	 movsxd	 rax, DWORD PTR keylen$[rsp]
  0002c	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00034	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  0003b	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  0003f	48 8d b2 60 0e
	00 00		 lea	 rsi, QWORD PTR [rdx+3680]
  00046	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0004b	f3 a4		 rep movsb

; 631  : 
; 632  :   rijndael_set_key(&context, sysblk.wkaes_reg, 256);

  0004d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00054	48 05 28 0e 00
	00		 add	 rax, 3624		; 00000e28H
  0005a	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00060	48 8b d0	 mov	 rdx, rax
  00063	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00068	e8 00 00 00 00	 call	 rijndael_set_key

; 633  : 
; 634  :   switch(keylen)

  0006d	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  00074	89 44 24 24	 mov	 DWORD PTR tv75[rsp], eax
  00078	83 7c 24 24 10	 cmp	 DWORD PTR tv75[rsp], 16
  0007d	74 17		 je	 SHORT $LN10@wrap_aes
  0007f	83 7c 24 24 18	 cmp	 DWORD PTR tv75[rsp], 24
  00084	74 2f		 je	 SHORT $LN11@wrap_aes
  00086	83 7c 24 24 20	 cmp	 DWORD PTR tv75[rsp], 32	; 00000020H
  0008b	0f 84 16 01 00
	00		 je	 $LN12@wrap_aes
  00091	e9 c3 01 00 00	 jmp	 $LN2@wrap_aes
$LN10@wrap_aes:

; 635  :   {
; 636  :     case 16:
; 637  :     {
; 638  :       rijndael_encrypt(&context, key, key);

  00096	4c 8b 84 24 70
	02 00 00	 mov	 r8, QWORD PTR key$[rsp]
  0009e	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  000a6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  000ab	e8 00 00 00 00	 call	 rijndael_encrypt

; 639  :       break;

  000b0	e9 a4 01 00 00	 jmp	 $LN2@wrap_aes
$LN11@wrap_aes:

; 640  :     }
; 641  :     case 24:
; 642  :     {
; 643  :       rijndael_encrypt(&context, key, cv);

  000b5	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR cv$[rsp]
  000bd	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  000c5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  000ca	e8 00 00 00 00	 call	 rijndael_encrypt

; 644  :       memcpy(buf, &key[16], 8);

  000cf	b8 01 00 00 00	 mov	 eax, 1
  000d4	48 6b c0 10	 imul	 rax, rax, 16
  000d8	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  000e0	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  000e4	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR buf$[rsp], rax

; 645  :       zeromem(&buf[8], 8);

  000ec	b8 01 00 00 00	 mov	 eax, 1
  000f1	48 6b c0 08	 imul	 rax, rax, 8
  000f5	48 8d 84 04 20
	02 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  000fd	48 8b f8	 mov	 rdi, rax
  00100	33 c0		 xor	 eax, eax
  00102	b9 08 00 00 00	 mov	 ecx, 8
  00107	f3 aa		 rep stosb

; 646  :       for(i = 0; i < 16; i++)

  00109	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00111	eb 0a		 jmp	 SHORT $LN6@wrap_aes
$LN4@wrap_aes:
  00113	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00117	ff c0		 inc	 eax
  00119	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN6@wrap_aes:
  0011d	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00122	7d 2a		 jge	 SHORT $LN5@wrap_aes

; 647  :         buf[i] ^= cv[i];

  00124	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00129	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  0012e	0f b6 8c 0c 30
	02 00 00	 movzx	 ecx, BYTE PTR cv$[rsp+rcx]
  00136	0f b6 84 04 20
	02 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  0013e	33 c1		 xor	 eax, ecx
  00140	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00145	88 84 0c 20 02
	00 00		 mov	 BYTE PTR buf$[rsp+rcx], al
  0014c	eb c5		 jmp	 SHORT $LN4@wrap_aes
$LN5@wrap_aes:

; 648  :       rijndael_encrypt(&context, buf, buf);

  0014e	4c 8d 84 24 20
	02 00 00	 lea	 r8, QWORD PTR buf$[rsp]
  00156	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0015e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00163	e8 00 00 00 00	 call	 rijndael_encrypt

; 649  :       memcpy(key, cv, 8);

  00168	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR key$[rsp]
  00170	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR cv$[rsp]
  00178	48 89 08	 mov	 QWORD PTR [rax], rcx

; 650  :       memcpy(&key[8], buf, 16);

  0017b	b8 01 00 00 00	 mov	 eax, 1
  00180	48 6b c0 08	 imul	 rax, rax, 8
  00184	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  0018c	48 8d 94 24 20
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00194	48 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+rax]
  00198	48 8b f2	 mov	 rsi, rdx
  0019b	b9 10 00 00 00	 mov	 ecx, 16
  001a0	f3 a4		 rep movsb

; 651  :       break;

  001a2	e9 b2 00 00 00	 jmp	 $LN2@wrap_aes
$LN12@wrap_aes:

; 652  :     }
; 653  :     case 32:
; 654  :     {
; 655  :       rijndael_encrypt(&context, key, key);

  001a7	4c 8b 84 24 70
	02 00 00	 mov	 r8, QWORD PTR key$[rsp]
  001af	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001b7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  001bc	e8 00 00 00 00	 call	 rijndael_encrypt

; 656  :       for(i = 0; i < 16; i++)

  001c1	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  001c9	eb 0a		 jmp	 SHORT $LN9@wrap_aes
$LN7@wrap_aes:
  001cb	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001cf	ff c0		 inc	 eax
  001d1	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN9@wrap_aes:
  001d5	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  001da	7d 3f		 jge	 SHORT $LN8@wrap_aes

; 657  :         key[i + 16] ^= key[i];

  001dc	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  001e0	83 c0 10	 add	 eax, 16
  001e3	48 98		 cdqe
  001e5	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ea	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001f2	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001f6	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001fe	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00202	33 c1		 xor	 eax, ecx
  00204	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  00208	83 c1 10	 add	 ecx, 16
  0020b	48 63 c9	 movsxd	 rcx, ecx
  0020e	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00216	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00219	eb b0		 jmp	 SHORT $LN7@wrap_aes
$LN8@wrap_aes:

; 658  :       rijndael_encrypt(&context, &key[16], &key[16]);

  0021b	b8 01 00 00 00	 mov	 eax, 1
  00220	48 6b c0 10	 imul	 rax, rax, 16
  00224	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  0022c	48 03 c8	 add	 rcx, rax
  0022f	48 8b c1	 mov	 rax, rcx
  00232	b9 01 00 00 00	 mov	 ecx, 1
  00237	48 6b c9 10	 imul	 rcx, rcx, 16
  0023b	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00243	48 03 d1	 add	 rdx, rcx
  00246	48 8b ca	 mov	 rcx, rdx
  00249	4c 8b c0	 mov	 r8, rax
  0024c	48 8b d1	 mov	 rdx, rcx
  0024f	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00254	e8 00 00 00 00	 call	 rijndael_encrypt
$LN2@wrap_aes:

; 659  :       break;
; 660  :     }
; 661  :   }
; 662  : }

  00259	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00261	48 33 cc	 xor	 rcx, rsp
  00264	e8 00 00 00 00	 call	 __security_check_cookie
  00269	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00270	5f		 pop	 rdi
  00271	5e		 pop	 rsi
  00272	c3		 ret	 0
wrap_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 32
j$ = 36
tv88 = 40
context$ = 48
cv$ = 464
__$ArrayPad$ = 480
key$ = 512
keylen$ = 520
unwrap_dea PROC

; 589  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec f8 01
	00 00		 sub	 rsp, 504		; 000001f8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 590  :   BYTE cv[16];
; 591  :   des3_context context;
; 592  :   int i;
; 593  :   int j;
; 594  : 
; 595  :   /* Verify verification pattern */
; 596  :   if(unlikely(memcmp(&key[keylen], sysblk.wkvpdea_reg, 24)))

  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00029	48 05 80 0e 00
	00		 add	 rax, 3712		; 00000e80H
  0002f	48 63 8c 24 08
	02 00 00	 movsxd	 rcx, DWORD PTR keylen$[rsp]
  00037	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0003f	48 03 d1	 add	 rdx, rcx
  00042	48 8b ca	 mov	 rcx, rdx
  00045	41 b8 18 00 00
	00		 mov	 r8d, 24
  0004b	48 8b d0	 mov	 rdx, rax
  0004e	e8 00 00 00 00	 call	 memcmp
  00053	85 c0		 test	 eax, eax
  00055	74 0a		 je	 SHORT $LN13@unwrap_dea
  00057	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  0005f	eb 08		 jmp	 SHORT $LN14@unwrap_dea
$LN13@unwrap_dea:
  00061	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN14@unwrap_dea:
  00069	83 7c 24 28 00	 cmp	 DWORD PTR tv88[rsp], 0
  0006e	74 0a		 je	 SHORT $LN8@unwrap_dea

; 597  :     return(1);

  00070	b8 01 00 00 00	 mov	 eax, 1
  00075	e9 bf 01 00 00	 jmp	 $LN1@unwrap_dea
$LN8@unwrap_dea:

; 598  : 
; 599  :   des3_set_3keys(&context, sysblk.wkdea_reg, &sysblk.wkdea_reg[8], &sysblk.wkdea_reg[16]);

  0007a	b8 01 00 00 00	 mov	 eax, 1
  0007f	48 6b c0 10	 imul	 rax, rax, 16
  00083	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008a	48 8d 84 01 48
	0e 00 00	 lea	 rax, QWORD PTR [rcx+rax+3656]
  00092	b9 01 00 00 00	 mov	 ecx, 1
  00097	48 6b c9 08	 imul	 rcx, rcx, 8
  0009b	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000a2	48 8d 8c 0a 48
	0e 00 00	 lea	 rcx, QWORD PTR [rdx+rcx+3656]
  000aa	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  000b1	48 81 c2 48 0e
	00 00		 add	 rdx, 3656		; 00000e48H
  000b8	4c 8b c8	 mov	 r9, rax
  000bb	4c 8b c1	 mov	 r8, rcx
  000be	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  000c3	e8 00 00 00 00	 call	 des3_set_3keys

; 600  : 
; 601  :   for(i = 0; i < keylen; i += 8)

  000c8	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  000d0	eb 0b		 jmp	 SHORT $LN4@unwrap_dea
$LN2@unwrap_dea:
  000d2	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000d6	83 c0 08	 add	 eax, 8
  000d9	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@unwrap_dea:
  000dd	8b 84 24 08 02
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  000e4	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  000e8	0f 8d 49 01 00
	00		 jge	 $LN3@unwrap_dea

; 602  :   {
; 603  :     /* Save cv */
; 604  :     memcpy(cv, &cv[8], 8);

  000ee	b8 01 00 00 00	 mov	 eax, 1
  000f3	48 6b c0 08	 imul	 rax, rax, 8
  000f7	48 8b 84 04 d0
	01 00 00	 mov	 rax, QWORD PTR cv$[rsp+rax]
  000ff	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR cv$[rsp], rax

; 605  :     memcpy(&cv[8], &key[i], 8);

  00107	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0010c	b9 01 00 00 00	 mov	 ecx, 1
  00111	48 6b c9 08	 imul	 rcx, rcx, 8
  00115	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0011d	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00121	48 89 84 0c d0
	01 00 00	 mov	 QWORD PTR cv$[rsp+rcx], rax

; 606  : 
; 607  :     des3_decrypt(&context, &key[i], &key[i]);

  00129	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0012e	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00136	48 03 c8	 add	 rcx, rax
  00139	48 8b c1	 mov	 rax, rcx
  0013c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00141	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00149	48 03 d1	 add	 rdx, rcx
  0014c	48 8b ca	 mov	 rcx, rdx
  0014f	4c 8b c0	 mov	 r8, rax
  00152	48 8b d1	 mov	 rdx, rcx
  00155	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0015a	e8 00 00 00 00	 call	 des3_decrypt

; 608  :     des3_encrypt(&context, &key[i], &key[i]);

  0015f	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00164	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  0016c	48 03 c8	 add	 rcx, rax
  0016f	48 8b c1	 mov	 rax, rcx
  00172	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00177	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0017f	48 03 d1	 add	 rdx, rcx
  00182	48 8b ca	 mov	 rcx, rdx
  00185	4c 8b c0	 mov	 r8, rax
  00188	48 8b d1	 mov	 rdx, rcx
  0018b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00190	e8 00 00 00 00	 call	 des3_encrypt

; 609  :     des3_decrypt(&context, &key[i], &key[i]);

  00195	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0019a	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  001a2	48 03 c8	 add	 rcx, rax
  001a5	48 8b c1	 mov	 rax, rcx
  001a8	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  001ad	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001b5	48 03 d1	 add	 rdx, rcx
  001b8	48 8b ca	 mov	 rcx, rdx
  001bb	4c 8b c0	 mov	 r8, rax
  001be	48 8b d1	 mov	 rdx, rcx
  001c1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  001c6	e8 00 00 00 00	 call	 des3_decrypt

; 610  :     if(i)

  001cb	83 7c 24 20 00	 cmp	 DWORD PTR i$[rsp], 0
  001d0	74 60		 je	 SHORT $LN9@unwrap_dea

; 611  :     {
; 612  :       /* XOR */
; 613  :       for(j = 0; j < 8; j++)

  001d2	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR j$[rsp], 0
  001da	eb 0a		 jmp	 SHORT $LN7@unwrap_dea
$LN5@unwrap_dea:
  001dc	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  001e0	ff c0		 inc	 eax
  001e2	89 44 24 24	 mov	 DWORD PTR j$[rsp], eax
$LN7@unwrap_dea:
  001e6	83 7c 24 24 08	 cmp	 DWORD PTR j$[rsp], 8
  001eb	7d 45		 jge	 SHORT $LN6@unwrap_dea

; 614  :         key[i + j] ^= cv[j];

  001ed	8b 44 24 24	 mov	 eax, DWORD PTR j$[rsp]
  001f1	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  001f5	03 c8		 add	 ecx, eax
  001f7	8b c1		 mov	 eax, ecx
  001f9	48 98		 cdqe
  001fb	48 63 4c 24 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00200	0f b6 8c 0c d0
	01 00 00	 movzx	 ecx, BYTE PTR cv$[rsp+rcx]
  00208	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00210	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00214	33 c1		 xor	 eax, ecx
  00216	8b 4c 24 24	 mov	 ecx, DWORD PTR j$[rsp]
  0021a	8b 54 24 20	 mov	 edx, DWORD PTR i$[rsp]
  0021e	03 d1		 add	 edx, ecx
  00220	8b ca		 mov	 ecx, edx
  00222	48 63 c9	 movsxd	 rcx, ecx
  00225	48 8b 94 24 00
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0022d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00230	eb aa		 jmp	 SHORT $LN5@unwrap_dea
$LN6@unwrap_dea:
$LN9@unwrap_dea:

; 615  :     }
; 616  :   }

  00232	e9 9b fe ff ff	 jmp	 $LN2@unwrap_dea
$LN3@unwrap_dea:

; 617  :   return(0);

  00237	33 c0		 xor	 eax, eax
$LN1@unwrap_dea:

; 618  : }

  00239	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00241	48 33 cc	 xor	 rcx, rsp
  00244	e8 00 00 00 00	 call	 __security_check_cookie
  00249	48 81 c4 f8 01
	00 00		 add	 rsp, 504		; 000001f8H
  00250	c3		 ret	 0
unwrap_dea ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 32
tv90 = 36
tv88 = 40
context$ = 48
cv$ = 544
buf$ = 560
__$ArrayPad$ = 576
key$ = 624
keylen$ = 632
unwrap_aes PROC

; 543  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 544  :   BYTE buf[16];
; 545  :   rijndael_ctx context;
; 546  :   BYTE cv[16];
; 547  :   int i;
; 548  : 
; 549  :   /* Verify verification pattern */
; 550  :   if(unlikely(memcmp(&key[keylen], sysblk.wkvpaes_reg, 32)))

  00024	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002b	48 05 60 0e 00
	00		 add	 rax, 3680		; 00000e60H
  00031	48 63 8c 24 78
	02 00 00	 movsxd	 rcx, DWORD PTR keylen$[rsp]
  00039	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00041	48 03 d1	 add	 rdx, rcx
  00044	48 8b ca	 mov	 rcx, rdx
  00047	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  0004d	48 8b d0	 mov	 rdx, rax
  00050	e8 00 00 00 00	 call	 memcmp
  00055	85 c0		 test	 eax, eax
  00057	74 0a		 je	 SHORT $LN17@unwrap_aes
  00059	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv88[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN18@unwrap_aes
$LN17@unwrap_aes:
  00063	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN18@unwrap_aes:
  0006b	83 7c 24 28 00	 cmp	 DWORD PTR tv88[rsp], 0
  00070	74 0a		 je	 SHORT $LN10@unwrap_aes

; 551  :     return(1);

  00072	b8 01 00 00 00	 mov	 eax, 1
  00077	e9 04 02 00 00	 jmp	 $LN1@unwrap_aes
$LN10@unwrap_aes:

; 552  : 
; 553  :   rijndael_set_key(&context, sysblk.wkaes_reg, 256);

  0007c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00083	48 05 28 0e 00
	00		 add	 rax, 3624		; 00000e28H
  00089	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0008f	48 8b d0	 mov	 rdx, rax
  00092	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00097	e8 00 00 00 00	 call	 rijndael_set_key

; 554  : 
; 555  :   switch(keylen)

  0009c	8b 84 24 78 02
	00 00		 mov	 eax, DWORD PTR keylen$[rsp]
  000a3	89 44 24 24	 mov	 DWORD PTR tv90[rsp], eax
  000a7	83 7c 24 24 10	 cmp	 DWORD PTR tv90[rsp], 16
  000ac	74 17		 je	 SHORT $LN11@unwrap_aes
  000ae	83 7c 24 24 18	 cmp	 DWORD PTR tv90[rsp], 24
  000b3	74 2f		 je	 SHORT $LN12@unwrap_aes
  000b5	83 7c 24 24 20	 cmp	 DWORD PTR tv90[rsp], 32	; 00000020H
  000ba	0f 84 f6 00 00
	00		 je	 $LN13@unwrap_aes
  000c0	e9 b9 01 00 00	 jmp	 $LN2@unwrap_aes
$LN11@unwrap_aes:

; 556  :   {
; 557  :     case 16:
; 558  :     {
; 559  :       rijndael_decrypt(&context, key, key);

  000c5	4c 8b 84 24 70
	02 00 00	 mov	 r8, QWORD PTR key$[rsp]
  000cd	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  000d5	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  000da	e8 00 00 00 00	 call	 rijndael_decrypt

; 560  :       break;

  000df	e9 9a 01 00 00	 jmp	 $LN2@unwrap_aes
$LN12@unwrap_aes:

; 561  :     }
; 562  :     case 24:
; 563  :     {
; 564  :       rijndael_decrypt(&context, &key[8], buf);

  000e4	b8 01 00 00 00	 mov	 eax, 1
  000e9	48 6b c0 08	 imul	 rax, rax, 8
  000ed	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  000f5	48 03 c8	 add	 rcx, rax
  000f8	48 8b c1	 mov	 rax, rcx
  000fb	4c 8d 84 24 30
	02 00 00	 lea	 r8, QWORD PTR buf$[rsp]
  00103	48 8b d0	 mov	 rdx, rax
  00106	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0010b	e8 00 00 00 00	 call	 rijndael_decrypt

; 565  :       memcpy(&key[8], &buf[8], 8);

  00110	b8 01 00 00 00	 mov	 eax, 1
  00115	48 6b c0 08	 imul	 rax, rax, 8
  00119	b9 01 00 00 00	 mov	 ecx, 1
  0011e	48 6b c9 08	 imul	 rcx, rcx, 8
  00122	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  0012a	48 8b 84 04 30
	02 00 00	 mov	 rax, QWORD PTR buf$[rsp+rax]
  00132	48 89 04 0a	 mov	 QWORD PTR [rdx+rcx], rax

; 566  :       memcpy(cv, key, 8);

  00136	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR key$[rsp]
  0013e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00141	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR cv$[rsp], rax

; 567  :       rijndael_decrypt(&context, key, key);

  00149	4c 8b 84 24 70
	02 00 00	 mov	 r8, QWORD PTR key$[rsp]
  00151	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00159	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  0015e	e8 00 00 00 00	 call	 rijndael_decrypt

; 568  :       for(i = 0; i < 8; i++)

  00163	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0016b	eb 0a		 jmp	 SHORT $LN6@unwrap_aes
$LN4@unwrap_aes:
  0016d	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00171	ff c0		 inc	 eax
  00173	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN6@unwrap_aes:
  00177	83 7c 24 20 08	 cmp	 DWORD PTR i$[rsp], 8
  0017c	7d 33		 jge	 SHORT $LN5@unwrap_aes

; 569  :         key[i + 16] = buf[i] ^ cv[i];

  0017e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00183	0f b6 84 04 30
	02 00 00	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  0018b	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00190	0f b6 8c 0c 20
	02 00 00	 movzx	 ecx, BYTE PTR cv$[rsp+rcx]
  00198	33 c1		 xor	 eax, ecx
  0019a	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0019e	83 c1 10	 add	 ecx, 16
  001a1	48 63 c9	 movsxd	 rcx, ecx
  001a4	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001ac	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001af	eb bc		 jmp	 SHORT $LN4@unwrap_aes
$LN5@unwrap_aes:

; 570  :       break;

  001b1	e9 c8 00 00 00	 jmp	 $LN2@unwrap_aes
$LN13@unwrap_aes:

; 571  :     }
; 572  :     case 32:
; 573  :     {
; 574  :       memcpy(cv, key, 16);

  001b6	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR cv$[rsp]
  001be	48 8b f8	 mov	 rdi, rax
  001c1	48 8b b4 24 70
	02 00 00	 mov	 rsi, QWORD PTR key$[rsp]
  001c9	b9 10 00 00 00	 mov	 ecx, 16
  001ce	f3 a4		 rep movsb

; 575  :       rijndael_decrypt(&context, key, key);

  001d0	4c 8b 84 24 70
	02 00 00	 mov	 r8, QWORD PTR key$[rsp]
  001d8	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  001e0	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  001e5	e8 00 00 00 00	 call	 rijndael_decrypt

; 576  :       rijndael_decrypt(&context, &key[16], &key[16]);

  001ea	b8 01 00 00 00	 mov	 eax, 1
  001ef	48 6b c0 10	 imul	 rax, rax, 16
  001f3	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  001fb	48 03 c8	 add	 rcx, rax
  001fe	48 8b c1	 mov	 rax, rcx
  00201	b9 01 00 00 00	 mov	 ecx, 1
  00206	48 6b c9 10	 imul	 rcx, rcx, 16
  0020a	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00212	48 03 d1	 add	 rdx, rcx
  00215	48 8b ca	 mov	 rcx, rdx
  00218	4c 8b c0	 mov	 r8, rax
  0021b	48 8b d1	 mov	 rdx, rcx
  0021e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR context$[rsp]
  00223	e8 00 00 00 00	 call	 rijndael_decrypt

; 577  :       for(i = 0; i < 16; i++)

  00228	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00230	eb 0a		 jmp	 SHORT $LN9@unwrap_aes
$LN7@unwrap_aes:
  00232	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00236	ff c0		 inc	 eax
  00238	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN9@unwrap_aes:
  0023c	83 7c 24 20 10	 cmp	 DWORD PTR i$[rsp], 16
  00241	7d 3b		 jge	 SHORT $LN8@unwrap_aes

; 578  :         key[i + 16] ^= cv[i];

  00243	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00247	83 c0 10	 add	 eax, 16
  0024a	48 98		 cdqe
  0024c	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00251	0f b6 8c 0c 20
	02 00 00	 movzx	 ecx, BYTE PTR cv$[rsp+rcx]
  00259	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00261	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00265	33 c1		 xor	 eax, ecx
  00267	8b 4c 24 20	 mov	 ecx, DWORD PTR i$[rsp]
  0026b	83 c1 10	 add	 ecx, 16
  0026e	48 63 c9	 movsxd	 rcx, ecx
  00271	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR key$[rsp]
  00279	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0027c	eb b4		 jmp	 SHORT $LN7@unwrap_aes
$LN8@unwrap_aes:
$LN2@unwrap_aes:

; 579  :       break;
; 580  :     }
; 581  :   }
; 582  :   return(0);

  0027e	33 c0		 xor	 eax, eax
$LN1@unwrap_aes:

; 583  : }

  00280	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00288	48 33 cc	 xor	 rcx, rsp
  0028b	e8 00 00 00 00	 call	 __security_check_cookie
  00290	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  00297	5f		 pop	 rdi
  00298	5e		 pop	 rsi
  00299	c3		 ret	 0
unwrap_aes ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
xR$ = 32
xL$ = 36
out$ = 40
sched$ = 48
ctx$ = 80
input$ = 88
output$ = 96
des3_decrypt PROC

; 524  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 525  :     DESContext *sched = ctx->sched;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR sched$[rsp], rax

; 526  :     word32 out[2], xL, xR;
; 527  :     xL = fetch_fw(input);

  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR input$[rsp]
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax

; 528  :     xR = fetch_fw(input+4);

  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR input$[rsp]
  00037	48 83 c0 04	 add	 rax, 4
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 _byteswap_ulong
  0004a	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 529  :     des_decipher(out, xL, xR, sched+2);

  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR sched$[rsp]
  00053	48 05 10 01 00
	00		 add	 rax, 272		; 00000110H
  00059	4c 8b c8	 mov	 r9, rax
  0005c	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  00061	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  00065	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  0006a	e8 00 00 00 00	 call	 des_decipher

; 530  :     xL = out[0]; xR = out[1];

  0006f	b8 04 00 00 00	 mov	 eax, 4
  00074	48 6b c0 00	 imul	 rax, rax, 0
  00078	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  0007c	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax
  00080	b8 04 00 00 00	 mov	 eax, 4
  00085	48 6b c0 01	 imul	 rax, rax, 1
  00089	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  0008d	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 531  :     des_encipher(out, xL, xR, sched+1);

  00091	48 8b 44 24 30	 mov	 rax, QWORD PTR sched$[rsp]
  00096	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  0009c	4c 8b c8	 mov	 r9, rax
  0009f	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  000a4	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  000a8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  000ad	e8 00 00 00 00	 call	 des_encipher

; 532  :     xL = out[0]; xR = out[1];

  000b2	b8 04 00 00 00	 mov	 eax, 4
  000b7	48 6b c0 00	 imul	 rax, rax, 0
  000bb	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  000bf	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax
  000c3	b8 04 00 00 00	 mov	 eax, 4
  000c8	48 6b c0 01	 imul	 rax, rax, 1
  000cc	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  000d0	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 533  :     des_decipher(out, xL, xR, sched);

  000d4	4c 8b 4c 24 30	 mov	 r9, QWORD PTR sched$[rsp]
  000d9	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  000de	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  000e2	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  000e7	e8 00 00 00 00	 call	 des_decipher

; 534  :     store_fw(output, out[0]);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	48 6b c0 00	 imul	 rax, rax, 0
  000f5	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  000f9	e8 00 00 00 00	 call	 _byteswap_ulong
  000fe	8b d0		 mov	 edx, eax
  00100	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  00105	e8 00 00 00 00	 call	 store_fw_noswap

; 535  :     store_fw(output+4, out[1]);

  0010a	b8 04 00 00 00	 mov	 eax, 4
  0010f	48 6b c0 01	 imul	 rax, rax, 1
  00113	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  00117	e8 00 00 00 00	 call	 _byteswap_ulong
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  00121	48 83 c1 04	 add	 rcx, 4
  00125	8b d0		 mov	 edx, eax
  00127	e8 00 00 00 00	 call	 store_fw_noswap

; 536  : }

  0012c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00130	c3		 ret	 0
des3_decrypt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
xR$ = 32
xL$ = 36
out$ = 40
sched$ = 48
ctx$ = 80
input$ = 88
output$ = 96
des3_encrypt PROC

; 509  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 510  :     DESContext *sched = ctx->sched;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR sched$[rsp], rax

; 511  :     word32 out[2], xL, xR;
; 512  :     xL = fetch_fw(input);

  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR input$[rsp]
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax

; 513  :     xR = fetch_fw(input+4);

  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR input$[rsp]
  00037	48 83 c0 04	 add	 rax, 4
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 _byteswap_ulong
  0004a	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 514  :     des_encipher(out, xL, xR, sched);

  0004e	4c 8b 4c 24 30	 mov	 r9, QWORD PTR sched$[rsp]
  00053	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  00058	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  0005c	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  00061	e8 00 00 00 00	 call	 des_encipher

; 515  :     xL = out[0]; xR = out[1];

  00066	b8 04 00 00 00	 mov	 eax, 4
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  00073	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax
  00077	b8 04 00 00 00	 mov	 eax, 4
  0007c	48 6b c0 01	 imul	 rax, rax, 1
  00080	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  00084	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 516  :     des_decipher(out, xL, xR, sched+1);

  00088	48 8b 44 24 30	 mov	 rax, QWORD PTR sched$[rsp]
  0008d	48 05 88 00 00
	00		 add	 rax, 136		; 00000088H
  00093	4c 8b c8	 mov	 r9, rax
  00096	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  0009b	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  0009f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  000a4	e8 00 00 00 00	 call	 des_decipher

; 517  :     xL = out[0]; xR = out[1];

  000a9	b8 04 00 00 00	 mov	 eax, 4
  000ae	48 6b c0 00	 imul	 rax, rax, 0
  000b2	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  000b6	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax
  000ba	b8 04 00 00 00	 mov	 eax, 4
  000bf	48 6b c0 01	 imul	 rax, rax, 1
  000c3	8b 44 04 28	 mov	 eax, DWORD PTR out$[rsp+rax]
  000c7	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 518  :     des_encipher(out, xL, xR, sched+2);

  000cb	48 8b 44 24 30	 mov	 rax, QWORD PTR sched$[rsp]
  000d0	48 05 10 01 00
	00		 add	 rax, 272		; 00000110H
  000d6	4c 8b c8	 mov	 r9, rax
  000d9	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  000de	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  000e2	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  000e7	e8 00 00 00 00	 call	 des_encipher

; 519  :     store_fw(output, out[0]);

  000ec	b8 04 00 00 00	 mov	 eax, 4
  000f1	48 6b c0 00	 imul	 rax, rax, 0
  000f5	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  000f9	e8 00 00 00 00	 call	 _byteswap_ulong
  000fe	8b d0		 mov	 edx, eax
  00100	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  00105	e8 00 00 00 00	 call	 store_fw_noswap

; 520  :     store_fw(output+4, out[1]);

  0010a	b8 04 00 00 00	 mov	 eax, 4
  0010f	48 6b c0 01	 imul	 rax, rax, 1
  00113	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  00117	e8 00 00 00 00	 call	 _byteswap_ulong
  0011c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  00121	48 83 c1 04	 add	 rcx, 4
  00125	8b d0		 mov	 edx, eax
  00127	e8 00 00 00 00	 call	 store_fw_noswap

; 521  : }

  0012c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00130	c3		 ret	 0
des3_encrypt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
kR$ = 32
kL$ = 36
sched$ = 40
ctx$ = 64
k1$ = 72
k2$ = 80
k3$ = 88
des3_set_3keys PROC

; 494  : {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 495  :     DESContext *sched = ctx->sched;

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR ctx$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR sched$[rsp], rax

; 496  :     word32 kL, kR;
; 497  :     kL = fetch_fw(k1);

  00022	48 8b 4c 24 48	 mov	 rcx, QWORD PTR k1$[rsp]
  00027	e8 00 00 00 00	 call	 fetch_fw_noswap
  0002c	8b c8		 mov	 ecx, eax
  0002e	e8 00 00 00 00	 call	 _byteswap_ulong
  00033	89 44 24 24	 mov	 DWORD PTR kL$[rsp], eax

; 498  :     kR = fetch_fw(k1+4);

  00037	48 8b 44 24 48	 mov	 rax, QWORD PTR k1$[rsp]
  0003c	48 83 c0 04	 add	 rax, 4
  00040	48 8b c8	 mov	 rcx, rax
  00043	e8 00 00 00 00	 call	 fetch_fw_noswap
  00048	8b c8		 mov	 ecx, eax
  0004a	e8 00 00 00 00	 call	 _byteswap_ulong
  0004f	89 44 24 20	 mov	 DWORD PTR kR$[rsp], eax

; 499  :     des_key_setup(kL, kR, &sched[0]);

  00053	b8 88 00 00 00	 mov	 eax, 136		; 00000088H
  00058	48 6b c0 00	 imul	 rax, rax, 0
  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sched$[rsp]
  00061	48 03 c8	 add	 rcx, rax
  00064	48 8b c1	 mov	 rax, rcx
  00067	4c 8b c0	 mov	 r8, rax
  0006a	8b 54 24 20	 mov	 edx, DWORD PTR kR$[rsp]
  0006e	8b 4c 24 24	 mov	 ecx, DWORD PTR kL$[rsp]
  00072	e8 00 00 00 00	 call	 des_key_setup

; 500  :     kL = fetch_fw(k2);

  00077	48 8b 4c 24 50	 mov	 rcx, QWORD PTR k2$[rsp]
  0007c	e8 00 00 00 00	 call	 fetch_fw_noswap
  00081	8b c8		 mov	 ecx, eax
  00083	e8 00 00 00 00	 call	 _byteswap_ulong
  00088	89 44 24 24	 mov	 DWORD PTR kL$[rsp], eax

; 501  :     kR = fetch_fw(k2+4);

  0008c	48 8b 44 24 50	 mov	 rax, QWORD PTR k2$[rsp]
  00091	48 83 c0 04	 add	 rax, 4
  00095	48 8b c8	 mov	 rcx, rax
  00098	e8 00 00 00 00	 call	 fetch_fw_noswap
  0009d	8b c8		 mov	 ecx, eax
  0009f	e8 00 00 00 00	 call	 _byteswap_ulong
  000a4	89 44 24 20	 mov	 DWORD PTR kR$[rsp], eax

; 502  :     des_key_setup(kL, kR, &sched[1]);

  000a8	b8 88 00 00 00	 mov	 eax, 136		; 00000088H
  000ad	48 6b c0 01	 imul	 rax, rax, 1
  000b1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sched$[rsp]
  000b6	48 03 c8	 add	 rcx, rax
  000b9	48 8b c1	 mov	 rax, rcx
  000bc	4c 8b c0	 mov	 r8, rax
  000bf	8b 54 24 20	 mov	 edx, DWORD PTR kR$[rsp]
  000c3	8b 4c 24 24	 mov	 ecx, DWORD PTR kL$[rsp]
  000c7	e8 00 00 00 00	 call	 des_key_setup

; 503  :     kL = fetch_fw(k3);

  000cc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR k3$[rsp]
  000d1	e8 00 00 00 00	 call	 fetch_fw_noswap
  000d6	8b c8		 mov	 ecx, eax
  000d8	e8 00 00 00 00	 call	 _byteswap_ulong
  000dd	89 44 24 24	 mov	 DWORD PTR kL$[rsp], eax

; 504  :     kR = fetch_fw(k3+4);

  000e1	48 8b 44 24 58	 mov	 rax, QWORD PTR k3$[rsp]
  000e6	48 83 c0 04	 add	 rax, 4
  000ea	48 8b c8	 mov	 rcx, rax
  000ed	e8 00 00 00 00	 call	 fetch_fw_noswap
  000f2	8b c8		 mov	 ecx, eax
  000f4	e8 00 00 00 00	 call	 _byteswap_ulong
  000f9	89 44 24 20	 mov	 DWORD PTR kR$[rsp], eax

; 505  :     des_key_setup(kL, kR, &sched[2]);

  000fd	b8 88 00 00 00	 mov	 eax, 136		; 00000088H
  00102	48 6b c0 02	 imul	 rax, rax, 2
  00106	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sched$[rsp]
  0010b	48 03 c8	 add	 rcx, rax
  0010e	48 8b c1	 mov	 rax, rcx
  00111	4c 8b c0	 mov	 r8, rax
  00114	8b 54 24 20	 mov	 edx, DWORD PTR kR$[rsp]
  00118	8b 4c 24 24	 mov	 ecx, DWORD PTR kL$[rsp]
  0011c	e8 00 00 00 00	 call	 des_key_setup

; 506  : }

  00121	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00125	c3		 ret	 0
des3_set_3keys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
kR$ = 32
kL$ = 36
sched$ = 40
ctx$ = 64
k1$ = 72
k2$ = 80
des3_set_2keys PROC

; 481  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 482  :     DESContext *sched = ctx->sched;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR ctx$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR sched$[rsp], rax

; 483  :     word32 kL, kR;
; 484  :     kL = fetch_fw(k1);

  0001d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR k1$[rsp]
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 24	 mov	 DWORD PTR kL$[rsp], eax

; 485  :     kR = fetch_fw(k1+4);

  00032	48 8b 44 24 48	 mov	 rax, QWORD PTR k1$[rsp]
  00037	48 83 c0 04	 add	 rax, 4
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 _byteswap_ulong
  0004a	89 44 24 20	 mov	 DWORD PTR kR$[rsp], eax

; 486  :     des_key_setup(kL, kR, &sched[0]);

  0004e	b8 88 00 00 00	 mov	 eax, 136		; 00000088H
  00053	48 6b c0 00	 imul	 rax, rax, 0
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sched$[rsp]
  0005c	48 03 c8	 add	 rcx, rax
  0005f	48 8b c1	 mov	 rax, rcx
  00062	4c 8b c0	 mov	 r8, rax
  00065	8b 54 24 20	 mov	 edx, DWORD PTR kR$[rsp]
  00069	8b 4c 24 24	 mov	 ecx, DWORD PTR kL$[rsp]
  0006d	e8 00 00 00 00	 call	 des_key_setup

; 487  :     des_key_setup(kL, kR, &sched[2]);

  00072	b8 88 00 00 00	 mov	 eax, 136		; 00000088H
  00077	48 6b c0 02	 imul	 rax, rax, 2
  0007b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sched$[rsp]
  00080	48 03 c8	 add	 rcx, rax
  00083	48 8b c1	 mov	 rax, rcx
  00086	4c 8b c0	 mov	 r8, rax
  00089	8b 54 24 20	 mov	 edx, DWORD PTR kR$[rsp]
  0008d	8b 4c 24 24	 mov	 ecx, DWORD PTR kL$[rsp]
  00091	e8 00 00 00 00	 call	 des_key_setup

; 488  :     kL = fetch_fw(k2);

  00096	48 8b 4c 24 50	 mov	 rcx, QWORD PTR k2$[rsp]
  0009b	e8 00 00 00 00	 call	 fetch_fw_noswap
  000a0	8b c8		 mov	 ecx, eax
  000a2	e8 00 00 00 00	 call	 _byteswap_ulong
  000a7	89 44 24 24	 mov	 DWORD PTR kL$[rsp], eax

; 489  :     kR = fetch_fw(k2+4);

  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR k2$[rsp]
  000b0	48 83 c0 04	 add	 rax, 4
  000b4	48 8b c8	 mov	 rcx, rax
  000b7	e8 00 00 00 00	 call	 fetch_fw_noswap
  000bc	8b c8		 mov	 ecx, eax
  000be	e8 00 00 00 00	 call	 _byteswap_ulong
  000c3	89 44 24 20	 mov	 DWORD PTR kR$[rsp], eax

; 490  :     des_key_setup(kL, kR, &sched[1]);

  000c7	b8 88 00 00 00	 mov	 eax, 136		; 00000088H
  000cc	48 6b c0 01	 imul	 rax, rax, 1
  000d0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sched$[rsp]
  000d5	48 03 c8	 add	 rcx, rax
  000d8	48 8b c1	 mov	 rax, rcx
  000db	4c 8b c0	 mov	 r8, rax
  000de	8b 54 24 20	 mov	 edx, DWORD PTR kR$[rsp]
  000e2	8b 4c 24 24	 mov	 ecx, DWORD PTR kL$[rsp]
  000e6	e8 00 00 00 00	 call	 des_key_setup

; 491  : }

  000eb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ef	c3		 ret	 0
des3_set_2keys ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
xR$ = 32
xL$ = 36
out$ = 40
sched$ = 48
ctx$ = 80
input$ = 88
output$ = 96
des_decrypt PROC

; 470  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 471  :     DESContext *sched = ctx->sched;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR sched$[rsp], rax

; 472  :     word32 out[2], xL, xR;
; 473  :     xL = fetch_fw(input);

  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR input$[rsp]
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax

; 474  :     xR = fetch_fw(input+4);

  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR input$[rsp]
  00037	48 83 c0 04	 add	 rax, 4
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 _byteswap_ulong
  0004a	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 475  :     des_decipher(out, xL, xR, sched);

  0004e	4c 8b 4c 24 30	 mov	 r9, QWORD PTR sched$[rsp]
  00053	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  00058	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  0005c	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  00061	e8 00 00 00 00	 call	 des_decipher

; 476  :     store_fw(output, out[0]);

  00066	b8 04 00 00 00	 mov	 eax, 4
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  00073	e8 00 00 00 00	 call	 _byteswap_ulong
  00078	8b d0		 mov	 edx, eax
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  0007f	e8 00 00 00 00	 call	 store_fw_noswap

; 477  :     store_fw(output+4, out[1]);

  00084	b8 04 00 00 00	 mov	 eax, 4
  00089	48 6b c0 01	 imul	 rax, rax, 1
  0008d	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  00091	e8 00 00 00 00	 call	 _byteswap_ulong
  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  0009b	48 83 c1 04	 add	 rcx, 4
  0009f	8b d0		 mov	 edx, eax
  000a1	e8 00 00 00 00	 call	 store_fw_noswap

; 478  : }

  000a6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000aa	c3		 ret	 0
des_decrypt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
xR$ = 32
xL$ = 36
out$ = 40
sched$ = 48
ctx$ = 80
input$ = 88
output$ = 96
des_encrypt PROC

; 459  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 460  :     DESContext *sched = ctx->sched;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR ctx$[rsp]
  00018	48 89 44 24 30	 mov	 QWORD PTR sched$[rsp], rax

; 461  :     word32 out[2], xL, xR;
; 462  :     xL = fetch_fw(input);

  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR input$[rsp]
  00022	e8 00 00 00 00	 call	 fetch_fw_noswap
  00027	8b c8		 mov	 ecx, eax
  00029	e8 00 00 00 00	 call	 _byteswap_ulong
  0002e	89 44 24 24	 mov	 DWORD PTR xL$[rsp], eax

; 463  :     xR = fetch_fw(input+4);

  00032	48 8b 44 24 58	 mov	 rax, QWORD PTR input$[rsp]
  00037	48 83 c0 04	 add	 rax, 4
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00043	8b c8		 mov	 ecx, eax
  00045	e8 00 00 00 00	 call	 _byteswap_ulong
  0004a	89 44 24 20	 mov	 DWORD PTR xR$[rsp], eax

; 464  :     des_encipher(out, xL, xR, sched);

  0004e	4c 8b 4c 24 30	 mov	 r9, QWORD PTR sched$[rsp]
  00053	44 8b 44 24 20	 mov	 r8d, DWORD PTR xR$[rsp]
  00058	8b 54 24 24	 mov	 edx, DWORD PTR xL$[rsp]
  0005c	48 8d 4c 24 28	 lea	 rcx, QWORD PTR out$[rsp]
  00061	e8 00 00 00 00	 call	 des_encipher

; 465  :     store_fw(output, out[0]);

  00066	b8 04 00 00 00	 mov	 eax, 4
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  00073	e8 00 00 00 00	 call	 _byteswap_ulong
  00078	8b d0		 mov	 edx, eax
  0007a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  0007f	e8 00 00 00 00	 call	 store_fw_noswap

; 466  :     store_fw(output+4, out[1]);

  00084	b8 04 00 00 00	 mov	 eax, 4
  00089	48 6b c0 01	 imul	 rax, rax, 1
  0008d	8b 4c 04 28	 mov	 ecx, DWORD PTR out$[rsp+rax]
  00091	e8 00 00 00 00	 call	 _byteswap_ulong
  00096	48 8b 4c 24 60	 mov	 rcx, QWORD PTR output$[rsp]
  0009b	48 83 c1 04	 add	 rcx, 4
  0009f	8b d0		 mov	 edx, eax
  000a1	e8 00 00 00 00	 call	 store_fw_noswap

; 467  : }

  000a6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000aa	c3		 ret	 0
des_encrypt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
kR$ = 32
kL$ = 36
sched$ = 40
ctx$ = 64
key$ = 72
des_set_key PROC

; 450  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 451  :     DESContext *sched = ctx->sched;

  0000e	48 8b 44 24 40	 mov	 rax, QWORD PTR ctx$[rsp]
  00013	48 89 44 24 28	 mov	 QWORD PTR sched$[rsp], rax

; 452  :     word32 kL, kR;
; 453  :     kL = fetch_fw(key);

  00018	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  0001d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00022	8b c8		 mov	 ecx, eax
  00024	e8 00 00 00 00	 call	 _byteswap_ulong
  00029	89 44 24 24	 mov	 DWORD PTR kL$[rsp], eax

; 454  :     kR = fetch_fw(key+4);

  0002d	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  00032	48 83 c0 04	 add	 rax, 4
  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 fetch_fw_noswap
  0003e	8b c8		 mov	 ecx, eax
  00040	e8 00 00 00 00	 call	 _byteswap_ulong
  00045	89 44 24 20	 mov	 DWORD PTR kR$[rsp], eax

; 455  :     des_key_setup(kL, kR, &sched[0]);

  00049	b8 88 00 00 00	 mov	 eax, 136		; 00000088H
  0004e	48 6b c0 00	 imul	 rax, rax, 0
  00052	48 8b 4c 24 28	 mov	 rcx, QWORD PTR sched$[rsp]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	4c 8b c0	 mov	 r8, rax
  00060	8b 54 24 20	 mov	 edx, DWORD PTR kR$[rsp]
  00064	8b 4c 24 24	 mov	 ecx, DWORD PTR kL$[rsp]
  00068	e8 00 00 00 00	 call	 des_key_setup

; 456  : }

  0006d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00071	c3		 ret	 0
des_set_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 0
carry$ = 4
dst$ = 32
src$ = 40
len$ = 48
shift_left PROC

; 415  : {

$LN8:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 416  :   int carry;
; 417  :   int i;
; 418  : 
; 419  :   carry = 0;

  00013	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR carry$[rsp], 0

; 420  :   for(i = 0; i < len; i++)

  0001b	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  00022	eb 08		 jmp	 SHORT $LN4@shift_left
$LN2@shift_left:
  00024	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00027	ff c0		 inc	 eax
  00029	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@shift_left:
  0002c	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00030	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  00033	0f 8d c7 00 00
	00		 jge	 $LN3@shift_left

; 421  :   {
; 422  :     if(carry)

  00039	83 7c 24 04 00	 cmp	 DWORD PTR carry$[rsp], 0
  0003e	74 74		 je	 SHORT $LN5@shift_left

; 423  :     {
; 424  :       carry = src[len - 1 - i] & 0x80;

  00040	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00044	ff c8		 dec	 eax
  00046	2b 04 24	 sub	 eax, DWORD PTR i$[rsp]
  00049	48 98		 cdqe
  0004b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  00050	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00054	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00059	89 44 24 04	 mov	 DWORD PTR carry$[rsp], eax

; 425  :       dst[len - 1 - i] = src[len - 1 - i] << 1;

  0005d	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00061	ff c8		 dec	 eax
  00063	2b 04 24	 sub	 eax, DWORD PTR i$[rsp]
  00066	48 98		 cdqe
  00068	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  0006d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00071	d1 e0		 shl	 eax, 1
  00073	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  00077	ff c9		 dec	 ecx
  00079	2b 0c 24	 sub	 ecx, DWORD PTR i$[rsp]
  0007c	48 63 c9	 movsxd	 rcx, ecx
  0007f	48 8b 54 24 20	 mov	 rdx, QWORD PTR dst$[rsp]
  00084	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 426  :       dst[len - 1 - i] |= 0x01;

  00087	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0008b	ff c8		 dec	 eax
  0008d	2b 04 24	 sub	 eax, DWORD PTR i$[rsp]
  00090	48 98		 cdqe
  00092	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dst$[rsp]
  00097	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0009b	83 c8 01	 or	 eax, 1
  0009e	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000a2	ff c9		 dec	 ecx
  000a4	2b 0c 24	 sub	 ecx, DWORD PTR i$[rsp]
  000a7	48 63 c9	 movsxd	 rcx, ecx
  000aa	48 8b 54 24 20	 mov	 rdx, QWORD PTR dst$[rsp]
  000af	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 427  :     }

  000b2	eb 47		 jmp	 SHORT $LN6@shift_left
$LN5@shift_left:

; 428  :     else
; 429  :     {
; 430  :       carry = src[len - 1 - i] & 0x80;

  000b4	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  000b8	ff c8		 dec	 eax
  000ba	2b 04 24	 sub	 eax, DWORD PTR i$[rsp]
  000bd	48 98		 cdqe
  000bf	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  000c4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000c8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000cd	89 44 24 04	 mov	 DWORD PTR carry$[rsp], eax

; 431  :       dst[len - 1 - i] = src[len - 1 - i] << 1;

  000d1	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  000d5	ff c8		 dec	 eax
  000d7	2b 04 24	 sub	 eax, DWORD PTR i$[rsp]
  000da	48 98		 cdqe
  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR src$[rsp]
  000e1	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  000e5	d1 e0		 shl	 eax, 1
  000e7	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000eb	ff c9		 dec	 ecx
  000ed	2b 0c 24	 sub	 ecx, DWORD PTR i$[rsp]
  000f0	48 63 c9	 movsxd	 rcx, ecx
  000f3	48 8b 54 24 20	 mov	 rdx, QWORD PTR dst$[rsp]
  000f8	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN6@shift_left:

; 432  :     }
; 433  :   }

  000fb	e9 24 ff ff ff	 jmp	 $LN2@shift_left
$LN3@shift_left:

; 434  : }

  00100	48 83 c4 18	 add	 rsp, 24
  00104	c3		 ret	 0
shift_left ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
j$ = 0
i$ = 4
ctx$ = 32
icv$ = 40
sha512_seticv PROC

; 395  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 396  :   int i, j;
; 397  : 
; 398  :   for(i = 0, j = 0; i < 8; i++)

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	c7 04 24 00 00
	00 00		 mov	 DWORD PTR j$[rsp], 0
  0001d	eb 0a		 jmp	 SHORT $LN4@sha512_set
$LN2@sha512_set:
  0001f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@sha512_set:
  00029	83 7c 24 04 08	 cmp	 DWORD PTR i$[rsp], 8
  0002e	0f 8d b4 01 00
	00		 jge	 $LN3@sha512_set

; 399  :   {
; 400  :     ctx->state.st64[i]  = (((U64)icv[j++]) << 56);

  00034	48 63 04 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR icv$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	48 c1 e0 38	 shl	 rax, 56			; 00000038H
  00045	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  0004a	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  0004f	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  00053	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00056	ff c0		 inc	 eax
  00058	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 401  :     ctx->state.st64[i] |= (((U64)icv[j++]) << 48);

  0005b	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00060	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00064	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00069	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0006d	48 c1 e1 30	 shl	 rcx, 48			; 00000030H
  00071	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00076	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0007a	48 0b c1	 or	 rax, rcx
  0007d	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  00082	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00087	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  0008b	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  0008e	ff c0		 inc	 eax
  00090	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 402  :     ctx->state.st64[i] |= (((U64)icv[j++]) << 40);

  00093	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00098	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0009c	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000a1	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000a5	48 c1 e1 28	 shl	 rcx, 40			; 00000028H
  000a9	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000ae	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  000b2	48 0b c1	 or	 rax, rcx
  000b5	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  000ba	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000bf	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  000c3	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000c6	ff c0		 inc	 eax
  000c8	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 403  :     ctx->state.st64[i] |= (((U64)icv[j++]) << 32);

  000cb	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000d0	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000d4	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000d9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000dd	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  000e1	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000e6	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  000ea	48 0b c1	 or	 rax, rcx
  000ed	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  000f2	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000f7	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  000fb	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000fe	ff c0		 inc	 eax
  00100	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 404  :     ctx->state.st64[i] |= (((U64)icv[j++]) << 24);

  00103	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00108	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0010c	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00111	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00115	48 c1 e1 18	 shl	 rcx, 24
  00119	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  0011e	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00122	48 0b c1	 or	 rax, rcx
  00125	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  0012a	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  0012f	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  00133	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00136	ff c0		 inc	 eax
  00138	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 405  :     ctx->state.st64[i] |= (((U64)icv[j++]) << 16);

  0013b	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00140	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00144	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00149	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0014d	48 c1 e1 10	 shl	 rcx, 16
  00151	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00156	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  0015a	48 0b c1	 or	 rax, rcx
  0015d	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  00162	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00167	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  0016b	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  0016e	ff c0		 inc	 eax
  00170	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 406  :     ctx->state.st64[i] |= (((U64)icv[j++]) <<  8);

  00173	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00178	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0017c	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00181	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00185	48 c1 e1 08	 shl	 rcx, 8
  00189	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  0018e	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  00192	48 0b c1	 or	 rax, rcx
  00195	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  0019a	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  0019f	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  001a3	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  001a6	ff c0		 inc	 eax
  001a8	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 407  :     ctx->state.st64[i] |= (((U64)icv[j++]) <<  0);

  001ab	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  001b0	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  001b4	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  001b9	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  001bd	48 c1 e1 00	 shl	 rcx, 0
  001c1	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  001c6	48 8b 04 c2	 mov	 rax, QWORD PTR [rdx+rax*8]
  001ca	48 0b c1	 or	 rax, rcx
  001cd	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  001d2	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  001d7	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
  001db	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  001de	ff c0		 inc	 eax
  001e0	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 408  :   }

  001e3	e9 37 fe ff ff	 jmp	 $LN2@sha512_set
$LN3@sha512_set:

; 409  : }

  001e8	48 83 c4 18	 add	 rsp, 24
  001ec	c3		 ret	 0
sha512_seticv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
j$ = 0
i$ = 4
ctx$ = 32
icv$ = 40
sha512_getcv PROC

; 375  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 376  :   int i, j;
; 377  : 
; 378  :   for(i = 0, j = 0; i < 8; i++)

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	c7 04 24 00 00
	00 00		 mov	 DWORD PTR j$[rsp], 0
  0001d	eb 0a		 jmp	 SHORT $LN4@sha512_get
$LN2@sha512_get:
  0001f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@sha512_get:
  00029	83 7c 24 04 08	 cmp	 DWORD PTR i$[rsp], 8
  0002e	0f 8d 7f 01 00
	00		 jge	 $LN3@sha512_get

; 379  :   {
; 380  :     icv[j++] = (ctx->state.st64[i] & 0xff00000000000000LL) >> 56;

  00034	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  0003e	48 ba 00 00 00
	00 00 00 00 ff	 mov	 rdx, -72057594037927936	; ff00000000000000H
  00048	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0004c	48 23 c2	 and	 rax, rdx
  0004f	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  00053	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00057	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0005c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0005f	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00062	ff c0		 inc	 eax
  00064	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 381  :     icv[j++] = (ctx->state.st64[i] & 0x00ff000000000000LL) >> 48;

  00067	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0006c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00071	48 ba 00 00 00
	00 00 00 ff 00	 mov	 rdx, 71776119061217280	; 00ff000000000000H
  0007b	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0007f	48 23 c2	 and	 rax, rdx
  00082	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00086	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0008a	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0008f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00092	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00095	ff c0		 inc	 eax
  00097	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 382  :     icv[j++] = (ctx->state.st64[i] & 0x0000ff0000000000LL) >> 40;

  0009a	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  000a4	48 ba 00 00 00
	00 00 ff 00 00	 mov	 rdx, 280375465082880	; 0000ff0000000000H
  000ae	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000b2	48 23 c2	 and	 rax, rdx
  000b5	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  000b9	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000bd	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000c2	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000c5	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000c8	ff c0		 inc	 eax
  000ca	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 383  :     icv[j++] = (ctx->state.st64[i] & 0x000000ff00000000LL) >> 32;

  000cd	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000d2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  000d7	48 ba 00 00 00
	00 ff 00 00 00	 mov	 rdx, 1095216660480	; 000000ff00000000H
  000e1	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000e5	48 23 c2	 and	 rax, rdx
  000e8	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  000ec	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000f0	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000f5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000f8	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000fb	ff c0		 inc	 eax
  000fd	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 384  :     icv[j++] = (ctx->state.st64[i] & 0x00000000ff000000LL) >> 24;

  00100	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00105	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  0010a	ba 00 00 00 ff	 mov	 edx, -16777216		; ff000000H
  0010f	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00113	48 23 c2	 and	 rax, rdx
  00116	48 c1 e8 18	 shr	 rax, 24
  0011a	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0011e	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00123	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00126	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00129	ff c0		 inc	 eax
  0012b	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 385  :     icv[j++] = (ctx->state.st64[i] & 0x0000000000ff0000LL) >> 16;

  0012e	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00133	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00138	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  0013c	48 25 00 00 ff
	00		 and	 rax, 16711680		; 00ff0000H
  00142	48 c1 e8 10	 shr	 rax, 16
  00146	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0014a	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0014f	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00152	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00155	ff c0		 inc	 eax
  00157	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 386  :     icv[j++] = (ctx->state.st64[i] & 0x000000000000ff00LL) >>  8;

  0015a	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0015f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00164	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00168	48 25 00 ff 00
	00		 and	 rax, 65280		; 0000ff00H
  0016e	48 c1 e8 08	 shr	 rax, 8
  00172	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00176	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0017b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0017e	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00181	ff c0		 inc	 eax
  00183	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 387  :     icv[j++] = (ctx->state.st64[i] & 0x00000000000000ffLL) >>  0;

  00186	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0018b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00190	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00194	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  0019a	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0019e	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  001a3	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  001a6	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  001a9	ff c0		 inc	 eax
  001ab	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 388  :   }

  001ae	e9 6c fe ff ff	 jmp	 $LN2@sha512_get
$LN3@sha512_get:

; 389  : }

  001b3	48 83 c4 18	 add	 rsp, 24
  001b7	c3		 ret	 0
sha512_getcv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
j$ = 0
i$ = 4
ctx$ = 32
icv$ = 40
sha256_seticv PROC

; 359  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 360  :   int i, j;
; 361  : 
; 362  :   for(i = 0, j = 0; i < 8; i++)

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	c7 04 24 00 00
	00 00		 mov	 DWORD PTR j$[rsp], 0
  0001d	eb 0a		 jmp	 SHORT $LN4@sha256_set
$LN2@sha256_set:
  0001f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@sha256_set:
  00029	83 7c 24 04 08	 cmp	 DWORD PTR i$[rsp], 8
  0002e	0f 8d c6 00 00
	00		 jge	 $LN3@sha256_set

; 363  :   {
; 364  :     ctx->state.st32[i]  = (((U32)icv[j++]) << 24);

  00034	48 63 04 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR icv$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	c1 e0 18	 shl	 eax, 24
  00044	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  00049	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  0004e	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00051	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00054	ff c0		 inc	 eax
  00056	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 365  :     ctx->state.st32[i] |= (((U32)icv[j++]) << 16);

  00059	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0005e	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00062	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00067	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0006b	c1 e1 10	 shl	 ecx, 16
  0006e	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00073	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00076	0b c1		 or	 eax, ecx
  00078	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  0007d	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00082	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00085	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 366  :     ctx->state.st32[i] |= (((U32)icv[j++]) <<  8);

  0008d	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00092	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00096	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0009b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0009f	c1 e1 08	 shl	 ecx, 8
  000a2	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000a7	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  000aa	0b c1		 or	 eax, ecx
  000ac	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b1	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000b6	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  000b9	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000bc	ff c0		 inc	 eax
  000be	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 367  :     ctx->state.st32[i] |= (((U32)icv[j++]) <<  0);

  000c1	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000c6	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000ca	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000cf	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d3	c1 e1 00	 shl	 ecx, 0
  000d6	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000db	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  000de	0b c1		 or	 eax, ecx
  000e0	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  000e5	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000ea	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  000ed	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000f0	ff c0		 inc	 eax
  000f2	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 368  :   }

  000f5	e9 25 ff ff ff	 jmp	 $LN2@sha256_set
$LN3@sha256_set:

; 369  : }

  000fa	48 83 c4 18	 add	 rsp, 24
  000fe	c3		 ret	 0
sha256_seticv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
j$ = 0
i$ = 4
ctx$ = 32
icv$ = 40
sha256_getcv PROC

; 343  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 344  :   int i, j;
; 345  : 
; 346  :   for(i = 0, j = 0; i < 8; i++)

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	c7 04 24 00 00
	00 00		 mov	 DWORD PTR j$[rsp], 0
  0001d	eb 0a		 jmp	 SHORT $LN4@sha256_get
$LN2@sha256_get:
  0001f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@sha256_get:
  00029	83 7c 24 04 08	 cmp	 DWORD PTR i$[rsp], 8
  0002e	0f 8d a6 00 00
	00		 jge	 $LN3@sha256_get

; 347  :   {
; 348  :     icv[j++] = (ctx->state.st32[i] & 0xff000000) >> 24;

  00034	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  0003e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00041	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00046	c1 e8 18	 shr	 eax, 24
  00049	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0004d	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00052	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00055	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00058	ff c0		 inc	 eax
  0005a	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 349  :     icv[j++] = (ctx->state.st32[i] & 0x00ff0000) >> 16;

  0005d	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00067	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0006a	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0006f	c1 e8 10	 shr	 eax, 16
  00072	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00076	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0007b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0007e	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00081	ff c0		 inc	 eax
  00083	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 350  :     icv[j++] = (ctx->state.st32[i] & 0x0000ff00) >>  8;

  00086	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00090	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00093	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00098	c1 e8 08	 shr	 eax, 8
  0009b	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0009f	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000a4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000a7	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000aa	ff c0		 inc	 eax
  000ac	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 351  :     icv[j++] = (ctx->state.st32[i] & 0x000000ff) >>  0;

  000af	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  000b9	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000bc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c1	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000c5	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000ca	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000cd	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000d0	ff c0		 inc	 eax
  000d2	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 352  :   }

  000d5	e9 45 ff ff ff	 jmp	 $LN2@sha256_get
$LN3@sha256_get:

; 353  : }

  000da	48 83 c4 18	 add	 rsp, 24
  000de	c3		 ret	 0
sha256_getcv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
j$ = 0
i$ = 4
ctx$ = 32
icv$ = 40
sha1_seticv PROC

; 327  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 328  :   int i, j;
; 329  : 
; 330  :   for(i = 0, j = 0; i < 5; i++)

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	c7 04 24 00 00
	00 00		 mov	 DWORD PTR j$[rsp], 0
  0001d	eb 0a		 jmp	 SHORT $LN4@sha1_setic
$LN2@sha1_setic:
  0001f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@sha1_setic:
  00029	83 7c 24 04 05	 cmp	 DWORD PTR i$[rsp], 5
  0002e	0f 8d c6 00 00
	00		 jge	 $LN3@sha1_setic

; 331  :   {
; 332  :     ctx->state[i]  = (((U32)icv[j++]) << 24);

  00034	48 63 04 24	 movsxd	 rax, DWORD PTR j$[rsp]
  00038	48 8b 4c 24 28	 mov	 rcx, QWORD PTR icv$[rsp]
  0003d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00041	c1 e0 18	 shl	 eax, 24
  00044	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  00049	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  0004e	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00051	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00054	ff c0		 inc	 eax
  00056	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 333  :     ctx->state[i] |= (((U32)icv[j++]) << 16);

  00059	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0005e	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00062	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00067	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0006b	c1 e1 10	 shl	 ecx, 16
  0006e	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00073	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  00076	0b c1		 or	 eax, ecx
  00078	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  0007d	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  00082	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  00085	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00088	ff c0		 inc	 eax
  0008a	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 334  :     ctx->state[i] |= (((U32)icv[j++]) <<  8);

  0008d	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00092	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00096	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0009b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0009f	c1 e1 08	 shl	 ecx, 8
  000a2	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000a7	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  000aa	0b c1		 or	 eax, ecx
  000ac	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  000b1	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000b6	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  000b9	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000bc	ff c0		 inc	 eax
  000be	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 335  :     ctx->state[i] |= (((U32)icv[j++]) <<  0);

  000c1	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000c6	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000ca	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000cf	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  000d3	c1 e1 00	 shl	 ecx, 0
  000d6	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000db	8b 04 82	 mov	 eax, DWORD PTR [rdx+rax*4]
  000de	0b c1		 or	 eax, ecx
  000e0	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR i$[rsp]
  000e5	48 8b 54 24 20	 mov	 rdx, QWORD PTR ctx$[rsp]
  000ea	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
  000ed	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000f0	ff c0		 inc	 eax
  000f2	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 336  :   }

  000f5	e9 25 ff ff ff	 jmp	 $LN2@sha1_setic
$LN3@sha1_setic:

; 337  : }

  000fa	48 83 c4 18	 add	 rsp, 24
  000fe	c3		 ret	 0
sha1_seticv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
j$ = 0
i$ = 4
ctx$ = 32
icv$ = 40
sha1_getcv PROC

; 311  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 312  :   int i, j;
; 313  : 
; 314  :   for(i = 0, j = 0; i < 5; i++)

  0000e	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00016	c7 04 24 00 00
	00 00		 mov	 DWORD PTR j$[rsp], 0
  0001d	eb 0a		 jmp	 SHORT $LN4@sha1_getcv
$LN2@sha1_getcv:
  0001f	8b 44 24 04	 mov	 eax, DWORD PTR i$[rsp]
  00023	ff c0		 inc	 eax
  00025	89 44 24 04	 mov	 DWORD PTR i$[rsp], eax
$LN4@sha1_getcv:
  00029	83 7c 24 04 05	 cmp	 DWORD PTR i$[rsp], 5
  0002e	0f 8d a6 00 00
	00		 jge	 $LN3@sha1_getcv

; 315  :   {
; 316  :     icv[j++] = (ctx->state[i] & 0xff000000) >> 24;

  00034	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00039	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  0003e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00041	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  00046	c1 e8 18	 shr	 eax, 24
  00049	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0004d	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  00052	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00055	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00058	ff c0		 inc	 eax
  0005a	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 317  :     icv[j++] = (ctx->state[i] & 0x00ff0000) >> 16;

  0005d	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00067	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  0006a	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  0006f	c1 e8 10	 shr	 eax, 16
  00072	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  00076	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  0007b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  0007e	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  00081	ff c0		 inc	 eax
  00083	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 318  :     icv[j++] = (ctx->state[i] & 0x0000ff00) >>  8;

  00086	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  0008b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  00090	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  00093	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00098	c1 e8 08	 shr	 eax, 8
  0009b	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  0009f	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000a4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000a7	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000aa	ff c0		 inc	 eax
  000ac	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 319  :     icv[j++] = (ctx->state[i] & 0x000000ff) >>  0;

  000af	48 63 44 24 04	 movsxd	 rax, DWORD PTR i$[rsp]
  000b4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ctx$[rsp]
  000b9	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  000bc	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  000c1	48 63 0c 24	 movsxd	 rcx, DWORD PTR j$[rsp]
  000c5	48 8b 54 24 28	 mov	 rdx, QWORD PTR icv$[rsp]
  000ca	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000cd	8b 04 24	 mov	 eax, DWORD PTR j$[rsp]
  000d0	ff c0		 inc	 eax
  000d2	89 04 24	 mov	 DWORD PTR j$[rsp], eax

; 320  :   }

  000d5	e9 45 ff ff ff	 jmp	 $LN2@sha1_getcv
$LN3@sha1_getcv:

; 321  : }

  000da	48 83 c4 18	 add	 rsp, 24
  000de	c3		 ret	 0
sha1_getcv ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
regs$ = 8
get_msa	PROC

; 293  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 294  :   if (FACILITY_ENABLED( 077_MSA_EXTENSION_4,  regs ))

  00005	b8 01 00 00 00	 mov	 eax, 1
  0000a	48 6b c0 09	 imul	 rax, rax, 9
  0000e	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00013	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0001b	83 e0 04	 and	 eax, 4
  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN2@get_msa

; 295  :     return(4);

  00022	b8 04 00 00 00	 mov	 eax, 4
  00027	e9 92 00 00 00	 jmp	 $LN1@get_msa
$LN2@get_msa:

; 296  :   if (FACILITY_ENABLED( 076_MSA_EXTENSION_3,  regs ))

  0002c	b8 01 00 00 00	 mov	 eax, 1
  00031	48 6b c0 09	 imul	 rax, rax, 9
  00035	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0003a	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00042	83 e0 08	 and	 eax, 8
  00045	85 c0		 test	 eax, eax
  00047	74 07		 je	 SHORT $LN3@get_msa

; 297  :     return(3);

  00049	b8 03 00 00 00	 mov	 eax, 3
  0004e	eb 6e		 jmp	 SHORT $LN1@get_msa
$LN3@get_msa:

; 298  :   if (FACILITY_ENABLED( HERC_MSA_EXTENSION_2, regs ))

  00050	b8 01 00 00 00	 mov	 eax, 1
  00055	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  00059	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  0005e	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  00066	83 e0 01	 and	 eax, 1
  00069	85 c0		 test	 eax, eax
  0006b	74 07		 je	 SHORT $LN4@get_msa

; 299  :     return(2);

  0006d	b8 02 00 00 00	 mov	 eax, 2
  00072	eb 4a		 jmp	 SHORT $LN1@get_msa
$LN4@get_msa:

; 300  :   if (FACILITY_ENABLED( HERC_MSA_EXTENSION_1, regs ))

  00074	b8 01 00 00 00	 mov	 eax, 1
  00079	48 6b c0 20	 imul	 rax, rax, 32		; 00000020H
  0007d	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  00082	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  0008a	83 e0 02	 and	 eax, 2
  0008d	85 c0		 test	 eax, eax
  0008f	74 07		 je	 SHORT $LN5@get_msa

; 301  :     return(1);

  00091	b8 01 00 00 00	 mov	 eax, 1
  00096	eb 26		 jmp	 SHORT $LN1@get_msa
$LN5@get_msa:

; 302  :   if (FACILITY_ENABLED( 017_MSA,              regs ))

  00098	b8 01 00 00 00	 mov	 eax, 1
  0009d	48 6b c0 02	 imul	 rax, rax, 2
  000a1	48 8b 4c 24 08	 mov	 rcx, QWORD PTR regs$[rsp]
  000a6	0f b6 84 01 28
	0d 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3368]
  000ae	83 e0 40	 and	 eax, 64			; 00000040H
  000b1	85 c0		 test	 eax, eax
  000b3	74 04		 je	 SHORT $LN6@get_msa

; 303  :     return(0);

  000b5	33 c0		 xor	 eax, eax
  000b7	eb 05		 jmp	 SHORT $LN1@get_msa
$LN6@get_msa:

; 304  :   return(-1);

  000b9	b8 ff ff ff ff	 mov	 eax, -1
$LN1@get_msa:

; 305  : }

  000be	c3		 ret	 0
get_msa	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
i$ = 32
b_r$ = 40
a_r$ = 56
c_r$ = 72
__$ArrayPad$ = 88
a$ = 112
b$ = 120
c$ = 128
xts_gf_mult PROC

; 273  : {

$LN9:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 274  :   unsigned char a_r[16], b_r[16], c_r[16];
; 275  :   int i;
; 276  : 
; 277  :   for (i=0; i<=15; i++)

  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002a	eb 0a		 jmp	 SHORT $LN4@xts_gf_mul
$LN2@xts_gf_mul:
  0002c	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00030	ff c0		 inc	 eax
  00032	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@xts_gf_mul:
  00036	83 7c 24 20 0f	 cmp	 DWORD PTR i$[rsp], 15
  0003b	7f 3c		 jg	 SHORT $LN3@xts_gf_mul

; 278  :   {
; 279  :     a_r[i] = reverse_bits( a[i] );

  0003d	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00042	48 8b 4c 24 70	 mov	 rcx, QWORD PTR a$[rsp]
  00047	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_reverse_bits
  00051	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00056	88 44 0c 38	 mov	 BYTE PTR a_r$[rsp+rcx], al

; 280  :     b_r[i] = reverse_bits( b[i] );

  0005a	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0005f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  00064	0f b6 0c 01	 movzx	 ecx, BYTE PTR [rcx+rax]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_reverse_bits
  0006e	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  00073	88 44 0c 28	 mov	 BYTE PTR b_r$[rsp+rcx], al

; 281  :   }

  00077	eb b3		 jmp	 SHORT $LN2@xts_gf_mul
$LN3@xts_gf_mul:

; 282  : 
; 283  :   gcm_gf_mult( a_r, b_r, c_r );

  00079	4c 8d 44 24 48	 lea	 r8, QWORD PTR c_r$[rsp]
  0007e	48 8d 54 24 28	 lea	 rdx, QWORD PTR b_r$[rsp]
  00083	48 8d 4c 24 38	 lea	 rcx, QWORD PTR a_r$[rsp]
  00088	e8 00 00 00 00	 call	 gcm_gf_mult

; 284  : 
; 285  :   for (i=0; i <= 15; i++)

  0008d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00095	eb 0a		 jmp	 SHORT $LN7@xts_gf_mul
$LN5@xts_gf_mul:
  00097	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN7@xts_gf_mul:
  000a1	83 7c 24 20 0f	 cmp	 DWORD PTR i$[rsp], 15
  000a6	7f 22		 jg	 SHORT $LN6@xts_gf_mul

; 286  :       c[i] = reverse_bits( c_r[i] );

  000a8	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  000ad	0f b6 4c 04 48	 movzx	 ecx, BYTE PTR c_r$[rsp+rax]
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_reverse_bits
  000b8	48 63 4c 24 20	 movsxd	 rcx, DWORD PTR i$[rsp]
  000bd	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR c$[rsp]
  000c5	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  000c8	eb cd		 jmp	 SHORT $LN5@xts_gf_mul
$LN6@xts_gf_mul:

; 287  : }

  000ca	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000cf	48 33 cc	 xor	 rcx, rsp
  000d2	e8 00 00 00 00	 call	 __security_check_cookie
  000d7	48 83 c4 68	 add	 rsp, 104		; 00000068H
  000db	c3		 ret	 0
xts_gf_mult ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
t$ = 0
tt$ = 1
x$ = 4
I$ = 32
xts_mult_x PROC

; 257  : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 258  :   int x;
; 259  :   unsigned char t, tt;
; 260  : 
; 261  :   for (x = t = 0; x < 16; x++) {

  00009	c6 04 24 00	 mov	 BYTE PTR t$[rsp], 0
  0000d	0f b6 04 24	 movzx	 eax, BYTE PTR t$[rsp]
  00011	89 44 24 04	 mov	 DWORD PTR x$[rsp], eax
  00015	eb 0a		 jmp	 SHORT $LN4@xts_mult_x
$LN2@xts_mult_x:
  00017	8b 44 24 04	 mov	 eax, DWORD PTR x$[rsp]
  0001b	ff c0		 inc	 eax
  0001d	89 44 24 04	 mov	 DWORD PTR x$[rsp], eax
$LN4@xts_mult_x:
  00021	83 7c 24 04 10	 cmp	 DWORD PTR x$[rsp], 16
  00026	7d 47		 jge	 SHORT $LN3@xts_mult_x

; 262  :      tt   = I[x] >> 7;

  00028	48 63 44 24 04	 movsxd	 rax, DWORD PTR x$[rsp]
  0002d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR I$[rsp]
  00032	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00036	c1 f8 07	 sar	 eax, 7
  00039	88 44 24 01	 mov	 BYTE PTR tt$[rsp], al

; 263  :      I[x] = ((I[x] << 1) | t) & 0xFF;

  0003d	48 63 44 24 04	 movsxd	 rax, DWORD PTR x$[rsp]
  00042	48 8b 4c 24 20	 mov	 rcx, QWORD PTR I$[rsp]
  00047	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0004b	d1 e0		 shl	 eax, 1
  0004d	0f b6 0c 24	 movzx	 ecx, BYTE PTR t$[rsp]
  00051	0b c1		 or	 eax, ecx
  00053	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00058	48 63 4c 24 04	 movsxd	 rcx, DWORD PTR x$[rsp]
  0005d	48 8b 54 24 20	 mov	 rdx, QWORD PTR I$[rsp]
  00062	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 264  :      t    = tt;

  00065	0f b6 44 24 01	 movzx	 eax, BYTE PTR tt$[rsp]
  0006a	88 04 24	 mov	 BYTE PTR t$[rsp], al

; 265  :   }

  0006d	eb a8		 jmp	 SHORT $LN2@xts_mult_x
$LN3@xts_mult_x:

; 266  :   if (tt) {

  0006f	0f b6 44 24 01	 movzx	 eax, BYTE PTR tt$[rsp]
  00074	85 c0		 test	 eax, eax
  00076	74 28		 je	 SHORT $LN5@xts_mult_x

; 267  :      I[0] ^= 0x87;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	48 6b c0 00	 imul	 rax, rax, 0
  00081	48 8b 4c 24 20	 mov	 rcx, QWORD PTR I$[rsp]
  00086	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0008a	35 87 00 00 00	 xor	 eax, 135		; 00000087H
  0008f	b9 01 00 00 00	 mov	 ecx, 1
  00094	48 6b c9 00	 imul	 rcx, rcx, 0
  00098	48 8b 54 24 20	 mov	 rdx, QWORD PTR I$[rsp]
  0009d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
$LN5@xts_mult_x:

; 268  :   }
; 269  : }

  000a0	48 83 c4 18	 add	 rsp, 24
  000a4	c3		 ret	 0
xts_mult_x ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
y$ = 32
x$ = 33
z$ = 34
V$ = 40
Z$ = 56
__$ArrayPad$ = 72
a$ = 112
b$ = 120
c$ = 128
gcm_gf_mult PROC

; 235  : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 236  :   unsigned char Z[16], V[16];
; 237  :   unsigned char x, y, z;
; 238  : 
; 239  :   zeromem(Z, 16);

  00024	48 8d 44 24 38	 lea	 rax, QWORD PTR Z$[rsp]
  00029	48 8b f8	 mov	 rdi, rax
  0002c	33 c0		 xor	 eax, eax
  0002e	b9 10 00 00 00	 mov	 ecx, 16
  00033	f3 aa		 rep stosb

; 240  :   XMEMCPY(V, a, 16);

  00035	48 8d 44 24 28	 lea	 rax, QWORD PTR V$[rsp]
  0003a	48 8b f8	 mov	 rdi, rax
  0003d	48 8b 74 24 70	 mov	 rsi, QWORD PTR a$[rsp]
  00042	b9 10 00 00 00	 mov	 ecx, 16
  00047	f3 a4		 rep movsb

; 241  :   for (x = 0; x < 128; x++)

  00049	c6 44 24 21 00	 mov	 BYTE PTR x$[rsp], 0
  0004e	eb 0b		 jmp	 SHORT $LN4@gcm_gf_mul
$LN2@gcm_gf_mul:
  00050	0f b6 44 24 21	 movzx	 eax, BYTE PTR x$[rsp]
  00055	fe c0		 inc	 al
  00057	88 44 24 21	 mov	 BYTE PTR x$[rsp], al
$LN4@gcm_gf_mul:
  0005b	0f b6 44 24 21	 movzx	 eax, BYTE PTR x$[rsp]
  00060	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00065	0f 8d bd 00 00
	00		 jge	 $LN3@gcm_gf_mul

; 242  :   {
; 243  :     if(b[x>>3] & mask[x&7])

  0006b	0f b6 44 24 21	 movzx	 eax, BYTE PTR x$[rsp]
  00070	c1 f8 03	 sar	 eax, 3
  00073	48 98		 cdqe
  00075	48 8b 4c 24 78	 mov	 rcx, QWORD PTR b$[rsp]
  0007a	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0007e	0f b6 4c 24 21	 movzx	 ecx, BYTE PTR x$[rsp]
  00083	83 e1 07	 and	 ecx, 7
  00086	48 63 c9	 movsxd	 rcx, ecx
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:mask
  00090	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00094	23 c1		 and	 eax, ecx
  00096	85 c0		 test	 eax, eax
  00098	74 3d		 je	 SHORT $LN8@gcm_gf_mul

; 244  :     {
; 245  :       for(y = 0; y < 16; y++)

  0009a	c6 44 24 20 00	 mov	 BYTE PTR y$[rsp], 0
  0009f	eb 0b		 jmp	 SHORT $LN7@gcm_gf_mul
$LN5@gcm_gf_mul:
  000a1	0f b6 44 24 20	 movzx	 eax, BYTE PTR y$[rsp]
  000a6	fe c0		 inc	 al
  000a8	88 44 24 20	 mov	 BYTE PTR y$[rsp], al
$LN7@gcm_gf_mul:
  000ac	0f b6 44 24 20	 movzx	 eax, BYTE PTR y$[rsp]
  000b1	83 f8 10	 cmp	 eax, 16
  000b4	7d 21		 jge	 SHORT $LN6@gcm_gf_mul

; 246  :         Z[y] ^= V[y];

  000b6	0f b6 44 24 20	 movzx	 eax, BYTE PTR y$[rsp]
  000bb	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR y$[rsp]
  000c0	0f b6 4c 0c 28	 movzx	 ecx, BYTE PTR V$[rsp+rcx]
  000c5	0f b6 44 04 38	 movzx	 eax, BYTE PTR Z$[rsp+rax]
  000ca	33 c1		 xor	 eax, ecx
  000cc	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR y$[rsp]
  000d1	88 44 0c 38	 mov	 BYTE PTR Z$[rsp+rcx], al
  000d5	eb ca		 jmp	 SHORT $LN5@gcm_gf_mul
$LN6@gcm_gf_mul:
$LN8@gcm_gf_mul:

; 247  :     }
; 248  :     z = V[15] & 0x01;

  000d7	b8 01 00 00 00	 mov	 eax, 1
  000dc	48 6b c0 0f	 imul	 rax, rax, 15
  000e0	0f b6 44 04 28	 movzx	 eax, BYTE PTR V$[rsp+rax]
  000e5	83 e0 01	 and	 eax, 1
  000e8	88 44 24 22	 mov	 BYTE PTR z$[rsp], al

; 249  :     gcm_rightshift(V);

  000ec	48 8d 4c 24 28	 lea	 rcx, QWORD PTR V$[rsp]
  000f1	e8 00 00 00 00	 call	 gcm_rightshift

; 250  :     V[0] ^= poly[z];

  000f6	b8 01 00 00 00	 mov	 eax, 1
  000fb	48 6b c0 00	 imul	 rax, rax, 0
  000ff	0f b6 4c 24 22	 movzx	 ecx, BYTE PTR z$[rsp]
  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:poly
  0010b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0010f	0f b6 44 04 28	 movzx	 eax, BYTE PTR V$[rsp+rax]
  00114	33 c1		 xor	 eax, ecx
  00116	b9 01 00 00 00	 mov	 ecx, 1
  0011b	48 6b c9 00	 imul	 rcx, rcx, 0
  0011f	88 44 0c 28	 mov	 BYTE PTR V$[rsp+rcx], al

; 251  :   }

  00123	e9 28 ff ff ff	 jmp	 $LN2@gcm_gf_mul
$LN3@gcm_gf_mul:

; 252  :   XMEMCPY(c, Z, 16);

  00128	48 8d 44 24 38	 lea	 rax, QWORD PTR Z$[rsp]
  0012d	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR c$[rsp]
  00135	48 8b f0	 mov	 rsi, rax
  00138	b9 10 00 00 00	 mov	 ecx, 16
  0013d	f3 a4		 rep movsb

; 253  : }

  0013f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00144	48 33 cc	 xor	 rcx, rsp
  00147	e8 00 00 00 00	 call	 __security_check_cookie
  0014c	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00150	5f		 pop	 rdi
  00151	5e		 pop	 rsi
  00152	c3		 ret	 0
gcm_gf_mult ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
x$ = 0
a$ = 32
gcm_rightshift PROC

; 222  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 223  :   int x;
; 224  : 
; 225  :   for(x = 15; x > 0; x--)

  00009	c7 04 24 0f 00
	00 00		 mov	 DWORD PTR x$[rsp], 15
  00010	eb 08		 jmp	 SHORT $LN4@gcm_rights
$LN2@gcm_rights:
  00012	8b 04 24	 mov	 eax, DWORD PTR x$[rsp]
  00015	ff c8		 dec	 eax
  00017	89 04 24	 mov	 DWORD PTR x$[rsp], eax
$LN4@gcm_rights:
  0001a	83 3c 24 00	 cmp	 DWORD PTR x$[rsp], 0
  0001e	7e 39		 jle	 SHORT $LN3@gcm_rights

; 226  :     a[x] = (a[x] >> 1) | ((a[x-1] << 7) & 0x80);

  00020	48 63 04 24	 movsxd	 rax, DWORD PTR x$[rsp]
  00024	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00029	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0002d	d1 f8		 sar	 eax, 1
  0002f	8b 0c 24	 mov	 ecx, DWORD PTR x$[rsp]
  00032	ff c9		 dec	 ecx
  00034	48 63 c9	 movsxd	 rcx, ecx
  00037	48 8b 54 24 20	 mov	 rdx, QWORD PTR a$[rsp]
  0003c	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00040	c1 e1 07	 shl	 ecx, 7
  00043	81 e1 80 00 00
	00		 and	 ecx, 128		; 00000080H
  00049	0b c1		 or	 eax, ecx
  0004b	48 63 0c 24	 movsxd	 rcx, DWORD PTR x$[rsp]
  0004f	48 8b 54 24 20	 mov	 rdx, QWORD PTR a$[rsp]
  00054	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00057	eb b9		 jmp	 SHORT $LN2@gcm_rights
$LN3@gcm_rights:

; 227  :   a[0] >>= 1;

  00059	b8 01 00 00 00	 mov	 eax, 1
  0005e	48 6b c0 00	 imul	 rax, rax, 0
  00062	48 8b 4c 24 20	 mov	 rcx, QWORD PTR a$[rsp]
  00067	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0006b	d0 e8		 shr	 al, 1
  0006d	b9 01 00 00 00	 mov	 ecx, 1
  00072	48 6b c9 00	 imul	 rcx, rcx, 0
  00076	48 8b 54 24 20	 mov	 rdx, QWORD PTR a$[rsp]
  0007b	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 228  : }

  0007e	48 83 c4 18	 add	 rsp, 24
  00082	c3		 ret	 0
gcm_rightshift ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
p$ = 48
n$ = 56
crypto_secure0 PROC

; 185  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 186  : #if defined( _MSVC_ )
; 187  :     SecureZeroMemory( p, n );

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR n$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR p$[rsp]
  00018	e8 00 00 00 00	 call	 RtlSecureZeroMemory

; 188  : #else // (portable C solution for non-buggy compilers)
; 189  :     volatile unsigned char* v = (volatile unsigned char*) p;
; 190  :     while( n-- ) *v++ = 0;
; 191  : #endif
; 192  : }

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
crypto_secure0 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
value$ = 48
crypto_cswap64 PROC

; 181  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 182  :     return CSWAP64( value );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR value$[rsp]
  0000e	e8 00 00 00 00	 call	 _byteswap_uint64

; 183  : }

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
crypto_cswap64 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
value$ = 48
crypto_cswap32 PROC

; 177  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 178  :     return CSWAP32( value );

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR value$[rsp]
  0000c	e8 00 00 00 00	 call	 _byteswap_ulong

; 179  : }

  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
crypto_cswap32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
ptr$ = 48
value$ = 56
crypto_store32 PROC

; 173  : {

$LN3:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 174  :     store_fw( ptr, value );

  0000d	8b 4c 24 38	 mov	 ecx, DWORD PTR value$[rsp]
  00011	e8 00 00 00 00	 call	 _byteswap_ulong
  00016	8b d0		 mov	 edx, eax
  00018	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0001d	e8 00 00 00 00	 call	 store_fw_noswap

; 175  : }

  00022	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00026	c3		 ret	 0
crypto_store32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dyncrypt.c
_TEXT	SEGMENT
ptr$ = 48
crypto_fetch32 PROC

; 169  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 170  :     return fetch_fw( ptr );

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$[rsp]
  0000e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00013	8b c8		 mov	 ecx, eax
  00015	e8 00 00 00 00	 call	 _byteswap_ulong

; 171  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
crypto_fetch32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_validate_operand
_TEXT	SEGMENT
tv79 = 48
tv94 = 52
tv138 = 56
addr$ = 80
arn$ = 88
len$ = 96
acctype$ = 104
regs$ = 112
s370_validate_operand PROC				; COMDAT

; 1376 : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1377 :     /* Translate address of leftmost operand byte */
; 1378 :     MADDR( addr, arn, regs, acctype, regs->psw.pkey );

  00016	48 8b 44 24 70	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	0f b6 40 79	 movzx	 eax, BYTE PTR [rax+121]
  0001f	88 44 24 28	 mov	 BYTE PTR [rsp+40], al
  00023	8b 44 24 68	 mov	 eax, DWORD PTR acctype$[rsp]
  00027	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0002b	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  00030	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  00035	ba 01 00 00 00	 mov	 edx, 1
  0003a	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0003e	e8 00 00 00 00	 call	 s370_maddr_l

; 1379 : 
; 1380 :     /* Translate next page if boundary crossed */
; 1381 :     if (CROSSPAGE( addr, len ))

  00043	8b 44 24 50	 mov	 eax, DWORD PTR addr$[rsp]
  00047	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0004c	b9 ff 07 00 00	 mov	 ecx, 2047		; 000007ffH
  00051	2b 4c 24 60	 sub	 ecx, DWORD PTR len$[rsp]
  00055	3b c1		 cmp	 eax, ecx
  00057	7e 0a		 jle	 SHORT $LN11@s370_valid
  00059	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  00061	eb 08		 jmp	 SHORT $LN12@s370_valid
$LN11@s370_valid:
  00063	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN12@s370_valid:
  0006b	83 7c 24 30 00	 cmp	 DWORD PTR tv79[rsp], 0
  00070	74 3e		 je	 SHORT $LN5@s370_valid

; 1382 :     {
; 1383 :         MADDR( (addr + len) & ADDRESS_MAXWRAP( regs ),

  00072	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00076	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  0007a	03 c8		 add	 ecx, eax
  0007c	8b c1		 mov	 eax, ecx
  0007e	25 ff ff ff 00	 and	 eax, 16777215		; 00ffffffH
  00083	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  00088	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  0008c	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00090	8b 4c 24 68	 mov	 ecx, DWORD PTR acctype$[rsp]
  00094	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00098	4c 8b 4c 24 70	 mov	 r9, QWORD PTR regs$[rsp]
  0009d	44 8b 44 24 58	 mov	 r8d, DWORD PTR arn$[rsp]
  000a2	ba 01 00 00 00	 mov	 edx, 1
  000a7	8b c8		 mov	 ecx, eax
  000a9	e8 00 00 00 00	 call	 s370_maddr_l

; 1384 :                arn, regs, acctype, regs->psw.pkey );
; 1385 :     }

  000ae	eb 5b		 jmp	 SHORT $LN6@s370_valid
$LN5@s370_valid:
$LN4@s370_valid:

; 1386 : #if defined( FEATURE_INTERVAL_TIMER )
; 1387 :     else
; 1388 :         ITIMER_SYNC( addr, len, regs );

  000b0	83 7c 24 50 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000b5	73 0a		 jae	 SHORT $LN15@s370_valid
  000b7	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  000bf	eb 08		 jmp	 SHORT $LN16@s370_valid
$LN15@s370_valid:
  000c1	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN16@s370_valid:
  000c9	83 7c 24 34 00	 cmp	 DWORD PTR tv94[rsp], 0
  000ce	74 1b		 je	 SHORT $LN17@s370_valid
  000d0	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  000d4	8b 4c 24 50	 mov	 ecx, DWORD PTR addr$[rsp]
  000d8	03 c8		 add	 ecx, eax
  000da	8b c1		 mov	 eax, ecx
  000dc	83 f8 50	 cmp	 eax, 80			; 00000050H
  000df	72 0a		 jb	 SHORT $LN17@s370_valid
  000e1	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv138[rsp], 1
  000e9	eb 08		 jmp	 SHORT $LN23@s370_valid
$LN17@s370_valid:
  000eb	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN23@s370_valid:
  000f3	83 7c 24 38 00	 cmp	 DWORD PTR tv138[rsp], 0
  000f8	74 0b		 je	 SHORT $LN7@s370_valid
  000fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR regs$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_store_int_timer
$LN7@s370_valid:
  00105	33 c0		 xor	 eax, eax
  00107	85 c0		 test	 eax, eax
  00109	75 a5		 jne	 SHORT $LN4@s370_valid
$LN6@s370_valid:

; 1389 : #endif
; 1390 : }

  0010b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0010f	c3		 ret	 0
s370_validate_operand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vfetchc
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv80 = 56
tv94 = 60
main1$ = 64
main2$ = 72
dest$ = 112
len$ = 120
addr$ = 128
arn$ = 136
regs$ = 144
s370_vfetchc PROC					; COMDAT

; 631  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 632  : BYTE   *main1, *main2;                  /* Main storage addresses    */
; 633  : int     len2;                           /* Length to copy on page    */
; 634  : 
; 635  :     if (NOCROSSPAGE( addr, len ))

  00019	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 4c 24 78	 movzx	 ecx, BYTE PTR len$[rsp]
  0002a	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  0002f	2b d1		 sub	 edx, ecx
  00031	8b ca		 mov	 ecx, edx
  00033	3b c1		 cmp	 eax, ecx
  00035	7f 0a		 jg	 SHORT $LN11@s370_vfetc
  00037	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0003f	eb 08		 jmp	 SHORT $LN12@s370_vfetc
$LN11@s370_vfetc:
  00041	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vfetc:
  00049	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  0004e	0f 84 c7 00 00
	00		 je	 $LN5@s370_vfetc
$LN4@s370_vfetc:

; 636  :     {
; 637  :         ITIMER_SYNC( addr, len, regs );

  00054	83 bc 24 80 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  0005c	73 0a		 jae	 SHORT $LN15@s370_vfetc
  0005e	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00066	eb 08		 jmp	 SHORT $LN16@s370_vfetc
$LN15@s370_vfetc:
  00068	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN16@s370_vfetc:
  00070	83 7c 24 38 00	 cmp	 DWORD PTR tv80[rsp], 0
  00075	74 1f		 je	 SHORT $LN17@s370_vfetc
  00077	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0007c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  00083	03 c8		 add	 ecx, eax
  00085	8b c1		 mov	 eax, ecx
  00087	83 f8 50	 cmp	 eax, 80			; 00000050H
  0008a	72 0a		 jb	 SHORT $LN17@s370_vfetc
  0008c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv94[rsp], 1
  00094	eb 08		 jmp	 SHORT $LN23@s370_vfetc
$LN17@s370_vfetc:
  00096	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN23@s370_vfetc:
  0009e	83 7c 24 3c 00	 cmp	 DWORD PTR tv94[rsp], 0
  000a3	74 0e		 je	 SHORT $LN7@s370_vfetc
  000a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_store_int_timer
$LN7@s370_vfetc:
  000b3	33 c0		 xor	 eax, eax
  000b5	85 c0		 test	 eax, eax
  000b7	75 9b		 jne	 SHORT $LN4@s370_vfetc

; 638  :         main1 = MADDRL( addr, len + 1, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  000b9	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  000be	ff c0		 inc	 eax
  000c0	48 98		 cdqe
  000c2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  000ca	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  000ce	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  000d2	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  000da	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  000e2	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  000ea	48 8b d0	 mov	 rdx, rax
  000ed	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f4	e8 00 00 00 00	 call	 s370_maddr_l
  000f9	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 639  :         memcpy( dest, main1, len + 1 );

  000fe	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  00103	ff c0		 inc	 eax
  00105	48 98		 cdqe
  00107	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  0010c	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  00111	48 8b c8	 mov	 rcx, rax
  00114	f3 a4		 rep movsb

; 640  :     }

  00116	e9 ef 00 00 00	 jmp	 $LN6@s370_vfetc
$LN5@s370_vfetc:

; 641  :     else
; 642  :     {
; 643  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0011b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00122	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00127	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0012c	2b c8		 sub	 ecx, eax
  0012e	8b c1		 mov	 eax, ecx
  00130	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 644  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_READ, regs->psw.pkey );

  00134	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  00139	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00141	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00145	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  00149	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  00151	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00159	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00161	48 8b d0	 mov	 rdx, rax
  00164	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0016b	e8 00 00 00 00	 call	 s370_maddr_l
  00170	48 89 44 24 40	 mov	 QWORD PTR main1$[rsp], rax

; 645  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ), len + 1 - len2,

  00175	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  0017a	ff c0		 inc	 eax
  0017c	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  00180	48 98		 cdqe
  00182	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  00186	8b 94 24 80 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  0018d	03 d1		 add	 edx, ecx
  0018f	8b ca		 mov	 ecx, edx
  00191	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  00197	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0019f	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001a3	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001a7	c7 44 24 20 04
	00 00 00	 mov	 DWORD PTR [rsp+32], 4
  001af	4c 8b 8c 24 90
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001b7	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001bf	48 8b d0	 mov	 rdx, rax
  001c2	e8 00 00 00 00	 call	 s370_maddr_l
  001c7	48 89 44 24 48	 mov	 QWORD PTR main2$[rsp], rax

; 646  :                         arn, regs, ACCTYPE_READ, regs->psw.pkey );
; 647  :         memcpy(        dest,        main1,           len2 );

  001cc	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  001d1	48 8b 7c 24 70	 mov	 rdi, QWORD PTR dest$[rsp]
  001d6	48 8b 74 24 40	 mov	 rsi, QWORD PTR main1$[rsp]
  001db	48 8b c8	 mov	 rcx, rax
  001de	f3 a4		 rep movsb

; 648  :         memcpy( (BYTE*)dest + len2, main2, len + 1 - len2 );

  001e0	0f b6 44 24 78	 movzx	 eax, BYTE PTR len$[rsp]
  001e5	ff c0		 inc	 eax
  001e7	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001eb	48 98		 cdqe
  001ed	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  001f2	48 8b 54 24 70	 mov	 rdx, QWORD PTR dest$[rsp]
  001f7	48 03 d1	 add	 rdx, rcx
  001fa	48 8b ca	 mov	 rcx, rdx
  001fd	48 8b f9	 mov	 rdi, rcx
  00200	48 8b 74 24 48	 mov	 rsi, QWORD PTR main2$[rsp]
  00205	48 8b c8	 mov	 rcx, rax
  00208	f3 a4		 rep movsb
$LN6@s370_vfetc:

; 649  :     }
; 650  : }

  0020a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0020e	5f		 pop	 rdi
  0020f	5e		 pop	 rsi
  00210	c3		 ret	 0
s370_vfetchc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\vstore.h
;	COMDAT s370_vstorec
_TEXT	SEGMENT
len2$ = 48
tv74 = 52
tv131 = 56
tv145 = 60
sk$ = 64
tv81 = 72
main1$ = 80
main2$ = 88
src$ = 128
len$ = 136
addr$ = 144
arn$ = 152
regs$ = 160
s370_vstorec PROC					; COMDAT

; 489  : {

$LN24:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 490  : BYTE   *main1, *main2;                  /* Mainstor addresses        */
; 491  : BYTE   *sk;                             /* Storage key addresses     */
; 492  : int     len2;                           /* Length to end of page     */
; 493  : 
; 494  :     if (NOCROSSPAGE( addr,len ))

  00019	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00020	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  00025	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  0002d	ba ff 07 00 00	 mov	 edx, 2047		; 000007ffH
  00032	2b d1		 sub	 edx, ecx
  00034	8b ca		 mov	 ecx, edx
  00036	3b c1		 cmp	 eax, ecx
  00038	7f 0a		 jg	 SHORT $LN11@s370_vstor
  0003a	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@s370_vstor
$LN11@s370_vstor:
  00044	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN12@s370_vstor:
  0004c	83 7c 24 34 00	 cmp	 DWORD PTR tv74[rsp], 0
  00051	0f 84 d7 00 00
	00		 je	 $LN5@s370_vstor

; 495  :     {
; 496  :         memcpy( MADDRL( addr, len+1, arn, regs, ACCTYPE_WRITE, regs->psw.pkey ),

  00057	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  0005f	ff c0		 inc	 eax
  00061	48 98		 cdqe
  00063	48 89 44 24 48	 mov	 QWORD PTR tv81[rsp], rax
  00068	0f b6 8c 24 88
	00 00 00	 movzx	 ecx, BYTE PTR len$[rsp]
  00070	ff c1		 inc	 ecx
  00072	48 63 c9	 movsxd	 rcx, ecx
  00075	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  0007d	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  00081	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  00085	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  0008d	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  00095	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  0009d	48 8b d1	 mov	 rdx, rcx
  000a0	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000a7	e8 00 00 00 00	 call	 s370_maddr_l
  000ac	48 8b f8	 mov	 rdi, rax
  000af	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  000b7	48 8b 44 24 48	 mov	 rax, QWORD PTR tv81[rsp]
  000bc	48 8b c8	 mov	 rcx, rax
  000bf	f3 a4		 rep movsb
$LN4@s370_vstor:

; 497  :                src, len + 1);
; 498  :         ITIMER_UPDATE( addr, len, regs );

  000c1	83 bc 24 90 00
	00 00 54	 cmp	 DWORD PTR addr$[rsp], 84 ; 00000054H
  000c9	73 0a		 jae	 SHORT $LN15@s370_vstor
  000cb	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv131[rsp], 1
  000d3	eb 08		 jmp	 SHORT $LN16@s370_vstor
$LN15@s370_vstor:
  000d5	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN16@s370_vstor:
  000dd	83 7c 24 38 00	 cmp	 DWORD PTR tv131[rsp], 0
  000e2	74 22		 je	 SHORT $LN17@s370_vstor
  000e4	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  000ec	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  000f3	03 c8		 add	 ecx, eax
  000f5	8b c1		 mov	 eax, ecx
  000f7	83 f8 50	 cmp	 eax, 80			; 00000050H
  000fa	72 0a		 jb	 SHORT $LN17@s370_vstor
  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00104	eb 08		 jmp	 SHORT $LN23@s370_vstor
$LN17@s370_vstor:
  00106	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN23@s370_vstor:
  0010e	83 7c 24 3c 00	 cmp	 DWORD PTR tv145[rsp], 0
  00113	74 0e		 je	 SHORT $LN7@s370_vstor
  00115	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  0011d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_fetch_int_timer
$LN7@s370_vstor:
  00123	33 c0		 xor	 eax, eax
  00125	85 c0		 test	 eax, eax
  00127	75 98		 jne	 SHORT $LN4@s370_vstor

; 499  :     }

  00129	e9 21 01 00 00	 jmp	 $LN6@s370_vstor
$LN5@s370_vstor:

; 500  :     else
; 501  :     {
; 502  :         len2 = PAGEFRAME_PAGESIZE - (addr & PAGEFRAME_BYTEMASK);

  0012e	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR addr$[rsp]
  00135	25 ff 07 00 00	 and	 eax, 2047		; 000007ffH
  0013a	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  0013f	2b c8		 sub	 ecx, eax
  00141	8b c1		 mov	 eax, ecx
  00143	89 44 24 30	 mov	 DWORD PTR len2$[rsp], eax

; 503  :         main1 = MADDRL( addr, len2, arn, regs, ACCTYPE_WRITE_SKP,

  00147	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0014c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00154	0f b6 49 79	 movzx	 ecx, BYTE PTR [rcx+121]
  00158	88 4c 24 28	 mov	 BYTE PTR [rsp+40], cl
  0015c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00164	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  0016c	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  00174	48 8b d0	 mov	 rdx, rax
  00177	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	e8 00 00 00 00	 call	 s370_maddr_l
  00183	48 89 44 24 50	 mov	 QWORD PTR main1$[rsp], rax

; 504  :                         regs->psw.pkey );
; 505  :         sk = regs->dat.storkey;

  00188	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00190	48 8b 80 28 08
	00 00		 mov	 rax, QWORD PTR [rax+2088]
  00197	48 89 44 24 40	 mov	 QWORD PTR sk$[rsp], rax

; 506  :         main2 = MADDRL( (addr + len2) & ADDRESS_MAXWRAP( regs ),

  0019c	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  001a4	ff c0		 inc	 eax
  001a6	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  001aa	48 98		 cdqe
  001ac	8b 4c 24 30	 mov	 ecx, DWORD PTR len2$[rsp]
  001b0	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR addr$[rsp]
  001b7	03 d1		 add	 edx, ecx
  001b9	8b ca		 mov	 ecx, edx
  001bb	81 e1 ff ff ff
	00		 and	 ecx, 16777215		; 00ffffffH
  001c1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  001c9	0f b6 52 79	 movzx	 edx, BYTE PTR [rdx+121]
  001cd	88 54 24 28	 mov	 BYTE PTR [rsp+40], dl
  001d1	c7 44 24 20 02
	00 00 00	 mov	 DWORD PTR [rsp+32], 2
  001d9	4c 8b 8c 24 a0
	00 00 00	 mov	 r9, QWORD PTR regs$[rsp]
  001e1	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR arn$[rsp]
  001e9	48 8b d0	 mov	 rdx, rax
  001ec	e8 00 00 00 00	 call	 s370_maddr_l
  001f1	48 89 44 24 58	 mov	 QWORD PTR main2$[rsp], rax

; 507  :                         len+1-len2, arn,
; 508  :                         regs, ACCTYPE_WRITE, regs->psw.pkey );
; 509  :         *sk |= (STORKEY_REF | STORKEY_CHANGE);

  001f6	48 8b 44 24 40	 mov	 rax, QWORD PTR sk$[rsp]
  001fb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fe	83 c8 06	 or	 eax, 6
  00201	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sk$[rsp]
  00206	88 01		 mov	 BYTE PTR [rcx], al

; 510  :         memcpy( main1, src, len2 );

  00208	48 63 44 24 30	 movsxd	 rax, DWORD PTR len2$[rsp]
  0020d	48 8b 7c 24 50	 mov	 rdi, QWORD PTR main1$[rsp]
  00212	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR src$[rsp]
  0021a	48 8b c8	 mov	 rcx, rax
  0021d	f3 a4		 rep movsb

; 511  :         memcpy( main2, (BYTE*)src + len2, len + 1 - len2 );

  0021f	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR len$[rsp]
  00227	ff c0		 inc	 eax
  00229	2b 44 24 30	 sub	 eax, DWORD PTR len2$[rsp]
  0022d	48 98		 cdqe
  0022f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR len2$[rsp]
  00234	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR src$[rsp]
  0023c	48 03 d1	 add	 rdx, rcx
  0023f	48 8b ca	 mov	 rcx, rdx
  00242	48 8b 7c 24 58	 mov	 rdi, QWORD PTR main2$[rsp]
  00247	48 8b f1	 mov	 rsi, rcx
  0024a	48 8b c8	 mov	 rcx, rax
  0024d	f3 a4		 rep movsb
$LN6@s370_vstor:

; 512  :     }
; 513  : }

  0024f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00253	5f		 pop	 rdi
  00254	5e		 pop	 rsi
  00255	c3		 ret	 0
s370_vstorec ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dat.h
;	COMDAT s370_maddr_l
_TEXT	SEGMENT
tlbix$ = 48
aea_crn$ = 52
tv70 = 56
maddr$ = 64
addr$ = 96
len$ = 104
arn$ = 112
regs$ = 120
acctype$ = 128
akey$ = 136
s370_maddr_l PROC					; COMDAT

; 307  : {

$LN14:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 308  :     /* Note: ALL of the below conditions must be true for a TLB hit
; 309  :        to occur.  If ANY of them are false, then it's a TLB miss,
; 310  :        requiring us to then perform a full DAT address translation.
; 311  : 
; 312  :        Note too that on the grand scheme of things the order/sequence
; 313  :        of the below tests (if statements) is completely unimportant
; 314  :        since ALL conditions must be checked anyway in order for a hit
; 315  :        to occur, and it doesn't matter that a miss tests a few extra
; 316  :        conditions since it's going to do a full translation anyway!
; 317  :        (which is many, many instructions)
; 318  :     */
; 319  : 
; 320  :     int  aea_crn  = (arn >= USE_ARMODE) ? 0 : regs->AEA_AR( arn );

  00017	83 7c 24 70 10	 cmp	 DWORD PTR arn$[rsp], 16
  0001c	7c 0a		 jl	 SHORT $LN12@s370_maddr
  0001e	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00026	eb 19		 jmp	 SHORT $LN13@s370_maddr
$LN12@s370_maddr:
  00028	8b 44 24 70	 mov	 eax, DWORD PTR arn$[rsp]
  0002c	83 c0 05	 add	 eax, 5
  0002f	48 98		 cdqe
  00031	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00036	8b 84 81 94 0c
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+3220]
  0003d	89 44 24 38	 mov	 DWORD PTR tv70[rsp], eax
$LN13@s370_maddr:
  00041	8b 44 24 38	 mov	 eax, DWORD PTR tv70[rsp]
  00045	89 44 24 34	 mov	 DWORD PTR aea_crn$[rsp], eax

; 321  :     U16  tlbix    = TLBIX( addr );

  00049	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  0004d	c1 e8 0b	 shr	 eax, 11
  00050	25 ff 03 00 00	 and	 eax, 1023		; 000003ffH
  00055	66 89 44 24 30	 mov	 WORD PTR tlbix$[rsp], ax

; 322  :     BYTE *maddr   = NULL;

  0005a	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR maddr$[rsp], 0

; 323  : 
; 324  :     /* Non-zero AEA Control Register number? */
; 325  :     if (aea_crn)

  00063	83 7c 24 34 00	 cmp	 DWORD PTR aea_crn$[rsp], 0
  00068	0f 84 25 01 00
	00		 je	 $LN2@s370_maddr

; 326  :     {
; 327  :         /* Same Addess Space Designator as before? */
; 328  :         /* Or if not, is address in a common segment? */
; 329  :         if (0
; 330  :             || (regs->CR( aea_crn ) == regs->tlb.TLB_ASD( tlbix ))
; 331  :             || (regs->AEA_COMMON( aea_crn ) & regs->tlb.common[ tlbix ])

  0006e	33 c0		 xor	 eax, eax
  00070	85 c0		 test	 eax, eax
  00072	75 59		 jne	 SHORT $LN4@s370_maddr
  00074	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  00078	ff c0		 inc	 eax
  0007a	48 98		 cdqe
  0007c	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  00081	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00086	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  0008b	41 8b 8c c8 60
	b0 00 00	 mov	 ecx, DWORD PTR [r8+rcx*8+45152]
  00093	39 8c c2 00 06
	00 00		 cmp	 DWORD PTR [rdx+rax*8+1536], ecx
  0009a	74 31		 je	 SHORT $LN4@s370_maddr
  0009c	8b 44 24 34	 mov	 eax, DWORD PTR aea_crn$[rsp]
  000a0	ff c0		 inc	 eax
  000a2	48 98		 cdqe
  000a4	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  000a9	0f b6 84 01 e8
	0c 00 00	 movzx	 eax, BYTE PTR [rcx+rax+3304]
  000b1	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000b6	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000bb	0f b6 8c 0a 60
	54 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+87136]
  000c3	23 c1		 and	 eax, ecx
  000c5	85 c0		 test	 eax, eax
  000c7	0f 84 c6 00 00
	00		 je	 $LN3@s370_maddr
$LN4@s370_maddr:

; 332  :         )
; 333  :         {
; 334  :             /* Storage Key zero? */
; 335  :             /* Or if not, same Storage Key as before? */
; 336  :             if (0
; 337  :                 || akey == 0
; 338  :                 || akey == regs->tlb.skey[ tlbix ]

  000cd	33 c0		 xor	 eax, eax
  000cf	85 c0		 test	 eax, eax
  000d1	75 2e		 jne	 SHORT $LN6@s370_maddr
  000d3	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000db	85 c0		 test	 eax, eax
  000dd	74 22		 je	 SHORT $LN6@s370_maddr
  000df	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  000e7	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  000ec	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  000f1	0f b6 8c 0a 60
	50 01 00	 movzx	 ecx, BYTE PTR [rdx+rcx+86112]
  000f9	3b c1		 cmp	 eax, ecx
  000fb	0f 85 92 00 00
	00		 jne	 $LN5@s370_maddr
$LN6@s370_maddr:

; 339  :             )
; 340  :             {
; 341  :                 /* Does the page address match the one in the TLB? */
; 342  :                 /* (does a TLB entry exist for this page address?) */
; 343  :                 if (
; 344  :                     ((addr & TLBID_PAGEMASK) | regs->tlbID)
; 345  :                     ==

  00101	8b 44 24 60	 mov	 eax, DWORD PTR addr$[rsp]
  00105	25 00 00 e0 00	 and	 eax, 14680064		; 00e00000H
  0010a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  0010f	0b 81 58 b0 00
	00		 or	 eax, DWORD PTR [rcx+45144]
  00115	0f b7 4c 24 30	 movzx	 ecx, WORD PTR tlbix$[rsp]
  0011a	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  0011f	3b 84 ca 60 d0
	00 00		 cmp	 eax, DWORD PTR [rdx+rcx*8+53344]
  00126	75 6b		 jne	 SHORT $LN7@s370_maddr

; 346  :                     regs->tlb.TLB_VADDR( tlbix )
; 347  :                 )
; 348  :                 {
; 349  :                     /* Is storage being accessed same way as before? */
; 350  :                     if (acctype & regs->tlb.acc[ tlbix ])

  00128	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0012d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00132	0f b6 84 01 60
	5c 01 00	 movzx	 eax, BYTE PTR [rcx+rax+89184]
  0013a	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR acctype$[rsp]
  00141	23 c8		 and	 ecx, eax
  00143	8b c1		 mov	 eax, ecx
  00145	85 c0		 test	 eax, eax
  00147	74 4a		 je	 SHORT $LN8@s370_maddr

; 351  :                     {
; 352  :                         /*------------------------------------------*/
; 353  :                         /* TLB hit: use previously translated value */
; 354  :                         /*------------------------------------------*/
; 355  : 
; 356  :                         if (acctype & ACC_CHECK)

  00149	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR acctype$[rsp]
  00150	83 e0 01	 and	 eax, 1
  00153	85 c0		 test	 eax, eax
  00155	74 1e		 je	 SHORT $LN9@s370_maddr

; 357  :                             regs->dat.storkey = regs->tlb.storkey[ tlbix ];

  00157	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0015c	48 8b 4c 24 78	 mov	 rcx, QWORD PTR regs$[rsp]
  00161	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00166	48 8b 84 c2 60
	30 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+77920]
  0016e	48 89 81 28 08
	00 00		 mov	 QWORD PTR [rcx+2088], rax
$LN9@s370_maddr:

; 358  : 
; 359  :                         maddr = MAINADDR( regs->tlb.main[tlbix], addr );

  00175	0f b7 44 24 30	 movzx	 eax, WORD PTR tlbix$[rsp]
  0017a	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  0017e	48 8b 54 24 78	 mov	 rdx, QWORD PTR regs$[rsp]
  00183	48 8b 84 c2 60
	10 01 00	 mov	 rax, QWORD PTR [rdx+rax*8+69728]
  0018b	48 33 c1	 xor	 rax, rcx
  0018e	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN8@s370_maddr:
$LN7@s370_maddr:
$LN5@s370_maddr:
$LN3@s370_maddr:
$LN2@s370_maddr:

; 360  :                     }
; 361  :                 }
; 362  :             }
; 363  :         }
; 364  :     }
; 365  : 
; 366  :     /*---------------------------------------*/
; 367  :     /* TLB miss: do full address translation */
; 368  :     /*---------------------------------------*/
; 369  :     if (!maddr)

  00193	48 83 7c 24 40
	00		 cmp	 QWORD PTR maddr$[rsp], 0
  00199	75 36		 jne	 SHORT $LN10@s370_maddr

; 370  :         maddr = ARCH_DEP( logical_to_main_l )( addr, arn, regs, acctype, akey, len );

  0019b	48 8b 44 24 68	 mov	 rax, QWORD PTR len$[rsp]
  001a0	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001a5	0f b6 84 24 88
	00 00 00	 movzx	 eax, BYTE PTR akey$[rsp]
  001ad	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  001b1	44 8b 8c 24 80
	00 00 00	 mov	 r9d, DWORD PTR acctype$[rsp]
  001b9	4c 8b 44 24 78	 mov	 r8, QWORD PTR regs$[rsp]
  001be	8b 54 24 70	 mov	 edx, DWORD PTR arn$[rsp]
  001c2	8b 4c 24 60	 mov	 ecx, DWORD PTR addr$[rsp]
  001c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_s370_logical_to_main_l
  001cc	48 89 44 24 40	 mov	 QWORD PTR maddr$[rsp], rax
$LN10@s370_maddr:

; 371  : 
; 372  : #if defined( FEATURE_073_TRANSACT_EXEC_FACILITY )
; 373  :     if (FACILITY_ENABLED( 073_TRANSACT_EXEC, regs ))
; 374  :     {
; 375  :         /* SA22-7832-12 Principles of Operation, page 5-99:
; 376  : 
; 377  :              "Storage accesses for instruction and DAT- and ART-
; 378  :               table fetches follow the non-transactional rules."
; 379  :         */
; 380  :         if (0
; 381  :             || !regs
; 382  :             || !regs->txf_tnd
; 383  :             || arn == USE_INST_SPACE    /* Instruction fetching */
; 384  :             || arn == USE_REAL_ADDR     /* Address translation  */
; 385  :         )
; 386  :             return maddr;
; 387  : 
; 388  :         /* Quick exit if NTSTG call */
; 389  :         if (regs->txf_NTSTG)
; 390  :         {
; 391  :             regs->txf_NTSTG = false;
; 392  :             return maddr;
; 393  :         }
; 394  : 
; 395  :         /* Translate to alternate TXF address */
; 396  :         maddr = TXF_MADDRL( addr, len, arn, regs, acctype, maddr );
; 397  :     }
; 398  : #endif
; 399  : 
; 400  :     return maddr;

  001d1	48 8b 44 24 40	 mov	 rax, QWORD PTR maddr$[rsp]

; 401  : }

  001d6	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001da	c3		 ret	 0
s370_maddr_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\um\winnt.h
;	COMDAT RtlSecureZeroMemory
_TEXT	SEGMENT
vptr$ = 0
ptr$ = 32
cnt$ = 40
RtlSecureZeroMemory PROC				; COMDAT

; 21417: {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 10	 sub	 rsp, 16

; 21418:     volatile char *vptr = (volatile char *)ptr;

  0000f	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  00014	48 89 04 24	 mov	 QWORD PTR vptr$[rsp], rax

; 21419: 
; 21420: #if defined(_M_AMD64) && !defined(_M_ARM64EC)
; 21421: 
; 21422:     __stosb((PBYTE )((DWORD64)vptr), 0, cnt);

  00018	48 8b 3c 24	 mov	 rdi, QWORD PTR vptr$[rsp]
  0001c	33 c0		 xor	 eax, eax
  0001e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR cnt$[rsp]
  00023	f3 aa		 rep stosb

; 21423: 
; 21424: #else
; 21425: 
; 21426:     while (cnt) {
; 21427: 
; 21428: #if !defined(_M_CEE) && (defined(_M_ARM) || defined(_M_ARM64) || defined(_M_ARM64EC))
; 21429: 
; 21430:         __iso_volatile_store8(vptr, 0);
; 21431: 
; 21432: #else
; 21433: 
; 21434:         *vptr = 0;
; 21435: 
; 21436: #endif
; 21437: 
; 21438:         vptr++;
; 21439:         cnt--;
; 21440:     }
; 21441: 
; 21442: #endif // _M_AMD64 && !defined(_M_ARM64EC)
; 21443: 
; 21444:     return ptr;

  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]

; 21445: }

  0002a	48 83 c4 10	 add	 rsp, 16
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
RtlSecureZeroMemory ENDP
_TEXT	ENDS
END
