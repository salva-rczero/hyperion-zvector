; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
zfcp_immed_commands DB 00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
zfcp_device_ned DB 0d0H
	DB	01H
	DB	01H
	DB	00H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f4H
	DB	0f2H
	DB	0f9H
	DB	0f0H
	DB	0f0H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	00H
	DB	00H
zfcp_ctlunit_ned DB 0d0H
	DB	02H
	DB	01H
	DB	01H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f4H
	DB	0f1H
	DB	0f9H
	DB	0f0H
	DB	0f0H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f2H
	DB	00H
	DB	00H
zfcp_token_ned DB 0f0H
	DB	00H
	DB	01H
	DB	01H
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f4H
	DB	0f0H
	DB	0f9H
	DB	0f0H
	DB	0f0H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f3H
	DB	00H
	DB	00H
zfcp_general_neq DB 080H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
zfcp_nd	DB	00H
	DB	00H
	DB	06H
	DB	0ffH
	DB	0f0H
	DB	0f0H
	DB	0f1H
	DB	0f7H
	DB	0f4H
	DB	0f1H
	DB	0f9H
	DB	0f0H
	DB	0f0H
	DB	0c8H
	DB	0d9H
	DB	0c3H
	DB	0e9H
	DB	0e9H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f0H
	DB	0f2H
	DB	00H
	DB	00H
zfcp_nq	DB	020H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
sense_id_bytes DB 0ffH
	DB	017H
	DB	031H
	DB	03H
	DB	017H
	DB	032H
	DB	03H
	DB	00H
	DB	040H
	DB	0faH
	DB	00H
	DB	080H
	DB	041H
	DB	081H
	DB	00H
	DB	04H
	DB	042H
	DB	082H
	DB	00H
	DB	040H
	DB	043H
	DB	01bH
	DB	010H
	DB	00H
	DB	044H
	DB	01fH
	DB	00H
	DB	00H
?len@?BD@??zfcp_execute_ccw@@9@9 DD 01H			; `zfcp_execute_ccw'::`19'::len
?opcode@?BD@??zfcp_execute_ccw@@9@9 DB 03H		; `zfcp_execute_ccw'::`19'::opcode
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_dev_storekey_ptr
PUBLIC	_get_dev_storekey1_ptr
PUBLIC	_get_dev_storekey2_ptr
PUBLIC	s370__get_dev_storage_key
PUBLIC	s370__or_dev_storage_key
PUBLIC	s370_get_dev_4K_storage_key
PUBLIC	s370_or_dev_4K_storage_key
PUBLIC	STORCHK
PUBLIC	hdl_check_depends_ep
PUBLIC	hdl_resolve_symbols_ep
PUBLIC	hdl_define_devtypes_ep
EXTRN	__report_rangecheckfailure:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_closesocket:PROC
EXTRN	__imp_recv:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp_hthread_initialize_lock:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_destroy_lock:PROC
EXTRN	__imp_hthread_initialize_condition:PROC
EXTRN	__imp_hthread_destroy_condition:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_socketpair:PROC
EXTRN	__imp_socket_set_blocking_mode:PROC
EXTRN	__imp_w32_FD_SET:PROC
EXTRN	__imp_w32_FD_ISSET:PROC
EXTRN	__imp_w32_select:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	__imp_group_device:PROC
EXTRN	__imp_FormatSID:PROC
EXTRN	__imp_FormatRCD:PROC
EXTRN	__imp_FormatRNI:PROC
EXTRN	__imp_Queue_IO_Interrupt:PROC
EXTRN	__imp_Update_IC_IOPENDING:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
configuration_data DB 080H DUP (?)
node_data DB	040H DUP (?)
$SG170201 DB	01H DUP (?)
	ALIGN	4

$SG170202 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_dev_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$_get_dev_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__get_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+140
	DD	imagerel $unwind$s370__get_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_dev_storage_key DD imagerel $LN8
	DD	imagerel $LN8+192
	DD	imagerel $unwind$s370__or_dev_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_get_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$s370_get_dev_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_dev_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+54
	DD	imagerel $unwind$s370_or_dev_4K_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$STORCHK DD imagerel $LN11
	DD	imagerel $LN11+330
	DD	imagerel $unwind$STORCHK
$pdata$set_alsi DD imagerel set_alsi
	DD	imagerel set_alsi+173
	DD	imagerel $unwind$set_alsi
$pdata$set_dsci DD imagerel set_dsci
	DD	imagerel set_dsci+251
	DD	imagerel $unwind$set_dsci
$pdata$raise_adapter_interrupt DD imagerel raise_adapter_interrupt
	DD	imagerel raise_adapter_interrupt+281
	DD	imagerel $unwind$raise_adapter_interrupt
$pdata$process_input_queue DD imagerel process_input_queue
	DD	imagerel process_input_queue+1906
	DD	imagerel $unwind$process_input_queue
$pdata$process_output_queue DD imagerel process_output_queue
	DD	imagerel process_output_queue+1594
	DD	imagerel $unwind$process_output_queue
$pdata$zfcp_halt_or_clear DD imagerel zfcp_halt_or_clear
	DD	imagerel zfcp_halt_or_clear+273
	DD	imagerel $unwind$zfcp_halt_or_clear
$pdata$zfcp_read_configuration_data DD imagerel zfcp_read_configuration_data
	DD	imagerel zfcp_read_configuration_data+484
	DD	imagerel $unwind$zfcp_read_configuration_data
$pdata$zfcp_init_handler DD imagerel zfcp_init_handler
	DD	imagerel zfcp_init_handler+1743
	DD	imagerel $unwind$zfcp_init_handler
$pdata$zfcp_query_device DD imagerel zfcp_query_device
	DD	imagerel zfcp_query_device+452
	DD	imagerel $unwind$zfcp_query_device
$pdata$zfcp_close_device DD imagerel zfcp_close_device
	DD	imagerel zfcp_close_device+350
	DD	imagerel $unwind$zfcp_close_device
$pdata$zfcp_set_sci DD imagerel zfcp_set_sci
	DD	imagerel zfcp_set_sci+391
	DD	imagerel $unwind$zfcp_set_sci
$pdata$zfcp_ssqd_desc DD imagerel zfcp_ssqd_desc
	DD	imagerel zfcp_ssqd_desc+372
	DD	imagerel $unwind$zfcp_ssqd_desc
$pdata$zfcp_execute_ccw DD imagerel zfcp_execute_ccw
	DD	imagerel zfcp_execute_ccw+5994
	DD	imagerel $unwind$zfcp_execute_ccw
$pdata$zfcp_initiate_input DD imagerel zfcp_initiate_input
	DD	imagerel zfcp_initiate_input+596
	DD	imagerel $unwind$zfcp_initiate_input
$pdata$zfcp_initiate_output DD imagerel zfcp_initiate_output
	DD	imagerel zfcp_initiate_output+545
	DD	imagerel $unwind$zfcp_initiate_output
$pdata$zfcp_do_sync DD imagerel zfcp_do_sync
	DD	imagerel zfcp_do_sync+151
	DD	imagerel $unwind$zfcp_do_sync
$pdata$zfcp_initiate_output_mult DD imagerel zfcp_initiate_output_mult
	DD	imagerel zfcp_initiate_output_mult+130
	DD	imagerel $unwind$zfcp_initiate_output_mult
$pdata$hdl_check_depends_ep DD imagerel $LN15
	DD	imagerel $LN15+433
	DD	imagerel $unwind$hdl_check_depends_ep
$pdata$hdl_define_devtypes_ep DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$hdl_define_devtypes_ep
pdata	ENDS
_DATA	SEGMENT
$SG169846 DB	'zfcp.c:189', 00H
	ORG $+5
$SG169847 DB	'zfcp.c:192', 00H
	ORG $+1
$SG170068 DB	'*', 00H
	ORG $+2
$SG169857 DB	'zfcp.c:207', 00H
	ORG $+1
$SG170155 DB	'lun', 00H
$SG169858 DB	'zfcp.c:212', 00H
	ORG $+1
$SG170193 DB	'FCP', 00H
$SG169877 DB	'Adapter Interrupt dev(%4.4x)', 0aH, 00H
	ORG $+2
$SG169879 DB	'Adapter Interrupt dev(%4.4x)', 0aH, 00H
	ORG $+2
$SG169880 DB	'zfcp.c:225', 00H
	ORG $+1
$SG170199 DB	'.', 00H
	ORG $+2
$SG169881 DB	'zfcp.c:229', 00H
	ORG $+1
$SG170429 DB	'SID', 00H
$SG169882 DB	'zfcp.c:230', 00H
	ORG $+1
$SG170430 DB	'I', 00H
	ORG $+2
$SG169883 DB	'zfcp.c:233', 00H
	ORG $+1
$SG170437 DB	'RCD', 00H
$SG169884 DB	'zfcp.c:235', 00H
	ORG $+1
$SG170438 DB	'I', 00H
	ORG $+2
$SG169945 DB	'Input Qpos(%d) Bpos(%d)', 0aH, 00H
	ORG $+3
$SG170070 DB	'zfcp.c', 00H
	ORG $+1
$SG170454 DB	'RNI', 00H
$SG169947 DB	'Input Qpos(%d) Bpos(%d)', 0aH, 00H
	ORG $+3
$SG170074 DB	'zfcp.c', 00H
	ORG $+1
$SG170455 DB	'I', 00H
	ORG $+2
$SG169953 DB	'Input Queue(%d) Buffer(%d)', 0aH, 00H
$SG170525 DB	'*', 00H
	ORG $+2
$SG169955 DB	'Input Queue(%d) Buffer(%d)', 0aH, 00H
$SG170570 DB	'*', 00H
	ORG $+2
$SG169958 DB	'STORCHK ERROR sa(%16.16llx), key(%2.2x)', 0aH, 00H
	ORG $+3
$SG170130 DB	'zfcp.c', 00H
	ORG $+5
$SG169960 DB	'STORCHK ERROR sa(%16.16llx), key(%2.2x)', 0aH, 00H
	ORG $+7
$SG169964 DB	'STORCHK ERROR la(%16.16llx), len(%d), key(%2.2x)', 0aH, 00H
	ORG $+6
$SG169966 DB	'STORCHK ERROR la(%16.16llx), len(%d), key(%2.2x)', 0aH, 00H
	ORG $+6
$SG170032 DB	'Output Queue(%d) Buffer(%d)', 0aH, 00H
	ORG $+3
$SG170034 DB	'Output Queue(%d) Buffer(%d)', 0aH, 00H
	ORG $+3
$SG170037 DB	'STORCHK ERROR sa(%16.16llx), key(%2.2x)', 0aH, 00H
	ORG $+7
$SG170039 DB	'STORCHK ERROR sa(%16.16llx), key(%2.2x)', 0aH, 00H
	ORG $+7
$SG170043 DB	'STORCHK ERROR la(%16.16llx), len(%d), key(%2.2x)', 0aH, 00H
	ORG $+6
$SG170045 DB	'STORCHK ERROR la(%16.16llx), len(%d), key(%2.2x)', 0aH, 00H
	ORG $+6
$SG170069 DB	'zfcp_halt_or_clear', 00H
	ORG $+5
$SG170071 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170073 DB	'zfcp_halt_or_clear', 00H
	ORG $+5
$SG170075 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170078 DB	'zfcp.c:484', 00H
	ORG $+5
$SG170128 DB	'ZFCP Experimental Driver - Incomplete - Work In Progress'
	DB	0aH, 00H
	ORG $+6
$SG170129 DB	'zfcp_init_handler', 00H
	ORG $+6
$SG170137 DB	'zfcp.c:556', 00H
	ORG $+5
$SG170138 DB	'zfcp.c:557', 00H
	ORG $+5
$SG170139 DB	'&grp->qlock', 00H
	ORG $+4
$SG170141 DB	'zfcp_init_handler', 00H
	ORG $+2
$SG170142 DB	'zfcp.c', 00H
	ORG $+5
$SG170143 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170145 DB	'zfcp_init_handler', 00H
	ORG $+2
$SG170146 DB	'zfcp.c', 00H
	ORG $+1
$SG170159 DB	'br_lba', 00H
	ORG $+5
$SG170147 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170151 DB	'portname', 00H
	ORG $+3
$SG170163 DB	'chpid', 00H
	ORG $+2
$SG170167 DB	'%x%c', 00H
	ORG $+7
$SG170168 DB	'ZFCP: Invalid channel path id %s for device %4.4X', 0aH, 00H
	ORG $+5
$SG170169 DB	'zfcp_init_handler', 00H
	ORG $+2
$SG170170 DB	'zfcp.c', 00H
	ORG $+1
$SG170173 DB	'debug', 00H
	ORG $+6
$SG170176 DB	'nodebug', 00H
$SG170177 DB	'ZFCP: Invalid option %s for device %4.4X', 0aH, 00H
	ORG $+6
$SG170178 DB	'zfcp_init_handler', 00H
	ORG $+2
$SG170179 DB	'zfcp.c', 00H
	ORG $+1
$SG170200 DB	'QDIO', 00H
	ORG $+7
$SG170203 DB	'*Incomplete ', 00H
	ORG $+3
$SG170204 DB	'%s%s', 00H
	ORG $+3
$SG170224 DB	'zfcp.c:686', 00H
	ORG $+5
$SG170411 DB	'zfcp.c:846', 00H
	ORG $+5
$SG170415 DB	'zfcp.c:857', 00H
	ORG $+5
$SG170417 DB	'zfcp.c:866', 00H
	ORG $+5
$SG170431 DB	'HHC03995%s %1d:%04X %s: %s:', 0aH, '%s', 0aH, 00H
$SG170432 DB	'zfcp_execute_ccw', 00H
	ORG $+3
$SG170433 DB	'zfcp.c', 00H
	ORG $+5
$SG170439 DB	'HHC03995%s %1d:%04X %s: %s:', 0aH, '%s', 0aH, 00H
$SG170440 DB	'zfcp_execute_ccw', 00H
	ORG $+3
$SG170441 DB	'zfcp.c', 00H
	ORG $+5
$SG170456 DB	'HHC03995%s %1d:%04X %s: %s:', 0aH, '%s', 0aH, 00H
$SG170457 DB	'zfcp_execute_ccw', 00H
	ORG $+3
$SG170458 DB	'zfcp.c', 00H
	ORG $+5
$SG170469 DB	'zfcp_execute_ccw', 00H
	ORG $+3
$SG170470 DB	'zfcp.c', 00H
	ORG $+5
$SG170471 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170473 DB	'zfcp_execute_ccw', 00H
	ORG $+3
$SG170474 DB	'zfcp.c', 00H
	ORG $+1
$SG170480 DB	'zfcp.c', 00H
	ORG $+5
$SG170475 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170485 DB	'Unkown CCW dev(%4.4x) code(%2.2x)', 0aH, 00H
	ORG $+5
$SG170487 DB	'Unkown CCW dev(%4.4x) code(%2.2x)', 0aH, 00H
	ORG $+5
$SG170516 DB	'SIGA-r dev(%4.4x) qmask(%8.8x)', 0aH, 00H
$SG170518 DB	'SIGA-r dev(%4.4x) qmask(%8.8x)', 0aH, 00H
$SG170526 DB	'zfcp_initiate_input', 00H
$SG170527 DB	'zfcp.c', 00H
	ORG $+5
$SG170530 DB	'zfcp_initiate_input', 00H
	ORG $+4
$SG170528 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170531 DB	'zfcp.c', 00H
	ORG $+1
$SG170532 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170561 DB	'SIGA-w dev(%4.4x) qmask(%8.8x)', 0aH, 00H
$SG170563 DB	'SIGA-w dev(%4.4x) qmask(%8.8x)', 0aH, 00H
$SG170571 DB	'zfcp_initiate_output', 00H
	ORG $+3
$SG170572 DB	'zfcp.c', 00H
	ORG $+1
$SG170575 DB	'zfcp_initiate_output', 00H
	ORG $+3
$SG170573 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170576 DB	'zfcp.c', 00H
	ORG $+1
$SG170577 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170604 DB	'SIGA-s dev(%4.4x) oqmask(%8.8x) iqmask(%8.8x)', 0aH, 00H
	ORG $+1
$SG170606 DB	'SIGA-s dev(%4.4x) oqmask(%8.8x) iqmask(%8.8x)', 0aH, 00H
	ORG $+1
$SG170621 DB	'SIGA-m dev(%4.4x) qmask(%8.8x)', 0aH, 00H
$SG170623 DB	'SIGA-m dev(%4.4x) qmask(%8.8x)', 0aH, 00H
$SG170671 DB	'DEVBLK', 00H
	ORG $+1
zfcp_device_hndinfo DQ FLAT:zfcp_init_handler
	DQ	FLAT:zfcp_execute_ccw
	DQ	FLAT:zfcp_close_device
	DQ	FLAT:zfcp_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:zfcp_halt_or_clear
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:zfcp_immed_commands
	DQ	FLAT:zfcp_initiate_input
	DQ	FLAT:zfcp_initiate_output
	DQ	FLAT:zfcp_do_sync
	DQ	FLAT:zfcp_initiate_output_mult
	DQ	FLAT:zfcp_ssqd_desc
	DQ	FLAT:zfcp_set_sci
	DQ	0000000000000000H
	DQ	0000000000000000H
$SG170667 DB	'SDL 4.60', 00H
	ORG $+7
$SG170668 DB	'HERCULES', 00H
	ORG $+7
$SG170670 DB	'SDL 4.00', 00H
	ORG $+7
$SG170673 DB	'SDL 4.2', 00H
$SG170674 DB	'SYSBLK', 00H
	ORG $+1
$SG170686 DB	'ZFCP', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:zfcp_execute_ccw
	DD	02cH
	DD	01625H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:zfcp_query_device
	DD	025H
	DD	01acH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:zfcp_read_configuration_data
	DD	022H
	DD	01caH
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_dev_4K_storage_key DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_get_dev_4K_storage_key DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_dev_storage_key DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__get_dev_storage_key DD 011301H
	DD	06213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_dev_storekey_ptr DD 011301H
	DD	02213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$STORCHK DD 011801H
	DD	06218H
$unwind$set_alsi DD 010d01H
	DD	0620dH
$unwind$set_dsci DD 010d01H
	DD	0620dH
$unwind$raise_adapter_interrupt DD 010901H
	DD	04209H
$unwind$process_input_queue DD 020c01H
	DD	013010cH
$unwind$process_output_queue DD 020c01H
	DD	013010cH
$unwind$zfcp_halt_or_clear DD 010901H
	DD	06209H
$unwind$zfcp_read_configuration_data DD 042a19H
	DD	0190118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0b0H
$unwind$zfcp_init_handler DD 041701H
	DD	0110117H
	DD	0600f7010H
$unwind$zfcp_query_device DD 022d19H
	DD	02f011bH
	DD	imagerel __GSHandlerCheck
	DD	0160H
$unwind$zfcp_close_device DD 010901H
	DD	06209H
$unwind$zfcp_set_sci DD 010e01H
	DD	0a20eH
$unwind$zfcp_ssqd_desc DD 010e01H
	DD	0620eH
$unwind$zfcp_execute_ccw DD 043419H
	DD	05ab0122H
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	02d40H
$unwind$zfcp_initiate_input DD 010d01H
	DD	0820dH
$unwind$zfcp_initiate_output DD 010d01H
	DD	0820dH
$unwind$zfcp_do_sync DD 011201H
	DD	04212H
$unwind$zfcp_initiate_output_mult DD 010d01H
	DD	0420dH
$unwind$hdl_check_depends_ep DD 030b01H
	DD	07007620bH
	DD	06006H
$unwind$hdl_define_devtypes_ep DD 010901H
	DD	04209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
defdev$ = 48
hdl_define_devtypes_ep PROC

; 1456 : HDL_DEVICE_SECTION;

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1457 : {
; 1458 :     HDL_DEVICE ( ZFCP, zfcp_device_hndinfo );

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:zfcp_device_hndinfo
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170686
  00017	ff 54 24 30	 call	 QWORD PTR defdev$[rsp]

; 1459 : }
; 1460 : END_DEVICE_SECTION

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
hdl_define_devtypes_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
getsym$ = 8
hdl_resolve_symbols_ep PROC

; 1444 : HDL_RESOLVER_SECTION;

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
$LN4@hdl_resolv:

; 1445 : {
; 1446 :   #if defined( WIN32 ) && !defined( _MSVC_ ) && !defined( HDL_USE_LIBTOOL )
; 1447 :     #undef sysblk
; 1448 :     HDL_RESOLVE_SYMPTR( psysblk, sysblk );
; 1449 :   #else
; 1450 :     UNREFERENCED( getsym );     // (HDL_RESOLVER_SECTION parameter)

  00005	33 c0		 xor	 eax, eax
  00007	85 c0		 test	 eax, eax
  00009	75 fa		 jne	 SHORT $LN4@hdl_resolv

; 1451 :   #endif
; 1452 : }
; 1453 : END_RESOLVER_SECTION

  0000b	c3		 ret	 0
hdl_resolve_symbols_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
depchk_rc$ = 32
depchk$ = 80
hdl_check_depends_ep PROC

; 1427 : HDL_DEPENDENCY_SECTION;

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  0000b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 0
$LN4@hdl_check_:

; 1428 : {
; 1429 :     HDL_DEPENDENCY( HERCULES );

  00013	41 b8 08 00 00
	00		 mov	 r8d, 8
  00019	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170667
  00020	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170668
  00027	ff 54 24 50	 call	 QWORD PTR depchk$[rsp]
  0002b	85 c0		 test	 eax, eax
  0002d	74 08		 je	 SHORT $LN11@hdl_check_
  0002f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN11@hdl_check_:
  00037	33 c0		 xor	 eax, eax
  00039	85 c0		 test	 eax, eax
  0003b	75 d6		 jne	 SHORT $LN4@hdl_check_
$LN7@hdl_check_:

; 1430 :     HDL_DEPENDENCY( DEVBLK );

  0003d	41 b8 a0 1b 00
	00		 mov	 r8d, 7072		; 00001ba0H
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170670
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170671
  00051	ff 54 24 50	 call	 QWORD PTR depchk$[rsp]
  00055	85 c0		 test	 eax, eax
  00057	74 08		 je	 SHORT $LN12@hdl_check_
  00059	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN12@hdl_check_:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 d6		 jne	 SHORT $LN7@hdl_check_
$LN10@hdl_check_:

; 1431 :     HDL_DEPENDENCY( SYSBLK );

  00067	41 b8 00 76 01
	00		 mov	 r8d, 95744		; 00017600H
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170673
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170674
  0007b	ff 54 24 50	 call	 QWORD PTR depchk$[rsp]
  0007f	85 c0		 test	 eax, eax
  00081	74 08		 je	 SHORT $LN13@hdl_check_
  00083	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR depchk_rc$[rsp], 1
$LN13@hdl_check_:
  0008b	33 c0		 xor	 eax, eax
  0008d	85 c0		 test	 eax, eax
  0008f	75 d6		 jne	 SHORT $LN10@hdl_check_

; 1432 : 
; 1433 :     memcpy( (NED*)&configuration_data[0], &zfcp_device_ned [0], sizeof( NED ));

  00091	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00096	48 6b c0 00	 imul	 rax, rax, 0
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zfcp_device_ned
  000a1	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000a6	48 6b d2 00	 imul	 rdx, rdx, 0
  000aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:configuration_data
  000b1	49 8d 3c 10	 lea	 rdi, QWORD PTR [r8+rdx]
  000b5	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000b9	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000be	f3 a4		 rep movsb

; 1434 :     memcpy( (NED*)&configuration_data[1], &zfcp_ctlunit_ned[0], sizeof( NED ));

  000c0	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000c5	48 6b c0 00	 imul	 rax, rax, 0
  000c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zfcp_ctlunit_ned
  000d0	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000d5	48 6b d2 01	 imul	 rdx, rdx, 1
  000d9	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:configuration_data
  000e0	48 03 fa	 add	 rdi, rdx
  000e3	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  000e7	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000ec	f3 a4		 rep movsb

; 1435 :     memcpy( (NED*)&configuration_data[2], &zfcp_token_ned  [0], sizeof( NED ));

  000ee	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  000f3	48 6b c0 00	 imul	 rax, rax, 0
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zfcp_token_ned
  000fe	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00103	48 6b d2 02	 imul	 rdx, rdx, 2
  00107	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:configuration_data
  0010e	48 03 fa	 add	 rdi, rdx
  00111	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00115	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0011a	f3 a4		 rep movsb

; 1436 :     memcpy( (NED*)&configuration_data[3], &zfcp_general_neq[0], sizeof( NEQ ));

  0011c	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00121	48 6b c0 00	 imul	 rax, rax, 0
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zfcp_general_neq
  0012c	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00131	48 6b d2 03	 imul	 rdx, rdx, 3
  00135	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:configuration_data
  0013c	48 03 fa	 add	 rdi, rdx
  0013f	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00143	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00148	f3 a4		 rep movsb

; 1437 : 
; 1438 :     memcpy( (ND*)&node_data[0], &zfcp_nd[0], sizeof( ND ));

  0014a	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0014f	48 6b c0 00	 imul	 rax, rax, 0
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zfcp_nd
  0015a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0015f	48 6b d2 00	 imul	 rdx, rdx, 0
  00163	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:node_data
  0016a	48 03 fa	 add	 rdi, rdx
  0016d	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  00171	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  00176	f3 a4		 rep movsb

; 1439 :     memcpy( (ND*)&node_data[1], &zfcp_nq[0], sizeof( NQ ));

  00178	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  0017d	48 6b c0 00	 imul	 rax, rax, 0
  00181	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zfcp_nq
  00188	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0018d	48 6b d2 01	 imul	 rdx, rdx, 1
  00191	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:node_data
  00198	48 03 fa	 add	 rdi, rdx
  0019b	48 8d 34 01	 lea	 rsi, QWORD PTR [rcx+rax]
  0019f	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  001a4	f3 a4		 rep movsb

; 1440 : }
; 1441 : END_DEPENDENCY_SECTION

  001a6	8b 44 24 20	 mov	 eax, DWORD PTR depchk_rc$[rsp]
  001aa	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001ae	5f		 pop	 rdi
  001af	5e		 pop	 rsi
  001b0	c3		 ret	 0
hdl_check_depends_ep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
dev$ = 48
qmask$ = 56
zfcp_initiate_output_mult PROC

; 1377 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@zfcp_initi:

; 1378 :     DBGTRC( dev, "SIGA-m dev(%4.4x) qmask(%8.8x)\n", dev->devnum, qmask );

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  0001e	74 49		 je	 SHORT $LN8@zfcp_initi
$LN7@zfcp_initi:
  00020	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00025	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00029	44 8b 44 24 38	 mov	 r8d, DWORD PTR qmask$[rsp]
  0002e	8b d0		 mov	 edx, eax
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170621
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00043	85 c0		 test	 eax, eax
  00045	74 1c		 je	 SHORT $LN9@zfcp_initi
  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0004c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00050	44 8b 44 24 38	 mov	 r8d, DWORD PTR qmask$[rsp]
  00055	8b d0		 mov	 edx, eax
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170623
  0005e	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@zfcp_initi:
  00063	33 c0		 xor	 eax, eax
  00065	85 c0		 test	 eax, eax
  00067	75 b7		 jne	 SHORT $LN7@zfcp_initi
$LN8@zfcp_initi:
  00069	33 c0		 xor	 eax, eax
  0006b	85 c0		 test	 eax, eax
  0006d	75 9e		 jne	 SHORT $LN4@zfcp_initi

; 1379 : 
; 1380 :     return zfcp_initiate_output(dev, qmask);

  0006f	8b 54 24 38	 mov	 edx, DWORD PTR qmask$[rsp]
  00073	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00078	e8 00 00 00 00	 call	 zfcp_initiate_output

; 1381 : }

  0007d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00081	c3		 ret	 0
zfcp_initiate_output_mult ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
dev$ = 48
oqmask$ = 56
iqmask$ = 64
zfcp_do_sync PROC

; 1361 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@zfcp_do_sy:

; 1362 :     UNREFERENCED(dev);          /* unreferenced for non-DEBUG builds */

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@zfcp_do_sy
$LN7@zfcp_do_sy:

; 1363 :     UNREFERENCED(oqmask);       /* unreferenced for non-DEBUG builds */

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN7@zfcp_do_sy
$LN10@zfcp_do_sy:

; 1364 :     UNREFERENCED(iqmask);       /* unreferenced for non-DEBUG builds */

  0001e	33 c0		 xor	 eax, eax
  00020	85 c0		 test	 eax, eax
  00022	75 fa		 jne	 SHORT $LN10@zfcp_do_sy
$LN13@zfcp_do_sy:

; 1365 : 
; 1366 :     DBGTRC( dev, "SIGA-s dev(%4.4x) oqmask(%8.8x) iqmask(%8.8x)\n",

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00029	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0002d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00031	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00035	74 53		 je	 SHORT $LN17@zfcp_do_sy
$LN16@zfcp_do_sy:
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00040	44 8b 4c 24 40	 mov	 r9d, DWORD PTR iqmask$[rsp]
  00045	44 8b 44 24 38	 mov	 r8d, DWORD PTR oqmask$[rsp]
  0004a	8b d0		 mov	 edx, eax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170604
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0005f	85 c0		 test	 eax, eax
  00061	74 21		 je	 SHORT $LN18@zfcp_do_sy
  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00068	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0006c	44 8b 4c 24 40	 mov	 r9d, DWORD PTR iqmask$[rsp]
  00071	44 8b 44 24 38	 mov	 r8d, DWORD PTR oqmask$[rsp]
  00076	8b d0		 mov	 edx, eax
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170606
  0007f	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@zfcp_do_sy:
  00084	33 c0		 xor	 eax, eax
  00086	85 c0		 test	 eax, eax
  00088	75 ad		 jne	 SHORT $LN16@zfcp_do_sy
$LN17@zfcp_do_sy:
  0008a	33 c0		 xor	 eax, eax
  0008c	85 c0		 test	 eax, eax
  0008e	75 94		 jne	 SHORT $LN13@zfcp_do_sy

; 1367 :         dev->devnum, oqmask, iqmask );
; 1368 : 
; 1369 :     return 0;

  00090	33 c0		 xor	 eax, eax

; 1370 : }

  00092	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00096	c3		 ret	 0
zfcp_do_sync ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
n$1 = 32
tv192 = 36
tv202 = 40
grp$ = 48
dev$ = 80
qmask$ = 88
zfcp_initiate_output PROC

; 1323 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1324 : ZFCP_GRP *grp = (ZFCP_GRP*)dev->group->grp_data;

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	48 89 44 24 30	 mov	 QWORD PTR grp$[rsp], rax
$LN4@zfcp_initi:

; 1325 : 
; 1326 :     DBGTRC( dev, "SIGA-w dev(%4.4x) qmask(%8.8x)\n", dev->devnum, qmask );

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00024	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00028	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002c	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00030	74 49		 je	 SHORT $LN17@zfcp_initi
$LN7@zfcp_initi:
  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0003b	44 8b 44 24 58	 mov	 r8d, DWORD PTR qmask$[rsp]
  00040	8b d0		 mov	 edx, eax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170561
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00055	85 c0		 test	 eax, eax
  00057	74 1c		 je	 SHORT $LN18@zfcp_initi
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0005e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00062	44 8b 44 24 58	 mov	 r8d, DWORD PTR qmask$[rsp]
  00067	8b d0		 mov	 edx, eax
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170563
  00070	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@zfcp_initi:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 b7		 jne	 SHORT $LN7@zfcp_initi
$LN17@zfcp_initi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 9e		 jne	 SHORT $LN4@zfcp_initi

; 1327 : 
; 1328 :     /* Return CC1 if the device is not QDIO active */
; 1329 :     if(!(dev->scsw.flag2 & SCSW2_Q))

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0008d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00092	85 c0		 test	 eax, eax
  00094	75 0a		 jne	 SHORT $LN19@zfcp_initi

; 1330 :         return 1;

  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	e9 7c 01 00 00	 jmp	 $LN1@zfcp_initi
$LN19@zfcp_initi:

; 1331 : 
; 1332 :     /* Validate Mask */
; 1333 :     qmask &= ~(0xffffffff >> dev->qdio.o_qcnt);

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  000ab	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  000b0	89 4c 24 24	 mov	 DWORD PTR tv192[rsp], ecx
  000b4	0f b6 c8	 movzx	 ecx, al
  000b7	8b 44 24 24	 mov	 eax, DWORD PTR tv192[rsp]
  000bb	d3 e8		 shr	 eax, cl
  000bd	f7 d0		 not	 eax
  000bf	8b 4c 24 58	 mov	 ecx, DWORD PTR qmask$[rsp]
  000c3	23 c8		 and	 ecx, eax
  000c5	8b c1		 mov	 eax, ecx
  000c7	89 44 24 58	 mov	 DWORD PTR qmask$[rsp], eax

; 1334 : 
; 1335 :     /* Reset Queue Positions */
; 1336 :     if(qmask != dev->qdio.o_qmask)

  000cb	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000d0	8b 80 50 14 00
	00		 mov	 eax, DWORD PTR [rax+5200]
  000d6	39 44 24 58	 cmp	 DWORD PTR qmask$[rsp], eax
  000da	0f 84 91 00 00
	00		 je	 $LN20@zfcp_initi

; 1337 :     {
; 1338 :     int n;
; 1339 :         for(n = 0; n < dev->qdio.o_qcnt; n++)

  000e0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  000e8	eb 0a		 jmp	 SHORT $LN10@zfcp_initi
$LN8@zfcp_initi:
  000ea	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  000ee	ff c0		 inc	 eax
  000f0	89 44 24 20	 mov	 DWORD PTR n$1[rsp], eax
$LN10@zfcp_initi:
  000f4	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000f9	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  000ff	39 44 24 20	 cmp	 DWORD PTR n$1[rsp], eax
  00103	7d 40		 jge	 SHORT $LN9@zfcp_initi

; 1340 :             if(!(dev->qdio.o_qmask & (0x80000000 >> n)))

  00105	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  00109	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0010e	89 4c 24 28	 mov	 DWORD PTR tv202[rsp], ecx
  00112	0f b6 c8	 movzx	 ecx, al
  00115	8b 44 24 28	 mov	 eax, DWORD PTR tv202[rsp]
  00119	d3 e8		 shr	 eax, cl
  0011b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00120	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  00126	23 c8		 and	 ecx, eax
  00128	8b c1		 mov	 eax, ecx
  0012a	85 c0		 test	 eax, eax
  0012c	75 15		 jne	 SHORT $LN21@zfcp_initi

; 1341 :                 dev->qdio.o_bpos[n] = 0;

  0012e	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  00133	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00138	c7 84 81 cc 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+5068], 0
$LN21@zfcp_initi:
  00143	eb a5		 jmp	 SHORT $LN8@zfcp_initi
$LN9@zfcp_initi:

; 1342 :         if(!dev->qdio.o_qmask)

  00145	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0014a	83 b8 50 14 00
	00 00		 cmp	 DWORD PTR [rax+5200], 0
  00151	75 0f		 jne	 SHORT $LN22@zfcp_initi

; 1343 :             dev->qdio.o_qpos = 0;

  00153	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00158	c7 80 c8 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5064], 0
$LN22@zfcp_initi:

; 1344 : 
; 1345 :         /* Update Write Queue Mask */
; 1346 :         dev->qdio.o_qmask = qmask;

  00162	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00167	8b 4c 24 58	 mov	 ecx, DWORD PTR qmask$[rsp]
  0016b	89 88 50 14 00
	00		 mov	 DWORD PTR [rax+5200], ecx
$LN20@zfcp_initi:

; 1347 :     }
; 1348 : 
; 1349 :     /* Send signal to QDIO thread */
; 1350 :     if(dev->qdio.o_qmask)

  00171	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00176	83 b8 50 14 00
	00 00		 cmp	 DWORD PTR [rax+5200], 0
  0017d	0f 84 97 00 00
	00		 je	 $LN23@zfcp_initi
$LN13@zfcp_initi:

; 1351 :         VERIFY(1 == write_pipe(grp->ppfd[1],"*",1));

  00183	b8 04 00 00 00	 mov	 eax, 4
  00188	48 6b c0 01	 imul	 rax, rax, 1
  0018c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR grp$[rsp]
  00191	48 63 44 01 2c	 movsxd	 rax, DWORD PTR [rcx+rax+44]
  00196	45 33 c9	 xor	 r9d, r9d
  00199	41 b8 01 00 00
	00		 mov	 r8d, 1
  0019f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170570
  001a6	48 8b c8	 mov	 rcx, rax
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  001af	83 f8 01	 cmp	 eax, 1
  001b2	74 5c		 je	 SHORT $LN24@zfcp_initi
$LN16@zfcp_initi:
  001b4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170571
  001bb	41 b8 47 05 00
	00		 mov	 r8d, 1351		; 00000547H
  001c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170572
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170573
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001db	85 c0		 test	 eax, eax
  001dd	74 20		 je	 SHORT $LN25@zfcp_initi
  001df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170575
  001e6	41 b8 47 05 00
	00		 mov	 r8d, 1351		; 00000547H
  001ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170576
  001f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170577
  001fa	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@zfcp_initi:
  001ff	33 c0		 xor	 eax, eax
  00201	85 c0		 test	 eax, eax
  00203	75 af		 jne	 SHORT $LN16@zfcp_initi
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0020b	85 c0		 test	 eax, eax
  0020d	74 01		 je	 SHORT $LN26@zfcp_initi
  0020f	cc		 int	 3
$LN26@zfcp_initi:
$LN24@zfcp_initi:
  00210	33 c0		 xor	 eax, eax
  00212	85 c0		 test	 eax, eax
  00214	0f 85 69 ff ff
	ff		 jne	 $LN13@zfcp_initi
$LN23@zfcp_initi:

; 1352 : 
; 1353 :     return 0;

  0021a	33 c0		 xor	 eax, eax
$LN1@zfcp_initi:

; 1354 : }

  0021c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00220	c3		 ret	 0
zfcp_initiate_output ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
n$1 = 32
tv90 = 36
tv198 = 40
tv208 = 44
noselrd$ = 48
grp$ = 56
dev$ = 80
qmask$ = 88
zfcp_initiate_input PROC

; 1281 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1282 : ZFCP_GRP *grp = (ZFCP_GRP*)dev->group->grp_data;

  0000d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00016	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001a	48 89 44 24 38	 mov	 QWORD PTR grp$[rsp], rax
$LN4@zfcp_initi:

; 1283 : int noselrd;
; 1284 : 
; 1285 :     DBGTRC( dev, "SIGA-r dev(%4.4x) qmask(%8.8x)\n", dev->devnum, qmask );

  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00024	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00028	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0002c	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00030	74 49		 je	 SHORT $LN17@zfcp_initi
$LN7@zfcp_initi:
  00032	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00037	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0003b	44 8b 44 24 58	 mov	 r8d, DWORD PTR qmask$[rsp]
  00040	8b d0		 mov	 edx, eax
  00042	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170516
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00055	85 c0		 test	 eax, eax
  00057	74 1c		 je	 SHORT $LN18@zfcp_initi
  00059	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0005e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00062	44 8b 44 24 58	 mov	 r8d, DWORD PTR qmask$[rsp]
  00067	8b d0		 mov	 edx, eax
  00069	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170518
  00070	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@zfcp_initi:
  00075	33 c0		 xor	 eax, eax
  00077	85 c0		 test	 eax, eax
  00079	75 b7		 jne	 SHORT $LN7@zfcp_initi
$LN17@zfcp_initi:
  0007b	33 c0		 xor	 eax, eax
  0007d	85 c0		 test	 eax, eax
  0007f	75 9e		 jne	 SHORT $LN4@zfcp_initi

; 1286 : 
; 1287 :     /* Return CC1 if the device is not QDIO active */
; 1288 :     if(!(dev->scsw.flag2 & SCSW2_Q))

  00081	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0008d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00092	85 c0		 test	 eax, eax
  00094	75 0a		 jne	 SHORT $LN19@zfcp_initi

; 1289 :         return 1;

  00096	b8 01 00 00 00	 mov	 eax, 1
  0009b	e9 af 01 00 00	 jmp	 $LN1@zfcp_initi
$LN19@zfcp_initi:

; 1290 : 
; 1291 :     /* Is there a read select */
; 1292 :     noselrd = !dev->qdio.i_qmask;

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  000ac	75 0a		 jne	 SHORT $LN28@zfcp_initi
  000ae	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000b6	eb 08		 jmp	 SHORT $LN29@zfcp_initi
$LN28@zfcp_initi:
  000b8	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN29@zfcp_initi:
  000c0	8b 44 24 24	 mov	 eax, DWORD PTR tv90[rsp]
  000c4	89 44 24 30	 mov	 DWORD PTR noselrd$[rsp], eax

; 1293 : 
; 1294 :     /* Validate Mask */
; 1295 :     qmask &= ~(0xffffffff >> dev->qdio.i_qcnt);

  000c8	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000cd	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  000d3	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  000d8	89 4c 24 28	 mov	 DWORD PTR tv198[rsp], ecx
  000dc	0f b6 c8	 movzx	 ecx, al
  000df	8b 44 24 28	 mov	 eax, DWORD PTR tv198[rsp]
  000e3	d3 e8		 shr	 eax, cl
  000e5	f7 d0		 not	 eax
  000e7	8b 4c 24 58	 mov	 ecx, DWORD PTR qmask$[rsp]
  000eb	23 c8		 and	 ecx, eax
  000ed	8b c1		 mov	 eax, ecx
  000ef	89 44 24 58	 mov	 DWORD PTR qmask$[rsp], eax

; 1296 : 
; 1297 :     /* Reset Queue Positions */
; 1298 :     if(qmask != dev->qdio.i_qmask)

  000f3	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000f8	8b 80 4c 14 00
	00		 mov	 eax, DWORD PTR [rax+5196]
  000fe	39 44 24 58	 cmp	 DWORD PTR qmask$[rsp], eax
  00102	0f 84 91 00 00
	00		 je	 $LN20@zfcp_initi

; 1299 :     {
; 1300 :     int n;
; 1301 :         for(n = 0; n < dev->qdio.i_qcnt; n++)

  00108	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$1[rsp], 0
  00110	eb 0a		 jmp	 SHORT $LN10@zfcp_initi
$LN8@zfcp_initi:
  00112	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  00116	ff c0		 inc	 eax
  00118	89 44 24 20	 mov	 DWORD PTR n$1[rsp], eax
$LN10@zfcp_initi:
  0011c	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00121	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00127	39 44 24 20	 cmp	 DWORD PTR n$1[rsp], eax
  0012b	7d 40		 jge	 SHORT $LN9@zfcp_initi

; 1302 :             if(!(dev->qdio.i_qmask & (0x80000000 >> n)))

  0012d	8b 44 24 20	 mov	 eax, DWORD PTR n$1[rsp]
  00131	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00136	89 4c 24 2c	 mov	 DWORD PTR tv208[rsp], ecx
  0013a	0f b6 c8	 movzx	 ecx, al
  0013d	8b 44 24 2c	 mov	 eax, DWORD PTR tv208[rsp]
  00141	d3 e8		 shr	 eax, cl
  00143	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00148	8b 89 4c 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5196]
  0014e	23 c8		 and	 ecx, eax
  00150	8b c1		 mov	 eax, ecx
  00152	85 c0		 test	 eax, eax
  00154	75 15		 jne	 SHORT $LN21@zfcp_initi

; 1303 :                 dev->qdio.i_bpos[n] = 0;

  00156	48 63 44 24 20	 movsxd	 rax, DWORD PTR n$1[rsp]
  0015b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00160	c7 84 81 44 13
	00 00 00 00 00
	00		 mov	 DWORD PTR [rcx+rax*4+4932], 0
$LN21@zfcp_initi:
  0016b	eb a5		 jmp	 SHORT $LN8@zfcp_initi
$LN9@zfcp_initi:

; 1304 :         if(!dev->qdio.i_qmask)

  0016d	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00172	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  00179	75 0f		 jne	 SHORT $LN22@zfcp_initi

; 1305 :             dev->qdio.i_qpos = 0;

  0017b	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00180	c7 80 40 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4928], 0
$LN22@zfcp_initi:

; 1306 : 
; 1307 :         /* Update Read Queue Mask */
; 1308 :         dev->qdio.i_qmask = qmask;

  0018a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0018f	8b 4c 24 58	 mov	 ecx, DWORD PTR qmask$[rsp]
  00193	89 88 4c 14 00
	00		 mov	 DWORD PTR [rax+5196], ecx
$LN20@zfcp_initi:

; 1309 :     }
; 1310 : 
; 1311 :     /* Send signal to QDIO thread */
; 1312 :     if(noselrd && dev->qdio.i_qmask)

  00199	83 7c 24 30 00	 cmp	 DWORD PTR noselrd$[rsp], 0
  0019e	0f 84 a9 00 00
	00		 je	 $LN23@zfcp_initi
  001a4	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  001a9	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  001b0	0f 84 97 00 00
	00		 je	 $LN23@zfcp_initi
$LN13@zfcp_initi:

; 1313 :         VERIFY(1 == write_pipe(grp->ppfd[1],"*",1));

  001b6	b8 04 00 00 00	 mov	 eax, 4
  001bb	48 6b c0 01	 imul	 rax, rax, 1
  001bf	48 8b 4c 24 38	 mov	 rcx, QWORD PTR grp$[rsp]
  001c4	48 63 44 01 2c	 movsxd	 rax, DWORD PTR [rcx+rax+44]
  001c9	45 33 c9	 xor	 r9d, r9d
  001cc	41 b8 01 00 00
	00		 mov	 r8d, 1
  001d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170525
  001d9	48 8b c8	 mov	 rcx, rax
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  001e2	83 f8 01	 cmp	 eax, 1
  001e5	74 5c		 je	 SHORT $LN24@zfcp_initi
$LN16@zfcp_initi:
  001e7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170526
  001ee	41 b8 21 05 00
	00		 mov	 r8d, 1313		; 00000521H
  001f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170527
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170528
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00208	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0020e	85 c0		 test	 eax, eax
  00210	74 20		 je	 SHORT $LN25@zfcp_initi
  00212	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170530
  00219	41 b8 21 05 00
	00		 mov	 r8d, 1313		; 00000521H
  0021f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170531
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170532
  0022d	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@zfcp_initi:
  00232	33 c0		 xor	 eax, eax
  00234	85 c0		 test	 eax, eax
  00236	75 af		 jne	 SHORT $LN16@zfcp_initi
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0023e	85 c0		 test	 eax, eax
  00240	74 01		 je	 SHORT $LN26@zfcp_initi
  00242	cc		 int	 3
$LN26@zfcp_initi:
$LN24@zfcp_initi:
  00243	33 c0		 xor	 eax, eax
  00245	85 c0		 test	 eax, eax
  00247	0f 85 69 ff ff
	ff		 jne	 $LN13@zfcp_initi
$LN23@zfcp_initi:

; 1314 : 
; 1315 :     return 0;

  0024d	33 c0		 xor	 eax, eax
$LN1@zfcp_initi:

; 1316 : }

  0024f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00253	c3		 ret	 0
zfcp_initiate_input ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
i$1 = 96
num$ = 100
grp$ = 104
accerr$2 = 112
qdes$3 = 120
rd_size$4 = 128
len$5 = 132
tv84 = 136
qdr$6 = 144
c$7 = 152
len$8 = 156
iir$9 = 160
rc$10 = 164
tv168 = 168
tv174 = 172
tv193 = 176
tv218 = 180
tv241 = 184
tv258 = 188
tv264 = 192
tv340 = 196
tv224 = 200
tv363 = 204
tv380 = 208
tv387 = 212
tv758 = 216
tv357 = 220
tv87 = 224
tv161 = 228
qib$11 = 232
tv292 = 240
nd$12 = 248
cua$13 = 256
nq$14 = 264
tv638 = 272
tv206 = 280
tv246 = 288
tv345 = 296
readset$15 = 304
buf$16 = 8512
buf$17 = 9536
buf$18 = 10560
__$ArrayPad$ = 11584
dev$ = 11632
code$ = 11640
flags$ = 11648
chained$ = 11656
count$ = 11664
prevcode$ = 11672
ccwseq$ = 11680
iobuf$ = 11688
more$ = 11696
unitstat$ = 11704
residual$ = 11712
zfcp_execute_ccw PROC

; 790  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	b8 58 2d 00 00	 mov	 eax, 11608		; 00002d58H
  0001a	e8 00 00 00 00	 call	 __chkstk
  0001f	48 2b e0	 sub	 rsp, rax
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 84 24 40
	2d 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 791  : ZFCP_GRP *grp = (ZFCP_GRP*)dev->group->grp_data;

  00034	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00040	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00044	48 89 44 24 68	 mov	 QWORD PTR grp$[rsp], rax
$LN4@zfcp_execu:

; 792  : U32 num;                                /* Number of bytes to move   */
; 793  : 
; 794  :     UNREFERENCED(flags);

  00049	33 c0		 xor	 eax, eax
  0004b	85 c0		 test	 eax, eax
  0004d	75 fa		 jne	 SHORT $LN4@zfcp_execu
$LN7@zfcp_execu:

; 795  :     UNREFERENCED(prevcode);

  0004f	33 c0		 xor	 eax, eax
  00051	85 c0		 test	 eax, eax
  00053	75 fa		 jne	 SHORT $LN7@zfcp_execu
$LN10@zfcp_execu:

; 796  :     UNREFERENCED(ccwseq);

  00055	33 c0		 xor	 eax, eax
  00057	85 c0		 test	 eax, eax
  00059	75 fa		 jne	 SHORT $LN10@zfcp_execu
$LN13@zfcp_execu:

; 797  :     UNREFERENCED(chained);

  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 fa		 jne	 SHORT $LN13@zfcp_execu

; 798  : 
; 799  :     /* Command reject if the device group has not been established */
; 800  :     if((dev->group->acount != ZFCP_GROUP_SIZE)
; 801  :       && !(IS_CCW_SENSE(code) || IS_CCW_NOP(code) || (code == ZFCP_RCD)))

  00061	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00069	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0006d	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  00071	74 55		 je	 SHORT $LN40@zfcp_execu
  00073	0f b6 84 24 78
	2d 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0007b	83 e0 0f	 and	 eax, 15
  0007e	83 f8 04	 cmp	 eax, 4
  00081	74 45		 je	 SHORT $LN40@zfcp_execu
  00083	0f b6 84 24 78
	2d 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  0008b	83 f8 03	 cmp	 eax, 3
  0008e	74 38		 je	 SHORT $LN40@zfcp_execu
  00090	0f b6 84 24 78
	2d 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00098	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  0009d	74 29		 je	 SHORT $LN40@zfcp_execu

; 802  :     {
; 803  :         /* Set Intervention required sense, and unit check status */
; 804  :         dev->sense[0] = SENSE_IR;

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b0	c6 84 01 64 03
	00 00 40	 mov	 BYTE PTR [rcx+rax+868], 64 ; 00000040H

; 805  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  000b8	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  000c0	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 806  :         return;

  000c3	e9 5d 15 00 00	 jmp	 $LN1@zfcp_execu
$LN40@zfcp_execu:

; 807  :     }
; 808  : 
; 809  :     /* Process depending on CCW opcode */
; 810  :     switch (code) {

  000c8	0f b6 84 24 78
	2d 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  000d0	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv84[rsp], eax
  000d7	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv84[rsp]
  000de	ff c8		 dec	 eax
  000e0	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv84[rsp], eax
  000e7	81 bc 24 88 00
	00 00 f9 00 00
	00		 cmp	 DWORD PTR tv84[rsp], 249 ; 000000f9H
  000f2	0f 87 92 14 00
	00		 ja	 $LN93@zfcp_execu
  000f8	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv84[rsp]
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00107	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN134@zfcp_execu[rcx+rax]
  0010f	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN135@zfcp_execu[rcx+rax*4]
  00116	48 03 c1	 add	 rax, rcx
  00119	ff e0		 jmp	 rax
$LN41@zfcp_execu:

; 811  : 
; 812  : 
; 813  :     case 0x01:
; 814  :     /*---------------------------------------------------------------*/
; 815  :     /* WRITE                                                         */
; 816  :     /*---------------------------------------------------------------*/
; 817  :     {
; 818  :         if(1)

  0011b	33 c0		 xor	 eax, eax
  0011d	83 f8 01	 cmp	 eax, 1
  00120	74 71		 je	 SHORT $LN42@zfcp_execu

; 819  :         {
; 820  : 
; 821  :             /* Calculate number of bytes to write and set residual count */
; 822  :             num = (count < RSP_BUFSZ) ? count : RSP_BUFSZ;

  00122	81 bc 24 90 2d
	00 00 00 10 00
	00		 cmp	 DWORD PTR count$[rsp], 4096 ; 00001000H
  0012d	73 10		 jae	 SHORT $LN97@zfcp_execu
  0012f	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00136	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv87[rsp], eax
  0013d	eb 0b		 jmp	 SHORT $LN98@zfcp_execu
$LN97@zfcp_execu:
  0013f	c7 84 24 e0 00
	00 00 00 10 00
	00		 mov	 DWORD PTR tv87[rsp], 4096 ; 00001000H
$LN98@zfcp_execu:
  0014a	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv87[rsp]
  00151	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 823  :             *residual = count - num;

  00155	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00159	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00160	2b c8		 sub	 ecx, eax
  00162	8b c1		 mov	 eax, ecx
  00164	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0016c	89 01		 mov	 DWORD PTR [rcx], eax

; 824  :             if (count < RSP_BUFSZ) *more = 1;

  0016e	81 bc 24 90 2d
	00 00 00 10 00
	00		 cmp	 DWORD PTR count$[rsp], 4096 ; 00001000H
  00179	73 0b		 jae	 SHORT $LN44@zfcp_execu
  0017b	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00183	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN44@zfcp_execu:

; 825  : 
; 826  :             /* Return normal status */
; 827  :             *unitstat = CSW_CE | CSW_DE;

  00186	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0018e	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 828  :         }

  00191	eb 24		 jmp	 SHORT $LN43@zfcp_execu
$LN42@zfcp_execu:

; 829  :         else
; 830  :         {
; 831  :             /* Command reject if no response buffer available */
; 832  :             dev->sense[0] = SENSE_CR;

  00193	b8 01 00 00 00	 mov	 eax, 1
  00198	48 6b c0 00	 imul	 rax, rax, 0
  0019c	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a4	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 833  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001ac	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001b4	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN43@zfcp_execu:

; 834  :         }
; 835  :         break;

  001b7	e9 69 14 00 00	 jmp	 $LN14@zfcp_execu
$LN45@zfcp_execu:

; 836  :     }
; 837  : 
; 838  : 
; 839  :     case 0x02:
; 840  :     /*---------------------------------------------------------------*/
; 841  :     /* READ                                                          */
; 842  :     /*---------------------------------------------------------------*/
; 843  :     {
; 844  :         U32 rd_size = 0;

  001bc	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR rd_size$4[rsp], 0

; 845  : 
; 846  :         obtain_lock(&grp->qlock);

  001c7	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  001cc	48 83 c0 08	 add	 rax, 8
  001d0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170411
  001d7	48 8b c8	 mov	 rcx, rax
  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 847  :         if(grp->rspsz)

  001e0	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  001e5	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  001e9	74 39		 je	 SHORT $LN46@zfcp_execu

; 848  :         {
; 849  :             rd_size = grp->rspsz;

  001eb	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  001f0	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  001f3	89 84 24 80 00
	00 00		 mov	 DWORD PTR rd_size$4[rsp], eax

; 850  :             memcpy(iobuf,grp->rspbf,rd_size);

  001fa	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rd_size$4[rsp]
  00201	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  00206	48 8b bc 24 a8
	2d 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  0020e	48 8b 71 38	 mov	 rsi, QWORD PTR [rcx+56]
  00212	8b c8		 mov	 ecx, eax
  00214	f3 a4		 rep movsb

; 851  :             grp->rspsz = 0;

  00216	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0021b	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 852  :         }

  00222	eb 66		 jmp	 SHORT $LN47@zfcp_execu
$LN46@zfcp_execu:

; 853  :         else
; 854  :         {
; 855  :             if(0)

  00224	33 c0		 xor	 eax, eax
  00226	85 c0		 test	 eax, eax
  00228	74 60		 je	 SHORT $LN48@zfcp_execu

; 856  :             {
; 857  :                 wait_condition(&grp->qcond, &grp->qlock);

  0022a	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0022f	48 83 c0 08	 add	 rax, 8
  00233	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  00238	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170415
  0023f	48 8b d0	 mov	 rdx, rax
  00242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 858  :                 if(grp->rspsz)

  00248	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0024d	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  00251	74 37		 je	 SHORT $LN49@zfcp_execu

; 859  :                 {
; 860  :                     rd_size = grp->rspsz;

  00253	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00258	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0025b	89 84 24 80 00
	00 00		 mov	 DWORD PTR rd_size$4[rsp], eax

; 861  :                     memcpy(iobuf,grp->rspbf,rd_size);

  00262	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rd_size$4[rsp]
  00269	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  0026e	48 8b bc 24 a8
	2d 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00276	48 8b 71 38	 mov	 rsi, QWORD PTR [rcx+56]
  0027a	8b c8		 mov	 ecx, eax
  0027c	f3 a4		 rep movsb

; 862  :                     grp->rspsz = 0;

  0027e	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00283	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0
$LN49@zfcp_execu:
$LN48@zfcp_execu:
$LN47@zfcp_execu:

; 863  :                 }
; 864  :             }
; 865  :         }
; 866  :         release_lock(&grp->qlock);

  0028a	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0028f	48 83 c0 08	 add	 rax, 8
  00293	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170417
  0029a	48 8b c8	 mov	 rcx, rax
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 867  : 
; 868  :         if(rd_size)

  002a3	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rd_size$4[rsp], 0
  002ab	74 7a		 je	 SHORT $LN50@zfcp_execu

; 869  :         {
; 870  :             /* Calculate number of bytes to read and set residual count */
; 871  :             num = (count < rd_size) ? count : rd_size;

  002ad	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rd_size$4[rsp]
  002b4	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  002bb	73 10		 jae	 SHORT $LN99@zfcp_execu
  002bd	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  002c4	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
  002cb	eb 0e		 jmp	 SHORT $LN100@zfcp_execu
$LN99@zfcp_execu:
  002cd	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rd_size$4[rsp]
  002d4	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv161[rsp], eax
$LN100@zfcp_execu:
  002db	8b 84 24 e4 00
	00 00		 mov	 eax, DWORD PTR tv161[rsp]
  002e2	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 872  :             *residual = count - num;

  002e6	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  002ea	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  002f1	2b c8		 sub	 ecx, eax
  002f3	8b c1		 mov	 eax, ecx
  002f5	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  002fd	89 01		 mov	 DWORD PTR [rcx], eax

; 873  :             if (count < rd_size) *more = 1;

  002ff	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR rd_size$4[rsp]
  00306	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0030d	73 0b		 jae	 SHORT $LN52@zfcp_execu
  0030f	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00317	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN52@zfcp_execu:

; 874  : 
; 875  :             /* Return normal status */
; 876  :             *unitstat = CSW_CE | CSW_DE;

  0031a	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00322	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 877  :         }

  00325	eb 24		 jmp	 SHORT $LN51@zfcp_execu
$LN50@zfcp_execu:

; 878  :         else
; 879  :         {
; 880  :             /* Return unit check with status modifier */
; 881  :             dev->sense[0] = 0;

  00327	b8 01 00 00 00	 mov	 eax, 1
  0032c	48 6b c0 00	 imul	 rax, rax, 0
  00330	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00338	c6 84 01 64 03
	00 00 00	 mov	 BYTE PTR [rcx+rax+868], 0

; 882  :             *unitstat = CSW_CE | CSW_DE | CSW_UC | CSW_SM;

  00340	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00348	c6 00 4e	 mov	 BYTE PTR [rax], 78	; 0000004eH
$LN51@zfcp_execu:

; 883  :         }
; 884  :         break;

  0034b	e9 d5 12 00 00	 jmp	 $LN14@zfcp_execu
$LN53@zfcp_execu:

; 885  :     }
; 886  : 
; 887  : 
; 888  :     case 0x03:
; 889  :     /*---------------------------------------------------------------*/
; 890  :     /* CONTROL NO-OPERATION                                          */
; 891  :     /*---------------------------------------------------------------*/
; 892  : 
; 893  :         *residual = 0;

  00350	48 8b 84 24 c0
	2d 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00358	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 894  :         *unitstat = CSW_CE | CSW_DE;

  0035e	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00366	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 895  :         break;

  00369	e9 b7 12 00 00	 jmp	 $LN14@zfcp_execu
$LN54@zfcp_execu:

; 896  : 
; 897  : 
; 898  :     case 0x14:
; 899  :     /*---------------------------------------------------------------*/
; 900  :     /* SENSE COMMAND BYTE                                            */
; 901  :     /*---------------------------------------------------------------*/
; 902  :     {
; 903  :         // PROGRAMMING NOTE: I'm still not sure about this. The
; 904  :         // Sense Command Byte command is known to be a 3088 CTCA
; 905  :         // command, so I suspect we should never be seeing this
; 906  :         // command because we don't support CTCA emulation mode.
; 907  : 
; 908  :         // I suspect the reason we're currently seeing it MAY be
; 909  :         // because we still don't have something right and z/OS
; 910  :         // is thus getting confused into thinking the OSA device
; 911  :         // is currently configured to emulate a 3088 CTCA device.
; 912  : 
; 913  :         // However, since rejecting it causes z/OS to go into a
; 914  :         // disabled wait, we are going to temporarily treat it
; 915  :         // as a valid command until we can positively determine
; 916  :         // whether or not it is a bonafide valid OSA command.
; 917  : 
; 918  :         /* The Sense Command Byte command returns a single byte
; 919  :            being the CCW opcode from the other end of the CTCA */
; 920  : 
; 921  :         static const U32 len = 1;               /* cmd length */
; 922  :         static const BYTE opcode = 0x03;        /* CCW opcode */
; 923  : 
; 924  :         /* Calculate residual byte count */
; 925  :         num = (count < len) ? count : len;

  0036e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?len@?BD@??zfcp_execute_ccw@@9@9
  00374	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0037b	73 10		 jae	 SHORT $LN101@zfcp_execu
  0037d	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00384	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  0038b	eb 0d		 jmp	 SHORT $LN102@zfcp_execu
$LN101@zfcp_execu:
  0038d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?len@?BD@??zfcp_execute_ccw@@9@9
  00393	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
$LN102@zfcp_execu:
  0039a	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv168[rsp]
  003a1	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 926  :         *residual = count - num;

  003a5	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  003a9	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  003b0	2b c8		 sub	 ecx, eax
  003b2	8b c1		 mov	 eax, ecx
  003b4	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  003bc	89 01		 mov	 DWORD PTR [rcx], eax

; 927  :         if (count < len) *more = 1;

  003be	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?len@?BD@??zfcp_execute_ccw@@9@9
  003c4	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  003cb	73 0b		 jae	 SHORT $LN55@zfcp_execu
  003cd	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  003d5	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN55@zfcp_execu:

; 928  : 
; 929  :         /* Copy the CTCA command byte to channel I/O buffer */
; 930  :         *iobuf = opcode;

  003d8	48 8b 84 24 a8
	2d 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  003e0	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR ?opcode@?BD@??zfcp_execute_ccw@@9@9
  003e7	88 08		 mov	 BYTE PTR [rax], cl

; 931  : 
; 932  :         /* Return normal i/o completion status */
; 933  :         *unitstat = CSW_CE | CSW_DE;

  003e9	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  003f1	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 934  :         break;

  003f4	e9 2c 12 00 00	 jmp	 $LN14@zfcp_execu
$LN56@zfcp_execu:

; 935  :     }
; 936  : 
; 937  :     case 0x04:
; 938  :     /*---------------------------------------------------------------*/
; 939  :     /* SENSE                                                         */
; 940  :     /*---------------------------------------------------------------*/
; 941  : 
; 942  :         /* Calculate residual byte count */
; 943  :         num = (count < dev->numsense) ? count : dev->numsense;

  003f9	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00401	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00407	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0040e	73 10		 jae	 SHORT $LN103@zfcp_execu
  00410	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00417	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv174[rsp], eax
  0041e	eb 15		 jmp	 SHORT $LN104@zfcp_execu
$LN103@zfcp_execu:
  00420	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00428	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  0042e	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv174[rsp], eax
$LN104@zfcp_execu:
  00435	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv174[rsp]
  0043c	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 944  :         *residual = count - num;

  00440	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00444	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0044b	2b c8		 sub	 ecx, eax
  0044d	8b c1		 mov	 eax, ecx
  0044f	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00457	89 01		 mov	 DWORD PTR [rcx], eax

; 945  :         if (count < dev->numsense) *more = 1;

  00459	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00461	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  00467	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0046e	73 0b		 jae	 SHORT $LN57@zfcp_execu
  00470	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00478	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN57@zfcp_execu:

; 946  : 
; 947  :         /* Copy device sense bytes to channel I/O buffer */
; 948  :         memcpy (iobuf, dev->sense, num);

  0047b	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0047f	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00487	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  0048e	48 8b bc 24 a8
	2d 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00496	48 8b f1	 mov	 rsi, rcx
  00499	8b c8		 mov	 ecx, eax
  0049b	f3 a4		 rep movsb

; 949  : 
; 950  :         /* Clear the device sense bytes */
; 951  :         memset (dev->sense, 0, sizeof(dev->sense));

  0049d	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a5	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  004ab	48 8b f8	 mov	 rdi, rax
  004ae	33 c0		 xor	 eax, eax
  004b0	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  004b5	f3 aa		 rep stosb

; 952  : 
; 953  :         /* Return unit status */
; 954  :         *unitstat = CSW_CE | CSW_DE;

  004b7	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  004bf	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 955  :         break;

  004c2	e9 5e 11 00 00	 jmp	 $LN14@zfcp_execu
$LN58@zfcp_execu:

; 956  : 
; 957  : 
; 958  :     case 0xE4:
; 959  :     /*---------------------------------------------------------------*/
; 960  :     /* SENSE ID                                                      */
; 961  :     /*---------------------------------------------------------------*/
; 962  : 
; 963  :         /* Calculate residual byte count */
; 964  :         num = (count < dev->numdevid) ? count : dev->numdevid;

  004c7	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004cf	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  004d5	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  004dc	73 10		 jae	 SHORT $LN105@zfcp_execu
  004de	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  004e5	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
  004ec	eb 15		 jmp	 SHORT $LN106@zfcp_execu
$LN105@zfcp_execu:
  004ee	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f6	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  004fc	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv193[rsp], eax
$LN106@zfcp_execu:
  00503	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv193[rsp]
  0050a	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 965  :         *residual = count - num;

  0050e	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00512	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00519	2b c8		 sub	 ecx, eax
  0051b	8b c1		 mov	 eax, ecx
  0051d	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00525	89 01		 mov	 DWORD PTR [rcx], eax

; 966  :         if (count < dev->numdevid) *more = 1;

  00527	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052f	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  00535	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0053c	73 0b		 jae	 SHORT $LN59@zfcp_execu
  0053e	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00546	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN59@zfcp_execu:

; 967  : 
; 968  :         /* Copy device identifier bytes to channel I/O buffer */
; 969  :         memcpy (iobuf, dev->devid, num);

  00549	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0054d	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00555	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  0055c	48 8b bc 24 a8
	2d 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  00564	48 8b f1	 mov	 rsi, rcx
  00567	8b c8		 mov	 ecx, eax
  00569	f3 a4		 rep movsb

; 970  : 
; 971  :         /* Return unit status */
; 972  :         *unitstat = CSW_CE | CSW_DE;

  0056b	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00573	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 973  : 
; 974  :         /* Display formatted Sense Id information, maybe */
; 975  :         if( grp->debug )

  00576	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0057b	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  0057f	0f 84 07 01 00
	00		 je	 $LN60@zfcp_execu

; 976  :         {
; 977  :             char buf[1024];
; 978  :             // HHC03995 "%1d:%04X %s: %s:\n%s"
; 979  :             WRMSG(HHC03995, "I", LCSS_DEVNUM,

  00585	48 83 bc 24 70
	2d 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0058e	74 15		 je	 SHORT $LN107@zfcp_execu
  00590	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00598	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0059c	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv218[rsp], eax
  005a3	eb 0b		 jmp	 SHORT $LN108@zfcp_execu
$LN107@zfcp_execu:
  005a5	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv218[rsp], 0
$LN108@zfcp_execu:
  005b0	48 83 bc 24 70
	2d 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  005b9	74 17		 je	 SHORT $LN109@zfcp_execu
  005bb	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005c3	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  005c7	d1 f8		 sar	 eax, 1
  005c9	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  005d0	eb 0b		 jmp	 SHORT $LN110@zfcp_execu
$LN109@zfcp_execu:
  005d2	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv224[rsp], 0
$LN110@zfcp_execu:
  005dd	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  005e3	4c 8d 84 24 40
	21 00 00	 lea	 r8, QWORD PTR buf$16[rsp]
  005eb	8b 54 24 64	 mov	 edx, DWORD PTR num$[rsp]
  005ef	48 8b 8c 24 a8
	2d 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatSID
  005fd	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv206[rsp], rax
  00605	b9 01 00 00 00	 mov	 ecx, 1
  0060a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00610	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv206[rsp]
  00618	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0061d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170429
  00624	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00629	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00631	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00635	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0063a	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv218[rsp]
  00641	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00645	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  0064c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00650	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170430
  00657	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0065c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170431
  00663	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00668	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0066d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00673	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170432
  0067a	ba d4 03 00 00	 mov	 edx, 980		; 000003d4H
  0067f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170433
  00686	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN60@zfcp_execu:

; 980  :                 dev->typname, "SID", FormatSID( iobuf, num, buf, sizeof( buf )));
; 981  :         }
; 982  :         break;

  0068c	e9 94 0f 00 00	 jmp	 $LN14@zfcp_execu
$LN61@zfcp_execu:

; 983  : 
; 984  : 
; 985  :     case ZFCP_RCD:
; 986  :     /*---------------------------------------------------------------*/
; 987  :     /* READ CONFIGURATION DATA                                       */
; 988  :     /*---------------------------------------------------------------*/
; 989  :     {
; 990  :         /* Build the configuration data area */
; 991  :         U32 len = dev->rcd (dev, iobuf, count);

  00691	44 8b 84 24 90
	2d 00 00	 mov	 r8d, DWORD PTR count$[rsp]
  00699	48 8b 94 24 a8
	2d 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  006a1	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006a9	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006b1	ff 90 b8 02 00
	00		 call	 QWORD PTR [rax+696]
  006b7	89 84 24 9c 00
	00 00		 mov	 DWORD PTR len$8[rsp], eax

; 992  : 
; 993  :         /* Calculate residual byte count */
; 994  :         num = (count < len ? count : len);

  006be	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR len$8[rsp]
  006c5	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  006cc	73 10		 jae	 SHORT $LN111@zfcp_execu
  006ce	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  006d5	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv241[rsp], eax
  006dc	eb 0e		 jmp	 SHORT $LN112@zfcp_execu
$LN111@zfcp_execu:
  006de	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR len$8[rsp]
  006e5	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv241[rsp], eax
$LN112@zfcp_execu:
  006ec	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv241[rsp]
  006f3	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 995  :         *residual = count - num;

  006f7	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  006fb	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00702	2b c8		 sub	 ecx, eax
  00704	8b c1		 mov	 eax, ecx
  00706	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0070e	89 01		 mov	 DWORD PTR [rcx], eax

; 996  :         if (count < len) *more = 1;

  00710	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR len$8[rsp]
  00717	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0071e	73 0b		 jae	 SHORT $LN62@zfcp_execu
  00720	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00728	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN62@zfcp_execu:

; 997  : 
; 998  :         /* Return unit status */
; 999  :         *unitstat = CSW_CE | CSW_DE;

  0072b	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00733	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1000 : 
; 1001 :         /* Display formatted Read Configuration Data records, maybe */
; 1002 :         if( grp->debug )

  00736	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0073b	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  0073f	0f 84 07 01 00
	00		 je	 $LN63@zfcp_execu

; 1003 :         {
; 1004 :             char buf[1024];
; 1005 :             // HHC03995 "%1d:%04X %s: %s:\n%s"
; 1006 :             WRMSG(HHC03995, "I", LCSS_DEVNUM,

  00745	48 83 bc 24 70
	2d 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0074e	74 15		 je	 SHORT $LN113@zfcp_execu
  00750	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00758	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0075c	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv258[rsp], eax
  00763	eb 0b		 jmp	 SHORT $LN114@zfcp_execu
$LN113@zfcp_execu:
  00765	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv258[rsp], 0
$LN114@zfcp_execu:
  00770	48 83 bc 24 70
	2d 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00779	74 17		 je	 SHORT $LN115@zfcp_execu
  0077b	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00783	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00787	d1 f8		 sar	 eax, 1
  00789	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv264[rsp], eax
  00790	eb 0b		 jmp	 SHORT $LN116@zfcp_execu
$LN115@zfcp_execu:
  00792	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv264[rsp], 0
$LN116@zfcp_execu:
  0079d	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  007a3	4c 8d 84 24 40
	25 00 00	 lea	 r8, QWORD PTR buf$17[rsp]
  007ab	8b 54 24 64	 mov	 edx, DWORD PTR num$[rsp]
  007af	48 8b 8c 24 a8
	2d 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  007b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatRCD
  007bd	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv246[rsp], rax
  007c5	b9 01 00 00 00	 mov	 ecx, 1
  007ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  007d0	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv246[rsp]
  007d8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  007dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170437
  007e4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  007e9	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007f1	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  007f5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  007fa	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv258[rsp]
  00801	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00805	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv264[rsp]
  0080c	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00810	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170438
  00817	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0081c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170439
  00823	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00828	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0082d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00833	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170440
  0083a	ba ef 03 00 00	 mov	 edx, 1007		; 000003efH
  0083f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170441
  00846	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN63@zfcp_execu:

; 1007 :                 dev->typname, "RCD", FormatRCD( iobuf, num, buf, sizeof( buf )));
; 1008 :         }
; 1009 :         break;

  0084c	e9 d4 0d 00 00	 jmp	 $LN14@zfcp_execu
$LN64@zfcp_execu:

; 1010 :     }
; 1011 : 
; 1012 : 
; 1013 :     case ZFCP_SII:
; 1014 :     /*---------------------------------------------------------------*/
; 1015 :     /* SET INTERFACE IDENTIFIER                                      */
; 1016 :     /*---------------------------------------------------------------*/
; 1017 :     {
; 1018 :         U32 iir;                    /* Work area to validate IIR     */
; 1019 :         FETCH_FW(iir,iobuf);        /* Fetch IIR into work area      */

  00851	48 8b 8c 24 a8
	2d 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00859	e8 00 00 00 00	 call	 fetch_fw_noswap
  0085e	8b c8		 mov	 ecx, eax
  00860	e8 00 00 00 00	 call	 _byteswap_ulong
  00865	89 84 24 a0 00
	00 00		 mov	 DWORD PTR iir$9[rsp], eax

; 1020 : 
; 1021 :         /* Command Reject if the Interface ID Record is invalid.
; 1022 :            Note: we only support one interface with an ID of 0. */
; 1023 :         if ((iir & 0xFFFCFFFF) != 0xB0000000 ||

  0086c	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR iir$9[rsp]
  00873	25 ff ff fc ff	 and	 eax, -196609		; fffcffffH
  00878	3d 00 00 00 b0	 cmp	 eax, -1342177280	; b0000000H
  0087d	75 13		 jne	 SHORT $LN66@zfcp_execu
  0087f	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR iir$9[rsp]
  00886	25 00 00 03 00	 and	 eax, 196608		; 00030000H
  0088b	3d 00 00 03 00	 cmp	 eax, 196608		; 00030000H
  00890	75 29		 jne	 SHORT $LN65@zfcp_execu
$LN66@zfcp_execu:

; 1024 :             (iir & 0x00030000) == 0x00030000)
; 1025 :         {
; 1026 :             dev->sense[0] = SENSE_CR;

  00892	b8 01 00 00 00	 mov	 eax, 1
  00897	48 6b c0 00	 imul	 rax, rax, 0
  0089b	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008a3	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1027 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  008ab	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  008b3	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1028 :             break;

  008b6	e9 6a 0d 00 00	 jmp	 $LN14@zfcp_execu
$LN65@zfcp_execu:

; 1029 :         }
; 1030 : 
; 1031 :         /* Save the requested Interface ID for later unless it's
; 1032 :            not chained (to a presumably following RNI command) */
; 1033 :         if (chained)

  008bb	0f b6 84 24 88
	2d 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  008c3	85 c0		 test	 eax, eax
  008c5	74 0f		 je	 SHORT $LN67@zfcp_execu

; 1034 :             grp->iir = iir;

  008c7	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  008cc	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR iir$9[rsp]
  008d3	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN67@zfcp_execu:

; 1035 : 
; 1036 :         /* Calculate residual byte count */
; 1037 :         num = (count < SII_SIZE) ? count : SII_SIZE;

  008d6	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  008dd	48 83 f8 04	 cmp	 rax, 4
  008e1	73 11		 jae	 SHORT $LN117@zfcp_execu
  008e3	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  008ea	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv292[rsp], rax
  008f2	eb 0c		 jmp	 SHORT $LN118@zfcp_execu
$LN117@zfcp_execu:
  008f4	48 c7 84 24 f0
	00 00 00 04 00
	00 00		 mov	 QWORD PTR tv292[rsp], 4
$LN118@zfcp_execu:
  00900	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv292[rsp]
  00907	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 1038 :         *residual = count - num;

  0090b	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  0090f	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00916	2b c8		 sub	 ecx, eax
  00918	8b c1		 mov	 eax, ecx
  0091a	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00922	89 01		 mov	 DWORD PTR [rcx], eax

; 1039 :         if (count < SII_SIZE) *more = 1;

  00924	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0092b	48 83 f8 04	 cmp	 rax, 4
  0092f	73 0b		 jae	 SHORT $LN68@zfcp_execu
  00931	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00939	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN68@zfcp_execu:

; 1040 : 
; 1041 :         /* Return unit status */
; 1042 :         *unitstat = CSW_CE | CSW_DE;

  0093c	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00944	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1043 : 
; 1044 : //!     /* Display various information, maybe */
; 1045 : //!     if( grp->debug )
; 1046 : //!     {
; 1047 : //!         mpc_display_stuff( dev, "SII", iobuf, num, ' ' );
; 1048 : //!     }
; 1049 : 
; 1050 :         break;

  00947	e9 d9 0c 00 00	 jmp	 $LN14@zfcp_execu
$LN69@zfcp_execu:

; 1051 :     }
; 1052 : 
; 1053 : 
; 1054 :     case ZFCP_RNI:
; 1055 :     /*---------------------------------------------------------------*/
; 1056 :     /* READ NODE IDENTIFIER                                          */
; 1057 :     /*---------------------------------------------------------------*/
; 1058 :     {
; 1059 :         U32 len = sizeof(node_data);

  0094c	c7 84 24 84 00
	00 00 40 00 00
	00		 mov	 DWORD PTR len$5[rsp], 64 ; 00000040H

; 1060 :         ND *nd = (ND*)iobuf;            /* Node Descriptor pointer   */

  00957	48 8b 84 24 a8
	2d 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  0095f	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR nd$12[rsp], rax

; 1061 :         DEVBLK *cua;                    /* Our Control Unit device   */
; 1062 : 
; 1063 :         /* Command Reject if not chained from Set Interface ID */
; 1064 :         if (!chained || prevcode != OSA_SII)

  00967	0f b6 84 24 88
	2d 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  0096f	85 c0		 test	 eax, eax
  00971	74 0f		 je	 SHORT $LN71@zfcp_execu
  00973	0f b6 84 24 98
	2d 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  0097b	3d 81 00 00 00	 cmp	 eax, 129		; 00000081H
  00980	74 29		 je	 SHORT $LN70@zfcp_execu
$LN71@zfcp_execu:

; 1065 :         {
; 1066 :             dev->sense[0] = SENSE_CR;

  00982	b8 01 00 00 00	 mov	 eax, 1
  00987	48 6b c0 00	 imul	 rax, rax, 0
  0098b	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00993	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1067 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0099b	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  009a3	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1068 :             break;

  009a6	e9 7a 0c 00 00	 jmp	 $LN14@zfcp_execu
$LN70@zfcp_execu:

; 1069 :         }
; 1070 : 
; 1071 :         /* The first device in the group is the control unit */
; 1072 :         cua = dev->group->memdev[0];

  009ab	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009b3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  009b7	b9 08 00 00 00	 mov	 ecx, 8
  009bc	48 6b c9 00	 imul	 rcx, rcx, 0
  009c0	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  009c5	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR cua$13[rsp], rax

; 1073 : 
; 1074 :         /* If the Node Selector was zero an ND and one or more
; 1075 :            NQs are returned. Otherwise just the ND is returned. */
; 1076 :         if ((grp->iir & 0x00030000) != 0)

  009cd	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  009d2	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  009d5	25 00 00 03 00	 and	 eax, 196608		; 00030000H
  009da	85 c0		 test	 eax, eax
  009dc	74 0b		 je	 SHORT $LN72@zfcp_execu

; 1077 :             len = sizeof(ND);

  009de	c7 84 24 84 00
	00 00 20 00 00
	00		 mov	 DWORD PTR len$5[rsp], 32 ; 00000020H
$LN72@zfcp_execu:

; 1078 : 
; 1079 :         /* Copy configuration data from tempate */
; 1080 :         memcpy (iobuf, node_data, len);

  009e9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len$5[rsp]
  009f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:node_data
  009f7	48 8b bc 24 a8
	2d 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  009ff	48 8b f1	 mov	 rsi, rcx
  00a02	8b c8		 mov	 ecx, eax
  00a04	f3 a4		 rep movsb

; 1081 : 
; 1082 :         /* Insert the CHPID of the node into the Node Descriptor ND */
; 1083 :         nd->tag[0] = dev->pmcw.chpid[0];

  00a06	b8 01 00 00 00	 mov	 eax, 1
  00a0b	48 6b c0 00	 imul	 rax, rax, 0
  00a0f	b9 01 00 00 00	 mov	 ecx, 1
  00a14	48 6b c9 00	 imul	 rcx, rcx, 0
  00a18	48 8b 94 24 f8
	00 00 00	 mov	 rdx, QWORD PTR nd$12[rsp]
  00a20	48 8b bc 24 70
	2d 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  00a28	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  00a30	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 1084 : 
; 1085 :         /* Update the Node Qualifier information if they want it */
; 1086 :         if (len > sizeof(ND))

  00a34	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len$5[rsp]
  00a3b	48 83 f8 20	 cmp	 rax, 32			; 00000020H
  00a3f	76 68		 jbe	 SHORT $LN73@zfcp_execu

; 1087 :         {
; 1088 :             NQ *nq = (NQ*)nd + 1;       /* Point to Node Qualifier */

  00a41	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR nd$12[rsp]
  00a49	48 83 c0 20	 add	 rax, 32			; 00000020H
  00a4d	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR nq$14[rsp], rax

; 1089 : 
; 1090 :             /* Insert the CULA CHPID and device number into the NQ */
; 1091 :             nq->rsrvd[1] = cua->pmcw.chpid[0];

  00a55	b8 01 00 00 00	 mov	 eax, 1
  00a5a	48 6b c0 00	 imul	 rax, rax, 0
  00a5e	b9 01 00 00 00	 mov	 ecx, 1
  00a63	48 6b c9 01	 imul	 rcx, rcx, 1
  00a67	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR nq$14[rsp]
  00a6f	48 8b bc 24 00
	01 00 00	 mov	 rdi, QWORD PTR cua$13[rsp]
  00a77	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  00a7f	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al

; 1092 :             nq->rsrvd[2] = cua->devnum & 0xFF;

  00a83	48 8b 84 24 00
	01 00 00	 mov	 rax, QWORD PTR cua$13[rsp]
  00a8b	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a8f	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00a94	b9 01 00 00 00	 mov	 ecx, 1
  00a99	48 6b c9 02	 imul	 rcx, rcx, 2
  00a9d	48 8b 94 24 08
	01 00 00	 mov	 rdx, QWORD PTR nq$14[rsp]
  00aa5	88 44 0a 01	 mov	 BYTE PTR [rdx+rcx+1], al
$LN73@zfcp_execu:

; 1093 :         }
; 1094 : 
; 1095 :         /* Calculate residual byte count */
; 1096 :         num = (count < len ? count : len);

  00aa9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len$5[rsp]
  00ab0	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00ab7	73 10		 jae	 SHORT $LN119@zfcp_execu
  00ab9	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00ac0	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv340[rsp], eax
  00ac7	eb 0e		 jmp	 SHORT $LN120@zfcp_execu
$LN119@zfcp_execu:
  00ac9	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len$5[rsp]
  00ad0	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv340[rsp], eax
$LN120@zfcp_execu:
  00ad7	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv340[rsp]
  00ade	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 1097 :         *residual = count - num;

  00ae2	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  00ae6	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00aed	2b c8		 sub	 ecx, eax
  00aef	8b c1		 mov	 eax, ecx
  00af1	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00af9	89 01		 mov	 DWORD PTR [rcx], eax

; 1098 :         if (count < len) *more = 1;

  00afb	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR len$5[rsp]
  00b02	39 84 24 90 2d
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00b09	73 0b		 jae	 SHORT $LN74@zfcp_execu
  00b0b	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00b13	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN74@zfcp_execu:

; 1099 : 
; 1100 :         /* Return unit status */
; 1101 :         *unitstat = CSW_CE | CSW_DE;

  00b16	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00b1e	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1102 : 
; 1103 :         /* Display formatted Read Node Information, maybe */
; 1104 :         if( grp->debug )

  00b21	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  00b26	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00b2a	0f 84 07 01 00
	00		 je	 $LN75@zfcp_execu

; 1105 :         {
; 1106 :             char buf[1024];
; 1107 :             // HHC03995 "%1d:%04X %s: %s:\n%s"
; 1108 :             WRMSG(HHC03995, "I", LCSS_DEVNUM,

  00b30	48 83 bc 24 70
	2d 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b39	74 15		 je	 SHORT $LN121@zfcp_execu
  00b3b	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b43	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b47	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv357[rsp], eax
  00b4e	eb 0b		 jmp	 SHORT $LN122@zfcp_execu
$LN121@zfcp_execu:
  00b50	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv357[rsp], 0
$LN122@zfcp_execu:
  00b5b	48 83 bc 24 70
	2d 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b64	74 17		 je	 SHORT $LN123@zfcp_execu
  00b66	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b6e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b72	d1 f8		 sar	 eax, 1
  00b74	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv363[rsp], eax
  00b7b	eb 0b		 jmp	 SHORT $LN124@zfcp_execu
$LN123@zfcp_execu:
  00b7d	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv363[rsp], 0
$LN124@zfcp_execu:
  00b88	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  00b8e	4c 8d 84 24 40
	29 00 00	 lea	 r8, QWORD PTR buf$18[rsp]
  00b96	8b 54 24 64	 mov	 edx, DWORD PTR num$[rsp]
  00b9a	48 8b 8c 24 a8
	2d 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00ba2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatRNI
  00ba8	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv345[rsp], rax
  00bb0	b9 01 00 00 00	 mov	 ecx, 1
  00bb5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bbb	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv345[rsp]
  00bc3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00bc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170454
  00bcf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00bd4	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bdc	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00be0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00be5	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR tv357[rsp]
  00bec	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00bf0	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv363[rsp]
  00bf7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00bfb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170455
  00c02	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c07	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170456
  00c0e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c13	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c18	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c1e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170457
  00c25	ba 55 04 00 00	 mov	 edx, 1109		; 00000455H
  00c2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170458
  00c31	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN75@zfcp_execu:

; 1109 :                 dev->typname, "RNI", FormatRNI( iobuf, num, buf, sizeof( buf )));
; 1110 :         }
; 1111 :         break;

  00c37	e9 e9 09 00 00	 jmp	 $LN14@zfcp_execu
$LN76@zfcp_execu:

; 1112 :     }
; 1113 : 
; 1114 : 
; 1115 :     case ZFCP_EQ:
; 1116 :     /*---------------------------------------------------------------*/
; 1117 :     /* ESTABLISH QUEUES                                              */
; 1118 :     /*---------------------------------------------------------------*/
; 1119 :     {
; 1120 :         QDIO_QDR *qdr = (QDIO_QDR*)iobuf;

  00c3c	48 8b 84 24 a8
	2d 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  00c44	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR qdr$6[rsp], rax

; 1121 :         QDIO_QDES0 *qdes;
; 1122 :         int accerr;
; 1123 :         int i;
; 1124 : 
; 1125 :         dev->qdio.i_qcnt = qdr->iqdcnt < QDIO_MAXQ ? qdr->iqdcnt : QDIO_MAXQ;

  00c4c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00c54	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00c58	83 f8 20	 cmp	 eax, 32			; 00000020H
  00c5b	7d 15		 jge	 SHORT $LN125@zfcp_execu
  00c5d	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00c65	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00c69	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv380[rsp], eax
  00c70	eb 0b		 jmp	 SHORT $LN126@zfcp_execu
$LN125@zfcp_execu:
  00c72	c7 84 24 d0 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv380[rsp], 32 ; 00000020H
$LN126@zfcp_execu:
  00c7d	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c85	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv380[rsp]
  00c8c	89 88 3c 13 00
	00		 mov	 DWORD PTR [rax+4924], ecx

; 1126 :         dev->qdio.o_qcnt = qdr->oqdcnt < QDIO_MAXQ ? qdr->oqdcnt : QDIO_MAXQ;

  00c92	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00c9a	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00c9e	83 f8 20	 cmp	 eax, 32			; 00000020H
  00ca1	7d 15		 jge	 SHORT $LN127@zfcp_execu
  00ca3	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00cab	0f b6 40 07	 movzx	 eax, BYTE PTR [rax+7]
  00caf	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv387[rsp], eax
  00cb6	eb 0b		 jmp	 SHORT $LN128@zfcp_execu
$LN127@zfcp_execu:
  00cb8	c7 84 24 d4 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv387[rsp], 32 ; 00000020H
$LN128@zfcp_execu:
  00cc3	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ccb	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv387[rsp]
  00cd2	89 88 c4 13 00
	00		 mov	 DWORD PTR [rax+5060], ecx

; 1127 : 
; 1128 :         FETCH_DW(dev->qdio.qiba,qdr->qiba);

  00cd8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00ce0	48 83 c0 30	 add	 rax, 48			; 00000030H
  00ce4	48 8b c8	 mov	 rcx, rax
  00ce7	e8 00 00 00 00	 call	 fetch_dw_noswap
  00cec	48 8b c8	 mov	 rcx, rax
  00cef	e8 00 00 00 00	 call	 _byteswap_uint64
  00cf4	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cfc	48 89 81 60 1b
	00 00		 mov	 QWORD PTR [rcx+7008], rax

; 1129 :         dev->qdio.qibk = qdr->qkey & 0xF0;

  00d03	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00d0b	0f b6 40 3c	 movzx	 eax, BYTE PTR [rax+60]
  00d0f	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00d14	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d1c	88 81 58 1b 00
	00		 mov	 BYTE PTR [rcx+7000], al

; 1130 : 
; 1131 :         if(!(accerr = STORCHK(dev->qdio.qiba,sizeof(QDIO_QIB)-1,dev->qdio.qibk,STORKEY_CHANGE,dev)))

  00d22	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d2a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d2f	41 b1 02	 mov	 r9b, 2
  00d32	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d3a	44 0f b6 80 58
	1b 00 00	 movzx	 r8d, BYTE PTR [rax+7000]
  00d42	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  00d47	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d4f	48 8b 88 60 1b
	00 00		 mov	 rcx, QWORD PTR [rax+7008]
  00d56	e8 00 00 00 00	 call	 STORCHK
  00d5b	0f b6 c0	 movzx	 eax, al
  00d5e	89 44 24 70	 mov	 DWORD PTR accerr$2[rsp], eax
  00d62	83 7c 24 70 00	 cmp	 DWORD PTR accerr$2[rsp], 0
  00d67	0f 85 90 00 00
	00		 jne	 $LN77@zfcp_execu

; 1132 :         {
; 1133 :         QDIO_QIB *qib = (QDIO_QIB*)(dev->mainstor + dev->qdio.qiba);

  00d6d	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d75	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00d7c	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d84	48 03 81 60 1b
	00 00		 add	 rax, QWORD PTR [rcx+7008]
  00d8b	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR qib$11[rsp], rax

; 1134 :             qib->ac |= QIB_AC_PCI; // Incidate PCI on output is supported

  00d93	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR qib$11[rsp]
  00d9b	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00d9f	83 c8 40	 or	 eax, 64			; 00000040H
  00da2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR qib$11[rsp]
  00daa	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 1135 : #if defined(_FEATURE_QEBSM)
; 1136 :             if (FACILITY_ENABLED_DEV( HERC_QEBSM ))

  00dad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00db4	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  00dbb	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  00dbf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00dc6	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  00dce	b9 01 00 00 00	 mov	 ecx, 1
  00dd3	48 6b c9 21	 imul	 rcx, rcx, 33		; 00000021H
  00dd7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00ddb	83 e0 08	 and	 eax, 8
  00dde	85 c0		 test	 eax, eax
  00de0	74 1b		 je	 SHORT $LN78@zfcp_execu

; 1137 :                 qib->rflags |= QIB_RFLAGS_QEBSM;

  00de2	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR qib$11[rsp]
  00dea	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  00dee	0f ba e8 07	 bts	 eax, 7
  00df2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR qib$11[rsp]
  00dfa	88 41 02	 mov	 BYTE PTR [rcx+2], al
$LN78@zfcp_execu:
$LN77@zfcp_execu:

; 1138 : #endif /*defined(_FEATURE_QEBSM)*/
; 1139 :         }
; 1140 : 
; 1141 :         qdes = qdr->qdf0;

  00dfd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00e05	48 83 c0 40	 add	 rax, 64			; 00000040H
  00e09	48 89 44 24 78	 mov	 QWORD PTR qdes$3[rsp], rax

; 1142 : 
; 1143 :         for(i = 0; i < dev->qdio.i_qcnt; i++)

  00e0e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00e16	eb 0a		 jmp	 SHORT $LN18@zfcp_execu
$LN16@zfcp_execu:
  00e18	8b 44 24 60	 mov	 eax, DWORD PTR i$1[rsp]
  00e1c	ff c0		 inc	 eax
  00e1e	89 44 24 60	 mov	 DWORD PTR i$1[rsp], eax
$LN18@zfcp_execu:
  00e22	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e2a	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00e30	39 44 24 60	 cmp	 DWORD PTR i$1[rsp], eax
  00e34	0f 8d e2 01 00
	00		 jge	 $LN17@zfcp_execu

; 1144 :         {
; 1145 :             FETCH_DW( dev->qdio.i_sliba[i],  qdes->sliba );

  00e3a	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  00e3f	48 8b c8	 mov	 rcx, rax
  00e42	e8 00 00 00 00	 call	 fetch_dw_noswap
  00e47	48 8b c8	 mov	 rcx, rax
  00e4a	e8 00 00 00 00	 call	 _byteswap_uint64
  00e4f	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00e54	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00e5c	48 89 84 ca d8
	14 00 00	 mov	 QWORD PTR [rdx+rcx*8+5336], rax

; 1146 :             FETCH_DW( dev->qdio.i_sla[i],    qdes->sla   );

  00e64	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  00e69	48 83 c0 08	 add	 rax, 8
  00e6d	48 8b c8	 mov	 rcx, rax
  00e70	e8 00 00 00 00	 call	 fetch_dw_noswap
  00e75	48 8b c8	 mov	 rcx, rax
  00e78	e8 00 00 00 00	 call	 _byteswap_uint64
  00e7d	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00e82	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00e8a	48 89 84 ca d8
	15 00 00	 mov	 QWORD PTR [rdx+rcx*8+5592], rax

; 1147 :             FETCH_DW( dev->qdio.i_slsbla[i], qdes->slsba );

  00e92	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  00e97	48 83 c0 10	 add	 rax, 16
  00e9b	48 8b c8	 mov	 rcx, rax
  00e9e	e8 00 00 00 00	 call	 fetch_dw_noswap
  00ea3	48 8b c8	 mov	 rcx, rax
  00ea6	e8 00 00 00 00	 call	 _byteswap_uint64
  00eab	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00eb0	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00eb8	48 89 84 ca d8
	16 00 00	 mov	 QWORD PTR [rdx+rcx*8+5848], rax

; 1148 : 
; 1149 :             dev->qdio.i_slibk[i]  = (qdes->keyp1)      & 0xF0;

  00ec0	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  00ec5	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  00ec9	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00ece	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00ed3	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00edb	88 84 0a 54 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5204], al

; 1150 :             dev->qdio.i_slk[i]    = (qdes->keyp1 << 4) & 0xF0;

  00ee2	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  00ee7	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  00eeb	c1 e0 04	 shl	 eax, 4
  00eee	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00ef3	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00ef8	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f00	88 84 0a 74 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5236], al

; 1151 :             dev->qdio.i_sbalk[i]  = (qdes->keyp2)      & 0xF0;

  00f07	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  00f0c	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00f10	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00f15	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00f1a	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f22	88 84 0a 94 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5268], al

; 1152 :             dev->qdio.i_slsblk[i] = (qdes->keyp2 << 4) & 0xF0;

  00f29	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  00f2e	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  00f32	c1 e0 04	 shl	 eax, 4
  00f35	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00f3a	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00f3f	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f47	88 84 0a b4 14
	00 00		 mov	 BYTE PTR [rdx+rcx+5300], al

; 1153 : 
; 1154 :             accerr |= STORCHK( dev->qdio.i_slsbla[i], sizeof(QDIO_SLSB) - 1, dev->qdio.i_slsblk[i], STORKEY_CHANGE, dev );

  00f4e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$1[rsp]
  00f53	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00f58	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f60	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00f65	41 b1 02	 mov	 r9b, 2
  00f68	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00f70	44 0f b6 84 02
	b4 14 00 00	 movzx	 r8d, BYTE PTR [rdx+rax+5300]
  00f79	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  00f7e	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f86	48 8b 8c c8 d8
	16 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+5848]
  00f8e	e8 00 00 00 00	 call	 STORCHK
  00f93	0f b6 c0	 movzx	 eax, al
  00f96	8b 4c 24 70	 mov	 ecx, DWORD PTR accerr$2[rsp]
  00f9a	0b c8		 or	 ecx, eax
  00f9c	8b c1		 mov	 eax, ecx
  00f9e	89 44 24 70	 mov	 DWORD PTR accerr$2[rsp], eax

; 1155 :             accerr |= STORCHK( dev->qdio.i_sla[i],    sizeof(QDIO_SL)   - 1, dev->qdio.i_slk[i],    STORKEY_REF,    dev );

  00fa2	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$1[rsp]
  00fa7	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  00fac	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00fb4	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00fb9	41 b1 04	 mov	 r9b, 4
  00fbc	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00fc4	44 0f b6 84 02
	74 14 00 00	 movzx	 r8d, BYTE PTR [rdx+rax+5236]
  00fcd	ba ff 03 00 00	 mov	 edx, 1023		; 000003ffH
  00fd2	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fda	48 8b 8c c8 d8
	15 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+5592]
  00fe2	e8 00 00 00 00	 call	 STORCHK
  00fe7	0f b6 c0	 movzx	 eax, al
  00fea	8b 4c 24 70	 mov	 ecx, DWORD PTR accerr$2[rsp]
  00fee	0b c8		 or	 ecx, eax
  00ff0	8b c1		 mov	 eax, ecx
  00ff2	89 44 24 70	 mov	 DWORD PTR accerr$2[rsp], eax

; 1156 : 
; 1157 :             qdes = (QDIO_QDES0*) ((BYTE*)qdes+(qdr->iqdsz << 2));

  00ff6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  00ffe	0f b6 40 09	 movzx	 eax, BYTE PTR [rax+9]
  01002	c1 e0 02	 shl	 eax, 2
  01005	48 98		 cdqe
  01007	48 8b 4c 24 78	 mov	 rcx, QWORD PTR qdes$3[rsp]
  0100c	48 03 c8	 add	 rcx, rax
  0100f	48 8b c1	 mov	 rax, rcx
  01012	48 89 44 24 78	 mov	 QWORD PTR qdes$3[rsp], rax

; 1158 :         }

  01017	e9 fc fd ff ff	 jmp	 $LN16@zfcp_execu
$LN17@zfcp_execu:

; 1159 : 
; 1160 :         for(i = 0; i < dev->qdio.o_qcnt; i++)

  0101c	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  01024	eb 0a		 jmp	 SHORT $LN21@zfcp_execu
$LN19@zfcp_execu:
  01026	8b 44 24 60	 mov	 eax, DWORD PTR i$1[rsp]
  0102a	ff c0		 inc	 eax
  0102c	89 44 24 60	 mov	 DWORD PTR i$1[rsp], eax
$LN21@zfcp_execu:
  01030	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01038	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  0103e	39 44 24 60	 cmp	 DWORD PTR i$1[rsp], eax
  01042	0f 8d e2 01 00
	00		 jge	 $LN20@zfcp_execu

; 1161 :         {
; 1162 :             FETCH_DW( dev->qdio.o_sliba[i],  qdes->sliba );

  01048	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  0104d	48 8b c8	 mov	 rcx, rax
  01050	e8 00 00 00 00	 call	 fetch_dw_noswap
  01055	48 8b c8	 mov	 rcx, rax
  01058	e8 00 00 00 00	 call	 _byteswap_uint64
  0105d	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01062	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0106a	48 89 84 ca 58
	18 00 00	 mov	 QWORD PTR [rdx+rcx*8+6232], rax

; 1163 :             FETCH_DW( dev->qdio.o_sla[i],    qdes->sla   );

  01072	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  01077	48 83 c0 08	 add	 rax, 8
  0107b	48 8b c8	 mov	 rcx, rax
  0107e	e8 00 00 00 00	 call	 fetch_dw_noswap
  01083	48 8b c8	 mov	 rcx, rax
  01086	e8 00 00 00 00	 call	 _byteswap_uint64
  0108b	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01090	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01098	48 89 84 ca 58
	19 00 00	 mov	 QWORD PTR [rdx+rcx*8+6488], rax

; 1164 :             FETCH_DW( dev->qdio.o_slsbla[i], qdes->slsba );

  010a0	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  010a5	48 83 c0 10	 add	 rax, 16
  010a9	48 8b c8	 mov	 rcx, rax
  010ac	e8 00 00 00 00	 call	 fetch_dw_noswap
  010b1	48 8b c8	 mov	 rcx, rax
  010b4	e8 00 00 00 00	 call	 _byteswap_uint64
  010b9	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  010be	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  010c6	48 89 84 ca 58
	1a 00 00	 mov	 QWORD PTR [rdx+rcx*8+6744], rax

; 1165 : 
; 1166 :             dev->qdio.o_slibk[i]  = (qdes->keyp1)      & 0xF0;

  010ce	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  010d3	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  010d7	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  010dc	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  010e1	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  010e9	88 84 0a d8 17
	00 00		 mov	 BYTE PTR [rdx+rcx+6104], al

; 1167 :             dev->qdio.o_slk[i]    = (qdes->keyp1 << 4) & 0xF0;

  010f0	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  010f5	0f b6 40 1c	 movzx	 eax, BYTE PTR [rax+28]
  010f9	c1 e0 04	 shl	 eax, 4
  010fc	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01101	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01106	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0110e	88 84 0a f8 17
	00 00		 mov	 BYTE PTR [rdx+rcx+6136], al

; 1168 :             dev->qdio.o_sbalk[i]  = (qdes->keyp2)      & 0xF0;

  01115	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  0111a	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  0111e	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01123	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01128	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01130	88 84 0a 18 18
	00 00		 mov	 BYTE PTR [rdx+rcx+6168], al

; 1169 :             dev->qdio.o_slsblk[i] = (qdes->keyp2 << 4) & 0xF0;

  01137	48 8b 44 24 78	 mov	 rax, QWORD PTR qdes$3[rsp]
  0113c	0f b6 40 1d	 movzx	 eax, BYTE PTR [rax+29]
  01140	c1 e0 04	 shl	 eax, 4
  01143	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  01148	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  0114d	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  01155	88 84 0a 38 18
	00 00		 mov	 BYTE PTR [rdx+rcx+6200], al

; 1170 : 
; 1171 :             accerr |= STORCHK( dev->qdio.o_slsbla[i], sizeof(QDIO_SLSB) - 1, dev->qdio.o_slsblk[i], STORKEY_CHANGE, dev );

  0115c	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$1[rsp]
  01161	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  01166	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0116e	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  01173	41 b1 02	 mov	 r9b, 2
  01176	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0117e	44 0f b6 84 02
	38 18 00 00	 movzx	 r8d, BYTE PTR [rdx+rax+6200]
  01187	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  0118c	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01194	48 8b 8c c8 58
	1a 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+6744]
  0119c	e8 00 00 00 00	 call	 STORCHK
  011a1	0f b6 c0	 movzx	 eax, al
  011a4	8b 4c 24 70	 mov	 ecx, DWORD PTR accerr$2[rsp]
  011a8	0b c8		 or	 ecx, eax
  011aa	8b c1		 mov	 eax, ecx
  011ac	89 44 24 70	 mov	 DWORD PTR accerr$2[rsp], eax

; 1172 :             accerr |= STORCHK( dev->qdio.o_sla[i],    sizeof(QDIO_SL)   - 1, dev->qdio.o_slk[i],    STORKEY_REF,    dev );

  011b0	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$1[rsp]
  011b5	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$1[rsp]
  011ba	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  011c2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  011c7	41 b1 04	 mov	 r9b, 4
  011ca	48 8b 94 24 70
	2d 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  011d2	44 0f b6 84 02
	f8 17 00 00	 movzx	 r8d, BYTE PTR [rdx+rax+6136]
  011db	ba ff 03 00 00	 mov	 edx, 1023		; 000003ffH
  011e0	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011e8	48 8b 8c c8 58
	19 00 00	 mov	 rcx, QWORD PTR [rax+rcx*8+6488]
  011f0	e8 00 00 00 00	 call	 STORCHK
  011f5	0f b6 c0	 movzx	 eax, al
  011f8	8b 4c 24 70	 mov	 ecx, DWORD PTR accerr$2[rsp]
  011fc	0b c8		 or	 ecx, eax
  011fe	8b c1		 mov	 eax, ecx
  01200	89 44 24 70	 mov	 DWORD PTR accerr$2[rsp], eax

; 1173 : 
; 1174 :             qdes = (QDIO_QDES0*) ((BYTE*)qdes+(qdr->oqdsz << 2));

  01204	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR qdr$6[rsp]
  0120c	0f b6 40 0b	 movzx	 eax, BYTE PTR [rax+11]
  01210	c1 e0 02	 shl	 eax, 2
  01213	48 98		 cdqe
  01215	48 8b 4c 24 78	 mov	 rcx, QWORD PTR qdes$3[rsp]
  0121a	48 03 c8	 add	 rcx, rax
  0121d	48 8b c1	 mov	 rax, rcx
  01220	48 89 44 24 78	 mov	 QWORD PTR qdes$3[rsp], rax

; 1175 :         }

  01225	e9 fc fd ff ff	 jmp	 $LN19@zfcp_execu
$LN20@zfcp_execu:

; 1176 : 
; 1177 :         /* Calculate residual byte count */
; 1178 :         num = (count < sizeof(QDIO_QDR)) ? count : sizeof(QDIO_QDR);

  0122a	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01231	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01237	73 11		 jae	 SHORT $LN129@zfcp_execu
  01239	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01240	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv638[rsp], rax
  01248	eb 0c		 jmp	 SHORT $LN130@zfcp_execu
$LN129@zfcp_execu:
  0124a	48 c7 84 24 10
	01 00 00 00 10
	00 00		 mov	 QWORD PTR tv638[rsp], 4096 ; 00001000H
$LN130@zfcp_execu:
  01256	8b 84 24 10 01
	00 00		 mov	 eax, DWORD PTR tv638[rsp]
  0125d	89 44 24 64	 mov	 DWORD PTR num$[rsp], eax

; 1179 :         *residual = count - num;

  01261	8b 44 24 64	 mov	 eax, DWORD PTR num$[rsp]
  01265	8b 8c 24 90 2d
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0126c	2b c8		 sub	 ecx, eax
  0126e	8b c1		 mov	 eax, ecx
  01270	48 8b 8c 24 c0
	2d 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01278	89 01		 mov	 DWORD PTR [rcx], eax

; 1180 :         if (count < sizeof(QDIO_QDR)) *more = 1;

  0127a	8b 84 24 90 2d
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01281	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01287	73 0b		 jae	 SHORT $LN79@zfcp_execu
  01289	48 8b 84 24 b0
	2d 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01291	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN79@zfcp_execu:

; 1181 : 
; 1182 :         if(!accerr)

  01294	83 7c 24 70 00	 cmp	 DWORD PTR accerr$2[rsp], 0
  01299	75 0d		 jne	 SHORT $LN80@zfcp_execu

; 1183 :         {
; 1184 :             /* Return unit status */
; 1185 :             *unitstat = CSW_CE | CSW_DE;

  0129b	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  012a3	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1186 :         }

  012a6	eb 24		 jmp	 SHORT $LN81@zfcp_execu
$LN80@zfcp_execu:

; 1187 :         else
; 1188 :         {
; 1189 :             /* Command reject on invalid or inaccessible storage addresses */
; 1190 :             dev->sense[0] = SENSE_CR;

  012a8	b8 01 00 00 00	 mov	 eax, 1
  012ad	48 6b c0 00	 imul	 rax, rax, 0
  012b1	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012b9	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1191 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  012c1	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  012c9	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN81@zfcp_execu:

; 1192 :         }
; 1193 : 
; 1194 :         break;

  012cc	e9 54 03 00 00	 jmp	 $LN14@zfcp_execu
$LN82@zfcp_execu:

; 1195 :     }
; 1196 : 
; 1197 : 
; 1198 :     case ZFCP_AQ:
; 1199 :     /*---------------------------------------------------------------*/
; 1200 :     /* ACTIVATE QUEUES                                               */
; 1201 :     /*---------------------------------------------------------------*/
; 1202 :     {
; 1203 :     fd_set readset;
; 1204 :     int rc;
; 1205 : 
; 1206 :         dev->qdio.i_qmask = dev->qdio.o_qmask = 0;

  012d1	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012d9	c7 80 50 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5200], 0
  012e3	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012eb	c7 80 4c 14 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+5196], 0

; 1207 : 
; 1208 :         FD_ZERO( &readset );

  012f5	c7 84 24 30 01
	00 00 00 00 00
	00		 mov	 DWORD PTR readset$15[rsp], 0

; 1209 : 
; 1210 :         dev->scsw.flag2 |= SCSW2_Q;

  01300	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01308	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0130f	0f ba e8 07	 bts	 eax, 7
  01313	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0131b	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al
$LN24@zfcp_execu:

; 1211 : 
; 1212 : 
; 1213 :         do {
; 1214 :             /* Process the Input Queue if data has been received */
; 1215 :             if(dev->qdio.i_qmask && FD_ISSET(grp->ttfd,&readset))

  01321	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01329	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  01330	74 27		 je	 SHORT $LN83@zfcp_execu
  01332	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR readset$15[rsp]
  0133a	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0133f	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  01348	85 c0		 test	 eax, eax
  0134a	74 0d		 je	 SHORT $LN83@zfcp_execu

; 1216 :             {
; 1217 :                 process_input_queue(dev);

  0134c	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01354	e8 00 00 00 00	 call	 process_input_queue
$LN83@zfcp_execu:

; 1218 :             }
; 1219 : 
; 1220 :             /* Process Output Queue if data needs to be sent */
; 1221 :             if(FD_ISSET(grp->ppfd[0],&readset))

  01359	b8 04 00 00 00	 mov	 eax, 4
  0135e	48 6b c0 00	 imul	 rax, rax, 0
  01362	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR readset$15[rsp]
  0136a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  0136f	8b 4c 01 2c	 mov	 ecx, DWORD PTR [rcx+rax+44]
  01373	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_ISSET
  01379	85 c0		 test	 eax, eax
  0137b	0f 84 b6 00 00
	00		 je	 $LN84@zfcp_execu
$LN27@zfcp_execu:

; 1222 :             {
; 1223 :             char c;
; 1224 :                 VERIFY(1 == read_pipe(grp->ppfd[0],&c,1));

  01381	b8 04 00 00 00	 mov	 eax, 4
  01386	48 6b c0 00	 imul	 rax, rax, 0
  0138a	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  0138f	48 63 44 01 2c	 movsxd	 rax, DWORD PTR [rcx+rax+44]
  01394	45 33 c9	 xor	 r9d, r9d
  01397	41 b8 01 00 00
	00		 mov	 r8d, 1
  0139d	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR c$7[rsp]
  013a5	48 8b c8	 mov	 rcx, rax
  013a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_recv
  013ae	83 f8 01	 cmp	 eax, 1
  013b1	74 5c		 je	 SHORT $LN85@zfcp_execu
$LN30@zfcp_execu:
  013b3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170469
  013ba	41 b8 c8 04 00
	00		 mov	 r8d, 1224		; 000004c8H
  013c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170470
  013c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170471
  013ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  013d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  013da	85 c0		 test	 eax, eax
  013dc	74 20		 je	 SHORT $LN86@zfcp_execu
  013de	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170473
  013e5	41 b8 c8 04 00
	00		 mov	 r8d, 1224		; 000004c8H
  013eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170474
  013f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170475
  013f9	e8 00 00 00 00	 call	 DebuggerTrace
$LN86@zfcp_execu:
  013fe	33 c0		 xor	 eax, eax
  01400	85 c0		 test	 eax, eax
  01402	75 af		 jne	 SHORT $LN30@zfcp_execu
  01404	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0140a	85 c0		 test	 eax, eax
  0140c	74 01		 je	 SHORT $LN87@zfcp_execu
  0140e	cc		 int	 3
$LN87@zfcp_execu:
$LN85@zfcp_execu:
  0140f	33 c0		 xor	 eax, eax
  01411	85 c0		 test	 eax, eax
  01413	0f 85 68 ff ff
	ff		 jne	 $LN27@zfcp_execu

; 1225 : 
; 1226 :                 if(dev->qdio.o_qmask)

  01419	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01421	83 b8 50 14 00
	00 00		 cmp	 DWORD PTR [rax+5200], 0
  01428	74 0d		 je	 SHORT $LN88@zfcp_execu

; 1227 :                 {
; 1228 :                     process_output_queue(dev);

  0142a	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01432	e8 00 00 00 00	 call	 process_output_queue
$LN88@zfcp_execu:
$LN84@zfcp_execu:

; 1229 :                 }
; 1230 :             }
; 1231 : 
; 1232 :             if(dev->qdio.i_qmask)

  01437	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0143f	83 b8 4c 14 00
	00 00		 cmp	 DWORD PTR [rax+5196], 0
  01446	74 16		 je	 SHORT $LN89@zfcp_execu

; 1233 :                 FD_SET(grp->ttfd, &readset);

  01448	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR readset$15[rsp]
  01450	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  01455	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01458	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET
$LN89@zfcp_execu:

; 1234 :             FD_SET(grp->ppfd[0], &readset);

  0145e	b8 04 00 00 00	 mov	 eax, 4
  01463	48 6b c0 00	 imul	 rax, rax, 0
  01467	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR readset$15[rsp]
  0146f	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  01474	8b 4c 01 2c	 mov	 ecx, DWORD PTR [rcx+rax+44]
  01478	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_FD_SET

; 1235 : 
; 1236 :             if(grp->reqpci)

  0147e	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  01483	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  01487	74 19		 je	 SHORT $LN90@zfcp_execu

; 1237 :             {
; 1238 :                 grp->reqpci = FALSE;

  01489	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  0148e	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 1239 :                 raise_adapter_interrupt(dev);

  01495	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0149d	e8 00 00 00 00	 call	 raise_adapter_interrupt
$LN90@zfcp_execu:
$LN133@zfcp_execu:
$LN33@zfcp_execu:

; 1240 :             }
; 1241 : 
; 1242 : #if defined( OPTION_W32_CTCI )
; 1243 :             do {
; 1244 : #endif
; 1245 : 
; 1246 :                 rc = select (((grp->ttfd > grp->ppfd[0]) ? grp->ttfd : grp->ppfd[0]) + 1,

  014a2	b8 04 00 00 00	 mov	 eax, 4
  014a7	48 6b c0 00	 imul	 rax, rax, 0
  014ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  014b0	48 8b 54 24 68	 mov	 rdx, QWORD PTR grp$[rsp]
  014b5	8b 44 02 2c	 mov	 eax, DWORD PTR [rdx+rax+44]
  014b9	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  014bc	7e 11		 jle	 SHORT $LN131@zfcp_execu
  014be	48 8b 44 24 68	 mov	 rax, QWORD PTR grp$[rsp]
  014c3	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  014c6	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv758[rsp], eax
  014cd	eb 19		 jmp	 SHORT $LN132@zfcp_execu
$LN131@zfcp_execu:
  014cf	b8 04 00 00 00	 mov	 eax, 4
  014d4	48 6b c0 00	 imul	 rax, rax, 0
  014d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR grp$[rsp]
  014dd	8b 44 01 2c	 mov	 eax, DWORD PTR [rcx+rax+44]
  014e1	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv758[rsp], eax
$LN132@zfcp_execu:
  014e8	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR tv758[rsp]
  014ef	ff c0		 inc	 eax
  014f1	c7 44 24 30 df
	04 00 00	 mov	 DWORD PTR [rsp+48], 1247 ; 000004dfH
  014f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170480
  01500	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01505	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0150e	45 33 c9	 xor	 r9d, r9d
  01511	45 33 c0	 xor	 r8d, r8d
  01514	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR readset$15[rsp]
  0151c	8b c8		 mov	 ecx, eax
  0151e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_select
  01524	89 84 24 a4 00
	00 00		 mov	 DWORD PTR rc$10[rsp], eax

; 1247 :                     &readset, NULL, NULL, NULL);
; 1248 : 
; 1249 : #if defined( OPTION_W32_CTCI )
; 1250 :             } while (0 == rc || (rc < 0 && HSO_errno == HSO_EINTR));

  0152b	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR rc$10[rsp], 0
  01533	0f 84 69 ff ff
	ff		 je	 $LN33@zfcp_execu
  01539	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR rc$10[rsp], 0
  01541	7d 11		 jge	 SHORT $LN91@zfcp_execu
  01543	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  01549	3d 14 27 00 00	 cmp	 eax, 10004		; 00002714H
  0154e	0f 84 4e ff ff
	ff		 je	 $LN133@zfcp_execu
$LN91@zfcp_execu:

; 1251 :         } while (rc > 0 && dev->scsw.flag2 & SCSW2_Q);

  01554	83 bc 24 a4 00
	00 00 00	 cmp	 DWORD PTR rc$10[rsp], 0
  0155c	7e 1c		 jle	 SHORT $LN92@zfcp_execu
  0155e	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01566	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0156d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  01572	85 c0		 test	 eax, eax
  01574	0f 85 a7 fd ff
	ff		 jne	 $LN24@zfcp_execu
$LN92@zfcp_execu:

; 1252 : #else
; 1253 :         } while (dev->scsw.flag2 & SCSW2_Q);
; 1254 : #endif
; 1255 : 
; 1256 : 
; 1257 :         /* Return unit status */
; 1258 :         *unitstat = CSW_CE | CSW_DE;

  0157a	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01582	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1259 :     }
; 1260 :         break;

  01585	e9 9b 00 00 00	 jmp	 $LN14@zfcp_execu
$LN93@zfcp_execu:
$LN36@zfcp_execu:

; 1261 : 
; 1262 : 
; 1263 :     default:
; 1264 :     /*---------------------------------------------------------------*/
; 1265 :     /* INVALID OPERATION                                             */
; 1266 :     /*---------------------------------------------------------------*/
; 1267 :         DBGTRC( dev, "Unkown CCW dev(%4.4x) code(%2.2x)\n", dev->devnum, code );

  0158a	48 8b 84 24 70
	2d 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01592	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01596	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0159a	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  0159e	74 5b		 je	 SHORT $LN94@zfcp_execu
$LN39@zfcp_execu:
  015a0	0f b6 84 24 78
	2d 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  015a8	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  015b0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  015b4	44 8b c0	 mov	 r8d, eax
  015b7	8b d1		 mov	 edx, ecx
  015b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170485
  015c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  015c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  015cc	85 c0		 test	 eax, eax
  015ce	74 25		 je	 SHORT $LN95@zfcp_execu
  015d0	0f b6 84 24 78
	2d 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  015d8	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  015e0	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  015e4	44 8b c0	 mov	 r8d, eax
  015e7	8b d1		 mov	 edx, ecx
  015e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170487
  015f0	e8 00 00 00 00	 call	 DebuggerTrace
$LN95@zfcp_execu:
  015f5	33 c0		 xor	 eax, eax
  015f7	85 c0		 test	 eax, eax
  015f9	75 a5		 jne	 SHORT $LN39@zfcp_execu
$LN94@zfcp_execu:
  015fb	33 c0		 xor	 eax, eax
  015fd	85 c0		 test	 eax, eax
  015ff	75 89		 jne	 SHORT $LN36@zfcp_execu

; 1268 :         /* Set command reject sense byte, and unit check status */
; 1269 :         dev->sense[0] = SENSE_CR;

  01601	b8 01 00 00 00	 mov	 eax, 1
  01606	48 6b c0 00	 imul	 rax, rax, 0
  0160a	48 8b 8c 24 70
	2d 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01612	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1270 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0161a	48 8b 84 24 b8
	2d 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01622	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN14@zfcp_execu:
$LN1@zfcp_execu:

; 1271 : 
; 1272 :     } /* end switch(code) */
; 1273 : 
; 1274 : } /* end function zfcp_execute_ccw */

  01625	48 8b 8c 24 40
	2d 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0162d	48 33 cc	 xor	 rcx, rsp
  01630	e8 00 00 00 00	 call	 __security_check_cookie
  01635	48 81 c4 58 2d
	00 00		 add	 rsp, 11608		; 00002d58H
  0163c	5f		 pop	 rdi
  0163d	5e		 pop	 rsi
  0163e	c3		 ret	 0
  0163f	90		 npad	 1
$LN135@zfcp_execu:
  01640	00 00 00 00	 DD	 $LN41@zfcp_execu
  01644	00 00 00 00	 DD	 $LN45@zfcp_execu
  01648	00 00 00 00	 DD	 $LN53@zfcp_execu
  0164c	00 00 00 00	 DD	 $LN56@zfcp_execu
  01650	00 00 00 00	 DD	 $LN54@zfcp_execu
  01654	00 00 00 00	 DD	 $LN76@zfcp_execu
  01658	00 00 00 00	 DD	 $LN82@zfcp_execu
  0165c	00 00 00 00	 DD	 $LN64@zfcp_execu
  01660	00 00 00 00	 DD	 $LN69@zfcp_execu
  01664	00 00 00 00	 DD	 $LN58@zfcp_execu
  01668	00 00 00 00	 DD	 $LN61@zfcp_execu
  0166c	00 00 00 00	 DD	 $LN93@zfcp_execu
$LN134@zfcp_execu:
  01670	00		 DB	 0
  01671	01		 DB	 1
  01672	02		 DB	 2
  01673	03		 DB	 3
  01674	0b		 DB	 11
  01675	0b		 DB	 11
  01676	0b		 DB	 11
  01677	0b		 DB	 11
  01678	0b		 DB	 11
  01679	0b		 DB	 11
  0167a	0b		 DB	 11
  0167b	0b		 DB	 11
  0167c	0b		 DB	 11
  0167d	0b		 DB	 11
  0167e	0b		 DB	 11
  0167f	0b		 DB	 11
  01680	0b		 DB	 11
  01681	0b		 DB	 11
  01682	0b		 DB	 11
  01683	04		 DB	 4
  01684	0b		 DB	 11
  01685	0b		 DB	 11
  01686	0b		 DB	 11
  01687	0b		 DB	 11
  01688	0b		 DB	 11
  01689	0b		 DB	 11
  0168a	05		 DB	 5
  0168b	0b		 DB	 11
  0168c	0b		 DB	 11
  0168d	0b		 DB	 11
  0168e	06		 DB	 6
  0168f	0b		 DB	 11
  01690	0b		 DB	 11
  01691	0b		 DB	 11
  01692	0b		 DB	 11
  01693	0b		 DB	 11
  01694	0b		 DB	 11
  01695	0b		 DB	 11
  01696	0b		 DB	 11
  01697	0b		 DB	 11
  01698	0b		 DB	 11
  01699	0b		 DB	 11
  0169a	0b		 DB	 11
  0169b	0b		 DB	 11
  0169c	0b		 DB	 11
  0169d	0b		 DB	 11
  0169e	0b		 DB	 11
  0169f	0b		 DB	 11
  016a0	0b		 DB	 11
  016a1	0b		 DB	 11
  016a2	0b		 DB	 11
  016a3	0b		 DB	 11
  016a4	0b		 DB	 11
  016a5	0b		 DB	 11
  016a6	0b		 DB	 11
  016a7	0b		 DB	 11
  016a8	0b		 DB	 11
  016a9	0b		 DB	 11
  016aa	0b		 DB	 11
  016ab	0b		 DB	 11
  016ac	0b		 DB	 11
  016ad	0b		 DB	 11
  016ae	0b		 DB	 11
  016af	0b		 DB	 11
  016b0	0b		 DB	 11
  016b1	0b		 DB	 11
  016b2	0b		 DB	 11
  016b3	0b		 DB	 11
  016b4	0b		 DB	 11
  016b5	0b		 DB	 11
  016b6	0b		 DB	 11
  016b7	0b		 DB	 11
  016b8	0b		 DB	 11
  016b9	0b		 DB	 11
  016ba	0b		 DB	 11
  016bb	0b		 DB	 11
  016bc	0b		 DB	 11
  016bd	0b		 DB	 11
  016be	0b		 DB	 11
  016bf	0b		 DB	 11
  016c0	0b		 DB	 11
  016c1	0b		 DB	 11
  016c2	0b		 DB	 11
  016c3	0b		 DB	 11
  016c4	0b		 DB	 11
  016c5	0b		 DB	 11
  016c6	0b		 DB	 11
  016c7	0b		 DB	 11
  016c8	0b		 DB	 11
  016c9	0b		 DB	 11
  016ca	0b		 DB	 11
  016cb	0b		 DB	 11
  016cc	0b		 DB	 11
  016cd	0b		 DB	 11
  016ce	0b		 DB	 11
  016cf	0b		 DB	 11
  016d0	0b		 DB	 11
  016d1	0b		 DB	 11
  016d2	0b		 DB	 11
  016d3	0b		 DB	 11
  016d4	0b		 DB	 11
  016d5	0b		 DB	 11
  016d6	0b		 DB	 11
  016d7	0b		 DB	 11
  016d8	0b		 DB	 11
  016d9	0b		 DB	 11
  016da	0b		 DB	 11
  016db	0b		 DB	 11
  016dc	0b		 DB	 11
  016dd	0b		 DB	 11
  016de	0b		 DB	 11
  016df	0b		 DB	 11
  016e0	0b		 DB	 11
  016e1	0b		 DB	 11
  016e2	0b		 DB	 11
  016e3	0b		 DB	 11
  016e4	0b		 DB	 11
  016e5	0b		 DB	 11
  016e6	0b		 DB	 11
  016e7	0b		 DB	 11
  016e8	0b		 DB	 11
  016e9	0b		 DB	 11
  016ea	0b		 DB	 11
  016eb	0b		 DB	 11
  016ec	0b		 DB	 11
  016ed	0b		 DB	 11
  016ee	0b		 DB	 11
  016ef	0b		 DB	 11
  016f0	07		 DB	 7
  016f1	08		 DB	 8
  016f2	0b		 DB	 11
  016f3	0b		 DB	 11
  016f4	0b		 DB	 11
  016f5	0b		 DB	 11
  016f6	0b		 DB	 11
  016f7	0b		 DB	 11
  016f8	0b		 DB	 11
  016f9	0b		 DB	 11
  016fa	0b		 DB	 11
  016fb	0b		 DB	 11
  016fc	0b		 DB	 11
  016fd	0b		 DB	 11
  016fe	0b		 DB	 11
  016ff	0b		 DB	 11
  01700	0b		 DB	 11
  01701	0b		 DB	 11
  01702	0b		 DB	 11
  01703	0b		 DB	 11
  01704	0b		 DB	 11
  01705	0b		 DB	 11
  01706	0b		 DB	 11
  01707	0b		 DB	 11
  01708	0b		 DB	 11
  01709	0b		 DB	 11
  0170a	0b		 DB	 11
  0170b	0b		 DB	 11
  0170c	0b		 DB	 11
  0170d	0b		 DB	 11
  0170e	0b		 DB	 11
  0170f	0b		 DB	 11
  01710	0b		 DB	 11
  01711	0b		 DB	 11
  01712	0b		 DB	 11
  01713	0b		 DB	 11
  01714	0b		 DB	 11
  01715	0b		 DB	 11
  01716	0b		 DB	 11
  01717	0b		 DB	 11
  01718	0b		 DB	 11
  01719	0b		 DB	 11
  0171a	0b		 DB	 11
  0171b	0b		 DB	 11
  0171c	0b		 DB	 11
  0171d	0b		 DB	 11
  0171e	0b		 DB	 11
  0171f	0b		 DB	 11
  01720	0b		 DB	 11
  01721	0b		 DB	 11
  01722	0b		 DB	 11
  01723	0b		 DB	 11
  01724	0b		 DB	 11
  01725	0b		 DB	 11
  01726	0b		 DB	 11
  01727	0b		 DB	 11
  01728	0b		 DB	 11
  01729	0b		 DB	 11
  0172a	0b		 DB	 11
  0172b	0b		 DB	 11
  0172c	0b		 DB	 11
  0172d	0b		 DB	 11
  0172e	0b		 DB	 11
  0172f	0b		 DB	 11
  01730	0b		 DB	 11
  01731	0b		 DB	 11
  01732	0b		 DB	 11
  01733	0b		 DB	 11
  01734	0b		 DB	 11
  01735	0b		 DB	 11
  01736	0b		 DB	 11
  01737	0b		 DB	 11
  01738	0b		 DB	 11
  01739	0b		 DB	 11
  0173a	0b		 DB	 11
  0173b	0b		 DB	 11
  0173c	0b		 DB	 11
  0173d	0b		 DB	 11
  0173e	0b		 DB	 11
  0173f	0b		 DB	 11
  01740	0b		 DB	 11
  01741	0b		 DB	 11
  01742	0b		 DB	 11
  01743	0b		 DB	 11
  01744	0b		 DB	 11
  01745	0b		 DB	 11
  01746	0b		 DB	 11
  01747	0b		 DB	 11
  01748	0b		 DB	 11
  01749	0b		 DB	 11
  0174a	0b		 DB	 11
  0174b	0b		 DB	 11
  0174c	0b		 DB	 11
  0174d	0b		 DB	 11
  0174e	0b		 DB	 11
  0174f	0b		 DB	 11
  01750	0b		 DB	 11
  01751	0b		 DB	 11
  01752	0b		 DB	 11
  01753	09		 DB	 9
  01754	0b		 DB	 11
  01755	0b		 DB	 11
  01756	0b		 DB	 11
  01757	0b		 DB	 11
  01758	0b		 DB	 11
  01759	0b		 DB	 11
  0175a	0b		 DB	 11
  0175b	0b		 DB	 11
  0175c	0b		 DB	 11
  0175d	0b		 DB	 11
  0175e	0b		 DB	 11
  0175f	0b		 DB	 11
  01760	0b		 DB	 11
  01761	0b		 DB	 11
  01762	0b		 DB	 11
  01763	0b		 DB	 11
  01764	0b		 DB	 11
  01765	0b		 DB	 11
  01766	0b		 DB	 11
  01767	0b		 DB	 11
  01768	0b		 DB	 11
  01769	0a		 DB	 10
zfcp_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
rsp24$ = 32
dev$ = 64
desc$ = 72
zfcp_ssqd_desc PROC

; 748  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 749  :     CHSC_RSP24 *rsp24 = (void *)desc;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR desc$[rsp]
  00013	48 89 44 24 20	 mov	 QWORD PTR rsp24$[rsp], rax

; 750  : 
; 751  :     STORE_HW(rsp24->sch, dev->subchan);

  00018	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	0f b7 48 46	 movzx	 ecx, WORD PTR [rax+70]
  00021	e8 00 00 00 00	 call	 _byteswap_ushort
  00026	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  0002b	48 83 c1 02	 add	 rcx, 2
  0002f	0f b7 d0	 movzx	 edx, ax
  00032	e8 00 00 00 00	 call	 store_hw_noswap

; 752  : 
; 753  :     if(dev->pmcw.flag4 & PMCW4_Q)

  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0003c	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  00043	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00048	85 c0		 test	 eax, eax
  0004a	0f 84 1d 01 00
	00		 je	 $LN2@zfcp_ssqd_

; 754  :     {
; 755  :         rsp24->flags |= ( CHSC_FLAG_QDIO_CAPABILITY | CHSC_FLAG_VALIDITY );

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00055	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00058	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00062	88 01		 mov	 BYTE PTR [rcx], al

; 756  : 
; 757  :         rsp24->qdioac1 |= ( AC1_SIGA_INPUT_NEEDED | AC1_SIGA_OUTPUT_NEEDED );

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00069	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  0006d	83 c8 60	 or	 eax, 96			; 00000060H
  00070	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00075	88 41 06	 mov	 BYTE PTR [rcx+6], al

; 758  :         rsp24->qdioac1 |= AC1_AUTOMATIC_SYNC_ON_OUT_PCI;

  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  0007d	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00081	83 c8 04	 or	 eax, 4
  00084	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00089	88 41 06	 mov	 BYTE PTR [rcx+6], al

; 759  : 
; 760  : #if defined(_FEATURE_QEBSM)
; 761  :         if (FACILITY_ENABLED_DEV( HERC_QEBSM ))

  0008c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00093	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  0009a	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  000ad	b9 01 00 00 00	 mov	 ecx, 1
  000b2	48 6b c9 21	 imul	 rcx, rcx, 33		; 00000021H
  000b6	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000ba	83 e0 08	 and	 eax, 8
  000bd	85 c0		 test	 eax, eax
  000bf	74 48		 je	 SHORT $LN3@zfcp_ssqd_

; 762  :         {
; 763  :             STORE_DW(rsp24->sch_token, IOID2TKN((dev->ssid << 16) | dev->subchan));

  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c6	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000ca	c1 e0 10	 shl	 eax, 16
  000cd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d2	0f b7 49 46	 movzx	 ecx, WORD PTR [rcx+70]
  000d6	0b c1		 or	 eax, ecx
  000d8	f7 d0		 not	 eax
  000da	48 98		 cdqe
  000dc	48 8b c8	 mov	 rcx, rax
  000df	e8 00 00 00 00	 call	 _byteswap_uint64
  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  000e9	48 83 c1 10	 add	 rcx, 16
  000ed	48 8b d0	 mov	 rdx, rax
  000f0	e8 00 00 00 00	 call	 store_dw_noswap

; 764  :             rsp24->qdioac1 |= ( AC1_SC_QEBSM_AVAILABLE | AC1_SC_QEBSM_ENABLED );

  000f5	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  000fa	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  000fe	83 c8 03	 or	 eax, 3
  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  00106	88 41 06	 mov	 BYTE PTR [rcx+6], al
$LN3@zfcp_ssqd_:

; 765  :         }
; 766  : #endif /*defined(_FEATURE_QEBSM)*/
; 767  : 
; 768  : #if defined(_FEATURE_QDIO_THININT)
; 769  :         if (FACILITY_ENABLED_DEV( HERC_QDIO_THININT ))

  00109	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00110	48 63 80 88 00
	00 00		 movsxd	 rax, DWORD PTR [rax+136]
  00117	48 6b c0 28	 imul	 rax, rax, 40		; 00000028H
  0011b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00122	48 8d 84 01 a0
	0d 00 00	 lea	 rax, QWORD PTR [rcx+rax+3488]
  0012a	b9 01 00 00 00	 mov	 ecx, 1
  0012f	48 6b c9 21	 imul	 rcx, rcx, 33		; 00000021H
  00133	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00137	83 e0 10	 and	 eax, 16
  0013a	85 c0		 test	 eax, eax
  0013c	74 14		 je	 SHORT $LN4@zfcp_ssqd_

; 770  :             rsp24->qdioac1 |= AC1_AUTOMATIC_SYNC_ON_THININT;

  0013e	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00143	0f b6 40 06	 movzx	 eax, BYTE PTR [rax+6]
  00147	83 c8 08	 or	 eax, 8
  0014a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR rsp24$[rsp]
  0014f	88 41 06	 mov	 BYTE PTR [rcx+6], al
$LN4@zfcp_ssqd_:

; 771  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 772  : 
; 773  : #if 1 // ZZTEST
; 774  :           rsp24->icnt = QDIO_MAXQ;

  00152	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00157	c6 40 09 20	 mov	 BYTE PTR [rax+9], 32	; 00000020H

; 775  :           rsp24->ocnt = QDIO_MAXQ;

  0015b	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00160	c6 40 0b 20	 mov	 BYTE PTR [rax+11], 32	; 00000020H

; 776  :           rsp24->mbccnt = 0x04;

  00164	48 8b 44 24 20	 mov	 rax, QWORD PTR rsp24$[rsp]
  00169	c6 40 0d 04	 mov	 BYTE PTR [rax+13], 4
$LN2@zfcp_ssqd_:

; 777  : #endif
; 778  :     }
; 779  : 
; 780  :     return 0;

  0016d	33 c0		 xor	 eax, eax

; 781  : }

  0016f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00173	c3		 ret	 0
zfcp_ssqd_desc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
ks$ = 48
kc$ = 49
opc$ = 52
req21$ = 56
alsi$ = 64
dsci$ = 72
dev$ = 96
desc$ = 104
zfcp_set_sci PROC

; 701  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 702  : CHSC_REQ21 *req21 = (void *)desc;

  0000e	48 8b 44 24 68	 mov	 rax, QWORD PTR desc$[rsp]
  00013	48 89 44 24 38	 mov	 QWORD PTR req21$[rsp], rax

; 703  : RADR alsi, dsci;
; 704  : BYTE ks, kc;
; 705  : U16 opc;
; 706  : 
; 707  :     FETCH_HW(opc,req21->opcode);

  00018	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0001d	48 83 c0 04	 add	 rax, 4
  00021	48 8b c8	 mov	 rcx, rax
  00024	e8 00 00 00 00	 call	 fetch_hw_noswap
  00029	0f b7 c8	 movzx	 ecx, ax
  0002c	e8 00 00 00 00	 call	 _byteswap_ushort
  00031	66 89 44 24 34	 mov	 WORD PTR opc$[rsp], ax

; 708  : 
; 709  :     if(opc)

  00036	0f b7 44 24 34	 movzx	 eax, WORD PTR opc$[rsp]
  0003b	85 c0		 test	 eax, eax
  0003d	74 0a		 je	 SHORT $LN2@zfcp_set_s

; 710  :         return 3; // Invalid operation code

  0003f	b8 03 00 00 00	 mov	 eax, 3
  00044	e9 39 01 00 00	 jmp	 $LN1@zfcp_set_s
$LN2@zfcp_set_s:

; 711  : 
; 712  :     FETCH_DW(alsi, req21->alsi);

  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0004e	48 83 c0 10	 add	 rax, 16
  00052	48 8b c8	 mov	 rcx, rax
  00055	e8 00 00 00 00	 call	 fetch_dw_noswap
  0005a	48 8b c8	 mov	 rcx, rax
  0005d	e8 00 00 00 00	 call	 _byteswap_uint64
  00062	48 89 44 24 40	 mov	 QWORD PTR alsi$[rsp], rax

; 713  :     ks = req21->sk & CHSC_REQ21_KS;

  00067	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0006c	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  00070	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  00075	88 44 24 30	 mov	 BYTE PTR ks$[rsp], al

; 714  : 
; 715  :     FETCH_DW(dsci, req21->dsci);

  00079	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0007e	48 83 c0 18	 add	 rax, 24
  00082	48 8b c8	 mov	 rcx, rax
  00085	e8 00 00 00 00	 call	 fetch_dw_noswap
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	e8 00 00 00 00	 call	 _byteswap_uint64
  00092	48 89 44 24 48	 mov	 QWORD PTR dsci$[rsp], rax

; 716  :     kc = (req21->sk & CHSC_REQ21_KC) << 4;

  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR req21$[rsp]
  0009c	0f b6 40 20	 movzx	 eax, BYTE PTR [rax+32]
  000a0	83 e0 0f	 and	 eax, 15
  000a3	c1 e0 04	 shl	 eax, 4
  000a6	88 44 24 31	 mov	 BYTE PTR kc$[rsp], al

; 717  : 
; 718  :     if(alsi && dsci)

  000aa	48 83 7c 24 40
	00		 cmp	 QWORD PTR alsi$[rsp], 0
  000b0	74 7d		 je	 SHORT $LN3@zfcp_set_s
  000b2	48 83 7c 24 48
	00		 cmp	 QWORD PTR dsci$[rsp], 0
  000b8	74 75		 je	 SHORT $LN3@zfcp_set_s

; 719  :     {
; 720  :         if(STORCHK(alsi,0,ks,STORKEY_CHANGE,dev)
; 721  :           || STORCHK(dsci,0,kc,STORKEY_CHANGE,dev))

  000ba	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c4	41 b1 02	 mov	 r9b, 2
  000c7	44 0f b6 44 24
	30		 movzx	 r8d, BYTE PTR ks$[rsp]
  000cd	33 d2		 xor	 edx, edx
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR alsi$[rsp]
  000d4	e8 00 00 00 00	 call	 STORCHK
  000d9	0f b6 c0	 movzx	 eax, al
  000dc	85 c0		 test	 eax, eax
  000de	75 26		 jne	 SHORT $LN7@zfcp_set_s
  000e0	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000e5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ea	41 b1 02	 mov	 r9b, 2
  000ed	44 0f b6 44 24
	31		 movzx	 r8d, BYTE PTR kc$[rsp]
  000f3	33 d2		 xor	 edx, edx
  000f5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dsci$[rsp]
  000fa	e8 00 00 00 00	 call	 STORCHK
  000ff	0f b6 c0	 movzx	 eax, al
  00102	85 c0		 test	 eax, eax
  00104	74 18		 je	 SHORT $LN5@zfcp_set_s
$LN7@zfcp_set_s:

; 722  :         {
; 723  :             dev->qdio.thinint = 0;

  00106	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0010b	c7 80 38 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4920], 0

; 724  :             return 3;

  00115	b8 03 00 00 00	 mov	 eax, 3
  0011a	eb 66		 jmp	 SHORT $LN1@zfcp_set_s

; 725  :         }

  0011c	eb 0f		 jmp	 SHORT $LN6@zfcp_set_s
$LN5@zfcp_set_s:

; 726  :         else
; 727  :             dev->qdio.thinint = 1;

  0011e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00123	c7 80 38 13 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+4920], 1
$LN6@zfcp_set_s:

; 728  : 
; 729  :     }

  0012d	eb 0f		 jmp	 SHORT $LN4@zfcp_set_s
$LN3@zfcp_set_s:

; 730  :     else
; 731  :         dev->qdio.thinint = 0;

  0012f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00134	c7 80 38 13 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4920], 0
$LN4@zfcp_set_s:

; 732  : 
; 733  :     dev->qdio.alsi = alsi;

  0013e	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00143	48 8b 4c 24 40	 mov	 rcx, QWORD PTR alsi$[rsp]
  00148	48 89 88 68 1b
	00 00		 mov	 QWORD PTR [rax+7016], rcx

; 734  :     dev->qdio.ks   = ks;

  0014f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00154	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR ks$[rsp]
  00159	88 88 78 1b 00
	00		 mov	 BYTE PTR [rax+7032], cl

; 735  : 
; 736  :     dev->qdio.dsci = dsci;

  0015f	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00164	48 8b 4c 24 48	 mov	 rcx, QWORD PTR dsci$[rsp]
  00169	48 89 88 70 1b
	00 00		 mov	 QWORD PTR [rax+7024], rcx

; 737  :     dev->qdio.kc   = kc;

  00170	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00175	0f b6 4c 24 31	 movzx	 ecx, BYTE PTR kc$[rsp]
  0017a	88 88 79 1b 00
	00		 mov	 BYTE PTR [rax+7033], cl

; 738  : 
; 739  :     return 0;

  00180	33 c0		 xor	 eax, eax
$LN1@zfcp_set_s:

; 740  : }

  00182	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00186	c3		 ret	 0
zfcp_set_sci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
grp$ = 32
dev$ = 64
zfcp_close_device PROC

; 665  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 666  : ZFCP_GRP *grp = (ZFCP_GRP*)dev->group->grp_data;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00016	48 89 44 24 20	 mov	 QWORD PTR grp$[rsp], rax

; 667  : 
; 668  :     if(!dev->member && dev->group->grp_data)

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00020	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  00024	0f 85 2d 01 00
	00		 jne	 $LN2@zfcp_close
  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00033	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00038	0f 84 19 01 00
	00		 je	 $LN2@zfcp_close

; 669  :     {
; 670  :         if(grp->ppfd[0])

  0003e	b8 04 00 00 00	 mov	 eax, 4
  00043	48 6b c0 00	 imul	 rax, rax, 0
  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  0004c	83 7c 01 2c 00	 cmp	 DWORD PTR [rcx+rax+44], 0
  00051	74 1c		 je	 SHORT $LN3@zfcp_close

; 671  :             close_pipe(grp->ppfd[0]);

  00053	b8 04 00 00 00	 mov	 eax, 4
  00058	48 6b c0 00	 imul	 rax, rax, 0
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  00061	48 63 44 01 2c	 movsxd	 rax, DWORD PTR [rcx+rax+44]
  00066	48 8b c8	 mov	 rcx, rax
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN3@zfcp_close:

; 672  :         if(grp->ppfd[1])

  0006f	b8 04 00 00 00	 mov	 eax, 4
  00074	48 6b c0 01	 imul	 rax, rax, 1
  00078	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  0007d	83 7c 01 2c 00	 cmp	 DWORD PTR [rcx+rax+44], 0
  00082	74 1c		 je	 SHORT $LN4@zfcp_close

; 673  :             close_pipe(grp->ppfd[1]);

  00084	b8 04 00 00 00	 mov	 eax, 4
  00089	48 6b c0 01	 imul	 rax, rax, 1
  0008d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  00092	48 63 44 01 2c	 movsxd	 rax, DWORD PTR [rcx+rax+44]
  00097	48 8b c8	 mov	 rcx, rax
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
$LN4@zfcp_close:

; 674  : 
; 675  :         if(grp->wwpn)

  000a0	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000a5	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  000aa	74 0f		 je	 SHORT $LN5@zfcp_close

; 676  :             free(grp->wwpn);

  000ac	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000b1	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@zfcp_close:

; 677  :         if(grp->lun)

  000bb	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000c0	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  000c5	74 0f		 je	 SHORT $LN6@zfcp_close

; 678  :             free(grp->lun);

  000c7	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000cc	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN6@zfcp_close:

; 679  :         if(grp->brlba)

  000d6	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000db	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  000e0	74 0f		 je	 SHORT $LN7@zfcp_close

; 680  :             free(grp->brlba);

  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000e7	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@zfcp_close:

; 681  : 
; 682  :         if(grp->rspbf)

  000f1	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000f6	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000fb	74 0f		 je	 SHORT $LN8@zfcp_close

; 683  :             free(grp->rspbf);

  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  00102	48 8b 48 38	 mov	 rcx, QWORD PTR [rax+56]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN8@zfcp_close:

; 684  : 
; 685  :         destroy_condition(&grp->qcond);

  0010c	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  00111	48 8b c8	 mov	 rcx, rax
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_condition

; 686  :         destroy_lock(&grp->qlock);

  0011a	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  0011f	48 83 c0 08	 add	 rax, 8
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170224
  0012a	48 8b c8	 mov	 rcx, rax
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_destroy_lock

; 687  : 
; 688  :         free(dev->group->grp_data);

  00133	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00138	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0013c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 689  :         dev->group->grp_data = NULL;

  00146	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0014b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0014f	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN2@zfcp_close:

; 690  :     }
; 691  : 
; 692  :     return 0;

  00157	33 c0		 xor	 eax, eax

; 693  : } /* end function zfcp_close_device */

  00159	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0015d	c3		 ret	 0
zfcp_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
$T1 = 48
tv95 = 56
tv132 = 64
filename$ = 80
__$ArrayPad$ = 352
dev$ = 384
devclass$ = 392
buflen$ = 400
buffer$ = 408
zfcp_query_device PROC

; 648  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 78 01
	00 00		 sub	 rsp, 376		; 00000178H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 649  :     char filename[ PATH_MAX + 1 ];      /* full path or just name    */
; 650  : 
; 651  :     BEGIN_DEVICE_CLASS_QUERY( "FCP", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 88
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@zfcp_query
  00038	48 8b 84 24 88
	01 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170193
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@zfcp_query:
  0004a	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@zfcp_query
  00055	48 83 bc 24 88
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@zfcp_query
  00060	83 bc 24 90 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@zfcp_query
  0006a	48 83 bc 24 98
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@zfcp_query
$LN4@zfcp_query:
  00075	e9 32 01 00 00	 jmp	 $LN1@zfcp_query
$LN3@zfcp_query:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@zfcp_query
  00091	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170199
  000c3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@zfcp_query
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 30	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 30
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN9@zfcp_query
  000ea	eb 05		 jmp	 SHORT $LN10@zfcp_query
$LN9@zfcp_query:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN10@zfcp_query:
  000f1	48 8b 44 24 30	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 50 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@zfcp_query:
  000fb	eb 22		 jmp	 SHORT $LN6@zfcp_query
$LN5@zfcp_query:
  000fd	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 50	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@zfcp_query:

; 652  : 
; 653  :     snprintf( buffer, buflen, "%s%s"

  0011f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00127	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  0012e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00133	85 c0		 test	 eax, eax
  00135	74 0e		 je	 SHORT $LN11@zfcp_query
  00137	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170200
  0013e	48 89 44 24 38	 mov	 QWORD PTR tv95[rsp], rax
  00143	eb 0c		 jmp	 SHORT $LN12@zfcp_query
$LN11@zfcp_query:
  00145	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170201
  0014c	48 89 44 24 38	 mov	 QWORD PTR tv95[rsp], rax
$LN12@zfcp_query:
  00151	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00159	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0015d	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  00161	75 0e		 jne	 SHORT $LN13@zfcp_query
  00163	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170202
  0016a	48 89 44 24 40	 mov	 QWORD PTR tv132[rsp], rax
  0016f	eb 0c		 jmp	 SHORT $LN14@zfcp_query
$LN13@zfcp_query:
  00171	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170203
  00178	48 89 44 24 40	 mov	 QWORD PTR tv132[rsp], rax
$LN14@zfcp_query:
  0017d	48 63 84 24 90
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00185	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv95[rsp]
  0018a	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0018f	4c 8b 4c 24 40	 mov	 r9, QWORD PTR tv132[rsp]
  00194	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170204
  0019b	48 8b d0	 mov	 rdx, rax
  0019e	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  001a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN1@zfcp_query:
$LN8@zfcp_query:

; 654  :         , (dev->group->acount == ZFCP_GROUP_SIZE) ? "" : "*Incomplete "
; 655  :         , (dev->scsw.flag2 & SCSW2_Q) ? "QDIO" : ""
; 656  :         );
; 657  : 
; 658  : } /* end function zfcp_query_device */

  001ac	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b4	48 33 cc	 xor	 rcx, rsp
  001b7	e8 00 00 00 00	 call	 __security_check_cookie
  001bc	48 81 c4 78 01
	00 00		 add	 rsp, 376		; 00000178H
  001c3	c3		 ret	 0
zfcp_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
i$ = 64
grp$ = 72
c$1 = 80
chpid$2 = 84
grouped$ = 88
tv283 = 92
tv317 = 96
tv285 = 104
tv319 = 112
dev$ = 160
argc$ = 168
argv$ = 176
zfcp_init_handler PROC

; 533  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	56		 push	 rsi
  0000f	57		 push	 rdi
  00010	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 534  : ZFCP_GRP *grp;
; 535  : int grouped;
; 536  : int i;
; 537  : 
; 538  :     LOGMSG( "ZFCP Experimental Driver - Incomplete - Work In Progress\n" );

  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170128
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00033	41 b9 03 00 00
	00		 mov	 r9d, 3
  00039	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170129
  00040	ba 1a 02 00 00	 mov	 edx, 538		; 0000021aH
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170130
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 539  : 
; 540  :     if(!dev->group)

  00052	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0005f	0f 85 41 02 00
	00		 jne	 $LN14@zfcp_init_

; 541  :     {
; 542  :         dev->rcd = &zfcp_read_configuration_data;

  00065	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:zfcp_read_configuration_data
  00074	48 89 88 b8 02
	00 00		 mov	 QWORD PTR [rax+696], rcx

; 543  : 
; 544  :         dev->numdevid = sizeof(sense_id_bytes);

  0007b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00083	c7 80 64 04 00
	00 1c 00 00 00	 mov	 DWORD PTR [rax+1124], 28

; 545  :         memcpy(dev->devid, sense_id_bytes, sizeof(sense_id_bytes));

  0008d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:sense_id_bytes
  0009c	48 8d b8 68 04
	00 00		 lea	 rdi, QWORD PTR [rax+1128]
  000a3	48 8b f1	 mov	 rsi, rcx
  000a6	b9 1c 00 00 00	 mov	 ecx, 28
  000ab	f3 a4		 rep movsb

; 546  : 
; 547  :         dev->devtype = dev->devid[1] << 8 | dev->devid[2];

  000ad	b8 01 00 00 00	 mov	 eax, 1
  000b2	48 6b c0 01	 imul	 rax, rax, 1
  000b6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000be	0f b6 84 01 68
	04 00 00	 movzx	 eax, BYTE PTR [rcx+rax+1128]
  000c6	c1 e0 08	 shl	 eax, 8
  000c9	b9 01 00 00 00	 mov	 ecx, 1
  000ce	48 6b c9 02	 imul	 rcx, rcx, 2
  000d2	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000da	0f b6 8c 0a 68
	04 00 00	 movzx	 ecx, BYTE PTR [rdx+rcx+1128]
  000e2	0b c1		 or	 eax, ecx
  000e4	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ec	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax

; 548  : 
; 549  :         dev->pmcw.flag4 |= PMCW4_Q;

  000f0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f8	0f b6 80 f0 02
	00 00		 movzx	 eax, BYTE PTR [rax+752]
  000ff	0f ba e8 07	 bts	 eax, 7
  00103	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010b	88 81 f0 02 00
	00		 mov	 BYTE PTR [rcx+752], al

; 550  : 
; 551  :         if((!(grouped = group_device(dev,ZFCP_GROUP_SIZE)) && !dev->member) || ZFCP_GROUP_SIZE == 1)

  00111	ba 01 00 00 00	 mov	 edx, 1
  00116	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_group_device
  00124	89 44 24 58	 mov	 DWORD PTR grouped$[rsp], eax
  00128	83 7c 24 58 00	 cmp	 DWORD PTR grouped$[rsp], 0
  0012d	75 0e		 jne	 SHORT $LN19@zfcp_init_
  0012f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00137	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  0013b	74 0b		 je	 SHORT $LN18@zfcp_init_
$LN19@zfcp_init_:
  0013d	33 c0		 xor	 eax, eax
  0013f	83 f8 01	 cmp	 eax, 1
  00142	0f 84 47 01 00
	00		 je	 $LN16@zfcp_init_
$LN18@zfcp_init_:

; 552  :         {
; 553  :             dev->group->grp_data = grp = malloc(sizeof(ZFCP_GRP));

  00148	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00153	48 89 44 24 48	 mov	 QWORD PTR grp$[rsp], rax
  00158	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00160	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00164	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00169	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 554  :             memset (grp, 0, sizeof(ZFCP_GRP));

  0016d	48 8b 7c 24 48	 mov	 rdi, QWORD PTR grp$[rsp]
  00172	33 c0		 xor	 eax, eax
  00174	b9 50 00 00 00	 mov	 ecx, 80			; 00000050H
  00179	f3 aa		 rep stosb

; 555  : 
; 556  :             initialize_condition(&grp->qcond);

  0017b	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00180	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170137
  00187	48 8b c8	 mov	 rcx, rax
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_condition

; 557  :             initialize_lock(&grp->qlock);

  00190	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00195	48 83 c0 08	 add	 rax, 8
  00199	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170138
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170139
  001a7	48 8b c8	 mov	 rcx, rax
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_initialize_lock
$LN4@zfcp_init_:

; 558  : 
; 559  :             /* Open write signalling pipe */
; 560  :             /* Check your retrun codes, Jan.                         */
; 561  :             VERIFY(!create_pipe(grp->ppfd));

  001b0	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  001b5	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  001b9	4c 8b c8	 mov	 r9, rax
  001bc	45 33 c0	 xor	 r8d, r8d
  001bf	ba 01 00 00 00	 mov	 edx, 1
  001c4	b9 02 00 00 00	 mov	 ecx, 2
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socketpair
  001cf	85 c0		 test	 eax, eax
  001d1	74 5c		 je	 SHORT $LN20@zfcp_init_
$LN7@zfcp_init_:
  001d3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170141
  001da	41 b8 31 02 00
	00		 mov	 r8d, 561		; 00000231H
  001e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170142
  001e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170143
  001ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001fa	85 c0		 test	 eax, eax
  001fc	74 20		 je	 SHORT $LN21@zfcp_init_
  001fe	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170145
  00205	41 b8 31 02 00
	00		 mov	 r8d, 561		; 00000231H
  0020b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170146
  00212	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170147
  00219	e8 00 00 00 00	 call	 DebuggerTrace
$LN21@zfcp_init_:
  0021e	33 c0		 xor	 eax, eax
  00220	85 c0		 test	 eax, eax
  00222	75 af		 jne	 SHORT $LN7@zfcp_init_
  00224	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0022a	85 c0		 test	 eax, eax
  0022c	74 01		 je	 SHORT $LN22@zfcp_init_
  0022e	cc		 int	 3
$LN22@zfcp_init_:
$LN20@zfcp_init_:
  0022f	33 c0		 xor	 eax, eax
  00231	85 c0		 test	 eax, eax
  00233	0f 85 77 ff ff
	ff		 jne	 $LN4@zfcp_init_

; 562  :             grp->ttfd = grp->ppfd[0]; // ZZ TEMP

  00239	b8 04 00 00 00	 mov	 eax, 4
  0023e	48 6b c0 00	 imul	 rax, rax, 0
  00242	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00247	48 8b 54 24 48	 mov	 rdx, QWORD PTR grp$[rsp]
  0024c	8b 44 02 2c	 mov	 eax, DWORD PTR [rdx+rax+44]
  00250	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 563  : 
; 564  :             /* Set Non-Blocking mode */
; 565  :             socket_set_blocking_mode(grp->ppfd[0],0);

  00253	b8 04 00 00 00	 mov	 eax, 4
  00258	48 6b c0 00	 imul	 rax, rax, 0
  0025c	33 d2		 xor	 edx, edx
  0025e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00263	8b 4c 01 2c	 mov	 ecx, DWORD PTR [rcx+rax+44]
  00267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket_set_blocking_mode

; 566  : 
; 567  :             /* Allocate reponse buffer */
; 568  :             grp->rspbf = malloc(RSP_BUFSZ);

  0026d	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00278	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  0027d	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 569  :             grp->rspsz = 0;

  00281	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00286	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 570  : 
; 571  :             /* Set defaults */
; 572  :         }

  0028d	eb 15		 jmp	 SHORT $LN17@zfcp_init_
$LN16@zfcp_init_:

; 573  :         else
; 574  :             grp = dev->group->grp_data;

  0028f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00297	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0029b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0029f	48 89 44 24 48	 mov	 QWORD PTR grp$[rsp], rax
$LN17@zfcp_init_:

; 575  :     }

  002a4	eb 15		 jmp	 SHORT $LN15@zfcp_init_
$LN14@zfcp_init_:

; 576  :     else
; 577  :         grp = dev->group->grp_data;

  002a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ae	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  002b2	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  002b6	48 89 44 24 48	 mov	 QWORD PTR grp$[rsp], rax
$LN15@zfcp_init_:

; 578  : 
; 579  :     // process all command line options here
; 580  :     for(i = 0; i < argc; i++)

  002bb	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  002c3	eb 0a		 jmp	 SHORT $LN10@zfcp_init_
$LN8@zfcp_init_:
  002c5	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  002c9	ff c0		 inc	 eax
  002cb	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN10@zfcp_init_:
  002cf	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  002d6	39 44 24 40	 cmp	 DWORD PTR i$[rsp], eax
  002da	0f 8d 81 03 00
	00		 jge	 $LN9@zfcp_init_

; 581  :     {
; 582  :         if(!strcasecmp("portname",argv[i]) && (i+1) < argc)

  002e0	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  002e5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002ed	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  002f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170151
  002f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  002fe	85 c0		 test	 eax, eax
  00300	75 5e		 jne	 SHORT $LN23@zfcp_init_
  00302	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00306	ff c0		 inc	 eax
  00308	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  0030f	7d 4f		 jge	 SHORT $LN23@zfcp_init_

; 583  :         {
; 584  :             if(grp->wwpn)

  00311	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00316	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0031b	74 0f		 je	 SHORT $LN25@zfcp_init_

; 585  :                 free(grp->wwpn);

  0031d	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00322	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00326	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN25@zfcp_init_:

; 586  :             grp->wwpn = strdup(argv[++i]);

  0032c	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00330	ff c0		 inc	 eax
  00332	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00336	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0033b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00343	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0034d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00352	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 587  :             continue;

  00356	e9 6a ff ff ff	 jmp	 $LN8@zfcp_init_

; 588  :         }

  0035b	e9 fc 02 00 00	 jmp	 $LN24@zfcp_init_
$LN23@zfcp_init_:

; 589  :         else if(!strcasecmp("lun",argv[i]) && (i+1) < argc)

  00360	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00365	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0036d	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00371	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170155
  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0037e	85 c0		 test	 eax, eax
  00380	75 5e		 jne	 SHORT $LN26@zfcp_init_
  00382	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00386	ff c0		 inc	 eax
  00388	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  0038f	7d 4f		 jge	 SHORT $LN26@zfcp_init_

; 590  :         {
; 591  :             if(grp->lun)

  00391	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00396	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  0039b	74 0f		 je	 SHORT $LN28@zfcp_init_

; 592  :                 free(grp->lun);

  0039d	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  003a2	48 8b 48 18	 mov	 rcx, QWORD PTR [rax+24]
  003a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN28@zfcp_init_:

; 593  :             grp->lun = strdup(argv[++i]);

  003ac	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  003b0	ff c0		 inc	 eax
  003b2	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  003b6	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003bb	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003c3	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  003c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  003cd	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  003d2	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 594  :             continue;

  003d6	e9 ea fe ff ff	 jmp	 $LN8@zfcp_init_

; 595  :         }

  003db	e9 7c 02 00 00	 jmp	 $LN27@zfcp_init_
$LN26@zfcp_init_:

; 596  :         else if(!strcasecmp("br_lba",argv[i]) && (i+1) < argc)

  003e0	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  003e5	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003ed	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  003f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170159
  003f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  003fe	85 c0		 test	 eax, eax
  00400	75 5e		 jne	 SHORT $LN29@zfcp_init_
  00402	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00406	ff c0		 inc	 eax
  00408	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  0040f	7d 4f		 jge	 SHORT $LN29@zfcp_init_

; 597  :         {
; 598  :             if(grp->brlba)

  00411	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00416	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0041b	74 0f		 je	 SHORT $LN31@zfcp_init_

; 599  :                 free(grp->brlba);

  0041d	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  00422	48 8b 48 20	 mov	 rcx, QWORD PTR [rax+32]
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN31@zfcp_init_:

; 600  :             grp->brlba = strdup(argv[++i]);

  0042c	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  00430	ff c0		 inc	 eax
  00432	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  00436	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  0043b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00443	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00447	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0044d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR grp$[rsp]
  00452	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 601  :             continue;

  00456	e9 6a fe ff ff	 jmp	 $LN8@zfcp_init_

; 602  :         }

  0045b	e9 fc 01 00 00	 jmp	 $LN30@zfcp_init_
$LN29@zfcp_init_:

; 603  :         else if(!strcasecmp("chpid",argv[i]) && (i+1) < argc)

  00460	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00465	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0046d	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00471	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170163
  00478	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0047e	85 c0		 test	 eax, eax
  00480	0f 85 f6 00 00
	00		 jne	 $LN32@zfcp_init_
  00486	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0048a	ff c0		 inc	 eax
  0048c	3b 84 24 a8 00
	00 00		 cmp	 eax, DWORD PTR argc$[rsp]
  00493	0f 8d e3 00 00
	00		 jge	 $LN32@zfcp_init_

; 604  :         {
; 605  :             int chpid;
; 606  :             char c;
; 607  :             if(sscanf(argv[++i], "%x%c", &chpid, &c) != 1 || chpid < 0x00 || chpid > 0xFF)

  00499	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0049d	ff c0		 inc	 eax
  0049f	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
  004a3	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  004a8	4c 8d 4c 24 50	 lea	 r9, QWORD PTR c$1[rsp]
  004ad	4c 8d 44 24 54	 lea	 r8, QWORD PTR chpid$2[rsp]
  004b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170167
  004b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004c1	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004c5	e8 00 00 00 00	 call	 sscanf
  004ca	83 f8 01	 cmp	 eax, 1
  004cd	75 11		 jne	 SHORT $LN36@zfcp_init_
  004cf	83 7c 24 54 00	 cmp	 DWORD PTR chpid$2[rsp], 0
  004d4	7c 0a		 jl	 SHORT $LN36@zfcp_init_
  004d6	81 7c 24 54 ff
	00 00 00	 cmp	 DWORD PTR chpid$2[rsp], 255 ; 000000ffH
  004de	7e 75		 jle	 SHORT $LN34@zfcp_init_
$LN36@zfcp_init_:

; 608  :                 LOGMSG( "ZFCP: Invalid channel path id %s for device %4.4X\n", argv[i], dev->devnum );

  004e0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004e8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  004ec	89 44 24 5c	 mov	 DWORD PTR tv283[rsp], eax
  004f0	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  004f5	48 89 4c 24 68	 mov	 QWORD PTR tv285[rsp], rcx
  004fa	b9 01 00 00 00	 mov	 ecx, 1
  004ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00505	8b 4c 24 5c	 mov	 ecx, DWORD PTR tv283[rsp]
  00509	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0050d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00515	48 8b 54 24 68	 mov	 rdx, QWORD PTR tv285[rsp]
  0051a	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  0051e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00523	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170168
  0052a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0052f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00534	41 b9 03 00 00
	00		 mov	 r9d, 3
  0053a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170169
  00541	ba 60 02 00 00	 mov	 edx, 608		; 00000260H
  00546	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170170
  0054d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00553	eb 1d		 jmp	 SHORT $LN35@zfcp_init_
$LN34@zfcp_init_:

; 609  : 
; 610  :             else
; 611  :                 dev->pmcw.chpid[0] = chpid;

  00555	b8 01 00 00 00	 mov	 eax, 1
  0055a	48 6b c0 00	 imul	 rax, rax, 0
  0055e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00566	0f b6 54 24 54	 movzx	 edx, BYTE PTR chpid$2[rsp]
  0056b	88 94 01 fc 02
	00 00		 mov	 BYTE PTR [rcx+rax+764], dl
$LN35@zfcp_init_:

; 612  :             continue;

  00572	e9 4e fd ff ff	 jmp	 $LN8@zfcp_init_

; 613  :         }

  00577	e9 e0 00 00 00	 jmp	 $LN33@zfcp_init_
$LN32@zfcp_init_:

; 614  :         else
; 615  : #if defined(ZFCP_DEBUG) || defined(IFF_DEBUG)
; 616  :         if(!strcasecmp("debug",argv[i]))

  0057c	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  00581	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00589	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  0058d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170173
  00594	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0059a	85 c0		 test	 eax, eax
  0059c	75 16		 jne	 SHORT $LN37@zfcp_init_

; 617  :         {
; 618  :             grp->debug = 1;

  0059e	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  005a3	c7 40 4c 01 00
	00 00		 mov	 DWORD PTR [rax+76], 1

; 619  :             continue;

  005aa	e9 16 fd ff ff	 jmp	 $LN8@zfcp_init_

; 620  :         }

  005af	e9 a8 00 00 00	 jmp	 $LN38@zfcp_init_
$LN37@zfcp_init_:

; 621  :         else
; 622  :         if(!strcasecmp("nodebug",argv[i]))

  005b4	48 63 44 24 40	 movsxd	 rax, DWORD PTR i$[rsp]
  005b9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005c1	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  005c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170176
  005cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  005d2	85 c0		 test	 eax, eax
  005d4	75 13		 jne	 SHORT $LN39@zfcp_init_

; 623  :         {
; 624  :             grp->debug = 0;

  005d6	48 8b 44 24 48	 mov	 rax, QWORD PTR grp$[rsp]
  005db	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [rax+76], 0

; 625  :             continue;

  005e2	e9 de fc ff ff	 jmp	 $LN8@zfcp_init_

; 626  :         }

  005e7	eb 73		 jmp	 SHORT $LN40@zfcp_init_
$LN39@zfcp_init_:

; 627  :         else
; 628  : #endif
; 629  :             LOGMSG( "ZFCP: Invalid option %s for device %4.4X\n", argv[i], dev->devnum );

  005e9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005f1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  005f5	89 44 24 60	 mov	 DWORD PTR tv317[rsp], eax
  005f9	48 63 4c 24 40	 movsxd	 rcx, DWORD PTR i$[rsp]
  005fe	48 89 4c 24 70	 mov	 QWORD PTR tv319[rsp], rcx
  00603	b9 01 00 00 00	 mov	 ecx, 1
  00608	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0060e	8b 4c 24 60	 mov	 ecx, DWORD PTR tv317[rsp]
  00612	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00616	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0061e	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv319[rsp]
  00623	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00627	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0062c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170177
  00633	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00638	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0063d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00643	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170178
  0064a	ba 75 02 00 00	 mov	 edx, 629		; 00000275H
  0064f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170179
  00656	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@zfcp_init_:
$LN38@zfcp_init_:
$LN33@zfcp_init_:
$LN30@zfcp_init_:
$LN27@zfcp_init_:
$LN24@zfcp_init_:

; 630  : 
; 631  :     }

  0065c	e9 64 fc ff ff	 jmp	 $LN8@zfcp_init_
$LN9@zfcp_init_:

; 632  : 
; 633  : #if ZFCP_GROUP_SIZE > 1
; 634  :     if(grouped)
; 635  : #endif
; 636  :         for(i = 0; i < ZFCP_GROUP_SIZE; i++)

  00661	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00669	eb 0a		 jmp	 SHORT $LN13@zfcp_init_
$LN11@zfcp_init_:
  0066b	8b 44 24 40	 mov	 eax, DWORD PTR i$[rsp]
  0066f	ff c0		 inc	 eax
  00671	89 44 24 40	 mov	 DWORD PTR i$[rsp], eax
$LN13@zfcp_init_:
  00675	83 7c 24 40 01	 cmp	 DWORD PTR i$[rsp], 1
  0067a	7d 47		 jge	 SHORT $LN12@zfcp_init_

; 637  :             dev->group->memdev[i]->fla[0] = dev->group->memdev[0]->devnum;

  0067c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00684	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00688	b9 08 00 00 00	 mov	 ecx, 8
  0068d	48 6b c9 00	 imul	 rcx, rcx, 0
  00691	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  00696	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0069e	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  006a2	48 63 54 24 40	 movsxd	 rdx, DWORD PTR i$[rsp]
  006a7	48 8b 4c d1 10	 mov	 rcx, QWORD PTR [rcx+rdx*8+16]
  006ac	ba 02 00 00 00	 mov	 edx, 2
  006b1	48 6b d2 00	 imul	 rdx, rdx, 0
  006b5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  006b9	66 89 84 11 bc
	05 00 00	 mov	 WORD PTR [rcx+rdx+1468], ax
  006c1	eb a8		 jmp	 SHORT $LN11@zfcp_init_
$LN12@zfcp_init_:

; 638  : 
; 639  :     return 0;

  006c3	33 c0		 xor	 eax, eax

; 640  : } /* end function zfcp_init_handler */

  006c5	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  006cc	5f		 pop	 rdi
  006cd	5e		 pop	 rsi
  006ce	c3		 ret	 0
zfcp_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
tv151 = 0
copylen$ = 4
cua$ = 8
dev_ned$ = 16
ctl_ned$ = 24
tkn_ned$ = 32
gen_neq$ = 40
work$ = 48
__$ArrayPad$ = 176
dev$ = 224
buffer$ = 232
bufsz$ = 240
zfcp_read_configuration_data PROC

; 492  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 493  :     int   copylen;
; 494  :     BYTE  work[ sizeof( configuration_data ) ];
; 495  : 
; 496  :     NED *dev_ned = (NED*)&work[0];  /* Device NED is first       */

  0002a	b8 01 00 00 00	 mov	 eax, 1
  0002f	48 6b c0 00	 imul	 rax, rax, 0
  00033	48 8d 44 04 30	 lea	 rax, QWORD PTR work$[rsp+rax]
  00038	48 89 44 24 10	 mov	 QWORD PTR dev_ned$[rsp], rax

; 497  :     NED *ctl_ned = dev_ned + 1;     /* Control Unit NED is next  */

  0003d	48 8b 44 24 10	 mov	 rax, QWORD PTR dev_ned$[rsp]
  00042	48 83 c0 20	 add	 rax, 32			; 00000020H
  00046	48 89 44 24 18	 mov	 QWORD PTR ctl_ned$[rsp], rax

; 498  :     NED *tkn_ned = ctl_ned + 1;     /* Token NED is last NED     */

  0004b	48 8b 44 24 18	 mov	 rax, QWORD PTR ctl_ned$[rsp]
  00050	48 83 c0 20	 add	 rax, 32			; 00000020H
  00054	48 89 44 24 20	 mov	 QWORD PTR tkn_ned$[rsp], rax

; 499  :     NEQ *gen_neq = (NEQ*)tkn_ned+1; /* General NEQ always last   */

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR tkn_ned$[rsp]
  0005e	48 83 c0 20	 add	 rax, 32			; 00000020H
  00062	48 89 44 24 28	 mov	 QWORD PTR gen_neq$[rsp], rax

; 500  :     DEVBLK *cua;                    /* Our Control Unit device   */
; 501  : 
; 502  :     /* Copy configuration data from tempate */
; 503  :     memcpy (work, configuration_data, sizeof( work ));

  00067	48 8d 44 24 30	 lea	 rax, QWORD PTR work$[rsp]
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:configuration_data
  00073	48 8b f8	 mov	 rdi, rax
  00076	48 8b f1	 mov	 rsi, rcx
  00079	b9 80 00 00 00	 mov	 ecx, 128		; 00000080H
  0007e	f3 a4		 rep movsb

; 504  : 
; 505  :     /* The first device in the group is the control unit */
; 506  :     cua = dev->group->memdev[0];

  00080	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00088	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0008c	b9 08 00 00 00	 mov	 ecx, 8
  00091	48 6b c9 00	 imul	 rcx, rcx, 0
  00095	48 8b 44 08 10	 mov	 rax, QWORD PTR [rax+rcx+16]
  0009a	48 89 44 24 08	 mov	 QWORD PTR cua$[rsp], rax

; 507  : 
; 508  :     /* Insert the Channel Path ID (CHPID) into all of the NEDs */
; 509  :     dev_ned->tag[0] = dev->pmcw.chpid[0];

  0009f	b8 01 00 00 00	 mov	 eax, 1
  000a4	48 6b c0 00	 imul	 rax, rax, 0
  000a8	b9 01 00 00 00	 mov	 ecx, 1
  000ad	48 6b c9 00	 imul	 rcx, rcx, 0
  000b1	48 8b 54 24 10	 mov	 rdx, QWORD PTR dev_ned$[rsp]
  000b6	48 8b bc 24 e0
	00 00 00	 mov	 rdi, QWORD PTR dev$[rsp]
  000be	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  000c6	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 510  :     ctl_ned->tag[0] = cua->pmcw.chpid[0];

  000ca	b8 01 00 00 00	 mov	 eax, 1
  000cf	48 6b c0 00	 imul	 rax, rax, 0
  000d3	b9 01 00 00 00	 mov	 ecx, 1
  000d8	48 6b c9 00	 imul	 rcx, rcx, 0
  000dc	48 8b 54 24 18	 mov	 rdx, QWORD PTR ctl_ned$[rsp]
  000e1	48 8b 7c 24 08	 mov	 rdi, QWORD PTR cua$[rsp]
  000e6	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  000ee	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 511  :     tkn_ned->tag[0] = cua->pmcw.chpid[0];

  000f2	b8 01 00 00 00	 mov	 eax, 1
  000f7	48 6b c0 00	 imul	 rax, rax, 0
  000fb	b9 01 00 00 00	 mov	 ecx, 1
  00100	48 6b c9 00	 imul	 rcx, rcx, 0
  00104	48 8b 54 24 20	 mov	 rdx, QWORD PTR tkn_ned$[rsp]
  00109	48 8b 7c 24 08	 mov	 rdi, QWORD PTR cua$[rsp]
  0010e	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  00116	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 512  : 
; 513  :     /* Insert the device's device number into its device NED. */
; 514  :     dev_ned->tag[1] = dev->devnum & 0xFF;

  0011a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00122	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00126	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0012b	b9 01 00 00 00	 mov	 ecx, 1
  00130	48 6b c9 01	 imul	 rcx, rcx, 1
  00134	48 8b 54 24 10	 mov	 rdx, QWORD PTR dev_ned$[rsp]
  00139	88 44 0a 1e	 mov	 BYTE PTR [rdx+rcx+30], al

; 515  : 
; 516  :     /* Insert the control unit address into the General NEQ */
; 517  :     gen_neq->iid[0] = cua->pmcw.chpid[0];

  0013d	b8 01 00 00 00	 mov	 eax, 1
  00142	48 6b c0 00	 imul	 rax, rax, 0
  00146	b9 01 00 00 00	 mov	 ecx, 1
  0014b	48 6b c9 00	 imul	 rcx, rcx, 0
  0014f	48 8b 54 24 28	 mov	 rdx, QWORD PTR gen_neq$[rsp]
  00154	48 8b 7c 24 08	 mov	 rdi, QWORD PTR cua$[rsp]
  00159	0f b6 84 07 fc
	02 00 00	 movzx	 eax, BYTE PTR [rdi+rax+764]
  00161	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 518  :     gen_neq->iid[1] = cua->devnum & 0xFF;

  00165	48 8b 44 24 08	 mov	 rax, QWORD PTR cua$[rsp]
  0016a	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0016e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00173	b9 01 00 00 00	 mov	 ecx, 1
  00178	48 6b c9 01	 imul	 rcx, rcx, 1
  0017c	48 8b 54 24 28	 mov	 rdx, QWORD PTR gen_neq$[rsp]
  00181	88 44 0a 02	 mov	 BYTE PTR [rdx+rcx+2], al

; 519  : 
; 520  :     /* Finally, copy the work area into the caller's buffer */
; 521  :     copylen = bufsz < (int) sizeof( work ) ? bufsz : (int) sizeof( work );

  00185	81 bc 24 f0 00
	00 00 80 00 00
	00		 cmp	 DWORD PTR bufsz$[rsp], 128 ; 00000080H
  00190	7d 0c		 jge	 SHORT $LN3@zfcp_read_
  00192	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR bufsz$[rsp]
  00199	89 04 24	 mov	 DWORD PTR tv151[rsp], eax
  0019c	eb 07		 jmp	 SHORT $LN4@zfcp_read_
$LN3@zfcp_read_:
  0019e	c7 04 24 80 00
	00 00		 mov	 DWORD PTR tv151[rsp], 128 ; 00000080H
$LN4@zfcp_read_:
  001a5	8b 04 24	 mov	 eax, DWORD PTR tv151[rsp]
  001a8	89 44 24 04	 mov	 DWORD PTR copylen$[rsp], eax

; 522  :     memcpy( buffer, work, copylen );

  001ac	48 63 44 24 04	 movsxd	 rax, DWORD PTR copylen$[rsp]
  001b1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR work$[rsp]
  001b6	48 8b bc 24 e8
	00 00 00	 mov	 rdi, QWORD PTR buffer$[rsp]
  001be	48 8b f1	 mov	 rsi, rcx
  001c1	48 8b c8	 mov	 rcx, rax
  001c4	f3 a4		 rep movsb

; 523  : 
; 524  :     /* Return to them the number of bytes we provided */
; 525  :     return copylen;

  001c6	8b 44 24 04	 mov	 eax, DWORD PTR copylen$[rsp]

; 526  : }

  001ca	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d2	48 33 cc	 xor	 rcx, rsp
  001d5	e8 00 00 00 00	 call	 __security_check_cookie
  001da	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  001e1	5f		 pop	 rdi
  001e2	5e		 pop	 rsi
  001e3	c3		 ret	 0
zfcp_read_configuration_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
grp$ = 32
dev$ = 64
zfcp_halt_or_clear PROC

; 473  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 474  :     ZFCP_GRP* grp = (ZFCP_GRP*) dev->group->grp_data;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00016	48 89 44 24 20	 mov	 QWORD PTR grp$[rsp], rax

; 475  : 
; 476  :     /* Signal QDIO end if QDIO is active */
; 477  :     if (dev->scsw.flag2 & SCSW2_Q)

  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00020	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00027	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002c	85 c0		 test	 eax, eax
  0002e	0f 84 b4 00 00
	00		 je	 $LN8@zfcp_halt_

; 478  :     {
; 479  :         dev->scsw.flag2 &= ~SCSW2_Q;

  00034	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00039	0f b6 80 0a 03
	00 00		 movzx	 eax, BYTE PTR [rax+778]
  00040	0f ba f0 07	 btr	 eax, 7
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00049	88 81 0a 03 00
	00		 mov	 BYTE PTR [rcx+778], al
$LN4@zfcp_halt_:

; 480  :         VERIFY( 1 == write_pipe( grp->ppfd[1], "*", 1 ));

  0004f	b8 04 00 00 00	 mov	 eax, 4
  00054	48 6b c0 01	 imul	 rax, rax, 1
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR grp$[rsp]
  0005d	48 63 44 01 2c	 movsxd	 rax, DWORD PTR [rcx+rax+44]
  00062	45 33 c9	 xor	 r9d, r9d
  00065	41 b8 01 00 00
	00		 mov	 r8d, 1
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170068
  00072	48 8b c8	 mov	 rcx, rax
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  0007b	83 f8 01	 cmp	 eax, 1
  0007e	74 5c		 je	 SHORT $LN10@zfcp_halt_
$LN7@zfcp_halt_:
  00080	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170069
  00087	41 b8 e0 01 00
	00		 mov	 r8d, 480		; 000001e0H
  0008d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170070
  00094	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170071
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a7	85 c0		 test	 eax, eax
  000a9	74 20		 je	 SHORT $LN11@zfcp_halt_
  000ab	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170073
  000b2	41 b8 e0 01 00
	00		 mov	 r8d, 480		; 000001e0H
  000b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170074
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170075
  000c6	e8 00 00 00 00	 call	 DebuggerTrace
$LN11@zfcp_halt_:
  000cb	33 c0		 xor	 eax, eax
  000cd	85 c0		 test	 eax, eax
  000cf	75 af		 jne	 SHORT $LN7@zfcp_halt_
  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000d7	85 c0		 test	 eax, eax
  000d9	74 01		 je	 SHORT $LN12@zfcp_halt_
  000db	cc		 int	 3
$LN12@zfcp_halt_:
$LN10@zfcp_halt_:
  000dc	33 c0		 xor	 eax, eax
  000de	85 c0		 test	 eax, eax
  000e0	0f 85 69 ff ff
	ff		 jne	 $LN4@zfcp_halt_

; 481  :     }

  000e6	eb 24		 jmp	 SHORT $LN9@zfcp_halt_
$LN8@zfcp_halt_:

; 482  :     else
; 483  :         if (dev->group->acount == ZFCP_GROUP_SIZE)

  000e8	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000ed	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000f1	83 78 04 01	 cmp	 DWORD PTR [rax+4], 1
  000f5	75 15		 jne	 SHORT $LN13@zfcp_halt_

; 484  :             signal_condition( &grp->qcond );

  000f7	48 8b 44 24 20	 mov	 rax, QWORD PTR grp$[rsp]
  000fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170078
  00103	48 8b c8	 mov	 rcx, rax
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN13@zfcp_halt_:
$LN9@zfcp_halt_:

; 485  : }

  0010c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00110	c3		 ret	 0
zfcp_halt_or_clear ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
oq$ = 48
ob$1 = 52
ns$2 = 56
len$3 = 60
mq$ = 64
mb$4 = 68
sa$5 = 72
la$6 = 80
slsb$7 = 88
tv70 = 96
tv371 = 100
tv87 = 104
sbal$8 = 112
grp$ = 120
sl$9 = 128
buf$10 = 136
dev$ = 160
process_output_queue PROC

; 370  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 371  : ZFCP_GRP *grp = (ZFCP_GRP*)dev->group->grp_data;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 89 44 24 78	 mov	 QWORD PTR grp$[rsp], rax

; 372  : int oq = dev->qdio.o_qpos;

  00021	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00029	8b 80 c8 13 00
	00		 mov	 eax, DWORD PTR [rax+5064]
  0002f	89 44 24 30	 mov	 DWORD PTR oq$[rsp], eax

; 373  : int mq = dev->qdio.o_qcnt;

  00033	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  00041	89 44 24 40	 mov	 DWORD PTR mq$[rsp], eax
$LN2@process_ou:

; 374  : 
; 375  :     while (mq--)

  00045	8b 44 24 40	 mov	 eax, DWORD PTR mq$[rsp]
  00049	89 44 24 60	 mov	 DWORD PTR tv70[rsp], eax
  0004d	8b 44 24 40	 mov	 eax, DWORD PTR mq$[rsp]
  00051	ff c8		 dec	 eax
  00053	89 44 24 40	 mov	 DWORD PTR mq$[rsp], eax
  00057	83 7c 24 60 00	 cmp	 DWORD PTR tv70[rsp], 0
  0005c	0f 84 d0 05 00
	00		 je	 $LN3@process_ou

; 376  :         if(dev->qdio.o_qmask & (0x80000000 >> oq))

  00062	8b 44 24 30	 mov	 eax, DWORD PTR oq$[rsp]
  00066	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0006b	89 4c 24 64	 mov	 DWORD PTR tv371[rsp], ecx
  0006f	0f b6 c8	 movzx	 ecx, al
  00072	8b 44 24 64	 mov	 eax, DWORD PTR tv371[rsp]
  00076	d3 e8		 shr	 eax, cl
  00078	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00080	8b 89 50 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5200]
  00086	23 c8		 and	 ecx, eax
  00088	8b c1		 mov	 eax, ecx
  0008a	85 c0		 test	 eax, eax
  0008c	0f 84 75 05 00
	00		 je	 $LN27@process_ou

; 377  :         {
; 378  :         int ob = dev->qdio.o_bpos[oq];

  00092	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  00097	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009f	8b 84 81 cc 13
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+5068]
  000a6	89 44 24 34	 mov	 DWORD PTR ob$1[rsp], eax

; 379  :         QDIO_SLSB *slsb;
; 380  :         int mb = 128;

  000aa	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR mb$4[rsp], 128 ; 00000080H

; 381  :             slsb = (QDIO_SLSB*)(dev->mainstor + dev->qdio.o_slsbla[oq]);

  000b2	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  000b7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000bf	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000c6	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000ce	48 03 8c c2 58
	1a 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+6744]
  000d6	48 8b c1	 mov	 rax, rcx
  000d9	48 89 44 24 58	 mov	 QWORD PTR slsb$7[rsp], rax
$LN4@process_ou:

; 382  : 
; 383  :             while(mb--)

  000de	8b 44 24 44	 mov	 eax, DWORD PTR mb$4[rsp]
  000e2	89 44 24 68	 mov	 DWORD PTR tv87[rsp], eax
  000e6	8b 44 24 44	 mov	 eax, DWORD PTR mb$4[rsp]
  000ea	ff c8		 dec	 eax
  000ec	89 44 24 44	 mov	 DWORD PTR mb$4[rsp], eax
  000f0	83 7c 24 68 00	 cmp	 DWORD PTR tv87[rsp], 0
  000f5	0f 84 0a 05 00
	00		 je	 $LN5@process_ou

; 384  :                 if(slsb->slsbe[ob] == SLSBE_OUTPUT_PRIMED)

  000fb	48 63 44 24 34	 movsxd	 rax, DWORD PTR ob$1[rsp]
  00100	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  00105	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00109	83 f8 62	 cmp	 eax, 98			; 00000062H
  0010c	0f 85 ac 04 00
	00		 jne	 $LN29@process_ou

; 385  :                 {
; 386  :                 QDIO_SL *sl = (QDIO_SL*)(dev->mainstor + dev->qdio.o_sla[oq]);

  00112	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  00117	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0011f	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00126	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0012e	48 03 8c c2 58
	19 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+6488]
  00136	48 8b c1	 mov	 rax, rcx
  00139	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR sl$9[rsp], rax
$LN8@process_ou:

; 387  :                 U64 sa; U32 len; BYTE *buf;
; 388  :                 U64 la;
; 389  :                 QDIO_SBAL *sbal;
; 390  :                 int ns;
; 391  : 
; 392  :                     DBGTRC( dev, "Output Queue(%d) Buffer(%d)\n", oq, ob );

  00141	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00149	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0014d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00151	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00155	74 3b		 je	 SHORT $LN31@process_ou
$LN11@process_ou:
  00157	44 8b 44 24 34	 mov	 r8d, DWORD PTR ob$1[rsp]
  0015c	8b 54 24 30	 mov	 edx, DWORD PTR oq$[rsp]
  00160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170032
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00173	85 c0		 test	 eax, eax
  00175	74 15		 je	 SHORT $LN32@process_ou
  00177	44 8b 44 24 34	 mov	 r8d, DWORD PTR ob$1[rsp]
  0017c	8b 54 24 30	 mov	 edx, DWORD PTR oq$[rsp]
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170034
  00187	e8 00 00 00 00	 call	 DebuggerTrace
$LN32@process_ou:
  0018c	33 c0		 xor	 eax, eax
  0018e	85 c0		 test	 eax, eax
  00190	75 c5		 jne	 SHORT $LN11@process_ou
$LN31@process_ou:
  00192	33 c0		 xor	 eax, eax
  00194	85 c0		 test	 eax, eax
  00196	75 a9		 jne	 SHORT $LN8@process_ou

; 393  : 
; 394  :                     FETCH_DW(sa,sl->sbala[ob]);

  00198	48 63 44 24 34	 movsxd	 rax, DWORD PTR ob$1[rsp]
  0019d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sl$9[rsp]
  001a5	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  001a9	48 8b c8	 mov	 rcx, rax
  001ac	e8 00 00 00 00	 call	 fetch_dw_noswap
  001b1	48 8b c8	 mov	 rcx, rax
  001b4	e8 00 00 00 00	 call	 _byteswap_uint64
  001b9	48 89 44 24 48	 mov	 QWORD PTR sa$5[rsp], rax

; 395  :                     if(STORCHK(sa,sizeof(QDIO_SBAL)-1,dev->qdio.o_slk[oq],STORKEY_REF,dev))

  001be	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  001c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001cb	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001d0	41 b1 04	 mov	 r9b, 4
  001d3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001db	44 0f b6 84 01
	f8 17 00 00	 movzx	 r8d, BYTE PTR [rcx+rax+6136]
  001e4	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  001e9	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sa$5[rsp]
  001ee	e8 00 00 00 00	 call	 STORCHK
  001f3	0f b6 c0	 movzx	 eax, al
  001f6	85 c0		 test	 eax, eax
  001f8	0f 84 d2 00 00
	00		 je	 $LN33@process_ou

; 396  :                     {
; 397  :                         slsb->slsbe[ob] = SLSBE_ERROR;

  001fe	48 63 44 24 34	 movsxd	 rax, DWORD PTR ob$1[rsp]
  00203	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  00208	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 398  :                         ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.o_slsbla[oq], (STORKEY_REF | STORKEY_CHANGE) );

  0020c	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  00211	41 b0 06	 mov	 r8b, 6
  00214	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0021c	48 8b 94 c1 58
	1a 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+6744]
  00224	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022c	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 399  : #if defined(_FEATURE_QDIO_THININT)
; 400  :                         set_alsi(dev,ALSI_ERROR);

  00231	b2 80		 mov	 dl, 128			; 00000080H
  00233	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0023b	e8 00 00 00 00	 call	 set_alsi

; 401  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 402  :                         grp->reqpci = TRUE;

  00240	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  00245	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [rax+68], 1
$LN14@process_ou:

; 403  :                         DBGTRC( dev, "STORCHK ERROR sa(%16.16"PRIx64"), key(%2.2x)\n", sa, dev->qdio.o_slk[ oq ]);

  0024c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00254	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00258	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0025c	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00260	74 63		 je	 SHORT $LN34@process_ou
$LN17@process_ou:
  00262	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  00267	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0026f	0f b6 84 01 f8
	17 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6136]
  00277	44 8b c0	 mov	 r8d, eax
  0027a	48 8b 54 24 48	 mov	 rdx, QWORD PTR sa$5[rsp]
  0027f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170037
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00292	85 c0		 test	 eax, eax
  00294	74 29		 je	 SHORT $LN35@process_ou
  00296	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  0029b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002a3	0f b6 84 01 f8
	17 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6136]
  002ab	44 8b c0	 mov	 r8d, eax
  002ae	48 8b 54 24 48	 mov	 rdx, QWORD PTR sa$5[rsp]
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170039
  002ba	e8 00 00 00 00	 call	 DebuggerTrace
$LN35@process_ou:
  002bf	33 c0		 xor	 eax, eax
  002c1	85 c0		 test	 eax, eax
  002c3	75 9d		 jne	 SHORT $LN17@process_ou
$LN34@process_ou:
  002c5	33 c0		 xor	 eax, eax
  002c7	85 c0		 test	 eax, eax
  002c9	75 81		 jne	 SHORT $LN14@process_ou

; 404  :                         return;

  002cb	e9 62 03 00 00	 jmp	 $LN1@process_ou
$LN33@process_ou:

; 405  :                     }
; 406  :                     sbal = (QDIO_SBAL*)(dev->mainstor + sa);

  002d0	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d8	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  002df	48 03 44 24 48	 add	 rax, QWORD PTR sa$5[rsp]
  002e4	48 89 44 24 70	 mov	 QWORD PTR sbal$8[rsp], rax

; 407  : 
; 408  :                     for(ns = 0; ns < 16; ns++)

  002e9	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ns$2[rsp], 0
  002f1	eb 0a		 jmp	 SHORT $LN20@process_ou
$LN18@process_ou:
  002f3	8b 44 24 38	 mov	 eax, DWORD PTR ns$2[rsp]
  002f7	ff c0		 inc	 eax
  002f9	89 44 24 38	 mov	 DWORD PTR ns$2[rsp], eax
$LN20@process_ou:
  002fd	83 7c 24 38 10	 cmp	 DWORD PTR ns$2[rsp], 16
  00302	0f 8d e3 01 00
	00		 jge	 $LN19@process_ou

; 409  :                     {
; 410  :                         FETCH_DW(la,sbal->sbale[ns].addr);

  00308	48 63 44 24 38	 movsxd	 rax, DWORD PTR ns$2[rsp]
  0030d	48 6b c0 10	 imul	 rax, rax, 16
  00311	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sbal$8[rsp]
  00316	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  0031b	48 8b c8	 mov	 rcx, rax
  0031e	e8 00 00 00 00	 call	 fetch_dw_noswap
  00323	48 8b c8	 mov	 rcx, rax
  00326	e8 00 00 00 00	 call	 _byteswap_uint64
  0032b	48 89 44 24 50	 mov	 QWORD PTR la$6[rsp], rax

; 411  :                         FETCH_FW(len,sbal->sbale[ns].length);

  00330	48 63 44 24 38	 movsxd	 rax, DWORD PTR ns$2[rsp]
  00335	48 6b c0 10	 imul	 rax, rax, 16
  00339	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sbal$8[rsp]
  0033e	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  00343	48 8b c8	 mov	 rcx, rax
  00346	e8 00 00 00 00	 call	 fetch_fw_noswap
  0034b	8b c8		 mov	 ecx, eax
  0034d	e8 00 00 00 00	 call	 _byteswap_ulong
  00352	89 44 24 3c	 mov	 DWORD PTR len$3[rsp], eax

; 412  :                         if(!len)

  00356	83 7c 24 3c 00	 cmp	 DWORD PTR len$3[rsp], 0
  0035b	75 05		 jne	 SHORT $LN36@process_ou

; 413  :                             break;  // Or should this be continue - ie a discontiguous sbal???

  0035d	e9 89 01 00 00	 jmp	 $LN19@process_ou
$LN36@process_ou:

; 414  :                         if(STORCHK(la,len-1,dev->qdio.o_sbalk[oq],STORKEY_REF,dev))

  00362	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  00367	8b 4c 24 3c	 mov	 ecx, DWORD PTR len$3[rsp]
  0036b	ff c9		 dec	 ecx
  0036d	8b c9		 mov	 ecx, ecx
  0036f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00377	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0037c	41 b1 04	 mov	 r9b, 4
  0037f	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00387	44 0f b6 84 02
	18 18 00 00	 movzx	 r8d, BYTE PTR [rdx+rax+6168]
  00390	8b d1		 mov	 edx, ecx
  00392	48 8b 4c 24 50	 mov	 rcx, QWORD PTR la$6[rsp]
  00397	e8 00 00 00 00	 call	 STORCHK
  0039c	0f b6 c0	 movzx	 eax, al
  0039f	85 c0		 test	 eax, eax
  003a1	0f 84 e0 00 00
	00		 je	 $LN37@process_ou

; 415  :                         {
; 416  :                             slsb->slsbe[ob] = SLSBE_ERROR;

  003a7	48 63 44 24 34	 movsxd	 rax, DWORD PTR ob$1[rsp]
  003ac	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  003b1	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 417  :                             ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.o_slsbla[oq], (STORKEY_REF | STORKEY_CHANGE) );

  003b5	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  003ba	41 b0 06	 mov	 r8b, 6
  003bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003c5	48 8b 94 c1 58
	1a 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+6744]
  003cd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003d5	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 418  : #if defined(_FEATURE_QDIO_THININT)
; 419  :                             set_alsi(dev,ALSI_ERROR);

  003da	b2 80		 mov	 dl, 128			; 00000080H
  003dc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e4	e8 00 00 00 00	 call	 set_alsi

; 420  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 421  :                             grp->reqpci = TRUE;

  003e9	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  003ee	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [rax+68], 1
$LN23@process_ou:

; 422  :                             DBGTRC( dev, "STORCHK ERROR la(%16.16"PRIx64"), len(%d), key(%2.2x)\n", la, len, dev->qdio.o_sbalk[ oq ]);

  003f5	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003fd	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00401	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00405	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00409	74 6d		 je	 SHORT $LN38@process_ou
$LN26@process_ou:
  0040b	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  00410	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00418	0f b6 84 01 18
	18 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6168]
  00420	44 8b c8	 mov	 r9d, eax
  00423	44 8b 44 24 3c	 mov	 r8d, DWORD PTR len$3[rsp]
  00428	48 8b 54 24 50	 mov	 rdx, QWORD PTR la$6[rsp]
  0042d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170043
  00434	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0043a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00440	85 c0		 test	 eax, eax
  00442	74 2e		 je	 SHORT $LN39@process_ou
  00444	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  00449	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00451	0f b6 84 01 18
	18 00 00	 movzx	 eax, BYTE PTR [rcx+rax+6168]
  00459	44 8b c8	 mov	 r9d, eax
  0045c	44 8b 44 24 3c	 mov	 r8d, DWORD PTR len$3[rsp]
  00461	48 8b 54 24 50	 mov	 rdx, QWORD PTR la$6[rsp]
  00466	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170045
  0046d	e8 00 00 00 00	 call	 DebuggerTrace
$LN39@process_ou:
  00472	33 c0		 xor	 eax, eax
  00474	85 c0		 test	 eax, eax
  00476	75 93		 jne	 SHORT $LN26@process_ou
$LN38@process_ou:
  00478	33 c0		 xor	 eax, eax
  0047a	85 c0		 test	 eax, eax
  0047c	0f 85 73 ff ff
	ff		 jne	 $LN23@process_ou

; 423  :                             return;

  00482	e9 ab 01 00 00	 jmp	 $LN1@process_ou
$LN37@process_ou:

; 424  :                         }
; 425  :                         buf = (BYTE*)(dev->mainstor + la);

  00487	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048f	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00496	48 03 44 24 50	 add	 rax, QWORD PTR la$6[rsp]
  0049b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$10[rsp], rax

; 426  : 
; 427  : #if 0
; 428  :                         // ADD CODE TO TAKE BLOCKS OF THE QUEUE AND WRITE
; 429  : #endif
; 430  : 
; 431  :                         if((sbal->sbale[ns].flags[3] & SBALE_FLAG3_PCI_REQ))

  004a3	48 63 44 24 38	 movsxd	 rax, DWORD PTR ns$2[rsp]
  004a8	48 6b c0 10	 imul	 rax, rax, 16
  004ac	48 8b 4c 24 70	 mov	 rcx, QWORD PTR sbal$8[rsp]
  004b1	48 03 c8	 add	 rcx, rax
  004b4	48 8b c1	 mov	 rax, rcx
  004b7	b9 01 00 00 00	 mov	 ecx, 1
  004bc	48 6b c9 03	 imul	 rcx, rcx, 3
  004c0	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  004c4	83 e0 40	 and	 eax, 64			; 00000040H
  004c7	85 c0		 test	 eax, eax
  004c9	74 1b		 je	 SHORT $LN40@process_ou

; 432  :                         {
; 433  : #if defined(_FEATURE_QDIO_THININT)
; 434  :                             set_dsci(dev,DSCI_IOCOMP);

  004cb	b2 01		 mov	 dl, 1
  004cd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004d5	e8 00 00 00 00	 call	 set_dsci

; 435  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 436  :                             grp->reqpci = TRUE;

  004da	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  004df	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [rax+68], 1
$LN40@process_ou:

; 437  :                         }
; 438  :                     }

  004e6	e9 08 fe ff ff	 jmp	 $LN18@process_ou
$LN19@process_ou:

; 439  : 
; 440  :                     slsb->slsbe[ob] = SLSBE_OUTPUT_COMPLETED;

  004eb	48 63 44 24 34	 movsxd	 rax, DWORD PTR ob$1[rsp]
  004f0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  004f5	c6 04 01 a1	 mov	 BYTE PTR [rcx+rax], 161	; 000000a1H

; 441  :                     ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.o_slsbla[oq], (STORKEY_REF | STORKEY_CHANGE) );

  004f9	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  004fe	41 b0 06	 mov	 r8b, 6
  00501	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00509	48 8b 94 c1 58
	1a 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+6744]
  00511	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00519	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 442  :                     if(++ob >= 128)

  0051e	8b 44 24 34	 mov	 eax, DWORD PTR ob$1[rsp]
  00522	ff c0		 inc	 eax
  00524	89 44 24 34	 mov	 DWORD PTR ob$1[rsp], eax
  00528	81 7c 24 34 80
	00 00 00	 cmp	 DWORD PTR ob$1[rsp], 128 ; 00000080H
  00530	7c 6a		 jl	 SHORT $LN41@process_ou

; 443  :                     {
; 444  :                         ob = 0;

  00532	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR ob$1[rsp], 0

; 445  :                         dev->qdio.o_bpos[oq] = ob;

  0053a	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  0053f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00547	8b 54 24 34	 mov	 edx, DWORD PTR ob$1[rsp]
  0054b	89 94 81 cc 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+5068], edx

; 446  :                         if(++oq >= dev->qdio.o_qcnt)

  00552	8b 44 24 30	 mov	 eax, DWORD PTR oq$[rsp]
  00556	ff c0		 inc	 eax
  00558	89 44 24 30	 mov	 DWORD PTR oq$[rsp], eax
  0055c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00564	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  0056a	39 44 24 30	 cmp	 DWORD PTR oq$[rsp], eax
  0056e	7c 08		 jl	 SHORT $LN42@process_ou

; 447  :                             oq = 0;

  00570	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR oq$[rsp], 0
$LN42@process_ou:

; 448  :                         dev->qdio.o_qpos = oq;

  00578	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00580	8b 4c 24 30	 mov	 ecx, DWORD PTR oq$[rsp]
  00584	89 88 c8 13 00
	00		 mov	 DWORD PTR [rax+5064], ecx

; 449  :                         mq = dev->qdio.o_qcnt;

  0058a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00592	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  00598	89 44 24 40	 mov	 DWORD PTR mq$[rsp], eax
$LN41@process_ou:

; 450  :                     }
; 451  :                     dev->qdio.o_bpos[oq] = ob;

  0059c	48 63 44 24 30	 movsxd	 rax, DWORD PTR oq$[rsp]
  005a1	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005a9	8b 54 24 34	 mov	 edx, DWORD PTR ob$1[rsp]
  005ad	89 94 81 cc 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+5068], edx

; 452  :                     mb = 128;

  005b4	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR mb$4[rsp], 128 ; 00000080H

; 453  :                 }

  005bc	eb 42		 jmp	 SHORT $LN30@process_ou
$LN29@process_ou:

; 454  :                 else
; 455  :                     if(++ob >= 128)

  005be	8b 44 24 34	 mov	 eax, DWORD PTR ob$1[rsp]
  005c2	ff c0		 inc	 eax
  005c4	89 44 24 34	 mov	 DWORD PTR ob$1[rsp], eax
  005c8	81 7c 24 34 80
	00 00 00	 cmp	 DWORD PTR ob$1[rsp], 128 ; 00000080H
  005d0	7c 2e		 jl	 SHORT $LN43@process_ou

; 456  :                     {
; 457  :                         ob = 0;

  005d2	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR ob$1[rsp], 0

; 458  :                         if(++oq >= dev->qdio.o_qcnt)

  005da	8b 44 24 30	 mov	 eax, DWORD PTR oq$[rsp]
  005de	ff c0		 inc	 eax
  005e0	89 44 24 30	 mov	 DWORD PTR oq$[rsp], eax
  005e4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005ec	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  005f2	39 44 24 30	 cmp	 DWORD PTR oq$[rsp], eax
  005f6	7c 08		 jl	 SHORT $LN44@process_ou

; 459  :                             oq = 0;

  005f8	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR oq$[rsp], 0
$LN44@process_ou:
$LN43@process_ou:
$LN30@process_ou:

; 460  :                     }

  00600	e9 d9 fa ff ff	 jmp	 $LN4@process_ou
$LN5@process_ou:

; 461  : 
; 462  :         }

  00605	eb 26		 jmp	 SHORT $LN28@process_ou
$LN27@process_ou:

; 463  :         else
; 464  :             if(++oq >= dev->qdio.o_qcnt)

  00607	8b 44 24 30	 mov	 eax, DWORD PTR oq$[rsp]
  0060b	ff c0		 inc	 eax
  0060d	89 44 24 30	 mov	 DWORD PTR oq$[rsp], eax
  00611	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00619	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  0061f	39 44 24 30	 cmp	 DWORD PTR oq$[rsp], eax
  00623	7c 08		 jl	 SHORT $LN45@process_ou

; 465  :                 oq = 0;

  00625	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR oq$[rsp], 0
$LN45@process_ou:
$LN28@process_ou:
  0062d	e9 13 fa ff ff	 jmp	 $LN2@process_ou
$LN3@process_ou:
$LN1@process_ou:

; 466  : }

  00632	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00639	c3		 ret	 0
process_output_queue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
iq$ = 48
ib$1 = 52
ns$2 = 56
len$3 = 60
mq$ = 64
mb$4 = 68
sa$5 = 72
la$6 = 80
slsb$7 = 88
sbal$8 = 96
tv128 = 104
tv428 = 108
tv145 = 112
tlen$9 = 116
grp$ = 120
sl$10 = 128
buf$11 = 136
dev$ = 160
process_input_queue PROC

; 252  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 253  : ZFCP_GRP *grp = (ZFCP_GRP*)dev->group->grp_data;

  0000c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00014	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00018	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0001c	48 89 44 24 78	 mov	 QWORD PTR grp$[rsp], rax

; 254  : int iq = dev->qdio.i_qpos;

  00021	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00029	8b 80 40 13 00
	00		 mov	 eax, DWORD PTR [rax+4928]
  0002f	89 44 24 30	 mov	 DWORD PTR iq$[rsp], eax

; 255  : int mq = dev->qdio.i_qcnt;

  00033	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00041	89 44 24 40	 mov	 DWORD PTR mq$[rsp], eax
$LN4@process_in:

; 256  : 
; 257  :     DBGTRC(dev, "Input Qpos(%d) Bpos(%d)\n",dev->qdio.i_qpos,dev->qdio.i_bpos[dev->qdio.i_qpos]);

  00045	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00051	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00055	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00059	0f 84 87 00 00
	00		 je	 $LN33@process_in
$LN7@process_in:
  0005f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00067	48 63 80 40 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4928]
  0006e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00076	44 8b 84 81 44
	13 00 00	 mov	 r8d, DWORD PTR [rcx+rax*4+4932]
  0007e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00086	8b 90 40 13 00
	00		 mov	 edx, DWORD PTR [rax+4928]
  0008c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169945
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0009f	85 c0		 test	 eax, eax
  000a1	74 39		 je	 SHORT $LN34@process_in
  000a3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ab	48 63 80 40 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4928]
  000b2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ba	44 8b 84 81 44
	13 00 00	 mov	 r8d, DWORD PTR [rcx+rax*4+4932]
  000c2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ca	8b 90 40 13 00
	00		 mov	 edx, DWORD PTR [rax+4928]
  000d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169947
  000d7	e8 00 00 00 00	 call	 DebuggerTrace
$LN34@process_in:
  000dc	33 c0		 xor	 eax, eax
  000de	85 c0		 test	 eax, eax
  000e0	0f 85 79 ff ff
	ff		 jne	 $LN7@process_in
$LN33@process_in:
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	0f 85 55 ff ff
	ff		 jne	 $LN4@process_in
$LN8@process_in:

; 258  : 
; 259  :     while (mq--)

  000f0	8b 44 24 40	 mov	 eax, DWORD PTR mq$[rsp]
  000f4	89 44 24 68	 mov	 DWORD PTR tv128[rsp], eax
  000f8	8b 44 24 40	 mov	 eax, DWORD PTR mq$[rsp]
  000fc	ff c8		 dec	 eax
  000fe	89 44 24 40	 mov	 DWORD PTR mq$[rsp], eax
  00102	83 7c 24 68 00	 cmp	 DWORD PTR tv128[rsp], 0
  00107	0f 84 5d 06 00
	00		 je	 $LN9@process_in

; 260  :         if(dev->qdio.i_qmask & (0x80000000 >> iq))

  0010d	8b 44 24 30	 mov	 eax, DWORD PTR iq$[rsp]
  00111	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  00116	89 4c 24 6c	 mov	 DWORD PTR tv428[rsp], ecx
  0011a	0f b6 c8	 movzx	 ecx, al
  0011d	8b 44 24 6c	 mov	 eax, DWORD PTR tv428[rsp]
  00121	d3 e8		 shr	 eax, cl
  00123	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012b	8b 89 4c 14 00
	00		 mov	 ecx, DWORD PTR [rcx+5196]
  00131	23 c8		 and	 ecx, eax
  00133	8b c1		 mov	 eax, ecx
  00135	85 c0		 test	 eax, eax
  00137	0f 84 02 06 00
	00		 je	 $LN35@process_in

; 261  :         {
; 262  :         int ib = dev->qdio.i_bpos[iq];

  0013d	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  00142	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0014a	8b 84 81 44 13
	00 00		 mov	 eax, DWORD PTR [rcx+rax*4+4932]
  00151	89 44 24 34	 mov	 DWORD PTR ib$1[rsp], eax

; 263  :         QDIO_SLSB *slsb;
; 264  :         int mb = 128;

  00155	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR mb$4[rsp], 128 ; 00000080H

; 265  :             slsb = (QDIO_SLSB*)(dev->mainstor + dev->qdio.i_slsbla[iq]);

  0015d	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  00162	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0016a	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00171	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00179	48 03 8c c2 d8
	16 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+5848]
  00181	48 8b c1	 mov	 rax, rcx
  00184	48 89 44 24 58	 mov	 QWORD PTR slsb$7[rsp], rax
$LN10@process_in:

; 266  : 
; 267  :             while(mb--)

  00189	8b 44 24 44	 mov	 eax, DWORD PTR mb$4[rsp]
  0018d	89 44 24 70	 mov	 DWORD PTR tv145[rsp], eax
  00191	8b 44 24 44	 mov	 eax, DWORD PTR mb$4[rsp]
  00195	ff c8		 dec	 eax
  00197	89 44 24 44	 mov	 DWORD PTR mb$4[rsp], eax
  0019b	83 7c 24 70 00	 cmp	 DWORD PTR tv145[rsp], 0
  001a0	0f 84 97 05 00
	00		 je	 $LN11@process_in

; 268  :                 if(slsb->slsbe[ib] == SLSBE_INPUT_EMPTY)

  001a6	48 63 44 24 34	 movsxd	 rax, DWORD PTR ib$1[rsp]
  001ab	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  001b0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001b4	83 f8 41	 cmp	 eax, 65			; 00000041H
  001b7	0f 85 f7 04 00
	00		 jne	 $LN37@process_in

; 269  :                 {
; 270  :                 QDIO_SL *sl = (QDIO_SL*)(dev->mainstor + dev->qdio.i_sla[iq]);

  001bd	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  001c2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ca	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  001d1	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001d9	48 03 8c c2 d8
	15 00 00	 add	 rcx, QWORD PTR [rdx+rax*8+5592]
  001e1	48 8b c1	 mov	 rax, rcx
  001e4	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR sl$10[rsp], rax

; 271  :                 U64 sa; U32 len; BYTE *buf;
; 272  :                 U64 la;
; 273  :                 QDIO_SBAL *sbal;
; 274  :                 int tlen = 0;

  001ec	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tlen$9[rsp], 0
$LN14@process_in:

; 275  :                 int ns;
; 276  : 
; 277  :                     DBGTRC( dev, "Input Queue(%d) Buffer(%d)\n", iq, ib );

  001f4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fc	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00200	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00204	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00208	74 3b		 je	 SHORT $LN39@process_in
$LN17@process_in:
  0020a	44 8b 44 24 34	 mov	 r8d, DWORD PTR ib$1[rsp]
  0020f	8b 54 24 30	 mov	 edx, DWORD PTR iq$[rsp]
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169953
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00226	85 c0		 test	 eax, eax
  00228	74 15		 je	 SHORT $LN40@process_in
  0022a	44 8b 44 24 34	 mov	 r8d, DWORD PTR ib$1[rsp]
  0022f	8b 54 24 30	 mov	 edx, DWORD PTR iq$[rsp]
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169955
  0023a	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@process_in:
  0023f	33 c0		 xor	 eax, eax
  00241	85 c0		 test	 eax, eax
  00243	75 c5		 jne	 SHORT $LN17@process_in
$LN39@process_in:
  00245	33 c0		 xor	 eax, eax
  00247	85 c0		 test	 eax, eax
  00249	75 a9		 jne	 SHORT $LN14@process_in

; 278  : 
; 279  :                     FETCH_DW(sa,sl->sbala[ib]);

  0024b	48 63 44 24 34	 movsxd	 rax, DWORD PTR ib$1[rsp]
  00250	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR sl$10[rsp]
  00258	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  0025c	48 8b c8	 mov	 rcx, rax
  0025f	e8 00 00 00 00	 call	 fetch_dw_noswap
  00264	48 8b c8	 mov	 rcx, rax
  00267	e8 00 00 00 00	 call	 _byteswap_uint64
  0026c	48 89 44 24 48	 mov	 QWORD PTR sa$5[rsp], rax

; 280  :                     if(STORCHK(sa,sizeof(QDIO_SBAL)-1,dev->qdio.i_slk[iq],STORKEY_REF,dev))

  00271	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  00276	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0027e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00283	41 b1 04	 mov	 r9b, 4
  00286	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028e	44 0f b6 84 01
	74 14 00 00	 movzx	 r8d, BYTE PTR [rcx+rax+5236]
  00297	ba ff 00 00 00	 mov	 edx, 255		; 000000ffH
  0029c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR sa$5[rsp]
  002a1	e8 00 00 00 00	 call	 STORCHK
  002a6	0f b6 c0	 movzx	 eax, al
  002a9	85 c0		 test	 eax, eax
  002ab	0f 84 d2 00 00
	00		 je	 $LN41@process_in

; 281  :                     {
; 282  :                         slsb->slsbe[ib] = SLSBE_ERROR;

  002b1	48 63 44 24 34	 movsxd	 rax, DWORD PTR ib$1[rsp]
  002b6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  002bb	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 283  :                         ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.i_slsbla[iq], (STORKEY_REF | STORKEY_CHANGE) );

  002bf	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  002c4	41 b0 06	 mov	 r8b, 6
  002c7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002cf	48 8b 94 c1 d8
	16 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+5848]
  002d7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002df	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 284  : #if defined(_FEATURE_QDIO_THININT)
; 285  :                         set_alsi(dev,ALSI_ERROR);

  002e4	b2 80		 mov	 dl, 128			; 00000080H
  002e6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002ee	e8 00 00 00 00	 call	 set_alsi

; 286  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 287  :                         grp->reqpci = TRUE;

  002f3	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  002f8	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [rax+68], 1
$LN20@process_in:

; 288  :                         DBGTRC( dev, "STORCHK ERROR sa(%16.16"PRIx64"), key(%2.2x)\n", sa, dev->qdio.i_slk[ iq ]);

  002ff	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00307	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0030b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0030f	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  00313	74 63		 je	 SHORT $LN42@process_in
$LN23@process_in:
  00315	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  0031a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00322	0f b6 84 01 74
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5236]
  0032a	44 8b c0	 mov	 r8d, eax
  0032d	48 8b 54 24 48	 mov	 rdx, QWORD PTR sa$5[rsp]
  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169958
  00339	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00345	85 c0		 test	 eax, eax
  00347	74 29		 je	 SHORT $LN43@process_in
  00349	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  0034e	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00356	0f b6 84 01 74
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5236]
  0035e	44 8b c0	 mov	 r8d, eax
  00361	48 8b 54 24 48	 mov	 rdx, QWORD PTR sa$5[rsp]
  00366	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169960
  0036d	e8 00 00 00 00	 call	 DebuggerTrace
$LN43@process_in:
  00372	33 c0		 xor	 eax, eax
  00374	85 c0		 test	 eax, eax
  00376	75 9d		 jne	 SHORT $LN23@process_in
$LN42@process_in:
  00378	33 c0		 xor	 eax, eax
  0037a	85 c0		 test	 eax, eax
  0037c	75 81		 jne	 SHORT $LN20@process_in

; 289  :                         return;

  0037e	e9 e7 03 00 00	 jmp	 $LN1@process_in
$LN41@process_in:

; 290  :                     }
; 291  :                     sbal = (QDIO_SBAL*)(dev->mainstor + sa);

  00383	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0038b	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00392	48 03 44 24 48	 add	 rax, QWORD PTR sa$5[rsp]
  00397	48 89 44 24 60	 mov	 QWORD PTR sbal$8[rsp], rax

; 292  : 
; 293  :                     for(ns = 0; ns < 16; ns++)

  0039c	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR ns$2[rsp], 0
  003a4	eb 0a		 jmp	 SHORT $LN26@process_in
$LN24@process_in:
  003a6	8b 44 24 38	 mov	 eax, DWORD PTR ns$2[rsp]
  003aa	ff c0		 inc	 eax
  003ac	89 44 24 38	 mov	 DWORD PTR ns$2[rsp], eax
$LN26@process_in:
  003b0	83 7c 24 38 10	 cmp	 DWORD PTR ns$2[rsp], 16
  003b5	0f 8d a0 01 00
	00		 jge	 $LN25@process_in

; 294  :                     {
; 295  :                         FETCH_DW(la,sbal->sbale[ns].addr);

  003bb	48 63 44 24 38	 movsxd	 rax, DWORD PTR ns$2[rsp]
  003c0	48 6b c0 10	 imul	 rax, rax, 16
  003c4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sbal$8[rsp]
  003c9	48 8d 44 01 08	 lea	 rax, QWORD PTR [rcx+rax+8]
  003ce	48 8b c8	 mov	 rcx, rax
  003d1	e8 00 00 00 00	 call	 fetch_dw_noswap
  003d6	48 8b c8	 mov	 rcx, rax
  003d9	e8 00 00 00 00	 call	 _byteswap_uint64
  003de	48 89 44 24 50	 mov	 QWORD PTR la$6[rsp], rax

; 296  :                         FETCH_FW(len,sbal->sbale[ns].length);

  003e3	48 63 44 24 38	 movsxd	 rax, DWORD PTR ns$2[rsp]
  003e8	48 6b c0 10	 imul	 rax, rax, 16
  003ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sbal$8[rsp]
  003f1	48 8d 44 01 04	 lea	 rax, QWORD PTR [rcx+rax+4]
  003f6	48 8b c8	 mov	 rcx, rax
  003f9	e8 00 00 00 00	 call	 fetch_fw_noswap
  003fe	8b c8		 mov	 ecx, eax
  00400	e8 00 00 00 00	 call	 _byteswap_ulong
  00405	89 44 24 3c	 mov	 DWORD PTR len$3[rsp], eax

; 297  :                         if(!len)

  00409	83 7c 24 3c 00	 cmp	 DWORD PTR len$3[rsp], 0
  0040e	75 05		 jne	 SHORT $LN44@process_in

; 298  :                             break;  // Or should this be continue - ie a discontiguous sbal???

  00410	e9 46 01 00 00	 jmp	 $LN25@process_in
$LN44@process_in:

; 299  :                         if(STORCHK(la,len-1,dev->qdio.i_sbalk[iq],STORKEY_CHANGE,dev))

  00415	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  0041a	8b 4c 24 3c	 mov	 ecx, DWORD PTR len$3[rsp]
  0041e	ff c9		 dec	 ecx
  00420	8b c9		 mov	 ecx, ecx
  00422	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0042a	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0042f	41 b1 02	 mov	 r9b, 2
  00432	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0043a	44 0f b6 84 02
	94 14 00 00	 movzx	 r8d, BYTE PTR [rdx+rax+5268]
  00443	8b d1		 mov	 edx, ecx
  00445	48 8b 4c 24 50	 mov	 rcx, QWORD PTR la$6[rsp]
  0044a	e8 00 00 00 00	 call	 STORCHK
  0044f	0f b6 c0	 movzx	 eax, al
  00452	85 c0		 test	 eax, eax
  00454	0f 84 e0 00 00
	00		 je	 $LN45@process_in

; 300  :                         {
; 301  :                             slsb->slsbe[ib] = SLSBE_ERROR;

  0045a	48 63 44 24 34	 movsxd	 rax, DWORD PTR ib$1[rsp]
  0045f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  00464	c6 04 01 ff	 mov	 BYTE PTR [rcx+rax], 255	; 000000ffH

; 302  :                             ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.i_slsbla[iq], (STORKEY_REF | STORKEY_CHANGE) );

  00468	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  0046d	41 b0 06	 mov	 r8b, 6
  00470	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00478	48 8b 94 c1 d8
	16 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+5848]
  00480	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00488	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 303  : #if defined(_FEATURE_QDIO_THININT)
; 304  :                             set_alsi(dev,ALSI_ERROR);

  0048d	b2 80		 mov	 dl, 128			; 00000080H
  0048f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00497	e8 00 00 00 00	 call	 set_alsi

; 305  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 306  :                             grp->reqpci = TRUE;

  0049c	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  004a1	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [rax+68], 1
$LN29@process_in:

; 307  :                             DBGTRC( dev, "STORCHK ERROR la(%16.16"PRIx64"), len(%d), key(%2.2x)\n", la, len, dev->qdio.i_sbalk[ iq ]);

  004a8	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004b0	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  004b4	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  004b8	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  004bc	74 6d		 je	 SHORT $LN46@process_in
$LN32@process_in:
  004be	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  004c3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004cb	0f b6 84 01 94
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5268]
  004d3	44 8b c8	 mov	 r9d, eax
  004d6	44 8b 44 24 3c	 mov	 r8d, DWORD PTR len$3[rsp]
  004db	48 8b 54 24 50	 mov	 rdx, QWORD PTR la$6[rsp]
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169964
  004e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  004ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004f3	85 c0		 test	 eax, eax
  004f5	74 2e		 je	 SHORT $LN47@process_in
  004f7	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  004fc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00504	0f b6 84 01 94
	14 00 00	 movzx	 eax, BYTE PTR [rcx+rax+5268]
  0050c	44 8b c8	 mov	 r9d, eax
  0050f	44 8b 44 24 3c	 mov	 r8d, DWORD PTR len$3[rsp]
  00514	48 8b 54 24 50	 mov	 rdx, QWORD PTR la$6[rsp]
  00519	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169966
  00520	e8 00 00 00 00	 call	 DebuggerTrace
$LN47@process_in:
  00525	33 c0		 xor	 eax, eax
  00527	85 c0		 test	 eax, eax
  00529	75 93		 jne	 SHORT $LN32@process_in
$LN46@process_in:
  0052b	33 c0		 xor	 eax, eax
  0052d	85 c0		 test	 eax, eax
  0052f	0f 85 73 ff ff
	ff		 jne	 $LN29@process_in

; 308  :                             return;

  00535	e9 30 02 00 00	 jmp	 $LN1@process_in
$LN45@process_in:

; 309  :                         }
; 310  :                         buf = (BYTE*)(dev->mainstor + la);

  0053a	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00542	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00549	48 03 44 24 50	 add	 rax, QWORD PTR la$6[rsp]
  0054e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR buf$11[rsp], rax

; 311  : 
; 312  : #if 0
; 313  :                         // ADD CODE TO READ BLOCKS AND SAVE TO THE QUEUES
; 314  : #endif
; 315  :                     }

  00556	e9 4b fe ff ff	 jmp	 $LN24@process_in
$LN25@process_in:

; 316  : 
; 317  :                     if(tlen > 0)

  0055b	83 7c 24 74 00	 cmp	 DWORD PTR tlen$9[rsp], 0
  00560	0f 8e ee 00 00
	00		 jle	 $LN48@process_in

; 318  :                     {
; 319  : #if defined(_FEATURE_QDIO_THININT)
; 320  :                         set_dsci(dev,DSCI_IOCOMP);

  00566	b2 01		 mov	 dl, 1
  00568	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00570	e8 00 00 00 00	 call	 set_dsci

; 321  : #endif /*defined(_FEATURE_QDIO_THININT)*/
; 322  :                         grp->reqpci = TRUE;

  00575	48 8b 44 24 78	 mov	 rax, QWORD PTR grp$[rsp]
  0057a	c7 40 44 01 00
	00 00		 mov	 DWORD PTR [rax+68], 1

; 323  :                         slsb->slsbe[ib] = SLSBE_INPUT_COMPLETED;

  00581	48 63 44 24 34	 movsxd	 rax, DWORD PTR ib$1[rsp]
  00586	48 8b 4c 24 58	 mov	 rcx, QWORD PTR slsb$7[rsp]
  0058b	c6 04 01 82	 mov	 BYTE PTR [rcx+rax], 130	; 00000082H

; 324  :                         ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.i_slsbla[iq], (STORKEY_REF | STORKEY_CHANGE) );

  0058f	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  00594	41 b0 06	 mov	 r8b, 6
  00597	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0059f	48 8b 94 c1 d8
	16 00 00	 mov	 rdx, QWORD PTR [rcx+rax*8+5848]
  005a7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005af	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 325  :                         if(++ib >= 128)

  005b4	8b 44 24 34	 mov	 eax, DWORD PTR ib$1[rsp]
  005b8	ff c0		 inc	 eax
  005ba	89 44 24 34	 mov	 DWORD PTR ib$1[rsp], eax
  005be	81 7c 24 34 80
	00 00 00	 cmp	 DWORD PTR ib$1[rsp], 128 ; 00000080H
  005c6	7c 6a		 jl	 SHORT $LN50@process_in

; 326  :                         {
; 327  :                             ib = 0;

  005c8	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR ib$1[rsp], 0

; 328  :                             dev->qdio.i_bpos[iq] = ib;

  005d0	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  005d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005dd	8b 54 24 34	 mov	 edx, DWORD PTR ib$1[rsp]
  005e1	89 94 81 44 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+4932], edx

; 329  :                             if(++iq >= dev->qdio.i_qcnt)

  005e8	8b 44 24 30	 mov	 eax, DWORD PTR iq$[rsp]
  005ec	ff c0		 inc	 eax
  005ee	89 44 24 30	 mov	 DWORD PTR iq$[rsp], eax
  005f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005fa	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00600	39 44 24 30	 cmp	 DWORD PTR iq$[rsp], eax
  00604	7c 08		 jl	 SHORT $LN51@process_in

; 330  :                                 iq = 0;

  00606	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR iq$[rsp], 0
$LN51@process_in:

; 331  :                             dev->qdio.i_qpos = iq;

  0060e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00616	8b 4c 24 30	 mov	 ecx, DWORD PTR iq$[rsp]
  0061a	89 88 40 13 00
	00		 mov	 DWORD PTR [rax+4928], ecx

; 332  :                             mq = dev->qdio.o_qcnt;

  00620	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00628	8b 80 c4 13 00
	00		 mov	 eax, DWORD PTR [rax+5060]
  0062e	89 44 24 40	 mov	 DWORD PTR mq$[rsp], eax
$LN50@process_in:

; 333  :                         }
; 334  :                         dev->qdio.i_bpos[iq] = ib;

  00632	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  00637	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0063f	8b 54 24 34	 mov	 edx, DWORD PTR ib$1[rsp]
  00643	89 94 81 44 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+4932], edx

; 335  :                         mb = 128;

  0064a	c7 44 24 44 80
	00 00 00	 mov	 DWORD PTR mb$4[rsp], 128 ; 00000080H

; 336  :                     }

  00652	eb 30		 jmp	 SHORT $LN49@process_in
$LN48@process_in:

; 337  :                     else
; 338  :                     {
; 339  :                         if(ns)

  00654	83 7c 24 38 00	 cmp	 DWORD PTR ns$2[rsp], 0
  00659	74 24		 je	 SHORT $LN52@process_in

; 340  :                             sbal->sbale[ns-1].flags[0] = SBALE_FLAG0_LAST_ENTRY;

  0065b	8b 44 24 38	 mov	 eax, DWORD PTR ns$2[rsp]
  0065f	ff c8		 dec	 eax
  00661	48 98		 cdqe
  00663	48 6b c0 10	 imul	 rax, rax, 16
  00667	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sbal$8[rsp]
  0066c	48 03 c8	 add	 rcx, rax
  0066f	48 8b c1	 mov	 rax, rcx
  00672	b9 01 00 00 00	 mov	 ecx, 1
  00677	48 6b c9 00	 imul	 rcx, rcx, 0
  0067b	c6 04 08 40	 mov	 BYTE PTR [rax+rcx], 64	; 00000040H
$LN52@process_in:

; 341  :                         return;

  0067f	e9 e6 00 00 00	 jmp	 $LN1@process_in
$LN49@process_in:

; 342  :                     }
; 343  :                     if(ns)

  00684	83 7c 24 38 00	 cmp	 DWORD PTR ns$2[rsp], 0
  00689	74 24		 je	 SHORT $LN53@process_in

; 344  :                         sbal->sbale[ns-1].flags[0] = SBALE_FLAG0_LAST_ENTRY;

  0068b	8b 44 24 38	 mov	 eax, DWORD PTR ns$2[rsp]
  0068f	ff c8		 dec	 eax
  00691	48 98		 cdqe
  00693	48 6b c0 10	 imul	 rax, rax, 16
  00697	48 8b 4c 24 60	 mov	 rcx, QWORD PTR sbal$8[rsp]
  0069c	48 03 c8	 add	 rcx, rax
  0069f	48 8b c1	 mov	 rax, rcx
  006a2	b9 01 00 00 00	 mov	 ecx, 1
  006a7	48 6b c9 00	 imul	 rcx, rcx, 0
  006ab	c6 04 08 40	 mov	 BYTE PTR [rax+rcx], 64	; 00000040H
$LN53@process_in:

; 345  :                 }

  006af	e9 84 00 00 00	 jmp	 $LN38@process_in
$LN37@process_in:

; 346  :                 else /* Buffer not empty */
; 347  :                 {
; 348  :                     if(++ib >= 128)

  006b4	8b 44 24 34	 mov	 eax, DWORD PTR ib$1[rsp]
  006b8	ff c0		 inc	 eax
  006ba	89 44 24 34	 mov	 DWORD PTR ib$1[rsp], eax
  006be	81 7c 24 34 80
	00 00 00	 cmp	 DWORD PTR ib$1[rsp], 128 ; 00000080H
  006c6	7c 58		 jl	 SHORT $LN54@process_in

; 349  :                     {
; 350  :                         ib = 0;

  006c8	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR ib$1[rsp], 0

; 351  :                         dev->qdio.i_bpos[iq] = ib;

  006d0	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  006d5	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006dd	8b 54 24 34	 mov	 edx, DWORD PTR ib$1[rsp]
  006e1	89 94 81 44 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+4932], edx

; 352  :                         if(++iq >= dev->qdio.i_qcnt)

  006e8	8b 44 24 30	 mov	 eax, DWORD PTR iq$[rsp]
  006ec	ff c0		 inc	 eax
  006ee	89 44 24 30	 mov	 DWORD PTR iq$[rsp], eax
  006f2	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006fa	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00700	39 44 24 30	 cmp	 DWORD PTR iq$[rsp], eax
  00704	7c 08		 jl	 SHORT $LN55@process_in

; 353  :                             iq = 0;

  00706	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR iq$[rsp], 0
$LN55@process_in:

; 354  :                         dev->qdio.i_qpos = iq;

  0070e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00716	8b 4c 24 30	 mov	 ecx, DWORD PTR iq$[rsp]
  0071a	89 88 40 13 00
	00		 mov	 DWORD PTR [rax+4928], ecx
$LN54@process_in:

; 355  :                     }
; 356  :                     dev->qdio.i_bpos[iq] = ib;

  00720	48 63 44 24 30	 movsxd	 rax, DWORD PTR iq$[rsp]
  00725	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0072d	8b 54 24 34	 mov	 edx, DWORD PTR ib$1[rsp]
  00731	89 94 81 44 13
	00 00		 mov	 DWORD PTR [rcx+rax*4+4932], edx
$LN38@process_in:

; 357  :                 }

  00738	e9 4c fa ff ff	 jmp	 $LN10@process_in
$LN11@process_in:

; 358  :         }

  0073d	eb 26		 jmp	 SHORT $LN36@process_in
$LN35@process_in:

; 359  :         else
; 360  :             if(++iq >= dev->qdio.i_qcnt)

  0073f	8b 44 24 30	 mov	 eax, DWORD PTR iq$[rsp]
  00743	ff c0		 inc	 eax
  00745	89 44 24 30	 mov	 DWORD PTR iq$[rsp], eax
  00749	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00751	8b 80 3c 13 00
	00		 mov	 eax, DWORD PTR [rax+4924]
  00757	39 44 24 30	 cmp	 DWORD PTR iq$[rsp], eax
  0075b	7c 08		 jl	 SHORT $LN56@process_in

; 361  :                 iq = 0;

  0075d	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR iq$[rsp], 0
$LN56@process_in:
$LN36@process_in:
  00765	e9 86 f9 ff ff	 jmp	 $LN8@process_in
$LN9@process_in:
$LN1@process_in:

; 362  : 
; 363  : }

  0076a	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00771	c3		 ret	 0
process_input_queue ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
dev$ = 48
raise_adapter_interrupt PROC

; 222  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@raise_adap:

; 223  :     DBGTRC( dev, "Adapter Interrupt dev(%4.4x)\n", dev->devnum );

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00012	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00016	83 78 4c 00	 cmp	 DWORD PTR [rax+76], 0
  0001a	74 3f		 je	 SHORT $LN8@raise_adap
$LN7@raise_adap:
  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00021	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00025	8b d0		 mov	 edx, eax
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169877
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003a	85 c0		 test	 eax, eax
  0003c	74 17		 je	 SHORT $LN9@raise_adap
  0003e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00043	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00047	8b d0		 mov	 edx, eax
  00049	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169879
  00050	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@raise_adap:
  00055	33 c0		 xor	 eax, eax
  00057	85 c0		 test	 eax, eax
  00059	75 c1		 jne	 SHORT $LN7@raise_adap
$LN8@raise_adap:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 a8		 jne	 SHORT $LN4@raise_adap

; 224  : 
; 225  :     obtain_lock(&dev->lock);

  00061	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00066	48 83 c0 38	 add	 rax, 56			; 00000038H
  0006a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169880
  00071	48 8b c8	 mov	 rcx, rax
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 226  :     dev->pciscsw.flag2 |= SCSW2_Q | SCSW2_FC_START;

  0007a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0007f	0f b6 80 16 03
	00 00		 movzx	 eax, BYTE PTR [rax+790]
  00086	0d c0 00 00 00	 or	 eax, 192		; 000000c0H
  0008b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00090	88 81 16 03 00
	00		 mov	 BYTE PTR [rcx+790], al

; 227  :     dev->pciscsw.flag3 |= SCSW3_SC_INTER | SCSW3_SC_PEND;

  00096	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0009b	0f b6 80 17 03
	00 00		 movzx	 eax, BYTE PTR [rax+791]
  000a2	83 c8 09	 or	 eax, 9
  000a5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  000aa	88 81 17 03 00
	00		 mov	 BYTE PTR [rcx+791], al

; 228  :     dev->pciscsw.chanstat = CSW_PCI;

  000b0	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000b5	c6 80 1d 03 00
	00 80		 mov	 BYTE PTR [rax+797], 128	; 00000080H

; 229  :     QUEUE_IO_INTERRUPT(&dev->pciioint,FALSE);

  000bc	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000c1	48 05 40 02 00
	00		 add	 rax, 576		; 00000240H
  000c7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169881
  000ce	33 d2		 xor	 edx, edx
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Queue_IO_Interrupt

; 230  :     release_lock (&dev->lock);

  000d9	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000de	48 83 c0 38	 add	 rax, 56			; 00000038H
  000e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169882
  000e9	48 8b c8	 mov	 rcx, rax
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 231  : 
; 232  :     /* Update interrupt status */
; 233  :     OBTAIN_INTLOCK( NULL );

  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169883
  000f9	33 c9		 xor	 ecx, ecx
  000fb	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 234  :     UPDATE_IC_IOPENDING();

  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Update_IC_IOPENDING

; 235  :     RELEASE_INTLOCK( NULL );

  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169884
  0010d	33 c9		 xor	 ecx, ecx
  0010f	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 236  : }

  00114	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00118	c3		 ret	 0
raise_adapter_interrupt ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
dsci$1 = 32
alsi$2 = 40
dev$ = 64
bits$ = 72
set_dsci PROC

; 201  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 202  :     if(dev->qdio.dsci)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 83 b8 70 1b
	00 00 00	 cmp	 QWORD PTR [rax+7024], 0
  0001a	0f 84 d6 00 00
	00		 je	 $LN2@set_dsci

; 203  :     {
; 204  :     BYTE *dsci = dev->mainstor + dev->qdio.dsci;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00025	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00031	48 03 81 70 1b
	00 00		 add	 rax, QWORD PTR [rcx+7024]
  00038	48 89 44 24 20	 mov	 QWORD PTR dsci$1[rsp], rax

; 205  :     BYTE *alsi = dev->mainstor + dev->qdio.alsi;

  0003d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00042	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004e	48 03 81 68 1b
	00 00		 add	 rax, QWORD PTR [rcx+7016]
  00055	48 89 44 24 28	 mov	 QWORD PTR alsi$2[rsp], rax

; 206  : 
; 207  :         obtain_lock(&sysblk.mainlock);

  0005a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00061	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169857
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 208  :         *dsci |= bits;

  00077	0f b6 44 24 48	 movzx	 eax, BYTE PTR bits$[rsp]
  0007c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dsci$1[rsp]
  00081	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00084	0b c8		 or	 ecx, eax
  00086	8b c1		 mov	 eax, ecx
  00088	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dsci$1[rsp]
  0008d	88 01		 mov	 BYTE PTR [rcx], al

; 209  :         ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.dsci, (STORKEY_REF | STORKEY_CHANGE) );

  0008f	41 b0 06	 mov	 r8b, 6
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00097	48 8b 90 70 1b
	00 00		 mov	 rdx, QWORD PTR [rax+7024]
  0009e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000a3	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 210  :         *alsi |= bits;

  000a8	0f b6 44 24 48	 movzx	 eax, BYTE PTR bits$[rsp]
  000ad	48 8b 4c 24 28	 mov	 rcx, QWORD PTR alsi$2[rsp]
  000b2	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000b5	0b c8		 or	 ecx, eax
  000b7	8b c1		 mov	 eax, ecx
  000b9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR alsi$2[rsp]
  000be	88 01		 mov	 BYTE PTR [rcx], al

; 211  :         ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.alsi, (STORKEY_REF | STORKEY_CHANGE) );

  000c0	41 b0 06	 mov	 r8b, 6
  000c3	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  000c8	48 8b 90 68 1b
	00 00		 mov	 rdx, QWORD PTR [rax+7016]
  000cf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000d4	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 212  :         release_lock(&sysblk.mainlock);

  000d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e0	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169858
  000ed	48 8b c8	 mov	 rcx, rax
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN2@set_dsci:

; 213  :     }
; 214  : }

  000f6	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fa	c3		 ret	 0
set_dsci ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
alsi$1 = 32
dev$ = 64
bits$ = 72
set_alsi PROC

; 184  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 185  :     if(dev->qdio.alsi)

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00012	48 83 b8 68 1b
	00 00 00	 cmp	 QWORD PTR [rax+7016], 0
  0001a	0f 84 88 00 00
	00		 je	 $LN2@set_alsi

; 186  :     {
; 187  :     BYTE *alsi = dev->mainstor + dev->qdio.alsi;

  00020	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00025	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0002c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00031	48 03 81 68 1b
	00 00		 add	 rax, QWORD PTR [rcx+7016]
  00038	48 89 44 24 20	 mov	 QWORD PTR alsi$1[rsp], rax

; 188  : 
; 189  :         obtain_lock(&sysblk.mainlock);

  0003d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00044	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169846
  00051	48 8b c8	 mov	 rcx, rax
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 190  :         *alsi |= bits;

  0005a	0f b6 44 24 48	 movzx	 eax, BYTE PTR bits$[rsp]
  0005f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alsi$1[rsp]
  00064	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00067	0b c8		 or	 ecx, eax
  00069	8b c1		 mov	 eax, ecx
  0006b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR alsi$1[rsp]
  00070	88 01		 mov	 BYTE PTR [rcx], al

; 191  :         ARCH_DEP( or_dev_4K_storage_key )( dev, dev->qdio.alsi, (STORKEY_REF | STORKEY_CHANGE) );

  00072	41 b0 06	 mov	 r8b, 6
  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0007a	48 8b 90 68 1b
	00 00		 mov	 rdx, QWORD PTR [rax+7016]
  00081	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00086	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key

; 192  :         release_lock(&sysblk.mainlock);

  0008b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00092	48 05 68 10 00
	00		 add	 rax, 4200		; 00001068H
  00098	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169847
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock
$LN2@set_alsi:

; 193  :     }
; 194  : }

  000a8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000ac	c3		 ret	 0
set_alsi ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\zfcp.c
_TEXT	SEGMENT
tv87 = 32
addr$ = 64
len$ = 72
key$ = 80
acc$ = 88
dev$ = 96
STORCHK	PROC

; 140  : {

$LN11:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 141  :     /* Validate address limits */
; 142  :     if (0
; 143  :         || (addr + len) > dev->mainlim   // (outside main storage)
; 144  :         || (dev->orb.flag5 & ORB5_A      // (or outside address limits)

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	0f 85 8c 00 00
	00		 jne	 $LN3@STORCHK
  00022	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00027	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  0002c	48 03 c8	 add	 rcx, rax
  0002f	48 8b c1	 mov	 rax, rcx
  00032	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00037	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0003e	77 6e		 ja	 SHORT $LN3@STORCHK
  00040	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00045	0f b6 80 d1 02
	00 00		 movzx	 eax, BYTE PTR [rax+721]
  0004c	83 e0 10	 and	 eax, 16
  0004f	85 c0		 test	 eax, eax
  00051	74 62		 je	 SHORT $LN2@STORCHK
  00053	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00058	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  0005f	83 e0 20	 and	 eax, 32			; 00000020H
  00062	85 c0		 test	 eax, eax
  00064	74 15		 je	 SHORT $LN5@STORCHK
  00066	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006d	48 8b 80 60 12
	00 00		 mov	 rax, QWORD PTR [rax+4704]
  00074	48 39 44 24 40	 cmp	 QWORD PTR addr$[rsp], rax
  00079	72 33		 jb	 SHORT $LN4@STORCHK
$LN5@STORCHK:
  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00080	0f b6 80 f1 02
	00 00		 movzx	 eax, BYTE PTR [rax+753]
  00087	83 e0 40	 and	 eax, 64			; 00000040H
  0008a	85 c0		 test	 eax, eax
  0008c	74 27		 je	 SHORT $LN2@STORCHK
  0008e	48 8b 44 24 48	 mov	 rax, QWORD PTR len$[rsp]
  00093	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  00098	48 03 c8	 add	 rcx, rax
  0009b	48 8b c1	 mov	 rax, rcx
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 3b 81 60 12
	00 00		 cmp	 rax, QWORD PTR [rcx+4704]
  000ac	76 07		 jbe	 SHORT $LN2@STORCHK
$LN4@STORCHK:
$LN3@STORCHK:

; 145  :             && ((dev->pmcw.flag5 & PMCW5_LM_LOW  && (addr +  0 ) < sysblk.addrlimval) ||
; 146  :                 (dev->pmcw.flag5 & PMCW5_LM_HIGH && (addr + len) > sysblk.addrlimval)))
; 147  :     )
; 148  :         return CSW_PROGC;

  000ae	b0 20		 mov	 al, 32			; 00000020H
  000b0	e9 90 00 00 00	 jmp	 $LN1@STORCHK
$LN2@STORCHK:

; 149  : 
; 150  :     /* Validate keyed access */
; 151  :     if (key && key != (ARCH_DEP( get_dev_4K_storage_key )( dev, addr ) & STORKEY_KEY) // (key doesn't match)
; 152  :         && (0

  000b5	0f b6 44 24 50	 movzx	 eax, BYTE PTR key$[rsp]
  000ba	85 c0		 test	 eax, eax
  000bc	74 55		 je	 SHORT $LN6@STORCHK
  000be	0f b6 44 24 50	 movzx	 eax, BYTE PTR key$[rsp]
  000c3	89 44 24 20	 mov	 DWORD PTR tv87[rsp], eax
  000c7	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr$[rsp]
  000cc	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000d1	e8 00 00 00 00	 call	 s370_get_dev_4K_storage_key
  000d6	0f b6 c0	 movzx	 eax, al
  000d9	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  000de	8b 4c 24 20	 mov	 ecx, DWORD PTR tv87[rsp]
  000e2	3b c8		 cmp	 ecx, eax
  000e4	74 2d		 je	 SHORT $LN6@STORCHK
  000e6	33 c0		 xor	 eax, eax
  000e8	85 c0		 test	 eax, eax
  000ea	75 23		 jne	 SHORT $LN7@STORCHK
  000ec	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr$[rsp]
  000f1	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000f6	e8 00 00 00 00	 call	 s370_get_dev_4K_storage_key
  000fb	0f b6 c0	 movzx	 eax, al
  000fe	83 e0 08	 and	 eax, 8
  00101	85 c0		 test	 eax, eax
  00103	75 0a		 jne	 SHORT $LN7@STORCHK
  00105	0f b6 44 24 58	 movzx	 eax, BYTE PTR acc$[rsp]
  0010a	83 f8 02	 cmp	 eax, 2
  0010d	75 04		 jne	 SHORT $LN6@STORCHK
$LN7@STORCHK:

; 153  :             || ARCH_DEP( get_dev_4K_storage_key )( dev, addr ) & STORKEY_FETCH        // (and fetch protected)
; 154  :             || acc == STORKEY_CHANGE                                                  // (or trying to update)
; 155  :            )
; 156  :     )
; 157  :         return CSW_PROTC;

  0010f	b0 10		 mov	 al, 16
  00111	eb 32		 jmp	 SHORT $LN1@STORCHK
$LN6@STORCHK:

; 158  : 
; 159  :     if (STORKEY_CHANGE == acc)

  00113	0f b6 44 24 58	 movzx	 eax, BYTE PTR acc$[rsp]
  00118	83 f8 02	 cmp	 eax, 2
  0011b	75 14		 jne	 SHORT $LN8@STORCHK

; 160  :         ARCH_DEP( or_dev_4K_storage_key )( dev, addr, (STORKEY_REF | STORKEY_CHANGE) );

  0011d	41 b0 06	 mov	 r8b, 6
  00120	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr$[rsp]
  00125	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0012a	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key
  0012f	eb 12		 jmp	 SHORT $LN9@STORCHK
$LN8@STORCHK:

; 161  :     else
; 162  :         ARCH_DEP( or_dev_4K_storage_key )( dev, addr, STORKEY_REF );

  00131	41 b0 04	 mov	 r8b, 4
  00134	48 8b 54 24 40	 mov	 rdx, QWORD PTR addr$[rsp]
  00139	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0013e	e8 00 00 00 00	 call	 s370_or_dev_4K_storage_key
$LN9@STORCHK:

; 163  : 
; 164  :     return 0;  // (0 == success)

  00143	32 c0		 xor	 al, al
$LN1@STORCHK:

; 165  : }

  00145	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00149	c3		 ret	 0
STORCHK	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
bits$ = 64
s370_or_dev_4K_storage_key PROC				; COMDAT

; 246  :   inline void  ARCH_DEP( or_dev_4K_storage_key )  ( DEVBLK* dev, U64 abs, BYTE bits ) {        ARCH_DEP( _or_dev_storage_key  )( dev, abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00013	0f b6 44 24 40	 movzx	 eax, BYTE PTR bits$[rsp]
  00018	83 e0 fe	 and	 eax, -2
  0001b	41 b1 04	 mov	 r9b, 4
  0001e	44 0f b6 c0	 movzx	 r8d, al
  00022	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00027	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0002c	e8 00 00 00 00	 call	 s370__or_dev_storage_key
  00031	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00035	c3		 ret	 0
s370_or_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_get_dev_4K_storage_key
_TEXT	SEGMENT
dev$ = 48
abs$ = 56
s370_get_dev_4K_storage_key PROC			; COMDAT

; 244  :   inline BYTE  ARCH_DEP( get_dev_4K_storage_key ) ( DEVBLK* dev, U64 abs            ) { return ARCH_DEP( _get_dev_storage_key )( dev, abs, 4 )  & ~STORKEY_BADFRM;      }

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000e	41 b0 04	 mov	 r8b, 4
  00011	48 8b 54 24 38	 mov	 rdx, QWORD PTR abs$[rsp]
  00016	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0001b	e8 00 00 00 00	 call	 s370__get_dev_storage_key
  00020	0f b6 c0	 movzx	 eax, al
  00023	83 e0 fe	 and	 eax, -2
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
s370_get_dev_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_dev_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
dev$ = 80
abs$ = 88
bits$ = 96
K$ = 104
s370__or_dev_storage_key PROC				; COMDAT

; 206  : {

$LN8:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_d:

; 207  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	75 fa		 jne	 SHORT $LN4@s370__or_d

; 208  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  0001e	0f b6 44 24 68	 movzx	 eax, BYTE PTR K$[rsp]
  00023	83 f8 04	 cmp	 eax, 4
  00026	75 61		 jne	 SHORT $LN5@s370__or_d
  00028	33 c0		 xor	 eax, eax
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	74 5a		 je	 SHORT $LN5@s370__or_d

; 209  :     {
; 210  :         BYTE* skey1_ptr = _get_dev_storekey1_ptr( dev, abs );

  0002f	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00034	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00039	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  0003e	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 211  :         BYTE* skey2_ptr = _get_dev_storekey2_ptr( dev, abs );

  00043	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00048	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  0004d	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  00052	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 212  :         OR_SKEY( skey1_ptr, bits );

  00057	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  0005c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00061	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00064	0b c8		 or	 ecx, eax
  00066	8b c1		 mov	 eax, ecx
  00068	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0006d	88 01		 mov	 BYTE PTR [rcx], al

; 213  :         OR_SKEY( skey2_ptr, bits );

  0006f	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  00074	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00079	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0007c	0b c8		 or	 ecx, eax
  0007e	8b c1		 mov	 eax, ecx
  00080	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00085	88 01		 mov	 BYTE PTR [rcx], al

; 214  :     }

  00087	eb 32		 jmp	 SHORT $LN6@s370__or_d
$LN5@s370__or_d:

; 215  :     else
; 216  :     {
; 217  :         BYTE* skey_ptr  = _get_dev_storekey_ptr(  dev, abs, K );

  00089	44 0f b6 44 24
	68		 movzx	 r8d, BYTE PTR K$[rsp]
  0008f	48 8b 54 24 58	 mov	 rdx, QWORD PTR abs$[rsp]
  00094	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00099	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  0009e	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 218  :         OR_SKEY( skey_ptr, bits );

  000a3	0f b6 44 24 60	 movzx	 eax, BYTE PTR bits$[rsp]
  000a8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000ad	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  000b0	0b c8		 or	 ecx, eax
  000b2	8b c1		 mov	 eax, ecx
  000b4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000b9	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_d:

; 219  :     }
; 220  : }

  000bb	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000bf	c3		 ret	 0
s370__or_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__get_dev_storage_key
_TEXT	SEGMENT
skey$ = 32
dev$ = 64
abs$ = 72
K$ = 80
s370__get_dev_storage_key PROC				; COMDAT

; 144  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@s370__get_:

; 145  :     BYTE skey;
; 146  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@s370__get_

; 147  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00019	0f b6 44 24 50	 movzx	 eax, BYTE PTR K$[rsp]
  0001e	83 f8 04	 cmp	 eax, 4
  00021	75 43		 jne	 SHORT $LN5@s370__get_
  00023	33 c0		 xor	 eax, eax
  00025	83 f8 01	 cmp	 eax, 1
  00028	74 3c		 je	 SHORT $LN5@s370__get_

; 148  :     {
; 149  :         skey  = *_get_dev_storekey1_ptr( dev, abs );

  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00034	e8 00 00 00 00	 call	 _get_dev_storekey1_ptr
  00039	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003c	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 150  :         skey |= *_get_dev_storekey2_ptr( dev, abs ) & ~(STORKEY_KEY);

  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004a	e8 00 00 00 00	 call	 _get_dev_storekey2_ptr
  0004f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00052	25 0f ff ff ff	 and	 eax, -241		; ffffffffffffff0fH
  00057	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR skey$[rsp]
  0005c	0b c8		 or	 ecx, eax
  0005e	8b c1		 mov	 eax, ecx
  00060	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al

; 151  :     }

  00064	eb 1c		 jmp	 SHORT $LN6@s370__get_
$LN5@s370__get_:

; 152  :     else
; 153  :         skey  = *_get_dev_storekey_ptr(  dev, abs, K );

  00066	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR K$[rsp]
  0006c	48 8b 54 24 48	 mov	 rdx, QWORD PTR abs$[rsp]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00076	e8 00 00 00 00	 call	 _get_dev_storekey_ptr
  0007b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0007e	88 44 24 20	 mov	 BYTE PTR skey$[rsp], al
$LN6@s370__get_:

; 154  :     return skey;

  00082	0f b6 44 24 20	 movzx	 eax, BYTE PTR skey$[rsp]

; 155  : }

  00087	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008b	c3		 ret	 0
s370__get_dev_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey2_ptr
_TEXT	SEGMENT
dev$ = 8
abs$ = 16
_get_dev_storekey2_ptr PROC				; COMDAT

; 72   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 73   :     ABS_CHECK( abs );
; 74   :     return &STOREKEY2( abs, dev );

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR abs$[rsp]
  0000f	48 c1 e8 0b	 shr	 rax, 11
  00013	48 83 c8 01	 or	 rax, 1
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0001c	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx

; 75   : }

  00029	c3		 ret	 0
_get_dev_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey1_ptr
_TEXT	SEGMENT
dev$ = 8
abs$ = 16
_get_dev_storekey1_ptr PROC				; COMDAT

; 66   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 67   :     ABS_CHECK( abs );
; 68   :     return &STOREKEY1( abs, dev );

  0000a	48 8b 44 24 10	 mov	 rax, QWORD PTR abs$[rsp]
  0000f	48 c1 e8 0b	 shr	 rax, 11
  00013	48 83 e0 fe	 and	 rax, -2
  00017	48 8b 4c 24 08	 mov	 rcx, QWORD PTR dev$[rsp]
  0001c	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00023	48 03 c8	 add	 rcx, rax
  00026	48 8b c1	 mov	 rax, rcx

; 69   : }

  00029	c3		 ret	 0
_get_dev_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_dev_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
dev$ = 32
abs$ = 40
K$ = 48
_get_dev_storekey_ptr PROC				; COMDAT

; 47   : {

$LN5:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 48   :     ABS_CHECK( abs );
; 49   :     return (4 == K) ? &STOREKEY1( abs, dev ) // (see feature.h PROGRAMMING NOTE)

  00013	0f b6 44 24 30	 movzx	 eax, BYTE PTR K$[rsp]
  00018	83 f8 04	 cmp	 eax, 4
  0001b	75 25		 jne	 SHORT $LN3@get_dev_st
  0001d	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00022	48 c1 e8 0b	 shr	 rax, 11
  00026	48 83 e0 fe	 and	 rax, -2
  0002a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  0002f	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00036	48 03 c8	 add	 rcx, rax
  00039	48 8b c1	 mov	 rax, rcx
  0003c	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  00040	eb 1f		 jmp	 SHORT $LN4@get_dev_st
$LN3@get_dev_st:
  00042	48 8b 44 24 28	 mov	 rax, QWORD PTR abs$[rsp]
  00047	48 c1 e8 0b	 shr	 rax, 11
  0004b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR dev$[rsp]
  00050	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  00057	48 03 c8	 add	 rcx, rax
  0005a	48 8b c1	 mov	 rax, rcx
  0005d	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_dev_st:
  00061	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 50   :                     : &STOREKEY(  abs, dev );
; 51   : }

  00065	48 83 c4 18	 add	 rsp, 24
  00069	c3		 ret	 0
_get_dev_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
