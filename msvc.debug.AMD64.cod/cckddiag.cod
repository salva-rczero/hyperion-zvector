; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
	ORG $+5
?xd@?1??offtify@@9@9 DB '0123456789abcdefABCDEF', 00H	; `offtify'::`2'::xd
	ORG $+1
?xv@?1??offtify@@9@9 DB 00H				; `offtify'::`2'::xv
	DB	01H
	DB	02H
	DB	03H
	DB	04H
	DB	05H
	DB	06H
	DB	07H
	DB	08H
	DB	09H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
	DB	0aH
	DB	0bH
	DB	0cH
	DB	0dH
	DB	0eH
	DB	0fH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	printf
PUBLIC	fetch_fw_noswap
PUBLIC	main
EXTRN	__imp_isxdigit:PROC
EXTRN	__imp__errno:PROC
EXTRN	strchr:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_exit:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp__atoi64:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_getc:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp_initialize_utility:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_dasd_lookup:PROC
EXTRN	__imp_cckd_def_opt_bigend:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_data_dump:PROC
EXTRN	__imp_data_dump_ascii:PROC
EXTRN	__imp_data_dump_offset:PROC
EXTRN	__imp_is_dh_devid_typ:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
L1tab	DQ	01H DUP (?)
L2tab	DQ	01H DUP (?)
tbuf	DQ	01H DUP (?)
bulk	DQ	01H DUP (?)
fd	DD	01H DUP (?)
debug	DD	01H DUP (?)
pausesnap DD	01H DUP (?)
$SG160045 DB	01H DUP (?)
	ALIGN	4

$SG160086 DB	01H DUP (?)
	ALIGN	4

$SG160143 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$printf DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$printf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$ErrExit DD imagerel ErrExit
	DD	imagerel ErrExit+23
	DD	imagerel $unwind$ErrExit
$pdata$syntax DD imagerel syntax
	DD	imagerel syntax+105
	DD	imagerel $unwind$syntax
$pdata$clean DD	imagerel clean
	DD	imagerel clean+73
	DD	imagerel $unwind$clean
$pdata$makbuf DD imagerel makbuf
	DD	imagerel makbuf+274
	DD	imagerel $unwind$makbuf
$pdata$readpos DD imagerel readpos
	DD	imagerel readpos+800
	DD	imagerel $unwind$readpos
$pdata$decomptrk DD imagerel decomptrk
	DD	imagerel decomptrk+172
	DD	imagerel $unwind$decomptrk
$pdata$show_ckd_count DD imagerel show_ckd_count
	DD	imagerel show_ckd_count+426
	DD	imagerel $unwind$show_ckd_count
$pdata$show_ckd_key DD imagerel show_ckd_key
	DD	imagerel show_ckd_key+309
	DD	imagerel $unwind$show_ckd_key
$pdata$show_ckd_data DD imagerel show_ckd_data
	DD	imagerel show_ckd_data+320
	DD	imagerel $unwind$show_ckd_data
$pdata$show_fba_block DD imagerel show_fba_block
	DD	imagerel show_fba_block+139
	DD	imagerel $unwind$show_fba_block
$pdata$snap DD	imagerel snap
	DD	imagerel snap+544
	DD	imagerel $unwind$snap
$pdata$showtrkorblk DD imagerel showtrkorblk
	DD	imagerel showtrkorblk+682
	DD	imagerel $unwind$showtrkorblk
$pdata$offtify DD imagerel offtify
	DD	imagerel offtify+491
	DD	imagerel $unwind$offtify
$pdata$main DD	imagerel $LN86
	DD	imagerel $LN86+6124
	DD	imagerel $unwind$main
pdata	ENDS
_DATA	SEGMENT
$SG159600 DB	'I', 00H
	ORG $+14
$SG159601 DB	'HHC02600%s Usage: %s [options] file', 0aH, 'HHC02600I   '
	DB	'file      name of CCKD/CFBA file', 0aH, 'HHC02600I Options:', 0aH
	DB	'HHC02600I   -d        display DEVHDR', 0aH, 'HHC02600I   -c  '
	DB	'      display CDEVHDR', 0aH, 'HHC02600I   -1        display L'
	DB	'1TAB (numeric one)', 0aH, 'HHC02600I   -g        enable debug'
	DB	' output', 0aH, 'HHC02600I CKD track and FBA block related opt'
	DB	'ions:', 0aH, 'HHC02600I   -a cc hh  display absolute CCHH tra'
	DB	'ck data', 0aH, 'HHC02600I   -r nnnnn  display relative track/'
	DB	'block data', 0aH, 'HHC02600I   -2        display L2TAB relate'
	DB	'd to -a or -r', 0aH, 'HHC02600I   -t        display track/blo'
	DB	'ck data', 0aH, 'HHC02600I   -x        hex display track key a'
	DB	'nd/or block data', 0aH, 'HHC02600I Offset option:', 0aH, 'HHC'
	DB	'02600I   -o oo ll  hex display data at offset oo of length ll'
	DB	0aH, 00H
	ORG $+3
$SG159602 DB	'syntax', 00H
	ORG $+1
$SG159603 DB	'cckddiag.c', 00H
	ORG $+1
$SG159619 DB	'S', 00H
	ORG $+2
$SG159618 DB	'malloc()', 00H
	ORG $+3
$SG159621 DB	'makbuf', 00H
	ORG $+5
$SG159620 DB	'HHC02602%s From %s: Storage allocation of size %d using '
	DB	'%s failed', 0aH, 00H
	ORG $+1
$SG159624 DB	'D', 00H
	ORG $+2
$SG159622 DB	'cckddiag.c', 00H
	ORG $+1
$SG159641 DB	'D', 00H
	ORG $+2
$SG159625 DB	'HHC90400%s MAKBUF() malloc %s buffer of %d bytes at %p', 0aH
	DB	00H
$SG159626 DB	'makbuf', 00H
	ORG $+1
$SG159627 DB	'cckddiag.c', 00H
	ORG $+1
$SG159646 DB	'S', 00H
	ORG $+2
$SG159642 DB	'HHC90401%s READPOS seeking %lld (0x%16.16llX)', 0aH, 00H
	ORG $+1
$SG159643 DB	'readpos', 00H
$SG159644 DB	'cckddiag.c', 00H
	ORG $+1
$SG159651 DB	'D', 00H
	ORG $+2
$SG159647 DB	'HHC02603%s lseek() to pos 0x%16.16llx error: %s', 0aH, 00H
	ORG $+3
$SG159659 DB	'S', 00H
	ORG $+2
$SG159648 DB	'readpos', 00H
$SG159649 DB	'cckddiag.c', 00H
	ORG $+1
$SG159667 DB	'S', 00H
	ORG $+2
$SG159652 DB	'HHC90402%s READPOS reading buf addr %p length %d (0x%X)', 0aH
	DB	00H
	ORG $+3
$SG159673 DB	'S', 00H
	ORG $+2
$SG159653 DB	'readpos', 00H
$SG159654 DB	'cckddiag.c', 00H
	ORG $+1
$SG159722 DB	'I', 00H
	ORG $+2
$SG159658 DB	'read() error: ', 00H
	ORG $+1
$SG159660 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG159738 DB	0aH, 00H
	ORG $+2
$SG159661 DB	'readpos', 00H
$SG159662 DB	'cckddiag.c', 00H
	ORG $+1
$SG159739 DB	'kl', 00H
	ORG $+1
$SG159665 DB	'unexpected EOF', 00H
	ORG $+1
$SG159666 DB	'read() error: ', 00H
	ORG $+1
$SG159668 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG159740 DB	'I', 00H
	ORG $+2
$SG159669 DB	'readpos', 00H
$SG159670 DB	'cckddiag.c', 00H
	ORG $+1
$SG159744 DB	0aH, 00H
	ORG $+2
$SG159671 DB	'short block', 00H
$SG159757 DB	0aH, 00H
	ORG $+2
$SG159672 DB	'read() error: ', 00H
	ORG $+1
$SG159674 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG159758 DB	'dl', 00H
	ORG $+1
$SG159675 DB	'readpos', 00H
$SG159676 DB	'cckddiag.c', 00H
	ORG $+5
$SG159724 DB	'show_ckd_count', 00H
	ORG $+1
$SG159774 DB	'HHC02616%s Block %d:', 0aH, 00H
	ORG $+2
$SG159723 DB	'HHC02605%s Track %d COUNT cyl[%04X/%d] head[%04X/%d] rec'
	DB	'[%02X/%d] kl[%d] dl[%d]', 0aH, 00H
	ORG $+3
$SG159759 DB	'I', 00H
	ORG $+2
$SG159725 DB	'cckddiag.c', 00H
	ORG $+1
$SG159763 DB	0aH, 00H
	ORG $+2
$SG159741 DB	'HHC02606%s Track %d rec[%02X/%d] %s[%d]:', 0aH, 00H
	ORG $+2
$SG159773 DB	'I', 00H
	ORG $+2
$SG159742 DB	'show_ckd_key', 00H
	ORG $+3
$SG159743 DB	'cckddiag.c', 00H
	ORG $+1
$SG159777 DB	0aH, 00H
	ORG $+2
$SG159760 DB	'HHC02606%s Track %d rec[%02X/%d] %s[%d]:', 0aH, 00H
	ORG $+2
$SG159792 DB	'TRK', 00H
$SG159761 DB	'show_ckd_data', 00H
	ORG $+2
$SG159762 DB	'cckddiag.c', 00H
	ORG $+1
$SG159793 DB	'BKG', 00H
$SG159775 DB	'show_fba_block', 00H
	ORG $+1
$SG159776 DB	'cckddiag.c', 00H
	ORG $+1
$SG159790 DB	'track', 00H
	ORG $+2
$SG159794 DB	'D', 00H
	ORG $+2
$SG159791 DB	'block group', 00H
$SG159800 DB	'TRK', 00H
$SG159795 DB	'HHC90403%s SHOW%s Compressed %s header and data:', 0aH, 00H
	ORG $+2
$SG159796 DB	'snap', 00H
	ORG $+3
$SG159798 DB	'track', 00H
	ORG $+2
$SG159801 DB	'BKG', 00H
$SG159797 DB	'cckddiag.c', 00H
	ORG $+1
$SG159802 DB	'D', 00H
	ORG $+2
$SG159799 DB	'block group', 00H
$SG159807 DB	0aH, 00H
	ORG $+2
$SG159803 DB	'HHC90404%s SHOW%s Decompressed %s header and data:', 0aH
	DB	00H
$SG159804 DB	'snap', 00H
	ORG $+3
$SG159809 DB	'A', 00H
	ORG $+2
$SG159805 DB	'cckddiag.c', 00H
	ORG $+1
$SG159843 DB	0aH, 00H
	ORG $+2
$SG159808 DB	'Press enter to continue', 00H
$SG159810 DB	'HHC02601%s %s', 0aH, 00H
	ORG $+1
$SG159811 DB	'snap', 00H
	ORG $+3
$SG159812 DB	'cckddiag.c', 00H
	ORG $+1
$SG159845 DB	0aH, 00H
	ORG $+2
$SG159849 DB	'End of track', 00H
	ORG $+3
$SG159850 DB	'I', 00H
	ORG $+2
$SG159875 DB	'D', 00H
	ORG $+2
$SG159851 DB	'HHC02601%s %s', 0aH, 00H
	ORG $+1
$SG159852 DB	'showtrkorblk', 00H
	ORG $+3
$SG159853 DB	'cckddiag.c', 00H
	ORG $+1
$SG159880 DB	0aH, 00H
	ORG $+2
$SG159876 DB	'HHC90405%s OFFTIFY hex string ''%s'' = 0x%16.16llX, dec '
	DB	'%lld.', 0aH, 00H
	ORG $+3
$SG159877 DB	'offtify', 00H
$SG159878 DB	'cckddiag.c', 00H
	ORG $+1
$SG159881 DB	'D', 00H
	ORG $+2
$SG159882 DB	'HHC90406%s OFFTIFY dec string ''%s'' = 0x%16.16llX, dec '
	DB	'%lld.', 0aH, 00H
	ORG $+3
$SG159883 DB	'offtify', 00H
$SG159884 DB	'cckddiag.c', 00H
	ORG $+1
$SG160017 DB	0aH, 00H
	ORG $+2
$SG159990 DB	'CCKD/CFBA diagnostic program', 00H
	ORG $+3
$SG159991 DB	'cckddiag', 00H
	ORG $+3
$SG160019 DB	'E', 00H
	ORG $+2
$SG160020 DB	'HHC02607%s error opening file %s: %s', 0aH, 00H
	ORG $+2
$SG160021 DB	'main', 00H
	ORG $+3
$SG160022 DB	'cckddiag.c', 00H
	ORG $+1
$SG160024 DB	0aH, 00H
	ORG $+2
$SG160025 DB	'DEVHDR', 00H
	ORG $+1
$SG160026 DB	'I', 00H
	ORG $+2
$SG160030 DB	0aH, 00H
	ORG $+2
$SG160027 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160028 DB	'main', 00H
	ORG $+3
$SG160029 DB	'cckddiag.c', 00H
	ORG $+1
$SG160034 DB	'S', 00H
	ORG $+2
$SG160035 DB	'HHC02608%s DASD table entry not found for devtype 0x%2.2'
	DB	'X', 0aH, 00H
	ORG $+1
$SG160036 DB	'main', 00H
	ORG $+3
$SG160041 DB	'S', 00H
	ORG $+2
$SG160037 DB	'cckddiag.c', 00H
	ORG $+1
$SG160047 DB	'E', 00H
	ORG $+2
$SG160042 DB	'HHC02608%s DASD table entry not found for devtype 0x%2.2'
	DB	'X', 0aH, 00H
	ORG $+1
$SG160043 DB	'main', 00H
	ORG $+3
$SG160053 DB	'D', 00H
	ORG $+2
$SG160044 DB	'cckddiag.c', 00H
	ORG $+1
$SG160058 DB	0aH, 00H
	ORG $+2
$SG160046 DB	'incorrect header id', 00H
$SG160060 DB	'I', 00H
	ORG $+2
$SG160048 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG160049 DB	'main', 00H
	ORG $+3
$SG160064 DB	0aH, 00H
	ORG $+2
$SG160050 DB	'cckddiag.c', 00H
	ORG $+1
$SG160068 DB	0aH, 00H
	ORG $+2
$SG160054 DB	'HHC90407%s %s device has %d heads/cylinder', 0aH, 00H
$SG160055 DB	'main', 00H
	ORG $+3
$SG160066 DB	'L1TAB', 00H
	ORG $+2
$SG160070 DB	'I', 00H
	ORG $+2
$SG160056 DB	'cckddiag.c', 00H
	ORG $+1
$SG160074 DB	0aH, 00H
	ORG $+2
$SG160059 DB	'CDEVHDR', 00H
$SG160061 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160062 DB	'main', 00H
	ORG $+3
$SG160063 DB	'cckddiag.c', 00H
	ORG $+1
$SG160069 DB	'L1TAB', 00H
	ORG $+2
$SG160077 DB	0aH, 00H
	ORG $+2
$SG160071 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160072 DB	'main', 00H
	ORG $+3
$SG160073 DB	'cckddiag.c', 00H
	ORG $+1
$SG160076 DB	'BULK', 00H
	ORG $+3
$SG160078 DB	':', 00H
	ORG $+2
$SG160079 DB	'IMAGE', 00H
	ORG $+2
$SG160080 DB	'I', 00H
	ORG $+6
$SG160081 DB	'HHC02613%s %s offset %lld (0x%16.16llX); length %d (0x%8'
	DB	'.8X) bytes%s', 0aH, 00H
	ORG $+2
$SG160082 DB	'main', 00H
	ORG $+3
$SG160083 DB	'cckddiag.c', 00H
	ORG $+1
$SG160084 DB	0aH, 00H
	ORG $+2
$SG160087 DB	'CCHH not supported for FBA', 00H
	ORG $+1
$SG160088 DB	'S', 00H
	ORG $+2
$SG160089 DB	'HHC02604%s %s%s', 0aH, 00H
	ORG $+3
$SG160090 DB	'main', 00H
	ORG $+3
$SG160097 DB	'Track', 00H
	ORG $+2
$SG160099 DB	'S', 00H
	ORG $+2
$SG160091 DB	'cckddiag.c', 00H
	ORG $+1
$SG160098 DB	'Block', 00H
	ORG $+2
$SG160108 DB	'I', 00H
	ORG $+2
$SG160100 DB	'HHC02617%s %s %d does not exist on this device', 0aH, 00H
$SG160101 DB	'main', 00H
	ORG $+3
$SG160102 DB	'cckddiag.c', 00H
	ORG $+1
$SG160110 DB	'main', 00H
	ORG $+7
$SG160109 DB	'HHC02609%s CC %d HH %d = reltrk %d; L1 index = %d, L2 in'
	DB	'dex = %d', 0aH, 00H
	ORG $+2
$SG160112 DB	'I', 00H
	ORG $+2
$SG160111 DB	'cckddiag.c', 00H
	ORG $+1
$SG160116 DB	'I', 00H
	ORG $+2
$SG160113 DB	'HHC02615%s Block %d; L1 index = %d, L2 index = %d', 0aH, 00H
	ORG $+1
$SG160114 DB	'main', 00H
	ORG $+3
$SG160122 DB	'track', 00H
	ORG $+2
$SG160124 DB	'S', 00H
	ORG $+2
$SG160115 DB	'cckddiag.c', 00H
	ORG $+1
$SG160130 DB	0aH, 00H
	ORG $+2
$SG160117 DB	'HHC02610%s L1 index %d = L2TAB offset %lld (0x%16.16llX)'
	DB	0aH, 00H
	ORG $+2
$SG160118 DB	'main', 00H
	ORG $+3
$SG160123 DB	'block', 00H
	ORG $+2
$SG160132 DB	'I', 00H
	ORG $+2
$SG160119 DB	'cckddiag.c', 00H
	ORG $+1
$SG160136 DB	0aH, 00H
	ORG $+2
$SG160125 DB	'HHC02618%s L2tab for %s %d not found', 0aH, 00H
	ORG $+2
$SG160126 DB	'main', 00H
	ORG $+3
$SG160127 DB	'cckddiag.c', 00H
	ORG $+1
$SG160128 DB	'L2TAB', 00H
	ORG $+2
$SG160131 DB	'L2TAB', 00H
	ORG $+2
$SG160137 DB	'I', 00H
	ORG $+2
$SG160133 DB	'HHC02614%s %s - %d (decimal) bytes:', 0aH, 00H
	ORG $+3
$SG160134 DB	'main', 00H
	ORG $+3
$SG160135 DB	'cckddiag.c', 00H
	ORG $+1
$SG160141 DB	0aH, 00H
	ORG $+2
$SG160138 DB	'HHC02611%s L2 index %d = L2TAB entry: %d bytes:', 0aH, 00H
	ORG $+3
$SG160139 DB	'main', 00H
	ORG $+3
$SG160144 DB	'TRKHDR', 00H
	ORG $+1
$SG160146 DB	'I', 00H
	ORG $+2
$SG160140 DB	'cckddiag.c', 00H
	ORG $+1
$SG160145 DB	'BKGHDR', 00H
	ORG $+5
$SG160147 DB	'HHC02613%s %s offset %lld (0x%16.16llX); length %d (0x%8'
	DB	'.8X) bytes%s', 0aH, 00H
	ORG $+2
$SG160148 DB	'main', 00H
	ORG $+3
$SG160149 DB	'cckddiag.c', 00H
	ORG $+1
$SG160152 DB	'Track', 00H
	ORG $+2
$SG160153 DB	'Block', 00H
	ORG $+2
$SG160154 DB	'S', 00H
	ORG $+2
$SG160155 DB	'HHC02619%s %s %d not found', 0aH, 00H
$SG160156 DB	'main', 00H
	ORG $+3
$SG160160 DB	'track', 00H
	ORG $+2
$SG160162 DB	'TRK', 00H
$SG160157 DB	'cckddiag.c', 00H
	ORG $+1
$SG160163 DB	'BKG', 00H
$SG160158 DB	'TRKHDR+DATA', 00H
$SG160164 DB	'I', 00H
	ORG $+2
$SG160159 DB	'BKGHDR+DATA', 00H
$SG160161 DB	'block', 00H
	ORG $+2
$SG160168 DB	0aH, 00H
	ORG $+2
$SG160165 DB	'HHC02612%s %sHDR %s %d:', 0aH, 00H
	ORG $+3
$SG160166 DB	'main', 00H
	ORG $+7
$SG160167 DB	'cckddiag.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:main
	DD	01aH
	DD	0175cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:showtrkorblk
	DD	02aH
	DD	0292H
voltbl	ENDS
xdata	SEGMENT
$unwind$ErrExit DD 010801H
	DD	04208H
$unwind$syntax DD 010901H
	DD	08209H
$unwind$clean DD 010401H
	DD	04204H
$unwind$makbuf DD 010d01H
	DD	0c20dH
$unwind$readpos DD 011701H
	DD	0e217H
$unwind$decomptrk DD 031901H
	DD	070154219H
	DD	06014H
$unwind$show_ckd_count DD 021001H
	DD	0150110H
$unwind$show_ckd_key DD 011801H
	DD	0e218H
$unwind$show_ckd_data DD 011801H
	DD	0e218H
$unwind$show_fba_block DD 011201H
	DD	08212H
$unwind$snap DD	011701H
	DD	0e217H
$unwind$showtrkorblk DD 023219H
	DD	0201d0120H
	DD	imagerel __GSHandlerCheck
	DD	0100d0H
$unwind$offtify DD 010901H
	DD	0e209H
$unwind$main DD	022219H
	DD	0d30110H
	DD	imagerel __GSHandlerCheck
	DD	0680H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$printf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
ckddasd$ = 112
cmd_tt$ = 113
swapend$ = 114
cmd_cchh$ = 115
cmd_trkdata$ = 116
trk$ = 120
cmd_devhdr$ = 124
cmd_cdevhdr$ = 125
cmd_l1tab$ = 126
cmd_offset$ = 127
cmd_l2tab$ = 128
cmd_hexdump$ = 129
imglen$ = 132
L2ndx$ = 136
num_L1tab$ = 140
L1ndx$ = 144
op_length$ = 148
pgm$ = 152
heads$ = 160
tv81 = 164
op_offset$ = 168
op_hh$ = 172
op_cc$ = 176
L2taboff$ = 184
op_tt$ = 192
trkhdroff$ = 200
blkgrp$1 = 208
tv445 = 212
tv443 = 216
tv447 = 220
tv318 = 224
cckd_diag_rc$ = 228
ckd$ = 232
fn$ = 240
p$2 = 248
fba$ = 256
tv590 = 264
tv659 = 272
tv779 = 280
tv795 = 288
tv810 = 296
tv820 = 304
tv824 = 312
tv234 = 320
tv470 = 328
tv503 = 336
tv505 = 344
tv688 = 352
cdevhdr$ = 368
devhdr$ = 880
pathname$ = 1392
__$ArrayPad$ = 1664
argc$ = 1696
argv$ = 1704
main	PROC

; 518  : {

$LN86:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 98 06
	00 00		 sub	 rsp, 1688		; 00000698H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 80
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 519  : int             cckd_diag_rc = 0;       /* Program return code       */

  00022	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cckd_diag_rc$[rsp], 0

; 520  : 
; 521  : char*           pgm;                    /* less any extension (.ext) */
; 522  : char*           fn;                     /* File name                 */
; 523  : 
; 524  : CKD_DEVHDR      devhdr;                 /* CKD device hdr            */
; 525  : CCKD_DEVHDR     cdevhdr;                /* Compressed CKD device hdr */
; 526  : 
; 527  : CKDDEV*         ckd          = NULL;    /* CKD DASD table entry      */

  0002d	48 c7 84 24 e8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ckd$[rsp], 0

; 528  : FBADEV*         fba          = NULL;    /* FBA DASD table entry      */

  00039	48 c7 84 24 00
	01 00 00 00 00
	00 00		 mov	 QWORD PTR fba$[rsp], 0

; 529  : 
; 530  : bool            cmd_devhdr   = false;   /* display DEVHDR            */

  00045	c6 44 24 7c 00	 mov	 BYTE PTR cmd_devhdr$[rsp], 0

; 531  : bool            cmd_cdevhdr  = false;   /* display CDEVHDR           */

  0004a	c6 44 24 7d 00	 mov	 BYTE PTR cmd_cdevhdr$[rsp], 0

; 532  : bool            cmd_l1tab    = false;   /* display L1TAB             */

  0004f	c6 44 24 7e 00	 mov	 BYTE PTR cmd_l1tab$[rsp], 0

; 533  : bool            cmd_l2tab    = false;   /* display L2TAB             */

  00054	c6 84 24 80 00
	00 00 00	 mov	 BYTE PTR cmd_l2tab$[rsp], 0

; 534  : bool            cmd_trkdata  = false;   /* display track data        */

  0005c	c6 44 24 74 00	 mov	 BYTE PTR cmd_trkdata$[rsp], 0

; 535  : bool            cmd_hexdump  = false;   /* display track data (hex)  */

  00061	c6 84 24 81 00
	00 00 00	 mov	 BYTE PTR cmd_hexdump$[rsp], 0

; 536  : 
; 537  : bool            cmd_offset   = false;   /* true = display data at    */

  00069	c6 44 24 7f 00	 mov	 BYTE PTR cmd_offset$[rsp], 0

; 538  : int             op_offset    = 0;       /* op_offset of length       */

  0006e	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_offset$[rsp], 0

; 539  : int             op_length    = 0;       /* op_length                 */

  00079	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_length$[rsp], 0

; 540  : 
; 541  : bool            cmd_cchh     = false;   /* true = display CCHH data  */

  00084	c6 44 24 73 00	 mov	 BYTE PTR cmd_cchh$[rsp], 0

; 542  : int             op_cc        = 0;       /* CC = cylinder             */

  00089	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_cc$[rsp], 0

; 543  : int             op_hh        = 0;       /* HH = head                 */

  00094	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_hh$[rsp], 0

; 544  : 
; 545  : bool            cmd_tt       = false;   /* true = display TT data    */

  0009f	c6 44 24 71 00	 mov	 BYTE PTR cmd_tt$[rsp], 0

; 546  : int             op_tt        = 0;       /* relative track/block #    */

  000a4	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR op_tt$[rsp], 0

; 547  : 
; 548  : int             heads        = 0;       /* Heads per cylinder        */

  000af	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR heads$[rsp], 0

; 549  : int             trk          = 0;       /* Track or block number     */

  000ba	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR trk$[rsp], 0

; 550  : int             imglen       = 0;       /* track length              */

  000c2	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR imglen$[rsp], 0

; 551  : 
; 552  : int             L1ndx        = 0;       /* Index into Level 1 table  */

  000cd	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR L1ndx$[rsp], 0

; 553  : int             L2ndx        = 0;       /* Index into Level 2 table  */

  000d8	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR L2ndx$[rsp], 0

; 554  : 
; 555  : off_t           L2taboff     = 0;       /* offset to assoc. L2 table */

  000e3	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR L2taboff$[rsp], 0

; 556  : off_t           trkhdroff    = 0;       /* offset to assoc. trk hdr  */

  000ef	48 c7 84 24 c8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR trkhdroff$[rsp], 0

; 557  : 
; 558  : bool            ckddasd = false;        /* true=CKD dasd, false=FBA  */

  000fb	c6 44 24 70 00	 mov	 BYTE PTR ckddasd$[rsp], 0

; 559  : bool            swapend = false;        /* 1 = New endianness doesn't

  00100	c6 44 24 72 00	 mov	 BYTE PTR swapend$[rsp], 0

; 560  :                                             match machine endianness */
; 561  : int             num_L1tab;              /* Number of L1tab entries   */
; 562  : char            pathname[ MAX_PATH ];   /* file path in host format  */
; 563  : 
; 564  :     INITIALIZE_UTILITY( UTILITY_NAME, UTILITY_DESC, &pgm );

  00105	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR pgm$[rsp]
  0010d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00112	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159990
  00119	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159991
  00120	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00128	8b 8c 24 a0 06
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_initialize_utility
  00135	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax

; 565  : 
; 566  :     /* parse the arguments */
; 567  : 
; 568  :     argc--; argv++;

  0013c	8b 84 24 a0 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00143	ff c8		 dec	 eax
  00145	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0014c	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00154	48 83 c0 08	 add	 rax, 8
  00158	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax
$LN2@main:

; 569  : 
; 570  :     while (argc > 0)

  00160	83 bc 24 a0 06
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00168	0f 8e 8b 04 00
	00		 jle	 $LN3@main

; 571  :     {
; 572  :         if (**argv != '-')

  0016e	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00176	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00179	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0017c	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0017f	74 05		 je	 SHORT $LN6@main

; 573  :             break;

  00181	e9 73 04 00 00	 jmp	 $LN3@main
$LN6@main:

; 574  : 
; 575  :         switch(argv[0][1])

  00186	b8 08 00 00 00	 mov	 eax, 8
  0018b	48 6b c0 00	 imul	 rax, rax, 0
  0018f	b9 01 00 00 00	 mov	 ecx, 1
  00194	48 6b c9 01	 imul	 rcx, rcx, 1
  00198	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001a0	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  001a4	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  001a8	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv81[rsp], eax
  001af	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv81[rsp]
  001b6	83 e8 31	 sub	 eax, 49			; 00000031H
  001b9	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv81[rsp], eax
  001c0	83 bc 24 a4 00
	00 00 47	 cmp	 DWORD PTR tv81[rsp], 71	; 00000047H
  001c8	0f 87 f5 03 00
	00		 ja	 $LN29@main
  001ce	48 63 84 24 a4
	00 00 00	 movsxd	 rax, DWORD PTR tv81[rsp]
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  001dd	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN84@main[rcx+rax]
  001e5	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN85@main[rcx+rax*4]
  001ec	48 03 c1	 add	 rax, rcx
  001ef	ff e0		 jmp	 rax
$LN7@main:

; 576  :         {
; 577  :             case 'v':
; 578  :                     if (argv[0][2] != '\0')

  001f1	b8 08 00 00 00	 mov	 eax, 8
  001f6	48 6b c0 00	 imul	 rax, rax, 0
  001fa	b9 01 00 00 00	 mov	 ecx, 1
  001ff	48 6b c9 02	 imul	 rcx, rcx, 2
  00203	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0020b	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0020f	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00213	85 c0		 test	 eax, eax
  00215	74 0d		 je	 SHORT $LN8@main

; 579  :                     {
; 580  :                         syntax (pgm);

  00217	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0021f	e8 00 00 00 00	 call	 syntax
$LN8@main:

; 581  :                     }
; 582  :                     ErrExit( EXIT_NORMAL_SUCCESS );

  00224	33 c9		 xor	 ecx, ecx
  00226	e8 00 00 00 00	 call	 ErrExit

; 583  :                     break;  /* Useless but prevents warning */

  0022b	e9 a0 03 00 00	 jmp	 $LN4@main
$LN9@main:

; 584  : 
; 585  :             case 'd':  if (argv[0][2] != '\0') syntax (pgm);

  00230	b8 08 00 00 00	 mov	 eax, 8
  00235	48 6b c0 00	 imul	 rax, rax, 0
  00239	b9 01 00 00 00	 mov	 ecx, 1
  0023e	48 6b c9 02	 imul	 rcx, rcx, 2
  00242	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0024a	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0024e	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00252	85 c0		 test	 eax, eax
  00254	74 0d		 je	 SHORT $LN10@main
  00256	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0025e	e8 00 00 00 00	 call	 syntax
$LN10@main:

; 586  :                        cmd_devhdr = true;

  00263	c6 44 24 7c 01	 mov	 BYTE PTR cmd_devhdr$[rsp], 1

; 587  :                        break;

  00268	e9 63 03 00 00	 jmp	 $LN4@main
$LN11@main:

; 588  : 
; 589  :             case 'c':  if (argv[0][2] != '\0') syntax (pgm);

  0026d	b8 08 00 00 00	 mov	 eax, 8
  00272	48 6b c0 00	 imul	 rax, rax, 0
  00276	b9 01 00 00 00	 mov	 ecx, 1
  0027b	48 6b c9 02	 imul	 rcx, rcx, 2
  0027f	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00287	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0028b	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0028f	85 c0		 test	 eax, eax
  00291	74 0d		 je	 SHORT $LN12@main
  00293	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0029b	e8 00 00 00 00	 call	 syntax
$LN12@main:

; 590  :                        cmd_cdevhdr = true;

  002a0	c6 44 24 7d 01	 mov	 BYTE PTR cmd_cdevhdr$[rsp], 1

; 591  :                        break;

  002a5	e9 26 03 00 00	 jmp	 $LN4@main
$LN13@main:

; 592  : 
; 593  :             case '1':  if (argv[0][2] != '\0') syntax (pgm);

  002aa	b8 08 00 00 00	 mov	 eax, 8
  002af	48 6b c0 00	 imul	 rax, rax, 0
  002b3	b9 01 00 00 00	 mov	 ecx, 1
  002b8	48 6b c9 02	 imul	 rcx, rcx, 2
  002bc	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  002c4	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  002c8	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  002cc	85 c0		 test	 eax, eax
  002ce	74 0d		 je	 SHORT $LN14@main
  002d0	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  002d8	e8 00 00 00 00	 call	 syntax
$LN14@main:

; 594  :                        cmd_l1tab = true;

  002dd	c6 44 24 7e 01	 mov	 BYTE PTR cmd_l1tab$[rsp], 1

; 595  :                        break;

  002e2	e9 e9 02 00 00	 jmp	 $LN4@main
$LN15@main:

; 596  : 
; 597  :             case '2':  if (argv[0][2] != '\0') syntax (pgm);

  002e7	b8 08 00 00 00	 mov	 eax, 8
  002ec	48 6b c0 00	 imul	 rax, rax, 0
  002f0	b9 01 00 00 00	 mov	 ecx, 1
  002f5	48 6b c9 02	 imul	 rcx, rcx, 2
  002f9	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00301	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00305	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00309	85 c0		 test	 eax, eax
  0030b	74 0d		 je	 SHORT $LN16@main
  0030d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00315	e8 00 00 00 00	 call	 syntax
$LN16@main:

; 598  :                        cmd_l2tab = true;

  0031a	c6 84 24 80 00
	00 00 01	 mov	 BYTE PTR cmd_l2tab$[rsp], 1

; 599  :                        break;

  00322	e9 a9 02 00 00	 jmp	 $LN4@main
$LN17@main:

; 600  : 
; 601  :             case 'a':  if (argv[0][2] != '\0') syntax (pgm);

  00327	b8 08 00 00 00	 mov	 eax, 8
  0032c	48 6b c0 00	 imul	 rax, rax, 0
  00330	b9 01 00 00 00	 mov	 ecx, 1
  00335	48 6b c9 02	 imul	 rcx, rcx, 2
  00339	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00341	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00345	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00349	85 c0		 test	 eax, eax
  0034b	74 0d		 je	 SHORT $LN18@main
  0034d	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00355	e8 00 00 00 00	 call	 syntax
$LN18@main:

; 602  :                        cmd_cchh = true;

  0035a	c6 44 24 73 01	 mov	 BYTE PTR cmd_cchh$[rsp], 1

; 603  : 
; 604  :                        argc--; argv++;

  0035f	8b 84 24 a0 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00366	ff c8		 dec	 eax
  00368	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0036f	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  00377	48 83 c0 08	 add	 rax, 8
  0037b	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 605  :                        op_cc = (int) offtify(*argv);

  00383	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0038b	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0038e	e8 00 00 00 00	 call	 offtify
  00393	89 84 24 b0 00
	00 00		 mov	 DWORD PTR op_cc$[rsp], eax

; 606  : 
; 607  :                        argc--; argv++;

  0039a	8b 84 24 a0 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  003a1	ff c8		 dec	 eax
  003a3	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  003aa	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  003b2	48 83 c0 08	 add	 rax, 8
  003b6	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 608  :                        op_hh = (int) offtify(*argv);

  003be	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  003c6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  003c9	e8 00 00 00 00	 call	 offtify
  003ce	89 84 24 ac 00
	00 00		 mov	 DWORD PTR op_hh$[rsp], eax

; 609  :                        break;

  003d5	e9 f6 01 00 00	 jmp	 $LN4@main
$LN19@main:

; 610  : 
; 611  :             case 'r':  if (argv[0][2] != '\0') syntax (pgm);

  003da	b8 08 00 00 00	 mov	 eax, 8
  003df	48 6b c0 00	 imul	 rax, rax, 0
  003e3	b9 01 00 00 00	 mov	 ecx, 1
  003e8	48 6b c9 02	 imul	 rcx, rcx, 2
  003ec	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  003f4	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  003f8	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  003fc	85 c0		 test	 eax, eax
  003fe	74 0d		 je	 SHORT $LN20@main
  00400	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00408	e8 00 00 00 00	 call	 syntax
$LN20@main:

; 612  :                        cmd_tt = true;

  0040d	c6 44 24 71 01	 mov	 BYTE PTR cmd_tt$[rsp], 1

; 613  : 
; 614  :                        argc--; argv++;

  00412	8b 84 24 a0 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00419	ff c8		 dec	 eax
  0041b	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  00422	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0042a	48 83 c0 08	 add	 rax, 8
  0042e	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 615  :                        op_tt = (int) offtify(*argv);

  00436	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0043e	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00441	e8 00 00 00 00	 call	 offtify
  00446	89 84 24 c0 00
	00 00		 mov	 DWORD PTR op_tt$[rsp], eax

; 616  :                        break;

  0044d	e9 7e 01 00 00	 jmp	 $LN4@main
$LN21@main:

; 617  : 
; 618  :             case 'o':  if (argv[0][2] != '\0') syntax (pgm);

  00452	b8 08 00 00 00	 mov	 eax, 8
  00457	48 6b c0 00	 imul	 rax, rax, 0
  0045b	b9 01 00 00 00	 mov	 ecx, 1
  00460	48 6b c9 02	 imul	 rcx, rcx, 2
  00464	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0046c	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00470	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00474	85 c0		 test	 eax, eax
  00476	74 0d		 je	 SHORT $LN22@main
  00478	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00480	e8 00 00 00 00	 call	 syntax
$LN22@main:

; 619  :                        cmd_offset = true;

  00485	c6 44 24 7f 01	 mov	 BYTE PTR cmd_offset$[rsp], 1

; 620  : 
; 621  :                        argc--; argv++;

  0048a	8b 84 24 a0 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00491	ff c8		 dec	 eax
  00493	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  0049a	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004a2	48 83 c0 08	 add	 rax, 8
  004a6	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 622  :                        op_offset = (int) offtify(*argv);

  004ae	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004b6	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004b9	e8 00 00 00 00	 call	 offtify
  004be	89 84 24 a8 00
	00 00		 mov	 DWORD PTR op_offset$[rsp], eax

; 623  : 
; 624  :                        argc--; argv++;

  004c5	8b 84 24 a0 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  004cc	ff c8		 dec	 eax
  004ce	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  004d5	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004dd	48 83 c0 08	 add	 rax, 8
  004e1	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 625  :                        op_length = (int) offtify(*argv);

  004e9	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  004f1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  004f4	e8 00 00 00 00	 call	 offtify
  004f9	89 84 24 94 00
	00 00		 mov	 DWORD PTR op_length$[rsp], eax

; 626  :                        break;

  00500	e9 cb 00 00 00	 jmp	 $LN4@main
$LN23@main:

; 627  : 
; 628  :             case 't':  if (argv[0][2] != '\0') syntax (pgm);

  00505	b8 08 00 00 00	 mov	 eax, 8
  0050a	48 6b c0 00	 imul	 rax, rax, 0
  0050e	b9 01 00 00 00	 mov	 ecx, 1
  00513	48 6b c9 02	 imul	 rcx, rcx, 2
  00517	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0051f	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00523	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00527	85 c0		 test	 eax, eax
  00529	74 0d		 je	 SHORT $LN24@main
  0052b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00533	e8 00 00 00 00	 call	 syntax
$LN24@main:

; 629  :                        cmd_trkdata = true;

  00538	c6 44 24 74 01	 mov	 BYTE PTR cmd_trkdata$[rsp], 1

; 630  :                        break;

  0053d	e9 8e 00 00 00	 jmp	 $LN4@main
$LN25@main:

; 631  : 
; 632  :             case 'x':  if (argv[0][2] != '\0') syntax (pgm);

  00542	b8 08 00 00 00	 mov	 eax, 8
  00547	48 6b c0 00	 imul	 rax, rax, 0
  0054b	b9 01 00 00 00	 mov	 ecx, 1
  00550	48 6b c9 02	 imul	 rcx, rcx, 2
  00554	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0055c	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00560	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00564	85 c0		 test	 eax, eax
  00566	74 0d		 je	 SHORT $LN26@main
  00568	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  00570	e8 00 00 00 00	 call	 syntax
$LN26@main:

; 633  :                        cmd_hexdump = true;

  00575	c6 84 24 81 00
	00 00 01	 mov	 BYTE PTR cmd_hexdump$[rsp], 1

; 634  :                        cmd_trkdata = true;

  0057d	c6 44 24 74 01	 mov	 BYTE PTR cmd_trkdata$[rsp], 1

; 635  :                        break;

  00582	eb 4c		 jmp	 SHORT $LN4@main
$LN27@main:

; 636  : 
; 637  :             case 'g':  if (argv[0][2] != '\0') syntax (pgm);

  00584	b8 08 00 00 00	 mov	 eax, 8
  00589	48 6b c0 00	 imul	 rax, rax, 0
  0058d	b9 01 00 00 00	 mov	 ecx, 1
  00592	48 6b c9 02	 imul	 rcx, rcx, 2
  00596	48 8b 94 24 a8
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0059e	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  005a2	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  005a6	85 c0		 test	 eax, eax
  005a8	74 0d		 je	 SHORT $LN28@main
  005aa	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  005b2	e8 00 00 00 00	 call	 syntax
$LN28@main:

; 638  :                        debug = 1;

  005b7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR debug, 1

; 639  :                        break;

  005c1	eb 0d		 jmp	 SHORT $LN4@main
$LN29@main:

; 640  : 
; 641  :             default:   syntax (pgm);

  005c3	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  005cb	e8 00 00 00 00	 call	 syntax
$LN4@main:

; 642  :         }
; 643  : 
; 644  :         argc--; argv++;

  005d0	8b 84 24 a0 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  005d7	ff c8		 dec	 eax
  005d9	89 84 24 a0 06
	00 00		 mov	 DWORD PTR argc$[rsp], eax
  005e0	48 8b 84 24 a8
	06 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005e8	48 83 c0 08	 add	 rax, 8
  005ec	48 89 84 24 a8
	06 00 00	 mov	 QWORD PTR argv$[rsp], rax

; 645  :     }

  005f4	e9 67 fb ff ff	 jmp	 $LN2@main
$LN3@main:

; 646  : 
; 647  :     if (argc != 1)

  005f9	83 bc 24 a0 06
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00601	74 0d		 je	 SHORT $LN30@main

; 648  :         syntax (pgm);

  00603	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR pgm$[rsp]
  0060b	e8 00 00 00 00	 call	 syntax
$LN30@main:

; 649  : 
; 650  :     printf("\n");

  00610	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160017
  00617	e8 00 00 00 00	 call	 printf

; 651  : 
; 652  :     fn = argv[0];

  0061c	b8 08 00 00 00	 mov	 eax, 8
  00621	48 6b c0 00	 imul	 rax, rax, 0
  00625	48 8b 8c 24 a8
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0062d	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  00631	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR fn$[rsp], rax

; 653  : 
; 654  :     /* open the file */
; 655  :     hostpath( pathname, fn, sizeof( pathname ));

  00639	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0063f	48 8b 94 24 f0
	00 00 00	 mov	 rdx, QWORD PTR fn$[rsp]
  00647	48 8d 8c 24 70
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0064f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 656  :     fd = HOPEN( pathname, O_RDONLY | O_BINARY );

  00655	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0065a	48 8d 8c 24 70
	05 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00662	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00668	89 05 00 00 00
	00		 mov	 DWORD PTR fd, eax

; 657  : 
; 658  :     if (fd < 0)

  0066e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR fd, 0
  00675	0f 8d 81 00 00
	00		 jge	 $LN31@main

; 659  :     {
; 660  :         // "error opening file %s: %s"
; 661  :         FWRMSG( stderr, HHC02607, "E", fn, strerror( errno ));

  0067b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00681	8b 08		 mov	 ecx, DWORD PTR [rax]
  00683	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00689	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR tv234[rsp], rax
  00691	b9 02 00 00 00	 mov	 ecx, 2
  00696	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0069c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv234[rsp]
  006a4	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  006a9	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR fn$[rsp]
  006b1	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160019
  006bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160020
  006c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  006d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160021
  006e0	ba 95 02 00 00	 mov	 edx, 661		; 00000295H
  006e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160022
  006ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 662  :         ErrExit( EXIT_OPEN_ERROR );

  006f2	b9 08 00 00 00	 mov	 ecx, 8
  006f7	e8 00 00 00 00	 call	 ErrExit
$LN31@main:

; 663  :     }
; 664  : 
; 665  :     /*---------------------------------------------------------------*/
; 666  :     /* display DEVHDR - first 512 bytes of dasd image                */
; 667  :     /*---------------------------------------------------------------*/
; 668  :     readpos( fd, &devhdr, 0, CKD_DEVHDR_SIZE );

  006fc	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00702	45 33 c0	 xor	 r8d, r8d
  00705	48 8d 94 24 70
	03 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  0070d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00713	e8 00 00 00 00	 call	 readpos

; 669  : 
; 670  :     if (cmd_devhdr)

  00718	0f b6 44 24 7c	 movzx	 eax, BYTE PTR cmd_devhdr$[rsp]
  0071d	85 c0		 test	 eax, eax
  0071f	0f 84 b6 00 00
	00		 je	 $LN32@main

; 671  :     {
; 672  :         BYTE* p = (BYTE*) &devhdr;

  00725	48 8d 84 24 70
	03 00 00	 lea	 rax, QWORD PTR devhdr$[rsp]
  0072d	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR p$2[rsp], rax

; 673  : 
; 674  :         // "%s - %d (decimal) bytes:"
; 675  :         printf("\n");

  00735	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160024
  0073c	e8 00 00 00 00	 call	 printf

; 676  :         WRMSG( HHC02614, "I", "DEVHDR", (int) CKD_DEVHDR_SIZE );

  00741	b9 01 00 00 00	 mov	 ecx, 1
  00746	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0074c	c7 44 24 40 00
	02 00 00	 mov	 DWORD PTR [rsp+64], 512	; 00000200H
  00754	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160025
  0075b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00760	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160026
  00767	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0076c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160027
  00773	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00778	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0077d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00783	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160028
  0078a	ba a4 02 00 00	 mov	 edx, 676		; 000002a4H
  0078f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160029
  00796	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 677  : 
; 678  :         // Note: first 8 bytes of DEVHDR is in ASCII, but
; 679  :         // the data_dump function dumps 16 bytes per line.
; 680  :         data_dump_ascii ( p,                       16 );

  0079c	ba 10 00 00 00	 mov	 edx, 16
  007a1	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR p$2[rsp]
  007a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump_ascii

; 681  :         data_dump_offset( p + 16, CKD_DEVHDR_SIZE, 16 );

  007af	48 8b 84 24 f8
	00 00 00	 mov	 rax, QWORD PTR p$2[rsp]
  007b7	48 83 c0 10	 add	 rax, 16
  007bb	41 b8 10 00 00
	00		 mov	 r8d, 16
  007c1	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  007c6	48 8b c8	 mov	 rcx, rax
  007c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump_offset

; 682  : 
; 683  :         printf("\n");

  007cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160030
  007d6	e8 00 00 00 00	 call	 printf
$LN32@main:

; 684  :     }
; 685  : 
; 686  :     /*---------------------------------------------------------------*/
; 687  :     /* Determine CKD or FBA device type                              */
; 688  :     /*---------------------------------------------------------------*/
; 689  :     if (is_dh_devid_typ( devhdr.dh_devid, CKD32_CMP_OR_SF_TYP ))

  007db	ba 00 00 00 60	 mov	 edx, 1610612736		; 60000000H
  007e0	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  007e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_is_dh_devid_typ
  007ee	0f b6 c0	 movzx	 eax, al
  007f1	85 c0		 test	 eax, eax
  007f3	0f 84 a8 00 00
	00		 je	 $LN33@main

; 690  :     {
; 691  :         ckddasd = true;

  007f9	c6 44 24 70 01	 mov	 BYTE PTR ckddasd$[rsp], 1

; 692  : 
; 693  :         ckd = dasd_lookup( DASD_CKDDEV, NULL, devhdr.dh_devtyp, 0 );

  007fe	0f b6 84 24 80
	03 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  00806	45 33 c9	 xor	 r9d, r9d
  00809	44 8b c0	 mov	 r8d, eax
  0080c	33 d2		 xor	 edx, edx
  0080e	b9 01 00 00 00	 mov	 ecx, 1
  00813	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  00819	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR ckd$[rsp], rax

; 694  : 
; 695  :         if (!ckd)

  00821	48 83 bc 24 e8
	00 00 00 00	 cmp	 QWORD PTR ckd$[rsp], 0
  0082a	75 70		 jne	 SHORT $LN35@main

; 696  :         {
; 697  :             // "DASD table entry not found for devtype 0x%2.2X"
; 698  :             FWRMSG( stderr, HHC02608, "S", devhdr.dh_devtyp );

  0082c	0f b6 84 24 80
	03 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  00834	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv318[rsp], eax
  0083b	b9 02 00 00 00	 mov	 ecx, 2
  00840	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00846	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv318[rsp]
  0084d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00851	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160034
  00858	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0085d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160035
  00864	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00869	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0086e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00874	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160036
  0087b	ba ba 02 00 00	 mov	 edx, 698		; 000002baH
  00880	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160037
  00887	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 699  :             clean();

  0088d	e8 00 00 00 00	 call	 clean

; 700  :             ErrExit( EXIT_NO_CKD_DASDTAB );

  00892	b9 05 00 00 00	 mov	 ecx, 5
  00897	e8 00 00 00 00	 call	 ErrExit
$LN35@main:

; 701  :         }
; 702  :     }

  0089c	e9 1f 01 00 00	 jmp	 $LN34@main
$LN33@main:

; 703  :     else if (is_dh_devid_typ( devhdr.dh_devid, FBA32_CMP_OR_SF_TYP ))

  008a1	ba 00 60 00 00	 mov	 edx, 24576		; 00006000H
  008a6	48 8d 8c 24 70
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  008ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_is_dh_devid_typ
  008b4	0f b6 c0	 movzx	 eax, al
  008b7	85 c0		 test	 eax, eax
  008b9	0f 84 93 00 00
	00		 je	 $LN36@main

; 704  :     {
; 705  :         ckddasd = false;

  008bf	c6 44 24 70 00	 mov	 BYTE PTR ckddasd$[rsp], 0

; 706  : 
; 707  :         fba = dasd_lookup( DASD_FBADEV, NULL, devhdr.dh_devtyp, 0 );

  008c4	0f b6 84 24 80
	03 00 00	 movzx	 eax, BYTE PTR devhdr$[rsp+16]
  008cc	45 33 c9	 xor	 r9d, r9d
  008cf	44 8b c0	 mov	 r8d, eax
  008d2	33 d2		 xor	 edx, edx
  008d4	b9 03 00 00 00	 mov	 ecx, 3
  008d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_dasd_lookup
  008df	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR fba$[rsp], rax

; 708  : 
; 709  :         if (!fba)

  008e7	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR fba$[rsp], 0
  008f0	75 5e		 jne	 SHORT $LN38@main

; 710  :         {
; 711  :             // "DASD table entry not found for devtype 0x%2.2X"
; 712  :             FWRMSG( stderr, HHC02608, "S", DEFAULT_FBA_TYPE );

  008f2	b9 02 00 00 00	 mov	 ecx, 2
  008f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008fd	c7 44 24 38 70
	33 00 00	 mov	 DWORD PTR [rsp+56], 13168 ; 00003370H
  00905	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160041
  0090c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00911	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160042
  00918	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0091d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00922	41 b9 03 00 00
	00		 mov	 r9d, 3
  00928	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160043
  0092f	ba c8 02 00 00	 mov	 edx, 712		; 000002c8H
  00934	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160044
  0093b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 713  :             clean();

  00941	e8 00 00 00 00	 call	 clean

; 714  :             ErrExit( EXIT_NO_FBA_DASDTAB );

  00946	b9 06 00 00 00	 mov	 ecx, 6
  0094b	e8 00 00 00 00	 call	 ErrExit
$LN38@main:

; 715  :         }
; 716  :     }

  00950	eb 6e		 jmp	 SHORT $LN37@main
$LN36@main:

; 717  :     else
; 718  :     {
; 719  :         // "%s%s"
; 720  :         FWRMSG( stderr, HHC02604, "E", "incorrect header id", "" );

  00952	b9 02 00 00 00	 mov	 ecx, 2
  00957	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0095d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160045
  00964	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00969	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160046
  00970	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00975	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160047
  0097c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00981	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160048
  00988	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0098d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00992	41 b9 03 00 00
	00		 mov	 r9d, 3
  00998	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160049
  0099f	ba d0 02 00 00	 mov	 edx, 720		; 000002d0H
  009a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160050
  009ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 721  :         clean();

  009b1	e8 00 00 00 00	 call	 clean

; 722  :         ErrExit( EXIT_WRONG_CCKD_TYPE );

  009b6	b9 09 00 00 00	 mov	 ecx, 9
  009bb	e8 00 00 00 00	 call	 ErrExit
$LN37@main:
$LN34@main:

; 723  :     }
; 724  : 
; 725  :     /*---------------------------------------------------------------*/
; 726  :     /* Set up device characteristics                                 */
; 727  :     /*---------------------------------------------------------------*/
; 728  :     if (ckddasd)

  009c0	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  009c5	85 c0		 test	 eax, eax
  009c7	0f 84 8d 00 00
	00		 je	 $LN39@main

; 729  :     {
; 730  :         FETCH_LE_FW( heads, devhdr.dh_heads );

  009cd	48 8d 8c 24 78
	03 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp+8]
  009d5	e8 00 00 00 00	 call	 fetch_fw_noswap
  009da	8b c8		 mov	 ecx, eax
  009dc	e8 00 00 00 00	 call	 _byteswap_ulong
  009e1	8b c8		 mov	 ecx, eax
  009e3	e8 00 00 00 00	 call	 _byteswap_ulong
  009e8	89 84 24 a0 00
	00 00		 mov	 DWORD PTR heads$[rsp], eax

; 731  : 
; 732  :         if (debug)

  009ef	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  009f6	74 62		 je	 SHORT $LN40@main

; 733  :         {
; 734  :             // "%s device has %d heads/cylinder"
; 735  :             WRMSG( HHC90407, "D", ckd->name, heads);

  009f8	b9 01 00 00 00	 mov	 ecx, 1
  009fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a03	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR heads$[rsp]
  00a0a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a0e	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR ckd$[rsp]
  00a16	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00a19	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a1e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160053
  00a25	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160054
  00a31	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a36	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a3b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a41	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160055
  00a48	ba df 02 00 00	 mov	 edx, 735		; 000002dfH
  00a4d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160056
  00a54	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN40@main:
$LN39@main:

; 736  :         }
; 737  :     }
; 738  : 
; 739  :     /*---------------------------------------------------------------*/
; 740  :     /* display CDEVHDR - follows DEVHDR                              */
; 741  :     /*---------------------------------------------------------------*/
; 742  :     readpos( fd, &cdevhdr, CKD_DEVHDR_SIZE, sizeof( cdevhdr ));

  00a5a	41 b9 00 02 00
	00		 mov	 r9d, 512		; 00000200H
  00a60	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00a66	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  00a6e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00a74	e8 00 00 00 00	 call	 readpos

; 743  : 
; 744  :     if (cmd_cdevhdr)

  00a79	0f b6 44 24 7d	 movzx	 eax, BYTE PTR cmd_cdevhdr$[rsp]
  00a7e	85 c0		 test	 eax, eax
  00a80	0f 84 86 00 00
	00		 je	 $LN41@main

; 745  :     {
; 746  :         // "%s - %d (decimal) bytes:"
; 747  :         printf("\n");

  00a86	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160058
  00a8d	e8 00 00 00 00	 call	 printf

; 748  :         WRMSG( HHC02614, "I", "CDEVHDR", (int) sizeof( cdevhdr ));

  00a92	b9 01 00 00 00	 mov	 ecx, 1
  00a97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a9d	c7 44 24 40 00
	02 00 00	 mov	 DWORD PTR [rsp+64], 512	; 00000200H
  00aa5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160059
  00aac	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00ab1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160060
  00ab8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00abd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160061
  00ac4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ac9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00ace	41 b9 03 00 00
	00		 mov	 r9d, 3
  00ad4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160062
  00adb	ba ec 02 00 00	 mov	 edx, 748		; 000002ecH
  00ae0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160063
  00ae7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 749  :         data_dump( &cdevhdr, sizeof( cdevhdr ));

  00aed	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00af2	48 8d 8c 24 70
	01 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp]
  00afa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 750  :         printf("\n");

  00b00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160064
  00b07	e8 00 00 00 00	 call	 printf
$LN41@main:

; 751  :     }
; 752  : 
; 753  :     /*---------------------------------------------------------------*/
; 754  :     /* Find machine endian-ness                                      */
; 755  :     /* cckd_def_opt_bigend() returns 1 for big-endian machines       */
; 756  :     /*---------------------------------------------------------------*/
; 757  :     swapend = (cckd_def_opt_bigend() !=

  00b0c	0f b6 84 24 73
	01 00 00	 movzx	 eax, BYTE PTR cdevhdr$[rsp+3]
  00b14	83 e0 02	 and	 eax, 2
  00b17	85 c0		 test	 eax, eax
  00b19	74 0d		 je	 SHORT $LN64@main
  00b1b	c7 84 24 d8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv443[rsp], 1
  00b26	eb 0b		 jmp	 SHORT $LN65@main
$LN64@main:
  00b28	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv443[rsp], 0
$LN65@main:
  00b33	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cckd_def_opt_bigend
  00b39	3b 84 24 d8 00
	00 00		 cmp	 eax, DWORD PTR tv443[rsp]
  00b40	74 0d		 je	 SHORT $LN66@main
  00b42	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv445[rsp], 1
  00b4d	eb 0b		 jmp	 SHORT $LN67@main
$LN66@main:
  00b4f	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv445[rsp], 0
$LN67@main:
  00b5a	83 bc 24 d4 00
	00 00 00	 cmp	 DWORD PTR tv445[rsp], 0
  00b62	75 0d		 jne	 SHORT $LN68@main
  00b64	c7 84 24 dc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv447[rsp], 0
  00b6f	eb 0b		 jmp	 SHORT $LN69@main
$LN68@main:
  00b71	c7 84 24 dc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv447[rsp], 1
$LN69@main:
  00b7c	0f b6 84 24 dc
	00 00 00	 movzx	 eax, BYTE PTR tv447[rsp]
  00b84	88 44 24 72	 mov	 BYTE PTR swapend$[rsp], al

; 758  :                ((cdevhdr.cdh_opts & CCKD_OPT_BIGEND) != 0));
; 759  : 
; 760  :     /*---------------------------------------------------------------*/
; 761  :     /* display L1TAB - follows CDEVHDR                               */
; 762  :     /*---------------------------------------------------------------*/
; 763  : 
; 764  :     /* swap num_L1tab if needed */
; 765  :     num_L1tab = cdevhdr.num_L1tab;

  00b88	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR cdevhdr$[rsp+4]
  00b8f	89 84 24 8c 00
	00 00		 mov	 DWORD PTR num_L1tab$[rsp], eax

; 766  :     if (swapend)

  00b96	0f b6 44 24 72	 movzx	 eax, BYTE PTR swapend$[rsp]
  00b9b	85 c0		 test	 eax, eax
  00b9d	74 13		 je	 SHORT $LN42@main

; 767  :         num_L1tab = SWAP32( num_L1tab );

  00b9f	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR num_L1tab$[rsp]
  00ba6	e8 00 00 00 00	 call	 _byteswap_ulong
  00bab	89 84 24 8c 00
	00 00		 mov	 DWORD PTR num_L1tab$[rsp], eax
$LN42@main:

; 768  : 
; 769  :     L1tab = makbuf( num_L1tab * CCKD_L1ENT_SIZE, "L1TAB" );

  00bb2	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00bba	48 c1 e0 02	 shl	 rax, 2
  00bbe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160066
  00bc5	8b c8		 mov	 ecx, eax
  00bc7	e8 00 00 00 00	 call	 makbuf
  00bcc	48 89 05 00 00
	00 00		 mov	 QWORD PTR L1tab, rax

; 770  :     readpos( fd, L1tab, CCKD_L1TAB_POS, num_L1tab * CCKD_L1ENT_SIZE );

  00bd3	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00bdb	48 c1 e0 02	 shl	 rax, 2
  00bdf	44 8b c8	 mov	 r9d, eax
  00be2	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  00be8	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR L1tab
  00bef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00bf5	e8 00 00 00 00	 call	 readpos

; 771  : 
; 772  :     /* L1TAB itself is NOT adjusted for endian-ness */
; 773  :     if (cmd_l1tab)

  00bfa	0f b6 44 24 7e	 movzx	 eax, BYTE PTR cmd_l1tab$[rsp]
  00bff	85 c0		 test	 eax, eax
  00c01	0f 84 a6 00 00
	00		 je	 $LN43@main

; 774  :     {
; 775  :         // "%s - %d (decimal) bytes:"
; 776  :         printf("\n");

  00c07	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160068
  00c0e	e8 00 00 00 00	 call	 printf

; 777  :         WRMSG( HHC02614, "I", "L1TAB", (int) (num_L1tab * CCKD_L1ENT_SIZE) );

  00c13	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00c1b	48 c1 e0 02	 shl	 rax, 2
  00c1f	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv470[rsp], rax
  00c27	b9 01 00 00 00	 mov	 ecx, 1
  00c2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c32	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv470[rsp]
  00c3a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160069
  00c45	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160070
  00c51	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c56	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160071
  00c5d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c62	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c67	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c6d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160072
  00c74	ba 09 03 00 00	 mov	 edx, 777		; 00000309H
  00c79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160073
  00c80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 778  :         data_dump( L1tab, num_L1tab * CCKD_L1ENT_SIZE );

  00c86	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR num_L1tab$[rsp]
  00c8e	48 c1 e0 02	 shl	 rax, 2
  00c92	8b d0		 mov	 edx, eax
  00c94	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  00c9b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 779  :         printf("\n");

  00ca1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160074
  00ca8	e8 00 00 00 00	 call	 printf
$LN43@main:

; 780  :     }
; 781  : 
; 782  :     /*---------------------------------------------------------------*/
; 783  :     /* display OFFSET, LENGTH data                                   */
; 784  :     /*---------------------------------------------------------------*/
; 785  :     if (cmd_offset)

  00cad	0f b6 44 24 7f	 movzx	 eax, BYTE PTR cmd_offset$[rsp]
  00cb2	85 c0		 test	 eax, eax
  00cb4	0f 84 32 01 00
	00		 je	 $LN44@main

; 786  :     {
; 787  :         bulk = makbuf(op_length, "BULK");

  00cba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160076
  00cc1	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR op_length$[rsp]
  00cc8	e8 00 00 00 00	 call	 makbuf
  00ccd	48 89 05 00 00
	00 00		 mov	 QWORD PTR bulk, rax

; 788  : 
; 789  :         readpos(fd, bulk, op_offset, op_length);

  00cd4	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR op_offset$[rsp]
  00cdc	44 8b 8c 24 94
	00 00 00	 mov	 r9d, DWORD PTR op_length$[rsp]
  00ce4	4c 8b c0	 mov	 r8, rax
  00ce7	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR bulk
  00cee	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  00cf4	e8 00 00 00 00	 call	 readpos

; 790  : 
; 791  :         // "%s offset %"PRId64" (0x%16.16"PRIX64"); length %d (0x%8.8X) bytes%s"
; 792  :         printf("\n");

  00cf9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160077
  00d00	e8 00 00 00 00	 call	 printf

; 793  :         WRMSG( HHC02613, "I", "IMAGE",

  00d05	48 63 84 24 a8
	00 00 00	 movsxd	 rax, DWORD PTR op_offset$[rsp]
  00d0d	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv503[rsp], rax
  00d15	48 63 8c 24 a8
	00 00 00	 movsxd	 rcx, DWORD PTR op_offset$[rsp]
  00d1d	48 89 8c 24 58
	01 00 00	 mov	 QWORD PTR tv505[rsp], rcx
  00d25	b9 01 00 00 00	 mov	 ecx, 1
  00d2a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d30	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160078
  00d37	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00d3c	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR op_length$[rsp]
  00d43	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00d47	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR op_length$[rsp]
  00d4e	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00d52	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv503[rsp]
  00d5a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d5f	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv505[rsp]
  00d67	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00d6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160079
  00d73	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00d78	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160080
  00d7f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d84	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160081
  00d8b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d90	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d95	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d9b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160082
  00da2	ba 1a 03 00 00	 mov	 edx, 794		; 0000031aH
  00da7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160083
  00dae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 794  :             (U64) op_offset, (U64) op_offset, op_length, op_length, ":" );
; 795  :         data_dump( bulk, op_length );

  00db4	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR op_length$[rsp]
  00dbb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bulk
  00dc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 796  :         printf("\n");

  00dc8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160084
  00dcf	e8 00 00 00 00	 call	 printf

; 797  : 
; 798  :         free(bulk);

  00dd4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bulk
  00ddb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 799  :         bulk = NULL;

  00de1	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR bulk, 0
$LN44@main:

; 800  :     }
; 801  : 
; 802  :     /*---------------------------------------------------------------*/
; 803  :     /* FBA devices don't have cylinders or heads                     */
; 804  :     /*---------------------------------------------------------------*/
; 805  :     if (!ckddasd && cmd_cchh)

  00dec	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00df1	85 c0		 test	 eax, eax
  00df3	75 77		 jne	 SHORT $LN45@main
  00df5	0f b6 44 24 73	 movzx	 eax, BYTE PTR cmd_cchh$[rsp]
  00dfa	85 c0		 test	 eax, eax
  00dfc	74 6e		 je	 SHORT $LN45@main

; 806  :     {
; 807  :         // "%s%s"
; 808  :         FWRMSG( stderr, HHC02604, "S", "CCHH not supported for FBA", "" );

  00dfe	b9 02 00 00 00	 mov	 ecx, 2
  00e03	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e09	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160086
  00e10	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00e15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160087
  00e1c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00e21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160088
  00e28	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160089
  00e34	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e39	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e3e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e44	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160090
  00e4b	ba 28 03 00 00	 mov	 edx, 808		; 00000328H
  00e50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160091
  00e57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 809  :         clean();

  00e5d	e8 00 00 00 00	 call	 clean

; 810  :         ErrExit( EXIT_NO_FBA_CCHH );

  00e62	b9 03 00 00 00	 mov	 ecx, 3
  00e67	e8 00 00 00 00	 call	 ErrExit
$LN45@main:

; 811  :     }
; 812  : 
; 813  :     /*---------------------------------------------------------------*/
; 814  :     /* Setup CCHH or relative track request                          */
; 815  :     /*---------------------------------------------------------------*/
; 816  :     if (ckddasd)

  00e6c	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00e71	85 c0		 test	 eax, eax
  00e73	0f 84 80 00 00
	00		 je	 $LN46@main

; 817  :     {
; 818  :         if (cmd_tt)

  00e79	0f b6 44 24 71	 movzx	 eax, BYTE PTR cmd_tt$[rsp]
  00e7e	85 c0		 test	 eax, eax
  00e80	74 35		 je	 SHORT $LN47@main

; 819  :         {
; 820  :             trk = op_tt;

  00e82	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR op_tt$[rsp]
  00e89	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax

; 821  :             op_cc = trk / heads;

  00e8d	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00e91	99		 cdq
  00e92	f7 bc 24 a0 00
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00e99	89 84 24 b0 00
	00 00		 mov	 DWORD PTR op_cc$[rsp], eax

; 822  :             op_hh = trk % heads;

  00ea0	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00ea4	99		 cdq
  00ea5	f7 bc 24 a0 00
	00 00		 idiv	 DWORD PTR heads$[rsp]
  00eac	8b c2		 mov	 eax, edx
  00eae	89 84 24 ac 00
	00 00		 mov	 DWORD PTR op_hh$[rsp], eax

; 823  :         }

  00eb5	eb 1a		 jmp	 SHORT $LN48@main
$LN47@main:

; 824  :         else
; 825  :         {
; 826  :             trk = (op_cc * heads) + op_hh;

  00eb7	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR op_cc$[rsp]
  00ebe	0f af 84 24 a0
	00 00 00	 imul	 eax, DWORD PTR heads$[rsp]
  00ec6	03 84 24 ac 00
	00 00		 add	 eax, DWORD PTR op_hh$[rsp]
  00ecd	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax
$LN48@main:

; 827  :         }
; 828  : 
; 829  :         L1ndx = trk / cdevhdr.num_L2tab;

  00ed1	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00ed5	99		 cdq
  00ed6	f7 bc 24 78 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00edd	89 84 24 90 00
	00 00		 mov	 DWORD PTR L1ndx$[rsp], eax

; 830  :         L2ndx = trk % cdevhdr.num_L2tab;

  00ee4	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00ee8	99		 cdq
  00ee9	f7 bc 24 78 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00ef0	8b c2		 mov	 eax, edx
  00ef2	89 84 24 88 00
	00 00		 mov	 DWORD PTR L2ndx$[rsp], eax
$LN46@main:

; 831  :     }
; 832  : 
; 833  :     /*---------------------------------------------------------------*/
; 834  :     /* For FBA devices a relative track is treated as a block number */
; 835  :     /*---------------------------------------------------------------*/
; 836  :     if (!ckddasd && cmd_tt)

  00ef9	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00efe	85 c0		 test	 eax, eax
  00f00	75 55		 jne	 SHORT $LN49@main
  00f02	0f b6 44 24 71	 movzx	 eax, BYTE PTR cmd_tt$[rsp]
  00f07	85 c0		 test	 eax, eax
  00f09	74 4c		 je	 SHORT $LN49@main

; 837  :     {
; 838  :         int blkgrp = (trk = op_tt) / CFBA_BLKS_PER_GRP;

  00f0b	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR op_tt$[rsp]
  00f12	89 44 24 78	 mov	 DWORD PTR trk$[rsp], eax
  00f16	8b 44 24 78	 mov	 eax, DWORD PTR trk$[rsp]
  00f1a	99		 cdq
  00f1b	b9 78 00 00 00	 mov	 ecx, 120		; 00000078H
  00f20	f7 f9		 idiv	 ecx
  00f22	89 84 24 d0 00
	00 00		 mov	 DWORD PTR blkgrp$1[rsp], eax

; 839  : 
; 840  :         L1ndx = blkgrp / cdevhdr.num_L2tab;

  00f29	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR blkgrp$1[rsp]
  00f30	99		 cdq
  00f31	f7 bc 24 78 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00f38	89 84 24 90 00
	00 00		 mov	 DWORD PTR L1ndx$[rsp], eax

; 841  :         L2ndx = blkgrp % cdevhdr.num_L2tab;

  00f3f	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR blkgrp$1[rsp]
  00f46	99		 cdq
  00f47	f7 bc 24 78 01
	00 00		 idiv	 DWORD PTR cdevhdr$[rsp+8]
  00f4e	8b c2		 mov	 eax, edx
  00f50	89 84 24 88 00
	00 00		 mov	 DWORD PTR L2ndx$[rsp], eax
$LN49@main:

; 842  :     }
; 843  : 
; 844  :     /*---------------------------------------------------------------*/
; 845  :     /* Verify device is large enough for the request                 */
; 846  :     /*---------------------------------------------------------------*/
; 847  :     if (L1ndx >= num_L1tab)

  00f57	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR num_L1tab$[rsp]
  00f5e	39 84 24 90 00
	00 00		 cmp	 DWORD PTR L1ndx$[rsp], eax
  00f65	0f 8c 94 00 00
	00		 jl	 $LN50@main

; 848  :     {
; 849  :         // "%s %d does not exist on this device"
; 850  :         FWRMSG( stderr, HHC02617, "S", ckddasd ? "Track" : "Block", trk );

  00f6b	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00f70	85 c0		 test	 eax, eax
  00f72	74 11		 je	 SHORT $LN70@main
  00f74	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160097
  00f7b	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv590[rsp], rax
  00f83	eb 0f		 jmp	 SHORT $LN71@main
$LN70@main:
  00f85	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160098
  00f8c	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv590[rsp], rax
$LN71@main:
  00f94	b9 02 00 00 00	 mov	 ecx, 2
  00f99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f9f	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  00fa3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00fa7	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv590[rsp]
  00faf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00fb4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160099
  00fbb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00fc0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160100
  00fc7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00fcc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00fd1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00fd7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160101
  00fde	ba 52 03 00 00	 mov	 edx, 850		; 00000352H
  00fe3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160102
  00fea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 851  :         clean();

  00ff0	e8 00 00 00 00	 call	 clean

; 852  :         ErrExit( EXIT_DATA_NOTFOUND );

  00ff5	b9 07 00 00 00	 mov	 ecx, 7
  00ffa	e8 00 00 00 00	 call	 ErrExit
$LN50@main:

; 853  :     }
; 854  : 
; 855  :     L2taboff = L1tab[ L1ndx ];

  00fff	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR L1ndx$[rsp]
  01007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  0100e	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01011	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR L2taboff$[rsp], rax

; 856  : 
; 857  :     if (swapend)

  01019	0f b6 44 24 72	 movzx	 eax, BYTE PTR swapend$[rsp]
  0101e	85 c0		 test	 eax, eax
  01020	74 15		 je	 SHORT $LN51@main

; 858  :         L2taboff = SWAP_OFF_T( L2taboff );

  01022	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR L2taboff$[rsp]
  0102a	e8 00 00 00 00	 call	 _byteswap_uint64
  0102f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR L2taboff$[rsp], rax
$LN51@main:

; 859  : 
; 860  :     /*---------------------------------------------------------------*/
; 861  :     /* Display CKD CCHH or relative track or FBA relative block data */
; 862  :     /*---------------------------------------------------------------*/
; 863  :     if ((cmd_cchh) || (cmd_tt))

  01037	0f b6 44 24 73	 movzx	 eax, BYTE PTR cmd_cchh$[rsp]
  0103c	85 c0		 test	 eax, eax
  0103e	75 0d		 jne	 SHORT $LN53@main
  01040	0f b6 44 24 71	 movzx	 eax, BYTE PTR cmd_tt$[rsp]
  01045	85 c0		 test	 eax, eax
  01047	0f 84 fe 06 00
	00		 je	 $LN52@main
$LN53@main:

; 864  :     {
; 865  :         if (ckddasd)

  0104d	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01052	85 c0		 test	 eax, eax
  01054	74 7d		 je	 SHORT $LN54@main

; 866  :             // "CC %d HH %d = reltrk %d; L1 index = %d, L2 index = %d"
; 867  :             WRMSG( HHC02609, "I", op_cc, op_hh, trk, L1ndx, L2ndx );

  01056	b9 01 00 00 00	 mov	 ecx, 1
  0105b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01061	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR L2ndx$[rsp]
  01068	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0106c	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR L1ndx$[rsp]
  01073	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01077	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  0107b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0107f	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR op_hh$[rsp]
  01086	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0108a	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR op_cc$[rsp]
  01091	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01095	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160108
  0109c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160109
  010a8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010ad	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010b2	41 b9 03 00 00
	00		 mov	 r9d, 3
  010b8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160110
  010bf	ba 63 03 00 00	 mov	 edx, 867		; 00000363H
  010c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160111
  010cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  010d1	eb 65		 jmp	 SHORT $LN55@main
$LN54@main:

; 868  :         else
; 869  :             // "Block %d; L1 index = %d, L2 index = %d"
; 870  :             WRMSG( HHC02615, "I", trk, L1ndx, L2ndx );

  010d3	b9 01 00 00 00	 mov	 ecx, 1
  010d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010de	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR L2ndx$[rsp]
  010e5	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  010e9	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR L1ndx$[rsp]
  010f0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010f4	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  010f8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160112
  01103	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01108	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160113
  0110f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01114	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01119	41 b9 03 00 00
	00		 mov	 r9d, 3
  0111f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160114
  01126	ba 66 03 00 00	 mov	 edx, 870		; 00000366H
  0112b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160115
  01132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN55@main:

; 871  : 
; 872  :         // "L1 index %d = L2TAB offset %"PRId64" (0x%16.16"PRIX64")"
; 873  :         WRMSG( HHC02610, "I", L1ndx, L2taboff, L2taboff );

  01138	b9 01 00 00 00	 mov	 ecx, 1
  0113d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01143	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR L2taboff$[rsp]
  0114b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01150	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR L2taboff$[rsp]
  01158	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0115d	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR L1ndx$[rsp]
  01164	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160116
  0116f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01174	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160117
  0117b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01180	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01185	41 b9 03 00 00
	00		 mov	 r9d, 3
  0118b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160118
  01192	ba 69 03 00 00	 mov	 edx, 873		; 00000369H
  01197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160119
  0119e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 874  : 
; 875  :         // PROGRAMMING NOTE: for whatever reason, base dasd image files
; 876  :         // use a L2_trkoff value of zero in their L1tab entry for non-
; 877  :         // existent tracks, whereas shadow files use a value of -1, so
; 878  :         // we need to check for both.
; 879  : 
; 880  :         if (!L2taboff || L2taboff == CCKD_MAXSIZE)

  011a4	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR L2taboff$[rsp], 0
  011ad	74 13		 je	 SHORT $LN57@main
  011af	b8 ff ff ff ff	 mov	 eax, -1
  011b4	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR L2taboff$[rsp], rax
  011bc	0f 85 94 00 00
	00		 jne	 $LN56@main
$LN57@main:

; 881  :         {
; 882  :             // "L2tab for %s %d not found"
; 883  :             FWRMSG( stderr, HHC02618, "S", ckddasd ? "track" : "block", trk );

  011c2	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  011c7	85 c0		 test	 eax, eax
  011c9	74 11		 je	 SHORT $LN72@main
  011cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160122
  011d2	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv659[rsp], rax
  011da	eb 0f		 jmp	 SHORT $LN73@main
$LN72@main:
  011dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160123
  011e3	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv659[rsp], rax
$LN73@main:
  011eb	b9 02 00 00 00	 mov	 ecx, 2
  011f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  011f6	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  011fa	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  011fe	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv659[rsp]
  01206	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0120b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160124
  01212	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160125
  0121e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01223	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01228	41 b9 03 00 00
	00		 mov	 r9d, 3
  0122e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160126
  01235	ba 73 03 00 00	 mov	 edx, 883		; 00000373H
  0123a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160127
  01241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 884  :             clean();

  01247	e8 00 00 00 00	 call	 clean

; 885  :             ErrExit( EXIT_DATA_NOTFOUND );

  0124c	b9 07 00 00 00	 mov	 ecx, 7
  01251	e8 00 00 00 00	 call	 ErrExit
$LN56@main:

; 886  :         }
; 887  : 
; 888  :         L2tab = makbuf(               cdevhdr.num_L2tab * CCKD_L2ENT_SIZE, "L2TAB" );

  01256	48 63 84 24 78
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  0125e	48 c1 e0 03	 shl	 rax, 3
  01262	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160128
  01269	8b c8		 mov	 ecx, eax
  0126b	e8 00 00 00 00	 call	 makbuf
  01270	48 89 05 00 00
	00 00		 mov	 QWORD PTR L2tab, rax

; 889  :         readpos( fd, L2tab, L2taboff, cdevhdr.num_L2tab * CCKD_L2ENT_SIZE );

  01277	48 63 84 24 78
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  0127f	48 c1 e0 03	 shl	 rax, 3
  01283	44 8b c8	 mov	 r9d, eax
  01286	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR L2taboff$[rsp]
  0128e	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR L2tab
  01295	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  0129b	e8 00 00 00 00	 call	 readpos

; 890  : 
; 891  :         if (cmd_l2tab)

  012a0	0f b6 84 24 80
	00 00 00	 movzx	 eax, BYTE PTR cmd_l2tab$[rsp]
  012a8	85 c0		 test	 eax, eax
  012aa	0f 84 9a 00 00
	00		 je	 $LN58@main

; 892  :         {
; 893  :             // "%s - %d (decimal) bytes:"
; 894  :             printf("\n");

  012b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160130
  012b7	e8 00 00 00 00	 call	 printf

; 895  :             WRMSG( HHC02614, "I", "L2TAB",

  012bc	48 63 84 24 78
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  012c4	48 c1 e0 03	 shl	 rax, 3
  012c8	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv688[rsp], rax
  012d0	b9 01 00 00 00	 mov	 ecx, 1
  012d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  012db	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv688[rsp]
  012e3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  012e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160131
  012ee	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  012f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160132
  012fa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  012ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160133
  01306	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0130b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01310	41 b9 03 00 00
	00		 mov	 r9d, 3
  01316	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160134
  0131d	ba 80 03 00 00	 mov	 edx, 896		; 00000380H
  01322	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160135
  01329	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 896  :                 (int)         (cdevhdr.num_L2tab * CCKD_L2ENT_SIZE) );
; 897  :             data_dump( L2tab, (cdevhdr.num_L2tab * CCKD_L2ENT_SIZE));

  0132f	48 63 84 24 78
	01 00 00	 movsxd	 rax, DWORD PTR cdevhdr$[rsp+8]
  01337	48 c1 e0 03	 shl	 rax, 3
  0133b	8b d0		 mov	 edx, eax
  0133d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  01344	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN58@main:

; 898  :         }
; 899  : 
; 900  :         // "L2 index %d = L2TAB entry: %d bytes:"
; 901  :         printf("\n");

  0134a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160136
  01351	e8 00 00 00 00	 call	 printf

; 902  :         WRMSG( HHC02611, "I", L2ndx, (int) CCKD_L2ENT_SIZE);

  01356	b9 01 00 00 00	 mov	 ecx, 1
  0135b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01361	c7 44 24 40 08
	00 00 00	 mov	 DWORD PTR [rsp+64], 8
  01369	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR L2ndx$[rsp]
  01370	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160137
  0137b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01380	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160138
  01387	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0138c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01391	41 b9 03 00 00
	00		 mov	 r9d, 3
  01397	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160139
  0139e	ba 86 03 00 00	 mov	 edx, 902		; 00000386H
  013a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160140
  013aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 903  :         data_dump( &L2tab[ L2ndx ],        CCKD_L2ENT_SIZE);

  013b0	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR L2ndx$[rsp]
  013b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  013bf	48 8d 04 c1	 lea	 rax, QWORD PTR [rcx+rax*8]
  013c3	ba 08 00 00 00	 mov	 edx, 8
  013c8	48 8b c8	 mov	 rcx, rax
  013cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 904  :         printf("\n");

  013d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160141
  013d8	e8 00 00 00 00	 call	 printf

; 905  : 
; 906  :         trkhdroff = L2tab[ L2ndx ].L2_trkoff;

  013dd	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR L2ndx$[rsp]
  013e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  013ec	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  013ef	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR trkhdroff$[rsp], rax

; 907  :         imglen    = L2tab[ L2ndx ].L2_len;

  013f7	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR L2ndx$[rsp]
  013ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  01406	0f b7 44 c1 04	 movzx	 eax, WORD PTR [rcx+rax*8+4]
  0140b	89 84 24 84 00
	00 00		 mov	 DWORD PTR imglen$[rsp], eax

; 908  : 
; 909  :         if (swapend)

  01412	0f b6 44 24 72	 movzx	 eax, BYTE PTR swapend$[rsp]
  01417	85 c0		 test	 eax, eax
  01419	74 28		 je	 SHORT $LN59@main

; 910  :         {
; 911  :             trkhdroff = SWAP_OFF_T( trkhdroff );

  0141b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR trkhdroff$[rsp]
  01423	e8 00 00 00 00	 call	 _byteswap_uint64
  01428	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR trkhdroff$[rsp], rax

; 912  :             imglen    = SWAP32( imglen );

  01430	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  01437	e8 00 00 00 00	 call	 _byteswap_ulong
  0143c	89 84 24 84 00
	00 00		 mov	 DWORD PTR imglen$[rsp], eax
$LN59@main:

; 913  :         }
; 914  : 
; 915  :         // "%s offset %"PRId64" (0x%16.16"PRIX64"); length %d (0x%8.8X) bytes%s"
; 916  :         WRMSG( HHC02613, "I", ckddasd ? "TRKHDR" : "BKGHDR",

  01443	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01448	85 c0		 test	 eax, eax
  0144a	74 11		 je	 SHORT $LN74@main
  0144c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160144
  01453	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv779[rsp], rax
  0145b	eb 0f		 jmp	 SHORT $LN75@main
$LN74@main:
  0145d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160145
  01464	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv779[rsp], rax
$LN75@main:
  0146c	b9 01 00 00 00	 mov	 ecx, 1
  01471	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01477	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160143
  0147e	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  01483	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  0148a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0148e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  01495	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  01499	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR trkhdroff$[rsp]
  014a1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  014a6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR trkhdroff$[rsp]
  014ae	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  014b3	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv779[rsp]
  014bb	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  014c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160146
  014c7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  014cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160147
  014d3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  014d8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  014dd	41 b9 03 00 00
	00		 mov	 r9d, 3
  014e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160148
  014ea	ba 95 03 00 00	 mov	 edx, 917		; 00000395H
  014ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160149
  014f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 917  :             trkhdroff, trkhdroff, imglen, imglen, "" );
; 918  : 
; 919  :         /* Verify device contains the requested track/block */
; 920  :         if (!trkhdroff || !imglen)

  014fc	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR trkhdroff$[rsp], 0
  01505	74 0e		 je	 SHORT $LN61@main
  01507	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR imglen$[rsp], 0
  0150f	0f 85 94 00 00
	00		 jne	 $LN60@main
$LN61@main:

; 921  :         {
; 922  :             // "%s %d not found"
; 923  :             FWRMSG( stderr, HHC02619, "S", ckddasd ? "Track" : "Block", trk );

  01515	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  0151a	85 c0		 test	 eax, eax
  0151c	74 11		 je	 SHORT $LN76@main
  0151e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160152
  01525	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv795[rsp], rax
  0152d	eb 0f		 jmp	 SHORT $LN77@main
$LN76@main:
  0152f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160153
  01536	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv795[rsp], rax
$LN77@main:
  0153e	b9 02 00 00 00	 mov	 ecx, 2
  01543	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01549	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  0154d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01551	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv795[rsp]
  01559	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0155e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160154
  01565	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0156a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160155
  01571	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01576	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0157b	41 b9 03 00 00
	00		 mov	 r9d, 3
  01581	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160156
  01588	ba 9b 03 00 00	 mov	 edx, 923		; 0000039bH
  0158d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160157
  01594	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 924  :             clean();

  0159a	e8 00 00 00 00	 call	 clean

; 925  :             ErrExit( EXIT_DATA_NOTFOUND );

  0159f	b9 07 00 00 00	 mov	 ecx, 7
  015a4	e8 00 00 00 00	 call	 ErrExit
$LN60@main:

; 926  :         }
; 927  : 
; 928  :         tbuf = makbuf(imglen, ckddasd ? "TRKHDR+DATA" : "BKGHDR+DATA");

  015a9	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  015ae	85 c0		 test	 eax, eax
  015b0	74 11		 je	 SHORT $LN78@main
  015b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160158
  015b9	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv810[rsp], rax
  015c1	eb 0f		 jmp	 SHORT $LN79@main
$LN78@main:
  015c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160159
  015ca	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv810[rsp], rax
$LN79@main:
  015d2	48 8b 94 24 28
	01 00 00	 mov	 rdx, QWORD PTR tv810[rsp]
  015da	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR imglen$[rsp]
  015e1	e8 00 00 00 00	 call	 makbuf
  015e6	48 89 05 00 00
	00 00		 mov	 QWORD PTR tbuf, rax

; 929  :         readpos(fd, tbuf, trkhdroff, imglen);

  015ed	44 8b 8c 24 84
	00 00 00	 mov	 r9d, DWORD PTR imglen$[rsp]
  015f5	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR trkhdroff$[rsp]
  015fd	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR tbuf
  01604	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  0160a	e8 00 00 00 00	 call	 readpos

; 930  : 
; 931  :         // "%sHDR %s %d:"
; 932  :         WRMSG( HHC02612, "I", ckddasd ? "TRK"   : "BKG",

  0160f	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  01614	85 c0		 test	 eax, eax
  01616	74 11		 je	 SHORT $LN80@main
  01618	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160160
  0161f	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv820[rsp], rax
  01627	eb 0f		 jmp	 SHORT $LN81@main
$LN80@main:
  01629	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160161
  01630	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR tv820[rsp], rax
$LN81@main:
  01638	0f b6 44 24 70	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  0163d	85 c0		 test	 eax, eax
  0163f	74 11		 je	 SHORT $LN82@main
  01641	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160162
  01648	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv824[rsp], rax
  01650	eb 0f		 jmp	 SHORT $LN83@main
$LN82@main:
  01652	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160163
  01659	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv824[rsp], rax
$LN83@main:
  01661	b9 01 00 00 00	 mov	 ecx, 1
  01666	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0166c	8b 4c 24 78	 mov	 ecx, DWORD PTR trk$[rsp]
  01670	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  01674	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv820[rsp]
  0167c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  01681	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv824[rsp]
  01689	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0168e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160164
  01695	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0169a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160165
  016a1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  016a6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  016ab	41 b9 03 00 00
	00		 mov	 r9d, 3
  016b1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160166
  016b8	ba a5 03 00 00	 mov	 edx, 933		; 000003a5H
  016bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160167
  016c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 933  :                               ckddasd ? "track" : "block", trk );
; 934  :         data_dump( tbuf, CKD_TRKHDR_SIZE);

  016ca	ba 05 00 00 00	 mov	 edx, 5
  016cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  016d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 935  :         printf("\n");

  016dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160168
  016e3	e8 00 00 00 00	 call	 printf

; 936  : 
; 937  :         if (cmd_trkdata)

  016e8	0f b6 44 24 74	 movzx	 eax, BYTE PTR cmd_trkdata$[rsp]
  016ed	85 c0		 test	 eax, eax
  016ef	74 2a		 je	 SHORT $LN62@main

; 938  :             showtrkorblk( tbuf, imglen, trk, ckddasd, cmd_hexdump );

  016f1	0f b6 84 24 81
	00 00 00	 movzx	 eax, BYTE PTR cmd_hexdump$[rsp]
  016f9	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  016fd	44 0f b6 4c 24
	70		 movzx	 r9d, BYTE PTR ckddasd$[rsp]
  01703	44 8b 44 24 78	 mov	 r8d, DWORD PTR trk$[rsp]
  01708	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR imglen$[rsp]
  0170f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  01716	e8 00 00 00 00	 call	 showtrkorblk
$LN62@main:

; 939  : 
; 940  :         free(L2tab);

  0171b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  01722	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 941  :         free(tbuf);

  01728	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  0172f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 942  : 
; 943  :         L2tab = NULL;

  01735	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR L2tab, 0

; 944  :         tbuf = NULL;

  01740	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR tbuf, 0
$LN52@main:

; 945  :     }
; 946  : 
; 947  :     /* Close file, exit */
; 948  :     clean();

  0174b	e8 00 00 00 00	 call	 clean

; 949  :     ErrExit( cckd_diag_rc );

  01750	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR cckd_diag_rc$[rsp]
  01757	e8 00 00 00 00	 call	 ErrExit
$LN63@main:

; 950  :     UNREACHABLE_CODE( return EXIT_ERROR_LOGIC_ERROR );
; 951  : }

  0175c	48 8b 8c 24 80
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01764	48 33 cc	 xor	 rcx, rsp
  01767	e8 00 00 00 00	 call	 __security_check_cookie
  0176c	48 81 c4 98 06
	00 00		 add	 rsp, 1688		; 00000698H
  01773	c3		 ret	 0
$LN85@main:
  01774	00 00 00 00	 DD	 $LN13@main
  01778	00 00 00 00	 DD	 $LN15@main
  0177c	00 00 00 00	 DD	 $LN17@main
  01780	00 00 00 00	 DD	 $LN11@main
  01784	00 00 00 00	 DD	 $LN9@main
  01788	00 00 00 00	 DD	 $LN27@main
  0178c	00 00 00 00	 DD	 $LN21@main
  01790	00 00 00 00	 DD	 $LN19@main
  01794	00 00 00 00	 DD	 $LN23@main
  01798	00 00 00 00	 DD	 $LN7@main
  0179c	00 00 00 00	 DD	 $LN25@main
  017a0	00 00 00 00	 DD	 $LN29@main
$LN84@main:
  017a4	00		 DB	 0
  017a5	01		 DB	 1
  017a6	0b		 DB	 11
  017a7	0b		 DB	 11
  017a8	0b		 DB	 11
  017a9	0b		 DB	 11
  017aa	0b		 DB	 11
  017ab	0b		 DB	 11
  017ac	0b		 DB	 11
  017ad	0b		 DB	 11
  017ae	0b		 DB	 11
  017af	0b		 DB	 11
  017b0	0b		 DB	 11
  017b1	0b		 DB	 11
  017b2	0b		 DB	 11
  017b3	0b		 DB	 11
  017b4	0b		 DB	 11
  017b5	0b		 DB	 11
  017b6	0b		 DB	 11
  017b7	0b		 DB	 11
  017b8	0b		 DB	 11
  017b9	0b		 DB	 11
  017ba	0b		 DB	 11
  017bb	0b		 DB	 11
  017bc	0b		 DB	 11
  017bd	0b		 DB	 11
  017be	0b		 DB	 11
  017bf	0b		 DB	 11
  017c0	0b		 DB	 11
  017c1	0b		 DB	 11
  017c2	0b		 DB	 11
  017c3	0b		 DB	 11
  017c4	0b		 DB	 11
  017c5	0b		 DB	 11
  017c6	0b		 DB	 11
  017c7	0b		 DB	 11
  017c8	0b		 DB	 11
  017c9	0b		 DB	 11
  017ca	0b		 DB	 11
  017cb	0b		 DB	 11
  017cc	0b		 DB	 11
  017cd	0b		 DB	 11
  017ce	0b		 DB	 11
  017cf	0b		 DB	 11
  017d0	0b		 DB	 11
  017d1	0b		 DB	 11
  017d2	0b		 DB	 11
  017d3	0b		 DB	 11
  017d4	02		 DB	 2
  017d5	0b		 DB	 11
  017d6	03		 DB	 3
  017d7	04		 DB	 4
  017d8	0b		 DB	 11
  017d9	0b		 DB	 11
  017da	05		 DB	 5
  017db	0b		 DB	 11
  017dc	0b		 DB	 11
  017dd	0b		 DB	 11
  017de	0b		 DB	 11
  017df	0b		 DB	 11
  017e0	0b		 DB	 11
  017e1	0b		 DB	 11
  017e2	06		 DB	 6
  017e3	0b		 DB	 11
  017e4	0b		 DB	 11
  017e5	07		 DB	 7
  017e6	0b		 DB	 11
  017e7	08		 DB	 8
  017e8	0b		 DB	 11
  017e9	09		 DB	 9
  017ea	0b		 DB	 11
  017eb	0a		 DB	 10
main	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
v$ = 80
p$ = 88
tv75 = 96
s$ = 128
offtify	PROC

; 477  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 478  :     static const char  xd[]  = { "0123456789abcdefABCDEF" };
; 479  :     static const char  xv[]  = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
; 480  :                                 10, 11, 12, 13, 14, 15,
; 481  :                                 10, 11, 12, 13, 14, 15 };
; 482  :     off_t   v;
; 483  :     char*   p;
; 484  : 
; 485  :     p = s;

  00009	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00011	48 89 44 24 58	 mov	 QWORD PTR p$[rsp], rax

; 486  :     if ( (*s == '0') && (*(s+1) == 'x') )

  00016	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0001e	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00021	83 f8 30	 cmp	 eax, 48			; 00000030H
  00024	0f 85 2a 01 00
	00		 jne	 $LN5@offtify
  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00032	0f be 40 01	 movsx	 eax, BYTE PTR [rax+1]
  00036	83 f8 78	 cmp	 eax, 120		; 00000078H
  00039	0f 85 15 01 00
	00		 jne	 $LN5@offtify

; 487  :     {
; 488  :         s = s + 2;

  0003f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00047	48 83 c0 02	 add	 rax, 2
  0004b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$[rsp], rax

; 489  : 
; 490  :         for (v = 0; isxdigit(*s); ++s)

  00053	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR v$[rsp], 0
  0005c	eb 13		 jmp	 SHORT $LN4@offtify
$LN2@offtify:
  0005e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00066	48 ff c0	 inc	 rax
  00069	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR s$[rsp], rax
$LN4@offtify:
  00071	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00079	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0007c	8b c8		 mov	 ecx, eax
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isxdigit
  00084	85 c0		 test	 eax, eax
  00086	74 4f		 je	 SHORT $LN3@offtify

; 491  :             v = (v << 4) + xv[ strchr( xd, *s ) - xd ];

  00088	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0008d	48 c1 e0 04	 shl	 rax, 4
  00091	48 89 44 24 60	 mov	 QWORD PTR tv75[rsp], rax
  00096	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	0f be 09	 movsx	 ecx, BYTE PTR [rcx]
  000a1	8b d1		 mov	 edx, ecx
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?xd@?1??offtify@@9@9
  000aa	e8 00 00 00 00	 call	 strchr
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?xd@?1??offtify@@9@9
  000b6	48 2b c1	 sub	 rax, rcx
  000b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?xv@?1??offtify@@9@9
  000c0	48 0f be 04 01	 movsx	 rax, BYTE PTR [rcx+rax]
  000c5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv75[rsp]
  000ca	48 03 c8	 add	 rcx, rax
  000cd	48 8b c1	 mov	 rax, rcx
  000d0	48 89 44 24 50	 mov	 QWORD PTR v$[rsp], rax
  000d5	eb 87		 jmp	 SHORT $LN2@offtify
$LN3@offtify:

; 492  : 
; 493  :         if (debug)

  000d7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  000de	74 65		 je	 SHORT $LN7@offtify

; 494  :         {
; 495  :             // "OFFTIFY hex string '%s' = 0x%16.16"PRIX64", dec %"PRId64"."
; 496  :             WRMSG( HHC90405, "D", p, (U64) v, (U64) v );

  000e0	b9 01 00 00 00	 mov	 ecx, 1
  000e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000eb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000f0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000f5	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  000fa	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ff	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  00104	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159875
  00110	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00115	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159876
  0011c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00121	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00126	41 b9 03 00 00
	00		 mov	 r9d, 3
  0012c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159877
  00133	ba f0 01 00 00	 mov	 edx, 496		; 000001f0H
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159878
  0013f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@offtify:

; 497  :         }
; 498  :         return v;

  00145	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
  0014a	e9 97 00 00 00	 jmp	 $LN1@offtify

; 499  :     }

  0014f	e9 92 00 00 00	 jmp	 $LN6@offtify
$LN5@offtify:

; 500  :     else /* decimal input */
; 501  :     {
; 502  :         v = (off_t) atoll(s);

  00154	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__atoi64
  00162	48 89 44 24 50	 mov	 QWORD PTR v$[rsp], rax

; 503  : 
; 504  :         if (debug)

  00167	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  0016e	74 71		 je	 SHORT $LN8@offtify

; 505  :         {
; 506  :             // "OFFTIFY dec string '%s' = 0x%16.16"PRIX64", dec %"PRId64"."
; 507  :             printf("\n");

  00170	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159880
  00177	e8 00 00 00 00	 call	 printf

; 508  :             WRMSG( HHC90406, "D", p, (U64) v, (U64) v );

  0017c	b9 01 00 00 00	 mov	 ecx, 1
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00187	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  0018c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00191	48 8b 4c 24 50	 mov	 rcx, QWORD PTR v$[rsp]
  00196	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0019b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR p$[rsp]
  001a0	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159881
  001ac	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159882
  001b8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001bd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001c8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159883
  001cf	ba fc 01 00 00	 mov	 edx, 508		; 000001fcH
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159884
  001db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN8@offtify:

; 509  :         }
; 510  :         return v;

  001e1	48 8b 44 24 50	 mov	 rax, QWORD PTR v$[rsp]
$LN6@offtify:
$LN1@offtify:

; 511  :     }
; 512  : }

  001e6	48 83 c4 78	 add	 rsp, 120		; 00000078H
  001ea	c3		 ret	 0
offtify	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
bufp$ = 64
tv75 = 72
rh$ = 80
len$ = 88
blknum$1 = 92
grpblk$2 = 96
blkghdr$3 = 104
msg$ = 112
buf2$ = 208
__$ArrayPad$ = 65744
buf$ = 65776
imglen$ = 65784
trk$ = 65792
ckddasd$ = 65800
hexdump$ = 65808
showtrkorblk PROC

; 400  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	b8 e8 00 01 00	 mov	 eax, 65768		; 000100e8H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 d0
	00 01 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 401  :     BYTE             buf2[64*1024];     /* max uncompressed buffer   */
; 402  :     char             msg[81];           /* error message buffer      */
; 403  :     CKD_RECHDR*      rh;                /* CCKD COUNT field          */
; 404  :     BYTE*            bufp;              /* Decompressed data pointer */
; 405  :     int              len;               /* Decompressed data length  */
; 406  : 
; 407  :     if (debug)

  00032	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00039	74 2f		 je	 SHORT $LN4@showtrkorb

; 408  :     {
; 409  :         snap( COMPRESSED, buf, imglen, ckddasd );

  0003b	44 0f b6 8c 24
	08 01 01 00	 movzx	 r9d, BYTE PTR ckddasd$[rsp]
  00044	44 8b 84 24 f8
	00 01 00	 mov	 r8d, DWORD PTR imglen$[rsp]
  0004c	48 8b 94 24 f0
	00 01 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00054	b9 01 00 00 00	 mov	 ecx, 1
  00059	e8 00 00 00 00	 call	 snap

; 410  :         printf("\n");

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159843
  00065	e8 00 00 00 00	 call	 printf
$LN4@showtrkorb:

; 411  :     }
; 412  : 
; 413  :     /* Expand (decompress) the CKD track or FBA block group */
; 414  :     len = decomptrk

  0006a	0f b6 84 24 08
	01 01 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00072	85 c0		 test	 eax, eax
  00074	74 0a		 je	 SHORT $LN10@showtrkorb
  00076	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  0007e	eb 08		 jmp	 SHORT $LN11@showtrkorb
$LN10@showtrkorb:
  00080	c7 44 24 48 ff
	ff ff ff	 mov	 DWORD PTR tv75[rsp], -1
$LN11@showtrkorb:
  00088	48 8d 44 24 70	 lea	 rax, QWORD PTR msg$[rsp]
  0008d	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00092	8b 84 24 00 01
	01 00		 mov	 eax, DWORD PTR trk$[rsp]
  00099	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0009d	8b 44 24 48	 mov	 eax, DWORD PTR tv75[rsp]
  000a1	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000a5	41 b9 00 00 01
	00		 mov	 r9d, 65536		; 00010000H
  000ab	4c 8d 84 24 d0
	00 00 00	 lea	 r8, QWORD PTR buf2$[rsp]
  000b3	8b 94 24 f8 00
	01 00		 mov	 edx, DWORD PTR imglen$[rsp]
  000ba	48 8b 8c 24 f0
	00 01 00	 mov	 rcx, QWORD PTR buf$[rsp]
  000c2	e8 00 00 00 00	 call	 decomptrk
  000c7	89 44 24 58	 mov	 DWORD PTR len$[rsp], eax

; 415  :     (
; 416  :         (BYTE *)buf,        /* input buffer address            */
; 417  :         imglen,             /* input buffer length             */
; 418  :         buf2,               /* output buffer address           */
; 419  :         sizeof(buf2),       /* output buffer length            */
; 420  :         ckddasd ? +1 : -1,  /* >=0 means CKD, else FBA         */
; 421  :         trk,                /* relative track or block number  */
; 422  :         msg                 /* addr of message buffer          */
; 423  :     );
; 424  : 
; 425  :     if (debug)

  000cb	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  000d2	74 29		 je	 SHORT $LN5@showtrkorb

; 426  :     {
; 427  :         snap( EXPANDED, buf2, len, ckddasd );

  000d4	44 0f b6 8c 24
	08 01 01 00	 movzx	 r9d, BYTE PTR ckddasd$[rsp]
  000dd	44 8b 44 24 58	 mov	 r8d, DWORD PTR len$[rsp]
  000e2	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buf2$[rsp]
  000ea	33 c9		 xor	 ecx, ecx
  000ec	e8 00 00 00 00	 call	 snap

; 428  :         printf("\n");

  000f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159845
  000f8	e8 00 00 00 00	 call	 printf
$LN5@showtrkorb:

; 429  :     }
; 430  : 
; 431  :     bufp = &buf2[ CKD_TRKHDR_SIZE];

  000fd	b8 01 00 00 00	 mov	 eax, 1
  00102	48 6b c0 05	 imul	 rax, rax, 5
  00106	48 8d 84 04 d0
	00 00 00	 lea	 rax, QWORD PTR buf2$[rsp+rax]
  0010e	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 432  : 
; 433  :     if (ckddasd)

  00113	0f b6 84 24 08
	01 01 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  0011b	85 c0		 test	 eax, eax
  0011d	0f 84 00 01 00
	00		 je	 $LN6@showtrkorb
$LN2@showtrkorb:

; 434  :     {
; 435  :         while (bufp < &buf2[ sizeof( buf2 )])

  00123	b8 01 00 00 00	 mov	 eax, 1
  00128	48 69 c0 00 00
	01 00		 imul	 rax, rax, 65536		; 00010000H
  0012f	48 8d 84 04 d0
	00 00 00	 lea	 rax, QWORD PTR buf2$[rsp+rax]
  00137	48 39 44 24 40	 cmp	 QWORD PTR bufp$[rsp], rax
  0013c	0f 83 df 00 00
	00		 jae	 $LN3@showtrkorb

; 436  :         {
; 437  :             rh = (CKD_RECHDR*) bufp;

  00142	48 8b 44 24 40	 mov	 rax, QWORD PTR bufp$[rsp]
  00147	48 89 44 24 50	 mov	 QWORD PTR rh$[rsp], rax

; 438  : 
; 439  :             if (memcmp( (BYTE*) rh, &CKD_ENDTRK, CKD_ENDTRK_SIZE ) == 0)

  0014c	41 b8 08 00 00
	00		 mov	 r8d, 8
  00152	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:CKD_ENDTRK
  00159	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  0015e	e8 00 00 00 00	 call	 memcmp
  00163	85 c0		 test	 eax, eax
  00165	75 55		 jne	 SHORT $LN8@showtrkorb

; 440  :             {
; 441  :                 // "%s"
; 442  :                 WRMSG( HHC02601, "I", "End of track" );

  00167	b9 01 00 00 00	 mov	 ecx, 1
  0016c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00172	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159849
  00179	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0017e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159850
  00185	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159851
  00191	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00196	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0019b	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159852
  001a8	ba ba 01 00 00	 mov	 edx, 442		; 000001baH
  001ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159853
  001b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 443  :                 break;

  001ba	eb 65		 jmp	 SHORT $LN3@showtrkorb
$LN8@showtrkorb:

; 444  :             }
; 445  : 
; 446  :             bufp = show_ckd_count ( rh, trk);

  001bc	8b 94 24 00 01
	01 00		 mov	 edx, DWORD PTR trk$[rsp]
  001c3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  001c8	e8 00 00 00 00	 call	 show_ckd_count
  001cd	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 447  :             bufp = show_ckd_key   ( rh, bufp, trk, hexdump );

  001d2	44 0f b6 8c 24
	10 01 01 00	 movzx	 r9d, BYTE PTR hexdump$[rsp]
  001db	44 8b 84 24 00
	01 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  001e3	48 8b 54 24 40	 mov	 rdx, QWORD PTR bufp$[rsp]
  001e8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  001ed	e8 00 00 00 00	 call	 show_ckd_key
  001f2	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 448  :             bufp = show_ckd_data  ( rh, bufp, trk, hexdump );

  001f7	44 0f b6 8c 24
	10 01 01 00	 movzx	 r9d, BYTE PTR hexdump$[rsp]
  00200	44 8b 84 24 00
	01 01 00	 mov	 r8d, DWORD PTR trk$[rsp]
  00208	48 8b 54 24 40	 mov	 rdx, QWORD PTR bufp$[rsp]
  0020d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR rh$[rsp]
  00212	e8 00 00 00 00	 call	 show_ckd_data
  00217	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 449  :         }

  0021c	e9 02 ff ff ff	 jmp	 $LN2@showtrkorb
$LN3@showtrkorb:

; 450  :     }

  00221	eb 6f		 jmp	 SHORT $LN7@showtrkorb
$LN6@showtrkorb:

; 451  :     else // FBA
; 452  :     {
; 453  :         /* Extract block number of first block in block group */
; 454  :         FBA_BKGHDR* blkghdr = (FBA_BKGHDR*) buf;

  00223	48 8b 84 24 f0
	00 01 00	 mov	 rax, QWORD PTR buf$[rsp]
  0022b	48 89 44 24 68	 mov	 QWORD PTR blkghdr$3[rsp], rax

; 455  :         U32 blknum = fetch_fw( blkghdr->blknum );

  00230	48 8b 44 24 68	 mov	 rax, QWORD PTR blkghdr$3[rsp]
  00235	48 ff c0	 inc	 rax
  00238	48 8b c8	 mov	 rcx, rax
  0023b	e8 00 00 00 00	 call	 fetch_fw_noswap
  00240	8b c8		 mov	 ecx, eax
  00242	e8 00 00 00 00	 call	 _byteswap_ulong
  00247	89 44 24 5c	 mov	 DWORD PTR blknum$1[rsp], eax

; 456  : 
; 457  :         /* Calculate relative block number within block group */
; 458  :         U32 grpblk = (trk - blknum);

  0024b	8b 44 24 5c	 mov	 eax, DWORD PTR blknum$1[rsp]
  0024f	8b 8c 24 00 01
	01 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00256	2b c8		 sub	 ecx, eax
  00258	8b c1		 mov	 eax, ecx
  0025a	89 44 24 60	 mov	 DWORD PTR grpblk$2[rsp], eax

; 459  : 
; 460  :         /* Index to desired block within expanded block group */
; 461  :         bufp += grpblk * 512;

  0025e	69 44 24 60 00
	02 00 00	 imul	 eax, DWORD PTR grpblk$2[rsp], 512 ; 00000200H
  00266	8b c0		 mov	 eax, eax
  00268	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bufp$[rsp]
  0026d	48 03 c8	 add	 rcx, rax
  00270	48 8b c1	 mov	 rax, rcx
  00273	48 89 44 24 40	 mov	 QWORD PTR bufp$[rsp], rax

; 462  : 
; 463  :         /* Show desired block data */
; 464  :         show_fba_block( bufp, trk, hexdump );

  00278	44 0f b6 84 24
	10 01 01 00	 movzx	 r8d, BYTE PTR hexdump$[rsp]
  00281	8b 94 24 00 01
	01 00		 mov	 edx, DWORD PTR trk$[rsp]
  00288	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bufp$[rsp]
  0028d	e8 00 00 00 00	 call	 show_fba_block
$LN7@showtrkorb:

; 465  :     }
; 466  : }

  00292	48 8b 8c 24 d0
	00 01 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0029a	48 33 cc	 xor	 rcx, rsp
  0029d	e8 00 00 00 00	 call	 __security_check_cookie
  002a2	48 81 c4 e8 00
	01 00		 add	 rsp, 65768		; 000100e8H
  002a9	c3		 ret	 0
showtrkorblk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
tv67 = 80
tv71 = 88
tv86 = 96
tv90 = 104
comp$ = 128
data$ = 136
len$ = 144
ckddasd$ = 152
snap	PROC

; 361  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 362  :     if (comp)

  00017	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR comp$[rsp], 0
  0001f	0f 84 c1 00 00
	00		 je	 $LN2@snap

; 363  :     {
; 364  :         // "SHOW%s Compressed %s header and data:"
; 365  :         WRMSG( HHC90403, "D",

  00025	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  0002d	85 c0		 test	 eax, eax
  0002f	74 0e		 je	 SHORT $LN6@snap
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159790
  00038	48 89 44 24 50	 mov	 QWORD PTR tv67[rsp], rax
  0003d	eb 0c		 jmp	 SHORT $LN7@snap
$LN6@snap:
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159791
  00046	48 89 44 24 50	 mov	 QWORD PTR tv67[rsp], rax
$LN7@snap:
  0004b	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00053	85 c0		 test	 eax, eax
  00055	74 0e		 je	 SHORT $LN8@snap
  00057	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159792
  0005e	48 89 44 24 58	 mov	 QWORD PTR tv71[rsp], rax
  00063	eb 0c		 jmp	 SHORT $LN9@snap
$LN8@snap:
  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159793
  0006c	48 89 44 24 58	 mov	 QWORD PTR tv71[rsp], rax
$LN9@snap:
  00071	b9 01 00 00 00	 mov	 ecx, 1
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv67[rsp]
  00081	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00086	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv71[rsp]
  0008b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159794
  00097	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159795
  000a3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ad	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159796
  000ba	ba 6f 01 00 00	 mov	 edx, 367		; 0000016fH
  000bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159797
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 366  :             ckddasd ? "TRK"   : "BKG",
; 367  :             ckddasd ? "track" : "block group" );
; 368  :         data_dump( data, len );

  000cc	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  000d3	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 369  :     }

  000e1	e9 bc 00 00 00	 jmp	 $LN3@snap
$LN2@snap:

; 370  :     else // EXPANDED
; 371  :     {
; 372  :         // "SHOW%s Decompressed %s header and data:"
; 373  :         WRMSG( HHC90404, "D",

  000e6	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  000ee	85 c0		 test	 eax, eax
  000f0	74 0e		 je	 SHORT $LN10@snap
  000f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159798
  000f9	48 89 44 24 60	 mov	 QWORD PTR tv86[rsp], rax
  000fe	eb 0c		 jmp	 SHORT $LN11@snap
$LN10@snap:
  00100	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159799
  00107	48 89 44 24 60	 mov	 QWORD PTR tv86[rsp], rax
$LN11@snap:
  0010c	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR ckddasd$[rsp]
  00114	85 c0		 test	 eax, eax
  00116	74 0e		 je	 SHORT $LN12@snap
  00118	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159800
  0011f	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
  00124	eb 0c		 jmp	 SHORT $LN13@snap
$LN12@snap:
  00126	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159801
  0012d	48 89 44 24 68	 mov	 QWORD PTR tv90[rsp], rax
$LN13@snap:
  00132	b9 01 00 00 00	 mov	 ecx, 1
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv86[rsp]
  00142	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00147	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv90[rsp]
  0014c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159802
  00158	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0015d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159803
  00164	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00169	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00174	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159804
  0017b	ba 77 01 00 00	 mov	 edx, 375		; 00000177H
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159805
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 374  :             ckddasd ? "TRK"   : "BKG",
; 375  :             ckddasd ? "track" : "block group" );
; 376  :         data_dump( data, len );

  0018d	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00194	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR data$[rsp]
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump
$LN3@snap:

; 377  :     }
; 378  : 
; 379  :     if (pausesnap)

  001a2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR pausesnap, 0
  001a9	74 70		 je	 SHORT $LN4@snap

; 380  :     {
; 381  :         // "%s"
; 382  :         printf("\n");

  001ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159807
  001b2	e8 00 00 00 00	 call	 printf

; 383  :         WRMSG( HHC02601, "A", "Press enter to continue" );

  001b7	b9 01 00 00 00	 mov	 ecx, 1
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159808
  001c9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159809
  001d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159810
  001e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159811
  001f8	ba 7f 01 00 00	 mov	 edx, 383		; 0000017fH
  001fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159812
  00204	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 384  :         getc( stdin );

  0020a	33 c9		 xor	 ecx, ecx
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00212	48 8b c8	 mov	 rcx, rax
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getc
$LN4@snap:

; 385  :     }
; 386  : }

  0021b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0021f	c3		 ret	 0
snap	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
buf$ = 80
blk$ = 88
hexdump$ = 96
show_fba_block PROC

; 345  : {

  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 346  :     if (hexdump)

  00012	0f b6 44 24 60	 movzx	 eax, BYTE PTR hexdump$[rsp]
  00017	85 c0		 test	 eax, eax
  00019	74 6b		 je	 SHORT $LN2@show_fba_b

; 347  :     {
; 348  :         // "Block %d:"
; 349  :         WRMSG( HHC02616, "I", blk );

  0001b	b9 01 00 00 00	 mov	 ecx, 1
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00026	8b 4c 24 58	 mov	 ecx, DWORD PTR blk$[rsp]
  0002a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0002e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159773
  00035	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0003a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159774
  00041	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00046	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0004b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00051	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159775
  00058	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159776
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 350  :         data_dump( buf, 512 );

  0006a	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  0006f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buf$[rsp]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 351  :         printf("\n");

  0007a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159777
  00081	e8 00 00 00 00	 call	 printf
$LN2@show_fba_b:

; 352  :     }
; 353  : }

  00086	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008a	c3		 ret	 0
show_fba_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
dl$ = 96
tv81 = 100
tv84 = 104
rh$ = 128
buf$ = 136
trk$ = 144
hexdump$ = 152
show_ckd_data PROC

; 325  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 326  :     int dl;
; 327  : 
; 328  :     dl = (rh->dlen[0] << 8) | (rh->dlen[1]);

  00018	b8 01 00 00 00	 mov	 eax, 1
  0001d	48 6b c0 00	 imul	 rax, rax, 0
  00021	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00029	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  0002e	c1 e0 08	 shl	 eax, 8
  00031	b9 01 00 00 00	 mov	 ecx, 1
  00036	48 6b c9 01	 imul	 rcx, rcx, 1
  0003a	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00042	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  00047	0b c1		 or	 eax, ecx
  00049	89 44 24 60	 mov	 DWORD PTR dl$[rsp], eax

; 329  : 
; 330  :     if (hexdump && dl)

  0004d	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR hexdump$[rsp]
  00055	85 c0		 test	 eax, eax
  00057	0f 84 cb 00 00
	00		 je	 $LN2@show_ckd_d
  0005d	83 7c 24 60 00	 cmp	 DWORD PTR dl$[rsp], 0
  00062	0f 84 c0 00 00
	00		 je	 $LN2@show_ckd_d

; 331  :     {
; 332  :         // "Track %d rec[%02X/%d] %s[%d]:"
; 333  :         printf("\n");

  00068	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159757
  0006f	e8 00 00 00 00	 call	 printf

; 334  :         WRMSG( HHC02606, "I", trk, rh->rec, rh->rec, "dl", dl );

  00074	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  0007c	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  00080	89 44 24 64	 mov	 DWORD PTR tv81[rsp], eax
  00084	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  0008c	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00090	89 4c 24 68	 mov	 DWORD PTR tv84[rsp], ecx
  00094	b9 01 00 00 00	 mov	 ecx, 1
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0009f	8b 4c 24 60	 mov	 ecx, DWORD PTR dl$[rsp]
  000a3	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159758
  000ae	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000b3	8b 4c 24 64	 mov	 ecx, DWORD PTR tv81[rsp]
  000b7	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  000bb	8b 4c 24 68	 mov	 ecx, DWORD PTR tv84[rsp]
  000bf	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  000ca	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159759
  000d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159760
  000e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  000f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159761
  000f8	ba 4e 01 00 00	 mov	 edx, 334		; 0000014eH
  000fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159762
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 335  :         data_dump( buf, dl );

  0010a	8b 54 24 60	 mov	 edx, DWORD PTR dl$[rsp]
  0010e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 336  :         printf("\n");

  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159763
  00123	e8 00 00 00 00	 call	 printf
$LN2@show_ckd_d:

; 337  :     }
; 338  :     return buf + dl;   /* skip past DATA field */

  00128	48 63 44 24 60	 movsxd	 rax, DWORD PTR dl$[rsp]
  0012d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00135	48 03 c8	 add	 rcx, rax
  00138	48 8b c1	 mov	 rax, rcx

; 339  : }

  0013b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0013f	c3		 ret	 0
show_ckd_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
tv71 = 96
tv75 = 100
tv78 = 104
rh$ = 128
buf$ = 136
trk$ = 144
hexdump$ = 152
show_ckd_key PROC

; 309  : {

  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 310  :     if (hexdump && rh->klen)

  00018	0f b6 84 24 98
	00 00 00	 movzx	 eax, BYTE PTR hexdump$[rsp]
  00020	85 c0		 test	 eax, eax
  00022	0f 84 ee 00 00
	00		 je	 $LN2@show_ckd_k
  00028	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00030	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00034	85 c0		 test	 eax, eax
  00036	0f 84 da 00 00
	00		 je	 $LN2@show_ckd_k

; 311  :     {
; 312  :         // "Track %d rec[%02X/%d] %s[%d]:"
; 313  :         printf("\n");

  0003c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159738
  00043	e8 00 00 00 00	 call	 printf

; 314  :         WRMSG( HHC02606, "I", trk, rh->rec, rh->rec, "kl", rh->klen );

  00048	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00050	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00054	89 44 24 60	 mov	 DWORD PTR tv71[rsp], eax
  00058	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00060	0f b6 49 04	 movzx	 ecx, BYTE PTR [rcx+4]
  00064	89 4c 24 64	 mov	 DWORD PTR tv75[rsp], ecx
  00068	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00070	0f b6 52 04	 movzx	 edx, BYTE PTR [rdx+4]
  00074	89 54 24 68	 mov	 DWORD PTR tv78[rsp], edx
  00078	b9 01 00 00 00	 mov	 ecx, 1
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00083	8b 4c 24 60	 mov	 ecx, DWORD PTR tv71[rsp]
  00087	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159739
  00092	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00097	8b 4c 24 64	 mov	 ecx, DWORD PTR tv75[rsp]
  0009b	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0009f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv78[rsp]
  000a3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000a7	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  000ae	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159740
  000b9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159741
  000c5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cf	41 b9 03 00 00
	00		 mov	 r9d, 3
  000d5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159742
  000dc	ba 3a 01 00 00	 mov	 edx, 314		; 0000013aH
  000e1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159743
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 315  :         data_dump( buf, rh->klen );

  000ee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  000f6	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  000fa	8b d0		 mov	 edx, eax
  000fc	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00104	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_data_dump

; 316  :         printf("\n");

  0010a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159744
  00111	e8 00 00 00 00	 call	 printf
$LN2@show_ckd_k:

; 317  :     }
; 318  :     return (BYTE *)buf + rh->klen;   /* skip past KEY field */

  00116	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  0011e	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00122	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  0012a	48 03 c8	 add	 rcx, rax
  0012d	48 8b c1	 mov	 rax, rcx

; 319  : }

  00130	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00134	c3		 ret	 0
show_ckd_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
r$ = 128
hh$ = 132
cc$ = 136
dl$ = 140
kl$ = 144
past$ = 152
rh$ = 176
trk$ = 184
show_ckd_count PROC

; 288  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 289  : int     cc, hh, r, kl, dl;
; 290  : BYTE    *past;
; 291  : 
; 292  :     cc = (rh->cyl[0] << 8) | (rh->cyl[1]);

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	48 6b c0 00	 imul	 rax, rax, 0
  00019	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00021	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00025	c1 e0 08	 shl	 eax, 8
  00028	b9 01 00 00 00	 mov	 ecx, 1
  0002d	48 6b c9 01	 imul	 rcx, rcx, 1
  00031	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00039	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0003d	0b c1		 or	 eax, ecx
  0003f	89 84 24 88 00
	00 00		 mov	 DWORD PTR cc$[rsp], eax

; 293  :     hh = (rh->head[0] << 8) | (rh->head[1]);

  00046	b8 01 00 00 00	 mov	 eax, 1
  0004b	48 6b c0 00	 imul	 rax, rax, 0
  0004f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  00057	0f b6 44 01 02	 movzx	 eax, BYTE PTR [rcx+rax+2]
  0005c	c1 e0 08	 shl	 eax, 8
  0005f	b9 01 00 00 00	 mov	 ecx, 1
  00064	48 6b c9 01	 imul	 rcx, rcx, 1
  00068	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  00070	0f b6 4c 0a 02	 movzx	 ecx, BYTE PTR [rdx+rcx+2]
  00075	0b c1		 or	 eax, ecx
  00077	89 84 24 84 00
	00 00		 mov	 DWORD PTR hh$[rsp], eax

; 294  :     r  = rh->rec;

  0007e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00086	0f b6 40 04	 movzx	 eax, BYTE PTR [rax+4]
  0008a	89 84 24 80 00
	00 00		 mov	 DWORD PTR r$[rsp], eax

; 295  :     kl = rh->klen;

  00091	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  00099	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  0009d	89 84 24 90 00
	00 00		 mov	 DWORD PTR kl$[rsp], eax

; 296  :     dl = (rh->dlen[0] << 8) | (rh->dlen[1]);

  000a4	b8 01 00 00 00	 mov	 eax, 1
  000a9	48 6b c0 00	 imul	 rax, rax, 0
  000ad	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR rh$[rsp]
  000b5	0f b6 44 01 06	 movzx	 eax, BYTE PTR [rcx+rax+6]
  000ba	c1 e0 08	 shl	 eax, 8
  000bd	b9 01 00 00 00	 mov	 ecx, 1
  000c2	48 6b c9 01	 imul	 rcx, rcx, 1
  000c6	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR rh$[rsp]
  000ce	0f b6 4c 0a 06	 movzx	 ecx, BYTE PTR [rdx+rcx+6]
  000d3	0b c1		 or	 eax, ecx
  000d5	89 84 24 8c 00
	00 00		 mov	 DWORD PTR dl$[rsp], eax

; 297  : 
; 298  :     // "Track %d COUNT cyl[%04X/%d] head[%04X/%d] rec[%02X/%d] kl[%d] dl[%d]"
; 299  :     WRMSG( HHC02605, "I", trk, cc, cc, hh, hh, r, r, kl, dl );

  000dc	b9 01 00 00 00	 mov	 ecx, 1
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e7	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR dl$[rsp]
  000ee	89 4c 24 78	 mov	 DWORD PTR [rsp+120], ecx
  000f2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR kl$[rsp]
  000f9	89 4c 24 70	 mov	 DWORD PTR [rsp+112], ecx
  000fd	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR r$[rsp]
  00104	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  00108	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR r$[rsp]
  0010f	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00113	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR hh$[rsp]
  0011a	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0011e	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR hh$[rsp]
  00125	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00129	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cc$[rsp]
  00130	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00134	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cc$[rsp]
  0013b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0013f	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR trk$[rsp]
  00146	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159722
  00151	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159723
  0015d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	41 b9 03 00 00
	00		 mov	 r9d, 3
  0016d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159724
  00174	ba 2b 01 00 00	 mov	 edx, 299		; 0000012bH
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159725
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 300  : 
; 301  :     past = (BYTE *)rh + CKD_RECHDR_SIZE;

  00186	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR rh$[rsp]
  0018e	48 83 c0 08	 add	 rax, 8
  00192	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR past$[rsp], rax

; 302  :     return past;

  0019a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR past$[rsp]

; 303  : }

  001a2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001a9	c3		 ret	 0
show_ckd_count ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
tv78 = 0
bufl$ = 4
tv76 = 8
tv69 = 16
ibuf$ = 64
ibuflen$ = 72
obuf$ = 80
obuflen$ = 88
heads$ = 96
trk$ = 104
emsg$ = 112
decomptrk PROC

; 194  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@decomptrk:

; 195  : #if defined( HAVE_ZLIB ) || defined( CCKD_BZIP2 )
; 196  :     int             rc;         /* Return code                       */
; 197  : #endif
; 198  :     unsigned int    bufl;       /* Buffer length                     */
; 199  : #if defined( CCKD_BZIP2 )
; 200  :     unsigned int    ubufl;      /* when size_t != unsigned int       */
; 201  : #endif
; 202  : 
; 203  : #if !defined( HAVE_ZLIB ) && !defined( CCKD_BZIP2 )
; 204  :     UNREFERENCED(heads);

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN4@decomptrk
$LN7@decomptrk:

; 205  :     UNREFERENCED(trk);

  0001f	33 c0		 xor	 eax, eax
  00021	85 c0		 test	 eax, eax
  00023	75 fa		 jne	 SHORT $LN7@decomptrk
$LN10@decomptrk:

; 206  :     UNREFERENCED(emsg);

  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 fa		 jne	 SHORT $LN10@decomptrk

; 207  : #endif
; 208  : 
; 209  :     memset(obuf, 0, obuflen);

  0002b	48 63 44 24 58	 movsxd	 rax, DWORD PTR obuflen$[rsp]
  00030	48 89 44 24 10	 mov	 QWORD PTR tv69[rsp], rax
  00035	48 8b 7c 24 50	 mov	 rdi, QWORD PTR obuf$[rsp]
  0003a	33 c0		 xor	 eax, eax
  0003c	48 8b 4c 24 10	 mov	 rcx, QWORD PTR tv69[rsp]
  00041	f3 aa		 rep stosb

; 210  : 
; 211  :     /* Uncompress the track/block image */
; 212  :     switch (ibuf[0] & CCKD_COMPRESS_MASK)

  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	48 6b c0 00	 imul	 rax, rax, 0
  0004c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ibuf$[rsp]
  00051	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00055	83 e0 03	 and	 eax, 3
  00058	89 44 24 08	 mov	 DWORD PTR tv76[rsp], eax
  0005c	83 7c 24 08 00	 cmp	 DWORD PTR tv76[rsp], 0
  00061	74 02		 je	 SHORT $LN13@decomptrk
  00063	eb 35		 jmp	 SHORT $LN14@decomptrk
$LN13@decomptrk:

; 213  :     {
; 214  : 
; 215  :     case CCKD_COMPRESS_NONE:
; 216  :         bufl = (ibuflen < obuflen) ? ibuflen : obuflen;

  00065	8b 44 24 58	 mov	 eax, DWORD PTR obuflen$[rsp]
  00069	39 44 24 48	 cmp	 DWORD PTR ibuflen$[rsp], eax
  0006d	7d 09		 jge	 SHORT $LN16@decomptrk
  0006f	8b 44 24 48	 mov	 eax, DWORD PTR ibuflen$[rsp]
  00073	89 04 24	 mov	 DWORD PTR tv78[rsp], eax
  00076	eb 07		 jmp	 SHORT $LN17@decomptrk
$LN16@decomptrk:
  00078	8b 44 24 58	 mov	 eax, DWORD PTR obuflen$[rsp]
  0007c	89 04 24	 mov	 DWORD PTR tv78[rsp], eax
$LN17@decomptrk:
  0007f	8b 04 24	 mov	 eax, DWORD PTR tv78[rsp]
  00082	89 44 24 04	 mov	 DWORD PTR bufl$[rsp], eax

; 217  :         memcpy (obuf, ibuf, bufl);

  00086	8b 44 24 04	 mov	 eax, DWORD PTR bufl$[rsp]
  0008a	48 8b 7c 24 50	 mov	 rdi, QWORD PTR obuf$[rsp]
  0008f	48 8b 74 24 40	 mov	 rsi, QWORD PTR ibuf$[rsp]
  00094	8b c8		 mov	 ecx, eax
  00096	f3 a4		 rep movsb

; 218  :         break;

  00098	eb 07		 jmp	 SHORT $LN11@decomptrk
$LN14@decomptrk:

; 219  : 
; 220  : #if defined( HAVE_ZLIB )
; 221  :     case CCKD_COMPRESS_ZLIB:
; 222  :         memcpy (obuf, ibuf, CKD_TRKHDR_SIZE);
; 223  :         bufl = obuflen - CKD_TRKHDR_SIZE;
; 224  :         rc = uncompress(&obuf[ CKD_TRKHDR_SIZE ],
; 225  :                          (void *)&bufl,
; 226  :                          &ibuf[ CKD_TRKHDR_SIZE ],
; 227  :                          ibuflen);
; 228  :         if (rc != Z_OK)
; 229  :         {
; 230  :             if (emsg)
; 231  :             {
; 232  :                 char msg[81];
; 233  : 
; 234  :                 MSGBUF(msg, "%s %d uncompress error, rc=%d;"
; 235  :                          "%2.2x%2.2x%2.2x%2.2x%2.2x",
; 236  :                          heads >= 0 ? "trk" : "blk", trk, rc,
; 237  :                          ibuf[0], ibuf[1], ibuf[2], ibuf[3], ibuf[4]);
; 238  :                 memcpy(emsg, msg, 81);
; 239  :             }
; 240  :             return -1;
; 241  :         }
; 242  :         bufl += CKD_TRKHDR_SIZE;
; 243  :         break;
; 244  : #endif
; 245  : 
; 246  : #if defined( CCKD_BZIP2 )
; 247  :     case CCKD_COMPRESS_BZIP2:
; 248  :         memcpy(obuf, ibuf, CKD_TRKHDR_SIZE);
; 249  :         ubufl = obuflen - CKD_TRKHDR_SIZE;
; 250  :         rc = BZ2_bzBuffToBuffDecompress
; 251  :         (
; 252  :             (char *)&obuf[ CKD_TRKHDR_SIZE ],
; 253  :             &ubufl,
; 254  :             (char *)&ibuf[ CKD_TRKHDR_SIZE ],
; 255  :             ibuflen, 0, 0
; 256  :         );
; 257  :         if (rc != BZ_OK)
; 258  :         {
; 259  :             if (emsg)
; 260  :             {
; 261  :                 char msg[81];
; 262  : 
; 263  :                 MSGBUF(msg, "%s %d decompress error, rc=%d;"
; 264  :                          "%2.2x%2.2x%2.2x%2.2x%2.2x",
; 265  :                          heads >= 0 ? "trk" : "blk", trk, rc,
; 266  :                          ibuf[0], ibuf[1], ibuf[2], ibuf[3], ibuf[4]);
; 267  :                 memcpy(emsg, msg, 81);
; 268  :             }
; 269  :             return -1;
; 270  :         }
; 271  :         bufl=ubufl;
; 272  :         bufl += CKD_TRKHDR_SIZE;
; 273  :         break;
; 274  : #endif
; 275  : 
; 276  :     default:
; 277  :         return -1;

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	eb 04		 jmp	 SHORT $LN1@decomptrk
$LN11@decomptrk:

; 278  : 
; 279  :     } /* switch (buf[0] & CCKD_COMPRESS_MASK) */
; 280  :     return bufl;

  000a1	8b 44 24 04	 mov	 eax, DWORD PTR bufl$[rsp]
$LN1@decomptrk:

; 281  : }

  000a5	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a9	5f		 pop	 rdi
  000aa	5e		 pop	 rsi
  000ab	c3		 ret	 0
decomptrk ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
rc$ = 80
tv81 = 88
tv147 = 96
fd$ = 128
buf$ = 136
offset$ = 144
len$ = 152
readpos	PROC

; 124  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 125  :     int rc;
; 126  : 
; 127  :     if (debug)

  00017	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  0001e	74 61		 je	 SHORT $LN2@readpos

; 128  :     {
; 129  :         // "READPOS seeking %"PRId64" (0x%16.16"PRIX64")"
; 130  :         WRMSG( HHC90401, "D", offset, offset );

  00020	b9 01 00 00 00	 mov	 ecx, 1
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00033	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00038	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00040	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00045	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159641
  0004c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159642
  00058	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0005d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00062	41 b9 03 00 00
	00		 mov	 r9d, 3
  00068	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159643
  0006f	ba 82 00 00 00	 mov	 edx, 130		; 00000082H
  00074	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159644
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN2@readpos:

; 131  :     }
; 132  :     if (lseek( fd, offset, SEEK_SET ) < 0)

  00081	45 33 c0	 xor	 r8d, r8d
  00084	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR offset$[rsp]
  0008c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00099	48 85 c0	 test	 rax, rax
  0009c	0f 8d 80 00 00
	00		 jge	 $LN3@readpos

; 133  :     {
; 134  :         // "lseek() to pos 0x%16.16"PRIx64" error: %s"
; 135  :         FWRMSG( stderr, HHC02603, "S",

  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a8	8b 08		 mov	 ecx, DWORD PTR [rax]
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000b0	48 89 44 24 58	 mov	 QWORD PTR tv81[rsp], rax
  000b5	b9 02 00 00 00	 mov	 ecx, 2
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv81[rsp]
  000c5	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ca	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  000d2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159646
  000de	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159647
  000ea	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000f4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000fa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159648
  00101	ba 88 00 00 00	 mov	 edx, 136		; 00000088H
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159649
  0010d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 136  :             offset, strerror( errno ));
; 137  :         clean();

  00113	e8 00 00 00 00	 call	 clean

; 138  :         ErrExit( EXIT_SEEK_ERROR );

  00118	b9 01 00 00 00	 mov	 ecx, 1
  0011d	e8 00 00 00 00	 call	 ErrExit
$LN3@readpos:

; 139  :     }
; 140  : 
; 141  :     if (debug)

  00122	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  00129	74 6a		 je	 SHORT $LN4@readpos

; 142  :     {
; 143  :         // "READPOS reading buf addr %p length %d (0x%X)"
; 144  :         WRMSG( HHC90402, "D", buf, len, len);

  0012b	b9 01 00 00 00	 mov	 ecx, 1
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00136	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  0013d	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00141	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR len$[rsp]
  00148	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0014c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR buf$[rsp]
  00154	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00159	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159651
  00160	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159652
  0016c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00171	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00176	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159653
  00183	ba 90 00 00 00	 mov	 edx, 144		; 00000090H
  00188	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159654
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN4@readpos:

; 145  :     }
; 146  : 
; 147  :     rc = read( fd, buf, len);

  00195	44 8b 84 24 98
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  0019d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  001a5	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  001b2	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 148  : 
; 149  :     if (rc < (int) len )

  001b6	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  001bd	39 44 24 50	 cmp	 DWORD PTR rc$[rsp], eax
  001c1	0f 8d 52 01 00
	00		 jge	 $LN5@readpos

; 150  :     {
; 151  :         if (rc < 0)

  001c7	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  001cc	7d 75		 jge	 SHORT $LN6@readpos

; 152  :         {
; 153  :             // "%s%s"
; 154  :             FWRMSG( stderr, HHC02604, "S", "read() error: ", strerror( errno ));

  001ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d4	8b 08		 mov	 ecx, DWORD PTR [rax]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001dc	48 89 44 24 60	 mov	 QWORD PTR tv147[rsp], rax
  001e1	b9 02 00 00 00	 mov	 ecx, 2
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ec	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv147[rsp]
  001f1	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159658
  001fd	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00202	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159659
  00209	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0020e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159660
  00215	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00225	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159661
  0022c	ba 9a 00 00 00	 mov	 edx, 154		; 0000009aH
  00231	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159662
  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 155  :         }

  0023e	e9 c7 00 00 00	 jmp	 $LN7@readpos
$LN6@readpos:

; 156  :         else if (rc == 0)

  00243	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  00248	75 61		 jne	 SHORT $LN8@readpos

; 157  :         {
; 158  :             // "%s%s"
; 159  :             FWRMSG( stderr, HHC02604, "S", "read() error: ", "unexpected EOF" );

  0024a	b9 02 00 00 00	 mov	 ecx, 2
  0024f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159665
  0025c	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159666
  00268	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0026d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159667
  00274	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159668
  00280	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00285	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0028a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00290	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159669
  00297	ba 9f 00 00 00	 mov	 edx, 159		; 0000009fH
  0029c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159670
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 160  :         }

  002a9	eb 5f		 jmp	 SHORT $LN9@readpos
$LN8@readpos:

; 161  :         else
; 162  :         {
; 163  :             // "%s%s"
; 164  :             FWRMSG( stderr, HHC02604, "S", "read() error: ", "short block" );

  002ab	b9 02 00 00 00	 mov	 ecx, 2
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159671
  002bd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159672
  002c9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159673
  002d5	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159674
  002e1	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002e6	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002eb	41 b9 03 00 00
	00		 mov	 r9d, 3
  002f1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159675
  002f8	ba a4 00 00 00	 mov	 edx, 164		; 000000a4H
  002fd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159676
  00304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@readpos:
$LN7@readpos:

; 165  :         }
; 166  : 
; 167  :         clean();

  0030a	e8 00 00 00 00	 call	 clean

; 168  :         ErrExit( EXIT_READ_ERROR );

  0030f	b9 02 00 00 00	 mov	 ecx, 2
  00314	e8 00 00 00 00	 call	 ErrExit
$LN5@readpos:

; 169  :     }
; 170  :     return 0;

  00319	33 c0		 xor	 eax, eax

; 171  : }

  0031b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  0031f	c3		 ret	 0
readpos	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
p$ = 80
len$ = 112
label$ = 120
makbuf	PROC

; 95   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 96   :     void *p;
; 97   : 
; 98   :     if (!(p = malloc( len )))

  0000d	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  00012	48 8b c8	 mov	 rcx, rax
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0001b	48 89 44 24 50	 mov	 QWORD PTR p$[rsp], rax
  00020	48 83 7c 24 50
	00		 cmp	 QWORD PTR p$[rsp], 0
  00026	75 74		 jne	 SHORT $LN2@makbuf

; 99   :     {
; 100  :         // "From %s: Storage allocation of size %d using %s failed"
; 101  :         FWRMSG( stderr, HHC02602, "S", label, len, "malloc()" );

  00028	b9 02 00 00 00	 mov	 ecx, 2
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159618
  0003a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0003f	8b 4c 24 70	 mov	 ecx, DWORD PTR len$[rsp]
  00043	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00047	48 8b 4c 24 78	 mov	 rcx, QWORD PTR label$[rsp]
  0004c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159619
  00058	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0005d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159620
  00064	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00069	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00074	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159621
  0007b	ba 65 00 00 00	 mov	 edx, 101		; 00000065H
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159622
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 102  :         clean();

  0008d	e8 00 00 00 00	 call	 clean

; 103  :         ErrExit( EXIT_MALLOC_FAILED );

  00092	b9 04 00 00 00	 mov	 ecx, 4
  00097	e8 00 00 00 00	 call	 ErrExit
$LN2@makbuf:

; 104  :     }
; 105  :     if (debug)

  0009c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR debug, 0
  000a3	74 63		 je	 SHORT $LN3@makbuf

; 106  :     {
; 107  :         // "MAKBUF() malloc %s buffer of %d bytes at %p"
; 108  :         WRMSG( HHC90400, "D", label, len, p);

  000a5	b9 01 00 00 00	 mov	 ecx, 1
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR p$[rsp]
  000b5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000ba	8b 4c 24 70	 mov	 ecx, DWORD PTR len$[rsp]
  000be	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000c2	48 8b 4c 24 78	 mov	 rcx, QWORD PTR label$[rsp]
  000c7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159624
  000d3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159625
  000df	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159626
  000f6	ba 6c 00 00 00	 mov	 edx, 108		; 0000006cH
  000fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159627
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@makbuf:

; 109  :     }
; 110  :     return p;

  00108	48 8b 44 24 50	 mov	 rax, QWORD PTR p$[rsp]

; 111  : }

  0010d	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00111	c3		 ret	 0
makbuf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
clean	PROC

; 83   : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 84   :     close(fd);

  00004	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR fd
  0000a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 85   :     free(L1tab);                       /* L1TAB buffer               */

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L1tab
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 86   :     free(L2tab);                       /* L2TAB buffer               */

  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR L2tab
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 87   :     free(tbuf);                        /* track and header buffer    */

  0002a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR tbuf
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 88   :     free(bulk);                        /* offset data buffer         */

  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR bulk
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 89   : }

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
clean	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
pgm$ = 80
syntax	PROC

; 73   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 74   :     // "Usage: %s ...
; 75   :     WRMSG( HHC02600, "I", pgm );

  00009	b9 01 00 00 00	 mov	 ecx, 1
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00014	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pgm$[rsp]
  00019	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0001e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159600
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159601
  00031	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00036	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0003b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159602
  00048	ba 4b 00 00 00	 mov	 edx, 75			; 0000004bH
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159603
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 76   :     ErrExit( EXIT_ERROR_SYNTAX );

  0005a	b9 ff ff ff ff	 mov	 ecx, -1
  0005f	e8 00 00 00 00	 call	 ErrExit

; 77   : }

  00064	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00068	c3		 ret	 0
syntax	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cckddiag.c
_TEXT	SEGMENT
rc$ = 48
ErrExit	PROC

; 65   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 66   :     exit( rc );     // common breakpoint location

  00008	8b 4c 24 30	 mov	 ecx, DWORD PTR rc$[rsp]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN2@ErrExit:

; 67   : }

  00012	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00016	c3		 ret	 0
ErrExit	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT printf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Format$ = 64
printf	PROC						; COMDAT

; 956  :     {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 957  :         int _Result;
; 958  :         va_list _ArgList;
; 959  :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 48	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 960  :         _Result = _vfprintf_l(stdout, _Format, NULL, _ArgList);

  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0002d	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00032	45 33 c0	 xor	 r8d, r8d
  00035	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Format$[rsp]
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	e8 00 00 00 00	 call	 _vfprintf_l
  00042	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 961  :         __crt_va_end(_ArgList);

  00046	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 962  :         return _Result;

  0004f	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 963  :     }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
printf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
