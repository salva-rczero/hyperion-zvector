; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	maxrates_rpt_intvl
PUBLIC	curr_high_mips_rate
PUBLIC	curr_high_sios_rate
PUBLIC	prev_high_mips_rate
PUBLIC	prev_high_sios_rate
PUBLIC	curr_int_start_time
PUBLIC	prev_int_start_time
_BSS	SEGMENT
curr_high_mips_rate DD 01H DUP (?)
curr_high_sios_rate DD 01H DUP (?)
prev_high_mips_rate DD 01H DUP (?)
prev_high_sios_rate DD 01H DUP (?)
curr_int_start_time DQ 01H DUP (?)
prev_int_start_time DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
COMM	redraw_msgs:DWORD
COMM	redraw_cmd:DWORD
COMM	redraw_status:DWORD
_DATA	ENDS
_BSS	SEGMENT
$SG168319 DB	01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
maxrates_rpt_intvl DD 05a0H
$SG168223 DB	' 0', 00H
	ORG $+1
$SG168224 DB	' 1', 00H
	ORG $+1
$SG168225 DB	' 2', 00H
	ORG $+1
$SG168226 DB	' 3', 00H
	ORG $+1
$SG168227 DB	' 4', 00H
	ORG $+1
$SG168228 DB	' 5', 00H
	ORG $+1
$SG168229 DB	' 6', 00H
	ORG $+1
$SG168230 DB	' 7', 00H
	ORG $+1
$SG168231 DB	' 8', 00H
	ORG $+1
$SG168232 DB	' 9', 00H
	ORG $+1
$SG168233 DB	'10', 00H
	ORG $+1
$SG168234 DB	'11', 00H
	ORG $+1
$SG168235 DB	'12', 00H
	ORG $+1
$SG168236 DB	'13', 00H
	ORG $+1
$SG168237 DB	'14', 00H
	ORG $+1
$SG168238 DB	'15', 00H
	ORG $+1
$SG168240 DB	'0', 00H
	ORG $+2
$SG168241 DB	'1', 00H
	ORG $+2
$SG168242 DB	'2', 00H
	ORG $+2
$SG168243 DB	'3', 00H
	ORG $+2
$SG168244 DB	'4', 00H
	ORG $+2
$SG168245 DB	'5', 00H
	ORG $+2
$SG168246 DB	'6', 00H
	ORG $+2
$SG168247 DB	'7', 00H
	ORG $+2
$SG168248 DB	'8', 00H
	ORG $+2
$SG168249 DB	'9', 00H
	ORG $+2
$SG168250 DB	'A', 00H
	ORG $+2
$SG168251 DB	'B', 00H
	ORG $+2
$SG168252 DB	'C', 00H
	ORG $+2
$SG168253 DB	'D', 00H
	ORG $+2
$SG168254 DB	'E', 00H
	ORG $+2
$SG168255 DB	'F', 00H
	ORG $+6
$SG168297 DB	'defined CPUs (device server only mode).', 00H
$SG168294 DB	'All commands consist of one character keypresses. The va'
	DB	'rious commands are', 00H
	ORG $+5
$SG168295 DB	'highlighted onscreen by bright white versus the gray of '
	DB	'other lettering.', 00H
	ORG $+7
$SG168296 DB	'Disabled buttons, commands and areas are not shown when '
	DB	'operating without', 00H
	ORG $+2
$SG168298 DB	' ', 00H
	ORG $+2
$SG168299 DB	'Press the escape key to terminate the control panel and '
	DB	'go to command mode.', 00H
$SG168300 DB	' ', 00H
	ORG $+2
$SG168301 DB	'Display Controls:   G - General purpose regs    C - Cont'
	DB	'rol regs', 00H
	ORG $+7
$SG168303 DB	'                    I - Display main memory at ADDRESS', 00H
	ORG $+1
$SG168302 DB	'                    A - Access registers        F - Floa'
	DB	'ting Point regs', 00H
$SG168304 DB	'CPU controls:       L - IPL                     S - Star'
	DB	't CPU', 00H
	ORG $+2
$SG168305 DB	'                    E - External interrupt      P - Stop'
	DB	' CPU', 00H
	ORG $+3
$SG168307 DB	'Storage update:     R - Enter ADDRESS to be updated', 00H
	ORG $+4
$SG168306 DB	'                    W - Exit Hercules           T - Rest'
	DB	'art interrupt', 00H
	ORG $+2
$SG168308 DB	'                    D - Enter DATA to be updated at ADDR'
	DB	'ESS', 00H
$SG168310 DB	' ', 00H
	ORG $+2
$SG168309 DB	'                    O - place DATA value at ADDRESS', 00H
	ORG $+4
$SG168311 DB	'Peripherals:        N - enter a new name for the device '
	DB	'file assignment', 00H
$SG168312 DB	'                    U - send an I/O attention interrupt', 00H
$SG168313 DB	' ', 00H
	ORG $+6
$SG168316 DB	'model number means the attached file is open to the devi'
	DB	'ce.', 00H
$SG168317 DB	' ', 00H
	ORG $+10
$SG168314 DB	'In the display of the first 26 devices, a green device l'
	DB	'etter means the device', 00H
	ORG $+1
$SG168315 DB	'is online, a highlighted device address means the device'
	DB	' is busy, and a green', 00H
	ORG $+2
$SG168318 DB	'               Press Escape to return to control panel o'
	DB	'perations', 00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	set_console_title
PUBLIC	update_maxrates_hwm
PUBLIC	set_panel_colors
PUBLIC	the_real_panel_display
PUBLIC	__real@bff0000000000000
PUBLIC	__real@c000000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isdigit:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_isprint:PROC
EXTRN	__imp_isgraph:PROC
EXTRN	__imp_toupper:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	strcpy:PROC
EXTRN	strlen:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strncpy:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp__aligned_free:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp_getch:PROC
EXTRN	__imp_kbhit:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__localtime64:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_hthread_set_thread_name:PROC
EXTRN	__imp_get_symbol:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_idx_snprintf:PROC
EXTRN	__imp_ptyp2short:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_usleep:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_fprintf:PROC
EXTRN	__imp_w32_set_thread_name:PROC
EXTRN	__imp_log_read:PROC
EXTRN	__imp_log_wakeup:PROC
EXTRN	__imp_hdl_addshut:PROC
EXTRN	copy_psw:PROC
EXTRN	str_lparname:PROC
EXTRN	str_sysname:PROC
EXTRN	str_sysplex:PROC
EXTRN	str_systype:PROC
EXTRN	copy_regs:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	get_arch_name:PROC
EXTRN	history_init:PROC
EXTRN	history_next:PROC
EXTRN	history_prev:PROC
EXTRN	history_show:PROC
EXTRN	tab_pressed:PROC
EXTRN	set_screen_color:PROC
EXTRN	set_screen_pos:PROC
EXTRN	clear_screen:PROC
EXTRN	erase_to_eol:PROC
EXTRN	set_or_reset_console_mode:PROC
EXTRN	translate_keystroke:PROC
EXTRN	console_beep:PROC
EXTRN	get_console_dim:PROC
EXTRN	get_cursor_pos:PROC
EXTRN	set_console_cursor_shape:PROC
EXTRN	w32_set_console_title:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_panel_command:QWORD
EXTRN	history_requested:DWORD
EXTRN	historyCmdLine:QWORD
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
	ALIGN	4

NPDup	DD	01H DUP (?)
NPDinit	DD	01H DUP (?)
NPhelpup DD	01H DUP (?)
NPhelpdown DD	01H DUP (?)
NPregdisp DD	01H DUP (?)
NPcmd	DD	01H DUP (?)
NPdataentry DD	01H DUP (?)
NPdevsel DD	01H DUP (?)
NPpending DB	01H DUP (?)
	ALIGN	4

NPentered DB	0100H DUP (?)
NPprompt1 DB	028H DUP (?)
NPoldprompt1 DB	028H DUP (?)
NPprompt2 DB	028H DUP (?)
NPoldprompt2 DB	028H DUP (?)
NPsel2	DB	01H DUP (?)
	ALIGN	4

NPdevice DB	01H DUP (?)
	ALIGN	4

NPasgn	DD	01H DUP (?)
NPlastdev DD	01H DUP (?)
NPcpugraph_ncpu DD 01H DUP (?)
NPcpunum_valid DD 01H DUP (?)
NPcpupct_valid DD 01H DUP (?)
NPpsw_valid DD	01H DUP (?)
NPpswstate_valid DD 01H DUP (?)
NPregs_valid DD	01H DUP (?)
NPaddr_valid DD	01H DUP (?)
NPdata_valid DD	01H DUP (?)
NPmips_valid DD	01H DUP (?)
NPsios_valid DD	01H DUP (?)
NPdevices_valid DD 01H DUP (?)
NPcpugraph_valid DD 01H DUP (?)
NPpswmode DD	01H DUP (?)
NPpswzhost DD	01H DUP (?)
NPpsw	DB	010H DUP (?)
NPpswstate DB	010H DUP (?)
NPregmode DD	01H DUP (?)
NPregzhost DD	01H DUP (?)
NPregs64 DQ	010H DUP (?)
NPregs	DD	010H DUP (?)
NPaddress DD	01H DUP (?)
NPdata	DD	01H DUP (?)
NPmips	DD	01H DUP (?)
NPsios	DD	01H DUP (?)
NPcpugraph DD	01H DUP (?)
NPcpugraphpct DD 040H DUP (?)
NPonline DD	0fdH DUP (?)
NPdevnum DW	0fdH DUP (?)
	ALIGN	4

NPbusy	DD	0fdH DUP (?)
NPdevtype DW	0fdH DUP (?)
	ALIGN	4

NPopen	DD	0fdH DUP (?)
NPdevnam DB	07e80H DUP (?)
NPcurrow DW	01H DUP (?)
	ALIGN	4

NPcurcol DW	01H DUP (?)
	ALIGN	4

NPcolorSwitch DD 01H DUP (?)
NPcolorFore DW	01H DUP (?)
	ALIGN	4

NPcolorBack DW	01H DUP (?)
	ALIGN	4

NPdatalen DD	01H DUP (?)
cons_rows DD	01H DUP (?)
cons_cols DD	01H DUP (?)
cur_cons_row DW	01H DUP (?)
	ALIGN	4

cur_cons_col DW	01H DUP (?)
	ALIGN	8

cons_term DQ	01H DUP (?)
cmdline	DB	0101H DUP (?)
	ALIGN	4

cmdlen	DD	01H DUP (?)
cmdoff	DD	01H DUP (?)
saved_cmdline DB 0101H DUP (?)
	ALIGN	4

saved_cmdlen DD	01H DUP (?)
saved_cmdoff DD	01H DUP (?)
saved_cons_row DW 01H DUP (?)
	ALIGN	4

saved_cons_col DW 01H DUP (?)
	ALIGN	4

cmdcols	DD	01H DUP (?)
cmdcol	DD	01H DUP (?)
confp	DQ	01H DUP (?)
msgbuf	DQ	01H DUP (?)
topmsg	DQ	01H DUP (?)
curmsg	DQ	01H DUP (?)
wrapped	DD	01H DUP (?)
numkept	DD	01H DUP (?)
npquiet	DD	01H DUP (?)
	ALIGN	8

lmsbuf	DQ	01H DUP (?)
lmsndx	DD	01H DUP (?)
copyregs DB	016080H DUP (?)
copysieregs DB	016080H DUP (?)
$SG168600 DB	01H DUP (?)
	ALIGN	4

$SG168601 DB	01H DUP (?)
	ALIGN	4

?obfr@?1??format_int@@9@9 DB 020H DUP (?)		; `format_int'::`2'::obfr
$SG168910 DB	01H DUP (?)
	ALIGN	4

$SG169394 DB	01H DUP (?)
	ALIGN	4

$SG169399 DB	01H DUP (?)
	ALIGN	4

$SG169623 DB	01H DUP (?)
	ALIGN	4

$SG169626 DB	01H DUP (?)
	ALIGN	4

$SG169629 DB	01H DUP (?)
	ALIGN	4

$SG169631 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$localtime DD imagerel localtime
	DD	imagerel localtime+25
	DD	imagerel $unwind$localtime
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$set_console_title DD imagerel $LN20
	DD	imagerel $LN20+1070
	DD	imagerel $unwind$set_console_title
$pdata$update_maxrates_hwm DD imagerel $LN6
	DD	imagerel $LN6+221
	DD	imagerel $unwind$update_maxrates_hwm
$pdata$set_panel_colors DD imagerel $LN9
	DD	imagerel $LN9+1261
	DD	imagerel $unwind$set_panel_colors
$pdata$the_real_panel_display DD imagerel $LN568
	DD	imagerel $LN568+19679
	DD	imagerel $unwind$the_real_panel_display
$pdata$beep DD	imagerel beep
	DD	imagerel beep+21
	DD	imagerel $unwind$beep
$pdata$oldest_msg DD imagerel oldest_msg
	DD	imagerel oldest_msg+49
	DD	imagerel $unwind$oldest_msg
$pdata$visible_lines DD imagerel visible_lines
	DD	imagerel visible_lines+16
	DD	imagerel $unwind$visible_lines
$pdata$is_currline_visible DD imagerel is_currline_visible
	DD	imagerel is_currline_visible+55
	DD	imagerel $unwind$is_currline_visible
$pdata$lines_remaining DD imagerel lines_remaining
	DD	imagerel lines_remaining+41
	DD	imagerel $unwind$lines_remaining
$pdata$scroll_up_lines DD imagerel scroll_up_lines
	DD	imagerel scroll_up_lines+77
	DD	imagerel $unwind$scroll_up_lines
$pdata$scroll_down_lines DD imagerel scroll_down_lines
	DD	imagerel scroll_down_lines+90
	DD	imagerel $unwind$scroll_down_lines
$pdata$page_up DD imagerel page_up
	DD	imagerel page_up+33
	DD	imagerel $unwind$page_up
$pdata$page_down DD imagerel page_down
	DD	imagerel page_down+33
	DD	imagerel $unwind$page_down
$pdata$scroll_to_top_line DD imagerel scroll_to_top_line
	DD	imagerel scroll_to_top_line+21
	DD	imagerel $unwind$scroll_to_top_line
$pdata$scroll_to_bottom_line DD imagerel scroll_to_bottom_line
	DD	imagerel scroll_to_bottom_line+35
	DD	imagerel $unwind$scroll_to_bottom_line
$pdata$scroll_to_bottom_screen DD imagerel scroll_to_bottom_screen
	DD	imagerel scroll_to_bottom_screen+19
	DD	imagerel $unwind$scroll_to_bottom_screen
$pdata$do_panel_command DD imagerel do_panel_command
	DD	imagerel do_panel_command+230
	DD	imagerel $unwind$do_panel_command
$pdata$do_prev_history DD imagerel do_prev_history
	DD	imagerel do_prev_history+191
	DD	imagerel $unwind$do_prev_history
$pdata$do_next_history DD imagerel do_next_history
	DD	imagerel do_next_history+191
	DD	imagerel $unwind$do_next_history
$pdata$clr_screen DD imagerel clr_screen
	DD	imagerel clr_screen+21
	DD	imagerel $unwind$clr_screen
$pdata$get_dim DD imagerel get_dim
	DD	imagerel get_dim+89
	DD	imagerel $unwind$get_dim
$pdata$set_color DD imagerel set_color
	DD	imagerel set_color+42
	DD	imagerel $unwind$set_color
$pdata$set_pos DD imagerel set_pos
	DD	imagerel set_pos+210
	DD	imagerel $unwind$set_pos
$pdata$is_cursor_on_cmdline DD imagerel is_cursor_on_cmdline
	DD	imagerel is_cursor_on_cmdline+180
	DD	imagerel $unwind$is_cursor_on_cmdline
$pdata$cursor_cmdline_home DD imagerel cursor_cmdline_home
	DD	imagerel cursor_cmdline_home+130
	DD	imagerel $unwind$cursor_cmdline_home
$pdata$cursor_cmdline_end DD imagerel cursor_cmdline_end
	DD	imagerel cursor_cmdline_end+145
	DD	imagerel $unwind$cursor_cmdline_end
$pdata$save_command_line DD imagerel save_command_line
	DD	imagerel save_command_line+85
	DD	imagerel $unwind$save_command_line
$pdata$restore_command_line DD imagerel restore_command_line
	DD	imagerel restore_command_line+85
	DD	imagerel $unwind$restore_command_line
$pdata$draw_text DD imagerel draw_text
	DD	imagerel draw_text+254
	DD	imagerel $unwind$draw_text
$pdata$write_text DD imagerel write_text
	DD	imagerel write_text+172
	DD	imagerel $unwind$write_text
$pdata$draw_char DD imagerel draw_char
	DD	imagerel draw_char+103
	DD	imagerel $unwind$draw_char
$pdata$draw_fw DD imagerel draw_fw
	DD	imagerel draw_fw+79
	DD	imagerel $unwind$draw_fw
$pdata$draw_dw DD imagerel draw_dw
	DD	imagerel draw_dw+80
	DD	imagerel $unwind$draw_dw
$pdata$fill_text DD imagerel fill_text
	DD	imagerel fill_text+207
	DD	imagerel $unwind$fill_text
$pdata$draw_button DD imagerel draw_button
	DD	imagerel draw_button+105
	DD	imagerel $unwind$draw_button
$pdata$NP_init DD imagerel NP_init
	DD	imagerel NP_init+71
	DD	imagerel $unwind$NP_init
$pdata$NP_screen_redraw DD imagerel NP_screen_redraw
	DD	imagerel NP_screen_redraw+2874
	DD	imagerel $unwind$NP_screen_redraw
$pdata$format_int DD imagerel format_int
	DD	imagerel format_int+400
	DD	imagerel $unwind$format_int
$pdata$NP_update DD imagerel NP_update
	DD	imagerel NP_update+9311
	DD	imagerel $unwind$NP_update
$pdata$panel_cleanup DD imagerel panel_cleanup
	DD	imagerel panel_cleanup+360
	DD	imagerel $unwind$panel_cleanup
$pdata$panel_copy_regs DD imagerel panel_copy_regs
	DD	imagerel panel_copy_regs+454
	DD	imagerel $unwind$panel_copy_regs
$pdata$msgcolor DD imagerel msgcolor
	DD	imagerel msgcolor+228
	DD	imagerel $unwind$msgcolor
$pdata$fg_msgcolor DD imagerel fg_msgcolor
	DD	imagerel fg_msgcolor+24
	DD	imagerel $unwind$fg_msgcolor
$pdata$bg_msgcolor DD imagerel bg_msgcolor
	DD	imagerel bg_msgcolor+27
	DD	imagerel $unwind$bg_msgcolor
$pdata$msg_sev DD imagerel msg_sev
	DD	imagerel msg_sev+99
	DD	imagerel $unwind$msg_sev
pdata	ENDS
;	COMDAT __real@c000000000000000
CONST	SEGMENT
__real@c000000000000000 DQ 0c000000000000000r	; -2
CONST	ENDS
;	COMDAT __real@bff0000000000000
CONST	SEGMENT
__real@bff0000000000000 DQ 0bff0000000000000r	; -1
CONST	ENDS
_DATA	SEGMENT
cmdins	DB	01H
	ORG $+1
NPhelppaint DD	01H
cursor_on_cmdline DD 01H
	ORG $+4
NPregnum DQ	FLAT:$SG168223
	DQ	FLAT:$SG168224
	DQ	FLAT:$SG168225
	DQ	FLAT:$SG168226
	DQ	FLAT:$SG168227
	DQ	FLAT:$SG168228
	DQ	FLAT:$SG168229
	DQ	FLAT:$SG168230
	DQ	FLAT:$SG168231
	DQ	FLAT:$SG168232
	DQ	FLAT:$SG168233
	DQ	FLAT:$SG168234
	DQ	FLAT:$SG168235
	DQ	FLAT:$SG168236
	DQ	FLAT:$SG168237
	DQ	FLAT:$SG168238
NPregnum64 DQ	FLAT:$SG168240
	DQ	FLAT:$SG168241
	DQ	FLAT:$SG168242
	DQ	FLAT:$SG168243
	DQ	FLAT:$SG168244
	DQ	FLAT:$SG168245
	DQ	FLAT:$SG168246
	DQ	FLAT:$SG168247
	DQ	FLAT:$SG168248
	DQ	FLAT:$SG168249
	DQ	FLAT:$SG168250
	DQ	FLAT:$SG168251
	DQ	FLAT:$SG168252
	DQ	FLAT:$SG168253
	DQ	FLAT:$SG168254
	DQ	FLAT:$SG168255
NPhelp	DQ	FLAT:$SG168294
	DQ	FLAT:$SG168295
	DQ	FLAT:$SG168296
	DQ	FLAT:$SG168297
	DQ	FLAT:$SG168298
	DQ	FLAT:$SG168299
	DQ	FLAT:$SG168300
	DQ	FLAT:$SG168301
	DQ	FLAT:$SG168302
	DQ	FLAT:$SG168303
	DQ	FLAT:$SG168304
	DQ	FLAT:$SG168305
	DQ	FLAT:$SG168306
	DQ	FLAT:$SG168307
	DQ	FLAT:$SG168308
	DQ	FLAT:$SG168309
	DQ	FLAT:$SG168310
	DQ	FLAT:$SG168311
	DQ	FLAT:$SG168312
	DQ	FLAT:$SG168313
	DQ	FLAT:$SG168314
	DQ	FLAT:$SG168315
	DQ	FLAT:$SG168316
	DQ	FLAT:$SG168317
	DQ	FLAT:$SG168318
	DQ	FLAT:$SG168319
lmsnum	DD	0ffffffffH
lmscnt	DD	0ffffffffH
lmsmax	DD	080000H
keybfd	DD	0ffffffffH
$SG168469 DB	'herc =====> ', 00H
	ORG $+3
$SG168470 DB	'herc =====> ', 00H
	ORG $+3
$SG168481 DB	'herc =====> ', 00H
	ORG $+3
$SG168492 DB	'herc =====> ', 00H
	ORG $+3
$SG168510 DB	'%s', 00H
	ORG $+1
$SG168512 DB	'%s', 00H
	ORG $+1
$SG168533 DB	'%8.8X', 00H
	ORG $+2
$SG168539 DB	'%16.16llX', 00H
	ORG $+2
$SG168583 DB	' - ', 00H
$SG168586 DB	' * ', 00H
$SG168589 DB	' * ', 00H
$SG168591 DB	'%s - System Status: %s', 00H
	ORG $+1
$SG168592 DB	'System Status: %s', 00H
	ORG $+2
$SG168596 DB	'%s', 00H
	ORG $+1
$SG168597 DB	'%s - System Status: %s', 00H
	ORG $+1
$SG168625 DB	'  Hercules', 00H
	ORG $+1
$SG168628 DB	'| ', 00H
	ORG $+1
$SG168627 DB	'CPU:    %', 00H
	ORG $+2
$SG168637 DB	'PSW', 00H
$SG168629 DB	'Peripherals [Shared Port %u]', 00H
	ORG $+3
$SG168633 DB	' Addr Modl Type Assig', 00H
	ORG $+2
$SG168634 DB	'ment', 00H
	ORG $+3
$SG168641 DB	'GPR', 00H
$SG168642 DB	'CR', 00H
	ORG $+1
$SG168643 DB	'AR', 00H
	ORG $+1
$SG168644 DB	'FPR', 00H
$SG168645 DB	'ADD', 00H
$SG168646 DB	'ESS:', 00H
	ORG $+3
$SG168647 DB	'ATA:', 00H
	ORG $+3
$SG168650 DB	' ', 00H
	ORG $+2
$SG168648 DB	'No CPUs defined', 00H
$SG168651 DB	'O', 00H
	ORG $+2
$SG168652 DB	' ST', 00H
$SG168653 DB	'S ', 00H
	ORG $+1
$SG168654 DB	'I', 00H
	ORG $+2
$SG168655 DB	' D', 00H
	ORG $+1
$SG168656 DB	' ', 00H
	ORG $+2
$SG168657 DB	'T', 00H
	ORG $+2
$SG168658 DB	' RS', 00H
$SG168660 DB	'MIPS', 00H
	ORG $+3
$SG168663 DB	'IO/s', 00H
	ORG $+3
$SG168665 DB	'TR ', 00H
$SG168666 DB	'S', 00H
	ORG $+2
$SG168667 DB	' ', 00H
	ORG $+2
$SG168668 DB	' ', 00H
	ORG $+2
$SG168669 DB	'P', 00H
	ORG $+2
$SG168670 DB	' ST', 00H
$SG168671 DB	'XT ', 00H
$SG168672 DB	'E', 00H
	ORG $+2
$SG168673 DB	' ', 00H
	ORG $+2
$SG168674 DB	' ', 00H
	ORG $+2
$SG168675 DB	'L', 00H
	ORG $+2
$SG168676 DB	' IP', 00H
$SG168677 DB	'R ', 00H
	ORG $+1
$SG168678 DB	'W', 00H
	ORG $+2
$SG168679 DB	' P', 00H
	ORG $+1
$SG168700 DB	'0', 00H
	ORG $+2
$SG168682 DB	'%s%02X ', 00H
$SG168703 DB	'%u', 00H
	ORG $+1
$SG168704 DB	'%3.3u', 00H
	ORG $+2
$SG168707 DB	',', 00H
	ORG $+2
$SG168799 DB	'%3d', 00H
$SG168804 DB	'PSW', 00H
$SG168811 DB	'----------------', 00H
	ORG $+3
$SG168873 DB	'%6.6s', 00H
	ORG $+2
$SG168905 DB	'%-4.4s', 00H
	ORG $+1
$SG169336 DB	'E', 00H
	ORG $+2
$SG168812 DB	'%2d%c%c%c%c%c%c%c%c', 00H
$SG169342 DB	'E', 00H
	ORG $+2
$SG168833 DB	'--------', 00H
	ORG $+3
$SG168899 DB	'%4.4X', 00H
	ORG $+2
$SG169449 DB	'ext', 00H
$SG168837 DB	'--------', 00H
	ORG $+3
$SG168902 DB	'%4.4X', 00H
	ORG $+2
$SG169462 DB	'IMMED ', 00H
	ORG $+1
$SG169512 DB	'W', 00H
	ORG $+2
$SG168862 DB	'%2d,%03d', 00H
	ORG $+3
$SG169466 DB	'DELAY ', 00H
	ORG $+1
$SG169532 DB	01bH, 'w', 00H
	ORG $+1
$SG168865 DB	'%4d.%01d', 00H
	ORG $+3
$SG169473 DB	'SUBST ', 00H
	ORG $+1
$SG169534 DB	01bH, 'u', 00H
	ORG $+1
$SG168868 DB	'%3d.%02d', 00H
	ORG $+3
$SG169477 DB	'IMMED ', 00H
	ORG $+1
$SG169536 DB	01bH, '[A', 00H
$SG168869 DB	'%2d.%03d', 00H
	ORG $+3
$SG169480 DB	'DELAY ', 00H
	ORG $+1
$SG169538 DB	01bH, '[B', 00H
$SG168879 DB	'OFFLINE', 00H
$SG168884 DB	'STOPPED', 00H
$SG168898 DB	'SYSG', 00H
	ORG $+3
$SG168923 DB	'NP_update', 00H
	ORG $+2
$SG169540 DB	01bH, 'OA', 00H
$SG168924 DB	'panel.c', 00H
$SG168925 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168927 DB	'NP_update', 00H
	ORG $+2
$SG169543 DB	01bH, 'OB', 00H
$SG168928 DB	'panel.c', 00H
$SG168929 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG168954 DB	'panel.c:1566', 00H
	ORG $+3
$SG168956 DB	'panel.c:1571', 00H
	ORG $+3
$SG168957 DB	'panel.c:1578', 00H
	ORG $+3
$SG169323 DB	'panel_display', 00H
	ORG $+2
$SG169324 DB	'panel_display', 00H
	ORG $+2
$SG169325 DB	'panel_cleanup', 00H
	ORG $+2
$SG169326 DB	'SUBST IMMED help &0', 00H
$SG169327 DB	'PF01', 00H
	ORG $+3
$SG169550 DB	01bH, 'D', 00H
	ORG $+1
$SG169328 DB	'IMMED devlist TAPE', 00H
	ORG $+1
$SG169329 DB	'PF11', 00H
	ORG $+3
$SG169552 DB	01bH, 'M', 00H
	ORG $+1
$SG169330 DB	'SUBST DELAY devinit &*', 00H
	ORG $+1
$SG169331 DB	'PF10', 00H
	ORG $+3
$SG169332 DB	'TERM', 00H
	ORG $+3
$SG169333 DB	'herc =====> ', 00H
	ORG $+3
$SG169335 DB	'malloc(%d)', 00H
	ORG $+1
$SG169567 DB	01bH, '[D', 00H
$SG169337 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169338 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169339 DB	'panel.c', 00H
$SG169341 DB	'malloc(%d)', 00H
	ORG $+1
$SG169573 DB	01bH, '[C', 00H
$SG169343 DB	'HHC00075%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169348 DB	'herc =====> ', 00H
	ORG $+3
$SG169367 DB	'startall', 00H
	ORG $+3
$SG169579 DB	01bH, 'OD', 00H
$SG169371 DB	'stopall', 00H
$SG169395 DB	'Enter Address', 00H
	ORG $+2
$SG169400 DB	'Enter Data Value', 00H
	ORG $+3
$SG169583 DB	01bH, 'OC', 00H
$SG169404 DB	'Select Device for IPL', 00H
	ORG $+2
$SG169409 DB	'ipl %4.4x', 00H
	ORG $+2
$SG169622 DB	'%x', 00H
	ORG $+1
$SG169412 DB	'Select Device for Interrupt', 00H
$SG169625 DB	'%x', 00H
	ORG $+1
$SG169417 DB	'i %4.4x', 00H
$SG169420 DB	'Select Device to Reassign', 00H
	ORG $+2
$SG169715 DB	'+', 00H
	ORG $+2
$SG169424 DB	'New Name, or [enter] to Reload', 00H
	ORG $+1
$SG169427 DB	'Confirm Powerdown Y or N', 00H
	ORG $+3
$SG169431 DB	'quit', 00H
	ORG $+3
$SG169717 DB	'V', 00H
	ORG $+2
$SG169435 DB	'Confirm Restart Y or N', 00H
	ORG $+1
$SG169440 DB	'restart', 00H
$SG169444 DB	'Confirm External Interrupt Y or N', 00H
	ORG $+2
$SG169455 DB	'PF%s', 00H
	ORG $+3
$SG169736 DB	'RED', 00H
$SG169458 DB	'DELAY * %s UNDEFINED', 00H
	ORG $+3
$SG169513 DB	'HHC01608%s PF KEY SUBSTitution results would exceed comm'
	DB	'and line maximum size of %d; truncation occurred', 0aH, 00H
	ORG $+2
$SG169754 DB	'%s', 00H
	ORG $+1
$SG169514 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169515 DB	'panel.c', 00H
$SG169522 DB	01bH, '[1~', 00H
	ORG $+3
$SG169527 DB	01bH, '[4~', 00H
	ORG $+3
$SG169546 DB	01bH, '[5~', 00H
	ORG $+3
$SG169548 DB	01bH, '[6~', 00H
	ORG $+3
$SG169562 DB	01bH, '[3~', 00H
	ORG $+3
$SG169587 DB	01bH, '[2~', 00H
	ORG $+3
$SG169630 DB	'devinit %4.4x %s', 00H
	ORG $+3
$SG169738 DB	'AMBER', 00H
	ORG $+2
$SG169789 DB	'I', 00H
	ORG $+2
$SG169640 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169641 DB	'panel.c', 00H
$SG169642 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169644 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169645 DB	'panel.c', 00H
$SG169653 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169646 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169654 DB	'panel.c', 00H
$SG169655 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169657 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169658 DB	'panel.c', 00H
$SG169664 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169659 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169665 DB	'panel.c', 00H
$SG169666 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169668 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169669 DB	'panel.c', 00H
$SG169673 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169670 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169674 DB	'panel.c', 00H
$SG169675 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169677 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169678 DB	'panel.c', 00H
$SG169721 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169679 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169719 DB	'herc =====> ', 00H
	ORG $+3
$SG169722 DB	'panel.c', 00H
$SG169723 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169725 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169726 DB	'panel.c', 00H
$SG169743 DB	'GREEN', 00H
	ORG $+2
$SG169727 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169744 DB	'%s%02X ', 00H
$SG169747 DB	'PSW=%8.8X%8.8X ', 00H
$SG169750 DB	'%16.16llX ', 00H
	ORG $+1
$SG169815 DB	0aH, 00H
	ORG $+2
$SG169752 DB	'%2d%c%c%c%c%c%c%c%c', 00H
	ORG $+4
$SG169753 DB	'Offline', 00H
$SG169756 DB	'instcnt %s', 00H
	ORG $+5
$SG169760 DB	'; mips %1d,%03d', 00H
$SG169763 DB	'; mips %3d.%01d', 00H
$SG169766 DB	'; mips %2d.%02d', 00H
$SG169767 DB	'; mips %1d.%03d', 00H
$SG169771 DB	'I/O %6.6s', 00H
	ORG $+6
$SG169780 DB	'herc =====> ', 00H
	ORG $+3
$SG169787 DB	'panel_display', 00H
	ORG $+2
$SG169788 DB	'panel.c:3313', 00H
	ORG $+3
$SG169790 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG169791 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169792 DB	'panel.c', 00H
$SG169794 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169795 DB	'panel.c', 00H
$SG169798 DB	'the_real_panel_display', 00H
	ORG $+1
$SG169796 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169799 DB	'panel.c', 00H
$SG169800 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:NP_update
	DD	018H
	DD	02445H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:format_int
	DD	013H
	DD	017eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:NP_screen_redraw
	DD	016H
	DD	0b22H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fill_text
	DD	01bH
	DD	0b6H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:draw_dw
	DD	013H
	DD	03eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:draw_fw
	DD	012H
	DD	03dH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:the_real_panel_display
	DD	01aH
	DD	04baaH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:set_console_title
	DD	017H
	DD	0415H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$localtime DD 010901H
	DD	04209H
$unwind$time DD	010901H
	DD	04209H
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$set_console_title DD 031f19H
	DD	056010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	02a0H
$unwind$update_maxrates_hwm DD 010401H
	DD	06204H
$unwind$set_panel_colors DD 010401H
	DD	02204H
$unwind$the_real_panel_display DD 042219H
	DD	02990110H
	DD	060027003H
	DD	imagerel __GSHandlerCheck
	DD	014b0H
$unwind$beep DD	010401H
	DD	04204H
$unwind$oldest_msg DD 010401H
	DD	02204H
$unwind$visible_lines DD 010401H
	DD	04204H
$unwind$is_currline_visible DD 010401H
	DD	06204H
$unwind$lines_remaining DD 010401H
	DD	06204H
$unwind$scroll_up_lines DD 010801H
	DD	06208H
$unwind$scroll_down_lines DD 010801H
	DD	06208H
$unwind$page_up DD 010401H
	DD	04204H
$unwind$page_down DD 010401H
	DD	04204H
$unwind$scroll_to_top_line DD 010401H
	DD	04204H
$unwind$scroll_to_bottom_line DD 010401H
	DD	04204H
$unwind$scroll_to_bottom_screen DD 010401H
	DD	04204H
$unwind$do_panel_command DD 010901H
	DD	06209H
$unwind$do_prev_history DD 010401H
	DD	06204H
$unwind$do_next_history DD 010401H
	DD	06204H
$unwind$clr_screen DD 010401H
	DD	04204H
$unwind$get_dim DD 010e01H
	DD	0420eH
$unwind$set_color DD 010e01H
	DD	0420eH
$unwind$set_pos DD 010e01H
	DD	0620eH
$unwind$is_cursor_on_cmdline DD 010401H
	DD	06204H
$unwind$cursor_cmdline_home DD 010401H
	DD	04204H
$unwind$cursor_cmdline_end DD 010401H
	DD	04204H
$unwind$save_command_line DD 020301H
	DD	060027003H
$unwind$restore_command_line DD 020301H
	DD	060027003H
$unwind$draw_text DD 010901H
	DD	06209H
$unwind$write_text DD 010d01H
	DD	0420dH
$unwind$draw_char DD 010801H
	DD	04208H
$unwind$draw_fw DD 011719H
	DD	08208H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$draw_dw DD 011819H
	DD	08209H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$fill_text DD 032319H
	DD	02c0111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0150H
$unwind$draw_button DD 011901H
	DD	04219H
$unwind$NP_init DD 010401H
	DD	04204H
$unwind$NP_screen_redraw DD 021e19H
	DD	08f010cH
	DD	imagerel __GSHandlerCheck
	DD	0460H
$unwind$format_int DD 011819H
	DD	0c209H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$NP_update DD 042019H
	DD	0d7010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	06a0H
$unwind$panel_cleanup DD 010901H
	DD	06209H
$unwind$panel_copy_regs DD 030a01H
	DD	07006620aH
	DD	06005H
$unwind$msgcolor DD 010c01H
	DD	0220cH
$unwind$fg_msgcolor DD 010801H
	DD	04208H
$unwind$bg_msgcolor DD 010801H
	DD	04208H
$unwind$msg_sev DD 010901H
	DD	06209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv67 = 32
sevidx$1 = 36
msg$ = 64
msg_sev	PROC

; 1707 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1708 : #if defined(HAVE_REGEX_H) || defined(HAVE_PCRE)
; 1709 :     if (have_regexp)
; 1710 :     {
; 1711 :         if (regexec( &regexp, msg, 1, &regmatch, 0 ) == 0)
; 1712 :             return (int)(msg[ regmatch.rm_so + 8 ]);
; 1713 :     }
; 1714 :     else
; 1715 : #endif // defined(HAVE_REGEX_H) || defined(HAVE_PCRE)
; 1716 :     {
; 1717 :         int sevidx = MLVL( DEBUG ) ? MLVL_DEBUG_PFXIDX + 8 : 8;

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00016	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0001b	85 c0		 test	 eax, eax
  0001d	74 0a		 je	 SHORT $LN4@msg_sev
  0001f	c7 44 24 20 1a
	00 00 00	 mov	 DWORD PTR tv67[rsp], 26
  00027	eb 08		 jmp	 SHORT $LN5@msg_sev
$LN4@msg_sev:
  00029	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR tv67[rsp], 8
$LN5@msg_sev:
  00031	8b 44 24 20	 mov	 eax, DWORD PTR tv67[rsp]
  00035	89 44 24 24	 mov	 DWORD PTR sevidx$1[rsp], eax

; 1718 :         if ((int)strlen( msg ) > sevidx)

  00039	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  0003e	e8 00 00 00 00	 call	 strlen
  00043	3b 44 24 24	 cmp	 eax, DWORD PTR sevidx$1[rsp]
  00047	7e 10		 jle	 SHORT $LN2@msg_sev

; 1719 :             return (int)(msg[ sevidx ]);

  00049	48 63 44 24 24	 movsxd	 rax, DWORD PTR sevidx$1[rsp]
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR msg$[rsp]
  00053	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00057	eb 05		 jmp	 SHORT $LN1@msg_sev
$LN2@msg_sev:

; 1720 :     }
; 1721 :     return (int)' ';

  00059	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
$LN1@msg_sev:

; 1722 : }

  0005e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00062	c3		 ret	 0
msg_sev	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
sev$ = 48
bg_msgcolor PROC

; 1683 : static int bg_msgcolor( int sev ) { return msgcolor( sev, PANC_BG_IDX ); }

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	ba 01 00 00 00	 mov	 edx, 1
  0000d	8b 4c 24 30	 mov	 ecx, DWORD PTR sev$[rsp]
  00011	e8 00 00 00 00	 call	 msgcolor
  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
bg_msgcolor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
sev$ = 48
fg_msgcolor PROC

; 1682 : static int fg_msgcolor( int sev ) { return msgcolor( sev, PANC_FG_IDX ); }

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00008	33 d2		 xor	 edx, edx
  0000a	8b 4c 24 30	 mov	 ecx, DWORD PTR sev$[rsp]
  0000e	e8 00 00 00 00	 call	 msgcolor
  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
fg_msgcolor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv64 = 0
sev$ = 32
fgbg$ = 40
msgcolor PROC

; 1674 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 18	 sub	 rsp, 24

; 1675 :     switch (sev) {

  0000c	8b 44 24 20	 mov	 eax, DWORD PTR sev$[rsp]
  00010	89 04 24	 mov	 DWORD PTR tv64[rsp], eax
  00013	83 3c 24 44	 cmp	 DWORD PTR tv64[rsp], 68	; 00000044H
  00017	0f 84 80 00 00
	00		 je	 $LN7@msgcolor
  0001d	83 3c 24 45	 cmp	 DWORD PTR tv64[rsp], 69	; 00000045H
  00021	74 36		 je	 SHORT $LN5@msgcolor
  00023	83 3c 24 49	 cmp	 DWORD PTR tv64[rsp], 73	; 00000049H
  00027	74 0b		 je	 SHORT $LN4@msgcolor
  00029	83 3c 24 57	 cmp	 DWORD PTR tv64[rsp], 87	; 00000057H
  0002d	74 4c		 je	 SHORT $LN6@msgcolor
  0002f	e9 8b 00 00 00	 jmp	 $LN8@msgcolor
$LN4@msgcolor:

; 1676 :     case 'I': return sysblk.pan_color[ PANC_I_IDX ][ fgbg ];

  00034	b8 08 00 00 00	 mov	 eax, 8
  00039	48 6b c0 01	 imul	 rax, rax, 1
  0003d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00044	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  0004c	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR fgbg$[rsp]
  00051	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00054	e9 86 00 00 00	 jmp	 $LN1@msgcolor
$LN5@msgcolor:

; 1677 :     case 'E': return sysblk.pan_color[ PANC_E_IDX ][ fgbg ];

  00059	b8 08 00 00 00	 mov	 eax, 8
  0005e	48 6b c0 02	 imul	 rax, rax, 2
  00062	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00069	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00071	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR fgbg$[rsp]
  00076	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00079	eb 64		 jmp	 SHORT $LN1@msgcolor
$LN6@msgcolor:

; 1678 :     case 'W': return sysblk.pan_color[ PANC_W_IDX ][ fgbg ];

  0007b	b8 08 00 00 00	 mov	 eax, 8
  00080	48 6b c0 03	 imul	 rax, rax, 3
  00084	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008b	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00093	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR fgbg$[rsp]
  00098	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0009b	eb 42		 jmp	 SHORT $LN1@msgcolor
$LN7@msgcolor:

; 1679 :     case 'D': return sysblk.pan_color[ PANC_D_IDX ][ fgbg ]; default: break; }

  0009d	b8 08 00 00 00	 mov	 eax, 8
  000a2	48 6b c0 04	 imul	 rax, rax, 4
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ad	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  000b5	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR fgbg$[rsp]
  000ba	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  000bd	eb 20		 jmp	 SHORT $LN1@msgcolor
$LN8@msgcolor:

; 1680 :               return sysblk.pan_color[ PANC_X_IDX ][ fgbg ];

  000bf	b8 08 00 00 00	 mov	 eax, 8
  000c4	48 6b c0 00	 imul	 rax, rax, 0
  000c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000cf	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  000d7	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR fgbg$[rsp]
  000dc	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
$LN1@msgcolor:

; 1681 : }

  000df	48 83 c4 18	 add	 rsp, 24
  000e3	c3		 ret	 0
msgcolor ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
regs$ = 32
cpu$ = 80
panel_copy_regs PROC

; 1558 : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	56		 push	 rsi
  00005	57		 push	 rdi
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1559 :     REGS* regs; /* (pointer to REGS struct that we'll be returning) */
; 1560 : 
; 1561 :     /* Default to CPU #0 if invalid CPU number is passed */
; 1562 :     if (cpu < 0 || cpu >= sysblk.maxcpu)

  0000a	83 7c 24 50 00	 cmp	 DWORD PTR cpu$[rsp], 0
  0000f	7c 13		 jl	 SHORT $LN6@panel_copy
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00018	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0001e	39 44 24 50	 cmp	 DWORD PTR cpu$[rsp], eax
  00022	7c 08		 jl	 SHORT $LN5@panel_copy
$LN6@panel_copy:

; 1563 :         cpu = 0;

  00024	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR cpu$[rsp], 0
$LN5@panel_copy:

; 1564 : 
; 1565 :     /* Use the standardized REGS copy function to make the copy */
; 1566 :     obtain_lock( &sysblk.cpulock[ cpu ]);

  0002c	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00031	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00038	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  00040	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168954
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1567 :     {
; 1568 :         if (!sysblk.regs[ cpu ])

  00050	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00055	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005c	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00065	75 36		 jne	 SHORT $LN7@panel_copy

; 1569 :         {
; 1570 :             /* Specified CPU does not exist. Use dummyregs instead */
; 1571 :             release_lock( &sysblk.cpulock[ cpu ]);

  00067	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00073	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  0007b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168956
  00082	48 8b c8	 mov	 rcx, rax
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1572 :             return &sysblk.dummyregs;

  0008b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00092	48 05 00 15 00
	00		 add	 rax, 5376		; 00001500H
  00098	e9 22 01 00 00	 jmp	 $LN1@panel_copy
$LN7@panel_copy:

; 1573 :         }
; 1574 : 
; 1575 :         /* Make a working copy of this CPU's REGS structs */
; 1576 :         regs = copy_regs( sysblk.regs[ cpu ] );

  0009d	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a9	48 8b 8c c1 98
	0b 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+2968]
  000b1	e8 00 00 00 00	 call	 copy_regs
  000b6	48 89 44 24 20	 mov	 QWORD PTR regs$[rsp], rax

; 1577 :     }
; 1578 :     release_lock( &sysblk.cpulock[ cpu ]);

  000bb	48 63 44 24 50	 movsxd	 rax, DWORD PTR cpu$[rsp]
  000c0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000c7	48 8d 84 c1 48
	01 00 00	 lea	 rax, QWORD PTR [rcx+rax*8+328]
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168957
  000d6	48 8b c8	 mov	 rcx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1579 : 
; 1580 :     /* Copy the working copy to our static work variables */
; 1581 :     memcpy( &copyregs, regs, sysblk.regs_copy_len );

  000df	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e6	48 63 80 90 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5264]
  000ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:copyregs
  000f4	48 8b f9	 mov	 rdi, rcx
  000f7	48 8b 74 24 20	 mov	 rsi, QWORD PTR regs$[rsp]
  000fc	48 8b c8	 mov	 rcx, rax
  000ff	f3 a4		 rep movsb

; 1582 : 
; 1583 :     /* Free the original working copy */
; 1584 :     free_aligned( regs );

  00101	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__aligned_free

; 1585 : 
; 1586 :     /* Point to our static copy */
; 1587 :     regs = &copyregs;

  0010c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:copyregs
  00113	48 89 44 24 20	 mov	 QWORD PTR regs$[rsp], rax

; 1588 : 
; 1589 :     /* Make a separate copy of the guest REGS, if they exist */
; 1590 :     if (GUESTREGS)

  00118	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  0011d	48 83 b8 70 08
	00 00 00	 cmp	 QWORD PTR [rax+2160], 0
  00125	74 29		 je	 SHORT $LN8@panel_copy

; 1591 :         memcpy( &copysieregs, GUESTREGS, sysblk.regs_copy_len );

  00127	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012e	48 63 80 90 14
	00 00		 movsxd	 rax, DWORD PTR [rax+5264]
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:copysieregs
  0013c	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00141	48 8b f9	 mov	 rdi, rcx
  00144	48 8b b2 70 08
	00 00		 mov	 rsi, QWORD PTR [rdx+2160]
  0014b	48 8b c8	 mov	 rcx, rax
  0014e	f3 a4		 rep movsb
$LN8@panel_copy:

; 1592 : 
; 1593 :     /* Switch to using the guest REGS instead, if SIE is active */
; 1594 : #if defined( _FEATURE_SIE )
; 1595 :     if (regs->sie_active)

  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00155	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  0015b	83 e0 01	 and	 eax, 1
  0015e	85 c0		 test	 eax, eax
  00160	74 0c		 je	 SHORT $LN9@panel_copy

; 1596 :         regs = &copysieregs;

  00162	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:copysieregs
  00169	48 89 44 24 20	 mov	 QWORD PTR regs$[rsp], rax
$LN9@panel_copy:
$LN4@panel_copy:

; 1597 : #endif
; 1598 : 
; 1599 :     /* Ensure PSW accurately reflects the current instruction */
; 1600 :     MAYBE_SET_PSW_IA_FROM_IP( regs );

  0016e	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00173	48 83 b8 08 02
	00 00 00	 cmp	 QWORD PTR [rax+520], 0
  0017b	74 37		 je	 SHORT $LN10@panel_copy
  0017d	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
  00182	8b 80 10 02 00
	00		 mov	 eax, DWORD PTR [rax+528]
  00188	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  0018d	48 8b 54 24 20	 mov	 rdx, QWORD PTR regs$[rsp]
  00192	48 8b 92 00 02
	00 00		 mov	 rdx, QWORD PTR [rdx+512]
  00199	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0019d	48 2b ca	 sub	 rcx, rdx
  001a0	48 03 c1	 add	 rax, rcx
  001a3	48 25 ff ff ff
	00		 and	 rax, 16777215		; 00ffffffH
  001a9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR regs$[rsp]
  001ae	89 81 88 00 00
	00		 mov	 DWORD PTR [rcx+136], eax
$LN10@panel_copy:
  001b4	33 c0		 xor	 eax, eax
  001b6	85 c0		 test	 eax, eax
  001b8	75 b4		 jne	 SHORT $LN4@panel_copy

; 1601 : 
; 1602 :     /* Return pointer to static copy of active CPU's REGS struct */
; 1603 :     return regs;

  001ba	48 8b 44 24 20	 mov	 rax, QWORD PTR regs$[rsp]
$LN1@panel_copy:

; 1604 : }

  001bf	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001c3	5f		 pop	 rdi
  001c4	5e		 pop	 rsi
  001c5	c3		 ret	 0
panel_copy_regs ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
i$ = 32
p$ = 40
unused$ = 64
panel_cleanup PROC

; 3320 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@panel_clea:

; 3321 : int i;
; 3322 : PANMSG* p;
; 3323 : 
; 3324 :     UNREFERENCED(unused);

  00009	33 c0		 xor	 eax, eax
  0000b	85 c0		 test	 eax, eax
  0000d	75 fa		 jne	 SHORT $LN4@panel_clea

; 3325 : 
; 3326 :     log_wakeup(NULL);

  0000f	33 c9		 xor	 ecx, ecx
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_log_wakeup

; 3327 : 
; 3328 :     if(topmsg)

  00017	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR topmsg, 0
  0001f	0f 84 be 00 00
	00		 je	 $LN8@panel_clea

; 3329 :     {
; 3330 :         set_screen_color( stderr, COLOR_DEFAULT_FG, COLOR_DEFAULT_BG );

  00025	b9 02 00 00 00	 mov	 ecx, 2
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00030	66 41 b8 11 00	 mov	 r8w, 17
  00035	66 ba 10 00	 mov	 dx, 16
  00039	48 8b c8	 mov	 rcx, rax
  0003c	e8 00 00 00 00	 call	 set_screen_color

; 3331 :         clear_screen( stderr );

  00041	b9 02 00 00 00	 mov	 ecx, 2
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	e8 00 00 00 00	 call	 clear_screen

; 3332 : 
; 3333 :         /* Scroll to last full screen's worth of messages */
; 3334 :         scroll_to_bottom_screen();

  00054	e8 00 00 00 00	 call	 scroll_to_bottom_screen

; 3335 : 
; 3336 :         /* Display messages in scrolling area */
; 3337 :         for (i=0, p = topmsg; i < SCROLL_LINES && p != curmsg->next; i++, p = p->next)

  00059	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00061	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  00068	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  0006d	eb 17		 jmp	 SHORT $LN7@panel_clea
$LN5@panel_clea:
  0006f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00073	ff c0		 inc	 eax
  00075	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00079	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  0007e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00081	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
$LN7@panel_clea:
  00086	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  0008c	83 e8 02	 sub	 eax, 2
  0008f	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR numkept
  00095	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00099	7d 48		 jge	 SHORT $LN6@panel_clea
  0009b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  000a2	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000a5	48 39 44 24 28	 cmp	 QWORD PTR p$[rsp], rax
  000aa	74 37		 je	 SHORT $LN6@panel_clea

; 3338 :         {
; 3339 :             set_pos (i+1, 1);

  000ac	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  000b0	ff c0		 inc	 eax
  000b2	66 ba 01 00	 mov	 dx, 1
  000b6	0f b7 c8	 movzx	 ecx, ax
  000b9	e8 00 00 00 00	 call	 set_pos

; 3340 :             set_color (COLOR_DEFAULT_FG, COLOR_DEFAULT_BG);

  000be	66 ba 11 00	 mov	 dx, 17
  000c2	66 b9 10 00	 mov	 cx, 16
  000c6	e8 00 00 00 00	 call	 set_color

; 3341 :             write_text (p->msg, MSG_SIZE);

  000cb	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  000d0	48 83 c0 14	 add	 rax, 20
  000d4	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	e8 00 00 00 00	 call	 write_text

; 3342 :         }

  000e1	eb 8c		 jmp	 SHORT $LN5@panel_clea
$LN6@panel_clea:
$LN8@panel_clea:

; 3343 :     }
; 3344 :     sysblk.panel_init = 0;      /* Panel is no longer running */

  000e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ea	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000f0	83 e0 f7	 and	 eax, -9			; fffffff7H
  000f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000fa	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 3345 : 
; 3346 :     /* Restore the terminal mode */
; 3347 :     set_or_reset_console_mode( keybfd, 0 );

  00100	33 d2		 xor	 edx, edx
  00102	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR keybfd
  00108	e8 00 00 00 00	 call	 set_or_reset_console_mode

; 3348 : 
; 3349 :     /* Position to next line */
; 3350 :     fwrite("\n",1,1,stderr);

  0010d	b9 02 00 00 00	 mov	 ecx, 2
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00118	4c 8b c8	 mov	 r9, rax
  0011b	41 b8 01 00 00
	00		 mov	 r8d, 1
  00121	ba 01 00 00 00	 mov	 edx, 1
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169815
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite

; 3351 : 
; 3352 :     set_screen_color(stderr, COLOR_DEFAULT_FG, COLOR_DEFAULT_BG);

  00133	b9 02 00 00 00	 mov	 ecx, 2
  00138	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0013e	66 41 b8 11 00	 mov	 r8w, 17
  00143	66 ba 10 00	 mov	 dx, 16
  00147	48 8b c8	 mov	 rcx, rax
  0014a	e8 00 00 00 00	 call	 set_screen_color

; 3353 : 
; 3354 :     fflush(stderr);

  0014f	b9 02 00 00 00	 mov	 ecx, 2
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015a	48 8b c8	 mov	 rcx, rax
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 3355 : }

  00163	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00167	c3		 ret	 0
panel_cleanup ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
i$ = 96
n$ = 100
dev$ = 104
mode$ = 112
zhost$ = 116
addr$ = 120
tv601 = 124
p$1 = 128
aaddr$ = 132
cpupct_total$ = 136
online$ = 140
busy$ = 144
open$ = 148
tv166 = 152
tv175 = 156
tv190 = 160
tv313 = 164
tv264 = 168
tv270 = 172
tv276 = 176
tv282 = 180
tv288 = 184
tv294 = 188
tv300 = 192
tv305 = 196
tv315 = 200
tv329 = 204
tv340 = 208
tv352 = 212
tv450 = 216
tv525 = 220
tv745 = 224
tv801 = 228
tv809 = 232
tv817 = 236
tv825 = 240
tv1034 = 244
tv1077 = 248
tv1098 = 252
tv1100 = 256
tv1103 = 260
tv1115 = 264
tv1120 = 268
tv1143 = 272
tv1183 = 276
tv1255 = 280
tv153 = 284
tv497 = 288
tv538 = 292
tv573 = 296
tv614 = 300
tv649 = 304
tv684 = 308
tv715 = 312
tv765 = 316
tv856 = 320
tv901 = 324
tv914 = 328
tv924 = 332
l$2 = 336
tv463 = 340
$T3 = 344
tv1429 = 352
tv752 = 360
devclass$ = 368
curr_psw$ = 376
devnam$ = 400
buf$ = 672
__$ArrayPad$ = 1696
regs$ = 1744
NP_update PROC

; 938  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec b8 06
	00 00		 sub	 rsp, 1720		; 000006b8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 a0
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 939  :     int     i, n;
; 940  :     int     mode, zhost;
; 941  :     int     cpupct_total;
; 942  :     QWORD   curr_psw;
; 943  :     U32     addr, aaddr;
; 944  :     DEVBLK *dev;
; 945  :     int     online, busy, open;
; 946  :     char   *devclass;
; 947  :     char    devnam[MAX_PATH];
; 948  :     char    buf[1024];
; 949  : 
; 950  :     if (NPhelpup == 1)

  00020	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPhelpup, 1
  00027	0f 85 b7 00 00
	00		 jne	 $LN53@NP_update

; 951  :     {
; 952  :         if (NPhelpdown == 1)

  0002d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPhelpdown, 1
  00034	75 32		 jne	 SHORT $LN54@NP_update

; 953  :         {
; 954  :              NP_init();

  00036	e8 00 00 00 00	 call	 NP_init

; 955  :              NP_screen_redraw(regs);

  0003b	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00043	e8 00 00 00 00	 call	 NP_screen_redraw

; 956  :              NPhelpup = 0;

  00048	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPhelpup, 0

; 957  :              NPhelpdown = 0;

  00052	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPhelpdown, 0

; 958  :              NPhelppaint = 1;

  0005c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPhelppaint, 1

; 959  :         }

  00066	eb 7c		 jmp	 SHORT $LN55@NP_update
$LN54@NP_update:

; 960  :         else
; 961  :         {
; 962  :             if (NPhelppaint)

  00068	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPhelppaint, 0
  0006f	74 6e		 je	 SHORT $LN56@NP_update

; 963  :             {
; 964  :                 set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  00071	33 d2		 xor	 edx, edx
  00073	66 b9 08 00	 mov	 cx, 8
  00077	e8 00 00 00 00	 call	 set_color

; 965  :                 clr_screen ();

  0007c	e8 00 00 00 00	 call	 clr_screen

; 966  :                 for (i = 0; *NPhelp[i]; i++)

  00081	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00089	eb 0a		 jmp	 SHORT $LN4@NP_update
$LN2@NP_update:
  0008b	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0008f	ff c0		 inc	 eax
  00091	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN4@NP_update:
  00095	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPhelp
  000a1	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  000a5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a8	85 c0		 test	 eax, eax
  000aa	74 29		 je	 SHORT $LN3@NP_update

; 967  :                 {
; 968  :                     set_pos (i+1, 1);

  000ac	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  000b0	ff c0		 inc	 eax
  000b2	66 ba 01 00	 mov	 dx, 1
  000b6	0f b7 c8	 movzx	 ecx, ax
  000b9	e8 00 00 00 00	 call	 set_pos

; 969  :                     draw_text (NPhelp[i]);

  000be	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  000c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPhelp
  000ca	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000ce	e8 00 00 00 00	 call	 draw_text

; 970  :                 }

  000d3	eb b6		 jmp	 SHORT $LN2@NP_update
$LN3@NP_update:

; 971  :                 NPhelppaint = 0;

  000d5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPhelppaint, 0
$LN56@NP_update:

; 972  :             }
; 973  :             return;

  000df	e9 61 23 00 00	 jmp	 $LN1@NP_update
$LN55@NP_update:
$LN53@NP_update:

; 974  :         }
; 975  :     }
; 976  : 
; 977  : #if defined(_FEATURE_SIE)
; 978  :     if(SIE_MODE(regs))

  000e4	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000ec	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000f2	d1 e8		 shr	 eax, 1
  000f4	83 e0 01	 and	 eax, 1
  000f7	85 c0		 test	 eax, eax
  000f9	74 17		 je	 SHORT $LN57@NP_update

; 979  :         regs = HOSTREGS;

  000fb	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00103	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0010a	48 89 84 24 d0
	06 00 00	 mov	 QWORD PTR regs$[rsp], rax
$LN57@NP_update:

; 980  : #endif /*defined(_FEATURE_SIE)*/
; 981  : 
; 982  :     /* percent CPU busy */
; 983  :     if (sysblk.hicpu)

  00112	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00119	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00120	0f 84 19 01 00
	00		 je	 $LN58@NP_update

; 984  :     {
; 985  :         cpupct_total = 0;

  00126	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cpupct_total$[rsp], 0

; 986  :         n = 0;

  00131	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0

; 987  :         for ( i = 0; i < sysblk.maxcpu; i++ )

  00139	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00141	eb 0a		 jmp	 SHORT $LN7@NP_update
$LN5@NP_update:
  00143	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00147	ff c0		 inc	 eax
  00149	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN7@NP_update:
  0014d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00154	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  0015a	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  0015e	7d 6f		 jge	 SHORT $LN6@NP_update

; 988  :             if ( IS_CPU_ONLINE(i) )

  00160	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00165	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0016c	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  00175	74 53		 je	 SHORT $LN59@NP_update

; 989  :                 if ( sysblk.regs[i]->cpustate == CPUSTATE_STARTED )

  00177	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0017c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00183	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0018b	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  0018f	83 f8 01	 cmp	 eax, 1
  00192	75 36		 jne	 SHORT $LN60@NP_update

; 990  :                 {
; 991  :                     n++;

  00194	8b 44 24 64	 mov	 eax, DWORD PTR n$[rsp]
  00198	ff c0		 inc	 eax
  0019a	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 992  :                     cpupct_total += sysblk.regs[i]->cpupct;

  0019e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  001a3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001aa	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  001b2	8b 80 b0 07 00
	00		 mov	 eax, DWORD PTR [rax+1968]
  001b8	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR cpupct_total$[rsp]
  001bf	03 c8		 add	 ecx, eax
  001c1	8b c1		 mov	 eax, ecx
  001c3	89 84 24 88 00
	00 00		 mov	 DWORD PTR cpupct_total$[rsp], eax
$LN60@NP_update:
$LN59@NP_update:

; 993  :                 }

  001ca	e9 74 ff ff ff	 jmp	 $LN5@NP_update
$LN6@NP_update:

; 994  :         set_color (COLOR_WHITE, COLOR_BLUE);

  001cf	66 ba 03 00	 mov	 dx, 3
  001d3	66 b9 0f 00	 mov	 cx, 15
  001d7	e8 00 00 00 00	 call	 set_color

; 995  :         set_pos (1, 22);

  001dc	66 ba 16 00	 mov	 dx, 22
  001e0	66 b9 01 00	 mov	 cx, 1
  001e4	e8 00 00 00 00	 call	 set_pos

; 996  :         MSGBUF(buf, "%3d", (n > 0 ? cpupct_total/n : 0));

  001e9	83 7c 24 64 00	 cmp	 DWORD PTR n$[rsp], 0
  001ee	7e 15		 jle	 SHORT $LN170@NP_update
  001f0	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR cpupct_total$[rsp]
  001f7	99		 cdq
  001f8	f7 7c 24 64	 idiv	 DWORD PTR n$[rsp]
  001fc	89 84 24 1c 01
	00 00		 mov	 DWORD PTR tv153[rsp], eax
  00203	eb 0b		 jmp	 SHORT $LN171@NP_update
$LN170@NP_update:
  00205	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv153[rsp], 0
$LN171@NP_update:
  00210	44 8b 8c 24 1c
	01 00 00	 mov	 r9d, DWORD PTR tv153[rsp]
  00218	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168799
  0021f	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00224	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 997  :         draw_text (buf);

  00232	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0023a	e8 00 00 00 00	 call	 draw_text
$LN58@NP_update:

; 998  :     }
; 999  : 
; 1000 :     if (sysblk.hicpu)

  0023f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00246	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0024d	0f 84 88 12 00
	00		 je	 $LN61@NP_update

; 1001 :     {
; 1002 : #if defined(_FEATURE_SIE)
; 1003 :         if(regs->sie_active)

  00253	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0025b	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00261	83 e0 01	 and	 eax, 1
  00264	85 c0		 test	 eax, eax
  00266	74 17		 je	 SHORT $LN62@NP_update

; 1004 :             regs = GUESTREGS;

  00268	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00270	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  00277	48 89 84 24 d0
	06 00 00	 mov	 QWORD PTR regs$[rsp], rax
$LN62@NP_update:

; 1005 : #endif /*defined(_FEATURE_SIE)*/
; 1006 : 
; 1007 :         mode = (regs->arch_mode == ARCH_900_IDX);

  0027f	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00287	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0028b	75 0d		 jne	 SHORT $LN172@NP_update
  0028d	c7 84 24 98 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv166[rsp], 1
  00298	eb 0b		 jmp	 SHORT $LN173@NP_update
$LN172@NP_update:
  0029a	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv166[rsp], 0
$LN173@NP_update:
  002a5	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv166[rsp]
  002ac	89 44 24 70	 mov	 DWORD PTR mode$[rsp], eax

; 1008 :         zhost =

  002b0	83 7c 24 70 00	 cmp	 DWORD PTR mode$[rsp], 0
  002b5	75 39		 jne	 SHORT $LN174@NP_update
  002b7	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002bf	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002c5	d1 e8		 shr	 eax, 1
  002c7	83 e0 01	 and	 eax, 1
  002ca	85 c0		 test	 eax, eax
  002cc	74 22		 je	 SHORT $LN174@NP_update
  002ce	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002d6	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  002dd	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  002e1	75 0d		 jne	 SHORT $LN174@NP_update
  002e3	c7 84 24 9c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv175[rsp], 1
  002ee	eb 0b		 jmp	 SHORT $LN175@NP_update
$LN174@NP_update:
  002f0	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv175[rsp], 0
$LN175@NP_update:
  002fb	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR tv175[rsp]
  00302	89 44 24 74	 mov	 DWORD PTR zhost$[rsp], eax

; 1009 : #if defined(_FEATURE_SIE)
; 1010 :                 !mode && SIE_MODE(regs) && HOSTREGS->arch_mode == ARCH_900_IDX;
; 1011 : #else // !defined(_FEATURE_SIE)
; 1012 :                 0;
; 1013 : #endif // defined(_FEATURE_SIE)
; 1014 : 
; 1015 :         /* Redraw the psw template if the mode changed */
; 1016 :         if (NPpswmode != mode || NPpswzhost != zhost)

  00306	8b 44 24 70	 mov	 eax, DWORD PTR mode$[rsp]
  0030a	39 05 00 00 00
	00		 cmp	 DWORD PTR NPpswmode, eax
  00310	75 10		 jne	 SHORT $LN64@NP_update
  00312	8b 44 24 74	 mov	 eax, DWORD PTR zhost$[rsp]
  00316	39 05 00 00 00
	00		 cmp	 DWORD PTR NPpswzhost, eax
  0031c	0f 84 ac 00 00
	00		 je	 $LN63@NP_update
$LN64@NP_update:

; 1017 :         {
; 1018 :             NPpswmode = mode;

  00322	8b 44 24 70	 mov	 eax, DWORD PTR mode$[rsp]
  00326	89 05 00 00 00
	00		 mov	 DWORD PTR NPpswmode, eax

; 1019 :             NPpswzhost = zhost;

  0032c	8b 44 24 74	 mov	 eax, DWORD PTR zhost$[rsp]
  00330	89 05 00 00 00
	00		 mov	 DWORD PTR NPpswzhost, eax

; 1020 :             NPpsw_valid = NPpswstate_valid = 0;

  00336	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPpswstate_valid, 0
  00340	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPpswstate_valid
  00346	89 05 00 00 00
	00		 mov	 DWORD PTR NPpsw_valid, eax

; 1021 :             set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  0034c	33 d2		 xor	 edx, edx
  0034e	66 b9 08 00	 mov	 cx, 8
  00352	e8 00 00 00 00	 call	 set_color

; 1022 :             set_pos (PSW_LINE, 1);

  00357	66 ba 01 00	 mov	 dx, 1
  0035b	66 b9 02 00	 mov	 cx, 2
  0035f	e8 00 00 00 00	 call	 set_pos

; 1023 :             fill_text (' ',38);

  00364	66 ba 26 00	 mov	 dx, 38			; 00000026H
  00368	b1 20		 mov	 cl, 32			; 00000020H
  0036a	e8 00 00 00 00	 call	 fill_text

; 1024 :             set_pos (PSW_LINE+1, 1);

  0036f	66 ba 01 00	 mov	 dx, 1
  00373	66 b9 03 00	 mov	 cx, 3
  00377	e8 00 00 00 00	 call	 set_pos

; 1025 :             fill_text (' ', 38);

  0037c	66 ba 26 00	 mov	 dx, 38			; 00000026H
  00380	b1 20		 mov	 cl, 32			; 00000020H
  00382	e8 00 00 00 00	 call	 fill_text

; 1026 :             set_pos (PSW_LINE+1, NPpswmode || NPpswzhost ? 19 : 10);

  00387	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPpswmode, 0
  0038e	75 16		 jne	 SHORT $LN176@NP_update
  00390	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPpswzhost, 0
  00397	75 0d		 jne	 SHORT $LN176@NP_update
  00399	c7 84 24 a0 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR tv190[rsp], 10
  003a4	eb 0b		 jmp	 SHORT $LN177@NP_update
$LN176@NP_update:
  003a6	c7 84 24 a0 00
	00 00 13 00 00
	00		 mov	 DWORD PTR tv190[rsp], 19
$LN177@NP_update:
  003b1	0f b7 94 24 a0
	00 00 00	 movzx	 edx, WORD PTR tv190[rsp]
  003b9	66 b9 03 00	 mov	 cx, 3
  003bd	e8 00 00 00 00	 call	 set_pos

; 1027 :             draw_text ("PSW");

  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168804
  003c9	e8 00 00 00 00	 call	 draw_text
$LN63@NP_update:

; 1028 :         }
; 1029 : 
; 1030 :         /* Display the psw */
; 1031 :         memset( curr_psw, 0, sizeof( curr_psw ));

  003ce	48 8d 84 24 78
	01 00 00	 lea	 rax, QWORD PTR curr_psw$[rsp]
  003d6	48 8b f8	 mov	 rdi, rax
  003d9	33 c0		 xor	 eax, eax
  003db	b9 10 00 00 00	 mov	 ecx, 16
  003e0	f3 aa		 rep stosb

; 1032 :         copy_psw( regs, curr_psw );

  003e2	48 8d 94 24 78
	01 00 00	 lea	 rdx, QWORD PTR curr_psw$[rsp]
  003ea	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  003f2	e8 00 00 00 00	 call	 copy_psw

; 1033 :         if (!NPpsw_valid || memcmp( NPpsw, curr_psw, sizeof( NPpsw )))

  003f7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPpsw_valid, 0
  003fe	74 22		 je	 SHORT $LN66@NP_update
  00400	41 b8 10 00 00
	00		 mov	 r8d, 16
  00406	48 8d 94 24 78
	01 00 00	 lea	 rdx, QWORD PTR curr_psw$[rsp]
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPpsw
  00415	e8 00 00 00 00	 call	 memcmp
  0041a	85 c0		 test	 eax, eax
  0041c	0f 84 35 01 00
	00		 je	 $LN65@NP_update
$LN66@NP_update:

; 1034 :         {
; 1035 :             set_color (COLOR_LIGHT_YELLOW, COLOR_BLACK);

  00422	33 d2		 xor	 edx, edx
  00424	66 b9 0e 00	 mov	 cx, 14
  00428	e8 00 00 00 00	 call	 set_color

; 1036 :             set_pos (PSW_LINE, 3);

  0042d	66 ba 03 00	 mov	 dx, 3
  00431	66 b9 02 00	 mov	 cx, 2
  00435	e8 00 00 00 00	 call	 set_pos

; 1037 :             if (mode)

  0043a	83 7c 24 70 00	 cmp	 DWORD PTR mode$[rsp], 0
  0043f	74 4f		 je	 SHORT $LN67@NP_update

; 1038 :             {
; 1039 :                 draw_dw( fetch_dw( curr_psw ));

  00441	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR curr_psw$[rsp]
  00449	e8 00 00 00 00	 call	 fetch_dw_noswap
  0044e	48 8b c8	 mov	 rcx, rax
  00451	e8 00 00 00 00	 call	 _byteswap_uint64
  00456	48 8b c8	 mov	 rcx, rax
  00459	e8 00 00 00 00	 call	 draw_dw

; 1040 :                 set_pos( PSW_LINE, 22 );

  0045e	66 ba 16 00	 mov	 dx, 22
  00462	66 b9 02 00	 mov	 cx, 2
  00466	e8 00 00 00 00	 call	 set_pos

; 1041 :                 draw_dw( fetch_dw( curr_psw + 8 ));

  0046b	48 8d 84 24 80
	01 00 00	 lea	 rax, QWORD PTR curr_psw$[rsp+8]
  00473	48 8b c8	 mov	 rcx, rax
  00476	e8 00 00 00 00	 call	 fetch_dw_noswap
  0047b	48 8b c8	 mov	 rcx, rax
  0047e	e8 00 00 00 00	 call	 _byteswap_uint64
  00483	48 8b c8	 mov	 rcx, rax
  00486	e8 00 00 00 00	 call	 draw_dw

; 1042 :             }

  0048b	e9 a1 00 00 00	 jmp	 $LN68@NP_update
$LN67@NP_update:

; 1043 :             else if (zhost)

  00490	83 7c 24 74 00	 cmp	 DWORD PTR zhost$[rsp], 0
  00495	74 54		 je	 SHORT $LN69@NP_update

; 1044 :             {
; 1045 :                 draw_fw( fetch_fw( curr_psw ));

  00497	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR curr_psw$[rsp]
  0049f	e8 00 00 00 00	 call	 fetch_fw_noswap
  004a4	8b c8		 mov	 ecx, eax
  004a6	e8 00 00 00 00	 call	 _byteswap_ulong
  004ab	8b c8		 mov	 ecx, eax
  004ad	e8 00 00 00 00	 call	 draw_fw

; 1046 :                 draw_fw( fetch_fw( curr_psw + 4 )); /* *JJ */

  004b2	48 8d 84 24 7c
	01 00 00	 lea	 rax, QWORD PTR curr_psw$[rsp+4]
  004ba	48 8b c8	 mov	 rcx, rax
  004bd	e8 00 00 00 00	 call	 fetch_fw_noswap
  004c2	8b c8		 mov	 ecx, eax
  004c4	e8 00 00 00 00	 call	 _byteswap_ulong
  004c9	8b c8		 mov	 ecx, eax
  004cb	e8 00 00 00 00	 call	 draw_fw

; 1047 :                 set_pos( PSW_LINE, 22 );

  004d0	66 ba 16 00	 mov	 dx, 22
  004d4	66 b9 02 00	 mov	 cx, 2
  004d8	e8 00 00 00 00	 call	 set_pos

; 1048 :                 draw_text( "----------------" ); /* *JJ */

  004dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168811
  004e4	e8 00 00 00 00	 call	 draw_text

; 1049 :             }

  004e9	eb 46		 jmp	 SHORT $LN70@NP_update
$LN69@NP_update:

; 1050 :             else
; 1051 :             {
; 1052 :                 draw_fw( fetch_fw( curr_psw ));

  004eb	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR curr_psw$[rsp]
  004f3	e8 00 00 00 00	 call	 fetch_fw_noswap
  004f8	8b c8		 mov	 ecx, eax
  004fa	e8 00 00 00 00	 call	 _byteswap_ulong
  004ff	8b c8		 mov	 ecx, eax
  00501	e8 00 00 00 00	 call	 draw_fw

; 1053 :                 set_pos( PSW_LINE, 12 );

  00506	66 ba 0c 00	 mov	 dx, 12
  0050a	66 b9 02 00	 mov	 cx, 2
  0050e	e8 00 00 00 00	 call	 set_pos

; 1054 :                 draw_fw( fetch_fw( curr_psw + 4 ));

  00513	48 8d 84 24 7c
	01 00 00	 lea	 rax, QWORD PTR curr_psw$[rsp+4]
  0051b	48 8b c8	 mov	 rcx, rax
  0051e	e8 00 00 00 00	 call	 fetch_fw_noswap
  00523	8b c8		 mov	 ecx, eax
  00525	e8 00 00 00 00	 call	 _byteswap_ulong
  0052a	8b c8		 mov	 ecx, eax
  0052c	e8 00 00 00 00	 call	 draw_fw
$LN70@NP_update:
$LN68@NP_update:

; 1055 :             }
; 1056 :             NPpsw_valid = 1;

  00531	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPpsw_valid, 1

; 1057 :             memcpy( NPpsw, curr_psw, sizeof( NPpsw ));

  0053b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPpsw
  00542	48 8d 8c 24 78
	01 00 00	 lea	 rcx, QWORD PTR curr_psw$[rsp]
  0054a	48 8b f8	 mov	 rdi, rax
  0054d	48 8b f1	 mov	 rsi, rcx
  00550	b9 10 00 00 00	 mov	 ecx, 16
  00555	f3 a4		 rep movsb
$LN65@NP_update:

; 1058 :         }
; 1059 : 
; 1060 :         /* Display psw state */
; 1061 :         MSGBUF (buf, "%2d%c%c%c%c%c%c%c%c",

  00557	83 7c 24 70 00	 cmp	 DWORD PTR mode$[rsp], 0
  0055c	74 0d		 je	 SHORT $LN178@NP_update
  0055e	c7 84 24 a8 00
	00 00 5a 00 00
	00		 mov	 DWORD PTR tv264[rsp], 90 ; 0000005aH
  00569	eb 0b		 jmp	 SHORT $LN179@NP_update
$LN178@NP_update:
  0056b	c7 84 24 a8 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv264[rsp], 46 ; 0000002eH
$LN179@NP_update:
  00576	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0057e	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00584	d1 e8		 shr	 eax, 1
  00586	83 e0 01	 and	 eax, 1
  00589	85 c0		 test	 eax, eax
  0058b	74 0d		 je	 SHORT $LN180@NP_update
  0058d	c7 84 24 ac 00
	00 00 53 00 00
	00		 mov	 DWORD PTR tv270[rsp], 83 ; 00000053H
  00598	eb 0b		 jmp	 SHORT $LN181@NP_update
$LN180@NP_update:
  0059a	c7 84 24 ac 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv270[rsp], 46 ; 0000002eH
$LN181@NP_update:
  005a5	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005ad	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  005b1	83 e0 01	 and	 eax, 1
  005b4	85 c0		 test	 eax, eax
  005b6	74 0d		 je	 SHORT $LN182@NP_update
  005b8	c7 84 24 b0 00
	00 00 50 00 00
	00		 mov	 DWORD PTR tv276[rsp], 80 ; 00000050H
  005c3	eb 0b		 jmp	 SHORT $LN183@NP_update
$LN182@NP_update:
  005c5	c7 84 24 b0 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv276[rsp], 46 ; 0000002eH
$LN183@NP_update:
  005d0	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  005d8	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  005de	c1 e8 05	 shr	 eax, 5
  005e1	83 e0 01	 and	 eax, 1
  005e4	85 c0		 test	 eax, eax
  005e6	74 0d		 je	 SHORT $LN184@NP_update
  005e8	c7 84 24 b4 00
	00 00 43 00 00
	00		 mov	 DWORD PTR tv282[rsp], 67 ; 00000043H
  005f3	eb 0b		 jmp	 SHORT $LN185@NP_update
$LN184@NP_update:
  005f5	c7 84 24 b4 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv282[rsp], 46 ; 0000002eH
$LN185@NP_update:
  00600	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00608	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  0060e	c1 e8 0c	 shr	 eax, 12
  00611	83 e0 01	 and	 eax, 1
  00614	85 c0		 test	 eax, eax
  00616	74 0d		 je	 SHORT $LN186@NP_update
  00618	c7 84 24 b8 00
	00 00 4c 00 00
	00		 mov	 DWORD PTR tv288[rsp], 76 ; 0000004cH
  00623	eb 0b		 jmp	 SHORT $LN187@NP_update
$LN186@NP_update:
  00625	c7 84 24 b8 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv288[rsp], 46 ; 0000002eH
$LN187@NP_update:
  00630	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00638	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0063c	83 e0 02	 and	 eax, 2
  0063f	85 c0		 test	 eax, eax
  00641	74 0d		 je	 SHORT $LN188@NP_update
  00643	c7 84 24 bc 00
	00 00 57 00 00
	00		 mov	 DWORD PTR tv294[rsp], 87 ; 00000057H
  0064e	eb 0b		 jmp	 SHORT $LN189@NP_update
$LN188@NP_update:
  00650	c7 84 24 bc 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv294[rsp], 46 ; 0000002eH
$LN189@NP_update:
  0065b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00662	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00668	c1 e8 0a	 shr	 eax, 10
  0066b	83 e0 01	 and	 eax, 1
  0066e	85 c0		 test	 eax, eax
  00670	74 0d		 je	 SHORT $LN190@NP_update
  00672	c7 84 24 c0 00
	00 00 54 00 00
	00		 mov	 DWORD PTR tv300[rsp], 84 ; 00000054H
  0067d	eb 0b		 jmp	 SHORT $LN191@NP_update
$LN190@NP_update:
  0067f	c7 84 24 c0 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv300[rsp], 46 ; 0000002eH
$LN191@NP_update:
  0068a	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00692	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  00696	83 f8 03	 cmp	 eax, 3
  00699	75 0d		 jne	 SHORT $LN192@NP_update
  0069b	c7 84 24 c4 00
	00 00 4d 00 00
	00		 mov	 DWORD PTR tv305[rsp], 77 ; 0000004dH
  006a6	eb 0b		 jmp	 SHORT $LN193@NP_update
$LN192@NP_update:
  006a8	c7 84 24 c4 00
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv305[rsp], 46 ; 0000002eH
$LN193@NP_update:
  006b3	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006bb	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006c1	83 e0 01	 and	 eax, 1
  006c4	85 c0		 test	 eax, eax
  006c6	74 0d		 je	 SHORT $LN196@NP_update
  006c8	c7 84 24 c8 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv315[rsp], 64 ; 00000040H
  006d3	eb 3d		 jmp	 SHORT $LN197@NP_update
$LN196@NP_update:
  006d5	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  006dd	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  006e3	d1 e8		 shr	 eax, 1
  006e5	83 e0 01	 and	 eax, 1
  006e8	85 c0		 test	 eax, eax
  006ea	74 0d		 je	 SHORT $LN194@NP_update
  006ec	c7 84 24 a4 00
	00 00 1f 00 00
	00		 mov	 DWORD PTR tv313[rsp], 31
  006f7	eb 0b		 jmp	 SHORT $LN195@NP_update
$LN194@NP_update:
  006f9	c7 84 24 a4 00
	00 00 18 00 00
	00		 mov	 DWORD PTR tv313[rsp], 24
$LN195@NP_update:
  00704	8b 84 24 a4 00
	00 00		 mov	 eax, DWORD PTR tv313[rsp]
  0070b	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv315[rsp], eax
$LN197@NP_update:
  00712	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR tv264[rsp]
  00719	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  0071d	8b 84 24 ac 00
	00 00		 mov	 eax, DWORD PTR tv270[rsp]
  00724	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  00728	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR tv276[rsp]
  0072f	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  00733	8b 84 24 b4 00
	00 00		 mov	 eax, DWORD PTR tv282[rsp]
  0073a	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  0073e	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv288[rsp]
  00745	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  00749	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv294[rsp]
  00750	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00754	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv300[rsp]
  0075b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0075f	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv305[rsp]
  00766	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0076a	44 8b 8c 24 c8
	00 00 00	 mov	 r9d, DWORD PTR tv315[rsp]
  00772	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168812
  00779	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0077e	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  00786	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1062 :                       regs->psw.amode64                  ? 64  :
; 1063 :                       regs->psw.amode                    ? 31  : 24,
; 1064 :                       regs->cpustate == CPUSTATE_STOPPED ? 'M' : '.',
; 1065 :                       sysblk.instbreak                   ? 'T' : '.',
; 1066 :                       WAITSTATE (&regs->psw)             ? 'W' : '.',
; 1067 :                       regs->loadstate                    ? 'L' : '.',
; 1068 :                       regs->checkstop                    ? 'C' : '.',
; 1069 :                       PROBSTATE(&regs->psw)              ? 'P' : '.',
; 1070 :                       SIE_MODE(regs)                     ? 'S' : '.',
; 1071 :                       mode                               ? 'Z' : '.');
; 1072 :         if (!NPpswstate_valid || strcmp(NPpswstate, buf))

  0078c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPpswstate_valid, 0
  00793	74 18		 je	 SHORT $LN72@NP_update
  00795	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0079d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPpswstate
  007a4	e8 00 00 00 00	 call	 strcmp
  007a9	85 c0		 test	 eax, eax
  007ab	74 74		 je	 SHORT $LN71@NP_update
$LN72@NP_update:

; 1073 :         {
; 1074 :             set_color( COLOR_LIGHT_YELLOW, COLOR_BLACK );

  007ad	33 d2		 xor	 edx, edx
  007af	66 b9 0e 00	 mov	 cx, 14
  007b3	e8 00 00 00 00	 call	 set_color

; 1075 :             set_pos( mode || zhost ? (PSW_LINE+1) : PSW_LINE, 28 );

  007b8	83 7c 24 70 00	 cmp	 DWORD PTR mode$[rsp], 0
  007bd	75 14		 jne	 SHORT $LN198@NP_update
  007bf	83 7c 24 74 00	 cmp	 DWORD PTR zhost$[rsp], 0
  007c4	75 0d		 jne	 SHORT $LN198@NP_update
  007c6	c7 84 24 cc 00
	00 00 02 00 00
	00		 mov	 DWORD PTR tv329[rsp], 2
  007d1	eb 0b		 jmp	 SHORT $LN199@NP_update
$LN198@NP_update:
  007d3	c7 84 24 cc 00
	00 00 03 00 00
	00		 mov	 DWORD PTR tv329[rsp], 3
$LN199@NP_update:
  007de	66 ba 1c 00	 mov	 dx, 28
  007e2	0f b7 8c 24 cc
	00 00 00	 movzx	 ecx, WORD PTR tv329[rsp]
  007ea	e8 00 00 00 00	 call	 set_pos

; 1076 :             draw_text( buf );

  007ef	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  007f7	e8 00 00 00 00	 call	 draw_text

; 1077 :             NPpswstate_valid = 1;

  007fc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPpswstate_valid, 1

; 1078 :             STRLCPY( NPpswstate, buf );

  00806	41 b8 10 00 00
	00		 mov	 r8d, 16
  0080c	48 8d 94 24 a0
	02 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  00814	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPpswstate
  0081b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN71@NP_update:

; 1079 :         }
; 1080 : 
; 1081 :         /* Redraw the register template if the regmode switched */
; 1082 :         mode = (regs->arch_mode == ARCH_900_IDX && (NPregdisp == 0 || NPregdisp == 1));

  00821	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00829	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0082d	75 1f		 jne	 SHORT $LN201@NP_update
  0082f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregdisp, 0
  00836	74 09		 je	 SHORT $LN200@NP_update
  00838	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPregdisp, 1
  0083f	75 0d		 jne	 SHORT $LN201@NP_update
$LN200@NP_update:
  00841	c7 84 24 d0 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv340[rsp], 1
  0084c	eb 0b		 jmp	 SHORT $LN202@NP_update
$LN201@NP_update:
  0084e	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv340[rsp], 0
$LN202@NP_update:
  00859	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR tv340[rsp]
  00860	89 44 24 70	 mov	 DWORD PTR mode$[rsp], eax

; 1083 :         zhost =

  00864	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0086c	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00870	74 4b		 je	 SHORT $LN203@NP_update
  00872	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0087a	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  00880	d1 e8		 shr	 eax, 1
  00882	83 e0 01	 and	 eax, 1
  00885	85 c0		 test	 eax, eax
  00887	74 34		 je	 SHORT $LN203@NP_update
  00889	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00891	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00898	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0089c	75 1f		 jne	 SHORT $LN203@NP_update
  0089e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregdisp, 0
  008a5	74 09		 je	 SHORT $LN204@NP_update
  008a7	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPregdisp, 1
  008ae	75 0d		 jne	 SHORT $LN203@NP_update
$LN204@NP_update:
  008b0	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv352[rsp], 1
  008bb	eb 0b		 jmp	 SHORT $LN205@NP_update
$LN203@NP_update:
  008bd	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv352[rsp], 0
$LN205@NP_update:
  008c8	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR tv352[rsp]
  008cf	89 44 24 74	 mov	 DWORD PTR zhost$[rsp], eax

; 1084 : #if defined(_FEATURE_SIE)
; 1085 :                 (regs->arch_mode != ARCH_900_IDX
; 1086 :               && SIE_MODE(regs) && HOSTREGS->arch_mode == ARCH_900_IDX
; 1087 :               && (NPregdisp == 0 || NPregdisp == 1));
; 1088 : #else // !defined(_FEATURE_SIE)
; 1089 :                      0;
; 1090 : #endif /*defined(_FEATURE_SIE)*/
; 1091 :         if (NPregmode != mode || NPregzhost != zhost)

  008d3	8b 44 24 70	 mov	 eax, DWORD PTR mode$[rsp]
  008d7	39 05 00 00 00
	00		 cmp	 DWORD PTR NPregmode, eax
  008dd	75 10		 jne	 SHORT $LN74@NP_update
  008df	8b 44 24 74	 mov	 eax, DWORD PTR zhost$[rsp]
  008e3	39 05 00 00 00
	00		 cmp	 DWORD PTR NPregzhost, eax
  008e9	0f 84 fc 01 00
	00		 je	 $LN73@NP_update
$LN74@NP_update:

; 1092 :         {
; 1093 :             NPregmode = mode;

  008ef	8b 44 24 70	 mov	 eax, DWORD PTR mode$[rsp]
  008f3	89 05 00 00 00
	00		 mov	 DWORD PTR NPregmode, eax

; 1094 :             NPregzhost = zhost;

  008f9	8b 44 24 74	 mov	 eax, DWORD PTR zhost$[rsp]
  008fd	89 05 00 00 00
	00		 mov	 DWORD PTR NPregzhost, eax

; 1095 :             NPregs_valid = 0;

  00903	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPregs_valid, 0

; 1096 :             set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  0090d	33 d2		 xor	 edx, edx
  0090f	66 b9 08 00	 mov	 cx, 8
  00913	e8 00 00 00 00	 call	 set_color

; 1097 :             if (NPregmode || NPregzhost)

  00918	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregmode, 0
  0091f	75 0d		 jne	 SHORT $LN77@NP_update
  00921	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregzhost, 0
  00928	0f 84 9b 00 00
	00		 je	 $LN75@NP_update
$LN77@NP_update:

; 1098 :             {
; 1099 :                 /* 64 bit registers */
; 1100 :                 for (i = 0; i < 8; i++)

  0092e	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00936	eb 0a		 jmp	 SHORT $LN10@NP_update
$LN8@NP_update:
  00938	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0093c	ff c0		 inc	 eax
  0093e	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN10@NP_update:
  00942	83 7c 24 60 08	 cmp	 DWORD PTR i$[rsp], 8
  00947	7d 7b		 jge	 SHORT $LN9@NP_update

; 1101 :                 {
; 1102 :                     set_pos (REGS_LINE+i, 1);

  00949	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0094d	83 c0 05	 add	 eax, 5
  00950	66 ba 01 00	 mov	 dx, 1
  00954	0f b7 c8	 movzx	 ecx, ax
  00957	e8 00 00 00 00	 call	 set_pos

; 1103 :                     fill_text (' ', 38);

  0095c	66 ba 26 00	 mov	 dx, 38			; 00000026H
  00960	b1 20		 mov	 cl, 32			; 00000020H
  00962	e8 00 00 00 00	 call	 fill_text

; 1104 :                     set_pos (REGS_LINE+i, 1);

  00967	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0096b	83 c0 05	 add	 eax, 5
  0096e	66 ba 01 00	 mov	 dx, 1
  00972	0f b7 c8	 movzx	 ecx, ax
  00975	e8 00 00 00 00	 call	 set_pos

; 1105 :                     draw_text (NPregnum64[i*2]);

  0097a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0097e	03 c0		 add	 eax, eax
  00980	48 98		 cdqe
  00982	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum64
  00989	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0098d	e8 00 00 00 00	 call	 draw_text

; 1106 :                     set_pos (REGS_LINE+i, 20);

  00992	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00996	83 c0 05	 add	 eax, 5
  00999	66 ba 14 00	 mov	 dx, 20
  0099d	0f b7 c8	 movzx	 ecx, ax
  009a0	e8 00 00 00 00	 call	 set_pos

; 1107 :                     draw_text (NPregnum64[i*2+1]);

  009a5	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  009a9	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  009ad	48 98		 cdqe
  009af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum64
  009b6	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  009ba	e8 00 00 00 00	 call	 draw_text

; 1108 :                 }

  009bf	e9 74 ff ff ff	 jmp	 $LN8@NP_update
$LN9@NP_update:

; 1109 :             }

  009c4	e9 22 01 00 00	 jmp	 $LN76@NP_update
$LN75@NP_update:

; 1110 :             else
; 1111 :             {
; 1112 :                 /* 32 bit registers */
; 1113 :                 for (i = 0; i < 4; i++)

  009c9	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  009d1	eb 0a		 jmp	 SHORT $LN13@NP_update
$LN11@NP_update:
  009d3	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  009d7	ff c0		 inc	 eax
  009d9	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN13@NP_update:
  009dd	83 7c 24 60 04	 cmp	 DWORD PTR i$[rsp], 4
  009e2	0f 8d 03 01 00
	00		 jge	 $LN12@NP_update

; 1114 :                 {
; 1115 :                     set_pos (i*2+REGS_LINE,1);

  009e8	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  009ec	8d 44 00 05	 lea	 eax, DWORD PTR [rax+rax+5]
  009f0	66 ba 01 00	 mov	 dx, 1
  009f4	0f b7 c8	 movzx	 ecx, ax
  009f7	e8 00 00 00 00	 call	 set_pos

; 1116 :                     fill_text (' ', 38);

  009fc	66 ba 26 00	 mov	 dx, 38			; 00000026H
  00a00	b1 20		 mov	 cl, 32			; 00000020H
  00a02	e8 00 00 00 00	 call	 fill_text

; 1117 :                     set_pos (i*2+(REGS_LINE+1),1);

  00a07	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a0b	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00a0f	66 ba 01 00	 mov	 dx, 1
  00a13	0f b7 c8	 movzx	 ecx, ax
  00a16	e8 00 00 00 00	 call	 set_pos

; 1118 :                     fill_text (' ', 38);

  00a1b	66 ba 26 00	 mov	 dx, 38			; 00000026H
  00a1f	b1 20		 mov	 cl, 32			; 00000020H
  00a21	e8 00 00 00 00	 call	 fill_text

; 1119 :                     set_pos (i*2+(REGS_LINE+1),9);

  00a26	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a2a	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00a2e	66 ba 09 00	 mov	 dx, 9
  00a32	0f b7 c8	 movzx	 ecx, ax
  00a35	e8 00 00 00 00	 call	 set_pos

; 1120 :                     draw_text (NPregnum[i*4]);

  00a3a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a3e	c1 e0 02	 shl	 eax, 2
  00a41	48 98		 cdqe
  00a43	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  00a4a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00a4e	e8 00 00 00 00	 call	 draw_text

; 1121 :                     set_pos (i*2+(REGS_LINE+1),18);

  00a53	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a57	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00a5b	66 ba 12 00	 mov	 dx, 18
  00a5f	0f b7 c8	 movzx	 ecx, ax
  00a62	e8 00 00 00 00	 call	 set_pos

; 1122 :                     draw_text (NPregnum[i*4+1]);

  00a67	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a6b	8d 04 85 01 00
	00 00		 lea	 eax, DWORD PTR [rax*4+1]
  00a72	48 98		 cdqe
  00a74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  00a7b	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00a7f	e8 00 00 00 00	 call	 draw_text

; 1123 :                     set_pos (i*2+(REGS_LINE+1),27);

  00a84	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a88	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00a8c	66 ba 1b 00	 mov	 dx, 27
  00a90	0f b7 c8	 movzx	 ecx, ax
  00a93	e8 00 00 00 00	 call	 set_pos

; 1124 :                     draw_text (NPregnum[i*4+2]);

  00a98	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00a9c	8d 04 85 02 00
	00 00		 lea	 eax, DWORD PTR [rax*4+2]
  00aa3	48 98		 cdqe
  00aa5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  00aac	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00ab0	e8 00 00 00 00	 call	 draw_text

; 1125 :                     set_pos (i*2+(REGS_LINE+1),36);

  00ab5	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00ab9	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00abd	66 ba 24 00	 mov	 dx, 36			; 00000024H
  00ac1	0f b7 c8	 movzx	 ecx, ax
  00ac4	e8 00 00 00 00	 call	 set_pos

; 1126 :                     draw_text (NPregnum[i*4+3]);

  00ac9	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00acd	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  00ad4	48 98		 cdqe
  00ad6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  00add	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00ae1	e8 00 00 00 00	 call	 draw_text

; 1127 :                 }

  00ae6	e9 e8 fe ff ff	 jmp	 $LN11@NP_update
$LN12@NP_update:
$LN76@NP_update:
$LN73@NP_update:

; 1128 :             }
; 1129 :         }
; 1130 : 
; 1131 :         /* Display register values */
; 1132 :         set_color (COLOR_LIGHT_YELLOW, COLOR_BLACK );

  00aeb	33 d2		 xor	 edx, edx
  00aed	66 b9 0e 00	 mov	 cx, 14
  00af1	e8 00 00 00 00	 call	 set_color

; 1133 :         if (NPregmode)

  00af6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregmode, 0
  00afd	0f 84 ae 01 00
	00		 je	 $LN78@NP_update

; 1134 :         {
; 1135 :             /* 64 bit registers */
; 1136 :             for (i = 0; i < 16; i++)

  00b03	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00b0b	eb 0a		 jmp	 SHORT $LN16@NP_update
$LN14@NP_update:
  00b0d	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00b11	ff c0		 inc	 eax
  00b13	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN16@NP_update:
  00b17	83 7c 24 60 10	 cmp	 DWORD PTR i$[rsp], 16
  00b1c	0f 8d 8a 01 00
	00		 jge	 $LN15@NP_update

; 1137 :             {
; 1138 :                 switch (NPregdisp) {

  00b22	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPregdisp
  00b28	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv450[rsp], eax
  00b2f	83 bc 24 d8 00
	00 00 00	 cmp	 DWORD PTR tv450[rsp], 0
  00b37	74 13		 je	 SHORT $LN80@NP_update
  00b39	83 bc 24 d8 00
	00 00 01	 cmp	 DWORD PTR tv450[rsp], 1
  00b41	0f 84 b0 00 00
	00		 je	 $LN83@NP_update
  00b47	e9 5b 01 00 00	 jmp	 $LN17@NP_update
$LN80@NP_update:

; 1139 :                 case 0:
; 1140 :                     if (!NPregs_valid || NPregs64[i] != regs->GR_G(i))

  00b4c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  00b53	74 27		 je	 SHORT $LN82@NP_update
  00b55	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00b5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs64
  00b61	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  00b66	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00b6e	48 8b 94 d7 80
	02 00 00	 mov	 rdx, QWORD PTR [rdi+rdx*8+640]
  00b76	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  00b7a	74 76		 je	 SHORT $LN81@NP_update
$LN82@NP_update:

; 1141 :                     {
; 1142 :                         set_pos (REGS_LINE + i/2, 3 + (i%2)*19);

  00b7c	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00b80	99		 cdq
  00b81	83 e0 01	 and	 eax, 1
  00b84	33 c2		 xor	 eax, edx
  00b86	2b c2		 sub	 eax, edx
  00b88	6b c0 13	 imul	 eax, eax, 19
  00b8b	83 c0 03	 add	 eax, 3
  00b8e	89 84 24 54 01
	00 00		 mov	 DWORD PTR tv463[rsp], eax
  00b95	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00b99	99		 cdq
  00b9a	2b c2		 sub	 eax, edx
  00b9c	d1 f8		 sar	 eax, 1
  00b9e	83 c0 05	 add	 eax, 5
  00ba1	8b 8c 24 54 01
	00 00		 mov	 ecx, DWORD PTR tv463[rsp]
  00ba8	0f b7 d1	 movzx	 edx, cx
  00bab	0f b7 c8	 movzx	 ecx, ax
  00bae	e8 00 00 00 00	 call	 set_pos

; 1143 :                         draw_dw (regs->GR_G(i));

  00bb3	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00bb8	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00bc0	48 8b 8c c1 80
	02 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+640]
  00bc8	e8 00 00 00 00	 call	 draw_dw

; 1144 :                         NPregs64[i] = regs->GR_G(i);

  00bcd	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00bd2	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  00bd7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs64
  00bde	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00be6	48 8b 84 c7 80
	02 00 00	 mov	 rax, QWORD PTR [rdi+rax*8+640]
  00bee	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN81@NP_update:

; 1145 :                     }
; 1146 :                     break;

  00bf2	e9 b0 00 00 00	 jmp	 $LN17@NP_update
$LN83@NP_update:

; 1147 :                 case 1:
; 1148 :                     if (!NPregs_valid || NPregs64[i] != regs->CR_G(i))

  00bf7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  00bfe	74 2b		 je	 SHORT $LN85@NP_update
  00c00	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00c05	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs64
  00c0c	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  00c10	ff c2		 inc	 edx
  00c12	48 63 d2	 movsxd	 rdx, edx
  00c15	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00c1d	48 8b 94 d7 00
	06 00 00	 mov	 rdx, QWORD PTR [rdi+rdx*8+1536]
  00c25	48 39 14 c1	 cmp	 QWORD PTR [rcx+rax*8], rdx
  00c29	74 7c		 je	 SHORT $LN84@NP_update
$LN85@NP_update:

; 1149 :                     {
; 1150 :                         set_pos (REGS_LINE + i/2, 3 + (i%2)*19);

  00c2b	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00c2f	99		 cdq
  00c30	83 e0 01	 and	 eax, 1
  00c33	33 c2		 xor	 eax, edx
  00c35	2b c2		 sub	 eax, edx
  00c37	6b c0 13	 imul	 eax, eax, 19
  00c3a	83 c0 03	 add	 eax, 3
  00c3d	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv497[rsp], eax
  00c44	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00c48	99		 cdq
  00c49	2b c2		 sub	 eax, edx
  00c4b	d1 f8		 sar	 eax, 1
  00c4d	83 c0 05	 add	 eax, 5
  00c50	8b 8c 24 20 01
	00 00		 mov	 ecx, DWORD PTR tv497[rsp]
  00c57	0f b7 d1	 movzx	 edx, cx
  00c5a	0f b7 c8	 movzx	 ecx, ax
  00c5d	e8 00 00 00 00	 call	 set_pos

; 1151 :                         draw_dw (regs->CR_G(i));

  00c62	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00c66	ff c0		 inc	 eax
  00c68	48 98		 cdqe
  00c6a	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00c72	48 8b 8c c1 00
	06 00 00	 mov	 rcx, QWORD PTR [rcx+rax*8+1536]
  00c7a	e8 00 00 00 00	 call	 draw_dw

; 1152 :                         NPregs64[i] = regs->CR_G(i);

  00c7f	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00c83	ff c0		 inc	 eax
  00c85	48 98		 cdqe
  00c87	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  00c8c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs64
  00c93	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00c9b	48 8b 84 c7 00
	06 00 00	 mov	 rax, QWORD PTR [rdi+rax*8+1536]
  00ca3	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN84@NP_update:
$LN17@NP_update:

; 1153 :                     }
; 1154 :                     break;
; 1155 :                 }
; 1156 :             }

  00ca7	e9 61 fe ff ff	 jmp	 $LN14@NP_update
$LN15@NP_update:

; 1157 :         }

  00cac	e9 8b 06 00 00	 jmp	 $LN79@NP_update
$LN78@NP_update:

; 1158 :         else if (NPregzhost)

  00cb1	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregzhost, 0
  00cb8	0f 84 c0 01 00
	00		 je	 $LN86@NP_update

; 1159 :         {
; 1160 :             /* 32 bit registers on 64 bit template */
; 1161 :             for (i = 0; i < 16; i++)

  00cbe	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00cc6	eb 0a		 jmp	 SHORT $LN21@NP_update
$LN19@NP_update:
  00cc8	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00ccc	ff c0		 inc	 eax
  00cce	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN21@NP_update:
  00cd2	83 7c 24 60 10	 cmp	 DWORD PTR i$[rsp], 16
  00cd7	0f 8d 9c 01 00
	00		 jge	 $LN20@NP_update

; 1162 :             {
; 1163 :                 switch (NPregdisp) {

  00cdd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPregdisp
  00ce3	89 84 24 dc 00
	00 00		 mov	 DWORD PTR tv525[rsp], eax
  00cea	83 bc 24 dc 00
	00 00 00	 cmp	 DWORD PTR tv525[rsp], 0
  00cf2	74 13		 je	 SHORT $LN88@NP_update
  00cf4	83 bc 24 dc 00
	00 00 01	 cmp	 DWORD PTR tv525[rsp], 1
  00cfc	0f 84 b7 00 00
	00		 je	 $LN91@NP_update
  00d02	e9 6d 01 00 00	 jmp	 $LN22@NP_update
$LN88@NP_update:

; 1164 :                 case 0:
; 1165 :                     if (!NPregs_valid || NPregs[i] != regs->GR_L(i))

  00d07	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  00d0e	74 25		 je	 SHORT $LN90@NP_update
  00d10	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00d15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs
  00d1c	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  00d21	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00d29	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  00d30	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  00d33	74 7f		 je	 SHORT $LN89@NP_update
$LN90@NP_update:

; 1166 :                     {
; 1167 :                         set_pos (REGS_LINE + i/2, 3 + (i%2)*19);

  00d35	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00d39	99		 cdq
  00d3a	83 e0 01	 and	 eax, 1
  00d3d	33 c2		 xor	 eax, edx
  00d3f	2b c2		 sub	 eax, edx
  00d41	6b c0 13	 imul	 eax, eax, 19
  00d44	83 c0 03	 add	 eax, 3
  00d47	89 84 24 24 01
	00 00		 mov	 DWORD PTR tv538[rsp], eax
  00d4e	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00d52	99		 cdq
  00d53	2b c2		 sub	 eax, edx
  00d55	d1 f8		 sar	 eax, 1
  00d57	83 c0 05	 add	 eax, 5
  00d5a	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR tv538[rsp]
  00d61	0f b7 d1	 movzx	 edx, cx
  00d64	0f b7 c8	 movzx	 ecx, ax
  00d67	e8 00 00 00 00	 call	 set_pos

; 1168 : //                      draw_fw (0);
; 1169 :                         draw_text("--------");

  00d6c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168833
  00d73	e8 00 00 00 00	 call	 draw_text

; 1170 :                         draw_fw (regs->GR_L(i));

  00d78	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00d7d	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00d85	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00d8c	e8 00 00 00 00	 call	 draw_fw

; 1171 :                         NPregs[i] = regs->GR_L(i);

  00d91	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00d96	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  00d9b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs
  00da2	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00daa	8b 84 c7 80 02
	00 00		 mov	 eax, DWORD PTR [rdi+rax*8+640]
  00db1	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN89@NP_update:

; 1172 :                     }
; 1173 :                     break;

  00db4	e9 bb 00 00 00	 jmp	 $LN22@NP_update
$LN91@NP_update:

; 1174 :                 case 1:
; 1175 :                     if (!NPregs_valid || NPregs[i] != regs->CR_L(i))

  00db9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  00dc0	74 2d		 je	 SHORT $LN93@NP_update
  00dc2	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00dc7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs
  00dce	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  00dd2	ff c2		 inc	 edx
  00dd4	48 63 d2	 movsxd	 rdx, edx
  00dd7	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00ddf	8b 94 d7 00 06
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+1536]
  00de6	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  00de9	0f 84 85 00 00
	00		 je	 $LN92@NP_update
$LN93@NP_update:

; 1176 :                     {
; 1177 :                         set_pos (REGS_LINE + i/2, 3 + (i%2)*19);

  00def	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00df3	99		 cdq
  00df4	83 e0 01	 and	 eax, 1
  00df7	33 c2		 xor	 eax, edx
  00df9	2b c2		 sub	 eax, edx
  00dfb	6b c0 13	 imul	 eax, eax, 19
  00dfe	83 c0 03	 add	 eax, 3
  00e01	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv573[rsp], eax
  00e08	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00e0c	99		 cdq
  00e0d	2b c2		 sub	 eax, edx
  00e0f	d1 f8		 sar	 eax, 1
  00e11	83 c0 05	 add	 eax, 5
  00e14	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR tv573[rsp]
  00e1b	0f b7 d1	 movzx	 edx, cx
  00e1e	0f b7 c8	 movzx	 ecx, ax
  00e21	e8 00 00 00 00	 call	 set_pos

; 1178 : //                      draw_fw (0);
; 1179 :                         draw_text("--------");

  00e26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168837
  00e2d	e8 00 00 00 00	 call	 draw_text

; 1180 :                         draw_fw (regs->CR_L(i));

  00e32	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00e36	ff c0		 inc	 eax
  00e38	48 98		 cdqe
  00e3a	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00e42	8b 8c c1 00 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+1536]
  00e49	e8 00 00 00 00	 call	 draw_fw

; 1181 :                         NPregs[i] = regs->CR_L(i);

  00e4e	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00e52	ff c0		 inc	 eax
  00e54	48 98		 cdqe
  00e56	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  00e5b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs
  00e62	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00e6a	8b 84 c7 00 06
	00 00		 mov	 eax, DWORD PTR [rdi+rax*8+1536]
  00e71	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN92@NP_update:
$LN22@NP_update:

; 1182 :                     }
; 1183 :                     break;
; 1184 :                 }
; 1185 :             }

  00e74	e9 4f fe ff ff	 jmp	 $LN19@NP_update
$LN20@NP_update:

; 1186 :         }

  00e79	e9 be 04 00 00	 jmp	 $LN87@NP_update
$LN86@NP_update:

; 1187 :         else
; 1188 :         {
; 1189 :             /* 32 bit registers */
; 1190 :             addr = NPaddress;

  00e7e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPaddress
  00e84	89 44 24 78	 mov	 DWORD PTR addr$[rsp], eax

; 1191 :             for (i = 0; i < 16; i++)

  00e88	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00e90	eb 0a		 jmp	 SHORT $LN26@NP_update
$LN24@NP_update:
  00e92	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00e96	ff c0		 inc	 eax
  00e98	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN26@NP_update:
  00e9c	83 7c 24 60 10	 cmp	 DWORD PTR i$[rsp], 16
  00ea1	0f 8d 95 04 00
	00		 jge	 $LN25@NP_update

; 1192 :             {
; 1193 :                 switch (NPregdisp) {

  00ea7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPregdisp
  00ead	89 44 24 7c	 mov	 DWORD PTR tv601[rsp], eax
  00eb1	83 7c 24 7c 00	 cmp	 DWORD PTR tv601[rsp], 0
  00eb6	74 2c		 je	 SHORT $LN95@NP_update
  00eb8	83 7c 24 7c 01	 cmp	 DWORD PTR tv601[rsp], 1
  00ebd	0f 84 cf 00 00
	00		 je	 $LN98@NP_update
  00ec3	83 7c 24 7c 02	 cmp	 DWORD PTR tv601[rsp], 2
  00ec8	0f 84 80 01 00
	00		 je	 $LN101@NP_update
  00ece	83 7c 24 7c 03	 cmp	 DWORD PTR tv601[rsp], 3
  00ed3	0f 84 23 02 00
	00		 je	 $LN104@NP_update
  00ed9	83 7c 24 7c 04	 cmp	 DWORD PTR tv601[rsp], 4
  00ede	0f 84 c6 02 00
	00		 je	 $LN107@NP_update
$LN95@NP_update:

; 1194 :                 default:
; 1195 :                 case 0:
; 1196 :                     if (!NPregs_valid || NPregs[i] != regs->GR_L(i))

  00ee4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  00eeb	74 25		 je	 SHORT $LN97@NP_update
  00eed	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00ef2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs
  00ef9	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  00efe	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00f06	8b 94 d7 80 02
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+640]
  00f0d	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  00f10	74 7b		 je	 SHORT $LN96@NP_update
$LN97@NP_update:

; 1197 :                     {
; 1198 :                         set_pos (REGS_LINE + (i/4)*2, 3 + (i%4)*9);

  00f12	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00f16	99		 cdq
  00f17	83 e2 03	 and	 edx, 3
  00f1a	03 c2		 add	 eax, edx
  00f1c	83 e0 03	 and	 eax, 3
  00f1f	2b c2		 sub	 eax, edx
  00f21	6b c0 09	 imul	 eax, eax, 9
  00f24	83 c0 03	 add	 eax, 3
  00f27	89 84 24 2c 01
	00 00		 mov	 DWORD PTR tv614[rsp], eax
  00f2e	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00f32	99		 cdq
  00f33	83 e2 03	 and	 edx, 3
  00f36	03 c2		 add	 eax, edx
  00f38	c1 f8 02	 sar	 eax, 2
  00f3b	8d 44 00 05	 lea	 eax, DWORD PTR [rax+rax+5]
  00f3f	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR tv614[rsp]
  00f46	0f b7 d1	 movzx	 edx, cx
  00f49	0f b7 c8	 movzx	 ecx, ax
  00f4c	e8 00 00 00 00	 call	 set_pos

; 1199 :                         draw_fw (regs->GR_L(i));

  00f51	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00f56	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00f5e	8b 8c c1 80 02
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+640]
  00f65	e8 00 00 00 00	 call	 draw_fw

; 1200 :                         NPregs[i] = regs->GR_L(i);

  00f6a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00f6f	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  00f74	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs
  00f7b	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00f83	8b 84 c7 80 02
	00 00		 mov	 eax, DWORD PTR [rdi+rax*8+640]
  00f8a	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN96@NP_update:

; 1201 :                     }
; 1202 :                     break;

  00f8d	e9 a5 03 00 00	 jmp	 $LN27@NP_update
$LN98@NP_update:

; 1203 :                 case 1:
; 1204 :                     if (!NPregs_valid || NPregs[i] != regs->CR_L(i))

  00f92	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  00f99	74 2d		 je	 SHORT $LN100@NP_update
  00f9b	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  00fa0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs
  00fa7	8b 54 24 60	 mov	 edx, DWORD PTR i$[rsp]
  00fab	ff c2		 inc	 edx
  00fad	48 63 d2	 movsxd	 rdx, edx
  00fb0	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  00fb8	8b 94 d7 00 06
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*8+1536]
  00fbf	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  00fc2	0f 84 81 00 00
	00		 je	 $LN99@NP_update
$LN100@NP_update:

; 1205 :                     {
; 1206 :                         set_pos (REGS_LINE + (i/4)*2, 3 + (i%4)*9);

  00fc8	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00fcc	99		 cdq
  00fcd	83 e2 03	 and	 edx, 3
  00fd0	03 c2		 add	 eax, edx
  00fd2	83 e0 03	 and	 eax, 3
  00fd5	2b c2		 sub	 eax, edx
  00fd7	6b c0 09	 imul	 eax, eax, 9
  00fda	83 c0 03	 add	 eax, 3
  00fdd	89 84 24 30 01
	00 00		 mov	 DWORD PTR tv649[rsp], eax
  00fe4	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  00fe8	99		 cdq
  00fe9	83 e2 03	 and	 edx, 3
  00fec	03 c2		 add	 eax, edx
  00fee	c1 f8 02	 sar	 eax, 2
  00ff1	8d 44 00 05	 lea	 eax, DWORD PTR [rax+rax+5]
  00ff5	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR tv649[rsp]
  00ffc	0f b7 d1	 movzx	 edx, cx
  00fff	0f b7 c8	 movzx	 ecx, ax
  01002	e8 00 00 00 00	 call	 set_pos

; 1207 :                         draw_fw (regs->CR_L(i));

  01007	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0100b	ff c0		 inc	 eax
  0100d	48 98		 cdqe
  0100f	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01017	8b 8c c1 00 06
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*8+1536]
  0101e	e8 00 00 00 00	 call	 draw_fw

; 1208 :                         NPregs[i] = regs->CR_L(i);

  01023	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01027	ff c0		 inc	 eax
  01029	48 98		 cdqe
  0102b	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  01030	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs
  01037	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  0103f	8b 84 c7 00 06
	00 00		 mov	 eax, DWORD PTR [rdi+rax*8+1536]
  01046	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN99@NP_update:

; 1209 :                     }
; 1210 :                     break;

  01049	e9 e9 02 00 00	 jmp	 $LN27@NP_update
$LN101@NP_update:

; 1211 :                 case 2:
; 1212 :                     if (!NPregs_valid || NPregs[i] != regs->AR(i))

  0104e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  01055	74 25		 je	 SHORT $LN103@NP_update
  01057	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0105c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs
  01063	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  01068	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  01070	8b 94 97 00 03
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*4+768]
  01077	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  0107a	74 7b		 je	 SHORT $LN102@NP_update
$LN103@NP_update:

; 1213 :                     {
; 1214 :                         set_pos (REGS_LINE + (i/4)*2, 3 + (i%4)*9);

  0107c	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01080	99		 cdq
  01081	83 e2 03	 and	 edx, 3
  01084	03 c2		 add	 eax, edx
  01086	83 e0 03	 and	 eax, 3
  01089	2b c2		 sub	 eax, edx
  0108b	6b c0 09	 imul	 eax, eax, 9
  0108e	83 c0 03	 add	 eax, 3
  01091	89 84 24 34 01
	00 00		 mov	 DWORD PTR tv684[rsp], eax
  01098	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0109c	99		 cdq
  0109d	83 e2 03	 and	 edx, 3
  010a0	03 c2		 add	 eax, edx
  010a2	c1 f8 02	 sar	 eax, 2
  010a5	8d 44 00 05	 lea	 eax, DWORD PTR [rax+rax+5]
  010a9	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR tv684[rsp]
  010b0	0f b7 d1	 movzx	 edx, cx
  010b3	0f b7 c8	 movzx	 ecx, ax
  010b6	e8 00 00 00 00	 call	 set_pos

; 1215 :                         draw_fw (regs->AR(i));

  010bb	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  010c0	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  010c8	8b 8c 81 00 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+768]
  010cf	e8 00 00 00 00	 call	 draw_fw

; 1216 :                         NPregs[i] = regs->AR(i);

  010d4	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  010d9	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  010de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs
  010e5	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  010ed	8b 84 87 00 03
	00 00		 mov	 eax, DWORD PTR [rdi+rax*4+768]
  010f4	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN102@NP_update:

; 1217 :                     }
; 1218 :                     break;

  010f7	e9 3b 02 00 00	 jmp	 $LN27@NP_update
$LN104@NP_update:

; 1219 :                 case 3:
; 1220 :                     if (!NPregs_valid || NPregs[i] != regs->fpr[i])

  010fc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  01103	74 25		 je	 SHORT $LN106@NP_update
  01105	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0110a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs
  01111	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  01116	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  0111e	8b 94 97 40 03
	00 00		 mov	 edx, DWORD PTR [rdi+rdx*4+832]
  01125	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  01128	74 7b		 je	 SHORT $LN105@NP_update
$LN106@NP_update:

; 1221 :                     {
; 1222 :                         set_pos (REGS_LINE + (i/4)*2, 3 + (i%4)*9);

  0112a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0112e	99		 cdq
  0112f	83 e2 03	 and	 edx, 3
  01132	03 c2		 add	 eax, edx
  01134	83 e0 03	 and	 eax, 3
  01137	2b c2		 sub	 eax, edx
  01139	6b c0 09	 imul	 eax, eax, 9
  0113c	83 c0 03	 add	 eax, 3
  0113f	89 84 24 38 01
	00 00		 mov	 DWORD PTR tv715[rsp], eax
  01146	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0114a	99		 cdq
  0114b	83 e2 03	 and	 edx, 3
  0114e	03 c2		 add	 eax, edx
  01150	c1 f8 02	 sar	 eax, 2
  01153	8d 44 00 05	 lea	 eax, DWORD PTR [rax+rax+5]
  01157	8b 8c 24 38 01
	00 00		 mov	 ecx, DWORD PTR tv715[rsp]
  0115e	0f b7 d1	 movzx	 edx, cx
  01161	0f b7 c8	 movzx	 ecx, ax
  01164	e8 00 00 00 00	 call	 set_pos

; 1223 :                         draw_fw (regs->fpr[i]);

  01169	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0116e	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01176	8b 8c 81 40 03
	00 00		 mov	 ecx, DWORD PTR [rcx+rax*4+832]
  0117d	e8 00 00 00 00	 call	 draw_fw

; 1224 :                         NPregs[i] = regs->fpr[i];

  01182	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01187	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0118c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs
  01193	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  0119b	8b 84 87 40 03
	00 00		 mov	 eax, DWORD PTR [rdi+rax*4+832]
  011a2	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN105@NP_update:

; 1225 :                     }
; 1226 :                     break;

  011a5	e9 8d 01 00 00	 jmp	 $LN27@NP_update
$LN107@NP_update:

; 1227 :                 case 4:
; 1228 :                     aaddr = APPLY_PREFIXING (addr, regs->PX);

  011aa	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  011ae	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  011b4	48 85 c0	 test	 rax, rax
  011b7	74 27		 je	 SHORT $LN206@NP_update
  011b9	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  011bd	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  011c3	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  011cb	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  011ce	48 3b c1	 cmp	 rax, rcx
  011d1	74 0d		 je	 SHORT $LN206@NP_update
  011d3	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  011d7	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv745[rsp], eax
  011de	eb 1a		 jmp	 SHORT $LN207@NP_update
$LN206@NP_update:
  011e0	48 8b 84 24 d0
	06 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  011e8	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  011eb	8b 4c 24 78	 mov	 ecx, DWORD PTR addr$[rsp]
  011ef	33 c8		 xor	 ecx, eax
  011f1	8b c1		 mov	 eax, ecx
  011f3	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv745[rsp], eax
$LN207@NP_update:
  011fa	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR tv745[rsp]
  01201	89 84 24 84 00
	00 00		 mov	 DWORD PTR aaddr$[rsp], eax

; 1229 :                     addr += 4;

  01208	8b 44 24 78	 mov	 eax, DWORD PTR addr$[rsp]
  0120c	83 c0 04	 add	 eax, 4
  0120f	89 44 24 78	 mov	 DWORD PTR addr$[rsp], eax

; 1230 :                     if (aaddr + 3 > regs->mainlim)

  01213	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR aaddr$[rsp]
  0121a	83 c0 03	 add	 eax, 3
  0121d	8b c0		 mov	 eax, eax
  0121f	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01227	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  0122e	76 05		 jbe	 SHORT $LN108@NP_update

; 1231 :                         break;

  01230	e9 02 01 00 00	 jmp	 $LN27@NP_update
$LN108@NP_update:

; 1232 :                     if (!NPregs_valid || NPregs[i] != fetch_fw(regs->mainstor + aaddr))

  01235	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  0123c	74 5a		 je	 SHORT $LN110@NP_update
  0123e	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01243	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR tv752[rsp], rax
  0124b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregs
  01252	48 89 8c 24 60
	01 00 00	 mov	 QWORD PTR tv1429[rsp], rcx
  0125a	8b 94 24 84 00
	00 00		 mov	 edx, DWORD PTR aaddr$[rsp]
  01261	48 8b bc 24 d0
	06 00 00	 mov	 rdi, QWORD PTR regs$[rsp]
  01269	48 03 97 48 08
	00 00		 add	 rdx, QWORD PTR [rdi+2120]
  01270	48 8b ca	 mov	 rcx, rdx
  01273	e8 00 00 00 00	 call	 fetch_fw_noswap
  01278	8b c8		 mov	 ecx, eax
  0127a	e8 00 00 00 00	 call	 _byteswap_ulong
  0127f	48 8b 94 24 60
	01 00 00	 mov	 rdx, QWORD PTR tv1429[rsp]
  01287	48 8b 8c 24 68
	01 00 00	 mov	 rcx, QWORD PTR tv752[rsp]
  0128f	39 04 8a	 cmp	 DWORD PTR [rdx+rcx*4], eax
  01292	0f 84 9f 00 00
	00		 je	 $LN109@NP_update
$LN110@NP_update:

; 1233 :                     {
; 1234 :                         set_pos (REGS_LINE + (i/4)*2, 3 + (i%4)*9);

  01298	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0129c	99		 cdq
  0129d	83 e2 03	 and	 edx, 3
  012a0	03 c2		 add	 eax, edx
  012a2	83 e0 03	 and	 eax, 3
  012a5	2b c2		 sub	 eax, edx
  012a7	6b c0 09	 imul	 eax, eax, 9
  012aa	83 c0 03	 add	 eax, 3
  012ad	89 84 24 3c 01
	00 00		 mov	 DWORD PTR tv765[rsp], eax
  012b4	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  012b8	99		 cdq
  012b9	83 e2 03	 and	 edx, 3
  012bc	03 c2		 add	 eax, edx
  012be	c1 f8 02	 sar	 eax, 2
  012c1	8d 44 00 05	 lea	 eax, DWORD PTR [rax+rax+5]
  012c5	8b 8c 24 3c 01
	00 00		 mov	 ecx, DWORD PTR tv765[rsp]
  012cc	0f b7 d1	 movzx	 edx, cx
  012cf	0f b7 c8	 movzx	 ecx, ax
  012d2	e8 00 00 00 00	 call	 set_pos

; 1235 :                         draw_fw (fetch_fw(regs->mainstor + aaddr));

  012d7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR aaddr$[rsp]
  012de	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  012e6	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  012ed	48 8b c8	 mov	 rcx, rax
  012f0	e8 00 00 00 00	 call	 fetch_fw_noswap
  012f5	8b c8		 mov	 ecx, eax
  012f7	e8 00 00 00 00	 call	 _byteswap_ulong
  012fc	8b c8		 mov	 ecx, eax
  012fe	e8 00 00 00 00	 call	 draw_fw

; 1236 :                         NPregs[i] = fetch_fw(regs->mainstor + aaddr);

  01303	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR aaddr$[rsp]
  0130a	48 8b 8c 24 d0
	06 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  01312	48 03 81 48 08
	00 00		 add	 rax, QWORD PTR [rcx+2120]
  01319	48 8b c8	 mov	 rcx, rax
  0131c	e8 00 00 00 00	 call	 fetch_fw_noswap
  01321	8b c8		 mov	 ecx, eax
  01323	e8 00 00 00 00	 call	 _byteswap_ulong
  01328	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  0132d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPregs
  01334	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN109@NP_update:
$LN27@NP_update:

; 1237 :                     }
; 1238 :                     break;
; 1239 :                 }
; 1240 :             }

  01337	e9 56 fb ff ff	 jmp	 $LN24@NP_update
$LN25@NP_update:
$LN87@NP_update:
$LN79@NP_update:

; 1241 :         }
; 1242 : 
; 1243 :         /* Update register selection indicator */
; 1244 :         if (!NPregs_valid)

  0133c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregs_valid, 0
  01343	0f 85 1c 01 00
	00		 jne	 $LN111@NP_update

; 1245 :         {
; 1246 :             set_pos ((REGS_LINE+8), 6);

  01349	66 ba 06 00	 mov	 dx, 6
  0134d	66 b9 0d 00	 mov	 cx, 13
  01351	e8 00 00 00 00	 call	 set_pos

; 1247 :             set_color (NPregdisp == 0 ? COLOR_LIGHT_YELLOW : COLOR_WHITE, COLOR_BLACK);

  01356	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregdisp, 0
  0135d	75 0d		 jne	 SHORT $LN208@NP_update
  0135f	c7 84 24 e4 00
	00 00 0e 00 00
	00		 mov	 DWORD PTR tv801[rsp], 14
  0136a	eb 0b		 jmp	 SHORT $LN209@NP_update
$LN208@NP_update:
  0136c	c7 84 24 e4 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR tv801[rsp], 15
$LN209@NP_update:
  01377	33 d2		 xor	 edx, edx
  01379	0f b7 8c 24 e4
	00 00 00	 movzx	 ecx, WORD PTR tv801[rsp]
  01381	e8 00 00 00 00	 call	 set_color

; 1248 :             draw_char ('G');

  01386	b9 47 00 00 00	 mov	 ecx, 71			; 00000047H
  0138b	e8 00 00 00 00	 call	 draw_char

; 1249 : 
; 1250 :             set_pos ((REGS_LINE+8), 14);

  01390	66 ba 0e 00	 mov	 dx, 14
  01394	66 b9 0d 00	 mov	 cx, 13
  01398	e8 00 00 00 00	 call	 set_pos

; 1251 :             set_color (NPregdisp == 1 ? COLOR_LIGHT_YELLOW : COLOR_WHITE, COLOR_BLACK);

  0139d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPregdisp, 1
  013a4	75 0d		 jne	 SHORT $LN210@NP_update
  013a6	c7 84 24 e8 00
	00 00 0e 00 00
	00		 mov	 DWORD PTR tv809[rsp], 14
  013b1	eb 0b		 jmp	 SHORT $LN211@NP_update
$LN210@NP_update:
  013b3	c7 84 24 e8 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR tv809[rsp], 15
$LN211@NP_update:
  013be	33 d2		 xor	 edx, edx
  013c0	0f b7 8c 24 e8
	00 00 00	 movzx	 ecx, WORD PTR tv809[rsp]
  013c8	e8 00 00 00 00	 call	 set_color

; 1252 :             draw_char ('C');

  013cd	b9 43 00 00 00	 mov	 ecx, 67			; 00000043H
  013d2	e8 00 00 00 00	 call	 draw_char

; 1253 : 
; 1254 :             set_pos ((REGS_LINE+8), 22);

  013d7	66 ba 16 00	 mov	 dx, 22
  013db	66 b9 0d 00	 mov	 cx, 13
  013df	e8 00 00 00 00	 call	 set_pos

; 1255 :             set_color (NPregdisp == 2 ? COLOR_LIGHT_YELLOW : COLOR_WHITE, COLOR_BLACK);

  013e4	83 3d 00 00 00
	00 02		 cmp	 DWORD PTR NPregdisp, 2
  013eb	75 0d		 jne	 SHORT $LN212@NP_update
  013ed	c7 84 24 ec 00
	00 00 0e 00 00
	00		 mov	 DWORD PTR tv817[rsp], 14
  013f8	eb 0b		 jmp	 SHORT $LN213@NP_update
$LN212@NP_update:
  013fa	c7 84 24 ec 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR tv817[rsp], 15
$LN213@NP_update:
  01405	33 d2		 xor	 edx, edx
  01407	0f b7 8c 24 ec
	00 00 00	 movzx	 ecx, WORD PTR tv817[rsp]
  0140f	e8 00 00 00 00	 call	 set_color

; 1256 :             draw_char ('A');

  01414	b9 41 00 00 00	 mov	 ecx, 65			; 00000041H
  01419	e8 00 00 00 00	 call	 draw_char

; 1257 : 
; 1258 :             set_pos ((REGS_LINE+8), 30);

  0141e	66 ba 1e 00	 mov	 dx, 30
  01422	66 b9 0d 00	 mov	 cx, 13
  01426	e8 00 00 00 00	 call	 set_pos

; 1259 :             set_color (NPregdisp == 3 ? COLOR_LIGHT_YELLOW : COLOR_WHITE, COLOR_BLACK);

  0142b	83 3d 00 00 00
	00 03		 cmp	 DWORD PTR NPregdisp, 3
  01432	75 0d		 jne	 SHORT $LN214@NP_update
  01434	c7 84 24 f0 00
	00 00 0e 00 00
	00		 mov	 DWORD PTR tv825[rsp], 14
  0143f	eb 0b		 jmp	 SHORT $LN215@NP_update
$LN214@NP_update:
  01441	c7 84 24 f0 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR tv825[rsp], 15
$LN215@NP_update:
  0144c	33 d2		 xor	 edx, edx
  0144e	0f b7 8c 24 f0
	00 00 00	 movzx	 ecx, WORD PTR tv825[rsp]
  01456	e8 00 00 00 00	 call	 set_color

; 1260 :             draw_char ('F');

  0145b	b9 46 00 00 00	 mov	 ecx, 70			; 00000046H
  01460	e8 00 00 00 00	 call	 draw_char
$LN111@NP_update:

; 1261 :         }
; 1262 : 
; 1263 :         NPregs_valid = 1;

  01465	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPregs_valid, 1

; 1264 : 
; 1265 :         /* Address & Data */
; 1266 :         if (!NPaddr_valid)

  0146f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPaddr_valid, 0
  01476	75 2d		 jne	 SHORT $LN112@NP_update

; 1267 :         {
; 1268 :             set_color (COLOR_LIGHT_YELLOW, COLOR_BLACK);

  01478	33 d2		 xor	 edx, edx
  0147a	66 b9 0e 00	 mov	 cx, 14
  0147e	e8 00 00 00 00	 call	 set_color

; 1269 :             set_pos (ADDR_LINE, 12);

  01483	66 ba 0c 00	 mov	 dx, 12
  01487	66 b9 0f 00	 mov	 cx, 15
  0148b	e8 00 00 00 00	 call	 set_pos

; 1270 :             draw_fw (NPaddress);

  01490	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR NPaddress
  01496	e8 00 00 00 00	 call	 draw_fw

; 1271 :             NPaddr_valid = 1;

  0149b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPaddr_valid, 1
$LN112@NP_update:

; 1272 :         }
; 1273 :         if (!NPdata_valid)

  014a5	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdata_valid, 0
  014ac	75 2d		 jne	 SHORT $LN113@NP_update

; 1274 :         {
; 1275 :             set_color (COLOR_LIGHT_YELLOW, COLOR_BLACK);

  014ae	33 d2		 xor	 edx, edx
  014b0	66 b9 0e 00	 mov	 cx, 14
  014b4	e8 00 00 00 00	 call	 set_color

; 1276 :             set_pos (ADDR_LINE, 30);

  014b9	66 ba 1e 00	 mov	 dx, 30
  014bd	66 b9 0f 00	 mov	 cx, 15
  014c1	e8 00 00 00 00	 call	 set_pos

; 1277 :             draw_fw (NPdata);

  014c6	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR NPdata
  014cc	e8 00 00 00 00	 call	 draw_fw

; 1278 :             NPdata_valid = 1;

  014d1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdata_valid, 1
$LN113@NP_update:
$LN61@NP_update:

; 1279 :         }
; 1280 :     }
; 1281 : 
; 1282 :     /* Rates */
; 1283 :     if ((!NPmips_valid || sysblk.mipsrate != NPmips) && sysblk.hicpu)

  014db	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPmips_valid, 0
  014e2	74 19		 je	 SHORT $LN115@NP_update
  014e4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  014eb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR NPmips
  014f1	39 88 88 14 00
	00		 cmp	 DWORD PTR [rax+5256], ecx
  014f7	0f 84 4d 02 00
	00		 je	 $LN114@NP_update
$LN115@NP_update:
  014fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01504	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0150b	0f 84 39 02 00
	00		 je	 $LN114@NP_update

; 1284 :     {
; 1285 :         set_color (COLOR_LIGHT_YELLOW, COLOR_BLACK);

  01511	33 d2		 xor	 edx, edx
  01513	66 b9 0e 00	 mov	 cx, 14
  01517	e8 00 00 00 00	 call	 set_color

; 1286 :         set_pos (BUTTONS_LINE, 1);

  0151c	66 ba 01 00	 mov	 dx, 1
  01520	66 b9 11 00	 mov	 cx, 17
  01524	e8 00 00 00 00	 call	 set_pos

; 1287 :         if((sysblk.mipsrate / 1000000) > 999)

  01529	33 d2		 xor	 edx, edx
  0152b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01532	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  01538	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0153d	f7 f1		 div	 ecx
  0153f	3d e7 03 00 00	 cmp	 eax, 999		; 000003e7H
  01544	76 6b		 jbe	 SHORT $LN116@NP_update

; 1288 :           MSGBUF(buf, "%2d,%03d", sysblk.mipsrate / 1000000000, sysblk.mipsrate % 1000000000 / 1000000);

  01546	33 d2		 xor	 edx, edx
  01548	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0154f	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  01555	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  0155a	f7 f1		 div	 ecx
  0155c	8b c2		 mov	 eax, edx
  0155e	33 d2		 xor	 edx, edx
  01560	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  01565	f7 f1		 div	 ecx
  01567	89 84 24 40 01
	00 00		 mov	 DWORD PTR tv856[rsp], eax
  0156e	33 d2		 xor	 edx, edx
  01570	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01577	8b 81 88 14 00
	00		 mov	 eax, DWORD PTR [rcx+5256]
  0157d	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  01582	f7 f1		 div	 ecx
  01584	8b 8c 24 40 01
	00 00		 mov	 ecx, DWORD PTR tv856[rsp]
  0158b	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0158f	44 8b c8	 mov	 r9d, eax
  01592	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168862
  01599	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0159e	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  015a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  015ac	e9 6f 01 00 00	 jmp	 $LN117@NP_update
$LN116@NP_update:

; 1289 :         else if((sysblk.mipsrate / 1000000) > 99)

  015b1	33 d2		 xor	 edx, edx
  015b3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  015ba	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  015c0	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  015c5	f7 f1		 div	 ecx
  015c7	83 f8 63	 cmp	 eax, 99			; 00000063H
  015ca	76 6b		 jbe	 SHORT $LN118@NP_update

; 1290 :           MSGBUF(buf, "%4d.%01d", sysblk.mipsrate / 1000000, sysblk.mipsrate % 1000000 / 100000);

  015cc	33 d2		 xor	 edx, edx
  015ce	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  015d5	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  015db	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  015e0	f7 f1		 div	 ecx
  015e2	8b c2		 mov	 eax, edx
  015e4	33 d2		 xor	 edx, edx
  015e6	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  015eb	f7 f1		 div	 ecx
  015ed	89 84 24 44 01
	00 00		 mov	 DWORD PTR tv901[rsp], eax
  015f4	33 d2		 xor	 edx, edx
  015f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  015fd	8b 81 88 14 00
	00		 mov	 eax, DWORD PTR [rcx+5256]
  01603	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  01608	f7 f1		 div	 ecx
  0160a	8b 8c 24 44 01
	00 00		 mov	 ecx, DWORD PTR tv901[rsp]
  01611	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01615	44 8b c8	 mov	 r9d, eax
  01618	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168865
  0161f	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  01624	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0162c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  01632	e9 e9 00 00 00	 jmp	 $LN119@NP_update
$LN118@NP_update:

; 1291 :         else if((sysblk.mipsrate / 1000000) > 9)

  01637	33 d2		 xor	 edx, edx
  01639	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01640	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  01646	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0164b	f7 f1		 div	 ecx
  0164d	83 f8 09	 cmp	 eax, 9
  01650	76 68		 jbe	 SHORT $LN120@NP_update

; 1292 :           MSGBUF(buf, "%3d.%02d", sysblk.mipsrate / 1000000, sysblk.mipsrate % 1000000 / 10000);

  01652	33 d2		 xor	 edx, edx
  01654	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0165b	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  01661	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  01666	f7 f1		 div	 ecx
  01668	8b c2		 mov	 eax, edx
  0166a	33 d2		 xor	 edx, edx
  0166c	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  01671	f7 f1		 div	 ecx
  01673	89 84 24 48 01
	00 00		 mov	 DWORD PTR tv914[rsp], eax
  0167a	33 d2		 xor	 edx, edx
  0167c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01683	8b 81 88 14 00
	00		 mov	 eax, DWORD PTR [rcx+5256]
  01689	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0168e	f7 f1		 div	 ecx
  01690	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR tv914[rsp]
  01697	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0169b	44 8b c8	 mov	 r9d, eax
  0169e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168868
  016a5	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  016aa	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  016b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  016b8	eb 66		 jmp	 SHORT $LN121@NP_update
$LN120@NP_update:

; 1293 :         else
; 1294 :           MSGBUF(buf, "%2d.%03d", sysblk.mipsrate / 1000000, sysblk.mipsrate % 1000000 / 1000);

  016ba	33 d2		 xor	 edx, edx
  016bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  016c3	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  016c9	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  016ce	f7 f1		 div	 ecx
  016d0	8b c2		 mov	 eax, edx
  016d2	33 d2		 xor	 edx, edx
  016d4	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  016d9	f7 f1		 div	 ecx
  016db	89 84 24 4c 01
	00 00		 mov	 DWORD PTR tv924[rsp], eax
  016e2	33 d2		 xor	 edx, edx
  016e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  016eb	8b 81 88 14 00
	00		 mov	 eax, DWORD PTR [rcx+5256]
  016f1	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  016f6	f7 f1		 div	 ecx
  016f8	8b 8c 24 4c 01
	00 00		 mov	 ecx, DWORD PTR tv924[rsp]
  016ff	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01703	44 8b c8	 mov	 r9d, eax
  01706	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168869
  0170d	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  01712	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  0171a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN121@NP_update:
$LN119@NP_update:
$LN117@NP_update:

; 1295 :         draw_text (buf);

  01720	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01728	e8 00 00 00 00	 call	 draw_text

; 1296 :         NPmips = sysblk.mipsrate;

  0172d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01734	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  0173a	89 05 00 00 00
	00		 mov	 DWORD PTR NPmips, eax

; 1297 :         NPmips_valid = 1;

  01740	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPmips_valid, 1
$LN114@NP_update:

; 1298 :     }
; 1299 : 
; 1300 :     if (0
; 1301 :         || (sysblk.hicpu && (!NPsios_valid || NPsios != sysblk.siosrate))
; 1302 : 
; 1303 : #if defined( OPTION_SHARED_DEVICES )
; 1304 :         || sysblk.shrdport

  0174a	33 c0		 xor	 eax, eax
  0174c	85 c0		 test	 eax, eax
  0174e	75 40		 jne	 SHORT $LN123@NP_update
  01750	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01757	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0175e	74 1e		 je	 SHORT $LN124@NP_update
  01760	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPsios_valid, 0
  01767	74 27		 je	 SHORT $LN123@NP_update
  01769	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01770	8b 80 8c 14 00
	00		 mov	 eax, DWORD PTR [rax+5260]
  01776	39 05 00 00 00
	00		 cmp	 DWORD PTR NPsios, eax
  0177c	75 12		 jne	 SHORT $LN123@NP_update
$LN124@NP_update:
  0177e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01785	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  0178c	85 c0		 test	 eax, eax
  0178e	74 73		 je	 SHORT $LN122@NP_update
$LN123@NP_update:

; 1305 : #endif
; 1306 :     )
; 1307 :     {
; 1308 :         set_color (COLOR_LIGHT_YELLOW, COLOR_BLACK);

  01790	33 d2		 xor	 edx, edx
  01792	66 b9 0e 00	 mov	 cx, 14
  01796	e8 00 00 00 00	 call	 set_color

; 1309 :         set_pos (BUTTONS_LINE, 8);

  0179b	66 ba 08 00	 mov	 dx, 8
  0179f	66 b9 11 00	 mov	 cx, 17
  017a3	e8 00 00 00 00	 call	 set_pos

; 1310 :         MSGBUF(buf, "%6.6s", format_int(sysblk.siosrate));

  017a8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  017af	8b 80 8c 14 00
	00		 mov	 eax, DWORD PTR [rax+5260]
  017b5	8b c8		 mov	 ecx, eax
  017b7	e8 00 00 00 00	 call	 format_int
  017bc	4c 8b c8	 mov	 r9, rax
  017bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168873
  017c6	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  017cb	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  017d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1311 :         draw_text (buf);

  017d9	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  017e1	e8 00 00 00 00	 call	 draw_text

; 1312 :         NPsios = sysblk.siosrate;

  017e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  017ed	8b 80 8c 14 00
	00		 mov	 eax, DWORD PTR [rax+5260]
  017f3	89 05 00 00 00
	00		 mov	 DWORD PTR NPsios, eax

; 1313 :         NPsios_valid = 1;

  017f9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPsios_valid, 1
$LN122@NP_update:

; 1314 :     }
; 1315 : 
; 1316 :     /* Optional cpu graph */
; 1317 :     if (NPcpugraph)

  01803	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPcpugraph, 0
  0180a	0f 84 7a 02 00
	00		 je	 $LN125@NP_update

; 1318 :     {
; 1319 :         for (i = 0; i < NPcpugraph_ncpu; i++)

  01810	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01818	eb 0a		 jmp	 SHORT $LN31@NP_update
$LN29@NP_update:
  0181a	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  0181e	ff c0		 inc	 eax
  01820	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN31@NP_update:
  01824	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPcpugraph_ncpu
  0182a	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  0182e	0f 8d 4c 02 00
	00		 jge	 $LN30@NP_update

; 1320 :         {
; 1321 :             if (!IS_CPU_ONLINE(i))

  01834	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01839	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01840	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  01849	75 73		 jne	 SHORT $LN126@NP_update

; 1322 :             {
; 1323 :                 if (!NPcpugraph_valid || NPcpugraphpct[i] != -2.0)

  0184b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPcpugraph_valid, 0
  01852	74 1d		 je	 SHORT $LN129@NP_update
  01854	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01859	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPcpugraphpct
  01860	f2 0f 2a 04 81	 cvtsi2sd xmm0, DWORD PTR [rcx+rax*4]
  01865	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@c000000000000000
  0186d	7a 02		 jp	 SHORT $LN240@NP_update
  0186f	74 48		 je	 SHORT $LN128@NP_update
$LN240@NP_update:
$LN129@NP_update:

; 1324 :                 {
; 1325 :                     set_color (COLOR_RED, COLOR_BLACK);

  01871	33 d2		 xor	 edx, edx
  01873	66 b9 01 00	 mov	 cx, 1
  01877	e8 00 00 00 00	 call	 set_color

; 1326 :                     set_pos (CPU_GRAPH_LINE+1+i, 6);

  0187c	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01880	83 c0 15	 add	 eax, 21
  01883	66 ba 06 00	 mov	 dx, 6
  01887	0f b7 c8	 movzx	 ecx, ax
  0188a	e8 00 00 00 00	 call	 set_pos

; 1327 :                     draw_text ("OFFLINE");

  0188f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168879
  01896	e8 00 00 00 00	 call	 draw_text

; 1328 :                     fill_text (' ', 38);

  0189b	66 ba 26 00	 mov	 dx, 38			; 00000026H
  0189f	b1 20		 mov	 cl, 32			; 00000020H
  018a1	e8 00 00 00 00	 call	 fill_text

; 1329 :                     NPcpugraphpct[i] = -2.0;

  018a6	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  018ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPcpugraphpct
  018b2	c7 04 81 fe ff
	ff ff		 mov	 DWORD PTR [rcx+rax*4], -2
$LN128@NP_update:

; 1330 :                 }
; 1331 :             }

  018b9	e9 b2 01 00 00	 jmp	 $LN127@NP_update
$LN126@NP_update:

; 1332 :             else if (sysblk.regs[i]->cpustate != CPUSTATE_STARTED)

  018be	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  018c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  018ca	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  018d2	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  018d6	83 f8 01	 cmp	 eax, 1
  018d9	74 73		 je	 SHORT $LN130@NP_update

; 1333 :             {
; 1334 :                 if (!NPcpugraph_valid || NPcpugraphpct[i] != -1.0)

  018db	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPcpugraph_valid, 0
  018e2	74 1d		 je	 SHORT $LN133@NP_update
  018e4	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  018e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPcpugraphpct
  018f0	f2 0f 2a 04 81	 cvtsi2sd xmm0, DWORD PTR [rcx+rax*4]
  018f5	66 0f 2e 05 00
	00 00 00	 ucomisd xmm0, QWORD PTR __real@bff0000000000000
  018fd	7a 02		 jp	 SHORT $LN239@NP_update
  018ff	74 48		 je	 SHORT $LN132@NP_update
$LN239@NP_update:
$LN133@NP_update:

; 1335 :                 {
; 1336 :                     set_color (COLOR_LIGHT_YELLOW, COLOR_BLACK);

  01901	33 d2		 xor	 edx, edx
  01903	66 b9 0e 00	 mov	 cx, 14
  01907	e8 00 00 00 00	 call	 set_color

; 1337 :                     set_pos (CPU_GRAPH_LINE+1+i, 6);

  0190c	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01910	83 c0 15	 add	 eax, 21
  01913	66 ba 06 00	 mov	 dx, 6
  01917	0f b7 c8	 movzx	 ecx, ax
  0191a	e8 00 00 00 00	 call	 set_pos

; 1338 :                     draw_text ("STOPPED");

  0191f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168884
  01926	e8 00 00 00 00	 call	 draw_text

; 1339 :                     fill_text (' ', 38);

  0192b	66 ba 26 00	 mov	 dx, 38			; 00000026H
  0192f	b1 20		 mov	 cl, 32			; 00000020H
  01931	e8 00 00 00 00	 call	 fill_text

; 1340 :                     NPcpugraphpct[i] = -1.0;

  01936	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0193b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPcpugraphpct
  01942	c7 04 81 ff ff
	ff ff		 mov	 DWORD PTR [rcx+rax*4], -1
$LN132@NP_update:

; 1341 :                 }
; 1342 :             }

  01949	e9 22 01 00 00	 jmp	 $LN131@NP_update
$LN130@NP_update:

; 1343 :             else if (!NPcpugraph_valid || NPcpugraphpct[i] != sysblk.regs[i]->cpupct)

  0194e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPcpugraph_valid, 0
  01955	74 2f		 je	 SHORT $LN135@NP_update
  01957	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0195c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPcpugraphpct
  01963	48 63 54 24 60	 movsxd	 rdx, DWORD PTR i$[rsp]
  01968	48 8b 3d 00 00
	00 00		 mov	 rdi, QWORD PTR __imp_sysblk
  0196f	48 8b 94 d7 98
	0b 00 00	 mov	 rdx, QWORD PTR [rdi+rdx*8+2968]
  01977	8b 92 b0 07 00
	00		 mov	 edx, DWORD PTR [rdx+1968]
  0197d	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  01980	0f 84 ea 00 00
	00		 je	 $LN134@NP_update
$LN135@NP_update:

; 1344 :             {
; 1345 :                 n = (34 * sysblk.regs[i]->cpupct) / 100;

  01986	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0198b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01992	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  0199a	6b 80 b0 07 00
	00 22		 imul	 eax, DWORD PTR [rax+1968], 34 ; 00000022H
  019a1	99		 cdq
  019a2	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  019a7	f7 f9		 idiv	 ecx
  019a9	89 44 24 64	 mov	 DWORD PTR n$[rsp], eax

; 1346 :                 if (n == 0 && sysblk.regs[i]->cpupct > 0)

  019ad	83 7c 24 64 00	 cmp	 DWORD PTR n$[rsp], 0
  019b2	75 27		 jne	 SHORT $LN136@NP_update
  019b4	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  019b9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  019c0	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  019c8	83 b8 b0 07 00
	00 00		 cmp	 DWORD PTR [rax+1968], 0
  019cf	7e 0a		 jle	 SHORT $LN136@NP_update

; 1347 :                     n = 1;

  019d1	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR n$[rsp], 1
  019d9	eb 0f		 jmp	 SHORT $LN137@NP_update
$LN136@NP_update:

; 1348 :                 else if (n > 34)

  019db	83 7c 24 64 22	 cmp	 DWORD PTR n$[rsp], 34	; 00000022H
  019e0	7e 08		 jle	 SHORT $LN138@NP_update

; 1349 :                     n = 34;

  019e2	c7 44 24 64 22
	00 00 00	 mov	 DWORD PTR n$[rsp], 34	; 00000022H
$LN138@NP_update:
$LN137@NP_update:

; 1350 :                 set_color (n > 17 ? COLOR_WHITE : COLOR_LIGHT_GREY, COLOR_BLACK);

  019ea	83 7c 24 64 11	 cmp	 DWORD PTR n$[rsp], 17
  019ef	7e 0d		 jle	 SHORT $LN216@NP_update
  019f1	c7 84 24 f4 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR tv1034[rsp], 15
  019fc	eb 0b		 jmp	 SHORT $LN217@NP_update
$LN216@NP_update:
  019fe	c7 84 24 f4 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv1034[rsp], 8
$LN217@NP_update:
  01a09	33 d2		 xor	 edx, edx
  01a0b	0f b7 8c 24 f4
	00 00 00	 movzx	 ecx, WORD PTR tv1034[rsp]
  01a13	e8 00 00 00 00	 call	 set_color

; 1351 :                 set_pos (CPU_GRAPH_LINE+1+i, 6);

  01a18	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01a1c	83 c0 15	 add	 eax, 21
  01a1f	66 ba 06 00	 mov	 dx, 6
  01a23	0f b7 c8	 movzx	 ecx, ax
  01a26	e8 00 00 00 00	 call	 set_pos

; 1352 :                 fill_text ('*', n+3);

  01a2b	8b 44 24 64	 mov	 eax, DWORD PTR n$[rsp]
  01a2f	83 c0 03	 add	 eax, 3
  01a32	0f b7 d0	 movzx	 edx, ax
  01a35	b1 2a		 mov	 cl, 42			; 0000002aH
  01a37	e8 00 00 00 00	 call	 fill_text

; 1353 :                 fill_text (' ', 38);

  01a3c	66 ba 26 00	 mov	 dx, 38			; 00000026H
  01a40	b1 20		 mov	 cl, 32			; 00000020H
  01a42	e8 00 00 00 00	 call	 fill_text

; 1354 :                 NPcpugraphpct[i] = sysblk.regs[i]->cpupct;

  01a47	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01a4c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  01a53	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  01a5b	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  01a60	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPcpugraphpct
  01a67	8b 80 b0 07 00
	00		 mov	 eax, DWORD PTR [rax+1968]
  01a6d	89 04 8a	 mov	 DWORD PTR [rdx+rcx*4], eax
$LN134@NP_update:
$LN131@NP_update:
$LN127@NP_update:

; 1355 :             }
; 1356 : 
; 1357 :             set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  01a70	33 d2		 xor	 edx, edx
  01a72	66 b9 08 00	 mov	 cx, 8
  01a76	e8 00 00 00 00	 call	 set_color

; 1358 :         }

  01a7b	e9 9a fd ff ff	 jmp	 $LN29@NP_update
$LN30@NP_update:

; 1359 :         NPcpugraph_valid = 1;

  01a80	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPcpugraph_valid, 1
$LN125@NP_update:

; 1360 :     }
; 1361 : 
; 1362 :     /* Process devices */
; 1363 :     for (i = 0, dev = sysblk.firstdev; dev != NULL; i++, dev = dev->nextdev)

  01a8a	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  01a92	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01a99	48 8b 80 c0 11
	00 00		 mov	 rax, QWORD PTR [rax+4544]
  01aa0	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax
  01aa5	eb 18		 jmp	 SHORT $LN34@NP_update
$LN32@NP_update:
  01aa7	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01aab	ff c0		 inc	 eax
  01aad	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
  01ab1	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01ab6	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  01aba	48 89 44 24 68	 mov	 QWORD PTR dev$[rsp], rax
$LN34@NP_update:
  01abf	48 83 7c 24 68
	00		 cmp	 QWORD PTR dev$[rsp], 0
  01ac5	0f 84 c3 05 00
	00		 je	 $LN33@NP_update

; 1364 :     {
; 1365 :         if (i >= cons_rows - 3) break;

  01acb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  01ad1	83 e8 03	 sub	 eax, 3
  01ad4	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  01ad8	7c 05		 jl	 SHORT $LN139@NP_update
  01ada	e9 af 05 00 00	 jmp	 $LN33@NP_update
$LN139@NP_update:

; 1366 :         if (!dev->allocated) continue;

  01adf	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01ae4	83 78 40 00	 cmp	 DWORD PTR [rax+64], 0
  01ae8	75 02		 jne	 SHORT $LN140@NP_update
  01aea	eb bb		 jmp	 SHORT $LN32@NP_update
$LN140@NP_update:

; 1367 : 
; 1368 :         online = (dev->console && dev->connected) || strlen(dev->filename) > 0;

  01aec	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01af1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01af7	c1 e8 04	 shr	 eax, 4
  01afa	83 e0 01	 and	 eax, 1
  01afd	85 c0		 test	 eax, eax
  01aff	74 15		 je	 SHORT $LN218@NP_update
  01b01	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01b06	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01b0c	c1 e8 05	 shr	 eax, 5
  01b0f	83 e0 01	 and	 eax, 1
  01b12	85 c0		 test	 eax, eax
  01b14	75 25		 jne	 SHORT $LN219@NP_update
$LN218@NP_update:
  01b16	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01b1b	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  01b21	48 8b c8	 mov	 rcx, rax
  01b24	e8 00 00 00 00	 call	 strlen
  01b29	48 85 c0	 test	 rax, rax
  01b2c	77 0d		 ja	 SHORT $LN219@NP_update
  01b2e	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1077[rsp], 0
  01b39	eb 0b		 jmp	 SHORT $LN220@NP_update
$LN219@NP_update:
  01b3b	c7 84 24 f8 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1077[rsp], 1
$LN220@NP_update:
  01b46	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR tv1077[rsp]
  01b4d	89 84 24 8c 00
	00 00		 mov	 DWORD PTR online$[rsp], eax

; 1369 :         busy   = dev->busy != 0 || IOPENDING(dev) != 0;

  01b54	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01b59	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01b5f	c1 e8 13	 shr	 eax, 19
  01b62	83 e0 01	 and	 eax, 1
  01b65	85 c0		 test	 eax, eax
  01b67	0f 85 83 00 00
	00		 jne	 $LN223@NP_update
  01b6d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01b72	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01b78	c1 e8 16	 shr	 eax, 22
  01b7b	83 e0 01	 and	 eax, 1
  01b7e	85 c0		 test	 eax, eax
  01b80	75 4c		 jne	 SHORT $LN221@NP_update
  01b82	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01b87	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01b8d	c1 e8 17	 shr	 eax, 23
  01b90	83 e0 01	 and	 eax, 1
  01b93	85 c0		 test	 eax, eax
  01b95	75 37		 jne	 SHORT $LN221@NP_update
  01b97	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01b9c	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01ba2	c1 e8 18	 shr	 eax, 24
  01ba5	83 e0 01	 and	 eax, 1
  01ba8	85 c0		 test	 eax, eax
  01baa	75 22		 jne	 SHORT $LN221@NP_update
  01bac	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01bb1	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01bb7	c1 e8 1b	 shr	 eax, 27
  01bba	83 e0 01	 and	 eax, 1
  01bbd	85 c0		 test	 eax, eax
  01bbf	75 0d		 jne	 SHORT $LN221@NP_update
  01bc1	c7 84 24 fc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1098[rsp], 0
  01bcc	eb 0b		 jmp	 SHORT $LN222@NP_update
$LN221@NP_update:
  01bce	c7 84 24 fc 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1098[rsp], 1
$LN222@NP_update:
  01bd9	83 bc 24 fc 00
	00 00 00	 cmp	 DWORD PTR tv1098[rsp], 0
  01be1	75 0d		 jne	 SHORT $LN223@NP_update
  01be3	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1100[rsp], 0
  01bee	eb 0b		 jmp	 SHORT $LN224@NP_update
$LN223@NP_update:
  01bf0	c7 84 24 00 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1100[rsp], 1
$LN224@NP_update:
  01bfb	8b 84 24 00 01
	00 00		 mov	 eax, DWORD PTR tv1100[rsp]
  01c02	89 84 24 90 00
	00 00		 mov	 DWORD PTR busy$[rsp], eax

; 1370 :         open   = dev->fd > 2;

  01c09	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01c0e	83 b8 ac 01 00
	00 02		 cmp	 DWORD PTR [rax+428], 2
  01c15	7e 0d		 jle	 SHORT $LN225@NP_update
  01c17	c7 84 24 04 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1103[rsp], 1
  01c22	eb 0b		 jmp	 SHORT $LN226@NP_update
$LN225@NP_update:
  01c24	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1103[rsp], 0
$LN226@NP_update:
  01c2f	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR tv1103[rsp]
  01c36	89 84 24 94 00
	00 00		 mov	 DWORD PTR open$[rsp], eax

; 1371 : 
; 1372 :         /* device identifier */
; 1373 :         if (!NPdevices_valid || online != NPonline[i])

  01c3d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdevices_valid, 0
  01c44	74 1c		 je	 SHORT $LN142@NP_update
  01c46	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01c4b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPonline
  01c52	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01c55	39 84 24 8c 00
	00 00		 cmp	 DWORD PTR online$[rsp], eax
  01c5c	0f 84 88 00 00
	00		 je	 $LN141@NP_update
$LN142@NP_update:

; 1374 :         {
; 1375 :             set_pos (DEV_LINE+i, 41);

  01c62	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01c66	83 c0 03	 add	 eax, 3
  01c69	66 ba 29 00	 mov	 dx, 41			; 00000029H
  01c6d	0f b7 c8	 movzx	 ecx, ax
  01c70	e8 00 00 00 00	 call	 set_pos

; 1376 :             set_color (online ? COLOR_LIGHT_GREEN : COLOR_LIGHT_GREY, COLOR_BLACK);

  01c75	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR online$[rsp], 0
  01c7d	74 0d		 je	 SHORT $LN227@NP_update
  01c7f	c7 84 24 08 01
	00 00 0a 00 00
	00		 mov	 DWORD PTR tv1115[rsp], 10
  01c8a	eb 0b		 jmp	 SHORT $LN228@NP_update
$LN227@NP_update:
  01c8c	c7 84 24 08 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv1115[rsp], 8
$LN228@NP_update:
  01c97	33 d2		 xor	 edx, edx
  01c99	0f b7 8c 24 08
	01 00 00	 movzx	 ecx, WORD PTR tv1115[rsp]
  01ca1	e8 00 00 00 00	 call	 set_color

; 1377 :             draw_char (i < 26 ? 'A' + i : '.');

  01ca6	83 7c 24 60 1a	 cmp	 DWORD PTR i$[rsp], 26
  01cab	7d 10		 jge	 SHORT $LN229@NP_update
  01cad	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01cb1	83 c0 41	 add	 eax, 65			; 00000041H
  01cb4	89 84 24 0c 01
	00 00		 mov	 DWORD PTR tv1120[rsp], eax
  01cbb	eb 0b		 jmp	 SHORT $LN230@NP_update
$LN229@NP_update:
  01cbd	c7 84 24 0c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv1120[rsp], 46 ; 0000002eH
$LN230@NP_update:
  01cc8	8b 8c 24 0c 01
	00 00		 mov	 ecx, DWORD PTR tv1120[rsp]
  01ccf	e8 00 00 00 00	 call	 draw_char

; 1378 :             NPonline[i] = online;

  01cd4	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01cd9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPonline
  01ce0	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR online$[rsp]
  01ce7	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN141@NP_update:

; 1379 :         }
; 1380 : 
; 1381 :         /* device number */
; 1382 :         if (!NPdevices_valid || dev->devnum != NPdevnum[i] || NPbusy[i] != busy)

  01cea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdevices_valid, 0
  01cf1	74 39		 je	 SHORT $LN144@NP_update
  01cf3	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01cf8	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01cfc	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  01d01	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPdevnum
  01d08	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  01d0c	3b c1		 cmp	 eax, ecx
  01d0e	75 1c		 jne	 SHORT $LN144@NP_update
  01d10	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01d15	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPbusy
  01d1c	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR busy$[rsp]
  01d23	39 14 81	 cmp	 DWORD PTR [rcx+rax*4], edx
  01d26	0f 84 d8 00 00
	00		 je	 $LN143@NP_update
$LN144@NP_update:

; 1383 :         {
; 1384 :             set_pos (DEV_LINE+i, 43);

  01d2c	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01d30	83 c0 03	 add	 eax, 3
  01d33	66 ba 2b 00	 mov	 dx, 43			; 0000002bH
  01d37	0f b7 c8	 movzx	 ecx, ax
  01d3a	e8 00 00 00 00	 call	 set_pos

; 1385 :             set_color (busy ? COLOR_LIGHT_YELLOW : COLOR_LIGHT_GREY, COLOR_BLACK);

  01d3f	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR busy$[rsp], 0
  01d47	74 0d		 je	 SHORT $LN231@NP_update
  01d49	c7 84 24 10 01
	00 00 0e 00 00
	00		 mov	 DWORD PTR tv1143[rsp], 14
  01d54	eb 0b		 jmp	 SHORT $LN232@NP_update
$LN231@NP_update:
  01d56	c7 84 24 10 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv1143[rsp], 8
$LN232@NP_update:
  01d61	33 d2		 xor	 edx, edx
  01d63	0f b7 8c 24 10
	01 00 00	 movzx	 ecx, WORD PTR tv1143[rsp]
  01d6b	e8 00 00 00 00	 call	 set_color

; 1386 :             if (dev == sysblk.sysgdev)

  01d70	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01d77	48 8b 80 c8 11
	00 00		 mov	 rax, QWORD PTR [rax+4552]
  01d7e	48 39 44 24 68	 cmp	 QWORD PTR dev$[rsp], rax
  01d83	75 1d		 jne	 SHORT $LN145@NP_update

; 1387 :                 STRLCPY( buf, "SYSG" );

  01d85	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  01d8b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168898
  01d92	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01d9a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  01da0	eb 26		 jmp	 SHORT $LN146@NP_update
$LN145@NP_update:

; 1388 :             else
; 1389 :                 MSGBUF (buf, "%4.4X", dev->devnum);

  01da2	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01da7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01dab	44 8b c8	 mov	 r9d, eax
  01dae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168899
  01db5	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  01dba	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01dc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN146@NP_update:

; 1390 :             draw_text (buf);

  01dc8	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01dd0	e8 00 00 00 00	 call	 draw_text

; 1391 :             NPdevnum[i] = dev->devnum;

  01dd5	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01dda	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnum
  01de1	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  01de6	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  01dea	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 1392 :             NPbusy[i] = busy;

  01dee	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01df3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPbusy
  01dfa	8b 94 24 90 00
	00 00		 mov	 edx, DWORD PTR busy$[rsp]
  01e01	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN143@NP_update:

; 1393 :         }
; 1394 : 
; 1395 :         /* device type */
; 1396 :         if (!NPdevices_valid || dev->devtype != NPdevtype[i] || open != NPopen[i])

  01e04	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdevices_valid, 0
  01e0b	74 39		 je	 SHORT $LN148@NP_update
  01e0d	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01e12	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01e16	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR i$[rsp]
  01e1b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPdevtype
  01e22	0f b7 0c 4a	 movzx	 ecx, WORD PTR [rdx+rcx*2]
  01e26	3b c1		 cmp	 eax, ecx
  01e28	75 1c		 jne	 SHORT $LN148@NP_update
  01e2a	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01e2f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPopen
  01e36	8b 04 81	 mov	 eax, DWORD PTR [rcx+rax*4]
  01e39	39 84 24 94 00
	00 00		 cmp	 DWORD PTR open$[rsp], eax
  01e40	0f 84 a6 00 00
	00		 je	 $LN147@NP_update
$LN148@NP_update:

; 1397 :         {
; 1398 :             set_pos (DEV_LINE+i, 48);

  01e46	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01e4a	83 c0 03	 add	 eax, 3
  01e4d	66 ba 30 00	 mov	 dx, 48			; 00000030H
  01e51	0f b7 c8	 movzx	 ecx, ax
  01e54	e8 00 00 00 00	 call	 set_pos

; 1399 :             set_color (open ? COLOR_LIGHT_GREEN : COLOR_LIGHT_GREY, COLOR_BLACK);

  01e59	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR open$[rsp], 0
  01e61	74 0d		 je	 SHORT $LN233@NP_update
  01e63	c7 84 24 14 01
	00 00 0a 00 00
	00		 mov	 DWORD PTR tv1183[rsp], 10
  01e6e	eb 0b		 jmp	 SHORT $LN234@NP_update
$LN233@NP_update:
  01e70	c7 84 24 14 01
	00 00 08 00 00
	00		 mov	 DWORD PTR tv1183[rsp], 8
$LN234@NP_update:
  01e7b	33 d2		 xor	 edx, edx
  01e7d	0f b7 8c 24 14
	01 00 00	 movzx	 ecx, WORD PTR tv1183[rsp]
  01e85	e8 00 00 00 00	 call	 set_color

; 1400 :             MSGBUF (buf, "%4.4X", dev->devtype);

  01e8a	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01e8f	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01e93	44 8b c8	 mov	 r9d, eax
  01e96	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168902
  01e9d	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  01ea2	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01eaa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1401 :             draw_text (buf);

  01eb0	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01eb8	e8 00 00 00 00	 call	 draw_text

; 1402 :             NPdevtype[i] = dev->devtype;

  01ebd	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01ec2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevtype
  01ec9	48 8b 54 24 68	 mov	 rdx, QWORD PTR dev$[rsp]
  01ece	0f b7 52 4a	 movzx	 edx, WORD PTR [rdx+74]
  01ed2	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx

; 1403 :             NPopen[i] = open;

  01ed6	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01edb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPopen
  01ee2	8b 94 24 94 00
	00 00		 mov	 edx, DWORD PTR open$[rsp]
  01ee9	89 14 81	 mov	 DWORD PTR [rcx+rax*4], edx
$LN147@NP_update:

; 1404 :         }
; 1405 : 
; 1406 :         /* device class and name */
; 1407 :         (dev->hnd->query)(dev, &devclass, sizeof(devnam), devnam);

  01eec	48 8b 44 24 68	 mov	 rax, QWORD PTR dev$[rsp]
  01ef1	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01ef8	4c 8d 8c 24 90
	01 00 00	 lea	 r9, QWORD PTR devnam$[rsp]
  01f00	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  01f06	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR devclass$[rsp]
  01f0e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR dev$[rsp]
  01f13	ff 50 18	 call	 QWORD PTR [rax+24]

; 1408 :         if (!NPdevices_valid || strcmp(NPdevnam[i], devnam))

  01f16	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdevices_valid, 0
  01f1d	74 31		 je	 SHORT $LN150@NP_update
  01f1f	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  01f24	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  01f2b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnam
  01f32	48 03 c8	 add	 rcx, rax
  01f35	48 8b c1	 mov	 rax, rcx
  01f38	48 8d 94 24 90
	01 00 00	 lea	 rdx, QWORD PTR devnam$[rsp]
  01f40	48 8b c8	 mov	 rcx, rax
  01f43	e8 00 00 00 00	 call	 strcmp
  01f48	85 c0		 test	 eax, eax
  01f4a	0f 84 39 01 00
	00		 je	 $LN149@NP_update
$LN150@NP_update:

; 1409 :         {
; 1410 :             set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  01f50	33 d2		 xor	 edx, edx
  01f52	66 b9 08 00	 mov	 cx, 8
  01f56	e8 00 00 00 00	 call	 set_color

; 1411 :             set_pos (DEV_LINE+i, 53);

  01f5b	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01f5f	83 c0 03	 add	 eax, 3
  01f62	66 ba 35 00	 mov	 dx, 53			; 00000035H
  01f66	0f b7 c8	 movzx	 ecx, ax
  01f69	e8 00 00 00 00	 call	 set_pos

; 1412 :             MSGBUF (buf, "%-4.4s", devclass);

  01f6e	4c 8b 8c 24 70
	01 00 00	 mov	 r9, QWORD PTR devclass$[rsp]
  01f76	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168905
  01f7d	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  01f82	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01f8a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1413 :             draw_text (buf);

  01f90	48 8d 8c 24 a0
	02 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  01f98	e8 00 00 00 00	 call	 draw_text

; 1414 :             /* Draw device name only if they're NOT assigning a new one */
; 1415 :             if (0
; 1416 :                 || NPdataentry != 1
; 1417 :                 || NPpending != 'n'
; 1418 :                 || NPasgn != i

  01f9d	33 c0		 xor	 eax, eax
  01f9f	85 c0		 test	 eax, eax
  01fa1	75 25		 jne	 SHORT $LN152@NP_update
  01fa3	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPdataentry, 1
  01faa	75 1c		 jne	 SHORT $LN152@NP_update
  01fac	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPpending
  01fb3	83 f8 6e	 cmp	 eax, 110		; 0000006eH
  01fb6	75 10		 jne	 SHORT $LN152@NP_update
  01fb8	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  01fbc	39 05 00 00 00
	00		 cmp	 DWORD PTR NPasgn, eax
  01fc2	0f 84 c1 00 00
	00		 je	 $LN151@NP_update
$LN152@NP_update:

; 1419 :             )
; 1420 :             {
; 1421 :                 /* locate first nonprintable and truncate */
; 1422 :                 int l, p;
; 1423 : 
; 1424 :                 l = (int)strlen(devnam);

  01fc8	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR devnam$[rsp]
  01fd0	e8 00 00 00 00	 call	 strlen
  01fd5	89 84 24 50 01
	00 00		 mov	 DWORD PTR l$2[rsp], eax

; 1425 :                 for ( p = 0; p < l; p++ )

  01fdc	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR p$1[rsp], 0
  01fe7	eb 10		 jmp	 SHORT $LN37@NP_update
$LN35@NP_update:
  01fe9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR p$1[rsp]
  01ff0	ff c0		 inc	 eax
  01ff2	89 84 24 80 00
	00 00		 mov	 DWORD PTR p$1[rsp], eax
$LN37@NP_update:
  01ff9	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR l$2[rsp]
  02000	39 84 24 80 00
	00 00		 cmp	 DWORD PTR p$1[rsp], eax
  02007	7d 55		 jge	 SHORT $LN36@NP_update

; 1426 :                 {
; 1427 :                     if ( !isprint(devnam[p]) )

  02009	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR p$1[rsp]
  02011	0f be 84 04 90
	01 00 00	 movsx	 eax, BYTE PTR devnam$[rsp+rax]
  02019	8b c8		 mov	 ecx, eax
  0201b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  02021	85 c0		 test	 eax, eax
  02023	75 37		 jne	 SHORT $LN153@NP_update

; 1428 :                     {
; 1429 :                         devnam[p] = '\0';

  02025	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR p$1[rsp]
  0202d	48 89 84 24 58
	01 00 00	 mov	 QWORD PTR $T3[rsp], rax
  02035	48 81 bc 24 58
	01 00 00 04 01
	00 00		 cmp	 QWORD PTR $T3[rsp], 260	; 00000104H
  02041	73 02		 jae	 SHORT $LN235@NP_update
  02043	eb 05		 jmp	 SHORT $LN236@NP_update
$LN235@NP_update:
  02045	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN236@NP_update:
  0204a	48 8b 84 24 58
	01 00 00	 mov	 rax, QWORD PTR $T3[rsp]
  02052	c6 84 04 90 01
	00 00 00	 mov	 BYTE PTR devnam$[rsp+rax], 0

; 1430 :                         break;

  0205a	eb 02		 jmp	 SHORT $LN36@NP_update
$LN153@NP_update:

; 1431 :                     }
; 1432 :                 }

  0205c	eb 8b		 jmp	 SHORT $LN35@NP_update
$LN36@NP_update:

; 1433 :                 set_pos (DEV_LINE+i, 58);

  0205e	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  02062	83 c0 03	 add	 eax, 3
  02065	66 ba 3a 00	 mov	 dx, 58			; 0000003aH
  02069	0f b7 c8	 movzx	 ecx, ax
  0206c	e8 00 00 00 00	 call	 set_pos

; 1434 :                 draw_text (devnam);

  02071	48 8d 8c 24 90
	01 00 00	 lea	 rcx, QWORD PTR devnam$[rsp]
  02079	e8 00 00 00 00	 call	 draw_text

; 1435 :                 fill_text (' ', PANEL_MAX_COLS);

  0207e	66 ba 00 01	 mov	 dx, 256			; 00000100H
  02082	b1 20		 mov	 cl, 32			; 00000020H
  02084	e8 00 00 00 00	 call	 fill_text
$LN151@NP_update:
$LN149@NP_update:

; 1436 :             }
; 1437 :         }
; 1438 :     }

  02089	e9 19 fa ff ff	 jmp	 $LN32@NP_update
$LN33@NP_update:

; 1439 : 
; 1440 :     /* Complete the device state table */
; 1441 :     if (!NPdevices_valid)

  0208e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdevices_valid, 0
  02095	0f 85 e3 00 00
	00		 jne	 $LN154@NP_update

; 1442 :     {
; 1443 :         NPlastdev = i > 26 ? 26 : i - 1;

  0209b	83 7c 24 60 1a	 cmp	 DWORD PTR i$[rsp], 26
  020a0	7e 0d		 jle	 SHORT $LN237@NP_update
  020a2	c7 84 24 18 01
	00 00 1a 00 00
	00		 mov	 DWORD PTR tv1255[rsp], 26
  020ad	eb 0d		 jmp	 SHORT $LN238@NP_update
$LN237@NP_update:
  020af	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  020b3	ff c8		 dec	 eax
  020b5	89 84 24 18 01
	00 00		 mov	 DWORD PTR tv1255[rsp], eax
$LN238@NP_update:
  020bc	8b 84 24 18 01
	00 00		 mov	 eax, DWORD PTR tv1255[rsp]
  020c3	89 05 00 00 00
	00		 mov	 DWORD PTR NPlastdev, eax

; 1444 :         for ( ; i < NP_MAX_DEVICES; i++)

  020c9	eb 0a		 jmp	 SHORT $LN40@NP_update
$LN38@NP_update:
  020cb	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  020cf	ff c0		 inc	 eax
  020d1	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN40@NP_update:
  020d5	81 7c 24 60 fd
	00 00 00	 cmp	 DWORD PTR i$[rsp], 253	; 000000fdH
  020dd	0f 8d 91 00 00
	00		 jge	 $LN39@NP_update

; 1445 :         {
; 1446 :             NPonline[i] = NPdevnum[i] = NPbusy[i] = NPdevtype[i] = NPopen[i] = 0;

  020e3	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  020e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPopen
  020ef	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  020f6	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  020fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevtype
  02102	33 d2		 xor	 edx, edx
  02104	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  02108	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  0210d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPbusy
  02114	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0
  0211b	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  02120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnum
  02127	33 d2		 xor	 edx, edx
  02129	66 89 14 41	 mov	 WORD PTR [rcx+rax*2], dx
  0212d	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  02132	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPonline
  02139	c7 04 81 00 00
	00 00		 mov	 DWORD PTR [rcx+rax*4], 0

; 1447 :             STRLCPY( NPdevnam[i], "" );

  02140	48 63 44 24 60	 movsxd	 rax, DWORD PTR i$[rsp]
  02145	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  0214c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnam
  02153	48 03 c8	 add	 rcx, rax
  02156	48 8b c1	 mov	 rax, rcx
  02159	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  0215f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168910
  02166	48 8b c8	 mov	 rcx, rax
  02169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1448 :         }

  0216f	e9 57 ff ff ff	 jmp	 $LN38@NP_update
$LN39@NP_update:

; 1449 :         NPdevices_valid = 1;

  02174	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdevices_valid, 1
$LN154@NP_update:

; 1450 :     }
; 1451 : 
; 1452 :     /* Prompt 1 */
; 1453 :     if (strcmp(NPprompt1, NPoldprompt1))

  0217e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPoldprompt1
  02185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  0218c	e8 00 00 00 00	 call	 strcmp
  02191	85 c0		 test	 eax, eax
  02193	0f 84 9f 00 00
	00		 je	 $LN155@NP_update

; 1454 :     {
; 1455 :         STRLCPY( NPoldprompt1, NPprompt1 );

  02199	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  0219f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPprompt1
  021a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPoldprompt1
  021ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1456 :         if (strlen(NPprompt1) > 0)

  021b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  021ba	e8 00 00 00 00	 call	 strlen
  021bf	48 85 c0	 test	 rax, rax
  021c2	76 45		 jbe	 SHORT $LN156@NP_update

; 1457 :         {
; 1458 :             set_color (COLOR_WHITE, COLOR_BLUE);

  021c4	66 ba 03 00	 mov	 dx, 3
  021c8	66 b9 0f 00	 mov	 cx, 15
  021cc	e8 00 00 00 00	 call	 set_color

; 1459 :             set_pos (cons_rows, (40 - (short)strlen(NPprompt1)) / 2);

  021d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  021d8	e8 00 00 00 00	 call	 strlen
  021dd	98		 cwde
  021de	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  021e3	2b c8		 sub	 ecx, eax
  021e5	8b c1		 mov	 eax, ecx
  021e7	99		 cdq
  021e8	2b c2		 sub	 eax, edx
  021ea	d1 f8		 sar	 eax, 1
  021ec	0f b7 d0	 movzx	 edx, ax
  021ef	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  021f6	e8 00 00 00 00	 call	 set_pos

; 1460 :             draw_text (NPprompt1);

  021fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  02202	e8 00 00 00 00	 call	 draw_text

; 1461 :         }

  02207	eb 2f		 jmp	 SHORT $LN157@NP_update
$LN156@NP_update:

; 1462 :         else if (cons_rows >= 24)

  02209	83 3d 00 00 00
	00 18		 cmp	 DWORD PTR cons_rows, 24
  02210	7c 26		 jl	 SHORT $LN158@NP_update

; 1463 :         {
; 1464 :             set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  02212	33 d2		 xor	 edx, edx
  02214	66 b9 08 00	 mov	 cx, 8
  02218	e8 00 00 00 00	 call	 set_color

; 1465 :             set_pos (cons_rows, 1);

  0221d	66 ba 01 00	 mov	 dx, 1
  02221	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  02228	e8 00 00 00 00	 call	 set_pos

; 1466 :             fill_text ('-', 38);

  0222d	66 ba 26 00	 mov	 dx, 38			; 00000026H
  02231	b1 2d		 mov	 cl, 45			; 0000002dH
  02233	e8 00 00 00 00	 call	 fill_text
$LN158@NP_update:
$LN157@NP_update:
$LN155@NP_update:

; 1467 :         }
; 1468 :     }
; 1469 : 
; 1470 :     /* Prompt 2 */
; 1471 :     if (strcmp(NPprompt2, NPoldprompt2))

  02238	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPoldprompt2
  0223f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  02246	e8 00 00 00 00	 call	 strcmp
  0224b	85 c0		 test	 eax, eax
  0224d	0f 84 88 00 00
	00		 je	 $LN159@NP_update

; 1472 :     {
; 1473 :         STRLCPY( NPoldprompt2, NPprompt2 );

  02253	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  02259	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:NPprompt2
  02260	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPoldprompt2
  02267	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 1474 :         if (strlen(NPprompt2) > 0)

  0226d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  02274	e8 00 00 00 00	 call	 strlen
  02279	48 85 c0	 test	 rax, rax
  0227c	76 2b		 jbe	 SHORT $LN160@NP_update

; 1475 :         {
; 1476 :             set_color(COLOR_WHITE, COLOR_BLUE);

  0227e	66 ba 03 00	 mov	 dx, 3
  02282	66 b9 0f 00	 mov	 cx, 15
  02286	e8 00 00 00 00	 call	 set_color

; 1477 :             set_pos(cons_rows, 41);

  0228b	66 ba 29 00	 mov	 dx, 41			; 00000029H
  0228f	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  02296	e8 00 00 00 00	 call	 set_pos

; 1478 :             draw_text(NPprompt2);

  0229b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  022a2	e8 00 00 00 00	 call	 draw_text

; 1479 :         }

  022a7	eb 32		 jmp	 SHORT $LN161@NP_update
$LN160@NP_update:

; 1480 :         else if (cons_rows >= 24)

  022a9	83 3d 00 00 00
	00 18		 cmp	 DWORD PTR cons_rows, 24
  022b0	7c 29		 jl	 SHORT $LN162@NP_update

; 1481 :         {
; 1482 :             set_color( COLOR_LIGHT_GREY, COLOR_BLACK );

  022b2	33 d2		 xor	 edx, edx
  022b4	66 b9 08 00	 mov	 cx, 8
  022b8	e8 00 00 00 00	 call	 set_color

; 1483 :             set_pos( cons_rows, 41) ;

  022bd	66 ba 29 00	 mov	 dx, 41			; 00000029H
  022c1	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  022c8	e8 00 00 00 00	 call	 set_pos

; 1484 :             fill_text( '-', cons_cols );

  022cd	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  022d4	b1 2d		 mov	 cl, 45			; 0000002dH
  022d6	e8 00 00 00 00	 call	 fill_text
$LN162@NP_update:
$LN161@NP_update:
$LN159@NP_update:

; 1485 :         }
; 1486 :     }
; 1487 : 
; 1488 :     /* Data entry field */
; 1489 :     if (NPdataentry && redraw_cmd)

  022db	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdataentry, 0
  022e2	0f 84 4a 01 00
	00		 je	 $LN163@NP_update
  022e8	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_cmd, 0
  022ef	0f 84 3d 01 00
	00		 je	 $LN163@NP_update

; 1490 :     {
; 1491 :         set_pos (NPcurrow, NPcurcol);

  022f5	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR NPcurcol
  022fc	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR NPcurrow
  02303	e8 00 00 00 00	 call	 set_pos

; 1492 :         if (NPcolorSwitch)

  02308	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPcolorSwitch, 0
  0230f	74 13		 je	 SHORT $LN165@NP_update

; 1493 :             set_color (NPcolorFore, NPcolorBack);

  02311	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR NPcolorBack
  02318	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR NPcolorFore
  0231f	e8 00 00 00 00	 call	 set_color
$LN165@NP_update:

; 1494 :         fill_text (' ', NPcurcol + NPdatalen - 1);

  02324	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR NPcurcol
  0232b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR NPdatalen
  02331	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  02335	0f b7 d0	 movzx	 edx, ax
  02338	b1 20		 mov	 cl, 32			; 00000020H
  0233a	e8 00 00 00 00	 call	 fill_text

; 1495 :         set_pos (NPcurrow, NPcurcol);

  0233f	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR NPcurcol
  02346	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR NPcurrow
  0234d	e8 00 00 00 00	 call	 set_pos
$LN43@NP_update:
$LN46@NP_update:

; 1496 :         PUTC_CMDLINE();

  02352	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  02358	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdcol, eax
  0235e	7e 5c		 jle	 SHORT $LN166@NP_update
$LN49@NP_update:
  02360	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168923
  02367	41 b8 d8 05 00
	00		 mov	 r8d, 1496		; 000005d8H
  0236d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168924
  02374	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168925
  0237b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  02381	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  02387	85 c0		 test	 eax, eax
  02389	74 20		 je	 SHORT $LN167@NP_update
  0238b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168927
  02392	41 b8 d8 05 00
	00		 mov	 r8d, 1496		; 000005d8H
  02398	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168928
  0239f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168929
  023a6	e8 00 00 00 00	 call	 DebuggerTrace
$LN167@NP_update:
  023ab	33 c0		 xor	 eax, eax
  023ad	85 c0		 test	 eax, eax
  023af	75 af		 jne	 SHORT $LN49@NP_update
  023b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  023b7	85 c0		 test	 eax, eax
  023b9	74 01		 je	 SHORT $LN168@NP_update
  023bb	cc		 int	 3
$LN168@NP_update:
$LN166@NP_update:
  023bc	33 c0		 xor	 eax, eax
  023be	85 c0		 test	 eax, eax
  023c0	75 90		 jne	 SHORT $LN46@NP_update
  023c2	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  023ca	eb 0a		 jmp	 SHORT $LN52@NP_update
$LN50@NP_update:
  023cc	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  023d0	ff c0		 inc	 eax
  023d2	89 44 24 60	 mov	 DWORD PTR i$[rsp], eax
$LN52@NP_update:
  023d6	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  023da	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdcol
  023e0	03 c8		 add	 ecx, eax
  023e2	8b c1		 mov	 eax, ecx
  023e4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdlen
  023ea	7d 30		 jge	 SHORT $LN51@NP_update
  023ec	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  023f2	39 44 24 60	 cmp	 DWORD PTR i$[rsp], eax
  023f6	7d 24		 jge	 SHORT $LN51@NP_update
  023f8	8b 44 24 60	 mov	 eax, DWORD PTR i$[rsp]
  023fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdcol
  02402	03 c8		 add	 ecx, eax
  02404	8b c1		 mov	 eax, ecx
  02406	48 98		 cdqe
  02408	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  0240f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02413	8b c8		 mov	 ecx, eax
  02415	e8 00 00 00 00	 call	 draw_char
  0241a	eb b0		 jmp	 SHORT $LN50@NP_update
$LN51@NP_update:
  0241c	33 c0		 xor	 eax, eax
  0241e	85 c0		 test	 eax, eax
  02420	0f 85 2c ff ff
	ff		 jne	 $LN43@NP_update

; 1497 :         redraw_cmd = 0;

  02426	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR redraw_cmd, 0

; 1498 :     }

  02430	eb 13		 jmp	 SHORT $LN164@NP_update
$LN163@NP_update:

; 1499 :     else
; 1500 :         /* Position the cursor to the bottom right */
; 1501 :         set_pos(cons_rows, cons_cols);

  02432	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  02439	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  02440	e8 00 00 00 00	 call	 set_pos
$LN164@NP_update:
$LN1@NP_update:
$LN169@NP_update:

; 1502 : }

  02445	48 8b 8c 24 a0
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0244d	48 33 cc	 xor	 rcx, rsp
  02450	e8 00 00 00 00	 call	 __security_check_cookie
  02455	48 81 c4 b8 06
	00 00		 add	 rsp, 1720		; 000006b8H
  0245c	5f		 pop	 rdi
  0245d	5e		 pop	 rsi
  0245e	c3		 ret	 0
NP_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
maxg$ = 32
i$ = 36
grp$1 = 40
$T2 = 48
grps$ = 56
__$ArrayPad$ = 88
ic$ = 112
format_int PROC

; 898  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 899  :     static char     obfr[32];   /* Enough for displaying 2^64-1 */
; 900  :     char            grps[7][4]; /* 7 groups of 3 digits */
; 901  :     int             maxg=0;

  00018	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR maxg$[rsp], 0

; 902  :     int             i;
; 903  : 
; 904  :     STRLCPY( grps[0], "0" );

  00020	b8 04 00 00 00	 mov	 eax, 4
  00025	48 6b c0 00	 imul	 rax, rax, 0
  00029	48 8d 44 04 38	 lea	 rax, QWORD PTR grps$[rsp+rax]
  0002e	41 b8 04 00 00
	00		 mov	 r8d, 4
  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168700
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN2@format_int:

; 905  :     while(ic>0)

  00044	48 83 7c 24 70
	00		 cmp	 QWORD PTR ic$[rsp], 0
  0004a	0f 86 8b 00 00
	00		 jbe	 $LN3@format_int

; 906  :     {
; 907  :         int grp;
; 908  :         grp=ic%1000;

  00050	33 d2		 xor	 edx, edx
  00052	48 8b 44 24 70	 mov	 rax, QWORD PTR ic$[rsp]
  00057	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0005c	48 f7 f1	 div	 rcx
  0005f	48 8b c2	 mov	 rax, rdx
  00062	89 44 24 28	 mov	 DWORD PTR grp$1[rsp], eax

; 909  :         ic/=1000;

  00066	33 d2		 xor	 edx, edx
  00068	48 8b 44 24 70	 mov	 rax, QWORD PTR ic$[rsp]
  0006d	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00072	48 f7 f1	 div	 rcx
  00075	48 89 44 24 70	 mov	 QWORD PTR ic$[rsp], rax

; 910  :         if(ic==0)

  0007a	48 83 7c 24 70
	00		 cmp	 QWORD PTR ic$[rsp], 0
  00080	75 26		 jne	 SHORT $LN7@format_int

; 911  :         {
; 912  :             MSGBUF(grps[maxg],"%u",grp);

  00082	48 63 44 24 20	 movsxd	 rax, DWORD PTR maxg$[rsp]
  00087	48 8d 44 84 38	 lea	 rax, QWORD PTR grps$[rsp+rax*4]
  0008c	44 8b 4c 24 28	 mov	 r9d, DWORD PTR grp$1[rsp]
  00091	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168703
  00098	ba 04 00 00 00	 mov	 edx, 4
  0009d	48 8b c8	 mov	 rcx, rax
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 913  :         }

  000a6	eb 24		 jmp	 SHORT $LN8@format_int
$LN7@format_int:

; 914  :         else
; 915  :         {
; 916  :             MSGBUF(grps[maxg],"%3.3u",grp);

  000a8	48 63 44 24 20	 movsxd	 rax, DWORD PTR maxg$[rsp]
  000ad	48 8d 44 84 38	 lea	 rax, QWORD PTR grps$[rsp+rax*4]
  000b2	44 8b 4c 24 28	 mov	 r9d, DWORD PTR grp$1[rsp]
  000b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168704
  000be	ba 04 00 00 00	 mov	 edx, 4
  000c3	48 8b c8	 mov	 rcx, rax
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN8@format_int:

; 917  :         }
; 918  :         maxg++;

  000cc	8b 44 24 20	 mov	 eax, DWORD PTR maxg$[rsp]
  000d0	ff c0		 inc	 eax
  000d2	89 44 24 20	 mov	 DWORD PTR maxg$[rsp], eax

; 919  :     }

  000d6	e9 69 ff ff ff	 jmp	 $LN2@format_int
$LN3@format_int:

; 920  :     if(maxg) maxg--;

  000db	83 7c 24 20 00	 cmp	 DWORD PTR maxg$[rsp], 0
  000e0	74 0a		 je	 SHORT $LN9@format_int
  000e2	8b 44 24 20	 mov	 eax, DWORD PTR maxg$[rsp]
  000e6	ff c8		 dec	 eax
  000e8	89 44 24 20	 mov	 DWORD PTR maxg$[rsp], eax
$LN9@format_int:

; 921  :     obfr[0]=0;

  000ec	b8 01 00 00 00	 mov	 eax, 1
  000f1	48 6b c0 00	 imul	 rax, rax, 0
  000f5	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp], rax
  000fa	48 83 7c 24 30
	20		 cmp	 QWORD PTR $T2[rsp], 32	; 00000020H
  00100	73 02		 jae	 SHORT $LN12@format_int
  00102	eb 05		 jmp	 SHORT $LN13@format_int
$LN12@format_int:
  00104	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN13@format_int:
  00109	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?obfr@?1??format_int@@9@9
  00110	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T2[rsp]
  00115	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 922  :     for(i=maxg;i>=0;i--)

  00119	8b 44 24 20	 mov	 eax, DWORD PTR maxg$[rsp]
  0011d	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
  00121	eb 0a		 jmp	 SHORT $LN6@format_int
$LN4@format_int:
  00123	8b 44 24 24	 mov	 eax, DWORD PTR i$[rsp]
  00127	ff c8		 dec	 eax
  00129	89 44 24 24	 mov	 DWORD PTR i$[rsp], eax
$LN6@format_int:
  0012d	83 7c 24 24 00	 cmp	 DWORD PTR i$[rsp], 0
  00132	7c 43		 jl	 SHORT $LN5@format_int

; 923  :     {
; 924  :         STRLCAT( obfr, grps[i] );

  00134	48 63 44 24 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00139	48 8d 44 84 38	 lea	 rax, QWORD PTR grps$[rsp+rax*4]
  0013e	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00144	48 8b d0	 mov	 rdx, rax
  00147	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?obfr@?1??format_int@@9@9
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 925  :         if(i)

  00154	83 7c 24 24 00	 cmp	 DWORD PTR i$[rsp], 0
  00159	74 1a		 je	 SHORT $LN10@format_int

; 926  :         {
; 927  :             STRLCAT( obfr, "," );

  0015b	41 b8 20 00 00
	00		 mov	 r8d, 32			; 00000020H
  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168707
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?obfr@?1??format_int@@9@9
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN10@format_int:

; 928  :         }
; 929  :     }

  00175	eb ac		 jmp	 SHORT $LN4@format_int
$LN5@format_int:

; 930  :     return obfr;

  00177	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?obfr@?1??format_int@@9@9
$LN11@format_int:

; 931  : }

  0017e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00183	48 33 cc	 xor	 rcx, rsp
  00186	e8 00 00 00 00	 call	 __security_check_cookie
  0018b	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0018f	c3		 ret	 0
format_int ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
i$ = 48
line$ = 52
tv441 = 56
tv494 = 58
tv167 = 60
tv176 = 64
tv179 = 68
tv190 = 72
tv202 = 76
tv438 = 80
$T1 = 88
buf$ = 96
__$ArrayPad$ = 1120
regs$ = 1152
NP_screen_redraw PROC

; 660  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 78 04
	00 00		 sub	 rsp, 1144		; 00000478H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 60
	04 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 661  :     int  i, line;
; 662  :     char buf[1024];
; 663  : 
; 664  :     /* Force all data to be redrawn */
; 665  :     NPcpunum_valid   = NPcpupct_valid   = NPpsw_valid  =

  0001e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPsios_valid, 0
  00028	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPsios_valid
  0002e	89 05 00 00 00
	00		 mov	 DWORD PTR NPmips_valid, eax
  00034	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPmips_valid
  0003a	89 05 00 00 00
	00		 mov	 DWORD PTR NPcpugraph_valid, eax
  00040	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPcpugraph_valid
  00046	89 05 00 00 00
	00		 mov	 DWORD PTR NPdevices_valid, eax
  0004c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPdevices_valid
  00052	89 05 00 00 00
	00		 mov	 DWORD PTR NPdata_valid, eax
  00058	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPdata_valid
  0005e	89 05 00 00 00
	00		 mov	 DWORD PTR NPaddr_valid, eax
  00064	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPaddr_valid
  0006a	89 05 00 00 00
	00		 mov	 DWORD PTR NPregs_valid, eax
  00070	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPregs_valid
  00076	89 05 00 00 00
	00		 mov	 DWORD PTR NPpswstate_valid, eax
  0007c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPpswstate_valid
  00082	89 05 00 00 00
	00		 mov	 DWORD PTR NPpsw_valid, eax
  00088	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPpsw_valid
  0008e	89 05 00 00 00
	00		 mov	 DWORD PTR NPcpupct_valid, eax
  00094	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPcpupct_valid
  0009a	89 05 00 00 00
	00		 mov	 DWORD PTR NPcpunum_valid, eax

; 666  :     NPpswstate_valid = NPregs_valid     = NPaddr_valid =
; 667  :     NPdata_valid     = NPdevices_valid  = NPcpugraph_valid =
; 668  :     NPmips_valid     = NPsios_valid     = 0;
; 669  : 
; 670  : #if defined(_FEATURE_SIE)
; 671  :     if(regs->sie_active)

  000a0	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000a8	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  000ae	83 e0 01	 and	 eax, 1
  000b1	85 c0		 test	 eax, eax
  000b3	74 17		 je	 SHORT $LN14@NP_screen_

; 672  :         regs = GUESTREGS;

  000b5	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  000bd	48 8b 80 70 08
	00 00		 mov	 rax, QWORD PTR [rax+2160]
  000c4	48 89 84 24 80
	04 00 00	 mov	 QWORD PTR regs$[rsp], rax
$LN14@NP_screen_:

; 673  : #endif /*defined(_FEATURE_SIE)*/
; 674  : 
; 675  :     /*
; 676  :      * Draw the static parts of the NP screen
; 677  :      */
; 678  :     set_color (COLOR_LIGHT_GREY, COLOR_BLACK );

  000cc	33 d2		 xor	 edx, edx
  000ce	66 b9 08 00	 mov	 cx, 8
  000d2	e8 00 00 00 00	 call	 set_color

; 679  :     clr_screen ();

  000d7	e8 00 00 00 00	 call	 clr_screen

; 680  : 
; 681  :     /* Line 1 - title line */
; 682  :     set_color (COLOR_WHITE, COLOR_BLUE );

  000dc	66 ba 03 00	 mov	 dx, 3
  000e0	66 b9 0f 00	 mov	 cx, 15
  000e4	e8 00 00 00 00	 call	 set_color

; 683  :     set_pos   (1, 1);

  000e9	66 ba 01 00	 mov	 dx, 1
  000ed	66 b9 01 00	 mov	 cx, 1
  000f1	e8 00 00 00 00	 call	 set_pos

; 684  :     draw_text ("  Hercules");

  000f6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168625
  000fd	e8 00 00 00 00	 call	 draw_text

; 685  :     if (sysblk.hicpu)

  00102	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00109	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00110	74 31		 je	 SHORT $LN15@NP_screen_

; 686  :     {
; 687  :         fill_text (' ', 16);

  00112	66 ba 10 00	 mov	 dx, 16
  00116	b1 20		 mov	 cl, 32			; 00000020H
  00118	e8 00 00 00 00	 call	 fill_text

; 688  :         draw_text ("CPU:    %");

  0011d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168627
  00124	e8 00 00 00 00	 call	 draw_text

; 689  :         fill_text (' ', 30);

  00129	66 ba 1e 00	 mov	 dx, 30
  0012d	b1 20		 mov	 cl, 32			; 00000020H
  0012f	e8 00 00 00 00	 call	 fill_text

; 690  :         draw_text (get_arch_name( NULL ));

  00134	33 c9		 xor	 ecx, ecx
  00136	e8 00 00 00 00	 call	 get_arch_name
  0013b	48 8b c8	 mov	 rcx, rax
  0013e	e8 00 00 00 00	 call	 draw_text
$LN15@NP_screen_:

; 691  :     }
; 692  : 
; 693  :     set_color (COLOR_LIGHT_GREY, COLOR_BLUE);

  00143	66 ba 03 00	 mov	 dx, 3
  00147	66 b9 08 00	 mov	 cx, 8
  0014b	e8 00 00 00 00	 call	 set_color

; 694  :     fill_text (' ', 38);

  00150	66 ba 26 00	 mov	 dx, 38			; 00000026H
  00154	b1 20		 mov	 cl, 32			; 00000020H
  00156	e8 00 00 00 00	 call	 fill_text

; 695  :     draw_text ("| ");

  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168628
  00162	e8 00 00 00 00	 call	 draw_text

; 696  :     set_color (COLOR_WHITE, COLOR_BLUE);

  00167	66 ba 03 00	 mov	 dx, 3
  0016b	66 b9 0f 00	 mov	 cx, 15
  0016f	e8 00 00 00 00	 call	 set_color

; 697  : 
; 698  : #if defined( OPTION_SHARED_DEVICES )
; 699  : 
; 700  :     /* Center "Peripherals" on the right-hand-side */
; 701  :     i = 40 + MSGBUF(buf,

  00174	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017b	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  00182	44 8b c8	 mov	 r9d, eax
  00185	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168629
  0018c	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00191	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0019c	83 c0 28	 add	 eax, 40			; 00000028H
  0019f	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax

; 702  :                       "Peripherals [Shared Port %u]",
; 703  :                       sysblk.shrdport);
; 704  :     if ((cons_cols < i) || !sysblk.shrdport)

  001a3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001a7	39 05 00 00 00
	00		 cmp	 DWORD PTR cons_cols, eax
  001ad	7c 12		 jl	 SHORT $LN17@NP_screen_
  001af	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001b6	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  001bd	85 c0		 test	 eax, eax
  001bf	75 32		 jne	 SHORT $LN16@NP_screen_
$LN17@NP_screen_:

; 705  :         i = 52, buf[11] = 0;            /* Truncate string */

  001c1	c7 44 24 30 34
	00 00 00	 mov	 DWORD PTR i$[rsp], 52	; 00000034H
  001c9	b8 01 00 00 00	 mov	 eax, 1
  001ce	48 6b c0 0b	 imul	 rax, rax, 11
  001d2	48 89 44 24 58	 mov	 QWORD PTR $T1[rsp], rax
  001d7	48 81 7c 24 58
	00 04 00 00	 cmp	 QWORD PTR $T1[rsp], 1024 ; 00000400H
  001e0	73 02		 jae	 SHORT $LN33@NP_screen_
  001e2	eb 05		 jmp	 SHORT $LN34@NP_screen_
$LN33@NP_screen_:
  001e4	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN34@NP_screen_:
  001e9	48 8b 44 24 58	 mov	 rax, QWORD PTR $T1[rsp]
  001ee	c6 44 04 60 00	 mov	 BYTE PTR buf$[rsp+rax], 0
$LN16@NP_screen_:

; 706  :     if (cons_cols > i)                  /* Center string   */

  001f3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  001f7	39 05 00 00 00
	00		 cmp	 DWORD PTR cons_cols, eax
  001fd	7e 20		 jle	 SHORT $LN18@NP_screen_

; 707  :         fill_text (' ', 40 + ((cons_cols - i) / 2));

  001ff	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00203	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_cols
  00209	2b c8		 sub	 ecx, eax
  0020b	8b c1		 mov	 eax, ecx
  0020d	99		 cdq
  0020e	2b c2		 sub	 eax, edx
  00210	d1 f8		 sar	 eax, 1
  00212	83 c0 28	 add	 eax, 40			; 00000028H
  00215	0f b7 d0	 movzx	 edx, ax
  00218	b1 20		 mov	 cl, 32			; 00000020H
  0021a	e8 00 00 00 00	 call	 fill_text
$LN18@NP_screen_:

; 708  :     draw_text (buf);

  0021f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  00224	e8 00 00 00 00	 call	 draw_text

; 709  :     fill_text (' ', (short)cons_cols);

  00229	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  00230	b1 20		 mov	 cl, 32			; 00000020H
  00232	e8 00 00 00 00	 call	 fill_text

; 710  : 
; 711  : #endif
; 712  : 
; 713  :     /* Line 2 - peripheral headings */
; 714  :     set_pos (2, 41);

  00237	66 ba 29 00	 mov	 dx, 41			; 00000029H
  0023b	66 b9 02 00	 mov	 cx, 2
  0023f	e8 00 00 00 00	 call	 set_pos

; 715  :     set_color (COLOR_WHITE, COLOR_BLACK);

  00244	33 d2		 xor	 edx, edx
  00246	66 b9 0f 00	 mov	 cx, 15
  0024a	e8 00 00 00 00	 call	 set_color

; 716  :     draw_char ('U');

  0024f	b9 55 00 00 00	 mov	 ecx, 85			; 00000055H
  00254	e8 00 00 00 00	 call	 draw_char

; 717  :     set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  00259	33 d2		 xor	 edx, edx
  0025b	66 b9 08 00	 mov	 cx, 8
  0025f	e8 00 00 00 00	 call	 set_color

; 718  :     draw_text(" Addr Modl Type Assig");

  00264	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168633
  0026b	e8 00 00 00 00	 call	 draw_text

; 719  :     set_color (COLOR_WHITE, COLOR_BLACK);

  00270	33 d2		 xor	 edx, edx
  00272	66 b9 0f 00	 mov	 cx, 15
  00276	e8 00 00 00 00	 call	 set_color

; 720  :     draw_char ('n');

  0027b	b9 6e 00 00 00	 mov	 ecx, 110		; 0000006eH
  00280	e8 00 00 00 00	 call	 draw_char

; 721  :     set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  00285	33 d2		 xor	 edx, edx
  00287	66 b9 08 00	 mov	 cx, 8
  0028b	e8 00 00 00 00	 call	 set_color

; 722  :     draw_text("ment");

  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168634
  00297	e8 00 00 00 00	 call	 draw_text

; 723  : 
; 724  :     if (sysblk.hicpu)

  0029c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002a3	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  002aa	0f 84 c7 03 00
	00		 je	 $LN19@NP_screen_

; 725  :     {
; 726  :         /* PSW_LINE = PSW */
; 727  :         NPpswmode = (regs->arch_mode == ARCH_900_IDX);

  002b0	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002b8	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  002bc	75 0a		 jne	 SHORT $LN35@NP_screen_
  002be	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv167[rsp], 1
  002c6	eb 08		 jmp	 SHORT $LN36@NP_screen_
$LN35@NP_screen_:
  002c8	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN36@NP_screen_:
  002d0	8b 44 24 3c	 mov	 eax, DWORD PTR tv167[rsp]
  002d4	89 05 00 00 00
	00		 mov	 DWORD PTR NPpswmode, eax

; 728  :         NPpswzhost =

  002da	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPpswmode, 0
  002e1	75 36		 jne	 SHORT $LN37@NP_screen_
  002e3	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  002eb	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  002f1	d1 e8		 shr	 eax, 1
  002f3	83 e0 01	 and	 eax, 1
  002f6	85 c0		 test	 eax, eax
  002f8	74 1f		 je	 SHORT $LN37@NP_screen_
  002fa	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00302	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00309	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  0030d	75 0a		 jne	 SHORT $LN37@NP_screen_
  0030f	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv176[rsp], 1
  00317	eb 08		 jmp	 SHORT $LN38@NP_screen_
$LN37@NP_screen_:
  00319	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv176[rsp], 0
$LN38@NP_screen_:
  00321	8b 44 24 40	 mov	 eax, DWORD PTR tv176[rsp]
  00325	89 05 00 00 00
	00		 mov	 DWORD PTR NPpswzhost, eax

; 729  : #if defined(_FEATURE_SIE)
; 730  :                      !NPpswmode && SIE_MODE(regs) && HOSTREGS->arch_mode == ARCH_900_IDX;
; 731  : #else
; 732  :                      0;
; 733  : #endif /*defined(_FEATURE_SIE)*/
; 734  :         set_pos (PSW_LINE+1, NPpswmode || NPpswzhost ? 19 : 10);

  0032b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPpswmode, 0
  00332	75 13		 jne	 SHORT $LN39@NP_screen_
  00334	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPpswzhost, 0
  0033b	75 0a		 jne	 SHORT $LN39@NP_screen_
  0033d	c7 44 24 44 0a
	00 00 00	 mov	 DWORD PTR tv179[rsp], 10
  00345	eb 08		 jmp	 SHORT $LN40@NP_screen_
$LN39@NP_screen_:
  00347	c7 44 24 44 13
	00 00 00	 mov	 DWORD PTR tv179[rsp], 19
$LN40@NP_screen_:
  0034f	0f b7 54 24 44	 movzx	 edx, WORD PTR tv179[rsp]
  00354	66 b9 03 00	 mov	 cx, 3
  00358	e8 00 00 00 00	 call	 set_pos

; 735  :         draw_text ("PSW");

  0035d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168637
  00364	e8 00 00 00 00	 call	 draw_text

; 736  : 
; 737  :         /* Register area */
; 738  :         set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  00369	33 d2		 xor	 edx, edx
  0036b	66 b9 08 00	 mov	 cx, 8
  0036f	e8 00 00 00 00	 call	 set_color

; 739  :         NPregmode = (regs->arch_mode == ARCH_900_IDX && (NPregdisp == 0 || NPregdisp == 1));

  00374	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0037c	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  00380	75 1c		 jne	 SHORT $LN42@NP_screen_
  00382	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregdisp, 0
  00389	74 09		 je	 SHORT $LN41@NP_screen_
  0038b	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPregdisp, 1
  00392	75 0a		 jne	 SHORT $LN42@NP_screen_
$LN41@NP_screen_:
  00394	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv190[rsp], 1
  0039c	eb 08		 jmp	 SHORT $LN43@NP_screen_
$LN42@NP_screen_:
  0039e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
$LN43@NP_screen_:
  003a6	8b 44 24 48	 mov	 eax, DWORD PTR tv190[rsp]
  003aa	89 05 00 00 00
	00		 mov	 DWORD PTR NPregmode, eax

; 740  :         NPregzhost =

  003b0	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003b8	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  003bc	74 48		 je	 SHORT $LN44@NP_screen_
  003be	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003c6	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  003cc	d1 e8		 shr	 eax, 1
  003ce	83 e0 01	 and	 eax, 1
  003d1	85 c0		 test	 eax, eax
  003d3	74 31		 je	 SHORT $LN44@NP_screen_
  003d5	48 8b 84 24 80
	04 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  003dd	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  003e4	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  003e8	75 1c		 jne	 SHORT $LN44@NP_screen_
  003ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregdisp, 0
  003f1	74 09		 je	 SHORT $LN45@NP_screen_
  003f3	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPregdisp, 1
  003fa	75 0a		 jne	 SHORT $LN44@NP_screen_
$LN45@NP_screen_:
  003fc	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv202[rsp], 1
  00404	eb 08		 jmp	 SHORT $LN46@NP_screen_
$LN44@NP_screen_:
  00406	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv202[rsp], 0
$LN46@NP_screen_:
  0040e	8b 44 24 4c	 mov	 eax, DWORD PTR tv202[rsp]
  00412	89 05 00 00 00
	00		 mov	 DWORD PTR NPregzhost, eax

; 741  : #if defined(_FEATURE_SIE)
; 742  :                      (regs->arch_mode != ARCH_900_IDX
; 743  :                    && SIE_MODE(regs) && HOSTREGS->arch_mode == ARCH_900_IDX
; 744  :                    && (NPregdisp == 0 || NPregdisp == 1));
; 745  : #else
; 746  :                      0;
; 747  : #endif /*defined(_FEATURE_SIE)*/
; 748  :         if (NPregmode == 1 || NPregzhost)

  00418	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPregmode, 1
  0041f	74 09		 je	 SHORT $LN23@NP_screen_
  00421	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPregzhost, 0
  00428	74 7a		 je	 SHORT $LN21@NP_screen_
$LN23@NP_screen_:

; 749  :         {
; 750  :             for (i = 0; i < 8; i++)

  0042a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00432	eb 0a		 jmp	 SHORT $LN4@NP_screen_
$LN2@NP_screen_:
  00434	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00438	ff c0		 inc	 eax
  0043a	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN4@NP_screen_:
  0043e	83 7c 24 30 08	 cmp	 DWORD PTR i$[rsp], 8
  00443	7d 5a		 jge	 SHORT $LN3@NP_screen_

; 751  :             {
; 752  :                 set_pos (REGS_LINE+i, 1);

  00445	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00449	83 c0 05	 add	 eax, 5
  0044c	66 ba 01 00	 mov	 dx, 1
  00450	0f b7 c8	 movzx	 ecx, ax
  00453	e8 00 00 00 00	 call	 set_pos

; 753  :                 draw_text (NPregnum64[i*2]);

  00458	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0045c	03 c0		 add	 eax, eax
  0045e	48 98		 cdqe
  00460	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum64
  00467	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0046b	e8 00 00 00 00	 call	 draw_text

; 754  :                 set_pos (REGS_LINE+i, 20);

  00470	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00474	83 c0 05	 add	 eax, 5
  00477	66 ba 14 00	 mov	 dx, 20
  0047b	0f b7 c8	 movzx	 ecx, ax
  0047e	e8 00 00 00 00	 call	 set_pos

; 755  :                 draw_text (NPregnum64[i*2+1]);

  00483	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00487	8d 44 00 01	 lea	 eax, DWORD PTR [rax+rax+1]
  0048b	48 98		 cdqe
  0048d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum64
  00494	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00498	e8 00 00 00 00	 call	 draw_text

; 756  :             }

  0049d	eb 95		 jmp	 SHORT $LN2@NP_screen_
$LN3@NP_screen_:

; 757  :         }

  0049f	e9 e4 00 00 00	 jmp	 $LN22@NP_screen_
$LN21@NP_screen_:

; 758  :         else
; 759  :         {
; 760  :             for (i = 0; i < 4; i++)

  004a4	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  004ac	eb 0a		 jmp	 SHORT $LN7@NP_screen_
$LN5@NP_screen_:
  004ae	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004b2	ff c0		 inc	 eax
  004b4	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN7@NP_screen_:
  004b8	83 7c 24 30 04	 cmp	 DWORD PTR i$[rsp], 4
  004bd	0f 8d c5 00 00
	00		 jge	 $LN6@NP_screen_

; 761  :             {
; 762  :                 set_pos (i*2+(REGS_LINE+1),9);

  004c3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004c7	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  004cb	66 ba 09 00	 mov	 dx, 9
  004cf	0f b7 c8	 movzx	 ecx, ax
  004d2	e8 00 00 00 00	 call	 set_pos

; 763  :                 draw_text (NPregnum[i*4]);

  004d7	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004db	c1 e0 02	 shl	 eax, 2
  004de	48 98		 cdqe
  004e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  004e7	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004eb	e8 00 00 00 00	 call	 draw_text

; 764  :                 set_pos (i*2+(REGS_LINE+1),18);

  004f0	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  004f4	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  004f8	66 ba 12 00	 mov	 dx, 18
  004fc	0f b7 c8	 movzx	 ecx, ax
  004ff	e8 00 00 00 00	 call	 set_pos

; 765  :                 draw_text (NPregnum[i*4+1]);

  00504	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00508	8d 04 85 01 00
	00 00		 lea	 eax, DWORD PTR [rax*4+1]
  0050f	48 98		 cdqe
  00511	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  00518	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0051c	e8 00 00 00 00	 call	 draw_text

; 766  :                 set_pos (i*2+(REGS_LINE+1),27);

  00521	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00525	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  00529	66 ba 1b 00	 mov	 dx, 27
  0052d	0f b7 c8	 movzx	 ecx, ax
  00530	e8 00 00 00 00	 call	 set_pos

; 767  :                 draw_text (NPregnum[i*4+2]);

  00535	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00539	8d 04 85 02 00
	00 00		 lea	 eax, DWORD PTR [rax*4+2]
  00540	48 98		 cdqe
  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  00549	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0054d	e8 00 00 00 00	 call	 draw_text

; 768  :                 set_pos (i*2+(REGS_LINE+1),36);

  00552	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00556	8d 44 00 06	 lea	 eax, DWORD PTR [rax+rax+6]
  0055a	66 ba 24 00	 mov	 dx, 36			; 00000024H
  0055e	0f b7 c8	 movzx	 ecx, ax
  00561	e8 00 00 00 00	 call	 set_pos

; 769  :                 draw_text (NPregnum[i*4+3]);

  00566	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  0056a	8d 04 85 03 00
	00 00		 lea	 eax, DWORD PTR [rax*4+3]
  00571	48 98		 cdqe
  00573	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPregnum
  0057a	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0057e	e8 00 00 00 00	 call	 draw_text

; 770  :             }

  00583	e9 26 ff ff ff	 jmp	 $LN5@NP_screen_
$LN6@NP_screen_:
$LN22@NP_screen_:

; 771  :         }
; 772  : 
; 773  :         /* Register selection */
; 774  :         set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  00588	33 d2		 xor	 edx, edx
  0058a	66 b9 08 00	 mov	 cx, 8
  0058e	e8 00 00 00 00	 call	 set_color

; 775  :         set_pos ((REGS_LINE+8), 6);

  00593	66 ba 06 00	 mov	 dx, 6
  00597	66 b9 0d 00	 mov	 cx, 13
  0059b	e8 00 00 00 00	 call	 set_pos

; 776  :         draw_text ("GPR");

  005a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168641
  005a7	e8 00 00 00 00	 call	 draw_text

; 777  :         set_pos ((REGS_LINE+8), 14);

  005ac	66 ba 0e 00	 mov	 dx, 14
  005b0	66 b9 0d 00	 mov	 cx, 13
  005b4	e8 00 00 00 00	 call	 set_pos

; 778  :         draw_text ("CR");

  005b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168642
  005c0	e8 00 00 00 00	 call	 draw_text

; 779  :         set_pos ((REGS_LINE+8), 22);

  005c5	66 ba 16 00	 mov	 dx, 22
  005c9	66 b9 0d 00	 mov	 cx, 13
  005cd	e8 00 00 00 00	 call	 set_pos

; 780  :         draw_text ("AR");

  005d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168643
  005d9	e8 00 00 00 00	 call	 draw_text

; 781  :         set_pos ((REGS_LINE+8), 30);

  005de	66 ba 1e 00	 mov	 dx, 30
  005e2	66 b9 0d 00	 mov	 cx, 13
  005e6	e8 00 00 00 00	 call	 set_pos

; 782  :         draw_text ("FPR");

  005eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168644
  005f2	e8 00 00 00 00	 call	 draw_text

; 783  : 
; 784  :         /* Address and data */
; 785  :         set_pos (ADDR_LINE, 2);

  005f7	66 ba 02 00	 mov	 dx, 2
  005fb	66 b9 0f 00	 mov	 cx, 15
  005ff	e8 00 00 00 00	 call	 set_pos

; 786  :         draw_text ("ADD");

  00604	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168645
  0060b	e8 00 00 00 00	 call	 draw_text

; 787  :         set_color (COLOR_WHITE, COLOR_BLACK);

  00610	33 d2		 xor	 edx, edx
  00612	66 b9 0f 00	 mov	 cx, 15
  00616	e8 00 00 00 00	 call	 set_color

; 788  :         draw_char ('R');

  0061b	b9 52 00 00 00	 mov	 ecx, 82			; 00000052H
  00620	e8 00 00 00 00	 call	 draw_char

; 789  :         set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  00625	33 d2		 xor	 edx, edx
  00627	66 b9 08 00	 mov	 cx, 8
  0062b	e8 00 00 00 00	 call	 set_color

; 790  :         draw_text ("ESS:");

  00630	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168646
  00637	e8 00 00 00 00	 call	 draw_text

; 791  :         set_pos (ADDR_LINE, 22);

  0063c	66 ba 16 00	 mov	 dx, 22
  00640	66 b9 0f 00	 mov	 cx, 15
  00644	e8 00 00 00 00	 call	 set_pos

; 792  :         set_color (COLOR_WHITE, COLOR_BLACK);

  00649	33 d2		 xor	 edx, edx
  0064b	66 b9 0f 00	 mov	 cx, 15
  0064f	e8 00 00 00 00	 call	 set_color

; 793  :         draw_char ('D');

  00654	b9 44 00 00 00	 mov	 ecx, 68			; 00000044H
  00659	e8 00 00 00 00	 call	 draw_char

; 794  :         set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  0065e	33 d2		 xor	 edx, edx
  00660	66 b9 08 00	 mov	 cx, 8
  00664	e8 00 00 00 00	 call	 set_color

; 795  :         draw_text ("ATA:");

  00669	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168647
  00670	e8 00 00 00 00	 call	 draw_text

; 796  :     }

  00675	eb 2f		 jmp	 SHORT $LN20@NP_screen_
$LN19@NP_screen_:

; 797  :     else
; 798  :     {
; 799  :         set_pos (8, 12);

  00677	66 ba 0c 00	 mov	 dx, 12
  0067b	66 b9 08 00	 mov	 cx, 8
  0067f	e8 00 00 00 00	 call	 set_pos

; 800  :         set_color (COLOR_LIGHT_RED, COLOR_BLACK);

  00684	33 d2		 xor	 edx, edx
  00686	66 b9 09 00	 mov	 cx, 9
  0068a	e8 00 00 00 00	 call	 set_color

; 801  :         draw_text ("No CPUs defined");

  0068f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168648
  00696	e8 00 00 00 00	 call	 draw_text

; 802  :         set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  0069b	33 d2		 xor	 edx, edx
  0069d	66 b9 08 00	 mov	 cx, 8
  006a1	e8 00 00 00 00	 call	 set_color
$LN20@NP_screen_:

; 803  :     }
; 804  : 
; 805  :     /* separator */
; 806  :     set_pos (ADDR_LINE+1, 1);

  006a6	66 ba 01 00	 mov	 dx, 1
  006aa	66 b9 10 00	 mov	 cx, 16
  006ae	e8 00 00 00 00	 call	 set_pos

; 807  :     fill_text ('-', 38);

  006b3	66 ba 26 00	 mov	 dx, 38			; 00000026H
  006b7	b1 2d		 mov	 cl, 45			; 0000002dH
  006b9	e8 00 00 00 00	 call	 fill_text

; 808  : 
; 809  :     /* Buttons */
; 810  : 
; 811  :     if (sysblk.hicpu)

  006be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  006c5	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  006cc	0f 84 ba 00 00
	00		 je	 $LN24@NP_screen_

; 812  :     {
; 813  :         set_pos (BUTTONS_LINE, 16);

  006d2	66 ba 10 00	 mov	 dx, 16
  006d6	66 b9 11 00	 mov	 cx, 17
  006da	e8 00 00 00 00	 call	 set_pos

; 814  :         draw_button(COLOR_BLUE,  COLOR_LIGHT_GREY, COLOR_WHITE,  " ST", "O", " "  );

  006df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168650
  006e6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  006eb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168651
  006f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006f7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168652
  006fe	66 41 b8 0f 00	 mov	 r8w, 15
  00703	66 ba 08 00	 mov	 dx, 8
  00707	66 b9 03 00	 mov	 cx, 3
  0070b	e8 00 00 00 00	 call	 draw_button

; 815  :         set_pos (BUTTONS_LINE, 24);

  00710	66 ba 18 00	 mov	 dx, 24
  00714	66 b9 11 00	 mov	 cx, 17
  00718	e8 00 00 00 00	 call	 set_pos

; 816  :         draw_button(COLOR_BLUE,  COLOR_LIGHT_GREY, COLOR_WHITE,  " D",  "I", "S " );

  0071d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168653
  00724	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00729	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168654
  00730	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00735	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168655
  0073c	66 41 b8 0f 00	 mov	 r8w, 15
  00741	66 ba 08 00	 mov	 dx, 8
  00745	66 b9 03 00	 mov	 cx, 3
  00749	e8 00 00 00 00	 call	 draw_button

; 817  :         set_pos (BUTTONS_LINE, 32);

  0074e	66 ba 20 00	 mov	 dx, 32			; 00000020H
  00752	66 b9 11 00	 mov	 cx, 17
  00756	e8 00 00 00 00	 call	 set_pos

; 818  :         draw_button(COLOR_BLUE,  COLOR_LIGHT_GREY, COLOR_WHITE,  " RS", "T", " "  );

  0075b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168656
  00762	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00767	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168657
  0076e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00773	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168658
  0077a	66 41 b8 0f 00	 mov	 r8w, 15
  0077f	66 ba 08 00	 mov	 dx, 8
  00783	66 b9 03 00	 mov	 cx, 3
  00787	e8 00 00 00 00	 call	 draw_button
$LN24@NP_screen_:

; 819  :     }
; 820  : 
; 821  :     if (sysblk.hicpu)

  0078c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00793	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0079a	74 24		 je	 SHORT $LN25@NP_screen_

; 822  :     {
; 823  :         set_pos ((BUTTONS_LINE+1), 3);

  0079c	66 ba 03 00	 mov	 dx, 3
  007a0	66 b9 12 00	 mov	 cx, 18
  007a4	e8 00 00 00 00	 call	 set_pos

; 824  :         set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  007a9	33 d2		 xor	 edx, edx
  007ab	66 b9 08 00	 mov	 cx, 8
  007af	e8 00 00 00 00	 call	 set_color

; 825  :         draw_text ("MIPS");

  007b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168660
  007bb	e8 00 00 00 00	 call	 draw_text
$LN25@NP_screen_:

; 826  :     }
; 827  : 
; 828  :     if (0
; 829  :         || sysblk.hicpu
; 830  : 
; 831  : #if defined( OPTION_SHARED_DEVICES )
; 832  :         || sysblk.shrdport

  007c0	33 c0		 xor	 eax, eax
  007c2	85 c0		 test	 eax, eax
  007c4	75 22		 jne	 SHORT $LN27@NP_screen_
  007c6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007cd	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  007d4	75 12		 jne	 SHORT $LN27@NP_screen_
  007d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007dd	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  007e4	85 c0		 test	 eax, eax
  007e6	74 19		 je	 SHORT $LN26@NP_screen_
$LN27@NP_screen_:

; 833  : #endif
; 834  :     )
; 835  :     {
; 836  :         set_pos ((BUTTONS_LINE+1), 10);

  007e8	66 ba 0a 00	 mov	 dx, 10
  007ec	66 b9 12 00	 mov	 cx, 18
  007f0	e8 00 00 00 00	 call	 set_pos

; 837  :         draw_text ("IO/s");

  007f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168663
  007fc	e8 00 00 00 00	 call	 draw_text
$LN26@NP_screen_:

; 838  :     }
; 839  : 
; 840  :     if (sysblk.hicpu)

  00801	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00808	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0080f	0f 84 f8 00 00
	00		 je	 $LN28@NP_screen_

; 841  :     {
; 842  :         set_pos ((BUTTONS_LINE+2), 2);

  00815	66 ba 02 00	 mov	 dx, 2
  00819	66 b9 13 00	 mov	 cx, 19
  0081d	e8 00 00 00 00	 call	 set_pos

; 843  :         draw_button(COLOR_GREEN, COLOR_LIGHT_GREY, COLOR_WHITE,  " ",   "S", "TR ");

  00822	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168665
  00829	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0082e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168666
  00835	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0083a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168667
  00841	66 41 b8 0f 00	 mov	 r8w, 15
  00846	66 ba 08 00	 mov	 dx, 8
  0084a	66 b9 02 00	 mov	 cx, 2
  0084e	e8 00 00 00 00	 call	 draw_button

; 844  :         set_pos ((BUTTONS_LINE+2), 9);

  00853	66 ba 09 00	 mov	 dx, 9
  00857	66 b9 13 00	 mov	 cx, 19
  0085b	e8 00 00 00 00	 call	 set_pos

; 845  :         draw_button(COLOR_RED,   COLOR_LIGHT_GREY, COLOR_WHITE,  " ST", "P", " "  );

  00860	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168668
  00867	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0086c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168669
  00873	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00878	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168670
  0087f	66 41 b8 0f 00	 mov	 r8w, 15
  00884	66 ba 08 00	 mov	 dx, 8
  00888	66 b9 01 00	 mov	 cx, 1
  0088c	e8 00 00 00 00	 call	 draw_button

; 846  :         set_pos ((BUTTONS_LINE+2), 16);

  00891	66 ba 10 00	 mov	 dx, 16
  00895	66 b9 13 00	 mov	 cx, 19
  00899	e8 00 00 00 00	 call	 set_pos

; 847  :         draw_button(COLOR_BLUE,  COLOR_LIGHT_GREY, COLOR_WHITE,  " ",   "E", "XT ");

  0089e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168671
  008a5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168672
  008b1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008b6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168673
  008bd	66 41 b8 0f 00	 mov	 r8w, 15
  008c2	66 ba 08 00	 mov	 dx, 8
  008c6	66 b9 03 00	 mov	 cx, 3
  008ca	e8 00 00 00 00	 call	 draw_button

; 848  :         set_pos ((BUTTONS_LINE+2), 24);

  008cf	66 ba 18 00	 mov	 dx, 24
  008d3	66 b9 13 00	 mov	 cx, 19
  008d7	e8 00 00 00 00	 call	 set_pos

; 849  :         draw_button(COLOR_BLUE,  COLOR_LIGHT_GREY, COLOR_WHITE,  " IP", "L", " "  );

  008dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168674
  008e3	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168675
  008ef	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008f4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168676
  008fb	66 41 b8 0f 00	 mov	 r8w, 15
  00900	66 ba 08 00	 mov	 dx, 8
  00904	66 b9 03 00	 mov	 cx, 3
  00908	e8 00 00 00 00	 call	 draw_button
$LN28@NP_screen_:

; 850  :     }
; 851  : 
; 852  :     set_pos ((BUTTONS_LINE+2), 32);

  0090d	66 ba 20 00	 mov	 dx, 32			; 00000020H
  00911	66 b9 13 00	 mov	 cx, 19
  00915	e8 00 00 00 00	 call	 set_pos

; 853  :     draw_button(COLOR_RED,   COLOR_LIGHT_GREY, COLOR_WHITE,  " P",  "W", "R " );

  0091a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168677
  00921	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00926	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG168678
  0092d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00932	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG168679
  00939	66 41 b8 0f 00	 mov	 r8w, 15
  0093e	66 ba 08 00	 mov	 dx, 8
  00942	66 b9 01 00	 mov	 cx, 1
  00946	e8 00 00 00 00	 call	 draw_button

; 854  : 
; 855  :     set_color (COLOR_LIGHT_GREY, COLOR_BLACK);

  0094b	33 d2		 xor	 edx, edx
  0094d	66 b9 08 00	 mov	 cx, 8
  00951	e8 00 00 00 00	 call	 set_color

; 856  : 
; 857  :     /* CPU busy graph */
; 858  :     line = CPU_GRAPH_LINE;                          // this is where the dashes start

  00956	c7 44 24 34 14
	00 00 00	 mov	 DWORD PTR line$[rsp], 20

; 859  :     NPcpugraph_ncpu = MIN(cons_rows - line - 1, sysblk.hicpu);

  0095e	8b 44 24 34	 mov	 eax, DWORD PTR line$[rsp]
  00962	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_rows
  00968	2b c8		 sub	 ecx, eax
  0096a	8b c1		 mov	 eax, ecx
  0096c	ff c8		 dec	 eax
  0096e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00975	3b 81 08 01 00
	00		 cmp	 eax, DWORD PTR [rcx+264]
  0097b	7d 16		 jge	 SHORT $LN47@NP_screen_
  0097d	8b 44 24 34	 mov	 eax, DWORD PTR line$[rsp]
  00981	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_rows
  00987	2b c8		 sub	 ecx, eax
  00989	8b c1		 mov	 eax, ecx
  0098b	ff c8		 dec	 eax
  0098d	89 44 24 50	 mov	 DWORD PTR tv438[rsp], eax
  00991	eb 11		 jmp	 SHORT $LN48@NP_screen_
$LN47@NP_screen_:
  00993	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0099a	8b 80 08 01 00
	00		 mov	 eax, DWORD PTR [rax+264]
  009a0	89 44 24 50	 mov	 DWORD PTR tv438[rsp], eax
$LN48@NP_screen_:
  009a4	8b 44 24 50	 mov	 eax, DWORD PTR tv438[rsp]
  009a8	89 05 00 00 00
	00		 mov	 DWORD PTR NPcpugraph_ncpu, eax

; 860  :     set_pos (line++, 1);

  009ae	0f b7 44 24 34	 movzx	 eax, WORD PTR line$[rsp]
  009b3	66 89 44 24 38	 mov	 WORD PTR tv441[rsp], ax
  009b8	66 ba 01 00	 mov	 dx, 1
  009bc	0f b7 4c 24 38	 movzx	 ecx, WORD PTR tv441[rsp]
  009c1	e8 00 00 00 00	 call	 set_pos
  009c6	8b 44 24 34	 mov	 eax, DWORD PTR line$[rsp]
  009ca	ff c0		 inc	 eax
  009cc	89 44 24 34	 mov	 DWORD PTR line$[rsp], eax

; 861  :     fill_text ('-', 38);

  009d0	66 ba 26 00	 mov	 dx, 38			; 00000026H
  009d4	b1 2d		 mov	 cl, 45			; 0000002dH
  009d6	e8 00 00 00 00	 call	 fill_text

; 862  : 
; 863  :     if (sysblk.hicpu)

  009db	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  009e2	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  009e9	0f 84 a0 00 00
	00		 je	 $LN29@NP_screen_

; 864  :     {
; 865  :         NPcpugraph = 1;

  009ef	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPcpugraph, 1

; 866  :         NPcpugraph_valid = 0;

  009f9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPcpugraph_valid, 0

; 867  :         for (i = 0; i < NPcpugraph_ncpu; i++)

  00a03	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00a0b	eb 0a		 jmp	 SHORT $LN10@NP_screen_
$LN8@NP_screen_:
  00a0d	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00a11	ff c0		 inc	 eax
  00a13	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN10@NP_screen_:
  00a17	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPcpugraph_ncpu
  00a1d	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00a21	7d 6a		 jge	 SHORT $LN9@NP_screen_

; 868  :         {
; 869  :             MSGBUF (buf, "%s%02X ", PTYPSTR(i), i);

  00a23	48 63 44 24 30	 movsxd	 rax, DWORD PTR i$[rsp]
  00a28	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00a2f	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  00a37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  00a3d	8b 4c 24 30	 mov	 ecx, DWORD PTR i$[rsp]
  00a41	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  00a45	4c 8b c8	 mov	 r9, rax
  00a48	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168682
  00a4f	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00a54	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  00a59	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 870  :             set_pos (line++, 1);

  00a5f	0f b7 44 24 34	 movzx	 eax, WORD PTR line$[rsp]
  00a64	66 89 44 24 3a	 mov	 WORD PTR tv494[rsp], ax
  00a69	66 ba 01 00	 mov	 dx, 1
  00a6d	0f b7 4c 24 3a	 movzx	 ecx, WORD PTR tv494[rsp]
  00a72	e8 00 00 00 00	 call	 set_pos
  00a77	8b 44 24 34	 mov	 eax, DWORD PTR line$[rsp]
  00a7b	ff c0		 inc	 eax
  00a7d	89 44 24 34	 mov	 DWORD PTR line$[rsp], eax

; 871  :             draw_text (buf);

  00a81	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buf$[rsp]
  00a86	e8 00 00 00 00	 call	 draw_text

; 872  :         }

  00a8b	eb 80		 jmp	 SHORT $LN8@NP_screen_
$LN9@NP_screen_:

; 873  :     }

  00a8d	eb 0a		 jmp	 SHORT $LN30@NP_screen_
$LN29@NP_screen_:

; 874  :     else
; 875  :         NPcpugraph = 0;

  00a8f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPcpugraph, 0
$LN30@NP_screen_:

; 876  : 
; 877  :     /* Vertical separators */
; 878  :     for (i = 2; i <= cons_rows; i++)

  00a99	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR i$[rsp], 2
  00aa1	eb 0a		 jmp	 SHORT $LN13@NP_screen_
$LN11@NP_screen_:
  00aa3	8b 44 24 30	 mov	 eax, DWORD PTR i$[rsp]
  00aa7	ff c0		 inc	 eax
  00aa9	89 44 24 30	 mov	 DWORD PTR i$[rsp], eax
$LN13@NP_screen_:
  00aad	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  00ab3	39 44 24 30	 cmp	 DWORD PTR i$[rsp], eax
  00ab7	7f 1a		 jg	 SHORT $LN12@NP_screen_

; 879  :     {
; 880  :         set_pos (i , 39);

  00ab9	66 ba 27 00	 mov	 dx, 39			; 00000027H
  00abd	0f b7 4c 24 30	 movzx	 ecx, WORD PTR i$[rsp]
  00ac2	e8 00 00 00 00	 call	 set_pos

; 881  :         draw_char ('|');

  00ac7	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00acc	e8 00 00 00 00	 call	 draw_char

; 882  :     }

  00ad1	eb d0		 jmp	 SHORT $LN11@NP_screen_
$LN12@NP_screen_:

; 883  : 
; 884  :     /* Last line : horizontal separator */
; 885  :     if (cons_rows >= 24)

  00ad3	83 3d 00 00 00
	00 18		 cmp	 DWORD PTR cons_rows, 24
  00ada	7c 33		 jl	 SHORT $LN31@NP_screen_

; 886  :     {
; 887  :         set_pos (cons_rows, 1);

  00adc	66 ba 01 00	 mov	 dx, 1
  00ae0	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  00ae7	e8 00 00 00 00	 call	 set_pos

; 888  :         fill_text ('-', 38);

  00aec	66 ba 26 00	 mov	 dx, 38			; 00000026H
  00af0	b1 2d		 mov	 cl, 45			; 0000002dH
  00af2	e8 00 00 00 00	 call	 fill_text

; 889  :         draw_char ('|');

  00af7	b9 7c 00 00 00	 mov	 ecx, 124		; 0000007cH
  00afc	e8 00 00 00 00	 call	 draw_char

; 890  :         fill_text ('-', cons_cols);

  00b01	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  00b08	b1 2d		 mov	 cl, 45			; 0000002dH
  00b0a	e8 00 00 00 00	 call	 fill_text
$LN31@NP_screen_:

; 891  :     }
; 892  : 
; 893  :     /* positions the cursor */
; 894  :     set_pos (cons_rows, cons_cols);

  00b0f	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  00b16	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  00b1d	e8 00 00 00 00	 call	 set_pos
$LN32@NP_screen_:

; 895  : }

  00b22	48 8b 8c 24 60
	04 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00b2a	48 33 cc	 xor	 rcx, rsp
  00b2d	e8 00 00 00 00	 call	 __security_check_cookie
  00b32	48 81 c4 78 04
	00 00		 add	 rsp, 1144		; 00000478H
  00b39	c3		 ret	 0
NP_screen_redraw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
NP_init	PROC

; 649  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 650  :     NPdataentry = 0;

  00004	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPdataentry, 0

; 651  :     STRLCPY( NPprompt1, "" );

  0000e	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168600
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 652  :     STRLCPY( NPprompt2, "" );

  00028	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  0002e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168601
  00035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 653  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
NP_init	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
bg$ = 48
fg$ = 56
hfg$ = 64
left$ = 72
mid$ = 80
right$ = 88
draw_button PROC

; 553  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	66 44 89 44 24
	18		 mov	 WORD PTR [rsp+24], r8w
  0000b	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00010	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  00015	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 554  :     set_color (fg, bg);

  00019	0f b7 54 24 30	 movzx	 edx, WORD PTR bg$[rsp]
  0001e	0f b7 4c 24 38	 movzx	 ecx, WORD PTR fg$[rsp]
  00023	e8 00 00 00 00	 call	 set_color

; 555  :     draw_text (left);

  00028	48 8b 4c 24 48	 mov	 rcx, QWORD PTR left$[rsp]
  0002d	e8 00 00 00 00	 call	 draw_text

; 556  :     set_color (hfg, bg);

  00032	0f b7 54 24 30	 movzx	 edx, WORD PTR bg$[rsp]
  00037	0f b7 4c 24 40	 movzx	 ecx, WORD PTR hfg$[rsp]
  0003c	e8 00 00 00 00	 call	 set_color

; 557  :     draw_text (mid);

  00041	48 8b 4c 24 50	 mov	 rcx, QWORD PTR mid$[rsp]
  00046	e8 00 00 00 00	 call	 draw_text

; 558  :     set_color (fg, bg);

  0004b	0f b7 54 24 30	 movzx	 edx, WORD PTR bg$[rsp]
  00050	0f b7 4c 24 38	 movzx	 ecx, WORD PTR fg$[rsp]
  00055	e8 00 00 00 00	 call	 set_color

; 559  :     draw_text (right);

  0005a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR right$[rsp]
  0005f	e8 00 00 00 00	 call	 draw_text

; 560  : }

  00064	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00068	c3		 ret	 0
draw_button ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
len$ = 32
$T1 = 40
tv73 = 48
buf$ = 64
__$ArrayPad$ = 336
c$ = 368
x$ = 376
fill_text PROC

; 540  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	88 4c 24 08	 mov	 BYTE PTR [rsp+8], cl
  00009	57		 push	 rdi
  0000a	48 81 ec 60 01
	00 00		 sub	 rsp, 352		; 00000160H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 541  :     char buf[PANEL_MAX_COLS+1];
; 542  :     int  len;
; 543  : 
; 544  :     if (x > PANEL_MAX_COLS) x = PANEL_MAX_COLS;

  00023	0f bf 84 24 78
	01 00 00	 movsx	 eax, WORD PTR x$[rsp]
  0002b	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  00030	7e 0d		 jle	 SHORT $LN2@fill_text
  00032	b8 00 01 00 00	 mov	 eax, 256		; 00000100H
  00037	66 89 84 24 78
	01 00 00	 mov	 WORD PTR x$[rsp], ax
$LN2@fill_text:

; 545  :     len = x + 1 - cur_cons_col;

  0003f	0f bf 84 24 78
	01 00 00	 movsx	 eax, WORD PTR x$[rsp]
  00047	ff c0		 inc	 eax
  00049	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR cur_cons_col
  00050	2b c1		 sub	 eax, ecx
  00052	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 546  :     if (len <= 0) return;

  00056	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  0005b	7f 02		 jg	 SHORT $LN3@fill_text
  0005d	eb 57		 jmp	 SHORT $LN1@fill_text
$LN3@fill_text:

; 547  :     memset( buf, c, len );

  0005f	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  00064	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  00069	0f be 8c 24 70
	01 00 00	 movsx	 ecx, BYTE PTR c$[rsp]
  00071	48 63 c9	 movsxd	 rcx, ecx
  00074	48 8d 54 24 40	 lea	 rdx, QWORD PTR buf$[rsp]
  00079	48 8b fa	 mov	 rdi, rdx
  0007c	48 8b c1	 mov	 rax, rcx
  0007f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv73[rsp]
  00084	f3 aa		 rep stosb

; 548  :     buf[len] = '\0';

  00086	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  0008b	48 89 44 24 28	 mov	 QWORD PTR $T1[rsp], rax
  00090	48 81 7c 24 28
	01 01 00 00	 cmp	 QWORD PTR $T1[rsp], 257	; 00000101H
  00099	73 02		 jae	 SHORT $LN5@fill_text
  0009b	eb 05		 jmp	 SHORT $LN6@fill_text
$LN5@fill_text:
  0009d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN6@fill_text:
  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR $T1[rsp]
  000a7	c6 44 04 40 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 549  :     draw_text (buf);

  000ac	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000b1	e8 00 00 00 00	 call	 draw_text
$LN1@fill_text:
$LN4@fill_text:

; 550  : }

  000b6	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000be	48 33 cc	 xor	 rcx, rsp
  000c1	e8 00 00 00 00	 call	 __security_check_cookie
  000c6	48 81 c4 60 01
	00 00		 add	 rsp, 352		; 00000160H
  000cd	5f		 pop	 rdi
  000ce	c3		 ret	 0
fill_text ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 56
dw$ = 80
draw_dw	PROC

; 533  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 534  :     char buf[17];
; 535  :     MSGBUF (buf, "%16.16"PRIX64, dw);

  00018	4c 8b 4c 24 50	 mov	 r9, QWORD PTR dw$[rsp]
  0001d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168539
  00024	ba 11 00 00 00	 mov	 edx, 17
  00029	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 536  :     draw_text (buf);

  00034	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00039	e8 00 00 00 00	 call	 draw_text

; 537  : }

  0003e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00043	48 33 cc	 xor	 rcx, rsp
  00046	e8 00 00 00 00	 call	 __security_check_cookie
  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
draw_dw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 48
fw$ = 80
draw_fw	PROC

; 526  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000f	48 33 c4	 xor	 rax, rsp
  00012	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 527  :     char buf[9];
; 528  :     MSGBUF (buf, "%8.8X", fw);

  00017	44 8b 4c 24 50	 mov	 r9d, DWORD PTR fw$[rsp]
  0001c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168533
  00023	ba 09 00 00 00	 mov	 edx, 9
  00028	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 529  :     draw_text (buf);

  00033	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00038	e8 00 00 00 00	 call	 draw_text

; 530  : }

  0003d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00042	48 33 cc	 xor	 rcx, rsp
  00045	e8 00 00 00 00	 call	 __security_check_cookie
  0004a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004e	c3		 ret	 0
draw_fw	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
c$ = 48
draw_char PROC

; 517  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 518  :     if (cur_cons_row < 1 || cur_cons_row > cons_rows
; 519  :      || cur_cons_col < 1 || cur_cons_col > cons_cols)

  00008	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  0000f	83 f8 01	 cmp	 eax, 1
  00012	7c 2a		 jl	 SHORT $LN3@draw_char
  00014	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  0001b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_rows
  00021	7f 1b		 jg	 SHORT $LN3@draw_char
  00023	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0002a	83 f8 01	 cmp	 eax, 1
  0002d	7c 0f		 jl	 SHORT $LN3@draw_char
  0002f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  00036	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  0003c	7e 02		 jle	 SHORT $LN2@draw_char
$LN3@draw_char:

; 520  :         return;

  0003e	eb 22		 jmp	 SHORT $LN1@draw_char
$LN2@draw_char:

; 521  :     fputc (c, confp);

  00040	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR confp
  00047	8b 4c 24 30	 mov	 ecx, DWORD PTR c$[rsp]
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 522  :     cur_cons_col++;

  00051	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_col
  00058	66 ff c0	 inc	 ax
  0005b	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN1@draw_char:

; 523  : }

  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00066	c3		 ret	 0
draw_char ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
text$ = 48
size$ = 56
write_text PROC

; 506  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 507  :     if (cur_cons_row < 1 || cur_cons_row > cons_rows
; 508  :      || cur_cons_col < 1 || cur_cons_col > cons_cols)

  0000d	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  00014	83 f8 01	 cmp	 eax, 1
  00017	7c 2a		 jl	 SHORT $LN3@write_text
  00019	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  00020	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_rows
  00026	7f 1b		 jg	 SHORT $LN3@write_text
  00028	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0002f	83 f8 01	 cmp	 eax, 1
  00032	7c 0f		 jl	 SHORT $LN3@write_text
  00034	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0003b	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  00041	7e 02		 jle	 SHORT $LN2@write_text
$LN3@write_text:

; 509  :         return;

  00043	eb 62		 jmp	 SHORT $LN1@write_text
$LN2@write_text:

; 510  :     if (cons_cols - cur_cons_col + 1 < size)

  00045	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0004c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_cols
  00052	2b c8		 sub	 ecx, eax
  00054	8b c1		 mov	 eax, ecx
  00056	ff c0		 inc	 eax
  00058	3b 44 24 38	 cmp	 eax, DWORD PTR size$[rsp]
  0005c	7d 17		 jge	 SHORT $LN4@write_text

; 511  :         size = cons_cols - cur_cons_col + 1;

  0005e	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  00065	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_cols
  0006b	2b c8		 sub	 ecx, eax
  0006d	8b c1		 mov	 eax, ecx
  0006f	ff c0		 inc	 eax
  00071	89 44 24 38	 mov	 DWORD PTR size$[rsp], eax
$LN4@write_text:

; 512  :     fwrite (text, size, 1, confp);

  00075	48 63 44 24 38	 movsxd	 rax, DWORD PTR size$[rsp]
  0007a	4c 8b 0d 00 00
	00 00		 mov	 r9, QWORD PTR confp
  00081	41 b8 01 00 00
	00		 mov	 r8d, 1
  00087	48 8b d0	 mov	 rdx, rax
  0008a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR text$[rsp]
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite

; 513  :     cur_cons_col += size;

  00095	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0009c	03 44 24 38	 add	 eax, DWORD PTR size$[rsp]
  000a0	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN1@write_text:

; 514  : }

  000a7	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ab	c3		 ret	 0
write_text ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
len$ = 32
short_text$ = 40
text$ = 64
draw_text PROC

; 483  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 484  :     int   len;
; 485  :     char *short_text;
; 486  : 
; 487  :     if (cur_cons_row < 1 || cur_cons_row > cons_rows
; 488  :      || cur_cons_col < 1 || cur_cons_col > cons_cols)

  00009	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  00010	83 f8 01	 cmp	 eax, 1
  00013	7c 2a		 jl	 SHORT $LN3@draw_text
  00015	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  0001c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_rows
  00022	7f 1b		 jg	 SHORT $LN3@draw_text
  00024	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	7c 0f		 jl	 SHORT $LN3@draw_text
  00030	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  00037	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  0003d	7e 05		 jle	 SHORT $LN2@draw_text
$LN3@draw_text:

; 489  :         return;

  0003f	e9 b5 00 00 00	 jmp	 $LN1@draw_text
$LN2@draw_text:

; 490  :     len = (int)strlen(text);

  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR text$[rsp]
  00049	e8 00 00 00 00	 call	 strlen
  0004e	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 491  :     if ((cur_cons_col + len - 1) <= cons_cols)

  00052	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  00059	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  0005d	8d 44 08 ff	 lea	 eax, DWORD PTR [rax+rcx-1]
  00061	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  00067	7f 1b		 jg	 SHORT $LN4@draw_text

; 492  :         fprintf (confp, "%s", text);

  00069	4c 8b 44 24 40	 mov	 r8, QWORD PTR text$[rsp]
  0006e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168510
  00075	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf
  00082	eb 63		 jmp	 SHORT $LN5@draw_text
$LN4@draw_text:

; 493  :     else
; 494  :     {
; 495  :         len = cons_cols - cur_cons_col + 1;

  00084	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0008b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_cols
  00091	2b c8		 sub	 ecx, eax
  00093	8b c1		 mov	 eax, ecx
  00095	ff c0		 inc	 eax
  00097	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 496  :         if ((short_text = strdup(text)) == NULL)

  0009b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR text$[rsp]
  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  000a6	48 89 44 24 28	 mov	 QWORD PTR short_text$[rsp], rax
  000ab	48 83 7c 24 28
	00		 cmp	 QWORD PTR short_text$[rsp], 0
  000b1	75 02		 jne	 SHORT $LN6@draw_text

; 497  :             return;

  000b3	eb 44		 jmp	 SHORT $LN1@draw_text
$LN6@draw_text:

; 498  :         short_text[len] = '\0';

  000b5	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  000ba	48 8b 4c 24 28	 mov	 rcx, QWORD PTR short_text$[rsp]
  000bf	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 499  :         fprintf (confp, "%s", short_text);

  000c3	4c 8b 44 24 28	 mov	 r8, QWORD PTR short_text$[rsp]
  000c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168512
  000cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 500  :         free (short_text);

  000dc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR short_text$[rsp]
  000e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@draw_text:

; 501  :     }
; 502  :     cur_cons_col += len;

  000e7	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  000ee	03 44 24 20	 add	 eax, DWORD PTR len$[rsp]
  000f2	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN1@draw_text:

; 503  : }

  000f9	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000fd	c3		 ret	 0
draw_text ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
restore_command_line PROC

; 474  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi

; 475  :     memcpy( cmdline, saved_cmdline, sizeof(cmdline) );

  00003	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:saved_cmdline
  00011	48 8b f8	 mov	 rdi, rax
  00014	48 8b f1	 mov	 rsi, rcx
  00017	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  0001c	f3 a4		 rep movsb

; 476  :     cmdlen = saved_cmdlen;

  0001e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR saved_cmdlen
  00024	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 477  :     cmdoff = saved_cmdoff;

  0002a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR saved_cmdoff
  00030	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax

; 478  :     cur_cons_row = saved_cons_row;

  00036	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_row
  0003d	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax

; 479  :     cur_cons_col = saved_cons_col;

  00044	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_col
  0004b	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax

; 480  : }

  00052	5f		 pop	 rdi
  00053	5e		 pop	 rsi
  00054	c3		 ret	 0
restore_command_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
save_command_line PROC

; 465  : {

  00000	40 56		 push	 rsi
  00002	57		 push	 rdi

; 466  :     memcpy( saved_cmdline, cmdline, sizeof(saved_cmdline) );

  00003	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:saved_cmdline
  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00011	48 8b f8	 mov	 rdi, rax
  00014	48 8b f1	 mov	 rsi, rcx
  00017	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  0001c	f3 a4		 rep movsb

; 467  :     saved_cmdlen = cmdlen;

  0001e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  00024	89 05 00 00 00
	00		 mov	 DWORD PTR saved_cmdlen, eax

; 468  :     saved_cmdoff = cmdoff;

  0002a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  00030	89 05 00 00 00
	00		 mov	 DWORD PTR saved_cmdoff, eax

; 469  :     saved_cons_row = cur_cons_row;

  00036	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  0003d	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_row, ax

; 470  :     saved_cons_col = cur_cons_col;

  00044	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_col
  0004b	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_col, ax

; 471  : }

  00052	5f		 pop	 rdi
  00053	5e		 pop	 rsi
  00054	c3		 ret	 0
save_command_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
cursor_cmdline_end PROC

; 458  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 459  :     cmdoff = cmdlen;

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  0000a	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN4@cursor_cmd:

; 460  :     ADJ_CMDCOL();

  00010	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00016	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0001c	2b c8		 sub	 ecx, eax
  0001e	8b c1		 mov	 eax, ecx
  00020	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  00026	7e 18		 jle	 SHORT $LN5@cursor_cmd
  00028	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  0002e	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  00034	2b c8		 sub	 ecx, eax
  00036	8b c1		 mov	 eax, ecx
  00038	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  0003e	eb 1a		 jmp	 SHORT $LN6@cursor_cmd
$LN5@cursor_cmd:
  00040	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00046	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  0004c	7d 0c		 jge	 SHORT $LN7@cursor_cmd
  0004e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  00054	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN7@cursor_cmd:
$LN6@cursor_cmd:
  0005a	33 c0		 xor	 eax, eax
  0005c	85 c0		 test	 eax, eax
  0005e	75 b0		 jne	 SHORT $LN4@cursor_cmd

; 461  :     set_pos( CMDLINE_ROW, CMDLINE_COL + cmdoff - cmdcol );

  00060	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168492
  00067	e8 00 00 00 00	 call	 strlen
  0006c	48 ff c0	 inc	 rax
  0006f	98		 cwde
  00070	03 05 00 00 00
	00		 add	 eax, DWORD PTR cmdoff
  00076	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR cmdcol
  0007c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_rows
  00082	ff c9		 dec	 ecx
  00084	0f b7 d0	 movzx	 edx, ax
  00087	e8 00 00 00 00	 call	 set_pos

; 462  : }

  0008c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00090	c3		 ret	 0
cursor_cmdline_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
cursor_cmdline_home PROC

; 451  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 452  :     cmdoff = 0;

  00004	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdoff, 0
$LN4@cursor_cmd:

; 453  :     ADJ_CMDCOL();

  0000e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00014	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0001a	2b c8		 sub	 ecx, eax
  0001c	8b c1		 mov	 eax, ecx
  0001e	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  00024	7e 18		 jle	 SHORT $LN5@cursor_cmd
  00026	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  0002c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  00032	2b c8		 sub	 ecx, eax
  00034	8b c1		 mov	 eax, ecx
  00036	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  0003c	eb 1a		 jmp	 SHORT $LN6@cursor_cmd
$LN5@cursor_cmd:
  0003e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00044	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  0004a	7d 0c		 jge	 SHORT $LN7@cursor_cmd
  0004c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  00052	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN7@cursor_cmd:
$LN6@cursor_cmd:
  00058	33 c0		 xor	 eax, eax
  0005a	85 c0		 test	 eax, eax
  0005c	75 b0		 jne	 SHORT $LN4@cursor_cmd

; 454  :     set_pos( CMDLINE_ROW, CMDLINE_COL );

  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168481
  00065	e8 00 00 00 00	 call	 strlen
  0006a	48 ff c0	 inc	 rax
  0006d	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_rows
  00073	ff c9		 dec	 ecx
  00075	0f b7 d0	 movzx	 edx, ax
  00078	e8 00 00 00 00	 call	 set_pos

; 455  : }

  0007d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00081	c3		 ret	 0
cursor_cmdline_home ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv89 = 32
tv74 = 36
tv81 = 40
is_cursor_on_cmdline PROC

; 435  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 436  : #if defined(OPTION_EXTCURS)
; 437  :     get_cursor_pos( keybfd, confp, &cur_cons_row, &cur_cons_col );

  00004	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cur_cons_col
  0000b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cur_cons_row
  00012	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR confp
  00019	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR keybfd
  0001f	e8 00 00 00 00	 call	 get_cursor_pos

; 438  :     cursor_on_cmdline =

  00024	33 c0		 xor	 eax, eax
  00026	83 f8 01	 cmp	 eax, 1
  00029	74 6c		 je	 SHORT $LN3@is_cursor_
  0002b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  00032	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_rows
  00038	ff c9		 dec	 ecx
  0003a	0f bf c9	 movsx	 ecx, cx
  0003d	3b c1		 cmp	 eax, ecx
  0003f	75 56		 jne	 SHORT $LN3@is_cursor_
  00041	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  00048	89 44 24 24	 mov	 DWORD PTR tv74[rsp], eax
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168469
  00053	e8 00 00 00 00	 call	 strlen
  00058	48 ff c0	 inc	 rax
  0005b	98		 cwde
  0005c	8b 4c 24 24	 mov	 ecx, DWORD PTR tv74[rsp]
  00060	3b c8		 cmp	 ecx, eax
  00062	7c 33		 jl	 SHORT $LN3@is_cursor_
  00064	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  0006b	89 44 24 28	 mov	 DWORD PTR tv81[rsp], eax
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168470
  00076	e8 00 00 00 00	 call	 strlen
  0007b	48 ff c0	 inc	 rax
  0007e	98		 cwde
  0007f	03 05 00 00 00
	00		 add	 eax, DWORD PTR cmdcols
  00085	8b 4c 24 28	 mov	 ecx, DWORD PTR tv81[rsp]
  00089	3b c8		 cmp	 ecx, eax
  0008b	7f 0a		 jg	 SHORT $LN3@is_cursor_
  0008d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
  00095	eb 08		 jmp	 SHORT $LN4@is_cursor_
$LN3@is_cursor_:
  00097	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN4@is_cursor_:
  0009f	8b 44 24 20	 mov	 eax, DWORD PTR tv89[rsp]
  000a3	89 05 00 00 00
	00		 mov	 DWORD PTR cursor_on_cmdline, eax

; 439  :     (1
; 440  :         && cur_cons_row == CMDLINE_ROW
; 441  :         && cur_cons_col >= CMDLINE_COL
; 442  :         && cur_cons_col <= CMDLINE_COL + cmdcols
; 443  :     );
; 444  : #else // !defined(OPTION_EXTCURS)
; 445  :     cursor_on_cmdline = 1;
; 446  : #endif // defined(OPTION_EXTCURS)
; 447  :     return cursor_on_cmdline;

  000a9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cursor_on_cmdline

; 448  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
is_cursor_on_cmdline ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv69 = 32
tv70 = 36
tv77 = 40
tv78 = 44
y$ = 64
x$ = 72
set_pos	PROC

; 426  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 427  :     cur_cons_row = y;

  0000e	0f b7 44 24 40	 movzx	 eax, WORD PTR y$[rsp]
  00013	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax

; 428  :     cur_cons_col = x;

  0001a	0f b7 44 24 48	 movzx	 eax, WORD PTR x$[rsp]
  0001f	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax

; 429  :     y = y < 1 ? 1 : y > cons_rows ? cons_rows : y;

  00026	0f bf 44 24 40	 movsx	 eax, WORD PTR y$[rsp]
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	7d 0a		 jge	 SHORT $LN5@set_pos
  00030	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00038	eb 2a		 jmp	 SHORT $LN6@set_pos
$LN5@set_pos:
  0003a	0f bf 44 24 40	 movsx	 eax, WORD PTR y$[rsp]
  0003f	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_rows
  00045	7e 0c		 jle	 SHORT $LN3@set_pos
  00047	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  0004d	89 44 24 20	 mov	 DWORD PTR tv69[rsp], eax
  00051	eb 09		 jmp	 SHORT $LN4@set_pos
$LN3@set_pos:
  00053	0f bf 44 24 40	 movsx	 eax, WORD PTR y$[rsp]
  00058	89 44 24 20	 mov	 DWORD PTR tv69[rsp], eax
$LN4@set_pos:
  0005c	8b 44 24 20	 mov	 eax, DWORD PTR tv69[rsp]
  00060	89 44 24 24	 mov	 DWORD PTR tv70[rsp], eax
$LN6@set_pos:
  00064	0f b7 44 24 24	 movzx	 eax, WORD PTR tv70[rsp]
  00069	66 89 44 24 40	 mov	 WORD PTR y$[rsp], ax

; 430  :     x = x < 1 ? 1 : x > cons_cols ? cons_cols : x;

  0006e	0f bf 44 24 48	 movsx	 eax, WORD PTR x$[rsp]
  00073	83 f8 01	 cmp	 eax, 1
  00076	7d 0a		 jge	 SHORT $LN9@set_pos
  00078	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv78[rsp], 1
  00080	eb 2a		 jmp	 SHORT $LN10@set_pos
$LN9@set_pos:
  00082	0f bf 44 24 48	 movsx	 eax, WORD PTR x$[rsp]
  00087	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  0008d	7e 0c		 jle	 SHORT $LN7@set_pos
  0008f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_cols
  00095	89 44 24 28	 mov	 DWORD PTR tv77[rsp], eax
  00099	eb 09		 jmp	 SHORT $LN8@set_pos
$LN7@set_pos:
  0009b	0f bf 44 24 48	 movsx	 eax, WORD PTR x$[rsp]
  000a0	89 44 24 28	 mov	 DWORD PTR tv77[rsp], eax
$LN8@set_pos:
  000a4	8b 44 24 28	 mov	 eax, DWORD PTR tv77[rsp]
  000a8	89 44 24 2c	 mov	 DWORD PTR tv78[rsp], eax
$LN10@set_pos:
  000ac	0f b7 44 24 2c	 movzx	 eax, WORD PTR tv78[rsp]
  000b1	66 89 44 24 48	 mov	 WORD PTR x$[rsp], ax

; 431  :     set_screen_pos (confp, y, x);

  000b6	44 0f b7 44 24
	48		 movzx	 r8d, WORD PTR x$[rsp]
  000bc	0f b7 54 24 40	 movzx	 edx, WORD PTR y$[rsp]
  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  000c8	e8 00 00 00 00	 call	 set_screen_pos

; 432  : }

  000cd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000d1	c3		 ret	 0
set_pos	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
fg$ = 48
bg$ = 56
set_color PROC

; 421  : {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	66 89 4c 24 08	 mov	 WORD PTR [rsp+8], cx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 422  :     set_screen_color (confp, fg, bg);

  0000e	44 0f b7 44 24
	38		 movzx	 r8d, WORD PTR bg$[rsp]
  00014	0f b7 54 24 30	 movzx	 edx, WORD PTR fg$[rsp]
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  00020	e8 00 00 00 00	 call	 set_screen_color

; 423  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
set_color ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
y$ = 48
x$ = 56
get_dim	PROC

; 405  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 406  :     get_console_dim( confp, y, x);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR x$[rsp]
  00013	48 8b 54 24 30	 mov	 rdx, QWORD PTR y$[rsp]
  00018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  0001f	e8 00 00 00 00	 call	 get_console_dim

; 407  :     if (*y > PANEL_MAX_ROWS)

  00024	48 8b 44 24 30	 mov	 rax, QWORD PTR y$[rsp]
  00029	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  0002f	7e 0b		 jle	 SHORT $LN2@get_dim

; 408  :         *y = PANEL_MAX_ROWS;

  00031	48 8b 44 24 30	 mov	 rax, QWORD PTR y$[rsp]
  00036	c7 00 00 01 00
	00		 mov	 DWORD PTR [rax], 256	; 00000100H
$LN2@get_dim:

; 409  :     if (*x > PANEL_MAX_COLS)

  0003c	48 8b 44 24 38	 mov	 rax, QWORD PTR x$[rsp]
  00041	81 38 00 01 00
	00		 cmp	 DWORD PTR [rax], 256	; 00000100H
  00047	7e 0b		 jle	 SHORT $LN3@get_dim

; 410  :         *x = PANEL_MAX_COLS;

  00049	48 8b 44 24 38	 mov	 rax, QWORD PTR x$[rsp]
  0004e	c7 00 00 01 00
	00		 mov	 DWORD PTR [rax], 256	; 00000100H
$LN3@get_dim:

; 411  : #if defined(WIN32) && !defined( _MSVC_ )
; 412  :    /* If running from a cygwin command prompt we do
; 413  :      * better with one less row.
; 414  :      */
; 415  :     if (!cons_term || !*cons_term || strcmp(cons_term, "xterm"))
; 416  :         (*y)--;
; 417  : #endif // defined(WIN32) && !defined( _MSVC_ )
; 418  : }

  00054	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00058	c3		 ret	 0
get_dim	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
clr_screen PROC

; 400  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 401  :     clear_screen (confp);

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  0000b	e8 00 00 00 00	 call	 clear_screen

; 402  : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
clr_screen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv73 = 32
do_next_history PROC

; 389  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 390  :     if (history_next() != -1)

  00004	e8 00 00 00 00	 call	 history_next
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	0f 84 a8 00 00
	00		 je	 $LN5@do_next_hi

; 391  :     {
; 392  :         STRLCPY( cmdline, historyCmdLine );

  00012	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  00018	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR historyCmdLine
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 393  :         cmdlen = (int)strlen(cmdline);

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00033	e8 00 00 00 00	 call	 strlen
  00038	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 394  :         cmdoff = cmdlen < cmdcols ? cmdlen : 0;

  0003e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  00044	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdlen, eax
  0004a	7d 0c		 jge	 SHORT $LN10@do_next_hi
  0004c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  00052	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  00056	eb 08		 jmp	 SHORT $LN11@do_next_hi
$LN10@do_next_hi:
  00058	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN11@do_next_hi:
  00060	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  00064	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN4@do_next_hi:

; 395  :         ADJ_CMDCOL();

  0006a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  00076	2b c8		 sub	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  00080	7e 18		 jle	 SHORT $LN6@do_next_hi
  00082	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0008e	2b c8		 sub	 ecx, eax
  00090	8b c1		 mov	 eax, ecx
  00092	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  00098	eb 1a		 jmp	 SHORT $LN7@do_next_hi
$LN6@do_next_hi:
  0009a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  000a0	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  000a6	7d 0c		 jge	 SHORT $LN8@do_next_hi
  000a8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  000ae	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN8@do_next_hi:
$LN7@do_next_hi:
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 b0		 jne	 SHORT $LN4@do_next_hi
$LN5@do_next_hi:

; 396  :     }
; 397  : }

  000ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000be	c3		 ret	 0
do_next_history ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv73 = 32
do_prev_history PROC

; 378  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 379  :     if (history_prev() != -1)

  00004	e8 00 00 00 00	 call	 history_prev
  00009	83 f8 ff	 cmp	 eax, -1
  0000c	0f 84 a8 00 00
	00		 je	 $LN5@do_prev_hi

; 380  :     {
; 381  :         STRLCPY( cmdline, historyCmdLine );

  00012	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  00018	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR historyCmdLine
  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 382  :         cmdlen = (int)strlen(cmdline);

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00033	e8 00 00 00 00	 call	 strlen
  00038	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 383  :         cmdoff = cmdlen < cmdcols ? cmdlen : 0;

  0003e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  00044	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdlen, eax
  0004a	7d 0c		 jge	 SHORT $LN10@do_prev_hi
  0004c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  00052	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  00056	eb 08		 jmp	 SHORT $LN11@do_prev_hi
$LN10@do_prev_hi:
  00058	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN11@do_prev_hi:
  00060	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]
  00064	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN4@do_prev_hi:

; 384  :         ADJ_CMDCOL();

  0006a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00070	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  00076	2b c8		 sub	 ecx, eax
  00078	8b c1		 mov	 eax, ecx
  0007a	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  00080	7e 18		 jle	 SHORT $LN6@do_prev_hi
  00082	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  00088	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0008e	2b c8		 sub	 ecx, eax
  00090	8b c1		 mov	 eax, ecx
  00092	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  00098	eb 1a		 jmp	 SHORT $LN7@do_prev_hi
$LN6@do_prev_hi:
  0009a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  000a0	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  000a6	7d 0c		 jge	 SHORT $LN8@do_prev_hi
  000a8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  000ae	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN8@do_prev_hi:
$LN7@do_prev_hi:
  000b4	33 c0		 xor	 eax, eax
  000b6	85 c0		 test	 eax, eax
  000b8	75 b0		 jne	 SHORT $LN4@do_prev_hi
$LN5@do_prev_hi:

; 385  :     }
; 386  : }

  000ba	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000be	c3		 ret	 0
do_prev_history ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
$T1 = 32
cmd$ = 64
do_panel_command PROC

; 359  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 360  :     if (!is_currline_visible())

  00009	e8 00 00 00 00	 call	 is_currline_visible
  0000e	85 c0		 test	 eax, eax
  00010	75 05		 jne	 SHORT $LN5@do_panel_c

; 361  :         scroll_to_bottom_screen();

  00012	e8 00 00 00 00	 call	 scroll_to_bottom_screen
$LN5@do_panel_c:

; 362  : 
; 363  :     if (cmd != (void*) cmdline)

  00017	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  0001e	48 39 44 24 40	 cmp	 QWORD PTR cmd$[rsp], rax
  00023	74 18		 je	 SHORT $LN6@do_panel_c

; 364  :         STRLCPY( cmdline, cmd );

  00025	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  0002b	48 8b 54 24 40	 mov	 rdx, QWORD PTR cmd$[rsp]
  00030	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@do_panel_c:

; 365  : 
; 366  :     panel_command( cmdline );

  0003d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00044	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  0004b	ff 10		 call	 QWORD PTR [rax]

; 367  : 
; 368  :     // Reset global variables
; 369  : 
; 370  :     cmdline[0] = 0;

  0004d	b8 01 00 00 00	 mov	 eax, 1
  00052	48 6b c0 00	 imul	 rax, rax, 0
  00056	48 89 44 24 20	 mov	 QWORD PTR $T1[rsp], rax
  0005b	48 81 7c 24 20
	01 01 00 00	 cmp	 QWORD PTR $T1[rsp], 257	; 00000101H
  00064	73 02		 jae	 SHORT $LN11@do_panel_c
  00066	eb 05		 jmp	 SHORT $LN12@do_panel_c
$LN11@do_panel_c:
  00068	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN12@do_panel_c:
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR $T1[rsp]
  00079	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 371  :     cmdlen     = 0;

  0007d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdlen, 0

; 372  :     cmdoff     = 0;

  00087	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdoff, 0
$LN4@do_panel_c:

; 373  : 
; 374  :     ADJ_CMDCOL();

  00091	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00097	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0009d	2b c8		 sub	 ecx, eax
  0009f	8b c1		 mov	 eax, ecx
  000a1	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  000a7	7e 18		 jle	 SHORT $LN7@do_panel_c
  000a9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  000af	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  000b5	2b c8		 sub	 ecx, eax
  000b7	8b c1		 mov	 eax, ecx
  000b9	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  000bf	eb 1a		 jmp	 SHORT $LN8@do_panel_c
$LN7@do_panel_c:
  000c1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  000c7	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  000cd	7d 0c		 jge	 SHORT $LN9@do_panel_c
  000cf	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  000d5	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN9@do_panel_c:
$LN8@do_panel_c:
  000db	33 c0		 xor	 eax, eax
  000dd	85 c0		 test	 eax, eax
  000df	75 b0		 jne	 SHORT $LN4@do_panel_c
$LN10@do_panel_c:

; 375  : }

  000e1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e5	c3		 ret	 0
do_panel_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
scroll_to_bottom_screen PROC

; 353  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 354  :     scroll_to_bottom_line();

  00004	e8 00 00 00 00	 call	 scroll_to_bottom_line

; 355  :     page_up();

  00009	e8 00 00 00 00	 call	 page_up

; 356  : }

  0000e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00012	c3		 ret	 0
scroll_to_bottom_screen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
scroll_to_bottom_line PROC

; 347  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN2@scroll_to_:

; 348  :     while (topmsg != newest_msg())

  00004	e8 00 00 00 00	 call	 newest_msg
  00009	48 39 05 00 00
	00 00		 cmp	 QWORD PTR topmsg, rax
  00010	74 0c		 je	 SHORT $LN3@scroll_to_

; 349  :         scroll_down_lines( 1 );

  00012	b9 01 00 00 00	 mov	 ecx, 1
  00017	e8 00 00 00 00	 call	 scroll_down_lines
  0001c	eb e6		 jmp	 SHORT $LN2@scroll_to_
$LN3@scroll_to_:

; 350  : }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
scroll_to_bottom_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
scroll_to_top_line PROC

; 342  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 343  :     topmsg = oldest_msg();

  00004	e8 00 00 00 00	 call	 oldest_msg
  00009	48 89 05 00 00
	00 00		 mov	 QWORD PTR topmsg, rax

; 344  : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
scroll_to_top_line ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
page_down PROC

; 337  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 338  :     scroll_down_lines( SCROLL_LINES - 1 );

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  0000a	83 e8 02	 sub	 eax, 2
  0000d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR numkept
  00013	ff c8		 dec	 eax
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 scroll_down_lines

; 339  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
page_down ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
page_up	PROC

; 333  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 334  :     scroll_up_lines( SCROLL_LINES - 1 );

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  0000a	83 e8 02	 sub	 eax, 2
  0000d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR numkept
  00013	ff c8		 dec	 eax
  00015	8b c8		 mov	 ecx, eax
  00017	e8 00 00 00 00	 call	 scroll_up_lines

; 335  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
page_up	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
i$ = 32
numlines$ = 64
scroll_down_lines PROC

; 322  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 323  :     int i;
; 324  : 
; 325  :     for (i=0; i < numlines && topmsg != newest_msg(); i++)

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00010	eb 0a		 jmp	 SHORT $LN4@scroll_dow
$LN2@scroll_dow:
  00012	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00016	ff c0		 inc	 eax
  00018	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@scroll_dow:
  0001c	8b 44 24 40	 mov	 eax, DWORD PTR numlines$[rsp]
  00020	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00024	7d 2f		 jge	 SHORT $LN3@scroll_dow
  00026	e8 00 00 00 00	 call	 newest_msg
  0002b	48 39 05 00 00
	00 00		 cmp	 QWORD PTR topmsg, rax
  00032	74 21		 je	 SHORT $LN3@scroll_dow

; 326  :     {
; 327  :         if (topmsg != newest_msg())

  00034	e8 00 00 00 00	 call	 newest_msg
  00039	48 39 05 00 00
	00 00		 cmp	 QWORD PTR topmsg, rax
  00040	74 11		 je	 SHORT $LN5@scroll_dow

; 328  :             topmsg = topmsg->next;

  00042	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  00049	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0004c	48 89 05 00 00
	00 00		 mov	 QWORD PTR topmsg, rax
$LN5@scroll_dow:

; 329  :     }

  00053	eb bd		 jmp	 SHORT $LN2@scroll_dow
$LN3@scroll_dow:

; 330  : }

  00055	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00059	c3		 ret	 0
scroll_down_lines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
i$ = 32
numlines$ = 64
scroll_up_lines PROC

; 314  : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 315  :     int i;
; 316  : 
; 317  :     for (i=0; i < numlines && topmsg != oldest_msg(); i++)

  00008	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00010	eb 0a		 jmp	 SHORT $LN4@scroll_up_
$LN2@scroll_up_:
  00012	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00016	ff c0		 inc	 eax
  00018	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@scroll_up_:
  0001c	8b 44 24 40	 mov	 eax, DWORD PTR numlines$[rsp]
  00020	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00024	7d 22		 jge	 SHORT $LN3@scroll_up_
  00026	e8 00 00 00 00	 call	 oldest_msg
  0002b	48 39 05 00 00
	00 00		 cmp	 QWORD PTR topmsg, rax
  00032	74 14		 je	 SHORT $LN3@scroll_up_

; 318  :         topmsg = topmsg->prev;

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  0003b	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0003f	48 89 05 00 00
	00 00		 mov	 QWORD PTR topmsg, rax
  00046	eb ca		 jmp	 SHORT $LN2@scroll_up_
$LN3@scroll_up_:

; 319  : }

  00048	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004c	c3		 ret	 0
scroll_up_lines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv65 = 32
lines_remaining PROC

; 309  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 310  :     return (SCROLL_LINES - visible_lines());

  00004	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  0000a	83 e8 02	 sub	 eax, 2
  0000d	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR numkept
  00013	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00017	e8 00 00 00 00	 call	 visible_lines
  0001c	8b 4c 24 20	 mov	 ecx, DWORD PTR tv65[rsp]
  00020	2b c8		 sub	 ecx, eax
  00022	8b c1		 mov	 eax, ecx

; 311  : }

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00028	c3		 ret	 0
lines_remaining ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv68 = 32
is_currline_visible PROC

; 304  : {

  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 305  :     return (visible_lines() <= SCROLL_LINES);

  00004	e8 00 00 00 00	 call	 visible_lines
  00009	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_rows
  0000f	83 e9 02	 sub	 ecx, 2
  00012	2b 0d 00 00 00
	00		 sub	 ecx, DWORD PTR numkept
  00018	3b c1		 cmp	 eax, ecx
  0001a	7f 0a		 jg	 SHORT $LN3@is_currlin
  0001c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00024	eb 08		 jmp	 SHORT $LN4@is_currlin
$LN3@is_currlin:
  00026	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN4@is_currlin:
  0002e	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]

; 306  : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
is_currline_visible ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
visible_lines PROC

; 299  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 300  :     return (lines_scrolled() + 1);

  00004	e8 00 00 00 00	 call	 lines_scrolled
  00009	ff c0		 inc	 eax

; 301  : }

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
visible_lines ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
lines_scrolled PROC

; 292  :     /* return # of lines 'up' from current line that we're scrolled. */
; 293  :     if (topmsg->msgnum <= curmsg->msgnum)

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  00007	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR curmsg
  0000e	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00011	39 48 10	 cmp	 DWORD PTR [rax+16], ecx
  00014	7f 18		 jg	 SHORT $LN2@lines_scro

; 294  :         return curmsg->msgnum - topmsg->msgnum;

  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  0001d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR topmsg
  00024	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  00027	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0002a	2b c1		 sub	 eax, ecx
  0002c	eb 1f		 jmp	 SHORT $LN1@lines_scro
$LN2@lines_scro:

; 295  :     return MAX_MSGS - (topmsg->msgnum - curmsg->msgnum);

  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  00035	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR curmsg
  0003c	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0003f	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00042	2b c1		 sub	 eax, ecx
  00044	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  00049	2b c8		 sub	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
$LN1@lines_scro:

; 296  : }

  0004d	c3		 ret	 0
lines_scrolled ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
newest_msg PROC

; 287  :     return curmsg;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg

; 288  : }

  00007	c3		 ret	 0
newest_msg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv66 = 0
oldest_msg PROC

; 281  : {

  00000	48 83 ec 18	 sub	 rsp, 24

; 282  :     return (wrapped) ? curmsg->next : msgbuf;

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR wrapped, 0
  0000b	74 10		 je	 SHORT $LN3@oldest_msg
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  00014	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00017	48 89 04 24	 mov	 QWORD PTR tv66[rsp], rax
  0001b	eb 0b		 jmp	 SHORT $LN4@oldest_msg
$LN3@oldest_msg:
  0001d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR msgbuf
  00024	48 89 04 24	 mov	 QWORD PTR tv66[rsp], rax
$LN4@oldest_msg:
  00028	48 8b 04 24	 mov	 rax, QWORD PTR tv66[rsp]

; 283  : }

  0002c	48 83 c4 18	 add	 rsp, 24
  00030	c3		 ret	 0
oldest_msg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
beep	PROC

; 276  : {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 277  :     console_beep( confp );

  00004	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  0000b	e8 00 00 00 00	 call	 console_beep

; 278  : }

  00010	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00014	c3		 ret	 0
beep	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
i$ = 112
j$1 = 116
len$ = 120
c$ = 124
odx$2 = 128
kbbuf$ = 136
idx$3 = 144
ctok$4 = 148
p$5 = 152
readoff$ = 160
regs$ = 168
prev_cpustate$ = 176
psz_PF$6 = 184
ncmd_tok$7 = 192
numcpu$ = 196
delim$8 = 200
prev_mipsrate$ = 204
mipsrate$9 = 208
kblen$ = 212
j$10 = 216
j$11 = 220
j$12 = 224
pt1$13 = 232
tv306 = 240
cnt_stopped$14 = 244
cnt_disabled$15 = 248
tv1414 = 252
prev_pcpu$ = 256
cnt_online$16 = 260
mipsfrac$17 = 264
prev_siosrate$ = 268
p$18 = 272
first$19 = 280
isdelay$20 = 284
tv1060 = 288
tv1310 = 292
tv1407 = 296
prev_shrdcount$ = 300
sev$21 = 304
prev_arch_mode$ = 308
tv2063 = 312
tv2014 = 316
tv2020 = 320
tv2026 = 324
tv2032 = 328
tv2038 = 332
tv2044 = 336
tv2050 = 340
prev_cpupct$ = 344
tv2065 = 348
tv2153 = 352
rows$22 = 356
cols$23 = 360
tv2055 = 364
tv333 = 368
aaddr$ = 372
tv700 = 376
pf$24 = 384
bg_color$25 = 392
fg_color$26 = 396
tv1967 = 400
tv2108 = 404
tv2280 = 408
tv2285 = 412
current_tm$27 = 416
state$28 = 424
prev_instcount$ = 432
$T29 = 440
kbbufsize$ = 448
since_midnight$30 = 456
current_time$31 = 464
loopcount$ = 472
$T32 = 480
$T33 = 488
$T34 = 496
$T35 = 504
$T36 = 512
$T37 = 520
$T38 = 528
$T39 = 536
$T40 = 544
tv134 = 552
tv163 = 560
tv1943 = 568
tv2083 = 576
cmd_tok$41 = 592
szPF$42 = 688
curr_psw$ = 696
ibuf$43 = 720
prev_psw$ = 784
msgbuf$44 = 800
buf$45 = 832
buf$46 = 872
buf$ = 912
readbuf$ = 1936
psz_cmdline$47 = 2192
psz_cmdline$48 = 2464
__$ArrayPad$ = 5296
the_real_panel_display PROC

; 1733 : {

$LN568:
  00000	40 56		 push	 rsi
  00002	57		 push	 rdi
  00003	b8 c8 14 00 00	 mov	 eax, 5320		; 000014c8H
  00008	e8 00 00 00 00	 call	 __chkstk
  0000d	48 2b e0	 sub	 rsp, rax
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 b0
	14 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1734 : #ifndef _MSVC_
; 1735 :   int     rc;                           /* Return code               */
; 1736 :   fd_set  readset;                      /* Select file descriptors   */
; 1737 :   struct  timeval tv;                   /* Select timeout structure  */
; 1738 : #endif // _MSVC_
; 1739 : int     i;                              /* Array subscripts          */
; 1740 : int     len;                            /* Length                    */
; 1741 : REGS   *regs;                           /* -> CPU register context   */
; 1742 : QWORD   curr_psw;                       /* Current PSW               */
; 1743 : QWORD   prev_psw;                       /* Previous PSW              */
; 1744 : int     prev_pcpu      = 0;             /* Previous pcpu             */

  00022	c7 84 24 00 01
	00 00 00 00 00
	00		 mov	 DWORD PTR prev_pcpu$[rsp], 0

; 1745 : int     prev_arch_mode = 0;             /* Previous primary arch.    */

  0002d	c7 84 24 34 01
	00 00 00 00 00
	00		 mov	 DWORD PTR prev_arch_mode$[rsp], 0

; 1746 : int     prev_cpupct    = 0;             /* Previous cpu percentage   */

  00038	c7 84 24 58 01
	00 00 00 00 00
	00		 mov	 DWORD PTR prev_cpupct$[rsp], 0

; 1747 : BYTE    prev_cpustate  = 0xFF;          /* Previous stopped state    */

  00043	c6 84 24 b0 00
	00 00 ff	 mov	 BYTE PTR prev_cpustate$[rsp], 255 ; 000000ffH

; 1748 : U64     prev_instcount = 0;             /* Previous instruction count*/

  0004b	48 c7 84 24 b0
	01 00 00 00 00
	00 00		 mov	 QWORD PTR prev_instcount$[rsp], 0

; 1749 : U32     prev_mipsrate  = 0;             /* Previous MIPS rate        */

  00057	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR prev_mipsrate$[rsp], 0

; 1750 : U32     prev_siosrate  = 0;             /* Previous SIOS rate        */

  00062	c7 84 24 0c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR prev_siosrate$[rsp], 0

; 1751 : #if defined( OPTION_SHARED_DEVICES )
; 1752 : U32     prev_shrdcount = 0;             /* Previous shrdcount        */

  0006d	c7 84 24 2c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR prev_shrdcount$[rsp], 0

; 1753 : #endif
; 1754 : U32     numcpu = 0;                     /* Online CPU count          */

  00078	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR numcpu$[rsp], 0

; 1755 : char    readbuf[MSG_SIZE];              /* Message read buffer       */
; 1756 : int     readoff = 0;                    /* Number of bytes in readbuf*/

  00083	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR readoff$[rsp], 0

; 1757 : BYTE    c;                              /* Character work area       */
; 1758 : size_t  kbbufsize = CMD_SIZE;           /* Size of keyboard buffer   */

  0008e	48 c7 84 24 c0
	01 00 00 00 01
	00 00		 mov	 QWORD PTR kbbufsize$[rsp], 256 ; 00000100H

; 1759 : char   *kbbuf = NULL;                   /* Keyboard input buffer     */

  0009a	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR kbbuf$[rsp], 0
$LN4@the_real_p:

; 1760 : int     kblen;                          /* Number of chars in kbbuf  */
; 1761 : U32     aaddr;                          /* Absolute address for STO  */
; 1762 : char    buf[1024];                      /* Buffer workarea           */
; 1763 : size_t  loopcount;                      /* Number of iterations done */
; 1764 : 
; 1765 :     SET_THREAD_NAME( PANEL_THREAD_NAME );

  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  000ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169323
  000b3	8b c8		 mov	 ecx, eax
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_set_thread_name
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169324
  000c8	8b c8		 mov	 ecx, eax
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_name
  000d0	33 c0		 xor	 eax, eax
  000d2	85 c0		 test	 eax, eax
  000d4	75 d0		 jne	 SHORT $LN4@the_real_p

; 1766 :     hdl_addshut( "panel_cleanup", panel_cleanup, NULL );

  000d6	45 33 c0	 xor	 r8d, r8d
  000d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:panel_cleanup
  000e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169325
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hdl_addshut

; 1767 :     history_init();

  000ed	e8 00 00 00 00	 call	 history_init

; 1768 : 
; 1769 : #if defined(HAVE_REGEX_H) || defined(HAVE_PCRE)
; 1770 :     init_HHC_regexp();
; 1771 : #endif
; 1772 : 
; 1773 :     /* Set Some Function Key Defaults */
; 1774 :     {
; 1775 :         set_symbol("PF01", "SUBST IMMED help &0");

  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169326
  000f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169327
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 1776 :         set_symbol("PF11", "IMMED devlist TAPE");

  00106	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169328
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169329
  00114	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 1777 :         set_symbol("PF10", "SUBST DELAY devinit &*");

  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169330
  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169331
  00128	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 1778 :     }
; 1779 : 
; 1780 :     /* Set up the input file descriptors */
; 1781 :     confp = stderr;

  0012e	b9 02 00 00 00	 mov	 ecx, 2
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00139	48 89 05 00 00
	00 00		 mov	 QWORD PTR confp, rax

; 1782 :     keybfd = STDIN_FILENO;

  00140	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR keybfd, 0

; 1783 : 
; 1784 :     /* Initialize screen dimensions */
; 1785 :     cons_term = get_symbol( "TERM" ); // Note! result could be "" empty string!

  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169332
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_get_symbol
  00157	48 89 05 00 00
	00 00		 mov	 QWORD PTR cons_term, rax

; 1786 :     get_dim (&cons_rows, &cons_cols);

  0015e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cons_cols
  00165	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cons_rows
  0016c	e8 00 00 00 00	 call	 get_dim

; 1787 : 
; 1788 :     /* Clear the command-line buffer */
; 1789 :     memset(cmdline, 0, sizeof(cmdline));

  00171	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  00178	48 8b f8	 mov	 rdi, rax
  0017b	33 c0		 xor	 eax, eax
  0017d	b9 01 01 00 00	 mov	 ecx, 257		; 00000101H
  00182	f3 aa		 rep stosb

; 1790 :     cmdcols = cons_cols - CMDLINE_COL;

  00184	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169333
  0018b	e8 00 00 00 00	 call	 strlen
  00190	48 ff c0	 inc	 rax
  00193	98		 cwde
  00194	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_cols
  0019a	2b c8		 sub	 ecx, eax
  0019c	8b c1		 mov	 eax, ecx
  0019e	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcols, eax

; 1791 : 
; 1792 :     /* Obtain storage for the keyboard buffer */
; 1793 :     if (!(kbbuf = malloc (kbbufsize)))

  001a4	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR kbbufsize$[rsp]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001b2	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR kbbuf$[rsp], rax
  001ba	48 83 bc 24 88
	00 00 00 00	 cmp	 QWORD PTR kbbuf$[rsp], 0
  001c3	0f 85 9e 00 00
	00		 jne	 $LN168@the_real_p

; 1794 :     {
; 1795 :         char buf[40];
; 1796 :         MSGBUF(buf, "malloc(%d)", (int)kbbufsize);

  001c9	44 8b 8c 24 c0
	01 00 00	 mov	 r9d, DWORD PTR kbbufsize$[rsp]
  001d1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169335
  001d8	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  001dd	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$45[rsp]
  001e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1797 :         WRMSG(HHC00075, "E", buf, strerror(errno));

  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001f1	8b 08		 mov	 ecx, DWORD PTR [rax]
  001f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001f9	48 89 84 24 28
	02 00 00	 mov	 QWORD PTR tv134[rsp], rax
  00201	b9 01 00 00 00	 mov	 ecx, 1
  00206	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0020c	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR tv134[rsp]
  00214	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00219	48 8d 8c 24 40
	03 00 00	 lea	 rcx, QWORD PTR buf$45[rsp]
  00221	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00226	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169336
  0022d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00232	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169337
  00239	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0023e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00243	41 b9 03 00 00
	00		 mov	 r9d, 3
  00249	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169338
  00250	ba 05 07 00 00	 mov	 edx, 1797		; 00000705H
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169339
  0025c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1798 :         return;

  00262	e9 43 49 00 00	 jmp	 $LN1@the_real_p
$LN168@the_real_p:

; 1799 :     }
; 1800 : 
; 1801 :     /* Obtain storage for the circular message buffer */
; 1802 :     msgbuf = malloc (MAX_MSGS * sizeof(PANMSG));

  00267	b9 00 c0 08 00	 mov	 ecx, 573440		; 0008c000H
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00272	48 89 05 00 00
	00 00		 mov	 QWORD PTR msgbuf, rax

; 1803 :     if (msgbuf == NULL)

  00279	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR msgbuf, 0
  00281	75 72		 jne	 SHORT $LN169@the_real_p

; 1804 :     {
; 1805 :         char buf[40];
; 1806 :         MSGBUF(buf, "malloc(%d)", (int)(MAX_MSGS * (int)sizeof(PANMSG)));

  00283	41 b9 00 c0 08
	00		 mov	 r9d, 573440		; 0008c000H
  00289	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169341
  00290	ba 28 00 00 00	 mov	 edx, 40			; 00000028H
  00295	48 8d 8c 24 68
	03 00 00	 lea	 rcx, QWORD PTR buf$46[rsp]
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 1807 :         fprintf (stderr,

  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a9	8b 08		 mov	 ecx, DWORD PTR [rax]
  002ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002b1	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR tv163[rsp], rax
  002b9	b9 02 00 00 00	 mov	 ecx, 2
  002be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002c4	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR tv163[rsp]
  002cc	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002d1	4c 8d 8c 24 68
	03 00 00	 lea	 r9, QWORD PTR buf$46[rsp]
  002d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169342
  002e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169343
  002e7	48 8b c8	 mov	 rcx, rax
  002ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fprintf

; 1808 :                 MSG(HHC00075, "E", buf, strerror(errno)));
; 1809 :         return;

  002f0	e9 b5 48 00 00	 jmp	 $LN1@the_real_p
$LN169@the_real_p:

; 1810 :     }
; 1811 : 
; 1812 :     /* Initialize circular message buffer */
; 1813 :     for (curmsg = msgbuf, i=0; i < MAX_MSGS; curmsg++, i++)

  002f5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR msgbuf
  002fc	48 89 05 00 00
	00 00		 mov	 QWORD PTR curmsg, rax
  00303	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0030b	eb 1e		 jmp	 SHORT $LN7@the_real_p
$LN5@the_real_p:
  0030d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  00314	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  0031a	48 89 05 00 00
	00 00		 mov	 QWORD PTR curmsg, rax
  00321	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00325	ff c0		 inc	 eax
  00327	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN7@the_real_p:
  0032b	81 7c 24 70 00
	08 00 00	 cmp	 DWORD PTR i$[rsp], 2048	; 00000800H
  00333	7d 5c		 jge	 SHORT $LN6@the_real_p

; 1814 :     {
; 1815 :         curmsg->next = curmsg + 1;

  00335	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  0033c	48 05 18 01 00
	00		 add	 rax, 280		; 00000118H
  00342	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR curmsg
  00349	48 89 01	 mov	 QWORD PTR [rcx], rax

; 1816 :         curmsg->prev = curmsg - 1;

  0034c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  00353	48 2d 18 01 00
	00		 sub	 rax, 280		; 00000118H
  00359	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR curmsg
  00360	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1817 :         curmsg->msgnum = i;

  00364	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  0036b	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  0036f	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 1818 :         memset(curmsg->msg,SPACE,MSG_SIZE);

  00372	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  00379	48 83 c0 14	 add	 rax, 20
  0037d	48 8b f8	 mov	 rdi, rax
  00380	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  00385	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0038a	f3 aa		 rep stosb

; 1819 :     }

  0038c	e9 7c ff ff ff	 jmp	 $LN5@the_real_p
$LN6@the_real_p:

; 1820 : 
; 1821 :     /* Complete the circle */
; 1822 :     msgbuf->prev = msgbuf + MAX_MSGS - 1;

  00391	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR msgbuf
  00398	48 05 e8 be 08
	00		 add	 rax, 573160		; 0008bee8H
  0039e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR msgbuf
  003a5	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 1823 :     msgbuf->prev->next = msgbuf;

  003a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR msgbuf
  003b0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  003b4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR msgbuf
  003bb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1824 : 
; 1825 :     /* Indicate "first-time" state */
; 1826 :     curmsg = topmsg = NULL;

  003be	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR topmsg, 0
  003c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  003d0	48 89 05 00 00
	00 00		 mov	 QWORD PTR curmsg, rax

; 1827 :     wrapped = 0;

  003d7	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR wrapped, 0

; 1828 :     numkept = 0;

  003e1	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR numkept, 0

; 1829 : 
; 1830 :     /* Set screen output stream to NON-buffered */
; 1831 :     setvbuf (confp, NULL, _IONBF, 0);

  003eb	45 33 c9	 xor	 r9d, r9d
  003ee	41 b8 04 00 00
	00		 mov	 r8d, 4
  003f4	33 d2		 xor	 edx, edx
  003f6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  003fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf

; 1832 : 
; 1833 :     /* Put the terminal into cbreak mode */
; 1834 :     set_or_reset_console_mode( keybfd, 1 );

  00403	66 ba 01 00	 mov	 dx, 1
  00407	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR keybfd
  0040d	e8 00 00 00 00	 call	 set_or_reset_console_mode

; 1835 : 
; 1836 :     /* Set console title */
; 1837 :     set_console_title(NULL);

  00412	33 c9		 xor	 ecx, ecx
  00414	e8 00 00 00 00	 call	 set_console_title

; 1838 : 
; 1839 :     /* Clear the screen */
; 1840 :     set_color (COLOR_DEFAULT_FG, COLOR_DEFAULT_BG);

  00419	66 ba 11 00	 mov	 dx, 17
  0041d	66 b9 10 00	 mov	 cx, 16
  00421	e8 00 00 00 00	 call	 set_color

; 1841 :     clr_screen ();

  00426	e8 00 00 00 00	 call	 clr_screen

; 1842 :     redraw_msgs = redraw_cmd = redraw_status = 1;

  0042b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1
  00435	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_status
  0043b	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_cmd, eax
  00441	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_cmd
  00447	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_msgs, eax

; 1843 : 
; 1844 :     /* Notify logger_thread we're in control */
; 1845 :     sysblk.panel_init = 1;

  0044d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00454	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0045a	83 c8 08	 or	 eax, 8
  0045d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00464	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 1846 : 
; 1847 :     /* Initialize "maxrates" command reporting intervals */
; 1848 :     if ( maxrates_rpt_intvl == 1440 )

  0046a	81 3d 00 00 00
	00 a0 05 00 00	 cmp	 DWORD PTR maxrates_rpt_intvl, 1440 ; 000005a0H
  00474	75 7d		 jne	 SHORT $LN170@the_real_p

; 1849 :     {
; 1850 :         time_t      current_time;
; 1851 :         struct tm  *current_tm;
; 1852 :         time_t      since_midnight = 0;

  00476	48 c7 84 24 c8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR since_midnight$30[rsp], 0

; 1853 :         current_time = time( NULL );

  00482	33 c9		 xor	 ecx, ecx
  00484	e8 00 00 00 00	 call	 time
  00489	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR current_time$31[rsp], rax

; 1854 :         current_tm   = localtime( &current_time );

  00491	48 8d 8c 24 d0
	01 00 00	 lea	 rcx, QWORD PTR current_time$31[rsp]
  00499	e8 00 00 00 00	 call	 localtime
  0049e	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR current_tm$27[rsp], rax

; 1855 :         since_midnight = (time_t)( ( ( current_tm->tm_hour  * 60 ) +

  004a6	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR current_tm$27[rsp]
  004ae	6b 40 08 3c	 imul	 eax, DWORD PTR [rax+8], 60 ; 0000003cH
  004b2	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR current_tm$27[rsp]
  004ba	03 41 04	 add	 eax, DWORD PTR [rcx+4]
  004bd	6b c0 3c	 imul	 eax, eax, 60		; 0000003cH
  004c0	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR current_tm$27[rsp]
  004c8	03 01		 add	 eax, DWORD PTR [rcx]
  004ca	48 98		 cdqe
  004cc	48 89 84 24 c8
	01 00 00	 mov	 QWORD PTR since_midnight$30[rsp], rax

; 1856 :                                        current_tm->tm_min ) * 60   +
; 1857 :                                        current_tm->tm_sec );
; 1858 :         curr_int_start_time = current_time - since_midnight;

  004d4	48 8b 84 24 c8
	01 00 00	 mov	 rax, QWORD PTR since_midnight$30[rsp]
  004dc	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR current_time$31[rsp]
  004e4	48 2b c8	 sub	 rcx, rax
  004e7	48 8b c1	 mov	 rax, rcx
  004ea	48 89 05 00 00
	00 00		 mov	 QWORD PTR curr_int_start_time, rax

; 1859 :     }

  004f1	eb 0e		 jmp	 SHORT $LN171@the_real_p
$LN170@the_real_p:

; 1860 :     else
; 1861 :         curr_int_start_time = time( NULL );

  004f3	33 c9		 xor	 ecx, ecx
  004f5	e8 00 00 00 00	 call	 time
  004fa	48 89 05 00 00
	00 00		 mov	 QWORD PTR curr_int_start_time, rax
$LN171@the_real_p:

; 1862 : 
; 1863 :     prev_int_start_time = curr_int_start_time;

  00501	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curr_int_start_time
  00508	48 89 05 00 00
	00 00		 mov	 QWORD PTR prev_int_start_time, rax

; 1864 : 
; 1865 :     /* Process messages and commands */
; 1866 :     for (loopcount = 0; ; loopcount++)

  0050f	48 c7 84 24 d8
	01 00 00 00 00
	00 00		 mov	 QWORD PTR loopcount$[rsp], 0
  0051b	eb 13		 jmp	 SHORT $LN10@the_real_p
$LN8@the_real_p:
  0051d	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR loopcount$[rsp]
  00525	48 ff c0	 inc	 rax
  00528	48 89 84 24 d8
	01 00 00	 mov	 QWORD PTR loopcount$[rsp], rax
$LN10@the_real_p:

; 1867 :     {
; 1868 : #if defined( _MSVC_ )
; 1869 :         /* Wait for keyboard input */
; 1870 :         for (i = sysblk.panrate / WAIT_FOR_KEYBOARD_INPUT_SLEEP_MILLISECS; i && !kbhit(); i--)

  00530	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00537	8b 80 30 11 00
	00		 mov	 eax, DWORD PTR [rax+4400]
  0053d	99		 cdq
  0053e	b9 14 00 00 00	 mov	 ecx, 20
  00543	f7 f9		 idiv	 ecx
  00545	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  00549	eb 0a		 jmp	 SHORT $LN13@the_real_p
$LN11@the_real_p:
  0054b	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0054f	ff c8		 dec	 eax
  00551	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN13@the_real_p:
  00555	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  0055a	74 17		 je	 SHORT $LN12@the_real_p
  0055c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_kbhit
  00562	85 c0		 test	 eax, eax
  00564	75 0d		 jne	 SHORT $LN12@the_real_p

; 1871 :             Sleep(                WAIT_FOR_KEYBOARD_INPUT_SLEEP_MILLISECS );

  00566	b9 14 00 00 00	 mov	 ecx, 20
  0056b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
  00571	eb d8		 jmp	 SHORT $LN11@the_real_p
$LN12@the_real_p:
$LN16@the_real_p:

; 1872 : 
; 1873 :         ADJ_SCREEN_SIZE();

  00573	48 8d 94 24 68
	01 00 00	 lea	 rdx, QWORD PTR cols$23[rsp]
  0057b	48 8d 8c 24 64
	01 00 00	 lea	 rcx, QWORD PTR rows$22[rsp]
  00583	e8 00 00 00 00	 call	 get_dim
  00588	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  0058e	39 84 24 64 01
	00 00		 cmp	 DWORD PTR rows$22[rsp], eax
  00595	75 0f		 jne	 SHORT $LN173@the_real_p
  00597	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_cols
  0059d	39 84 24 68 01
	00 00		 cmp	 DWORD PTR cols$23[rsp], eax
  005a4	74 6b		 je	 SHORT $LN172@the_real_p
$LN173@the_real_p:
  005a6	8b 84 24 64 01
	00 00		 mov	 eax, DWORD PTR rows$22[rsp]
  005ad	89 05 00 00 00
	00		 mov	 DWORD PTR cons_rows, eax
  005b3	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR cols$23[rsp]
  005ba	89 05 00 00 00
	00		 mov	 DWORD PTR cons_cols, eax
  005c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169348
  005c7	e8 00 00 00 00	 call	 strlen
  005cc	48 ff c0	 inc	 rax
  005cf	98		 cwde
  005d0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_cols
  005d6	2b c8		 sub	 ecx, eax
  005d8	8b c1		 mov	 eax, ecx
  005da	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcols, eax
  005e0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1
  005ea	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_status
  005f0	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_cmd, eax
  005f6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_cmd
  005fc	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_msgs, eax
  00602	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPDinit, 0
  0060c	e8 00 00 00 00	 call	 clr_screen
$LN172@the_real_p:
  00611	33 c0		 xor	 eax, eax
  00613	85 c0		 test	 eax, eax
  00615	0f 85 58 ff ff
	ff		 jne	 $LN16@the_real_p

; 1874 : 
; 1875 :         /* If keyboard input has [finally] arrived, then process it */
; 1876 :         if ( kbhit() )

  0061b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_kbhit
  00621	85 c0		 test	 eax, eax
  00623	0f 84 85 2e 00
	00		 je	 $LN174@the_real_p

; 1877 :         {
; 1878 :             /* Read character(s) from the keyboard */
; 1879 :             kbbuf[0] = getch();

  00629	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getch
  0062f	b9 01 00 00 00	 mov	 ecx, 1
  00634	48 6b c9 00	 imul	 rcx, rcx, 0
  00638	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR kbbuf$[rsp]
  00640	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1880 :             kbbuf[kblen=1] = '\0';

  00643	c7 84 24 d4 00
	00 00 01 00 00
	00		 mov	 DWORD PTR kblen$[rsp], 1
  0064e	48 63 84 24 d4
	00 00 00	 movsxd	 rax, DWORD PTR kblen$[rsp]
  00656	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0065e	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1881 :             translate_keystroke( kbbuf, &kblen );

  00662	48 8d 94 24 d4
	00 00 00	 lea	 rdx, QWORD PTR kblen$[rsp]
  0066a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  00672	e8 00 00 00 00	 call	 translate_keystroke

; 1882 : 
; 1883 : #else // !defined( _MSVC_ )
; 1884 : 
; 1885 :         /* Set the file descriptors for select */
; 1886 :         FD_ZERO (&readset);
; 1887 :         FD_SET (keybfd, &readset);
; 1888 : 
; 1889 :         /* Wait for a key to be pressed,
; 1890 :            or the inactivity interval to expire */
; 1891 :         tv.tv_sec  =  sysblk.panrate / 1000;
; 1892 :         tv.tv_usec = (sysblk.panrate * 1000) % 1000000;
; 1893 :         rc = select (keybfd + 1, &readset, NULL, NULL, &tv);
; 1894 :         if (rc < 0 )
; 1895 :         {
; 1896 :             if (errno == EINTR) continue;
; 1897 :             // "select: %s"
; 1898 :             fprintf (stderr, MSG(HHC00014, "E", strerror(errno) ) );
; 1899 :             break;
; 1900 :         }
; 1901 : 
; 1902 :         ADJ_SCREEN_SIZE();
; 1903 : 
; 1904 :         /* If keyboard input has arrived then process it */
; 1905 :         if (loopcount && FD_ISSET(keybfd, &readset))
; 1906 :         {
; 1907 :             /* Read character(s) from the keyboard */
; 1908 :             kblen = read (keybfd, kbbuf, kbbufsize-1);
; 1909 : 
; 1910 :             if (kblen < 0)
; 1911 :             {
; 1912 :                 // "keyboard read: %s"
; 1913 :                 fprintf (stderr, MSG(HHC00015, "E", strerror(errno) ) );
; 1914 :                 break;
; 1915 :             }
; 1916 :             if (!kblen)
; 1917 :             {
; 1918 :                 panel_command("quit");             /* Force shutdown */
; 1919 :                 break;                /* EOF on input.  Don't loop   */
; 1920 :             }
; 1921 : 
; 1922 :             kbbuf[kblen] = '\0';
; 1923 : 
; 1924 : #endif // defined( _MSVC_ )
; 1925 : 
; 1926 :             /* =NP= : Intercept NP commands & process */
; 1927 :             if (NPDup == 1)

  00677	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDup, 1
  0067e	0f 85 99 0b 00
	00		 jne	 $LN175@the_real_p

; 1928 :             {
; 1929 :                 if (NPdevsel == 1)

  00684	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPdevsel, 1
  0068b	75 40		 jne	 SHORT $LN176@the_real_p

; 1930 :                 {
; 1931 :                     NPdevsel = 0;

  0068d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPdevsel, 0

; 1932 :                     NPdevice = kbbuf[0];  /* save the device selected */

  00697	b8 01 00 00 00	 mov	 eax, 1
  0069c	48 6b c0 00	 imul	 rax, rax, 0
  006a0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  006a8	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  006ac	88 05 00 00 00
	00		 mov	 BYTE PTR NPdevice, al

; 1933 :                     kbbuf[0] = NPsel2;    /* setup for 2nd part of rtn */

  006b2	b8 01 00 00 00	 mov	 eax, 1
  006b7	48 6b c0 00	 imul	 rax, rax, 0
  006bb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  006c3	0f b6 15 00 00
	00 00		 movzx	 edx, BYTE PTR NPsel2
  006ca	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
$LN176@the_real_p:

; 1934 :                 }
; 1935 :                 if (NPdataentry == 0 && kblen == 1)

  006cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPdataentry, 0
  006d4	0f 85 bb 0a 00
	00		 jne	 $LN177@the_real_p
  006da	83 bc 24 d4 00
	00 00 01	 cmp	 DWORD PTR kblen$[rsp], 1
  006e2	0f 85 ad 0a 00
	00		 jne	 $LN177@the_real_p

; 1936 :                 {   /* We are in command mode */
; 1937 :                     if (NPhelpup == 1)

  006e8	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPhelpup, 1
  006ef	75 43		 jne	 SHORT $LN179@the_real_p

; 1938 :                     {
; 1939 :                         if (kbbuf[0] == 0x1b)

  006f1	b8 01 00 00 00	 mov	 eax, 1
  006f6	48 6b c0 00	 imul	 rax, rax, 0
  006fa	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  00702	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00706	83 f8 1b	 cmp	 eax, 27
  00709	75 0a		 jne	 SHORT $LN180@the_real_p

; 1940 :                             NPhelpdown = 1;

  0070b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPhelpdown, 1
$LN180@the_real_p:

; 1941 :                         kbbuf[0] = '\0';

  00715	b8 01 00 00 00	 mov	 eax, 1
  0071a	48 6b c0 00	 imul	 rax, rax, 0
  0071e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  00726	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 1942 :                         redraw_status = 1;

  0072a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1
$LN179@the_real_p:

; 1943 :                     }
; 1944 :                     cmdline[0] = '\0';

  00734	b8 01 00 00 00	 mov	 eax, 1
  00739	48 6b c0 00	 imul	 rax, rax, 0
  0073d	48 89 84 24 e0
	01 00 00	 mov	 QWORD PTR $T32[rsp], rax
  00745	48 81 bc 24 e0
	01 00 00 01 01
	00 00		 cmp	 QWORD PTR $T32[rsp], 257 ; 00000101H
  00751	73 02		 jae	 SHORT $LN513@the_real_p
  00753	eb 05		 jmp	 SHORT $LN514@the_real_p
$LN513@the_real_p:
  00755	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN514@the_real_p:
  0075a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  00761	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR $T32[rsp]
  00769	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 1945 :                     cmdlen = 0;

  0076d	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdlen, 0

; 1946 :                     cmdoff = 0;

  00777	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdoff, 0
$LN19@the_real_p:

; 1947 :                     ADJ_CMDCOL();

  00781	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00787	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0078d	2b c8		 sub	 ecx, eax
  0078f	8b c1		 mov	 eax, ecx
  00791	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  00797	7e 18		 jle	 SHORT $LN181@the_real_p
  00799	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  0079f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  007a5	2b c8		 sub	 ecx, eax
  007a7	8b c1		 mov	 eax, ecx
  007a9	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  007af	eb 1a		 jmp	 SHORT $LN182@the_real_p
$LN181@the_real_p:
  007b1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  007b7	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  007bd	7d 0c		 jge	 SHORT $LN183@the_real_p
  007bf	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  007c5	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN183@the_real_p:
$LN182@the_real_p:
  007cb	33 c0		 xor	 eax, eax
  007cd	85 c0		 test	 eax, eax
  007cf	75 b0		 jne	 SHORT $LN19@the_real_p

; 1948 :                     switch(kbbuf[0]) {

  007d1	b8 01 00 00 00	 mov	 eax, 1
  007d6	48 6b c0 00	 imul	 rax, rax, 0
  007da	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  007e2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  007e6	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv306[rsp], eax
  007ed	8b 84 24 f0 00
	00 00		 mov	 eax, DWORD PTR tv306[rsp]
  007f4	ff c8		 dec	 eax
  007f6	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv306[rsp], eax
  007fd	83 bc 24 f0 00
	00 00 76	 cmp	 DWORD PTR tv306[rsp], 118 ; 00000076H
  00805	0f 87 7e 09 00
	00		 ja	 $LN257@the_real_p
  0080b	48 63 84 24 f0
	00 00 00	 movsxd	 rax, DWORD PTR tv306[rsp]
  00813	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0081a	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN566@the_real_p[rcx+rax]
  00822	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN567@the_real_p[rcx+rax*4]
  00829	48 03 c1	 add	 rax, rcx
  0082c	ff e0		 jmp	 rax
$LN184@the_real_p:

; 1949 :                         case 0x1B:                  /* ESC */
; 1950 :                             NPDup = 0;

  0082e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPDup, 0

; 1951 :                             restore_command_line();

  00838	e8 00 00 00 00	 call	 restore_command_line
$LN24@the_real_p:

; 1952 :                             ADJ_CMDCOL();

  0083d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00843	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  00849	2b c8		 sub	 ecx, eax
  0084b	8b c1		 mov	 eax, ecx
  0084d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  00853	7e 18		 jle	 SHORT $LN185@the_real_p
  00855	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  0085b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  00861	2b c8		 sub	 ecx, eax
  00863	8b c1		 mov	 eax, ecx
  00865	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  0086b	eb 1a		 jmp	 SHORT $LN186@the_real_p
$LN185@the_real_p:
  0086d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  00873	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  00879	7d 0c		 jge	 SHORT $LN187@the_real_p
  0087b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  00881	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN187@the_real_p:
$LN186@the_real_p:
  00887	33 c0		 xor	 eax, eax
  00889	85 c0		 test	 eax, eax
  0088b	75 b0		 jne	 SHORT $LN24@the_real_p

; 1953 :                             redraw_msgs = redraw_cmd = redraw_status = 1;

  0088d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1
  00897	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_status
  0089d	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_cmd, eax
  008a3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_cmd
  008a9	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_msgs, eax

; 1954 :                             npquiet = 0; // (forced for one paint cycle)

  008af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR npquiet, 0

; 1955 :                             break;

  008b9	e9 cb 08 00 00	 jmp	 $LN20@the_real_p
$LN188@the_real_p:

; 1956 :                         case '?':
; 1957 :                             NPhelpup = 1;

  008be	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPhelpup, 1

; 1958 :                             redraw_status = 1;

  008c8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 1959 :                             break;

  008d2	e9 b2 08 00 00	 jmp	 $LN20@the_real_p
$LN189@the_real_p:
$LN190@the_real_p:

; 1960 :                         case 'S':                   /* START */
; 1961 :                         case 's':
; 1962 :                             if (!sysblk.hicpu)

  008d7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  008de	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  008e5	75 05		 jne	 SHORT $LN191@the_real_p

; 1963 :                               break;

  008e7	e9 9d 08 00 00	 jmp	 $LN20@the_real_p
$LN191@the_real_p:

; 1964 :                             do_panel_command( "startall" );

  008ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169367
  008f3	e8 00 00 00 00	 call	 do_panel_command

; 1965 :                             break;

  008f8	e9 8c 08 00 00	 jmp	 $LN20@the_real_p
$LN192@the_real_p:
$LN193@the_real_p:

; 1966 :                         case 'P':                   /* STOP */
; 1967 :                         case 'p':
; 1968 :                             if (!sysblk.hicpu)

  008fd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00904	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0090b	75 05		 jne	 SHORT $LN194@the_real_p

; 1969 :                               break;

  0090d	e9 77 08 00 00	 jmp	 $LN20@the_real_p
$LN194@the_real_p:

; 1970 :                             do_panel_command( "stopall" );

  00912	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169371
  00919	e8 00 00 00 00	 call	 do_panel_command

; 1971 :                             break;

  0091e	e9 66 08 00 00	 jmp	 $LN20@the_real_p
$LN195@the_real_p:
$LN196@the_real_p:

; 1972 :                         case 'O':                   /* Store */
; 1973 :                         case 'o':
; 1974 :                             if (!sysblk.hicpu)

  00923	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0092a	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00931	75 05		 jne	 SHORT $LN197@the_real_p

; 1975 :                               break;

  00933	e9 51 08 00 00	 jmp	 $LN20@the_real_p
$LN197@the_real_p:

; 1976 :                             regs = panel_copy_regs(sysblk.pcpu);

  00938	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0093f	8b 88 54 13 00
	00		 mov	 ecx, DWORD PTR [rax+4948]
  00945	e8 00 00 00 00	 call	 panel_copy_regs
  0094a	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR regs$[rsp], rax

; 1977 :                             aaddr = APPLY_PREFIXING (NPaddress, regs->PX);

  00952	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPaddress
  00958	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0095e	48 85 c0	 test	 rax, rax
  00961	74 2b		 je	 SHORT $LN515@the_real_p
  00963	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPaddress
  00969	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  0096f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  00977	8b 49 70	 mov	 ecx, DWORD PTR [rcx+112]
  0097a	48 3b c1	 cmp	 rax, rcx
  0097d	74 0f		 je	 SHORT $LN515@the_real_p
  0097f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPaddress
  00985	89 84 24 70 01
	00 00		 mov	 DWORD PTR tv333[rsp], eax
  0098c	eb 1c		 jmp	 SHORT $LN516@the_real_p
$LN515@the_real_p:
  0098e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  00996	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00999	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR NPaddress
  0099f	33 c8		 xor	 ecx, eax
  009a1	8b c1		 mov	 eax, ecx
  009a3	89 84 24 70 01
	00 00		 mov	 DWORD PTR tv333[rsp], eax
$LN516@the_real_p:
  009aa	8b 84 24 70 01
	00 00		 mov	 eax, DWORD PTR tv333[rsp]
  009b1	89 84 24 74 01
	00 00		 mov	 DWORD PTR aaddr$[rsp], eax

; 1978 :                             if (aaddr > regs->mainlim)

  009b8	8b 84 24 74 01
	00 00		 mov	 eax, DWORD PTR aaddr$[rsp]
  009bf	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  009c7	48 3b 81 58 08
	00 00		 cmp	 rax, QWORD PTR [rcx+2136]
  009ce	76 05		 jbe	 SHORT $LN198@the_real_p

; 1979 :                                 break;

  009d0	e9 b4 07 00 00	 jmp	 $LN20@the_real_p
$LN198@the_real_p:

; 1980 :                             store_fw (regs->mainstor + aaddr, NPdata);

  009d5	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR NPdata
  009db	e8 00 00 00 00	 call	 _byteswap_ulong
  009e0	8b 8c 24 74 01
	00 00		 mov	 ecx, DWORD PTR aaddr$[rsp]
  009e7	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR regs$[rsp]
  009ef	48 03 8a 48 08
	00 00		 add	 rcx, QWORD PTR [rdx+2120]
  009f6	8b d0		 mov	 edx, eax
  009f8	e8 00 00 00 00	 call	 store_fw_noswap

; 1981 :                             redraw_status = 1;

  009fd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 1982 :                             break;

  00a07	e9 7d 07 00 00	 jmp	 $LN20@the_real_p
$LN199@the_real_p:
$LN200@the_real_p:

; 1983 :                         case 'I':                   /* Display */
; 1984 :                         case 'i':
; 1985 :                             if (!sysblk.hicpu)

  00a0c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a13	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00a1a	75 05		 jne	 SHORT $LN201@the_real_p

; 1986 :                               break;

  00a1c	e9 68 07 00 00	 jmp	 $LN20@the_real_p
$LN201@the_real_p:

; 1987 :                             NPregdisp = 4;

  00a21	c7 05 00 00 00
	00 04 00 00 00	 mov	 DWORD PTR NPregdisp, 4

; 1988 :                             NPregs_valid = 0;

  00a2b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPregs_valid, 0

; 1989 :                             redraw_status = 1;

  00a35	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 1990 :                             break;

  00a3f	e9 45 07 00 00	 jmp	 $LN20@the_real_p
$LN202@the_real_p:
$LN203@the_real_p:

; 1991 :                         case 'g':                   /* display GPR */
; 1992 :                         case 'G':
; 1993 :                             if (!sysblk.hicpu)

  00a44	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a4b	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00a52	75 05		 jne	 SHORT $LN204@the_real_p

; 1994 :                               break;

  00a54	e9 30 07 00 00	 jmp	 $LN20@the_real_p
$LN204@the_real_p:

; 1995 :                             NPregdisp = 0;

  00a59	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPregdisp, 0

; 1996 :                             NPregs_valid = 0;

  00a63	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPregs_valid, 0

; 1997 :                             redraw_status = 1;

  00a6d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 1998 :                             break;

  00a77	e9 0d 07 00 00	 jmp	 $LN20@the_real_p
$LN205@the_real_p:
$LN206@the_real_p:

; 1999 :                         case 'a':                   /* Display AR */
; 2000 :                         case 'A':
; 2001 :                             if (!sysblk.hicpu)

  00a7c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00a83	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00a8a	75 05		 jne	 SHORT $LN207@the_real_p

; 2002 :                               break;

  00a8c	e9 f8 06 00 00	 jmp	 $LN20@the_real_p
$LN207@the_real_p:

; 2003 :                             NPregdisp = 2;

  00a91	c7 05 00 00 00
	00 02 00 00 00	 mov	 DWORD PTR NPregdisp, 2

; 2004 :                             NPregs_valid = 0;

  00a9b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPregs_valid, 0

; 2005 :                             redraw_status = 1;

  00aa5	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2006 :                             break;

  00aaf	e9 d5 06 00 00	 jmp	 $LN20@the_real_p
$LN208@the_real_p:
$LN209@the_real_p:

; 2007 :                         case 'c':
; 2008 :                         case 'C':                   /* Case CR */
; 2009 :                             if (!sysblk.hicpu)

  00ab4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00abb	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00ac2	75 05		 jne	 SHORT $LN210@the_real_p

; 2010 :                               break;

  00ac4	e9 c0 06 00 00	 jmp	 $LN20@the_real_p
$LN210@the_real_p:

; 2011 :                             NPregdisp = 1;

  00ac9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPregdisp, 1

; 2012 :                             NPregs_valid = 0;

  00ad3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPregs_valid, 0

; 2013 :                             redraw_status = 1;

  00add	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2014 :                             break;

  00ae7	e9 9d 06 00 00	 jmp	 $LN20@the_real_p
$LN211@the_real_p:
$LN212@the_real_p:

; 2015 :                         case 'f':                   /* Case FPR */
; 2016 :                         case 'F':
; 2017 :                             if (!sysblk.hicpu)

  00aec	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00af3	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00afa	75 05		 jne	 SHORT $LN213@the_real_p

; 2018 :                               break;

  00afc	e9 88 06 00 00	 jmp	 $LN20@the_real_p
$LN213@the_real_p:

; 2019 :                             NPregdisp = 3;

  00b01	c7 05 00 00 00
	00 03 00 00 00	 mov	 DWORD PTR NPregdisp, 3

; 2020 :                             NPregs_valid = 0;

  00b0b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPregs_valid, 0

; 2021 :                             redraw_status = 1;

  00b15	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2022 :                             break;

  00b1f	e9 65 06 00 00	 jmp	 $LN20@the_real_p
$LN214@the_real_p:
$LN215@the_real_p:

; 2023 :                         case 'r':                   /* Enter address */
; 2024 :                         case 'R':
; 2025 :                             if (!sysblk.hicpu)

  00b24	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b2b	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00b32	75 05		 jne	 SHORT $LN216@the_real_p

; 2026 :                               break;

  00b34	e9 50 06 00 00	 jmp	 $LN20@the_real_p
$LN216@the_real_p:

; 2027 :                             NPdataentry = 1;

  00b39	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdataentry, 1

; 2028 :                             redraw_cmd = 1;

  00b43	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2029 :                             NPpending = 'r';

  00b4d	c6 05 00 00 00
	00 72		 mov	 BYTE PTR NPpending, 114	; 00000072H

; 2030 :                             NPcurrow = 16;

  00b54	b8 10 00 00 00	 mov	 eax, 16
  00b59	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurrow, ax

; 2031 :                             NPcurcol = 12;

  00b60	b8 0c 00 00 00	 mov	 eax, 12
  00b65	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurcol, ax

; 2032 :                             NPdatalen = 8;

  00b6c	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR NPdatalen, 8

; 2033 :                             NPcolorSwitch = 1;

  00b76	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPcolorSwitch, 1

; 2034 :                             NPcolorFore = COLOR_WHITE;

  00b80	b8 0f 00 00 00	 mov	 eax, 15
  00b85	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcolorFore, ax

; 2035 :                             NPcolorBack = COLOR_BLUE;

  00b8c	b8 03 00 00 00	 mov	 eax, 3
  00b91	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcolorBack, ax

; 2036 :                             STRLCPY( NPentered, "" );

  00b98	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00b9e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169394
  00ba5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPentered
  00bac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2037 :                             STRLCPY( NPprompt1, "Enter Address" );

  00bb2	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00bb8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169395
  00bbf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  00bc6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2038 :                             redraw_status = 1;

  00bcc	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2039 :                             break;

  00bd6	e9 ae 05 00 00	 jmp	 $LN20@the_real_p
$LN217@the_real_p:
$LN218@the_real_p:

; 2040 :                         case 'd':                   /* Enter data */
; 2041 :                         case 'D':
; 2042 :                             if (!sysblk.hicpu)

  00bdb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00be2	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00be9	75 05		 jne	 SHORT $LN219@the_real_p

; 2043 :                               break;

  00beb	e9 99 05 00 00	 jmp	 $LN20@the_real_p
$LN219@the_real_p:

; 2044 :                             NPdataentry = 1;

  00bf0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdataentry, 1

; 2045 :                             redraw_cmd = 1;

  00bfa	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2046 :                             NPpending = 'd';

  00c04	c6 05 00 00 00
	00 64		 mov	 BYTE PTR NPpending, 100	; 00000064H

; 2047 :                             NPcurrow = 16;

  00c0b	b8 10 00 00 00	 mov	 eax, 16
  00c10	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurrow, ax

; 2048 :                             NPcurcol = 30;

  00c17	b8 1e 00 00 00	 mov	 eax, 30
  00c1c	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurcol, ax

; 2049 :                             NPdatalen = 8;

  00c23	c7 05 00 00 00
	00 08 00 00 00	 mov	 DWORD PTR NPdatalen, 8

; 2050 :                             NPcolorSwitch = 1;

  00c2d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPcolorSwitch, 1

; 2051 :                             NPcolorFore = COLOR_WHITE;

  00c37	b8 0f 00 00 00	 mov	 eax, 15
  00c3c	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcolorFore, ax

; 2052 :                             NPcolorBack = COLOR_BLUE;

  00c43	b8 03 00 00 00	 mov	 eax, 3
  00c48	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcolorBack, ax

; 2053 :                             STRLCPY( NPentered, "" );

  00c4f	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00c55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169399
  00c5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPentered
  00c63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2054 :                             STRLCPY( NPprompt1, "Enter Data Value" );

  00c69	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00c6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169400
  00c76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  00c7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2055 :                             redraw_status = 1;

  00c83	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2056 :                             break;

  00c8d	e9 f7 04 00 00	 jmp	 $LN20@the_real_p
$LN220@the_real_p:
$LN221@the_real_p:

; 2057 :                         case 'l':                   /* IPL */
; 2058 :                         case 'L':
; 2059 :                             if (!sysblk.hicpu)

  00c92	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c99	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00ca0	75 05		 jne	 SHORT $LN222@the_real_p

; 2060 :                               break;

  00ca2	e9 e2 04 00 00	 jmp	 $LN20@the_real_p
$LN222@the_real_p:

; 2061 :                             NPdevsel = 1;

  00ca7	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdevsel, 1

; 2062 :                             NPsel2 = 1;

  00cb1	c6 05 00 00 00
	00 01		 mov	 BYTE PTR NPsel2, 1

; 2063 :                             STRLCPY( NPprompt2, "Select Device for IPL" );

  00cb8	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00cbe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169404
  00cc5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  00ccc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2064 :                             redraw_status = 1;

  00cd2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2065 :                             break;

  00cdc	e9 a8 04 00 00	 jmp	 $LN20@the_real_p
$LN223@the_real_p:

; 2066 :                         case 1:                     /* IPL - 2nd part */
; 2067 :                             if (!sysblk.hicpu)

  00ce1	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ce8	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00cef	75 05		 jne	 SHORT $LN224@the_real_p

; 2068 :                               break;

  00cf1	e9 93 04 00 00	 jmp	 $LN20@the_real_p
$LN224@the_real_p:

; 2069 :                             i = toupper(NPdevice) - 'A';

  00cf6	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  00cfd	8b c8		 mov	 ecx, eax
  00cff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00d05	83 e8 41	 sub	 eax, 65			; 00000041H
  00d08	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2070 :                             if (i < 0 || i > NPlastdev) {

  00d0c	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  00d11	7c 0c		 jl	 SHORT $LN226@the_real_p
  00d13	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPlastdev
  00d19	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00d1d	7e 22		 jle	 SHORT $LN225@the_real_p
$LN226@the_real_p:

; 2071 :                                 memset(NPprompt2,0,sizeof(NPprompt2));

  00d1f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt2
  00d26	48 8b f8	 mov	 rdi, rax
  00d29	33 c0		 xor	 eax, eax
  00d2b	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00d30	f3 aa		 rep stosb

; 2072 :                                 redraw_status = 1;

  00d32	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2073 :                                 break;

  00d3c	e9 48 04 00 00	 jmp	 $LN20@the_real_p
$LN225@the_real_p:

; 2074 :                             }
; 2075 :                             MSGBUF (cmdline, "ipl %4.4x", NPdevnum[i]);

  00d41	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00d46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnum
  00d4d	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00d51	44 8b c8	 mov	 r9d, eax
  00d54	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169409
  00d5b	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  00d60	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00d67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2076 :                             do_panel_command(cmdline);

  00d6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00d74	e8 00 00 00 00	 call	 do_panel_command

; 2077 :                             memset(NPprompt2,0,sizeof(NPprompt2));

  00d79	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt2
  00d80	48 8b f8	 mov	 rdi, rax
  00d83	33 c0		 xor	 eax, eax
  00d85	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00d8a	f3 aa		 rep stosb

; 2078 :                             redraw_status = 1;

  00d8c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2079 :                             break;

  00d96	e9 ee 03 00 00	 jmp	 $LN20@the_real_p
$LN227@the_real_p:
$LN228@the_real_p:

; 2080 :                         case 'u':                   /* Device interrupt */
; 2081 :                         case 'U':
; 2082 :                             NPdevsel = 1;

  00d9b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdevsel, 1

; 2083 :                             NPsel2 = 2;

  00da5	c6 05 00 00 00
	00 02		 mov	 BYTE PTR NPsel2, 2

; 2084 :                             STRLCPY( NPprompt2, "Select Device for Interrupt" );

  00dac	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00db2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169412
  00db9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  00dc0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2085 :                             redraw_status = 1;

  00dc6	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2086 :                             break;

  00dd0	e9 b4 03 00 00	 jmp	 $LN20@the_real_p
$LN229@the_real_p:

; 2087 :                         case 2:                     /* Device int: part 2 */
; 2088 :                             if (!sysblk.hicpu)

  00dd5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00ddc	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  00de3	75 05		 jne	 SHORT $LN230@the_real_p

; 2089 :                               break;

  00de5	e9 9f 03 00 00	 jmp	 $LN20@the_real_p
$LN230@the_real_p:

; 2090 :                             i = toupper(NPdevice) - 'A';

  00dea	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  00df1	8b c8		 mov	 ecx, eax
  00df3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00df9	83 e8 41	 sub	 eax, 65			; 00000041H
  00dfc	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2091 :                             if (i < 0 || i > NPlastdev) {

  00e00	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  00e05	7c 0c		 jl	 SHORT $LN232@the_real_p
  00e07	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPlastdev
  00e0d	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00e11	7e 22		 jle	 SHORT $LN231@the_real_p
$LN232@the_real_p:

; 2092 :                                 memset(NPprompt2,0,sizeof(NPprompt2));

  00e13	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt2
  00e1a	48 8b f8	 mov	 rdi, rax
  00e1d	33 c0		 xor	 eax, eax
  00e1f	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00e24	f3 aa		 rep stosb

; 2093 :                                 redraw_status = 1;

  00e26	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2094 :                                 break;

  00e30	e9 54 03 00 00	 jmp	 $LN20@the_real_p
$LN231@the_real_p:

; 2095 :                             }
; 2096 :                             MSGBUF( cmdline, "i %4.4x", NPdevnum[i]);

  00e35	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00e3a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnum
  00e41	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  00e45	44 8b c8	 mov	 r9d, eax
  00e48	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169417
  00e4f	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  00e54	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00e5b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2097 :                             do_panel_command(cmdline);

  00e61	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  00e68	e8 00 00 00 00	 call	 do_panel_command

; 2098 :                             memset(NPprompt2,0,sizeof(NPprompt2));

  00e6d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt2
  00e74	48 8b f8	 mov	 rdi, rax
  00e77	33 c0		 xor	 eax, eax
  00e79	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00e7e	f3 aa		 rep stosb

; 2099 :                             redraw_status = 1;

  00e80	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2100 :                             break;

  00e8a	e9 fa 02 00 00	 jmp	 $LN20@the_real_p
$LN233@the_real_p:
$LN234@the_real_p:

; 2101 :                         case 'n':                   /* Device Assignment */
; 2102 :                         case 'N':
; 2103 :                             NPdevsel = 1;

  00e8f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdevsel, 1

; 2104 :                             NPsel2 = 3;

  00e99	c6 05 00 00 00
	00 03		 mov	 BYTE PTR NPsel2, 3

; 2105 :                             STRLCPY( NPprompt2, "Select Device to Reassign" );

  00ea0	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00ea6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169420
  00ead	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  00eb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2106 :                             redraw_status = 1;

  00eba	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2107 :                             break;

  00ec4	e9 c0 02 00 00	 jmp	 $LN20@the_real_p
$LN235@the_real_p:

; 2108 :                         case 3:                     /* Device asgn: part 2 */
; 2109 :                             i = toupper(NPdevice) - 'A';

  00ec9	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  00ed0	8b c8		 mov	 ecx, eax
  00ed2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_toupper
  00ed8	83 e8 41	 sub	 eax, 65			; 00000041H
  00edb	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2110 :                             if (i < 0 || i > NPlastdev) {

  00edf	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  00ee4	7c 0c		 jl	 SHORT $LN237@the_real_p
  00ee6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR NPlastdev
  00eec	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00ef0	7e 22		 jle	 SHORT $LN236@the_real_p
$LN237@the_real_p:

; 2111 :                                 memset(NPprompt2,0,sizeof(NPprompt2));

  00ef2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt2
  00ef9	48 8b f8	 mov	 rdi, rax
  00efc	33 c0		 xor	 eax, eax
  00efe	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  00f03	f3 aa		 rep stosb

; 2112 :                                 redraw_status = 1;

  00f05	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2113 :                                 break;

  00f0f	e9 75 02 00 00	 jmp	 $LN20@the_real_p
$LN236@the_real_p:

; 2114 :                             }
; 2115 :                             NPdataentry = 1;

  00f14	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdataentry, 1

; 2116 :                             redraw_cmd = 1;

  00f1e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2117 :                             NPpending = 'n';

  00f28	c6 05 00 00 00
	00 6e		 mov	 BYTE PTR NPpending, 110	; 0000006eH

; 2118 :                             NPasgn = i;

  00f2f	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00f33	89 05 00 00 00
	00		 mov	 DWORD PTR NPasgn, eax

; 2119 :                             NPcurrow = 3 + i;

  00f39	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00f3d	83 c0 03	 add	 eax, 3
  00f40	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurrow, ax

; 2120 :                             NPcurcol = 58;

  00f47	b8 3a 00 00 00	 mov	 eax, 58			; 0000003aH
  00f4c	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurcol, ax

; 2121 :                             NPdatalen = cons_cols - 57;

  00f53	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_cols
  00f59	83 e8 39	 sub	 eax, 57			; 00000039H
  00f5c	89 05 00 00 00
	00		 mov	 DWORD PTR NPdatalen, eax

; 2122 :                             NPcolorSwitch = 1;

  00f62	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPcolorSwitch, 1

; 2123 :                             NPcolorFore = COLOR_DEFAULT_LIGHT;

  00f6c	b8 12 00 00 00	 mov	 eax, 18
  00f71	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcolorFore, ax

; 2124 :                             NPcolorBack = COLOR_BLUE;

  00f78	b8 03 00 00 00	 mov	 eax, 3
  00f7d	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcolorBack, ax

; 2125 :                             memset(NPentered,0,sizeof(NPentered));

  00f84	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPentered
  00f8b	48 8b f8	 mov	 rdi, rax
  00f8e	33 c0		 xor	 eax, eax
  00f90	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  00f95	f3 aa		 rep stosb

; 2126 :                             STRLCPY( NPprompt2, "New Name, or [enter] to Reload" );

  00f97	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00f9d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169424
  00fa4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  00fab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2127 :                             redraw_status = 1;

  00fb1	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2128 :                             break;

  00fbb	e9 c9 01 00 00	 jmp	 $LN20@the_real_p
$LN238@the_real_p:
$LN239@the_real_p:

; 2129 :                         case 'W':                   /* POWER */
; 2130 :                         case 'w':
; 2131 :                             NPdevsel = 1;

  00fc0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdevsel, 1

; 2132 :                             NPsel2 = 4;

  00fca	c6 05 00 00 00
	00 04		 mov	 BYTE PTR NPsel2, 4

; 2133 :                             STRLCPY( NPprompt1, "Confirm Powerdown Y or N" );

  00fd1	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  00fd7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169427
  00fde	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  00fe5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2134 :                             redraw_status = 1;

  00feb	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2135 :                             break;

  00ff5	e9 8f 01 00 00	 jmp	 $LN20@the_real_p
$LN240@the_real_p:

; 2136 :                         case 4:                     /* POWER - 2nd part */
; 2137 :                             if (NPdevice == 'y' || NPdevice == 'Y')

  00ffa	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  01001	83 f8 79	 cmp	 eax, 121		; 00000079H
  01004	74 0c		 je	 SHORT $LN242@the_real_p
  01006	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  0100d	83 f8 59	 cmp	 eax, 89			; 00000059H
  01010	75 0c		 jne	 SHORT $LN241@the_real_p
$LN242@the_real_p:

; 2138 :                                 do_panel_command( "quit" );

  01012	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169431
  01019	e8 00 00 00 00	 call	 do_panel_command
$LN241@the_real_p:

; 2139 :                             memset(NPprompt1, 0, sizeof(NPprompt1));

  0101e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt1
  01025	48 8b f8	 mov	 rdi, rax
  01028	33 c0		 xor	 eax, eax
  0102a	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0102f	f3 aa		 rep stosb

; 2140 :                             redraw_status = 1;

  01031	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2141 :                             break;

  0103b	e9 49 01 00 00	 jmp	 $LN20@the_real_p
$LN243@the_real_p:
$LN244@the_real_p:

; 2142 :                         case 'T':                   /* Restart */
; 2143 :                         case 't':
; 2144 :                             if (!sysblk.hicpu)

  01040	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01047	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0104e	75 05		 jne	 SHORT $LN245@the_real_p

; 2145 :                               break;

  01050	e9 34 01 00 00	 jmp	 $LN20@the_real_p
$LN245@the_real_p:

; 2146 :                             NPdevsel = 1;

  01055	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdevsel, 1

; 2147 :                             NPsel2 = 5;

  0105f	c6 05 00 00 00
	00 05		 mov	 BYTE PTR NPsel2, 5

; 2148 :                             STRLCPY( NPprompt1, "Confirm Restart Y or N" );

  01066	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  0106c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169435
  01073	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  0107a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2149 :                             redraw_status = 1;

  01080	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2150 :                             break;

  0108a	e9 fa 00 00 00	 jmp	 $LN20@the_real_p
$LN246@the_real_p:

; 2151 :                         case 5:                    /* Restart - part 2 */
; 2152 :                             if (!sysblk.hicpu)

  0108f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  01096	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  0109d	75 05		 jne	 SHORT $LN247@the_real_p

; 2153 :                               break;

  0109f	e9 e5 00 00 00	 jmp	 $LN20@the_real_p
$LN247@the_real_p:

; 2154 :                             if (NPdevice == 'y' || NPdevice == 'Y')

  010a4	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  010ab	83 f8 79	 cmp	 eax, 121		; 00000079H
  010ae	74 0c		 je	 SHORT $LN249@the_real_p
  010b0	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  010b7	83 f8 59	 cmp	 eax, 89			; 00000059H
  010ba	75 0c		 jne	 SHORT $LN248@the_real_p
$LN249@the_real_p:

; 2155 :                                 do_panel_command( "restart" );

  010bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169440
  010c3	e8 00 00 00 00	 call	 do_panel_command
$LN248@the_real_p:

; 2156 :                             memset(NPprompt1, 0, sizeof(NPprompt1));

  010c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt1
  010cf	48 8b f8	 mov	 rdi, rax
  010d2	33 c0		 xor	 eax, eax
  010d4	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  010d9	f3 aa		 rep stosb

; 2157 :                             redraw_status = 1;

  010db	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2158 :                             break;

  010e5	e9 9f 00 00 00	 jmp	 $LN20@the_real_p
$LN250@the_real_p:
$LN251@the_real_p:

; 2159 :                         case 'E':                   /* Ext int */
; 2160 :                         case 'e':
; 2161 :                             if (!sysblk.hicpu)

  010ea	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  010f1	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  010f8	75 05		 jne	 SHORT $LN252@the_real_p

; 2162 :                               break;

  010fa	e9 8a 00 00 00	 jmp	 $LN20@the_real_p
$LN252@the_real_p:

; 2163 :                             NPdevsel = 1;

  010ff	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPdevsel, 1

; 2164 :                             NPsel2 = 6;

  01109	c6 05 00 00 00
	00 06		 mov	 BYTE PTR NPsel2, 6

; 2165 :                             STRLCPY( NPprompt1, "Confirm External Interrupt Y or N" );

  01110	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  01116	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169444
  0111d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  01124	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2166 :                             redraw_status = 1;

  0112a	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2167 :                             break;

  01134	eb 53		 jmp	 SHORT $LN20@the_real_p
$LN253@the_real_p:

; 2168 :                         case 6:                    /* External - part 2 */
; 2169 :                             if (!sysblk.hicpu)

  01136	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0113d	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  01144	75 02		 jne	 SHORT $LN254@the_real_p

; 2170 :                               break;

  01146	eb 41		 jmp	 SHORT $LN20@the_real_p
$LN254@the_real_p:

; 2171 :                             if (NPdevice == 'y' || NPdevice == 'Y')

  01148	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  0114f	83 f8 79	 cmp	 eax, 121		; 00000079H
  01152	74 0c		 je	 SHORT $LN256@the_real_p
  01154	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR NPdevice
  0115b	83 f8 59	 cmp	 eax, 89			; 00000059H
  0115e	75 0c		 jne	 SHORT $LN255@the_real_p
$LN256@the_real_p:

; 2172 :                                 do_panel_command( "ext" );

  01160	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169449
  01167	e8 00 00 00 00	 call	 do_panel_command
$LN255@the_real_p:

; 2173 :                             memset(NPprompt1, 0, sizeof(NPprompt1));

  0116c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt1
  01173	48 8b f8	 mov	 rdi, rax
  01176	33 c0		 xor	 eax, eax
  01178	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0117d	f3 aa		 rep stosb

; 2174 :                             redraw_status = 1;

  0117f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1
$LN257@the_real_p:
$LN20@the_real_p:

; 2175 :                             break;
; 2176 :                         default:
; 2177 :                             break;
; 2178 :                     }
; 2179 :                     NPcmd = 1;

  01189	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPcmd, 1

; 2180 :                 } else {  /* We are in data entry mode */

  01193	eb 74		 jmp	 SHORT $LN178@the_real_p
$LN177@the_real_p:

; 2181 :                     if (kbbuf[0] == 0x1B) {

  01195	b8 01 00 00 00	 mov	 eax, 1
  0119a	48 6b c0 00	 imul	 rax, rax, 0
  0119e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  011a6	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  011aa	83 f8 1b	 cmp	 eax, 27
  011ad	75 50		 jne	 SHORT $LN258@the_real_p

; 2182 :                         /* Switch back to command mode */
; 2183 :                         NPdataentry = 0;

  011af	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPdataentry, 0

; 2184 :                         NPaddr_valid = 0;

  011b9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPaddr_valid, 0

; 2185 :                         NPdata_valid = 0;

  011c3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPdata_valid, 0

; 2186 :                         memset(NPprompt1, 0,sizeof(NPprompt1));

  011cd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt1
  011d4	48 8b f8	 mov	 rdi, rax
  011d7	33 c0		 xor	 eax, eax
  011d9	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  011de	f3 aa		 rep stosb

; 2187 :                         memset(NPprompt2, 0, sizeof(NPprompt2));

  011e0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:NPprompt2
  011e7	48 8b f8	 mov	 rdi, rax
  011ea	33 c0		 xor	 eax, eax
  011ec	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  011f1	f3 aa		 rep stosb

; 2188 :                         NPcmd = 1;

  011f3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPcmd, 1

; 2189 :                     }

  011fd	eb 0a		 jmp	 SHORT $LN259@the_real_p
$LN258@the_real_p:

; 2190 :                     else
; 2191 :                         NPcmd = 0;

  011ff	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPcmd, 0
$LN259@the_real_p:
$LN178@the_real_p:

; 2192 :                 }
; 2193 :                 if (NPcmd == 1)

  01209	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPcmd, 1
  01210	75 0b		 jne	 SHORT $LN260@the_real_p

; 2194 :                     kblen = 0;                  /* don't process as command */

  01212	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR kblen$[rsp], 0
$LN260@the_real_p:
$LN175@the_real_p:

; 2195 :             }
; 2196 :             /* =NP END= */
; 2197 : 
; 2198 :             /* Process characters in the keyboard buffer */
; 2199 :             for (i = 0; i < kblen; )

  0121d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN25@the_real_p:
  01225	8b 84 24 d4 00
	00 00		 mov	 eax, DWORD PTR kblen$[rsp]
  0122c	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  01230	0f 8d 78 22 00
	00		 jge	 $LN26@the_real_p

; 2200 :             {
; 2201 : #if defined ( _MSVC_ )
; 2202 :                 /* Test for PF key  Windows */
; 2203 :                 if ( strlen(kbbuf+i) == 4 && kbbuf[i] == '\x1b' && kbbuf[i+1] == ')' ) /* this is a PF Key */

  01236	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0123b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  01243	48 03 c8	 add	 rcx, rax
  01246	48 8b c1	 mov	 rax, rcx
  01249	48 8b c8	 mov	 rcx, rax
  0124c	e8 00 00 00 00	 call	 strlen
  01251	48 83 f8 04	 cmp	 rax, 4
  01255	0f 85 a6 0d 00
	00		 jne	 $LN261@the_real_p
  0125b	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  01260	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  01268	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0126c	83 f8 1b	 cmp	 eax, 27
  0126f	0f 85 8c 0d 00
	00		 jne	 $LN261@the_real_p
  01275	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  01279	ff c0		 inc	 eax
  0127b	48 98		 cdqe
  0127d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  01285	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01289	83 f8 29	 cmp	 eax, 41			; 00000029H
  0128c	0f 85 6f 0d 00
	00		 jne	 $LN261@the_real_p

; 2204 :                 {
; 2205 :                     char szPF[6];
; 2206 :                     char msgbuf[32];
; 2207 :                     char *pf;
; 2208 :                     char *psz_PF;
; 2209 :                     int j;
; 2210 : 
; 2211 :                     MSGBUF( szPF, "PF%s", kbbuf+2 );

  01292	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR kbbuf$[rsp]
  0129a	48 83 c0 02	 add	 rax, 2
  0129e	4c 8b c8	 mov	 r9, rax
  012a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169455
  012a8	ba 06 00 00 00	 mov	 edx, 6
  012ad	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR szPF$42[rsp]
  012b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2212 :                     szPF[4] = '\0';

  012bb	b8 01 00 00 00	 mov	 eax, 1
  012c0	48 6b c0 04	 imul	 rax, rax, 4
  012c4	48 89 84 24 e8
	01 00 00	 mov	 QWORD PTR $T33[rsp], rax
  012cc	48 83 bc 24 e8
	01 00 00 06	 cmp	 QWORD PTR $T33[rsp], 6
  012d5	73 02		 jae	 SHORT $LN517@the_real_p
  012d7	eb 05		 jmp	 SHORT $LN518@the_real_p
$LN517@the_real_p:
  012d9	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN518@the_real_p:
  012de	48 8b 84 24 e8
	01 00 00	 mov	 rax, QWORD PTR $T33[rsp]
  012e6	c6 84 04 b0 02
	00 00 00	 mov	 BYTE PTR szPF$42[rsp+rax], 0

; 2213 : 
; 2214 : #else   // ! _MSVC_
; 2215 :                 if ( !strcmp(kbbuf+i, KBD_PF1) || !strcmp(kbbuf+i, KBD_PF1_a) ||
; 2216 :                      !strcmp(kbbuf+i, KBD_PF2) || !strcmp(kbbuf+i, KBD_PF2_a) ||
; 2217 :                      !strcmp(kbbuf+i, KBD_PF3) || !strcmp(kbbuf+i, KBD_PF3_a) ||
; 2218 :                      !strcmp(kbbuf+i, KBD_PF4) || !strcmp(kbbuf+i, KBD_PF4_a) ||
; 2219 :                      !strcmp(kbbuf+i, KBD_PF5) || !strcmp(kbbuf+i, KBD_PF6  ) ||
; 2220 :                      !strcmp(kbbuf+i, KBD_PF7) || !strcmp(kbbuf+i, KBD_PF8  ) ||
; 2221 :                      !strcmp(kbbuf+i, KBD_PF9) || !strcmp(kbbuf+i, KBD_PF10 ) ||
; 2222 :                      !strcmp(kbbuf+i, KBD_PF11)|| !strcmp(kbbuf+i, KBD_PF12 ) ||
; 2223 :                      !strcmp(kbbuf+i, KBD_PF13)|| !strcmp(kbbuf+i, KBD_PF14 ) ||
; 2224 :                      !strcmp(kbbuf+i, KBD_PF15)|| !strcmp(kbbuf+i, KBD_PF16 ) ||
; 2225 :                      !strcmp(kbbuf+i, KBD_PF17)|| !strcmp(kbbuf+i, KBD_PF18 ) ||
; 2226 :                      !strcmp(kbbuf+i, KBD_PF19)|| !strcmp(kbbuf+i, KBD_PF20 ) )
; 2227 :                 {
; 2228 :                     char *szPF;
; 2229 :                     char msgbuf[32];
; 2230 :                     char *pf;
; 2231 :                     char *psz_PF;
; 2232 :                     int j;
; 2233 : 
; 2234 :                     if      ( !strcmp(kbbuf+i, KBD_PF1) || !strcmp(kbbuf+i, KBD_PF1_a) ) szPF = "PF01";
; 2235 :                     else if ( !strcmp(kbbuf+i, KBD_PF2) || !strcmp(kbbuf+i, KBD_PF2_a) ) szPF = "PF02";
; 2236 :                     else if ( !strcmp(kbbuf+i, KBD_PF3) || !strcmp(kbbuf+i, KBD_PF3_a) ) szPF = "PF03";
; 2237 :                     else if ( !strcmp(kbbuf+i, KBD_PF4) || !strcmp(kbbuf+i, KBD_PF4_a) ) szPF = "PF04";
; 2238 :                     else if ( !strcmp(kbbuf+i, KBD_PF5)                                ) szPF = "PF05";
; 2239 :                     else if ( !strcmp(kbbuf+i, KBD_PF6)                                ) szPF = "PF06";
; 2240 :                     else if ( !strcmp(kbbuf+i, KBD_PF7)                                ) szPF = "PF07";
; 2241 :                     else if ( !strcmp(kbbuf+i, KBD_PF8)                                ) szPF = "PF08";
; 2242 :                     else if ( !strcmp(kbbuf+i, KBD_PF9)                                ) szPF = "PF09";
; 2243 :                     else if ( !strcmp(kbbuf+i, KBD_PF10)                               ) szPF = "PF10";
; 2244 :                     else if ( !strcmp(kbbuf+i, KBD_PF11)                               ) szPF = "PF11";
; 2245 :                     else if ( !strcmp(kbbuf+i, KBD_PF12)                               ) szPF = "PF12";
; 2246 :                     else if ( !strcmp(kbbuf+i, KBD_PF13)                               ) szPF = "PF13";
; 2247 :                     else if ( !strcmp(kbbuf+i, KBD_PF14)                               ) szPF = "PF14";
; 2248 :                     else if ( !strcmp(kbbuf+i, KBD_PF15)                               ) szPF = "PF15";
; 2249 :                     else if ( !strcmp(kbbuf+i, KBD_PF16)                               ) szPF = "PF16";
; 2250 :                     else if ( !strcmp(kbbuf+i, KBD_PF17)                               ) szPF = "PF17";
; 2251 :                     else if ( !strcmp(kbbuf+i, KBD_PF18)                               ) szPF = "PF18";
; 2252 :                     else if ( !strcmp(kbbuf+i, KBD_PF19)                               ) szPF = "PF19";
; 2253 :                     else if ( !strcmp(kbbuf+i, KBD_PF20)                               ) szPF = "PF20";
; 2254 :                     else szPF = NULL;
; 2255 : #endif
; 2256 : 
; 2257 :                     if (!(pf = (char*) get_symbol( szPF )) || !*pf)

  012ee	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR szPF$42[rsp]
  012f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_get_symbol
  012fc	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR pf$24[rsp], rax
  01304	48 83 bc 24 80
	01 00 00 00	 cmp	 QWORD PTR pf$24[rsp], 0
  0130d	74 0f		 je	 SHORT $LN263@the_real_p
  0130f	48 8b 84 24 80
	01 00 00	 mov	 rax, QWORD PTR pf$24[rsp]
  01317	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0131a	85 c0		 test	 eax, eax
  0131c	75 32		 jne	 SHORT $LN262@the_real_p
$LN263@the_real_p:

; 2258 :                     {
; 2259 :                         MSGBUF( msgbuf, "DELAY * %s UNDEFINED", szPF );

  0131e	4c 8d 8c 24 b0
	02 00 00	 lea	 r9, QWORD PTR szPF$42[rsp]
  01326	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169458
  0132d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  01332	48 8d 8c 24 20
	03 00 00	 lea	 rcx, QWORD PTR msgbuf$44[rsp]
  0133a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2260 :                         pf = msgbuf;

  01340	48 8d 84 24 20
	03 00 00	 lea	 rax, QWORD PTR msgbuf$44[rsp]
  01348	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR pf$24[rsp], rax
$LN262@the_real_p:

; 2261 :                     }
; 2262 : 
; 2263 :                     psz_PF = strdup(pf);

  01350	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR pf$24[rsp]
  01358	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0135e	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR psz_PF$6[rsp], rax

; 2264 : 
; 2265 :                     /* test for 1st of IMMED, DELAY or SUBST */
; 2266 :                     for ( j = 0; j < (int)strlen(psz_PF); j++ )

  01366	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR j$1[rsp], 0
  0136e	eb 0a		 jmp	 SHORT $LN30@the_real_p
$LN28@the_real_p:
  01370	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  01374	ff c0		 inc	 eax
  01376	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
$LN30@the_real_p:
  0137a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01382	e8 00 00 00 00	 call	 strlen
  01387	39 44 24 74	 cmp	 DWORD PTR j$1[rsp], eax
  0138b	7d 1a		 jge	 SHORT $LN29@the_real_p

; 2267 :                         if ( psz_PF[j] != ' ' ) break;

  0138d	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  01392	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  0139a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0139e	83 f8 20	 cmp	 eax, 32			; 00000020H
  013a1	74 02		 je	 SHORT $LN264@the_real_p
  013a3	eb 02		 jmp	 SHORT $LN29@the_real_p
$LN264@the_real_p:
  013a5	eb c9		 jmp	 SHORT $LN28@the_real_p
$LN29@the_real_p:

; 2268 : 
; 2269 :                     if ( !strncasecmp( psz_PF+j, "IMMED ", 6 ) )

  013a7	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  013ac	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  013b4	48 03 c8	 add	 rcx, rax
  013b7	48 8b c1	 mov	 rax, rcx
  013ba	41 b8 06 00 00
	00		 mov	 r8d, 6
  013c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169462
  013c7	48 8b c8	 mov	 rcx, rax
  013ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  013d0	85 c0		 test	 eax, eax
  013d2	75 64		 jne	 SHORT $LN265@the_real_p

; 2270 :                     {
; 2271 :                         for ( j += 5; j < (int)strlen(psz_PF); j++ )

  013d4	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  013d8	83 c0 05	 add	 eax, 5
  013db	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
  013df	eb 0a		 jmp	 SHORT $LN33@the_real_p
$LN31@the_real_p:
  013e1	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  013e5	ff c0		 inc	 eax
  013e7	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
$LN33@the_real_p:
  013eb	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  013f3	e8 00 00 00 00	 call	 strlen
  013f8	39 44 24 74	 cmp	 DWORD PTR j$1[rsp], eax
  013fc	7d 1a		 jge	 SHORT $LN32@the_real_p

; 2272 :                             if ( psz_PF[j] != ' ' ) break;

  013fe	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  01403	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  0140b	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0140f	83 f8 20	 cmp	 eax, 32			; 00000020H
  01412	74 02		 je	 SHORT $LN267@the_real_p
  01414	eb 02		 jmp	 SHORT $LN32@the_real_p
$LN267@the_real_p:
  01416	eb c9		 jmp	 SHORT $LN31@the_real_p
$LN32@the_real_p:

; 2273 :                         do_panel_command( psz_PF+j );

  01418	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  0141d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01425	48 03 c8	 add	 rcx, rax
  01428	48 8b c1	 mov	 rax, rcx
  0142b	48 8b c8	 mov	 rcx, rax
  0142e	e8 00 00 00 00	 call	 do_panel_command

; 2274 :                     }

  01433	e9 a2 0b 00 00	 jmp	 $LN266@the_real_p
$LN265@the_real_p:

; 2275 :                     else if ( !strncasecmp( psz_PF+j, "DELAY ", 6 ) )

  01438	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  0143d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01445	48 03 c8	 add	 rcx, rax
  01448	48 8b c1	 mov	 rax, rcx
  0144b	41 b8 06 00 00
	00		 mov	 r8d, 6
  01451	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169466
  01458	48 8b c8	 mov	 rcx, rax
  0145b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  01461	85 c0		 test	 eax, eax
  01463	0f 85 09 01 00
	00		 jne	 $LN268@the_real_p

; 2276 :                     {
; 2277 :                         for ( j += 5; j < (int)strlen(psz_PF); j++ )

  01469	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  0146d	83 c0 05	 add	 eax, 5
  01470	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
  01474	eb 0a		 jmp	 SHORT $LN36@the_real_p
$LN34@the_real_p:
  01476	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  0147a	ff c0		 inc	 eax
  0147c	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
$LN36@the_real_p:
  01480	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01488	e8 00 00 00 00	 call	 strlen
  0148d	39 44 24 74	 cmp	 DWORD PTR j$1[rsp], eax
  01491	7d 1a		 jge	 SHORT $LN35@the_real_p

; 2278 :                             if ( psz_PF[j] != ' ' ) break;

  01493	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  01498	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  014a0	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  014a4	83 f8 20	 cmp	 eax, 32			; 00000020H
  014a7	74 02		 je	 SHORT $LN270@the_real_p
  014a9	eb 02		 jmp	 SHORT $LN35@the_real_p
$LN270@the_real_p:
  014ab	eb c9		 jmp	 SHORT $LN34@the_real_p
$LN35@the_real_p:

; 2279 :                         STRLCPY( cmdline, psz_PF+j );

  014ad	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  014b2	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  014ba	48 03 c8	 add	 rcx, rax
  014bd	48 8b c1	 mov	 rax, rcx
  014c0	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  014c6	48 8b d0	 mov	 rdx, rax
  014c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  014d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2280 :                         cmdlen = (int)strlen(cmdline);

  014d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  014dd	e8 00 00 00 00	 call	 strlen
  014e2	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 2281 :                         cmdoff = cmdlen < cmdcols ? cmdlen : 0;

  014e8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  014ee	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdlen, eax
  014f4	7d 0f		 jge	 SHORT $LN519@the_real_p
  014f6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  014fc	89 84 24 78 01
	00 00		 mov	 DWORD PTR tv700[rsp], eax
  01503	eb 0b		 jmp	 SHORT $LN520@the_real_p
$LN519@the_real_p:
  01505	c7 84 24 78 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv700[rsp], 0
$LN520@the_real_p:
  01510	8b 84 24 78 01
	00 00		 mov	 eax, DWORD PTR tv700[rsp]
  01517	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN39@the_real_p:

; 2282 :                         ADJ_CMDCOL();

  0151d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  01523	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  01529	2b c8		 sub	 ecx, eax
  0152b	8b c1		 mov	 eax, ecx
  0152d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  01533	7e 18		 jle	 SHORT $LN271@the_real_p
  01535	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  0153b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  01541	2b c8		 sub	 ecx, eax
  01543	8b c1		 mov	 eax, ecx
  01545	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  0154b	eb 1a		 jmp	 SHORT $LN272@the_real_p
$LN271@the_real_p:
  0154d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  01553	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  01559	7d 0c		 jge	 SHORT $LN273@the_real_p
  0155b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  01561	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN273@the_real_p:
$LN272@the_real_p:
  01567	33 c0		 xor	 eax, eax
  01569	85 c0		 test	 eax, eax
  0156b	75 b0		 jne	 SHORT $LN39@the_real_p

; 2283 :                     }

  0156d	e9 68 0a 00 00	 jmp	 $LN269@the_real_p
$LN268@the_real_p:

; 2284 :                     else if ( !strncasecmp( psz_PF+j, "SUBST ", 6 ) )

  01572	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  01577	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  0157f	48 03 c8	 add	 rcx, rax
  01582	48 8b c1	 mov	 rax, rcx
  01585	41 b8 06 00 00
	00		 mov	 r8d, 6
  0158b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169473
  01592	48 8b c8	 mov	 rcx, rax
  01595	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0159b	85 c0		 test	 eax, eax
  0159d	0f 85 2a 0a 00
	00		 jne	 $LN274@the_real_p

; 2285 :                     {
; 2286 :                         int  isdelay = TRUE;

  015a3	c7 84 24 1c 01
	00 00 01 00 00
	00		 mov	 DWORD PTR isdelay$20[rsp], 1

; 2287 :                         char *cmd_tok[11] = { NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL };

  015ae	48 c7 84 24 50
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp], 0
  015ba	48 c7 84 24 58
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+8], 0
  015c6	48 c7 84 24 60
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+16], 0
  015d2	48 c7 84 24 68
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+24], 0
  015de	48 c7 84 24 70
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+32], 0
  015ea	48 c7 84 24 78
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+40], 0
  015f6	48 c7 84 24 80
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+48], 0
  01602	48 c7 84 24 88
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+56], 0
  0160e	48 c7 84 24 90
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+64], 0
  0161a	48 c7 84 24 98
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+72], 0
  01626	48 c7 84 24 a0
	02 00 00 00 00
	00 00		 mov	 QWORD PTR cmd_tok$41[rsp+80], 0

; 2288 :                         int   ncmd_tok = 0;

  01632	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR ncmd_tok$7[rsp], 0

; 2289 :                         char *pt1;
; 2290 : 
; 2291 :                         for ( j += 5; j < (int)strlen(psz_PF); j++ )

  0163d	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  01641	83 c0 05	 add	 eax, 5
  01644	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
  01648	eb 0a		 jmp	 SHORT $LN42@the_real_p
$LN40@the_real_p:
  0164a	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  0164e	ff c0		 inc	 eax
  01650	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
$LN42@the_real_p:
  01654	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  0165c	e8 00 00 00 00	 call	 strlen
  01661	39 44 24 74	 cmp	 DWORD PTR j$1[rsp], eax
  01665	7d 1a		 jge	 SHORT $LN41@the_real_p

; 2292 :                             if ( psz_PF[j] != ' ' ) break;

  01667	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  0166c	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01674	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01678	83 f8 20	 cmp	 eax, 32			; 00000020H
  0167b	74 02		 je	 SHORT $LN276@the_real_p
  0167d	eb 02		 jmp	 SHORT $LN41@the_real_p
$LN276@the_real_p:
  0167f	eb c9		 jmp	 SHORT $LN40@the_real_p
$LN41@the_real_p:

; 2293 : 
; 2294 :                         if ( !strncasecmp( psz_PF+j, "IMMED ", 6 ) )

  01681	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  01686	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  0168e	48 03 c8	 add	 rcx, rax
  01691	48 8b c1	 mov	 rax, rcx
  01694	41 b8 06 00 00
	00		 mov	 r8d, 6
  0169a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169477
  016a1	48 8b c8	 mov	 rcx, rax
  016a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  016aa	85 c0		 test	 eax, eax
  016ac	75 51		 jne	 SHORT $LN277@the_real_p

; 2295 :                         {
; 2296 :                             isdelay = FALSE;

  016ae	c7 84 24 1c 01
	00 00 00 00 00
	00		 mov	 DWORD PTR isdelay$20[rsp], 0

; 2297 :                             for ( j += 5; j < (int)strlen(psz_PF); j++ )

  016b9	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  016bd	83 c0 05	 add	 eax, 5
  016c0	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
  016c4	eb 0a		 jmp	 SHORT $LN45@the_real_p
$LN43@the_real_p:
  016c6	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  016ca	ff c0		 inc	 eax
  016cc	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
$LN45@the_real_p:
  016d0	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  016d8	e8 00 00 00 00	 call	 strlen
  016dd	39 44 24 74	 cmp	 DWORD PTR j$1[rsp], eax
  016e1	7d 1a		 jge	 SHORT $LN44@the_real_p

; 2298 :                                 if ( psz_PF[j] != ' ' ) break;

  016e3	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  016e8	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  016f0	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  016f4	83 f8 20	 cmp	 eax, 32			; 00000020H
  016f7	74 02		 je	 SHORT $LN279@the_real_p
  016f9	eb 02		 jmp	 SHORT $LN44@the_real_p
$LN279@the_real_p:
  016fb	eb c9		 jmp	 SHORT $LN43@the_real_p
$LN44@the_real_p:

; 2299 : 
; 2300 :                         }

  016fd	eb 71		 jmp	 SHORT $LN278@the_real_p
$LN277@the_real_p:

; 2301 :                         else if ( !strncasecmp( psz_PF+j, "DELAY ", 6 ) )

  016ff	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  01704	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  0170c	48 03 c8	 add	 rcx, rax
  0170f	48 8b c1	 mov	 rax, rcx
  01712	41 b8 06 00 00
	00		 mov	 r8d, 6
  01718	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169480
  0171f	48 8b c8	 mov	 rcx, rax
  01722	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  01728	85 c0		 test	 eax, eax
  0172a	75 44		 jne	 SHORT $LN280@the_real_p

; 2302 :                         {
; 2303 :                             for ( j += 5; j < (int)strlen(psz_PF); j++ )

  0172c	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  01730	83 c0 05	 add	 eax, 5
  01733	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
  01737	eb 0a		 jmp	 SHORT $LN48@the_real_p
$LN46@the_real_p:
  01739	8b 44 24 74	 mov	 eax, DWORD PTR j$1[rsp]
  0173d	ff c0		 inc	 eax
  0173f	89 44 24 74	 mov	 DWORD PTR j$1[rsp], eax
$LN48@the_real_p:
  01743	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  0174b	e8 00 00 00 00	 call	 strlen
  01750	39 44 24 74	 cmp	 DWORD PTR j$1[rsp], eax
  01754	7d 1a		 jge	 SHORT $LN47@the_real_p

; 2304 :                                 if ( psz_PF[j] != ' ' ) break;

  01756	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  0175b	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01763	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01767	83 f8 20	 cmp	 eax, 32			; 00000020H
  0176a	74 02		 je	 SHORT $LN281@the_real_p
  0176c	eb 02		 jmp	 SHORT $LN47@the_real_p
$LN281@the_real_p:
  0176e	eb c9		 jmp	 SHORT $LN46@the_real_p
$LN47@the_real_p:
$LN280@the_real_p:
$LN278@the_real_p:

; 2305 :                         }
; 2306 : 
; 2307 :                         if ( ( cmdlen = (int)strlen(cmdline) ) > 0 )

  01770	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  01777	e8 00 00 00 00	 call	 strlen
  0177c	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax
  01782	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cmdlen, 0
  01789	0f 8e d4 02 00
	00		 jle	 $LN282@the_real_p

; 2308 :                         {
; 2309 :                             char    psz_cmdline[sizeof(cmdline)];
; 2310 :                             char   *p = cmdline;

  0178f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  01796	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$5[rsp], rax
$LN49@the_real_p:

; 2311 : 
; 2312 :                             while (*p && ncmd_tok < 10 )

  0179e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  017a6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  017a9	85 c0		 test	 eax, eax
  017ab	0f 84 5e 02 00
	00		 je	 $LN50@the_real_p
  017b1	83 bc 24 c0 00
	00 00 0a	 cmp	 DWORD PTR ncmd_tok$7[rsp], 10
  017b9	0f 8d 50 02 00
	00		 jge	 $LN50@the_real_p
$LN51@the_real_p:

; 2313 :                             {
; 2314 :                                 while (*p && isspace(*p))

  017bf	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  017c7	0f be 00	 movsx	 eax, BYTE PTR [rax]
  017ca	85 c0		 test	 eax, eax
  017cc	74 2c		 je	 SHORT $LN52@the_real_p
  017ce	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  017d6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  017d9	8b c8		 mov	 ecx, eax
  017db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  017e1	85 c0		 test	 eax, eax
  017e3	74 15		 je	 SHORT $LN52@the_real_p

; 2315 :                                 {
; 2316 :                                     p++;

  017e5	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  017ed	48 ff c0	 inc	 rax
  017f0	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$5[rsp], rax

; 2317 :                                 }

  017f8	eb c5		 jmp	 SHORT $LN51@the_real_p
$LN52@the_real_p:

; 2318 :                                 if (!*p)

  017fa	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01802	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01805	85 c0		 test	 eax, eax
  01807	75 05		 jne	 SHORT $LN283@the_real_p

; 2319 :                                 {
; 2320 :                                     break; /* find start of arg */

  01809	e9 01 02 00 00	 jmp	 $LN50@the_real_p
$LN283@the_real_p:

; 2321 :                                 }
; 2322 : 
; 2323 :                                 if (*p == '#') break; // stop on comments

  0180e	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01816	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01819	83 f8 23	 cmp	 eax, 35			; 00000023H
  0181c	75 05		 jne	 SHORT $LN284@the_real_p
  0181e	e9 ec 01 00 00	 jmp	 $LN50@the_real_p
$LN284@the_real_p:

; 2324 : 
; 2325 :                                 cmd_tok[ncmd_tok] = p; ++ncmd_tok; // count new arg

  01823	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR ncmd_tok$7[rsp]
  0182b	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p$5[rsp]
  01833	48 89 8c c4 50
	02 00 00	 mov	 QWORD PTR cmd_tok$41[rsp+rax*8], rcx
  0183b	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ncmd_tok$7[rsp]
  01842	ff c0		 inc	 eax
  01844	89 84 24 c0 00
	00 00		 mov	 DWORD PTR ncmd_tok$7[rsp], eax
$LN53@the_real_p:

; 2326 : 
; 2327 :                                 while ( *p
; 2328 :                                         && !isspace(*p)
; 2329 :                                         && *p != '\"'
; 2330 :                                         && *p != '\'' )

  0184b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01853	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01856	85 c0		 test	 eax, eax
  01858	74 4c		 je	 SHORT $LN54@the_real_p
  0185a	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01862	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01865	8b c8		 mov	 ecx, eax
  01867	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  0186d	85 c0		 test	 eax, eax
  0186f	75 35		 jne	 SHORT $LN54@the_real_p
  01871	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01879	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0187c	83 f8 22	 cmp	 eax, 34			; 00000022H
  0187f	74 25		 je	 SHORT $LN54@the_real_p
  01881	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01889	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0188c	83 f8 27	 cmp	 eax, 39			; 00000027H
  0188f	74 15		 je	 SHORT $LN54@the_real_p

; 2331 :                                 {
; 2332 :                                     p++;

  01891	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01899	48 ff c0	 inc	 rax
  0189c	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$5[rsp], rax

; 2333 :                                 }

  018a4	eb a5		 jmp	 SHORT $LN53@the_real_p
$LN54@the_real_p:

; 2334 :                                 if (!*p)

  018a6	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  018ae	0f be 00	 movsx	 eax, BYTE PTR [rax]
  018b1	85 c0		 test	 eax, eax
  018b3	75 05		 jne	 SHORT $LN285@the_real_p

; 2335 :                                 {
; 2336 :                                     break; /* find end of arg */

  018b5	e9 55 01 00 00	 jmp	 $LN50@the_real_p
$LN285@the_real_p:

; 2337 :                                 }
; 2338 : 
; 2339 :                                 if (*p == '\"' || *p == '\'')

  018ba	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  018c2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  018c5	83 f8 22	 cmp	 eax, 34			; 00000022H
  018c8	74 14		 je	 SHORT $LN287@the_real_p
  018ca	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  018d2	0f be 00	 movsx	 eax, BYTE PTR [rax]
  018d5	83 f8 27	 cmp	 eax, 39			; 00000027H
  018d8	0f 85 0e 01 00
	00		 jne	 $LN286@the_real_p
$LN287@the_real_p:

; 2340 :                                 {
; 2341 :                                     char delim = *p;

  018de	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  018e6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  018e9	88 84 24 c8 00
	00 00		 mov	 BYTE PTR delim$8[rsp], al
$LN57@the_real_p:

; 2342 : 
; 2343 :                                     do {} while (*++p && *p != delim);

  018f0	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  018f8	48 ff c0	 inc	 rax
  018fb	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$5[rsp], rax
  01903	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  0190b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0190e	85 c0		 test	 eax, eax
  01910	74 17		 je	 SHORT $LN288@the_real_p
  01912	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  0191a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0191d	0f be 8c 24 c8
	00 00 00	 movsx	 ecx, BYTE PTR delim$8[rsp]
  01925	3b c1		 cmp	 eax, ecx
  01927	75 c7		 jne	 SHORT $LN57@the_real_p
$LN288@the_real_p:

; 2344 :                                     if (!*p) break;                    // find end of quoted string

  01929	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01931	0f be 00	 movsx	 eax, BYTE PTR [rax]
  01934	85 c0		 test	 eax, eax
  01936	75 05		 jne	 SHORT $LN289@the_real_p
  01938	e9 d2 00 00 00	 jmp	 $LN50@the_real_p
$LN289@the_real_p:

; 2345 :                                     p++;

  0193d	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01945	48 ff c0	 inc	 rax
  01948	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$5[rsp], rax

; 2346 :                                     if (!*p) break;                    // found end of args

  01950	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01958	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0195b	85 c0		 test	 eax, eax
  0195d	75 05		 jne	 SHORT $LN290@the_real_p
  0195f	e9 ab 00 00 00	 jmp	 $LN50@the_real_p
$LN290@the_real_p:

; 2347 : 
; 2348 :                                     if ( *p != ' ')

  01964	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  0196c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0196f	83 f8 20	 cmp	 eax, 32			; 00000020H
  01972	74 78		 je	 SHORT $LN291@the_real_p

; 2349 :                                     {
; 2350 :                                         strlcpy(psz_cmdline, p, sizeof(cmdline));

  01974	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  0197a	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR p$5[rsp]
  01982	48 8d 8c 24 90
	08 00 00	 lea	 rcx, QWORD PTR psz_cmdline$47[rsp]
  0198a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2351 :                                         *p = ' ';                       // insert a space

  01990	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  01998	c6 00 20	 mov	 BYTE PTR [rax], 32	; 00000020H

; 2352 :                                         strcpy(p+1, psz_cmdline);

  0199b	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  019a3	48 ff c0	 inc	 rax
  019a6	48 8d 94 24 90
	08 00 00	 lea	 rdx, QWORD PTR psz_cmdline$47[rsp]
  019ae	48 8b c8	 mov	 rcx, rax
  019b1	e8 00 00 00 00	 call	 strcpy

; 2353 :                                         psz_cmdline[0] = 0;

  019b6	b8 01 00 00 00	 mov	 eax, 1
  019bb	48 6b c0 00	 imul	 rax, rax, 0
  019bf	48 89 84 24 f0
	01 00 00	 mov	 QWORD PTR $T34[rsp], rax
  019c7	48 81 bc 24 f0
	01 00 00 01 01
	00 00		 cmp	 QWORD PTR $T34[rsp], 257 ; 00000101H
  019d3	73 02		 jae	 SHORT $LN521@the_real_p
  019d5	eb 05		 jmp	 SHORT $LN522@the_real_p
$LN521@the_real_p:
  019d7	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN522@the_real_p:
  019dc	48 8b 84 24 f0
	01 00 00	 mov	 rax, QWORD PTR $T34[rsp]
  019e4	c6 84 04 90 08
	00 00 00	 mov	 BYTE PTR psz_cmdline$47[rsp+rax], 0
$LN291@the_real_p:
$LN286@the_real_p:

; 2354 :                                     }
; 2355 :                                 }
; 2356 : 
; 2357 :                                 *p++ = 0; // mark end of arg

  019ec	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  019f4	c6 00 00	 mov	 BYTE PTR [rax], 0
  019f7	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR p$5[rsp]
  019ff	48 ff c0	 inc	 rax
  01a02	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR p$5[rsp], rax

; 2358 :                             }

  01a0a	e9 8f fd ff ff	 jmp	 $LN49@the_real_p
$LN50@the_real_p:

; 2359 : 
; 2360 :                             ncmd_tok--;

  01a0f	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ncmd_tok$7[rsp]
  01a16	ff c8		 dec	 eax
  01a18	89 84 24 c0 00
	00 00		 mov	 DWORD PTR ncmd_tok$7[rsp], eax

; 2361 : 
; 2362 :                             /* token 10 represents the rest of the line */
; 2363 :                             if ( ncmd_tok == 9 && strlen(p) > 0 )

  01a1f	83 bc 24 c0 00
	00 00 09	 cmp	 DWORD PTR ncmd_tok$7[rsp], 9
  01a27	75 3a		 jne	 SHORT $LN292@the_real_p
  01a29	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p$5[rsp]
  01a31	e8 00 00 00 00	 call	 strlen
  01a36	48 85 c0	 test	 rax, rax
  01a39	76 28		 jbe	 SHORT $LN292@the_real_p

; 2364 :                                 cmd_tok[++ncmd_tok] = p;

  01a3b	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR ncmd_tok$7[rsp]
  01a42	ff c0		 inc	 eax
  01a44	89 84 24 c0 00
	00 00		 mov	 DWORD PTR ncmd_tok$7[rsp], eax
  01a4b	48 63 84 24 c0
	00 00 00	 movsxd	 rax, DWORD PTR ncmd_tok$7[rsp]
  01a53	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR p$5[rsp]
  01a5b	48 89 8c c4 50
	02 00 00	 mov	 QWORD PTR cmd_tok$41[rsp+rax*8], rcx
$LN292@the_real_p:
$LN282@the_real_p:

; 2365 :                         }
; 2366 : 
; 2367 :                         {
; 2368 :                             int     ctok = -1;

  01a63	c7 84 24 94 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR ctok$4[rsp], -1

; 2369 :                             int     odx  = 0;

  01a6e	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR odx$2[rsp], 0

; 2370 :                             int     idx  = 0;

  01a79	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR idx$3[rsp], 0

; 2371 :                             char    psz_cmdline[(sizeof(cmdline) * 11)];
; 2372 : 
; 2373 :                             memset(psz_cmdline, 0, sizeof(psz_cmdline));

  01a84	48 8d 84 24 a0
	09 00 00	 lea	 rax, QWORD PTR psz_cmdline$48[rsp]
  01a8c	48 8b f8	 mov	 rdi, rax
  01a8f	33 c0		 xor	 eax, eax
  01a91	b9 0b 0b 00 00	 mov	 ecx, 2827		; 00000b0bH
  01a96	f3 aa		 rep stosb

; 2374 : 
; 2375 :                             pt1 = psz_PF+j;

  01a98	48 63 44 24 74	 movsxd	 rax, DWORD PTR j$1[rsp]
  01a9d	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01aa5	48 03 c8	 add	 rcx, rax
  01aa8	48 8b c1	 mov	 rax, rcx
  01aab	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR pt1$13[rsp], rax

; 2376 : 
; 2377 :                             for ( idx = 0; idx < (int)strlen(pt1); idx++ )

  01ab3	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR idx$3[rsp], 0
  01abe	eb 10		 jmp	 SHORT $LN60@the_real_p
$LN58@the_real_p:
  01ac0	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01ac7	ff c0		 inc	 eax
  01ac9	89 84 24 90 00
	00 00		 mov	 DWORD PTR idx$3[rsp], eax
$LN60@the_real_p:
  01ad0	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01ad8	e8 00 00 00 00	 call	 strlen
  01add	39 84 24 90 00
	00 00		 cmp	 DWORD PTR idx$3[rsp], eax
  01ae4	0f 8d d6 03 00
	00		 jge	 $LN59@the_real_p

; 2378 :                             {
; 2379 :                                 if ( pt1[idx] != '&' )

  01aea	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR idx$3[rsp]
  01af2	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01afa	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01afe	83 f8 26	 cmp	 eax, 38			; 00000026H
  01b01	74 38		 je	 SHORT $LN293@the_real_p

; 2380 :                                 {
; 2381 :                                     psz_cmdline[odx++] = pt1[idx];

  01b03	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR idx$3[rsp]
  01b0b	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR odx$2[rsp]
  01b13	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pt1$13[rsp]
  01b1b	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  01b1f	88 84 0c a0 09
	00 00		 mov	 BYTE PTR psz_cmdline$48[rsp+rcx], al
  01b26	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR odx$2[rsp]
  01b2d	ff c0		 inc	 eax
  01b2f	89 84 24 80 00
	00 00		 mov	 DWORD PTR odx$2[rsp], eax

; 2382 :                                 }

  01b36	e9 22 03 00 00	 jmp	 $LN294@the_real_p
$LN293@the_real_p:

; 2383 :                                 else
; 2384 :                                 {
; 2385 :                                     if ( pt1[idx+1] == '&' )

  01b3b	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01b42	ff c0		 inc	 eax
  01b44	48 98		 cdqe
  01b46	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01b4e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01b52	83 f8 26	 cmp	 eax, 38			; 00000026H
  01b55	75 48		 jne	 SHORT $LN295@the_real_p

; 2386 :                                     {
; 2387 :                                         idx++;

  01b57	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01b5e	ff c0		 inc	 eax
  01b60	89 84 24 90 00
	00 00		 mov	 DWORD PTR idx$3[rsp], eax

; 2388 :                                         psz_cmdline[odx++] = pt1[idx];

  01b67	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR idx$3[rsp]
  01b6f	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR odx$2[rsp]
  01b77	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pt1$13[rsp]
  01b7f	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  01b83	88 84 0c a0 09
	00 00		 mov	 BYTE PTR psz_cmdline$48[rsp+rcx], al
  01b8a	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR odx$2[rsp]
  01b91	ff c0		 inc	 eax
  01b93	89 84 24 80 00
	00 00		 mov	 DWORD PTR odx$2[rsp], eax

; 2389 :                                     }

  01b9a	e9 be 02 00 00	 jmp	 $LN296@the_real_p
$LN295@the_real_p:

; 2390 :                                     else if ( pt1[idx+1] == '*' )

  01b9f	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01ba6	ff c0		 inc	 eax
  01ba8	48 98		 cdqe
  01baa	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01bb2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01bb6	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  01bb9	0f 85 fd 00 00
	00		 jne	 $LN297@the_real_p

; 2391 :                                     {
; 2392 :                                         idx++;

  01bbf	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01bc6	ff c0		 inc	 eax
  01bc8	89 84 24 90 00
	00 00		 mov	 DWORD PTR idx$3[rsp], eax

; 2393 : 
; 2394 :                                         if ( ctok < 9 )

  01bcf	83 bc 24 94 00
	00 00 09	 cmp	 DWORD PTR ctok$4[rsp], 9
  01bd7	0f 8d da 00 00
	00		 jge	 $LN299@the_real_p

; 2395 :                                         {
; 2396 :                                             int first = TRUE;

  01bdd	c7 84 24 18 01
	00 00 01 00 00
	00		 mov	 DWORD PTR first$19[rsp], 1

; 2397 : 
; 2398 :                                             for( ctok++; ctok <= 10; ctok++ )

  01be8	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR ctok$4[rsp]
  01bef	ff c0		 inc	 eax
  01bf1	89 84 24 94 00
	00 00		 mov	 DWORD PTR ctok$4[rsp], eax
  01bf8	eb 10		 jmp	 SHORT $LN63@the_real_p
$LN61@the_real_p:
  01bfa	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR ctok$4[rsp]
  01c01	ff c0		 inc	 eax
  01c03	89 84 24 94 00
	00 00		 mov	 DWORD PTR ctok$4[rsp], eax
$LN63@the_real_p:
  01c0a	83 bc 24 94 00
	00 00 0a	 cmp	 DWORD PTR ctok$4[rsp], 10
  01c12	0f 8f 9f 00 00
	00		 jg	 $LN62@the_real_p

; 2399 :                                             {
; 2400 :                                                 if ( cmd_tok[ctok] != NULL )

  01c18	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR ctok$4[rsp]
  01c20	48 83 bc c4 50
	02 00 00 00	 cmp	 QWORD PTR cmd_tok$41[rsp+rax*8], 0
  01c29	0f 84 83 00 00
	00		 je	 $LN300@the_real_p

; 2401 :                                                 {
; 2402 :                                                     if ( first )

  01c2f	83 bc 24 18 01
	00 00 00	 cmp	 DWORD PTR first$19[rsp], 0
  01c37	74 0d		 je	 SHORT $LN301@the_real_p

; 2403 :                                                         first = FALSE;

  01c39	c7 84 24 18 01
	00 00 00 00 00
	00		 mov	 DWORD PTR first$19[rsp], 0
  01c44	eb 20		 jmp	 SHORT $LN302@the_real_p
$LN301@the_real_p:

; 2404 :                                                     else
; 2405 :                                                         psz_cmdline[odx++] = ' ';         // add one space

  01c46	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR odx$2[rsp]
  01c4e	c6 84 04 a0 09
	00 00 20	 mov	 BYTE PTR psz_cmdline$48[rsp+rax], 32 ; 00000020H
  01c56	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR odx$2[rsp]
  01c5d	ff c0		 inc	 eax
  01c5f	89 84 24 80 00
	00 00		 mov	 DWORD PTR odx$2[rsp], eax
$LN302@the_real_p:

; 2406 :                                                     strcpy( &psz_cmdline[odx], cmd_tok[ctok] );

  01c66	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR ctok$4[rsp]
  01c6e	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR odx$2[rsp]
  01c76	48 8d 8c 0c a0
	09 00 00	 lea	 rcx, QWORD PTR psz_cmdline$48[rsp+rcx]
  01c7e	48 8b 94 c4 50
	02 00 00	 mov	 rdx, QWORD PTR cmd_tok$41[rsp+rax*8]
  01c86	e8 00 00 00 00	 call	 strcpy

; 2407 :                                                     odx += (int)strlen(cmd_tok[ctok]);

  01c8b	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR ctok$4[rsp]
  01c93	48 8b 8c c4 50
	02 00 00	 mov	 rcx, QWORD PTR cmd_tok$41[rsp+rax*8]
  01c9b	e8 00 00 00 00	 call	 strlen
  01ca0	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR odx$2[rsp]
  01ca7	03 c8		 add	 ecx, eax
  01ca9	8b c1		 mov	 eax, ecx
  01cab	89 84 24 80 00
	00 00		 mov	 DWORD PTR odx$2[rsp], eax
$LN300@the_real_p:

; 2408 : 
; 2409 :                                                 }
; 2410 :                                             }

  01cb2	e9 43 ff ff ff	 jmp	 $LN61@the_real_p
$LN62@the_real_p:
$LN299@the_real_p:

; 2411 :                                         }
; 2412 :                                     }

  01cb7	e9 a1 01 00 00	 jmp	 $LN298@the_real_p
$LN297@the_real_p:

; 2413 :                                     else if ( !isdigit( pt1[idx+1] ) && ( pt1[idx+1] != '$' ) )

  01cbc	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01cc3	ff c0		 inc	 eax
  01cc5	48 98		 cdqe
  01cc7	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01ccf	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01cd3	8b c8		 mov	 ecx, eax
  01cd5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isdigit
  01cdb	85 c0		 test	 eax, eax
  01cdd	75 54		 jne	 SHORT $LN303@the_real_p
  01cdf	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01ce6	ff c0		 inc	 eax
  01ce8	48 98		 cdqe
  01cea	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01cf2	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01cf6	83 f8 24	 cmp	 eax, 36			; 00000024H
  01cf9	74 38		 je	 SHORT $LN303@the_real_p

; 2414 :                                     {
; 2415 :                                         psz_cmdline[odx++] = pt1[idx];

  01cfb	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR idx$3[rsp]
  01d03	48 63 8c 24 80
	00 00 00	 movsxd	 rcx, DWORD PTR odx$2[rsp]
  01d0b	48 8b 94 24 e8
	00 00 00	 mov	 rdx, QWORD PTR pt1$13[rsp]
  01d13	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  01d17	88 84 0c a0 09
	00 00		 mov	 BYTE PTR psz_cmdline$48[rsp+rcx], al
  01d1e	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR odx$2[rsp]
  01d25	ff c0		 inc	 eax
  01d27	89 84 24 80 00
	00 00		 mov	 DWORD PTR odx$2[rsp], eax

; 2416 :                                     }

  01d2e	e9 2a 01 00 00	 jmp	 $LN304@the_real_p
$LN303@the_real_p:

; 2417 :                                     else
; 2418 :                                     {
; 2419 :                                         idx++;

  01d33	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR idx$3[rsp]
  01d3a	ff c0		 inc	 eax
  01d3c	89 84 24 90 00
	00 00		 mov	 DWORD PTR idx$3[rsp], eax

; 2420 :                                         if ( pt1[idx] == '$' )

  01d43	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR idx$3[rsp]
  01d4b	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01d53	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01d57	83 f8 24	 cmp	 eax, 36			; 00000024H
  01d5a	75 0d		 jne	 SHORT $LN305@the_real_p

; 2421 :                                             ctok = 10;

  01d5c	c7 84 24 94 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR ctok$4[rsp], 10
  01d67	eb 3d		 jmp	 SHORT $LN306@the_real_p
$LN305@the_real_p:

; 2422 :                                         else
; 2423 :                                         {
; 2424 :                                             ctok = (int)pt1[idx] - '0';

  01d69	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR idx$3[rsp]
  01d71	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR pt1$13[rsp]
  01d79	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  01d7d	83 e8 30	 sub	 eax, 48			; 00000030H
  01d80	89 84 24 94 00
	00 00		 mov	 DWORD PTR ctok$4[rsp], eax

; 2425 :                                             if ( ctok < 0 || ctok > 9 ) ctok = 10;

  01d87	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR ctok$4[rsp], 0
  01d8f	7c 0a		 jl	 SHORT $LN308@the_real_p
  01d91	83 bc 24 94 00
	00 00 09	 cmp	 DWORD PTR ctok$4[rsp], 9
  01d99	7e 0b		 jle	 SHORT $LN307@the_real_p
$LN308@the_real_p:
  01d9b	c7 84 24 94 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR ctok$4[rsp], 10
$LN307@the_real_p:
$LN306@the_real_p:

; 2426 :                                         }
; 2427 :                                         if ( cmd_tok[ctok] != NULL && strlen( cmd_tok[ctok] ) > 0 )

  01da6	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR ctok$4[rsp]
  01dae	48 83 bc c4 50
	02 00 00 00	 cmp	 QWORD PTR cmd_tok$41[rsp+rax*8], 0
  01db7	0f 84 80 00 00
	00		 je	 $LN309@the_real_p
  01dbd	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR ctok$4[rsp]
  01dc5	48 8b 8c c4 50
	02 00 00	 mov	 rcx, QWORD PTR cmd_tok$41[rsp+rax*8]
  01dcd	e8 00 00 00 00	 call	 strlen
  01dd2	48 85 c0	 test	 rax, rax
  01dd5	76 66		 jbe	 SHORT $LN309@the_real_p

; 2428 :                                         {
; 2429 :                                             memcpy(&psz_cmdline[odx], cmd_tok[ctok], strlen( cmd_tok[ctok] ) );

  01dd7	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR ctok$4[rsp]
  01ddf	48 8b 8c c4 50
	02 00 00	 mov	 rcx, QWORD PTR cmd_tok$41[rsp+rax*8]
  01de7	e8 00 00 00 00	 call	 strlen
  01dec	48 63 8c 24 94
	00 00 00	 movsxd	 rcx, DWORD PTR ctok$4[rsp]
  01df4	48 63 94 24 80
	00 00 00	 movsxd	 rdx, DWORD PTR odx$2[rsp]
  01dfc	48 8d 94 14 a0
	09 00 00	 lea	 rdx, QWORD PTR psz_cmdline$48[rsp+rdx]
  01e04	48 8b fa	 mov	 rdi, rdx
  01e07	48 8b b4 cc 50
	02 00 00	 mov	 rsi, QWORD PTR cmd_tok$41[rsp+rcx*8]
  01e0f	48 8b c8	 mov	 rcx, rax
  01e12	f3 a4		 rep movsb

; 2430 :                                             odx += (int)strlen( cmd_tok[ctok] );

  01e14	48 63 84 24 94
	00 00 00	 movsxd	 rax, DWORD PTR ctok$4[rsp]
  01e1c	48 8b 8c c4 50
	02 00 00	 mov	 rcx, QWORD PTR cmd_tok$41[rsp+rax*8]
  01e24	e8 00 00 00 00	 call	 strlen
  01e29	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR odx$2[rsp]
  01e30	03 c8		 add	 ecx, eax
  01e32	8b c1		 mov	 eax, ecx
  01e34	89 84 24 80 00
	00 00		 mov	 DWORD PTR odx$2[rsp], eax

; 2431 :                                         }

  01e3b	eb 20		 jmp	 SHORT $LN310@the_real_p
$LN309@the_real_p:

; 2432 :                                         else
; 2433 :                                             psz_cmdline[odx++] = ' ';

  01e3d	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR odx$2[rsp]
  01e45	c6 84 04 a0 09
	00 00 20	 mov	 BYTE PTR psz_cmdline$48[rsp+rax], 32 ; 00000020H
  01e4d	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR odx$2[rsp]
  01e54	ff c0		 inc	 eax
  01e56	89 84 24 80 00
	00 00		 mov	 DWORD PTR odx$2[rsp], eax
$LN310@the_real_p:
$LN304@the_real_p:
$LN298@the_real_p:
$LN296@the_real_p:
$LN294@the_real_p:

; 2434 :                                     }
; 2435 :                                 }
; 2436 : 
; 2437 :                                 if ( odx > (int)sizeof(cmdline) )

  01e5d	81 bc 24 80 00
	00 00 01 01 00
	00		 cmp	 DWORD PTR odx$2[rsp], 257 ; 00000101H
  01e68	7e 51		 jle	 SHORT $LN311@the_real_p

; 2438 :                                 {
; 2439 :                                     WRMSG(HHC01608, "W", ((int)sizeof(cmdline) - 1) );

  01e6a	b9 01 00 00 00	 mov	 ecx, 1
  01e6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01e75	c7 44 24 38 00
	01 00 00	 mov	 DWORD PTR [rsp+56], 256	; 00000100H
  01e7d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169512
  01e84	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01e89	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169513
  01e90	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01e95	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01e9a	41 b9 03 00 00
	00		 mov	 r9d, 3
  01ea0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169514
  01ea7	ba 87 09 00 00	 mov	 edx, 2439		; 00000987H
  01eac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169515
  01eb3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2440 :                                     break;

  01eb9	eb 05		 jmp	 SHORT $LN59@the_real_p
$LN311@the_real_p:

; 2441 :                                 }
; 2442 :                             }

  01ebb	e9 00 fc ff ff	 jmp	 $LN58@the_real_p
$LN59@the_real_p:

; 2443 : 
; 2444 :                             if ( isdelay )

  01ec0	83 bc 24 1c 01
	00 00 00	 cmp	 DWORD PTR isdelay$20[rsp], 0
  01ec8	0f 84 f0 00 00
	00		 je	 $LN312@the_real_p

; 2445 :                             {
; 2446 :                                 strncpy( cmdline, psz_cmdline, sizeof(cmdline) );

  01ece	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  01ed4	48 8d 94 24 a0
	09 00 00	 lea	 rdx, QWORD PTR psz_cmdline$48[rsp]
  01edc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  01ee3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncpy

; 2447 :                                 cmdline[sizeof(cmdline) - 1] = 0;

  01ee9	b8 01 00 00 00	 mov	 eax, 1
  01eee	48 69 c0 00 01
	00 00		 imul	 rax, rax, 256		; 00000100H
  01ef5	48 89 84 24 f8
	01 00 00	 mov	 QWORD PTR $T35[rsp], rax
  01efd	48 81 bc 24 f8
	01 00 00 01 01
	00 00		 cmp	 QWORD PTR $T35[rsp], 257 ; 00000101H
  01f09	73 02		 jae	 SHORT $LN523@the_real_p
  01f0b	eb 05		 jmp	 SHORT $LN524@the_real_p
$LN523@the_real_p:
  01f0d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN524@the_real_p:
  01f12	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  01f19	48 8b 8c 24 f8
	01 00 00	 mov	 rcx, QWORD PTR $T35[rsp]
  01f21	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2448 :                                 cmdlen = (int)strlen(cmdline);

  01f25	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  01f2c	e8 00 00 00 00	 call	 strlen
  01f31	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 2449 :                                 cmdoff = cmdlen < cmdcols ? cmdlen : 0;

  01f37	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  01f3d	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdlen, eax
  01f43	7d 0f		 jge	 SHORT $LN525@the_real_p
  01f45	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  01f4b	89 84 24 20 01
	00 00		 mov	 DWORD PTR tv1060[rsp], eax
  01f52	eb 0b		 jmp	 SHORT $LN526@the_real_p
$LN525@the_real_p:
  01f54	c7 84 24 20 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1060[rsp], 0
$LN526@the_real_p:
  01f5f	8b 84 24 20 01
	00 00		 mov	 eax, DWORD PTR tv1060[rsp]
  01f66	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN66@the_real_p:

; 2450 :                                 ADJ_CMDCOL();

  01f6c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  01f72	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  01f78	2b c8		 sub	 ecx, eax
  01f7a	8b c1		 mov	 eax, ecx
  01f7c	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  01f82	7e 18		 jle	 SHORT $LN314@the_real_p
  01f84	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  01f8a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  01f90	2b c8		 sub	 ecx, eax
  01f92	8b c1		 mov	 eax, ecx
  01f94	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  01f9a	eb 1a		 jmp	 SHORT $LN315@the_real_p
$LN314@the_real_p:
  01f9c	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  01fa2	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  01fa8	7d 0c		 jge	 SHORT $LN316@the_real_p
  01faa	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  01fb0	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN316@the_real_p:
$LN315@the_real_p:
  01fb6	33 c0		 xor	 eax, eax
  01fb8	85 c0		 test	 eax, eax
  01fba	75 b0		 jne	 SHORT $LN66@the_real_p

; 2451 :                             }

  01fbc	eb 0d		 jmp	 SHORT $LN313@the_real_p
$LN312@the_real_p:

; 2452 :                             else
; 2453 :                                 do_panel_command( psz_cmdline );

  01fbe	48 8d 8c 24 a0
	09 00 00	 lea	 rcx, QWORD PTR psz_cmdline$48[rsp]
  01fc6	e8 00 00 00 00	 call	 do_panel_command
$LN313@the_real_p:

; 2454 :                         }
; 2455 :                     }

  01fcb	eb 0d		 jmp	 SHORT $LN275@the_real_p
$LN274@the_real_p:

; 2456 :                     else /* this is the same as IMMED */
; 2457 :                     {
; 2458 :                         do_panel_command( psz_PF );

  01fcd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01fd5	e8 00 00 00 00	 call	 do_panel_command
$LN275@the_real_p:
$LN269@the_real_p:
$LN266@the_real_p:

; 2459 :                     }
; 2460 :                     free(psz_PF);

  01fda	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR psz_PF$6[rsp]
  01fe2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 2461 :                     redraw_cmd = 1;

  01fe8	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2462 :                     redraw_msgs = 1;

  01ff2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1

; 2463 :                     break;

  01ffc	e9 ad 14 00 00	 jmp	 $LN26@the_real_p
$LN261@the_real_p:

; 2464 :                 }
; 2465 : 
; 2466 :                 /* Test for HOME */
; 2467 :                 if (strcmp(kbbuf+i, KBD_HOME) == 0) {

  02001	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02006	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0200e	48 03 c8	 add	 rcx, rax
  02011	48 8b c1	 mov	 rax, rcx
  02014	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169522
  0201b	48 8b c8	 mov	 rcx, rax
  0201e	e8 00 00 00 00	 call	 strcmp
  02023	85 c0		 test	 eax, eax
  02025	75 40		 jne	 SHORT $LN317@the_real_p

; 2468 :                     if (NPDup == 1 || !is_cursor_on_cmdline() || cmdlen) {

  02027	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDup, 1
  0202e	74 12		 je	 SHORT $LN320@the_real_p
  02030	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  02035	85 c0		 test	 eax, eax
  02037	74 09		 je	 SHORT $LN320@the_real_p
  02039	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cmdlen, 0
  02040	74 11		 je	 SHORT $LN318@the_real_p
$LN320@the_real_p:

; 2469 :                         cursor_cmdline_home();

  02042	e8 00 00 00 00	 call	 cursor_cmdline_home

; 2470 :                         redraw_cmd = 1;

  02047	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2471 :                     } else {

  02051	eb 0f		 jmp	 SHORT $LN319@the_real_p
$LN318@the_real_p:

; 2472 :                         scroll_to_top_line();

  02053	e8 00 00 00 00	 call	 scroll_to_top_line

; 2473 :                         redraw_msgs = 1;

  02058	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1
$LN319@the_real_p:

; 2474 :                     }
; 2475 :                     break;

  02062	e9 47 14 00 00	 jmp	 $LN26@the_real_p
$LN317@the_real_p:

; 2476 :                 }
; 2477 : 
; 2478 :                 /* Test for END */
; 2479 :                 if (strcmp(kbbuf+i, KBD_END) == 0) {

  02067	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0206c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02074	48 03 c8	 add	 rcx, rax
  02077	48 8b c1	 mov	 rax, rcx
  0207a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169527
  02081	48 8b c8	 mov	 rcx, rax
  02084	e8 00 00 00 00	 call	 strcmp
  02089	85 c0		 test	 eax, eax
  0208b	75 40		 jne	 SHORT $LN321@the_real_p

; 2480 :                     if (NPDup == 1 || !is_cursor_on_cmdline() || cmdlen) {

  0208d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDup, 1
  02094	74 12		 je	 SHORT $LN324@the_real_p
  02096	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  0209b	85 c0		 test	 eax, eax
  0209d	74 09		 je	 SHORT $LN324@the_real_p
  0209f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cmdlen, 0
  020a6	74 11		 je	 SHORT $LN322@the_real_p
$LN324@the_real_p:

; 2481 :                         cursor_cmdline_end();

  020a8	e8 00 00 00 00	 call	 cursor_cmdline_end

; 2482 :                         redraw_cmd = 1;

  020ad	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2483 :                     } else {

  020b7	eb 0f		 jmp	 SHORT $LN323@the_real_p
$LN322@the_real_p:

; 2484 :                         scroll_to_bottom_screen();

  020b9	e8 00 00 00 00	 call	 scroll_to_bottom_screen

; 2485 :                         redraw_msgs = 1;

  020be	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1
$LN323@the_real_p:

; 2486 :                     }
; 2487 :                     break;

  020c8	e9 e1 13 00 00	 jmp	 $LN26@the_real_p
$LN321@the_real_p:

; 2488 :                 }
; 2489 : 
; 2490 :                 /* Test for CTRL+HOME */
; 2491 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_CTRL_HOME) == 0) {

  020cd	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  020d4	75 3a		 jne	 SHORT $LN325@the_real_p
  020d6	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  020db	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  020e3	48 03 c8	 add	 rcx, rax
  020e6	48 8b c1	 mov	 rax, rcx
  020e9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169532
  020f0	48 8b c8	 mov	 rcx, rax
  020f3	e8 00 00 00 00	 call	 strcmp
  020f8	85 c0		 test	 eax, eax
  020fa	75 14		 jne	 SHORT $LN325@the_real_p

; 2492 :                     scroll_to_top_line();

  020fc	e8 00 00 00 00	 call	 scroll_to_top_line

; 2493 :                     redraw_msgs = 1;

  02101	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1

; 2494 :                     break;

  0210b	e9 9e 13 00 00	 jmp	 $LN26@the_real_p
$LN325@the_real_p:

; 2495 :                 }
; 2496 : 
; 2497 :                 /* Test for CTRL+END */
; 2498 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_CTRL_END) == 0) {

  02110	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02117	75 3a		 jne	 SHORT $LN326@the_real_p
  02119	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0211e	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02126	48 03 c8	 add	 rcx, rax
  02129	48 8b c1	 mov	 rax, rcx
  0212c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169534
  02133	48 8b c8	 mov	 rcx, rax
  02136	e8 00 00 00 00	 call	 strcmp
  0213b	85 c0		 test	 eax, eax
  0213d	75 14		 jne	 SHORT $LN326@the_real_p

; 2499 :                     scroll_to_bottom_line();

  0213f	e8 00 00 00 00	 call	 scroll_to_bottom_line

; 2500 :                     redraw_msgs = 1;

  02144	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1

; 2501 :                     break;

  0214e	e9 5b 13 00 00	 jmp	 $LN26@the_real_p
$LN326@the_real_p:

; 2502 :                 }
; 2503 : 
; 2504 :                 /* Process UPARROW */
; 2505 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_UP_ARROW) == 0)

  02153	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  0215a	75 3a		 jne	 SHORT $LN327@the_real_p
  0215c	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02161	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02169	48 03 c8	 add	 rcx, rax
  0216c	48 8b c1	 mov	 rax, rcx
  0216f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169536
  02176	48 8b c8	 mov	 rcx, rax
  02179	e8 00 00 00 00	 call	 strcmp
  0217e	85 c0		 test	 eax, eax
  02180	75 14		 jne	 SHORT $LN327@the_real_p

; 2506 :                 {
; 2507 :                     do_prev_history();

  02182	e8 00 00 00 00	 call	 do_prev_history

; 2508 :                     redraw_cmd = 1;

  02187	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2509 :                     break;

  02191	e9 18 13 00 00	 jmp	 $LN26@the_real_p
$LN327@the_real_p:

; 2510 :                 }
; 2511 : 
; 2512 :                 /* Process DOWNARROW */
; 2513 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_DOWN_ARROW) == 0)

  02196	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  0219d	75 3a		 jne	 SHORT $LN328@the_real_p
  0219f	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  021a4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  021ac	48 03 c8	 add	 rcx, rax
  021af	48 8b c1	 mov	 rax, rcx
  021b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169538
  021b9	48 8b c8	 mov	 rcx, rax
  021bc	e8 00 00 00 00	 call	 strcmp
  021c1	85 c0		 test	 eax, eax
  021c3	75 14		 jne	 SHORT $LN328@the_real_p

; 2514 :                 {
; 2515 :                     do_next_history();

  021c5	e8 00 00 00 00	 call	 do_next_history

; 2516 :                     redraw_cmd = 1;

  021ca	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2517 :                     break;

  021d4	e9 d5 12 00 00	 jmp	 $LN26@the_real_p
$LN328@the_real_p:

; 2518 :                 }
; 2519 : 
; 2520 : #if defined(OPTION_EXTCURS)
; 2521 :                 /* Process ALT+UPARROW */
; 2522 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_ALT_UP_ARROW) == 0) {

  021d9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  021e0	0f 85 8a 00 00
	00		 jne	 $LN329@the_real_p
  021e6	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  021eb	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  021f3	48 03 c8	 add	 rcx, rax
  021f6	48 8b c1	 mov	 rax, rcx
  021f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169540
  02200	48 8b c8	 mov	 rcx, rax
  02203	e8 00 00 00 00	 call	 strcmp
  02208	85 c0		 test	 eax, eax
  0220a	75 64		 jne	 SHORT $LN329@the_real_p

; 2523 :                     get_cursor_pos( keybfd, confp, &cur_cons_row, &cur_cons_col );

  0220c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cur_cons_col
  02213	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cur_cons_row
  0221a	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR confp
  02221	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR keybfd
  02227	e8 00 00 00 00	 call	 get_cursor_pos

; 2524 :                     if (cur_cons_row <= 1)

  0222c	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  02233	83 f8 01	 cmp	 eax, 1
  02236	7f 0f		 jg	 SHORT $LN330@the_real_p

; 2525 :                         cur_cons_row = cons_rows + 1;

  02238	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  0223e	ff c0		 inc	 eax
  02240	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax
$LN330@the_real_p:

; 2526 :                     set_pos( --cur_cons_row, cur_cons_col );

  02247	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  0224e	66 ff c8	 dec	 ax
  02251	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax
  02258	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cur_cons_col
  0225f	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cur_cons_row
  02266	e8 00 00 00 00	 call	 set_pos

; 2527 :                     break;

  0226b	e9 3e 12 00 00	 jmp	 $LN26@the_real_p
$LN329@the_real_p:

; 2528 :                 }
; 2529 : 
; 2530 :                 /* Process ALT+DOWNARROW */
; 2531 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_ALT_DOWN_ARROW) == 0) {

  02270	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02277	0f 85 87 00 00
	00		 jne	 $LN331@the_real_p
  0227d	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02282	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0228a	48 03 c8	 add	 rcx, rax
  0228d	48 8b c1	 mov	 rax, rcx
  02290	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169543
  02297	48 8b c8	 mov	 rcx, rax
  0229a	e8 00 00 00 00	 call	 strcmp
  0229f	85 c0		 test	 eax, eax
  022a1	75 61		 jne	 SHORT $LN331@the_real_p

; 2532 :                     get_cursor_pos( keybfd, confp, &cur_cons_row, &cur_cons_col );

  022a3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cur_cons_col
  022aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cur_cons_row
  022b1	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR confp
  022b8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR keybfd
  022be	e8 00 00 00 00	 call	 get_cursor_pos

; 2533 :                     if (cur_cons_row >= cons_rows)

  022c3	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  022ca	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_rows
  022d0	7c 09		 jl	 SHORT $LN332@the_real_p

; 2534 :                         cur_cons_row = 1 - 1;

  022d2	33 c0		 xor	 eax, eax
  022d4	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax
$LN332@the_real_p:

; 2535 :                     set_pos( ++cur_cons_row, cur_cons_col );

  022db	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  022e2	66 ff c0	 inc	 ax
  022e5	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax
  022ec	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cur_cons_col
  022f3	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cur_cons_row
  022fa	e8 00 00 00 00	 call	 set_pos

; 2536 :                     break;

  022ff	e9 aa 11 00 00	 jmp	 $LN26@the_real_p
$LN331@the_real_p:

; 2537 :                 }
; 2538 : #endif // defined(OPTION_EXTCURS)
; 2539 : 
; 2540 :                 /* Test for PAGEUP */
; 2541 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_PAGE_UP) == 0) {

  02304	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  0230b	75 3a		 jne	 SHORT $LN333@the_real_p
  0230d	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02312	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0231a	48 03 c8	 add	 rcx, rax
  0231d	48 8b c1	 mov	 rax, rcx
  02320	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169546
  02327	48 8b c8	 mov	 rcx, rax
  0232a	e8 00 00 00 00	 call	 strcmp
  0232f	85 c0		 test	 eax, eax
  02331	75 14		 jne	 SHORT $LN333@the_real_p

; 2542 :                     page_up();

  02333	e8 00 00 00 00	 call	 page_up

; 2543 :                     redraw_msgs = 1;

  02338	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1

; 2544 :                     break;

  02342	e9 67 11 00 00	 jmp	 $LN26@the_real_p
$LN333@the_real_p:

; 2545 :                 }
; 2546 : 
; 2547 :                 /* Test for PAGEDOWN */
; 2548 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_PAGE_DOWN) == 0) {

  02347	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  0234e	75 3a		 jne	 SHORT $LN334@the_real_p
  02350	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02355	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0235d	48 03 c8	 add	 rcx, rax
  02360	48 8b c1	 mov	 rax, rcx
  02363	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169548
  0236a	48 8b c8	 mov	 rcx, rax
  0236d	e8 00 00 00 00	 call	 strcmp
  02372	85 c0		 test	 eax, eax
  02374	75 14		 jne	 SHORT $LN334@the_real_p

; 2549 :                     page_down();

  02376	e8 00 00 00 00	 call	 page_down

; 2550 :                     redraw_msgs = 1;

  0237b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1

; 2551 :                     break;

  02385	e9 24 11 00 00	 jmp	 $LN26@the_real_p
$LN334@the_real_p:

; 2552 :                 }
; 2553 : 
; 2554 :                 /* Test for CTRL+UPARROW */
; 2555 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_CTRL_UP_ARROW) == 0) {

  0238a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02391	75 3f		 jne	 SHORT $LN335@the_real_p
  02393	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02398	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  023a0	48 03 c8	 add	 rcx, rax
  023a3	48 8b c1	 mov	 rax, rcx
  023a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169550
  023ad	48 8b c8	 mov	 rcx, rax
  023b0	e8 00 00 00 00	 call	 strcmp
  023b5	85 c0		 test	 eax, eax
  023b7	75 19		 jne	 SHORT $LN335@the_real_p

; 2556 :                     scroll_up_lines(1);

  023b9	b9 01 00 00 00	 mov	 ecx, 1
  023be	e8 00 00 00 00	 call	 scroll_up_lines

; 2557 :                     redraw_msgs = 1;

  023c3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1

; 2558 :                     break;

  023cd	e9 dc 10 00 00	 jmp	 $LN26@the_real_p
$LN335@the_real_p:

; 2559 :                 }
; 2560 : 
; 2561 :                 /* Test for CTRL+DOWNARROW */
; 2562 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_CTRL_DOWN_ARROW) == 0) {

  023d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  023d9	75 3f		 jne	 SHORT $LN336@the_real_p
  023db	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  023e0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  023e8	48 03 c8	 add	 rcx, rax
  023eb	48 8b c1	 mov	 rax, rcx
  023ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169552
  023f5	48 8b c8	 mov	 rcx, rax
  023f8	e8 00 00 00 00	 call	 strcmp
  023fd	85 c0		 test	 eax, eax
  023ff	75 19		 jne	 SHORT $LN336@the_real_p

; 2563 :                     scroll_down_lines(1);

  02401	b9 01 00 00 00	 mov	 ecx, 1
  02406	e8 00 00 00 00	 call	 scroll_down_lines

; 2564 :                     redraw_msgs = 1;

  0240b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1

; 2565 :                     break;

  02415	e9 94 10 00 00	 jmp	 $LN26@the_real_p
$LN336@the_real_p:

; 2566 :                 }
; 2567 : 
; 2568 :                 /* Process BACKSPACE */
; 2569 :                 if (kbbuf[i] == '\b' || kbbuf[i] == '\x7F') {

  0241a	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0241f	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02427	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0242b	83 f8 08	 cmp	 eax, 8
  0242e	74 1a		 je	 SHORT $LN338@the_real_p
  02430	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02435	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0243d	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02441	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  02444	0f 85 08 01 00
	00		 jne	 $LN337@the_real_p
$LN338@the_real_p:

; 2570 :                     if (NPDup == 0 && !is_cursor_on_cmdline())

  0244a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02451	75 13		 jne	 SHORT $LN339@the_real_p
  02453	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  02458	85 c0		 test	 eax, eax
  0245a	75 0a		 jne	 SHORT $LN339@the_real_p

; 2571 :                         beep();

  0245c	e8 00 00 00 00	 call	 beep
  02461	e9 e7 00 00 00	 jmp	 $LN340@the_real_p
$LN339@the_real_p:

; 2572 :                     else {
; 2573 :                         if (cmdoff > 0) {

  02466	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cmdoff, 0
  0246d	0f 8e c6 00 00
	00		 jle	 $LN341@the_real_p

; 2574 :                             int j;
; 2575 :                             for (j = cmdoff-1; j<cmdlen; j++)

  02473	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  02479	ff c8		 dec	 eax
  0247b	89 84 24 d8 00
	00 00		 mov	 DWORD PTR j$10[rsp], eax
  02482	eb 10		 jmp	 SHORT $LN69@the_real_p
$LN67@the_real_p:
  02484	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR j$10[rsp]
  0248b	ff c0		 inc	 eax
  0248d	89 84 24 d8 00
	00 00		 mov	 DWORD PTR j$10[rsp], eax
$LN69@the_real_p:
  02494	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  0249a	39 84 24 d8 00
	00 00		 cmp	 DWORD PTR j$10[rsp], eax
  024a1	7d 2a		 jge	 SHORT $LN68@the_real_p

; 2576 :                                 cmdline[j] = cmdline[j+1];

  024a3	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR j$10[rsp]
  024aa	ff c0		 inc	 eax
  024ac	48 98		 cdqe
  024ae	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  024b5	48 63 94 24 d8
	00 00 00	 movsxd	 rdx, DWORD PTR j$10[rsp]
  024bd	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:cmdline
  024c4	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  024c8	88 04 17	 mov	 BYTE PTR [rdi+rdx], al
  024cb	eb b7		 jmp	 SHORT $LN67@the_real_p
$LN68@the_real_p:

; 2577 :                             cmdoff--;

  024cd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  024d3	ff c8		 dec	 eax
  024d5	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax

; 2578 :                             cmdlen--;

  024db	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  024e1	ff c8		 dec	 eax
  024e3	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax
$LN72@the_real_p:

; 2579 :                             ADJ_CMDCOL();

  024e9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  024ef	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  024f5	2b c8		 sub	 ecx, eax
  024f7	8b c1		 mov	 eax, ecx
  024f9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  024ff	7e 18		 jle	 SHORT $LN342@the_real_p
  02501	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02507	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0250d	2b c8		 sub	 ecx, eax
  0250f	8b c1		 mov	 eax, ecx
  02511	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  02517	eb 1a		 jmp	 SHORT $LN343@the_real_p
$LN342@the_real_p:
  02519	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0251f	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  02525	7d 0c		 jge	 SHORT $LN344@the_real_p
  02527	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  0252d	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN344@the_real_p:
$LN343@the_real_p:
  02533	33 c0		 xor	 eax, eax
  02535	85 c0		 test	 eax, eax
  02537	75 b0		 jne	 SHORT $LN72@the_real_p
$LN341@the_real_p:

; 2580 :                         }
; 2581 :                         i++;

  02539	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0253d	ff c0		 inc	 eax
  0253f	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2582 :                         redraw_cmd = 1;

  02543	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1
$LN340@the_real_p:

; 2583 :                     }
; 2584 :                     break;

  0254d	e9 5c 0f 00 00	 jmp	 $LN26@the_real_p
$LN337@the_real_p:

; 2585 :                 }
; 2586 : 
; 2587 :                 /* Process DELETE */
; 2588 :                 if (strcmp(kbbuf+i, KBD_DELETE) == 0) {

  02552	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02557	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0255f	48 03 c8	 add	 rcx, rax
  02562	48 8b c1	 mov	 rax, rcx
  02565	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169562
  0256c	48 8b c8	 mov	 rcx, rax
  0256f	e8 00 00 00 00	 call	 strcmp
  02574	85 c0		 test	 eax, eax
  02576	0f 85 a9 00 00
	00		 jne	 $LN345@the_real_p

; 2589 :                     if (NPDup == 0 && !is_cursor_on_cmdline())

  0257c	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02583	75 13		 jne	 SHORT $LN346@the_real_p
  02585	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  0258a	85 c0		 test	 eax, eax
  0258c	75 0a		 jne	 SHORT $LN346@the_real_p

; 2590 :                         beep();

  0258e	e8 00 00 00 00	 call	 beep
  02593	e9 88 00 00 00	 jmp	 $LN347@the_real_p
$LN346@the_real_p:

; 2591 :                     else {
; 2592 :                         if (cmdoff < cmdlen) {

  02598	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  0259e	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  025a4	7d 66		 jge	 SHORT $LN348@the_real_p

; 2593 :                             int j;
; 2594 :                             for (j = cmdoff; j<cmdlen; j++)

  025a6	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  025ac	89 84 24 dc 00
	00 00		 mov	 DWORD PTR j$11[rsp], eax
  025b3	eb 10		 jmp	 SHORT $LN75@the_real_p
$LN73@the_real_p:
  025b5	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR j$11[rsp]
  025bc	ff c0		 inc	 eax
  025be	89 84 24 dc 00
	00 00		 mov	 DWORD PTR j$11[rsp], eax
$LN75@the_real_p:
  025c5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  025cb	39 84 24 dc 00
	00 00		 cmp	 DWORD PTR j$11[rsp], eax
  025d2	7d 2a		 jge	 SHORT $LN74@the_real_p

; 2595 :                                 cmdline[j] = cmdline[j+1];

  025d4	8b 84 24 dc 00
	00 00		 mov	 eax, DWORD PTR j$11[rsp]
  025db	ff c0		 inc	 eax
  025dd	48 98		 cdqe
  025df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  025e6	48 63 94 24 dc
	00 00 00	 movsxd	 rdx, DWORD PTR j$11[rsp]
  025ee	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:cmdline
  025f5	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  025f9	88 04 17	 mov	 BYTE PTR [rdi+rdx], al
  025fc	eb b7		 jmp	 SHORT $LN73@the_real_p
$LN74@the_real_p:

; 2596 :                             cmdlen--;

  025fe	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  02604	ff c8		 dec	 eax
  02606	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax
$LN348@the_real_p:

; 2597 :                         }
; 2598 :                         i++;

  0260c	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  02610	ff c0		 inc	 eax
  02612	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2599 :                         redraw_cmd = 1;

  02616	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1
$LN347@the_real_p:

; 2600 :                     }
; 2601 :                     break;

  02620	e9 89 0e 00 00	 jmp	 $LN26@the_real_p
$LN345@the_real_p:

; 2602 :                 }
; 2603 : 
; 2604 :                 /* Process LEFTARROW */
; 2605 :                 if (strcmp(kbbuf+i, KBD_LEFT_ARROW) == 0) {

  02625	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0262a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02632	48 03 c8	 add	 rcx, rax
  02635	48 8b c1	 mov	 rax, rcx
  02638	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169567
  0263f	48 8b c8	 mov	 rcx, rax
  02642	e8 00 00 00 00	 call	 strcmp
  02647	85 c0		 test	 eax, eax
  02649	0f 85 80 00 00
	00		 jne	 $LN349@the_real_p

; 2606 :                     if (cmdoff > 0) cmdoff--;

  0264f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cmdoff, 0
  02656	7e 0e		 jle	 SHORT $LN350@the_real_p
  02658	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  0265e	ff c8		 dec	 eax
  02660	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN350@the_real_p:
$LN78@the_real_p:

; 2607 :                     ADJ_CMDCOL();

  02666	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0266c	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02672	2b c8		 sub	 ecx, eax
  02674	8b c1		 mov	 eax, ecx
  02676	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  0267c	7e 18		 jle	 SHORT $LN351@the_real_p
  0267e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02684	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0268a	2b c8		 sub	 ecx, eax
  0268c	8b c1		 mov	 eax, ecx
  0268e	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  02694	eb 1a		 jmp	 SHORT $LN352@the_real_p
$LN351@the_real_p:
  02696	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0269c	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  026a2	7d 0c		 jge	 SHORT $LN353@the_real_p
  026a4	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  026aa	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN353@the_real_p:
$LN352@the_real_p:
  026b0	33 c0		 xor	 eax, eax
  026b2	85 c0		 test	 eax, eax
  026b4	75 b0		 jne	 SHORT $LN78@the_real_p

; 2608 :                     i++;

  026b6	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  026ba	ff c0		 inc	 eax
  026bc	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2609 :                     redraw_cmd = 1;

  026c0	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2610 :                     break;

  026ca	e9 df 0d 00 00	 jmp	 $LN26@the_real_p
$LN349@the_real_p:

; 2611 :                 }
; 2612 : 
; 2613 :                 /* Process RIGHTARROW */
; 2614 :                 if (strcmp(kbbuf+i, KBD_RIGHT_ARROW) == 0) {

  026cf	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  026d4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  026dc	48 03 c8	 add	 rcx, rax
  026df	48 8b c1	 mov	 rax, rcx
  026e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169573
  026e9	48 8b c8	 mov	 rcx, rax
  026ec	e8 00 00 00 00	 call	 strcmp
  026f1	85 c0		 test	 eax, eax
  026f3	0f 85 85 00 00
	00		 jne	 $LN354@the_real_p

; 2615 :                     if (cmdoff < cmdlen) cmdoff++;

  026f9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  026ff	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  02705	7d 0e		 jge	 SHORT $LN355@the_real_p
  02707	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  0270d	ff c0		 inc	 eax
  0270f	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN355@the_real_p:
$LN81@the_real_p:

; 2616 :                     ADJ_CMDCOL();

  02715	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0271b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02721	2b c8		 sub	 ecx, eax
  02723	8b c1		 mov	 eax, ecx
  02725	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  0272b	7e 18		 jle	 SHORT $LN356@the_real_p
  0272d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02733	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02739	2b c8		 sub	 ecx, eax
  0273b	8b c1		 mov	 eax, ecx
  0273d	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  02743	eb 1a		 jmp	 SHORT $LN357@the_real_p
$LN356@the_real_p:
  02745	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0274b	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  02751	7d 0c		 jge	 SHORT $LN358@the_real_p
  02753	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  02759	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN358@the_real_p:
$LN357@the_real_p:
  0275f	33 c0		 xor	 eax, eax
  02761	85 c0		 test	 eax, eax
  02763	75 b0		 jne	 SHORT $LN81@the_real_p

; 2617 :                     i++;

  02765	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  02769	ff c0		 inc	 eax
  0276b	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2618 :                     redraw_cmd = 1;

  0276f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2619 :                     break;

  02779	e9 30 0d 00 00	 jmp	 $LN26@the_real_p
$LN354@the_real_p:

; 2620 :                 }
; 2621 : 
; 2622 : #if defined(OPTION_EXTCURS)
; 2623 :                 /* Process ALT+LEFTARROW */
; 2624 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_ALT_LEFT_ARROW) == 0) {

  0277e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02785	0f 85 b9 00 00
	00		 jne	 $LN359@the_real_p
  0278b	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02790	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02798	48 03 c8	 add	 rcx, rax
  0279b	48 8b c1	 mov	 rax, rcx
  0279e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169579
  027a5	48 8b c8	 mov	 rcx, rax
  027a8	e8 00 00 00 00	 call	 strcmp
  027ad	85 c0		 test	 eax, eax
  027af	0f 85 8f 00 00
	00		 jne	 $LN359@the_real_p

; 2625 :                     get_cursor_pos( keybfd, confp, &cur_cons_row, &cur_cons_col );

  027b5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cur_cons_col
  027bc	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cur_cons_row
  027c3	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR confp
  027ca	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR keybfd
  027d0	e8 00 00 00 00	 call	 get_cursor_pos

; 2626 :                     if (cur_cons_col <= 1)

  027d5	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  027dc	83 f8 01	 cmp	 eax, 1
  027df	7f 20		 jg	 SHORT $LN360@the_real_p

; 2627 :                     {
; 2628 :                         cur_cons_row--;

  027e1	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  027e8	66 ff c8	 dec	 ax
  027eb	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax

; 2629 :                         cur_cons_col = cons_cols + 1;

  027f2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_cols
  027f8	ff c0		 inc	 eax
  027fa	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN360@the_real_p:

; 2630 :                     }
; 2631 :                     if (cur_cons_row < 1)

  02801	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  02808	83 f8 01	 cmp	 eax, 1
  0280b	7d 0e		 jge	 SHORT $LN361@the_real_p

; 2632 :                         cur_cons_row = cons_rows;

  0280d	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cons_rows
  02814	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax
$LN361@the_real_p:

; 2633 :                     set_pos( cur_cons_row, --cur_cons_col );

  0281b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_col
  02822	66 ff c8	 dec	 ax
  02825	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
  0282c	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cur_cons_col
  02833	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cur_cons_row
  0283a	e8 00 00 00 00	 call	 set_pos

; 2634 :                     break;

  0283f	e9 6a 0c 00 00	 jmp	 $LN26@the_real_p
$LN359@the_real_p:

; 2635 :                 }
; 2636 : 
; 2637 :                 /* Process ALT+RIGHTARROW */
; 2638 :                 if (NPDup == 0 && strcmp(kbbuf+i, KBD_ALT_RIGHT_ARROW) == 0) {

  02844	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  0284b	0f 85 b7 00 00
	00		 jne	 $LN362@the_real_p
  02851	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02856	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  0285e	48 03 c8	 add	 rcx, rax
  02861	48 8b c1	 mov	 rax, rcx
  02864	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169583
  0286b	48 8b c8	 mov	 rcx, rax
  0286e	e8 00 00 00 00	 call	 strcmp
  02873	85 c0		 test	 eax, eax
  02875	0f 85 8d 00 00
	00		 jne	 $LN362@the_real_p

; 2639 :                     get_cursor_pos( keybfd, confp, &cur_cons_row, &cur_cons_col );

  0287b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:cur_cons_col
  02882	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cur_cons_row
  02889	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR confp
  02890	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR keybfd
  02896	e8 00 00 00 00	 call	 get_cursor_pos

; 2640 :                     if (cur_cons_col >= cons_cols)

  0289b	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_col
  028a2	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  028a8	7c 1a		 jl	 SHORT $LN363@the_real_p

; 2641 :                     {
; 2642 :                         cur_cons_row++;

  028aa	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  028b1	66 ff c0	 inc	 ax
  028b4	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax

; 2643 :                         cur_cons_col = 0;

  028bb	33 c0		 xor	 eax, eax
  028bd	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN363@the_real_p:

; 2644 :                     }
; 2645 :                     if (cur_cons_row > cons_rows)

  028c4	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR cur_cons_row
  028cb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_rows
  028d1	7e 0c		 jle	 SHORT $LN364@the_real_p

; 2646 :                         cur_cons_row = 1;

  028d3	b8 01 00 00 00	 mov	 eax, 1
  028d8	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax
$LN364@the_real_p:

; 2647 :                     set_pos( cur_cons_row, ++cur_cons_col );

  028df	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_col
  028e6	66 ff c0	 inc	 ax
  028e9	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
  028f0	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cur_cons_col
  028f7	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cur_cons_row
  028fe	e8 00 00 00 00	 call	 set_pos

; 2648 :                     break;

  02903	e9 a6 0b 00 00	 jmp	 $LN26@the_real_p
$LN362@the_real_p:

; 2649 :                 }
; 2650 : #endif // defined(OPTION_EXTCURS)
; 2651 : 
; 2652 :                 /* Process INSERT */
; 2653 :                 if (strcmp(kbbuf+i, KBD_INSERT) == 0 ) {

  02908	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0290d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02915	48 03 c8	 add	 rcx, rax
  02918	48 8b c1	 mov	 rax, rcx
  0291b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169587
  02922	48 8b c8	 mov	 rcx, rax
  02925	e8 00 00 00 00	 call	 strcmp
  0292a	85 c0		 test	 eax, eax
  0292c	75 55		 jne	 SHORT $LN365@the_real_p

; 2654 :                     cmdins = !cmdins;

  0292e	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR cmdins
  02935	85 c0		 test	 eax, eax
  02937	75 0d		 jne	 SHORT $LN527@the_real_p
  02939	c7 84 24 24 01
	00 00 01 00 00
	00		 mov	 DWORD PTR tv1310[rsp], 1
  02944	eb 0b		 jmp	 SHORT $LN528@the_real_p
$LN527@the_real_p:
  02946	c7 84 24 24 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1310[rsp], 0
$LN528@the_real_p:
  02951	0f b6 84 24 24
	01 00 00	 movzx	 eax, BYTE PTR tv1310[rsp]
  02959	88 05 00 00 00
	00		 mov	 BYTE PTR cmdins, al

; 2655 :                     set_console_cursor_shape( confp, cmdins );

  0295f	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR cmdins
  02966	8b d0		 mov	 edx, eax
  02968	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  0296f	e8 00 00 00 00	 call	 set_console_cursor_shape

; 2656 :                     i++;

  02974	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  02978	ff c0		 inc	 eax
  0297a	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2657 :                     break;

  0297e	e9 2b 0b 00 00	 jmp	 $LN26@the_real_p
$LN365@the_real_p:

; 2658 :                 }
; 2659 : 
; 2660 :                 /* Process ESCAPE */
; 2661 :                 if (kbbuf[i] == '\x1B') {

  02983	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02988	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02990	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02994	83 f8 1b	 cmp	 eax, 27
  02997	0f 85 e5 00 00
	00		 jne	 $LN366@the_real_p

; 2662 :                     /* If data on cmdline, erase it */
; 2663 :                     if ((NPDup == 1 || is_cursor_on_cmdline()) && cmdlen) {

  0299d	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDup, 1
  029a4	74 0d		 je	 SHORT $LN369@the_real_p
  029a6	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  029ab	85 c0		 test	 eax, eax
  029ad	0f 84 b6 00 00
	00		 je	 $LN367@the_real_p
$LN369@the_real_p:
  029b3	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cmdlen, 0
  029ba	0f 84 a9 00 00
	00		 je	 $LN367@the_real_p

; 2664 :                         cmdline[0] = '\0';

  029c0	b8 01 00 00 00	 mov	 eax, 1
  029c5	48 6b c0 00	 imul	 rax, rax, 0
  029c9	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR $T36[rsp], rax
  029d1	48 81 bc 24 00
	02 00 00 01 01
	00 00		 cmp	 QWORD PTR $T36[rsp], 257 ; 00000101H
  029dd	73 02		 jae	 SHORT $LN529@the_real_p
  029df	eb 05		 jmp	 SHORT $LN530@the_real_p
$LN529@the_real_p:
  029e1	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN530@the_real_p:
  029e6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  029ed	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR $T36[rsp]
  029f5	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2665 :                         cmdlen = 0;

  029f9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdlen, 0

; 2666 :                         cmdoff = 0;

  02a03	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdoff, 0
$LN84@the_real_p:

; 2667 :                         ADJ_CMDCOL();

  02a0d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02a13	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02a19	2b c8		 sub	 ecx, eax
  02a1b	8b c1		 mov	 eax, ecx
  02a1d	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  02a23	7e 18		 jle	 SHORT $LN370@the_real_p
  02a25	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02a2b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02a31	2b c8		 sub	 ecx, eax
  02a33	8b c1		 mov	 eax, ecx
  02a35	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  02a3b	eb 1a		 jmp	 SHORT $LN371@the_real_p
$LN370@the_real_p:
  02a3d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02a43	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  02a49	7d 0c		 jge	 SHORT $LN372@the_real_p
  02a4b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  02a51	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN372@the_real_p:
$LN371@the_real_p:
  02a57	33 c0		 xor	 eax, eax
  02a59	85 c0		 test	 eax, eax
  02a5b	75 b0		 jne	 SHORT $LN84@the_real_p

; 2668 :                         redraw_cmd = 1;

  02a5d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2669 :                     } else {

  02a67	eb 14		 jmp	 SHORT $LN368@the_real_p
$LN367@the_real_p:

; 2670 :                         /* =NP= : Switch to new panel display */
; 2671 :                         save_command_line();

  02a69	e8 00 00 00 00	 call	 save_command_line

; 2672 :                         NP_init();

  02a6e	e8 00 00 00 00	 call	 NP_init

; 2673 :                         NPDup = 1;

  02a73	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPDup, 1
$LN368@the_real_p:

; 2674 :                         /* =END= */
; 2675 :                     }
; 2676 :                     break;

  02a7d	e9 2c 0a 00 00	 jmp	 $LN26@the_real_p
$LN366@the_real_p:

; 2677 :                 }
; 2678 : 
; 2679 :                 /* Process TAB */
; 2680 :                 if (kbbuf[i] == '\t' || kbbuf[i] == '\x7F')

  02a82	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02a87	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02a8f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02a93	83 f8 09	 cmp	 eax, 9
  02a96	74 1a		 je	 SHORT $LN374@the_real_p
  02a98	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02a9d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02aa5	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02aa9	83 f8 7f	 cmp	 eax, 127		; 0000007fH
  02aac	0f 85 b9 00 00
	00		 jne	 $LN373@the_real_p
$LN374@the_real_p:

; 2681 :                 {
; 2682 :                     if (NPDup == 1 || !is_cursor_on_cmdline())

  02ab2	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDup, 1
  02ab9	74 09		 je	 SHORT $LN377@the_real_p
  02abb	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  02ac0	85 c0		 test	 eax, eax
  02ac2	75 14		 jne	 SHORT $LN375@the_real_p
$LN377@the_real_p:

; 2683 :                     {
; 2684 :                         cursor_cmdline_home();

  02ac4	e8 00 00 00 00	 call	 cursor_cmdline_home

; 2685 :                         redraw_cmd = 1;

  02ac9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2686 :                     }

  02ad3	e9 8e 00 00 00	 jmp	 $LN376@the_real_p
$LN375@the_real_p:

; 2687 :                     else
; 2688 :                     {
; 2689 :                         tab_pressed(cmdline, sizeof(cmdline), &cmdoff);

  02ad8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:cmdoff
  02adf	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  02ae4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02aeb	e8 00 00 00 00	 call	 tab_pressed

; 2690 :                         cmdlen = (int)strlen(cmdline);

  02af0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02af7	e8 00 00 00 00	 call	 strlen
  02afc	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax
$LN87@the_real_p:

; 2691 :                         ADJ_CMDCOL();

  02b02	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02b08	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02b0e	2b c8		 sub	 ecx, eax
  02b10	8b c1		 mov	 eax, ecx
  02b12	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  02b18	7e 18		 jle	 SHORT $LN378@the_real_p
  02b1a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02b20	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02b26	2b c8		 sub	 ecx, eax
  02b28	8b c1		 mov	 eax, ecx
  02b2a	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  02b30	eb 1a		 jmp	 SHORT $LN379@the_real_p
$LN378@the_real_p:
  02b32	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02b38	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  02b3e	7d 0c		 jge	 SHORT $LN380@the_real_p
  02b40	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  02b46	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN380@the_real_p:
$LN379@the_real_p:
  02b4c	33 c0		 xor	 eax, eax
  02b4e	85 c0		 test	 eax, eax
  02b50	75 b0		 jne	 SHORT $LN87@the_real_p

; 2692 :                         i++;

  02b52	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  02b56	ff c0		 inc	 eax
  02b58	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2693 :                         redraw_cmd = 1;

  02b5c	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1
$LN376@the_real_p:

; 2694 :                     }
; 2695 :                     break;

  02b66	e9 43 09 00 00	 jmp	 $LN26@the_real_p
$LN373@the_real_p:

; 2696 :                 }
; 2697 : 
; 2698 : #if defined(OPTION_EXTCURS)
; 2699 :                 /* ENTER key special handling */
; 2700 :                 if (NPDup == 0 && kbbuf[i] == '\n')

  02b6b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02b72	75 29		 jne	 SHORT $LN381@the_real_p
  02b74	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02b79	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02b81	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02b85	83 f8 0a	 cmp	 eax, 10
  02b88	75 13		 jne	 SHORT $LN381@the_real_p

; 2701 :                 {
; 2702 :                     /* Get cursor pos and check if on cmdline */
; 2703 :                     if (!is_cursor_on_cmdline())

  02b8a	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  02b8f	85 c0		 test	 eax, eax
  02b91	75 0a		 jne	 SHORT $LN382@the_real_p

; 2704 :                     {
; 2705 :                         beep();

  02b93	e8 00 00 00 00	 call	 beep

; 2706 :                         break;

  02b98	e9 11 09 00 00	 jmp	 $LN26@the_real_p
$LN382@the_real_p:
$LN381@the_real_p:

; 2707 :                     }
; 2708 :                 }
; 2709 : #endif // defined(OPTION_EXTCURS)
; 2710 : 
; 2711 :                 /* Process the command when the ENTER key is pressed */
; 2712 :                 if (kbbuf[i] == '\n') {

  02b9d	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  02ba2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  02baa	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02bae	83 f8 0a	 cmp	 eax, 10
  02bb1	0f 85 c1 04 00
	00		 jne	 $LN383@the_real_p

; 2713 :                     if (1
; 2714 :                         && cmdlen == 0
; 2715 :                         && NPDup == 0
; 2716 :                         && !sysblk.instbreak

  02bb7	33 c0		 xor	 eax, eax
  02bb9	83 f8 01	 cmp	 eax, 1
  02bbc	74 33		 je	 SHORT $LN384@the_real_p
  02bbe	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR cmdlen, 0
  02bc5	75 2a		 jne	 SHORT $LN384@the_real_p
  02bc7	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02bce	75 21		 jne	 SHORT $LN384@the_real_p
  02bd0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  02bd7	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  02bdd	c1 e8 0a	 shr	 eax, 10
  02be0	83 e0 01	 and	 eax, 1
  02be3	85 c0		 test	 eax, eax
  02be5	75 0a		 jne	 SHORT $LN384@the_real_p

; 2717 :                     ) {
; 2718 :                         history_show();

  02be7	e8 00 00 00 00	 call	 history_show

; 2719 :                     } else {

  02bec	e9 82 04 00 00	 jmp	 $LN385@the_real_p
$LN384@the_real_p:

; 2720 :                         cmdline[cmdlen] = '\0';

  02bf1	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR cmdlen
  02bf8	48 89 84 24 b8
	01 00 00	 mov	 QWORD PTR $T29[rsp], rax
  02c00	48 81 bc 24 b8
	01 00 00 01 01
	00 00		 cmp	 QWORD PTR $T29[rsp], 257 ; 00000101H
  02c0c	73 02		 jae	 SHORT $LN531@the_real_p
  02c0e	eb 05		 jmp	 SHORT $LN532@the_real_p
$LN531@the_real_p:
  02c10	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN532@the_real_p:
  02c15	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  02c1c	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR $T29[rsp]
  02c24	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2721 :                         /* =NP= create_thread replaced with: */
; 2722 :                         if (NPDup == 0) {

  02c28	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  02c2f	0f 85 ce 01 00
	00		 jne	 $LN386@the_real_p

; 2723 :                             if ('#' == cmdline[0] || '*' == cmdline[0]) {

  02c35	b8 01 00 00 00	 mov	 eax, 1
  02c3a	48 6b c0 00	 imul	 rax, rax, 0
  02c3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02c45	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02c49	83 f8 23	 cmp	 eax, 35			; 00000023H
  02c4c	74 1d		 je	 SHORT $LN390@the_real_p
  02c4e	b8 01 00 00 00	 mov	 eax, 1
  02c53	48 6b c0 00	 imul	 rax, rax, 0
  02c57	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02c5e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  02c62	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  02c65	0f 85 a1 00 00
	00		 jne	 $LN388@the_real_p
$LN390@the_real_p:

; 2724 :                                 if (!is_currline_visible())

  02c6b	e8 00 00 00 00	 call	 is_currline_visible
  02c70	85 c0		 test	 eax, eax
  02c72	75 05		 jne	 SHORT $LN391@the_real_p

; 2725 :                                     scroll_to_bottom_screen();

  02c74	e8 00 00 00 00	 call	 scroll_to_bottom_screen
$LN391@the_real_p:

; 2726 :                                 history_requested = 0;

  02c79	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR history_requested, 0

; 2727 :                                 do_panel_command(cmdline);

  02c83	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02c8a	e8 00 00 00 00	 call	 do_panel_command

; 2728 :                                 redraw_cmd = 1;

  02c8f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2729 :                                 cmdlen = 0;

  02c99	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdlen, 0

; 2730 :                                 cmdoff = 0;

  02ca3	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdoff, 0
$LN90@the_real_p:

; 2731 :                                 ADJ_CMDCOL();

  02cad	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02cb3	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02cb9	2b c8		 sub	 ecx, eax
  02cbb	8b c1		 mov	 eax, ecx
  02cbd	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  02cc3	7e 18		 jle	 SHORT $LN392@the_real_p
  02cc5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02ccb	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02cd1	2b c8		 sub	 ecx, eax
  02cd3	8b c1		 mov	 eax, ecx
  02cd5	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  02cdb	eb 1a		 jmp	 SHORT $LN393@the_real_p
$LN392@the_real_p:
  02cdd	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02ce3	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  02ce9	7d 0c		 jge	 SHORT $LN394@the_real_p
  02ceb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  02cf1	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN394@the_real_p:
$LN393@the_real_p:
  02cf7	33 c0		 xor	 eax, eax
  02cf9	85 c0		 test	 eax, eax
  02cfb	75 b0		 jne	 SHORT $LN90@the_real_p

; 2732 :                                 redraw_cmd = 1;

  02cfd	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2733 :                             } else {

  02d07	e9 f2 00 00 00	 jmp	 $LN389@the_real_p
$LN388@the_real_p:

; 2734 :                                 history_requested = 0;

  02d0c	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR history_requested, 0

; 2735 :                                 do_panel_command(cmdline);

  02d16	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02d1d	e8 00 00 00 00	 call	 do_panel_command

; 2736 :                                 redraw_cmd = 1;

  02d22	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2737 :                                 if (history_requested == 1) {

  02d2c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR history_requested, 1
  02d33	0f 85 c5 00 00
	00		 jne	 $LN395@the_real_p

; 2738 :                                     STRLCPY(cmdline, historyCmdLine);

  02d39	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  02d3f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR historyCmdLine
  02d46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02d4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2739 :                                     cmdlen = (int)strlen(cmdline);

  02d53	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02d5a	e8 00 00 00 00	 call	 strlen
  02d5f	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 2740 :                                     cmdoff = cmdlen < cmdcols ? cmdlen : 0;

  02d65	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02d6b	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdlen, eax
  02d71	7d 0f		 jge	 SHORT $LN533@the_real_p
  02d73	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  02d79	89 84 24 28 01
	00 00		 mov	 DWORD PTR tv1407[rsp], eax
  02d80	eb 0b		 jmp	 SHORT $LN534@the_real_p
$LN533@the_real_p:
  02d82	c7 84 24 28 01
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1407[rsp], 0
$LN534@the_real_p:
  02d8d	8b 84 24 28 01
	00 00		 mov	 eax, DWORD PTR tv1407[rsp]
  02d94	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN93@the_real_p:

; 2741 :                                     ADJ_CMDCOL();

  02d9a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02da0	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02da6	2b c8		 sub	 ecx, eax
  02da8	8b c1		 mov	 eax, ecx
  02daa	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  02db0	7e 18		 jle	 SHORT $LN396@the_real_p
  02db2	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  02db8	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  02dbe	2b c8		 sub	 ecx, eax
  02dc0	8b c1		 mov	 eax, ecx
  02dc2	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  02dc8	eb 1a		 jmp	 SHORT $LN397@the_real_p
$LN396@the_real_p:
  02dca	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  02dd0	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  02dd6	7d 0c		 jge	 SHORT $LN398@the_real_p
  02dd8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  02dde	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN398@the_real_p:
$LN397@the_real_p:
  02de4	33 c0		 xor	 eax, eax
  02de6	85 c0		 test	 eax, eax
  02de8	75 b0		 jne	 SHORT $LN93@the_real_p

; 2742 :                                     redraw_cmd = 1;

  02dea	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1

; 2743 :                                     cursor_cmdline_end();

  02df4	e8 00 00 00 00	 call	 cursor_cmdline_end

; 2744 :                                     break;

  02df9	e9 b0 06 00 00	 jmp	 $LN26@the_real_p
$LN395@the_real_p:
$LN389@the_real_p:

; 2745 :                                 }
; 2746 :                             }
; 2747 :                         } else {

  02dfe	e9 66 02 00 00	 jmp	 $LN387@the_real_p
$LN386@the_real_p:

; 2748 :                             NPdataentry = 0;

  02e03	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPdataentry, 0

; 2749 :                             NPcurrow = cons_rows;

  02e0d	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cons_rows
  02e14	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurrow, ax

; 2750 :                             NPcurcol = cons_cols;

  02e1b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cons_cols
  02e22	66 89 05 00 00
	00 00		 mov	 WORD PTR NPcurcol, ax

; 2751 :                             NPcolorSwitch = 0;

  02e29	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPcolorSwitch, 0

; 2752 :                             switch (NPpending) {

  02e33	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR NPpending
  02e3a	88 84 24 fc 00
	00 00		 mov	 BYTE PTR tv1414[rsp], al
  02e41	80 bc 24 fc 00
	00 00 64	 cmp	 BYTE PTR tv1414[rsp], 100 ; 00000064H
  02e49	74 60		 je	 SHORT $LN400@the_real_p
  02e4b	80 bc 24 fc 00
	00 00 6e	 cmp	 BYTE PTR tv1414[rsp], 110 ; 0000006eH
  02e53	0f 84 95 00 00
	00		 je	 $LN401@the_real_p
  02e59	80 bc 24 fc 00
	00 00 72	 cmp	 BYTE PTR tv1414[rsp], 114 ; 00000072H
  02e61	74 05		 je	 SHORT $LN399@the_real_p
  02e63	e9 5a 01 00 00	 jmp	 $LN403@the_real_p
$LN399@the_real_p:

; 2753 :                                 case 'r':
; 2754 :                                     sscanf(cmdline, "%x", &NPaddress);

  02e68	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:NPaddress
  02e6f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169622
  02e76	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02e7d	e8 00 00 00 00	 call	 sscanf

; 2755 :                                     NPaddr_valid = 0;

  02e82	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPaddr_valid, 0

; 2756 :                                     STRLCPY(NPprompt1, "");

  02e8c	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  02e92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169623
  02e99	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  02ea0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2757 :                                     break;

  02ea6	e9 17 01 00 00	 jmp	 $LN94@the_real_p
$LN400@the_real_p:

; 2758 :                                 case 'd':
; 2759 :                                     sscanf(cmdline, "%x", &NPdata);

  02eab	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:NPdata
  02eb2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169625
  02eb9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02ec0	e8 00 00 00 00	 call	 sscanf

; 2760 :                                     NPdata_valid = 0;

  02ec5	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPdata_valid, 0

; 2761 :                                     STRLCPY(NPprompt1, "");

  02ecf	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  02ed5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169626
  02edc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt1
  02ee3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2762 :                                     break;

  02ee9	e9 d4 00 00 00	 jmp	 $LN94@the_real_p
$LN401@the_real_p:

; 2763 :                                 case 'n':
; 2764 :                                     if (strlen(cmdline) < 1) {

  02eee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02ef5	e8 00 00 00 00	 call	 strlen
  02efa	48 83 f8 01	 cmp	 rax, 1
  02efe	73 31		 jae	 SHORT $LN402@the_real_p

; 2765 :                                         STRLCPY(cmdline, NPdevnam[NPasgn]);

  02f00	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR NPasgn
  02f07	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  02f0e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnam
  02f15	48 03 c8	 add	 rcx, rax
  02f18	48 8b c1	 mov	 rax, rcx
  02f1b	41 b8 01 01 00
	00		 mov	 r8d, 257		; 00000101H
  02f21	48 8b d0	 mov	 rdx, rax
  02f24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02f2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN402@the_real_p:

; 2766 :                                     }
; 2767 :                                     STRLCPY(NPdevnam[NPasgn], "");

  02f31	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR NPasgn
  02f38	48 69 c0 80 00
	00 00		 imul	 rax, rax, 128		; 00000080H
  02f3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnam
  02f46	48 03 c8	 add	 rcx, rax
  02f49	48 8b c1	 mov	 rax, rcx
  02f4c	41 b8 80 00 00
	00		 mov	 r8d, 128		; 00000080H
  02f52	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169629
  02f59	48 8b c8	 mov	 rcx, rax
  02f5c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 2768 :                                     MSGBUF (NPentered, "devinit %4.4x %s",

  02f62	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR NPasgn
  02f69	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPdevnum
  02f70	0f b7 04 41	 movzx	 eax, WORD PTR [rcx+rax*2]
  02f74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  02f7b	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  02f80	44 8b c8	 mov	 r9d, eax
  02f83	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169630
  02f8a	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  02f8f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPentered
  02f96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 2769 :                                              NPdevnum[NPasgn], cmdline);
; 2770 :                                     do_panel_command(NPentered);

  02f9c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPentered
  02fa3	e8 00 00 00 00	 call	 do_panel_command

; 2771 :                                     STRLCPY(NPprompt2, "");

  02fa8	41 b8 28 00 00
	00		 mov	 r8d, 40			; 00000028H
  02fae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169631
  02fb5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:NPprompt2
  02fbc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN403@the_real_p:
$LN94@the_real_p:

; 2772 :                                     break;
; 2773 :                                 default:
; 2774 :                                     break;
; 2775 :                             }
; 2776 :                             redraw_status = 1;

  02fc2	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2777 :                             cmdline[0] = '\0';

  02fcc	b8 01 00 00 00	 mov	 eax, 1
  02fd1	48 6b c0 00	 imul	 rax, rax, 0
  02fd5	48 89 84 24 08
	02 00 00	 mov	 QWORD PTR $T37[rsp], rax
  02fdd	48 81 bc 24 08
	02 00 00 01 01
	00 00		 cmp	 QWORD PTR $T37[rsp], 257 ; 00000101H
  02fe9	73 02		 jae	 SHORT $LN535@the_real_p
  02feb	eb 05		 jmp	 SHORT $LN536@the_real_p
$LN535@the_real_p:
  02fed	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN536@the_real_p:
  02ff2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  02ff9	48 8b 8c 24 08
	02 00 00	 mov	 rcx, QWORD PTR $T37[rsp]
  03001	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2778 :                             cmdlen = 0;

  03005	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdlen, 0

; 2779 :                             cmdoff = 0;

  0300f	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR cmdoff, 0
$LN98@the_real_p:

; 2780 :                             ADJ_CMDCOL();

  03019	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0301f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  03025	2b c8		 sub	 ecx, eax
  03027	8b c1		 mov	 eax, ecx
  03029	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  0302f	7e 18		 jle	 SHORT $LN404@the_real_p
  03031	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  03037	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  0303d	2b c8		 sub	 ecx, eax
  0303f	8b c1		 mov	 eax, ecx
  03041	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  03047	eb 1a		 jmp	 SHORT $LN405@the_real_p
$LN404@the_real_p:
  03049	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0304f	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  03055	7d 0c		 jge	 SHORT $LN406@the_real_p
  03057	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  0305d	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN406@the_real_p:
$LN405@the_real_p:
  03063	33 c0		 xor	 eax, eax
  03065	85 c0		 test	 eax, eax
  03067	75 b0		 jne	 SHORT $LN98@the_real_p
$LN387@the_real_p:

; 2781 :                         }
; 2782 :                         /* =END= */
; 2783 :                         redraw_cmd = 1;

  03069	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1
$LN385@the_real_p:

; 2784 :                     }
; 2785 :                     break;

  03073	e9 36 04 00 00	 jmp	 $LN26@the_real_p
$LN383@the_real_p:

; 2786 :                 } /* end if (kbbuf[i] == '\n') */
; 2787 : 
; 2788 :                 /* Ignore non-printable characters */
; 2789 :                 if (!isprint(kbbuf[i])) {

  03078	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0307d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  03085	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  03089	8b c8		 mov	 ecx, eax
  0308b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isprint
  03091	85 c0		 test	 eax, eax
  03093	75 14		 jne	 SHORT $LN407@the_real_p

; 2790 :                     beep();

  03095	e8 00 00 00 00	 call	 beep

; 2791 :                     i++;

  0309a	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0309e	ff c0		 inc	 eax
  030a0	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2792 :                     continue;

  030a4	e9 7c e1 ff ff	 jmp	 $LN25@the_real_p
$LN407@the_real_p:

; 2793 :                 }
; 2794 : 
; 2795 :                 /* Ignore all other keystrokes not on cmdline */
; 2796 :                 if (NPDup == 0 && !is_cursor_on_cmdline()) {

  030a9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  030b0	75 13		 jne	 SHORT $LN408@the_real_p
  030b2	e8 00 00 00 00	 call	 is_cursor_on_cmdline
  030b7	85 c0		 test	 eax, eax
  030b9	75 0a		 jne	 SHORT $LN408@the_real_p

; 2797 :                     beep();

  030bb	e8 00 00 00 00	 call	 beep

; 2798 :                     break;

  030c0	e9 e9 03 00 00	 jmp	 $LN26@the_real_p
$LN408@the_real_p:
$LN101@the_real_p:

; 2799 :                 }
; 2800 : 
; 2801 :                 /* Append the character to the command buffer */
; 2802 :                 ASSERT(cmdlen <= CMD_SIZE-1 && cmdoff <= cmdlen);

  030c5	81 3d 00 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR cmdlen, 255	; 000000ffH
  030cf	7f 0e		 jg	 SHORT $LN410@the_real_p
  030d1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  030d7	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  030dd	7e 5c		 jle	 SHORT $LN409@the_real_p
$LN410@the_real_p:
$LN104@the_real_p:
  030df	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169640
  030e6	41 b8 f2 0a 00
	00		 mov	 r8d, 2802		; 00000af2H
  030ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169641
  030f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169642
  030fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  03100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03106	85 c0		 test	 eax, eax
  03108	74 20		 je	 SHORT $LN411@the_real_p
  0310a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169644
  03111	41 b8 f2 0a 00
	00		 mov	 r8d, 2802		; 00000af2H
  03117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169645
  0311e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169646
  03125	e8 00 00 00 00	 call	 DebuggerTrace
$LN411@the_real_p:
  0312a	33 c0		 xor	 eax, eax
  0312c	85 c0		 test	 eax, eax
  0312e	75 af		 jne	 SHORT $LN104@the_real_p
  03130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03136	85 c0		 test	 eax, eax
  03138	74 01		 je	 SHORT $LN412@the_real_p
  0313a	cc		 int	 3
$LN412@the_real_p:
$LN409@the_real_p:
  0313b	33 c0		 xor	 eax, eax
  0313d	85 c0		 test	 eax, eax
  0313f	75 84		 jne	 SHORT $LN101@the_real_p

; 2803 :                 if (0
; 2804 :                     || (cmdoff >= CMD_SIZE-1)
; 2805 :                     || (cmdins && cmdlen >= CMD_SIZE-1)

  03141	33 c0		 xor	 eax, eax
  03143	85 c0		 test	 eax, eax
  03145	75 23		 jne	 SHORT $LN415@the_real_p
  03147	81 3d 00 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR cmdoff, 255	; 000000ffH
  03151	7d 17		 jge	 SHORT $LN415@the_real_p
  03153	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR cmdins
  0315a	85 c0		 test	 eax, eax
  0315c	74 16		 je	 SHORT $LN413@the_real_p
  0315e	81 3d 00 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR cmdlen, 255	; 000000ffH
  03168	7c 0a		 jl	 SHORT $LN413@the_real_p
$LN415@the_real_p:

; 2806 :                 )
; 2807 :                 {
; 2808 :                     /* (no more room!) */
; 2809 :                     beep();

  0316a	e8 00 00 00 00	 call	 beep

; 2810 :                 }

  0316f	e9 2b 03 00 00	 jmp	 $LN414@the_real_p
$LN413@the_real_p:
$LN107@the_real_p:

; 2811 :                 else /* (there's still room) */
; 2812 :                 {
; 2813 :                     ASSERT(cmdlen < CMD_SIZE-1 || (!cmdins && cmdoff < cmdlen));

  03174	81 3d 00 00 00
	00 ff 00 00 00	 cmp	 DWORD PTR cmdlen, 255	; 000000ffH
  0317e	7c 75		 jl	 SHORT $LN416@the_real_p
  03180	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR cmdins
  03187	85 c0		 test	 eax, eax
  03189	75 0e		 jne	 SHORT $LN417@the_real_p
  0318b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  03191	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  03197	7c 5c		 jl	 SHORT $LN416@the_real_p
$LN417@the_real_p:
$LN110@the_real_p:
  03199	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169653
  031a0	41 b8 fd 0a 00
	00		 mov	 r8d, 2813		; 00000afdH
  031a6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169654
  031ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169655
  031b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  031ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  031c0	85 c0		 test	 eax, eax
  031c2	74 20		 je	 SHORT $LN418@the_real_p
  031c4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169657
  031cb	41 b8 fd 0a 00
	00		 mov	 r8d, 2813		; 00000afdH
  031d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169658
  031d8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169659
  031df	e8 00 00 00 00	 call	 DebuggerTrace
$LN418@the_real_p:
  031e4	33 c0		 xor	 eax, eax
  031e6	85 c0		 test	 eax, eax
  031e8	75 af		 jne	 SHORT $LN110@the_real_p
  031ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  031f0	85 c0		 test	 eax, eax
  031f2	74 01		 je	 SHORT $LN419@the_real_p
  031f4	cc		 int	 3
$LN419@the_real_p:
$LN416@the_real_p:
  031f5	33 c0		 xor	 eax, eax
  031f7	85 c0		 test	 eax, eax
  031f9	0f 85 75 ff ff
	ff		 jne	 $LN107@the_real_p

; 2814 :                     if (cmdoff >= cmdlen)

  031ff	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  03205	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  0320b	0f 8c ea 00 00
	00		 jl	 $LN420@the_real_p
$LN113@the_real_p:

; 2815 :                     {
; 2816 :                         /* Append to end of buffer */
; 2817 :                         ASSERT(!(cmdoff > cmdlen)); // (sanity check)

  03211	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  03217	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  0321d	7e 5c		 jle	 SHORT $LN422@the_real_p
$LN116@the_real_p:
  0321f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169664
  03226	41 b8 01 0b 00
	00		 mov	 r8d, 2817		; 00000b01H
  0322c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169665
  03233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169666
  0323a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  03240	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03246	85 c0		 test	 eax, eax
  03248	74 20		 je	 SHORT $LN423@the_real_p
  0324a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169668
  03251	41 b8 01 0b 00
	00		 mov	 r8d, 2817		; 00000b01H
  03257	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169669
  0325e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169670
  03265	e8 00 00 00 00	 call	 DebuggerTrace
$LN423@the_real_p:
  0326a	33 c0		 xor	 eax, eax
  0326c	85 c0		 test	 eax, eax
  0326e	75 af		 jne	 SHORT $LN116@the_real_p
  03270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03276	85 c0		 test	 eax, eax
  03278	74 01		 je	 SHORT $LN424@the_real_p
  0327a	cc		 int	 3
$LN424@the_real_p:
$LN422@the_real_p:
  0327b	33 c0		 xor	 eax, eax
  0327d	85 c0		 test	 eax, eax
  0327f	75 90		 jne	 SHORT $LN113@the_real_p

; 2818 :                         cmdline[cmdoff++] = kbbuf[i];

  03281	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  03286	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR cmdoff
  0328d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cmdline
  03294	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR kbbuf$[rsp]
  0329c	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  032a0	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  032a3	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  032a9	ff c0		 inc	 eax
  032ab	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax

; 2819 :                         cmdline[cmdoff] = '\0';

  032b1	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR cmdoff
  032b8	48 89 84 24 10
	02 00 00	 mov	 QWORD PTR $T38[rsp], rax
  032c0	48 81 bc 24 10
	02 00 00 01 01
	00 00		 cmp	 QWORD PTR $T38[rsp], 257 ; 00000101H
  032cc	73 02		 jae	 SHORT $LN537@the_real_p
  032ce	eb 05		 jmp	 SHORT $LN538@the_real_p
$LN537@the_real_p:
  032d0	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN538@the_real_p:
  032d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdline
  032dc	48 8b 8c 24 10
	02 00 00	 mov	 rcx, QWORD PTR $T38[rsp]
  032e4	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0

; 2820 :                         cmdlen++;

  032e8	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  032ee	ff c0		 inc	 eax
  032f0	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 2821 :                     }

  032f6	e9 4a 01 00 00	 jmp	 $LN421@the_real_p
$LN420@the_real_p:
$LN119@the_real_p:

; 2822 :                     else
; 2823 :                     {
; 2824 :                         ASSERT(cmdoff < cmdlen);

  032fb	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  03301	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  03307	7c 5c		 jl	 SHORT $LN425@the_real_p
$LN122@the_real_p:
  03309	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169673
  03310	41 b8 08 0b 00
	00		 mov	 r8d, 2824		; 00000b08H
  03316	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169674
  0331d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169675
  03324	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0332a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03330	85 c0		 test	 eax, eax
  03332	74 20		 je	 SHORT $LN426@the_real_p
  03334	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169677
  0333b	41 b8 08 0b 00
	00		 mov	 r8d, 2824		; 00000b08H
  03341	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169678
  03348	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  0334f	e8 00 00 00 00	 call	 DebuggerTrace
$LN426@the_real_p:
  03354	33 c0		 xor	 eax, eax
  03356	85 c0		 test	 eax, eax
  03358	75 af		 jne	 SHORT $LN122@the_real_p
  0335a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03360	85 c0		 test	 eax, eax
  03362	74 01		 je	 SHORT $LN427@the_real_p
  03364	cc		 int	 3
$LN427@the_real_p:
$LN425@the_real_p:
  03365	33 c0		 xor	 eax, eax
  03367	85 c0		 test	 eax, eax
  03369	75 90		 jne	 SHORT $LN119@the_real_p

; 2825 :                         if (cmdins)

  0336b	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR cmdins
  03372	85 c0		 test	 eax, eax
  03374	0f 84 9b 00 00
	00		 je	 $LN428@the_real_p

; 2826 :                         {
; 2827 :                             /* Insert: make room by sliding all
; 2828 :                                following chars right one position */
; 2829 :                             int j;
; 2830 :                             for (j=cmdlen-1; j>=cmdoff; j--)

  0337a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  03380	ff c8		 dec	 eax
  03382	89 84 24 e0 00
	00 00		 mov	 DWORD PTR j$12[rsp], eax
  03389	eb 10		 jmp	 SHORT $LN125@the_real_p
$LN123@the_real_p:
  0338b	8b 84 24 e0 00
	00 00		 mov	 eax, DWORD PTR j$12[rsp]
  03392	ff c8		 dec	 eax
  03394	89 84 24 e0 00
	00 00		 mov	 DWORD PTR j$12[rsp], eax
$LN125@the_real_p:
  0339b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  033a1	39 84 24 e0 00
	00 00		 cmp	 DWORD PTR j$12[rsp], eax
  033a8	7c 2b		 jl	 SHORT $LN124@the_real_p

; 2831 :                                 cmdline[j+1] = cmdline[j];

  033aa	48 63 84 24 e0
	00 00 00	 movsxd	 rax, DWORD PTR j$12[rsp]
  033b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  033b9	8b 94 24 e0 00
	00 00		 mov	 edx, DWORD PTR j$12[rsp]
  033c0	ff c2		 inc	 edx
  033c2	48 63 d2	 movsxd	 rdx, edx
  033c5	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:cmdline
  033cc	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  033d0	88 04 17	 mov	 BYTE PTR [rdi+rdx], al
  033d3	eb b6		 jmp	 SHORT $LN123@the_real_p
$LN124@the_real_p:

; 2832 :                             cmdline[cmdoff++] = kbbuf[i];

  033d5	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  033da	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR cmdoff
  033e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cmdline
  033e8	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR kbbuf$[rsp]
  033f0	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  033f4	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  033f7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  033fd	ff c0		 inc	 eax
  033ff	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax

; 2833 :                             cmdlen++;

  03405	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  0340b	ff c0		 inc	 eax
  0340d	89 05 00 00 00
	00		 mov	 DWORD PTR cmdlen, eax

; 2834 :                         }

  03413	eb 30		 jmp	 SHORT $LN429@the_real_p
$LN428@the_real_p:

; 2835 :                         else
; 2836 :                         {
; 2837 :                             /* Overlay: replace current position */
; 2838 :                             cmdline[cmdoff++] = kbbuf[i];

  03415	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0341a	48 63 0d 00 00
	00 00		 movsxd	 rcx, DWORD PTR cmdoff
  03421	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:cmdline
  03428	48 8b bc 24 88
	00 00 00	 mov	 rdi, QWORD PTR kbbuf$[rsp]
  03430	0f b6 04 07	 movzx	 eax, BYTE PTR [rdi+rax]
  03434	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  03437	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  0343d	ff c0		 inc	 eax
  0343f	89 05 00 00 00
	00		 mov	 DWORD PTR cmdoff, eax
$LN429@the_real_p:
$LN421@the_real_p:
$LN128@the_real_p:

; 2839 :                         }
; 2840 :                     }
; 2841 :                     ADJ_CMDCOL();

  03445	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0344b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  03451	2b c8		 sub	 ecx, eax
  03453	8b c1		 mov	 eax, ecx
  03455	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdcols
  0345b	7e 18		 jle	 SHORT $LN430@the_real_p
  0345d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  03463	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdoff
  03469	2b c8		 sub	 ecx, eax
  0346b	8b c1		 mov	 eax, ecx
  0346d	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
  03473	eb 1a		 jmp	 SHORT $LN431@the_real_p
$LN430@the_real_p:
  03475	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcol
  0347b	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdoff, eax
  03481	7d 0c		 jge	 SHORT $LN432@the_real_p
  03483	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdoff
  03489	89 05 00 00 00
	00		 mov	 DWORD PTR cmdcol, eax
$LN432@the_real_p:
$LN431@the_real_p:
  0348f	33 c0		 xor	 eax, eax
  03491	85 c0		 test	 eax, eax
  03493	75 b0		 jne	 SHORT $LN128@the_real_p

; 2842 :                     redraw_cmd = 1;

  03495	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1
$LN414@the_real_p:

; 2843 :                 }
; 2844 :                 i++;

  0349f	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  034a3	ff c0		 inc	 eax
  034a5	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 2845 :             } /* end for(i) */

  034a9	e9 77 dd ff ff	 jmp	 $LN25@the_real_p
$LN26@the_real_p:
$LN174@the_real_p:
$FinishShutdown$569:

; 2846 :         } /* end if keystroke */
; 2847 : 
; 2848 : FinishShutdown:
; 2849 : 
; 2850 :         // If we finished processing all of the message data
; 2851 :         // the last time we were here, then get some more...
; 2852 : 
; 2853 :         if ( lmsndx >= lmscnt )  // (all previous data processed?)

  034ae	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmscnt
  034b4	39 05 00 00 00
	00		 cmp	 DWORD PTR lmsndx, eax
  034ba	7c 29		 jl	 SHORT $LN433@the_real_p

; 2854 :         {
; 2855 :             lmscnt = log_read( &lmsbuf, &lmsnum, LOG_NOBLOCK );

  034bc	45 33 c0	 xor	 r8d, r8d
  034bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:lmsnum
  034c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:lmsbuf
  034cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_log_read
  034d3	89 05 00 00 00
	00		 mov	 DWORD PTR lmscnt, eax

; 2856 :             lmsndx = 0;

  034d9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR lmsndx, 0

; 2857 :         }

  034e3	eb 49		 jmp	 SHORT $LN434@the_real_p
$LN433@the_real_p:

; 2858 :         else if ( lmsndx >= lmsmax )

  034e5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmsmax
  034eb	39 05 00 00 00
	00		 cmp	 DWORD PTR lmsndx, eax
  034f1	7c 3b		 jl	 SHORT $LN435@the_real_p

; 2859 :         {
; 2860 :             lmsbuf += lmsndx;   // pick up where we left off at...

  034f3	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR lmsndx
  034fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR lmsbuf
  03501	48 03 c8	 add	 rcx, rax
  03504	48 8b c1	 mov	 rax, rcx
  03507	48 89 05 00 00
	00 00		 mov	 QWORD PTR lmsbuf, rax

; 2861 :             lmscnt -= lmsndx;   // pick up where we left off at...

  0350e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmsndx
  03514	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR lmscnt
  0351a	2b c8		 sub	 ecx, eax
  0351c	8b c1		 mov	 eax, ecx
  0351e	89 05 00 00 00
	00		 mov	 DWORD PTR lmscnt, eax

; 2862 :             lmsndx = 0;

  03524	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR lmsndx, 0
$LN435@the_real_p:
$LN434@the_real_p:
$LN129@the_real_p:

; 2863 :         }
; 2864 : 
; 2865 :         // Process all message data or until limit reached...
; 2866 : 
; 2867 :         // (limiting the amount of data we process a console message flood
; 2868 :         // from preventing keyboard from being read since we need to break
; 2869 :         // out of the below message data processing loop to loop back up
; 2870 :         // to read the keyboard again...)
; 2871 : 
; 2872 :         /* Read message bytes until newline... */
; 2873 :         while ( lmsndx < lmscnt && lmsndx < lmsmax )

  0352e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmscnt
  03534	39 05 00 00 00
	00		 cmp	 DWORD PTR lmsndx, eax
  0353a	0f 8d 00 02 00
	00		 jge	 $LN130@the_real_p
  03540	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmsmax
  03546	39 05 00 00 00
	00		 cmp	 DWORD PTR lmsndx, eax
  0354c	0f 8d ee 01 00
	00		 jge	 $LN130@the_real_p

; 2874 :         {
; 2875 :             /* Initialize the read buffer */
; 2876 :             if (!readoff || readoff >= MSG_SIZE) {

  03552	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR readoff$[rsp], 0
  0355a	74 0d		 je	 SHORT $LN437@the_real_p
  0355c	81 bc 24 a0 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR readoff$[rsp], 256 ; 00000100H
  03567	7c 22		 jl	 SHORT $LN436@the_real_p
$LN437@the_real_p:

; 2877 :                 memset (readbuf, SPACE, MSG_SIZE);

  03569	48 8d 84 24 90
	07 00 00	 lea	 rax, QWORD PTR readbuf$[rsp]
  03571	48 8b f8	 mov	 rdi, rax
  03574	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  03579	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  0357e	f3 aa		 rep stosb

; 2878 :                 readoff = 0;

  03580	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR readoff$[rsp], 0
$LN436@the_real_p:
$LN565@the_real_p:
$LN131@the_real_p:

; 2879 :             }
; 2880 : 
; 2881 :             /* Read message bytes and copy into read buffer
; 2882 :                until we either encounter a newline character
; 2883 :                or our buffer is completely filled with data. */
; 2884 :             while ( lmsndx < lmscnt && lmsndx < lmsmax )

  0358b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmscnt
  03591	39 05 00 00 00
	00		 cmp	 DWORD PTR lmsndx, eax
  03597	0f 8d ea 00 00
	00		 jge	 $LN132@the_real_p
  0359d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmsmax
  035a3	39 05 00 00 00
	00		 cmp	 DWORD PTR lmsndx, eax
  035a9	0f 8d d8 00 00
	00		 jge	 $LN132@the_real_p

; 2885 :             {
; 2886 :                 /* Read a byte from the message pipe */
; 2887 :                 c = *(lmsbuf + lmsndx); lmsndx++;

  035af	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR lmsndx
  035b6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR lmsbuf
  035bd	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  035c1	88 44 24 7c	 mov	 BYTE PTR c$[rsp], al
  035c5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR lmsndx
  035cb	ff c0		 inc	 eax
  035cd	89 05 00 00 00
	00		 mov	 DWORD PTR lmsndx, eax

; 2888 : 
; 2889 :                 /* Break to process received message
; 2890 :                    whenever a newline is encountered */
; 2891 :                 if (c == '\n' || c == '\r') {

  035d3	0f b6 44 24 7c	 movzx	 eax, BYTE PTR c$[rsp]
  035d8	83 f8 0a	 cmp	 eax, 10
  035db	74 0a		 je	 SHORT $LN439@the_real_p
  035dd	0f b6 44 24 7c	 movzx	 eax, BYTE PTR c$[rsp]
  035e2	83 f8 0d	 cmp	 eax, 13
  035e5	75 10		 jne	 SHORT $LN438@the_real_p
$LN439@the_real_p:

; 2892 :                     readoff = 0;    /* (for next time) */

  035e7	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR readoff$[rsp], 0

; 2893 :                     break;

  035f2	e9 90 00 00 00	 jmp	 $LN132@the_real_p
$LN438@the_real_p:

; 2894 :                 }
; 2895 : 
; 2896 :                 /* Handle tab character */
; 2897 :                 if (c == '\t') {

  035f7	0f b6 44 24 7c	 movzx	 eax, BYTE PTR c$[rsp]
  035fc	83 f8 09	 cmp	 eax, 9
  035ff	75 38		 jne	 SHORT $LN440@the_real_p

; 2898 :                     readoff += 8;

  03601	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR readoff$[rsp]
  03608	83 c0 08	 add	 eax, 8
  0360b	89 84 24 a0 00
	00 00		 mov	 DWORD PTR readoff$[rsp], eax

; 2899 :                     readoff &= 0xFFFFFFF8;

  03612	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR readoff$[rsp]
  03619	83 e0 f8	 and	 eax, -8			; fffffff8H
  0361c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR readoff$[rsp], eax

; 2900 :                     /* Messages longer than one screen line will
; 2901 :                        be continued on the very next screen line */
; 2902 :                     if (readoff >= MSG_SIZE)

  03623	81 bc 24 a0 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR readoff$[rsp], 256 ; 00000100H
  0362e	7c 04		 jl	 SHORT $LN441@the_real_p

; 2903 :                         break;

  03630	eb 55		 jmp	 SHORT $LN132@the_real_p
  03632	eb 05		 jmp	 SHORT $LN442@the_real_p
$LN441@the_real_p:

; 2904 :                     else continue;

  03634	e9 52 ff ff ff	 jmp	 $LN131@the_real_p
$LN442@the_real_p:
$LN440@the_real_p:

; 2905 :                 }
; 2906 : 
; 2907 :                 /* Eliminate non-displayable characters */
; 2908 :                 if (!isgraph(c)) c = SPACE;

  03639	0f b6 44 24 7c	 movzx	 eax, BYTE PTR c$[rsp]
  0363e	8b c8		 mov	 ecx, eax
  03640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isgraph
  03646	85 c0		 test	 eax, eax
  03648	75 05		 jne	 SHORT $LN443@the_real_p
  0364a	c6 44 24 7c 20	 mov	 BYTE PTR c$[rsp], 32	; 00000020H
$LN443@the_real_p:

; 2909 : 
; 2910 :                 /* Stuff byte into message processing buffer */
; 2911 :                 readbuf[readoff++] = c;

  0364f	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR readoff$[rsp]
  03657	0f b6 4c 24 7c	 movzx	 ecx, BYTE PTR c$[rsp]
  0365c	88 8c 04 90 07
	00 00		 mov	 BYTE PTR readbuf$[rsp+rax], cl
  03663	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR readoff$[rsp]
  0366a	ff c0		 inc	 eax
  0366c	89 84 24 a0 00
	00 00		 mov	 DWORD PTR readoff$[rsp], eax

; 2912 : 
; 2913 :                 /* Messages longer than one screen line will
; 2914 :                    be continued on the very next screen line */
; 2915 :                 if (readoff >= MSG_SIZE)

  03673	81 bc 24 a0 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR readoff$[rsp], 256 ; 00000100H
  0367e	7c 02		 jl	 SHORT $LN444@the_real_p

; 2916 :                     break;

  03680	eb 05		 jmp	 SHORT $LN132@the_real_p
$LN444@the_real_p:

; 2917 :             } /* end while ( lmsndx < lmscnt && lmsndx < lmsmax ) */

  03682	e9 04 ff ff ff	 jmp	 $LN565@the_real_p
$LN132@the_real_p:

; 2918 : 
; 2919 :             /* If we have a message to be displayed (or a complete
; 2920 :                part of one), then copy it to the circular buffer. */
; 2921 :             if (!readoff || readoff >= MSG_SIZE) {

  03687	83 bc 24 a0 00
	00 00 00	 cmp	 DWORD PTR readoff$[rsp], 0
  0368f	74 11		 je	 SHORT $LN446@the_real_p
  03691	81 bc 24 a0 00
	00 00 00 01 00
	00		 cmp	 DWORD PTR readoff$[rsp], 256 ; 00000100H
  0369c	0f 8c 99 00 00
	00		 jl	 $LN445@the_real_p
$LN446@the_real_p:

; 2922 : 
; 2923 :                 /* First-time here? */
; 2924 :                 if (curmsg == NULL) {

  036a2	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR curmsg, 0
  036aa	75 1e		 jne	 SHORT $LN447@the_real_p

; 2925 :                     curmsg = topmsg = msgbuf;

  036ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR msgbuf
  036b3	48 89 05 00 00
	00 00		 mov	 QWORD PTR topmsg, rax
  036ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  036c1	48 89 05 00 00
	00 00		 mov	 QWORD PTR curmsg, rax

; 2926 :                 } else {

  036c8	eb 54		 jmp	 SHORT $LN448@the_real_p
$LN447@the_real_p:

; 2927 :                     /* Perform autoscroll if needed */
; 2928 :                     if (is_currline_visible()) {

  036ca	e8 00 00 00 00	 call	 is_currline_visible
  036cf	85 c0		 test	 eax, eax
  036d1	74 20		 je	 SHORT $LN449@the_real_p
$LN133@the_real_p:

; 2929 :                         while (lines_remaining() < 1)

  036d3	e8 00 00 00 00	 call	 lines_remaining
  036d8	83 f8 01	 cmp	 eax, 1
  036db	7d 0c		 jge	 SHORT $LN134@the_real_p

; 2930 :                             scroll_down_lines(1);

  036dd	b9 01 00 00 00	 mov	 ecx, 1
  036e2	e8 00 00 00 00	 call	 scroll_down_lines
  036e7	eb ea		 jmp	 SHORT $LN133@the_real_p
$LN134@the_real_p:

; 2931 :                         /* Set the display update indicator */
; 2932 :                         redraw_msgs = 1;

  036e9	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_msgs, 1
$LN449@the_real_p:

; 2933 :                     }
; 2934 : 
; 2935 :                     /* Go on to next available msg buffer */
; 2936 :                     curmsg = curmsg->next;

  036f3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  036fa	48 8b 00	 mov	 rax, QWORD PTR [rax]
  036fd	48 89 05 00 00
	00 00		 mov	 QWORD PTR curmsg, rax

; 2937 : 
; 2938 :                     /* Updated wrapped indicator */
; 2939 :                     if (curmsg == msgbuf)

  03704	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR msgbuf
  0370b	48 39 05 00 00
	00 00		 cmp	 QWORD PTR curmsg, rax
  03712	75 0a		 jne	 SHORT $LN450@the_real_p

; 2940 :                         wrapped = 1;

  03714	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR wrapped, 1
$LN450@the_real_p:
$LN448@the_real_p:

; 2941 :                 }
; 2942 : 
; 2943 :                 /* Copy message into next available PANMSG slot */
; 2944 :                 memcpy( curmsg->msg, readbuf, MSG_SIZE );

  0371e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  03725	48 8d 8c 24 90
	07 00 00	 lea	 rcx, QWORD PTR readbuf$[rsp]
  0372d	48 8d 78 14	 lea	 rdi, QWORD PTR [rax+20]
  03731	48 8b f1	 mov	 rsi, rcx
  03734	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  03739	f3 a4		 rep movsb
$LN445@the_real_p:

; 2945 : 
; 2946 :             } /* end if (!readoff || readoff >= MSG_SIZE) */
; 2947 :         } /* end Read message bytes until newline... */

  0373b	e9 ee fd ff ff	 jmp	 $LN129@the_real_p
$LN130@the_real_p:

; 2948 : 
; 2949 :         /* Don't read or otherwise process any input
; 2950 :            once system shutdown has been initiated
; 2951 :         */
; 2952 :         if ( sysblk.shutdown )

  03740	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03747	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0374d	c1 e8 0b	 shr	 eax, 11
  03750	83 e0 01	 and	 eax, 1
  03753	85 c0		 test	 eax, eax
  03755	74 36		 je	 SHORT $LN451@the_real_p

; 2953 :         {
; 2954 :             if ( sysblk.shutfini ) break;

  03757	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0375e	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  03764	c1 e8 0c	 shr	 eax, 12
  03767	83 e0 01	 and	 eax, 1
  0376a	85 c0		 test	 eax, eax
  0376c	74 05		 je	 SHORT $LN452@the_real_p
  0376e	e9 01 13 00 00	 jmp	 $LN9@the_real_p
$LN452@the_real_p:

; 2955 :             /* wait for system to finish shutting down */
; 2956 :             usleep(10000);

  03773	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  03778	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_usleep

; 2957 :             lmsmax = INT_MAX;

  0377e	c7 05 00 00 00
	00 ff ff ff 7f	 mov	 DWORD PTR lmsmax, 2147483647 ; 7fffffffH

; 2958 :             goto FinishShutdown;

  03788	e9 21 fd ff ff	 jmp	 $FinishShutdown$569
$LN451@the_real_p:

; 2959 :         }
; 2960 : 
; 2961 :         /* =NP= : Reinit traditional panel if NP is down */
; 2962 :         if (NPDup == 0 && NPDinit == 1) {

  0378d	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  03794	75 3d		 jne	 SHORT $LN453@the_real_p
  03796	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDinit, 1
  0379d	75 34		 jne	 SHORT $LN453@the_real_p

; 2963 :             redraw_msgs = redraw_status = redraw_cmd = 1;

  0379f	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_cmd, 1
  037a9	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_cmd
  037af	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_status, eax
  037b5	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_status
  037bb	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_msgs, eax

; 2964 :             set_color (COLOR_DEFAULT_FG, COLOR_DEFAULT_BG);

  037c1	66 ba 11 00	 mov	 dx, 17
  037c5	66 b9 10 00	 mov	 cx, 16
  037c9	e8 00 00 00 00	 call	 set_color

; 2965 :             clr_screen ();

  037ce	e8 00 00 00 00	 call	 clr_screen
$LN453@the_real_p:

; 2966 :         }
; 2967 :         /* =END= */
; 2968 : 
; 2969 :         /* Obtain the PSW for target CPU */
; 2970 :         regs = panel_copy_regs( sysblk.pcpu );

  037d3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  037da	8b 88 54 13 00
	00		 mov	 ecx, DWORD PTR [rax+4948]
  037e0	e8 00 00 00 00	 call	 panel_copy_regs
  037e5	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR regs$[rsp], rax

; 2971 :         memset( curr_psw, 0, sizeof( curr_psw ));

  037ed	48 8d 84 24 b8
	02 00 00	 lea	 rax, QWORD PTR curr_psw$[rsp]
  037f5	48 8b f8	 mov	 rdi, rax
  037f8	33 c0		 xor	 eax, eax
  037fa	b9 10 00 00 00	 mov	 ecx, 16
  037ff	f3 aa		 rep stosb

; 2972 :         copy_psw( regs, curr_psw );

  03801	48 8d 94 24 b8
	02 00 00	 lea	 rdx, QWORD PTR curr_psw$[rsp]
  03809	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  03811	e8 00 00 00 00	 call	 copy_psw

; 2973 : 
; 2974 :         numcpu = 0;

  03816	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR numcpu$[rsp], 0

; 2975 :         for (i=0; i < sysblk.maxcpu; ++i )

  03821	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  03829	eb 0a		 jmp	 SHORT $LN137@the_real_p
$LN135@the_real_p:
  0382b	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0382f	ff c0		 inc	 eax
  03831	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN137@the_real_p:
  03835	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0383c	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  03842	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  03846	7d 29		 jge	 SHORT $LN136@the_real_p

; 2976 :             if (IS_CPU_ONLINE( i ))

  03848	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  0384d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  03854	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0385d	74 10		 je	 SHORT $LN454@the_real_p

; 2977 :                 ++numcpu;

  0385f	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR numcpu$[rsp]
  03866	ff c0		 inc	 eax
  03868	89 84 24 c4 00
	00 00		 mov	 DWORD PTR numcpu$[rsp], eax
$LN454@the_real_p:
  0386f	eb ba		 jmp	 SHORT $LN135@the_real_p
$LN136@the_real_p:

; 2978 : 
; 2979 :         /* Set the display update indicator
; 2980 :            if anything interesting happened.
; 2981 :         */
; 2982 :         if (0
; 2983 :             || memcmp( curr_psw, prev_psw, sizeof( curr_psw )) != 0
; 2984 :             || prev_cpupct    != regs->cpupct
; 2985 :             || prev_cpustate  != regs->cpustate
; 2986 :             || prev_instcount != sysblk.instcount
; 2987 :             || prev_mipsrate  != sysblk.mipsrate
; 2988 :             || prev_siosrate  != sysblk.siosrate
; 2989 : #if defined( OPTION_SHARED_DEVICES )
; 2990 :             || prev_shrdcount != sysblk.shrdcount

  03871	33 c0		 xor	 eax, eax
  03873	85 c0		 test	 eax, eax
  03875	0f 85 b0 00 00
	00		 jne	 $LN456@the_real_p
  0387b	41 b8 10 00 00
	00		 mov	 r8d, 16
  03881	48 8d 94 24 10
	03 00 00	 lea	 rdx, QWORD PTR prev_psw$[rsp]
  03889	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR curr_psw$[rsp]
  03891	e8 00 00 00 00	 call	 memcmp
  03896	85 c0		 test	 eax, eax
  03898	0f 85 8d 00 00
	00		 jne	 $LN456@the_real_p
  0389e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  038a6	8b 80 b0 07 00
	00		 mov	 eax, DWORD PTR [rax+1968]
  038ac	39 84 24 58 01
	00 00		 cmp	 DWORD PTR prev_cpupct$[rsp], eax
  038b3	75 76		 jne	 SHORT $LN456@the_real_p
  038b5	0f b6 84 24 b0
	00 00 00	 movzx	 eax, BYTE PTR prev_cpustate$[rsp]
  038bd	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  038c5	0f b6 49 60	 movzx	 ecx, BYTE PTR [rcx+96]
  038c9	3b c1		 cmp	 eax, ecx
  038cb	75 5e		 jne	 SHORT $LN456@the_real_p
  038cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  038d4	48 8b 80 80 14
	00 00		 mov	 rax, QWORD PTR [rax+5248]
  038db	48 39 84 24 b0
	01 00 00	 cmp	 QWORD PTR prev_instcount$[rsp], rax
  038e3	75 46		 jne	 SHORT $LN456@the_real_p
  038e5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  038ec	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  038f2	39 84 24 cc 00
	00 00		 cmp	 DWORD PTR prev_mipsrate$[rsp], eax
  038f9	75 30		 jne	 SHORT $LN456@the_real_p
  038fb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03902	8b 80 8c 14 00
	00		 mov	 eax, DWORD PTR [rax+5260]
  03908	39 84 24 0c 01
	00 00		 cmp	 DWORD PTR prev_siosrate$[rsp], eax
  0390f	75 1a		 jne	 SHORT $LN456@the_real_p
  03911	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03918	8b 80 b0 13 00
	00		 mov	 eax, DWORD PTR [rax+5040]
  0391e	39 84 24 2c 01
	00 00		 cmp	 DWORD PTR prev_shrdcount$[rsp], eax
  03925	0f 84 a1 00 00
	00		 je	 $LN455@the_real_p
$LN456@the_real_p:

; 2991 : #endif
; 2992 :         )
; 2993 :         {
; 2994 :             redraw_status = 1;

  0392b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 2995 :             memcpy( prev_psw, curr_psw, sizeof( prev_psw ));

  03935	48 8d 84 24 10
	03 00 00	 lea	 rax, QWORD PTR prev_psw$[rsp]
  0393d	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR curr_psw$[rsp]
  03945	48 8b f8	 mov	 rdi, rax
  03948	48 8b f1	 mov	 rsi, rcx
  0394b	b9 10 00 00 00	 mov	 ecx, 16
  03950	f3 a4		 rep movsb

; 2996 :             prev_cpupct    = regs->cpupct;

  03952	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0395a	8b 80 b0 07 00
	00		 mov	 eax, DWORD PTR [rax+1968]
  03960	89 84 24 58 01
	00 00		 mov	 DWORD PTR prev_cpupct$[rsp], eax

; 2997 :             prev_cpustate  = regs->cpustate;

  03967	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0396f	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  03973	88 84 24 b0 00
	00 00		 mov	 BYTE PTR prev_cpustate$[rsp], al

; 2998 :             prev_instcount = sysblk.instcount;

  0397a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03981	48 8b 80 80 14
	00 00		 mov	 rax, QWORD PTR [rax+5248]
  03988	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR prev_instcount$[rsp], rax

; 2999 :             prev_mipsrate  = sysblk.mipsrate;

  03990	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03997	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  0399d	89 84 24 cc 00
	00 00		 mov	 DWORD PTR prev_mipsrate$[rsp], eax

; 3000 :             prev_siosrate  = sysblk.siosrate;

  039a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  039ab	8b 80 8c 14 00
	00		 mov	 eax, DWORD PTR [rax+5260]
  039b1	89 84 24 0c 01
	00 00		 mov	 DWORD PTR prev_siosrate$[rsp], eax

; 3001 : #if defined( OPTION_SHARED_DEVICES )
; 3002 :             prev_shrdcount = sysblk.shrdcount;

  039b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  039bf	8b 80 b0 13 00
	00		 mov	 eax, DWORD PTR [rax+5040]
  039c5	89 84 24 2c 01
	00 00		 mov	 DWORD PTR prev_shrdcount$[rsp], eax
$LN455@the_real_p:

; 3003 : #endif
; 3004 :         }
; 3005 : 
; 3006 :         /* =NP= : Display the screen - traditional or NP */
; 3007 :         /*        Note: this is the only code block modified rather */
; 3008 :         /*        than inserted.  It makes the block of 3 ifs in the */
; 3009 :         /*        original code dependent on NPDup == 0, and inserts */
; 3010 :         /*        the NP display as an else after those ifs */
; 3011 : 
; 3012 :         if (NPDup == 0) {

  039cc	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  039d3	0f 85 8f 0f 00
	00		 jne	 $LN457@the_real_p

; 3013 :             int sev, fg_color, bg_color;
; 3014 :             /* Rewrite the screen if display update indicators are set */
; 3015 :             if (redraw_msgs && !npquiet)

  039d9	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_msgs, 0
  039e0	0f 84 0e 02 00
	00		 je	 $LN459@the_real_p
  039e6	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR npquiet, 0
  039ed	0f 85 01 02 00
	00		 jne	 $LN459@the_real_p

; 3016 :             {
; 3017 :                 /* Display messages in scrolling area */
; 3018 :                 PANMSG* p;
; 3019 : 
; 3020 :                 /* Save cursor location */
; 3021 :                 saved_cons_row = cur_cons_row;

  039f3	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  039fa	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_row, ax

; 3022 :                 saved_cons_col = cur_cons_col;

  03a01	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_col
  03a08	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_col, ax

; 3023 : 
; 3024 :                 i = 0;

  03a0f	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 3025 :                 /* Then draw current screen */
; 3026 :                 for (p=topmsg; i < (SCROLL_LINES + numkept) && (p != curmsg->next || p == topmsg); i++, p = p->next)

  03a17	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  03a1e	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR p$18[rsp], rax
  03a26	eb 1d		 jmp	 SHORT $LN140@the_real_p
$LN138@the_real_p:
  03a28	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03a2c	ff c0		 inc	 eax
  03a2e	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  03a32	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR p$18[rsp]
  03a3a	48 8b 00	 mov	 rax, QWORD PTR [rax]
  03a3d	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR p$18[rsp], rax
$LN140@the_real_p:
  03a45	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  03a4b	83 e8 02	 sub	 eax, 2
  03a4e	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR numkept
  03a54	03 05 00 00 00
	00		 add	 eax, DWORD PTR numkept
  03a5a	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  03a5e	0f 8d af 00 00
	00		 jge	 $LN139@the_real_p
  03a64	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curmsg
  03a6b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  03a6e	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR p$18[rsp], rax
  03a76	75 15		 jne	 SHORT $LN460@the_real_p
  03a78	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR topmsg
  03a7f	48 39 84 24 10
	01 00 00	 cmp	 QWORD PTR p$18[rsp], rax
  03a87	0f 85 86 00 00
	00		 jne	 $LN139@the_real_p
$LN460@the_real_p:

; 3027 :                 {
; 3028 :                     sev = msg_sev( p->msg );

  03a8d	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR p$18[rsp]
  03a95	48 83 c0 14	 add	 rax, 20
  03a99	48 8b c8	 mov	 rcx, rax
  03a9c	e8 00 00 00 00	 call	 msg_sev
  03aa1	89 84 24 30 01
	00 00		 mov	 DWORD PTR sev$21[rsp], eax

; 3029 : 
; 3030 :                     fg_color = fg_msgcolor( sev );

  03aa8	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR sev$21[rsp]
  03aaf	e8 00 00 00 00	 call	 fg_msgcolor
  03ab4	89 84 24 8c 01
	00 00		 mov	 DWORD PTR fg_color$26[rsp], eax

; 3031 :                     bg_color = bg_msgcolor( sev );

  03abb	8b 8c 24 30 01
	00 00		 mov	 ecx, DWORD PTR sev$21[rsp]
  03ac2	e8 00 00 00 00	 call	 bg_msgcolor
  03ac7	89 84 24 88 01
	00 00		 mov	 DWORD PTR bg_color$25[rsp], eax

; 3032 : 
; 3033 :                     set_pos( i+1, 1 );

  03ace	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03ad2	ff c0		 inc	 eax
  03ad4	66 ba 01 00	 mov	 dx, 1
  03ad8	0f b7 c8	 movzx	 ecx, ax
  03adb	e8 00 00 00 00	 call	 set_pos

; 3034 :                     set_color( fg_color, bg_color );

  03ae0	0f b7 94 24 88
	01 00 00	 movzx	 edx, WORD PTR bg_color$25[rsp]
  03ae8	0f b7 8c 24 8c
	01 00 00	 movzx	 ecx, WORD PTR fg_color$26[rsp]
  03af0	e8 00 00 00 00	 call	 set_color

; 3035 :                     write_text( p->msg, MSG_SIZE );

  03af5	48 8b 84 24 10
	01 00 00	 mov	 rax, QWORD PTR p$18[rsp]
  03afd	48 83 c0 14	 add	 rax, 20
  03b01	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  03b06	48 8b c8	 mov	 rcx, rax
  03b09	e8 00 00 00 00	 call	 write_text

; 3036 :                 }

  03b0e	e9 15 ff ff ff	 jmp	 $LN138@the_real_p
$LN139@the_real_p:

; 3037 : 
; 3038 :                 /* Pad remainder of screen with blank lines */
; 3039 :                 for (; i < (SCROLL_LINES + numkept); i++)

  03b13	eb 0a		 jmp	 SHORT $LN143@the_real_p
$LN141@the_real_p:
  03b15	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03b19	ff c0		 inc	 eax
  03b1b	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN143@the_real_p:
  03b1f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  03b25	83 e8 02	 sub	 eax, 2
  03b28	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR numkept
  03b2e	03 05 00 00 00
	00		 add	 eax, DWORD PTR numkept
  03b34	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  03b38	7d 2d		 jge	 SHORT $LN142@the_real_p

; 3040 :                 {
; 3041 :                     set_pos (i+1, 1);

  03b3a	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03b3e	ff c0		 inc	 eax
  03b40	66 ba 01 00	 mov	 dx, 1
  03b44	0f b7 c8	 movzx	 ecx, ax
  03b47	e8 00 00 00 00	 call	 set_pos

; 3042 :                     set_color (COLOR_DEFAULT_FG, COLOR_DEFAULT_BG);

  03b4c	66 ba 11 00	 mov	 dx, 17
  03b50	66 b9 10 00	 mov	 cx, 16
  03b54	e8 00 00 00 00	 call	 set_color

; 3043 :                     erase_to_eol( confp );

  03b59	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  03b60	e8 00 00 00 00	 call	 erase_to_eol

; 3044 :                 }

  03b65	eb ae		 jmp	 SHORT $LN141@the_real_p
$LN142@the_real_p:

; 3045 : 
; 3046 :                 /* Display the scroll indicators */
; 3047 :                 if (topmsg != oldest_msg())

  03b67	e8 00 00 00 00	 call	 oldest_msg
  03b6c	48 39 05 00 00
	00 00		 cmp	 QWORD PTR topmsg, rax
  03b73	74 29		 je	 SHORT $LN461@the_real_p

; 3048 :                 {
; 3049 :                     /* More messages precede top line */
; 3050 :                     set_pos (1, cons_cols);

  03b75	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  03b7c	66 b9 01 00	 mov	 cx, 1
  03b80	e8 00 00 00 00	 call	 set_pos

; 3051 :                     set_color (COLOR_DEFAULT_LIGHT, COLOR_DEFAULT_BG);

  03b85	66 ba 11 00	 mov	 dx, 17
  03b89	66 b9 12 00	 mov	 cx, 18
  03b8d	e8 00 00 00 00	 call	 set_color

; 3052 :                     draw_text ("+");

  03b92	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169715
  03b99	e8 00 00 00 00	 call	 draw_text
$LN461@the_real_p:

; 3053 :                 }
; 3054 :                 if (!is_currline_visible())

  03b9e	e8 00 00 00 00	 call	 is_currline_visible
  03ba3	85 c0		 test	 eax, eax
  03ba5	75 31		 jne	 SHORT $LN462@the_real_p

; 3055 :                 {
; 3056 :                     /* More messages follow bottom line */
; 3057 :                     set_pos (cons_rows-2, cons_cols);

  03ba7	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  03bad	83 e8 02	 sub	 eax, 2
  03bb0	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  03bb7	0f b7 c8	 movzx	 ecx, ax
  03bba	e8 00 00 00 00	 call	 set_pos

; 3058 :                     set_color (COLOR_DEFAULT_LIGHT, COLOR_DEFAULT_BG);

  03bbf	66 ba 11 00	 mov	 dx, 17
  03bc3	66 b9 12 00	 mov	 cx, 18
  03bc7	e8 00 00 00 00	 call	 set_color

; 3059 :                     draw_text ("V");

  03bcc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169717
  03bd3	e8 00 00 00 00	 call	 draw_text
$LN462@the_real_p:

; 3060 :                 }
; 3061 : 
; 3062 :                 /* restore cursor location */
; 3063 :                 cur_cons_row = saved_cons_row;

  03bd8	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_row
  03bdf	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax

; 3064 :                 cur_cons_col = saved_cons_col;

  03be6	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_col
  03bed	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN459@the_real_p:

; 3065 :             } /* end if(redraw_msgs) */
; 3066 : 
; 3067 :             if (redraw_cmd)

  03bf4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_cmd, 0
  03bfb	0f 84 54 01 00
	00		 je	 $LN463@the_real_p

; 3068 :             {
; 3069 :                 /* Save cursor location */
; 3070 :                 saved_cons_row = cur_cons_row;

  03c01	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  03c08	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_row, ax

; 3071 :                 saved_cons_col = cur_cons_col;

  03c0f	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_col
  03c16	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_col, ax

; 3072 : 
; 3073 :                 /* Display the command line */
; 3074 :                 set_pos (CMDLINE_ROW, 1);

  03c1d	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_rows
  03c23	ff c8		 dec	 eax
  03c25	66 ba 01 00	 mov	 dx, 1
  03c29	0f b7 c8	 movzx	 ecx, ax
  03c2c	e8 00 00 00 00	 call	 set_pos

; 3075 :                 set_color (COLOR_DEFAULT_LIGHT, COLOR_DEFAULT_BG);

  03c31	66 ba 11 00	 mov	 dx, 17
  03c35	66 b9 12 00	 mov	 cx, 18
  03c39	e8 00 00 00 00	 call	 set_color

; 3076 :                 draw_text( CMD_PREFIX_HERC );

  03c3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169719
  03c45	e8 00 00 00 00	 call	 draw_text

; 3077 :                 set_color (COLOR_DEFAULT_FG, COLOR_DEFAULT_BG);

  03c4a	66 ba 11 00	 mov	 dx, 17
  03c4e	66 b9 10 00	 mov	 cx, 16
  03c52	e8 00 00 00 00	 call	 set_color
$LN146@the_real_p:
$LN149@the_real_p:

; 3078 :                 PUTC_CMDLINE ();

  03c57	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdlen
  03c5d	39 05 00 00 00
	00		 cmp	 DWORD PTR cmdcol, eax
  03c63	7e 5c		 jle	 SHORT $LN464@the_real_p
$LN152@the_real_p:
  03c65	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169721
  03c6c	41 b8 06 0c 00
	00		 mov	 r8d, 3078		; 00000c06H
  03c72	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169722
  03c79	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169723
  03c80	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  03c86	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03c8c	85 c0		 test	 eax, eax
  03c8e	74 20		 je	 SHORT $LN465@the_real_p
  03c90	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169725
  03c97	41 b8 06 0c 00
	00		 mov	 r8d, 3078		; 00000c06H
  03c9d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169726
  03ca4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169727
  03cab	e8 00 00 00 00	 call	 DebuggerTrace
$LN465@the_real_p:
  03cb0	33 c0		 xor	 eax, eax
  03cb2	85 c0		 test	 eax, eax
  03cb4	75 af		 jne	 SHORT $LN152@the_real_p
  03cb6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  03cbc	85 c0		 test	 eax, eax
  03cbe	74 01		 je	 SHORT $LN466@the_real_p
  03cc0	cc		 int	 3
$LN466@the_real_p:
$LN464@the_real_p:
  03cc1	33 c0		 xor	 eax, eax
  03cc3	85 c0		 test	 eax, eax
  03cc5	75 90		 jne	 SHORT $LN149@the_real_p
  03cc7	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  03ccf	eb 0a		 jmp	 SHORT $LN155@the_real_p
$LN153@the_real_p:
  03cd1	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03cd5	ff c0		 inc	 eax
  03cd7	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN155@the_real_p:
  03cdb	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03cdf	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdcol
  03ce5	03 c8		 add	 ecx, eax
  03ce7	8b c1		 mov	 eax, ecx
  03ce9	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cmdlen
  03cef	7d 30		 jge	 SHORT $LN154@the_real_p
  03cf1	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cmdcols
  03cf7	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  03cfb	7d 24		 jge	 SHORT $LN154@the_real_p
  03cfd	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03d01	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cmdcol
  03d07	03 c8		 add	 ecx, eax
  03d09	8b c1		 mov	 eax, ecx
  03d0b	48 98		 cdqe
  03d0d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdline
  03d14	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  03d18	8b c8		 mov	 ecx, eax
  03d1a	e8 00 00 00 00	 call	 draw_char
  03d1f	eb b0		 jmp	 SHORT $LN153@the_real_p
$LN154@the_real_p:
  03d21	33 c0		 xor	 eax, eax
  03d23	85 c0		 test	 eax, eax
  03d25	0f 85 2c ff ff
	ff		 jne	 $LN146@the_real_p

; 3079 :                 fill_text (' ',cons_cols);

  03d2b	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cons_cols
  03d32	b1 20		 mov	 cl, 32			; 00000020H
  03d34	e8 00 00 00 00	 call	 fill_text

; 3080 : 
; 3081 :                 /* restore cursor location */
; 3082 :                 cur_cons_row = saved_cons_row;

  03d39	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_row
  03d40	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax

; 3083 :                 cur_cons_col = saved_cons_col;

  03d47	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_col
  03d4e	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN463@the_real_p:

; 3084 :             } /* end if(redraw_cmd) */
; 3085 : 
; 3086 :             /* Determine if redraw required for CPU or architecture
; 3087 :              * change.
; 3088 :              */
; 3089 :             if (0
; 3090 :                 || (sysblk.pcpu != prev_pcpu && (regs = sysblk.regs[ sysblk.pcpu ]) != NULL)
; 3091 :                 || ((regs = sysblk.regs[ prev_pcpu ]) != NULL && regs->arch_mode != prev_arch_mode)

  03d55	33 c0		 xor	 eax, eax
  03d57	85 c0		 test	 eax, eax
  03d59	0f 85 84 00 00
	00		 jne	 $LN468@the_real_p
  03d5f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03d66	8b 8c 24 00 01
	00 00		 mov	 ecx, DWORD PTR prev_pcpu$[rsp]
  03d6d	39 88 54 13 00
	00		 cmp	 DWORD PTR [rax+4948], ecx
  03d73	74 30		 je	 SHORT $LN469@the_real_p
  03d75	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03d7c	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  03d83	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  03d8a	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  03d92	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR regs$[rsp], rax
  03d9a	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR regs$[rsp], 0
  03da3	75 3e		 jne	 SHORT $LN468@the_real_p
$LN469@the_real_p:
  03da5	48 63 84 24 00
	01 00 00	 movsxd	 rax, DWORD PTR prev_pcpu$[rsp]
  03dad	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  03db4	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  03dbc	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR regs$[rsp], rax
  03dc4	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR regs$[rsp], 0
  03dcd	74 44		 je	 SHORT $LN467@the_real_p
  03dcf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  03dd7	8b 8c 24 34 01
	00 00		 mov	 ecx, DWORD PTR prev_arch_mode$[rsp]
  03dde	39 48 64	 cmp	 DWORD PTR [rax+100], ecx
  03de1	74 30		 je	 SHORT $LN467@the_real_p
$LN468@the_real_p:

; 3092 :             )
; 3093 :             {
; 3094 :                 redraw_status = 1;

  03de3	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 3095 :                 prev_pcpu = sysblk.pcpu;

  03ded	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03df4	8b 80 54 13 00
	00		 mov	 eax, DWORD PTR [rax+4948]
  03dfa	89 84 24 00 01
	00 00		 mov	 DWORD PTR prev_pcpu$[rsp], eax

; 3096 :                 prev_arch_mode = regs->arch_mode;

  03e01	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  03e09	8b 40 64	 mov	 eax, DWORD PTR [rax+100]
  03e0c	89 84 24 34 01
	00 00		 mov	 DWORD PTR prev_arch_mode$[rsp], eax
$LN467@the_real_p:

; 3097 :             }
; 3098 : 
; 3099 :             if (redraw_status && !npquiet)

  03e13	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_status, 0
  03e1a	0f 84 68 0a 00
	00		 je	 $LN470@the_real_p
  03e20	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR npquiet, 0
  03e27	0f 85 5b 0a 00
	00		 jne	 $LN470@the_real_p

; 3100 :             {
; 3101 :                 char ibuf[64];      /* Rate buffer */
; 3102 :                 {
; 3103 :                     int cnt_disabled = 0;

  03e2d	c7 84 24 f8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cnt_disabled$15[rsp], 0

; 3104 :                     int cnt_stopped  = 0;

  03e38	c7 84 24 f4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR cnt_stopped$14[rsp], 0

; 3105 :                     int cnt_online = 0;

  03e43	c7 84 24 04 01
	00 00 00 00 00
	00		 mov	 DWORD PTR cnt_online$16[rsp], 0

; 3106 :                     char   *state;
; 3107 :                     for ( i = 0; i < sysblk.maxcpu; i++ )

  03e4e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  03e56	eb 0a		 jmp	 SHORT $LN158@the_real_p
$LN156@the_real_p:
  03e58	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  03e5c	ff c0		 inc	 eax
  03e5e	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN158@the_real_p:
  03e62	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03e69	8b 80 00 01 00
	00		 mov	 eax, DWORD PTR [rax+256]
  03e6f	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  03e73	0f 8d ac 00 00
	00		 jge	 $LN157@the_real_p

; 3108 :                     {
; 3109 :                         if ( IS_CPU_ONLINE(i) )

  03e79	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  03e7e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  03e85	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  03e8e	0f 84 8c 00 00
	00		 je	 $LN471@the_real_p

; 3110 :                         {
; 3111 :                             cnt_online++;

  03e94	8b 84 24 04 01
	00 00		 mov	 eax, DWORD PTR cnt_online$16[rsp]
  03e9b	ff c0		 inc	 eax
  03e9d	89 84 24 04 01
	00 00		 mov	 DWORD PTR cnt_online$16[rsp], eax

; 3112 :                             if ( sysblk.regs[i]->cpustate != CPUSTATE_STARTED )

  03ea4	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  03ea9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  03eb0	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  03eb8	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  03ebc	83 f8 01	 cmp	 eax, 1
  03ebf	74 10		 je	 SHORT $LN472@the_real_p

; 3113 :                                 cnt_stopped++;

  03ec1	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR cnt_stopped$14[rsp]
  03ec8	ff c0		 inc	 eax
  03eca	89 84 24 f4 00
	00 00		 mov	 DWORD PTR cnt_stopped$14[rsp], eax
$LN472@the_real_p:

; 3114 :                             if ( WAITSTATE(&sysblk.regs[i]->psw) &&

  03ed1	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  03ed6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  03edd	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  03ee5	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  03ee9	83 e0 02	 and	 eax, 2
  03eec	85 c0		 test	 eax, eax
  03eee	74 30		 je	 SHORT $LN473@the_real_p
  03ef0	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  03ef5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  03efc	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  03f04	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  03f07	25 f0 ff 00 5f	 and	 eax, 1593901040		; 5f00fff0H
  03f0c	85 c0		 test	 eax, eax
  03f0e	75 10		 jne	 SHORT $LN473@the_real_p

; 3115 :                                  IS_IC_DISABLED_WAIT_PSW( sysblk.regs[i] ) )
; 3116 :                                 cnt_disabled++;

  03f10	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR cnt_disabled$15[rsp]
  03f17	ff c0		 inc	 eax
  03f19	89 84 24 f8 00
	00 00		 mov	 DWORD PTR cnt_disabled$15[rsp], eax
$LN473@the_real_p:
$LN471@the_real_p:

; 3117 :                         }
; 3118 :                     }

  03f20	e9 33 ff ff ff	 jmp	 $LN156@the_real_p
$LN157@the_real_p:

; 3119 :                     state = "RED";

  03f25	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169736
  03f2c	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR state$28[rsp], rax

; 3120 : 
; 3121 :                     if ( cnt_online > cnt_stopped && cnt_disabled == 0 )

  03f34	8b 84 24 f4 00
	00 00		 mov	 eax, DWORD PTR cnt_stopped$14[rsp]
  03f3b	39 84 24 04 01
	00 00		 cmp	 DWORD PTR cnt_online$16[rsp], eax
  03f42	7e 19		 jle	 SHORT $LN474@the_real_p
  03f44	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR cnt_disabled$15[rsp], 0
  03f4c	75 0f		 jne	 SHORT $LN474@the_real_p

; 3122 :                         state = "AMBER";

  03f4e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169738
  03f55	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR state$28[rsp], rax
$LN474@the_real_p:

; 3123 : 
; 3124 :                     if (0
; 3125 :                         || ( sysblk.hicpu && (cnt_stopped == 0 && cnt_disabled == 0))
; 3126 : #if defined( OPTION_SHARED_DEVICES )
; 3127 :                         || (!sysblk.hicpu && (sysblk.shrdport))

  03f5d	33 c0		 xor	 eax, eax
  03f5f	85 c0		 test	 eax, eax
  03f61	75 46		 jne	 SHORT $LN476@the_real_p
  03f63	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03f6a	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  03f71	74 14		 je	 SHORT $LN477@the_real_p
  03f73	83 bc 24 f4 00
	00 00 00	 cmp	 DWORD PTR cnt_stopped$14[rsp], 0
  03f7b	75 0a		 jne	 SHORT $LN478@the_real_p
  03f7d	83 bc 24 f8 00
	00 00 00	 cmp	 DWORD PTR cnt_disabled$15[rsp], 0
  03f85	74 22		 je	 SHORT $LN476@the_real_p
$LN478@the_real_p:
$LN477@the_real_p:
  03f87	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03f8e	83 b8 08 01 00
	00 00		 cmp	 DWORD PTR [rax+264], 0
  03f95	75 21		 jne	 SHORT $LN475@the_real_p
  03f97	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  03f9e	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  03fa5	85 c0		 test	 eax, eax
  03fa7	74 0f		 je	 SHORT $LN475@the_real_p
$LN476@the_real_p:

; 3128 : #endif
; 3129 :                     )
; 3130 :                         state = "GREEN";

  03fa9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169743
  03fb0	48 89 84 24 a8
	01 00 00	 mov	 QWORD PTR state$28[rsp], rax
$LN475@the_real_p:

; 3131 :                     set_console_title(state);

  03fb8	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR state$28[rsp]
  03fc0	e8 00 00 00 00	 call	 set_console_title

; 3132 :                 }
; 3133 : 
; 3134 :                 /* Save cursor location */
; 3135 :                 saved_cons_row = cur_cons_row;

  03fc5	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_row
  03fcc	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_row, ax

; 3136 :                 saved_cons_col = cur_cons_col;

  03fd3	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR cur_cons_col
  03fda	66 89 05 00 00
	00 00		 mov	 WORD PTR saved_cons_col, ax

; 3137 : 
; 3138 :                 memset (buf, ' ', cons_cols);

  03fe1	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR cons_cols
  03fe8	48 89 84 24 38
	02 00 00	 mov	 QWORD PTR tv1943[rsp], rax
  03ff0	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  03ff8	48 8b f9	 mov	 rdi, rcx
  03ffb	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  04000	48 8b 8c 24 38
	02 00 00	 mov	 rcx, QWORD PTR tv1943[rsp]
  04008	f3 aa		 rep stosb

; 3139 :                 len = MSGBUF ( buf, "%s%02X ",

  0400a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04011	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  04018	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0401f	0f b6 8c 01 48
	0b 00 00	 movzx	 ecx, BYTE PTR [rcx+rax+2888]
  04027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptyp2short
  0402d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  04034	8b 89 54 13 00
	00		 mov	 ecx, DWORD PTR [rcx+4948]
  0403a	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  0403e	4c 8b c8	 mov	 r9, rax
  04041	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169744
  04048	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0404d	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  04055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  0405b	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 3140 :                     PTYPSTR(sysblk.pcpu), sysblk.pcpu ) ;
; 3141 :                 if (IS_CPU_ONLINE(sysblk.pcpu))

  0405f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04066	48 63 80 54 13
	00 00		 movsxd	 rax, DWORD PTR [rax+4948]
  0406d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  04074	48 83 bc c1 98
	0b 00 00 00	 cmp	 QWORD PTR [rcx+rax*8+2968], 0
  0407d	0f 84 78 03 00
	00		 je	 $LN479@the_real_p

; 3142 :                 {
; 3143 :                     len += idx_snprintf( len, buf, sizeof(buf), "PSW=%8.8X%8.8X ",

  04083	48 8d 84 24 bc
	02 00 00	 lea	 rax, QWORD PTR curr_psw$[rsp+4]
  0408b	48 8b c8	 mov	 rcx, rax
  0408e	e8 00 00 00 00	 call	 fetch_fw_noswap
  04093	8b c8		 mov	 ecx, eax
  04095	e8 00 00 00 00	 call	 _byteswap_ulong
  0409a	89 84 24 90 01
	00 00		 mov	 DWORD PTR tv1967[rsp], eax
  040a1	48 8d 8c 24 b8
	02 00 00	 lea	 rcx, QWORD PTR curr_psw$[rsp]
  040a9	e8 00 00 00 00	 call	 fetch_fw_noswap
  040ae	8b c8		 mov	 ecx, eax
  040b0	e8 00 00 00 00	 call	 _byteswap_ulong
  040b5	8b 8c 24 90 01
	00 00		 mov	 ecx, DWORD PTR tv1967[rsp]
  040bc	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  040c0	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  040c4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169747
  040cb	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  040d1	48 8d 94 24 90
	03 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  040d9	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  040dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  040e3	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  040e7	03 c8		 add	 ecx, eax
  040e9	8b c1		 mov	 eax, ecx
  040eb	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 3144 :                                    fetch_fw( curr_psw ), fetch_fw( curr_psw + 4 ));
; 3145 :                     if (regs->arch_mode == ARCH_900_IDX)

  040ef	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  040f7	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  040fb	75 4a		 jne	 SHORT $LN481@the_real_p

; 3146 :                         len += idx_snprintf( len, buf, sizeof(buf), "%16.16"PRIX64" ",

  040fd	48 8d 84 24 c0
	02 00 00	 lea	 rax, QWORD PTR curr_psw$[rsp+8]
  04105	48 8b c8	 mov	 rcx, rax
  04108	e8 00 00 00 00	 call	 fetch_dw_noswap
  0410d	48 8b c8	 mov	 rcx, rax
  04110	e8 00 00 00 00	 call	 _byteswap_uint64
  04115	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0411a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169750
  04121	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  04127	48 8d 94 24 90
	03 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0412f	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  04133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  04139	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  0413d	03 c8		 add	 ecx, eax
  0413f	8b c1		 mov	 eax, ecx
  04141	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
  04145	eb 62		 jmp	 SHORT $LN482@the_real_p
$LN481@the_real_p:

; 3147 :                                         fetch_dw( curr_psw + 8 ));
; 3148 : #if defined(_FEATURE_SIE)
; 3149 :                     else
; 3150 :                         if( SIE_MODE(regs) )

  04147	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  0414f	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  04155	d1 e8		 shr	 eax, 1
  04157	83 e0 01	 and	 eax, 1
  0415a	85 c0		 test	 eax, eax
  0415c	74 4b		 je	 SHORT $LN483@the_real_p

; 3151 :                         {
; 3152 :                             for(i = 0;i < 16;i++)

  0415e	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  04166	eb 0a		 jmp	 SHORT $LN161@the_real_p
$LN159@the_real_p:
  04168	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0416c	ff c0		 inc	 eax
  0416e	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN161@the_real_p:
  04172	83 7c 24 70 10	 cmp	 DWORD PTR i$[rsp], 16
  04177	7d 19		 jge	 SHORT $LN160@the_real_p

; 3153 :                                 buf[len++] = '-';

  04179	48 63 44 24 78	 movsxd	 rax, DWORD PTR len$[rsp]
  0417e	c6 84 04 90 03
	00 00 2d	 mov	 BYTE PTR buf$[rsp+rax], 45 ; 0000002dH
  04186	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  0418a	ff c0		 inc	 eax
  0418c	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
  04190	eb d6		 jmp	 SHORT $LN159@the_real_p
$LN160@the_real_p:

; 3154 :                             buf[len++] = ' ';

  04192	48 63 44 24 78	 movsxd	 rax, DWORD PTR len$[rsp]
  04197	c6 84 04 90 03
	00 00 20	 mov	 BYTE PTR buf$[rsp+rax], 32 ; 00000020H
  0419f	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  041a3	ff c0		 inc	 eax
  041a5	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
$LN483@the_real_p:
$LN482@the_real_p:

; 3155 :                         }
; 3156 : #endif /*defined(_FEATURE_SIE)*/
; 3157 :                     len += idx_snprintf( len, buf, sizeof(buf), "%2d%c%c%c%c%c%c%c%c",

  041a9	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  041b1	83 78 64 02	 cmp	 DWORD PTR [rax+100], 2
  041b5	75 0d		 jne	 SHORT $LN539@the_real_p
  041b7	c7 84 24 3c 01
	00 00 5a 00 00
	00		 mov	 DWORD PTR tv2014[rsp], 90 ; 0000005aH
  041c2	eb 0b		 jmp	 SHORT $LN540@the_real_p
$LN539@the_real_p:
  041c4	c7 84 24 3c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2014[rsp], 46 ; 0000002eH
$LN540@the_real_p:
  041cf	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  041d7	8b 80 c8 08 00
	00		 mov	 eax, DWORD PTR [rax+2248]
  041dd	d1 e8		 shr	 eax, 1
  041df	83 e0 01	 and	 eax, 1
  041e2	85 c0		 test	 eax, eax
  041e4	74 0d		 je	 SHORT $LN541@the_real_p
  041e6	c7 84 24 40 01
	00 00 53 00 00
	00		 mov	 DWORD PTR tv2020[rsp], 83 ; 00000053H
  041f1	eb 0b		 jmp	 SHORT $LN542@the_real_p
$LN541@the_real_p:
  041f3	c7 84 24 40 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2020[rsp], 46 ; 0000002eH
$LN542@the_real_p:
  041fe	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  04206	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  0420a	83 e0 01	 and	 eax, 1
  0420d	85 c0		 test	 eax, eax
  0420f	74 0d		 je	 SHORT $LN543@the_real_p
  04211	c7 84 24 44 01
	00 00 50 00 00
	00		 mov	 DWORD PTR tv2026[rsp], 80 ; 00000050H
  0421c	eb 0b		 jmp	 SHORT $LN544@the_real_p
$LN543@the_real_p:
  0421e	c7 84 24 44 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2026[rsp], 46 ; 0000002eH
$LN544@the_real_p:
  04229	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  04231	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  04237	c1 e8 05	 shr	 eax, 5
  0423a	83 e0 01	 and	 eax, 1
  0423d	85 c0		 test	 eax, eax
  0423f	74 0d		 je	 SHORT $LN545@the_real_p
  04241	c7 84 24 48 01
	00 00 43 00 00
	00		 mov	 DWORD PTR tv2032[rsp], 67 ; 00000043H
  0424c	eb 0b		 jmp	 SHORT $LN546@the_real_p
$LN545@the_real_p:
  0424e	c7 84 24 48 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2032[rsp], 46 ; 0000002eH
$LN546@the_real_p:
  04259	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  04261	8b 80 28 07 00
	00		 mov	 eax, DWORD PTR [rax+1832]
  04267	c1 e8 0c	 shr	 eax, 12
  0426a	83 e0 01	 and	 eax, 1
  0426d	85 c0		 test	 eax, eax
  0426f	74 0d		 je	 SHORT $LN547@the_real_p
  04271	c7 84 24 4c 01
	00 00 4c 00 00
	00		 mov	 DWORD PTR tv2038[rsp], 76 ; 0000004cH
  0427c	eb 0b		 jmp	 SHORT $LN548@the_real_p
$LN547@the_real_p:
  0427e	c7 84 24 4c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2038[rsp], 46 ; 0000002eH
$LN548@the_real_p:
  04289	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  04291	0f b6 40 7a	 movzx	 eax, BYTE PTR [rax+122]
  04295	83 e0 02	 and	 eax, 2
  04298	85 c0		 test	 eax, eax
  0429a	74 0d		 je	 SHORT $LN549@the_real_p
  0429c	c7 84 24 50 01
	00 00 57 00 00
	00		 mov	 DWORD PTR tv2044[rsp], 87 ; 00000057H
  042a7	eb 0b		 jmp	 SHORT $LN550@the_real_p
$LN549@the_real_p:
  042a9	c7 84 24 50 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2044[rsp], 46 ; 0000002eH
$LN550@the_real_p:
  042b4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  042bb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  042c1	c1 e8 0a	 shr	 eax, 10
  042c4	83 e0 01	 and	 eax, 1
  042c7	85 c0		 test	 eax, eax
  042c9	74 0d		 je	 SHORT $LN551@the_real_p
  042cb	c7 84 24 54 01
	00 00 54 00 00
	00		 mov	 DWORD PTR tv2050[rsp], 84 ; 00000054H
  042d6	eb 0b		 jmp	 SHORT $LN552@the_real_p
$LN551@the_real_p:
  042d8	c7 84 24 54 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2050[rsp], 46 ; 0000002eH
$LN552@the_real_p:
  042e3	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  042eb	0f b6 40 60	 movzx	 eax, BYTE PTR [rax+96]
  042ef	83 f8 03	 cmp	 eax, 3
  042f2	75 0d		 jne	 SHORT $LN553@the_real_p
  042f4	c7 84 24 6c 01
	00 00 4d 00 00
	00		 mov	 DWORD PTR tv2055[rsp], 77 ; 0000004dH
  042ff	eb 0b		 jmp	 SHORT $LN554@the_real_p
$LN553@the_real_p:
  04301	c7 84 24 6c 01
	00 00 2e 00 00
	00		 mov	 DWORD PTR tv2055[rsp], 46 ; 0000002eH
$LN554@the_real_p:
  0430c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  04314	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0431a	83 e0 01	 and	 eax, 1
  0431d	85 c0		 test	 eax, eax
  0431f	74 0d		 je	 SHORT $LN557@the_real_p
  04321	c7 84 24 5c 01
	00 00 40 00 00
	00		 mov	 DWORD PTR tv2065[rsp], 64 ; 00000040H
  0432c	eb 3d		 jmp	 SHORT $LN558@the_real_p
$LN557@the_real_p:
  0432e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR regs$[rsp]
  04336	8b 80 80 00 00
	00		 mov	 eax, DWORD PTR [rax+128]
  0433c	d1 e8		 shr	 eax, 1
  0433e	83 e0 01	 and	 eax, 1
  04341	85 c0		 test	 eax, eax
  04343	74 0d		 je	 SHORT $LN555@the_real_p
  04345	c7 84 24 38 01
	00 00 1f 00 00
	00		 mov	 DWORD PTR tv2063[rsp], 31
  04350	eb 0b		 jmp	 SHORT $LN556@the_real_p
$LN555@the_real_p:
  04352	c7 84 24 38 01
	00 00 18 00 00
	00		 mov	 DWORD PTR tv2063[rsp], 24
$LN556@the_real_p:
  0435d	8b 84 24 38 01
	00 00		 mov	 eax, DWORD PTR tv2063[rsp]
  04364	89 84 24 5c 01
	00 00		 mov	 DWORD PTR tv2065[rsp], eax
$LN558@the_real_p:
  0436b	8b 84 24 3c 01
	00 00		 mov	 eax, DWORD PTR tv2014[rsp]
  04372	89 44 24 60	 mov	 DWORD PTR [rsp+96], eax
  04376	8b 84 24 40 01
	00 00		 mov	 eax, DWORD PTR tv2020[rsp]
  0437d	89 44 24 58	 mov	 DWORD PTR [rsp+88], eax
  04381	8b 84 24 44 01
	00 00		 mov	 eax, DWORD PTR tv2026[rsp]
  04388	89 44 24 50	 mov	 DWORD PTR [rsp+80], eax
  0438c	8b 84 24 48 01
	00 00		 mov	 eax, DWORD PTR tv2032[rsp]
  04393	89 44 24 48	 mov	 DWORD PTR [rsp+72], eax
  04397	8b 84 24 4c 01
	00 00		 mov	 eax, DWORD PTR tv2038[rsp]
  0439e	89 44 24 40	 mov	 DWORD PTR [rsp+64], eax
  043a2	8b 84 24 50 01
	00 00		 mov	 eax, DWORD PTR tv2044[rsp]
  043a9	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  043ad	8b 84 24 54 01
	00 00		 mov	 eax, DWORD PTR tv2050[rsp]
  043b4	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  043b8	8b 84 24 6c 01
	00 00		 mov	 eax, DWORD PTR tv2055[rsp]
  043bf	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  043c3	8b 84 24 5c 01
	00 00		 mov	 eax, DWORD PTR tv2065[rsp]
  043ca	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  043ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169752
  043d5	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  043db	48 8d 94 24 90
	03 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  043e3	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  043e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  043ed	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  043f1	03 c8		 add	 ecx, eax
  043f3	8b c1		 mov	 eax, ecx
  043f5	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 3158 :                            regs->psw.amode64                  ? 64 :
; 3159 :                            regs->psw.amode                    ? 31 : 24,
; 3160 :                            regs->cpustate == CPUSTATE_STOPPED ? 'M' : '.',
; 3161 :                            sysblk.instbreak                   ? 'T' : '.',
; 3162 :                            WAITSTATE(&regs->psw)              ? 'W' : '.',
; 3163 :                            regs->loadstate                    ? 'L' : '.',
; 3164 :                            regs->checkstop                    ? 'C' : '.',
; 3165 :                            PROBSTATE(&regs->psw)              ? 'P' : '.',
; 3166 :                            SIE_MODE(regs)                     ? 'S' : '.',
; 3167 :                            regs->arch_mode == ARCH_900_IDX    ? 'Z' : '.');
; 3168 :                 }

  043f9	eb 37		 jmp	 SHORT $LN480@the_real_p
$LN479@the_real_p:

; 3169 :                 else
; 3170 :                     len += idx_snprintf( len, buf, sizeof(buf), "%s", "Offline");

  043fb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169753
  04402	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04407	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169754
  0440e	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  04414	48 8d 94 24 90
	03 00 00	 lea	 rdx, QWORD PTR buf$[rsp]
  0441c	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  04420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  04426	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  0442a	03 c8		 add	 ecx, eax
  0442c	8b c1		 mov	 eax, ecx
  0442e	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
$LN480@the_real_p:

; 3171 : 
; 3172 :                 memset( buf+len, ' ', sizeof( buf ) - len - 1 );

  04432	48 63 44 24 78	 movsxd	 rax, DWORD PTR len$[rsp]
  04437	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  0443c	48 2b c8	 sub	 rcx, rax
  0443f	48 8b c1	 mov	 rax, rcx
  04442	48 ff c8	 dec	 rax
  04445	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR tv2083[rsp], rax
  0444d	48 63 4c 24 78	 movsxd	 rcx, DWORD PTR len$[rsp]
  04452	48 8d 8c 0c 90
	03 00 00	 lea	 rcx, QWORD PTR buf$[rsp+rcx]
  0445a	48 8b f9	 mov	 rdi, rcx
  0445d	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  04462	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR tv2083[rsp]
  0446a	f3 aa		 rep stosb

; 3173 :                 buf[ sizeof( buf ) - 1 ] = 0;

  0446c	b8 01 00 00 00	 mov	 eax, 1
  04471	48 69 c0 ff 03
	00 00		 imul	 rax, rax, 1023		; 000003ffH
  04478	48 89 84 24 18
	02 00 00	 mov	 QWORD PTR $T39[rsp], rax
  04480	48 81 bc 24 18
	02 00 00 00 04
	00 00		 cmp	 QWORD PTR $T39[rsp], 1024 ; 00000400H
  0448c	73 02		 jae	 SHORT $LN559@the_real_p
  0448e	eb 05		 jmp	 SHORT $LN560@the_real_p
$LN559@the_real_p:
  04490	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN560@the_real_p:
  04495	48 8b 84 24 18
	02 00 00	 mov	 rax, QWORD PTR $T39[rsp]
  0449d	c6 84 04 90 03
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 3174 :                 len++;

  044a5	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  044a9	ff c0		 inc	 eax
  044ab	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax

; 3175 : 
; 3176 :                 /* Bottom line right corner can be when there is space:
; 3177 :                  * ""
; 3178 :                  * "instcnt <string>"
; 3179 :                  * "instcnt <string>; mips nnnnn"
; 3180 :                  * nnnnn can be nnnnn, nnn.n, nn.nn or n.nnn
; 3181 :                  * "instcnt <string>; mips nnnnn; IO/s nnnnnn"
; 3182 :                  * "IO/s nnnnnn"
; 3183 :                  */
; 3184 :                 i = 0;

  044af	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0

; 3185 :                 if (numcpu)

  044b7	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR numcpu$[rsp], 0
  044bf	0f 84 01 02 00
	00		 je	 $LN484@the_real_p

; 3186 :                 {
; 3187 :                     U32 mipsrate = prev_mipsrate / 1000000;

  044c5	33 d2		 xor	 edx, edx
  044c7	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR prev_mipsrate$[rsp]
  044ce	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  044d3	f7 f1		 div	 ecx
  044d5	89 84 24 d0 00
	00 00		 mov	 DWORD PTR mipsrate$9[rsp], eax

; 3188 : 
; 3189 :                     /* Format instruction count */
; 3190 :                     i = MSGBUF(ibuf,

  044dc	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR prev_instcount$[rsp]
  044e4	e8 00 00 00 00	 call	 format_int
  044e9	4c 8b c8	 mov	 r9, rax
  044ec	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169756
  044f3	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  044f8	48 8d 8c 24 d0
	02 00 00	 lea	 rcx, QWORD PTR ibuf$43[rsp]
  04500	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  04506	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax

; 3191 :                                  "instcnt %s",
; 3192 :                                  format_int( prev_instcount ));
; 3193 : 
; 3194 :                     if ((len + i + 12) < cons_cols)

  0450a	8b 44 24 78	 mov	 eax, DWORD PTR len$[rsp]
  0450e	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  04512	8d 44 08 0c	 lea	 eax, DWORD PTR [rax+rcx+12]
  04516	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  0451c	0f 8d a4 01 00
	00		 jge	 $LN485@the_real_p

; 3195 :                     {
; 3196 :                         if (mipsrate > 999)

  04522	81 bc 24 d0 00
	00 00 e7 03 00
	00		 cmp	 DWORD PTR mipsrate$9[rsp], 999 ; 000003e7H
  0452d	76 76		 jbe	 SHORT $LN486@the_real_p

; 3197 :                             i += idx_snprintf( i, ibuf, sizeof(ibuf),

  0452f	33 d2		 xor	 edx, edx
  04531	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR prev_mipsrate$[rsp]
  04538	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  0453d	f7 f1		 div	 ecx
  0453f	8b c2		 mov	 eax, edx
  04541	05 20 a1 07 00	 add	 eax, 500000		; 0007a120H
  04546	33 d2		 xor	 edx, edx
  04548	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0454d	f7 f1		 div	 ecx
  0454f	89 84 24 94 01
	00 00		 mov	 DWORD PTR tv2108[rsp], eax
  04556	33 d2		 xor	 edx, edx
  04558	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR prev_mipsrate$[rsp]
  0455f	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  04564	f7 f1		 div	 ecx
  04566	8b 8c 24 94 01
	00 00		 mov	 ecx, DWORD PTR tv2108[rsp]
  0456d	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  04571	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  04575	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169760
  0457c	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  04582	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR ibuf$43[rsp]
  0458a	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  0458e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  04594	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  04598	03 c8		 add	 ecx, eax
  0459a	8b c1		 mov	 eax, ecx
  0459c	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  045a0	e9 21 01 00 00	 jmp	 $LN487@the_real_p
$LN486@the_real_p:

; 3198 :                                           "; mips %1d,%03d",
; 3199 :                                           prev_mipsrate / 1000000000,
; 3200 :                                           ((prev_mipsrate % 1000000000) +
; 3201 :                                             500000) / 1000000);
; 3202 :                         else
; 3203 :                         {
; 3204 :                             U32 mipsfrac = prev_mipsrate % 1000000;

  045a5	33 d2		 xor	 edx, edx
  045a7	8b 84 24 cc 00
	00 00		 mov	 eax, DWORD PTR prev_mipsrate$[rsp]
  045ae	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  045b3	f7 f1		 div	 ecx
  045b5	8b c2		 mov	 eax, edx
  045b7	89 84 24 08 01
	00 00		 mov	 DWORD PTR mipsfrac$17[rsp], eax

; 3205 : 
; 3206 :                             if (mipsrate > 99)

  045be	83 bc 24 d0 00
	00 00 63	 cmp	 DWORD PTR mipsrate$9[rsp], 99 ; 00000063H
  045c6	76 54		 jbe	 SHORT $LN488@the_real_p

; 3207 :                                 i += idx_snprintf( i, ibuf, sizeof(ibuf),

  045c8	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR mipsfrac$17[rsp]
  045cf	05 50 c3 00 00	 add	 eax, 50000		; 0000c350H
  045d4	33 d2		 xor	 edx, edx
  045d6	b9 a0 86 01 00	 mov	 ecx, 100000		; 000186a0H
  045db	f7 f1		 div	 ecx
  045dd	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  045e1	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR mipsrate$9[rsp]
  045e8	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  045ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169763
  045f3	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  045f9	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR ibuf$43[rsp]
  04601	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  04605	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  0460b	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  0460f	03 c8		 add	 ecx, eax
  04611	8b c1		 mov	 eax, ecx
  04613	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  04617	e9 aa 00 00 00	 jmp	 $LN489@the_real_p
$LN488@the_real_p:

; 3208 :                                               "; mips %3d.%01d",
; 3209 :                                               mipsrate,
; 3210 :                                               (mipsfrac + 50000) / 100000);
; 3211 :                             else if (mipsrate > 9)

  0461c	83 bc 24 d0 00
	00 00 09	 cmp	 DWORD PTR mipsrate$9[rsp], 9
  04624	76 51		 jbe	 SHORT $LN490@the_real_p

; 3212 :                                 i += idx_snprintf( i, ibuf, sizeof(ibuf),

  04626	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR mipsfrac$17[rsp]
  0462d	05 88 13 00 00	 add	 eax, 5000		; 00001388H
  04632	33 d2		 xor	 edx, edx
  04634	b9 10 27 00 00	 mov	 ecx, 10000		; 00002710H
  04639	f7 f1		 div	 ecx
  0463b	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0463f	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR mipsrate$9[rsp]
  04646	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0464a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169766
  04651	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  04657	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR ibuf$43[rsp]
  0465f	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  04663	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  04669	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  0466d	03 c8		 add	 ecx, eax
  0466f	8b c1		 mov	 eax, ecx
  04671	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  04675	eb 4f		 jmp	 SHORT $LN491@the_real_p
$LN490@the_real_p:

; 3213 :                                               "; mips %2d.%02d",
; 3214 :                                               mipsrate,
; 3215 :                                               (mipsfrac + 5000) / 10000);
; 3216 :                             else
; 3217 :                                 i += idx_snprintf( i, ibuf, sizeof(ibuf),

  04677	8b 84 24 08 01
	00 00		 mov	 eax, DWORD PTR mipsfrac$17[rsp]
  0467e	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  04683	33 d2		 xor	 edx, edx
  04685	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  0468a	f7 f1		 div	 ecx
  0468c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  04690	8b 84 24 d0 00
	00 00		 mov	 eax, DWORD PTR mipsrate$9[rsp]
  04697	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  0469b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169767
  046a2	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  046a8	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR ibuf$43[rsp]
  046b0	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  046b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  046ba	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  046be	03 c8		 add	 ecx, eax
  046c0	8b c1		 mov	 eax, ecx
  046c2	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN491@the_real_p:
$LN489@the_real_p:
$LN487@the_real_p:
$LN485@the_real_p:
$LN484@the_real_p:

; 3218 :                                               "; mips %1d.%03d",
; 3219 :                                               mipsrate,
; 3220 :                                               (mipsfrac + 500) / 1000);
; 3221 :                         }
; 3222 :                     }
; 3223 :                 }
; 3224 : 
; 3225 :                 /* Prepare I/O statistics */
; 3226 :                 if (1
; 3227 :                     && (len + i + (numcpu ? 13 : 11)) < cons_cols
; 3228 :                     && (0

  046c6	33 c0		 xor	 eax, eax
  046c8	83 f8 01	 cmp	 eax, 1
  046cb	0f 84 e7 00 00
	00		 je	 $LN492@the_real_p
  046d1	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR numcpu$[rsp], 0
  046d9	74 0d		 je	 SHORT $LN561@the_real_p
  046db	c7 84 24 60 01
	00 00 0d 00 00
	00		 mov	 DWORD PTR tv2153[rsp], 13
  046e6	eb 0b		 jmp	 SHORT $LN562@the_real_p
$LN561@the_real_p:
  046e8	c7 84 24 60 01
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv2153[rsp], 11
$LN562@the_real_p:
  046f3	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  046f7	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  046fb	03 c8		 add	 ecx, eax
  046fd	8b c1		 mov	 eax, ecx
  046ff	03 84 24 60 01
	00 00		 add	 eax, DWORD PTR tv2153[rsp]
  04706	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  0470c	0f 8d a6 00 00
	00		 jge	 $LN492@the_real_p
  04712	33 c0		 xor	 eax, eax
  04714	85 c0		 test	 eax, eax
  04716	75 2a		 jne	 SHORT $LN493@the_real_p
  04718	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR numcpu$[rsp], 0
  04720	75 20		 jne	 SHORT $LN493@the_real_p
  04722	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR numcpu$[rsp], 0
  0472a	0f 85 88 00 00
	00		 jne	 $LN492@the_real_p
  04730	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04737	0f b7 80 ac 13
	00 00		 movzx	 eax, WORD PTR [rax+5036]
  0473e	85 c0		 test	 eax, eax
  04740	74 76		 je	 SHORT $LN492@the_real_p
$LN493@the_real_p:

; 3229 :                         ||   numcpu
; 3230 : #if defined( OPTION_SHARED_DEVICES )
; 3231 :                         || (!numcpu && sysblk.shrdport)
; 3232 : #endif
; 3233 :                        )
; 3234 :                 )
; 3235 :                 {
; 3236 :                     if (numcpu)

  04742	83 bc 24 c4 00
	00 00 00	 cmp	 DWORD PTR numcpu$[rsp], 0
  0474a	74 2e		 je	 SHORT $LN494@the_real_p

; 3237 :                         ibuf[(int)i++] = ';',

  0474c	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  04751	c6 84 04 d0 02
	00 00 3b	 mov	 BYTE PTR ibuf$43[rsp+rax], 59 ; 0000003bH
  04759	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  0475d	ff c0		 inc	 eax
  0475f	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
  04763	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  04768	c6 84 04 d0 02
	00 00 20	 mov	 BYTE PTR ibuf$43[rsp+rax], 32 ; 00000020H
  04770	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  04774	ff c0		 inc	 eax
  04776	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN494@the_real_p:

; 3238 :                         ibuf[(int)i++] = ' ';
; 3239 :                     i += idx_snprintf( i, ibuf, sizeof(ibuf),

  0477a	8b 84 24 0c 01
	00 00		 mov	 eax, DWORD PTR prev_siosrate$[rsp]
  04781	8b c8		 mov	 ecx, eax
  04783	e8 00 00 00 00	 call	 format_int
  04788	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0478d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169771
  04794	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0479a	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR ibuf$43[rsp]
  047a2	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  047a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_idx_snprintf
  047ac	8b 4c 24 70	 mov	 ecx, DWORD PTR i$[rsp]
  047b0	03 c8		 add	 ecx, eax
  047b2	8b c1		 mov	 eax, ecx
  047b4	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN492@the_real_p:

; 3240 :                                   "I/O %6.6s",
; 3241 :                                   format_int( prev_siosrate ));
; 3242 :                 }
; 3243 : 
; 3244 :                 /* Copy prepared statistics to buffer */
; 3245 :                 if (i)

  047b8	83 7c 24 70 00	 cmp	 DWORD PTR i$[rsp], 0
  047bd	74 4f		 je	 SHORT $LN495@the_real_p

; 3246 :                 {
; 3247 :                     if ((len + i) < cons_cols)

  047bf	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  047c3	8b 4c 24 78	 mov	 ecx, DWORD PTR len$[rsp]
  047c7	03 c8		 add	 ecx, eax
  047c9	8b c1		 mov	 eax, ecx
  047cb	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR cons_cols
  047d1	7d 12		 jge	 SHORT $LN496@the_real_p

; 3248 :                         len = cons_cols - i;

  047d3	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  047d7	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_cols
  047dd	2b c8		 sub	 ecx, eax
  047df	8b c1		 mov	 eax, ecx
  047e1	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
$LN496@the_real_p:

; 3249 :                     strcpy (buf + len, ibuf);

  047e5	48 63 44 24 78	 movsxd	 rax, DWORD PTR len$[rsp]
  047ea	48 8d 84 04 90
	03 00 00	 lea	 rax, QWORD PTR buf$[rsp+rax]
  047f2	48 8d 94 24 d0
	02 00 00	 lea	 rdx, QWORD PTR ibuf$43[rsp]
  047fa	48 8b c8	 mov	 rcx, rax
  047fd	e8 00 00 00 00	 call	 strcpy

; 3250 :                     len = cons_cols - 1;

  04802	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR cons_cols
  04808	ff c8		 dec	 eax
  0480a	89 44 24 78	 mov	 DWORD PTR len$[rsp], eax
$LN495@the_real_p:

; 3251 :                 }
; 3252 : 
; 3253 :                 buf[cons_cols] = '\0';

  0480e	48 63 05 00 00
	00 00		 movsxd	 rax, DWORD PTR cons_cols
  04815	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR $T40[rsp], rax
  0481d	48 81 bc 24 20
	02 00 00 00 04
	00 00		 cmp	 QWORD PTR $T40[rsp], 1024 ; 00000400H
  04829	73 02		 jae	 SHORT $LN563@the_real_p
  0482b	eb 05		 jmp	 SHORT $LN564@the_real_p
$LN563@the_real_p:
  0482d	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN564@the_real_p:
  04832	48 8b 84 24 20
	02 00 00	 mov	 rax, QWORD PTR $T40[rsp]
  0483a	c6 84 04 90 03
	00 00 00	 mov	 BYTE PTR buf$[rsp+rax], 0

; 3254 :                 set_pos (cons_rows, 1);

  04842	66 ba 01 00	 mov	 dx, 1
  04846	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cons_rows
  0484d	e8 00 00 00 00	 call	 set_pos

; 3255 :                 set_color (COLOR_LIGHT_YELLOW, COLOR_RED);

  04852	66 ba 01 00	 mov	 dx, 1
  04856	66 b9 0e 00	 mov	 cx, 14
  0485a	e8 00 00 00 00	 call	 set_color

; 3256 :                 draw_text (buf);

  0485f	48 8d 8c 24 90
	03 00 00	 lea	 rcx, QWORD PTR buf$[rsp]
  04867	e8 00 00 00 00	 call	 draw_text

; 3257 : 
; 3258 :                 /* restore cursor location */
; 3259 :                 cur_cons_row = saved_cons_row;

  0486c	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_row
  04873	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_row, ax

; 3260 :                 cur_cons_col = saved_cons_col;

  0487a	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR saved_cons_col
  04881	66 89 05 00 00
	00 00		 mov	 WORD PTR cur_cons_col, ax
$LN470@the_real_p:

; 3261 :             } /* end if(redraw_status) */
; 3262 : 
; 3263 :             /* Flush screen buffer and reset display update indicators */
; 3264 :             if (redraw_msgs || redraw_cmd || redraw_status)

  04888	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_msgs, 0
  0488f	75 16		 jne	 SHORT $LN498@the_real_p
  04891	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_cmd, 0
  04898	75 0d		 jne	 SHORT $LN498@the_real_p
  0489a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_status, 0
  048a1	0f 84 bc 00 00
	00		 je	 $LN497@the_real_p
$LN498@the_real_p:

; 3265 :             {
; 3266 :                 set_color (COLOR_DEFAULT_FG, COLOR_DEFAULT_BG);

  048a7	66 ba 11 00	 mov	 dx, 17
  048ab	66 b9 10 00	 mov	 cx, 16
  048af	e8 00 00 00 00	 call	 set_color

; 3267 :                 if (NPDup == 0 && NPDinit == 1)

  048b4	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDup, 0
  048bb	75 2d		 jne	 SHORT $LN499@the_real_p
  048bd	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDinit, 1
  048c4	75 24		 jne	 SHORT $LN499@the_real_p

; 3268 :                 {
; 3269 :                     NPDinit = 0;

  048c6	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR NPDinit, 0

; 3270 :                     restore_command_line();

  048d0	e8 00 00 00 00	 call	 restore_command_line

; 3271 :                     set_pos (cur_cons_row, cur_cons_col);

  048d5	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cur_cons_col
  048dc	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cur_cons_row
  048e3	e8 00 00 00 00	 call	 set_pos

; 3272 :                 }

  048e8	eb 4a		 jmp	 SHORT $LN500@the_real_p
$LN499@the_real_p:

; 3273 :                 else if (redraw_cmd)

  048ea	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_cmd, 0
  048f1	74 2e		 je	 SHORT $LN501@the_real_p

; 3274 :                     set_pos (CMDLINE_ROW, CMDLINE_COL + cmdoff - cmdcol);

  048f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169780
  048fa	e8 00 00 00 00	 call	 strlen
  048ff	48 ff c0	 inc	 rax
  04902	98		 cwde
  04903	03 05 00 00 00
	00		 add	 eax, DWORD PTR cmdoff
  04909	2b 05 00 00 00
	00		 sub	 eax, DWORD PTR cmdcol
  0490f	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR cons_rows
  04915	ff c9		 dec	 ecx
  04917	0f b7 d0	 movzx	 edx, ax
  0491a	e8 00 00 00 00	 call	 set_pos
  0491f	eb 13		 jmp	 SHORT $LN502@the_real_p
$LN501@the_real_p:

; 3275 :                 else
; 3276 :                     set_pos (cur_cons_row, cur_cons_col);

  04921	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR cur_cons_col
  04928	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR cur_cons_row
  0492f	e8 00 00 00 00	 call	 set_pos
$LN502@the_real_p:
$LN500@the_real_p:

; 3277 :                 fflush (confp);

  04934	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  0493b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 3278 :                 redraw_msgs = redraw_cmd = redraw_status = 0;

  04941	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR redraw_status, 0
  0494b	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_status
  04951	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_cmd, eax
  04957	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_cmd
  0495d	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_msgs, eax
$LN497@the_real_p:

; 3279 :             }
; 3280 : 
; 3281 :         } else { /* (NPDup == 1) */

  04963	e9 ac 00 00 00	 jmp	 $LN458@the_real_p
$LN457@the_real_p:

; 3282 : 
; 3283 :             if (redraw_status || (NPDinit == 0 && NPDup == 1)
; 3284 :                    || (redraw_cmd && NPdataentry == 1)) {

  04968	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_status, 0
  0496f	75 24		 jne	 SHORT $LN504@the_real_p
  04971	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDinit, 0
  04978	75 09		 jne	 SHORT $LN505@the_real_p
  0497a	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPDup, 1
  04981	74 12		 je	 SHORT $LN504@the_real_p
$LN505@the_real_p:
  04983	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR redraw_cmd, 0
  0498a	74 43		 je	 SHORT $LN503@the_real_p
  0498c	83 3d 00 00 00
	00 01		 cmp	 DWORD PTR NPdataentry, 1
  04993	75 3a		 jne	 SHORT $LN503@the_real_p
$LN504@the_real_p:

; 3285 :                 if (NPDinit == 0) {

  04995	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR NPDinit, 0
  0499c	75 31		 jne	 SHORT $LN506@the_real_p

; 3286 :                     NPDinit = 1;

  0499e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR NPDinit, 1

; 3287 :                     NP_screen_redraw(regs);

  049a8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  049b0	e8 00 00 00 00	 call	 NP_screen_redraw

; 3288 :                     NP_update(regs);

  049b5	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  049bd	e8 00 00 00 00	 call	 NP_update

; 3289 :                     fflush (confp);

  049c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  049c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
$LN506@the_real_p:
$LN503@the_real_p:

; 3290 :                 }
; 3291 :             }
; 3292 :             /* Update New Panel every panrate interval */
; 3293 :             if (!npquiet) {

  049cf	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR npquiet, 0
  049d6	75 1a		 jne	 SHORT $LN507@the_real_p

; 3294 :                 NP_update(regs);

  049d8	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR regs$[rsp]
  049e0	e8 00 00 00 00	 call	 NP_update

; 3295 :                 fflush (confp);

  049e5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR confp
  049ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
$LN507@the_real_p:

; 3296 :             }
; 3297 :             redraw_msgs = redraw_cmd = redraw_status = 0;

  049f2	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR redraw_status, 0
  049fc	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_status
  04a02	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_cmd, eax
  04a08	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_cmd
  04a0e	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_msgs, eax
$LN458@the_real_p:

; 3298 :         }
; 3299 : 
; 3300 :     /* =END= */
; 3301 : 
; 3302 :         /* Force full screen repaint if needed */
; 3303 :         if (!sysblk.npquiet && npquiet)

  04a14	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04a1b	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  04a21	c1 e8 04	 shr	 eax, 4
  04a24	83 e0 01	 and	 eax, 1
  04a27	85 c0		 test	 eax, eax
  04a29	75 2b		 jne	 SHORT $LN508@the_real_p
  04a2b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR npquiet, 0
  04a32	74 22		 je	 SHORT $LN508@the_real_p

; 3304 :             redraw_msgs = redraw_cmd = redraw_status = 1;

  04a34	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1
  04a3e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_status
  04a44	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_cmd, eax
  04a4a	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR redraw_cmd
  04a50	89 05 00 00 00
	00		 mov	 DWORD PTR redraw_msgs, eax
$LN508@the_real_p:

; 3305 :         npquiet = sysblk.npquiet;

  04a56	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04a5d	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  04a63	c1 e8 04	 shr	 eax, 4
  04a66	83 e0 01	 and	 eax, 1
  04a69	89 05 00 00 00
	00		 mov	 DWORD PTR npquiet, eax

; 3306 : 
; 3307 :     } /* end while */

  04a6f	e9 a9 ba ff ff	 jmp	 $LN8@the_real_p
$LN9@the_real_p:

; 3308 : 
; 3309 :     free( kbbuf );

  04a74	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR kbbuf$[rsp]
  04a7c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3310 : 
; 3311 :     sysblk.panel_init = 0;

  04a82	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04a89	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  04a8f	83 e0 f7	 and	 eax, -9			; fffffff7H
  04a92	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  04a99	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax

; 3312 : 
; 3313 :     LOG_THREAD_END( PANEL_THREAD_NAME  );

  04a9f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  04aa5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169788
  04aac	8b c8		 mov	 ecx, eax
  04aae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  04ab4	89 84 24 98 01
	00 00		 mov	 DWORD PTR tv2280[rsp], eax
  04abb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  04ac1	89 84 24 9c 01
	00 00		 mov	 DWORD PTR tv2285[rsp], eax
  04ac8	b9 01 00 00 00	 mov	 ecx, 1
  04acd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  04ad3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169787
  04ada	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  04adf	8b 8c 24 98 01
	00 00		 mov	 ecx, DWORD PTR tv2280[rsp]
  04ae6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  04aea	8b 8c 24 9c 01
	00 00		 mov	 ecx, DWORD PTR tv2285[rsp]
  04af1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  04af5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169789
  04afc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  04b01	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169790
  04b08	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  04b0d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  04b12	41 b9 03 00 00
	00		 mov	 r9d, 3
  04b18	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169791
  04b1f	ba f1 0c 00 00	 mov	 edx, 3313		; 00000cf1H
  04b24	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169792
  04b2b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN164@the_real_p:

; 3314 : 
; 3315 :     ASSERT( sysblk.shutdown );  // (why else would we be here?!)

  04b31	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  04b38	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  04b3e	c1 e8 0b	 shr	 eax, 11
  04b41	83 e0 01	 and	 eax, 1
  04b44	85 c0		 test	 eax, eax
  04b46	75 5c		 jne	 SHORT $LN509@the_real_p
$LN167@the_real_p:
  04b48	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169794
  04b4f	41 b8 f3 0c 00
	00		 mov	 r8d, 3315		; 00000cf3H
  04b55	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169795
  04b5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169796
  04b63	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  04b69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  04b6f	85 c0		 test	 eax, eax
  04b71	74 20		 je	 SHORT $LN510@the_real_p
  04b73	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169798
  04b7a	41 b8 f3 0c 00
	00		 mov	 r8d, 3315		; 00000cf3H
  04b80	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169799
  04b87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169800
  04b8e	e8 00 00 00 00	 call	 DebuggerTrace
$LN510@the_real_p:
  04b93	33 c0		 xor	 eax, eax
  04b95	85 c0		 test	 eax, eax
  04b97	75 af		 jne	 SHORT $LN167@the_real_p
  04b99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  04b9f	85 c0		 test	 eax, eax
  04ba1	74 01		 je	 SHORT $LN511@the_real_p
  04ba3	cc		 int	 3
$LN511@the_real_p:
$LN509@the_real_p:
  04ba4	33 c0		 xor	 eax, eax
  04ba6	85 c0		 test	 eax, eax
  04ba8	75 87		 jne	 SHORT $LN164@the_real_p
$LN1@the_real_p:
$LN512@the_real_p:

; 3316 : 
; 3317 : } /* end function panel_display */

  04baa	48 8b 8c 24 b0
	14 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  04bb2	48 33 cc	 xor	 rcx, rsp
  04bb5	e8 00 00 00 00	 call	 __security_check_cookie
  04bba	48 81 c4 c8 14
	00 00		 add	 rsp, 5320		; 000014c8H
  04bc1	5f		 pop	 rdi
  04bc2	5e		 pop	 rsi
  04bc3	c3		 ret	 0
$LN567@the_real_p:
  04bc4	00 00 00 00	 DD	 $LN223@the_real_p
  04bc8	00 00 00 00	 DD	 $LN229@the_real_p
  04bcc	00 00 00 00	 DD	 $LN235@the_real_p
  04bd0	00 00 00 00	 DD	 $LN240@the_real_p
  04bd4	00 00 00 00	 DD	 $LN246@the_real_p
  04bd8	00 00 00 00	 DD	 $LN253@the_real_p
  04bdc	00 00 00 00	 DD	 $LN184@the_real_p
  04be0	00 00 00 00	 DD	 $LN188@the_real_p
  04be4	00 00 00 00	 DD	 $LN206@the_real_p
  04be8	00 00 00 00	 DD	 $LN209@the_real_p
  04bec	00 00 00 00	 DD	 $LN218@the_real_p
  04bf0	00 00 00 00	 DD	 $LN250@the_real_p
  04bf4	00 00 00 00	 DD	 $LN212@the_real_p
  04bf8	00 00 00 00	 DD	 $LN203@the_real_p
  04bfc	00 00 00 00	 DD	 $LN199@the_real_p
  04c00	00 00 00 00	 DD	 $LN221@the_real_p
  04c04	00 00 00 00	 DD	 $LN234@the_real_p
  04c08	00 00 00 00	 DD	 $LN195@the_real_p
  04c0c	00 00 00 00	 DD	 $LN192@the_real_p
  04c10	00 00 00 00	 DD	 $LN215@the_real_p
  04c14	00 00 00 00	 DD	 $LN189@the_real_p
  04c18	00 00 00 00	 DD	 $LN243@the_real_p
  04c1c	00 00 00 00	 DD	 $LN228@the_real_p
  04c20	00 00 00 00	 DD	 $LN238@the_real_p
  04c24	00 00 00 00	 DD	 $LN205@the_real_p
  04c28	00 00 00 00	 DD	 $LN208@the_real_p
  04c2c	00 00 00 00	 DD	 $LN217@the_real_p
  04c30	00 00 00 00	 DD	 $LN251@the_real_p
  04c34	00 00 00 00	 DD	 $LN211@the_real_p
  04c38	00 00 00 00	 DD	 $LN202@the_real_p
  04c3c	00 00 00 00	 DD	 $LN200@the_real_p
  04c40	00 00 00 00	 DD	 $LN220@the_real_p
  04c44	00 00 00 00	 DD	 $LN233@the_real_p
  04c48	00 00 00 00	 DD	 $LN196@the_real_p
  04c4c	00 00 00 00	 DD	 $LN193@the_real_p
  04c50	00 00 00 00	 DD	 $LN214@the_real_p
  04c54	00 00 00 00	 DD	 $LN190@the_real_p
  04c58	00 00 00 00	 DD	 $LN244@the_real_p
  04c5c	00 00 00 00	 DD	 $LN227@the_real_p
  04c60	00 00 00 00	 DD	 $LN239@the_real_p
  04c64	00 00 00 00	 DD	 $LN257@the_real_p
$LN566@the_real_p:
  04c68	00		 DB	 0
  04c69	01		 DB	 1
  04c6a	02		 DB	 2
  04c6b	03		 DB	 3
  04c6c	04		 DB	 4
  04c6d	05		 DB	 5
  04c6e	28		 DB	 40			; 00000028H
  04c6f	28		 DB	 40			; 00000028H
  04c70	28		 DB	 40			; 00000028H
  04c71	28		 DB	 40			; 00000028H
  04c72	28		 DB	 40			; 00000028H
  04c73	28		 DB	 40			; 00000028H
  04c74	28		 DB	 40			; 00000028H
  04c75	28		 DB	 40			; 00000028H
  04c76	28		 DB	 40			; 00000028H
  04c77	28		 DB	 40			; 00000028H
  04c78	28		 DB	 40			; 00000028H
  04c79	28		 DB	 40			; 00000028H
  04c7a	28		 DB	 40			; 00000028H
  04c7b	28		 DB	 40			; 00000028H
  04c7c	28		 DB	 40			; 00000028H
  04c7d	28		 DB	 40			; 00000028H
  04c7e	28		 DB	 40			; 00000028H
  04c7f	28		 DB	 40			; 00000028H
  04c80	28		 DB	 40			; 00000028H
  04c81	28		 DB	 40			; 00000028H
  04c82	06		 DB	 6
  04c83	28		 DB	 40			; 00000028H
  04c84	28		 DB	 40			; 00000028H
  04c85	28		 DB	 40			; 00000028H
  04c86	28		 DB	 40			; 00000028H
  04c87	28		 DB	 40			; 00000028H
  04c88	28		 DB	 40			; 00000028H
  04c89	28		 DB	 40			; 00000028H
  04c8a	28		 DB	 40			; 00000028H
  04c8b	28		 DB	 40			; 00000028H
  04c8c	28		 DB	 40			; 00000028H
  04c8d	28		 DB	 40			; 00000028H
  04c8e	28		 DB	 40			; 00000028H
  04c8f	28		 DB	 40			; 00000028H
  04c90	28		 DB	 40			; 00000028H
  04c91	28		 DB	 40			; 00000028H
  04c92	28		 DB	 40			; 00000028H
  04c93	28		 DB	 40			; 00000028H
  04c94	28		 DB	 40			; 00000028H
  04c95	28		 DB	 40			; 00000028H
  04c96	28		 DB	 40			; 00000028H
  04c97	28		 DB	 40			; 00000028H
  04c98	28		 DB	 40			; 00000028H
  04c99	28		 DB	 40			; 00000028H
  04c9a	28		 DB	 40			; 00000028H
  04c9b	28		 DB	 40			; 00000028H
  04c9c	28		 DB	 40			; 00000028H
  04c9d	28		 DB	 40			; 00000028H
  04c9e	28		 DB	 40			; 00000028H
  04c9f	28		 DB	 40			; 00000028H
  04ca0	28		 DB	 40			; 00000028H
  04ca1	28		 DB	 40			; 00000028H
  04ca2	28		 DB	 40			; 00000028H
  04ca3	28		 DB	 40			; 00000028H
  04ca4	28		 DB	 40			; 00000028H
  04ca5	28		 DB	 40			; 00000028H
  04ca6	07		 DB	 7
  04ca7	28		 DB	 40			; 00000028H
  04ca8	08		 DB	 8
  04ca9	28		 DB	 40			; 00000028H
  04caa	09		 DB	 9
  04cab	0a		 DB	 10
  04cac	0b		 DB	 11
  04cad	0c		 DB	 12
  04cae	0d		 DB	 13
  04caf	28		 DB	 40			; 00000028H
  04cb0	0e		 DB	 14
  04cb1	28		 DB	 40			; 00000028H
  04cb2	28		 DB	 40			; 00000028H
  04cb3	0f		 DB	 15
  04cb4	28		 DB	 40			; 00000028H
  04cb5	10		 DB	 16
  04cb6	11		 DB	 17
  04cb7	12		 DB	 18
  04cb8	28		 DB	 40			; 00000028H
  04cb9	13		 DB	 19
  04cba	14		 DB	 20
  04cbb	15		 DB	 21
  04cbc	16		 DB	 22
  04cbd	28		 DB	 40			; 00000028H
  04cbe	17		 DB	 23
  04cbf	28		 DB	 40			; 00000028H
  04cc0	28		 DB	 40			; 00000028H
  04cc1	28		 DB	 40			; 00000028H
  04cc2	28		 DB	 40			; 00000028H
  04cc3	28		 DB	 40			; 00000028H
  04cc4	28		 DB	 40			; 00000028H
  04cc5	28		 DB	 40			; 00000028H
  04cc6	28		 DB	 40			; 00000028H
  04cc7	28		 DB	 40			; 00000028H
  04cc8	18		 DB	 24
  04cc9	28		 DB	 40			; 00000028H
  04cca	19		 DB	 25
  04ccb	1a		 DB	 26
  04ccc	1b		 DB	 27
  04ccd	1c		 DB	 28
  04cce	1d		 DB	 29
  04ccf	28		 DB	 40			; 00000028H
  04cd0	1e		 DB	 30
  04cd1	28		 DB	 40			; 00000028H
  04cd2	28		 DB	 40			; 00000028H
  04cd3	1f		 DB	 31
  04cd4	28		 DB	 40			; 00000028H
  04cd5	20		 DB	 32			; 00000020H
  04cd6	21		 DB	 33			; 00000021H
  04cd7	22		 DB	 34			; 00000022H
  04cd8	28		 DB	 40			; 00000028H
  04cd9	23		 DB	 35			; 00000023H
  04cda	24		 DB	 36			; 00000024H
  04cdb	25		 DB	 37			; 00000025H
  04cdc	26		 DB	 38			; 00000026H
  04cdd	28		 DB	 40			; 00000028H
  04cde	27		 DB	 39			; 00000027H
the_real_panel_display ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv65 = 0
set_panel_colors PROC

; 1610 : {

$LN9:
  00000	48 83 ec 18	 sub	 rsp, 24

; 1611 :     switch (sysblk.pan_colors)

  00004	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0000b	8b 80 34 11 00
	00		 mov	 eax, DWORD PTR [rax+4404]
  00011	89 04 24	 mov	 DWORD PTR tv65[rsp], eax
  00014	83 3c 24 00	 cmp	 DWORD PTR tv65[rsp], 0
  00018	74 14		 je	 SHORT $LN5@set_panel_
  0001a	83 3c 24 01	 cmp	 DWORD PTR tv65[rsp], 1
  0001e	0f 84 9f 01 00
	00		 je	 $LN6@set_panel_
  00024	83 3c 24 02	 cmp	 DWORD PTR tv65[rsp], 2
  00028	0f 84 2a 03 00
	00		 je	 $LN7@set_panel_
$LN5@set_panel_:

; 1612 :     {
; 1613 :     default:
; 1614 :     case PANC_NONE:   // No colors: use defaults
; 1615 : 
; 1616 :         sysblk.pan_color[ PANC_X_IDX ][ PANC_FG_IDX ] = COLOR_DEFAULT_FG;

  0002e	b8 08 00 00 00	 mov	 eax, 8
  00033	48 6b c0 00	 imul	 rax, rax, 0
  00037	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0003e	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00046	b9 04 00 00 00	 mov	 ecx, 4
  0004b	48 6b c9 00	 imul	 rcx, rcx, 0
  0004f	c7 04 08 10 00
	00 00		 mov	 DWORD PTR [rax+rcx], 16

; 1617 :         sysblk.pan_color[ PANC_I_IDX ][ PANC_FG_IDX ] = COLOR_DEFAULT_FG;

  00056	b8 08 00 00 00	 mov	 eax, 8
  0005b	48 6b c0 01	 imul	 rax, rax, 1
  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00066	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  0006e	b9 04 00 00 00	 mov	 ecx, 4
  00073	48 6b c9 00	 imul	 rcx, rcx, 0
  00077	c7 04 08 10 00
	00 00		 mov	 DWORD PTR [rax+rcx], 16

; 1618 :         sysblk.pan_color[ PANC_E_IDX ][ PANC_FG_IDX ] = COLOR_DEFAULT_FG;

  0007e	b8 08 00 00 00	 mov	 eax, 8
  00083	48 6b c0 02	 imul	 rax, rax, 2
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0008e	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00096	b9 04 00 00 00	 mov	 ecx, 4
  0009b	48 6b c9 00	 imul	 rcx, rcx, 0
  0009f	c7 04 08 10 00
	00 00		 mov	 DWORD PTR [rax+rcx], 16

; 1619 :         sysblk.pan_color[ PANC_W_IDX ][ PANC_FG_IDX ] = COLOR_DEFAULT_FG;

  000a6	b8 08 00 00 00	 mov	 eax, 8
  000ab	48 6b c0 03	 imul	 rax, rax, 3
  000af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b6	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  000be	b9 04 00 00 00	 mov	 ecx, 4
  000c3	48 6b c9 00	 imul	 rcx, rcx, 0
  000c7	c7 04 08 10 00
	00 00		 mov	 DWORD PTR [rax+rcx], 16

; 1620 :         sysblk.pan_color[ PANC_D_IDX ][ PANC_FG_IDX ] = COLOR_DEFAULT_FG;

  000ce	b8 08 00 00 00	 mov	 eax, 8
  000d3	48 6b c0 04	 imul	 rax, rax, 4
  000d7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000de	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  000e6	b9 04 00 00 00	 mov	 ecx, 4
  000eb	48 6b c9 00	 imul	 rcx, rcx, 0
  000ef	c7 04 08 10 00
	00 00		 mov	 DWORD PTR [rax+rcx], 16

; 1621 : 
; 1622 :         sysblk.pan_color[ PANC_X_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  000f6	b8 08 00 00 00	 mov	 eax, 8
  000fb	48 6b c0 00	 imul	 rax, rax, 0
  000ff	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00106	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  0010e	b9 04 00 00 00	 mov	 ecx, 4
  00113	48 6b c9 01	 imul	 rcx, rcx, 1
  00117	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1623 :         sysblk.pan_color[ PANC_I_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  0011e	b8 08 00 00 00	 mov	 eax, 8
  00123	48 6b c0 01	 imul	 rax, rax, 1
  00127	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0012e	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00136	b9 04 00 00 00	 mov	 ecx, 4
  0013b	48 6b c9 01	 imul	 rcx, rcx, 1
  0013f	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1624 :         sysblk.pan_color[ PANC_E_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  00146	b8 08 00 00 00	 mov	 eax, 8
  0014b	48 6b c0 02	 imul	 rax, rax, 2
  0014f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00156	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  0015e	b9 04 00 00 00	 mov	 ecx, 4
  00163	48 6b c9 01	 imul	 rcx, rcx, 1
  00167	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1625 :         sysblk.pan_color[ PANC_W_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  0016e	b8 08 00 00 00	 mov	 eax, 8
  00173	48 6b c0 03	 imul	 rax, rax, 3
  00177	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0017e	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00186	b9 04 00 00 00	 mov	 ecx, 4
  0018b	48 6b c9 01	 imul	 rcx, rcx, 1
  0018f	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1626 :         sysblk.pan_color[ PANC_D_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  00196	b8 08 00 00 00	 mov	 eax, 8
  0019b	48 6b c0 04	 imul	 rax, rax, 4
  0019f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001a6	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  001ae	b9 04 00 00 00	 mov	 ecx, 4
  001b3	48 6b c9 01	 imul	 rcx, rcx, 1
  001b7	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1627 : 
; 1628 :         break;

  001be	e9 25 03 00 00	 jmp	 $LN2@set_panel_
$LN6@set_panel_:

; 1629 : 
; 1630 :     case PANC_DARK:   // Dark scheme: light text on dark background
; 1631 : 
; 1632 :         sysblk.pan_color[ PANC_X_IDX ][ PANC_FG_IDX ] = COLOR_WHITE;

  001c3	b8 08 00 00 00	 mov	 eax, 8
  001c8	48 6b c0 00	 imul	 rax, rax, 0
  001cc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d3	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  001db	b9 04 00 00 00	 mov	 ecx, 4
  001e0	48 6b c9 00	 imul	 rcx, rcx, 0
  001e4	c7 04 08 0f 00
	00 00		 mov	 DWORD PTR [rax+rcx], 15

; 1633 :         sysblk.pan_color[ PANC_X_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  001eb	b8 08 00 00 00	 mov	 eax, 8
  001f0	48 6b c0 00	 imul	 rax, rax, 0
  001f4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001fb	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00203	b9 04 00 00 00	 mov	 ecx, 4
  00208	48 6b c9 01	 imul	 rcx, rcx, 1
  0020c	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1634 : 
; 1635 :         sysblk.pan_color[ PANC_I_IDX ][ PANC_FG_IDX ] = COLOR_LIGHT_GREY;

  00213	b8 08 00 00 00	 mov	 eax, 8
  00218	48 6b c0 01	 imul	 rax, rax, 1
  0021c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00223	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  0022b	b9 04 00 00 00	 mov	 ecx, 4
  00230	48 6b c9 00	 imul	 rcx, rcx, 0
  00234	c7 04 08 08 00
	00 00		 mov	 DWORD PTR [rax+rcx], 8

; 1636 :         sysblk.pan_color[ PANC_I_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  0023b	b8 08 00 00 00	 mov	 eax, 8
  00240	48 6b c0 01	 imul	 rax, rax, 1
  00244	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0024b	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00253	b9 04 00 00 00	 mov	 ecx, 4
  00258	48 6b c9 01	 imul	 rcx, rcx, 1
  0025c	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1637 : 
; 1638 :         sysblk.pan_color[ PANC_E_IDX ][ PANC_FG_IDX ] = COLOR_WHITE;

  00263	b8 08 00 00 00	 mov	 eax, 8
  00268	48 6b c0 02	 imul	 rax, rax, 2
  0026c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00273	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  0027b	b9 04 00 00 00	 mov	 ecx, 4
  00280	48 6b c9 00	 imul	 rcx, rcx, 0
  00284	c7 04 08 0f 00
	00 00		 mov	 DWORD PTR [rax+rcx], 15

; 1639 :         sysblk.pan_color[ PANC_E_IDX ][ PANC_BG_IDX ] = COLOR_LIGHT_RED;

  0028b	b8 08 00 00 00	 mov	 eax, 8
  00290	48 6b c0 02	 imul	 rax, rax, 2
  00294	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0029b	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  002a3	b9 04 00 00 00	 mov	 ecx, 4
  002a8	48 6b c9 01	 imul	 rcx, rcx, 1
  002ac	c7 04 08 09 00
	00 00		 mov	 DWORD PTR [rax+rcx], 9

; 1640 : 
; 1641 :         sysblk.pan_color[ PANC_W_IDX ][ PANC_FG_IDX ] = COLOR_LIGHT_GREY;

  002b3	b8 08 00 00 00	 mov	 eax, 8
  002b8	48 6b c0 03	 imul	 rax, rax, 3
  002bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002c3	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  002cb	b9 04 00 00 00	 mov	 ecx, 4
  002d0	48 6b c9 00	 imul	 rcx, rcx, 0
  002d4	c7 04 08 08 00
	00 00		 mov	 DWORD PTR [rax+rcx], 8

; 1642 :         sysblk.pan_color[ PANC_W_IDX ][ PANC_BG_IDX ] = COLOR_RED;

  002db	b8 08 00 00 00	 mov	 eax, 8
  002e0	48 6b c0 03	 imul	 rax, rax, 3
  002e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002eb	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  002f3	b9 04 00 00 00	 mov	 ecx, 4
  002f8	48 6b c9 01	 imul	 rcx, rcx, 1
  002fc	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 1643 : 
; 1644 :         sysblk.pan_color[ PANC_D_IDX ][ PANC_FG_IDX ] = COLOR_LIGHT_GREY;

  00303	b8 08 00 00 00	 mov	 eax, 8
  00308	48 6b c0 04	 imul	 rax, rax, 4
  0030c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00313	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  0031b	b9 04 00 00 00	 mov	 ecx, 4
  00320	48 6b c9 00	 imul	 rcx, rcx, 0
  00324	c7 04 08 08 00
	00 00		 mov	 DWORD PTR [rax+rcx], 8

; 1645 :         sysblk.pan_color[ PANC_D_IDX ][ PANC_BG_IDX ] = COLOR_BLUE;

  0032b	b8 08 00 00 00	 mov	 eax, 8
  00330	48 6b c0 04	 imul	 rax, rax, 4
  00334	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0033b	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00343	b9 04 00 00 00	 mov	 ecx, 4
  00348	48 6b c9 01	 imul	 rcx, rcx, 1
  0034c	c7 04 08 03 00
	00 00		 mov	 DWORD PTR [rax+rcx], 3

; 1646 : 
; 1647 :         break;

  00353	e9 90 01 00 00	 jmp	 $LN2@set_panel_
$LN7@set_panel_:

; 1648 : 
; 1649 :     case PANC_LIGHT:  // Light scheme: dark text on light background
; 1650 : 
; 1651 :         sysblk.pan_color[ PANC_X_IDX ][ PANC_FG_IDX ] = COLOR_DARK_GREY;

  00358	b8 08 00 00 00	 mov	 eax, 8
  0035d	48 6b c0 00	 imul	 rax, rax, 0
  00361	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00368	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00370	b9 04 00 00 00	 mov	 ecx, 4
  00375	48 6b c9 00	 imul	 rcx, rcx, 0
  00379	c7 04 08 07 00
	00 00		 mov	 DWORD PTR [rax+rcx], 7

; 1652 :         sysblk.pan_color[ PANC_X_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  00380	b8 08 00 00 00	 mov	 eax, 8
  00385	48 6b c0 00	 imul	 rax, rax, 0
  00389	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00390	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00398	b9 04 00 00 00	 mov	 ecx, 4
  0039d	48 6b c9 01	 imul	 rcx, rcx, 1
  003a1	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1653 : 
; 1654 :         sysblk.pan_color[ PANC_I_IDX ][ PANC_FG_IDX ] = COLOR_BLACK;

  003a8	b8 08 00 00 00	 mov	 eax, 8
  003ad	48 6b c0 01	 imul	 rax, rax, 1
  003b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003b8	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  003c0	b9 04 00 00 00	 mov	 ecx, 4
  003c5	48 6b c9 00	 imul	 rcx, rcx, 0
  003c9	c7 04 08 00 00
	00 00		 mov	 DWORD PTR [rax+rcx], 0

; 1655 :         sysblk.pan_color[ PANC_I_IDX ][ PANC_BG_IDX ] = COLOR_DEFAULT_BG;

  003d0	b8 08 00 00 00	 mov	 eax, 8
  003d5	48 6b c0 01	 imul	 rax, rax, 1
  003d9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003e0	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  003e8	b9 04 00 00 00	 mov	 ecx, 4
  003ed	48 6b c9 01	 imul	 rcx, rcx, 1
  003f1	c7 04 08 11 00
	00 00		 mov	 DWORD PTR [rax+rcx], 17

; 1656 : 
; 1657 :         sysblk.pan_color[ PANC_E_IDX ][ PANC_FG_IDX ] = COLOR_WHITE;

  003f8	b8 08 00 00 00	 mov	 eax, 8
  003fd	48 6b c0 02	 imul	 rax, rax, 2
  00401	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00408	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00410	b9 04 00 00 00	 mov	 ecx, 4
  00415	48 6b c9 00	 imul	 rcx, rcx, 0
  00419	c7 04 08 0f 00
	00 00		 mov	 DWORD PTR [rax+rcx], 15

; 1658 :         sysblk.pan_color[ PANC_E_IDX ][ PANC_BG_IDX ] = COLOR_LIGHT_RED;

  00420	b8 08 00 00 00	 mov	 eax, 8
  00425	48 6b c0 02	 imul	 rax, rax, 2
  00429	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00430	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00438	b9 04 00 00 00	 mov	 ecx, 4
  0043d	48 6b c9 01	 imul	 rcx, rcx, 1
  00441	c7 04 08 09 00
	00 00		 mov	 DWORD PTR [rax+rcx], 9

; 1659 : 
; 1660 :         sysblk.pan_color[ PANC_W_IDX ][ PANC_FG_IDX ] = COLOR_LIGHT_GREY;

  00448	b8 08 00 00 00	 mov	 eax, 8
  0044d	48 6b c0 03	 imul	 rax, rax, 3
  00451	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00458	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00460	b9 04 00 00 00	 mov	 ecx, 4
  00465	48 6b c9 00	 imul	 rcx, rcx, 0
  00469	c7 04 08 08 00
	00 00		 mov	 DWORD PTR [rax+rcx], 8

; 1661 :         sysblk.pan_color[ PANC_W_IDX ][ PANC_BG_IDX ] = COLOR_RED;

  00470	b8 08 00 00 00	 mov	 eax, 8
  00475	48 6b c0 03	 imul	 rax, rax, 3
  00479	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00480	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  00488	b9 04 00 00 00	 mov	 ecx, 4
  0048d	48 6b c9 01	 imul	 rcx, rcx, 1
  00491	c7 04 08 01 00
	00 00		 mov	 DWORD PTR [rax+rcx], 1

; 1662 : 
; 1663 :         sysblk.pan_color[ PANC_D_IDX ][ PANC_FG_IDX ] = COLOR_LIGHT_GREY;

  00498	b8 08 00 00 00	 mov	 eax, 8
  0049d	48 6b c0 04	 imul	 rax, rax, 4
  004a1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004a8	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  004b0	b9 04 00 00 00	 mov	 ecx, 4
  004b5	48 6b c9 00	 imul	 rcx, rcx, 0
  004b9	c7 04 08 08 00
	00 00		 mov	 DWORD PTR [rax+rcx], 8

; 1664 :         sysblk.pan_color[ PANC_D_IDX ][ PANC_BG_IDX ] = COLOR_BLUE;

  004c0	b8 08 00 00 00	 mov	 eax, 8
  004c5	48 6b c0 04	 imul	 rax, rax, 4
  004c9	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  004d0	48 8d 84 01 38
	11 00 00	 lea	 rax, QWORD PTR [rcx+rax+4408]
  004d8	b9 04 00 00 00	 mov	 ecx, 4
  004dd	48 6b c9 01	 imul	 rcx, rcx, 1
  004e1	c7 04 08 03 00
	00 00		 mov	 DWORD PTR [rax+rcx], 3
$LN2@set_panel_:

; 1665 : 
; 1666 :         break;
; 1667 :     }
; 1668 : }

  004e8	48 83 c4 18	 add	 rsp, 24
  004ec	c3		 ret	 0
set_panel_colors ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
elapsed_secs$ = 32
current_time$ = 40
update_maxrates_hwm PROC

; 1525 : {

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1526 :     time_t  current_time = 0;

  00004	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR current_time$[rsp], 0

; 1527 :     U32     elapsed_secs = 0;

  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR elapsed_secs$[rsp], 0

; 1528 : 
; 1529 :     if (curr_high_mips_rate < sysblk.mipsrate)

  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001c	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  00022	39 05 00 00 00
	00		 cmp	 DWORD PTR curr_high_mips_rate, eax
  00028	73 13		 jae	 SHORT $LN2@update_max

; 1530 :         curr_high_mips_rate = sysblk.mipsrate;

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00031	8b 80 88 14 00
	00		 mov	 eax, DWORD PTR [rax+5256]
  00037	89 05 00 00 00
	00		 mov	 DWORD PTR curr_high_mips_rate, eax
$LN2@update_max:

; 1531 : 
; 1532 :     if (curr_high_sios_rate < sysblk.siosrate)

  0003d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00044	8b 80 8c 14 00
	00		 mov	 eax, DWORD PTR [rax+5260]
  0004a	39 05 00 00 00
	00		 cmp	 DWORD PTR curr_high_sios_rate, eax
  00050	73 13		 jae	 SHORT $LN3@update_max

; 1533 :         curr_high_sios_rate = sysblk.siosrate;

  00052	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00059	8b 80 8c 14 00
	00		 mov	 eax, DWORD PTR [rax+5260]
  0005f	89 05 00 00 00
	00		 mov	 DWORD PTR curr_high_sios_rate, eax
$LN3@update_max:

; 1534 : 
; 1535 :     // Save high water marks for current interval...
; 1536 : 
; 1537 :     time( &current_time );

  00065	48 8d 4c 24 28	 lea	 rcx, QWORD PTR current_time$[rsp]
  0006a	e8 00 00 00 00	 call	 time

; 1538 : 
; 1539 :     elapsed_secs = current_time - curr_int_start_time;

  0006f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curr_int_start_time
  00076	48 8b 4c 24 28	 mov	 rcx, QWORD PTR current_time$[rsp]
  0007b	48 2b c8	 sub	 rcx, rax
  0007e	48 8b c1	 mov	 rax, rcx
  00081	89 44 24 20	 mov	 DWORD PTR elapsed_secs$[rsp], eax

; 1540 : 
; 1541 :     if ( elapsed_secs >= ( maxrates_rpt_intvl * 60 ) )

  00085	6b 05 00 00 00
	00 3c		 imul	 eax, DWORD PTR maxrates_rpt_intvl, 60 ; 0000003cH
  0008c	39 44 24 20	 cmp	 DWORD PTR elapsed_secs$[rsp], eax
  00090	72 46		 jb	 SHORT $LN4@update_max

; 1542 :     {
; 1543 :         prev_high_mips_rate = curr_high_mips_rate;

  00092	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR curr_high_mips_rate
  00098	89 05 00 00 00
	00		 mov	 DWORD PTR prev_high_mips_rate, eax

; 1544 :         prev_high_sios_rate = curr_high_sios_rate;

  0009e	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR curr_high_sios_rate
  000a4	89 05 00 00 00
	00		 mov	 DWORD PTR prev_high_sios_rate, eax

; 1545 : 
; 1546 :         curr_high_mips_rate = 0;

  000aa	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR curr_high_mips_rate, 0

; 1547 :         curr_high_sios_rate = 0;

  000b4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR curr_high_sios_rate, 0

; 1548 : 
; 1549 :         prev_int_start_time = curr_int_start_time;

  000be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR curr_int_start_time
  000c5	48 89 05 00 00
	00 00		 mov	 QWORD PTR prev_int_start_time, rax

; 1550 :         curr_int_start_time = current_time;

  000cc	48 8b 44 24 28	 mov	 rax, QWORD PTR current_time$[rsp]
  000d1	48 89 05 00 00
	00 00		 mov	 QWORD PTR curr_int_start_time, rax
$LN4@update_max:

; 1551 :     }
; 1552 : }

  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
update_maxrates_hwm ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\panel.c
_TEXT	SEGMENT
tv76 = 48
tv148 = 56
tv151 = 64
tv159 = 72
tv166 = 80
tv177 = 88
sysplex$1 = 96
sysname$2 = 112
systype$3 = 128
lparnam$4 = 144
msgbuf$5 = 160
title$ = 416
__$ArrayPad$ = 672
status$ = 704
set_console_title PROC

; 563  : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec b0 02
	00 00		 sub	 rsp, 688		; 000002b0H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 a0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 564  :     char    title[256];
; 565  : 
; 566  :     if ( sysblk.daemon_mode ) return;

  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00026	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0002c	c1 e8 02	 shr	 eax, 2
  0002f	83 e0 01	 and	 eax, 1
  00032	85 c0		 test	 eax, eax
  00034	74 05		 je	 SHORT $LN2@set_consol
  00036	e9 da 03 00 00	 jmp	 $LN1@set_consol
$LN2@set_consol:

; 567  : 
; 568  :     redraw_status = 1;

  0003b	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR redraw_status, 1

; 569  : 
; 570  :     if ( !sysblk.pantitle && ( !status || strlen(status) == 0 ) ) return;

  00045	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0004c	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  00054	75 22		 jne	 SHORT $LN3@set_consol
  00056	48 83 bc 24 c0
	02 00 00 00	 cmp	 QWORD PTR status$[rsp], 0
  0005f	74 12		 je	 SHORT $LN4@set_consol
  00061	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR status$[rsp]
  00069	e8 00 00 00 00	 call	 strlen
  0006e	48 85 c0	 test	 rax, rax
  00071	75 05		 jne	 SHORT $LN3@set_consol
$LN4@set_consol:
  00073	e9 9d 03 00 00	 jmp	 $LN1@set_consol
$LN3@set_consol:

; 571  : 
; 572  :     if ( !sysblk.pantitle )

  00078	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007f	48 83 b8 68 11
	00 00 00	 cmp	 QWORD PTR [rax+4456], 0
  00087	0f 85 ff 02 00
	00		 jne	 $LN5@set_consol

; 573  :     {
; 574  :         char msgbuf[256];
; 575  :         char sysname[16] = { 0 };

  0008d	48 8d 44 24 70	 lea	 rax, QWORD PTR sysname$2[rsp]
  00092	48 8b f8	 mov	 rdi, rax
  00095	33 c0		 xor	 eax, eax
  00097	b9 10 00 00 00	 mov	 ecx, 16
  0009c	f3 aa		 rep stosb

; 576  :         char sysplex[16] = { 0 };

  0009e	48 8d 44 24 60	 lea	 rax, QWORD PTR sysplex$1[rsp]
  000a3	48 8b f8	 mov	 rdi, rax
  000a6	33 c0		 xor	 eax, eax
  000a8	b9 10 00 00 00	 mov	 ecx, 16
  000ad	f3 aa		 rep stosb

; 577  :         char systype[16] = { 0 };

  000af	48 8d 84 24 80
	00 00 00	 lea	 rax, QWORD PTR systype$3[rsp]
  000b7	48 8b f8	 mov	 rdi, rax
  000ba	33 c0		 xor	 eax, eax
  000bc	b9 10 00 00 00	 mov	 ecx, 16
  000c1	f3 aa		 rep stosb

; 578  :         char lparnam[16] = { 0 };

  000c3	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR lparnam$4[rsp]
  000cb	48 8b f8	 mov	 rdi, rax
  000ce	33 c0		 xor	 eax, eax
  000d0	b9 10 00 00 00	 mov	 ecx, 16
  000d5	f3 aa		 rep stosb

; 579  : 
; 580  :         memset( msgbuf, 0, sizeof(msgbuf) );

  000d7	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR msgbuf$5[rsp]
  000df	48 8b f8	 mov	 rdi, rax
  000e2	33 c0		 xor	 eax, eax
  000e4	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  000e9	f3 aa		 rep stosb

; 581  : 
; 582  :         STRLCAT( systype, str_systype()  );

  000eb	e8 00 00 00 00	 call	 str_systype
  000f0	41 b8 10 00 00
	00		 mov	 r8d, 16
  000f6	48 8b d0	 mov	 rdx, rax
  000f9	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR systype$3[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 583  :         STRLCAT( sysname, str_sysname()  );

  00107	e8 00 00 00 00	 call	 str_sysname
  0010c	41 b8 10 00 00
	00		 mov	 r8d, 16
  00112	48 8b d0	 mov	 rdx, rax
  00115	48 8d 4c 24 70	 lea	 rcx, QWORD PTR sysname$2[rsp]
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 584  :         STRLCAT( sysplex, str_sysplex()  );

  00120	e8 00 00 00 00	 call	 str_sysplex
  00125	41 b8 10 00 00
	00		 mov	 r8d, 16
  0012b	48 8b d0	 mov	 rdx, rax
  0012e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sysplex$1[rsp]
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 585  :         STRLCAT( lparnam, str_lparname() );

  00139	e8 00 00 00 00	 call	 str_lparname
  0013e	41 b8 10 00 00
	00		 mov	 r8d, 16
  00144	48 8b d0	 mov	 rdx, rax
  00147	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR lparnam$4[rsp]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 586  : 
; 587  :         if ( strlen(lparnam)+strlen(systype)+strlen(sysname)+strlen(sysplex) > 0 )

  00155	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR lparnam$4[rsp]
  0015d	e8 00 00 00 00	 call	 strlen
  00162	48 89 44 24 30	 mov	 QWORD PTR tv76[rsp], rax
  00167	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR systype$3[rsp]
  0016f	e8 00 00 00 00	 call	 strlen
  00174	48 8b 4c 24 30	 mov	 rcx, QWORD PTR tv76[rsp]
  00179	48 03 c8	 add	 rcx, rax
  0017c	48 8b c1	 mov	 rax, rcx
  0017f	48 89 44 24 38	 mov	 QWORD PTR tv148[rsp], rax
  00184	48 8d 4c 24 70	 lea	 rcx, QWORD PTR sysname$2[rsp]
  00189	e8 00 00 00 00	 call	 strlen
  0018e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR tv148[rsp]
  00193	48 03 c8	 add	 rcx, rax
  00196	48 8b c1	 mov	 rax, rcx
  00199	48 89 44 24 40	 mov	 QWORD PTR tv151[rsp], rax
  0019e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sysplex$1[rsp]
  001a3	e8 00 00 00 00	 call	 strlen
  001a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR tv151[rsp]
  001ad	48 03 c8	 add	 rcx, rax
  001b0	48 8b c1	 mov	 rax, rcx
  001b3	48 85 c0	 test	 rax, rax
  001b6	0f 86 ac 01 00
	00		 jbe	 $LN7@set_consol

; 588  :         {
; 589  :             if ( strlen(lparnam) > 0 )

  001bc	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR lparnam$4[rsp]
  001c4	e8 00 00 00 00	 call	 strlen
  001c9	48 85 c0	 test	 rax, rax
  001cc	76 7d		 jbe	 SHORT $LN9@set_consol

; 590  :             {
; 591  :                 STRLCAT( msgbuf, lparnam );

  001ce	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001d4	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR lparnam$4[rsp]
  001dc	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 592  :                 if ( strlen(systype)+strlen(sysname)+strlen(sysplex) > 0 )

  001ea	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR systype$3[rsp]
  001f2	e8 00 00 00 00	 call	 strlen
  001f7	48 89 44 24 48	 mov	 QWORD PTR tv159[rsp], rax
  001fc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR sysname$2[rsp]
  00201	e8 00 00 00 00	 call	 strlen
  00206	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv159[rsp]
  0020b	48 03 c8	 add	 rcx, rax
  0020e	48 8b c1	 mov	 rax, rcx
  00211	48 89 44 24 50	 mov	 QWORD PTR tv166[rsp], rax
  00216	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sysplex$1[rsp]
  0021b	e8 00 00 00 00	 call	 strlen
  00220	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv166[rsp]
  00225	48 03 c8	 add	 rcx, rax
  00228	48 8b c1	 mov	 rax, rcx
  0022b	48 85 c0	 test	 rax, rax
  0022e	76 1b		 jbe	 SHORT $LN10@set_consol

; 593  :                     STRLCAT( msgbuf, " - " );

  00230	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00236	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168583
  0023d	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN10@set_consol:
$LN9@set_consol:

; 594  :             }
; 595  :             if ( strlen(systype) > 0 )

  0024b	48 8d 8c 24 80
	00 00 00	 lea	 rcx, QWORD PTR systype$3[rsp]
  00253	e8 00 00 00 00	 call	 strlen
  00258	48 85 c0	 test	 rax, rax
  0025b	76 60		 jbe	 SHORT $LN11@set_consol

; 596  :             {
; 597  :                 STRLCAT( msgbuf, systype );

  0025d	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00263	48 8d 94 24 80
	00 00 00	 lea	 rdx, QWORD PTR systype$3[rsp]
  0026b	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  00273	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 598  :                 if ( strlen(sysname)+strlen(sysplex) > 0 )

  00279	48 8d 4c 24 70	 lea	 rcx, QWORD PTR sysname$2[rsp]
  0027e	e8 00 00 00 00	 call	 strlen
  00283	48 89 44 24 58	 mov	 QWORD PTR tv177[rsp], rax
  00288	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sysplex$1[rsp]
  0028d	e8 00 00 00 00	 call	 strlen
  00292	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv177[rsp]
  00297	48 03 c8	 add	 rcx, rax
  0029a	48 8b c1	 mov	 rax, rcx
  0029d	48 85 c0	 test	 rax, rax
  002a0	76 1b		 jbe	 SHORT $LN12@set_consol

; 599  :                     STRLCAT( msgbuf, " * " );

  002a2	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  002a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168586
  002af	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  002b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN12@set_consol:
$LN11@set_consol:

; 600  :             }
; 601  :             if ( strlen(sysname) > 0 )

  002bd	48 8d 4c 24 70	 lea	 rcx, QWORD PTR sysname$2[rsp]
  002c2	e8 00 00 00 00	 call	 strlen
  002c7	48 85 c0	 test	 rax, rax
  002ca	76 43		 jbe	 SHORT $LN13@set_consol

; 602  :             {
; 603  :                 STRLCAT( msgbuf, sysname );

  002cc	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  002d2	48 8d 54 24 70	 lea	 rdx, QWORD PTR sysname$2[rsp]
  002d7	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  002df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 604  :                 if ( strlen(sysplex) > 0 )

  002e5	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sysplex$1[rsp]
  002ea	e8 00 00 00 00	 call	 strlen
  002ef	48 85 c0	 test	 rax, rax
  002f2	76 1b		 jbe	 SHORT $LN14@set_consol

; 605  :                     STRLCAT( msgbuf, " * " );

  002f4	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  002fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG168589
  00301	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  00309	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN14@set_consol:
$LN13@set_consol:

; 606  :             }
; 607  :             if ( strlen(sysplex) > 0 )

  0030f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR sysplex$1[rsp]
  00314	e8 00 00 00 00	 call	 strlen
  00319	48 85 c0	 test	 rax, rax
  0031c	76 19		 jbe	 SHORT $LN15@set_consol

; 608  :             {
; 609  :                 STRLCAT( msgbuf, sysplex );

  0031e	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00324	48 8d 54 24 60	 lea	 rdx, QWORD PTR sysplex$1[rsp]
  00329	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR msgbuf$5[rsp]
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN15@set_consol:

; 610  :             }
; 611  : 
; 612  :             MSGBUF( title, "%s - System Status: %s", msgbuf, status );

  00337	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR status$[rsp]
  0033f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00344	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR msgbuf$5[rsp]
  0034c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168591
  00353	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00358	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR title$[rsp]
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 613  :         }

  00366	eb 22		 jmp	 SHORT $LN8@set_consol
$LN7@set_consol:

; 614  :         else
; 615  :         {
; 616  :             MSGBUF( title, "System Status: %s", status );

  00368	4c 8b 8c 24 c0
	02 00 00	 mov	 r9, QWORD PTR status$[rsp]
  00370	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168592
  00377	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  0037c	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR title$[rsp]
  00384	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN8@set_consol:

; 617  :         }
; 618  :     }

  0038a	eb 7c		 jmp	 SHORT $LN6@set_consol
$LN5@set_consol:

; 619  :     else
; 620  :     {
; 621  :         if ( !status || strlen(status) == 0 )

  0038c	48 83 bc 24 c0
	02 00 00 00	 cmp	 QWORD PTR status$[rsp], 0
  00395	74 12		 je	 SHORT $LN18@set_consol
  00397	48 8b 8c 24 c0
	02 00 00	 mov	 rcx, QWORD PTR status$[rsp]
  0039f	e8 00 00 00 00	 call	 strlen
  003a4	48 85 c0	 test	 rax, rax
  003a7	75 2a		 jne	 SHORT $LN16@set_consol
$LN18@set_consol:

; 622  :             MSGBUF( title, "%s", sysblk.pantitle );

  003a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b0	4c 8b 88 68 11
	00 00		 mov	 r9, QWORD PTR [rax+4456]
  003b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168596
  003be	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  003c3	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR title$[rsp]
  003cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
  003d1	eb 35		 jmp	 SHORT $LN17@set_consol
$LN16@set_consol:

; 623  :         else
; 624  :             MSGBUF( title, "%s - System Status: %s", sysblk.pantitle, status );

  003d3	48 8b 84 24 c0
	02 00 00	 mov	 rax, QWORD PTR status$[rsp]
  003db	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003e7	4c 8b 88 68 11
	00 00		 mov	 r9, QWORD PTR [rax+4456]
  003ee	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168597
  003f5	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  003fa	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR title$[rsp]
  00402	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN17@set_consol:
$LN6@set_consol:

; 625  :     }
; 626  : 
; 627  :   #if defined( _MSVC_ )
; 628  :     w32_set_console_title( title );

  00408	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR title$[rsp]
  00410	e8 00 00 00 00	 call	 w32_set_console_title
$LN1@set_consol:

; 629  :   #else /*!defined(_MSVC_) */
; 630  :     /* For Unix systems we set the window title by sending a special
; 631  :        escape sequence (depends on terminal type) to the console.
; 632  :        See http://www.faqs.org/docs/Linux-mini/Xterm-Title.html */
; 633  :     if (!cons_term || !*cons_term) return;
; 634  :     if (strcmp(cons_term,"xterm")==0
; 635  :      || strcmp(cons_term,"rxvt")==0
; 636  :      || strcmp(cons_term,"dtterm")==0
; 637  :      || strcmp(cons_term,"screen")==0)
; 638  :     {
; 639  :         fprintf( confp, "%c]0;%s%c", '\033', title, '\007' );
; 640  :     }
; 641  :   #endif /*!defined(_MSVC_) */
; 642  : }

  00415	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0041d	48 33 cc	 xor	 rcx, rsp
  00420	e8 00 00 00 00	 call	 __security_check_cookie
  00425	48 81 c4 b0 02
	00 00		 add	 rsp, 688		; 000002b0H
  0042c	5f		 pop	 rdi
  0042d	c3		 ret	 0
set_console_title ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
localtime PROC

; 498  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 499  :             return _localtime64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__localtime64

; 500  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
localtime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
