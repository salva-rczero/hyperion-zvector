; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	zapcmd_cmd
PUBLIC	HelpCommand
PUBLIC	call_cachestats_cmd
PUBLIC	call_ptt_cmd
PUBLIC	call_locks_cmd
PUBLIC	call_threads_cmd
PUBLIC	call_shrd_cmd
EXTRN	quit_cmd:PROC
EXTRN	quitmout_cmd:PROC
EXTRN	devinit_cmd:PROC
EXTRN	qproc_cmd:PROC
EXTRN	stopall_cmd:PROC
EXTRN	restart_cmd:PROC
EXTRN	aia_cmd:PROC
EXTRN	rexx_cmd:PROC
EXTRN	exec_cmd:PROC
EXTRN	suspend_cmd:PROC
EXTRN	resume_cmd:PROC
EXTRN	locate_cmd:PROC
EXTRN	$runtest_cmd:PROC
EXTRN	$test_cmd:PROC
EXTRN	cckd_cmd:PROC
EXTRN	devtmax_cmd:PROC
EXTRN	legacysenseid_cmd:PROC
EXTRN	sclproot_cmd:PROC
EXTRN	comment_cmd:PROC
EXTRN	cmdlvl_cmd:PROC
EXTRN	cmdsep_cmd:PROC
EXTRN	History:PROC
EXTRN	msg_cmd:PROC
EXTRN	msglevel_cmd:PROC
EXTRN	uptime_cmd:PROC
EXTRN	version_cmd:PROC
EXTRN	attach_cmd:PROC
EXTRN	cpu_cmd:PROC
EXTRN	define_cmd:PROC
EXTRN	detach_cmd:PROC
EXTRN	devlist_cmd:PROC
EXTRN	fcb_cmd:PROC
EXTRN	cctape_cmd:PROC
EXTRN	loadparm_cmd:PROC
EXTRN	log_cmd:PROC
EXTRN	logopt_cmd:PROC
EXTRN	mt_cmd:PROC
EXTRN	panopt_cmd:PROC
EXTRN	panrate_cmd:PROC
EXTRN	pantitle_cmd:PROC
EXTRN	qcpuid_cmd:PROC
EXTRN	qpid_cmd:PROC
EXTRN	qports_cmd:PROC
EXTRN	qstor_cmd:PROC
EXTRN	start_cmd:PROC
EXTRN	stop_cmd:PROC
EXTRN	abs_or_r_cmd:PROC
EXTRN	aea_cmd:PROC
EXTRN	ar_cmd:PROC
EXTRN	autoinit_cmd:PROC
EXTRN	automount_cmd:PROC
EXTRN	trace_cmd:PROC
EXTRN	bear_cmd:PROC
EXTRN	clocks_cmd:PROC
EXTRN	codepage_cmd:PROC
EXTRN	conkpalv_cmd:PROC
EXTRN	cp_updt_cmd:PROC
EXTRN	cr_cmd:PROC
EXTRN	cscript_cmd:PROC
EXTRN	ctc_cmd:PROC
EXTRN	ds_cmd:PROC
EXTRN	fquest_cmd:PROC
EXTRN	fpc_cmd:PROC
EXTRN	fpr_cmd:PROC
EXTRN	g_cmd:PROC
EXTRN	gpr_cmd:PROC
EXTRN	herclogo_cmd:PROC
EXTRN	ipending_cmd:PROC
EXTRN	k_cmd:PROC
EXTRN	loadcore_cmd:PROC
EXTRN	loadtext_cmd:PROC
EXTRN	maxcpu_cmd:PROC
EXTRN	mounted_tape_reinit_cmd:PROC
EXTRN	netdev_cmd:PROC
EXTRN	numcpu_cmd:PROC
EXTRN	qeth_cmd:PROC
EXTRN	ostailor_cmd:PROC
EXTRN	pgmtrace_cmd:PROC
EXTRN	pr_cmd:PROC
EXTRN	psw_cmd:PROC
EXTRN	ptp_cmd:PROC
EXTRN	qd_cmd:PROC
EXTRN	quiet_cmd:PROC
EXTRN	savecore_cmd:PROC
EXTRN	script_cmd:PROC
EXTRN	sh_cmd:PROC
EXTRN	traceopt_cmd:PROC
EXTRN	tf_cmd:PROC
EXTRN	txf_cmd:PROC
EXTRN	auto_trace_cmd:PROC
EXTRN	timerint_cmd:PROC
EXTRN	tlb_cmd:PROC
EXTRN	toddrag_cmd:PROC
EXTRN	u_cmd:PROC
EXTRN	v_cmd:PROC
EXTRN	i_cmd:PROC
EXTRN	ipl_cmd:PROC
EXTRN	iplc_cmd:PROC
EXTRN	ext_cmd:PROC
EXTRN	startall_cmd:PROC
EXTRN	store_cmd:PROC
EXTRN	sysclear_cmd:PROC
EXTRN	sysreset_cmd:PROC
EXTRN	cnslport_cmd:PROC
EXTRN	cpuidfmt_cmd:PROC
EXTRN	cpumodel_cmd:PROC
EXTRN	cpuserial_cmd:PROC
EXTRN	cpuverid_cmd:PROC
EXTRN	diag8_cmd:PROC
EXTRN	engines_cmd:PROC
EXTRN	lparname_cmd:PROC
EXTRN	lparnum_cmd:PROC
EXTRN	mainsize_cmd:PROC
EXTRN	stsi_manufacturer_cmd:PROC
EXTRN	stsi_model_cmd:PROC
EXTRN	stsi_plant_cmd:PROC
EXTRN	shcmdopt_cmd:PROC
EXTRN	sysepoch_cmd:PROC
EXTRN	sysgport_cmd:PROC
EXTRN	tzoffset_cmd:PROC
EXTRN	xpndsize_cmd:PROC
EXTRN	yroffset_cmd:PROC
EXTRN	hercnice_cmd:PROC
EXTRN	hercprio_cmd:PROC
EXTRN	cpuprio_cmd:PROC
EXTRN	devprio_cmd:PROC
EXTRN	srvprio_cmd:PROC
EXTRN	todprio_cmd:PROC
EXTRN	archlvl_cmd:PROC
EXTRN	facility_cmd:PROC
EXTRN	sizeof_cmd:PROC
EXTRN	cmpscpad_cmd:PROC
EXTRN	alrf_cmd:PROC
EXTRN	cf_cmd:PROC
EXTRN	cfall_cmd:PROC
EXTRN	ecpsvm_cmd:PROC
EXTRN	scpecho_cmd:PROC
EXTRN	scpimply_cmd:PROC
EXTRN	ssd_cmd:PROC
EXTRN	hwldr_cmd:PROC
EXTRN	lddev_cmd:PROC
EXTRN	qpfkeys_cmd:PROC
EXTRN	defsym_cmd:PROC
EXTRN	delsym_cmd:PROC
EXTRN	modpath_cmd:PROC
EXTRN	ldmod_cmd:PROC
EXTRN	lsdep_cmd:PROC
EXTRN	lsequ_cmd:PROC
EXTRN	lsmod_cmd:PROC
EXTRN	rmmod_cmd:PROC
EXTRN	http_cmd:PROC
EXTRN	iodelay_cmd:PROC
EXTRN	pgmprdos_cmd:PROC
EXTRN	maxrates_cmd:PROC
EXTRN	scsimount_cmd:PROC
EXTRN	shrdport_cmd:PROC
EXTRN	tt32_cmd:PROC
_DATA	SEGMENT
$SG160477 DB	'$locate', 00H
$SG160478 DB	'Display sysblk, regs or hostinfo', 00H
	ORG $+7
$SG160479 DB	'$runtest', 00H
	ORG $+3
$SG160482 DB	'$test', 00H
	ORG $+2
$SG160499 DB	'#', 00H
	ORG $+2
$SG160480 DB	'Start the test if test mode is active', 00H
	ORG $+2
$SG160481 DB	'Issue ''restart'' command and then wait for all processo'
	DB	'rs to load a', 0aH, 'disabled wait PSW. This is a scripting o'
	DB	'nly command and is only valid', 0aH, 'when test mode is activ'
	DB	'e. Test mode can only be activated by specifying', 0aH, 'the '
	DB	'''-t'' command line switch when Hercules is started. Runtest '
	DB	'supports', 0aH, 'a single optional argument being the expecte'
	DB	'd test duration in seconds.', 0aH, 'If not specified then a d'
	DB	'efault value is used. If the test runs longer', 0aH, 'than th'
	DB	'e expected time an error message is issued and the test abort'
	DB	's.', 0aH, 00H
$SG160483 DB	'Your custom command (*DANGEROUS!*)', 00H
	ORG $+5
$SG160485 DB	'$zapcmd', 00H
$SG160484 DB	'Performs whatever test function *YOU* specifically coded'
	DB	' it to do.', 0aH, 0aH, '                  * * * *  WARNING!  '
	DB	'* * * *', 0aH, 0aH, 'DO NOT RUN THIS COMMAND UNLESS *YOU* SPE'
	DB	'CIFICALLY CODED THE FUNCTION', 0aH, 'THAT THIS COMMAND INVOKE'
	DB	'S! Unless you wrote it yourself you probably', 0aH, 'don''t k'
	DB	'now it does. It could perform any function at all from crashi'
	DB	'ng', 0aH, 'Hercules to launching a nuclear strike. You have b'
	DB	'een warned!', 0aH, 00H
	ORG $+2
$SG160501 DB	'*', 00H
	ORG $+2
$SG160486 DB	'Enable/disable command (*CAREFUL!*)', 00H
	ORG $+4
$SG160487 DB	'Format:', 0aH, 0aH, '    $zapcmd  cmdname  CFG|NOCFG|CMD'
	DB	'|NOCMD', 0aH, 0aH, 'For normal non-Debug production release b'
	DB	'uilds, use the sequence:', 0aH, 0aH, '    msglvl   VERBOSE   '
	DB	'   (optional)', 0aH, '    msglvl   DEBUG        (optional)', 0aH
	DB	'    cmdlvl   DEBUG        (*required!*) (because not DEBUG bu'
	DB	'ild,', 0aH, '    $zapcmd  cmdname  CMD                and $za'
	DB	'pcmd is SYSDEBUG)', 0aH, 0aH, 'In other words, the $zapcmd is'
	DB	' itself a ''debug'' level command, and', 0aH, 'thus in order '
	DB	'to use it, the debug cmdlvl must be set first (which', 0aH, 'i'
	DB	's the default for Debug builds but not normal production buil'
	DB	'ds).', 0aH, 'Note: it is possible to disable the $zapcmd itse'
	DB	'lf so BE CAREFUL!', 0aH, 00H
	ORG $+2
$SG160488 DB	'cckd', 00H
	ORG $+3
$SG160503 DB	'?', 00H
	ORG $+2
$SG160489 DB	'Compressed CKD command', 00H
	ORG $+1
$SG160491 DB	'devtmax', 00H
$SG160490 DB	'The cckd command is used to display current cckd process'
	DB	'ing options', 0aH, 'or statistics or to set new cckd processi'
	DB	'ng options:', 0aH, 0aH, ' cckd  help         Display cckd hel'
	DB	'p', 0aH, ' cckd  stats        Display current cckd statistics'
	DB	0aH, ' cckd  opts         Display current cckd options', 0aH, ' '
	DB	'cckd  opt=val,...  Set cckd option. Multiple options may be s'
	DB	'pecified.', 0aH, '                    Each option must be sep'
	DB	'arated from the next with a', 0aH, '                    singl'
	DB	'e comma and no intervening blanks. The list of', 0aH, '      '
	DB	'              supported cckd options are:', 0aH, 0aH, '  comp'
	DB	'=n        Override compression                  (-1,0,1,2)', 0aH
	DB	'  compparm=n    Override compression parm             (-1 ...'
	DB	' 9)', 0aH, '  debug=n       Enable CCW tracing debug messages'
	DB	'       (0 or 1)', 0aH, '  dtax=n        Dump trace table at e'
	DB	'xit                (0 or 1)', 0aH, '  freepend=n    Set free '
	DB	'pending cycles               (-1 ... 4)', 0aH, '  fsync=n    '
	DB	'   Enable fsync                            (0 or 1)', 0aH, ' '
	DB	' gcint=n       Set garbage collector interval (sec)  ( 0 .. 6'
	DB	'0)', 0aH, '  gcmsgs=n      Display garbage collector messages'
	DB	'      (0 or 1)', 0aH, '  gcparm=n      Set garbage collector '
	DB	'parameter       (-8 ... 8)', 0aH, '  gcstart=n     Start garb'
	DB	'age collector                 (0 or 1)', 0aH, '  linuxnull=n '
	DB	'  Check for null linux tracks             (0 or 1)', 0aH, '  '
	DB	'nosfd=n       Disable stats report at close           (0 or 1'
	DB	')', 0aH, '  nostress=n    Disable stress writes              '
	DB	'     (0 or 1)', 0aH, '  ra=n          Set number readahead th'
	DB	'reads          ( 1 ... 9)', 0aH, '  raq=n         Set readahe'
	DB	'ad queue size              ( 0 .. 16)', 0aH, '  rat=n        '
	DB	' Set number tracks to read ahead       ( 0 .. 16)', 0aH, '  t'
	DB	'race=n       Set trace table size              (0 ... 200000)'
	DB	0aH, '  wr=n          Set number writer threads             ( '
	DB	'1 ... 9)', 0aH, 0aH, 'Refer to the Hercules CCKD documentatio'
	DB	'n web page for more information.', 0aH, 00H
	ORG $+3
$SG160505 DB	'cmdlvl', 00H
	ORG $+1
$SG160514 DB	'hst', 00H
$SG160492 DB	'Display or set max device threads', 00H
	ORG $+6
$SG160493 DB	'Specifies the maximum number of device threads allowed.', 0aH
	DB	0aH, 'Specify -1 to cause ''one time only'' temporary threads '
	DB	'to be created', 0aH, 'to service each I/O request to a device'
	DB	'. Once the I/O request is', 0aH, 'complete, the thread exits.'
	DB	' Subsequent I/O to the same device will', 0aH, 'cause another'
	DB	' worker thread to be created again.', 0aH, 0aH, 'Specify 0 to'
	DB	' cause an unlimited number of ''semi-permanent'' threads', 0aH
	DB	'to be created on an ''as-needed'' basis. With this option, a '
	DB	'thread', 0aH, 'is created to service an I/O request for a dev'
	DB	'ice if one doesn''t', 0aH, 'already exist, but once the I/O i'
	DB	's complete, the thread enters an', 0aH, 'idle state waiting f'
	DB	'or new work. If a new I/O request for the device', 0aH, 'arri'
	DB	'ves before the timeout period expires, the existing thread wi'
	DB	'll', 0aH, 'be reused. The timeout value is currently hard cod'
	DB	'ed at 5 minutes.', 0aH, 'Note that this option can cause one '
	DB	'thread (or possibly more) to be', 0aH, 'created for each devi'
	DB	'ce defined in your configuration. Specifying 0', 0aH, 'means '
	DB	'there is no limit to the number of threads that can be create'
	DB	'd.', 0aH, 0aH, 'Specify a value from 1 to nnn  to set an uppe'
	DB	'r limit to the number of', 0aH, 'threads that can be created '
	DB	'to service any I/O request to any device.', 0aH, 'Like the 0 '
	DB	'option, each thread, once done servicing an I/O request,', 0aH
	DB	'enters an idle state. If a new request arrives before the tim'
	DB	'eout', 0aH, 'period expires, the thread is reused. If all thr'
	DB	'eads are busy when a', 0aH, 'new I/O request arrives however,'
	DB	' a new thread is created only if the', 0aH, 'specified maximu'
	DB	'm has not yet been reached. If the specified maximum', 0aH, 'n'
	DB	'umber of threads has already been reached, then the I/O reque'
	DB	'st is', 0aH, 'placed in a queue and will be serviced by the f'
	DB	'irst available thread', 0aH, '(i.e. by whichever thread becom'
	DB	'es idle first). This option was created', 0aH, 'to address a '
	DB	'threading issue (possibly related to the cygwin Pthreads', 0aH
	DB	'implementation) on Windows systems.', 0aH, 0aH, 'The default '
	DB	'for Windows is 8. The default for all other systems is 0.', 0aH
	DB	00H
	ORG $+3
$SG160508 DB	'cmdsep', 00H
	ORG $+1
$SG160520 DB	'msg', 00H
$SG160494 DB	'legacysenseid', 00H
	ORG $+2
$SG160495 DB	'Set legacysenseid setting', 00H
	ORG $+2
$SG160525 DB	'msglvl', 00H
	ORG $+1
$SG160536 DB	'cpu', 00H
$SG160496 DB	'sclproot', 00H
	ORG $+3
$SG160527 DB	'msgnoh', 00H
	ORG $+1
$SG160551 DB	'fcb', 00H
$SG160497 DB	'Set SCLP base directory', 00H
$SG160498 DB	'Format: "sclproot [path|NONE]"', 0aH, 'Enables SCLP disk'
	DB	' I/O for the specified directory path, or disables', 0aH, 'SC'
	DB	'LP disk I/O if NONE is specified. A subsequent list-directed '
	DB	'IPL', 0aH, 'resets the path to the location of the .ins file,'
	DB	' and a CCW-type IPL', 0aH, 'disables SCLP disk I/O. If no ope'
	DB	'rand is specified, sclproot displays', 0aH, 'the current sett'
	DB	'ing.', 0aH, 00H
	ORG $+1
$SG160500 DB	'Silent comment', 00H
	ORG $+1
$SG160502 DB	'Loud comment', 00H
	ORG $+3
$SG160504 DB	'alias for help', 00H
	ORG $+1
$SG160506 DB	'Display/Set current command group', 00H
	ORG $+2
$SG160529 DB	'uptime', 00H
	ORG $+1
$SG160560 DB	'log', 00H
$SG160507 DB	'Format: cmdlevel [{+/-}{ALL|MAINT|PROG|OPER|DEVEL|DEBUG}'
	DB	'...]', 0aH, 00H
	ORG $+2
$SG160509 DB	'Display/Set command line separator', 00H
	ORG $+5
$SG160510 DB	'A command line separator character allows multiple comma'
	DB	'nds', 0aH, 'to be entered on a single line.', 0aH, 0aH, 'Form'
	DB	'at: CMDSEP  [OFF | c ]', 0aH, '        c       a single chara'
	DB	'cter used to separate commands.', 0aH, '        OFF     disab'
	DB	'les command separation.', 0aH, 00H
$SG160511 DB	'help', 00H
	ORG $+3
$SG160533 DB	'attach', 00H
	ORG $+1
$SG160566 DB	'mt', 00H
	ORG $+1
$SG160512 DB	'list all commands / command specific help', 00H
	ORG $+6
$SG160515 DB	'History of commands', 00H
	ORG $+4
$SG160513 DB	'Format: "help [cmd|c*]".', 0aH, 0aH, 'The command withou'
	DB	't any options will display a short description', 0aH, 'of all'
	DB	' of the commands available matching the current cmdlevel. You'
	DB	0aH, 'may specify a partial command name followed by an ''*'' '
	DB	'to get a', 0aH, 'list matching the partial command name. For '
	DB	'example ''help msg*''', 0aH, 'will list all commands beginnin'
	DB	'g with ''msg'' and matching the current', 0aH, 'cmdlevel.', 0aH
	DB	0aH, 'This command with the ''cmd'' option will display a long'
	DB	' form of help', 0aH, 'information associated with that comman'
	DB	'd if the command is available', 0aH, 'for the current cmdleve'
	DB	'l.', 0aH, 0aH, 'Help text may be limited to explaining the ge'
	DB	'neral format of the', 0aH, 'command and its various required '
	DB	'or optional parameters and is not', 0aH, 'meant to replace th'
	DB	'e appropriate manual.', 0aH, 00H
$SG160516 DB	'Format: "hst | hst n | hst l". Command "hst l" or "hst 0'
	DB	'" displays', 0aH, 'list of last ten commands entered from com'
	DB	'mand line', 0aH, 'hst n, where n is a positive number retriev'
	DB	'es n-th command from list', 0aH, 'hst n, where n is a negativ'
	DB	'e number retrieves n-th last command', 0aH, 'hst without an a'
	DB	'rgument works exactly as hst -1, it retrieves the', 0aH, 'las'
	DB	't command', 0aH, 00H
$SG160593 DB	'abs', 00H
$SG160517 DB	'message', 00H
$SG160518 DB	'Display message on console a la VM', 00H
	ORG $+5
$SG160519 DB	'Format: "message * text". The ''text'' field is variable'
	DB	' in size.', 0aH, 'A ''VM'' message similar to: "13:02:41 * MS'
	DB	'G FROM HERCULES: hello" is', 0aH, 'diplayed on the console pa'
	DB	'nel as a result of the panel command', 0aH, '''message * hell'
	DB	'o''.  (See also the "msgnoh" command)', 0aH, 00H
$SG160521 DB	'Alias for message', 00H
	ORG $+2
$SG160539 DB	'define', 00H
	ORG $+1
$SG160596 DB	'aea', 00H
$SG160522 DB	'msglevel', 00H
	ORG $+3
$SG160542 DB	'detach', 00H
	ORG $+1
$SG160598 DB	'aia', 00H
$SG160523 DB	'Display/Set current Message Display output', 00H
	ORG $+5
$SG160524 DB	'Format:  msglevel  [verbose|terse|debug|nodebug|emsgloc|'
	DB	'noemsgloc]', 0aH, 0aH, '   verbose     Display messages durin'
	DB	'g configuration file processing', 0aH, '   terse       Do not'
	DB	' display configuration file processing messages', 0aH, '   de'
	DB	'bug       Prefix messages with filename and line number', 0aH
	DB	'   nodebug     Display messages normally', 0aH, '   emsgloc  '
	DB	'   Show where error messages originated', 0aH, '   noemsgloc '
	DB	'  Do not show where error messages originated', 0aH, 00H
$SG160600 DB	'ar', 00H
	ORG $+1
$SG160526 DB	'Alias for msglevel', 00H
	ORG $+1
$SG160608 DB	'b-', 00H
	ORG $+1
$SG160528 DB	'Similar to "message" but no header', 00H
	ORG $+1
$SG160610 DB	'b', 00H
	ORG $+2
$SG160530 DB	'Display how long Hercules has been running', 00H
	ORG $+1
$SG160613 DB	'b?', 00H
	ORG $+1
$SG160531 DB	'version', 00H
$SG160532 DB	'Display version information', 00H
$SG160615 DB	'b+', 00H
	ORG $+1
$SG160534 DB	'Configure device', 00H
	ORG $+3
$SG160554 DB	'cctape', 00H
	ORG $+1
$SG160633 DB	'cr', 00H
	ORG $+1
$SG160535 DB	'Format: "attach devn type [arg...]', 0aH, 00H
$SG160639 DB	'ctc', 00H
$SG160537 DB	'Define target cpu for panel display and commands', 00H
	ORG $+7
$SG160538 DB	'Format: "cpu [xx [cmd]]" where ''xx'' is the hexadecimal'
	DB	' cpu address ', 0aH, 'of the cpu in your multiprocessor confi'
	DB	'guration you wish all panel', 0aH, 'commands to apply to.  If'
	DB	' command text follows the cpu address, the', 0aH, 'command ex'
	DB	'ecutes on cpu xx and the target cpu is not changed.', 0aH, 0aH
	DB	'For example, entering ''cpu 1F'' followed by "gpr" will chang'
	DB	'e the', 0aH, 'target cpu for the panel display and commands a'
	DB	'nd then display the', 0aH, 'general purpose registers for cpu'
	DB	' 31 of your configuration, whereas', 0aH, '"cpu 14 gpr" execu'
	DB	'tes the ''gpr'' command on cpu 20, but does not', 0aH, 'chang'
	DB	'e the target cpu for subsequent panel displays and commands.', 0aH
	DB	0aH, 'Entering the command with no arguments displays the curr'
	DB	'ent value.', 0aH, 00H
	ORG $+3
$SG160563 DB	'logopt', 00H
	ORG $+1
$SG160642 DB	'ds', 00H
	ORG $+1
$SG160540 DB	'Rename device', 00H
	ORG $+2
$SG160541 DB	'Format: "define olddevn newdevn"', 0aH, 00H
	ORG $+2
$SG160569 DB	'panopt', 00H
	ORG $+1
$SG160644 DB	'f?', 00H
	ORG $+1
$SG160543 DB	'Remove device', 00H
	ORG $+2
$SG160545 DB	'devinit', 00H
$SG160544 DB	'Format: "detach devn [FORCE]"', 0aH, 'Where ''devn'' is '
	DB	'the device address of the device to be removed from', 0aH, 't'
	DB	'he hardware configuration. Use the ''FORCE'' option to forcib'
	DB	'ly remove', 0aH, 'devices which are still in use (are current'
	DB	'ly ''busy'' performing I/O).', 0aH, 'Note that using the FORC'
	DB	'E option is inherently DANGEROUS and can easily', 0aH, 'cause'
	DB	' Hercules to CRASH!', 0aH, 00H
$SG160546 DB	'Reinitialize device', 00H
$SG160576 DB	'qcpuid', 00H
	ORG $+5
$SG160547 DB	'Format: "devinit devn [arg...]"', 0aH, 'If no arguments '
	DB	'are given then the same arguments are used', 0aH, 'as were us'
	DB	'ed the last time the device was created/initialized.', 0aH, 00H
	ORG $+1
$SG160646 DB	'fpc', 00H
$SG160548 DB	'devlist', 00H
$SG160549 DB	'List device, device class, or all devices', 00H
	ORG $+6
$SG160552 DB	'Display a printer''s current FCB', 00H
$SG160553 DB	'Format: "fcb <devnum>"', 00H
	ORG $+1
$SG160550 DB	'Format: "devlist [devn | devc]"', 0aH, '    devn       i'
	DB	's a single device address', 0aH, '    devc       is a single '
	DB	'device class. Device classes are CHAN, CON,', 0aH, '         '
	DB	'      CTCA, DASD, DSP, FCP, LINE, OSA, PCH, PRT, RDR, and TAP'
	DB	'E.', 0aH, 0aH, 'If no arguments are given then all devices wi'
	DB	'll be listed.', 0aH, 00H
	ORG $+1
$SG160555 DB	'Display a printer''s current cctape', 00H
	ORG $+1
$SG160649 DB	'fpr', 00H
$SG160556 DB	'Format: "cctape <devnum>"', 00H
	ORG $+2
$SG160581 DB	'qports', 00H
	ORG $+1
$SG160652 DB	'g', 00H
	ORG $+2
$SG160557 DB	'loadparm', 00H
	ORG $+3
$SG160583 DB	'qproc', 00H
	ORG $+2
$SG160622 DB	'clocks', 00H
	ORG $+1
$SG160654 DB	'gpr', 00H
$SG160558 DB	'Set the default IPL ''LOADPARM'' parameter', 00H
	ORG $+7
$SG160561 DB	'Direct logger output', 00H
	ORG $+3
$SG160559 DB	'Specifies the default eight-character IPL ''LOADPARM'' p'
	DB	'arameter used by', 0aH, 'some operating systems to select cer'
	DB	'tain initialization options. The', 0aH, 'value specified here'
	DB	' can be overridden by specifying a different value', 0aH, 'on'
	DB	' the the IPL command itself. The LOADPARM command simply defi'
	DB	'nes the', 0aH, 'default value that is used if not overridden '
	DB	'on the IPL command itself.', 0aH, 00H
	ORG $+5
$SG160564 DB	'Set/Display logging options', 00H
$SG160579 DB	'qpid', 00H
	ORG $+7
$SG160562 DB	'Format: "log [ OFF | newfile ]".   Sets log filename or '
	DB	'stops', 0aH, 'log file output with the "OFF" option.', 00H
	ORG $+3
$SG160567 DB	'Control magnetic tape operation', 00H
$SG160572 DB	'panrate', 00H
$SG160565 DB	'Format: "LOGOPT [DATESTAMP | NODATESTAMP] [TIMESTAMP | N'
	DB	'OTIMESTAMP]".', 0aH, 0aH, 'Sets logfile options. "TIMESTAMP" '
	DB	'inserts a time stamp in front of', 0aH, 'each log message. "N'
	DB	'OTIMESTAMP" logs messages without time stamps.', 0aH, 'Simila'
	DB	'rly, "DATESTAMP" and "NODATESTAMP" prefixes logfile messages', 0aH
	DB	'with or without the current date. Entering the command with n'
	DB	'o arguments', 0aH, 'displays current logging options. The cur'
	DB	'rent resolution of the stamp', 0aH, 'is one second.', 0aH, 00H
	ORG $+1
$SG160568 DB	'Format:     "mt device operation [ 1-9999 ]".', 0aH, '  '
	DB	'Operations below can be used on a valid tape device. The devi'
	DB	'ce', 0aH, '  must not have any I/O operation in process or pe'
	DB	'nding.', 0aH, '     operation   description', 0aH, '       re'
	DB	'w       rewind tape to the beginning', 0aH, '       asf n    '
	DB	' position tape at ''n'' file  (default = 1)', 0aH, '       fs'
	DB	'f n     forward space ''n'' files    (default = 1)', 0aH, '  '
	DB	'     bsf n     backward space ''n'' files   (default = 1)', 0aH
	DB	'       fsr n     forward space ''n'' records  (default = 1)', 0aH
	DB	'       bsr n     backward space ''n'' records (default = 1)', 0aH
	DB	'       wtm n     write ''n'' tapemarks        (default = 1)', 0aH
	DB	'       dse       data secure erase', 0aH, '       dvol1     d'
	DB	'isplay VOL1 header', 0aH, 00H
	ORG $+3
$SG160585 DB	'qstor', 00H
	ORG $+2
$SG160662 DB	'k', 00H
	ORG $+2
$SG160570 DB	'Set or display panel options', 00H
	ORG $+3
$SG160577 DB	'Display cpuid(s)', 00H
	ORG $+7
$SG160571 DB	'Format:', 0aH, 0aH, '  panopt [FULLpath|NAMEonly] [RATE='
	DB	'n] [MSGCOLOR=NO|DARK|LIGHT] [TITLE=xxx]', 0aH, 0aH, 'NAMEONLY'
	DB	' requests the extended panel screen (that displays the list o'
	DB	'f', 0aH, 'devices and is reached by pressing the ESC key) to '
	DB	'display the emulated', 0aH, 'device''s base filename only, wh'
	DB	'ereas FULLPATH (the default) displays the', 0aH, 'file''s ful'
	DB	'l path filename.', 0aH, 0aH, 'RATE=nnn sets the panel refresh'
	DB	' rate to nnn milliseconds. RATE=FAST sets', 0aH, 'the refresh'
	DB	' rate to 50 milliseconds. RATE=SLOW sets the refresh rate to', 0aH
	DB	'500 milliseconds.', 0aH, 0aH, 'MSGCOLOR=DARK displays coloriz'
	DB	'ed panel messages meant for dark colored', 0aH, 'panels (e.g.'
	DB	' white text on black background) whereas MSGCOLOR=LIGHT is', 0aH
	DB	'meant for light colored panels (e.g. black text on white back'
	DB	'ground).', 0aH, 0aH, 'TITLE=xxx sets an optional console wind'
	DB	'ow title-bar string to be used in', 0aH, 'place of the defaul'
	DB	't supplied by the windowing system. The entire TITLE=', 0aH, 'a'
	DB	'rgument should be enclosed within double quotes if it contain'
	DB	's any blanks', 0aH, '(e.g. use "TITLE=my title" and not TITLE'
	DB	'="my title" which is an error).', 0aH, 'An empty string ("TIT'
	DB	'LE=") will remove the existing console title. The', 0aH, 'def'
	DB	'ault console title is the string consisting of:', 0aH, 0aH, ' '
	DB	'    LPARNAME - SYSTYPE * SYSNAME * SYSPLEX - System Status: c'
	DB	'olor', 0aH, 0aH, 'SYSTYPE, SYSNAME, and SYSPLEX are populated'
	DB	' by the system call SCLP Control', 0aH, 'Program Identificati'
	DB	'on. If a value is blank then that field is not shown.', 0aH, 0aH
	DB	'System Status colors are:', 0aH, 0aH, '     GREEN       every'
	DB	'thing is working correctly', 0aH, '     YELLOW      one or mo'
	DB	're CPUs are not running', 0aH, '     RED         one or more '
	DB	'CPUs are in a disabled wait state', 0aH, 0aH, 'Enter PANOPT w'
	DB	'ithout any arguments at all to display the current settings.', 0aH
	DB	00H
	ORG $+1
$SG160573 DB	'(deprecated; use PANOPT RATE=nnn instead)', 00H
	ORG $+2
$SG160670 DB	'maxcpu', 00H
	ORG $+1
$SG160680 DB	'osa', 00H
$SG160574 DB	'pantitle', 00H
	ORG $+3
$SG160587 DB	'start', 00H
	ORG $+2
$SG160675 DB	'netdev', 00H
	ORG $+1
$SG160689 DB	'pr', 00H
	ORG $+1
$SG160575 DB	'(deprecated; use PANOPT TITLE=xxx instead)', 00H
	ORG $+5
$SG160578 DB	'Format:   "qcpuid   [xx|ALL]"', 0aH, 0aH, 'Displays the '
	DB	'cpuid and STSI results presented to the SCP for either', 0aH, 't'
	DB	'he current panel command target cpu (as defined by the "cpu" '
	DB	'panel', 0aH, 'command) if no arguments are given, or the spec'
	DB	'ified hexadecimal cpu', 0aH, 'address or all cpus if an argum'
	DB	'ent was given.', 0aH, 00H
	ORG $+1
$SG160692 DB	'psw', 00H
$SG160580 DB	'Display Process ID of Hercules', 00H
	ORG $+1
$SG160582 DB	'Display TCP/IP ports in use', 00H
$SG160695 DB	'ptp', 00H
$SG160584 DB	'Display processors type and utilization', 00H
$SG160586 DB	'Display main and expanded storage values', 00H
	ORG $+3
$SG160678 DB	'numcpu', 00H
	ORG $+1
$SG160698 DB	'ptt', 00H
$SG160588 DB	'Start CPU (or printer/punch device if argument given)', 00H
	ORG $+2
$SG160590 DB	'stop', 00H
	ORG $+3
$SG160589 DB	'Entering the ''start'' command by itself starts the targ'
	DB	'et cpu if it', 0aH, 'is currently stopped. Entering the ''sta'
	DB	'rt <devn>'' command will press', 0aH, 'the specified printer '
	DB	'or punch device''s virtual start button. Use the', 0aH, '''cp'
	DB	'u'' command beforehand to choose which processor you wish to '
	DB	'start.', 0aH, 00H
	ORG $+3
$SG160591 DB	'Stop CPU (or printer/punch device if argument given)', 00H
	ORG $+3
$SG160592 DB	'Entering the ''stop'' command by itself stops the target'
	DB	' cpu if it is', 0aH, 'currently running. Entering the ''stop '
	DB	'<devn>'' command will press the', 0aH, 'specified printer or '
	DB	'punch device''s virtual stop button, usually causing', 0aH, 'a'
	DB	'n INTREQ (Intervention Required) status. Use the ''cpu'' comm'
	DB	'and before', 0aH, 'issuing the stop command to choose which p'
	DB	'rocessor you wish to stop.', 0aH, 00H
	ORG $+1
$SG160594 DB	'Display or alter absolute storage', 00H
	ORG $+6
$SG160597 DB	'Display AEA tables', 00H
	ORG $+5
$SG160595 DB	'Format: "abs addr[.len]" or "abs addr[-addr2]" to displa'
	DB	'y up to 64K', 0aH, 'of absolute storage, or "abs addr=value" '
	DB	'to alter up to 32 bytes of', 0aH, 'absolute storage, where '''
	DB	'value'' is either a string of up to 32 pairs of', 0aH, 'hex d'
	DB	'igits, or a string of up to 32 characters enclosed within sin'
	DB	'gle or', 0aH, 'double quotes.', 0aH, 00H
	ORG $+3
$SG160701 DB	'qd', 00H
	ORG $+1
$SG160599 DB	'Display AIA fields', 00H
	ORG $+1
$SG160710 DB	'r', 00H
	ORG $+2
$SG160601 DB	'Display access registers', 00H
	ORG $+3
$SG160707 DB	'quiet', 00H
	ORG $+2
$SG160713 DB	'resume', 00H
	ORG $+1
$SG160715 DB	's-', 00H
	ORG $+1
$SG160602 DB	'autoinit', 00H
	ORG $+3
$SG160717 DB	's', 00H
	ORG $+2
$SG160603 DB	'Display/Set auto-create-empty-tape-file option', 00H
	ORG $+1
$SG160606 DB	'Display/Update allowable tape automount directories', 00H
	ORG $+4
$SG160604 DB	'Format: "AUTOINIT  [ ON | OFF ]"', 0aH, 0aH, 'The AUTOIN'
	DB	'IT option controls whether emulated tape drive device files', 0aH
	DB	'will be automatically created or not when it is discovered th'
	DB	'ey do not', 0aH, 'yet exist.', 0aH, 0aH, 'When AUTOINIT is ON'
	DB	' (the default), a devinit command specifying a file', 0aH, 't'
	DB	'hat does not yet exist causes the tape driver to automaticall'
	DB	'y create', 0aH, 'an unlabeled tape volume consisting of just '
	DB	'two tapemarks whenever it', 0aH, 'discovered the specified fi'
	DB	'le does not exist.', 0aH, 0aH, 'When AUTOINIT is OFF, a devin'
	DB	'it command instead fails with an expected', 0aH, '"file not f'
	DB	'ound" error if the specified tape file does not exist.', 0aH, 0aH
	DB	'Entering the command without any arguments displays the curre'
	DB	'nt setting.', 0aH, 00H
	ORG $+2
$SG160720 DB	's?', 00H
	ORG $+1
$SG160605 DB	'automount', 00H
	ORG $+6
$SG160609 DB	'Delete breakpoint', 00H
	ORG $+6
$SG160607 DB	'Format: "automount  { add <dir> | del <dir> | list }"', 0aH
	DB	0aH, 'Adds or deletes entries from the list of allowable/unall'
	DB	'owable tape', 0aH, 'automount directories, or lists all curre'
	DB	'ntly defined list entries,', 0aH, 'if any.', 0aH, 0aH, 'The f'
	DB	'ormat of the <dir> directory operand for add/del operations i'
	DB	's', 0aH, 'identical to that as described in the documentation'
	DB	' for the AUTOMOUNT', 0aH, 'configuration file statement (i.e.'
	DB	' prefix with ''+'' or ''-'' as needed).', 0aH, 0aH, 'The auto'
	DB	'mount feature is appropriately enabled or disabled for all', 0aH
	DB	'tape devices as needed depending on the updated empty/non-emp'
	DB	'ty list', 0aH, 'state.', 0aH, 00H
	ORG $+3
$SG160723 DB	's+', 00H
	ORG $+1
$SG160611 DB	'Set breakpoint', 00H
	ORG $+1
$SG160612 DB	'Format:', 0aH, 0aH, '     "b addr-addr   [asid]"', 0aH, ' '
	DB	'    "b addr:addr   [asid]"', 0aH, '     "b addr.length [asid]'
	DB	'"', 0aH, 0aH, 'Sets the instruction address or address range '
	DB	'where you wish to halt', 0aH, 'execution.  This command is sy'
	DB	'nonymous with the "s+" command.', 0aH, 00H
	ORG $+2
$SG160729 DB	'script', 00H
	ORG $+1
$SG160732 DB	'sh', 00H
	ORG $+1
$SG160614 DB	'Query breakpoint', 00H
	ORG $+3
$SG160739 DB	'tf', 00H
	ORG $+1
$SG160616 DB	'(Synonym for ''b'')', 00H
	ORG $+2
$SG160617 DB	'bear', 00H
	ORG $+3
$SG160742 DB	't-', 00H
	ORG $+1
$SG160618 DB	'Display or set BEAR register', 00H
	ORG $+3
$SG160621 DB	'Cache stats command', 00H
	ORG $+4
$SG160619 DB	'Format: "bear [address]" where ''address'' is value the '
	DB	'BEAR register', 0aH, 'should be set to. Enter the command wit'
	DB	'hout any operand to just display', 0aH, 'the current value of'
	DB	' the BEAR register.', 0aH, 00H
	ORG $+3
$SG160620 DB	'cachestats', 00H
	ORG $+1
$SG160744 DB	't', 00H
	ORG $+2
$SG160623 DB	'Display tod clkc and cpu timer', 00H
	ORG $+1
$SG160624 DB	'codepage', 00H
	ORG $+3
$SG160747 DB	't?', 00H
	ORG $+1
$SG160625 DB	'Set/display code page conversion table', 00H
	ORG $+1
$SG160626 DB	'Format: ''codepage [cp]''', 0aH, '        ''codepage mai'
	DB	'nt cmd [operands]'' - see cp_updt command for', 0aH, '       '
	DB	'                                   help', 0aH, 'If no operand'
	DB	' is specified, the current codepage is displayed.', 0aH, 'If '
	DB	'''cp'' is specified, then code page is set to the specified p'
	DB	'age', 0aH, 'if the page is valid.', 0aH, 00H
	ORG $+3
$SG160750 DB	't+', 00H
	ORG $+1
$SG160627 DB	'conkpalv', 00H
	ORG $+3
$SG160753 DB	'txf', 00H
$SG160628 DB	'Display/alter console TCP keepalive settings', 00H
	ORG $+3
$SG160630 DB	'cp_updt', 00H
$SG160629 DB	'Format: "conkpalv (idle,intv,count)" where ''idle'', ''i'
	DB	'ntv'' and ''count''', 0aH, 'are the new values for the TCP ke'
	DB	'epalive settings for console', 0aH, 'connections:', 0aH, 0aH, ' '
	DB	'  Begin probing after connection has been idle for ''idle'' s'
	DB	'econds', 0aH, '   wait for a maximum of ''intv'' seconds for '
	DB	'a probe response', 0aH, '   Close the connection once ''count'
	DB	''' consecutive probes have failed', 0aH, 0aH, 'The format mus'
	DB	't be exactly as shown, with each value separated from', 0aH, 't'
	DB	'he next by a single comma, no intervening spaces between them'
	DB	', and', 0aH, 'surrounded within parenthesis. Enter the comman'
	DB	'd without any operands', 0aH, 'to display the current values.'
	DB	0aH, 00H
	ORG $+3
$SG160631 DB	'Create/Modify user character conversion table', 00H
	ORG $+2
$SG160634 DB	'Display or alter control registers', 00H
	ORG $+5
$SG160632 DB	'Format: ''cp_updt cmd [operands]''', 0aH, 0aH, '  altER '
	DB	'e|g2h|a|h2g (pos, val, pos, val,...)', 0aH, '                '
	DB	'              - alter the user eBCDIC/g2h or aSCII/h2g', 0aH, ' '
	DB	'                               table value at hex POSition to'
	DB	' hex', 0aH, '                                VALue 16 pairs o'
	DB	'f hex digits may be', 0aH, '                                s'
	DB	'pecified within the parens', 0aH, 0aH, '  dsp|disPLAY e|g2h|a'
	DB	'|h2g     - display user eBCDIC|aSCII table', 0aH, 0aH, '  exp'
	DB	'ORT e|g2h|a|h2g filename - export contents of user table to f'
	DB	'ile', 0aH, 0aH, '  impORT e|g2h|a|h2g filename - import file '
	DB	'contents into user table', 0aH, 0aH, '  refERENCE [cp]       '
	DB	'       - copy codepage to user tables', 0aH, '               '
	DB	'                 if cp is not specified, a list of', 0aH, '  '
	DB	'                              valid codepage tables is genera'
	DB	'ted', 0aH, 0aH, '  reset                       - reset the in'
	DB	'ternal user tables to', 0aH, '                               '
	DB	' binary zero', 0aH, 0aH, '  test                        - ver'
	DB	'ify that user tables are', 0aH, '                            '
	DB	'    transparent, i.e. the value at', 0aH, '                  '
	DB	'              position n in g2h used as an index', 0aH, '    '
	DB	'                            into h2g will return a value equa'
	DB	'l n', 0aH, '                                ( g2h<=>h2g, h2g<'
	DB	'=>g2h )', 0aH, 0aH, ' *e|g2h represent ebcdic; a|h2g represen'
	DB	't ascii', 0aH, ' **lower case part of the cmd name represent '
	DB	'the minimum abbreviation', 0aH, '   for the command', 0aH, 0aH
	DB	'To activate the user table, enter the command ''codepage user'
	DB	'''', 0aH, 0aH, 'Note: ebcdic refers to guest to host translat'
	DB	'ion', 0aH, '      ascii refers to host to guest translation', 0aH
	DB	'      These terms are used for historical purposes and do not'
	DB	0aH, '      represent the literal term.', 0aH, 00H
	ORG $+6
$SG160636 DB	'cscript', 00H
$SG160635 DB	'Format: "cr [nn=xxxxxxxxxxxxxxxx]" where ''nn'' is the o'
	DB	'ptional', 0aH, 'control register number (0 to 15) and ''xxxxx'
	DB	'xxxxxxxxxxx'' is the', 0aH, 'control register value in hex (1'
	DB	'-8 hex digits for 32-bit registers', 0aH, 'or 1-16 hex digits'
	DB	' for 64-bit registers). Enter "cr" by itself to', 0aH, 'displ'
	DB	'ay the control registers without altering them.', 0aH, 00H
	ORG $+3
$SG160756 DB	't+-', 00H
$SG160637 DB	'Cancels a running script thread', 00H
$SG160638 DB	'Format: "cscript  [''*'' | ''ALL'' | id]".  This command'
	DB	' cancels a running', 0aH, 'script or all scripts. If ''*'' or'
	DB	' ''ALL'' is given then all running scripts', 0aH, 'are cancel'
	DB	'ed. If no arguments are given only the first running script i'
	DB	's', 0aH, 'cancelled. Otherwise the specific script ''id'' is '
	DB	'canceled. The ''script''', 0aH, 'command may be used to displ'
	DB	'ay a list of all currently running scripts.', 0aH, 00H
	ORG $+2
$SG160762 DB	'tlb', 00H
$SG160640 DB	'Enable/Disable CTC debugging', 00H
	ORG $+3
$SG160641 DB	'Format:  "ctc  debug  [ on | off | startup  [ <devnum> |'
	DB	' ALL ]]".', 0aH, 0aH, 'Enables/disables debug packet tracing '
	DB	'for the specified CTCI/LCS/PTP/CTCE', 0aH, 'device group(s) i'
	DB	'dentified by <devnum> or for all CTCI/LCS/PTP/CTCE device', 0aH
	DB	'groups if <devnum> is not specified or specified as ''ALL''.', 0aH
	DB	0aH, 'Note: only CTCE devices support ''startup'' debugging.', 0aH
	DB	0aH, 'Use the command "ctc debug" (without any other operands)'
	DB	' to list the', 0aH, 'current CTC debugging state for all CTC '
	DB	'devices.', 0aH, 00H
	ORG $+3
$SG160769 DB	'u', 00H
	ORG $+2
$SG160643 DB	'Display subchannel', 00H
	ORG $+1
$SG160772 DB	'v', 00H
	ORG $+2
$SG160645 DB	'Query unusable page frame range(s)', 00H
	ORG $+1
$SG160775 DB	'i', 00H
	ORG $+2
$SG160647 DB	'Display or alter floating point control register', 00H
	ORG $+7
$SG160648 DB	'Format: "fpc [xxxxxxxxxxxxxxxx]" where ''xxxxxxxxxxxxxxx'
	DB	'x'' is the', 0aH, 'register value in hexadecimal (1-8 hex dig'
	DB	'its). Enter "fpc" by itself', 0aH, 'to display the register v'
	DB	'alue without altering it.', 0aH, 00H
	ORG $+1
$SG160777 DB	'ipl', 00H
$SG160650 DB	'Display or alter floating point registers', 00H
	ORG $+6
$SG160651 DB	'Format: "fpr [nn=xxxxxxxxxxxxxxxx]" where ''nn'' is the '
	DB	'register number', 0aH, '(0 to 15 or 0, 2, 4 or 6 depending on'
	DB	' the Control Register 0 AFP bit) and', 0aH, '''xxxxxxxxxxxxxx'
	DB	'xx'' is the register value in hexadecimal (1-16 hex digits', 0aH
	DB	'for 64-bit registers). Enter "fpr" by itself to display the r'
	DB	'egister', 0aH, 'values without altering them.', 0aH, 00H
	ORG $+3
$SG160653 DB	'Turn off instruction stepping and start all CPUs', 00H
	ORG $+3
$SG160785 DB	'ext', 00H
$SG160655 DB	'Display or alter general purpose registers', 00H
	ORG $+5
$SG160658 DB	'Read a new hercules logo file', 00H
	ORG $+2
$SG160665 DB	'Load a core image file', 00H
	ORG $+1
$SG160656 DB	'Format: "gpr [nn=xxxxxxxxxxxxxxxx]" where ''nn'' is the '
	DB	'optional', 0aH, 'register number (0 to 15) and ''xxxxxxxxxxxx'
	DB	'xxxx'' is the register', 0aH, 'value in hexadecimal (1-8 hex '
	DB	'digits for 32-bit registers or 1-16 hex', 0aH, 'digits for 64'
	DB	'-bit registers). Enter "gpr" by itself to display the', 0aH, 'r'
	DB	'egister values without altering them.', 0aH, 00H
	ORG $+3
$SG160791 DB	'store', 00H
	ORG $+2
$SG160873 DB	'sizeof', 00H
	ORG $+1
$SG160888 DB	'cf', 00H
	ORG $+1
$SG160657 DB	'herclogo', 00H
	ORG $+7
$SG160661 DB	'Display pending interrupts', 00H
	ORG $+5
$SG160663 DB	'Display cckd internal trace', 00H
$SG160704 DB	'qeth', 00H
	ORG $+7
$SG160659 DB	'Format: "herclogo [<filename>]". Load a new logo file fo'
	DB	'r 3270', 0aH, 'terminal sessions. If no filename is specified'
	DB	', the built-in logo', 0aH, 'is used instead.', 0aH, 00H
	ORG $+1
$SG160899 DB	'evm', 00H
$SG160660 DB	'ipending', 00H
	ORG $+3
$SG160826 DB	'model', 00H
	ORG $+2
$SG160896 DB	'ecpsvm', 00H
	ORG $+1
$SG160917 DB	'ssd', 00H
$SG160664 DB	'loadcore', 00H
	ORG $+7
$SG160668 DB	'Load a text deck file', 00H
	ORG $+2
$SG160666 DB	'Format: "loadcore filename [address]" where ''address'' '
	DB	'is the storage', 0aH, 'address of where to begin loading memo'
	DB	'ry. The file ''filename'' is', 0aH, 'presumed to be a pure bi'
	DB	'nary image file previously created via the', 0aH, '''savecore'
	DB	''' command. The default for ''address'' is 0 (beginning of', 0aH
	DB	'storage).', 0aH, 00H
	ORG $+3
$SG160667 DB	'loadtext', 00H
	ORG $+7
$SG160671 DB	'Set maxcpu parameter', 00H
	ORG $+3
$SG160669 DB	'Format: "loadtext filename [address]". This command is e'
	DB	'ssentially', 0aH, 'identical to the ''loadcore'' command exce'
	DB	'pt that it loads a text deck', 0aH, 'file with "TXT" and "END'
	DB	'" 80 byte records (i.e. an object deck).', 0aH, 00H
	ORG $+2
$SG160905 DB	'.reply', 00H
	ORG $+1
$SG160946 DB	'sfc', 00H
$SG160672 DB	'mounted_tape_reinit', 00H
$SG160949 DB	'sfd', 00H
$SG160673 DB	'Control tape initialization', 00H
	ORG $+4
$SG160674 DB	'Format: "mounted_tape_reinit [disallow|disable | allow|e'
	DB	'nable]"', 0aH, 'Specifies whether reinitialization of tape dr'
	DB	'ive devices', 0aH, '(via the devinit command, in order to mou'
	DB	'nt a new tape)', 0aH, 'should be allowed if there is already '
	DB	'a tape mounted on', 0aH, 'the drive. The current value is dis'
	DB	'played if no operand is', 0aH, 'specified', 0aH, 'Specifying '
	DB	'ALLOW or ENABLE indicates new tapes may be', 0aH, 'mounted (v'
	DB	'ia ''devinit nnnn new-tape-filename'') irrespective', 0aH, 'o'
	DB	'f whether or not there is already a tape mounted on the drive'
	DB	'.', 0aH, 'This is the default state.', 0aH, 'Specifying DISAL'
	DB	'LOW or DISABLE prevents new tapes from being', 0aH, 'mounted '
	DB	'if one is already mounted. When DISALLOW or DISABLE has', 0aH
	DB	'been specified and a tape is already mounted on the drive, it'
	DB	0aH, 'must first be unmounted (via the command ''devinit nnnn '
	DB	'*'') before', 0aH, 'the new tape can be mounted. Otherwise th'
	DB	'e devinit attempt to', 0aH, 'mount the new tape is rejected.', 0aH
	DB	00H
	ORG $+1
$SG160676 DB	'Set default host networking device', 00H
	ORG $+5
$SG160677 DB	'Specifies the name (or for Windows, the IP or MAC addres'
	DB	's) of the', 0aH, 'underlying default host network device to b'
	DB	'e used for all Hercules', 0aH, 'communications devices unless'
	DB	' overridden on the device statement.', 0aH, 0aH, 'The default'
	DB	' for Linux (except Apple and FreeBSD) is ''/dev/net/tun''.', 0aH
	DB	'The default for Apple and FreeBSD is ''/dev/tun''.', 0aH, 0aH
	DB	'The default for Windows is whatever SoftDevLabs''s CTCI-WIN p'
	DB	'roduct', 0aH, 'returns as its default CTCI-WIN host network a'
	DB	'dapter, which for older', 0aH, 'versions of CTCI-WIN (3.5.0) '
	DB	'is the first network adapter returned by', 0aH, 'Windows in i'
	DB	'ts adapter binding order or for newer versions of CTCI-WIN', 0aH
	DB	'(3.6.0) what you defined as your default CTCI-WIN host networ'
	DB	'k adapter.', 0aH, 00H
	ORG $+3
$SG160679 DB	'Set numcpu parameter', 00H
	ORG $+3
$SG160681 DB	'(Synonym for ''qeth'')', 00H
	ORG $+3
$SG160682 DB	'Format:  "QETH  DEBUG {ON|OFF}  [ [<devnum>|ALL] [mask .'
	DB	'..] ]"', 0aH, '         "QETH  ADDR              [<devnum>|AL'
	DB	'L]"', 0aH, 0aH, 'Enables/disables debug tracing for the QETH '
	DB	'(OSA) device groups iden-', 0aH, 'tified by <devnum>, or for '
	DB	'all QETH (OSA) device groups if <devnum> is', 0aH, 'not speci'
	DB	'fied or specified as ''ALL'', or displays all MAC addresses', 0aH
	DB	'registered with the device identified by <devnum> or for all '
	DB	'QETH (OSA)', 0aH, 'device groups if <devnum> is not specified'
	DB	' or specified as ''ALL''.  The', 0aH, 'optional ''mask'' valu'
	DB	'e may be specified more than once. Mask values are', 0aH, ''''
	DB	'Ccw'', ''DAta'', ''DRopped'', ''Expand'', ''Interupts'', ''Pa'
	DB	'cket'', ''Queues'',', 0aH, '''SBale'', ''SIga'', ''Updown'' o'
	DB	'r 0xhhhhhhhh hexadecimal value.', 0aH, 00H
	ORG $+3
$SG160829 DB	'plant', 00H
	ORG $+2
$SG160908 DB	'\reply', 00H
	ORG $+1
$SG160952 DB	'sfk', 00H
$SG160683 DB	'ostailor', 00H
	ORG $+3
$SG160875 DB	'locks', 00H
	ORG $+2
$SG160940 DB	'sf-dev', 00H
	ORG $+5
$SG160684 DB	'Tailor trace information for specific OS', 00H
	ORG $+7
$SG160685 DB	'Format: "ostailor [quiet|os/390|z/os|vm|vse|z/vse|linux|'
	DB	'opensolaris|null]".', 0aH, 'Specifies the intended operating '
	DB	'system. The effect is to reduce', 0aH, 'control panel message'
	DB	' traffic by selectively suppressing program', 0aH, 'check tra'
	DB	'ce messages which are considered normal in the specified', 0aH
	DB	'environment. The option ''quiet'' suppresses all exception me'
	DB	'ssages,', 0aH, 'whereas ''null'' suppresses none of them. The'
	DB	' other options suppress', 0aH, 'some messages and not others '
	DB	'depending on the specified o/s. Prefix', 0aH, 'values with '''
	DB	'+'' to combine them with existing values or ''-'' to exclude', 0aH
	DB	'them. SEE ALSO the ''pgmtrace'' command which allows you to f'
	DB	'urther fine', 0aH, 'tune the tracing of program interrupt exc'
	DB	'eptions.', 0aH, 00H
	ORG $+5
$SG160686 DB	'pgmtrace', 00H
	ORG $+7
$SG160687 DB	'Trace program interrupts', 00H
	ORG $+7
$SG160688 DB	'Format: "pgmtrace [-]intcode" where ''intcode'' is any v'
	DB	'alid program', 0aH, 'interruption code in the range 0x01 to 0'
	DB	'x40. Precede the interrupt', 0aH, 'code with a ''-'' to stop '
	DB	'tracing of that particular program', 0aH, 'interruption.', 0aH
	DB	00H
$SG160690 DB	'Display or alter prefix register', 00H
	ORG $+7
$SG160693 DB	'Display or alter program status word', 00H
	ORG $+3
$SG160691 DB	'Format: "pr [value]" where the optional ''value'' operan'
	DB	'd is the new', 0aH, 'prefix register value for the current CP'
	DB	'U. Enter just ''pr'' by itself', 0aH, 'to display the current'
	DB	' value. Use the''cpu'' command beforehand to choose', 0aH, 'w'
	DB	'hich processor''s prefix register should be displayed or alte'
	DB	'red.', 0aH, 00H
	ORG $+5
$SG160696 DB	'Enable/Disable PTP debugging', 00H
	ORG $+3
$SG160705 DB	'Enable/Disable QETH debugging', 00H
	ORG $+2
$SG160708 DB	'Toggle automatic refresh of panel display data', 00H
	ORG $+1
$SG160714 DB	'Resume hercules', 00H
$SG160718 DB	'Instruction stepping', 00H
	ORG $+3
$SG160694 DB	'Format: "psw [operand ...]" where ''operand ...'' is one'
	DB	' or more', 0aH, 'optional parameters which modify the content'
	DB	's of the Program Status', 0aH, 'Word:', 0aH, 0aH, '  am=24|31'
	DB	'|64           addressing mode', 0aH, '  as=ar|home|pri|sec   '
	DB	' address-space', 0aH, '  cc=n                  condition code'
	DB	'       (decimal 0 to 3)', 0aH, '  cmwp=x                C/M/W'
	DB	'/P bits         (one hex digit)', 0aH, '  ia=xxx             '
	DB	'   instruction address  (1 to 16 hex digits)', 0aH, '  pk=n  '
	DB	'                protection key       (decimal 0 to 15)', 0aH, ' '
	DB	' pm=x                  program mask         (one hex digit)', 0aH
	DB	'  sm=xx                 system mask          (2 hex digits)', 0aH
	DB	0aH, 'Enter "psw" by itself to display the current PSW without'
	DB	' altering it.', 0aH, 00H
	ORG $+3
$SG160711 DB	'Display or alter real storage', 00H
	ORG $+2
$SG160730 DB	'Run a sequence of panel commands contained in a file', 00H
	ORG $+3
$SG160697 DB	'Format:  "ptp  debug  { on | off } [ [ <devnum> | ALL ] '
	DB	'[ mask ] ]".', 0aH, 0aH, 'Enables/disables debug tracing for '
	DB	'the PTP device group', 0aH, 'identified by <devnum>, or for a'
	DB	'll PTP device groups if', 0aH, '<devnum> is not specified or '
	DB	'specified as ''ALL''.', 0aH, 00H
$SG160699 DB	'Activate or display internal trace table', 00H
	ORG $+7
$SG160716 DB	'Turn off instruction stepping', 00H
	ORG $+2
$SG160735 DB	'suspend', 00H
$SG160700 DB	'Format: "ptt [?] [events] [options] [nnnnnn]"', 0aH, 0aH
	DB	'When specified with no operands, the ptt command displays the'
	DB	' defined trace', 0aH, 'parameters and the contents of the int'
	DB	'ernal trace table.', 0aH, 0aH, 'When specified with operands,'
	DB	' the ptt command defines the trace parameters', 0aH, 'identif'
	DB	'ying which events are to be traced. When the last option is n'
	DB	'umeric,', 0aH, 'it defines the size of the trace table itself'
	DB	' and activates tracing.', 0aH, 0aH, 'Events:    (should be sp'
	DB	'ecified first, before any options are specified)', 0aH, 0aH, ' '
	DB	'    (no)log          trace internal logger events', 0aH, '   '
	DB	'  (no)tmr          trace internal timer events', 0aH, '     ('
	DB	'no)thr          trace internal threading events', 0aH, '     '
	DB	'(no)inf          trace instruction information events', 0aH, ' '
	DB	'    (no)err          trace instruction error events', 0aH, ' '
	DB	'    (no)pgm          trace program interrupt events', 0aH, ' '
	DB	'    (no)csf          trace interlocked instruction type event'
	DB	's', 0aH, '     (no)sie          trace SIE instruction events', 0aH
	DB	'     (no)sig          trace SIGP instruction events', 0aH, ' '
	DB	'    (no)io           trace I/O instruction events', 0aH, '   '
	DB	'  (no)txf          trace Transactional-Execution Facility eve'
	DB	'nts', 0aH, '     (no)lcs1         trace LCS timing events', 0aH
	DB	'     (no)lcs2         trace LCS general debugging events', 0aH
	DB	'     (no)qeth         trace QETH general debugging events', 0aH
	DB	'     (no)xxx          trace undefined/generic/custom events', 0aH
	DB	0aH, 'options:   (should be specified last, after any events a'
	DB	're specified)', 0aH, 0aH, '     ?                show current'
	DB	'ly defined trace parameters', 0aH, '     (no)lock         loc'
	DB	'k table before updating', 0aH, '     (no)tod          timesta'
	DB	'mp table entries', 0aH, '     (no)wrap         wraparound tra'
	DB	'ce table', 0aH, '     (no)dtax         dump table at exit', 0aH
	DB	'     to=nnn           automatic display timeout  (number of s'
	DB	'econds)', 0aH, '     nnnnnn           table size             '
	DB	'    (number of entries)', 0aH, 00H
	ORG $+3
$SG160702 DB	'Query device information', 00H
	ORG $+7
$SG160703 DB	'Format: "qd [devnum(s)] | [devclass]" where ''devnum(s)'''
	DB	' is either', 0aH, 'a single device number or a multiple devic'
	DB	'e number specification', 0aH, 'in the same format as used for'
	DB	' configuration file device statements,', 0aH, 'and ''devclass'
	DB	''' is either CHAN, CON, CTCA, DASD, DSP, FCP, LINE, OSA,', 0aH
	DB	'PCH, PRT, RDR, or TAPE. When no argument is given all devices'
	DB	' are shown.', 0aH, 00H
	ORG $+1
$SG160736 DB	'Suspend hercules', 00H
	ORG $+7
$SG160706 DB	'Format:  "QETH  DEBUG {ON|OFF}  [ [<devnum>|ALL] [mask .'
	DB	'..] ]"', 0aH, '         "QETH  ADDR              [<devnum>|AL'
	DB	'L]"', 0aH, 0aH, 'Enables/disables debug tracing for the QETH '
	DB	'(OSA) device groups iden-', 0aH, 'tified by <devnum>, or for '
	DB	'all QETH (OSA) device groups if <devnum> is', 0aH, 'not speci'
	DB	'fied or specified as ''ALL'', or displays all MAC addresses', 0aH
	DB	'registered with the device identified by <devnum> or for all '
	DB	'QETH (OSA)', 0aH, 'device groups if <devnum> is not specified'
	DB	' or specified as ''ALL''.  The', 0aH, 'optional ''mask'' valu'
	DB	'e may be specified more than once. Mask values are', 0aH, ''''
	DB	'Ccw'', ''DAta'', ''DRopped'', ''Expand'', ''Interupts'', ''Pa'
	DB	'cket'', ''Queues'',', 0aH, '''SBale'', ''SIga'', ''Updown'' o'
	DB	'r 0xhhhhhhhh hexadecimal value.', 0aH, 00H
	ORG $+7
$SG160709 DB	'''quiet'' either disables automatic screen refreshing if'
	DB	' it is', 0aH, 'currently enabled or enables it if it is curre'
	DB	'ntly disabled.', 0aH, 'When disabled you will no be able to s'
	DB	'ee the response of any', 0aH, 'entered commands nor any messa'
	DB	'ges issued by the system nor be', 0aH, 'able to scroll the di'
	DB	'splay, etc. Basically all screen updating', 0aH, 'is disabled'
	DB	'. Entering ''quiet'' again re-enables screen updating.', 0aH, 00H
	ORG $+3
$SG160724 DB	'Activate instruction stepping', 00H
	ORG $+2
$SG160737 DB	'symptom', 00H
$SG160712 DB	'Format: "r addr[.len]" or "r addr[-addr2]" to display up'
	DB	' to 64K', 0aH, 'of real storage, or "r addr=value" to alter u'
	DB	'p to 32 bytes of real', 0aH, 'storage, where ''value'' is eit'
	DB	'her a string of up to 32 pairs of hex digits,', 0aH, 'or a st'
	DB	'ring of up to 32 characters enclosed in single or double quot'
	DB	'es.', 0aH, 00H
	ORG $+1
$SG160738 DB	'Alias for traceopt', 00H
	ORG $+5
$SG160719 DB	'Format:', 0aH, 0aH, '     "s [ addr-addr   [ asid ]]"', 0aH
	DB	'     "s [ addr:addr   [ asid ]]"', 0aH, '     "s [ addr.lengt'
	DB	'h [ asid ]]"', 0aH, 0aH, 'Sets the instruction stepping and i'
	DB	'nstruction breaking range, which', 0aH, 'is totally separate '
	DB	'from the instruction tracing range.', 0aH, 0aH, 'With or with'
	DB	'out a range, the s command displays whether instruction', 0aH
	DB	'stepping is on or off, and the range and asid, if any.  Speci'
	DB	'fying an', 0aH, 'optional asid value causes stepping only for'
	DB	' instructions executed by', 0aH, 'that specific address space'
	DB	'; instructions executed for any other asid', 0aH, 'will not b'
	DB	'e stepped.', 0aH, 0aH, 'Note: the s command by itself does no'
	DB	't activate instruction stepping.', 0aH, 'The s+ command must '
	DB	'be used to activate instruction stepping.  Use the', 0aH, 's '
	DB	'0 command to remove a range, causing all instructions to be s'
	DB	'tepped.', 0aH, 00H
	ORG $+5
$SG160721 DB	'Query instruction stepping', 00H
	ORG $+5
$SG160722 DB	'Format: "s?" displays whether instruction stepping is on'
	DB	' or off', 0aH, 'and the range if any.', 0aH, 00H
	ORG $+1
$SG160740 DB	'Define trace-to-file parameters', 00H
$SG160745 DB	'Set tracing range or Query tracing', 00H
	ORG $+5
$SG160725 DB	'Format:  "s+ [ addr-addr [ asid ]]".  Activates instruct'
	DB	'ion stepping.', 0aH, 0aH, 'A range can be specified as for th'
	DB	'e "s" command.  If a range is not', 0aH, 'specified then any '
	DB	'previously defined range is used instead.  If there', 0aH, 'i'
	DB	's no previously defined range (or the range was specified as '
	DB	'0) then', 0aH, 'the range includes all addresses.  When an in'
	DB	'struction within the range', 0aH, 'is about to be executed, t'
	DB	'he CPU is temporarily stopped and the next', 0aH, 'instructio'
	DB	'n is displayed.  You may then examine registers and storage,', 0aH
	DB	'etc, before pressing the <enter> key to execute the instructi'
	DB	'on and stop', 0aH, 'after the next one.  Use the "g" command '
	DB	'to stop stepping and return', 0aH, 'to normal instruction pro'
	DB	'cessing instead.', 0aH, 00H
	ORG $+3
$SG160726 DB	'savecore', 00H
	ORG $+7
$SG160727 DB	'Save a core image to file', 00H
	ORG $+6
$SG160733 DB	'Shell command', 00H
	ORG $+2
$SG160760 DB	'Display or set timers update interval', 00H
	ORG $+2
$SG160728 DB	'Format: "savecore filename [{start|*}] [{end|*}]" where '
	DB	'''start'' and', 0aH, '''end'' define the starting and ending '
	DB	'addresss of the range of real', 0aH, 'storage to be saved to '
	DB	'file ''filename''. An ''*'' for either the start', 0aH, 'addr'
	DB	'ess or end address (the default) means: "the first/last byte '
	DB	'of', 0aH, 'the first/last modified page as determined by the '
	DB	'storage-key', 0aH, '''changed'' bit".', 0aH, 00H
	ORG $+2
$SG160731 DB	'Format: "script [filename [filename] ...]". Sequentially'
	DB	' executes', 0aH, 'the commands contained within the file ''fi'
	DB	'lename''. The script file', 0aH, 'may also contain "script" c'
	DB	'ommands, but the system ensures that no', 0aH, 'more than 10 '
	DB	'levels of script are invoked at any one time.', 0aH, 0aH, 'En'
	DB	'ter the command with no arguments to list all running scripts'
	DB	'.', 0aH, 00H
	ORG $+2
$SG160763 DB	'Display TLB tables', 00H
	ORG $+5
$SG160734 DB	'Format: "sh command [args...]" where ''command'' is any '
	DB	'valid shell', 0aH, 'command or the special command ''startgui'
	DB	'''. The entered command and any', 0aH, 'arguments are passed '
	DB	'as-is to the shell for processing and the results', 0aH, 'are'
	DB	' displayed on the Hercules console.', 0aH, 0aH, 'The special '
	DB	'startgui command MUST be used if the command being started', 0aH
	DB	'either directly or indirectly starts a Windows graphical user'
	DB	' interface', 0aH, '(i.e. non-command-line) program such as no'
	DB	'tepad. Failure to use startgui', 0aH, 'in such cases will han'
	DB	'g Hercules until you close/exit notepad. Note that', 0aH, 'st'
	DB	'arting a batch file which starts notepad still requires using'
	DB	' startgui.', 0aH, 'If ''foo.bat'' does: "start notepad", then'
	DB	' doing "sh foo.bat" will hang', 0aH, 'Hercules until notepad '
	DB	'exits just like doing "sh start notepad" will.', 0aH, 'Use st'
	DB	'artgui instead: "sh startgui notepad", "sh startgui foo.bat".'
	DB	0aH, 0aH, 'For security reasons execution of shell commands ar'
	DB	'e disabled by default.', 0aH, 'Enter ''help shcmdopt'' for mo'
	DB	're information.', 0aH, 00H
	ORG $+5
$SG160741 DB	'Format:', 0aH, 0aH, '   tf  [ OFF | ON ] [ "FILE=filenam'
	DB	'e" ] [ MAX=nnnS ] [ STOP | NOSTOP ]', 0aH, 0aH, 'Defines the '
	DB	'parameters for instruction and/or ccw tracing to an output', 0aH
	DB	'file. Note that this command only enables/disables tracing to'
	DB	' a file;', 0aH, 'you will still need to enable instruction an'
	DB	'd/or ccw tracing separately', 0aH, 'via the ''t+'' and/or ''t'
	DB	'+dev'' command(s).', 0aH, 0aH, 'ON or OFF enables or disables'
	DB	' tracing to a file. If ON is specified', 0aH, 'then FILE= is '
	DB	'required if not already defined by a previous command.', 0aH, 'E'
	DB	'nclose the entire option name and value within double quotes '
	DB	'if it', 0aH, 'contains any blanks (e.g. "FILE=my trace file")'
	DB	'.', 0aH, 0aH, 'MAX= specifies the desired maximum size the tr'
	DB	'ace file is allowed to', 0aH, 'grow to. Specify the value as '
	DB	'"nnnM" for megabytes or "nnnG" for', 0aH, 'gigabytes, where '''
	DB	'nnn'' is the maximum number of megabytes/gigabytes', 0aH, 'in'
	DB	' size the file is allowed to grow to. Once the maximum is rea'
	DB	'ched,', 0aH, 'both tracefile tracing as well as all instructi'
	DB	'on and ccw tracing are', 0aH, 'disabled. This prevents instru'
	DB	'ction and/or ccw tracing from continuing', 0aH, 'to be traced'
	DB	' but to the hardware panel instead once the limit has been', 0aH
	DB	'reached. Use the NOSTOP option to disable this behavior and a'
	DB	'llow the', 0aH, 'instruction and/or ccw tracing to continue, '
	DB	'but to the hardware panel', 0aH, 'instead once the limit has '
	DB	'been reached. The default is STOP/NOCONT.', 0aH, 0aH, 'OPEN/C'
	DB	'LOSE or NOCONT/CONT may be used in lieu of ON/OFF or STOP/NOS'
	DB	'TOP.', 0aH, 'Specify the command without any arguments to dis'
	DB	'play current values.', 00H
$SG160743 DB	'Turn instruction tracing OFF for all CPUs', 00H
	ORG $+6
$SG160746 DB	'Format:', 0aH, 0aH, '     "t [addr-addr]"', 0aH, '     "'
	DB	't [addr:addr]"', 0aH, '     "t [addr.length]"', 0aH, 0aH, 'Se'
	DB	'ts the instruction tracing address range, which is totally se'
	DB	'parate', 0aH, 'from the instruction stepping and breaking add'
	DB	'ress range.', 0aH, 0aH, 'With or without an address range, th'
	DB	'e ''t'' command displays whether', 0aH, 'instruction tracing '
	DB	'is on or off, and the address range, if any.', 0aH, 0aH, 'The'
	DB	' ''t'' command by itself does NOT activate instruction tracin'
	DB	'g.', 0aH, 'Use the ''t+'' command to activate instruction tra'
	DB	'cing.  Use ''t 0''', 0aH, 'to remove the address range causin'
	DB	'g all addresses to be traced.', 0aH, 00H
	ORG $+4
$SG160748 DB	'Query instruction tracing', 00H
	ORG $+6
$SG160757 DB	'Automatic instruction tracing', 00H
	ORG $+2
$SG160764 DB	'toddrag', 00H
$SG160749 DB	'Format: "t?" displays whether instruction tracing is ON '
	DB	'or OFF', 0aH, 'and the address range if any.', 0aH, 00H
	ORG $+2
$SG160751 DB	'Turn instruction tracing ON for all CPUs', 00H
	ORG $+7
$SG160752 DB	'Format:   "t+ [addr-addr]".    Activates instruction tra'
	DB	'cing.', 0aH, 0aH, 'An address range can be specified as for t'
	DB	'he "t" command, else the', 0aH, 'existing address range is us'
	DB	'ed. If there is no address range (or was', 0aH, 'specified as'
	DB	' 0) then all instructions will be traced. Please note that', 0aH
	DB	'the "t+" command affects ALL cpus.', 0aH, 00H
	ORG $+6
$SG160754 DB	'Transactional-Execution Facility tracing', 00H
	ORG $+7
$SG160765 DB	'Display or set TOD clock drag factor', 00H
	ORG $+3
$SG160755 DB	'Format:', 0aH, 0aH, '   txf  [0 | STATS | [INSTR] [U] [C'
	DB	'] [GOOD] [BAD] [TDB] [Pages|Lines]', 0aH, '        [WHY hhhhh'
	DB	'hhh] [TAC nnn] [TND nn] [CPU nnn] [FAILS nn] ]', 0aH, 0aH, 'W'
	DB	'here:', 0aH, 0aH, '   0       Disables all txf tracing.', 0aH
	DB	0aH, '   STATS   Display statistics.', 0aH, 0aH, '   INSTR   E'
	DB	'nables instruction tracing of ONLY transactions.', 0aH, '    '
	DB	'       Either ''U'' or ''C'' or both must also be specified.', 0aH
	DB	'           Default is both. Use ''t+'' to activate the tracin'
	DB	'g.', 0aH, 0aH, '   U       Enables tracing of unconstrained t'
	DB	'ransactions.', 0aH, '   C       Enables tracing of constraine'
	DB	'd transactions.', 0aH, 0aH, '   GOOD    Enables tracing of su'
	DB	'ccessful transactions.', 0aH, '           The keyword ''SUCCE'
	DB	'SS'' is also accepted.', 0aH, 0aH, '   BAD     Enables tracin'
	DB	'g of unsuccessful transactions.', 0aH, '           The keywor'
	DB	'd ''FAIL''or ''FAILURE'' is also accepted.', 0aH, 0aH, '   TD'
	DB	'B     Displays an unsuccessful transaction''s TDB.', 0aH, '  '
	DB	' PAGES   Displays a transaction''s page map information.', 0aH
	DB	'   LINES   Displays a page map''s cache line information.', 0aH
	DB	0aH, '   WHY     Trace only when why abort is any of mask hhhh'
	DB	'hhhh.', 0aH, '   TAC     Trace only when abort code = nnn.', 0aH
	DB	'   TND     Trace only when nesting depth >= nn.', 0aH, '   CP'
	DB	'U     Trace only when transaction executes on CPU nnn.', 0aH, ' '
	DB	'  FAILS   Trace only when abort count >= nn.', 0aH, 0aH, 'Ent'
	DB	'er ''txf'' by itself to display the current options. Use ''tx'
	DB	'f 0''', 0aH, 'to disable all txf tracing. If ''INSTR'' is not'
	DB	' specified then only', 0aH, 'the results of transactions are '
	DB	'traced. If any option other than', 0aH, '''U'' or ''C'' is al'
	DB	'so specified with ''INSTR'' then both instructions', 0aH, 'an'
	DB	'd transaction results are traced. Note: ''txf INSTR'' does no'
	DB	't by', 0aH, 'itself enable instruction tracing. Use the ''t+'''
	DB	' command to do that.', 0aH, 'WHY masks are #defined in source'
	DB	' file transact.h. A common WHY mask', 0aH, 'is 0xC000FFFF to '
	DB	'detect unexpected aborts.', 0aH, 00H
	ORG $+7
$SG160758 DB	'Format:  "t+-    [ BEG=<instrcount>   AMT=num ]"', 0aH, 0aH
	DB	'Automatically activates and deactivates instruction tracing b'
	DB	'ased on', 0aH, 'the values provided.', 0aH, 0aH, 'Once the sy'
	DB	'stem-wide instruction count value (displayed at the bottom', 0aH
	DB	'of the screen) becomes greater or equal to the specified ''BE'
	DB	'G='' value', 0aH, 'tracing is automatically activated (as if '
	DB	'the ''t+'' command were given)', 0aH, 'and remains active unt'
	DB	'il either at least ''AMT'' instructions are traced', 0aH, 'or'
	DB	' tracing is explicitly deactivated via the ''t-'' command.', 0aH
	DB	0aH, 'Note that instruction counts reported by Hercules are ap'
	DB	'proximate and', 0aH, 'should not be relied on for accuracy.  '
	DB	'Also note automatic tracing only', 0aH, 'checks the instructi'
	DB	'on count approximately once every 257 instructions', 0aH, 'or'
	DB	' so and introduces a performance penalty when enabled.', 0aH, 0aH
	DB	'Using either of the ''t+'' or ''t-'' commands will disable/re'
	DB	'set automatic', 0aH, 'tracing.  Enter the ''t+-'' command by '
	DB	'itself (without any arguments) to', 0aH, 'display the current'
	DB	' settings.', 0aH, 00H
	ORG $+1
$SG160759 DB	'timerint', 00H
	ORG $+7
$SG160761 DB	'Specifies the internal timers update interval, in micros'
	DB	'econds.', 0aH, 'This parameter specifies how frequently Hercu'
	DB	'les''s internal', 0aH, 'timers-update thread updates the TOD '
	DB	'Clock, CPU Timer, and other', 0aH, 'architectural related clo'
	DB	'ck/timer values.', 0aH, 0aH, 'When the z/Arch Transactional-E'
	DB	'xecution Facility (073_TRANSACT_EXEC)', 0aH, 'is not installe'
	DB	'd or enabled, the minimum and default intervals are 1', 0aH, 'a'
	DB	'nd 50 microseconds respectively, which strikes a reasonable b'
	DB	'alance', 0aH, 'between clock accuracy and overall host perfor'
	DB	'mance.', 0aH, 0aH, 'When the z/Arch Transactional-Execution F'
	DB	'acility *is* installed and', 0aH, 'enabled the minimum and de'
	DB	'fault intervals are 200 and 400 microseconds.', 0aH, 0aH, 'Th'
	DB	'e maximum allowed interval is 1000000 microseconds (one secon'
	DB	'd).', 0aH, 0aH, 'Also note that due to host system limitation'
	DB	's and/or design, some', 0aH, 'hosts may round up and/or coale'
	DB	'sce short microsecond intervals to a', 0aH, 'much longer mill'
	DB	'isecond interval instead.', 0aH, 0aH, 'CAUTION! While lower T'
	DB	'IMERINT values MAY help increase the accuracy', 0aH, 'of your'
	DB	' guest''s TOD Clock and CPU Timer values, it could also have '
	DB	'a', 0aH, 'SEVERE NEGATIVE IMPACT on host operating system per'
	DB	'formance as well.', 0aH, 'You should exercise EXTREME CAUTION'
	DB	' when choosing your TIMERINT value', 0aH, 'in relationship to'
	DB	' the actual process priority (nice value) of the', 0aH, 'Herc'
	DB	'ules process itself.', 0aH, 00H
$SG160766 DB	'traceopt', 00H
	ORG $+7
$SG160767 DB	'Instruction and/or CCW trace display option', 00H
	ORG $+4
$SG160768 DB	'Format: "TRACEOPT [TRADITIONAL|REGSFIRST|NOREGS] [NOCH9O'
	DB	'FLOW]".', 0aH, 'Determines how the registers are displayed du'
	DB	'ring instruction tracing', 0aH, 'and stepping and/or whether '
	DB	'CCW tracing of printer channel-9 overflow', 0aH, 'unit-checks'
	DB	' should be suppressed. Entering the command with no arguments'
	DB	0aH, 'displays the current settings. The default is TRADITIONA'
	DB	'L.', 0aH, 00H
	ORG $+7
$SG160770 DB	'Disassemble storage', 00H
	ORG $+4
$SG160771 DB	'Format: "u [R|V|P|H]addr[.len]" or "u [R|V|P|H]addr[-add'
	DB	'r2]" to', 0aH, 'disassemble up to 64K of storage beginning at'
	DB	' address ''addr'' for length', 0aH, '''len'' or to address '''
	DB	'addr2''. The optional R, V, P or H address prefix', 0aH, 'for'
	DB	'ces Real, Virtual, Primary, or Home Space address translation'
	DB	' mode', 0aH, 'instead of using the current PSW mode, which is'
	DB	' the default.', 0aH, 00H
	ORG $+6
$SG160773 DB	'Display or alter virtual storage', 00H
	ORG $+7
$SG160774 DB	'Format: "v [P|S|H]addr[.len]" or "v [P|S|H]addr[-addr2]"'
	DB	' to display', 0aH, 'up to 64K of virtual storage, or "v [P|S|'
	DB	'H]addr=value" to alter up to', 0aH, '32 bytes of virtual stor'
	DB	'age, where ''value'' is either a string of up to 32', 0aH, 'p'
	DB	'airs of hex digits, or a string of up to 32 characters enclos'
	DB	'ed in single', 0aH, 'or double quotes. The optional P, S or H'
	DB	' address prefix character forces', 0aH, 'Primary, Secondary o'
	DB	'r Home Space address translation mode instead of using', 0aH, 't'
	DB	'he current PSW mode, which is the default.', 0aH, 00H
$SG160776 DB	'Generate I/O attention interrupt for device', 00H
	ORG $+4
$SG160778 DB	'IPL from device or file', 00H
$SG160780 DB	'iplc', 00H
	ORG $+3
$SG160779 DB	'Format: "IPL {xxxx | cccc} [CLEAR] [LOADPARM xxxxxxxx] ['
	DB	'PARM xxx [xxx ...]]"', 0aH, 0aH, 'Performs the Initial Progra'
	DB	'm Load manual control function. If the first', 0aH, 'operand '
	DB	'''xxxx'' is a valid device number then a CCW-type IPL is init'
	DB	'iated', 0aH, 'from the specified device and SCLP disk I/O is '
	DB	'disabled.  Otherwise a ', 0aH, 'list-directed IPL is performe'
	DB	'd from the .ins file named ''cccc'', and SCLP', 0aH, 'disk I/'
	DB	'O is enabled for the directory path where the .ins file is lo'
	DB	'cated.', 0aH, 0aH, 'The optional ''CLEAR'' keyword will initi'
	DB	'ate a Load Clear manual control', 0aH, 'function prior to sta'
	DB	'rting an IPL.', 0aH, 0aH, 'The optional ''LOADPARM'' keyword '
	DB	'followed by a 1-8 character string can be', 0aH, 'used to ove'
	DB	'rride the default value defined by the ''LOADPARM'' command.', 0aH
	DB	0aH, 'An optional ''PARM'' keyword followed by string data can'
	DB	' also be used to', 0aH, 'pass data to the IPL command process'
	DB	'or. If specified the string data is', 0aH, 'loaded into the l'
	DB	'ow-order 32 bits of General Purpose registers R0 - R15', 0aH, '('
	DB	'4 characters per register for a maximum of 64 bytes total; an'
	DB	'y excess', 0aH, 'is ignored). The PARM option behaves similar'
	DB	'ly to the VM IPL command.', 0aH, 0aH, 'PLEASE NOTE that becau'
	DB	'se the ''PARM'' option supports multiple arguments,', 0aH, 'i'
	DB	'f specified, it MUST be the LAST option on the command line s'
	DB	'ince ALL', 0aH, 'remaining command line arguments following t'
	DB	'he ''PARM'' keyword will be', 0aH, 'treated as being part of '
	DB	'a single blank-separated parameter string.', 0aH, 00H
	ORG $+2
$SG160781 DB	'Command deprecated - use IPL with clear option', 00H
	ORG $+1
$SG160783 DB	'restart', 00H
$SG160782 DB	'This command is deprecated. Use "ipl" with clear option '
	DB	'specified instead.', 0aH, 00H
	ORG $+4
$SG160784 DB	'Generate restart interrupt', 00H
	ORG $+5
$SG160786 DB	'Generate external interrupt', 00H
	ORG $+4
$SG160787 DB	'startall', 00H
	ORG $+7
$SG160788 DB	'Start all CPU''s', 00H
$SG160789 DB	'stopall', 00H
$SG160790 DB	'Stop all CPU''s', 00H
	ORG $+1
$SG160792 DB	'Store CPU status at absolute zero', 00H
	ORG $+6
$SG160793 DB	'sysclear', 00H
	ORG $+7
$SG160794 DB	'System Clear Reset manual operation', 00H
$SG160871 DB	'exit', 00H
	ORG $+7
$SG160795 DB	'Performs the System Reset Clear manual control function.'
	DB	' Same as', 0aH, 'the "sysreset clear" command. Clears main st'
	DB	'orage to 0, and all', 0aH, 'registers, control registers, etc'
	DB	'.. are reset to their initial value.', 0aH, 'At this point, f'
	DB	'or architecture modes OTHER than z/Arch, the system is', 0aH, 'e'
	DB	'ssentially in the same state as it was when it was first powe'
	DB	'red on.', 0aH, 0aH, 'For z/Arch architecture mode, essentiall'
	DB	'y the same thing happens except', 0aH, 'that your architectur'
	DB	'e mode is reset to ESA/390 mode in preparation for', 0aH, 'th'
	DB	'e system being IPLed.', 00H
	ORG $+3
$SG160796 DB	'sysreset', 00H
	ORG $+7
$SG160797 DB	'System Reset manual operation', 00H
	ORG $+2
$SG160798 DB	'Performs the System Reset manual control function. Witho'
	DB	'ut any arguments', 0aH, 'or with the "normal" argument then o'
	DB	'nly a CPU and I/O subsystem reset', 0aH, 'are performed. When'
	DB	' the "clear" argument is given then this command is', 0aH, 'i'
	DB	'dentical in functionality to the "sysclear" command.', 0aH, 00H
	ORG $+3
$SG160799 DB	'cnslport', 00H
	ORG $+7
$SG160800 DB	'Set console port', 00H
	ORG $+7
$SG160801 DB	'cpuidfmt', 00H
	ORG $+7
$SG160802 DB	'Set format BASIC/0/1 STIDP generation', 00H
	ORG $+2
$SG160803 DB	'cpumodel', 00H
	ORG $+7
$SG160804 DB	'Set CPU model number', 00H
	ORG $+3
$SG160805 DB	'cpuserial', 00H
	ORG $+6
$SG160806 DB	'Set CPU serial number', 00H
	ORG $+2
$SG160807 DB	'cpuverid', 00H
	ORG $+7
$SG160808 DB	'Set CPU verion number', 00H
	ORG $+2
$SG160811 DB	'Set DIAG 8 instruction options', 00H
	ORG $+1
$SG160813 DB	'engines', 00H
$SG160809 DB	'Format: "cpuverid xx [force]" where ''xx'' is the 2 hexa'
	DB	'decimal digit', 0aH, 'CPU version code stored by the STIDP in'
	DB	'struction.', 0aH, 0aH, 'The default cpuverid version code at '
	DB	'startup is ''FD'', and that value will', 0aH, 'be stored by t'
	DB	'he STIDP instruction -- even for z/Arch -- unless and UNTIL', 0aH
	DB	'you set it to a different value via the ''cpuverid'' command/'
	DB	'statement.', 0aH, 0aH, 'If you try using the cpuverid command'
	DB	'/statement to set a non-zero cpuverid', 0aH, 'value when the '
	DB	'architecture mode is currently set to z/Arch, the version', 0aH
	DB	'code stored by the STIDP instruction will STILL be stored as '
	DB	'''00'' anyway,', 0aH, 'UNLESS ... the ''FORCE'' option is use'
	DB	'd. For z/Arch, the ''FORCE'' option is', 0aH, 'the ONLY way t'
	DB	'o cause the cpuverid command to force the STIDP instruction', 0aH
	DB	'to store a non-zero version code. (But as explained, at start'
	DB	'up, the value', 0aH, 'stored will STILL be ''FD'' even for z/'
	DB	'Arch since that is the default. This', 0aH, 'means if you wan'
	DB	't your STIDP version code to be ''00'' for z/Arch, then you', 0aH
	DB	'MUST use a ''cpuverid'' command/statement in your configurati'
	DB	'on file!)', 0aH, 00H
$SG160810 DB	'diag8cmd', 00H
	ORG $+7
$SG160814 DB	'Set engines parameter', 00H
	ORG $+2
$SG160812 DB	'Format:  "diag8cmd  [DISABLE|ENABLE]  [ECHO|NOECHO]".', 0aH
	DB	0aH, 'When ENABLE is specified the Hercules Diagnose 8 instruc'
	DB	'tion interface', 0aH, 'is enabled, allowing guests to directl'
	DB	'y issue Hercules commands via the', 0aH, 'Hercules Diagnose 8'
	DB	' instruction.  When set to DISABLE such instructions', 0aH, 'i'
	DB	'nstead cause a Specification Exception program interrupt.', 0aH
	DB	0aH, 'When ECHO is specified a message is issued to the hardwa'
	DB	're console panel', 0aH, 'when the command is about to be issu'
	DB	'ed, when the command is redisplayed,', 0aH, 'and when the com'
	DB	'mand has finished executing.  When NOECHO is specified', 0aH, 'n'
	DB	'o such audit trail messages are displayed.', 0aH, 0aH, 'NOTE:'
	DB	' Enabling this feature has security consequences. When this f'
	DB	'eature', 0aH, 'is enabled it is possible for guest operating '
	DB	'systems to issue commands', 0aH, 'directly to the host operat'
	DB	'ing system via the ''sh'' and ''exec'' commands.', 0aH, 'Use '
	DB	'the SHCMDOPT command''s NODIAG8 option to disable this abilit'
	DB	'y.', 0aH, 00H
	ORG $+3
$SG160815 DB	'lparname', 00H
	ORG $+7
$SG160816 DB	'Set LPAR name', 00H
	ORG $+2
$SG160817 DB	'Specifies the eight-character LPAR name returned by', 0aH
	DB	'DIAG X''204''. The default is HERCULES', 00H
	ORG $+7
$SG160818 DB	'lparnum', 00H
$SG160819 DB	'Set LPAR identification number', 00H
	ORG $+1
$SG160822 DB	'Define/Display mainsize parameter', 00H
	ORG $+6
$SG160820 DB	'Specifies the one- or two-digit hexadecimal LPAR identif'
	DB	'ication', 0aH, 'number stored by the STIDP instruction, or BA'
	DB	'SIC. If a one-digit', 0aH, 'hexadecimal number from 1 to F is'
	DB	' specified, then STIDP stores a', 0aH, 'format-0 CPU ID. If a'
	DB	' two-digit hexadecimal number is specified,', 0aH, 'except 10'
	DB	', then STIDP stores a format-1 CPU ID. For LPARNUM 10, ', 0aH
	DB	'STIDP uses the current CPUIDFMT setting. If LPARNUM is BASIC,'
	DB	' then', 0aH, 'STIDP stores a basic-mode CPU ID. The default L'
	DB	'PAR identification', 0aH, 'number is 1.', 0aH, 00H
	ORG $+1
$SG160821 DB	'mainsize', 00H
	ORG $+7
$SG160824 DB	'manufacturer', 00H
	ORG $+3
$SG160830 DB	'Set STSI plant code', 00H
	ORG $+4
$SG160823 DB	'Format: mainsize [ mmmm | nnnS [ lOCK | unlOCK ] ]', 0aH
	DB	'        mmmm    - define main storage size mmmm Megabytes', 0aH
	DB	0aH, '        nnnS    - define main storage size nnn S where S'
	DB	' is the', 0aH, '                  multipler:', 0aH, '        '
	DB	'          B = no multiplier', 0aH, '                  K = 2**'
	DB	'10 (kilo/kibi)', 0aH, '                  M = 2**20 (mega/mebi'
	DB	')', 0aH, '                  G = 2**30 (giga/gibi)', 0aH, '   '
	DB	'               T = 2**40 (tera/tebi)', 0aH, '                '
	DB	'  P = 2**50 (peta/pebi)', 0aH, '                  E = 2**60 ('
	DB	'exa/exbi)', 0aH, 0aH, '        lOCK    - attempt to lock stor'
	DB	'age (pages lock by host OS)', 0aH, '        unlOCK  - leave s'
	DB	'torage unlocked (pagable by host OS)', 0aH, 0aH, '      (none'
	DB	')    - display current mainsize value', 0aH, 0aH, ' Note: Mul'
	DB	'tipliers ''T'', ''P'', and ''E'' are not available on 32bit m'
	DB	'achines', 0aH, 00H
	ORG $+4
$SG160825 DB	'Set STSI manufacturer code', 00H
	ORG $+5
$SG160827 DB	'Set/Query STSI model code', 00H
	ORG $+6
$SG160828 DB	'Format:', 0aH, 0aH, '     model [hardware [capacity [per'
	DB	'manent [temporary]]]]', 0aH, 0aH, 'where:', 0aH, 0aH, '<null>'
	DB	'       specifies a query of the current model code settings.', 0aH
	DB	0aH, 'hardware     specifies the hardware model setting. Speci'
	DB	'fying an "="', 0aH, '             resets the hardware model t'
	DB	'o "EMULATOR"; specifying an', 0aH, '             "*" leaves t'
	DB	'he current hardware model setting intact.', 0aH, '           '
	DB	'  Valid characters are 0-9 and uppercase A-Z only.', 0aH, '  '
	DB	'           The default hardware model is "EMULATOR".', 0aH, 0aH
	DB	'capacity     specifies the capacity model setting. Specifying'
	DB	' an "="', 0aH, '             copies the current hardware mode'
	DB	'l; specifying an "*" ', 0aH, '             leaves the current'
	DB	' capacity model setting intact.', 0aH, '             Valid ch'
	DB	'aracters are 0-9 and uppercase A-Z only.', 0aH, '            '
	DB	' The default capacity model is "EMULATOR".', 0aH, 0aH, 'perma'
	DB	'nent    specifies the permanent model setting. Specifying an', 0aH
	DB	'             "=" copies the current capacity model; specifyin'
	DB	'g an', 0aH, '             "*" leaves the current permanent mo'
	DB	'del setting intact.', 0aH, '             Valid characters are'
	DB	' 0-9 and uppercase A-Z only.', 0aH, '             The default'
	DB	' permanent model is "" (null string).', 0aH, 0aH, 'temporary '
	DB	'   specifies the temporary model setting. Specifying an', 0aH
	DB	'             "=" copies the current permanent model; specifyi'
	DB	'ng an', 0aH, '             "*" leaves the current temporary m'
	DB	'odel setting intact.', 0aH, '             Valid characters ar'
	DB	'e 0-9 and uppercase A-Z only.', 0aH, '             The defaul'
	DB	't temporary model is "" (null string).', 0aH, 00H
	ORG $+7
$SG160831 DB	'shcmdopt', 00H
	ORG $+7
$SG160832 DB	'Set shell command options', 00H
	ORG $+6
$SG160833 DB	'Format:  "shcmdopt  [DISABLE|ENABLE]  [DIAG8|NODIAG8]".', 0aH
	DB	0aH, 'When set to DISABLE, the ''sh'' (host shell command) and'
	DB	' ''exec'' (execute', 0aH, 'Rexx script) commands are globally'
	DB	' disabled and will result in an error', 0aH, 'if entered eith'
	DB	'er directly via the hardware console or programmatically', 0aH
	DB	'via the DIAG 8 interface.', 0aH, 0aH, 'If the optional NODIAG'
	DB	'8 option is specified, then only the programmatic', 0aH, 'exe'
	DB	'cution of commands via the the Diagnose 8 interface are disab'
	DB	'led, but', 0aH, 'shell and Rexx commands entered directly via'
	DB	' the Hercules command line', 0aH, 'still work.', 0aH, 0aH, 'N'
	DB	'OTE: Enabling this feature has security consequences. When EN'
	DB	'ABLE DIAG8', 0aH, 'is specified, it''s possible for Hercules '
	DB	'guest operating systems to issue', 0aH, 'commands directly to'
	DB	' your host operating system.', 0aH, 00H
	ORG $+3
$SG160834 DB	'sysepoch', 00H
	ORG $+7
$SG160835 DB	'Set sysepoch parameter', 00H
	ORG $+1
$SG160836 DB	'sysgport', 00H
	ORG $+7
$SG160837 DB	'Define SYSG console port', 00H
	ORG $+7
$SG160838 DB	'tzoffset', 00H
	ORG $+7
$SG160839 DB	'Set tzoffset parameter', 00H
	ORG $+1
$SG160840 DB	'xpndsize', 00H
	ORG $+7
$SG160841 DB	'Define/Display xpndsize parameter', 00H
	ORG $+6
$SG160842 DB	'Format: xpndsize [ mmmm | nnnS [ lOCK | unlOCK ] ]', 0aH
	DB	'        mmmm    - define expanded storage size mmmm Megabytes'
	DB	0aH, 0aH, '        nnnS    - define expanded storage size nnn '
	DB	'S where S is the multiplier', 0aH, '                  M = 2**'
	DB	'20 (mega/mebi)', 0aH, '                  G = 2**30 (giga/gibi'
	DB	')', 0aH, '                  T = 2**40 (tera/tebi)', 0aH, 0aH, ' '
	DB	'     (none)    - display current mainsize value', 0aH, 0aH, ' '
	DB	'       lOCK    - attempt to lock storage (pages lock by host '
	DB	'OS)', 0aH, '        unlOCK  - leave storage unlocked (pagable'
	DB	' by host OS)', 0aH, 0aH, ' Note: Multiplier ''T'' is not avai'
	DB	'lable on 32bit machines', 0aH, '       Expanded storage is li'
	DB	'mited to 1G on 32bit machines', 0aH, 00H
	ORG $+6
$SG160843 DB	'yroffset', 00H
	ORG $+7
$SG160844 DB	'Set yroffset parameter', 00H
	ORG $+1
$SG160845 DB	'hercnice', 00H
	ORG $+7
$SG160846 DB	'(deprecated)', 00H
	ORG $+3
$SG160847 DB	'This command is no longer supported and and will be remo'
	DB	'ved in the future.', 0aH, 00H
	ORG $+4
$SG160848 DB	'hercprio', 00H
	ORG $+7
$SG160849 DB	'(deprecated)', 00H
	ORG $+3
$SG160850 DB	'This command is no longer supported and and will be remo'
	DB	'ved in the future.', 0aH, 00H
	ORG $+4
$SG160851 DB	'cpuprio', 00H
$SG160852 DB	'(deprecated)', 00H
	ORG $+3
$SG160854 DB	'devprio', 00H
$SG160853 DB	'This command is no longer supported and and will be remo'
	DB	'ved in the future.', 0aH, 00H
	ORG $+4
$SG160855 DB	'(deprecated)', 00H
	ORG $+3
$SG160856 DB	'This command is no longer supported and and will be remo'
	DB	'ved in the future.', 0aH, 00H
	ORG $+4
$SG160857 DB	'srvprio', 00H
$SG160858 DB	'(deprecated)', 00H
	ORG $+3
$SG160860 DB	'todprio', 00H
$SG160859 DB	'This command is no longer supported and and will be remo'
	DB	'ved in the future.', 0aH, 00H
	ORG $+4
$SG160861 DB	'(deprecated)', 00H
	ORG $+3
$SG160862 DB	'This command is no longer supported and and will be remo'
	DB	'ved in the future.', 0aH, 00H
	ORG $+4
$SG160863 DB	'archlvl', 00H
$SG160864 DB	'Set or Query current Architecture Mode', 00H
	ORG $+1
$SG160865 DB	'Format: ARCHLVL  S/370 | ESA/390 | z/ARCH', 0aH, 0aH, 'E'
	DB	'ntering the command without arguments displays the current ar'
	DB	'chitecture', 0aH, 'mode. Entering the command with an argumen'
	DB	't sets the architecture mode.', 0aH, 'To enable/disable/query'
	DB	' facilities please use the new FACILITY command.', 0aH, 00H
	ORG $+3
$SG160866 DB	'facility', 00H
	ORG $+7
$SG160867 DB	'Enable/Disable/Query z/Arch STFLE Facility bits', 00H
$SG160872 DB	'(Synonym for ''quit'')', 00H
	ORG $+3
$SG160868 DB	'Format: FACILITY  ENABLE | DISABLE   <facility> | bit   '
	DB	'[ archlvl ]', 0aH, '        FACILITY  QUERY  SHORT | LONG | R'
	DB	'AW', 0aH, '        FACILITY  QUERY  <facility> | bit | ALL', 0aH
	DB	'        FACILITY  QUERY  ENABLED | DISABLED   [ LONG ]', 0aH, 0aH
	DB	'''facility'' is the SHORT facility name to be enabled, disabl'
	DB	'ed or queried.', 0aH, 'The facility may also be specified by '
	DB	'explicit bit number or via ''BITnnn''.', 0aH, 'ALL is a synon'
	DB	'ym for SHORT. RAW displays the hex string. ENABLED displays', 0aH
	DB	'only facilities which are enabled. DISABLED shows only disabl'
	DB	'ed failities.', 0aH, 'LONG sorts the display by Long Descript'
	DB	'ion. SHORT is the default.', 0aH, 00H
	ORG $+3
$SG160869 DB	'archmode', 00H
	ORG $+7
$SG160870 DB	'Deprecated. Use the archlvl command instead', 00H
	ORG $+4
$SG160874 DB	'Display size of structures', 00H
	ORG $+5
$SG160876 DB	'Display internal locks list', 00H
$SG160884 DB	'alrf', 00H
	ORG $+7
$SG160877 DB	'Format: "locks [ALL|HELD|tid] [SORT NAME|{TID|OWNER}|{WH'
	DB	'EN|TIME|TOD}|{WHERE|LOC}]"', 0aH, 00H
	ORG $+4
$SG160878 DB	'threads', 00H
$SG160879 DB	'Display internal threads list', 00H
	ORG $+2
$SG160880 DB	'Format:  "threads [ALL|WAITING|tid] [SORT NAME|TID|{WHEN'
	DB	'|TIME|TOD}|{WHERE|LOC}]"', 0aH, 00H
	ORG $+6
$SG160881 DB	'cmpscpad', 00H
	ORG $+7
$SG160882 DB	'Set/display the CMPSC zero padding value.', 00H
	ORG $+6
$SG160885 DB	'Command deprecated. Use facility command instead', 00H
	ORG $+7
$SG160883 DB	'The CMPSCPAD command defines the zero padding storage al'
	DB	'ignment boundary', 0aH, 'for the CMPSC-Enhancement Facility. '
	DB	'It must be a power of 2 value ranging', 0aH, 'anywhere from 1'
	DB	' to 12. Enter the command with no arguments to display the', 0aH
	DB	'current value.', 0aH, 00H
	ORG $+3
$SG160886 DB	'asn_and_lx_reuse', 00H
	ORG $+7
$SG160887 DB	'Command deprecated. Use facility command instead', 00H
	ORG $+7
$SG160889 DB	'Configure current CPU online or offline', 00H
$SG160891 DB	'cfall', 00H
	ORG $+2
$SG160890 DB	'Configure current CPU online or offline:  Format->  "cf '
	DB	'[on|off]"', 0aH, 'Where the ''current'' CPU is defined as wha'
	DB	'tever CPU was defined as', 0aH, 'the panel command target cpu'
	DB	' via the "cpu" panel command. (Refer', 0aH, 'to the ''cpu'' c'
	DB	'ommand for further information) Entering ''cf'' by itself', 0aH
	DB	'simply displays the current online/offline status of the curr'
	DB	'ent cpu.', 0aH, 'Otherwise the current cpu is configured onli'
	DB	'ne or offline as', 0aH, 'specified.', 0aH, 'Use ''cfall'' to '
	DB	'configure/display all CPUs online/offline state.', 0aH, 00H
	ORG $+6
$SG160892 DB	'Configure all CPU''s online or offline', 00H
	ORG $+2
$SG160893 DB	'ecps:vm', 00H
$SG160894 DB	'Command deprecated - Use "ECPSVM"', 00H
	ORG $+6
$SG160895 DB	'This command is deprecated. Use "ecpsvm" instead.', 0aH, 00H
	ORG $+5
$SG160897 DB	'ECPS:VM Commands', 00H
	ORG $+7
$SG160900 DB	'Command deprecated - Use "ECPSVM"', 00H
	ORG $+6
$SG160898 DB	'Format: "ecpsvm". This command invokes ECPS:VM Subcomman'
	DB	'ds.', 0aH, 'Type "ecpsvm help" to see a list of available com'
	DB	'mands', 0aH, 00H
	ORG $+4
$SG160901 DB	'This command is deprecated. Use "ecpsvm" instead.', 0aH, 00H
	ORG $+5
$SG160902 DB	'!message', 00H
	ORG $+7
$SG160903 DB	'SCP priority command', 00H
	ORG $+3
$SG160909 DB	'SCP suppressed reply', 00H
	ORG $+3
$SG160904 DB	'To enter a system control program (i.e. guest operating '
	DB	'system)', 0aH, 'priority command on the Hercules console, sim'
	DB	'ply prefix the command', 0aH, 'with an exclamation point ''!'''
	DB	'.', 0aH, 00H
	ORG $+4
$SG160906 DB	'SCP reply', 00H
	ORG $+6
$SG160911 DB	'scpecho', 00H
$SG160907 DB	'To reply to a system control program (i.e. guest operati'
	DB	'ng system)', 0aH, 'prompt that gets issued to the Hercules co'
	DB	'nsole, prefix the reply', 0aH, 'with a period.', 0aH, 00H
	ORG $+3
$SG160918 DB	'Signal shutdown', 00H
$SG160920 DB	'hwldr', 00H
	ORG $+2
$SG160910 DB	'To reply to a system control program (i.e. guest operati'
	DB	'ng system)', 0aH, 'prompt that gets issued to the Hercules co'
	DB	'nsole without echoing it', 0aH, 'the console (such as when en'
	DB	'tering a password), prefix the reply', 0aH, 'with a ''\'' bac'
	DB	'kslash.', 0aH, 00H
	ORG $+2
$SG160912 DB	'Set/Display option to echo to console and history of scp'
	DB	' replys', 00H
$SG160913 DB	'Format: "scpecho [ on | off ]"', 0aH, 'When scpecho is s'
	DB	'et ON, scp commands entered on the console are', 0aH, 'echoed'
	DB	' to the console and recorded in the command history.', 0aH, 'T'
	DB	'he default is on. When scpecho is entered without any options'
	DB	',', 0aH, 'the current state is displayed. This is to help man'
	DB	'age passwords', 0aH, 'sent to the scp from being displayed an'
	DB	'd journaled.', 0aH, 00H
$SG160914 DB	'scpimply', 00H
	ORG $+7
$SG160915 DB	'Set/Display option to pass non-hercules commands to the '
	DB	'scp', 00H
	ORG $+4
$SG160916 DB	'Format: "scpimply [ on | off ]"', 0aH, 'When scpimply is'
	DB	' set ON, non-hercules commands are passed to', 0aH, 'the scp '
	DB	'if the scp has enabled receipt of scp commands. The', 0aH, 'd'
	DB	'efault is off. When scpimply is entered without any options,', 0aH
	DB	'the current state is displayed.', 0aH, 00H
$SG160923 DB	'loaddev', 00H
$SG160919 DB	'The SSD (signal shutdown) command signals an imminent hy'
	DB	'pervisor', 0aH, 'shutdown to the guest.  Guests who support t'
	DB	'his are supposed to', 0aH, 'perform a shutdown upon receiving'
	DB	' this request.', 0aH, 'An implicit ssd command is given on a '
	DB	'hercules "quit" command', 0aH, 'if the guest supports ssd.  I'
	DB	'n that case hercules shutdown will', 0aH, 'be delayed until t'
	DB	'he guest has shutdown or a 2nd quit command is', 0aH, 'given.'
	DB	' "ssd now" will signal the guest immediately, without', 0aH, 'a'
	DB	'sking for confirmation.', 0aH, 00H
	ORG $+2
$SG160921 DB	'Specify boot loader filename', 00H
	ORG $+3
$SG160924 DB	'Specify bootstrap loader IPL parameters', 00H
$SG160922 DB	'Format: "hwldr scsiboot [filename]"  Specifies the boots'
	DB	'trap loader', 0aH, '                                     to b'
	DB	'e used for FCP attached SCSI', 0aH, '                        '
	DB	'             devices.', 0aH, 00H
	ORG $+7
$SG160925 DB	'Format: "loaddev [options]"  Specifies optional paramete'
	DB	'rs to be', 0aH, '                             passed to be bo'
	DB	'otstrap loader.', 0aH, '  Valid options are:', 0aH, 0aH, '  "'
	DB	'portname [16 digit WWPN]" Fibre Channel Portname of the FCP d'
	DB	'evice', 0aH, '  "lun      [16 digit LUN]"  Fibre Channel Logi'
	DB	'cal Unit Number', 0aH, '  "bootprog [number]"        The boot'
	DB	' program number to be loaded', 0aH, '  "br_lba   [16 digit LB'
	DB	'A]"  Logical Block Address of the boot record', 0aH, '  "scpd'
	DB	'ata  [data]"          Information to be passed to the OS', 0aH
	DB	00H
	ORG $+7
$SG160926 DB	'dumpdev', 00H
$SG160927 DB	'Specify bootstrap loader DUMP parameters', 00H
	ORG $+7
$SG160928 DB	'Format: "dumpdev [options]"  Specifies optional paramete'
	DB	'rs to be', 0aH, '                             passed to be bo'
	DB	'otstrap loader.', 0aH, '  Valid options are:', 0aH, 0aH, '  "'
	DB	'portname [16 digit WWPN]" Fibre Channel Portname of the FCP d'
	DB	'evice', 0aH, '  "lun      [16 digit LUN]"  Fibre Channel Logi'
	DB	'cal Unit Number', 0aH, '  "bootprog [number]"        The boot'
	DB	' program number to be loaded', 0aH, '  "br_lba   [16 digit LB'
	DB	'A]"  Logical Block Address of the boot record', 0aH, '  "scpd'
	DB	'ata  [data]"          Information to be passed to the OS', 0aH
	DB	00H
	ORG $+7
$SG160929 DB	'f{+/-}adr', 00H
	ORG $+6
$SG160930 DB	'Mark page frame(s) as +usable/-unusable', 00H
$SG160931 DB	'Format: "f{+/-} addr[.len]" or "f{+/-} addr[-addr2]" to '
	DB	'mark an area', 0aH, 'of storage as being either +usable or -u'
	DB	'nusable where ''addr'' is absolute', 0aH, 'address of the ran'
	DB	'ge of storage to be modified. Guest operating systems', 0aH, 'c'
	DB	'an then use the B22C ''TB'' (Test Block) instruction to deter'
	DB	'mine whether', 0aH, 'a given page is usable or not and react '
	DB	'accordingly. Note that Hercules', 0aH, 'does not prevent unus'
	DB	'able frames from being used anyway. That is to say', 0aH, 'fr'
	DB	'ames marked as unusable can still be accessed normally withou'
	DB	't error.', 0aH, 'Use "f?" to display the currently defined -u'
	DB	'nusable storage range(s).', 0aH, 00H
	ORG $+2
$SG160932 DB	'o{+/-}dev', 00H
	ORG $+6
$SG160933 DB	'Turn ORB tracing ON/OFF for device', 00H
	ORG $+5
$SG160934 DB	't{+/-}dev', 00H
	ORG $+6
$SG160935 DB	'Turn ORB and CCW tracing ON/OFF for device', 00H
	ORG $+5
$SG160936 DB	't{+/-}CKD [devnum]', 00H
	ORG $+5
$SG160937 DB	'Turn Search Key tracing ON/OFF for device', 00H
	ORG $+6
$SG160938 DB	't{+/-}CPU [cpunum]', 00H
	ORG $+5
$SG160939 DB	'Turn instruction tracing ON/OFF for CPU(s)', 00H
	ORG $+5
$SG160941 DB	'Delete shadow file', 00H
	ORG $+5
$SG160942 DB	'Format: "sf- {*|dev} [MERGE|nomerge] [force]".  Removes '
	DB	'the active', 0aH, 'shadow file for the device, where dev is t'
	DB	'he device number (*=all cckd', 0aH, 'devices).', 0aH, 0aH, 'I'
	DB	'f merge is specified (the default), then the contents of the '
	DB	'current', 0aH, 'file is merged into the previous file, the cu'
	DB	'rrent file is removed, and', 0aH, 'the previous file becomes '
	DB	'the current file.  The previous file must be', 0aH, 'able to '
	DB	'be opened read-write.  If nomerge is specified then the conte'
	DB	'nts', 0aH, 'of the current shadow file is discarded and the p'
	DB	'revious file becomes the', 0aH, 'new current file.  However, '
	DB	'if the previous file is read-only then a new', 0aH, 'empty sh'
	DB	'adow file is then immediately re-added again and that new emp'
	DB	'ty', 0aH, 'shadow file then becomes the new current file.  Th'
	DB	'e force option is re-', 0aH, 'quired when doing a merge to th'
	DB	'e base file and the base file is read-only', 0aH, 'because th'
	DB	'e ''ro'' option was specified on the device config statement.'
	DB	0aH, 0aH, 'Note that because it is possible for this command t'
	DB	'o take a long time to', 0aH, 'complete (when the default MERG'
	DB	'E option is used) this command operates', 0aH, 'asynchronousl'
	DB	'y in a separate worker thread.', 0aH, 00H
$SG160943 DB	'sf+dev', 00H
	ORG $+5
$SG160944 DB	'Add shadow file', 00H
$SG160945 DB	'Format: "sf+ {*|dev}".  Creates another shadow file for '
	DB	'the device', 0aH, 'where dev is the device number (*=all cckd'
	DB	' devices).  Note that this', 0aH, 'command operates asynchron'
	DB	'ously in a separate worker thread.', 0aH, 00H
	ORG $+2
$SG160947 DB	'Compress shadow files', 00H
	ORG $+2
$SG160948 DB	'Format: "sfc {*|dev}". Compresses the active device or s'
	DB	'hadow file', 0aH, 'where dev is the device number (*=all cckd'
	DB	' devices). This command is', 0aH, 'essentially identical to t'
	DB	'he ''cckdcomp'' utility.  Note that because it''s', 0aH, 'pos'
	DB	'sible for this command to take a long time to complete it ope'
	DB	'rates', 0aH, 'asynchronously in a separate worker thread.', 0aH
	DB	00H
	ORG $+4
$SG160950 DB	'Display shadow file stats', 00H
	ORG $+6
$SG160953 DB	'Check shadow files', 00H
	ORG $+5
$SG160951 DB	'Format: "sfd {*|dev}".  Displays shadow file status and '
	DB	'statistics', 0aH, 'where dev is the device number (*=all cckd'
	DB	' devices).  Note that this', 0aH, 'command operates asynchron'
	DB	'ously in a separate worker thread.', 0aH, 00H
	ORG $+2
$SG160955 DB	'rexx', 00H
	ORG $+3
$SG160954 DB	'Format: "sfk {*|dev} [n]". Performs a chkdsk on the acti'
	DB	've shadow file', 0aH, 'where dev is the device number (*=all '
	DB	'cckd devices) and n is an optional', 0aH, 'check level (defau'
	DB	'lt is 2):', 0aH, 0aH, '   -1   devhdr, cdevhdr, l1 table.', 0aH
	DB	'    0   devhdr, cdevhdr, l1 table, l2 tables.', 0aH, '    1  '
	DB	' devhdr, cdevhdr, l1 table, l2 tables, free spaces.', 0aH, ' '
	DB	'   2   devhdr, cdevhdr, l1 table, l2 tables, free spaces, trk'
	DB	'hdrs.', 0aH, '    3   devhdr, cdevhdr, l1 table, l2 tables, f'
	DB	'ree spaces, trkimgs.', 0aH, '    4   devhdr, cdevhdr. Build e'
	DB	'verything else from recovery.', 0aH, 0aH, 'This command is es'
	DB	'sentially identical to the ''cckdcdsk'' utility.', 0aH, 'You '
	DB	'probably don''t want to use ''4'' unless you have a backup an'
	DB	'd are', 0aH, 'prepared to wait a long time.  Note that becaus'
	DB	'e this command could', 0aH, 'take a long time to complete it '
	DB	'operates asynchronously in a separate', 0aH, 'worker thread.', 0aH
	DB	00H
	ORG $+1
$SG160956 DB	'Modify/Display Hercules''s Rexx settings', 00H
$SG160958 DB	'exec', 00H
	ORG $+3
$SG160957 DB	'Format:   ''rexx [optname optvalue] ...''', 0aH, 0aH, 'E'
	DB	'na[ble]/Sta[rt]     Enable/Start a Rexx Package, where packag'
	DB	'e is', 0aH, '                     either ''OORexx'' (the defa'
	DB	'ult) or ''Regina''.', 0aH, '                     Use the HREX'
	DB	'X_PACKAGE environment variable', 0aH, '                     t'
	DB	'o define your preferred default value. "auto"', 0aH, '       '
	DB	'              will automatically start the default package.', 0aH
	DB	'                     Use "none" to prevent automatic enableme'
	DB	'nt.', 0aH, 'Disa[ble]/Sto[p]     Disable/Stop the Rexx packag'
	DB	'e.', 0aH, 0aH, 'RexxP[ath]/Path      List of directories to s'
	DB	'earch for scripts.', 0aH, '                     No default. U'
	DB	'se the HREXX_PATH environment', 0aH, '                     va'
	DB	'riable to define your preferred default.', 0aH, 'SysP[ath]   '
	DB	'         Extend the search to the System Paths too.', 0aH, ' '
	DB	'                    ''On'' (default) or ''Off''.', 0aH, 'Ext['
	DB	'ensions]         List of extensions to use when searching for'
	DB	0aH, '                     scripts. A search with no extension'
	DB	' is always', 0aH, '                     done first. The HREXX'
	DB	'_EXTENSIONS environment', 0aH, '                     can be u'
	DB	'sed to set a different default list.', 0aH, 'Suf[fixes]      '
	DB	'     Alias for ''Ext[ensions]''', 0aH, 'Resolv[er]           '
	DB	'''On'' (default): Hercules will resolve the script''s', 0aH, ' '
	DB	'                    full path. ''Off'': the script name is us'
	DB	'ed as-is.', 0aH, 'MsgL[evel]           ''Off'' (default) or '''
	DB	'On'' to disable or enable', 0aH, '                     Hercul'
	DB	'es messages HHC17503I and HHC17504I', 0aH, '                 '
	DB	'    that display a script''s return code and value', 0aH, '  '
	DB	'                   when it finishes executing.', 0aH, 'MsgP[r'
	DB	'efix]          ''Off'' (default) or ''On'' to disable or enab'
	DB	'le', 0aH, '                     prefixing Rexx script ''say'''
	DB	' messages with', 0aH, '                     Hercules message '
	DB	'number HHC17540I.', 0aH, 'ErrP[refix]          ''Off'' (defau'
	DB	'lt) or ''On'' to disable or enable', 0aH, '                  '
	DB	'   prefixing Rexx script ''TRACE'' messages with', 0aH, '    '
	DB	'                 Hercules message number HHC17541D.', 0aH, 'M'
	DB	'ode                 Define the preferred argument passing sty'
	DB	'le.', 0aH, '                     ''Com[mand]'' (default) or '''
	DB	'Sub[routine]''. Use', 0aH, '                     the HREXX_MO'
	DB	'DE environment variable to define', 0aH, '                   '
	DB	'  your preferred default mode.', 0aH, 'List                 L'
	DB	'ists all scripts currently running asynchronously.', 0aH, 'Ca'
	DB	'ncel               <tid> to halt an asynchronously running sc'
	DB	'ript.', 0aH, 0aH, 'Setting any option to ''reset'' will reset'
	DB	' the option to its default value.', 0aH, 'Entering the comman'
	DB	'd without any arguments displays the current values.', 0aH, 00H
$SG160959 DB	'Execute a Rexx script', 00H
	ORG $+2
$SG160961 DB	'qpfkeys', 00H
$SG160960 DB	'Format:    ''exec [mode] scriptname [[args...][&&]]''', 0aH
	DB	0aH, 'Where ''scriptname'' is the name of the Rexx script, ''a'
	DB	'rgs'' is an optional', 0aH, 'list of arguments to be passed t'
	DB	'o the script and ''&&'' as the last argument', 0aH, 'requests'
	DB	' the script to be run asynchronously in the background. The '''
	DB	'rexx''', 0aH, 'command can be used to list/cancel currently r'
	DB	'unning asynchronous scripts.', 0aH, 0aH, 'The argument passin'
	DB	'g style is determined by the ''rexx'' command''s current', 0aH
	DB	'''Mode'' setting. You can override it for the current executi'
	DB	'on by specifying', 0aH, 'an optional ''mode'' parameter on co'
	DB	'mmand itself, just before the scriptname:', 0aH, '''exec cmd '
	DB	'script'' for command style argument passing or ''exec sub scr'
	DB	'ipt''', 0aH, 'for subroutine style argument passing.', 0aH, 0aH
	DB	'TAKE SPECIAL CARE when using the ''&&'' option to run a scrip'
	DB	't asynchronously.', 0aH, 'Be careful to NOT accidentally ente'
	DB	'r a single ''&'' instead which invokes the', 0aH, 'Hercules '''
	DB	'exec'' command asynchronously, but NOT the rexx script, leavi'
	DB	'ng you', 0aH, 'with no way to cancel it. Always use two amper'
	DB	'sands ''&&'' to cause the script', 0aH, 'itself to run in the'
	DB	' background. Of course, if the script ends quickly then', 0aH
	DB	'there is no need to run it asynchronously in the background. '
	DB	'The ability to', 0aH, 'run scripts in the background was mean'
	DB	't for never-ending ''monitoring'' type', 0aH, 'scripts that m'
	DB	'onitor and report such things as Hercules status.', 00H
	ORG $+7
$SG160962 DB	'Display the current PF Key settings', 00H
$SG160963 DB	'defsym', 00H
	ORG $+5
$SG160964 DB	'Define symbol', 00H
	ORG $+2
$SG160965 DB	'Format: "defsym symbol [value]". Defines symbol ''symbol'
	DB	''' to contain', 0aH, 'value ''value''. The symbol can then be'
	DB	' the object of a substitution for', 0aH, 'later panel command'
	DB	's. If ''value'' contains blanks or spaces, then it', 0aH, 'mu'
	DB	'st be enclosed within quotes or apostrophes. For more detaile'
	DB	'd', 0aH, 'information regarding symbol substitution refer to '
	DB	'the ''DEFSYM''', 0aH, 'configuration file statement in Hercul'
	DB	'es documentation.', 0aH, 'Enter "defsym" by itself to display'
	DB	' the values of all defined', 0aH, 'symbols.', 0aH, 00H
$SG160966 DB	'delsym', 00H
	ORG $+1
$SG160967 DB	'Delete a symbol', 00H
$SG160968 DB	'Format: "delsym symbol". Deletes symbol ''symbol''.', 0aH
	DB	00H
	ORG $+5
$SG160969 DB	'modpath', 00H
$SG160970 DB	'Set module load path', 00H
	ORG $+3
$SG160971 DB	'Format:      MODPATH   <path>', 0aH, 0aH, 'Where <path> '
	DB	'specifies the relative or absolute path of the directory', 0aH
	DB	'where dynamic modules should be loaded from. Only one directo'
	DB	'ry may be', 0aH, 'specified. Enclose the path within double q'
	DB	'uotes if it contains blanks.', 0aH, 00H
	ORG $+3
$SG160972 DB	'ldmod', 00H
	ORG $+2
$SG160973 DB	'Load a module', 00H
	ORG $+2
$SG160974 DB	'Format: "ldmod module ..."', 0aH, 'Specifies additional '
	DB	'modules that are to be loaded by the', 0aH, 'Hercules dynamic'
	DB	' loader.', 0aH, 00H
	ORG $+1
$SG160975 DB	'lsdep', 00H
	ORG $+2
$SG160976 DB	'List module dependencies', 00H
	ORG $+3
$SG160977 DB	'lsequ', 00H
	ORG $+6
$SG160978 DB	'List device equates', 00H
$SG160979 DB	'lsmod', 00H
	ORG $+6
$SG160980 DB	'List dynamic modules', 00H
	ORG $+3
$SG160982 DB	'rmmod', 00H
	ORG $+2
$SG160981 DB	'Format:  lsmod  [ALL]', 0aH, 0aH, 'Lists all dynamically'
	DB	' loaded modules and their registered symbols,', 0aH, 'device-'
	DB	'types and instruction overrides. If ''ALL'' is specified then'
	DB	0aH, 'registered symbols which are currently unresolved are al'
	DB	'so listed.', 0aH, 00H
	ORG $+7
$SG160983 DB	'Delete a module', 00H
$SG160984 DB	'http', 00H
	ORG $+3
$SG160985 DB	'Start/Stop/Modify/Display HTTP Server', 00H
	ORG $+2
$SG160987 DB	'iodelay', 00H
$SG160986 DB	'Format: ''http [start|stop|port nnnn [[noauth]|[auth use'
	DB	'r pass]]|root path]''', 0aH, 0aH, 'start                     '
	DB	'            - starts HTTP server if stopped', 0aH, 'stop     '
	DB	'                             - stops HTTP server if started', 0aH
	DB	'port nnnn [[noauth]|[auth user pass]] - set port and optional'
	DB	' authorization.', 0aH, '                                     '
	DB	'   Default is noauthorization needed.', 0aH, '               '
	DB	'                         ''auth'' requires a user and passwor'
	DB	'd', 0aH, 0aH, 'root path                             - set th'
	DB	'e root file path name', 0aH, 0aH, '<none>                    '
	DB	'            - display status of HTTP server', 0aH, 00H
	ORG $+7
$SG160988 DB	'Display or set I/O delay value', 00H
	ORG $+1
$SG160989 DB	'Format:  "iodelay  n".', 0aH, 0aH, 'Specifies the amount'
	DB	' of time (in microseconds) to wait after an', 0aH, 'I/O inter'
	DB	'rupt is ready to be set pending. This value can also be', 0aH
	DB	'set using the Hercules console. The purpose of this parameter'
	DB	' is', 0aH, 'to bypass a bug in the Linux/390 and zLinux dasd.'
	DB	'c device driver.', 0aH, 'The problem is more apt to happen un'
	DB	'der Hercules than on a real', 0aH, 'machine because we may pr'
	DB	'esent an I/O interrupt sooner than a', 0aH, 'real machine.', 0aH
	DB	00H
	ORG $+7
$SG160990 DB	'pgmprdos', 00H
	ORG $+7
$SG160991 DB	'Set LPP license setting', 00H
$SG160997 DB	'Command deprecated - Use "SCSIMOUNT"', 00H
	ORG $+3
$SG160992 DB	'Format: "pgmprdos restricted | licensed"', 0aH, 0aH, 'No'
	DB	'te: It is YOUR responsibility to comply with the terms of the'
	DB	' license for', 0aH, '      the operating system you intend to'
	DB	' run on Hercules. If you specify', 0aH, '      LICENSED and r'
	DB	'un a licensed operating system in violation of that', 0aH, ' '
	DB	'     license, then don''t come after the Hercules developers '
	DB	'when the vendor', 0aH, '      sends their lawyers after you.', 0aH
	DB	00H
	ORG $+6
$SG160993 DB	'maxrates', 00H
	ORG $+7
$SG160994 DB	'Display highest MIPS/SIOS rate or set interval', 00H
	ORG $+1
$SG160995 DB	'Format: "maxrates [nnnn]" where ''nnnn'' is the desired '
	DB	'reporting', 0aH, 'interval in minutes or ''midnight''. Accept'
	DB	'able values are from', 0aH, '1 to 1440. The default is 1440 m'
	DB	'inutes (one day).', 0aH, 'The interval ''midnight'' sets the '
	DB	'interval to 1440 and aligns the', 0aH, 'start of the current '
	DB	'interval to midnight.', 0aH, 'Entering "maxrates" by itself d'
	DB	'isplays the current highest', 0aH, 'rates observed during the'
	DB	' defined intervals.', 0aH, 00H
	ORG $+3
$SG160996 DB	'auto_scsi_mount', 00H
$SG160998 DB	'This command is deprecated. Use "scsimount" instead.', 0aH
	DB	00H
	ORG $+2
$SG160999 DB	'scsimount', 00H
	ORG $+6
$SG161000 DB	'Automatic SCSI tape mounts', 00H
	ORG $+5
$SG161001 DB	'Format:    "scsimount [ no | yes | 0-99 ]".', 0aH, 0aH, 'D'
	DB	'isplays or modifies the automatic SCSI tape mounts option.', 0aH
	DB	0aH, 'When entered without any operands, it displays the curre'
	DB	'nt interval', 0aH, 'and any pending tape mount requests. Ente'
	DB	'ring ''no'' (or 0 seconds)', 0aH, 'disables automount detecti'
	DB	'on.', 0aH, 0aH, 'Entering a value between 1-99 seconds (or '''
	DB	'yes'') enables the option', 0aH, 'and specifies how often to '
	DB	'query SCSI tape drives to automatically', 0aH, 'detect when a'
	DB	' tape has been mounted (upon which an unsolicited', 0aH, 'dev'
	DB	'ice-attention interrupt will be presented to the guest operat'
	DB	'ing', 0aH, 'system). ''yes'' is equivalent to specifying a 5 '
	DB	'second interval.', 0aH, 00H
	ORG $+6
$SG161002 DB	'shrdport', 00H
	ORG $+7
$SG161003 DB	'Set shrdport value', 00H
	ORG $+1
$SG161005 DB	'shrd', 00H
	ORG $+7
$SG161004 DB	'Format:  "SHRDPORT   [0 | 3990 | nnnn | START | STOP]"  '
	DB	' where nnnn', 0aH, 'is the port number that the Shared Device'
	DB	' Server is to use to listen', 0aH, 'for remote connections on'
	DB	'.  The default port is 3990.  Setting shrdport', 0aH, 'to 0 s'
	DB	'tops the server and resets port number back to the default.  '
	DB	'Using', 0aH, 'the ''STOP'' command also stops the server, but'
	DB	' preserves the currently', 0aH, 'established port number so t'
	DB	'hat entering the ''START'' command will start', 0aH, 'the ser'
	DB	'ver again using the same port number.  Entering the command', 0aH
	DB	'without any argument displays the current value.', 0aH, 'SEE '
	DB	'ALSO: ''shrd'' command.', 0aH, 00H
	ORG $+1
$SG161006 DB	'shrd command', 00H
	ORG $+3
$SG161008 DB	'quit', 00H
	ORG $+3
$SG161007 DB	'Format: "SHRD [TRACE[=nnnn]|[DTAX=0|1]]" where ''nnnn'' '
	DB	'is the desired', 0aH, 'number of trace table entries, and DTA'
	DB	'X is either 0 or 1. Specifying a', 0aH, 'non-zero TRACE= valu'
	DB	'e enables debug tracing of the Shared Device Server.', 0aH, 'S'
	DB	'pecifying a value of 0 disables tracing. DTAX is a boolean tr'
	DB	'ue/false', 0aH, 'value indicating whether or not to automatic'
	DB	'ally dump the trace table', 0aH, 'when Hercules exits. Both T'
	DB	'RACE= and DTAX= must each be set individually', 0aH, 'via sep'
	DB	'arate commands. They cannot both be specified on the same com'
	DB	'mand.', 0aH, 'Entering the SHRD command by itself with no arg'
	DB	'uments displays current', 0aH, 'values. Entering "SHRD TRACE"'
	DB	' by itself (without defining any value)', 0aH, 'prints the cu'
	DB	'rrent trace table. SEE ALSO: the ''shrdport'' command.', 0aH, 00H
	ORG $+4
$SG161009 DB	'Terminate the emulator', 00H
	ORG $+1
$SG161010 DB	'Format: "quit [force]"  Terminates the emulator. If the '
	DB	'guest OS', 0aH, '                        has enabled Signal S'
	DB	'hutdown, then a', 0aH, '                        signal shutdo'
	DB	'wn request is sent to the', 0aH, '                        gue'
	DB	'st OS and termination will begin', 0aH, '                    '
	DB	'    after guest OS has shutdown.', 0aH, '              force '
	DB	'    This option will terminate the emulator', 0aH, '         '
	DB	'               immediately.', 0aH, 00H
	ORG $+5
$SG161011 DB	'quitmout', 00H
	ORG $+7
$SG161012 DB	'Define maximum guest quiesce time', 00H
	ORG $+6
$SG161013 DB	'Format: "quitmout [nnn]" Defines the maximum amount of t'
	DB	'ime in seconds', 0aH, 'you wish to wait for your guest to com'
	DB	'plete its quiesce function before', 0aH, 'proceeding with Her'
	DB	'cules shutdown processing. If the guest completes its', 0aH, 'q'
	DB	'uiesce before this time period has expired Hercules proceeds '
	DB	'immediately', 0aH, 'with its normal shutdown processing. It d'
	DB	'oes not wait for the time period', 0aH, 'to expire.', 0aH, 0aH
	DB	'If the guest fails to complete its quiesce functionality with'
	DB	'in the given', 0aH, 'time period then Hercules does not wait '
	DB	'any long and proceeds immediately', 0aH, 'to performing a nor'
	DB	'mal shutdown of the emulator.', 0aH, 0aH, 'Specify ''0'' to i'
	DB	'ndicate you wish to always wait for the guest to complete', 0aH
	DB	'its quiesce functionality before shutting down the emulator n'
	DB	'o matter how', 0aH, 'long it may take (i.e. wait forever for '
	DB	'the guest to quiesce).', 0aH, 0aH, 'Enter the command with no'
	DB	' operand to display the current value.', 0aH, 0aH, 'NOTE: set'
	DB	'ting a quit timeout value only makes sense if you are running'
	DB	' a', 0aH, 'guest that supports the Signal Shutdown hypervisor'
	DB	' signal. Not all guests', 0aH, 'support such signals. zLinux '
	DB	'and z/VM do, but z/OS for example does not.', 0aH, 00H
$SG161014 DB	'tt32', 00H
	ORG $+3
$SG161015 DB	'Control/query CTCI-WIN functionality', 00H
	ORG $+3
$SG161016 DB	'Format:  "tt32   debug | nodebug | stats <devnum>".', 0aH
	DB	0aH, 'Enables or disables global CTCI-WIN debug tracing', 0aH, 'o'
	DB	'r displays TunTap32 stats for the specified CTC device.', 0aH
	DB	00H
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	InternalHercCmd
PUBLIC	HercCmdLine
PUBLIC	CallHercCmd
PUBLIC	the_real_panel_command
PUBLIC	bgcmd_thread
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp_isspace:PROC
EXTRN	strchr:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_qsort:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_locks_cmd:PROC
EXTRN	__imp_threads_cmd:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_ptt_cmd:PROC
EXTRN	__imp_resolve_symbol_string:PROC
EXTRN	__imp_set_symbol:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_rtrim:PROC
EXTRN	__imp_parse_args:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_cachestats_cmd:PROC
EXTRN	__imp_shrd_cmd:PROC
EXTRN	is_diag_instr:PROC
EXTRN	scp_command:PROC
EXTRN	can_send_command:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	history_add:PROC
EXTRN	OnOffCommand:PROC
EXTRN	sf_cmd:PROC
EXTRN	FindSCRCTL:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_panel_command:QWORD
EXTRN	__imp_system_command:QWORD
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG161090 DB	01H DUP (?)
	ALIGN	4

$SG161092 DB	01H DUP (?)
	ALIGN	4

?didinit@?1??HelpCommand@@9@9 DD 01H DUP (?)		; `HelpCommand'::`2'::didinit
$SG161352 DB	01H DUP (?)
	ALIGN	4

$SG161379 DB	01H DUP (?)
	ALIGN	4

$SG161389 DB	01H DUP (?)
	ALIGN	4

$SG161397 DB	01H DUP (?)
	ALIGN	4

$SG161419 DB	01H DUP (?)
	ALIGN	4

$SG161429 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$InternalHercCmd DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$InternalHercCmd
$pdata$HercCmdLine DD imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$HercCmdLine
$pdata$CallHercCmd DD imagerel $LN51
	DD	imagerel $LN51+2180
	DD	imagerel $unwind$CallHercCmd
$pdata$the_real_panel_command DD imagerel $LN52
	DD	imagerel $LN52+1457
	DD	imagerel $unwind$the_real_panel_command
$pdata$zapcmd_cmd DD imagerel $LN29
	DD	imagerel $LN29+1099
	DD	imagerel $unwind$zapcmd_cmd
$pdata$HelpCommand DD imagerel $LN54
	DD	imagerel $LN54+3347
	DD	imagerel $unwind$HelpCommand
$pdata$call_cachestats_cmd DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$call_cachestats_cmd
$pdata$call_ptt_cmd DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$call_ptt_cmd
$pdata$call_locks_cmd DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$call_locks_cmd
$pdata$call_threads_cmd DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$call_threads_cmd
$pdata$call_shrd_cmd DD imagerel $LN3
	DD	imagerel $LN3+43
	DD	imagerel $unwind$call_shrd_cmd
$pdata$bgcmd_thread DD imagerel $LN3
	DD	imagerel $LN3+174
	DD	imagerel $unwind$bgcmd_thread
$pdata$DoCallHercCmdLine DD imagerel DoCallHercCmdLine
	DD	imagerel DoCallHercCmdLine+752
	DD	imagerel $unwind$DoCallHercCmdLine
$pdata$SortCmdTab DD imagerel SortCmdTab
	DD	imagerel SortCmdTab+155
	DD	imagerel $unwind$SortCmdTab
$pdata$EchoHercCmdLine DD imagerel EchoHercCmdLine
	DD	imagerel EchoHercCmdLine+165
	DD	imagerel $unwind$EchoHercCmdLine
pdata	ENDS
_DATA	SEGMENT
	ORG $+15
cmdtab	DQ	FLAT:$SG160477
	DQ	FLAT:$SG160478
	DQ	0000000000000000H
	DQ	FLAT:locate_cmd
	DQ	0000000000000004H
	DB	064H
	ORG $+7
	DQ	FLAT:$SG160479
	DQ	FLAT:$SG160480
	DQ	FLAT:$SG160481
	DQ	FLAT:$runtest_cmd
	DQ	0000000000000000H
	DB	064H
	ORG $+7
	DQ	FLAT:$SG160482
	DQ	FLAT:$SG160483
	DQ	FLAT:$SG160484
	DQ	FLAT:$test_cmd
	DQ	0000000000000000H
	DB	064H
	ORG $+7
	DQ	FLAT:$SG160485
	DQ	FLAT:$SG160486
	DQ	FLAT:$SG160487
	DQ	FLAT:zapcmd_cmd
	DQ	0000000000000004H
	DB	064H
	ORG $+7
	DQ	FLAT:$SG160488
	DQ	FLAT:$SG160489
	DQ	FLAT:$SG160490
	DQ	FLAT:cckd_cmd
	DQ	0000000000000000H
	DB	010H
	ORG $+7
	DQ	FLAT:$SG160491
	DQ	FLAT:$SG160492
	DQ	FLAT:$SG160493
	DQ	FLAT:devtmax_cmd
	DQ	0000000000000000H
	DB	010H
	ORG $+7
	DQ	FLAT:$SG160494
	DQ	FLAT:$SG160495
	DQ	0000000000000000H
	DQ	FLAT:legacysenseid_cmd
	DQ	0000000000000009H
	DB	010H
	ORG $+7
	DQ	FLAT:$SG160496
	DQ	FLAT:$SG160497
	DQ	FLAT:$SG160498
	DQ	FLAT:sclproot_cmd
	DQ	0000000000000000H
	DB	010H
	ORG $+7
	DQ	FLAT:$SG160499
	DQ	FLAT:$SG160500
	DQ	0000000000000000H
	DQ	FLAT:comment_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160501
	DQ	FLAT:$SG160502
	DQ	0000000000000000H
	DQ	FLAT:comment_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160503
	DQ	FLAT:$SG160504
	DQ	0000000000000000H
	DQ	FLAT:HelpCommand
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160505
	DQ	FLAT:$SG160506
	DQ	FLAT:$SG160507
	DQ	FLAT:cmdlvl_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160508
	DQ	FLAT:$SG160509
	DQ	FLAT:$SG160510
	DQ	FLAT:cmdsep_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160511
	DQ	FLAT:$SG160512
	DQ	FLAT:$SG160513
	DQ	FLAT:HelpCommand
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160514
	DQ	FLAT:$SG160515
	DQ	FLAT:$SG160516
	DQ	FLAT:History
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160517
	DQ	FLAT:$SG160518
	DQ	FLAT:$SG160519
	DQ	FLAT:msg_cmd
	DQ	0000000000000001H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160520
	DQ	FLAT:$SG160521
	DQ	0000000000000000H
	DQ	FLAT:msg_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160522
	DQ	FLAT:$SG160523
	DQ	FLAT:$SG160524
	DQ	FLAT:msglevel_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160525
	DQ	FLAT:$SG160526
	DQ	0000000000000000H
	DQ	FLAT:msglevel_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160527
	DQ	FLAT:$SG160528
	DQ	0000000000000000H
	DQ	FLAT:msg_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160529
	DQ	FLAT:$SG160530
	DQ	0000000000000000H
	DQ	FLAT:uptime_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160531
	DQ	FLAT:$SG160532
	DQ	0000000000000000H
	DQ	FLAT:version_cmd
	DQ	0000000000000000H
	DB	07fH
	ORG $+7
	DQ	FLAT:$SG160533
	DQ	FLAT:$SG160534
	DQ	FLAT:$SG160535
	DQ	FLAT:attach_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160536
	DQ	FLAT:$SG160537
	DQ	FLAT:$SG160538
	DQ	FLAT:cpu_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160539
	DQ	FLAT:$SG160540
	DQ	FLAT:$SG160541
	DQ	FLAT:define_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160542
	DQ	FLAT:$SG160543
	DQ	FLAT:$SG160544
	DQ	FLAT:detach_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160545
	DQ	FLAT:$SG160546
	DQ	FLAT:$SG160547
	DQ	FLAT:devinit_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160548
	DQ	FLAT:$SG160549
	DQ	FLAT:$SG160550
	DQ	FLAT:devlist_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160551
	DQ	FLAT:$SG160552
	DQ	FLAT:$SG160553
	DQ	FLAT:fcb_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160554
	DQ	FLAT:$SG160555
	DQ	FLAT:$SG160556
	DQ	FLAT:cctape_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160557
	DQ	FLAT:$SG160558
	DQ	FLAT:$SG160559
	DQ	FLAT:loadparm_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160560
	DQ	FLAT:$SG160561
	DQ	FLAT:$SG160562
	DQ	FLAT:log_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160563
	DQ	FLAT:$SG160564
	DQ	FLAT:$SG160565
	DQ	FLAT:logopt_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160566
	DQ	FLAT:$SG160567
	DQ	FLAT:$SG160568
	DQ	FLAT:mt_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160569
	DQ	FLAT:$SG160570
	DQ	FLAT:$SG160571
	DQ	FLAT:panopt_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160572
	DQ	FLAT:$SG160573
	DQ	0000000000000000H
	DQ	FLAT:panrate_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160574
	DQ	FLAT:$SG160575
	DQ	0000000000000000H
	DQ	FLAT:pantitle_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160576
	DQ	FLAT:$SG160577
	DQ	FLAT:$SG160578
	DQ	FLAT:qcpuid_cmd
	DQ	0000000000000005H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160579
	DQ	FLAT:$SG160580
	DQ	0000000000000000H
	DQ	FLAT:qpid_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160581
	DQ	FLAT:$SG160582
	DQ	0000000000000000H
	DQ	FLAT:qports_cmd
	DQ	0000000000000005H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160583
	DQ	FLAT:$SG160584
	DQ	0000000000000000H
	DQ	FLAT:qproc_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160585
	DQ	FLAT:$SG160586
	DQ	0000000000000000H
	DQ	FLAT:qstor_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160587
	DQ	FLAT:$SG160588
	DQ	FLAT:$SG160589
	DQ	FLAT:start_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160590
	DQ	FLAT:$SG160591
	DQ	FLAT:$SG160592
	DQ	FLAT:stop_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160593
	DQ	FLAT:$SG160594
	DQ	FLAT:$SG160595
	DQ	FLAT:abs_or_r_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160596
	DQ	FLAT:$SG160597
	DQ	0000000000000000H
	DQ	FLAT:aea_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160598
	DQ	FLAT:$SG160599
	DQ	0000000000000000H
	DQ	FLAT:aia_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160600
	DQ	FLAT:$SG160601
	DQ	0000000000000000H
	DQ	FLAT:ar_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160602
	DQ	FLAT:$SG160603
	DQ	FLAT:$SG160604
	DQ	FLAT:autoinit_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160605
	DQ	FLAT:$SG160606
	DQ	FLAT:$SG160607
	DQ	FLAT:automount_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160608
	DQ	FLAT:$SG160609
	DQ	0000000000000000H
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160610
	DQ	FLAT:$SG160611
	DQ	FLAT:$SG160612
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160613
	DQ	FLAT:$SG160614
	DQ	0000000000000000H
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160615
	DQ	FLAT:$SG160616
	DQ	0000000000000000H
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160617
	DQ	FLAT:$SG160618
	DQ	FLAT:$SG160619
	DQ	FLAT:bear_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160620
	DQ	FLAT:$SG160621
	DQ	0000000000000000H
	DQ	FLAT:call_cachestats_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160622
	DQ	FLAT:$SG160623
	DQ	0000000000000000H
	DQ	FLAT:clocks_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160624
	DQ	FLAT:$SG160625
	DQ	FLAT:$SG160626
	DQ	FLAT:codepage_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160627
	DQ	FLAT:$SG160628
	DQ	FLAT:$SG160629
	DQ	FLAT:conkpalv_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160630
	DQ	FLAT:$SG160631
	DQ	FLAT:$SG160632
	DQ	FLAT:cp_updt_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160633
	DQ	FLAT:$SG160634
	DQ	FLAT:$SG160635
	DQ	FLAT:cr_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160636
	DQ	FLAT:$SG160637
	DQ	FLAT:$SG160638
	DQ	FLAT:cscript_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160639
	DQ	FLAT:$SG160640
	DQ	FLAT:$SG160641
	DQ	FLAT:ctc_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160642
	DQ	FLAT:$SG160643
	DQ	0000000000000000H
	DQ	FLAT:ds_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160644
	DQ	FLAT:$SG160645
	DQ	0000000000000000H
	DQ	FLAT:fquest_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160646
	DQ	FLAT:$SG160647
	DQ	FLAT:$SG160648
	DQ	FLAT:fpc_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160649
	DQ	FLAT:$SG160650
	DQ	FLAT:$SG160651
	DQ	FLAT:fpr_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160652
	DQ	FLAT:$SG160653
	DQ	0000000000000000H
	DQ	FLAT:g_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160654
	DQ	FLAT:$SG160655
	DQ	FLAT:$SG160656
	DQ	FLAT:gpr_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160657
	DQ	FLAT:$SG160658
	DQ	FLAT:$SG160659
	DQ	FLAT:herclogo_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160660
	DQ	FLAT:$SG160661
	DQ	0000000000000000H
	DQ	FLAT:ipending_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160662
	DQ	FLAT:$SG160663
	DQ	0000000000000000H
	DQ	FLAT:k_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160664
	DQ	FLAT:$SG160665
	DQ	FLAT:$SG160666
	DQ	FLAT:loadcore_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160667
	DQ	FLAT:$SG160668
	DQ	FLAT:$SG160669
	DQ	FLAT:loadtext_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160670
	DQ	FLAT:$SG160671
	DQ	0000000000000000H
	DQ	FLAT:maxcpu_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160672
	DQ	FLAT:$SG160673
	DQ	FLAT:$SG160674
	DQ	FLAT:mounted_tape_reinit_cmd
	DQ	0000000000000009H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160675
	DQ	FLAT:$SG160676
	DQ	FLAT:$SG160677
	DQ	FLAT:netdev_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160678
	DQ	FLAT:$SG160679
	DQ	0000000000000000H
	DQ	FLAT:numcpu_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160680
	DQ	FLAT:$SG160681
	DQ	FLAT:$SG160682
	DQ	FLAT:qeth_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160683
	DQ	FLAT:$SG160684
	DQ	FLAT:$SG160685
	DQ	FLAT:ostailor_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160686
	DQ	FLAT:$SG160687
	DQ	FLAT:$SG160688
	DQ	FLAT:pgmtrace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160689
	DQ	FLAT:$SG160690
	DQ	FLAT:$SG160691
	DQ	FLAT:pr_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160692
	DQ	FLAT:$SG160693
	DQ	FLAT:$SG160694
	DQ	FLAT:psw_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160695
	DQ	FLAT:$SG160696
	DQ	FLAT:$SG160697
	DQ	FLAT:ptp_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160698
	DQ	FLAT:$SG160699
	DQ	FLAT:$SG160700
	DQ	FLAT:call_ptt_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160701
	DQ	FLAT:$SG160702
	DQ	FLAT:$SG160703
	DQ	FLAT:qd_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160704
	DQ	FLAT:$SG160705
	DQ	FLAT:$SG160706
	DQ	FLAT:qeth_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160707
	DQ	FLAT:$SG160708
	DQ	FLAT:$SG160709
	DQ	FLAT:quiet_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160710
	DQ	FLAT:$SG160711
	DQ	FLAT:$SG160712
	DQ	FLAT:abs_or_r_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160713
	DQ	FLAT:$SG160714
	DQ	0000000000000000H
	DQ	FLAT:resume_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160715
	DQ	FLAT:$SG160716
	DQ	0000000000000000H
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160717
	DQ	FLAT:$SG160718
	DQ	FLAT:$SG160719
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160720
	DQ	FLAT:$SG160721
	DQ	FLAT:$SG160722
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160723
	DQ	FLAT:$SG160724
	DQ	FLAT:$SG160725
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160726
	DQ	FLAT:$SG160727
	DQ	FLAT:$SG160728
	DQ	FLAT:savecore_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160729
	DQ	FLAT:$SG160730
	DQ	FLAT:$SG160731
	DQ	FLAT:script_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160732
	DQ	FLAT:$SG160733
	DQ	FLAT:$SG160734
	DQ	FLAT:sh_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160735
	DQ	FLAT:$SG160736
	DQ	0000000000000000H
	DQ	FLAT:suspend_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160737
	DQ	FLAT:$SG160738
	DQ	0000000000000000H
	DQ	FLAT:traceopt_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160739
	DQ	FLAT:$SG160740
	DQ	FLAT:$SG160741
	DQ	FLAT:tf_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160742
	DQ	FLAT:$SG160743
	DQ	0000000000000000H
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160744
	DQ	FLAT:$SG160745
	DQ	FLAT:$SG160746
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160747
	DQ	FLAT:$SG160748
	DQ	FLAT:$SG160749
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160750
	DQ	FLAT:$SG160751
	DQ	FLAT:$SG160752
	DQ	FLAT:trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160753
	DQ	FLAT:$SG160754
	DQ	FLAT:$SG160755
	DQ	FLAT:txf_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160756
	DQ	FLAT:$SG160757
	DQ	FLAT:$SG160758
	DQ	FLAT:auto_trace_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160759
	DQ	FLAT:$SG160760
	DQ	FLAT:$SG160761
	DQ	FLAT:timerint_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160762
	DQ	FLAT:$SG160763
	DQ	0000000000000000H
	DQ	FLAT:tlb_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160764
	DQ	FLAT:$SG160765
	DQ	0000000000000000H
	DQ	FLAT:toddrag_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160766
	DQ	FLAT:$SG160767
	DQ	FLAT:$SG160768
	DQ	FLAT:traceopt_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160769
	DQ	FLAT:$SG160770
	DQ	FLAT:$SG160771
	DQ	FLAT:u_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160772
	DQ	FLAT:$SG160773
	DQ	FLAT:$SG160774
	DQ	FLAT:v_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160775
	DQ	FLAT:$SG160776
	DQ	0000000000000000H
	DQ	FLAT:i_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160777
	DQ	FLAT:$SG160778
	DQ	FLAT:$SG160779
	DQ	FLAT:ipl_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160780
	DQ	FLAT:$SG160781
	DQ	FLAT:$SG160782
	DQ	FLAT:iplc_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160783
	DQ	FLAT:$SG160784
	DQ	0000000000000000H
	DQ	FLAT:restart_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160785
	DQ	FLAT:$SG160786
	DQ	0000000000000000H
	DQ	FLAT:ext_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160787
	DQ	FLAT:$SG160788
	DQ	0000000000000000H
	DQ	FLAT:startall_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160789
	DQ	FLAT:$SG160790
	DQ	0000000000000000H
	DQ	FLAT:stopall_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160791
	DQ	FLAT:$SG160792
	DQ	0000000000000000H
	DQ	FLAT:store_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160793
	DQ	FLAT:$SG160794
	DQ	FLAT:$SG160795
	DQ	FLAT:sysclear_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160796
	DQ	FLAT:$SG160797
	DQ	FLAT:$SG160798
	DQ	FLAT:sysreset_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160799
	DQ	FLAT:$SG160800
	DQ	0000000000000000H
	DQ	FLAT:cnslport_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160801
	DQ	FLAT:$SG160802
	DQ	0000000000000000H
	DQ	FLAT:cpuidfmt_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160803
	DQ	FLAT:$SG160804
	DQ	0000000000000000H
	DQ	FLAT:cpumodel_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160805
	DQ	FLAT:$SG160806
	DQ	0000000000000000H
	DQ	FLAT:cpuserial_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160807
	DQ	FLAT:$SG160808
	DQ	FLAT:$SG160809
	DQ	FLAT:cpuverid_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160810
	DQ	FLAT:$SG160811
	DQ	FLAT:$SG160812
	DQ	FLAT:diag8_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160813
	DQ	FLAT:$SG160814
	DQ	0000000000000000H
	DQ	FLAT:engines_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160815
	DQ	FLAT:$SG160816
	DQ	FLAT:$SG160817
	DQ	FLAT:lparname_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160818
	DQ	FLAT:$SG160819
	DQ	FLAT:$SG160820
	DQ	FLAT:lparnum_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160821
	DQ	FLAT:$SG160822
	DQ	FLAT:$SG160823
	DQ	FLAT:mainsize_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160824
	DQ	FLAT:$SG160825
	DQ	0000000000000000H
	DQ	FLAT:stsi_manufacturer_cmd
	DQ	0000000000000008H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160826
	DQ	FLAT:$SG160827
	DQ	FLAT:$SG160828
	DQ	FLAT:stsi_model_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160829
	DQ	FLAT:$SG160830
	DQ	0000000000000000H
	DQ	FLAT:stsi_plant_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160831
	DQ	FLAT:$SG160832
	DQ	FLAT:$SG160833
	DQ	FLAT:shcmdopt_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160834
	DQ	FLAT:$SG160835
	DQ	0000000000000000H
	DQ	FLAT:sysepoch_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160836
	DQ	FLAT:$SG160837
	DQ	0000000000000000H
	DQ	FLAT:sysgport_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160838
	DQ	FLAT:$SG160839
	DQ	0000000000000000H
	DQ	FLAT:tzoffset_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160840
	DQ	FLAT:$SG160841
	DQ	FLAT:$SG160842
	DQ	FLAT:xpndsize_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160843
	DQ	FLAT:$SG160844
	DQ	0000000000000000H
	DQ	FLAT:yroffset_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160845
	DQ	FLAT:$SG160846
	DQ	FLAT:$SG160847
	DQ	FLAT:hercnice_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160848
	DQ	FLAT:$SG160849
	DQ	FLAT:$SG160850
	DQ	FLAT:hercprio_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160851
	DQ	FLAT:$SG160852
	DQ	FLAT:$SG160853
	DQ	FLAT:cpuprio_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160854
	DQ	FLAT:$SG160855
	DQ	FLAT:$SG160856
	DQ	FLAT:devprio_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160857
	DQ	FLAT:$SG160858
	DQ	FLAT:$SG160859
	DQ	FLAT:srvprio_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160860
	DQ	FLAT:$SG160861
	DQ	FLAT:$SG160862
	DQ	FLAT:todprio_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160863
	DQ	FLAT:$SG160864
	DQ	FLAT:$SG160865
	DQ	FLAT:archlvl_cmd
	DQ	0000000000000000H
	DB	0f6H
	ORG $+7
	DQ	FLAT:$SG160866
	DQ	FLAT:$SG160867
	DQ	FLAT:$SG160868
	DQ	FLAT:facility_cmd
	DQ	0000000000000003H
	DB	0f6H
	ORG $+7
	DQ	FLAT:$SG160869
	DQ	FLAT:$SG160870
	DQ	0000000000000000H
	DQ	FLAT:archlvl_cmd
	DQ	0000000000000000H
	DB	0f6H
	ORG $+7
	DQ	FLAT:$SG160871
	DQ	FLAT:$SG160872
	DQ	0000000000000000H
	DQ	FLAT:quit_cmd
	DQ	0000000000000000H
	DB	0ffH
	ORG $+7
	DQ	FLAT:$SG160873
	DQ	FLAT:$SG160874
	DQ	0000000000000000H
	DQ	FLAT:sizeof_cmd
	DQ	0000000000000000H
	DB	072H
	ORG $+7
	DQ	FLAT:$SG160875
	DQ	FLAT:$SG160876
	DQ	FLAT:$SG160877
	DQ	FLAT:call_locks_cmd
	DQ	0000000000000000H
	DB	024H
	ORG $+7
	DQ	FLAT:$SG160878
	DQ	FLAT:$SG160879
	DQ	FLAT:$SG160880
	DQ	FLAT:call_threads_cmd
	DQ	0000000000000000H
	DB	024H
	ORG $+7
	DQ	FLAT:$SG160881
	DQ	FLAT:$SG160882
	DQ	FLAT:$SG160883
	DQ	FLAT:cmpscpad_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160884
	DQ	FLAT:$SG160885
	DQ	0000000000000000H
	DQ	FLAT:alrf_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160886
	DQ	FLAT:$SG160887
	DQ	0000000000000000H
	DQ	FLAT:alrf_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160888
	DQ	FLAT:$SG160889
	DQ	FLAT:$SG160890
	DQ	FLAT:cf_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160891
	DQ	FLAT:$SG160892
	DQ	0000000000000000H
	DQ	FLAT:cfall_cmd
	DQ	0000000000000000H
	DB	0f7H
	ORG $+7
	DQ	FLAT:$SG160893
	DQ	FLAT:$SG160894
	DQ	FLAT:$SG160895
	DQ	FLAT:ecpsvm_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160896
	DQ	FLAT:$SG160897
	DQ	FLAT:$SG160898
	DQ	FLAT:ecpsvm_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160899
	DQ	FLAT:$SG160900
	DQ	FLAT:$SG160901
	DQ	FLAT:ecpsvm_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160902
	DQ	FLAT:$SG160903
	DQ	FLAT:$SG160904
	DQ	FLAT:g_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160905
	DQ	FLAT:$SG160906
	DQ	FLAT:$SG160907
	DQ	FLAT:g_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160908
	DQ	FLAT:$SG160909
	DQ	FLAT:$SG160910
	DQ	FLAT:g_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160911
	DQ	FLAT:$SG160912
	DQ	FLAT:$SG160913
	DQ	FLAT:scpecho_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160914
	DQ	FLAT:$SG160915
	DQ	FLAT:$SG160916
	DQ	FLAT:scpimply_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160917
	DQ	FLAT:$SG160918
	DQ	FLAT:$SG160919
	DQ	FLAT:ssd_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160920
	DQ	FLAT:$SG160921
	DQ	FLAT:$SG160922
	DQ	FLAT:hwldr_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160923
	DQ	FLAT:$SG160924
	DQ	FLAT:$SG160925
	DQ	FLAT:lddev_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160926
	DQ	FLAT:$SG160927
	DQ	FLAT:$SG160928
	DQ	FLAT:lddev_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160929
	DQ	FLAT:$SG160930
	DQ	FLAT:$SG160931
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160932
	DQ	FLAT:$SG160933
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160934
	DQ	FLAT:$SG160935
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160936
	DQ	FLAT:$SG160937
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160938
	DQ	FLAT:$SG160939
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160940
	DQ	FLAT:$SG160941
	DQ	FLAT:$SG160942
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160943
	DQ	FLAT:$SG160944
	DQ	FLAT:$SG160945
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160946
	DQ	FLAT:$SG160947
	DQ	FLAT:$SG160948
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160949
	DQ	FLAT:$SG160950
	DQ	FLAT:$SG160951
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160952
	DQ	FLAT:$SG160953
	DQ	FLAT:$SG160954
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160955
	DQ	FLAT:$SG160956
	DQ	FLAT:$SG160957
	DQ	FLAT:rexx_cmd
	DQ	0000000000000000H
	DB	010H
	ORG $+7
	DQ	FLAT:$SG160958
	DQ	FLAT:$SG160959
	DQ	FLAT:$SG160960
	DQ	FLAT:exec_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160961
	DQ	FLAT:$SG160962
	DQ	0000000000000000H
	DQ	FLAT:qpfkeys_cmd
	DQ	0000000000000003H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160963
	DQ	FLAT:$SG160964
	DQ	FLAT:$SG160965
	DQ	FLAT:defsym_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160966
	DQ	FLAT:$SG160967
	DQ	FLAT:$SG160968
	DQ	FLAT:delsym_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160969
	DQ	FLAT:$SG160970
	DQ	FLAT:$SG160971
	DQ	FLAT:modpath_cmd
	DQ	0000000000000000H
	DB	010H
	ORG $+7
	DQ	FLAT:$SG160972
	DQ	FLAT:$SG160973
	DQ	FLAT:$SG160974
	DQ	FLAT:ldmod_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160975
	DQ	FLAT:$SG160976
	DQ	0000000000000000H
	DQ	FLAT:lsdep_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160977
	DQ	FLAT:$SG160978
	DQ	0000000000000000H
	DQ	FLAT:lsequ_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160979
	DQ	FLAT:$SG160980
	DQ	FLAT:$SG160981
	DQ	FLAT:lsmod_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160982
	DQ	FLAT:$SG160983
	DQ	0000000000000000H
	DQ	FLAT:rmmod_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160984
	DQ	FLAT:$SG160985
	DQ	FLAT:$SG160986
	DQ	FLAT:http_cmd
	DQ	0000000000000000H
	DB	010H
	ORG $+7
	DQ	FLAT:$SG160987
	DQ	FLAT:$SG160988
	DQ	FLAT:$SG160989
	DQ	FLAT:iodelay_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160990
	DQ	FLAT:$SG160991
	DQ	FLAT:$SG160992
	DQ	FLAT:pgmprdos_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG160993
	DQ	FLAT:$SG160994
	DQ	FLAT:$SG160995
	DQ	FLAT:maxrates_cmd
	DQ	0000000000000000H
	DB	077H
	ORG $+7
	DQ	FLAT:$SG160996
	DQ	FLAT:$SG160997
	DQ	FLAT:$SG160998
	DQ	FLAT:scsimount_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG160999
	DQ	FLAT:$SG161000
	DQ	FLAT:$SG161001
	DQ	FLAT:scsimount_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG161002
	DQ	FLAT:$SG161003
	DQ	FLAT:$SG161004
	DQ	FLAT:shrdport_cmd
	DQ	0000000000000000H
	DB	090H
	ORG $+7
	DQ	FLAT:$SG161005
	DQ	FLAT:$SG161006
	DQ	FLAT:$SG161007
	DQ	FLAT:call_shrd_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	FLAT:$SG161008
	DQ	FLAT:$SG161009
	DQ	FLAT:$SG161010
	DQ	FLAT:quit_cmd
	DQ	0000000000000000H
	DB	0ffH
	ORG $+7
	DQ	FLAT:$SG161011
	DQ	FLAT:$SG161012
	DQ	FLAT:$SG161013
	DQ	FLAT:quitmout_cmd
	DQ	0000000000000000H
	DB	0ffH
	ORG $+7
	DQ	FLAT:$SG161014
	DQ	FLAT:$SG161015
	DQ	FLAT:$SG161016
	DQ	FLAT:tt32_cmd
	DQ	0000000000000000H
	DB	076H
	ORG $+7
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DB	00H
	ORG $+7
$SG161077 DB	'Cfg', 00H
$SG161080 DB	'NoCfg', 00H
	ORG $+2
$SG161083 DB	'Cmd', 00H
$SG161086 DB	'NoCmd', 00H
	ORG $+2
$SG161087 DB	'Invalid arg: %s: %s %s [(No)Cfg|(No)Cmd]', 0aH, 00H
	ORG $+2
$SG161091 DB	'No', 00H
	ORG $+1
$SG161088 DB	'zapcmd_cmd', 00H
	ORG $+1
$SG161093 DB	'No', 00H
	ORG $+1
$SG161089 DB	'cmdtab.c', 00H
	ORG $+3
$SG161197 DB	'&', 00H
	ORG $+2
$SG161094 DB	'%s: %s(%sCfg,%sCmd)', 0aH, 00H
	ORG $+3
$SG161095 DB	'zapcmd_cmd', 00H
	ORG $+1
$SG161199 DB	' ', 00H
	ORG $+2
$SG161096 DB	'cmdtab.c', 00H
	ORG $+3
$SG161201 DB	'"', 00H
	ORG $+2
$SG161097 DB	'%s: %s not in command table', 0aH, 00H
	ORG $+3
$SG161098 DB	'zapcmd_cmd', 00H
	ORG $+1
$SG161203 DB	'"', 00H
	ORG $+2
$SG161099 DB	'cmdtab.c', 00H
	ORG $+3
$SG161207 DB	'&&', 00H
	ORG $+1
$SG161100 DB	'Usage: %s <command> [(No)Cfg|(No)Cmd]', 0aH, 00H
	ORG $+1
$SG161101 DB	'zapcmd_cmd', 00H
	ORG $+1
$SG161212 DB	'sf+', 00H
$SG161102 DB	'cmdtab.c', 00H
	ORG $+3
$SG161213 DB	'sf-', 00H
$SG161172 DB	'cscript', 00H
$SG161179 DB	'CallHercCmd', 00H
$SG161214 DB	'sfc', 00H
$SG161180 DB	'cmdtab.c', 00H
	ORG $+7
$SG161181 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161183 DB	'CallHercCmd', 00H
$SG161215 DB	'sfd', 00H
$SG161184 DB	'cmdtab.c', 00H
	ORG $+7
$SG161204 DB	'cmdtab.c:363', 00H
	ORG $+3
$SG161216 DB	'sfk', 00H
	ORG $+4
$SG161185 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161205 DB	'bgcmd_thread', 00H
	ORG $+3
$SG161241 DB	'DoCallHercCmdLine', 00H
	ORG $+2
$SG161251 DB	'E', 00H
	ORG $+2
$SG161242 DB	'cmdtab.c', 00H
	ORG $+7
$SG161243 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161245 DB	'DoCallHercCmdLine', 00H
	ORG $+2
$SG161257 DB	'D', 00H
	ORG $+2
$SG161246 DB	'cmdtab.c', 00H
	ORG $+7
$SG161247 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161253 DB	'DoCallHercCmdLine', 00H
	ORG $+6
$SG161252 DB	'HHC01600%s Unknown command %s, enter ''help'' for a list'
	DB	' of valid commands', 0aH, 00H
	ORG $+2
$SG161331 DB	'E', 00H
	ORG $+2
$SG161254 DB	'cmdtab.c', 00H
	ORG $+3
$SG161338 DB	'E', 00H
	ORG $+2
$SG161256 DB	'RC = %d', 00H
$SG161258 DB	'HHC90000%s DBG: %s', 0aH, 00H
$SG161353 DB	'I', 00H
	ORG $+2
$SG161259 DB	'DoCallHercCmdLine', 00H
	ORG $+2
$SG161359 DB	'I', 00H
	ORG $+2
$SG161260 DB	'cmdtab.c', 00H
	ORG $+3
$SG161330 DB	'help', 00H
	ORG $+7
$SG161332 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+2
$SG161365 DB	'I', 00H
	ORG $+2
$SG161333 DB	'HelpCommand', 00H
$SG161369 DB	'I', 00H
	ORG $+2
$SG161334 DB	'cmdtab.c', 00H
	ORG $+7
$SG161340 DB	'HelpCommand', 00H
$SG161375 DB	'E', 00H
	ORG $+2
$SG161354 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161358 DB	'Command         ', 00H
	ORG $+7
$SG161339 DB	'HHC02299%s Invalid command usage. Type ''help %s'' for a'
	DB	'ssistance.', 0aH, 00H
	ORG $+2
$SG161380 DB	'I', 00H
	ORG $+2
$SG161341 DB	'cmdtab.c', 00H
	ORG $+3
$SG161385 DB	'I', 00H
	ORG $+2
$SG161355 DB	'HelpCommand', 00H
$SG161390 DB	'I', 00H
	ORG $+2
$SG161356 DB	'cmdtab.c', 00H
	ORG $+3
$SG161398 DB	'I', 00H
	ORG $+2
$SG161357 DB	'Description', 00H
$SG161404 DB	'I', 00H
	ORG $+2
$SG161360 DB	'HHC01602%s %-*.*s  %c%s', 0aH, 00H
	ORG $+3
$SG161410 DB	'I', 00H
	ORG $+2
$SG161361 DB	'HelpCommand', 00H
$SG161414 DB	'I', 00H
	ORG $+2
$SG161362 DB	'cmdtab.c', 00H
	ORG $+3
$SG161420 DB	'I', 00H
	ORG $+2
$SG161363 DB	'-----------------------------------------------', 00H
$SG161364 DB	'----------------', 00H
	ORG $+3
$SG161425 DB	'I', 00H
	ORG $+2
$SG161366 DB	'HHC01602%s %-*.*s  %c%s', 0aH, 00H
	ORG $+3
$SG161430 DB	'I', 00H
	ORG $+2
$SG161367 DB	'HelpCommand', 00H
$SG161435 DB	'I', 00H
	ORG $+2
$SG161368 DB	'cmdtab.c', 00H
	ORG $+3
$SG161446 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG161447 DB	'I', 00H
	ORG $+2
$SG161370 DB	'HHC01602%s %-*.*s  %c%s', 0aH, 00H
	ORG $+3
$SG161513 DB	'$(CUU)', 00H
	ORG $+1
$SG161514 DB	'CUU', 00H
$SG161371 DB	'HelpCommand', 00H
	ORG $+4
$SG161372 DB	'cmdtab.c', 00H
	ORG $+7
$SG161376 DB	'HHC01609%s No help available for mask %s', 0aH, 00H
	ORG $+6
$SG161377 DB	'HelpCommand', 00H
	ORG $+4
$SG161378 DB	'cmdtab.c', 00H
	ORG $+7
$SG161381 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161382 DB	'HelpCommand', 00H
	ORG $+4
$SG161383 DB	'cmdtab.c', 00H
	ORG $+7
$SG161386 DB	'HHC01610%s  (*)  Enter "help <command>" for more info.', 0aH
	DB	00H
$SG161387 DB	'HelpCommand', 00H
	ORG $+4
$SG161388 DB	'cmdtab.c', 00H
	ORG $+7
$SG161391 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161392 DB	'HelpCommand', 00H
	ORG $+4
$SG161393 DB	'cmdtab.c', 00H
	ORG $+7
$SG161399 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161400 DB	'HelpCommand', 00H
	ORG $+4
$SG161401 DB	'cmdtab.c', 00H
	ORG $+7
$SG161402 DB	'Description', 00H
	ORG $+4
$SG161403 DB	'Command         ', 00H
	ORG $+7
$SG161405 DB	'HHC01602%s %-*.*s  %c%s', 0aH, 00H
	ORG $+7
$SG161406 DB	'HelpCommand', 00H
	ORG $+4
$SG161407 DB	'cmdtab.c', 00H
	ORG $+7
$SG161408 DB	'-------------------------------------------------------', 00H
$SG161409 DB	'----------------', 00H
	ORG $+7
$SG161411 DB	'HHC01602%s %-*.*s  %c%s', 0aH, 00H
	ORG $+7
$SG161412 DB	'HelpCommand', 00H
	ORG $+4
$SG161413 DB	'cmdtab.c', 00H
	ORG $+7
$SG161415 DB	'HHC01602%s %-*.*s  %c%s', 0aH, 00H
	ORG $+7
$SG161416 DB	'HelpCommand', 00H
	ORG $+4
$SG161417 DB	'cmdtab.c', 00H
	ORG $+7
$SG161421 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161422 DB	'HelpCommand', 00H
	ORG $+4
$SG161423 DB	'cmdtab.c', 00H
	ORG $+7
$SG161426 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161427 DB	'HelpCommand', 00H
	ORG $+4
$SG161428 DB	'cmdtab.c', 00H
	ORG $+7
$SG161431 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161432 DB	'HelpCommand', 00H
	ORG $+4
$SG161433 DB	'cmdtab.c', 00H
	ORG $+7
$SG161436 DB	'HHC01604%s Unknown command %s, no help available', 0aH, 00H
	ORG $+6
$SG161437 DB	'HelpCommand', 00H
	ORG $+4
$SG161438 DB	'cmdtab.c', 00H
	ORG $+7
$SG161448 DB	'HHC01603%s %s', 0aH, 00H
	ORG $+1
$SG161449 DB	'EchoHercCmdLine', 00H
$SG161450 DB	'cmdtab.c', 00H
	ORG $+7
$SG161491 DB	'the_real_panel_command', 00H
	ORG $+1
$SG161492 DB	'cmdtab.c', 00H
	ORG $+7
$SG161493 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161495 DB	'the_real_panel_command', 00H
	ORG $+1
$SG161496 DB	'cmdtab.c', 00H
	ORG $+7
$SG161497 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161515 DB	'$(CCUU)', 00H
$SG161516 DB	'CCUU', 00H
	ORG $+3
$SG161517 DB	'$(DEVN)', 00H
$SG161518 DB	'DEVN', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:DoCallHercCmdLine
	DD	020H
	DD	02d8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:bgcmd_thread
	DD	01cH
	DD	096H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:HelpCommand
	DD	01fH
	DD	0cfbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:the_real_panel_command
	DD	01cH
	DD	0599H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CallHercCmd
	DD	01fH
	DD	086cH
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$InternalHercCmd DD 010901H
	DD	04209H
$unwind$HercCmdLine DD 010901H
	DD	04209H
$unwind$CallHercCmd DD 022719H
	DD	0350115H
	DD	imagerel __GSHandlerCheck
	DD	0190H
$unwind$the_real_panel_command DD 022419H
	DD	010150112H
	DD	imagerel __GSHandlerCheck
	DD	08090H
$unwind$zapcmd_cmd DD 021501H
	DD	0170115H
$unwind$HelpCommand DD 022719H
	DD	0430115H
	DD	imagerel __GSHandlerCheck
	DD	0200H
$unwind$call_cachestats_cmd DD 011201H
	DD	04212H
$unwind$call_ptt_cmd DD 011201H
	DD	04212H
$unwind$call_locks_cmd DD 011201H
	DD	04212H
$unwind$call_threads_cmd DD 011201H
	DD	04212H
$unwind$call_shrd_cmd DD 011201H
	DD	04212H
$unwind$bgcmd_thread DD 022419H
	DD	040b0112H
	DD	imagerel __GSHandlerCheck
	DD	02040H
$unwind$DoCallHercCmdLine DD 022819H
	DD	04150116H
	DD	imagerel __GSHandlerCheck
	DD	02090H
$unwind$SortCmdTab DD 010e01H
	DD	0820eH
$unwind$EchoHercCmdLine DD 010901H
	DD	0a209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
panel$ = 64
tv71 = 72
cmd$ = 96
EchoHercCmdLine PROC

; 670  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 671  :     BYTE panel = WRMSG_NORMAL;  // (default)

  00009	c6 44 24 40 03	 mov	 BYTE PTR panel$[rsp], 3

; 672  : 
; 673  :     /* Don't echo the command if it's the DIAG8 interface issuing it
; 674  :        unless the echo option is enabled, and if it is enabled, only
; 675  :        echo it to the panel to prevent DIAG8 from capturing the echo.
; 676  :     */
; 677  :     if (is_diag_instr())

  0000e	e8 00 00 00 00	 call	 is_diag_instr
  00013	0f b6 c0	 movzx	 eax, al
  00016	85 c0		 test	 eax, eax
  00018	74 1e		 je	 SHORT $LN2@EchoHercCm

; 678  :     {
; 679  :         if (!(sysblk.diag8opt & DIAG8CMD_ECHO))

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 2e 11
	00 00		 movzx	 eax, BYTE PTR [rax+4398]
  00028	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0002d	85 c0		 test	 eax, eax
  0002f	75 02		 jne	 SHORT $LN3@EchoHercCm

; 680  :             return;             // (no logging whatsoever)

  00031	eb 6d		 jmp	 SHORT $LN1@EchoHercCm
$LN3@EchoHercCm:

; 681  :         panel = WRMSG_PANEL;    // (prevent DIAG8 capturing)

  00033	c6 44 24 40 02	 mov	 BYTE PTR panel$[rsp], 2
$LN2@EchoHercCm:

; 682  :     }
; 683  : 
; 684  :     PWRMSG( panel, HHC01603, "I", RTRIM( cmd ));    // "%s"

  00038	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161446
  0003f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cmd$[rsp]
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rtrim
  0004a	48 89 44 24 48	 mov	 QWORD PTR tv71[rsp], rax
  0004f	b9 01 00 00 00	 mov	 ecx, 1
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0005a	48 8b 4c 24 48	 mov	 rcx, QWORD PTR tv71[rsp]
  0005f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00064	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161447
  0006b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161448
  00077	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0007c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00081	44 0f b6 4c 24
	40		 movzx	 r9d, BYTE PTR panel$[rsp]
  00087	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161449
  0008e	ba ac 02 00 00	 mov	 edx, 684		; 000002acH
  00093	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161450
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN1@EchoHercCm:

; 685  : }

  000a0	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000a4	c3		 ret	 0
EchoHercCmdLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
tv75 = 32
tv77 = 36
tv78 = 40
pCmdTab1$ = 48
pCmdTab2$ = 56
p1$ = 80
p2$ = 88
SortCmdTab PROC

; 473  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 474  :     CMDTAB* pCmdTab1 = (CMDTAB*) p1;

  0000e	48 8b 44 24 50	 mov	 rax, QWORD PTR p1$[rsp]
  00013	48 89 44 24 30	 mov	 QWORD PTR pCmdTab1$[rsp], rax

; 475  :     CMDTAB* pCmdTab2 = (CMDTAB*) p2;

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR p2$[rsp]
  0001d	48 89 44 24 38	 mov	 QWORD PTR pCmdTab2$[rsp], rax

; 476  :     /* (special handling for NULL table terminator) */
; 477  :     return (pCmdTab1->statement && pCmdTab2->statement) ?

  00022	48 8b 44 24 30	 mov	 rax, QWORD PTR pCmdTab1$[rsp]
  00027	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0002b	74 27		 je	 SHORT $LN3@SortCmdTab
  0002d	48 8b 44 24 38	 mov	 rax, QWORD PTR pCmdTab2$[rsp]
  00032	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00036	74 1c		 je	 SHORT $LN3@SortCmdTab
  00038	48 8b 44 24 38	 mov	 rax, QWORD PTR pCmdTab2$[rsp]
  0003d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR pCmdTab1$[rsp]
  00045	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0004e	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
  00052	eb 3e		 jmp	 SHORT $LN8@SortCmdTab
$LN3@SortCmdTab:
  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR pCmdTab1$[rsp]
  00059	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0005d	75 0a		 jne	 SHORT $LN4@SortCmdTab
  0005f	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00067	eb 08		 jmp	 SHORT $LN5@SortCmdTab
$LN4@SortCmdTab:
  00069	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN5@SortCmdTab:
  00071	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00076	74 0a		 je	 SHORT $LN6@SortCmdTab
  00078	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  00080	eb 08		 jmp	 SHORT $LN7@SortCmdTab
$LN6@SortCmdTab:
  00082	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv77[rsp], -1
$LN7@SortCmdTab:
  0008a	8b 44 24 24	 mov	 eax, DWORD PTR tv77[rsp]
  0008e	89 44 24 28	 mov	 DWORD PTR tv78[rsp], eax
$LN8@SortCmdTab:
  00092	8b 44 24 28	 mov	 eax, DWORD PTR tv78[rsp]

; 478  :         strcasecmp( pCmdTab1->statement, pCmdTab2->statement )
; 479  :         : (!pCmdTab1->statement ? +1 : -1);
; 480  : }

  00096	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009a	c3		 ret	 0
SortCmdTab ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
rc$ = 64
tv137 = 68
tv146 = 72
tv139 = 76
tv148 = 80
cmdline$ = 88
argc$ = 96
tv153 = 104
argv$ = 112
msgbuf$1 = 8304
__$ArrayPad$ = 8336
pszCmdLine$ = 8368
internal$ = 8376
DoCallHercCmdLine PROC

; 413  : {

  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	b8 a8 20 00 00	 mov	 eax, 8360		; 000020a8H
  0000e	e8 00 00 00 00	 call	 __chkstk
  00013	48 2b e0	 sub	 rsp, rax
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 90
	20 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 414  :     int      argc;
; 415  :     char*    argv[ MAX_ARGS ];
; 416  :     char*    cmdline  = NULL;

  00028	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR cmdline$[rsp], 0

; 417  :     int      rc       = -1;

  00031	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 418  : 
; 419  :     /* Save unmodified copy of the command line in case
; 420  :        its format is unusual and needs customized parsing. */
; 421  :     cmdline = strdup( pszCmdLine );

  00039	48 8b 8c 24 b0
	20 00 00	 mov	 rcx, QWORD PTR pszCmdLine$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00047	48 89 44 24 58	 mov	 QWORD PTR cmdline$[rsp], rax

; 422  : 
; 423  :     /* Parse the command line into its individual arguments.
; 424  :        Note: original command line now sprinkled with nulls */
; 425  :     parse_args( pszCmdLine, MAX_ARGS, argv, &argc );

  0004c	4c 8d 4c 24 60	 lea	 r9, QWORD PTR argc$[rsp]
  00051	4c 8d 44 24 70	 lea	 r8, QWORD PTR argv$[rsp]
  00056	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  0005b	48 8b 8c 24 b0
	20 00 00	 mov	 rcx, QWORD PTR pszCmdLine$[rsp]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_parse_args

; 426  : 
; 427  :     /* Our primary Hercules command function gets first crack. */
; 428  :     if ((rc = CallHercCmd( CMDFUNC_ARGS )) != HERRINVCMD)

  00069	4c 8b 44 24 58	 mov	 r8, QWORD PTR cmdline$[rsp]
  0006e	48 8d 54 24 70	 lea	 rdx, QWORD PTR argv$[rsp]
  00073	8b 4c 24 60	 mov	 ecx, DWORD PTR argc$[rsp]
  00077	e8 00 00 00 00	 call	 CallHercCmd
  0007c	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  00080	81 7c 24 40 01
	80 ff ff	 cmp	 DWORD PTR rc$[rsp], -32767 ; ffffffffffff8001H
  00088	74 05		 je	 SHORT $LN8@DoCallHerc

; 429  :         goto HercCmdExit;

  0008a	e9 b1 01 00 00	 jmp	 $HercCmdExit$24
$LN8@DoCallHerc:
$LN4@DoCallHerc:

; 430  :     ASSERT( argv[0] ); /* (herc handles any/all empty commands) */

  0008f	b8 08 00 00 00	 mov	 eax, 8
  00094	48 6b c0 00	 imul	 rax, rax, 0
  00098	48 83 7c 04 70
	00		 cmp	 QWORD PTR argv$[rsp+rax], 0
  0009e	75 5c		 jne	 SHORT $LN9@DoCallHerc
$LN7@DoCallHerc:
  000a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161241
  000a7	41 b8 ae 01 00
	00		 mov	 r8d, 430		; 000001aeH
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161242
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161243
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c7	85 c0		 test	 eax, eax
  000c9	74 20		 je	 SHORT $LN10@DoCallHerc
  000cb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161245
  000d2	41 b8 ae 01 00
	00		 mov	 r8d, 430		; 000001aeH
  000d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161246
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161247
  000e6	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@DoCallHerc:
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	75 af		 jne	 SHORT $LN7@DoCallHerc
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000f7	85 c0		 test	 eax, eax
  000f9	74 01		 je	 SHORT $LN11@DoCallHerc
  000fb	cc		 int	 3
$LN11@DoCallHerc:
$LN9@DoCallHerc:
  000fc	33 c0		 xor	 eax, eax
  000fe	85 c0		 test	 eax, eax
  00100	75 8d		 jne	 SHORT $LN4@DoCallHerc

; 431  : 
; 432  : #if defined( _FEATURE_SYSTEM_CONSOLE )
; 433  :     /* See if maybe it's a command that the guest understands. */
; 434  :     if ( !internal && sysblk.scpimply && can_send_command() )

  00102	0f b6 84 24 b8
	20 00 00	 movzx	 eax, BYTE PTR internal$[rsp]
  0010a	85 c0		 test	 eax, eax
  0010c	0f 85 ca 00 00
	00		 jne	 $LN12@DoCallHerc
  00112	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00119	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0011f	c1 e8 06	 shr	 eax, 6
  00122	83 e0 01	 and	 eax, 1
  00125	85 c0		 test	 eax, eax
  00127	0f 84 af 00 00
	00		 je	 $LN12@DoCallHerc
  0012d	e8 00 00 00 00	 call	 can_send_command
  00132	85 c0		 test	 eax, eax
  00134	0f 84 a2 00 00
	00		 je	 $LN12@DoCallHerc

; 435  :         rc = scp_command( cmdline, false,

  0013a	b8 01 00 00 00	 mov	 eax, 1
  0013f	48 6b c0 00	 imul	 rax, rax, 0
  00143	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00148	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0014c	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0014f	75 0a		 jne	 SHORT $LN16@DoCallHerc
  00151	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv137[rsp], 1
  00159	eb 08		 jmp	 SHORT $LN17@DoCallHerc
$LN16@DoCallHerc:
  0015b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN17@DoCallHerc:
  00163	83 7c 24 44 00	 cmp	 DWORD PTR tv137[rsp], 0
  00168	75 0a		 jne	 SHORT $LN18@DoCallHerc
  0016a	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
  00172	eb 08		 jmp	 SHORT $LN19@DoCallHerc
$LN18@DoCallHerc:
  00174	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
$LN19@DoCallHerc:
  0017c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00183	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00189	c1 e8 05	 shr	 eax, 5
  0018c	83 e0 01	 and	 eax, 1
  0018f	85 c0		 test	 eax, eax
  00191	74 0a		 je	 SHORT $LN20@DoCallHerc
  00193	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv146[rsp], 1
  0019b	eb 08		 jmp	 SHORT $LN21@DoCallHerc
$LN20@DoCallHerc:
  0019d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv146[rsp], 0
$LN21@DoCallHerc:
  001a5	83 7c 24 48 00	 cmp	 DWORD PTR tv146[rsp], 0
  001aa	75 0a		 jne	 SHORT $LN22@DoCallHerc
  001ac	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv148[rsp], 0
  001b4	eb 08		 jmp	 SHORT $LN23@DoCallHerc
$LN22@DoCallHerc:
  001b6	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv148[rsp], 1
$LN23@DoCallHerc:
  001be	44 0f b6 4c 24
	4c		 movzx	 r9d, BYTE PTR tv139[rsp]
  001c4	44 0f b6 44 24
	50		 movzx	 r8d, BYTE PTR tv148[rsp]
  001ca	33 d2		 xor	 edx, edx
  001cc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdline$[rsp]
  001d1	e8 00 00 00 00	 call	 scp_command
  001d6	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  001da	eb 64		 jmp	 SHORT $LN13@DoCallHerc
$LN12@DoCallHerc:

; 436  :                           sysblk.scpecho ? true : false,
; 437  :                           cmdline[0] == '\\' ? true : false );
; 438  :     else
; 439  : #else
; 440  :         UNREFERENCED( internal );
; 441  : #endif
; 442  :         /* Error: unknown/unsupported command */
; 443  :         WRMSG( HHC01600, "E", argv[0] );

  001dc	b8 08 00 00 00	 mov	 eax, 8
  001e1	48 6b c0 00	 imul	 rax, rax, 0
  001e5	48 89 44 24 68	 mov	 QWORD PTR tv153[rsp], rax
  001ea	b9 01 00 00 00	 mov	 ecx, 1
  001ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv153[rsp]
  001fa	48 8b 4c 0c 70	 mov	 rcx, QWORD PTR argv$[rsp+rcx]
  001ff	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00204	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161251
  0020b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00210	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161252
  00217	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0021c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00221	41 b9 03 00 00
	00		 mov	 r9d, 3
  00227	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161253
  0022e	ba bb 01 00 00	 mov	 edx, 443		; 000001bbH
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161254
  0023a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@DoCallHerc:
$HercCmdExit$24:

; 444  : 
; 445  : HercCmdExit:
; 446  : 
; 447  :     /* Free our saved copy */
; 448  :     free( cmdline );

  00240	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 449  : 
; 450  :     if (MLVL( DEBUG ))

  0024b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00252	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00258	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0025d	85 c0		 test	 eax, eax
  0025f	74 73		 je	 SHORT $LN14@DoCallHerc

; 451  :     {
; 452  :         char msgbuf[32];
; 453  :         MSGBUF( msgbuf, "RC = %d", rc );

  00261	44 8b 4c 24 40	 mov	 r9d, DWORD PTR rc$[rsp]
  00266	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161256
  0026d	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00272	48 8d 8c 24 70
	20 00 00	 lea	 rcx, QWORD PTR msgbuf$1[rsp]
  0027a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 454  :         WRMSG( HHC90000, "D", msgbuf );

  00280	b9 01 00 00 00	 mov	 ecx, 1
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0028b	48 8d 8c 24 70
	20 00 00	 lea	 rcx, QWORD PTR msgbuf$1[rsp]
  00293	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00298	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161257
  0029f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161258
  002ab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002b5	41 b9 03 00 00
	00		 mov	 r9d, 3
  002bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161259
  002c2	ba c6 01 00 00	 mov	 edx, 454		; 000001c6H
  002c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161260
  002ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@DoCallHerc:

; 455  :     }
; 456  : 
; 457  :     return rc;

  002d4	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 458  : }

  002d8	48 8b 8c 24 90
	20 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  002e0	48 33 cc	 xor	 rcx, rsp
  002e3	e8 00 00 00 00	 call	 __security_check_cookie
  002e8	48 81 c4 a8 20
	00 00		 add	 rsp, 8360		; 000020a8H
  002ef	c3		 ret	 0
DoCallHercCmdLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
pBGCMD$ = 32
argc$ = 40
cmdline$ = 48
argv$ = 64
__$ArrayPad$ = 8256
bgcmd$ = 8288
bgcmd_thread PROC

; 212  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 58 20 00 00	 mov	 eax, 8280		; 00002058H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 40
	20 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 213  : BGCMD* pBGCMD;
; 214  : char*  cmdline;
; 215  : int    argc;
; 216  : char*  argv[MAX_ARGS];
; 217  : 
; 218  :     pBGCMD = (BGCMD*) bgcmd;

  00024	48 8b 84 24 60
	20 00 00	 mov	 rax, QWORD PTR bgcmd$[rsp]
  0002c	48 89 44 24 20	 mov	 QWORD PTR pBGCMD$[rsp], rax

; 219  :     /* (must save copy of cmdline since parse_args modifies it) */
; 220  :     cmdline = strdup( pBGCMD->cmdline );

  00031	48 8b 44 24 20	 mov	 rax, QWORD PTR pBGCMD$[rsp]
  00036	48 83 c0 08	 add	 rax, 8
  0003a	48 8b c8	 mov	 rcx, rax
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00043	48 89 44 24 30	 mov	 QWORD PTR cmdline$[rsp], rax

; 221  :     parse_args( pBGCMD->cmdline, MAX_ARGS, argv, &argc );

  00048	48 8b 44 24 20	 mov	 rax, QWORD PTR pBGCMD$[rsp]
  0004d	48 83 c0 08	 add	 rax, 8
  00051	4c 8d 4c 24 28	 lea	 r9, QWORD PTR argc$[rsp]
  00056	4c 8d 44 24 40	 lea	 r8, QWORD PTR argv$[rsp]
  0005b	ba 00 04 00 00	 mov	 edx, 1024		; 00000400H
  00060	48 8b c8	 mov	 rcx, rax
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_parse_args

; 222  :     pBGCMD->func( CMDFUNC_ARGS );

  00069	4c 8b 44 24 30	 mov	 r8, QWORD PTR cmdline$[rsp]
  0006e	48 8d 54 24 40	 lea	 rdx, QWORD PTR argv$[rsp]
  00073	8b 4c 24 28	 mov	 ecx, DWORD PTR argc$[rsp]
  00077	48 8b 44 24 20	 mov	 rax, QWORD PTR pBGCMD$[rsp]
  0007c	ff 10		 call	 QWORD PTR [rax]

; 223  :     free( pBGCMD );

  0007e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pBGCMD$[rsp]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 224  :     free( cmdline );

  00089	48 8b 4c 24 30	 mov	 rcx, QWORD PTR cmdline$[rsp]
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 225  :     return NULL;

  00094	33 c0		 xor	 eax, eax

; 226  : }

  00096	48 8b 8c 24 40
	20 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0009e	48 33 cc	 xor	 rcx, rsp
  000a1	e8 00 00 00 00	 call	 __security_check_cookie
  000a6	48 81 c4 58 20
	00 00		 add	 rsp, 8280		; 00002058H
  000ad	c3		 ret	 0
bgcmd_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
cmdline$ = 64
call_shrd_cmd PROC

; 120  :   CALL_EXTCMD ( shrd_cmd       )            /* (lives in shared.c)   */

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	4c 8b 44 24 40	 mov	 r8, QWORD PTR cmdline$[rsp]
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR argv$[rsp]
  0001c	8b 4c 24 30	 mov	 ecx, DWORD PTR argc$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_shrd_cmd
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
call_shrd_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
cmdline$ = 64
call_threads_cmd PROC

; 123  :   CALL_EXTCMD ( threads_cmd    )            /* (lives in hthreads.c) */

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	4c 8b 44 24 40	 mov	 r8, QWORD PTR cmdline$[rsp]
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR argv$[rsp]
  0001c	8b 4c 24 30	 mov	 ecx, DWORD PTR argc$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_threads_cmd
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
call_threads_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
cmdline$ = 64
call_locks_cmd PROC

; 122  :   CALL_EXTCMD ( locks_cmd      )            /* (lives in hthreads.c) */

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	4c 8b 44 24 40	 mov	 r8, QWORD PTR cmdline$[rsp]
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR argv$[rsp]
  0001c	8b 4c 24 30	 mov	 ecx, DWORD PTR argc$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_locks_cmd
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
call_locks_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
cmdline$ = 64
call_ptt_cmd PROC

; 121  :   CALL_EXTCMD ( ptt_cmd        )            /* (lives in pttrace.c)  */

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	4c 8b 44 24 40	 mov	 r8, QWORD PTR cmdline$[rsp]
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR argv$[rsp]
  0001c	8b 4c 24 30	 mov	 ecx, DWORD PTR argc$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_cmd
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
call_ptt_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
cmdline$ = 64
call_cachestats_cmd PROC

; 119  :   CALL_EXTCMD ( cachestats_cmd )            /* (lives in cache.c)    */

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00012	4c 8b 44 24 40	 mov	 r8, QWORD PTR cmdline$[rsp]
  00017	48 8b 54 24 38	 mov	 rdx, QWORD PTR argv$[rsp]
  0001c	8b 4c 24 30	 mov	 ecx, DWORD PTR argc$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_cachestats_cmd
  00026	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002a	c3		 ret	 0
call_cachestats_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
pCmdTab$ = 96
max_stmtlen$ = 104
longflag$1 = 108
i$2 = 112
longflag$3 = 116
pfxlen$ = 120
rc$ = 124
j$4 = 128
found$5 = 132
stmtlen$ = 136
didlong$6 = 140
tv364 = 144
tv227 = 148
tv406 = 152
p$ = 160
tv327 = 168
cmdlen$7 = 176
tv337 = 184
$T8 = 192
tv141 = 200
tv244 = 208
matchlen$9 = 216
tv524 = 224
buf$10 = 240
__$ArrayPad$ = 512
argc$ = 544
argv$ = 552
cmdline$ = 560
HelpCommand PROC

; 486  : {

$LN54:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec 18 02
	00 00		 sub	 rsp, 536		; 00000218H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 00
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 487  :     static int didinit = 0;
; 488  :     CMDTAB* pCmdTab;
; 489  :     int     rc = 1;

  00027	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR rc$[rsp], 1

; 490  :     int     pfxlen = -1;

  0002f	c7 44 24 78 ff
	ff ff ff	 mov	 DWORD PTR pfxlen$[rsp], -1

; 491  :     char   *p = NULL;

  00037	48 c7 84 24 a0
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$[rsp], 0

; 492  :     int     stmtlen, max_stmtlen = 9;

  00043	c7 44 24 68 09
	00 00 00	 mov	 DWORD PTR max_stmtlen$[rsp], 9
$LN4@HelpComman:

; 493  : 
; 494  :     UNREFERENCED( cmdline );

  0004b	33 c0		 xor	 eax, eax
  0004d	85 c0		 test	 eax, eax
  0004f	75 fa		 jne	 SHORT $LN4@HelpComman

; 495  : 
; 496  :     if (!didinit)

  00051	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?didinit@?1??HelpCommand@@9@9, 0
  00058	75 29		 jne	 SHORT $LN19@HelpComman

; 497  :     {
; 498  :         qsort( cmdtab, _countof( cmdtab ), sizeof( CMDTAB ), SortCmdTab );

  0005a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:SortCmdTab
  00061	41 b8 30 00 00
	00		 mov	 r8d, 48			; 00000030H
  00067	ba cc 00 00 00	 mov	 edx, 204		; 000000ccH
  0006c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:cmdtab
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort

; 499  :         didinit = 1;

  00079	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?didinit@?1??HelpCommand@@9@9, 1
$LN19@HelpComman:

; 500  :     }
; 501  : 
; 502  :     /* Keep 'max_stmtlen' accurate */
; 503  :     for (pCmdTab = cmdtab; pCmdTab->statement; pCmdTab++)

  00083	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdtab
  0008a	48 89 44 24 60	 mov	 QWORD PTR pCmdTab$[rsp], rax
  0008f	eb 0e		 jmp	 SHORT $LN7@HelpComman
$LN5@HelpComman:
  00091	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00096	48 83 c0 30	 add	 rax, 48			; 00000030H
  0009a	48 89 44 24 60	 mov	 QWORD PTR pCmdTab$[rsp], rax
$LN7@HelpComman:
  0009f	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  000a4	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000a8	74 39		 je	 SHORT $LN6@HelpComman

; 504  :     {
; 505  :         if (pCmdTab->statement)

  000aa	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  000af	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  000b3	74 2c		 je	 SHORT $LN20@HelpComman

; 506  :         {
; 507  :             if ((stmtlen = (int) strlen( pCmdTab->statement )) > max_stmtlen)

  000b5	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  000ba	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000bd	e8 00 00 00 00	 call	 strlen
  000c2	89 84 24 88 00
	00 00		 mov	 DWORD PTR stmtlen$[rsp], eax
  000c9	8b 44 24 68	 mov	 eax, DWORD PTR max_stmtlen$[rsp]
  000cd	39 84 24 88 00
	00 00		 cmp	 DWORD PTR stmtlen$[rsp], eax
  000d4	7e 0b		 jle	 SHORT $LN21@HelpComman

; 508  :                 max_stmtlen = stmtlen;

  000d6	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR stmtlen$[rsp]
  000dd	89 44 24 68	 mov	 DWORD PTR max_stmtlen$[rsp], eax
$LN21@HelpComman:
$LN20@HelpComman:

; 509  :         }
; 510  :     }

  000e1	eb ae		 jmp	 SHORT $LN5@HelpComman
$LN6@HelpComman:

; 511  : 
; 512  :     /* Too many arguments? */
; 513  :     if (argc > 2)

  000e3	83 bc 24 20 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  000eb	7e 5d		 jle	 SHORT $LN22@HelpComman

; 514  :     {
; 515  :         // "Invalid command usage. Type 'help %s' for assistance."
; 516  :         WRMSG( HHC02299, "E", "help" );

  000ed	b9 01 00 00 00	 mov	 ecx, 1
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161330
  000ff	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00104	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161331
  0010b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161332
  00117	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00121	41 b9 03 00 00
	00		 mov	 r9d, 3
  00127	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161333
  0012e	ba 04 02 00 00	 mov	 edx, 516		; 00000204H
  00133	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161334
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 517  :         return 1;

  00140	b8 01 00 00 00	 mov	 eax, 1
  00145	e9 b1 0b 00 00	 jmp	 $LN1@HelpComman
$LN22@HelpComman:

; 518  :     }
; 519  : 
; 520  :     /* If "help pfx*", calculate prefix length */
; 521  :     if (argc == 2)

  0014a	83 bc 24 20 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00152	0f 85 ff 00 00
	00		 jne	 $LN23@HelpComman

; 522  :     {
; 523  :         p = strchr(argv[1], '*');

  00158	b8 08 00 00 00	 mov	 eax, 8
  0015d	48 6b c0 01	 imul	 rax, rax, 1
  00161	ba 2a 00 00 00	 mov	 edx, 42			; 0000002aH
  00166	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0016e	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00172	e8 00 00 00 00	 call	 strchr
  00177	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR p$[rsp], rax

; 524  :         if (p != NULL)

  0017f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR p$[rsp], 0
  00188	0f 84 c9 00 00
	00		 je	 $LN24@HelpComman

; 525  :         {
; 526  :             pfxlen = (int)(p - argv[1]);

  0018e	b8 08 00 00 00	 mov	 eax, 8
  00193	48 6b c0 01	 imul	 rax, rax, 1
  00197	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0019f	48 8b 04 01	 mov	 rax, QWORD PTR [rcx+rax]
  001a3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR p$[rsp]
  001ab	48 2b c8	 sub	 rcx, rax
  001ae	48 8b c1	 mov	 rax, rcx
  001b1	89 44 24 78	 mov	 DWORD PTR pfxlen$[rsp], eax

; 527  :             if (strlen( argv[1] ) > (unsigned) (pfxlen + 1))

  001b5	b8 08 00 00 00	 mov	 eax, 8
  001ba	48 6b c0 01	 imul	 rax, rax, 1
  001be	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001c6	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  001ca	e8 00 00 00 00	 call	 strlen
  001cf	8b 4c 24 78	 mov	 ecx, DWORD PTR pfxlen$[rsp]
  001d3	ff c1		 inc	 ecx
  001d5	8b c9		 mov	 ecx, ecx
  001d7	48 3b c1	 cmp	 rax, rcx
  001da	76 7b		 jbe	 SHORT $LN25@HelpComman

; 528  :             {
; 529  :                 // "Invalid command usage. Type 'help %s' for assistance."
; 530  :                 WRMSG( HHC02299, "E", argv[0] );

  001dc	b8 08 00 00 00	 mov	 eax, 8
  001e1	48 6b c0 00	 imul	 rax, rax, 0
  001e5	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
  001ed	b9 01 00 00 00	 mov	 ecx, 1
  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001f8	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00200	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR tv141[rsp]
  00208	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0020c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00211	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161338
  00218	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0021d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161339
  00224	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00229	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0022e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00234	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161340
  0023b	ba 12 02 00 00	 mov	 edx, 530		; 00000212H
  00240	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161341
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 531  :                 return -1;

  0024d	b8 ff ff ff ff	 mov	 eax, -1
  00252	e9 a4 0a 00 00	 jmp	 $LN1@HelpComman
$LN25@HelpComman:
$LN24@HelpComman:
$LN23@HelpComman:

; 532  :             }
; 533  :         }
; 534  :     }
; 535  : 
; 536  :     /* List all commands or those matching given prefix?  */
; 537  :     if (argc < 2 || pfxlen >= 0)    /* "help" or "help pfx*" ? */

  00257	83 bc 24 20 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0025f	7c 0b		 jl	 SHORT $LN28@HelpComman
  00261	83 7c 24 78 00	 cmp	 DWORD PTR pfxlen$[rsp], 0
  00266	0f 8c 88 04 00
	00		 jl	 $LN26@HelpComman
$LN28@HelpComman:

; 538  :     {
; 539  :         int found = FALSE;

  0026c	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR found$5[rsp], 0

; 540  :         int didlong = FALSE;

  00277	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR didlong$6[rsp], 0

; 541  :         char longflag;
; 542  : 
; 543  :         if (argc < 2)

  00282	83 bc 24 20 02
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  0028a	7d 08		 jge	 SHORT $LN29@HelpComman

; 544  :             pfxlen = 0;

  0028c	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR pfxlen$[rsp], 0
$LN29@HelpComman:

; 545  : 
; 546  :         /* List standard formatted commands from our routing table */
; 547  :         for (pCmdTab = cmdtab; pCmdTab->statement; pCmdTab++)

  00294	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdtab
  0029b	48 89 44 24 60	 mov	 QWORD PTR pCmdTab$[rsp], rax
  002a0	eb 0e		 jmp	 SHORT $LN10@HelpComman
$LN8@HelpComman:
  002a2	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  002a7	48 83 c0 30	 add	 rax, 48			; 00000030H
  002ab	48 89 44 24 60	 mov	 QWORD PTR pCmdTab$[rsp], rax
$LN10@HelpComman:
  002b0	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  002b5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002b9	0f 84 9a 02 00
	00		 je	 $LN9@HelpComman

; 548  :         {
; 549  :             if (pCmdTab->type == SYSPROGDEVELDEBUG)

  002bf	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  002c4	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  002c8	83 f8 64	 cmp	 eax, 100		; 00000064H
  002cb	75 18		 jne	 SHORT $LN30@HelpComman

; 550  :             {
; 551  :                 /* Special System Programmer Developer Debug command */
; 552  :                 /* Command Level must also be Debug too, else hidden */
; 553  :                 if ((sysblk.sysgroup & SYSGROUP_PROGDEVELDEBUG) != SYSGROUP_PROGDEVELDEBUG)

  002cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002d4	0f b6 80 2d 11
	00 00		 movzx	 eax, BYTE PTR [rax+4397]
  002db	83 e0 64	 and	 eax, 100		; 00000064H
  002de	83 f8 64	 cmp	 eax, 100		; 00000064H
  002e1	74 02		 je	 SHORT $LN31@HelpComman

; 554  :                     continue;

  002e3	eb bd		 jmp	 SHORT $LN8@HelpComman
$LN31@HelpComman:
$LN30@HelpComman:

; 555  :             }
; 556  :             if (  (pCmdTab->type & sysblk.sysgroup)
; 557  :                && (pCmdTab->shortdesc)
; 558  :                && (pfxlen == 0 || !strncasecmp( argv[1], pCmdTab->statement, pfxlen ))

  002e5	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  002ea	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  002ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  002f5	0f b6 89 2d 11
	00 00		 movzx	 ecx, BYTE PTR [rcx+4397]
  002fc	23 c1		 and	 eax, ecx
  002fe	85 c0		 test	 eax, eax
  00300	0f 84 4e 02 00
	00		 je	 $LN32@HelpComman
  00306	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  0030b	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00310	0f 84 3e 02 00
	00		 je	 $LN32@HelpComman
  00316	83 7c 24 78 00	 cmp	 DWORD PTR pfxlen$[rsp], 0
  0031b	74 33		 je	 SHORT $LN33@HelpComman
  0031d	48 63 44 24 78	 movsxd	 rax, DWORD PTR pfxlen$[rsp]
  00322	b9 08 00 00 00	 mov	 ecx, 8
  00327	48 6b c9 01	 imul	 rcx, rcx, 1
  0032b	4c 8b c0	 mov	 r8, rax
  0032e	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00333	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00336	48 8b 84 24 28
	02 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0033e	48 8b 0c 08	 mov	 rcx, QWORD PTR [rax+rcx]
  00342	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00348	85 c0		 test	 eax, eax
  0034a	0f 85 04 02 00
	00		 jne	 $LN32@HelpComman
$LN33@HelpComman:

; 559  :             )
; 560  :             {
; 561  :                 longflag = ' ';

  00350	c6 44 24 6c 20	 mov	 BYTE PTR longflag$1[rsp], 32 ; 00000020H

; 562  :                 if (pCmdTab->longdesc)

  00355	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  0035a	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0035f	74 10		 je	 SHORT $LN34@HelpComman

; 563  :                 {
; 564  :                     longflag = '*';

  00361	c6 44 24 6c 2a	 mov	 BYTE PTR longflag$1[rsp], 42 ; 0000002aH

; 565  :                     didlong = TRUE;

  00366	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR didlong$6[rsp], 1
$LN34@HelpComman:

; 566  :                 }
; 567  :                 if (!found)

  00371	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR found$5[rsp], 0
  00379	0f 85 4c 01 00
	00		 jne	 $LN35@HelpComman

; 568  :                 {
; 569  :                     found = TRUE;

  0037f	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR found$5[rsp], 1

; 570  :                     WRMSG( HHC01603, "I", "" );

  0038a	b9 01 00 00 00	 mov	 ecx, 1
  0038f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00395	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161352
  0039c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003a1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161353
  003a8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161354
  003b4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003be	41 b9 03 00 00
	00		 mov	 r9d, 3
  003c4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161355
  003cb	ba 3a 02 00 00	 mov	 edx, 570		; 0000023aH
  003d0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161356
  003d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 571  :                     WRMSG( HHC01602, "I", max_stmtlen, max_stmtlen, "Command         ", ' ', "Description" );

  003dd	b9 01 00 00 00	 mov	 ecx, 1
  003e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161357
  003ef	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  003f4	c7 44 24 50 20
	00 00 00	 mov	 DWORD PTR [rsp+80], 32	; 00000020H
  003fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161358
  00403	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00408	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  0040c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00410	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  00414	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00418	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161359
  0041f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00424	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161360
  0042b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00430	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00435	41 b9 03 00 00
	00		 mov	 r9d, 3
  0043b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161361
  00442	ba 3b 02 00 00	 mov	 edx, 571		; 0000023bH
  00447	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161362
  0044e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 572  :                     WRMSG( HHC01602, "I", max_stmtlen, max_stmtlen, "----------------", ' ', "-----------------------------------------------" );

  00454	b9 01 00 00 00	 mov	 ecx, 1
  00459	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0045f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161363
  00466	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0046b	c7 44 24 50 20
	00 00 00	 mov	 DWORD PTR [rsp+80], 32	; 00000020H
  00473	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161364
  0047a	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0047f	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  00483	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00487	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  0048b	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0048f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161365
  00496	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0049b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161366
  004a2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004ac	41 b9 03 00 00
	00		 mov	 r9d, 3
  004b2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161367
  004b9	ba 3c 02 00 00	 mov	 edx, 572		; 0000023cH
  004be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161368
  004c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN35@HelpComman:

; 573  :                 }
; 574  :                 WRMSG( HHC01602, "I", max_stmtlen, max_stmtlen, pCmdTab->statement, longflag, pCmdTab->shortdesc );

  004cb	0f be 44 24 6c	 movsx	 eax, BYTE PTR longflag$1[rsp]
  004d0	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv227[rsp], eax
  004d7	b9 01 00 00 00	 mov	 ecx, 1
  004dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004e2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  004e7	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  004eb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  004f0	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv227[rsp]
  004f7	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  004fb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00500	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00503	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00508	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  0050c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00510	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  00514	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00518	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161369
  0051f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00524	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161370
  0052b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00530	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00535	41 b9 03 00 00
	00		 mov	 r9d, 3
  0053b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161371
  00542	ba 3e 02 00 00	 mov	 edx, 574		; 0000023eH
  00547	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161372
  0054e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN32@HelpComman:

; 575  :             }
; 576  :         }

  00554	e9 49 fd ff ff	 jmp	 $LN8@HelpComman
$LN9@HelpComman:

; 577  : 
; 578  :         /* Prefix given but no matches found? */
; 579  :         if (pfxlen > 0 && !found)

  00559	83 7c 24 78 00	 cmp	 DWORD PTR pfxlen$[rsp], 0
  0055e	0f 8e 88 00 00
	00		 jle	 $LN36@HelpComman
  00564	83 bc 24 84 00
	00 00 00	 cmp	 DWORD PTR found$5[rsp], 0
  0056c	75 7e		 jne	 SHORT $LN36@HelpComman

; 580  :         {
; 581  :             // "No help available for mask '%s'"
; 582  :             WRMSG( HHC01609, "E", argv[1] );

  0056e	b8 08 00 00 00	 mov	 eax, 8
  00573	48 6b c0 01	 imul	 rax, rax, 1
  00577	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv244[rsp], rax
  0057f	b9 01 00 00 00	 mov	 ecx, 1
  00584	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0058a	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00592	48 8b 94 24 d0
	00 00 00	 mov	 rdx, QWORD PTR tv244[rsp]
  0059a	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0059e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  005a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161375
  005aa	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161376
  005b6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005c0	41 b9 03 00 00
	00		 mov	 r9d, 3
  005c6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161377
  005cd	ba 46 02 00 00	 mov	 edx, 582		; 00000246H
  005d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161378
  005d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 583  :             rc = -1;

  005df	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 584  :         }

  005e7	e9 03 01 00 00	 jmp	 $LN37@HelpComman
$LN36@HelpComman:

; 585  :         else
; 586  :         {
; 587  :             WRMSG( HHC01603, "I", "" );

  005ec	b9 01 00 00 00	 mov	 ecx, 1
  005f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161379
  005fe	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00603	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161380
  0060a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0060f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161381
  00616	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0061b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00620	41 b9 03 00 00
	00		 mov	 r9d, 3
  00626	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161382
  0062d	ba 4b 02 00 00	 mov	 edx, 587		; 0000024bH
  00632	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161383
  00639	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 588  :             if (didlong)

  0063f	83 bc 24 8c 00
	00 00 00	 cmp	 DWORD PTR didlong$6[rsp], 0
  00647	0f 84 9a 00 00
	00		 je	 $LN38@HelpComman

; 589  :             {
; 590  :                 // " (*)  Enter \"help <command>\" for more info."
; 591  :                 WRMSG( HHC01610, "I" );

  0064d	b9 01 00 00 00	 mov	 ecx, 1
  00652	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00658	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161385
  0065f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00664	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161386
  0066b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00670	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00675	41 b9 03 00 00
	00		 mov	 r9d, 3
  0067b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161387
  00682	ba 4f 02 00 00	 mov	 edx, 591		; 0000024fH
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161388
  0068e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 592  :                 WRMSG( HHC01603, "I", "" );

  00694	b9 01 00 00 00	 mov	 ecx, 1
  00699	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0069f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161389
  006a6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  006ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161390
  006b2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161391
  006be	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006c3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006c8	41 b9 03 00 00
	00		 mov	 r9d, 3
  006ce	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161392
  006d5	ba 50 02 00 00	 mov	 edx, 592		; 00000250H
  006da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161393
  006e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN38@HelpComman:

; 593  :             }
; 594  :             rc = 0;

  006e7	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN37@HelpComman:

; 595  :         }
; 596  :     }

  006ef	e9 03 06 00 00	 jmp	 $LN27@HelpComman
$LN26@HelpComman:

; 597  :     else /* (argc == 2 && pfxlen < 0) "help cmd": Show help for given command */
; 598  :     {
; 599  :         char longflag;
; 600  :         size_t cmdlen, matchlen;
; 601  : 
; 602  :         for (pCmdTab = cmdtab; pCmdTab->statement; pCmdTab++)

  006f4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdtab
  006fb	48 89 44 24 60	 mov	 QWORD PTR pCmdTab$[rsp], rax
  00700	eb 0e		 jmp	 SHORT $LN13@HelpComman
$LN11@HelpComman:
  00702	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00707	48 83 c0 30	 add	 rax, 48			; 00000030H
  0070b	48 89 44 24 60	 mov	 QWORD PTR pCmdTab$[rsp], rax
$LN13@HelpComman:
  00710	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00715	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00719	0f 84 58 05 00
	00		 je	 $LN12@HelpComman

; 603  :         {
; 604  :             cmdlen = pCmdTab->mincmdlen ? pCmdTab->mincmdlen : strlen( pCmdTab->statement );

  0071f	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00724	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00729	74 13		 je	 SHORT $LN46@HelpComman
  0072b	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00730	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00734	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv327[rsp], rax
  0073c	eb 15		 jmp	 SHORT $LN47@HelpComman
$LN46@HelpComman:
  0073e	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00743	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00746	e8 00 00 00 00	 call	 strlen
  0074b	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv327[rsp], rax
$LN47@HelpComman:
  00753	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv327[rsp]
  0075b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR cmdlen$7[rsp], rax

; 605  :             matchlen = MAX( strlen(argv[1]), cmdlen );

  00763	b8 08 00 00 00	 mov	 eax, 8
  00768	48 6b c0 01	 imul	 rax, rax, 1
  0076c	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00774	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00778	e8 00 00 00 00	 call	 strlen
  0077d	48 3b 84 24 b0
	00 00 00	 cmp	 rax, QWORD PTR cmdlen$7[rsp]
  00785	76 24		 jbe	 SHORT $LN48@HelpComman
  00787	b8 08 00 00 00	 mov	 eax, 8
  0078c	48 6b c0 01	 imul	 rax, rax, 1
  00790	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00798	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  0079c	e8 00 00 00 00	 call	 strlen
  007a1	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv337[rsp], rax
  007a9	eb 10		 jmp	 SHORT $LN49@HelpComman
$LN48@HelpComman:
  007ab	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR cmdlen$7[rsp]
  007b3	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv337[rsp], rax
$LN49@HelpComman:
  007bb	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR tv337[rsp]
  007c3	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR matchlen$9[rsp], rax

; 606  : 
; 607  :             if (pCmdTab->type == SYSPROGDEVELDEBUG)

  007cb	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  007d0	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  007d4	83 f8 64	 cmp	 eax, 100		; 00000064H
  007d7	75 1b		 jne	 SHORT $LN39@HelpComman

; 608  :             {
; 609  :                 /* Special System Programmer Developer Debug command */
; 610  :                 /* Command Level must also be Debug too, else hidden */
; 611  :                 if ((sysblk.sysgroup & SYSGROUP_PROGDEVELDEBUG) != SYSGROUP_PROGDEVELDEBUG)

  007d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007e0	0f b6 80 2d 11
	00 00		 movzx	 eax, BYTE PTR [rax+4397]
  007e7	83 e0 64	 and	 eax, 100		; 00000064H
  007ea	83 f8 64	 cmp	 eax, 100		; 00000064H
  007ed	74 05		 je	 SHORT $LN40@HelpComman

; 612  :                     continue;

  007ef	e9 0e ff ff ff	 jmp	 $LN11@HelpComman
$LN40@HelpComman:
$LN39@HelpComman:

; 613  :             }
; 614  :             if (1
; 615  :                 && (pCmdTab->shortdesc)
; 616  :                 && (pCmdTab->type & sysblk.sysgroup)
; 617  :                 && !strncasecmp( argv[1], pCmdTab->statement, matchlen )

  007f4	33 c0		 xor	 eax, eax
  007f6	83 f8 01	 cmp	 eax, 1
  007f9	0f 84 73 04 00
	00		 je	 $LN41@HelpComman
  007ff	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00804	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0
  00809	0f 84 63 04 00
	00		 je	 $LN41@HelpComman
  0080f	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00814	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  00818	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0081f	0f b6 89 2d 11
	00 00		 movzx	 ecx, BYTE PTR [rcx+4397]
  00826	23 c1		 and	 eax, ecx
  00828	85 c0		 test	 eax, eax
  0082a	0f 84 42 04 00
	00		 je	 $LN41@HelpComman
  00830	b8 08 00 00 00	 mov	 eax, 8
  00835	48 6b c0 01	 imul	 rax, rax, 1
  00839	4c 8b 84 24 d8
	00 00 00	 mov	 r8, QWORD PTR matchlen$9[rsp]
  00841	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00846	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00849	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00851	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00855	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0085b	85 c0		 test	 eax, eax
  0085d	0f 85 0f 04 00
	00		 jne	 $LN41@HelpComman

; 618  :             )
; 619  :             {
; 620  :                 longflag = (pCmdTab->longdesc) ? '*' : ' ';

  00863	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00868	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0086d	74 0d		 je	 SHORT $LN50@HelpComman
  0086f	c7 84 24 90 00
	00 00 2a 00 00
	00		 mov	 DWORD PTR tv364[rsp], 42 ; 0000002aH
  0087a	eb 0b		 jmp	 SHORT $LN51@HelpComman
$LN50@HelpComman:
  0087c	c7 84 24 90 00
	00 00 20 00 00
	00		 mov	 DWORD PTR tv364[rsp], 32 ; 00000020H
$LN51@HelpComman:
  00887	0f b6 84 24 90
	00 00 00	 movzx	 eax, BYTE PTR tv364[rsp]
  0088f	88 44 24 74	 mov	 BYTE PTR longflag$3[rsp], al

; 621  : 
; 622  :                 WRMSG( HHC01603, "I", "" );

  00893	b9 01 00 00 00	 mov	 ecx, 1
  00898	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0089e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161397
  008a5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  008aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161398
  008b1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161399
  008bd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008c2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c7	41 b9 03 00 00
	00		 mov	 r9d, 3
  008cd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161400
  008d4	ba 6e 02 00 00	 mov	 edx, 622		; 0000026eH
  008d9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161401
  008e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 623  :                 WRMSG( HHC01602, "I", max_stmtlen, max_stmtlen, "Command         ", ' ', "Description" );

  008e6	b9 01 00 00 00	 mov	 ecx, 1
  008eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  008f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161402
  008f8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  008fd	c7 44 24 50 20
	00 00 00	 mov	 DWORD PTR [rsp+80], 32	; 00000020H
  00905	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161403
  0090c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00911	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  00915	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00919	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  0091d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00921	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161404
  00928	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0092d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161405
  00934	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00939	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0093e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00944	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161406
  0094b	ba 6f 02 00 00	 mov	 edx, 623		; 0000026fH
  00950	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161407
  00957	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 624  :                 WRMSG( HHC01602, "I", max_stmtlen, max_stmtlen, "----------------", ' ', "-------------------------------------------------------" );

  0095d	b9 01 00 00 00	 mov	 ecx, 1
  00962	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00968	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161408
  0096f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00974	c7 44 24 50 20
	00 00 00	 mov	 DWORD PTR [rsp+80], 32	; 00000020H
  0097c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161409
  00983	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00988	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  0098c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00990	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  00994	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00998	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161410
  0099f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009a4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161411
  009ab	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  009b0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  009b5	41 b9 03 00 00
	00		 mov	 r9d, 3
  009bb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161412
  009c2	ba 70 02 00 00	 mov	 edx, 624		; 00000270H
  009c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161413
  009ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 625  :                 WRMSG( HHC01602, "I", max_stmtlen, max_stmtlen, pCmdTab->statement, longflag, pCmdTab->shortdesc);

  009d4	0f be 44 24 74	 movsx	 eax, BYTE PTR longflag$3[rsp]
  009d9	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv406[rsp], eax
  009e0	b9 01 00 00 00	 mov	 ecx, 1
  009e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  009f0	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  009f4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  009f9	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv406[rsp]
  00a00	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00a04	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00a09	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00a0c	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00a11	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  00a15	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00a19	8b 4c 24 68	 mov	 ecx, DWORD PTR max_stmtlen$[rsp]
  00a1d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00a21	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161414
  00a28	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a2d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161415
  00a34	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a39	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a3e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a44	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161416
  00a4b	ba 71 02 00 00	 mov	 edx, 625		; 00000271H
  00a50	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161417
  00a57	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 626  : 
; 627  :                 if (pCmdTab->longdesc)

  00a5d	48 8b 44 24 60	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00a62	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00a67	0f 84 a8 01 00
	00		 je	 $LN42@HelpComman

; 628  :                 {
; 629  :                     char buf[257];
; 630  :                     int i = 0;

  00a6d	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR i$2[rsp], 0

; 631  :                     int j;
; 632  : 
; 633  :                     WRMSG( HHC01603, "I", "" );

  00a75	b9 01 00 00 00	 mov	 ecx, 1
  00a7a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00a80	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161419
  00a87	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00a8c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161420
  00a93	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00a98	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161421
  00a9f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00aa4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00aa9	41 b9 03 00 00
	00		 mov	 r9d, 3
  00aaf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161422
  00ab6	ba 79 02 00 00	 mov	 edx, 633		; 00000279H
  00abb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161423
  00ac2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN14@HelpComman:

; 634  :                     while(pCmdTab->longdesc[i])

  00ac8	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$2[rsp]
  00acd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00ad2	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00ad6	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00ada	85 c0		 test	 eax, eax
  00adc	0f 84 33 01 00
	00		 je	 $LN15@HelpComman

; 635  :                     {
; 636  :                         for(j = 0; j < (int)sizeof(buf)      &&

  00ae2	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR j$4[rsp], 0
  00aed	eb 1a		 jmp	 SHORT $LN18@HelpComman
$LN16@HelpComman:

; 638  :                                    pCmdTab->longdesc[i] != '\n'; i++, j++)

  00aef	8b 44 24 70	 mov	 eax, DWORD PTR i$2[rsp]
  00af3	ff c0		 inc	 eax
  00af5	89 44 24 70	 mov	 DWORD PTR i$2[rsp], eax
  00af9	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR j$4[rsp]
  00b00	ff c0		 inc	 eax
  00b02	89 84 24 80 00
	00 00		 mov	 DWORD PTR j$4[rsp], eax
$LN18@HelpComman:

; 637  :                                    pCmdTab->longdesc[i] &&

  00b09	81 bc 24 80 00
	00 00 01 01 00
	00		 cmp	 DWORD PTR j$4[rsp], 257	; 00000101H
  00b14	7d 50		 jge	 SHORT $LN17@HelpComman
  00b16	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$2[rsp]
  00b1b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00b20	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00b24	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00b28	85 c0		 test	 eax, eax
  00b2a	74 3a		 je	 SHORT $LN17@HelpComman
  00b2c	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$2[rsp]
  00b31	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00b36	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00b3a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00b3e	83 f8 0a	 cmp	 eax, 10
  00b41	74 23		 je	 SHORT $LN17@HelpComman

; 639  :                         {
; 640  :                             buf[j] = pCmdTab->longdesc[i];

  00b43	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$2[rsp]
  00b48	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00b4d	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00b51	48 63 94 24 80
	00 00 00	 movsxd	 rdx, DWORD PTR j$4[rsp]
  00b59	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00b5d	88 84 14 f0 00
	00 00		 mov	 BYTE PTR buf$10[rsp+rdx], al

; 641  :                         }

  00b64	eb 89		 jmp	 SHORT $LN16@HelpComman
$LN17@HelpComman:

; 642  : 
; 643  :                         buf[j] = '\0';

  00b66	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR j$4[rsp]
  00b6e	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR $T8[rsp], rax
  00b76	48 81 bc 24 c0
	00 00 00 01 01
	00 00		 cmp	 QWORD PTR $T8[rsp], 257	; 00000101H
  00b82	73 02		 jae	 SHORT $LN52@HelpComman
  00b84	eb 05		 jmp	 SHORT $LN53@HelpComman
$LN52@HelpComman:
  00b86	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN53@HelpComman:
  00b8b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR $T8[rsp]
  00b93	c6 84 04 f0 00
	00 00 00	 mov	 BYTE PTR buf$10[rsp+rax], 0

; 644  :                         if(pCmdTab->longdesc[i] == '\n')

  00b9b	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$2[rsp]
  00ba0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  00ba5	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00ba9	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00bad	83 f8 0a	 cmp	 eax, 10
  00bb0	75 0a		 jne	 SHORT $LN43@HelpComman

; 645  :                             i++;

  00bb2	8b 44 24 70	 mov	 eax, DWORD PTR i$2[rsp]
  00bb6	ff c0		 inc	 eax
  00bb8	89 44 24 70	 mov	 DWORD PTR i$2[rsp], eax
$LN43@HelpComman:

; 646  :                         WRMSG( HHC01603, "I", buf );

  00bbc	b9 01 00 00 00	 mov	 ecx, 1
  00bc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bc7	48 8d 8c 24 f0
	00 00 00	 lea	 rcx, QWORD PTR buf$10[rsp]
  00bcf	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00bd4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161425
  00bdb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00be0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161426
  00be7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00bec	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00bf1	41 b9 03 00 00
	00		 mov	 r9d, 3
  00bf7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161427
  00bfe	ba 86 02 00 00	 mov	 edx, 646		; 00000286H
  00c03	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161428
  00c0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 647  :                     }

  00c10	e9 b3 fe ff ff	 jmp	 $LN14@HelpComman
$LN15@HelpComman:
$LN42@HelpComman:

; 648  :                 }
; 649  :                 WRMSG( HHC01603, "I", "" );

  00c15	b9 01 00 00 00	 mov	 ecx, 1
  00c1a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c20	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161429
  00c27	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00c2c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161430
  00c33	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c38	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161431
  00c3f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c44	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c49	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c4f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161432
  00c56	ba 89 02 00 00	 mov	 edx, 649		; 00000289H
  00c5b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161433
  00c62	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 650  :                 rc = 0;

  00c68	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 651  :                 break;

  00c70	eb 05		 jmp	 SHORT $LN12@HelpComman
$LN41@HelpComman:

; 652  :             }
; 653  :         }

  00c72	e9 8b fa ff ff	 jmp	 $LN11@HelpComman
$LN12@HelpComman:

; 654  : 
; 655  :         if (rc == 1)  /* (not found?) */

  00c77	83 7c 24 7c 01	 cmp	 DWORD PTR rc$[rsp], 1
  00c7c	75 79		 jne	 SHORT $LN44@HelpComman

; 656  :         {
; 657  :             // "Unknown command %s, no help available"
; 658  :             WRMSG( HHC01604, "I", argv[1] );

  00c7e	b8 08 00 00 00	 mov	 eax, 8
  00c83	48 6b c0 01	 imul	 rax, rax, 1
  00c87	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv524[rsp], rax
  00c8f	b9 01 00 00 00	 mov	 ecx, 1
  00c94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c9a	48 8b 8c 24 28
	02 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00ca2	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR tv524[rsp]
  00caa	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00cae	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00cb3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161435
  00cba	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cbf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161436
  00cc6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00ccb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00cd0	41 b9 03 00 00
	00		 mov	 r9d, 3
  00cd6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161437
  00cdd	ba 92 02 00 00	 mov	 edx, 658		; 00000292H
  00ce2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161438
  00ce9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 659  :             rc = -1;

  00cef	c7 44 24 7c ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1
$LN44@HelpComman:
$LN27@HelpComman:

; 660  :         }
; 661  :     }
; 662  :     return rc;

  00cf7	8b 44 24 7c	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@HelpComman:
$LN45@HelpComman:

; 663  : }

  00cfb	48 8b 8c 24 00
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00d03	48 33 cc	 xor	 rcx, rsp
  00d06	e8 00 00 00 00	 call	 __security_check_cookie
  00d0b	48 81 c4 18 02
	00 00		 add	 rsp, 536		; 00000218H
  00d12	c3		 ret	 0
HelpCommand ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
i$ = 80
cmdent$ = 88
tv181 = 96
tv187 = 104
tv159 = 112
tv162 = 120
tv165 = 128
tv191 = 136
tv202 = 144
tv205 = 152
tv216 = 160
argc$ = 192
argv$ = 200
cmdline$ = 208
zapcmd_cmd PROC

; 129  : {

$LN29:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
$LN4@zapcmd_cmd:

; 130  : CMDTAB* cmdent;
; 131  : int i;
; 132  : 
; 133  : //  Format:
; 134  : //
; 135  : //      $zapcmd  cmdname  CFG|NOCFG|CMD|NOCMD
; 136  : //
; 137  : //  For normal non-DEBUG production release builds, use the sequence:
; 138  : //
; 139  : //      msglvl   VERBOSE      (optional)
; 140  : //      msglvl   DEBUG        (optional)
; 141  : //      cmdlvl   DEBUG        (*required!*) (because not DEBUG build,
; 142  : //      $zapcmd  cmdname  CMD                and $zapcmd is SYSDEBUG)
; 143  : //
; 144  : //  In other words, the $zapcmd is itself a "debug" level command, and
; 145  : //  thus in order to use it, the debug cmdlvl must be set first (which
; 146  : //  is the default for DEBUG builds but not for Release/Retail builds).
; 147  : 
; 148  :     UNREFERENCED(cmdline);

  00015	33 c0		 xor	 eax, eax
  00017	85 c0		 test	 eax, eax
  00019	75 fa		 jne	 SHORT $LN4@zapcmd_cmd

; 149  : 
; 150  :     if (argc > 1)

  0001b	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00023	0f 8e b0 03 00
	00		 jle	 $LN11@zapcmd_cmd

; 151  :     {
; 152  :         for (cmdent = cmdtab; cmdent->statement; cmdent++)

  00029	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdtab
  00030	48 89 44 24 58	 mov	 QWORD PTR cmdent$[rsp], rax
  00035	eb 0e		 jmp	 SHORT $LN7@zapcmd_cmd
$LN5@zapcmd_cmd:
  00037	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  0003c	48 83 c0 30	 add	 rax, 48			; 00000030H
  00040	48 89 44 24 58	 mov	 QWORD PTR cmdent$[rsp], rax
$LN7@zapcmd_cmd:
  00045	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  0004a	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  0004e	0f 84 ed 02 00
	00		 je	 $LN6@zapcmd_cmd

; 153  :         {
; 154  :             if (!strcasecmp(argv[1], cmdent->statement))

  00054	b8 08 00 00 00	 mov	 eax, 8
  00059	48 6b c0 01	 imul	 rax, rax, 1
  0005d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdent$[rsp]
  00062	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00065	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0006d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00077	85 c0		 test	 eax, eax
  00079	0f 85 bd 02 00
	00		 jne	 $LN13@zapcmd_cmd

; 155  :             {
; 156  :                 if (argc > 2)

  0007f	83 bc 24 c0 00
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00087	0f 8e ce 01 00
	00		 jle	 $LN14@zapcmd_cmd

; 157  :                     for (i = 2; i < argc; i++)

  0008d	c7 44 24 50 02
	00 00 00	 mov	 DWORD PTR i$[rsp], 2
  00095	eb 0a		 jmp	 SHORT $LN10@zapcmd_cmd
$LN8@zapcmd_cmd:
  00097	8b 44 24 50	 mov	 eax, DWORD PTR i$[rsp]
  0009b	ff c0		 inc	 eax
  0009d	89 44 24 50	 mov	 DWORD PTR i$[rsp], eax
$LN10@zapcmd_cmd:
  000a1	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  000a8	39 44 24 50	 cmp	 DWORD PTR i$[rsp], eax
  000ac	0f 8d a4 01 00
	00		 jge	 $LN9@zapcmd_cmd

; 158  :                     {
; 159  :                         if (!strcasecmp(argv[i],"Cfg"))

  000b2	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161077
  000be	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000c6	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  000d0	85 c0		 test	 eax, eax
  000d2	75 19		 jne	 SHORT $LN16@zapcmd_cmd

; 160  :                             cmdent->type |= SYSCONFIG;

  000d4	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  000d9	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  000dd	83 c8 10	 or	 eax, 16
  000e0	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdent$[rsp]
  000e5	88 41 28	 mov	 BYTE PTR [rcx+40], al
  000e8	e9 64 01 00 00	 jmp	 $LN17@zapcmd_cmd
$LN16@zapcmd_cmd:

; 161  :                         else
; 162  :                         if (!strcasecmp(argv[i],"NoCfg"))

  000ed	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161080
  000f9	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00101	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0010b	85 c0		 test	 eax, eax
  0010d	75 19		 jne	 SHORT $LN18@zapcmd_cmd

; 163  :                             cmdent->type &= ~SYSCONFIG;

  0010f	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  00114	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  00118	83 e0 ef	 and	 eax, -17
  0011b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdent$[rsp]
  00120	88 41 28	 mov	 BYTE PTR [rcx+40], al
  00123	e9 29 01 00 00	 jmp	 $LN19@zapcmd_cmd
$LN18@zapcmd_cmd:

; 164  :                         else
; 165  :                         if (!strcasecmp(argv[i],"Cmd"))

  00128	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161083
  00134	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0013c	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00140	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00146	85 c0		 test	 eax, eax
  00148	75 19		 jne	 SHORT $LN20@zapcmd_cmd

; 166  :                             cmdent->type |= SYSCMD;

  0014a	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  0014f	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  00153	83 c8 77	 or	 eax, 119		; 00000077H
  00156	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdent$[rsp]
  0015b	88 41 28	 mov	 BYTE PTR [rcx+40], al
  0015e	e9 ee 00 00 00	 jmp	 $LN21@zapcmd_cmd
$LN20@zapcmd_cmd:

; 167  :                         else
; 168  :                         if (!strcasecmp(argv[i],"NoCmd"))

  00163	48 63 44 24 50	 movsxd	 rax, DWORD PTR i$[rsp]
  00168	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161086
  0016f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00177	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  00181	85 c0		 test	 eax, eax
  00183	75 19		 jne	 SHORT $LN22@zapcmd_cmd

; 169  :                             cmdent->type &= ~SYSCMD;

  00185	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  0018a	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  0018e	83 e0 88	 and	 eax, -120		; ffffffffffffff88H
  00191	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdent$[rsp]
  00196	88 41 28	 mov	 BYTE PTR [rcx+40], al
  00199	e9 b3 00 00 00	 jmp	 $LN23@zapcmd_cmd
$LN22@zapcmd_cmd:

; 170  :                         else
; 171  :                         {
; 172  :                             LOGMSG( "Invalid arg: %s: %s %s [(No)Cfg|(No)Cmd]\n",

  0019e	b8 08 00 00 00	 mov	 eax, 8
  001a3	48 6b c0 01	 imul	 rax, rax, 1
  001a7	48 89 44 24 70	 mov	 QWORD PTR tv159[rsp], rax
  001ac	b9 08 00 00 00	 mov	 ecx, 8
  001b1	48 6b c9 00	 imul	 rcx, rcx, 0
  001b5	48 89 4c 24 78	 mov	 QWORD PTR tv162[rsp], rcx
  001ba	48 63 54 24 50	 movsxd	 rdx, DWORD PTR i$[rsp]
  001bf	48 89 94 24 80
	00 00 00	 mov	 QWORD PTR tv165[rsp], rdx
  001c7	b9 01 00 00 00	 mov	 ecx, 1
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d2	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001da	48 8b 54 24 70	 mov	 rdx, QWORD PTR tv159[rsp]
  001df	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001e3	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001e8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  001f0	48 8b 54 24 78	 mov	 rdx, QWORD PTR tv162[rsp]
  001f5	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  001f9	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001fe	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00206	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR tv165[rsp]
  0020e	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00212	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00217	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161087
  0021e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00223	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00228	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161088
  00235	ba ad 00 00 00	 mov	 edx, 173		; 000000adH
  0023a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161089
  00241	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 173  :                                 argv[i], argv[0], argv[1] );
; 174  :                             return -1;

  00247	b8 ff ff ff ff	 mov	 eax, -1
  0024c	e9 f2 01 00 00	 jmp	 $LN1@zapcmd_cmd
$LN23@zapcmd_cmd:
$LN21@zapcmd_cmd:
$LN19@zapcmd_cmd:
$LN17@zapcmd_cmd:

; 175  :                         }
; 176  :                     }

  00251	e9 41 fe ff ff	 jmp	 $LN8@zapcmd_cmd
$LN9@zapcmd_cmd:
  00256	e9 da 00 00 00	 jmp	 $LN15@zapcmd_cmd
$LN14@zapcmd_cmd:

; 177  :                 else
; 178  :                     LOGMSG( "%s: %s(%sCfg,%sCmd)\n", argv[0], cmdent->statement,

  0025b	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  00260	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  00264	83 e0 77	 and	 eax, 119		; 00000077H
  00267	85 c0		 test	 eax, eax
  00269	74 0e		 je	 SHORT $LN25@zapcmd_cmd
  0026b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161090
  00272	48 89 44 24 60	 mov	 QWORD PTR tv181[rsp], rax
  00277	eb 0c		 jmp	 SHORT $LN26@zapcmd_cmd
$LN25@zapcmd_cmd:
  00279	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161091
  00280	48 89 44 24 60	 mov	 QWORD PTR tv181[rsp], rax
$LN26@zapcmd_cmd:
  00285	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdent$[rsp]
  0028a	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  0028e	83 e0 10	 and	 eax, 16
  00291	85 c0		 test	 eax, eax
  00293	74 0e		 je	 SHORT $LN27@zapcmd_cmd
  00295	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161092
  0029c	48 89 44 24 68	 mov	 QWORD PTR tv187[rsp], rax
  002a1	eb 0c		 jmp	 SHORT $LN28@zapcmd_cmd
$LN27@zapcmd_cmd:
  002a3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161093
  002aa	48 89 44 24 68	 mov	 QWORD PTR tv187[rsp], rax
$LN28@zapcmd_cmd:
  002af	b8 08 00 00 00	 mov	 eax, 8
  002b4	48 6b c0 00	 imul	 rax, rax, 0
  002b8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv191[rsp], rax
  002c0	b9 01 00 00 00	 mov	 ecx, 1
  002c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002cb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv181[rsp]
  002d0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002d5	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv187[rsp]
  002da	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  002df	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cmdent$[rsp]
  002e4	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  002e7	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002ec	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  002f4	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR tv191[rsp]
  002fc	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00300	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00305	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161094
  0030c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00311	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00316	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161095
  00323	ba b4 00 00 00	 mov	 edx, 180		; 000000b4H
  00328	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161096
  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN15@zapcmd_cmd:

; 179  :                       (cmdent->type & SYSCONFIG) ? "" : "No",
; 180  :                       (cmdent->type & SYSCMD)    ? "" : "No" );
; 181  :                 return 0;

  00335	33 c0		 xor	 eax, eax
  00337	e9 07 01 00 00	 jmp	 $LN1@zapcmd_cmd
$LN13@zapcmd_cmd:

; 182  :             }
; 183  :         }

  0033c	e9 f6 fc ff ff	 jmp	 $LN5@zapcmd_cmd
$LN6@zapcmd_cmd:

; 184  :         LOGMSG( "%s: %s not in command table\n", argv[0], argv[1] );

  00341	b8 08 00 00 00	 mov	 eax, 8
  00346	48 6b c0 01	 imul	 rax, rax, 1
  0034a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv202[rsp], rax
  00352	b9 08 00 00 00	 mov	 ecx, 8
  00357	48 6b c9 00	 imul	 rcx, rcx, 0
  0035b	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv205[rsp], rcx
  00363	b9 01 00 00 00	 mov	 ecx, 1
  00368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036e	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00376	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR tv202[rsp]
  0037e	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00382	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00387	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0038f	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR tv205[rsp]
  00397	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0039b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161097
  003a7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003ac	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b1	41 b9 03 00 00
	00		 mov	 r9d, 3
  003b7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161098
  003be	ba b8 00 00 00	 mov	 edx, 184		; 000000b8H
  003c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161099
  003ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 185  :         return -1;

  003d0	b8 ff ff ff ff	 mov	 eax, -1
  003d5	eb 6c		 jmp	 SHORT $LN1@zapcmd_cmd

; 186  :     }

  003d7	eb 65		 jmp	 SHORT $LN12@zapcmd_cmd
$LN11@zapcmd_cmd:

; 187  :     else
; 188  :         LOGMSG( "Usage: %s <command> [(No)Cfg|(No)Cmd]\n", argv[0] );

  003d9	b8 08 00 00 00	 mov	 eax, 8
  003de	48 6b c0 00	 imul	 rax, rax, 0
  003e2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv216[rsp], rax
  003ea	b9 01 00 00 00	 mov	 ecx, 1
  003ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003f5	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003fd	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR tv216[rsp]
  00405	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00409	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0040e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161100
  00415	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0041a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00425	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161101
  0042c	ba bc 00 00 00	 mov	 edx, 188		; 000000bcH
  00431	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161102
  00438	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN12@zapcmd_cmd:

; 189  :     return -1;

  0043e	b8 ff ff ff ff	 mov	 eax, -1
$LN1@zapcmd_cmd:

; 190  : }

  00443	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  0044a	c3		 ret	 0
zapcmd_cmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
pCmdLine$ = 32
mask$1 = 40
scpecho$2 = 41
priomsg$3 = 42
i$ = 44
hercecho$ = 48
rc$ = 52
tv204 = 56
tv206 = 60
tv212 = 64
tv214 = 68
tv220 = 72
tv222 = 76
first_cmd$4 = 80
cl$5 = 88
firstsep$6 = 96
sepcharindex$7 = 104
$T8 = 112
$T9 = 120
rc$10 = 128
cmd$ = 144
__$ArrayPad$ = 32912
cmdline$ = 32944
the_real_panel_command PROC

; 693  : {

$LN52:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	b8 a8 80 00 00	 mov	 eax, 32936		; 000080a8H
  0000a	e8 00 00 00 00	 call	 __chkstk
  0000f	48 2b e0	 sub	 rsp, rax
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 84 24 90
	80 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 694  : #define MAX_CMD_LEN (32768)
; 695  : 
; 696  :     char  cmd[ MAX_CMD_LEN ];           /* Copy of panel command     */
; 697  :     char* pCmdLine;
; 698  :     unsigned i;
; 699  :     int hercecho = 1;                   /* Default echo to console   */

  00024	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR hercecho$[rsp], 1

; 700  :     int rc = 0;                         /* Return Code from command  */

  0002c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 701  : 
; 702  :     /* Handle command separation */
; 703  :     if (sysblk.cmdsep)

  00034	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0003b	0f be 80 2c 11
	00 00		 movsx	 eax, BYTE PTR [rax+4396]
  00042	85 c0		 test	 eax, eax
  00044	0f 84 b5 00 00
	00		 je	 $LN14@the_real_p

; 704  :     {
; 705  :         /* Does cmdline contain any separator characters? */
; 706  :         char*  firstsep  = strchr( cmdline, sysblk.cmdsep );

  0004a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00051	0f be 80 2c 11
	00 00		 movsx	 eax, BYTE PTR [rax+4396]
  00058	8b d0		 mov	 edx, eax
  0005a	48 8b 8c 24 b0
	80 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00062	e8 00 00 00 00	 call	 strchr
  00067	48 89 44 24 60	 mov	 QWORD PTR firstsep$6[rsp], rax

; 707  :         if (firstsep)

  0006c	48 83 7c 24 60
	00		 cmp	 QWORD PTR firstsep$6[rsp], 0
  00072	0f 84 87 00 00
	00		 je	 $LN15@the_real_p

; 708  :         {
; 709  :             /* Yes! Must process commands separately */
; 710  :             void*   rc;
; 711  :             size_t  sepcharindex  = (firstsep - cmdline);

  00078	48 8b 84 24 b0
	80 00 00	 mov	 rax, QWORD PTR cmdline$[rsp]
  00080	48 8b 4c 24 60	 mov	 rcx, QWORD PTR firstsep$6[rsp]
  00085	48 2b c8	 sub	 rcx, rax
  00088	48 8b c1	 mov	 rax, rcx
  0008b	48 89 44 24 68	 mov	 QWORD PTR sepcharindex$7[rsp], rax

; 712  :             char*   first_cmd     = strdup( cmdline );

  00090	48 8b 8c 24 b0
	80 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  0009e	48 89 44 24 50	 mov	 QWORD PTR first_cmd$4[rsp], rax

; 713  : 
; 714  :             /* Mark end of first command */
; 715  :             first_cmd[ sepcharindex ] = 0;

  000a3	48 8b 44 24 68	 mov	 rax, QWORD PTR sepcharindex$7[rsp]
  000a8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR first_cmd$4[rsp]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	48 8b c1	 mov	 rax, rcx
  000b3	c6 00 00	 mov	 BYTE PTR [rax], 0

; 716  : 
; 717  :             /* Process first command */
; 718  :             panel_command( first_cmd );

  000b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR first_cmd$4[rsp]
  000bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  000c2	ff 10		 call	 QWORD PTR [rax]

; 719  : 
; 720  :             /* Process remaining command(s) */
; 721  :             rc = panel_command( first_cmd + sepcharindex + 1 );

  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR first_cmd$4[rsp]
  000c9	48 8b 4c 24 68	 mov	 rcx, QWORD PTR sepcharindex$7[rsp]
  000ce	48 8d 44 08 01	 lea	 rax, QWORD PTR [rax+rcx+1]
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_panel_command
  000dd	ff 10		 call	 QWORD PTR [rax]
  000df	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR rc$10[rsp], rax

; 722  : 
; 723  :             /* Prevent memory leak */
; 724  :             free( first_cmd );

  000e7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR first_cmd$4[rsp]
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 725  : 
; 726  :             /* Return with retcode of second command */
; 727  :             return rc;

  000f2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR rc$10[rsp]
  000fa	e9 9a 04 00 00	 jmp	 $LN1@the_real_p
$LN15@the_real_p:
$LN14@the_real_p:

; 728  :         }
; 729  :     }
; 730  : 
; 731  :     pCmdLine = cmdline; ASSERT( pCmdLine );

  000ff	48 8b 84 24 b0
	80 00 00	 mov	 rax, QWORD PTR cmdline$[rsp]
  00107	48 89 44 24 20	 mov	 QWORD PTR pCmdLine$[rsp], rax
$LN4@the_real_p:
  0010c	48 83 7c 24 20
	00		 cmp	 QWORD PTR pCmdLine$[rsp], 0
  00112	75 5c		 jne	 SHORT $LN16@the_real_p
$LN7@the_real_p:
  00114	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161491
  0011b	41 b8 db 02 00
	00		 mov	 r8d, 731		; 000002dbH
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161492
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161493
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0013b	85 c0		 test	 eax, eax
  0013d	74 20		 je	 SHORT $LN17@the_real_p
  0013f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161495
  00146	41 b8 db 02 00
	00		 mov	 r8d, 731		; 000002dbH
  0014c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161496
  00153	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161497
  0015a	e8 00 00 00 00	 call	 DebuggerTrace
$LN17@the_real_p:
  0015f	33 c0		 xor	 eax, eax
  00161	85 c0		 test	 eax, eax
  00163	75 af		 jne	 SHORT $LN7@the_real_p
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016b	85 c0		 test	 eax, eax
  0016d	74 01		 je	 SHORT $LN18@the_real_p
  0016f	cc		 int	 3
$LN18@the_real_p:
$LN16@the_real_p:
  00170	33 c0		 xor	 eax, eax
  00172	85 c0		 test	 eax, eax
  00174	75 96		 jne	 SHORT $LN4@the_real_p

; 732  : 
; 733  :     /* Every command will be stored in history list,
; 734  :        EXCEPT: null commands, script commands, scp input,
; 735  :        and "silent" commands (prefixed with '-')
; 736  :     */
; 737  :     if (*pCmdLine != 0 && !FindSCRCTL( thread_id() ))

  00176	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  0017b	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0017e	85 c0		 test	 eax, eax
  00180	74 6c		 je	 SHORT $LN19@the_real_p
  00182	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00188	8b c8		 mov	 ecx, eax
  0018a	e8 00 00 00 00	 call	 FindSCRCTL
  0018f	48 85 c0	 test	 rax, rax
  00192	75 5a		 jne	 SHORT $LN19@the_real_p

; 738  :     {
; 739  :         if (!(*pCmdLine == '-'))    /* (normal command?) */

  00194	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  00199	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0019c	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  0019f	74 4d		 je	 SHORT $LN20@the_real_p

; 740  :         {
; 741  : 
; 742  : #if defined( _FEATURE_SYSTEM_CONSOLE )
; 743  : 
; 744  :             if (*pCmdLine == '.' || *pCmdLine == '!')

  001a1	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  001a6	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001a9	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  001ac	74 0d		 je	 SHORT $LN23@the_real_p
  001ae	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  001b3	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001b6	83 f8 21	 cmp	 eax, 33			; 00000021H
  001b9	75 26		 jne	 SHORT $LN21@the_real_p
$LN23@the_real_p:

; 745  :             {
; 746  :                 if (sysblk.scpecho)

  001bb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c2	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001c8	c1 e8 05	 shr	 eax, 5
  001cb	83 e0 01	 and	 eax, 1
  001ce	85 c0		 test	 eax, eax
  001d0	74 0d		 je	 SHORT $LN24@the_real_p

; 747  :                     history_add( cmdline );

  001d2	48 8b 8c 24 b0
	80 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  001da	e8 00 00 00 00	 call	 history_add
$LN24@the_real_p:

; 748  :             }

  001df	eb 0d		 jmp	 SHORT $LN22@the_real_p
$LN21@the_real_p:

; 749  :             else
; 750  : 
; 751  : #endif /* defined( _FEATURE_SYSTEM_CONSOLE ) */
; 752  : 
; 753  :                 history_add( cmdline );

  001e1	48 8b 8c 24 b0
	80 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  001e9	e8 00 00 00 00	 call	 history_add
$LN22@the_real_p:
$LN20@the_real_p:
$LN19@the_real_p:

; 754  :         }
; 755  :     }
; 756  : 
; 757  :     /* Copy panel command to work area, skipping leading blanks.
; 758  :        If the command starts with a -, then strip it and indicate
; 759  :        that we do NOT want the command echoed to the console.
; 760  :     */
; 761  :     hercecho = 1;   // (default)

  001ee	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR hercecho$[rsp], 1
$LN8@the_real_p:

; 762  : 
; 763  :     while (*pCmdLine && isspace( *pCmdLine ))

  001f6	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  001fb	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001fe	85 c0		 test	 eax, eax
  00200	74 23		 je	 SHORT $LN9@the_real_p
  00202	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  00207	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0020a	8b c8		 mov	 ecx, eax
  0020c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  00212	85 c0		 test	 eax, eax
  00214	74 0f		 je	 SHORT $LN9@the_real_p

; 764  :         pCmdLine++;

  00216	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  0021b	48 ff c0	 inc	 rax
  0021e	48 89 44 24 20	 mov	 QWORD PTR pCmdLine$[rsp], rax
  00223	eb d1		 jmp	 SHORT $LN8@the_real_p
$LN9@the_real_p:

; 765  : 
; 766  :     i = 0;

  00225	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
$LN10@the_real_p:

; 767  : 
; 768  :     while (*pCmdLine && i < (MAX_CMD_LEN-1))

  0022d	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  00232	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00235	85 c0		 test	 eax, eax
  00237	0f 84 b5 00 00
	00		 je	 $LN11@the_real_p
  0023d	81 7c 24 2c ff
	7f 00 00	 cmp	 DWORD PTR i$[rsp], 32767 ; 00007fffH
  00245	0f 83 a7 00 00
	00		 jae	 $LN11@the_real_p

; 769  :     {
; 770  :         if (i == 0 && (0            /* (1st character?) */

  0024b	83 7c 24 2c 00	 cmp	 DWORD PTR i$[rsp], 0
  00250	75 71		 jne	 SHORT $LN25@the_real_p
  00252	33 c0		 xor	 eax, eax
  00254	85 c0		 test	 eax, eax
  00256	75 1a		 jne	 SHORT $LN26@the_real_p
  00258	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  0025d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00260	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00263	74 0d		 je	 SHORT $LN26@the_real_p
  00265	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  0026a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0026d	83 f8 23	 cmp	 eax, 35			; 00000023H
  00270	75 51		 jne	 SHORT $LN25@the_real_p
$LN26@the_real_p:

; 771  :             || *pCmdLine == '-'     /* (silent command) */
; 772  :             || *pCmdLine == '#'     /* (silent comment) */
; 773  :         ))
; 774  :         {
; 775  :             hercecho = 0;           /* (silence please) */

  00272	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hercecho$[rsp], 0

; 776  : 
; 777  :             if (*pCmdLine == '-')   /* (silent command?)*/

  0027a	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  0027f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00282	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00285	75 3c		 jne	 SHORT $LN27@the_real_p

; 778  :             {
; 779  :                 pCmdLine++;         /* (skip past the '-' ... */

  00287	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  0028c	48 ff c0	 inc	 rax
  0028f	48 89 44 24 20	 mov	 QWORD PTR pCmdLine$[rsp], rax
$LN12@the_real_p:

; 780  :                                     /* ... and remove blanks) */
; 781  : 
; 782  :                 while (*pCmdLine && isspace( *pCmdLine ))

  00294	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  00299	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0029c	85 c0		 test	 eax, eax
  0029e	74 23		 je	 SHORT $LN13@the_real_p
  002a0	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  002a5	0f be 00	 movsx	 eax, BYTE PTR [rax]
  002a8	8b c8		 mov	 ecx, eax
  002aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  002b0	85 c0		 test	 eax, eax
  002b2	74 0f		 je	 SHORT $LN13@the_real_p

; 783  :                     pCmdLine++;     /* (get past blank) */

  002b4	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  002b9	48 ff c0	 inc	 rax
  002bc	48 89 44 24 20	 mov	 QWORD PTR pCmdLine$[rsp], rax
  002c1	eb d1		 jmp	 SHORT $LN12@the_real_p
$LN13@the_real_p:
$LN27@the_real_p:
$LN25@the_real_p:

; 784  :             }
; 785  :         }
; 786  : 
; 787  :         cmd[i] = *pCmdLine;

  002c3	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  002c7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pCmdLine$[rsp]
  002cc	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  002cf	88 8c 04 90 00
	00 00		 mov	 BYTE PTR cmd$[rsp+rax], cl

; 788  :         i++;

  002d6	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  002da	ff c0		 inc	 eax
  002dc	89 44 24 2c	 mov	 DWORD PTR i$[rsp], eax

; 789  :         pCmdLine++;

  002e0	48 8b 44 24 20	 mov	 rax, QWORD PTR pCmdLine$[rsp]
  002e5	48 ff c0	 inc	 rax
  002e8	48 89 44 24 20	 mov	 QWORD PTR pCmdLine$[rsp], rax

; 790  :     }

  002ed	e9 3b ff ff ff	 jmp	 $LN10@the_real_p
$LN11@the_real_p:

; 791  :     cmd[i] = 0;

  002f2	8b 44 24 2c	 mov	 eax, DWORD PTR i$[rsp]
  002f6	48 89 44 24 70	 mov	 QWORD PTR $T8[rsp], rax
  002fb	48 81 7c 24 70
	00 80 00 00	 cmp	 QWORD PTR $T8[rsp], 32768 ; 00008000H
  00304	73 02		 jae	 SHORT $LN36@the_real_p
  00306	eb 05		 jmp	 SHORT $LN37@the_real_p
$LN36@the_real_p:
  00308	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN37@the_real_p:
  0030d	48 8b 44 24 70	 mov	 rax, QWORD PTR $T8[rsp]
  00312	c6 84 04 90 00
	00 00 00	 mov	 BYTE PTR cmd$[rsp+rax], 0

; 792  : 
; 793  :     /* (just pressing the enter key shouldn't be echoed) */
; 794  :     if (0 == cmd[0])

  0031a	b8 01 00 00 00	 mov	 eax, 1
  0031f	48 6b c0 00	 imul	 rax, rax, 0
  00323	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  0032b	85 c0		 test	 eax, eax
  0032d	75 08		 jne	 SHORT $LN28@the_real_p

; 795  :         hercecho = 0;               /* (silence please) */

  0032f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hercecho$[rsp], 0
$LN28@the_real_p:

; 796  : 
; 797  : #if defined( _FEATURE_SYSTEM_CONSOLE )
; 798  : 
; 799  :     /* Check if SCP command */
; 800  :     if (0
; 801  :         || cmd[0] == '.'
; 802  :         || cmd[0] == '!'
; 803  :         || cmd[0] == '\\'

  00337	33 c0		 xor	 eax, eax
  00339	85 c0		 test	 eax, eax
  0033b	75 46		 jne	 SHORT $LN31@the_real_p
  0033d	b8 01 00 00 00	 mov	 eax, 1
  00342	48 6b c0 00	 imul	 rax, rax, 0
  00346	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  0034e	83 f8 2e	 cmp	 eax, 46			; 0000002eH
  00351	74 30		 je	 SHORT $LN31@the_real_p
  00353	b8 01 00 00 00	 mov	 eax, 1
  00358	48 6b c0 00	 imul	 rax, rax, 0
  0035c	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  00364	83 f8 21	 cmp	 eax, 33			; 00000021H
  00367	74 1a		 je	 SHORT $LN31@the_real_p
  00369	b8 01 00 00 00	 mov	 eax, 1
  0036e	48 6b c0 00	 imul	 rax, rax, 0
  00372	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  0037a	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0037d	0f 85 5c 01 00
	00		 jne	 $LN29@the_real_p
$LN31@the_real_p:

; 804  :     )
; 805  :     {
; 806  :         bool  priomsg  = cmd[0] == '!'  ? true : false;

  00383	b8 01 00 00 00	 mov	 eax, 1
  00388	48 6b c0 00	 imul	 rax, rax, 0
  0038c	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  00394	83 f8 21	 cmp	 eax, 33			; 00000021H
  00397	75 0a		 jne	 SHORT $LN38@the_real_p
  00399	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv204[rsp], 1
  003a1	eb 08		 jmp	 SHORT $LN39@the_real_p
$LN38@the_real_p:
  003a3	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv204[rsp], 0
$LN39@the_real_p:
  003ab	83 7c 24 38 00	 cmp	 DWORD PTR tv204[rsp], 0
  003b0	75 0a		 jne	 SHORT $LN40@the_real_p
  003b2	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv206[rsp], 0
  003ba	eb 08		 jmp	 SHORT $LN41@the_real_p
$LN40@the_real_p:
  003bc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv206[rsp], 1
$LN41@the_real_p:
  003c4	0f b6 44 24 3c	 movzx	 eax, BYTE PTR tv206[rsp]
  003c9	88 44 24 2a	 mov	 BYTE PTR priomsg$3[rsp], al

; 807  :         bool  scpecho  = sysblk.scpecho ? true : false;

  003cd	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003d4	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  003da	c1 e8 05	 shr	 eax, 5
  003dd	83 e0 01	 and	 eax, 1
  003e0	85 c0		 test	 eax, eax
  003e2	74 0a		 je	 SHORT $LN42@the_real_p
  003e4	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv212[rsp], 1
  003ec	eb 08		 jmp	 SHORT $LN43@the_real_p
$LN42@the_real_p:
  003ee	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv212[rsp], 0
$LN43@the_real_p:
  003f6	83 7c 24 40 00	 cmp	 DWORD PTR tv212[rsp], 0
  003fb	75 0a		 jne	 SHORT $LN44@the_real_p
  003fd	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv214[rsp], 0
  00405	eb 08		 jmp	 SHORT $LN45@the_real_p
$LN44@the_real_p:
  00407	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv214[rsp], 1
$LN45@the_real_p:
  0040f	0f b6 44 24 44	 movzx	 eax, BYTE PTR tv214[rsp]
  00414	88 44 24 29	 mov	 BYTE PTR scpecho$2[rsp], al

; 808  :         bool  mask     = cmd[0] == '\\' ? true : false;

  00418	b8 01 00 00 00	 mov	 eax, 1
  0041d	48 6b c0 00	 imul	 rax, rax, 0
  00421	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  00429	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  0042c	75 0a		 jne	 SHORT $LN46@the_real_p
  0042e	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv220[rsp], 1
  00436	eb 08		 jmp	 SHORT $LN47@the_real_p
$LN46@the_real_p:
  00438	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv220[rsp], 0
$LN47@the_real_p:
  00440	83 7c 24 48 00	 cmp	 DWORD PTR tv220[rsp], 0
  00445	75 0a		 jne	 SHORT $LN48@the_real_p
  00447	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv222[rsp], 0
  0044f	eb 08		 jmp	 SHORT $LN49@the_real_p
$LN48@the_real_p:
  00451	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv222[rsp], 1
$LN49@the_real_p:
  00459	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv222[rsp]
  0045e	88 44 24 28	 mov	 BYTE PTR mask$1[rsp], al

; 809  : 
; 810  :         if (!cmd[1]) {      /* (empty command given?) */

  00462	b8 01 00 00 00	 mov	 eax, 1
  00467	48 6b c0 01	 imul	 rax, rax, 1
  0046b	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  00473	85 c0		 test	 eax, eax
  00475	75 3e		 jne	 SHORT $LN32@the_real_p

; 811  :             cmd[1] = ' ';   /* (must send something!) */

  00477	b8 01 00 00 00	 mov	 eax, 1
  0047c	48 6b c0 01	 imul	 rax, rax, 1
  00480	c6 84 04 90 00
	00 00 20	 mov	 BYTE PTR cmd$[rsp+rax], 32 ; 00000020H

; 812  :             cmd[2] = 0;

  00488	b8 01 00 00 00	 mov	 eax, 1
  0048d	48 6b c0 02	 imul	 rax, rax, 2
  00491	48 89 44 24 78	 mov	 QWORD PTR $T9[rsp], rax
  00496	48 81 7c 24 78
	00 80 00 00	 cmp	 QWORD PTR $T9[rsp], 32768 ; 00008000H
  0049f	73 02		 jae	 SHORT $LN50@the_real_p
  004a1	eb 05		 jmp	 SHORT $LN51@the_real_p
$LN50@the_real_p:
  004a3	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN51@the_real_p:
  004a8	48 8b 44 24 78	 mov	 rax, QWORD PTR $T9[rsp]
  004ad	c6 84 04 90 00
	00 00 00	 mov	 BYTE PTR cmd$[rsp+rax], 0
$LN32@the_real_p:

; 813  :         }
; 814  : 
; 815  :         rc = scp_command( cmd+1, priomsg, scpecho, mask );

  004b5	48 8d 84 24 91
	00 00 00	 lea	 rax, QWORD PTR cmd$[rsp+1]
  004bd	44 0f b6 4c 24
	28		 movzx	 r9d, BYTE PTR mask$1[rsp]
  004c3	44 0f b6 44 24
	29		 movzx	 r8d, BYTE PTR scpecho$2[rsp]
  004c9	0f b6 54 24 2a	 movzx	 edx, BYTE PTR priomsg$3[rsp]
  004ce	48 8b c8	 mov	 rcx, rax
  004d1	e8 00 00 00 00	 call	 scp_command
  004d6	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 816  :     }

  004da	e9 b5 00 00 00	 jmp	 $LN30@the_real_p
$LN29@the_real_p:

; 817  :     else
; 818  : 
; 819  : #endif /* defined( _FEATURE_SYSTEM_CONSOLE ) */
; 820  : 
; 821  :     /* Perform variable substitution */
; 822  :     {
; 823  :         char* cl;
; 824  : 
; 825  :         set_symbol( "CUU",  "$(CUU)"  );

  004df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161513
  004e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161514
  004ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 826  :         set_symbol( "CCUU", "$(CCUU)" );

  004f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161515
  004fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161516
  00501	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 827  :         set_symbol( "DEVN", "$(DEVN)" );

  00507	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161517
  0050e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161518
  00515	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_set_symbol

; 828  : 
; 829  :         cl = resolve_symbol_string( cmd );

  0051b	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_resolve_symbol_string
  00529	48 89 44 24 58	 mov	 QWORD PTR cl$5[rsp], rax

; 830  : 
; 831  :         if (cl)

  0052e	48 83 7c 24 58
	00		 cmp	 QWORD PTR cl$5[rsp], 0
  00534	74 24		 je	 SHORT $LN33@the_real_p

; 832  :         {
; 833  :             STRLCPY( cmd, cl );

  00536	41 b8 00 80 00
	00		 mov	 r8d, 32768		; 00008000H
  0053c	48 8b 54 24 58	 mov	 rdx, QWORD PTR cl$5[rsp]
  00541	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  00549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 834  :             free( cl );

  0054f	48 8b 4c 24 58	 mov	 rcx, QWORD PTR cl$5[rsp]
  00554	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN33@the_real_p:

; 835  :         }
; 836  : 
; 837  :         if (hercecho && *cmd)

  0055a	83 7c 24 30 00	 cmp	 DWORD PTR hercecho$[rsp], 0
  0055f	74 22		 je	 SHORT $LN34@the_real_p
  00561	b8 01 00 00 00	 mov	 eax, 1
  00566	48 6b c0 00	 imul	 rax, rax, 0
  0056a	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR cmd$[rsp+rax]
  00572	85 c0		 test	 eax, eax
  00574	74 0d		 je	 SHORT $LN34@the_real_p

; 838  :             EchoHercCmdLine( cmd );

  00576	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  0057e	e8 00 00 00 00	 call	 EchoHercCmdLine
$LN34@the_real_p:

; 839  : 
; 840  :         rc = HercCmdLine( cmd );

  00583	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cmd$[rsp]
  0058b	e8 00 00 00 00	 call	 HercCmdLine
  00590	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax
$LN30@the_real_p:

; 841  :     }
; 842  : 
; 843  :     return (void*)((uintptr_t)rc);

  00594	48 63 44 24 34	 movsxd	 rax, DWORD PTR rc$[rsp]
$LN1@the_real_p:
$LN35@the_real_p:

; 844  : }

  00599	48 8b 8c 24 90
	80 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005a1	48 33 cc	 xor	 rcx, rsp
  005a4	e8 00 00 00 00	 call	 __security_check_cookie
  005a9	48 81 c4 a8 80
	00 00		 add	 rsp, 32936		; 000080a8H
  005b0	c3		 ret	 0
the_real_panel_command ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
rc$ = 48
i$1 = 52
len$2 = 56
isdiag$ = 60
pCmdTab$ = 64
bgcmd$3 = 72
tv206 = 80
cmdlen$ = 88
tv216 = 96
tid$4 = 104
matchlen$ = 112
tv275 = 120
tv303 = 128
cmd$5 = 144
__$ArrayPad$ = 400
argc$ = 432
argv$ = 440
cmdline$ = 448
CallHercCmd PROC

; 232  : {

$LN51:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 81 ec a8 01
	00 00		 sub	 rsp, 424		; 000001a8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 233  : CMDTAB* pCmdTab;
; 234  : size_t  cmdlen, matchlen;
; 235  : int     rc = HERRINVCMD;             /* Default to invalid command   */

  00027	c7 44 24 30 01
	80 ff ff	 mov	 DWORD PTR rc$[rsp], -32767 ; ffffffffffff8001H

; 236  : bool    isdiag;
; 237  : 
; 238  :     /* Let 'cscript' command run immediately in any context */
; 239  :     if (argc >= 1 && strcasecmp( argv[0], "cscript" ) == 0)

  0002f	83 bc 24 b0 01
	00 00 01	 cmp	 DWORD PTR argc$[rsp], 1
  00037	7c 47		 jl	 SHORT $LN17@CallHercCm
  00039	b8 08 00 00 00	 mov	 eax, 8
  0003e	48 6b c0 00	 imul	 rax, rax, 0
  00042	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161172
  00049	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00051	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp
  0005b	85 c0		 test	 eax, eax
  0005d	75 21		 jne	 SHORT $LN17@CallHercCm

; 240  :         return cscript_cmd( CMDFUNC_ARGS );

  0005f	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  00067	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0006f	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00076	e8 00 00 00 00	 call	 cscript_cmd
  0007b	e9 ec 07 00 00	 jmp	 $LN1@CallHercCm
$LN17@CallHercCm:

; 241  : 
; 242  :     /* [ENTER] key by itself: either start the CPU or ignore
; 243  :        it altogether when instruction stepping is not active. */
; 244  :     if (0
; 245  :         || !argc            /* (no args)    */
; 246  :         || !argv[0]         /* (no cmd)     */
; 247  :         || !cmdline         /* (no cmdline) */
; 248  :         || !cmdline[0]      /* (empty cmd)  */
; 249  :         || !argv[0][0]      /* (empty cmd)  */

  00080	33 c0		 xor	 eax, eax
  00082	85 c0		 test	 eax, eax
  00084	75 6c		 jne	 SHORT $LN19@CallHercCm
  00086	83 bc 24 b0 01
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  0008e	74 62		 je	 SHORT $LN19@CallHercCm
  00090	b8 08 00 00 00	 mov	 eax, 8
  00095	48 6b c0 00	 imul	 rax, rax, 0
  00099	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000a1	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  000a6	74 4a		 je	 SHORT $LN19@CallHercCm
  000a8	48 83 bc 24 c0
	01 00 00 00	 cmp	 QWORD PTR cmdline$[rsp], 0
  000b1	74 3f		 je	 SHORT $LN19@CallHercCm
  000b3	b8 01 00 00 00	 mov	 eax, 1
  000b8	48 6b c0 00	 imul	 rax, rax, 0
  000bc	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  000c4	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000c8	85 c0		 test	 eax, eax
  000ca	74 26		 je	 SHORT $LN19@CallHercCm
  000cc	b8 08 00 00 00	 mov	 eax, 8
  000d1	48 6b c0 00	 imul	 rax, rax, 0
  000d5	b9 01 00 00 00	 mov	 ecx, 1
  000da	48 6b c9 00	 imul	 rcx, rcx, 0
  000de	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  000e6	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  000ea	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  000ee	85 c0		 test	 eax, eax
  000f0	75 3a		 jne	 SHORT $LN18@CallHercCm
$LN19@CallHercCm:

; 250  :     )
; 251  :     {
; 252  :         if (sysblk.instbreak)

  000f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000f9	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000ff	c1 e8 0a	 shr	 eax, 10
  00102	83 e0 01	 and	 eax, 1
  00105	85 c0		 test	 eax, eax
  00107	74 12		 je	 SHORT $LN20@CallHercCm

; 253  :             rc = start_cmd( 0, NULL, NULL );

  00109	45 33 c0	 xor	 r8d, r8d
  0010c	33 d2		 xor	 edx, edx
  0010e	33 c9		 xor	 ecx, ecx
  00110	e8 00 00 00 00	 call	 start_cmd
  00115	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  00119	eb 08		 jmp	 SHORT $LN21@CallHercCm
$LN20@CallHercCm:

; 254  :         else
; 255  :             rc = 0;         /* ignore [ENTER] */

  0011b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0
$LN21@CallHercCm:

; 256  :         return rc;

  00123	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
  00127	e9 40 07 00 00	 jmp	 $LN1@CallHercCm
$LN18@CallHercCm:
$LN4@CallHercCm:

; 257  :     }
; 258  : 
; 259  :     /* (sanity check) */
; 260  :     ASSERT( argc && cmdline && *cmdline && argv[0] && argv[0][0] );

  0012c	83 bc 24 b0 01
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  00134	74 58		 je	 SHORT $LN23@CallHercCm
  00136	48 83 bc 24 c0
	01 00 00 00	 cmp	 QWORD PTR cmdline$[rsp], 0
  0013f	74 4d		 je	 SHORT $LN23@CallHercCm
  00141	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR cmdline$[rsp]
  00149	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0014c	85 c0		 test	 eax, eax
  0014e	74 3e		 je	 SHORT $LN23@CallHercCm
  00150	b8 08 00 00 00	 mov	 eax, 8
  00155	48 6b c0 00	 imul	 rax, rax, 0
  00159	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00161	48 83 3c 01 00	 cmp	 QWORD PTR [rcx+rax], 0
  00166	74 26		 je	 SHORT $LN23@CallHercCm
  00168	b8 08 00 00 00	 mov	 eax, 8
  0016d	48 6b c0 00	 imul	 rax, rax, 0
  00171	b9 01 00 00 00	 mov	 ecx, 1
  00176	48 6b c9 00	 imul	 rcx, rcx, 0
  0017a	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00182	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00186	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  0018a	85 c0		 test	 eax, eax
  0018c	75 5c		 jne	 SHORT $LN22@CallHercCm
$LN23@CallHercCm:
$LN7@CallHercCm:
  0018e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161179
  00195	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0019b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161180
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161181
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  001af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001b5	85 c0		 test	 eax, eax
  001b7	74 20		 je	 SHORT $LN24@CallHercCm
  001b9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161183
  001c0	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  001c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161184
  001cd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161185
  001d4	e8 00 00 00 00	 call	 DebuggerTrace
$LN24@CallHercCm:
  001d9	33 c0		 xor	 eax, eax
  001db	85 c0		 test	 eax, eax
  001dd	75 af		 jne	 SHORT $LN7@CallHercCm
  001df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001e5	85 c0		 test	 eax, eax
  001e7	74 01		 je	 SHORT $LN25@CallHercCm
  001e9	cc		 int	 3
$LN25@CallHercCm:
$LN22@CallHercCm:
  001ea	33 c0		 xor	 eax, eax
  001ec	85 c0		 test	 eax, eax
  001ee	0f 85 38 ff ff
	ff		 jne	 $LN4@CallHercCm

; 261  : 
; 262  :     /* If a system command hook exists, let it try processing it first. */
; 263  :     /* Only if it rejects it, will we then try processing it ourselves. */
; 264  :     if (system_command)

  001f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_system_command
  001fb	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  001ff	74 37		 je	 SHORT $LN26@CallHercCm

; 265  :         if ((rc = system_command( CMDFUNC_ARGS )) != HERRINVCMD)

  00201	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  00209	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00211	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00218	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_system_command
  0021f	ff 10		 call	 QWORD PTR [rax]
  00221	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  00225	81 7c 24 30 01
	80 ff ff	 cmp	 DWORD PTR rc$[rsp], -32767 ; ffffffffffff8001H
  0022d	74 09		 je	 SHORT $LN27@CallHercCm

; 266  :             return rc;

  0022f	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
  00233	e9 34 06 00 00	 jmp	 $LN1@CallHercCm
$LN27@CallHercCm:
$LN26@CallHercCm:

; 267  : 
; 268  :     /* Check for comment command. We need to test for this separately
; 269  :        rather than scanning our COMAMND table since the first token
; 270  :        of the "command" might not be a single '#' or '*'. That is to
; 271  :        say, the first token might be "#comment" or "*comment" (with
; 272  :        no blanks following the '#' or '*'), which would thus not match
; 273  :        either of our "comment_cmd" COMMAND table entries. Note that
; 274  :        this also means the COMMAND table entries for '*' and '#' are
; 275  :        redundant since they will never be used (since we're processing
; 276  :        comments here and not via our table search), but that's okay. */
; 277  :     if (0
; 278  :         || argv[0][0] == '#'       /* (comment command?) */
; 279  :         || argv[0][0] == '*'       /* (comment command?) */

  00238	33 c0		 xor	 eax, eax
  0023a	85 c0		 test	 eax, eax
  0023c	75 4e		 jne	 SHORT $LN29@CallHercCm
  0023e	b8 08 00 00 00	 mov	 eax, 8
  00243	48 6b c0 00	 imul	 rax, rax, 0
  00247	b9 01 00 00 00	 mov	 ecx, 1
  0024c	48 6b c9 00	 imul	 rcx, rcx, 0
  00250	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00258	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  0025c	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00260	83 f8 23	 cmp	 eax, 35			; 00000023H
  00263	74 27		 je	 SHORT $LN29@CallHercCm
  00265	b8 08 00 00 00	 mov	 eax, 8
  0026a	48 6b c0 00	 imul	 rax, rax, 0
  0026e	b9 01 00 00 00	 mov	 ecx, 1
  00273	48 6b c9 00	 imul	 rcx, rcx, 0
  00277	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0027f	48 8b 04 02	 mov	 rax, QWORD PTR [rdx+rax]
  00283	0f be 04 08	 movsx	 eax, BYTE PTR [rax+rcx]
  00287	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  0028a	75 29		 jne	 SHORT $LN28@CallHercCm
$LN29@CallHercCm:

; 280  :     )
; 281  :     {
; 282  :         /* PROGRAMMING NOTE: we ALWAYS call the "comment_cmd" function
; 283  :            for comments even though today it does nothing. We might decide
; 284  :            to do additional processing for comments in the future (such
; 285  :            as simply counting them for example), so we should ALWAYS call
; 286  :            our comment_cmd function here instead of just returning. */
; 287  :         rc = comment_cmd( CMDFUNC_ARGS );

  0028c	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  00294	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  0029c	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  002a3	e8 00 00 00 00	 call	 comment_cmd
  002a8	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 288  :         return rc;

  002ac	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
  002b0	e9 b7 05 00 00	 jmp	 $LN1@CallHercCm
$LN28@CallHercCm:

; 289  :     }
; 290  : 
; 291  :     /* Route standard formatted commands from our COMMAND routing table */
; 292  : 
; 293  :     /* PROGRAMMING NOTE: since our table is now sorted, the below could
; 294  :        be converted to a more efficient binary search algorithm instead */
; 295  : 
; 296  :     isdiag = is_diag_instr();

  002b5	e8 00 00 00 00	 call	 is_diag_instr
  002ba	88 44 24 3c	 mov	 BYTE PTR isdiag$[rsp], al

; 297  : 
; 298  :     for (pCmdTab = cmdtab; pCmdTab->statement; pCmdTab++)

  002be	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:cmdtab
  002c5	48 89 44 24 40	 mov	 QWORD PTR pCmdTab$[rsp], rax
  002ca	eb 0e		 jmp	 SHORT $LN10@CallHercCm
$LN8@CallHercCm:
  002cc	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  002d1	48 83 c0 30	 add	 rax, 48			; 00000030H
  002d5	48 89 44 24 40	 mov	 QWORD PTR pCmdTab$[rsp], rax
$LN10@CallHercCm:
  002da	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  002df	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002e3	0f 84 37 04 00
	00		 je	 $LN9@CallHercCm

; 299  :     {
; 300  :         if (1
; 301  :             && pCmdTab->function
; 302  :             && (pCmdTab->type & sysblk.sysgroup)
; 303  :             /********************************************************
; 304  :             *  SECURITY CHECK: any command in the "SYSNDIAG8" group
; 305  :             *  are not *ever* to be allowed to be issued via DIAG8!
; 306  :             *  The following test causes us to consider only those
; 307  :             *  commands that are either NOT in the SYSNDIAG8 group,
; 308  :             *  or, for those that are, ONLY when DIAG8 isn't active.
; 309  :             ********************************************************/
; 310  :             && (!(pCmdTab->type & SYSNDIAG8) || !isdiag)

  002e9	33 c0		 xor	 eax, eax
  002eb	83 f8 01	 cmp	 eax, 1
  002ee	0f 84 27 04 00
	00		 je	 $LN30@CallHercCm
  002f4	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  002f9	48 83 78 18 00	 cmp	 QWORD PTR [rax+24], 0
  002fe	0f 84 17 04 00
	00		 je	 $LN30@CallHercCm
  00304	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00309	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  0030d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00314	0f b6 89 2d 11
	00 00		 movzx	 ecx, BYTE PTR [rcx+4397]
  0031b	23 c1		 and	 eax, ecx
  0031d	85 c0		 test	 eax, eax
  0031f	0f 84 f6 03 00
	00		 je	 $LN30@CallHercCm
  00325	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  0032a	0f b6 40 28	 movzx	 eax, BYTE PTR [rax+40]
  0032e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00333	85 c0		 test	 eax, eax
  00335	74 0d		 je	 SHORT $LN31@CallHercCm
  00337	0f b6 44 24 3c	 movzx	 eax, BYTE PTR isdiag$[rsp]
  0033c	85 c0		 test	 eax, eax
  0033e	0f 85 d7 03 00
	00		 jne	 $LN30@CallHercCm
$LN31@CallHercCm:

; 311  :         )
; 312  :         {
; 313  :             cmdlen = pCmdTab->mincmdlen ? pCmdTab->mincmdlen : strlen( pCmdTab->statement );

  00344	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00349	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0034e	74 10		 je	 SHORT $LN47@CallHercCm
  00350	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00355	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00359	48 89 44 24 50	 mov	 QWORD PTR tv206[rsp], rax
  0035e	eb 12		 jmp	 SHORT $LN48@CallHercCm
$LN47@CallHercCm:
  00360	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00365	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00368	e8 00 00 00 00	 call	 strlen
  0036d	48 89 44 24 50	 mov	 QWORD PTR tv206[rsp], rax
$LN48@CallHercCm:
  00372	48 8b 44 24 50	 mov	 rax, QWORD PTR tv206[rsp]
  00377	48 89 44 24 58	 mov	 QWORD PTR cmdlen$[rsp], rax

; 314  :             matchlen = MAX( strlen(argv[0]), cmdlen );

  0037c	b8 08 00 00 00	 mov	 eax, 8
  00381	48 6b c0 00	 imul	 rax, rax, 0
  00385	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0038d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00391	e8 00 00 00 00	 call	 strlen
  00396	48 3b 44 24 58	 cmp	 rax, QWORD PTR cmdlen$[rsp]
  0039b	76 21		 jbe	 SHORT $LN49@CallHercCm
  0039d	b8 08 00 00 00	 mov	 eax, 8
  003a2	48 6b c0 00	 imul	 rax, rax, 0
  003a6	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003ae	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  003b2	e8 00 00 00 00	 call	 strlen
  003b7	48 89 44 24 60	 mov	 QWORD PTR tv216[rsp], rax
  003bc	eb 0a		 jmp	 SHORT $LN50@CallHercCm
$LN49@CallHercCm:
  003be	48 8b 44 24 58	 mov	 rax, QWORD PTR cmdlen$[rsp]
  003c3	48 89 44 24 60	 mov	 QWORD PTR tv216[rsp], rax
$LN50@CallHercCm:
  003c8	48 8b 44 24 60	 mov	 rax, QWORD PTR tv216[rsp]
  003cd	48 89 44 24 70	 mov	 QWORD PTR matchlen$[rsp], rax

; 315  : 
; 316  :             if (!strncasecmp( argv[0], pCmdTab->statement, matchlen ))

  003d2	b8 08 00 00 00	 mov	 eax, 8
  003d7	48 6b c0 00	 imul	 rax, rax, 0
  003db	4c 8b 44 24 70	 mov	 r8, QWORD PTR matchlen$[rsp]
  003e0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  003e5	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  003e8	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  003f0	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  003f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  003fa	85 c0		 test	 eax, eax
  003fc	0f 85 19 03 00
	00		 jne	 $LN32@CallHercCm

; 317  :             {
; 318  :                 char cmd[256]; /* (copy of command name) */
; 319  : 
; 320  :                 /* Make full-length copy of the true command's name */
; 321  :                 STRLCPY( cmd, pCmdTab->statement );

  00402	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  00408	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  0040d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00410	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR cmd$5[rsp]
  00418	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 322  : 
; 323  :                 /* Replace abbreviated command with full command */
; 324  :                 if (pCmdTab->mincmdlen)

  0041e	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00423	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00428	74 1d		 je	 SHORT $LN33@CallHercCm

; 325  :                     argv[0] = cmd; /* (since theirs may be abbreviated) */

  0042a	b8 08 00 00 00	 mov	 eax, 8
  0042f	48 6b c0 00	 imul	 rax, rax, 0
  00433	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0043b	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR cmd$5[rsp]
  00443	48 89 14 01	 mov	 QWORD PTR [rcx+rax], rdx
$LN33@CallHercCm:

; 326  : 
; 327  :                 /* Run command in background? (last argument == '&') */
; 328  :                 if (strcmp(argv[argc-1],"&") == 0)

  00447	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0044e	ff c8		 dec	 eax
  00450	48 98		 cdqe
  00452	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161197
  00459	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00461	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00465	e8 00 00 00 00	 call	 strcmp
  0046a	85 c0		 test	 eax, eax
  0046c	0f 85 24 02 00
	00		 jne	 $LN34@CallHercCm

; 329  :                 {
; 330  :                 BGCMD *bgcmd;
; 331  :                 TID tid;
; 332  :                 int i,len;
; 333  : 
; 334  :                     /* Calculate length of the command-line (all arguments
; 335  :                        except the last one), including intervening blanks. */
; 336  :                     for (len=0, i=0; i < argc-1; i++ )

  00472	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR len$2[rsp], 0
  0047a	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00482	eb 0a		 jmp	 SHORT $LN13@CallHercCm
$LN11@CallHercCm:
  00484	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  00488	ff c0		 inc	 eax
  0048a	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
$LN13@CallHercCm:
  0048e	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00495	ff c8		 dec	 eax
  00497	39 44 24 34	 cmp	 DWORD PTR i$1[rsp], eax
  0049b	7d 4f		 jge	 SHORT $LN12@CallHercCm

; 337  :                     {
; 338  :                         len += (int) strlen( (char*) argv[i] ) + 1;

  0049d	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  004a2	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004aa	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004ae	e8 00 00 00 00	 call	 strlen
  004b3	8b 4c 24 38	 mov	 ecx, DWORD PTR len$2[rsp]
  004b7	8d 44 01 01	 lea	 eax, DWORD PTR [rcx+rax+1]
  004bb	89 44 24 38	 mov	 DWORD PTR len$2[rsp], eax

; 339  :                         if (strchr( argv[i], ' ' ))

  004bf	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  004c4	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  004c9	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  004d1	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  004d5	e8 00 00 00 00	 call	 strchr
  004da	48 85 c0	 test	 rax, rax
  004dd	74 0b		 je	 SHORT $LN36@CallHercCm

; 340  :                             len += 2; // (surrounding double quotes)

  004df	8b 44 24 38	 mov	 eax, DWORD PTR len$2[rsp]
  004e3	83 c0 02	 add	 eax, 2
  004e6	89 44 24 38	 mov	 DWORD PTR len$2[rsp], eax
$LN36@CallHercCm:

; 341  :                     }

  004ea	eb 98		 jmp	 SHORT $LN11@CallHercCm
$LN12@CallHercCm:

; 342  : 
; 343  :                     /* Build parameter to pass to background thread */
; 344  :                     bgcmd = (BGCMD*) malloc( sizeof(BGCMD) + len );

  004ec	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$2[rsp]
  004f1	48 83 c0 08	 add	 rax, 8
  004f5	48 8b c8	 mov	 rcx, rax
  004f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  004fe	48 89 44 24 48	 mov	 QWORD PTR bgcmd$3[rsp], rax

; 345  :                     bgcmd->func = pCmdTab->function;

  00503	48 8b 44 24 48	 mov	 rax, QWORD PTR bgcmd$3[rsp]
  00508	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pCmdTab$[rsp]
  0050d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00511	48 89 08	 mov	 QWORD PTR [rax], rcx

; 346  : 
; 347  :                     /* Build private copy of cmdline for bgcmd_thread */
; 348  :                     strlcpy( bgcmd->cmdline, argv[0], len );

  00514	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$2[rsp]
  00519	b9 08 00 00 00	 mov	 ecx, 8
  0051e	48 6b c9 00	 imul	 rcx, rcx, 0
  00522	48 8b 54 24 48	 mov	 rdx, QWORD PTR bgcmd$3[rsp]
  00527	48 83 c2 08	 add	 rdx, 8
  0052b	48 89 54 24 78	 mov	 QWORD PTR tv275[rsp], rdx
  00530	4c 8b c0	 mov	 r8, rax
  00533	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  0053b	48 8b 14 08	 mov	 rdx, QWORD PTR [rax+rcx]
  0053f	48 8b 44 24 78	 mov	 rax, QWORD PTR tv275[rsp]
  00544	48 8b c8	 mov	 rcx, rax
  00547	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 349  :                     for (i=1; i < argc-1; i++)

  0054d	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR i$1[rsp], 1
  00555	eb 0a		 jmp	 SHORT $LN16@CallHercCm
$LN14@CallHercCm:
  00557	8b 44 24 34	 mov	 eax, DWORD PTR i$1[rsp]
  0055b	ff c0		 inc	 eax
  0055d	89 44 24 34	 mov	 DWORD PTR i$1[rsp], eax
$LN16@CallHercCm:
  00561	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00568	ff c8		 dec	 eax
  0056a	39 44 24 34	 cmp	 DWORD PTR i$1[rsp], eax
  0056e	0f 8d da 00 00
	00		 jge	 $LN15@CallHercCm

; 350  :                     {
; 351  :                         strlcat( bgcmd->cmdline,  " ",    len );

  00574	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$2[rsp]
  00579	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bgcmd$3[rsp]
  0057e	48 83 c1 08	 add	 rcx, 8
  00582	4c 8b c0	 mov	 r8, rax
  00585	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161199
  0058c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 352  : 
; 353  :                         if (strchr( argv[i], ' ' ))

  00592	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  00597	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0059c	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  005a4	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  005a8	e8 00 00 00 00	 call	 strchr
  005ad	48 85 c0	 test	 rax, rax
  005b0	74 1e		 je	 SHORT $LN37@CallHercCm

; 354  :                             strlcat( bgcmd->cmdline,  "\"", len );

  005b2	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$2[rsp]
  005b7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bgcmd$3[rsp]
  005bc	48 83 c1 08	 add	 rcx, 8
  005c0	4c 8b c0	 mov	 r8, rax
  005c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161201
  005ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN37@CallHercCm:

; 355  : 
; 356  :                         strlcat( bgcmd->cmdline, argv[i], len );

  005d0	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$2[rsp]
  005d5	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR i$1[rsp]
  005da	48 8b 54 24 48	 mov	 rdx, QWORD PTR bgcmd$3[rsp]
  005df	48 83 c2 08	 add	 rdx, 8
  005e3	48 89 94 24 80
	00 00 00	 mov	 QWORD PTR tv303[rsp], rdx
  005eb	4c 8b c0	 mov	 r8, rax
  005ee	48 8b 84 24 b8
	01 00 00	 mov	 rax, QWORD PTR argv$[rsp]
  005f6	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  005fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR tv303[rsp]
  00602	48 8b c8	 mov	 rcx, rax
  00605	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 357  : 
; 358  :                         if (strchr( argv[i], ' ' ))

  0060b	48 63 44 24 34	 movsxd	 rax, DWORD PTR i$1[rsp]
  00610	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00615	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0061d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00621	e8 00 00 00 00	 call	 strchr
  00626	48 85 c0	 test	 rax, rax
  00629	74 1e		 je	 SHORT $LN38@CallHercCm

; 359  :                             strlcat( bgcmd->cmdline,  "\"", len );

  0062b	48 63 44 24 38	 movsxd	 rax, DWORD PTR len$2[rsp]
  00630	48 8b 4c 24 48	 mov	 rcx, QWORD PTR bgcmd$3[rsp]
  00635	48 83 c1 08	 add	 rcx, 8
  00639	4c 8b c0	 mov	 r8, rax
  0063c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161203
  00643	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat
$LN38@CallHercCm:

; 360  :                     }

  00649	e9 09 ff ff ff	 jmp	 $LN14@CallHercCm
$LN15@CallHercCm:

; 361  : 
; 362  :                     /* Process command asynchronously in the background */
; 363  :                     rc = create_thread( &tid, DETACHED, bgcmd_thread, bgcmd, "bgcmd_thread" );

  0064e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00655	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0065b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161204
  00662	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00667	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161205
  0066e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00673	4c 8b 4c 24 48	 mov	 r9, QWORD PTR bgcmd$3[rsp]
  00678	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:bgcmd_thread
  0067f	48 8b d0	 mov	 rdx, rax
  00682	48 8d 4c 24 68	 lea	 rcx, QWORD PTR tid$4[rsp]
  00687	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  0068d	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 364  :                 }

  00691	e9 83 00 00 00	 jmp	 $LN35@CallHercCm
$LN34@CallHercCm:

; 365  :                 else /* (not a background command) */
; 366  :                 {
; 367  :                     /* Does last argument start with two ampersands? */
; 368  :                     if (strncmp( argv[argc-1], "&&", 2 ) == 0)

  00696	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  0069d	ff c8		 dec	 eax
  0069f	48 98		 cdqe
  006a1	41 b8 02 00 00
	00		 mov	 r8d, 2
  006a7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161207
  006ae	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006b6	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  006ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  006c0	85 c0		 test	 eax, eax
  006c2	75 32		 jne	 SHORT $LN39@CallHercCm

; 369  :                         /* Yes, skip past the first one */
; 370  :                         argv[argc-1]++; /* ("&&&" ==> "&&", "&&" ==> "&", etc) */

  006c4	8b 84 24 b0 01
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  006cb	ff c8		 dec	 eax
  006cd	48 98		 cdqe
  006cf	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  006d7	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  006db	48 ff c0	 inc	 rax
  006de	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  006e5	ff c9		 dec	 ecx
  006e7	48 63 c9	 movsxd	 rcx, ecx
  006ea	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  006f2	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax
$LN39@CallHercCm:

; 371  : 
; 372  :                     /* Process the Hercules command */
; 373  :                     rc = pCmdTab->function( CMDFUNC_ARGS );

  006f6	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  006fe	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00706	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0070d	48 8b 44 24 40	 mov	 rax, QWORD PTR pCmdTab$[rsp]
  00712	ff 50 18	 call	 QWORD PTR [rax+24]
  00715	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
$LN35@CallHercCm:

; 374  :                 }
; 375  :                 break;

  00719	eb 05		 jmp	 SHORT $LN9@CallHercCm
$LN32@CallHercCm:
$LN30@CallHercCm:

; 376  :             }
; 377  :             /* end strncasecmp( table entry match ) */
; 378  :         }
; 379  :         /* end if ( valid table entry ) */
; 380  :     }

  0071b	e9 ac fb ff ff	 jmp	 $LN8@CallHercCm
$LN9@CallHercCm:

; 381  :     /* end for ( search table ) */
; 382  : 
; 383  :     /* If we didn't find an exact match in our table, check if
; 384  :        this is maybe a special non-standard formatted command. */
; 385  :     if (rc == HERRINVCMD && (sysblk.sysgroup & SYSCMDNOPER))

  00720	81 7c 24 30 01
	80 ff ff	 cmp	 DWORD PTR rc$[rsp], -32767 ; ffffffffffff8001H
  00728	0f 85 3a 01 00
	00		 jne	 $LN40@CallHercCm
  0072e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00735	0f b6 80 2d 11
	00 00		 movzx	 eax, BYTE PTR [rax+4397]
  0073c	83 e0 76	 and	 eax, 118		; 00000076H
  0073f	85 c0		 test	 eax, eax
  00741	0f 84 21 01 00
	00		 je	 $LN40@CallHercCm

; 386  :     {
; 387  :         /* shadow file commands: add/remove/compress/display/check */
; 388  :         if (0
; 389  :             || !strncasecmp( cmdline, "sf+", 3 )
; 390  :             || !strncasecmp( cmdline, "sf-", 3 )
; 391  :             || !strncasecmp( cmdline, "sfc", 3 )
; 392  :             || !strncasecmp( cmdline, "sfd", 3 )
; 393  :             || !strncasecmp( cmdline, "sfk", 3 )

  00747	33 c0		 xor	 eax, eax
  00749	85 c0		 test	 eax, eax
  0074b	0f 85 9b 00 00
	00		 jne	 $LN43@CallHercCm
  00751	41 b8 03 00 00
	00		 mov	 r8d, 3
  00757	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161212
  0075e	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00766	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0076c	85 c0		 test	 eax, eax
  0076e	74 7c		 je	 SHORT $LN43@CallHercCm
  00770	41 b8 03 00 00
	00		 mov	 r8d, 3
  00776	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161213
  0077d	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00785	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  0078b	85 c0		 test	 eax, eax
  0078d	74 5d		 je	 SHORT $LN43@CallHercCm
  0078f	41 b8 03 00 00
	00		 mov	 r8d, 3
  00795	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161214
  0079c	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  007aa	85 c0		 test	 eax, eax
  007ac	74 3e		 je	 SHORT $LN43@CallHercCm
  007ae	41 b8 03 00 00
	00		 mov	 r8d, 3
  007b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161215
  007bb	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  007c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  007c9	85 c0		 test	 eax, eax
  007cb	74 1f		 je	 SHORT $LN43@CallHercCm
  007cd	41 b8 03 00 00
	00		 mov	 r8d, 3
  007d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161216
  007da	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  007e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  007e8	85 c0		 test	 eax, eax
  007ea	75 22		 jne	 SHORT $LN41@CallHercCm
$LN43@CallHercCm:

; 394  :         )
; 395  :             rc = sf_cmd( CMDFUNC_ARGS );

  007ec	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  007f4	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  007fc	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  00803	e8 00 00 00 00	 call	 sf_cmd
  00808	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
  0080c	eb 5a		 jmp	 SHORT $LN42@CallHercCm
$LN41@CallHercCm:

; 396  :         else
; 397  :         /* "x+" and "x-" commands: turn switch on or off */
; 398  :         if (0
; 399  :             || '+' == cmdline[1]
; 400  :             || '-' == cmdline[1]

  0080e	33 c0		 xor	 eax, eax
  00810	85 c0		 test	 eax, eax
  00812	75 34		 jne	 SHORT $LN45@CallHercCm
  00814	b8 01 00 00 00	 mov	 eax, 1
  00819	48 6b c0 01	 imul	 rax, rax, 1
  0081d	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  00825	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00829	83 f8 2b	 cmp	 eax, 43			; 0000002bH
  0082c	74 1a		 je	 SHORT $LN45@CallHercCm
  0082e	b8 01 00 00 00	 mov	 eax, 1
  00833	48 6b c0 01	 imul	 rax, rax, 1
  00837	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR cmdline$[rsp]
  0083f	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00843	83 f8 2d	 cmp	 eax, 45			; 0000002dH
  00846	75 20		 jne	 SHORT $LN44@CallHercCm
$LN45@CallHercCm:

; 401  :         )
; 402  :             rc = OnOffCommand( CMDFUNC_ARGS );

  00848	4c 8b 84 24 c0
	01 00 00	 mov	 r8, QWORD PTR cmdline$[rsp]
  00850	48 8b 94 24 b8
	01 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  00858	8b 8c 24 b0 01
	00 00		 mov	 ecx, DWORD PTR argc$[rsp]
  0085f	e8 00 00 00 00	 call	 OnOffCommand
  00864	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
$LN44@CallHercCm:
$LN42@CallHercCm:
$LN40@CallHercCm:

; 403  :     }
; 404  : 
; 405  :     return rc;

  00868	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@CallHercCm:

; 406  : }

  0086c	48 8b 8c 24 90
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00874	48 33 cc	 xor	 rcx, rsp
  00877	e8 00 00 00 00	 call	 __security_check_cookie
  0087c	48 81 c4 a8 01
	00 00		 add	 rsp, 424		; 000001a8H
  00883	c3		 ret	 0
CallHercCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
pszCmdLine$ = 48
HercCmdLine PROC

; 464  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 465  :     return DoCallHercCmdLine( pszCmdLine, 0 );

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pszCmdLine$[rsp]
  00010	e8 00 00 00 00	 call	 DoCallHercCmdLine

; 466  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
HercCmdLine ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\cmdtab.c
_TEXT	SEGMENT
pszCmdLine$ = 48
InternalHercCmd PROC

; 460  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 461  :     return DoCallHercCmdLine( pszCmdLine, 1 );

  00009	b2 01		 mov	 dl, 1
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pszCmdLine$[rsp]
  00010	e8 00 00 00 00	 call	 DoCallHercCmdLine

; 462  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
InternalHercCmd ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
