; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	w32_errno_tab
PUBLIC	buffer_overflow_msg
PUBLIC	buffer_overflow_msg_len
_BSS	SEGMENT
buffer_overflow_msg DQ 01H DUP (?)
buffer_overflow_msg_len DQ 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
w32_errno_tab DD 04H
	DD	018H
	DD	05H
	DD	0dH
	DD	06H
	DD	09H
	DD	08H
	DD	0cH
	DD	0eH
	DD	0cH
	DD	0fH
	DD	02H
	DD	013H
	DD	0dH
	DD	015H
	DD	05H
	DD	017H
	DD	05H
	DD	01dH
	DD	05H
	DD	01eH
	DD	05H
	DD	01fH
	DD	05H
	DD	020H
	DD	0dH
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vfprintf_l
PUBLIC	vfprintf
PUBLIC	_vsnprintf_l
PUBLIC	_vsnprintf
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vscprintf_l
PUBLIC	_vscprintf
PUBLIC	_snprintf
PUBLIC	are_elevated
PUBLIC	w32_trans_w32error
PUBLIC	w32_strerror
PUBLIC	w32_strerror_r
PUBLIC	w32_w32errmsg
PUBLIC	w32_NtStatusToLastError
PUBLIC	socketpair
PUBLIC	fork
PUBLIC	strtok_r
PUBLIC	clock_gettime
PUBLIC	gettimeofday
PUBLIC	nanosleep
PUBLIC	usleep
PUBLIC	sleep
PUBLIC	sched_yield
PUBLIC	scandir
PUBLIC	alphasort
PUBLIC	getrusage
PUBLIC	pthread_getcpuclockid
PUBLIC	getlogin
PUBLIC	getlogin_r
PUBLIC	realpath
PUBLIC	inet_aton
PUBLIC	hostpath
PUBLIC	get_file_accmode_flags
PUBLIC	gethostid
PUBLIC	socket_init
PUBLIC	socket_deinit
PUBLIC	socket_set_blocking_mode
PUBLIC	socket_is_socket
PUBLIC	set_socket_keepalive
PUBLIC	get_socket_keepalive
PUBLIC	get_process_directory
PUBLIC	expand_environ_vars
PUBLIC	w32_init_hostinfo
PUBLIC	w32_socket
PUBLIC	w32_accept
PUBLIC	w32_close_socket
PUBLIC	w32_FD_SET
PUBLIC	w32_FD_ISSET
PUBLIC	w32_select
PUBLIC	w32_pselect
PUBLIC	w32_if_nametoindex
PUBLIC	w32_inet_ntop
PUBLIC	w32_inet_pton
PUBLIC	w32_fdopen
PUBLIC	w32_fwrite
PUBLIC	w32_vsnprintf
PUBLIC	w32_snprintf
PUBLIC	w32_fprintf
PUBLIC	w32_fclose
PUBLIC	w32_get_stdin_char
PUBLIC	w32_poor_mans_fork
PUBLIC	w32_set_thread_name
PUBLIC	w32_hpagesize
PUBLIC	w32_mlock
PUBLIC	w32_munlock
PUBLIC	w32_hopen
PUBLIC	w32_basename
PUBLIC	w32_dirname
PUBLIC	w32_strcasestr
PUBLIC	DisableInvalidParameterHandling
PUBLIC	EnableInvalidParameterHandling
PUBLIC	DoGetRUsage
PUBLIC	CountSetBits
PUBLIC	w32_read_piped_process_stdxxx_output_thread
PUBLIC	w32_parse_piped_process_stdxxx_data
EXTRN	__imp_isalpha:PROC
EXTRN	__imp_isspace:PROC
EXTRN	__imp_tolower:PROC
EXTRN	__imp__errno:PROC
EXTRN	memmove:PROC
EXTRN	strchr:PROC
EXTRN	strrchr:PROC
EXTRN	__imp_strtok_s:PROC
EXTRN	strcmp:PROC
EXTRN	__imp__stricmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp__strnicmp:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_ExpandEnvironmentStringsA:PROC
EXTRN	__imp_FindClose:PROC
EXTRN	__imp_FindFirstFileA:PROC
EXTRN	__imp_FindNextFileA:PROC
EXTRN	__imp_ReadFile:PROC
EXTRN	__imp_WriteFile:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_CloseHandle:PROC
EXTRN	__imp_DuplicateHandle:PROC
EXTRN	__imp_RaiseException:PROC
EXTRN	__imp_GetLastError:PROC
EXTRN	__imp_SetLastError:PROC
EXTRN	__imp_CreatePipe:PROC
EXTRN	__imp_QueryPerformanceCounter:PROC
EXTRN	__imp_QueryPerformanceFrequency:PROC
EXTRN	__imp_GetOverlappedResult:PROC
EXTRN	__imp_InitializeCriticalSection:PROC
EXTRN	__imp_EnterCriticalSection:PROC
EXTRN	__imp_LeaveCriticalSection:PROC
EXTRN	__imp_InitializeCriticalSectionAndSpinCount:PROC
EXTRN	__imp_TryEnterCriticalSection:PROC
EXTRN	__imp_DeleteCriticalSection:PROC
EXTRN	__imp_SetEvent:PROC
EXTRN	__imp_ResetEvent:PROC
EXTRN	__imp_WaitForSingleObject:PROC
EXTRN	__imp_CreateEventA:PROC
EXTRN	__imp_SetWaitableTimer:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_WaitForMultipleObjects:PROC
EXTRN	__imp_GetProcessTimes:PROC
EXTRN	__imp_GetCurrentProcess:PROC
EXTRN	__imp_GetCurrentProcessId:PROC
EXTRN	__imp_SwitchToThread:PROC
EXTRN	__imp_GetCurrentThreadId:PROC
EXTRN	__imp_CreateProcessA:PROC
EXTRN	__imp_OpenProcessToken:PROC
EXTRN	__imp_GetThreadTimes:PROC
EXTRN	__imp_OpenProcess:PROC
EXTRN	__imp_GlobalMemoryStatusEx:PROC
EXTRN	__imp_GetSystemInfo:PROC
EXTRN	__imp_GetSystemTimeAsFileTime:PROC
EXTRN	__imp_GetVersionExA:PROC
EXTRN	__imp_VirtualLock:PROC
EXTRN	__imp_VirtualUnlock:PROC
EXTRN	__imp_GetModuleFileNameA:PROC
EXTRN	__imp_GetModuleHandleA:PROC
EXTRN	__imp_GetProcAddress:PROC
EXTRN	__imp_LoadLibraryA:PROC
EXTRN	__imp_GetTokenInformation:PROC
EXTRN	__imp_FormatMessageA:PROC
EXTRN	__imp_CreateWaitableTimerA:PROC
EXTRN	__imp_GetComputerNameA:PROC
EXTRN	__imp_GetUserNameA:PROC
EXTRN	__imp_GetSystemMetrics:PROC
EXTRN	__imp_RegCloseKey:PROC
EXTRN	__imp_RegOpenKeyExA:PROC
EXTRN	__imp_RegQueryValueExA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_realloc:PROC
EXTRN	__imp_qsort:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp__set_invalid_parameter_handler:PROC
EXTRN	__imp___sys_errlist:PROC
EXTRN	__imp___sys_nerr:PROC
EXTRN	__imp__fullpath:PROC
EXTRN	__imp__splitpath_s:PROC
EXTRN	__WSAFDIsSet:PROC
EXTRN	__imp_bind:PROC
EXTRN	__imp_closesocket:PROC
EXTRN	__imp_connect:PROC
EXTRN	__imp_ioctlsocket:PROC
EXTRN	__imp_getsockname:PROC
EXTRN	__imp_getsockopt:PROC
EXTRN	__imp_htonl:PROC
EXTRN	__imp_htons:PROC
EXTRN	__imp_inet_addr:PROC
EXTRN	__imp_listen:PROC
EXTRN	__imp_select:PROC
EXTRN	__imp_send:PROC
EXTRN	__imp_shutdown:PROC
EXTRN	__imp_socket:PROC
EXTRN	__imp_gethostbyname:PROC
EXTRN	__imp_gethostname:PROC
EXTRN	__imp_WSAStartup:PROC
EXTRN	__imp_WSASetLastError:PROC
EXTRN	__imp_WSAGetLastError:PROC
EXTRN	__imp_WSAAccept:PROC
EXTRN	__imp_WSAHtonl:PROC
EXTRN	__imp_WSAIoctl:PROC
EXTRN	__imp_WSASocketA:PROC
EXTRN	__imp__get_osfhandle:PROC
EXTRN	__imp__open_osfhandle:PROC
EXTRN	__imp__sopen_s:PROC
EXTRN	CreateToolhelp32Snapshot:PROC
EXTRN	Process32First:PROC
EXTRN	Process32Next:PROC
EXTRN	__imp__CrtSetReportMode:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp__fdopen:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp__getmaxstdio:PROC
EXTRN	__imp___stdio_common_vfprintf:PROC
EXTRN	__imp___stdio_common_vsprintf:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fileno:PROC
EXTRN	__imp__beginthreadex:PROC
EXTRN	fthread_get_handle:PROC
EXTRN	hthread_set_thread_name:PROC
EXTRN	strlcpy:PROC
EXTRN	strlcat:PROC
EXTRN	timeval_add:PROC
EXTRN	rtrim:PROC
EXTRN	fwritemsg:PROC
EXTRN	logmsg:PROC
EXTRN	__C_specific_handler:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__chkstk:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
old_iph	DQ	01H DUP (?)
prev_rm	DD	01H DUP (?)
?szMsgBuff@?1??w32_strerror@@9@9 DB 0100H DUP (?)	; `w32_strerror'::`2'::szMsgBuff
	ALIGN	8

?uliHPCTicksPerSec@?1??clock_gettime@@9@9 DQ 01H DUP (?) ; `clock_gettime'::`2'::uliHPCTicksPerSec
?uliStartingHPCTick@?1??clock_gettime@@9@9 DQ 01H DUP (?) ; `clock_gettime'::`2'::uliStartingHPCTick
?uliMaxElapsedHPCTicks@?1??clock_gettime@@9@9 DQ 01H DUP (?) ; `clock_gettime'::`2'::uliMaxElapsedHPCTicks
?uliStartingNanoTime@?1??clock_gettime@@9@9 DQ 01H DUP (?) ; `clock_gettime'::`2'::uliStartingNanoTime
?tsPrevRetVal@?1??clock_gettime@@9@9 DB 010H DUP (?)	; `clock_gettime'::`2'::tsPrevRetVal
?u64ClockNanoScale@?1??clock_gettime@@9@9 DQ 01H DUP (?) ; `clock_gettime'::`2'::u64ClockNanoScale
?bInSync@?1??clock_gettime@@9@9 DD 01H DUP (?)		; `clock_gettime'::`2'::bInSync
	ALIGN	8

?timerint@?1??w32_nanosleep@@9@9 DQ 01H DUP (?)		; `w32_nanosleep'::`2'::timerint
?hTimer@?1??w32_nanosleep@@9@9 DQ 01H DUP (?)		; `w32_nanosleep'::`2'::hTimer
?liWaitAmt@?1??w32_nanosleep@@9@9 DQ 01H DUP (?)	; `w32_nanosleep'::`2'::liWaitAmt
?waitlock@?1??w32_nanosleep@@9@9 DB 028H DUP (?)	; `w32_nanosleep'::`2'::waitlock
?tsCurrTime@?1??w32_nanosleep@@9@9 DB 010H DUP (?)	; `w32_nanosleep'::`2'::tsCurrTime
?tsWakeTime@?1??w32_nanosleep@@9@9 DB 010H DUP (?)	; `w32_nanosleep'::`2'::tsWakeTime
?login_name@?1??getlogin@@9@9 DB 0101H DUP (?)		; `getlogin'::`2'::login_name
	ALIGN	4

$SG159931 DB	01H DUP (?)
	ALIGN	4

$SG159932 DB	01H DUP (?)
	ALIGN	4

$SG159933 DB	01H DUP (?)
	ALIGN	4

$SG160186 DB	01H DUP (?)
	ALIGN	4

$SG160189 DB	01H DUP (?)
	ALIGN	4

dwThreadId DD	01H DUP (?)
	ALIGN	8

hThread	DQ	01H DUP (?)
hGotStdIn DQ	01H DUP (?)
hStdInAvailable DQ 01H DUP (?)
hDupedStdIn DQ	01H DUP (?)
chStdIn	DB	01H DUP (?)
	ALIGN	4

kasock_head DB	010H DUP (?)
kasock_lock DB	028H DUP (?)
def_ka_time DD	01H DUP (?)
def_ka_intv DD	01H DUP (?)
def_ka_cnt DD	01H DUP (?)
?bDidThis@?1??kasock_init@@9@9 DD 01H DUP (?)		; `kasock_init'::`2'::bDidThis
	ALIGN	8

g_hIphlpapi_dll DQ 01H DUP (?)
g_pIf_NameToIndex DQ 01H DUP (?)
g_pRtlIpv4AddressToStringExA DQ 01H DUP (?)
g_pRtlIpv4StringToAddressExA DQ 01H DUP (?)
g_pRtlIpv6AddressToStringExA DQ 01H DUP (?)
g_pRtlIpv6StringToAddressExA DQ 01H DUP (?)
g_hNtdll_dll DQ	01H DUP (?)
?_basename@?1??w32_basename@@9@9 DB 0104H DUP (?)	; `w32_basename'::`2'::_basename
?_dirname@?1??w32_dirname@@9@9 DB 0104H DUP (?)		; `w32_dirname'::`2'::_dirname
?g_pagesize@?1??w32_hpagesize@@9@9 DD 01H DUP (?)	; `w32_hpagesize'::`2'::g_pagesize
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vfprintf_l DD imagerel $LN3
	DD	imagerel $LN3+68
	DD	imagerel $unwind$_vfprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$vfprintf DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$vfprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_l DD imagerel $LN5
	DD	imagerel $LN5+118
	DD	imagerel $unwind$_vsnprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$_vsnprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vscprintf_l DD imagerel $LN5
	DD	imagerel $LN5+108
	DD	imagerel $unwind$_vscprintf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vscprintf DD imagerel $LN3
	DD	imagerel $LN3+36
	DD	imagerel $unwind$_vscprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_snprintf DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$_snprintf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$are_elevated DD imagerel $LN10
	DD	imagerel $LN10+204
	DD	imagerel $unwind$are_elevated
$pdata$w32_trans_w32error DD imagerel $LN7
	DD	imagerel $LN7+83
	DD	imagerel $unwind$w32_trans_w32error
$pdata$w32_strerror DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$w32_strerror
$pdata$w32_strerror_r DD imagerel $LN7
	DD	imagerel $LN7+120
	DD	imagerel $unwind$w32_strerror_r
$pdata$w32_w32errmsg DD imagerel $LN13
	DD	imagerel $LN13+237
	DD	imagerel $unwind$w32_w32errmsg
$pdata$w32_NtStatusToLastError DD imagerel $LN3
	DD	imagerel $LN3+112
	DD	imagerel $unwind$w32_NtStatusToLastError
$pdata$socketpair DD imagerel $LN11
	DD	imagerel $LN11+796
	DD	imagerel $unwind$socketpair
$pdata$fork DD	imagerel $LN3
	DD	imagerel $LN3+26
	DD	imagerel $unwind$fork
$pdata$strtok_r DD imagerel $LN3
	DD	imagerel $LN3+45
	DD	imagerel $unwind$strtok_r
$pdata$clock_gettime DD imagerel $LN94
	DD	imagerel $LN94+1965
	DD	imagerel $unwind$clock_gettime
$pdata$gettimeofday DD imagerel $LN36
	DD	imagerel $LN36+484
	DD	imagerel $unwind$gettimeofday
$pdata$nanosleep DD imagerel $LN8
	DD	imagerel $LN8+86
	DD	imagerel $unwind$nanosleep
$pdata$usleep DD imagerel $LN8
	DD	imagerel $LN8+126
	DD	imagerel $unwind$usleep
$pdata$sleep DD	imagerel $LN3
	DD	imagerel $LN3+31
	DD	imagerel $unwind$sleep
$pdata$sched_yield DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$sched_yield
$pdata$scandir DD imagerel $LN16
	DD	imagerel $LN16+677
	DD	imagerel $unwind$scandir
$pdata$alphasort DD imagerel $LN3
	DD	imagerel $LN3+52
	DD	imagerel $unwind$alphasort
$pdata$getrusage DD imagerel $LN47
	DD	imagerel $LN47+926
	DD	imagerel $unwind$getrusage
$pdata$getlogin DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$getlogin
$pdata$getlogin_r DD imagerel $LN8
	DD	imagerel $LN8+110
	DD	imagerel $unwind$getlogin_r
$pdata$realpath DD imagerel $LN6
	DD	imagerel $LN6+103
	DD	imagerel $unwind$realpath
$pdata$inet_aton DD imagerel $LN6
	DD	imagerel $LN6+124
	DD	imagerel $unwind$inet_aton
$pdata$hostpath DD imagerel $LN25
	DD	imagerel $LN25+673
	DD	imagerel $unwind$hostpath
$pdata$get_file_accmode_flags DD imagerel $LN34
	DD	imagerel $LN34+569
	DD	imagerel $unwind$get_file_accmode_flags
$pdata$gethostid DD imagerel $LN5
	DD	imagerel $LN5+145
	DD	imagerel $unwind$gethostid
$pdata$socket_init DD imagerel $LN5
	DD	imagerel $LN5+114
	DD	imagerel $unwind$socket_init
$pdata$socket_set_blocking_mode DD imagerel $LN12
	DD	imagerel $LN12+184
	DD	imagerel $unwind$socket_set_blocking_mode
$pdata$socket_is_socket DD imagerel $LN11
	DD	imagerel $LN11+190
	DD	imagerel $unwind$socket_is_socket
$pdata$set_socket_keepalive DD imagerel $LN3
	DD	imagerel $LN3+55
	DD	imagerel $unwind$set_socket_keepalive
$pdata$get_socket_keepalive DD imagerel $LN13
	DD	imagerel $LN13+221
	DD	imagerel $unwind$get_socket_keepalive
$pdata$get_process_directory DD imagerel $LN8
	DD	imagerel $LN8+215
	DD	imagerel $unwind$get_process_directory
$pdata$expand_environ_vars DD imagerel $LN5
	DD	imagerel $LN5+88
	DD	imagerel $unwind$expand_environ_vars
$pdata$w32_init_hostinfo DD imagerel $LN198
	DD	imagerel $LN198+5792
	DD	imagerel $unwind$w32_init_hostinfo
$pdata$w32_socket DD imagerel $LN14
	DD	imagerel $LN14+221
	DD	imagerel $unwind$w32_socket
$pdata$w32_accept DD imagerel $LN14
	DD	imagerel $LN14+220
	DD	imagerel $unwind$w32_accept
$pdata$w32_close_socket DD imagerel $LN5
	DD	imagerel $LN5+67
	DD	imagerel $unwind$w32_close_socket
$pdata$w32_FD_SET DD imagerel $LN13
	DD	imagerel $LN13+195
	DD	imagerel $unwind$w32_FD_SET
$pdata$w32_FD_ISSET DD imagerel $LN10
	DD	imagerel $LN10+166
	DD	imagerel $unwind$w32_FD_ISSET
$pdata$w32_select DD imagerel $LN41
	DD	imagerel $LN41+1371
	DD	imagerel $unwind$w32_select
$pdata$w32_pselect DD imagerel $LN8
	DD	imagerel $LN8+211
	DD	imagerel $unwind$w32_pselect
$pdata$w32_if_nametoindex DD imagerel $LN8
	DD	imagerel $LN8+134
	DD	imagerel $unwind$w32_if_nametoindex
$pdata$w32_inet_ntop DD imagerel $LN10
	DD	imagerel $LN10+366
	DD	imagerel $unwind$w32_inet_ntop
$pdata$w32_inet_pton DD imagerel $LN12
	DD	imagerel $LN12+350
	DD	imagerel $unwind$w32_inet_pton
$pdata$w32_fdopen DD imagerel $LN20
	DD	imagerel $LN20+906
	DD	imagerel $unwind$w32_fdopen
$pdata$w32_fwrite DD imagerel $LN15
	DD	imagerel $LN15+320
	DD	imagerel $unwind$w32_fwrite
$pdata$w32_vsnprintf DD imagerel $LN4
	DD	imagerel $LN4+100
	DD	imagerel $unwind$w32_vsnprintf
$pdata$w32_snprintf DD imagerel $LN3
	DD	imagerel $LN3+81
	DD	imagerel $unwind$w32_snprintf
$pdata$w32_fprintf DD imagerel $LN19
	DD	imagerel $LN19+433
	DD	imagerel $unwind$w32_fprintf
$pdata$w32_fclose DD imagerel $LN14
	DD	imagerel $LN14+266
	DD	imagerel $unwind$w32_fclose
$pdata$w32_get_stdin_char DD imagerel $LN5
	DD	imagerel $LN5+131
	DD	imagerel $unwind$w32_get_stdin_char
$pdata$w32_poor_mans_fork DD imagerel $LN230
	DD	imagerel $LN230+4452
	DD	imagerel $unwind$w32_poor_mans_fork
$pdata$w32_set_thread_name DD imagerel $LN10
	DD	imagerel $LN10+88
	DD	imagerel $unwind$w32_set_thread_name
pdata	ENDS
pdata	SEGMENT
$pdata$w32_set_thread_name$filt$0 DD imagerel w32_set_thread_name$filt$0
	DD	imagerel w32_set_thread_name$filt$0+21
	DD	imagerel $unwind$w32_set_thread_name$filt$0
pdata	ENDS
pdata	SEGMENT
$pdata$w32_hpagesize DD imagerel $LN4
	DD	imagerel $LN4+45
	DD	imagerel $unwind$w32_hpagesize
$pdata$w32_mlock DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$w32_mlock
$pdata$w32_munlock DD imagerel $LN5
	DD	imagerel $LN5+61
	DD	imagerel $unwind$w32_munlock
$pdata$w32_hopen DD imagerel $LN6
	DD	imagerel $LN6+481
	DD	imagerel $unwind$w32_hopen
$pdata$w32_basename DD imagerel $LN7
	DD	imagerel $LN7+362
	DD	imagerel $unwind$w32_basename
$pdata$w32_dirname DD imagerel $LN7
	DD	imagerel $LN7+391
	DD	imagerel $unwind$w32_dirname
$pdata$w32_strcasestr DD imagerel $LN10
	DD	imagerel $LN10+336
	DD	imagerel $unwind$w32_strcasestr
$pdata$DisableInvalidParameterHandling DD imagerel $LN4
	DD	imagerel $LN4+60
	DD	imagerel $unwind$DisableInvalidParameterHandling
$pdata$EnableInvalidParameterHandling DD imagerel $LN4
	DD	imagerel $LN4+62
	DD	imagerel $unwind$EnableInvalidParameterHandling
$pdata$FileTimeTo1970Nanoseconds DD imagerel FileTimeTo1970Nanoseconds
	DD	imagerel FileTimeTo1970Nanoseconds+184
	DD	imagerel $unwind$FileTimeTo1970Nanoseconds
$pdata$w32_nanosleep DD imagerel w32_nanosleep
	DD	imagerel w32_nanosleep+1811
	DD	imagerel $unwind$w32_nanosleep
$pdata$rusage_failure DD imagerel rusage_failure
	DD	imagerel rusage_failure+78
	DD	imagerel $unwind$rusage_failure
$pdata$FileTime2us DD imagerel FileTime2us
	DD	imagerel FileTime2us+63
	DD	imagerel $unwind$FileTime2us
$pdata$FileTime2timeval DD imagerel FileTime2timeval
	DD	imagerel FileTime2timeval+42
	DD	imagerel $unwind$FileTime2timeval
$pdata$DoGetRUsage DD imagerel $LN12
	DD	imagerel $LN12+388
	DD	imagerel $unwind$DoGetRUsage
$pdata$CountSetBits DD imagerel $LN8
	DD	imagerel $LN8+167
	DD	imagerel $unwind$CountSetBits
$pdata$ReadStdInThread DD imagerel ReadStdInThread
	DD	imagerel ReadStdInThread+518
	DD	imagerel $unwind$ReadStdInThread
$pdata$CreateReadStdInThread DD imagerel CreateReadStdInThread
	DD	imagerel CreateReadStdInThread+983
	DD	imagerel $unwind$CreateReadStdInThread
$pdata$kasock_init DD imagerel kasock_init
	DD	imagerel kasock_init+1010
	DD	imagerel $unwind$kasock_init
$pdata$lock_kasock_list DD imagerel lock_kasock_list
	DD	imagerel lock_kasock_list+22
	DD	imagerel $unwind$lock_kasock_list
$pdata$unlock_kasock_list DD imagerel unlock_kasock_list
	DD	imagerel unlock_kasock_list+22
	DD	imagerel $unwind$unlock_kasock_list
$pdata$get_kasock DD imagerel get_kasock
	DD	imagerel get_kasock+108
	DD	imagerel $unwind$get_kasock
$pdata$add_kasock DD imagerel add_kasock
	DD	imagerel add_kasock+229
	DD	imagerel $unwind$add_kasock
$pdata$rem_kasock DD imagerel rem_kasock
	DD	imagerel rem_kasock+143
	DD	imagerel $unwind$rem_kasock
$pdata$internal_set_socket_keepalive DD imagerel internal_set_socket_keepalive
	DD	imagerel internal_set_socket_keepalive+466
	DD	imagerel $unwind$internal_set_socket_keepalive
$pdata$SelectSet DD imagerel SelectSet
	DD	imagerel SelectSet+308
	DD	imagerel $unwind$SelectSet
$pdata$w32_read_piped_process_stdxxx_output_thread DD imagerel $LN20
	DD	imagerel $LN20+597
	DD	imagerel $unwind$w32_read_piped_process_stdxxx_output_thread
$pdata$w32_parse_piped_process_stdxxx_data DD imagerel $LN56
	DD	imagerel $LN56+1156
	DD	imagerel $unwind$w32_parse_piped_process_stdxxx_data
pdata	ENDS
_DATA	SEGMENT
$SG159123 DB	'w32_w32errmsg', 00H
	ORG $+2
$SG159124 DB	'w32util.c', 00H
	ORG $+6
$SG159127 DB	'w32_w32errmsg', 00H
	ORG $+2
$SG159131 DB	' ', 09H, 0aH, 0bH, 0cH, 0dH, 00H
	ORG $+1
$SG159125 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159128 DB	'w32util.c', 00H
	ORG $+6
?u64ClockResolution@?1??clock_gettime@@9@9 DQ 000000003b9aca00H ; `clock_gettime'::`2'::u64ClockResolution
$SG159129 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159165 DB	'FileTimeTo1970Nanoseconds', 00H
	ORG $+2
?uiResyncSecs@?1??clock_gettime@@9@9 DD 01eH		; `clock_gettime'::`2'::uiResyncSecs
$SG159166 DB	'w32util.c', 00H
	ORG $+6
$SG159229 DB	'clock_gettime', 00H
	ORG $+2
$SG159516 DB	'*.*', 00H
	ORG $+4
$SG159167 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159169 DB	'FileTimeTo1970Nanoseconds', 00H
	ORG $+2
$SG159261 DB	'S', 00H
	ORG $+2
$SG159170 DB	'w32util.c', 00H
	ORG $+6
$SG159233 DB	'clock_gettime', 00H
	ORG $+2
$SG159717 DB	'\\.\', 00H
	ORG $+3
$SG159171 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159230 DB	'w32util.c', 00H
	ORG $+6
$SG159241 DB	'clock_gettime', 00H
	ORG $+2
$SG159718 DB	'//./', 00H
	ORG $+3
$SG159231 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159234 DB	'w32util.c', 00H
	ORG $+6
$SG159245 DB	'clock_gettime', 00H
	ORG $+2
$SG159719 DB	'\\.\', 00H
	ORG $+3
$SG159235 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159242 DB	'w32util.c', 00H
	ORG $+6
$SG159252 DB	'clock_gettime', 00H
	ORG $+2
$SG159759 DB	'get_file_accmode_flags', 00H
	ORG $+1
$SG159243 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159246 DB	'w32util.c', 00H
	ORG $+6
$SG159256 DB	'clock_gettime', 00H
	ORG $+2
$SG159763 DB	'get_file_accmode_flags', 00H
	ORG $+1
$SG159247 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159253 DB	'w32util.c', 00H
	ORG $+6
$SG159263 DB	'clock_gettime', 00H
	ORG $+2
$SG159768 DB	'get_file_accmode_flags', 00H
	ORG $+1
$SG159254 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159257 DB	'w32util.c', 00H
	ORG $+6
$SG159304 DB	'gettimeofday', 00H
	ORG $+3
$SG159392 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159772 DB	'get_file_accmode_flags', 00H
	ORG $+1
$SG159258 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159396 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159780 DB	'get_file_accmode_flags', 00H
	ORG $+1
$SG159262 DB	'HHC04112%s Cannot provide minimum emulated TOD clock res'
	DB	'olution', 0aH, 00H
	ORG $+3
$SG159515 DB	'/', 00H
	ORG $+2
$SG159264 DB	'w32util.c', 00H
	ORG $+2
$SG159970 DB	'??', 00H
	ORG $+1
$SG159305 DB	'w32util.c', 00H
	ORG $+6
$SG159308 DB	'gettimeofday', 00H
	ORG $+3
$SG159403 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159784 DB	'get_file_accmode_flags', 00H
	ORG $+1
$SG159306 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159309 DB	'w32util.c', 00H
	ORG $+6
$SG159314 DB	'gettimeofday', 00H
	ORG $+3
$SG159407 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159934 DB	'GetLogicalProcessorInformation', 00H
	ORG $+1
$SG159958 DB	'CallNtPowerInformation', 00H
	ORG $+1
$SG159310 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159315 DB	'w32util.c', 00H
	ORG $+6
$SG159318 DB	'gettimeofday', 00H
	ORG $+3
$SG159413 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159964 DB	'GetNativeSystemInfo', 00H
	ORG $+4
$SG159316 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159319 DB	'w32util.c', 00H
	ORG $+6
$SG159417 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159972 DB	'9x', 00H
	ORG $+5
$SG159320 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159393 DB	'w32util.c', 00H
	ORG $+6
$SG159427 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159975 DB	'GetProductInfo', 00H
	ORG $+1
$SG159980 DB	'Vista', 00H
	ORG $+2
$SG159394 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159397 DB	'w32util.c', 00H
	ORG $+6
$SG159431 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159986 DB	'Server 2008 R2', 00H
	ORG $+1
$SG159990 DB	'Ultimate Edition', 00H
	ORG $+7
$SG159398 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159404 DB	'w32util.c', 00H
	ORG $+6
$SG159436 DB	'w32_nanosleep', 00H
	ORG $+2
$SG159998 DB	'Home Premium Edition', 00H
	ORG $+3
$SG159405 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159408 DB	'w32util.c', 00H
	ORG $+6
$SG159440 DB	'w32_nanosleep', 00H
	ORG $+2
$SG160002 DB	'Home Basic Edition', 00H
	ORG $+5
$SG159409 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159414 DB	'w32util.c', 00H
	ORG $+6
$SG159446 DB	'w32_nanosleep', 00H
	ORG $+2
$SG160006 DB	'Home Premium Server', 00H
	ORG $+4
$SG159415 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159418 DB	'w32util.c', 00H
	ORG $+6
$SG159450 DB	'w32_nanosleep', 00H
	ORG $+2
$SG160008 DB	'Hyper-V', 00H
$SG159419 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159428 DB	'w32util.c', 00H
	ORG $+6
$SG159722 DB	'/cygdrive/', 00H
	ORG $+5
$SG159935 DB	'kernel32.dll', 00H
	ORG $+3
$SG159985 DB	'7', 00H
	ORG $+6
$SG159429 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159432 DB	'w32util.c', 00H
	ORG $+6
$SG159959 DB	'powrprof.dll', 00H
	ORG $+3
$SG160012 DB	'Enterprise Edition', 00H
	ORG $+5
$SG159433 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159437 DB	'w32util.c', 00H
	ORG $+6
$SG159965 DB	'kernel32.dll', 00H
	ORG $+3
$SG160015 DB	'Business Edition', 00H
	ORG $+7
$SG159438 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159441 DB	'w32util.c', 00H
	ORG $+6
$SG159976 DB	'kernel32.dll', 00H
	ORG $+3
$SG160017 DB	'Essential Business Server Management', 00H
	ORG $+3
$SG159442 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159447 DB	'w32util.c', 00H
	ORG $+6
$SG159981 DB	'Server 2008', 00H
$SG160171 DB	'2000', 00H
	ORG $+7
$SG159448 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159451 DB	'w32util.c', 00H
	ORG $+6
$SG159994 DB	'Professional', 00H
	ORG $+3
$SG160019 DB	'Essential Business Server Messaging', 00H
	ORG $+4
$SG159452 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159622 DB	'getrusage', 00H
	ORG $+2
$SG160178 DB	'Server', 00H
	ORG $+1
$SG160212 DB	'SH', 00H
	ORG $+1
$SG159623 DB	'w32util.c', 00H
	ORG $+6
$SG159624 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159626 DB	'getrusage', 00H
	ORG $+2
$SG160214 DB	'ARM', 00H
$SG159627 DB	'w32util.c', 00H
	ORG $+6
$SG160004 DB	'Home Server', 00H
$SG160198 DB	'i%d86', 00H
	ORG $+6
$SG159628 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159631 DB	'getrusage', 00H
	ORG $+2
$SG160224 DB	'???', 00H
$SG159632 DB	'w32util.c', 00H
	ORG $+6
$SG160021 DB	'Essential Business Server Security', 00H
	ORG $+5
$SG159633 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159635 DB	'getrusage', 00H
	ORG $+2
$SG160267 DB	'D', 00H
	ORG $+2
$SG159636 DB	'w32util.c', 00H
	ORG $+6
$SG160025 DB	'Starter Edition', 00H
$SG160027 DB	'Cluster Server Edition', 00H
	ORG $+1
$SG159637 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159640 DB	'getrusage', 00H
	ORG $+2
$SG160355 DB	'W', 00H
	ORG $+2
$SG159641 DB	'w32util.c', 00H
	ORG $+6
$SG160029 DB	'Cluster Server Edition w/o Hyper-V', 00H
	ORG $+5
$SG159642 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159644 DB	'getrusage', 00H
	ORG $+2
$SG160666 DB	'E', 00H
	ORG $+2
$SG159645 DB	'w32util.c', 00H
	ORG $+6
$SG160031 DB	'Datacenter Edition', 00H
	ORG $+5
$SG159646 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159707 DB	'hostpath', 00H
	ORG $+3
$SG160208 DB	'AMD64', 00H
	ORG $+2
$SG160876 DB	'D', 00H
	ORG $+2
$SG159708 DB	'w32util.c', 00H
	ORG $+6
$SG159709 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159711 DB	'hostpath', 00H
	ORG $+3
$SG160220 DB	'ALPHA', 00H
	ORG $+2
$SG160889 DB	'D', 00H
	ORG $+2
$SG159712 DB	'w32util.c', 00H
	ORG $+6
$SG159713 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159760 DB	'w32util.c', 00H
	ORG $+6
$SG160033 DB	'Datacenter Edition w/o Hyper-V', 00H
	ORG $+1
$SG160037 DB	'Datacenter Edition w/o Hyper-V (core)', 00H
	ORG $+2
$SG159761 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159764 DB	'w32util.c', 00H
	ORG $+6
$SG160039 DB	'Enterprise Edition', 00H
	ORG $+5
$SG159765 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159769 DB	'w32util.c', 00H
	ORG $+6
$SG160041 DB	'Enterprise Edition w/o Hyper-V', 00H
	ORG $+1
$SG160045 DB	'Enterprise Edition w/o Hyper-V (core)', 00H
	ORG $+2
$SG159770 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159773 DB	'w32util.c', 00H
	ORG $+6
$SG160047 DB	'Enterprise Edition for IA64 Systems', 00H
	ORG $+4
$SG159774 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159781 DB	'w32util.c', 00H
	ORG $+6
$SG160049 DB	'Essential Server Solutions', 00H
	ORG $+5
$SG160051 DB	'Essential Server Solutions w/o Hyper-V', 00H
	ORG $+1
$SG159782 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG159785 DB	'w32util.c', 00H
	ORG $+6
$SG160053 DB	'Server Foundation', 00H
	ORG $+6
$SG159786 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160035 DB	'Datacenter Edition (core)', 00H
	ORG $+2
$SG160895 DB	'D', 00H
	ORG $+2
$SG160043 DB	'Enterprise Edition (core)', 00H
	ORG $+2
$SG161115 DB	'r', 00H
	ORG $+2
$SG160055 DB	'Small Business Server', 00H
	ORG $+2
$SG160057 DB	'Small Business Server Premium Edition', 00H
	ORG $+2
$SG160059 DB	'Standard Edition', 00H
	ORG $+3
$SG161117 DB	'rbc', 00H
$SG160061 DB	'Standard Edition w/o Hyper-V', 00H
	ORG $+3
$SG160063 DB	'Standard Edition (core)', 00H
$SG160065 DB	'Standard Edition w/o Hyper-V (core)', 00H
$SG161119 DB	'r+', 00H
	ORG $+1
$SG160067 DB	'Storage Server Enterprise', 00H
	ORG $+2
$SG161123 DB	'r+b', 00H
$SG160069 DB	'Storage Server Express', 00H
	ORG $+1
$SG160071 DB	'Storage Server Standard', 00H
$SG160073 DB	'Storage Server Workgroup', 00H
	ORG $+3
$SG161127 DB	'rb+', 00H
$SG160075 DB	'Storage Server Enterprise (core)', 00H
	ORG $+3
$SG161131 DB	'w', 00H
	ORG $+2
$SG160077 DB	'Storage Server Express (core)', 00H
	ORG $+2
$SG160079 DB	'Storage Server Standard (core)', 00H
	ORG $+1
$SG160081 DB	'Storage Server Workgroup (core)', 00H
$SG160084 DB	'Small Business Solution Server', 00H
	ORG $+1
$SG160087 DB	'Server for Small Business Solutions', 00H
$SG161133 DB	'wbc', 00H
$SG160089 DB	'Standard Server Solutions', 00H
	ORG $+2
$SG161135 DB	'w+', 00H
	ORG $+1
$SG160091 DB	'Standard Server Solutions (core)', 00H
	ORG $+3
$SG161139 DB	'w+b', 00H
$SG160093 DB	'Embedded Solution Server', 00H
	ORG $+3
$SG161143 DB	'wb+', 00H
$SG160095 DB	'Embedded Solution Server (core)', 00H
$SG160097 DB	'Small Business Server Premium Edition (core)', 00H
	ORG $+3
$SG160099 DB	'EBS 2008 Management', 00H
$SG161147 DB	'a', 00H
	ORG $+2
$SG160101 DB	'EBS 2008 Additional', 00H
$SG161149 DB	'abc', 00H
$SG160103 DB	'EBS 2008 Management Services', 00H
	ORG $+3
$SG160105 DB	'EBS 2008 Additional Services', 00H
	ORG $+3
$SG160107 DB	'Embedded Server', 00H
$SG160109 DB	'Web Server Edition', 00H
	ORG $+1
$SG161151 DB	'a+', 00H
	ORG $+1
$SG160111 DB	'Web Server Edition (core)', 00H
	ORG $+2
$SG161155 DB	'a+b', 00H
$SG160113 DB	'Undefined Product', 00H
	ORG $+2
$SG161159 DB	'ab+', 00H
$SG160115 DB	'Unlicensed Product', 00H
	ORG $+1
$SG161741 DB	'%s', 0aH, 00H
$SG160117 DB	'unknown', 00H
$SG160121 DB	'Server 2003 R2', 00H
	ORG $+1
$SG160124 DB	'Storage Server 2003', 00H
$SG161841 DB	'%s', 0aH, 00H
$SG160127 DB	'Home Server', 00H
$SG161916 DB	'.', 00H
	ORG $+2
$SG160130 DB	'XP Professional x64 Edition', 00H
$SG161917 DB	'/', 00H
	ORG $+2
$SG160131 DB	'Server 2003', 00H
$SG161919 DB	'.', 00H
	ORG $+2
$SG160137 DB	'Datacenter Edition for IA64 Systems', 00H
$SG161933 DB	'.', 00H
	ORG $+2
$SG160139 DB	'Enterprise Edition for IA64 Systems', 00H
$SG161934 DB	'/', 00H
	ORG $+2
$SG160144 DB	'Datacenter x64 Edition', 00H
	ORG $+1
$SG160147 DB	'Enterprise x64 Edition', 00H
	ORG $+1
$SG160148 DB	'Standard x64 Edition', 00H
	ORG $+3
$SG160151 DB	'Computer Cluster Edition', 00H
	ORG $+3
$SG161936 DB	'.', 00H
	ORG $+2
$SG160154 DB	'Datacenter Edition', 00H
	ORG $+1
$SG161998 DB	'D', 00H
	ORG $+2
$SG160157 DB	'Enterprise Edition', 00H
	ORG $+5
$SG160160 DB	'Web Edition', 00H
	ORG $+4
$SG160161 DB	'Standard Edition', 00H
	ORG $+7
$SG160165 DB	'XP Home Edition', 00H
$SG160166 DB	'XP Professional', 00H
$SG160170 DB	'2000 Professional', 00H
	ORG $+6
$SG160174 DB	'Datacenter Server', 00H
	ORG $+6
$SG160177 DB	'Enterprise Server', 00H
	ORG $+6
$SG160182 DB	' 64-bit', 00H
$SG160185 DB	' 32-bit', 00H
$SG160188 DB	'unknown', 00H
$SG160190 DB	'Windows', 00H
$SG160191 DB	'%d.%d.%d', 00H
	ORG $+7
$SG160192 DB	'%s %s%s', 00H
$SG160202 DB	'GenuineIntel', 00H
	ORG $+3
$SG160203 DB	'Intel(R) x64', 00H
	ORG $+3
$SG160206 DB	'AuthenticAMD', 00H
	ORG $+3
$SG160207 DB	'AMD(R) x64', 00H
	ORG $+5
$SG160210 DB	'PowerPC', 00H
$SG160216 DB	'IA64', 00H
	ORG $+3
$SG160218 DB	'IA32_ON_WIN64', 00H
	ORG $+2
$SG160222 DB	'MIPS', 00H
	ORG $+3
$SG160261 DB	'ReadStdInThread', 00H
$SG160262 DB	'ReadStdInThread', 00H
$SG160266 DB	'ReadFile( hDupedStdIn ) failed! dwLastError=%d (0x%8.8X)'
	DB	': %s', 00H
	ORG $+3
$SG160268 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG160269 DB	'ReadStdInThread', 00H
$SG160270 DB	'w32util.c', 00H
	ORG $+6
$SG160272 DB	'ReadStdInThread', 00H
$SG160273 DB	'w32util.c', 00H
	ORG $+6
$SG160274 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160276 DB	'ReadStdInThread', 00H
$SG160277 DB	'w32util.c', 00H
	ORG $+6
$SG160335 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160278 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160336 DB	'w32util.c', 00H
	ORG $+6
$SG160339 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160337 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160340 DB	'w32util.c', 00H
	ORG $+6
$SG160345 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160341 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160346 DB	'w32util.c', 00H
	ORG $+6
$SG160349 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160347 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160350 DB	'w32util.c', 00H
	ORG $+6
$SG160357 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160351 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160361 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160356 DB	'HHC04110%s DuplicateHandle() failed: dwLastError=%d (0x%'
	DB	'8.8X): %s', 0aH, 00H
	ORG $+5
$SG160358 DB	'w32util.c', 00H
	ORG $+6
$SG160362 DB	'w32util.c', 00H
	ORG $+6
$SG160365 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160363 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160366 DB	'w32util.c', 00H
	ORG $+6
$SG160371 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160367 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160372 DB	'w32util.c', 00H
	ORG $+6
$SG160375 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160373 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160376 DB	'w32util.c', 00H
	ORG $+6
$SG160380 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160377 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160381 DB	'w32util.c', 00H
	ORG $+6
$SG160384 DB	'CreateReadStdInThread', 00H
	ORG $+2
$SG160382 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160385 DB	'w32util.c', 00H
	ORG $+6
$SG160497 DB	'kasock_init', 00H
$SG161121 DB	'r+bc', 00H
	ORG $+7
$SG160386 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160498 DB	'w32util.c', 00H
	ORG $+6
$SG160501 DB	'kasock_init', 00H
$SG161125 DB	'r+bc', 00H
	ORG $+7
$SG160499 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160502 DB	'w32util.c', 00H
	ORG $+6
$SG160505 DB	'SYSTEM\CurrentControlSet\Services\Tcpip\Parameters', 00H
	ORG $+5
$SG160503 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160507 DB	'KeepAliveTime', 00H
	ORG $+2
$SG160510 DB	'KeepAliveInterval', 00H
	ORG $+6
$SG160513 DB	'TcpMaxDataRetransmissions', 00H
	ORG $+6
$SG160517 DB	'PPTPTcpMaxDataRetransmissions', 00H
	ORG $+2
$SG160578 DB	'w32_socket', 00H
	ORG $+5
$SG160579 DB	'w32util.c', 00H
	ORG $+6
$SG160580 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160582 DB	'w32_socket', 00H
	ORG $+5
$SG160583 DB	'w32util.c', 00H
	ORG $+6
$SG160608 DB	'w32_accept', 00H
	ORG $+5
$SG160665 DB	'WSAIoctl( SIO_KEEPALIVE_VALS )', 00H
	ORG $+1
$SG160667 DB	'HHC02219%s Error in function %s: %s', 0aH, 00H
	ORG $+3
$SG160584 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160609 DB	'w32util.c', 00H
	ORG $+6
$SG160612 DB	'w32_accept', 00H
	ORG $+5
$SG160668 DB	'internal_set_socket_keepalive', 00H
	ORG $+2
$SG160699 DB	'get_socket_keepalive', 00H
	ORG $+3
$SG160610 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160613 DB	'w32util.c', 00H
	ORG $+6
$SG160703 DB	'get_socket_keepalive', 00H
	ORG $+3
$SG160614 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160669 DB	'w32util.c', 00H
	ORG $+6
$SG160700 DB	'w32util.c', 00H
	ORG $+6
$SG160712 DB	'255.255.255.255', 00H
$SG160877 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG160701 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160704 DB	'w32util.c', 00H
	ORG $+6
$SG160866 DB	'w32_select', 00H
	ORG $+5
$SG160890 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG160705 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160867 DB	'w32util.c', 00H
	ORG $+6
$SG160870 DB	'w32_select', 00H
	ORG $+5
$SG160896 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG160868 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160871 DB	'w32util.c', 00H
	ORG $+6
$SG160878 DB	'w32_select', 00H
	ORG $+5
$SG160985 DB	'iphlpapi.dll', 00H
	ORG $+3
$SG160988 DB	'if_nametoindex', 00H
	ORG $+1
$SG161129 DB	'r+bc', 00H
	ORG $+3
$SG160872 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161137 DB	'w+bc', 00H
	ORG $+3
$SG160875 DB	'** Win32 porting error: invalid call to ''w32_select'' f'
	DB	'rom %s(%d): NULL args', 00H
	ORG $+4
$SG160879 DB	'w32util.c', 00H
	ORG $+6
$SG160888 DB	'** Win32 porting error: invalid call to ''w32_select'' f'
	DB	'rom %s(%d): mixed set(s)', 00H
	ORG $+1
$SG160891 DB	'w32_select', 00H
	ORG $+5
$SG160892 DB	'w32util.c', 00H
	ORG $+6
$SG160894 DB	'** Win32 porting error: invalid call to ''w32_select'' f'
	DB	'rom %s(%d): non-socket except set', 00H
$SG160897 DB	'w32_select', 00H
	ORG $+5
$SG160898 DB	'w32util.c', 00H
	ORG $+6
$SG160906 DB	'w32_select', 00H
	ORG $+5
$SG160907 DB	'w32util.c', 00H
	ORG $+6
$SG160910 DB	'w32_select', 00H
	ORG $+1
$SG161141 DB	'w+bc', 00H
	ORG $+7
$SG160908 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160911 DB	'w32util.c', 00H
	ORG $+2
$SG161145 DB	'w+bc', 00H
	ORG $+7
$SG160912 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160940 DB	'SelectSet', 00H
	ORG $+6
$SG160941 DB	'w32util.c', 00H
	ORG $+2
$SG161153 DB	'a+bc', 00H
	ORG $+7
$SG160942 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG160944 DB	'SelectSet', 00H
	ORG $+6
$SG160945 DB	'w32util.c', 00H
	ORG $+2
$SG161157 DB	'a+bc', 00H
	ORG $+7
$SG160946 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161056 DB	'ntdll.dll', 00H
	ORG $+6
$SG161059 DB	'RtlIpv4AddressToStringExA', 00H
	ORG $+6
$SG161063 DB	'RtlIpv6AddressToStringExA', 00H
	ORG $+6
$SG161078 DB	'ntdll.dll', 00H
	ORG $+6
$SG161081 DB	'RtlIpv4StringToAddressExA', 00H
	ORG $+6
$SG161084 DB	'RtlIpv6StringToAddressExA', 00H
	ORG $+2
$SG161161 DB	'a+bc', 00H
	ORG $+7
$SG161163 DB	'w32_fdopen', 00H
	ORG $+5
$SG161164 DB	'w32util.c', 00H
	ORG $+6
$SG161165 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161167 DB	'w32_fdopen', 00H
	ORG $+5
$SG161168 DB	'w32util.c', 00H
	ORG $+6
$SG161198 DB	'w32_fwrite', 00H
	ORG $+5
$SG161259 DB	'w32_fprintf', 00H
	ORG $+12
$SG161169 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161199 DB	'w32util.c', 00H
	ORG $+14
$SG161200 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161202 DB	'w32_fwrite', 00H
	ORG $+5
$SG161203 DB	'w32util.c', 00H
	ORG $+14
$SG161204 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161260 DB	'w32util.c', 00H
	ORG $+14
$SG161261 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161263 DB	'w32_fprintf', 00H
	ORG $+4
$SG161264 DB	'w32util.c', 00H
	ORG $+14
$SG161265 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161285 DB	'w32_fclose', 00H
	ORG $+5
$SG161286 DB	'w32util.c', 00H
	ORG $+14
$SG161287 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161289 DB	'w32_fclose', 00H
	ORG $+5
$SG161290 DB	'w32util.c', 00H
	ORG $+14
$SG161291 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161520 DB	'...(truncated)', 0aH, 00H
$SG161524 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161525 DB	'w32util.c', 00H
	ORG $+6
$SG161526 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161528 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161529 DB	'w32util.c', 00H
	ORG $+6
$SG161530 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161533 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161534 DB	'w32util.c', 00H
	ORG $+6
$SG161535 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161537 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161538 DB	'w32util.c', 00H
	ORG $+6
$SG161539 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161542 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161543 DB	'w32util.c', 00H
	ORG $+6
$SG161544 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161546 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161547 DB	'w32util.c', 00H
	ORG $+6
$SG161548 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161551 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161552 DB	'w32util.c', 00H
	ORG $+6
$SG161553 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161555 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161556 DB	'w32util.c', 00H
	ORG $+6
$SG161557 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161560 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161561 DB	'w32util.c', 00H
	ORG $+6
$SG161562 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161564 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161565 DB	'w32util.c', 00H
	ORG $+6
$SG161566 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161569 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161570 DB	'w32util.c', 00H
	ORG $+6
$SG161571 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161573 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161574 DB	'w32util.c', 00H
	ORG $+6
$SG161575 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161578 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161579 DB	'w32util.c', 00H
	ORG $+6
$SG161580 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161582 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161583 DB	'w32util.c', 00H
	ORG $+6
$SG161584 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161587 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161588 DB	'w32util.c', 00H
	ORG $+6
$SG161589 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161591 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161592 DB	'w32util.c', 00H
	ORG $+6
$SG161593 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161596 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161597 DB	'w32util.c', 00H
	ORG $+6
$SG161598 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161600 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161601 DB	'w32util.c', 00H
	ORG $+6
$SG161602 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161606 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161607 DB	'w32util.c', 00H
	ORG $+6
$SG161608 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161610 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161611 DB	'w32util.c', 00H
	ORG $+6
$SG161612 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161615 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161616 DB	'w32util.c', 00H
	ORG $+6
$SG161617 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161619 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161620 DB	'w32util.c', 00H
	ORG $+6
$SG161621 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161624 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161625 DB	'w32util.c', 00H
	ORG $+6
$SG161626 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161628 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161629 DB	'w32util.c', 00H
	ORG $+6
$SG161630 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161633 DB	'*** CreateProcess() failed! rc = %d : %s', 0aH, 00H
	ORG $+6
$SG161635 DB	'*** CreateProcess() failed! rc = %d : %s', 0aH, 00H
	ORG $+6
$SG161638 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161639 DB	'w32util.c', 00H
	ORG $+6
$SG161640 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161642 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161643 DB	'w32util.c', 00H
	ORG $+6
$SG161644 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161647 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161648 DB	'w32util.c', 00H
	ORG $+6
$SG161649 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161651 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161652 DB	'w32util.c', 00H
	ORG $+6
$SG161653 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161656 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161657 DB	'w32util.c', 00H
	ORG $+6
$SG161658 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161660 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161661 DB	'w32util.c', 00H
	ORG $+6
$SG161662 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161668 DB	'*** _beginthreadex() failed! rc = %d : %s', 0aH, 00H
	ORG $+5
$SG161670 DB	'*** _beginthreadex() failed! rc = %d : %s', 0aH, 00H
	ORG $+5
$SG161673 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161674 DB	'w32util.c', 00H
	ORG $+6
$SG161675 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161677 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161678 DB	'w32util.c', 00H
	ORG $+6
$SG161679 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161682 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161683 DB	'w32util.c', 00H
	ORG $+6
$SG161684 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161686 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161687 DB	'w32util.c', 00H
	ORG $+6
$SG161688 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161691 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161692 DB	'w32util.c', 00H
	ORG $+6
$SG161693 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161695 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161696 DB	'w32util.c', 00H
	ORG $+6
$SG161697 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161700 DB	'w32_pipe_stdOUT', 00H
$SG161701 DB	'w32_pipe_stdOUT', 00H
$SG161704 DB	'*** _beginthreadex() failed! rc = %d : %s', 0aH, 00H
	ORG $+5
$SG161706 DB	'*** _beginthreadex() failed! rc = %d : %s', 0aH, 00H
	ORG $+5
$SG161709 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161710 DB	'w32util.c', 00H
	ORG $+6
$SG161711 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161713 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161714 DB	'w32util.c', 00H
	ORG $+6
$SG161715 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161718 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161719 DB	'w32util.c', 00H
	ORG $+6
$SG161720 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161722 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161723 DB	'w32util.c', 00H
	ORG $+6
$SG161724 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161727 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161728 DB	'w32util.c', 00H
	ORG $+6
$SG161729 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161731 DB	'w32_poor_mans_fork', 00H
	ORG $+5
$SG161732 DB	'w32util.c', 00H
	ORG $+6
$SG161733 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161736 DB	'w32_pipe_stdERR', 00H
$SG161737 DB	'w32_pipe_stdERR', 00H
$SG161783 DB	'w32_read_piped_process_stdxxx_output_thread', 00H
	ORG $+4
$SG161784 DB	'w32util.c', 00H
	ORG $+14
$SG161785 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161787 DB	'w32_read_piped_process_stdxxx_output_thread', 00H
	ORG $+4
$SG161788 DB	'w32util.c', 00H
	ORG $+14
$SG161789 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161844 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161845 DB	'w32util.c', 00H
	ORG $+6
$SG161846 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161848 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161849 DB	'w32util.c', 00H
	ORG $+6
$SG161850 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161854 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161855 DB	'w32util.c', 00H
	ORG $+6
$SG161856 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161858 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161859 DB	'w32util.c', 00H
	ORG $+6
$SG161860 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161864 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161865 DB	'w32util.c', 00H
	ORG $+6
$SG161866 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161868 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161869 DB	'w32util.c', 00H
	ORG $+6
$SG161870 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161873 DB	'*** ParseStdxxxMsg logic error! ***', 0aH, 00H
	ORG $+3
$SG161875 DB	'*** ParseStdxxxMsg logic error! ***', 0aH, 00H
	ORG $+3
$SG161877 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161878 DB	'w32util.c', 00H
	ORG $+6
$SG161879 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161881 DB	'w32_parse_piped_process_stdxxx_data', 00H
	ORG $+4
$SG161882 DB	'w32util.c', 00H
	ORG $+6
$SG161883 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG161997 DB	'Error opening ''%s''; errno(%d) %s', 00H
	ORG $+7
$SG161999 DB	'HHC90000%s DBG: %s', 0aH, 00H
	ORG $+4
$SG162000 DB	'w32_hopen', 00H
	ORG $+6
$SG162001 DB	'w32util.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_read_piped_process_stdxxx_output_thread
	DD	018H
	DD	023bH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:internal_set_socket_keepalive
	DD	023H
	DD	01baH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:kasock_init
	DD	013H
	DD	03d9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:CreateReadStdInThread
	DD	011H
	DD	03bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:ReadStdInThread
	DD	016H
	DD	01eeH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_nanosleep
	DD	018H
	DD	06fcH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_dirname
	DD	017H
	DD	016eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_basename
	DD	017H
	DD	0151H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_hopen
	DD	024H
	DD	01c9H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_fdopen
	DD	01aH
	DD	0372H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_select
	DD	02aH
	DD	0543H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:w32_init_hostinfo
	DD	019H
	DD	0155fH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:get_process_directory
	DD	01bH
	DD	0bfH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:socket_init
	DD	011H
	DD	05aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:gethostid
	DD	011H
	DD	079H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:getrusage
	DD	01bH
	DD	0385H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:scandir
	DD	026H
	DD	028cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:usleep
	DD	012H
	DD	06cH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:gettimeofday
	DD	019H
	DD	01d1H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:clock_gettime
	DD	01aH
	DD	0795H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:socketpair
	DD	024H
	DD	0303H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$are_elevated DD 020601H
	DD	070029206H
$unwind$w32_trans_w32error DD 010801H
	DD	02208H
$unwind$w32_strerror DD 010801H
	DD	04208H
$unwind$w32_strerror_r DD 011201H
	DD	04212H
$unwind$w32_w32errmsg DD 011201H
	DD	0a212H
$unwind$w32_NtStatusToLastError DD 010801H
	DD	0a208H
$unwind$socketpair DD 032c19H
	DD	012011aH
	DD	07013H
	DD	imagerel __GSHandlerCheck
	DD	080H
$unwind$fork DD	010401H
	DD	04204H
$unwind$strtok_r DD 011301H
	DD	04213H
$unwind$clock_gettime DD 022219H
	DD	0170110H
	DD	imagerel __GSHandlerCheck
	DD	0a0H
$unwind$gettimeofday DD 021e19H
	DD	0700b920fH
	DD	imagerel __GSHandlerCheck
	DD	040H
$unwind$nanosleep DD 010e01H
	DD	0620eH
$unwind$usleep DD 011719H
	DD	08208H
	DD	imagerel __GSHandlerCheck
	DD	038H
$unwind$sleep DD 010801H
	DD	04208H
$unwind$sched_yield DD 010401H
	DD	04204H
$unwind$scandir DD 032e19H
	DD	058011cH
	DD	07015H
	DD	imagerel __GSHandlerCheck
	DD	02b0H
$unwind$alphasort DD 010e01H
	DD	0420eH
$unwind$getrusage DD 032319H
	DD	0320111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$getlogin DD 010401H
	DD	06204H
$unwind$getlogin_r DD 010e01H
	DD	0620eH
$unwind$realpath DD 010e01H
	DD	0620eH
$unwind$inet_aton DD 010e01H
	DD	0620eH
$unwind$hostpath DD 011301H
	DD	06213H
$unwind$get_file_accmode_flags DD 010801H
	DD	0a208H
$unwind$gethostid DD 021919H
	DD	0290107H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$socket_init DD 021919H
	DD	03d0107H
	DD	imagerel __GSHandlerCheck
	DD	01d0H
$unwind$socket_set_blocking_mode DD 010c01H
	DD	0620cH
$unwind$socket_is_socket DD 010801H
	DD	0a208H
$unwind$set_socket_keepalive DD 011601H
	DD	06216H
$unwind$get_socket_keepalive DD 011701H
	DD	06217H
$unwind$get_process_directory DD 022319H
	DD	02b0111H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$expand_environ_vars DD 011301H
	DD	06213H
$unwind$w32_init_hostinfo DD 052119H
	DD	052010fH
	DD	060077008H
	DD	03006H
	DD	imagerel __GSHandlerCheck
	DD	0280H
$unwind$w32_socket DD 011101H
	DD	08211H
$unwind$w32_accept DD 011201H
	DD	08212H
$unwind$w32_close_socket DD 010801H
	DD	06208H
$unwind$w32_FD_SET DD 010d01H
	DD	0620dH
$unwind$w32_FD_ISSET DD 010d01H
	DD	0620dH
$unwind$w32_select DD 023219H
	DD	086f0120H
	DD	imagerel __GSHandlerCheck
	DD	04360H
$unwind$w32_pselect DD 011701H
	DD	0a217H
$unwind$w32_if_nametoindex DD 010901H
	DD	06209H
$unwind$w32_inet_ntop DD 011701H
	DD	08217H
$unwind$w32_inet_pton DD 011201H
	DD	08212H
$unwind$w32_fdopen DD 022219H
	DD	0330110H
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$w32_fwrite DD 011801H
	DD	08218H
$unwind$w32_vsnprintf DD 011801H
	DD	08218H
$unwind$w32_snprintf DD 011801H
	DD	06218H
$unwind$w32_fprintf DD 011801H
	DD	0a218H
$unwind$w32_fclose DD 010901H
	DD	08209H
$unwind$w32_get_stdin_char DD 010d01H
	DD	0420dH
$unwind$w32_poor_mans_fork DD 031201H
	DD	0320112H
	DD	0700bH
$unwind$w32_set_thread_name DD 010d09H
	DD	0820dH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN10+57
	DD	imagerel $LN10+83
	DD	imagerel w32_set_thread_name$filt$0
	DD	imagerel $LN10+83
$unwind$w32_set_thread_name$filt$0 DD 020601H
	DD	050023206H
$unwind$w32_hpagesize DD 010401H
	DD	0a204H
$unwind$w32_mlock DD 010e01H
	DD	0620eH
$unwind$w32_munlock DD 010e01H
	DD	0620eH
$unwind$w32_hopen DD 022c19H
	DD	051011aH
	DD	imagerel __GSHandlerCheck
	DD	0270H
$unwind$w32_basename DD 031f19H
	DD	06e010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0360H
$unwind$w32_dirname DD 031f19H
	DD	050010dH
	DD	07006H
	DD	imagerel __GSHandlerCheck
	DD	0270H
$unwind$w32_strcasestr DD 010e01H
	DD	0820eH
$unwind$DisableInvalidParameterHandling DD 010401H
	DD	04204H
$unwind$EnableInvalidParameterHandling DD 010401H
	DD	04204H
$unwind$FileTimeTo1970Nanoseconds DD 010901H
	DD	06209H
$unwind$w32_nanosleep DD 041d19H
	DD	011010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	078H
$unwind$rusage_failure DD 010901H
	DD	04209H
$unwind$FileTime2us DD 010901H
	DD	02209H
$unwind$FileTime2timeval DD 010e01H
	DD	0420eH
$unwind$DoGetRUsage DD 011101H
	DD	0c211H
$unwind$CountSetBits DD 010901H
	DD	04209H
$unwind$ReadStdInThread DD 021e19H
	DD	06d010cH
	DD	imagerel __GSHandlerCheck
	DD	0350H
$unwind$CreateReadStdInThread DD 021919H
	DD	0310107H
	DD	imagerel __GSHandlerCheck
	DD	0170H
$unwind$kasock_init DD 031b19H
	DD	0280109H
	DD	07002H
	DD	imagerel __GSHandlerCheck
	DD	0130H
$unwind$lock_kasock_list DD 010401H
	DD	04204H
$unwind$unlock_kasock_list DD 010401H
	DD	04204H
$unwind$get_kasock DD 010901H
	DD	06209H
$unwind$add_kasock DD 010901H
	DD	08209H
$unwind$rem_kasock DD 010901H
	DD	08209H
$unwind$internal_set_socket_keepalive DD 022b19H
	DD	0130119H
	DD	imagerel __GSHandlerCheck
	DD	088H
$unwind$SelectSet DD 011801H
	DD	06218H
$unwind$w32_read_piped_process_stdxxx_output_thread DD 042019H
	DD	018f010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0c60H
$unwind$w32_parse_piped_process_stdxxx_data DD 031501H
	DD	07011a215H
	DD	06010H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_snprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vscprintf DD 010e01H
	DD	0420eH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vscprintf_l DD 011301H
	DD	08213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_l DD 011801H
	DD	08218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$vfprintf DD 011301H
	DD	04213H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vfprintf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
nlen$ = 32
ntotlen$ = 36
pbeg$ = 40
pend$ = 48
pmsgend$ = 56
nNewStrLen$1 = 64
nAllocSizeNeeded$2 = 72
pPipedProcessCtl$ = 112
holdbuff$ = 120
pnHoldAmount$ = 128
w32_parse_piped_process_stdxxx_data PROC

; 4353 : {

$LN56:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4354 :     // This function executes in the context of the worker thread that calls it.
; 4355 : 
; 4356 :     char* pbeg;                         // ptr to start of message
; 4357 :     char* pend;                         // find end of message (MUST NOT BE MODIFIED!)
; 4358 :     char* pmsgend;                      // work ptr to end of message
; 4359 :                                         // 'pend' variable MUST NOT BE MODIFIED
; 4360 :     int nlen;                           // work length of one message
; 4361 :     int ntotlen;                        // accumulated length of all parsed messages
; 4362 : 
; 4363 :     // A worker thread that monitors a child's Stdout o/p has received a message
; 4364 :     // and is calling this function to determine what, if anything, to do with it.
; 4365 : 
; 4366 :     // (Note: the worker thread that calls us ensures holdbuff is null terminated)
; 4367 : 
; 4368 :     pbeg = holdbuff;                    // ptr to start of message

  00015	48 8b 44 24 78	 mov	 rax, QWORD PTR holdbuff$[rsp]
  0001a	48 89 44 24 28	 mov	 QWORD PTR pbeg$[rsp], rax

; 4369 :     pend = strchr(pbeg,'\n');           // find end of message (MUST NOT BE MODIFIED!)

  0001f	ba 0a 00 00 00	 mov	 edx, 10
  00024	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pbeg$[rsp]
  00029	e8 00 00 00 00	 call	 strchr
  0002e	48 89 44 24 30	 mov	 QWORD PTR pend$[rsp], rax

; 4370 :     if (!pend) return;                  // we don't we have a complete message yet

  00033	48 83 7c 24 30
	00		 cmp	 QWORD PTR pend$[rsp], 0
  00039	75 05		 jne	 SHORT $LN34@w32_parse_
  0003b	e9 3d 04 00 00	 jmp	 $LN1@w32_parse_
$LN34@w32_parse_:

; 4371 :     ntotlen = 0;                        // accumulated length of all parsed messages

  00040	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR ntotlen$[rsp], 0
$LN4@w32_parse_:

; 4372 : 
; 4373 :     // Parse the message...
; 4374 : 
; 4375 :     do
; 4376 :     {
; 4377 :         nlen = (pend-pbeg);             // get length of THIS message

  00048	48 8b 44 24 28	 mov	 rax, QWORD PTR pbeg$[rsp]
  0004d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR pend$[rsp]
  00052	48 2b c8	 sub	 rcx, rax
  00055	48 8b c1	 mov	 rax, rcx
  00058	89 44 24 20	 mov	 DWORD PTR nlen$[rsp], eax

; 4378 :         ntotlen += nlen + 1;            // keep track of all that we see

  0005c	8b 44 24 24	 mov	 eax, DWORD PTR ntotlen$[rsp]
  00060	8b 4c 24 20	 mov	 ecx, DWORD PTR nlen$[rsp]
  00064	8d 44 08 01	 lea	 eax, DWORD PTR [rax+rcx+1]
  00068	89 44 24 24	 mov	 DWORD PTR ntotlen$[rsp], eax

; 4379 : 
; 4380 :         // Remove trailing newline character and any other trailing blanks...
; 4381 : 
; 4382 :         // (Note: we MUST NOT MODIFY the 'pend' variable. It should always
; 4383 :         // point to where the newline character was found so we can start
; 4384 :         // looking for the next message (if there is one) where this message
; 4385 :         // ended).
; 4386 : 
; 4387 :         *pend = 0;                      // (change newline character to null)

  0006c	48 8b 44 24 30	 mov	 rax, QWORD PTR pend$[rsp]
  00071	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4388 :         pmsgend = pend;                 // (start removing blanks from here)

  00074	48 8b 44 24 30	 mov	 rax, QWORD PTR pend$[rsp]
  00079	48 89 44 24 38	 mov	 QWORD PTR pmsgend$[rsp], rax
$LN5@w32_parse_:

; 4389 : 
; 4390 :         while (--pmsgend >= pbeg && isspace(*pmsgend)) {*pmsgend = 0; --nlen;}

  0007e	48 8b 44 24 38	 mov	 rax, QWORD PTR pmsgend$[rsp]
  00083	48 ff c8	 dec	 rax
  00086	48 89 44 24 38	 mov	 QWORD PTR pmsgend$[rsp], rax
  0008b	48 8b 44 24 28	 mov	 rax, QWORD PTR pbeg$[rsp]
  00090	48 39 44 24 38	 cmp	 QWORD PTR pmsgend$[rsp], rax
  00095	72 28		 jb	 SHORT $LN6@w32_parse_
  00097	48 8b 44 24 38	 mov	 rax, QWORD PTR pmsgend$[rsp]
  0009c	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0009f	8b c8		 mov	 ecx, eax
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  000a7	85 c0		 test	 eax, eax
  000a9	74 14		 je	 SHORT $LN6@w32_parse_
  000ab	48 8b 44 24 38	 mov	 rax, QWORD PTR pmsgend$[rsp]
  000b0	c6 00 00	 mov	 BYTE PTR [rax], 0
  000b3	8b 44 24 20	 mov	 eax, DWORD PTR nlen$[rsp]
  000b7	ff c8		 dec	 eax
  000b9	89 44 24 20	 mov	 DWORD PTR nlen$[rsp], eax
  000bd	eb bf		 jmp	 SHORT $LN5@w32_parse_
$LN6@w32_parse_:

; 4391 : 
; 4392 :         // If we were passed a PIPED_PROCESS_CTL pointer, then the root thread
; 4393 :         // wants us to just capture the o/p and IT will issue the logmsg within
; 4394 :         // its own thread. Otherwise root thread isn't interested in capturing
; 4395 :         // and thus we must issue the individual logmsg's ourselves...
; 4396 : 
; 4397 :         if (!pPipedProcessCtl)

  000bf	48 83 7c 24 70
	00		 cmp	 QWORD PTR pPipedProcessCtl$[rsp], 0
  000c5	75 16		 jne	 SHORT $LN35@w32_parse_

; 4398 :         {
; 4399 :             logmsg("%s\n",pbeg);    // send all child's msgs to Herc console

  000c7	48 8b 54 24 28	 mov	 rdx, QWORD PTR pbeg$[rsp]
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161841
  000d3	e8 00 00 00 00	 call	 logmsg

; 4400 :         }

  000d8	e9 fb 01 00 00	 jmp	 $LN36@w32_parse_
$LN35@w32_parse_:

; 4401 :         else
; 4402 :         {
; 4403 :             size_t  nNewStrLen, nAllocSizeNeeded;   // (work)
; 4404 : 
; 4405 :             EnterCriticalSection( &pPipedProcessCtl->csLock );

  000dd	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  000e2	48 83 c0 18	 add	 rax, 24
  000e6	48 8b c8	 mov	 rcx, rax
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 4406 : 
; 4407 :             nNewStrLen        = strlen( pbeg );

  000ef	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pbeg$[rsp]
  000f4	e8 00 00 00 00	 call	 strlen
  000f9	48 89 44 24 40	 mov	 QWORD PTR nNewStrLen$1[rsp], rax

; 4408 :             nAllocSizeNeeded  = ((((pPipedProcessCtl->nStrLen + nNewStrLen + 2) / 4096) + 1) * 4096);

  000fe	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00103	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR nNewStrLen$1[rsp]
  0010c	48 8d 44 08 02	 lea	 rax, QWORD PTR [rax+rcx+2]
  00111	33 d2		 xor	 edx, edx
  00113	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  00118	48 f7 f1	 div	 rcx
  0011b	48 ff c0	 inc	 rax
  0011e	48 69 c0 00 10
	00 00		 imul	 rax, rax, 4096		; 00001000H
  00125	48 89 44 24 48	 mov	 QWORD PTR nAllocSizeNeeded$2[rsp], rax

; 4409 : 
; 4410 :             if ( nAllocSizeNeeded > pPipedProcessCtl->nAllocSize )

  0012a	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  0012f	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00133	48 39 44 24 48	 cmp	 QWORD PTR nAllocSizeNeeded$2[rsp], rax
  00138	0f 86 95 00 00
	00		 jbe	 $LN37@w32_parse_

; 4411 :             {
; 4412 :                 pPipedProcessCtl->nAllocSize = nAllocSizeNeeded;

  0013e	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00143	48 8b 4c 24 48	 mov	 rcx, QWORD PTR nAllocSizeNeeded$2[rsp]
  00148	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4413 :                 pPipedProcessCtl->pszBuffer  = realloc( pPipedProcessCtl->pszBuffer, nAllocSizeNeeded );

  0014c	48 8b 54 24 48	 mov	 rdx, QWORD PTR nAllocSizeNeeded$2[rsp]
  00151	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00156	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realloc
  0015f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00164	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN9@w32_parse_:

; 4414 :                 ASSERT( pPipedProcessCtl->pszBuffer );

  00167	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  0016c	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00170	75 5b		 jne	 SHORT $LN38@w32_parse_
$LN12@w32_parse_:
  00172	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161844
  00179	41 b8 3e 11 00
	00		 mov	 r8d, 4414		; 0000113eH
  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161845
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161846
  0018d	e8 00 00 00 00	 call	 logmsg
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00198	85 c0		 test	 eax, eax
  0019a	74 20		 je	 SHORT $LN39@w32_parse_
  0019c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161848
  001a3	41 b8 3e 11 00
	00		 mov	 r8d, 4414		; 0000113eH
  001a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161849
  001b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161850
  001b7	e8 00 00 00 00	 call	 DebuggerTrace
$LN39@w32_parse_:
  001bc	33 c0		 xor	 eax, eax
  001be	85 c0		 test	 eax, eax
  001c0	75 b0		 jne	 SHORT $LN12@w32_parse_
  001c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001c8	85 c0		 test	 eax, eax
  001ca	74 01		 je	 SHORT $LN40@w32_parse_
  001cc	cc		 int	 3
$LN40@w32_parse_:
$LN38@w32_parse_:
  001cd	33 c0		 xor	 eax, eax
  001cf	85 c0		 test	 eax, eax
  001d1	75 94		 jne	 SHORT $LN9@w32_parse_
$LN37@w32_parse_:

; 4415 :             }
; 4416 : 
; 4417 :             if (nNewStrLen)

  001d3	48 83 7c 24 40
	00		 cmp	 QWORD PTR nNewStrLen$1[rsp], 0
  001d9	74 37		 je	 SHORT $LN41@w32_parse_

; 4418 :             {
; 4419 :                 memcpy( pPipedProcessCtl->pszBuffer + pPipedProcessCtl->nStrLen, pbeg, nNewStrLen );

  001db	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  001e0	48 8b 00	 mov	 rax, QWORD PTR [rax]
  001e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  001e8	48 03 41 10	 add	 rax, QWORD PTR [rcx+16]
  001ec	48 8b f8	 mov	 rdi, rax
  001ef	48 8b 74 24 28	 mov	 rsi, QWORD PTR pbeg$[rsp]
  001f4	48 8b 4c 24 40	 mov	 rcx, QWORD PTR nNewStrLen$1[rsp]
  001f9	f3 a4		 rep movsb

; 4420 :                 pPipedProcessCtl->nStrLen += nNewStrLen;

  001fb	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00200	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00204	48 03 44 24 40	 add	 rax, QWORD PTR nNewStrLen$1[rsp]
  00209	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  0020e	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
$LN41@w32_parse_:

; 4421 :             }
; 4422 : 
; 4423 :             *(pPipedProcessCtl->pszBuffer + pPipedProcessCtl->nStrLen) = '\n';

  00212	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00217	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0021a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  0021f	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00223	c6 04 08 0a	 mov	 BYTE PTR [rax+rcx], 10

; 4424 :             pPipedProcessCtl->nStrLen++;

  00227	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  0022c	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00230	48 ff c0	 inc	 rax
  00233	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00238	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 4425 :             *(pPipedProcessCtl->pszBuffer + pPipedProcessCtl->nStrLen) = '\0';

  0023c	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00241	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00244	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00249	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0024d	c6 04 08 00	 mov	 BYTE PTR [rax+rcx], 0
$LN15@w32_parse_:

; 4426 : 
; 4427 :             ASSERT( pPipedProcessCtl->nStrLen <= pPipedProcessCtl->nAllocSize );

  00251	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00256	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  0025b	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  0025f	48 39 48 10	 cmp	 QWORD PTR [rax+16], rcx
  00263	76 5b		 jbe	 SHORT $LN42@w32_parse_
$LN18@w32_parse_:
  00265	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161854
  0026c	41 b8 4b 11 00
	00		 mov	 r8d, 4427		; 0000114bH
  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161855
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161856
  00280	e8 00 00 00 00	 call	 logmsg
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0028b	85 c0		 test	 eax, eax
  0028d	74 20		 je	 SHORT $LN43@w32_parse_
  0028f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161858
  00296	41 b8 4b 11 00
	00		 mov	 r8d, 4427		; 0000114bH
  0029c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161859
  002a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161860
  002aa	e8 00 00 00 00	 call	 DebuggerTrace
$LN43@w32_parse_:
  002af	33 c0		 xor	 eax, eax
  002b1	85 c0		 test	 eax, eax
  002b3	75 b0		 jne	 SHORT $LN18@w32_parse_
  002b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002bb	85 c0		 test	 eax, eax
  002bd	74 01		 je	 SHORT $LN44@w32_parse_
  002bf	cc		 int	 3
$LN44@w32_parse_:
$LN42@w32_parse_:
  002c0	33 c0		 xor	 eax, eax
  002c2	85 c0		 test	 eax, eax
  002c4	75 8b		 jne	 SHORT $LN15@w32_parse_

; 4428 : 
; 4429 :             LeaveCriticalSection( &pPipedProcessCtl->csLock );

  002c6	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  002cb	48 83 c0 18	 add	 rax, 24
  002cf	48 8b c8	 mov	 rcx, rax
  002d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN36@w32_parse_:

; 4430 :         }
; 4431 : 
; 4432 :         // 'pend' should still point to the end of this message (where newline was)
; 4433 : 
; 4434 :         pbeg = (pend + 1);              // point to beg of next message (if any)

  002d8	48 8b 44 24 30	 mov	 rax, QWORD PTR pend$[rsp]
  002dd	48 ff c0	 inc	 rax
  002e0	48 89 44 24 28	 mov	 QWORD PTR pbeg$[rsp], rax

; 4435 : 
; 4436 :         if (pbeg >= (holdbuff + *pnHoldAmount))   // past end of data?

  002e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pnHoldAmount$[rsp]
  002ed	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  002f0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR holdbuff$[rsp]
  002f5	48 03 c8	 add	 rcx, rax
  002f8	48 8b c1	 mov	 rax, rcx
  002fb	48 39 44 24 28	 cmp	 QWORD PTR pbeg$[rsp], rax
  00300	72 79		 jb	 SHORT $LN45@w32_parse_

; 4437 :         {
; 4438 :             pbeg = pend;                // re-point back to our null

  00302	48 8b 44 24 30	 mov	 rax, QWORD PTR pend$[rsp]
  00307	48 89 44 24 28	 mov	 QWORD PTR pbeg$[rsp], rax
$LN21@w32_parse_:

; 4439 :             ASSERT(*pbeg == 0);         // sanity check

  0030c	48 8b 44 24 28	 mov	 rax, QWORD PTR pbeg$[rsp]
  00311	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00314	85 c0		 test	 eax, eax
  00316	74 5b		 je	 SHORT $LN46@w32_parse_
$LN24@w32_parse_:
  00318	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161864
  0031f	41 b8 57 11 00
	00		 mov	 r8d, 4439		; 00001157H
  00325	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161865
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161866
  00333	e8 00 00 00 00	 call	 logmsg
  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0033e	85 c0		 test	 eax, eax
  00340	74 20		 je	 SHORT $LN47@w32_parse_
  00342	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161868
  00349	41 b8 57 11 00
	00		 mov	 r8d, 4439		; 00001157H
  0034f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161869
  00356	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161870
  0035d	e8 00 00 00 00	 call	 DebuggerTrace
$LN47@w32_parse_:
  00362	33 c0		 xor	 eax, eax
  00364	85 c0		 test	 eax, eax
  00366	75 b0		 jne	 SHORT $LN24@w32_parse_
  00368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0036e	85 c0		 test	 eax, eax
  00370	74 01		 je	 SHORT $LN48@w32_parse_
  00372	cc		 int	 3
$LN48@w32_parse_:
$LN46@w32_parse_:
  00373	33 c0		 xor	 eax, eax
  00375	85 c0		 test	 eax, eax
  00377	75 93		 jne	 SHORT $LN21@w32_parse_

; 4440 :             break;                      // we're done with this batch

  00379	eb 20		 jmp	 SHORT $LN3@w32_parse_
$LN45@w32_parse_:

; 4441 :         }
; 4442 : 
; 4443 :         pend = strchr(pbeg,'\n');       // is there another message?

  0037b	ba 0a 00 00 00	 mov	 edx, 10
  00380	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pbeg$[rsp]
  00385	e8 00 00 00 00	 call	 strchr
  0038a	48 89 44 24 30	 mov	 QWORD PTR pend$[rsp], rax

; 4444 :     }
; 4445 :     while (pend);                       // while messages remain...

  0038f	48 83 7c 24 30
	00		 cmp	 QWORD PTR pend$[rsp], 0
  00395	0f 85 ad fc ff
	ff		 jne	 $LN4@w32_parse_
$LN3@w32_parse_:

; 4446 : 
; 4447 :     if (ntotlen > *pnHoldAmount)        // make sure we didn't process too much

  0039b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pnHoldAmount$[rsp]
  003a3	8b 00		 mov	 eax, DWORD PTR [rax]
  003a5	39 44 24 24	 cmp	 DWORD PTR ntotlen$[rsp], eax
  003a9	0f 8e 90 00 00
	00		 jle	 $LN49@w32_parse_
$LN27@w32_parse_:

; 4448 :     {
; 4449 :         TRACE("*** ParseStdxxxMsg logic error! ***\n");

  003af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161873
  003b6	e8 00 00 00 00	 call	 logmsg
  003bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003c1	85 c0		 test	 eax, eax
  003c3	74 0c		 je	 SHORT $LN50@w32_parse_
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161875
  003cc	e8 00 00 00 00	 call	 DebuggerTrace
$LN50@w32_parse_:
  003d1	33 c0		 xor	 eax, eax
  003d3	85 c0		 test	 eax, eax
  003d5	75 d8		 jne	 SHORT $LN27@w32_parse_
$LN30@w32_parse_:

; 4450 :         ASSERT(FALSE);                  // oops!

  003d7	33 c0		 xor	 eax, eax
  003d9	83 f8 01	 cmp	 eax, 1
  003dc	74 5b		 je	 SHORT $LN51@w32_parse_
$LN33@w32_parse_:
  003de	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161877
  003e5	41 b8 62 11 00
	00		 mov	 r8d, 4450		; 00001162H
  003eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161878
  003f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161879
  003f9	e8 00 00 00 00	 call	 logmsg
  003fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00404	85 c0		 test	 eax, eax
  00406	74 20		 je	 SHORT $LN52@w32_parse_
  00408	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161881
  0040f	41 b8 62 11 00
	00		 mov	 r8d, 4450		; 00001162H
  00415	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161882
  0041c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161883
  00423	e8 00 00 00 00	 call	 DebuggerTrace
$LN52@w32_parse_:
  00428	33 c0		 xor	 eax, eax
  0042a	85 c0		 test	 eax, eax
  0042c	75 b0		 jne	 SHORT $LN33@w32_parse_
  0042e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00434	85 c0		 test	 eax, eax
  00436	74 01		 je	 SHORT $LN53@w32_parse_
  00438	cc		 int	 3
$LN53@w32_parse_:
$LN51@w32_parse_:
  00439	33 c0		 xor	 eax, eax
  0043b	85 c0		 test	 eax, eax
  0043d	75 98		 jne	 SHORT $LN30@w32_parse_
$LN49@w32_parse_:

; 4451 :     }
; 4452 : 
; 4453 :     // 'Remove' the messages that we parsed from the caller's hold buffer by
; 4454 :     // sliding the remainder to the left (i.e. left justifying the remainder
; 4455 :     // in their hold buffer) and then telling them how much data now remains
; 4456 :     // in their hold buffer.
; 4457 : 
; 4458 :     // IMPORTANT PROGRAMMING NOTE! We must use memmove here and not strcpy!
; 4459 :     // strcpy doesn't work correctly for overlapping source and destination.
; 4460 :     // If there's 100 bytes remaining and we just want to slide it left by 1
; 4461 :     // byte (just as an illustrative example), strcpy screws up. This is more
; 4462 :     // than likely because strcpy is trying to be as efficient as possible and
; 4463 :     // is grabbing multiple bytes at a time from the source string and plonking
; 4464 :     // them down into the destination string, thus wiping out part of our source
; 4465 :     // string. Thus, we MUST use memmove here and NOT strcpy.
; 4466 : 
; 4467 :     if ((*pnHoldAmount = (int)strlen(pbeg)) > 0)   // new amount of data remaining

  0043f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pbeg$[rsp]
  00444	e8 00 00 00 00	 call	 strlen
  00449	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pnHoldAmount$[rsp]
  00451	89 01		 mov	 DWORD PTR [rcx], eax
  00453	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pnHoldAmount$[rsp]
  0045b	83 38 00	 cmp	 DWORD PTR [rax], 0
  0045e	7e 1d		 jle	 SHORT $LN54@w32_parse_

; 4468 :         memmove(holdbuff,pbeg,*pnHoldAmount);      // slide left justify remainder

  00460	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pnHoldAmount$[rsp]
  00468	48 63 00	 movsxd	 rax, DWORD PTR [rax]
  0046b	4c 8b c0	 mov	 r8, rax
  0046e	48 8b 54 24 28	 mov	 rdx, QWORD PTR pbeg$[rsp]
  00473	48 8b 4c 24 78	 mov	 rcx, QWORD PTR holdbuff$[rsp]
  00478	e8 00 00 00 00	 call	 memmove
$LN54@w32_parse_:
$LN1@w32_parse_:

; 4469 : }

  0047d	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00481	5f		 pop	 rdi
  00482	5e		 pop	 rsi
  00483	c3		 ret	 0
w32_parse_piped_process_stdxxx_data ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
nHoldAmount$ = 48
nAmountRead$ = 52
nRetcode$ = 56
oflow$ = 60
pPipedStdXXXThreadCtl$ = 64
hOurReadFromStdxxx$ = 72
pPipedProcessCtl$ = 80
readbuff$ = 96
holdbuff$ = 1120
__$ArrayPad$ = 3168
pThreadParm$ = 3216
w32_read_piped_process_stdxxx_output_thread PROC

; 4280 : {

$LN20:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 78 0c
	00 00		 sub	 rsp, 3192		; 00000c78H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 60
	0c 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4281 :     PIPED_THREAD_CTL*   pPipedStdXXXThreadCtl   = NULL;

  00020	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR pPipedStdXXXThreadCtl$[rsp], 0

; 4282 :     PIPED_PROCESS_CTL*  pPipedProcessCtl        = NULL;

  00029	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR pPipedProcessCtl$[rsp], 0

; 4283 : 
; 4284 :     HANDLE    hOurReadFromStdxxx  = NULL;

  00032	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR hOurReadFromStdxxx$[rsp], 0

; 4285 :     DWORD     nAmountRead         = 0;

  0003b	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR nAmountRead$[rsp], 0

; 4286 :     int       nHoldAmount         = 0;

  00043	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR nHoldAmount$[rsp], 0

; 4287 :     BOOL      oflow               = FALSE;

  0004b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR oflow$[rsp], 0

; 4288 :     unsigned  nRetcode            = 0;

  00053	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR nRetcode$[rsp], 0

; 4289 : 
; 4290 :     char   readbuff [ PIPEBUFSIZE ];
; 4291 :     char   holdbuff [ HOLDBUFSIZE ];
; 4292 : 
; 4293 :     // Extract parms
; 4294 : 
; 4295 :     pPipedStdXXXThreadCtl = (PIPED_THREAD_CTL*) pThreadParm;

  0005b	48 8b 84 24 90
	0c 00 00	 mov	 rax, QWORD PTR pThreadParm$[rsp]
  00063	48 89 44 24 40	 mov	 QWORD PTR pPipedStdXXXThreadCtl$[rsp], rax

; 4296 : 
; 4297 :     pPipedProcessCtl    = pPipedStdXXXThreadCtl->pPipedProcessCtl;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR pPipedStdXXXThreadCtl$[rsp]
  0006d	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00071	48 89 44 24 50	 mov	 QWORD PTR pPipedProcessCtl$[rsp], rax

; 4298 :     hOurReadFromStdxxx  = pPipedStdXXXThreadCtl->hStdXXX;

  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR pPipedStdXXXThreadCtl$[rsp]
  0007b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0007e	48 89 44 24 48	 mov	 QWORD PTR hOurReadFromStdxxx$[rsp], rax

; 4299 : 
; 4300 :     free( pPipedStdXXXThreadCtl );      // (prevent memory leak)

  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pPipedStdXXXThreadCtl$[rsp]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@w32_read_p:

; 4301 : 
; 4302 :     // Begin work...
; 4303 : 
; 4304 :     for (;;)
; 4305 :     {
; 4306 :         if (!ReadFile(hOurReadFromStdxxx, readbuff, PIPEBUFSIZE-1, &nAmountRead, NULL))

  0008e	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00097	4c 8d 4c 24 34	 lea	 r9, QWORD PTR nAmountRead$[rsp]
  0009c	41 b8 ff 03 00
	00		 mov	 r8d, 1023		; 000003ffH
  000a2	48 8d 54 24 60	 lea	 rdx, QWORD PTR readbuff$[rsp]
  000a7	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hOurReadFromStdxxx$[rsp]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  000b2	85 c0		 test	 eax, eax
  000b4	75 1e		 jne	 SHORT $LN11@w32_read_p

; 4307 :         {
; 4308 :             if (ERROR_BROKEN_PIPE == (nRetcode = GetLastError()))

  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000bc	89 44 24 38	 mov	 DWORD PTR nRetcode$[rsp], eax
  000c0	83 7c 24 38 6d	 cmp	 DWORD PTR nRetcode$[rsp], 109 ; 0000006dH
  000c5	75 08		 jne	 SHORT $LN12@w32_read_p

; 4309 :                 nRetcode = 0;

  000c7	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR nRetcode$[rsp], 0
$LN12@w32_read_p:

; 4310 :             // (else keep value returned from GetLastError())
; 4311 :             break;

  000cf	e9 58 01 00 00	 jmp	 $LN3@w32_read_p
$LN11@w32_read_p:

; 4312 :         }
; 4313 :         *(readbuff+nAmountRead) = 0;

  000d4	8b 44 24 34	 mov	 eax, DWORD PTR nAmountRead$[rsp]
  000d8	c6 44 04 60 00	 mov	 BYTE PTR readbuff$[rsp+rax], 0

; 4314 : 
; 4315 :         if (!nAmountRead) break;    // (pipe closed (i.e. broken pipe); time to exit)

  000dd	83 7c 24 34 00	 cmp	 DWORD PTR nAmountRead$[rsp], 0
  000e2	75 05		 jne	 SHORT $LN13@w32_read_p
  000e4	e9 43 01 00 00	 jmp	 $LN3@w32_read_p
$LN13@w32_read_p:

; 4316 : 
; 4317 :         if ((nHoldAmount + nAmountRead) >= (HOLDBUFSIZE-1))

  000e9	8b 44 24 34	 mov	 eax, DWORD PTR nAmountRead$[rsp]
  000ed	8b 4c 24 30	 mov	 ecx, DWORD PTR nHoldAmount$[rsp]
  000f1	03 c8		 add	 ecx, eax
  000f3	8b c1		 mov	 eax, ecx
  000f5	3d ff 07 00 00	 cmp	 eax, 2047		; 000007ffH
  000fa	72 60		 jb	 SHORT $LN14@w32_read_p

; 4318 :         {
; 4319 :             // OVERFLOW! append "truncated" string and force end-of-msg...
; 4320 : 
; 4321 :             oflow = TRUE;

  000fc	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR oflow$[rsp], 1

; 4322 :             memcpy( holdbuff + nHoldAmount, readbuff, HOLDBUFSIZE - nHoldAmount);

  00104	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  00109	2b 44 24 30	 sub	 eax, DWORD PTR nHoldAmount$[rsp]
  0010d	48 98		 cdqe
  0010f	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR nHoldAmount$[rsp]
  00114	48 8d 8c 0c 60
	04 00 00	 lea	 rcx, QWORD PTR holdbuff$[rsp+rcx]
  0011c	48 8d 54 24 60	 lea	 rdx, QWORD PTR readbuff$[rsp]
  00121	48 8b f9	 mov	 rdi, rcx
  00124	48 8b f2	 mov	 rsi, rdx
  00127	48 8b c8	 mov	 rcx, rax
  0012a	f3 a4		 rep movsb

; 4323 :             STRLCPY(                        readbuff, buffer_overflow_msg );

  0012c	41 b8 00 04 00
	00		 mov	 r8d, 1024		; 00000400H
  00132	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR buffer_overflow_msg
  00139	48 8d 4c 24 60	 lea	 rcx, QWORD PTR readbuff$[rsp]
  0013e	e8 00 00 00 00	 call	 strlcpy

; 4324 :             nAmountRead =                   (DWORD)buffer_overflow_msg_len;

  00143	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR buffer_overflow_msg_len
  00149	89 44 24 34	 mov	 DWORD PTR nAmountRead$[rsp], eax

; 4325 :             nHoldAmount =  HOLDBUFSIZE  -   nAmountRead - 1;

  0014d	b8 00 08 00 00	 mov	 eax, 2048		; 00000800H
  00152	2b 44 24 34	 sub	 eax, DWORD PTR nAmountRead$[rsp]
  00156	ff c8		 dec	 eax
  00158	89 44 24 30	 mov	 DWORD PTR nHoldAmount$[rsp], eax
$LN14@w32_read_p:

; 4326 :         }
; 4327 : 
; 4328 :         // Append new data to end of hold buffer...
; 4329 : 
; 4330 :         memcpy(holdbuff+nHoldAmount,readbuff,nAmountRead);

  0015c	8b 44 24 34	 mov	 eax, DWORD PTR nAmountRead$[rsp]
  00160	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR nHoldAmount$[rsp]
  00165	48 8d 8c 0c 60
	04 00 00	 lea	 rcx, QWORD PTR holdbuff$[rsp+rcx]
  0016d	48 8d 54 24 60	 lea	 rdx, QWORD PTR readbuff$[rsp]
  00172	48 8b f9	 mov	 rdi, rcx
  00175	48 8b f2	 mov	 rsi, rdx
  00178	8b c8		 mov	 ecx, eax
  0017a	f3 a4		 rep movsb

; 4331 :         nHoldAmount += nAmountRead;

  0017c	8b 44 24 34	 mov	 eax, DWORD PTR nAmountRead$[rsp]
  00180	8b 4c 24 30	 mov	 ecx, DWORD PTR nHoldAmount$[rsp]
  00184	03 c8		 add	 ecx, eax
  00186	8b c1		 mov	 eax, ecx
  00188	89 44 24 30	 mov	 DWORD PTR nHoldAmount$[rsp], eax

; 4332 :         *(holdbuff+nHoldAmount) = 0;

  0018c	48 63 44 24 30	 movsxd	 rax, DWORD PTR nHoldAmount$[rsp]
  00191	c6 84 04 60 04
	00 00 00	 mov	 BYTE PTR holdbuff$[rsp+rax], 0

; 4333 : 
; 4334 :         // Pass all existing data to parsing function...
; 4335 : 
; 4336 :         w32_parse_piped_process_stdxxx_data( pPipedProcessCtl, holdbuff, &nHoldAmount );

  00199	4c 8d 44 24 30	 lea	 r8, QWORD PTR nHoldAmount$[rsp]
  0019e	48 8d 94 24 60
	04 00 00	 lea	 rdx, QWORD PTR holdbuff$[rsp]
  001a6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  001ab	e8 00 00 00 00	 call	 w32_parse_piped_process_stdxxx_data

; 4337 : 
; 4338 :         if (oflow) ASSERT(!nHoldAmount); oflow = FALSE;

  001b0	83 7c 24 3c 00	 cmp	 DWORD PTR oflow$[rsp], 0
  001b5	74 68		 je	 SHORT $LN15@w32_read_p
$LN7@w32_read_p:
  001b7	83 7c 24 30 00	 cmp	 DWORD PTR nHoldAmount$[rsp], 0
  001bc	74 5b		 je	 SHORT $LN16@w32_read_p
$LN10@w32_read_p:
  001be	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161783
  001c5	41 b8 f2 10 00
	00		 mov	 r8d, 4338		; 000010f2H
  001cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161784
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161785
  001d9	e8 00 00 00 00	 call	 logmsg
  001de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001e4	85 c0		 test	 eax, eax
  001e6	74 20		 je	 SHORT $LN17@w32_read_p
  001e8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161787
  001ef	41 b8 f2 10 00
	00		 mov	 r8d, 4338		; 000010f2H
  001f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161788
  001fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161789
  00203	e8 00 00 00 00	 call	 DebuggerTrace
$LN17@w32_read_p:
  00208	33 c0		 xor	 eax, eax
  0020a	85 c0		 test	 eax, eax
  0020c	75 b0		 jne	 SHORT $LN10@w32_read_p
  0020e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00214	85 c0		 test	 eax, eax
  00216	74 01		 je	 SHORT $LN18@w32_read_p
  00218	cc		 int	 3
$LN18@w32_read_p:
$LN16@w32_read_p:
  00219	33 c0		 xor	 eax, eax
  0021b	85 c0		 test	 eax, eax
  0021d	75 98		 jne	 SHORT $LN7@w32_read_p
$LN15@w32_read_p:
  0021f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR oflow$[rsp], 0

; 4339 :     }

  00227	e9 62 fe ff ff	 jmp	 $LN2@w32_read_p
$LN3@w32_read_p:

; 4340 : 
; 4341 :     // Finish up...
; 4342 : 
; 4343 :     CloseHandle( hOurReadFromStdxxx );      // (prevent HANDLE leak)

  0022c	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hOurReadFromStdxxx$[rsp]
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4344 : 
; 4345 :     return nRetcode;

  00237	8b 44 24 38	 mov	 eax, DWORD PTR nRetcode$[rsp]

; 4346 : }

  0023b	48 8b 8c 24 60
	0c 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00243	48 33 cc	 xor	 rcx, rsp
  00246	e8 00 00 00 00	 call	 __security_check_cookie
  0024b	48 81 c4 78 0c
	00 00		 add	 rsp, 3192		; 00000c78H
  00252	5f		 pop	 rdi
  00253	5e		 pop	 rsi
  00254	c3		 ret	 0
w32_read_piped_process_stdxxx_output_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
i$ = 32
pSet$ = 64
pbSocketFound$ = 72
pbNonSocketFound$ = 80
pdwHandles$ = 88
parHandles$ = 96
SelectSet PROC

; 3410 : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3411 :     unsigned int i;
; 3412 : 
; 3413 :     if ( !pSet ) return;

  00018	48 83 7c 24 40
	00		 cmp	 QWORD PTR pSet$[rsp], 0
  0001e	75 05		 jne	 SHORT $LN11@SelectSet
  00020	e9 0a 01 00 00	 jmp	 $LN1@SelectSet
$LN11@SelectSet:

; 3414 : 
; 3415 :     for (i=0; i < pSet->fd_count && i < FD_SETSIZE; i++)

  00025	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  0002d	eb 0a		 jmp	 SHORT $LN4@SelectSet
$LN2@SelectSet:
  0002f	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00033	ff c0		 inc	 eax
  00035	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@SelectSet:
  00039	48 8b 44 24 40	 mov	 rax, QWORD PTR pSet$[rsp]
  0003e	8b 00		 mov	 eax, DWORD PTR [rax]
  00040	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  00044	0f 83 e5 00 00
	00		 jae	 $LN3@SelectSet
  0004a	81 7c 24 20 00
	04 00 00	 cmp	 DWORD PTR i$[rsp], 1024	; 00000400H
  00052	0f 83 d7 00 00
	00		 jae	 $LN3@SelectSet

; 3416 :     {
; 3417 :         if ( socket_is_socket( pSet->fd_array[i] ) )

  00058	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0005c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR pSet$[rsp]
  00061	8b 4c c1 08	 mov	 ecx, DWORD PTR [rcx+rax*8+8]
  00065	e8 00 00 00 00	 call	 socket_is_socket
  0006a	85 c0		 test	 eax, eax
  0006c	74 0d		 je	 SHORT $LN12@SelectSet

; 3418 :         {
; 3419 :             *pbSocketFound = TRUE;

  0006e	48 8b 44 24 48	 mov	 rax, QWORD PTR pbSocketFound$[rsp]
  00073	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 3420 :             continue;

  00079	eb b4		 jmp	 SHORT $LN2@SelectSet
$LN12@SelectSet:

; 3421 :         }
; 3422 : 
; 3423 :         *pbNonSocketFound = TRUE;

  0007b	48 8b 44 24 50	 mov	 rax, QWORD PTR pbNonSocketFound$[rsp]
  00080	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 3424 : 
; 3425 :         // If parHandles is NULL, then we're
; 3426 :         // only interested in the BOOLean flags...
; 3427 : 
; 3428 :         if ( !parHandles ) continue;

  00086	48 83 7c 24 60
	00		 cmp	 QWORD PTR parHandles$[rsp], 0
  0008c	75 02		 jne	 SHORT $LN13@SelectSet
  0008e	eb 9f		 jmp	 SHORT $LN2@SelectSet
$LN13@SelectSet:
$LN7@SelectSet:

; 3429 :         ASSERT( *pdwHandles < ( 2 * FD_SETSIZE ) );

  00090	48 8b 44 24 58	 mov	 rax, QWORD PTR pdwHandles$[rsp]
  00095	81 38 00 08 00
	00		 cmp	 DWORD PTR [rax], 2048	; 00000800H
  0009b	72 5b		 jb	 SHORT $LN14@SelectSet
$LN10@SelectSet:
  0009d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160940
  000a4	41 b8 65 0d 00
	00		 mov	 r8d, 3429		; 00000d65H
  000aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160941
  000b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160942
  000b8	e8 00 00 00 00	 call	 logmsg
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c3	85 c0		 test	 eax, eax
  000c5	74 20		 je	 SHORT $LN15@SelectSet
  000c7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160944
  000ce	41 b8 65 0d 00
	00		 mov	 r8d, 3429		; 00000d65H
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160945
  000db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160946
  000e2	e8 00 00 00 00	 call	 DebuggerTrace
$LN15@SelectSet:
  000e7	33 c0		 xor	 eax, eax
  000e9	85 c0		 test	 eax, eax
  000eb	75 b0		 jne	 SHORT $LN10@SelectSet
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000f3	85 c0		 test	 eax, eax
  000f5	74 01		 je	 SHORT $LN16@SelectSet
  000f7	cc		 int	 3
$LN16@SelectSet:
$LN14@SelectSet:
  000f8	33 c0		 xor	 eax, eax
  000fa	85 c0		 test	 eax, eax
  000fc	75 92		 jne	 SHORT $LN7@SelectSet

; 3430 :         *( parHandles + *pdwHandles ) = (HANDLE) pSet->fd_array[i];

  000fe	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00102	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pdwHandles$[rsp]
  00107	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00109	48 8b 54 24 60	 mov	 rdx, QWORD PTR parHandles$[rsp]
  0010e	4c 8b 44 24 40	 mov	 r8, QWORD PTR pSet$[rsp]
  00113	49 8b 44 c0 08	 mov	 rax, QWORD PTR [r8+rax*8+8]
  00118	48 89 04 ca	 mov	 QWORD PTR [rdx+rcx*8], rax

; 3431 :         *pdwHandles++;

  0011c	48 8b 44 24 58	 mov	 rax, QWORD PTR pdwHandles$[rsp]
  00121	48 83 c0 04	 add	 rax, 4
  00125	48 89 44 24 58	 mov	 QWORD PTR pdwHandles$[rsp], rax

; 3432 :     }

  0012a	e9 00 ff ff ff	 jmp	 $LN2@SelectSet
$LN3@SelectSet:
$LN1@SelectSet:

; 3433 : }

  0012f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00133	c3		 ret	 0
SelectSet ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv136 = 80
lasterror$1 = 84
pKASOCK$ = 88
dwBytesReturned$ = 96
tv81 = 104
p$2 = 112
ka$ = 120
__$ArrayPad$ = 136
sfd$ = 160
idle_time$ = 168
probe_interval$ = 176
probe_count$ = 184
quiet$ = 192
internal_set_socket_keepalive PROC

; 2885 : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2886 : #if !defined( HAVE_BASIC_KEEPALIVE )
; 2887 : 
; 2888 :     // Not basic support == No TCP keepalive support at all
; 2889 : 
; 2890 :     if (!quiet)
; 2891 :     {
; 2892 :         WSASetLastError( EOPNOTSUPP );
; 2893 :         // "Error in function %s: %s"
; 2894 :         WRMSG( HHC02219, "E", "internal_set_socket_keepalive()", strerror( HSO_errno ));
; 2895 :     }
; 2896 :     WSASetLastError( EOPNOTSUPP );
; 2897 :     return -1;
; 2898 : 
; 2899 : #elif !defined( HAVE_PARTIAL_KEEPALIVE )
; 2900 : 
; 2901 :     // Not partial support == only Basic TCP keepalive support
; 2902 : 
; 2903 :     BOOL  bOptVal  = TRUE;
; 2904 :     int   nOptLen  = sizeof( bOptVal );
; 2905 : 
; 2906 :     if (setsockopt( (SOCKET) sfd, SOL_SOCKET, SO_KEEPALIVE, (char*) &bOptVal, nOptLen ) == SOCKET_ERROR)
; 2907 :     {
; 2908 :         if (!quiet)
; 2909 :         {
; 2910 :             int lasterror = WSAGetLastError();
; 2911 :             // "Error in function %s: %s"
; 2912 :             WRMSG( HHC02219, "E", "internal_set_socket_keepalive()", strerror( HSO_errno ));
; 2913 :             WSASetLastError( lasterror );
; 2914 :         }
; 2915 :         return -1;
; 2916 :     }
; 2917 : 
; 2918 :     return idle_time      != def_ka_time ? +1 :
; 2919 :            probe_interval != def_ka_intv ? +1 :
; 2920 :            probe_count    != def_ka_cnt  ? +1 : 0;
; 2921 : 
; 2922 : #else
; 2923 : 
; 2924 :     // Partial or Full TCP keepalive support
; 2925 : 
; 2926 :     KASOCK* pKASOCK;
; 2927 :     DWORD   dwBytesReturned;
; 2928 :     struct tcp_keepalive ka;
; 2929 : 
; 2930 :     ka.onoff              = TRUE;

  0002b	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR ka$[rsp], 1

; 2931 :     ka.keepalivetime      = idle_time       * 1000;  // (seconds to milliseconds)

  00033	69 84 24 a8 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR idle_time$[rsp], 1000 ; 000003e8H
  0003e	89 44 24 7c	 mov	 DWORD PTR ka$[rsp+4], eax

; 2932 :     ka.keepaliveinterval  = probe_interval  * 1000;  // (seconds to milliseconds)

  00042	69 84 24 b0 00
	00 00 e8 03 00
	00		 imul	 eax, DWORD PTR probe_interval$[rsp], 1000 ; 000003e8H
  0004d	89 84 24 80 00
	00 00		 mov	 DWORD PTR ka$[rsp+8], eax

; 2933 : 
; 2934 :     // It either works or it doesn't <shrug>
; 2935 : 
; 2936 :     // PROGRAMMING NOTE: the 'dwBytesReturned' value must apparently always be
; 2937 :     // specified in order for this call to work at all. If you don't specify it,
; 2938 :     // even though the call succeeds (does not return an error), the automatic
; 2939 :     // keepalive polling does not occur.
; 2940 : 
; 2941 :     // Also note that QUERYING the current SIO_KEEPALIVE_VALS is unsupported.
; 2942 :     // See programming note further below in 'get_socket_keepalive' function.
; 2943 : 
; 2944 :     if (0 != WSAIoctl

  00054	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  0005c	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  00065	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0006e	48 8d 4c 24 60	 lea	 rcx, QWORD PTR dwBytesReturned$[rsp]
  00073	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00078	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00080	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00089	41 b9 0c 00 00
	00		 mov	 r9d, 12
  0008f	4c 8d 44 24 78	 lea	 r8, QWORD PTR ka$[rsp]
  00094	ba 04 00 00 98	 mov	 edx, -1744830460	; 98000004H
  00099	48 8b c8	 mov	 rcx, rax
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAIoctl
  000a2	85 c0		 test	 eax, eax
  000a4	0f 84 99 00 00
	00		 je	 $LN5@internal_s

; 2945 :     (
; 2946 :         (SOCKET) sfd,                   // [in]  Descriptor identifying a socket
; 2947 :         SIO_KEEPALIVE_VALS,             // [in]  Control code of operation to perform
; 2948 :         &ka,                            // [in]  Pointer to the input buffer
; 2949 :         sizeof( ka ),                   // [in]  Size of the input buffer, in bytes
; 2950 :         NULL,                           // [in]  Pointer to the output buffer
; 2951 :         0,                              // [in]  Size of the output buffer, in bytes
; 2952 :         &dwBytesReturned,               // [out] Pointer to actual number of bytes of output
; 2953 :         NULL,                           // [in]  Pointer to a WSAOVERLAPPED structure
; 2954 :                                         //       (ignored for nonoverlapped sockets)
; 2955 :         NULL                            // [in]  Pointer to the completion routine called
; 2956 :                                         //       when the operation has been completed
; 2957 :                                         //       (ignored for nonoverlapped sockets)
; 2958 :     ))
; 2959 :     {
; 2960 :         if (!quiet)

  000aa	0f b6 84 24 c0
	00 00 00	 movzx	 eax, BYTE PTR quiet$[rsp]
  000b2	85 c0		 test	 eax, eax
  000b4	0f 85 82 00 00
	00		 jne	 $LN6@internal_s

; 2961 :         {
; 2962 :             int lasterror = WSAGetLastError();

  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000c0	89 44 24 54	 mov	 DWORD PTR lasterror$1[rsp], eax

; 2963 :             // "Error in function %s: %s"
; 2964 :             WRMSG( HHC02219, "E", "WSAIoctl( SIO_KEEPALIVE_VALS )", strerror( HSO_errno ));

  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000ca	8b c8		 mov	 ecx, eax
  000cc	e8 00 00 00 00	 call	 w32_strerror
  000d1	48 89 44 24 68	 mov	 QWORD PTR tv81[rsp], rax
  000d6	b9 01 00 00 00	 mov	 ecx, 1
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000e1	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv81[rsp]
  000e6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160665
  000f2	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160666
  000fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00103	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160667
  0010a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0010f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00114	41 b9 03 00 00
	00		 mov	 r9d, 3
  0011a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160668
  00121	ba 94 0b 00 00	 mov	 edx, 2964		; 00000b94H
  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160669
  0012d	e8 00 00 00 00	 call	 fwritemsg

; 2965 :             WSASetLastError( lasterror );

  00132	8b 4c 24 54	 mov	 ecx, DWORD PTR lasterror$1[rsp]
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASetLastError
$LN6@internal_s:

; 2966 :         }
; 2967 :         return -1;  // (failure)

  0013c	b8 ff ff ff ff	 mov	 eax, -1
  00141	eb 77		 jmp	 SHORT $LN1@internal_s
$LN5@internal_s:

; 2968 :     }
; 2969 : 
; 2970 :     // Save new values so 'get_socket_keepalive' can retrieve them if desired
; 2971 : 
; 2972 :     if (!(pKASOCK = get_kasock( sfd )))

  00143	48 63 84 24 a0
	00 00 00	 movsxd	 rax, DWORD PTR sfd$[rsp]
  0014b	48 8b c8	 mov	 rcx, rax
  0014e	e8 00 00 00 00	 call	 get_kasock
  00153	48 89 44 24 58	 mov	 QWORD PTR pKASOCK$[rsp], rax
  00158	48 83 7c 24 58
	00		 cmp	 QWORD PTR pKASOCK$[rsp], 0
  0015e	75 17		 jne	 SHORT $LN7@internal_s
$LN4@internal_s:

; 2973 :         CRASH(); // (should NEVER occur!)

  00160	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR p$2[rsp], 0
  00169	48 8b 44 24 70	 mov	 rax, QWORD PTR p$2[rsp]
  0016e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00171	33 c0		 xor	 eax, eax
  00173	85 c0		 test	 eax, eax
  00175	75 e9		 jne	 SHORT $LN4@internal_s
$LN7@internal_s:

; 2974 : 
; 2975 :     pKASOCK->time = idle_time;

  00177	48 8b 44 24 58	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0017c	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR idle_time$[rsp]
  00183	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 2976 :     pKASOCK->intv = probe_interval;

  00186	48 8b 44 24 58	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0018b	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR probe_interval$[rsp]
  00192	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 2977 : 
; 2978 :     // Probe count cannot be changed on Windows
; 2979 : 
; 2980 :     return (probe_count != def_ka_cnt) ? +1 : 0;  // (partial or complete success)

  00195	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR def_ka_cnt
  0019b	39 84 24 b8 00
	00 00		 cmp	 DWORD PTR probe_count$[rsp], eax
  001a2	74 0a		 je	 SHORT $LN9@internal_s
  001a4	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
  001ac	eb 08		 jmp	 SHORT $LN10@internal_s
$LN9@internal_s:
  001ae	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN10@internal_s:
  001b6	8b 44 24 50	 mov	 eax, DWORD PTR tv136[rsp]
$LN1@internal_s:

; 2981 : 
; 2982 : #endif // (KEEPALIVE)
; 2983 : }

  001ba	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001c2	48 33 cc	 xor	 rcx, rsp
  001c5	e8 00 00 00 00	 call	 __security_check_cookie
  001ca	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  001d1	c3		 ret	 0
internal_set_socket_keepalive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv73 = 32
pKASOCK$ = 40
_EX_Flink$1 = 48
_EX_Blink$2 = 56
sock$ = 80
rem_kasock PROC

; 2732 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2733 :     KASOCK* pKASOCK;
; 2734 :     lock_kasock_list();

  00009	e8 00 00 00 00	 call	 lock_kasock_list

; 2735 :     if ((pKASOCK = get_kasock( sock )) != NULL)

  0000e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR sock$[rsp]
  00013	e8 00 00 00 00	 call	 get_kasock
  00018	48 89 44 24 28	 mov	 QWORD PTR pKASOCK$[rsp], rax
  0001d	48 83 7c 24 28
	00		 cmp	 QWORD PTR pKASOCK$[rsp], 0
  00023	74 42		 je	 SHORT $LN2@rem_kasock

; 2736 :     {
; 2737 :         RemoveListEntry( &pKASOCK->link );

  00025	48 8b 44 24 28	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0002a	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0002e	48 89 44 24 30	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  00033	48 8b 44 24 28	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  00038	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0003c	48 89 44 24 38	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  00041	48 8b 44 24 38	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  00046	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  0004b	48 89 08	 mov	 QWORD PTR [rax], rcx
  0004e	48 8b 44 24 30	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  00053	48 8b 4c 24 38	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  00058	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2738 :         free( pKASOCK );

  0005c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pKASOCK$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@rem_kasock:

; 2739 :     }
; 2740 :     unlock_kasock_list();

  00067	e8 00 00 00 00	 call	 unlock_kasock_list

; 2741 :     return pKASOCK ? TRUE : FALSE;

  0006c	48 83 7c 24 28
	00		 cmp	 QWORD PTR pKASOCK$[rsp], 0
  00072	74 0a		 je	 SHORT $LN4@rem_kasock
  00074	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv73[rsp], 1
  0007c	eb 08		 jmp	 SHORT $LN5@rem_kasock
$LN4@rem_kasock:
  0007e	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN5@rem_kasock:
  00086	8b 44 24 20	 mov	 eax, DWORD PTR tv73[rsp]

; 2742 : }

  0008a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0008e	c3		 ret	 0
rem_kasock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
pKASOCK$ = 32
_EX_Head$1 = 40
_EX_Next$2 = 48
sock$ = 80
add_kasock PROC

; 2714 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2715 :     KASOCK* pKASOCK;
; 2716 :     if (!(pKASOCK = (KASOCK*) malloc( sizeof( KASOCK )))) return FALSE;

  00009	b9 28 00 00 00	 mov	 ecx, 40			; 00000028H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00014	48 89 44 24 20	 mov	 QWORD PTR pKASOCK$[rsp], rax
  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR pKASOCK$[rsp], 0
  0001f	75 07		 jne	 SHORT $LN2@add_kasock
  00021	33 c0		 xor	 eax, eax
  00023	e9 b8 00 00 00	 jmp	 $LN1@add_kasock
$LN2@add_kasock:

; 2717 :     pKASOCK->sock = sock;

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR sock$[rsp]
  00032	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2718 :     pKASOCK->time = def_ka_time;

  00035	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0003a	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR def_ka_time
  00040	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 2719 :     pKASOCK->intv = def_ka_intv;

  00043	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  00048	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR def_ka_intv
  0004e	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 2720 :     pKASOCK->cnt  = def_ka_cnt;

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  00056	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR def_ka_cnt
  0005c	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 2721 :     InitializeListLink( &pKASOCK->link );

  0005f	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  00064	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
  0006c	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  00071	48 c7 40 18 00
	00 00 00	 mov	 QWORD PTR [rax+24], 0

; 2722 :     lock_kasock_list();

  00079	e8 00 00 00 00	 call	 lock_kasock_list

; 2723 :     InsertListHead( &kasock_head, &pKASOCK->link );

  0007e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:kasock_head
  00085	48 89 44 24 28	 mov	 QWORD PTR _EX_Head$1[rsp], rax
  0008a	48 8b 44 24 28	 mov	 rax, QWORD PTR _EX_Head$1[rsp]
  0008f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00092	48 89 44 24 30	 mov	 QWORD PTR _EX_Next$2[rsp], rax
  00097	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0009c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  000a1	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx
  000a5	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  000aa	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  000af	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx
  000b3	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  000b8	48 83 c0 18	 add	 rax, 24
  000bc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR _EX_Head$1[rsp]
  000c1	48 89 01	 mov	 QWORD PTR [rcx], rax
  000c4	48 8b 44 24 20	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  000c9	48 83 c0 18	 add	 rax, 24
  000cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _EX_Next$2[rsp]
  000d2	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 2724 :     unlock_kasock_list();

  000d6	e8 00 00 00 00	 call	 unlock_kasock_list

; 2725 :     return TRUE;

  000db	b8 01 00 00 00	 mov	 eax, 1
$LN1@add_kasock:

; 2726 : }

  000e0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000e4	c3		 ret	 0
add_kasock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
pListEntry$ = 32
pKASOCK$ = 40
sock$ = 64
get_kasock PROC

; 2686 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2687 :     KASOCK*      pKASOCK;
; 2688 :     LIST_ENTRY*  pListEntry;
; 2689 : 
; 2690 :     lock_kasock_list();

  00009	e8 00 00 00 00	 call	 lock_kasock_list

; 2691 :     pListEntry = kasock_head.Flink;         // (start with first entry)

  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR kasock_head
  00015	48 89 44 24 20	 mov	 QWORD PTR pListEntry$[rsp], rax
$LN2@get_kasock:

; 2692 : 
; 2693 :     while (pListEntry != &kasock_head)      // (while not at beginning)

  0001a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:kasock_head
  00021	48 39 44 24 20	 cmp	 QWORD PTR pListEntry$[rsp], rax
  00026	74 38		 je	 SHORT $LN3@get_kasock

; 2694 :     {
; 2695 :         pKASOCK = CONTAINING_RECORD( pListEntry, KASOCK, link );

  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR pListEntry$[rsp]
  0002d	48 83 e8 18	 sub	 rax, 24
  00031	48 89 44 24 28	 mov	 QWORD PTR pKASOCK$[rsp], rax

; 2696 : 
; 2697 :         if (pKASOCK->sock == sock)          // (is this the one?)

  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0003b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sock$[rsp]
  00040	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00043	75 0c		 jne	 SHORT $LN4@get_kasock

; 2698 :         {
; 2699 :             unlock_kasock_list();

  00045	e8 00 00 00 00	 call	 unlock_kasock_list

; 2700 :             return pKASOCK;                 // (yes, return it)

  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR pKASOCK$[rsp]
  0004f	eb 16		 jmp	 SHORT $LN1@get_kasock
$LN4@get_kasock:

; 2701 :         }
; 2702 : 
; 2703 :         pListEntry = pListEntry->Flink;     // (next entry)

  00051	48 8b 44 24 20	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00056	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00059	48 89 44 24 20	 mov	 QWORD PTR pListEntry$[rsp], rax

; 2704 :     }

  0005e	eb ba		 jmp	 SHORT $LN2@get_kasock
$LN3@get_kasock:

; 2705 : 
; 2706 :     unlock_kasock_list();

  00060	e8 00 00 00 00	 call	 unlock_kasock_list

; 2707 :     return NULL;                            // (not found)

  00065	33 c0		 xor	 eax, eax
$LN1@get_kasock:

; 2708 : }

  00067	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006b	c3		 ret	 0
get_kasock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
unlock_kasock_list PROC

; 2531 : static void unlock_kasock_list()  { LeaveCriticalSection( &kasock_lock ); }

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kasock_lock
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
unlock_kasock_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
lock_kasock_list PROC

; 2530 : static void lock_kasock_list()    { EnterCriticalSection( &kasock_lock ); }

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kasock_lock
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
lock_kasock_list ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
lResult$1 = 48
dwCnt1$2 = 52
dwCnt2$3 = 56
dwSize$4 = 60
bPreVista$5 = 64
dwTime$6 = 68
dwIntv$7 = 72
hKey$8 = 80
tv89 = 88
tv161 = 92
tv174 = 96
p$9 = 104
p$10 = 112
p$11 = 120
p$12 = 128
p$13 = 136
vi$14 = 144
__$ArrayPad$ = 304
kasock_init PROC

; 2541 : {

  00000	40 57		 push	 rdi
  00002	48 81 ec 40 01
	00 00		 sub	 rsp, 320		; 00000140H
  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00010	48 33 c4	 xor	 rax, rsp
  00013	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2542 :     static BOOL bDidThis = FALSE;   // (we only need to do this once)
; 2543 :     if (bDidThis) return;           // (we only need to do this once)

  0001b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bDidThis@?1??kasock_init@@9@9, 0
  00022	74 05		 je	 SHORT $LN23@kasock_ini
  00024	e9 b0 03 00 00	 jmp	 $LN1@kasock_ini
$LN23@kasock_ini:

; 2544 :     bDidThis = TRUE;                // (we only need to do this once)

  00029	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bDidThis@?1??kasock_init@@9@9, 1

; 2545 : 
; 2546 :     InitializeCriticalSectionAndSpinCount( &kasock_lock, 4000 );

  00033	ba a0 0f 00 00	 mov	 edx, 4000		; 00000fa0H
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:kasock_lock
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSectionAndSpinCount

; 2547 :     InitializeListHead( &kasock_head );

  00045	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:kasock_head
  0004c	48 89 05 08 00
	00 00		 mov	 QWORD PTR kasock_head+8, rax
  00053	48 8b 05 08 00
	00 00		 mov	 rax, QWORD PTR kasock_head+8
  0005a	48 89 05 00 00
	00 00		 mov	 QWORD PTR kasock_head, rax

; 2548 : 
; 2549 :     // http://msdn.microsoft.com/en-us/library/windows/desktop/dd877220(v=vs.85).aspx
; 2550 : 
; 2551 :     // The default settings when a TCP socket is initialized sets the
; 2552 :     // keepalive timeout to 2 hours and the keepalive interval to 1 second.
; 2553 : 
; 2554 : #define DEF_KA_TIME             ((2*60*60)*1000)    // 2 hours
; 2555 : #define DEF_KA_INTV             (1*1000)            // 1 second
; 2556 : 
; 2557 :     // The default system-wide value of the keepalive timeout
; 2558 :     // is controllable through the KeepAliveTime registry setting
; 2559 :     // which takes a value in milliseconds.
; 2560 : 
; 2561 : #define KA_REGROOT    HKEY_LOCAL_MACHINE
; 2562 : #define KA_REGKEY     "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters"
; 2563 : #define REG_KA_TIME   "KeepAliveTime"
; 2564 : 
; 2565 :     // The default system-wide value of the keepalive interval
; 2566 :     // is controllable through the KeepAliveInterval registry setting
; 2567 :     // which takes a value in milliseconds.
; 2568 : 
; 2569 : #define REG_KA_INTV   "KeepAliveInterval"
; 2570 : 
; 2571 :     // On Windows Vista and later, the number of keepalive probes
; 2572 :     // (data retransmissions) is set to 10 and cannot be changed.
; 2573 : 
; 2574 : #define DEF_KA_CNT              10                  // 10 probes
; 2575 : 
; 2576 :     // On Windows Server 2003, Windows XP, and Windows 2000, the default
; 2577 :     // setting for number of keepalive probes is 5.
; 2578 : 
; 2579 : #define PREVISTA_DEF_KA_CNT     5                   // 5 probes
; 2580 : 
; 2581 :     // The number of keepalive probes is controllable through the
; 2582 :     // TcpMaxDataRetransmissions and PPTPTcpMaxDataRetransmissions
; 2583 :     // registry settings.
; 2584 : 
; 2585 : #define REG_KA_CNT1   "TcpMaxDataRetransmissions"
; 2586 : #define REG_KA_CNT2   "PPTPTcpMaxDataRetransmissions"
; 2587 : 
; 2588 :     // The number of keepalive probes is set to the larger of the two
; 2589 :     // registry key values. If this number is 0, then keepalive probes
; 2590 :     // are not sent. If this number is above 255, it is adjusted to 255.
; 2591 : 
; 2592 : #define MAX_KA_CNT              255                 // maximum probes
; 2593 : 
; 2594 :     {
; 2595 :         OSVERSIONINFO  vi  = { sizeof( vi ), 0 };

  00061	c7 84 24 90 00
	00 00 94 00 00
	00		 mov	 DWORD PTR vi$14[rsp], 148 ; 00000094H
  0006c	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR vi$14[rsp+4], 0
  00077	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR vi$14[rsp+8]
  0007f	48 8b f8	 mov	 rdi, rax
  00082	33 c0		 xor	 eax, eax
  00084	b9 8c 00 00 00	 mov	 ecx, 140		; 0000008cH
  00089	f3 aa		 rep stosb

; 2596 :         BOOL    bPreVista  = FALSE;

  0008b	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR bPreVista$5[rsp], 0

; 2597 :         DWORD   dwSize     = sizeof( DWORD );

  00093	c7 44 24 3c 04
	00 00 00	 mov	 DWORD PTR dwSize$4[rsp], 4

; 2598 :         LONG    lResult    = 0;

  0009b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR lResult$1[rsp], 0

; 2599 :         HKEY    hKey       = NULL;

  000a3	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR hKey$8[rsp], 0

; 2600 :         DWORD   dwTime     = 0;

  000ac	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR dwTime$6[rsp], 0

; 2601 :         DWORD   dwIntv     = 0;

  000b4	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR dwIntv$7[rsp], 0

; 2602 :         DWORD   dwCnt1     = 0;

  000bc	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR dwCnt1$2[rsp], 0

; 2603 :         DWORD   dwCnt2     = 0;

  000c4	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR dwCnt2$3[rsp], 0
$LN4@kasock_ini:

; 2604 : 
; 2605 :         VERIFY( GetVersionEx( &vi ));

  000cc	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR vi$14[rsp]
  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetVersionExA
  000da	85 c0		 test	 eax, eax
  000dc	75 5b		 jne	 SHORT $LN24@kasock_ini
$LN7@kasock_ini:
  000de	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160497
  000e5	41 b8 2d 0a 00
	00		 mov	 r8d, 2605		; 00000a2dH
  000eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160498
  000f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160499
  000f9	e8 00 00 00 00	 call	 logmsg
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00104	85 c0		 test	 eax, eax
  00106	74 20		 je	 SHORT $LN25@kasock_ini
  00108	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160501
  0010f	41 b8 2d 0a 00
	00		 mov	 r8d, 2605		; 00000a2dH
  00115	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160502
  0011c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160503
  00123	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@kasock_ini:
  00128	33 c0		 xor	 eax, eax
  0012a	85 c0		 test	 eax, eax
  0012c	75 b0		 jne	 SHORT $LN7@kasock_ini
  0012e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00134	85 c0		 test	 eax, eax
  00136	74 01		 je	 SHORT $LN26@kasock_ini
  00138	cc		 int	 3
$LN26@kasock_ini:
$LN24@kasock_ini:
  00139	33 c0		 xor	 eax, eax
  0013b	85 c0		 test	 eax, eax
  0013d	75 8d		 jne	 SHORT $LN4@kasock_ini

; 2606 :         bPreVista = (vi.dwMajorVersion < 6);

  0013f	83 bc 24 94 00
	00 00 06	 cmp	 DWORD PTR vi$14[rsp+4], 6
  00147	73 0a		 jae	 SHORT $LN40@kasock_ini
  00149	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv89[rsp], 1
  00151	eb 08		 jmp	 SHORT $LN41@kasock_ini
$LN40@kasock_ini:
  00153	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN41@kasock_ini:
  0015b	8b 44 24 58	 mov	 eax, DWORD PTR tv89[rsp]
  0015f	89 44 24 40	 mov	 DWORD PTR bPreVista$5[rsp], eax

; 2607 : 
; 2608 :         lResult = RegOpenKeyEx( KA_REGROOT, KA_REGKEY, 0, KEY_QUERY_VALUE, &hKey );

  00163	48 8d 44 24 50	 lea	 rax, QWORD PTR hKey$8[rsp]
  00168	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0016d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00173	45 33 c0	 xor	 r8d, r8d
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160505
  0017d	48 c7 c1 02 00
	00 80		 mov	 rcx, -2147483646	; ffffffff80000002H
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegOpenKeyExA
  0018a	89 44 24 30	 mov	 DWORD PTR lResult$1[rsp], eax

; 2609 : 
; 2610 :         if (ERROR_SUCCESS != lResult)

  0018e	83 7c 24 30 00	 cmp	 DWORD PTR lResult$1[rsp], 0
  00193	74 17		 je	 SHORT $LN27@kasock_ini
$LN10@kasock_ini:

; 2611 :             CRASH();

  00195	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR p$9[rsp], 0
  0019e	48 8b 44 24 68	 mov	 rax, QWORD PTR p$9[rsp]
  001a3	c6 00 00	 mov	 BYTE PTR [rax], 0
  001a6	33 c0		 xor	 eax, eax
  001a8	85 c0		 test	 eax, eax
  001aa	75 e9		 jne	 SHORT $LN10@kasock_ini
$LN27@kasock_ini:

; 2612 : 
; 2613 :         // keepalive timeout
; 2614 : 
; 2615 :         lResult = RegQueryValueEx( hKey, REG_KA_TIME, NULL, NULL, (BYTE*) &dwTime, &dwSize );

  001ac	48 8d 44 24 3c	 lea	 rax, QWORD PTR dwSize$4[rsp]
  001b1	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001b6	48 8d 44 24 44	 lea	 rax, QWORD PTR dwTime$6[rsp]
  001bb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001c0	45 33 c9	 xor	 r9d, r9d
  001c3	45 33 c0	 xor	 r8d, r8d
  001c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160507
  001cd	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hKey$8[rsp]
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  001d8	89 44 24 30	 mov	 DWORD PTR lResult$1[rsp], eax

; 2616 : 
; 2617 :         if (ERROR_SUCCESS != lResult)

  001dc	83 7c 24 30 00	 cmp	 DWORD PTR lResult$1[rsp], 0
  001e1	74 26		 je	 SHORT $LN28@kasock_ini

; 2618 :         {
; 2619 :             if (ERROR_FILE_NOT_FOUND != lResult)

  001e3	83 7c 24 30 02	 cmp	 DWORD PTR lResult$1[rsp], 2
  001e8	74 17		 je	 SHORT $LN29@kasock_ini
$LN13@kasock_ini:

; 2620 :                 CRASH();

  001ea	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR p$10[rsp], 0
  001f3	48 8b 44 24 70	 mov	 rax, QWORD PTR p$10[rsp]
  001f8	c6 00 00	 mov	 BYTE PTR [rax], 0
  001fb	33 c0		 xor	 eax, eax
  001fd	85 c0		 test	 eax, eax
  001ff	75 e9		 jne	 SHORT $LN13@kasock_ini
$LN29@kasock_ini:

; 2621 :             dwTime = DEF_KA_TIME;

  00201	c7 44 24 44 00
	dd 6d 00	 mov	 DWORD PTR dwTime$6[rsp], 7200000 ; 006ddd00H
$LN28@kasock_ini:

; 2622 :         }
; 2623 : 
; 2624 :         // keepalive interval
; 2625 : 
; 2626 :         lResult = RegQueryValueEx( hKey, REG_KA_INTV, NULL, NULL, (BYTE*) &dwIntv, &dwSize );

  00209	48 8d 44 24 3c	 lea	 rax, QWORD PTR dwSize$4[rsp]
  0020e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00213	48 8d 44 24 48	 lea	 rax, QWORD PTR dwIntv$7[rsp]
  00218	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021d	45 33 c9	 xor	 r9d, r9d
  00220	45 33 c0	 xor	 r8d, r8d
  00223	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160510
  0022a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hKey$8[rsp]
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  00235	89 44 24 30	 mov	 DWORD PTR lResult$1[rsp], eax

; 2627 : 
; 2628 :         if (ERROR_SUCCESS != lResult)

  00239	83 7c 24 30 00	 cmp	 DWORD PTR lResult$1[rsp], 0
  0023e	74 26		 je	 SHORT $LN30@kasock_ini

; 2629 :         {
; 2630 :             if (ERROR_FILE_NOT_FOUND != lResult)

  00240	83 7c 24 30 02	 cmp	 DWORD PTR lResult$1[rsp], 2
  00245	74 17		 je	 SHORT $LN31@kasock_ini
$LN16@kasock_ini:

; 2631 :                 CRASH();

  00247	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR p$11[rsp], 0
  00250	48 8b 44 24 78	 mov	 rax, QWORD PTR p$11[rsp]
  00255	c6 00 00	 mov	 BYTE PTR [rax], 0
  00258	33 c0		 xor	 eax, eax
  0025a	85 c0		 test	 eax, eax
  0025c	75 e9		 jne	 SHORT $LN16@kasock_ini
$LN31@kasock_ini:

; 2632 :             dwIntv = DEF_KA_INTV;

  0025e	c7 44 24 48 e8
	03 00 00	 mov	 DWORD PTR dwIntv$7[rsp], 1000 ; 000003e8H
$LN30@kasock_ini:

; 2633 :         }
; 2634 : 
; 2635 :         // TcpMaxDataRetransmissions
; 2636 : 
; 2637 :         lResult = RegQueryValueEx( hKey, REG_KA_CNT1, NULL, NULL, (BYTE*) &dwCnt1, &dwSize );

  00266	48 8d 44 24 3c	 lea	 rax, QWORD PTR dwSize$4[rsp]
  0026b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00270	48 8d 44 24 34	 lea	 rax, QWORD PTR dwCnt1$2[rsp]
  00275	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0027a	45 33 c9	 xor	 r9d, r9d
  0027d	45 33 c0	 xor	 r8d, r8d
  00280	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160513
  00287	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hKey$8[rsp]
  0028c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  00292	89 44 24 30	 mov	 DWORD PTR lResult$1[rsp], eax

; 2638 : 
; 2639 :         if (ERROR_SUCCESS != lResult)

  00296	83 7c 24 30 00	 cmp	 DWORD PTR lResult$1[rsp], 0
  0029b	74 45		 je	 SHORT $LN32@kasock_ini

; 2640 :         {
; 2641 :             if (ERROR_FILE_NOT_FOUND != lResult)

  0029d	83 7c 24 30 02	 cmp	 DWORD PTR lResult$1[rsp], 2
  002a2	74 1d		 je	 SHORT $LN33@kasock_ini
$LN19@kasock_ini:

; 2642 :                 CRASH();

  002a4	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$12[rsp], 0
  002b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$12[rsp]
  002b8	c6 00 00	 mov	 BYTE PTR [rax], 0
  002bb	33 c0		 xor	 eax, eax
  002bd	85 c0		 test	 eax, eax
  002bf	75 e3		 jne	 SHORT $LN19@kasock_ini
$LN33@kasock_ini:

; 2643 :             dwCnt1 = bPreVista ? PREVISTA_DEF_KA_CNT : DEF_KA_CNT;

  002c1	83 7c 24 40 00	 cmp	 DWORD PTR bPreVista$5[rsp], 0
  002c6	74 0a		 je	 SHORT $LN42@kasock_ini
  002c8	c7 44 24 5c 05
	00 00 00	 mov	 DWORD PTR tv161[rsp], 5
  002d0	eb 08		 jmp	 SHORT $LN43@kasock_ini
$LN42@kasock_ini:
  002d2	c7 44 24 5c 0a
	00 00 00	 mov	 DWORD PTR tv161[rsp], 10
$LN43@kasock_ini:
  002da	8b 44 24 5c	 mov	 eax, DWORD PTR tv161[rsp]
  002de	89 44 24 34	 mov	 DWORD PTR dwCnt1$2[rsp], eax
$LN32@kasock_ini:

; 2644 :         }
; 2645 : 
; 2646 :         // (round down to maximum allowed)
; 2647 : 
; 2648 :         if (dwCnt1 > MAX_KA_CNT)

  002e2	81 7c 24 34 ff
	00 00 00	 cmp	 DWORD PTR dwCnt1$2[rsp], 255 ; 000000ffH
  002ea	76 08		 jbe	 SHORT $LN34@kasock_ini

; 2649 :             dwCnt1 = MAX_KA_CNT;

  002ec	c7 44 24 34 ff
	00 00 00	 mov	 DWORD PTR dwCnt1$2[rsp], 255 ; 000000ffH
$LN34@kasock_ini:

; 2650 : 
; 2651 :         // PPTPTcpMaxDataRetransmissions
; 2652 : 
; 2653 :         lResult = RegQueryValueEx( hKey, REG_KA_CNT2, NULL, NULL, (BYTE*) &dwCnt2, &dwSize );

  002f4	48 8d 44 24 3c	 lea	 rax, QWORD PTR dwSize$4[rsp]
  002f9	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002fe	48 8d 44 24 38	 lea	 rax, QWORD PTR dwCnt2$3[rsp]
  00303	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00308	45 33 c9	 xor	 r9d, r9d
  0030b	45 33 c0	 xor	 r8d, r8d
  0030e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160517
  00315	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hKey$8[rsp]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegQueryValueExA
  00320	89 44 24 30	 mov	 DWORD PTR lResult$1[rsp], eax

; 2654 : 
; 2655 :         if (ERROR_SUCCESS != lResult)

  00324	83 7c 24 30 00	 cmp	 DWORD PTR lResult$1[rsp], 0
  00329	74 45		 je	 SHORT $LN35@kasock_ini

; 2656 :         {
; 2657 :             if (ERROR_FILE_NOT_FOUND != lResult)

  0032b	83 7c 24 30 02	 cmp	 DWORD PTR lResult$1[rsp], 2
  00330	74 1d		 je	 SHORT $LN36@kasock_ini
$LN22@kasock_ini:

; 2658 :                 CRASH();

  00332	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR p$13[rsp], 0
  0033e	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR p$13[rsp]
  00346	c6 00 00	 mov	 BYTE PTR [rax], 0
  00349	33 c0		 xor	 eax, eax
  0034b	85 c0		 test	 eax, eax
  0034d	75 e3		 jne	 SHORT $LN22@kasock_ini
$LN36@kasock_ini:

; 2659 :             dwCnt2 = bPreVista ? PREVISTA_DEF_KA_CNT : DEF_KA_CNT;

  0034f	83 7c 24 40 00	 cmp	 DWORD PTR bPreVista$5[rsp], 0
  00354	74 0a		 je	 SHORT $LN44@kasock_ini
  00356	c7 44 24 60 05
	00 00 00	 mov	 DWORD PTR tv174[rsp], 5
  0035e	eb 08		 jmp	 SHORT $LN45@kasock_ini
$LN44@kasock_ini:
  00360	c7 44 24 60 0a
	00 00 00	 mov	 DWORD PTR tv174[rsp], 10
$LN45@kasock_ini:
  00368	8b 44 24 60	 mov	 eax, DWORD PTR tv174[rsp]
  0036c	89 44 24 38	 mov	 DWORD PTR dwCnt2$3[rsp], eax
$LN35@kasock_ini:

; 2660 :         }
; 2661 : 
; 2662 :         // (round down to maximum allowed)
; 2663 : 
; 2664 :         if (dwCnt2 > MAX_KA_CNT)

  00370	81 7c 24 38 ff
	00 00 00	 cmp	 DWORD PTR dwCnt2$3[rsp], 255 ; 000000ffH
  00378	76 08		 jbe	 SHORT $LN37@kasock_ini

; 2665 :             dwCnt2 = MAX_KA_CNT;

  0037a	c7 44 24 38 ff
	00 00 00	 mov	 DWORD PTR dwCnt2$3[rsp], 255 ; 000000ffH
$LN37@kasock_ini:

; 2666 : 
; 2667 :         RegCloseKey( hKey );

  00382	48 8b 4c 24 50	 mov	 rcx, QWORD PTR hKey$8[rsp]
  00387	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RegCloseKey

; 2668 : 
; 2669 :         // Choose the greater of the two probe count values
; 2670 : 
; 2671 :         if (dwCnt1 < dwCnt2)

  0038d	8b 44 24 38	 mov	 eax, DWORD PTR dwCnt2$3[rsp]
  00391	39 44 24 34	 cmp	 DWORD PTR dwCnt1$2[rsp], eax
  00395	73 08		 jae	 SHORT $LN38@kasock_ini

; 2672 :             dwCnt1 = dwCnt2;

  00397	8b 44 24 38	 mov	 eax, DWORD PTR dwCnt2$3[rsp]
  0039b	89 44 24 34	 mov	 DWORD PTR dwCnt1$2[rsp], eax
$LN38@kasock_ini:

; 2673 : 
; 2674 :         // Save default values in number of whole seconds
; 2675 : 
; 2676 :         def_ka_time  =  (int) ((dwTime + 500) / 1000);

  0039f	8b 44 24 44	 mov	 eax, DWORD PTR dwTime$6[rsp]
  003a3	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  003a8	33 d2		 xor	 edx, edx
  003aa	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  003af	f7 f1		 div	 ecx
  003b1	89 05 00 00 00
	00		 mov	 DWORD PTR def_ka_time, eax

; 2677 :         def_ka_intv  =  (int) ((dwIntv + 500) / 1000);

  003b7	8b 44 24 48	 mov	 eax, DWORD PTR dwIntv$7[rsp]
  003bb	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  003c0	33 d2		 xor	 edx, edx
  003c2	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  003c7	f7 f1		 div	 ecx
  003c9	89 05 00 00 00
	00		 mov	 DWORD PTR def_ka_intv, eax

; 2678 :         def_ka_cnt   =  (int) (dwCnt1);

  003cf	8b 44 24 34	 mov	 eax, DWORD PTR dwCnt1$2[rsp]
  003d3	89 05 00 00 00
	00		 mov	 DWORD PTR def_ka_cnt, eax
$LN1@kasock_ini:

; 2679 :     }
; 2680 : }

  003d9	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003e1	48 33 cc	 xor	 rcx, rsp
  003e4	e8 00 00 00 00	 call	 __security_check_cookie
  003e9	48 81 c4 40 01
	00 00		 add	 rsp, 320		; 00000140H
  003f0	5f		 pop	 rdi
  003f1	c3		 ret	 0
kasock_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
dwLastError$1 = 80
hOrigStdIn$2 = 88
hOurProcess$3 = 96
tv153 = 104
szErrMsg$4 = 112
__$ArrayPad$ = 368
CreateReadStdInThread PROC

; 2252 : {

  00000	48 81 ec 88 01
	00 00		 sub	 rsp, 392		; 00000188H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2253 :     if (!dwThreadId)  // (only do this once)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR dwThreadId, 0
  00020	0f 85 99 03 00
	00		 jne	 $LN32@CreateRead

; 2254 :     {
; 2255 :         HANDLE hOrigStdIn, hOurProcess;
; 2256 : 
; 2257 :         hStdInAvailable = CreateEvent( NULL, TRUE, FALSE, NULL );

  00026	45 33 c9	 xor	 r9d, r9d
  00029	45 33 c0	 xor	 r8d, r8d
  0002c	ba 01 00 00 00	 mov	 edx, 1
  00031	33 c9		 xor	 ecx, ecx
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  00039	48 89 05 00 00
	00 00		 mov	 QWORD PTR hStdInAvailable, rax

; 2258 :         hGotStdIn       = CreateEvent( NULL, TRUE, TRUE,  NULL );

  00040	45 33 c9	 xor	 r9d, r9d
  00043	41 b8 01 00 00
	00		 mov	 r8d, 1
  00049	ba 01 00 00 00	 mov	 edx, 1
  0004e	33 c9		 xor	 ecx, ecx
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateEventA
  00056	48 89 05 00 00
	00 00		 mov	 QWORD PTR hGotStdIn, rax
$LN4@CreateRead:

; 2259 : 
; 2260 :         ASSERT( hStdInAvailable && INVALID_HANDLE_VALUE != hStdInAvailable );

  0005d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hStdInAvailable, 0
  00065	74 0a		 je	 SHORT $LN34@CreateRead
  00067	48 83 3d 00 00
	00 00 ff	 cmp	 QWORD PTR hStdInAvailable, -1
  0006f	75 5b		 jne	 SHORT $LN33@CreateRead
$LN34@CreateRead:
$LN7@CreateRead:
  00071	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160335
  00078	41 b8 d4 08 00
	00		 mov	 r8d, 2260		; 000008d4H
  0007e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160336
  00085	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160337
  0008c	e8 00 00 00 00	 call	 logmsg
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00097	85 c0		 test	 eax, eax
  00099	74 20		 je	 SHORT $LN35@CreateRead
  0009b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160339
  000a2	41 b8 d4 08 00
	00		 mov	 r8d, 2260		; 000008d4H
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160340
  000af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160341
  000b6	e8 00 00 00 00	 call	 DebuggerTrace
$LN35@CreateRead:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 b0		 jne	 SHORT $LN7@CreateRead
  000c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000c7	85 c0		 test	 eax, eax
  000c9	74 01		 je	 SHORT $LN36@CreateRead
  000cb	cc		 int	 3
$LN36@CreateRead:
$LN33@CreateRead:
  000cc	33 c0		 xor	 eax, eax
  000ce	85 c0		 test	 eax, eax
  000d0	75 8b		 jne	 SHORT $LN4@CreateRead
$LN10@CreateRead:

; 2261 :         ASSERT( hGotStdIn       && INVALID_HANDLE_VALUE != hGotStdIn       );

  000d2	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hGotStdIn, 0
  000da	74 0a		 je	 SHORT $LN38@CreateRead
  000dc	48 83 3d 00 00
	00 00 ff	 cmp	 QWORD PTR hGotStdIn, -1
  000e4	75 5b		 jne	 SHORT $LN37@CreateRead
$LN38@CreateRead:
$LN13@CreateRead:
  000e6	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160345
  000ed	41 b8 d5 08 00
	00		 mov	 r8d, 2261		; 000008d5H
  000f3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160346
  000fa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160347
  00101	e8 00 00 00 00	 call	 logmsg
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0010c	85 c0		 test	 eax, eax
  0010e	74 20		 je	 SHORT $LN39@CreateRead
  00110	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160349
  00117	41 b8 d5 08 00
	00		 mov	 r8d, 2261		; 000008d5H
  0011d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160350
  00124	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160351
  0012b	e8 00 00 00 00	 call	 DebuggerTrace
$LN39@CreateRead:
  00130	33 c0		 xor	 eax, eax
  00132	85 c0		 test	 eax, eax
  00134	75 b0		 jne	 SHORT $LN13@CreateRead
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0013c	85 c0		 test	 eax, eax
  0013e	74 01		 je	 SHORT $LN40@CreateRead
  00140	cc		 int	 3
$LN40@CreateRead:
$LN37@CreateRead:
  00141	33 c0		 xor	 eax, eax
  00143	85 c0		 test	 eax, eax
  00145	75 8b		 jne	 SHORT $LN10@CreateRead

; 2262 : 
; 2263 :         // PROGRAMMING NOTE: during testing of Rexx is was discovered
; 2264 :         // that OORexx would get stuck in its PeekNamedPipe() API call
; 2265 :         // whenever Hercules was run under the control of an External
; 2266 :         // GUI (e.g. HercGUI) thereby preventing the Rexx script from
; 2267 :         // ever finishing/exiting (i.e. returning back to Hercules).
; 2268 :         //
; 2269 :         // Invoking a Rexx script which permanently hangs (i.e. never
; 2270 :         // completes) is clearly a disastrous situation, but is made
; 2271 :         // even more disastrous should the thread invoking the Rexx
; 2272 :         // script happen to be one of the CPU threads invoking said
; 2273 :         // Rexx script via the Hercules DIAGNOSE X'008' interface.
; 2274 :         // The DIAG8 instruction would hang causing a Machine Check.
; 2275 :         //
; 2276 :         // After much research is was determined the cause was due to
; 2277 :         // the above read from stdin thread was stuck waiting for its
; 2278 :         // ReadFile of stdin to be satisfied, thereby causing OORexx's
; 2279 :         // PeekNamedPipe call to hang. (Apparently the way Microsoft
; 2280 :         // designed their anonymous pipe handling you can't have two
; 2281 :         // threads within the same process both trying to access the
; 2282 :         // same Windows HANDLE at the same time, which makes sense).
; 2283 :         // The unsatisfied (blocked) ReadFile on the stdin HANDLE was
; 2284 :         // causing OORexx's PeekNamedPipe() call to hang.
; 2285 :         //
; 2286 :         // Many different workarounds were attempted but the simplest
; 2287 :         // and most straightforward of them all was determined to be
; 2288 :         // the technique used below: to simply create a duplicate of
; 2289 :         // the original stdin HANDLE and use it instead to read from
; 2290 :         // our end of the anonymous pipe (closing the original stdin
; 2291 :         // HANDLE afterwards of course). Doing this prevents OORexx's
; 2292 :         // PeekNamedPipe() call on the original handle from hanging
; 2293 :         // since now only one thread was accessing the handle (Rexx)
; 2294 :         // since we closed our copy and were now using a completely
; 2295 :         // different HANDLE to read from that Rexx wasn't also using.
; 2296 : 
; 2297 :         hOurProcess = GetCurrentProcess();

  00147	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  0014d	48 89 44 24 60	 mov	 QWORD PTR hOurProcess$3[rsp], rax

; 2298 :         hOrigStdIn  = GetStdHandle( STD_INPUT_HANDLE );

  00152	b9 f6 ff ff ff	 mov	 ecx, -10		; fffffff6H
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  0015d	48 89 44 24 58	 mov	 QWORD PTR hOrigStdIn$2[rsp], rax

; 2299 : 
; 2300 :         if (DuplicateHandle

  00162	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  0016a	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00172	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0017a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:hDupedStdIn
  00181	4c 8b 44 24 60	 mov	 r8, QWORD PTR hOurProcess$3[rsp]
  00186	48 8b 54 24 58	 mov	 rdx, QWORD PTR hOrigStdIn$2[rsp]
  0018b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR hOurProcess$3[rsp]
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DuplicateHandle
  00196	85 c0		 test	 eax, eax
  00198	74 10		 je	 SHORT $LN41@CreateRead

; 2301 :         (
; 2302 :             hOurProcess,            // Process with handle to be duplicated
; 2303 :             hOrigStdIn,             // Original handle to be duplicated
; 2304 :             hOurProcess,            // Process to receive duplicated handle
; 2305 :             &hDupedStdIn,           // The resulting duplicated handle
; 2306 :             0,                      // (ignored for DUPLICATE_SAME_ACCESS)
; 2307 :             FALSE,                  // Never inherit resulting duplicate
; 2308 :             DUPLICATE_SAME_ACCESS   // Give duplicate same access rights
; 2309 :         ))
; 2310 :         {
; 2311 :             CloseHandle( hOrigStdIn );  // (see above PROGRAMMING NOTE)

  0019a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR hOrigStdIn$2[rsp]
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 2312 :         }

  001a5	e9 8f 00 00 00	 jmp	 $LN42@CreateRead
$LN41@CreateRead:

; 2313 :         else
; 2314 :         {
; 2315 :             DWORD  dwLastError;
; 2316 :             char   szErrMsg[ 256 ];
; 2317 : 
; 2318 :             // "DuplicateHandle() failed: dwLastError=%d (0x%8.8X): %s"
; 2319 :             dwLastError = GetLastError();

  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001b0	89 44 24 50	 mov	 DWORD PTR dwLastError$1[rsp], eax

; 2320 :             WRMSG( HHC04110, "W", dwLastError, dwLastError,

  001b4	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  001ba	48 8d 54 24 70	 lea	 rdx, QWORD PTR szErrMsg$4[rsp]
  001bf	8b 4c 24 50	 mov	 ecx, DWORD PTR dwLastError$1[rsp]
  001c3	e8 00 00 00 00	 call	 w32_w32errmsg
  001c8	48 89 44 24 68	 mov	 QWORD PTR tv153[rsp], rax
  001cd	b9 01 00 00 00	 mov	 ecx, 1
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001d8	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv153[rsp]
  001dd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001e2	8b 4c 24 50	 mov	 ecx, DWORD PTR dwLastError$1[rsp]
  001e6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ea	8b 4c 24 50	 mov	 ecx, DWORD PTR dwLastError$1[rsp]
  001ee	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160355
  001f9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160356
  00205	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00215	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160357
  0021c	ba 11 09 00 00	 mov	 edx, 2321		; 00000911H
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160358
  00228	e8 00 00 00 00	 call	 fwritemsg

; 2321 :                 w32_w32errmsg( dwLastError, szErrMsg, sizeof( szErrMsg )));
; 2322 : 
; 2323 :             hDupedStdIn = hOrigStdIn;   // (we have no other choice!)

  0022d	48 8b 44 24 58	 mov	 rax, QWORD PTR hOrigStdIn$2[rsp]
  00232	48 89 05 00 00
	00 00		 mov	 QWORD PTR hDupedStdIn, rax
$LN42@CreateRead:
$LN16@CreateRead:

; 2324 :         }
; 2325 : 
; 2326 :         ASSERT( hDupedStdIn && INVALID_HANDLE_VALUE != hDupedStdIn );

  00239	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hDupedStdIn, 0
  00241	74 0a		 je	 SHORT $LN44@CreateRead
  00243	48 83 3d 00 00
	00 00 ff	 cmp	 QWORD PTR hDupedStdIn, -1
  0024b	75 5b		 jne	 SHORT $LN43@CreateRead
$LN44@CreateRead:
$LN19@CreateRead:
  0024d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160361
  00254	41 b8 16 09 00
	00		 mov	 r8d, 2326		; 00000916H
  0025a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160362
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160363
  00268	e8 00 00 00 00	 call	 logmsg
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00273	85 c0		 test	 eax, eax
  00275	74 20		 je	 SHORT $LN45@CreateRead
  00277	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160365
  0027e	41 b8 16 09 00
	00		 mov	 r8d, 2326		; 00000916H
  00284	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160366
  0028b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160367
  00292	e8 00 00 00 00	 call	 DebuggerTrace
$LN45@CreateRead:
  00297	33 c0		 xor	 eax, eax
  00299	85 c0		 test	 eax, eax
  0029b	75 b0		 jne	 SHORT $LN19@CreateRead
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002a3	85 c0		 test	 eax, eax
  002a5	74 01		 je	 SHORT $LN46@CreateRead
  002a7	cc		 int	 3
$LN46@CreateRead:
$LN43@CreateRead:
  002a8	33 c0		 xor	 eax, eax
  002aa	85 c0		 test	 eax, eax
  002ac	75 8b		 jne	 SHORT $LN16@CreateRead

; 2327 : 
; 2328 :         hThread = (HANDLE) _beginthreadex

  002ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:dwThreadId
  002b5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  002ba	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  002c2	45 33 c9	 xor	 r9d, r9d
  002c5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:ReadStdInThread
  002cc	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  002d1	33 c9		 xor	 ecx, ecx
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__beginthreadex
  002d9	48 89 05 00 00
	00 00		 mov	 QWORD PTR hThread, rax
$LN22@CreateRead:

; 2329 :         (
; 2330 :             NULL,                   // Pointer to security attributes
; 2331 :             64*1024,                // Initial thread stack size in bytes
; 2332 :             ReadStdInThread,        // Pointer to thread function
; 2333 :             NULL,                   // Argument for new thread
; 2334 :             0,                      // Creation flags
; 2335 :             &dwThreadId             // Pointer to receive thread ID
; 2336 :         );
; 2337 : 
; 2338 :         ASSERT( hThread && INVALID_HANDLE_VALUE != hThread );

  002e0	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR hThread, 0
  002e8	74 0a		 je	 SHORT $LN48@CreateRead
  002ea	48 83 3d 00 00
	00 00 ff	 cmp	 QWORD PTR hThread, -1
  002f2	75 5b		 jne	 SHORT $LN47@CreateRead
$LN48@CreateRead:
$LN25@CreateRead:
  002f4	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160371
  002fb	41 b8 22 09 00
	00		 mov	 r8d, 2338		; 00000922H
  00301	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160372
  00308	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160373
  0030f	e8 00 00 00 00	 call	 logmsg
  00314	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0031a	85 c0		 test	 eax, eax
  0031c	74 20		 je	 SHORT $LN49@CreateRead
  0031e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160375
  00325	41 b8 22 09 00
	00		 mov	 r8d, 2338		; 00000922H
  0032b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160376
  00332	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160377
  00339	e8 00 00 00 00	 call	 DebuggerTrace
$LN49@CreateRead:
  0033e	33 c0		 xor	 eax, eax
  00340	85 c0		 test	 eax, eax
  00342	75 b0		 jne	 SHORT $LN25@CreateRead
  00344	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0034a	85 c0		 test	 eax, eax
  0034c	74 01		 je	 SHORT $LN50@CreateRead
  0034e	cc		 int	 3
$LN50@CreateRead:
$LN47@CreateRead:
  0034f	33 c0		 xor	 eax, eax
  00351	85 c0		 test	 eax, eax
  00353	75 8b		 jne	 SHORT $LN22@CreateRead
$LN28@CreateRead:

; 2339 :         ASSERT( dwThreadId != 0 );

  00355	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR dwThreadId, 0
  0035c	75 5b		 jne	 SHORT $LN51@CreateRead
$LN31@CreateRead:
  0035e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160380
  00365	41 b8 23 09 00
	00		 mov	 r8d, 2339		; 00000923H
  0036b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160381
  00372	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160382
  00379	e8 00 00 00 00	 call	 logmsg
  0037e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00384	85 c0		 test	 eax, eax
  00386	74 20		 je	 SHORT $LN52@CreateRead
  00388	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160384
  0038f	41 b8 23 09 00
	00		 mov	 r8d, 2339		; 00000923H
  00395	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160385
  0039c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160386
  003a3	e8 00 00 00 00	 call	 DebuggerTrace
$LN52@CreateRead:
  003a8	33 c0		 xor	 eax, eax
  003aa	85 c0		 test	 eax, eax
  003ac	75 b0		 jne	 SHORT $LN31@CreateRead
  003ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003b4	85 c0		 test	 eax, eax
  003b6	74 01		 je	 SHORT $LN53@CreateRead
  003b8	cc		 int	 3
$LN53@CreateRead:
$LN51@CreateRead:
  003b9	33 c0		 xor	 eax, eax
  003bb	85 c0		 test	 eax, eax
  003bd	75 96		 jne	 SHORT $LN28@CreateRead
$LN32@CreateRead:

; 2340 :     }
; 2341 : }

  003bf	48 8b 8c 24 70
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003c7	48 33 cc	 xor	 rcx, rsp
  003ca	e8 00 00 00 00	 call	 __security_check_cookie
  003cf	48 81 c4 88 01
	00 00		 add	 rsp, 392		; 00000188H
  003d6	c3		 ret	 0
CreateReadStdInThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
dwLastError$1 = 64
dwBytesRead$ = 68
szErrMsg$2 = 80
buf$3 = 336
__$ArrayPad$ = 848
lpParameter$ = 880
ReadStdInThread PROC

; 2206 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 68 03
	00 00		 sub	 rsp, 872		; 00000368H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 50
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2207 :     DWORD   dwBytesRead  = 0;

  0001e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR dwBytesRead$[rsp], 0
$LN4@ReadStdInT:

; 2208 : 
; 2209 :     UNREFERENCED( lpParameter );

  00026	33 c0		 xor	 eax, eax
  00028	85 c0		 test	 eax, eax
  0002a	75 fa		 jne	 SHORT $LN4@ReadStdInT
$LN7@ReadStdInT:

; 2210 : 
; 2211 :     SET_THREAD_NAME ("ReadStdInThread");

  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160261
  00039	8b c8		 mov	 ecx, eax
  0003b	e8 00 00 00 00	 call	 w32_set_thread_name
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160262
  0004d	8b c8		 mov	 ecx, eax
  0004f	e8 00 00 00 00	 call	 hthread_set_thread_name
  00054	33 c0		 xor	 eax, eax
  00056	85 c0		 test	 eax, eax
  00058	75 d2		 jne	 SHORT $LN7@ReadStdInT
$LN8@ReadStdInT:

; 2212 : 
; 2213 :     for (;;)
; 2214 :     {
; 2215 :         WaitForSingleObject( hGotStdIn, INFINITE );

  0005a	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hGotStdIn
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 2216 : 
; 2217 :         if (!ReadFile( hDupedStdIn, &chStdIn, 1, &dwBytesRead, NULL ))

  0006c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00075	4c 8d 4c 24 44	 lea	 r9, QWORD PTR dwBytesRead$[rsp]
  0007a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:chStdIn
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hDupedStdIn
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  00094	85 c0		 test	 eax, eax
  00096	0f 85 c9 00 00
	00		 jne	 $LN17@ReadStdInT

; 2218 :         {
; 2219 :             char  buf[512];
; 2220 :             char  szErrMsg[256];
; 2221 :             DWORD dwLastError = GetLastError();

  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  000a2	89 44 24 40	 mov	 DWORD PTR dwLastError$1[rsp], eax

; 2222 : 
; 2223 :             if ( ERROR_BROKEN_PIPE == dwLastError || sysblk.shutdown )

  000a6	83 7c 24 40 6d	 cmp	 DWORD PTR dwLastError$1[rsp], 109 ; 0000006dH
  000ab	74 17		 je	 SHORT $LN19@ReadStdInT
  000ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b4	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000ba	c1 e8 0b	 shr	 eax, 11
  000bd	83 e0 01	 and	 eax, 1
  000c0	85 c0		 test	 eax, eax
  000c2	74 05		 je	 SHORT $LN18@ReadStdInT
$LN19@ReadStdInT:

; 2224 :                 break; // (shutting down; time to exit)

  000c4	e9 23 01 00 00	 jmp	 $LN9@ReadStdInT
$LN18@ReadStdInT:

; 2225 : 
; 2226 :             w32_w32errmsg( dwLastError, szErrMsg, sizeof(szErrMsg) );

  000c9	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  000cf	48 8d 54 24 50	 lea	 rdx, QWORD PTR szErrMsg$2[rsp]
  000d4	8b 4c 24 40	 mov	 ecx, DWORD PTR dwLastError$1[rsp]
  000d8	e8 00 00 00 00	 call	 w32_w32errmsg

; 2227 : 
; 2228 :             MSGBUF

  000dd	48 8d 44 24 50	 lea	 rax, QWORD PTR szErrMsg$2[rsp]
  000e2	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000e7	8b 44 24 40	 mov	 eax, DWORD PTR dwLastError$1[rsp]
  000eb	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000ef	44 8b 4c 24 40	 mov	 r9d, DWORD PTR dwLastError$1[rsp]
  000f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160266
  000fb	ba 00 02 00 00	 mov	 edx, 512		; 00000200H
  00100	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00108	e8 00 00 00 00	 call	 w32_snprintf

; 2229 :             (
; 2230 :                  buf, "ReadFile( hDupedStdIn ) failed! dwLastError=%d (0x%8.8X): %s"
; 2231 :                 ,dwLastError
; 2232 :                 ,dwLastError
; 2233 :                 ,szErrMsg
; 2234 :             );
; 2235 :             WRMSG(HHC90000, "D", buf);

  0010d	b9 01 00 00 00	 mov	 ecx, 1
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00118	48 8d 8c 24 50
	01 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00120	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160267
  0012c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00131	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160268
  00138	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0013d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00142	41 b9 03 00 00
	00		 mov	 r9d, 3
  00148	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160269
  0014f	ba bb 08 00 00	 mov	 edx, 2235		; 000008bbH
  00154	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160270
  0015b	e8 00 00 00 00	 call	 fwritemsg

; 2236 :             continue;

  00160	e9 f5 fe ff ff	 jmp	 $LN8@ReadStdInT
$LN17@ReadStdInT:
$LN13@ReadStdInT:

; 2237 :         }
; 2238 : 
; 2239 :         ASSERT( 1 == dwBytesRead );

  00165	83 7c 24 44 01	 cmp	 DWORD PTR dwBytesRead$[rsp], 1
  0016a	74 5b		 je	 SHORT $LN20@ReadStdInT
$LN16@ReadStdInT:
  0016c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160272
  00173	41 b8 bf 08 00
	00		 mov	 r8d, 2239		; 000008bfH
  00179	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160273
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160274
  00187	e8 00 00 00 00	 call	 logmsg
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00192	85 c0		 test	 eax, eax
  00194	74 20		 je	 SHORT $LN21@ReadStdInT
  00196	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160276
  0019d	41 b8 bf 08 00
	00		 mov	 r8d, 2239		; 000008bfH
  001a3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160277
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160278
  001b1	e8 00 00 00 00	 call	 DebuggerTrace
$LN21@ReadStdInT:
  001b6	33 c0		 xor	 eax, eax
  001b8	85 c0		 test	 eax, eax
  001ba	75 b0		 jne	 SHORT $LN16@ReadStdInT
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001c2	85 c0		 test	 eax, eax
  001c4	74 01		 je	 SHORT $LN22@ReadStdInT
  001c6	cc		 int	 3
$LN22@ReadStdInT:
$LN20@ReadStdInT:
  001c7	33 c0		 xor	 eax, eax
  001c9	85 c0		 test	 eax, eax
  001cb	75 98		 jne	 SHORT $LN13@ReadStdInT

; 2240 : 
; 2241 :         ResetEvent( hGotStdIn );

  001cd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hGotStdIn
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 2242 :         SetEvent( hStdInAvailable );

  001da	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hStdInAvailable
  001e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent

; 2243 :     }

  001e7	e9 6e fe ff ff	 jmp	 $LN8@ReadStdInT
$LN9@ReadStdInT:

; 2244 : 
; 2245 :     return 0;

  001ec	33 c0		 xor	 eax, eax

; 2246 : }

  001ee	48 8b 8c 24 50
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001f6	48 33 cc	 xor	 rcx, rsp
  001f9	e8 00 00 00 00	 call	 __security_check_cookie
  001fe	48 81 c4 68 03
	00 00		 add	 rsp, 872		; 00000368H
  00205	c3		 ret	 0
ReadStdInThread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
i$ = 0
bitSetCount$ = 4
LSHIFT$ = 8
tv69 = 12
bitTest$ = 16
tv76 = 24
bitMask$ = 48
CountSetBits PROC

; 1431 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1432 :     DWORD LSHIFT = sizeof(U_LONG_PTR)*8 - 1;

  00009	c7 44 24 08 3f
	00 00 00	 mov	 DWORD PTR LSHIFT$[rsp], 63 ; 0000003fH

; 1433 :     DWORD bitSetCount = 0;

  00011	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR bitSetCount$[rsp], 0

; 1434 :     U_LONG_PTR bitTest = (U_LONG_PTR)1 << LSHIFT;

  00019	8b 44 24 08	 mov	 eax, DWORD PTR LSHIFT$[rsp]
  0001d	b9 01 00 00 00	 mov	 ecx, 1
  00022	48 89 4c 24 18	 mov	 QWORD PTR tv76[rsp], rcx
  00027	0f b6 c8	 movzx	 ecx, al
  0002a	48 8b 44 24 18	 mov	 rax, QWORD PTR tv76[rsp]
  0002f	48 d3 e0	 shl	 rax, cl
  00032	48 89 44 24 10	 mov	 QWORD PTR bitTest$[rsp], rax

; 1435 :     DWORD i;
; 1436 : 
; 1437 :     for (i = 0; i <= LSHIFT; ++i)

  00037	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0003e	eb 08		 jmp	 SHORT $LN4@CountSetBi
$LN2@CountSetBi:
  00040	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00043	ff c0		 inc	 eax
  00045	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@CountSetBi:
  00048	8b 44 24 08	 mov	 eax, DWORD PTR LSHIFT$[rsp]
  0004c	39 04 24	 cmp	 DWORD PTR i$[rsp], eax
  0004f	77 4d		 ja	 SHORT $LN3@CountSetBi

; 1438 :     {
; 1439 :         bitSetCount += ((bitMask & bitTest)?1:0);

  00051	48 8b 44 24 10	 mov	 rax, QWORD PTR bitTest$[rsp]
  00056	48 8b 4c 24 30	 mov	 rcx, QWORD PTR bitMask$[rsp]
  0005b	48 23 c8	 and	 rcx, rax
  0005e	48 8b c1	 mov	 rax, rcx
  00061	48 85 c0	 test	 rax, rax
  00064	74 0a		 je	 SHORT $LN6@CountSetBi
  00066	c7 44 24 0c 01
	00 00 00	 mov	 DWORD PTR tv69[rsp], 1
  0006e	eb 08		 jmp	 SHORT $LN7@CountSetBi
$LN6@CountSetBi:
  00070	c7 44 24 0c 00
	00 00 00	 mov	 DWORD PTR tv69[rsp], 0
$LN7@CountSetBi:
  00078	8b 44 24 0c	 mov	 eax, DWORD PTR tv69[rsp]
  0007c	8b 4c 24 04	 mov	 ecx, DWORD PTR bitSetCount$[rsp]
  00080	03 c8		 add	 ecx, eax
  00082	8b c1		 mov	 eax, ecx
  00084	89 44 24 04	 mov	 DWORD PTR bitSetCount$[rsp], eax

; 1440 :         bitTest/=2;

  00088	33 d2		 xor	 edx, edx
  0008a	48 8b 44 24 10	 mov	 rax, QWORD PTR bitTest$[rsp]
  0008f	b9 02 00 00 00	 mov	 ecx, 2
  00094	48 f7 f1	 div	 rcx
  00097	48 89 44 24 10	 mov	 QWORD PTR bitTest$[rsp], rax

; 1441 :     }

  0009c	eb a2		 jmp	 SHORT $LN2@CountSetBi
$LN3@CountSetBi:

; 1442 : 
; 1443 :     return bitSetCount;

  0009e	8b 44 24 04	 mov	 eax, DWORD PTR bitSetCount$[rsp]

; 1444 : }

  000a2	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000a6	c3		 ret	 0
CountSetBits ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
result$ = 48
tv64 = 52
whoHandle$ = 56
ftKernel$ = 64
ftUser$ = 72
ftExit$ = 80
ftCreation$ = 88
who$ = 112
whotype$ = 120
r_usage$ = 128
DoGetRUsage PROC

; 1025 : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1026 :     FILETIME  ftCreation;   // When the process was created(*)
; 1027 :     FILETIME  ftExit;       // When the process exited(*)
; 1028 : 
; 1029 :     // (*) Windows standard FILETIME format: date/time expressed as the
; 1030 :     //     amount of time that has elapsed since midnight January 1,
; 1031 :     //     1601. These fields are NOT used in converting FILETIME usage
; 1032 :     //     times to rusage times.
; 1033 : 
; 1034 :     FILETIME  ftKernel;     // CPU time spent in kernel mode (in #of 100-nanosecond units)
; 1035 :     FILETIME  ftUser;       // CPU time spent in user   mode (in #of 100-nanosecond units)
; 1036 : 
; 1037 :     int result = 0;

  00011	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 1038 : 
; 1039 :     HANDLE  whoHandle;
; 1040 : 
; 1041 :     switch ( whotype )

  00019	8b 44 24 78	 mov	 eax, DWORD PTR whotype$[rsp]
  0001d	89 44 24 34	 mov	 DWORD PTR tv64[rsp], eax
  00021	83 7c 24 34 00	 cmp	 DWORD PTR tv64[rsp], 0
  00026	74 0c		 je	 SHORT $LN4@DoGetRUsag
  00028	83 7c 24 34 01	 cmp	 DWORD PTR tv64[rsp], 1
  0002d	74 6e		 je	 SHORT $LN6@DoGetRUsag
  0002f	e9 bb 00 00 00	 jmp	 $LN8@DoGetRUsag
$LN4@DoGetRUsag:

; 1042 :     {
; 1043 :         case rusage_type_process:
; 1044 :             whoHandle = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, who );

  00034	44 8b 44 24 70	 mov	 r8d, DWORD PTR who$[rsp]
  00039	33 d2		 xor	 edx, edx
  0003b	b9 00 04 00 00	 mov	 ecx, 1024		; 00000400H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenProcess
  00046	48 89 44 24 38	 mov	 QWORD PTR whoHandle$[rsp], rax

; 1045 :             if ( whoHandle == NULL )

  0004b	48 83 7c 24 38
	00		 cmp	 QWORD PTR whoHandle$[rsp], 0
  00051	75 12		 jne	 SHORT $LN5@DoGetRUsag

; 1046 :                 return rusage_failure( r_usage );

  00053	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR r_usage$[rsp]
  0005b	e8 00 00 00 00	 call	 rusage_failure
  00060	e9 1a 01 00 00	 jmp	 $LN1@DoGetRUsag
$LN5@DoGetRUsag:

; 1047 :             result = GetProcessTimes( whoHandle, &ftCreation, &ftExit, &ftKernel, &ftUser );

  00065	48 8d 44 24 48	 lea	 rax, QWORD PTR ftUser$[rsp]
  0006a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0006f	4c 8d 4c 24 40	 lea	 r9, QWORD PTR ftKernel$[rsp]
  00074	4c 8d 44 24 50	 lea	 r8, QWORD PTR ftExit$[rsp]
  00079	48 8d 54 24 58	 lea	 rdx, QWORD PTR ftCreation$[rsp]
  0007e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR whoHandle$[rsp]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcessTimes
  00089	89 44 24 30	 mov	 DWORD PTR result$[rsp], eax

; 1048 :             CloseHandle( whoHandle );

  0008d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR whoHandle$[rsp]
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1049 :             break;

  00098	e9 90 00 00 00	 jmp	 $LN2@DoGetRUsag
$LN6@DoGetRUsag:

; 1050 :         case rusage_type_thread:
; 1051 :             whoHandle = hthread_get_handle( who );

  0009d	8b 4c 24 70	 mov	 ecx, DWORD PTR who$[rsp]
  000a1	e8 00 00 00 00	 call	 fthread_get_handle
  000a6	48 89 44 24 38	 mov	 QWORD PTR whoHandle$[rsp], rax

; 1052 :             if ( whoHandle == NULL )

  000ab	48 83 7c 24 38
	00		 cmp	 QWORD PTR whoHandle$[rsp], 0
  000b1	75 12		 jne	 SHORT $LN7@DoGetRUsag

; 1053 :                 return rusage_failure( r_usage );

  000b3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR r_usage$[rsp]
  000bb	e8 00 00 00 00	 call	 rusage_failure
  000c0	e9 ba 00 00 00	 jmp	 $LN1@DoGetRUsag
$LN7@DoGetRUsag:

; 1054 :             result = GetThreadTimes( whoHandle, &ftCreation, &ftExit, &ftKernel, &ftUser );

  000c5	48 8d 44 24 48	 lea	 rax, QWORD PTR ftUser$[rsp]
  000ca	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000cf	4c 8d 4c 24 40	 lea	 r9, QWORD PTR ftKernel$[rsp]
  000d4	4c 8d 44 24 50	 lea	 r8, QWORD PTR ftExit$[rsp]
  000d9	48 8d 54 24 58	 lea	 rdx, QWORD PTR ftCreation$[rsp]
  000de	48 8b 4c 24 38	 mov	 rcx, QWORD PTR whoHandle$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetThreadTimes
  000e9	89 44 24 30	 mov	 DWORD PTR result$[rsp], eax

; 1055 :             break;

  000ed	eb 3e		 jmp	 SHORT $LN2@DoGetRUsag
$LN8@DoGetRUsag:

; 1056 :         default:
; 1057 :             // Check for thread ID first. If failure, handle as process ID.
; 1058 :             result = DoGetRUsage( who, rusage_type_thread, r_usage );

  000ef	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR r_usage$[rsp]
  000f7	ba 01 00 00 00	 mov	 edx, 1
  000fc	8b 4c 24 70	 mov	 ecx, DWORD PTR who$[rsp]
  00100	e8 00 00 00 00	 call	 DoGetRUsage
  00105	89 44 24 30	 mov	 DWORD PTR result$[rsp], eax

; 1059 :             if ( result == -1 )

  00109	83 7c 24 30 ff	 cmp	 DWORD PTR result$[rsp], -1
  0010e	75 17		 jne	 SHORT $LN9@DoGetRUsag

; 1060 :                 result = DoGetRUsage( who, rusage_type_process, r_usage );

  00110	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR r_usage$[rsp]
  00118	33 d2		 xor	 edx, edx
  0011a	8b 4c 24 70	 mov	 ecx, DWORD PTR who$[rsp]
  0011e	e8 00 00 00 00	 call	 DoGetRUsage
  00123	89 44 24 30	 mov	 DWORD PTR result$[rsp], eax
$LN9@DoGetRUsag:

; 1061 :             return (result);

  00127	8b 44 24 30	 mov	 eax, DWORD PTR result$[rsp]
  0012b	eb 52		 jmp	 SHORT $LN1@DoGetRUsag
$LN2@DoGetRUsag:

; 1062 :     }
; 1063 : 
; 1064 :     if ( !result )

  0012d	83 7c 24 30 00	 cmp	 DWORD PTR result$[rsp], 0
  00132	75 0f		 jne	 SHORT $LN10@DoGetRUsag

; 1065 :         return rusage_failure( r_usage );

  00134	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR r_usage$[rsp]
  0013c	e8 00 00 00 00	 call	 rusage_failure
  00141	eb 3c		 jmp	 SHORT $LN1@DoGetRUsag
$LN10@DoGetRUsag:

; 1066 : 
; 1067 :     FileTime2timeval( ftKernel, &r_usage->ru_stime );   // Kernel time...

  00143	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  0014b	48 83 c0 08	 add	 rax, 8
  0014f	48 8b d0	 mov	 rdx, rax
  00152	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ftKernel$[rsp]
  00157	e8 00 00 00 00	 call	 FileTime2timeval

; 1068 :     FileTime2timeval( ftUser,   &r_usage->ru_utime );   // User time...

  0015c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  00164	48 8b d0	 mov	 rdx, rax
  00167	48 8b 4c 24 48	 mov	 rcx, QWORD PTR ftUser$[rsp]
  0016c	e8 00 00 00 00	 call	 FileTime2timeval

; 1069 : 
; 1070 :     errno = 0;

  00171	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00177	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 1071 :     return ( 0 );

  0017d	33 c0		 xor	 eax, eax
$LN1@DoGetRUsag:

; 1072 : }

  0017f	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00183	c3		 ret	 0
DoGetRUsage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
ft$ = 48
tv$ = 56
FileTime2timeval PROC

; 1019 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1020 :     usecs2timeval( FileTime2us( ft ), tv );    // Convert to timeval

  0000e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ft$[rsp]
  00013	e8 00 00 00 00	 call	 FileTime2us
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR tv$[rsp]
  0001d	48 8b c8	 mov	 rcx, rax
  00020	e8 00 00 00 00	 call	 usecs2timeval

; 1021 : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
FileTime2timeval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
uliWork$ = 0
ft$ = 32
FileTime2us PROC

; 1006 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1007 :     ULARGE_INTEGER  uliWork;                // Work area
; 1008 : 
; 1009 :     uliWork.HighPart = ft.dwHighDateTime;   // Initialize work area for 64-bit

  00009	8b 44 24 24	 mov	 eax, DWORD PTR ft$[rsp+4]
  0000d	89 44 24 04	 mov	 DWORD PTR uliWork$[rsp+4], eax

; 1010 :     uliWork.LowPart  = ft.dwLowDateTime;    // operations

  00011	8b 44 24 20	 mov	 eax, DWORD PTR ft$[rsp]
  00015	89 04 24	 mov	 DWORD PTR uliWork$[rsp], eax

; 1011 : 
; 1012 :     uliWork.QuadPart +=  5;                 // Round FILETIME 100ns increments

  00018	48 8b 04 24	 mov	 rax, QWORD PTR uliWork$[rsp]
  0001c	48 83 c0 05	 add	 rax, 5
  00020	48 89 04 24	 mov	 QWORD PTR uliWork$[rsp], rax

; 1013 :     uliWork.QuadPart /= 10;                 // Convert to microseconds

  00024	33 d2		 xor	 edx, edx
  00026	48 8b 04 24	 mov	 rax, QWORD PTR uliWork$[rsp]
  0002a	b9 0a 00 00 00	 mov	 ecx, 10
  0002f	48 f7 f1	 div	 rcx
  00032	48 89 04 24	 mov	 QWORD PTR uliWork$[rsp], rax

; 1014 :     return ( uliWork.QuadPart );

  00036	48 8b 04 24	 mov	 rax, QWORD PTR uliWork$[rsp]

; 1015 : }

  0003a	48 83 c4 18	 add	 rsp, 24
  0003e	c3		 ret	 0
FileTime2us ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
r_usage$ = 48
rusage_failure PROC

; 995  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 996  :     r_usage->ru_stime.tv_sec  = 0;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR r_usage$[rsp]
  0000e	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 997  :     r_usage->ru_stime.tv_usec = 0;

  00015	48 8b 44 24 30	 mov	 rax, QWORD PTR r_usage$[rsp]
  0001a	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 998  :     r_usage->ru_utime.tv_sec  = 0;

  00021	48 8b 44 24 30	 mov	 rax, QWORD PTR r_usage$[rsp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 999  :     r_usage->ru_utime.tv_usec = 0;

  0002c	48 8b 44 24 30	 mov	 rax, QWORD PTR r_usage$[rsp]
  00031	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 1000 :     errno = EINVAL;

  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003e	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 1001 :     return ( -1 );

  00044	b8 ff ff ff ff	 mov	 eax, -1

; 1002 : }

  00049	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0004d	c3		 ret	 0
rusage_failure ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv136 = 48
tv140 = 52
tv145 = 56
tv170 = 60
tv175 = 64
tv203 = 68
tv228 = 72
tv240 = 76
tv214 = 80
tsOurWake$ = 88
tsSaveWake$ = 104
__$ArrayPad$ = 120
rqtp$ = 160
w32_nanosleep PROC

; 558  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 78	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 559  :     /**************************************************************************
; 560  : 
; 561  :                                 NANOSLEEP
; 562  : 
; 563  :     DESCRIPTION
; 564  : 
; 565  :         The nanosleep() function shall cause the current thread
; 566  :         to be suspended from execution until either the time interval
; 567  :         specified by the rqtp argument has elapsed or a signal is
; 568  :         delivered to the calling thread, and its action is to invoke
; 569  :         a signal-catching function or to terminate the process. The
; 570  :         suspension time may be longer than requested because the argument
; 571  :         value is rounded up to an integer multiple of the sleep resolution
; 572  :         or because of the scheduling of other activity by the system.
; 573  :         But, except for the case of being interrupted by a signal, the
; 574  :         suspension time shall not be less than the time specified by rqtp,
; 575  :         as measured by the system clock CLOCK_REALTIME.
; 576  : 
; 577  :         The use of the nanosleep() function has no effect on the action
; 578  :         or blockage of any signal.
; 579  : 
; 580  :     RETURN VALUE
; 581  : 
; 582  :         If the nanosleep() function returns because the requested time
; 583  :         has elapsed, its return value shall be zero.
; 584  : 
; 585  :         If the nanosleep() function returns because it has been interrupted
; 586  :         by a signal, it shall return a value of -1 and set errno to indicate
; 587  :         the interruption. If the rmtp argument is non-NULL, the timespec
; 588  :         structure referenced by it is updated to contain the amount of time
; 589  :         remaining in the interval (the requested time minus the time actually
; 590  :         slept). If the rmtp argument is NULL, the remaining time is not
; 591  :         returned.
; 592  : 
; 593  :         If nanosleep() fails, it shall return a value of -1 and set errno
; 594  :         to indicate the error.
; 595  : 
; 596  :     ERRORS
; 597  : 
; 598  :         The nanosleep() function shall fail if:
; 599  : 
; 600  :         [EINTR]   The nanosleep() function was interrupted by a signal.
; 601  : 
; 602  :         [EINVAL]  The rqtp argument specified a nanosecond value less than
; 603  :                   zero or greater than or equal to 1000 million.
; 604  : 
; 605  :     **************************************************************************/
; 606  : 
; 607  :     //                      IMPLEMENTATION NOTE
; 608  :     //
; 609  :     // The following code of course does not actually implement true nano-
; 610  :     // second resolution sleep functionality since Windows does not support
; 611  :     // such finely grained timers (yet). It is however coded in such a way
; 612  :     // that should Windows ever begin providing such support in the future,
; 613  :     // the changes needed to support such high precisions should be trivial.
; 614  : 
; 615  :     static LONGLONG         timerint    =  0;       // TOD clock interval
; 616  :     static HANDLE           hTimer      = NULL;     // Waitable timer handle
; 617  :     static LARGE_INTEGER    liWaitAmt   = {0};      // Amount of time to wait
; 618  :     static CRITICAL_SECTION waitlock    = {0};      // Multi-threading lock
; 619  :     static struct timespec  tsCurrTime  = {0};      // Current Time-of-Day
; 620  :     static struct timespec  tsWakeTime  = {0};      // Current wakeup time
; 621  :            struct timespec  tsSaveWake  = {0};      // Saved   wakeup time

  0001d	48 8d 44 24 68	 lea	 rax, QWORD PTR tsSaveWake$[rsp]
  00022	48 8b f8	 mov	 rdi, rax
  00025	33 c0		 xor	 eax, eax
  00027	b9 10 00 00 00	 mov	 ecx, 16
  0002c	f3 aa		 rep stosb

; 622  :            struct timespec  tsOurWake   = {0};      // Our wakeup time

  0002e	48 8d 44 24 58	 lea	 rax, QWORD PTR tsOurWake$[rsp]
  00033	48 8b f8	 mov	 rdi, rax
  00036	33 c0		 xor	 eax, eax
  00038	b9 10 00 00 00	 mov	 ecx, 16
  0003d	f3 aa		 rep stosb
$LN4@w32_nanosl:

; 623  : 
; 624  :     // Check passed parameters...
; 625  : 
; 626  :     ASSERT( rqtp );

  0003f	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rqtp$[rsp], 0
  00048	75 5b		 jne	 SHORT $LN41@w32_nanosl
$LN7@w32_nanosl:
  0004a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159392
  00051	41 b8 72 02 00
	00		 mov	 r8d, 626		; 00000272H
  00057	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159393
  0005e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159394
  00065	e8 00 00 00 00	 call	 logmsg
  0006a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00070	85 c0		 test	 eax, eax
  00072	74 20		 je	 SHORT $LN42@w32_nanosl
  00074	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159396
  0007b	41 b8 72 02 00
	00		 mov	 r8d, 626		; 00000272H
  00081	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159397
  00088	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159398
  0008f	e8 00 00 00 00	 call	 DebuggerTrace
$LN42@w32_nanosl:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 b0		 jne	 SHORT $LN7@w32_nanosl
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a0	85 c0		 test	 eax, eax
  000a2	74 01		 je	 SHORT $LN43@w32_nanosl
  000a4	cc		 int	 3
$LN43@w32_nanosl:
$LN41@w32_nanosl:
  000a5	33 c0		 xor	 eax, eax
  000a7	85 c0		 test	 eax, eax
  000a9	75 94		 jne	 SHORT $LN4@w32_nanosl

; 627  : 
; 628  :     if (unlikely

  000ab	33 c0		 xor	 eax, eax
  000ad	85 c0		 test	 eax, eax
  000af	75 34		 jne	 SHORT $LN70@w32_nanosl
  000b1	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR rqtp$[rsp], 0
  000ba	74 29		 je	 SHORT $LN70@w32_nanosl
  000bc	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rqtp$[rsp]
  000c4	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  000c8	7c 1b		 jl	 SHORT $LN70@w32_nanosl
  000ca	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rqtp$[rsp]
  000d2	81 78 08 00 ca
	9a 3b		 cmp	 DWORD PTR [rax+8], 1000000000 ; 3b9aca00H
  000d9	7d 0a		 jge	 SHORT $LN70@w32_nanosl
  000db	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
  000e3	eb 08		 jmp	 SHORT $LN73@w32_nanosl
$LN70@w32_nanosl:
  000e5	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv136[rsp], 1
$LN73@w32_nanosl:
  000ed	83 7c 24 30 00	 cmp	 DWORD PTR tv136[rsp], 0
  000f2	74 16		 je	 SHORT $LN44@w32_nanosl

; 629  :     (0
; 630  :         || !rqtp
; 631  :         || rqtp->tv_nsec < 0
; 632  :         || rqtp->tv_nsec >= BILLION
; 633  :     ))
; 634  :     {
; 635  :         errno = EINVAL;

  000f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000fa	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 636  :         return -1;

  00100	b8 ff ff ff ff	 mov	 eax, -1
  00105	e9 f2 05 00 00	 jmp	 $LN1@w32_nanosl
$LN44@w32_nanosl:

; 637  :     }
; 638  : 
; 639  :     // Perform first time initialization...
; 640  : 
; 641  :     if (unlikely( !hTimer ))

  0010a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?hTimer@?1??w32_nanosleep@@9@9, 0
  00112	75 0a		 jne	 SHORT $LN74@w32_nanosl
  00114	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR tv140[rsp], 1
  0011c	eb 08		 jmp	 SHORT $LN75@w32_nanosl
$LN74@w32_nanosl:
  0011e	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv140[rsp], 0
$LN75@w32_nanosl:
  00126	83 7c 24 34 00	 cmp	 DWORD PTR tv140[rsp], 0
  0012b	74 0a		 je	 SHORT $LN78@w32_nanosl
  0012d	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv145[rsp], 1
  00135	eb 08		 jmp	 SHORT $LN79@w32_nanosl
$LN78@w32_nanosl:
  00137	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv145[rsp], 0
$LN79@w32_nanosl:
  0013f	83 7c 24 38 00	 cmp	 DWORD PTR tv145[rsp], 0
  00144	0f 84 98 00 00
	00		 je	 $LN45@w32_nanosl

; 642  :     {
; 643  :         InitializeCriticalSectionAndSpinCount( &waitlock, 4000 );

  0014a	ba a0 0f 00 00	 mov	 edx, 4000		; 00000fa0H
  0014f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?waitlock@?1??w32_nanosleep@@9@9
  00156	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSectionAndSpinCount
$LN10@w32_nanosl:

; 644  :         VERIFY(( hTimer = CreateWaitableTimer( NULL, TRUE, NULL ) ) != NULL );

  0015c	45 33 c0	 xor	 r8d, r8d
  0015f	ba 01 00 00 00	 mov	 edx, 1
  00164	33 c9		 xor	 ecx, ecx
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateWaitableTimerA
  0016c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?hTimer@?1??w32_nanosleep@@9@9, rax
  00173	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?hTimer@?1??w32_nanosleep@@9@9, 0
  0017b	75 5b		 jne	 SHORT $LN46@w32_nanosl
$LN13@w32_nanosl:
  0017d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159403
  00184	41 b8 84 02 00
	00		 mov	 r8d, 644		; 00000284H
  0018a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159404
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159405
  00198	e8 00 00 00 00	 call	 logmsg
  0019d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001a3	85 c0		 test	 eax, eax
  001a5	74 20		 je	 SHORT $LN47@w32_nanosl
  001a7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159407
  001ae	41 b8 84 02 00
	00		 mov	 r8d, 644		; 00000284H
  001b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159408
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159409
  001c2	e8 00 00 00 00	 call	 DebuggerTrace
$LN47@w32_nanosl:
  001c7	33 c0		 xor	 eax, eax
  001c9	85 c0		 test	 eax, eax
  001cb	75 b0		 jne	 SHORT $LN13@w32_nanosl
  001cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001d3	85 c0		 test	 eax, eax
  001d5	74 01		 je	 SHORT $LN48@w32_nanosl
  001d7	cc		 int	 3
$LN48@w32_nanosl:
$LN46@w32_nanosl:
  001d8	33 c0		 xor	 eax, eax
  001da	85 c0		 test	 eax, eax
  001dc	0f 85 7a ff ff
	ff		 jne	 $LN10@w32_nanosl
$LN45@w32_nanosl:

; 645  :     }
; 646  : 
; 647  :     EnterCriticalSection( &waitlock );

  001e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?waitlock@?1??w32_nanosleep@@9@9
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection
$LN99@w32_nanosl:
$LN98@w32_nanosl:
$LN16@w32_nanosl:

; 648  : 
; 649  :     do
; 650  :     {
; 651  :         // Calculate our wakeup time if we haven't done so yet...
; 652  : 
; 653  :         if (unlikely( !tsOurWake.tv_sec ))

  001ef	48 83 7c 24 58
	00		 cmp	 QWORD PTR tsOurWake$[rsp], 0
  001f5	75 0a		 jne	 SHORT $LN80@w32_nanosl
  001f7	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv170[rsp], 1
  001ff	eb 08		 jmp	 SHORT $LN81@w32_nanosl
$LN80@w32_nanosl:
  00201	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv170[rsp], 0
$LN81@w32_nanosl:
  00209	83 7c 24 3c 00	 cmp	 DWORD PTR tv170[rsp], 0
  0020e	74 0a		 je	 SHORT $LN84@w32_nanosl
  00210	c7 44 24 40 01
	00 00 00	 mov	 DWORD PTR tv175[rsp], 1
  00218	eb 08		 jmp	 SHORT $LN85@w32_nanosl
$LN84@w32_nanosl:
  0021a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR tv175[rsp], 0
$LN85@w32_nanosl:
  00222	83 7c 24 40 00	 cmp	 DWORD PTR tv175[rsp], 0
  00227	0f 84 fb 00 00
	00		 je	 $LN49@w32_nanosl
$LN19@w32_nanosl:

; 654  :         {
; 655  :             VERIFY( clock_gettime( CLOCK_REALTIME, &tsCurrTime ) == 0);

  0022d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tsCurrTime@?1??w32_nanosleep@@9@9
  00234	33 c9		 xor	 ecx, ecx
  00236	e8 00 00 00 00	 call	 clock_gettime
  0023b	85 c0		 test	 eax, eax
  0023d	74 5b		 je	 SHORT $LN50@w32_nanosl
$LN22@w32_nanosl:
  0023f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159413
  00246	41 b8 8f 02 00
	00		 mov	 r8d, 655		; 0000028fH
  0024c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159414
  00253	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159415
  0025a	e8 00 00 00 00	 call	 logmsg
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00265	85 c0		 test	 eax, eax
  00267	74 20		 je	 SHORT $LN51@w32_nanosl
  00269	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159417
  00270	41 b8 8f 02 00
	00		 mov	 r8d, 655		; 0000028fH
  00276	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159418
  0027d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159419
  00284	e8 00 00 00 00	 call	 DebuggerTrace
$LN51@w32_nanosl:
  00289	33 c0		 xor	 eax, eax
  0028b	85 c0		 test	 eax, eax
  0028d	75 b0		 jne	 SHORT $LN22@w32_nanosl
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00295	85 c0		 test	 eax, eax
  00297	74 01		 je	 SHORT $LN52@w32_nanosl
  00299	cc		 int	 3
$LN52@w32_nanosl:
$LN50@w32_nanosl:
  0029a	33 c0		 xor	 eax, eax
  0029c	85 c0		 test	 eax, eax
  0029e	75 8d		 jne	 SHORT $LN19@w32_nanosl

; 656  : 
; 657  :             tsOurWake = tsCurrTime;

  002a0	48 8d 44 24 58	 lea	 rax, QWORD PTR tsOurWake$[rsp]
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?tsCurrTime@?1??w32_nanosleep@@9@9
  002ac	48 8b f8	 mov	 rdi, rax
  002af	48 8b f1	 mov	 rsi, rcx
  002b2	b9 10 00 00 00	 mov	 ecx, 16
  002b7	f3 a4		 rep movsb

; 658  :             tsOurWake.tv_sec  += rqtp->tv_sec;

  002b9	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rqtp$[rsp]
  002c1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  002c4	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tsOurWake$[rsp]
  002c9	48 03 c8	 add	 rcx, rax
  002cc	48 8b c1	 mov	 rax, rcx
  002cf	48 89 44 24 58	 mov	 QWORD PTR tsOurWake$[rsp], rax

; 659  :             tsOurWake.tv_nsec += rqtp->tv_nsec;

  002d4	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR rqtp$[rsp]
  002dc	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002df	8b 4c 24 60	 mov	 ecx, DWORD PTR tsOurWake$[rsp+8]
  002e3	03 c8		 add	 ecx, eax
  002e5	8b c1		 mov	 eax, ecx
  002e7	89 44 24 60	 mov	 DWORD PTR tsOurWake$[rsp+8], eax

; 660  : 
; 661  :             if (unlikely( tsOurWake.tv_nsec >= BILLION ))

  002eb	81 7c 24 60 00
	ca 9a 3b	 cmp	 DWORD PTR tsOurWake$[rsp+8], 1000000000 ; 3b9aca00H
  002f3	7c 0a		 jl	 SHORT $LN88@w32_nanosl
  002f5	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv203[rsp], 1
  002fd	eb 08		 jmp	 SHORT $LN89@w32_nanosl
$LN88@w32_nanosl:
  002ff	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv203[rsp], 0
$LN89@w32_nanosl:
  00307	83 7c 24 44 00	 cmp	 DWORD PTR tv203[rsp], 0
  0030c	74 1a		 je	 SHORT $LN53@w32_nanosl

; 662  :             {
; 663  :                 tsOurWake.tv_sec  += 1;

  0030e	48 8b 44 24 58	 mov	 rax, QWORD PTR tsOurWake$[rsp]
  00313	48 ff c0	 inc	 rax
  00316	48 89 44 24 58	 mov	 QWORD PTR tsOurWake$[rsp], rax

; 664  :                 tsOurWake.tv_nsec -= BILLION;

  0031b	8b 44 24 60	 mov	 eax, DWORD PTR tsOurWake$[rsp+8]
  0031f	2d 00 ca 9a 3b	 sub	 eax, 1000000000		; 3b9aca00H
  00324	89 44 24 60	 mov	 DWORD PTR tsOurWake$[rsp+8], eax
$LN53@w32_nanosl:
$LN49@w32_nanosl:

; 665  :             }
; 666  :         }
; 667  : 
; 668  :         //                    (CRTICIAL TEST)
; 669  :         //
; 670  :         // If our wakeup time is earlier than the current alarm time,
; 671  :         // then set the timer again with our new earlier wakeup time.
; 672  :         //
; 673  :         // Otherwise (our wakeup time comes later than the currently
; 674  :         // set wakeup/alarm time) we proceed directly to waiting for
; 675  :         // the existing currently set alarm to expire first...
; 676  : 
; 677  :         if (0
; 678  :             || !tsWakeTime.tv_sec
; 679  :             || tsOurWake.tv_sec < tsWakeTime.tv_sec
; 680  :             || (1

  00328	33 c0		 xor	 eax, eax
  0032a	85 c0		 test	 eax, eax
  0032c	75 45		 jne	 SHORT $LN55@w32_nanosl
  0032e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9, 0
  00336	74 3b		 je	 SHORT $LN55@w32_nanosl
  00338	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9
  0033f	48 39 44 24 58	 cmp	 QWORD PTR tsOurWake$[rsp], rax
  00344	7c 2d		 jl	 SHORT $LN55@w32_nanosl
  00346	33 c0		 xor	 eax, eax
  00348	83 f8 01	 cmp	 eax, 1
  0034b	0f 84 f5 01 00
	00		 je	 $LN54@w32_nanosl
  00351	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9
  00358	48 39 44 24 58	 cmp	 QWORD PTR tsOurWake$[rsp], rax
  0035d	0f 85 e3 01 00
	00		 jne	 $LN54@w32_nanosl
  00363	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9+8
  00369	39 44 24 60	 cmp	 DWORD PTR tsOurWake$[rsp+8], eax
  0036d	0f 8d d3 01 00
	00		 jge	 $LN54@w32_nanosl
$LN55@w32_nanosl:

; 681  :                 && tsOurWake.tv_sec  == tsWakeTime.tv_sec
; 682  :                 && tsOurWake.tv_nsec <  tsWakeTime.tv_nsec
; 683  :                )
; 684  :         )
; 685  :         {
; 686  :             // Calculate how long to wait in 100-nanosecond units...
; 687  : 
; 688  :             liWaitAmt.QuadPart =

  00373	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?tsCurrTime@?1??w32_nanosleep@@9@9
  0037a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tsOurWake$[rsp]
  0037f	48 2b c8	 sub	 rcx, rax
  00382	48 8b c1	 mov	 rax, rcx
  00385	48 69 c0 80 96
	98 00		 imul	 rax, rax, 10000000	; 00989680H
  0038c	48 89 44 24 50	 mov	 QWORD PTR tv214[rsp], rax
  00391	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?tsCurrTime@?1??w32_nanosleep@@9@9+8
  00397	8b 54 24 60	 mov	 edx, DWORD PTR tsOurWake$[rsp+8]
  0039b	2b d1		 sub	 edx, ecx
  0039d	8b ca		 mov	 ecx, edx
  0039f	48 63 c9	 movsxd	 rcx, ecx
  003a2	48 83 c1 32	 add	 rcx, 50			; 00000032H
  003a6	48 8b c1	 mov	 rax, rcx
  003a9	48 99		 cdq
  003ab	b9 64 00 00 00	 mov	 ecx, 100		; 00000064H
  003b0	48 f7 f9	 idiv	 rcx
  003b3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv214[rsp]
  003b8	48 03 c8	 add	 rcx, rax
  003bb	48 8b c1	 mov	 rax, rcx
  003be	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?liWaitAmt@?1??w32_nanosleep@@9@9, rax

; 689  :             (
; 690  :                 ( (LONGLONG)(tsOurWake.tv_sec  - tsCurrTime.tv_sec)  * 10000000 )
; 691  :                 +
; 692  :                 (((LONGLONG)(tsOurWake.tv_nsec - tsCurrTime.tv_nsec) + 50) / 100)
; 693  :             );
; 694  : 
; 695  :             // For efficiency don't allow any wait interval shorter
; 696  :             // than our currently defined TOD clock update interval...
; 697  : 
; 698  :             timerint = sysblk.timerint;   // (copy volatile value)

  003c5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003cc	48 63 80 60 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4448]
  003d3	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?timerint@?1??w32_nanosleep@@9@9, rax

; 699  : 
; 700  :             if (unlikely( liWaitAmt.QuadPart < (timerint * 10) ))

  003da	48 6b 05 00 00
	00 00 0a	 imul	 rax, QWORD PTR ?timerint@?1??w32_nanosleep@@9@9, 10
  003e2	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?liWaitAmt@?1??w32_nanosleep@@9@9, rax
  003e9	7d 0a		 jge	 SHORT $LN92@w32_nanosl
  003eb	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv228[rsp], 1
  003f3	eb 08		 jmp	 SHORT $LN93@w32_nanosl
$LN92@w32_nanosl:
  003f5	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
$LN93@w32_nanosl:
  003fd	83 7c 24 48 00	 cmp	 DWORD PTR tv228[rsp], 0
  00402	0f 84 80 00 00
	00		 je	 $LN56@w32_nanosl

; 701  :             {
; 702  :                 // (adjust wakeup time to respect imposed minimum)
; 703  : 
; 704  :                 tsOurWake.tv_nsec += (long) ((timerint * 10) - liWaitAmt.QuadPart) * 100;

  00408	48 6b 05 00 00
	00 00 0a	 imul	 rax, QWORD PTR ?timerint@?1??w32_nanosleep@@9@9, 10
  00410	48 2b 05 00 00
	00 00		 sub	 rax, QWORD PTR ?liWaitAmt@?1??w32_nanosleep@@9@9
  00417	6b c0 64	 imul	 eax, eax, 100		; 00000064H
  0041a	8b 4c 24 60	 mov	 ecx, DWORD PTR tsOurWake$[rsp+8]
  0041e	03 c8		 add	 ecx, eax
  00420	8b c1		 mov	 eax, ecx
  00422	89 44 24 60	 mov	 DWORD PTR tsOurWake$[rsp+8], eax

; 705  :                 liWaitAmt.QuadPart = (timerint * 10);

  00426	48 6b 05 00 00
	00 00 0a	 imul	 rax, QWORD PTR ?timerint@?1??w32_nanosleep@@9@9, 10
  0042e	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?liWaitAmt@?1??w32_nanosleep@@9@9, rax

; 706  : 
; 707  :                 if (unlikely( tsOurWake.tv_nsec >= BILLION ))

  00435	81 7c 24 60 00
	ca 9a 3b	 cmp	 DWORD PTR tsOurWake$[rsp+8], 1000000000 ; 3b9aca00H
  0043d	7c 0a		 jl	 SHORT $LN96@w32_nanosl
  0043f	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv240[rsp], 1
  00447	eb 08		 jmp	 SHORT $LN97@w32_nanosl
$LN96@w32_nanosl:
  00449	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv240[rsp], 0
$LN97@w32_nanosl:
  00451	83 7c 24 4c 00	 cmp	 DWORD PTR tv240[rsp], 0
  00456	74 30		 je	 SHORT $LN57@w32_nanosl

; 708  :                 {
; 709  :                     tsOurWake.tv_sec  += (tsOurWake.tv_nsec / BILLION);

  00458	8b 44 24 60	 mov	 eax, DWORD PTR tsOurWake$[rsp+8]
  0045c	99		 cdq
  0045d	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00462	f7 f9		 idiv	 ecx
  00464	48 98		 cdqe
  00466	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tsOurWake$[rsp]
  0046b	48 03 c8	 add	 rcx, rax
  0046e	48 8b c1	 mov	 rax, rcx
  00471	48 89 44 24 58	 mov	 QWORD PTR tsOurWake$[rsp], rax

; 710  :                     tsOurWake.tv_nsec %= BILLION;

  00476	8b 44 24 60	 mov	 eax, DWORD PTR tsOurWake$[rsp+8]
  0047a	99		 cdq
  0047b	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00480	f7 f9		 idiv	 ecx
  00482	8b c2		 mov	 eax, edx
  00484	89 44 24 60	 mov	 DWORD PTR tsOurWake$[rsp+8], eax
$LN57@w32_nanosl:
$LN56@w32_nanosl:

; 711  :                 }
; 712  :             }
; 713  : 
; 714  :             liWaitAmt.QuadPart = -liWaitAmt.QuadPart; // (negative == relative)

  00488	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?liWaitAmt@?1??w32_nanosleep@@9@9
  0048f	48 f7 d8	 neg	 rax
  00492	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?liWaitAmt@?1??w32_nanosleep@@9@9, rax
$LN25@w32_nanosl:

; 715  :             VERIFY( SetWaitableTimer( hTimer, &liWaitAmt, 0, NULL, NULL, FALSE ) );

  00499	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  004a1	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  004aa	45 33 c9	 xor	 r9d, r9d
  004ad	45 33 c0	 xor	 r8d, r8d
  004b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?liWaitAmt@?1??w32_nanosleep@@9@9
  004b7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?hTimer@?1??w32_nanosleep@@9@9
  004be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetWaitableTimer
  004c4	85 c0		 test	 eax, eax
  004c6	75 5b		 jne	 SHORT $LN58@w32_nanosl
$LN28@w32_nanosl:
  004c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159427
  004cf	41 b8 cb 02 00
	00		 mov	 r8d, 715		; 000002cbH
  004d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159428
  004dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159429
  004e3	e8 00 00 00 00	 call	 logmsg
  004e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004ee	85 c0		 test	 eax, eax
  004f0	74 20		 je	 SHORT $LN59@w32_nanosl
  004f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159431
  004f9	41 b8 cb 02 00
	00		 mov	 r8d, 715		; 000002cbH
  004ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159432
  00506	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159433
  0050d	e8 00 00 00 00	 call	 DebuggerTrace
$LN59@w32_nanosl:
  00512	33 c0		 xor	 eax, eax
  00514	85 c0		 test	 eax, eax
  00516	75 b0		 jne	 SHORT $LN28@w32_nanosl
  00518	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0051e	85 c0		 test	 eax, eax
  00520	74 01		 je	 SHORT $LN60@w32_nanosl
  00522	cc		 int	 3
$LN60@w32_nanosl:
$LN58@w32_nanosl:
  00523	33 c0		 xor	 eax, eax
  00525	85 c0		 test	 eax, eax
  00527	0f 85 6c ff ff
	ff		 jne	 $LN25@w32_nanosl

; 716  :             tsWakeTime = tsOurWake; // (use our wakeup time)

  0052d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?tsWakeTime@?1??w32_nanosleep@@9@9
  00534	48 8d 4c 24 58	 lea	 rcx, QWORD PTR tsOurWake$[rsp]
  00539	48 8b f8	 mov	 rdi, rax
  0053c	48 8b f1	 mov	 rsi, rcx
  0053f	b9 10 00 00 00	 mov	 ecx, 16
  00544	f3 a4		 rep movsb
$LN54@w32_nanosl:

; 717  :         }
; 718  : 
; 719  :         tsSaveWake = tsWakeTime;    // (save the wakeup time)

  00546	48 8d 44 24 68	 lea	 rax, QWORD PTR tsSaveWake$[rsp]
  0054b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?tsWakeTime@?1??w32_nanosleep@@9@9
  00552	48 8b f8	 mov	 rdi, rax
  00555	48 8b f1	 mov	 rsi, rcx
  00558	b9 10 00 00 00	 mov	 ecx, 16
  0055d	f3 a4		 rep movsb

; 720  : 
; 721  :         // Wait for the currently calculated wakeup time to arrive...
; 722  : 
; 723  :         LeaveCriticalSection( &waitlock );

  0055f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?waitlock@?1??w32_nanosleep@@9@9
  00566	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN31@w32_nanosl:

; 724  :         {
; 725  :             VERIFY( WaitForSingleObject( hTimer, INFINITE ) == WAIT_OBJECT_0 );

  0056c	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00571	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?hTimer@?1??w32_nanosleep@@9@9
  00578	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  0057e	85 c0		 test	 eax, eax
  00580	74 5b		 je	 SHORT $LN61@w32_nanosl
$LN34@w32_nanosl:
  00582	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159436
  00589	41 b8 d5 02 00
	00		 mov	 r8d, 725		; 000002d5H
  0058f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159437
  00596	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159438
  0059d	e8 00 00 00 00	 call	 logmsg
  005a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  005a8	85 c0		 test	 eax, eax
  005aa	74 20		 je	 SHORT $LN62@w32_nanosl
  005ac	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159440
  005b3	41 b8 d5 02 00
	00		 mov	 r8d, 725		; 000002d5H
  005b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159441
  005c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159442
  005c7	e8 00 00 00 00	 call	 DebuggerTrace
$LN62@w32_nanosl:
  005cc	33 c0		 xor	 eax, eax
  005ce	85 c0		 test	 eax, eax
  005d0	75 b0		 jne	 SHORT $LN34@w32_nanosl
  005d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  005d8	85 c0		 test	 eax, eax
  005da	74 01		 je	 SHORT $LN63@w32_nanosl
  005dc	cc		 int	 3
$LN63@w32_nanosl:
$LN61@w32_nanosl:
  005dd	33 c0		 xor	 eax, eax
  005df	85 c0		 test	 eax, eax
  005e1	75 89		 jne	 SHORT $LN31@w32_nanosl

; 726  :         }
; 727  :         EnterCriticalSection( &waitlock );

  005e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?waitlock@?1??w32_nanosleep@@9@9
  005ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_EnterCriticalSection

; 728  : 
; 729  :         // Reset the wakeup time (if the previously awakened thread
; 730  :         // hasn't done that yet) and get a new updated current TOD.
; 731  : 
; 732  :         //                (CRTICIAL TEST)
; 733  :         if (1
; 734  :             && tsWakeTime.tv_sec  == tsSaveWake.tv_sec
; 735  :             && tsWakeTime.tv_nsec == tsSaveWake.tv_nsec
; 736  :             && WaitForSingleObject( hTimer, 0 ) == WAIT_OBJECT_0

  005f0	33 c0		 xor	 eax, eax
  005f2	83 f8 01	 cmp	 eax, 1
  005f5	74 42		 je	 SHORT $LN64@w32_nanosl
  005f7	48 8b 44 24 68	 mov	 rax, QWORD PTR tsSaveWake$[rsp]
  005fc	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9, rax
  00603	75 34		 jne	 SHORT $LN64@w32_nanosl
  00605	8b 44 24 70	 mov	 eax, DWORD PTR tsSaveWake$[rsp+8]
  00609	39 05 08 00 00
	00		 cmp	 DWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9+8, eax
  0060f	75 28		 jne	 SHORT $LN64@w32_nanosl
  00611	33 d2		 xor	 edx, edx
  00613	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?hTimer@?1??w32_nanosleep@@9@9
  0061a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00620	85 c0		 test	 eax, eax
  00622	75 15		 jne	 SHORT $LN64@w32_nanosl

; 737  :         )
; 738  :         {
; 739  :             // The wakeup time hasn't been changed and the timer
; 740  :             // is still signaled so we must be the first thread
; 741  :             // to be woken up (otherwise the previously awakened
; 742  :             // thread would have set a new wakeup time and the
; 743  :             // timer thus wouldn't still be signaled). We clear
; 744  :             // the wakeup time too (since it's now known to be
; 745  :             // obsolete) which forces us to calculate a new one
; 746  :             // further above.
; 747  : 
; 748  :             tsWakeTime.tv_sec = 0;     // (needs recalculated)

  00624	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9, 0

; 749  :             tsWakeTime.tv_nsec = 0;    // (needs recalculated)

  0062f	c7 05 08 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?tsWakeTime@?1??w32_nanosleep@@9@9+8, 0
$LN64@w32_nanosl:
$LN37@w32_nanosl:

; 750  :         }
; 751  : 
; 752  :         // PROGRAMMING NOTE: I thought about simply using either
; 753  :         // 'tsWakeTime' or 'tsSaveWake' (depending on the above
; 754  :         // condition) as our new current TOD value, but doing so
; 755  :         // does not yield the desired behavior, since the system
; 756  :         // does not always wake us at our exact requested time.
; 757  :         // Thus obtaining a fresh/current TOD value each time we
; 758  :         // are awakened yields more precise/desireable behavior.
; 759  : 
; 760  :         VERIFY( clock_gettime( CLOCK_REALTIME, &tsCurrTime ) == 0);

  00639	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?tsCurrTime@?1??w32_nanosleep@@9@9
  00640	33 c9		 xor	 ecx, ecx
  00642	e8 00 00 00 00	 call	 clock_gettime
  00647	85 c0		 test	 eax, eax
  00649	74 5b		 je	 SHORT $LN65@w32_nanosl
$LN40@w32_nanosl:
  0064b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159446
  00652	41 b8 f8 02 00
	00		 mov	 r8d, 760		; 000002f8H
  00658	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159447
  0065f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159448
  00666	e8 00 00 00 00	 call	 logmsg
  0066b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00671	85 c0		 test	 eax, eax
  00673	74 20		 je	 SHORT $LN66@w32_nanosl
  00675	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159450
  0067c	41 b8 f8 02 00
	00		 mov	 r8d, 760		; 000002f8H
  00682	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159451
  00689	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159452
  00690	e8 00 00 00 00	 call	 DebuggerTrace
$LN66@w32_nanosl:
  00695	33 c0		 xor	 eax, eax
  00697	85 c0		 test	 eax, eax
  00699	75 b0		 jne	 SHORT $LN40@w32_nanosl
  0069b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  006a1	85 c0		 test	 eax, eax
  006a3	74 01		 je	 SHORT $LN67@w32_nanosl
  006a5	cc		 int	 3
$LN67@w32_nanosl:
$LN65@w32_nanosl:
  006a6	33 c0		 xor	 eax, eax
  006a8	85 c0		 test	 eax, eax
  006aa	75 8d		 jne	 SHORT $LN37@w32_nanosl

; 761  :     }
; 762  :     while // (has our wakeup time arrived yet?)
; 763  :     (0
; 764  :         || tsCurrTime.tv_sec < tsOurWake.tv_sec
; 765  :         || (1

  006ac	33 c0		 xor	 eax, eax
  006ae	85 c0		 test	 eax, eax
  006b0	0f 85 39 fb ff
	ff		 jne	 $LN16@w32_nanosl
  006b6	48 8b 44 24 58	 mov	 rax, QWORD PTR tsOurWake$[rsp]
  006bb	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?tsCurrTime@?1??w32_nanosleep@@9@9, rax
  006c2	0f 8c 27 fb ff
	ff		 jl	 $LN98@w32_nanosl
  006c8	33 c0		 xor	 eax, eax
  006ca	83 f8 01	 cmp	 eax, 1
  006cd	74 1e		 je	 SHORT $LN68@w32_nanosl
  006cf	48 8b 44 24 58	 mov	 rax, QWORD PTR tsOurWake$[rsp]
  006d4	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?tsCurrTime@?1??w32_nanosleep@@9@9, rax
  006db	75 10		 jne	 SHORT $LN68@w32_nanosl
  006dd	8b 44 24 60	 mov	 eax, DWORD PTR tsOurWake$[rsp+8]
  006e1	39 05 08 00 00
	00		 cmp	 DWORD PTR ?tsCurrTime@?1??w32_nanosleep@@9@9+8, eax
  006e7	0f 8c 02 fb ff
	ff		 jl	 $LN99@w32_nanosl
$LN68@w32_nanosl:

; 766  :             && tsCurrTime.tv_sec  == tsOurWake.tv_sec
; 767  :             && tsCurrTime.tv_nsec <  tsOurWake.tv_nsec
; 768  :            )
; 769  : 
; 770  :     );
; 771  : 
; 772  :     // Our wakeup time has arrived...
; 773  : 
; 774  :     LeaveCriticalSection( &waitlock );

  006ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?waitlock@?1??w32_nanosleep@@9@9
  006f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection

; 775  :     return 0;

  006fa	33 c0		 xor	 eax, eax
$LN1@w32_nanosl:

; 776  : }

  006fc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00701	48 33 cc	 xor	 rcx, rsp
  00704	e8 00 00 00 00	 call	 __security_check_cookie
  00709	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00710	5f		 pop	 rdi
  00711	5e		 pop	 rsi
  00712	c3		 ret	 0
w32_nanosleep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
uliRetVal$ = 32
pFT$ = 64
FileTimeTo1970Nanoseconds PROC

; 262  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H
$LN4@FileTimeTo:

; 263  :     ULARGE_INTEGER  uliRetVal;
; 264  :     ASSERT( pFT );

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR pFT$[rsp], 0
  0000f	75 5b		 jne	 SHORT $LN8@FileTimeTo
$LN7@FileTimeTo:
  00011	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159165
  00018	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159166
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159167
  0002c	e8 00 00 00 00	 call	 logmsg
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00037	85 c0		 test	 eax, eax
  00039	74 20		 je	 SHORT $LN9@FileTimeTo
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159169
  00042	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159170
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159171
  00056	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@FileTimeTo:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 b0		 jne	 SHORT $LN7@FileTimeTo
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00067	85 c0		 test	 eax, eax
  00069	74 01		 je	 SHORT $LN10@FileTimeTo
  0006b	cc		 int	 3
$LN10@FileTimeTo:
$LN8@FileTimeTo:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 97		 jne	 SHORT $LN4@FileTimeTo

; 265  : 
; 266  :     // Convert FILETIME to ULARGE_INTEGER
; 267  : 
; 268  :     uliRetVal.HighPart = pFT->dwHighDateTime;

  00072	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT$[rsp]
  00077	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0007a	89 44 24 24	 mov	 DWORD PTR uliRetVal$[rsp+4], eax

; 269  :     uliRetVal.LowPart  = pFT->dwLowDateTime;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR pFT$[rsp]
  00083	8b 00		 mov	 eax, DWORD PTR [rax]
  00085	89 44 24 20	 mov	 DWORD PTR uliRetVal$[rsp], eax

; 270  : 
; 271  :     // Convert from 100-nsec units since 1/1/1601
; 272  :     // to number of 100-nsec units since 1/1/1970
; 273  : 
; 274  :     uliRetVal.QuadPart -= 116444736000000000ULL;

  00089	48 b8 00 80 3e
	d5 de b1 9d 01	 mov	 rax, 116444736000000000	; 019db1ded53e8000H
  00093	48 8b 4c 24 20	 mov	 rcx, QWORD PTR uliRetVal$[rsp]
  00098	48 2b c8	 sub	 rcx, rax
  0009b	48 8b c1	 mov	 rax, rcx
  0009e	48 89 44 24 20	 mov	 QWORD PTR uliRetVal$[rsp], rax

; 275  : 
; 276  :     // Convert from 100-nsec units to just nsecs
; 277  : 
; 278  :     uliRetVal.QuadPart *= 100;

  000a3	48 6b 44 24 20
	64		 imul	 rax, QWORD PTR uliRetVal$[rsp], 100 ; 00000064H
  000a9	48 89 44 24 20	 mov	 QWORD PTR uliRetVal$[rsp], rax

; 279  : 
; 280  :     return uliRetVal;

  000ae	48 8b 44 24 20	 mov	 rax, QWORD PTR uliRetVal$[rsp]

; 281  : }

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
FileTimeTo1970Nanoseconds ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
expression$ = 8
function$ = 16
file$ = 24
line$ = 32
pReserved$ = 40
DummyCRTInvalidParameterHandler PROC

; 50   : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 51   :     // Do nothing to cause CRT to simply ignore the invalid parameter
; 52   :     // and to instead just pass back the return code to the caller.
; 53   : }

  00014	c3		 ret	 0
DummyCRTInvalidParameterHandler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\clock.h
_TEXT	SEGMENT
us$ = 8
tv$ = 16
usecs2timeval PROC

; 237  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 238  :     tv->tv_sec  = us / 1000000;

  0000a	33 d2		 xor	 edx, edx
  0000c	48 8b 44 24 08	 mov	 rax, QWORD PTR us$[rsp]
  00011	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  00016	48 f7 f1	 div	 rcx
  00019	48 8b 4c 24 10	 mov	 rcx, QWORD PTR tv$[rsp]
  0001e	89 01		 mov	 DWORD PTR [rcx], eax

; 239  :     tv->tv_usec = us % 1000000;

  00020	33 d2		 xor	 edx, edx
  00022	48 8b 44 24 08	 mov	 rax, QWORD PTR us$[rsp]
  00027	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0002c	48 f7 f1	 div	 rcx
  0002f	48 8b c2	 mov	 rax, rdx
  00032	48 8b 4c 24 10	 mov	 rcx, QWORD PTR tv$[rsp]
  00037	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 240  : }

  0003a	c3		 ret	 0
usecs2timeval ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
EnableInvalidParameterHandling PROC

; 72   : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 73   :     if ( !old_iph ) return;

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR old_iph, 0
  0000c	75 02		 jne	 SHORT $LN2@EnableInva
  0000e	eb 29		 jmp	 SHORT $LN1@EnableInva
$LN2@EnableInva:

; 74   :     _set_invalid_parameter_handler( old_iph ); old_iph = NULL;

  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR old_iph
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__set_invalid_parameter_handler
  0001d	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR old_iph, 0

; 75   : #if defined(DEBUG) || defined(_DEBUG)
; 76   :     _CrtSetReportMode( _CRT_ASSERT, prev_rm );

  00028	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR prev_rm
  0002e	b9 02 00 00 00	 mov	 ecx, 2
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtSetReportMode
$LN1@EnableInva:

; 77   : #endif
; 78   : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
EnableInvalidParameterHandling ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
DisableInvalidParameterHandling PROC

; 63   : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 64   :     if ( old_iph ) return;

  00004	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR old_iph, 0
  0000c	74 02		 je	 SHORT $LN2@DisableInv
  0000e	eb 27		 jmp	 SHORT $LN1@DisableInv
$LN2@DisableInv:

; 65   :     old_iph = _set_invalid_parameter_handler( DummyCRTInvalidParameterHandler );

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DummyCRTInvalidParameterHandler
  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__set_invalid_parameter_handler
  0001d	48 89 05 00 00
	00 00		 mov	 QWORD PTR old_iph, rax

; 66   : #if defined(DEBUG) || defined(_DEBUG)
; 67   :     prev_rm = _CrtSetReportMode( _CRT_ASSERT, 0 );

  00024	33 d2		 xor	 edx, edx
  00026	b9 02 00 00 00	 mov	 ecx, 2
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtSetReportMode
  00031	89 05 00 00 00
	00		 mov	 DWORD PTR prev_rm, eax
$LN1@DisableInv:

; 68   : #endif
; 69   : }

  00037	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003b	c3		 ret	 0
DisableInvalidParameterHandling ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
i$ = 32
k$1 = 36
j$2 = 40
match$3 = 44
tv70 = 48
tv89 = 52
haystack$ = 80
needle$ = 88
w32_strcasestr PROC

; 4642 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4643 :     int i = -1;

  0000e	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR i$[rsp], -1
$LN2@w32_strcas:

; 4644 : 
; 4645 :     while ( haystack[++i] != '\0' )

  00016	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0001a	ff c0		 inc	 eax
  0001c	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
  00020	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00025	48 8b 4c 24 50	 mov	 rcx, QWORD PTR haystack$[rsp]
  0002a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0002e	85 c0		 test	 eax, eax
  00030	0f 84 13 01 00
	00		 je	 $LN3@w32_strcas

; 4646 :     {
; 4647 :         if ( tolower( haystack[i] ) == tolower( needle[0] ) )

  00036	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  0003b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR haystack$[rsp]
  00040	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00044	8b c8		 mov	 ecx, eax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  0004c	89 44 24 30	 mov	 DWORD PTR tv70[rsp], eax
  00050	b9 01 00 00 00	 mov	 ecx, 1
  00055	48 6b c9 00	 imul	 rcx, rcx, 0
  00059	48 8b 54 24 58	 mov	 rdx, QWORD PTR needle$[rsp]
  0005e	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  00062	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  00068	8b 4c 24 30	 mov	 ecx, DWORD PTR tv70[rsp]
  0006c	3b c8		 cmp	 ecx, eax
  0006e	0f 85 d0 00 00
	00		 jne	 $LN6@w32_strcas

; 4648 :         {
; 4649 :             int j=i, k=0, match=0;

  00074	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  00078	89 44 24 28	 mov	 DWORD PTR j$2[rsp], eax
  0007c	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR k$1[rsp], 0
  00084	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR match$3[rsp], 0
$LN4@w32_strcas:

; 4650 :             while ( tolower( haystack[++j] ) == tolower( needle[++k] ) )

  0008c	8b 44 24 28	 mov	 eax, DWORD PTR j$2[rsp]
  00090	ff c0		 inc	 eax
  00092	89 44 24 28	 mov	 DWORD PTR j$2[rsp], eax
  00096	8b 44 24 24	 mov	 eax, DWORD PTR k$1[rsp]
  0009a	ff c0		 inc	 eax
  0009c	89 44 24 24	 mov	 DWORD PTR k$1[rsp], eax
  000a0	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$1[rsp]
  000a5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR needle$[rsp]
  000aa	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000ae	8b c8		 mov	 ecx, eax
  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  000b6	89 44 24 34	 mov	 DWORD PTR tv89[rsp], eax
  000ba	48 63 4c 24 28	 movsxd	 rcx, DWORD PTR j$2[rsp]
  000bf	48 8b 54 24 50	 mov	 rdx, QWORD PTR haystack$[rsp]
  000c4	0f be 0c 0a	 movsx	 ecx, BYTE PTR [rdx+rcx]
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tolower
  000ce	8b 4c 24 34	 mov	 ecx, DWORD PTR tv89[rsp]
  000d2	3b c1		 cmp	 eax, ecx
  000d4	75 43		 jne	 SHORT $LN5@w32_strcas

; 4651 :             {
; 4652 :                 match=1;

  000d6	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR match$3[rsp], 1

; 4653 :                 // Catch case when they match at the end
; 4654 :                 if ( haystack[j] == '\0' && needle[k] == '\0' )

  000de	48 63 44 24 28	 movsxd	 rax, DWORD PTR j$2[rsp]
  000e3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR haystack$[rsp]
  000e8	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000ec	85 c0		 test	 eax, eax
  000ee	75 24		 jne	 SHORT $LN7@w32_strcas
  000f0	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$1[rsp]
  000f5	48 8b 4c 24 58	 mov	 rcx, QWORD PTR needle$[rsp]
  000fa	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  000fe	85 c0		 test	 eax, eax
  00100	75 12		 jne	 SHORT $LN7@w32_strcas

; 4655 :                 {
; 4656 :                     return (char*)&haystack[i];

  00102	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00107	48 8b 4c 24 50	 mov	 rcx, QWORD PTR haystack$[rsp]
  0010c	48 03 c8	 add	 rcx, rax
  0010f	48 8b c1	 mov	 rax, rcx
  00112	eb 37		 jmp	 SHORT $LN1@w32_strcas
$LN7@w32_strcas:

; 4657 :                 }
; 4658 :             }

  00114	e9 73 ff ff ff	 jmp	 $LN4@w32_strcas
$LN5@w32_strcas:

; 4659 :             // Catch normal case
; 4660 :             if ( match && needle[k] == '\0' )

  00119	83 7c 24 2c 00	 cmp	 DWORD PTR match$3[rsp], 0
  0011e	74 24		 je	 SHORT $LN8@w32_strcas
  00120	48 63 44 24 24	 movsxd	 rax, DWORD PTR k$1[rsp]
  00125	48 8b 4c 24 58	 mov	 rcx, QWORD PTR needle$[rsp]
  0012a	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0012e	85 c0		 test	 eax, eax
  00130	75 12		 jne	 SHORT $LN8@w32_strcas

; 4661 :             {
; 4662 :                 return (char*)&haystack[i];

  00132	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00137	48 8b 4c 24 50	 mov	 rcx, QWORD PTR haystack$[rsp]
  0013c	48 03 c8	 add	 rcx, rax
  0013f	48 8b c1	 mov	 rax, rcx
  00142	eb 07		 jmp	 SHORT $LN1@w32_strcas
$LN8@w32_strcas:
$LN6@w32_strcas:

; 4663 :             }
; 4664 :         }
; 4665 :     }

  00144	e9 cd fe ff ff	 jmp	 $LN2@w32_strcas
$LN3@w32_strcas:

; 4666 :     return NULL;

  00149	33 c0		 xor	 eax, eax
$LN1@w32_strcas:

; 4667 : }

  0014b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0014f	c3		 ret	 0
w32_strcasestr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
drive$1 = 80
buffer$2 = 96
dir$3 = 368
__$ArrayPad$ = 624
path$ = 656
w32_dirname PROC

; 4580 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 80 02
	00 00		 sub	 rsp, 640		; 00000280H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4581 :     // The dirname() function shall return a pointer to a string
; 4582 :     // that is the parent directory of path.
; 4583 : 
; 4584 :     // If path is a NULL pointer, points to an empty string, or
; 4585 :     // does not contain a path separator character (indicating
; 4586 :     // that determining the parent directory of path would be
; 4587 :     // impossible), then a pointer to the string "." is returned.
; 4588 : 
; 4589 :     // The dirname() function may modify the string pointed to by path,
; 4590 :     // and may return a pointer to internal storage. The returned pointer
; 4591 :     // might be invalidated or the storage might be overwritten by a
; 4592 :     // subsequent call to dirname().
; 4593 : 
; 4594 :     // The dirname() function need not be thread-safe.
; 4595 : 
; 4596 :     static char _dirname [  MAX_PATH  ];
; 4597 : 
; 4598 :     /* We do a memset to not leak any of previous caller's results */
; 4599 :     memset( _dirname, 0, sizeof( _dirname ));

  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_dirname@?1??w32_dirname@@9@9
  00026	48 8b f8	 mov	 rdi, rax
  00029	33 c0		 xor	 eax, eax
  0002b	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  00030	f3 aa		 rep stosb

; 4600 : 
; 4601 :     if (0
; 4602 :         || !path
; 4603 :         || !path[0]
; 4604 :         || !strchr( path, PATHSEPC )

  00032	33 c0		 xor	 eax, eax
  00034	85 c0		 test	 eax, eax
  00036	75 3b		 jne	 SHORT $LN4@w32_dirnam
  00038	48 83 bc 24 90
	02 00 00 00	 cmp	 QWORD PTR path$[rsp], 0
  00041	74 30		 je	 SHORT $LN4@w32_dirnam
  00043	b8 01 00 00 00	 mov	 eax, 1
  00048	48 6b c0 00	 imul	 rax, rax, 0
  0004c	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00054	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00058	85 c0		 test	 eax, eax
  0005a	74 17		 je	 SHORT $LN4@w32_dirnam
  0005c	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  00061	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00069	e8 00 00 00 00	 call	 strchr
  0006e	48 85 c0	 test	 rax, rax
  00071	75 1e		 jne	 SHORT $LN2@w32_dirnam
$LN4@w32_dirnam:

; 4605 :     )
; 4606 :         STRLCPY( _dirname, "." );

  00073	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00079	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161933
  00080	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_dirname@?1??w32_dirname@@9@9
  00087	e8 00 00 00 00	 call	 strlcpy
  0008c	e9 d6 00 00 00	 jmp	 $LN3@w32_dirnam
$LN2@w32_dirnam:

; 4607 :     else
; 4608 :     {
; 4609 :         char buffer [  MAX_PATH  ];
; 4610 :         char drive  [ _MAX_DRIVE ];
; 4611 :         char dir    [ _MAX_DIR   ];
; 4612 : 
; 4613 :         /* Copy path to work buffer */
; 4614 :         STRLCPY( buffer, path );

  00091	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00097	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  0009f	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buffer$2[rsp]
  000a4	e8 00 00 00 00	 call	 strlcpy

; 4615 : 
; 4616 :         /* Remove any trailing slashes before doing splitpath */
; 4617 :         rtrim( buffer, PATHSEPS );

  000a9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161934
  000b0	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buffer$2[rsp]
  000b5	e8 00 00 00 00	 call	 rtrim

; 4618 : 
; 4619 :         /* Why does MSVC declare _splitpath_s as deprecated?! (C4996) */
; 4620 :         _splitpath_s

  000ba	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  000c3	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  000cc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  000d5	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  000de	48 c7 44 24 20
	00 01 00 00	 mov	 QWORD PTR [rsp+32], 256	; 00000100H
  000e7	4c 8d 8c 24 70
	01 00 00	 lea	 r9, QWORD PTR dir$3[rsp]
  000ef	41 b8 03 00 00
	00		 mov	 r8d, 3
  000f5	48 8d 54 24 50	 lea	 rdx, QWORD PTR drive$1[rsp]
  000fa	48 8d 4c 24 60	 lea	 rcx, QWORD PTR buffer$2[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__splitpath_s

; 4621 :         (
; 4622 :             buffer,                 // input
; 4623 :             drive, sizeof( drive ), // drive buffer and buffer size
; 4624 :             dir,   sizeof( dir   ), // directory buffer and buffer size
; 4625 :             NULL, 0,                // not interested in filename component
; 4626 :             NULL, 0                 // not interested in extension component
; 4627 :         );
; 4628 : 
; 4629 :         STRLCPY( _dirname, drive );

  00105	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0010b	48 8d 54 24 50	 lea	 rdx, QWORD PTR drive$1[rsp]
  00110	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_dirname@?1??w32_dirname@@9@9
  00117	e8 00 00 00 00	 call	 strlcpy

; 4630 :         STRLCAT( _dirname, dir );

  0011c	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00122	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR dir$3[rsp]
  0012a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_dirname@?1??w32_dirname@@9@9
  00131	e8 00 00 00 00	 call	 strlcat

; 4631 : 
; 4632 :         if (!_dirname[0])

  00136	b8 01 00 00 00	 mov	 eax, 1
  0013b	48 6b c0 00	 imul	 rax, rax, 0
  0013f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_dirname@?1??w32_dirname@@9@9
  00146	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0014a	85 c0		 test	 eax, eax
  0014c	75 19		 jne	 SHORT $LN5@w32_dirnam

; 4633 :             STRLCPY( _dirname, "." );

  0014e	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00154	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161936
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_dirname@?1??w32_dirname@@9@9
  00162	e8 00 00 00 00	 call	 strlcpy
$LN5@w32_dirnam:
$LN3@w32_dirnam:

; 4634 :     }
; 4635 : 
; 4636 :     return _dirname;

  00167	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_dirname@?1??w32_dirname@@9@9

; 4637 : }

  0016e	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00176	48 33 cc	 xor	 rcx, rsp
  00179	e8 00 00 00 00	 call	 __security_check_cookie
  0017e	48 81 c4 80 02
	00 00		 add	 rsp, 640		; 00000280H
  00185	5f		 pop	 rdi
  00186	c3		 ret	 0
w32_dirname ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
buffer$1 = 80
fname$2 = 352
ext$3 = 608
__$ArrayPad$ = 864
path$ = 896
w32_basename PROC

; 4516 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 81 ec 70 03
	00 00		 sub	 rsp, 880		; 00000370H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 84 24 60
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4517 :     // The basename() function shall take the pathname pointed to by
; 4518 :     // path and return a pointer to the final component of the pathname,
; 4519 :     // deleting any trailing path separator characters.
; 4520 : 
; 4521 :     // If path is a NULL pointer or points to an empty string, basename()
; 4522 :     // shall return a pointer to the string ".".
; 4523 : 
; 4524 :     // The basename() function may modify the string pointed to by path,
; 4525 :     // and may return a pointer to internal storage. The returned pointer
; 4526 :     // might be invalidated or the storage might be overwritten by a
; 4527 :     // subsequent call to basename().
; 4528 : 
; 4529 :     // The basename() function need not be thread-safe.
; 4530 : 
; 4531 :     static char _basename[  MAX_PATH ];
; 4532 : 
; 4533 :     /* We do a memset to not leak any of previous caller's results */
; 4534 :     memset( _basename, 0, sizeof( _basename ));

  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_basename@?1??w32_basename@@9@9
  00026	48 8b f8	 mov	 rdi, rax
  00029	33 c0		 xor	 eax, eax
  0002b	b9 04 01 00 00	 mov	 ecx, 260		; 00000104H
  00030	f3 aa		 rep stosb

; 4535 : 
; 4536 :     if (!path || !path[0])

  00032	48 83 bc 24 80
	03 00 00 00	 cmp	 QWORD PTR path$[rsp], 0
  0003b	74 19		 je	 SHORT $LN4@w32_basena
  0003d	b8 01 00 00 00	 mov	 eax, 1
  00042	48 6b c0 00	 imul	 rax, rax, 0
  00046	48 8b 8c 24 80
	03 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0004e	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  00052	85 c0		 test	 eax, eax
  00054	75 1e		 jne	 SHORT $LN2@w32_basena
$LN4@w32_basena:

; 4537 :         STRLCPY( _basename, "." );

  00056	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0005c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161916
  00063	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_basename@?1??w32_basename@@9@9
  0006a	e8 00 00 00 00	 call	 strlcpy
  0006f	e9 d6 00 00 00	 jmp	 $LN3@w32_basena
$LN2@w32_basena:

; 4538 :     else
; 4539 :     {
; 4540 :         char buffer [  MAX_PATH  ];
; 4541 :         char fname  [ _MAX_FNAME ];
; 4542 :         char ext    [ _MAX_EXT   ];
; 4543 : 
; 4544 :         /* Copy path to work buffer */
; 4545 :         STRLCPY( buffer, path );

  00074	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0007a	48 8b 94 24 80
	03 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  00082	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buffer$1[rsp]
  00087	e8 00 00 00 00	 call	 strlcpy

; 4546 : 
; 4547 :         /* Remove any trailing slashes before doing splitpath */
; 4548 :         rtrim( buffer, PATHSEPS );

  0008c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161917
  00093	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buffer$1[rsp]
  00098	e8 00 00 00 00	 call	 rtrim

; 4549 : 
; 4550 :         /* Why does MSVC declare _splitpath_s as deprecated?! (C4996) */
; 4551 :         _splitpath_s

  0009d	48 c7 44 24 40
	00 01 00 00	 mov	 QWORD PTR [rsp+64], 256	; 00000100H
  000a6	48 8d 84 24 60
	02 00 00	 lea	 rax, QWORD PTR ext$3[rsp]
  000ae	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  000b3	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR [rsp+48], 256	; 00000100H
  000bc	48 8d 84 24 60
	01 00 00	 lea	 rax, QWORD PTR fname$2[rsp]
  000c4	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000c9	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000d2	45 33 c9	 xor	 r9d, r9d
  000d5	45 33 c0	 xor	 r8d, r8d
  000d8	33 d2		 xor	 edx, edx
  000da	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buffer$1[rsp]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__splitpath_s

; 4552 :         (
; 4553 :             buffer,                 // input
; 4554 :             NULL, 0,                // not interested in drive component
; 4555 :             NULL, 0,                // not interested in dir  component
; 4556 :             fname, sizeof( fname ), // filename buffer and buffer size
; 4557 :             ext,   sizeof( ext   )  // extension buffer and buffer size
; 4558 :         );
; 4559 : 
; 4560 :         STRLCPY( _basename, fname );

  000e5	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000eb	48 8d 94 24 60
	01 00 00	 lea	 rdx, QWORD PTR fname$2[rsp]
  000f3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_basename@?1??w32_basename@@9@9
  000fa	e8 00 00 00 00	 call	 strlcpy

; 4561 :         STRLCAT( _basename, ext );

  000ff	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00105	48 8d 94 24 60
	02 00 00	 lea	 rdx, QWORD PTR ext$3[rsp]
  0010d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_basename@?1??w32_basename@@9@9
  00114	e8 00 00 00 00	 call	 strlcat

; 4562 : 
; 4563 :         if (!_basename[0])

  00119	b8 01 00 00 00	 mov	 eax, 1
  0011e	48 6b c0 00	 imul	 rax, rax, 0
  00122	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_basename@?1??w32_basename@@9@9
  00129	0f be 04 01	 movsx	 eax, BYTE PTR [rcx+rax]
  0012d	85 c0		 test	 eax, eax
  0012f	75 19		 jne	 SHORT $LN5@w32_basena

; 4564 :             STRLCPY( _basename, "." );

  00131	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00137	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161919
  0013e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?_basename@?1??w32_basename@@9@9
  00145	e8 00 00 00 00	 call	 strlcpy
$LN5@w32_basena:
$LN3@w32_basena:

; 4565 :     }
; 4566 : 
; 4567 :     return _basename;

  0014a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_basename@?1??w32_basename@@9@9

; 4568 : }

  00151	48 8b 8c 24 60
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00159	48 33 cc	 xor	 rcx, rsp
  0015c	e8 00 00 00 00	 call	 __security_check_cookie
  00161	48 81 c4 70 03
	00 00		 add	 rsp, 880		; 00000370H
  00168	5f		 pop	 rdi
  00169	c3		 ret	 0
w32_basename ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
err$ = 64
pmode$ = 68
sh_flg$ = 72
fh$ = 76
vargs$1 = 80
msgbuf$2 = 96
__$ArrayPad$ = 624
path$ = 656
oflag$ = 664
w32_hopen PROC

; 4700 : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000e	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00013	48 81 ec 88 02
	00 00		 sub	 rsp, 648		; 00000288H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 70
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 4701 :     int pmode   = _S_IREAD | _S_IWRITE;

  0002c	c7 44 24 44 80
	01 00 00	 mov	 DWORD PTR pmode$[rsp], 384 ; 00000180H

; 4702 :     int sh_flg  = _SH_DENYWR;

  00034	c7 44 24 48 20
	00 00 00	 mov	 DWORD PTR sh_flg$[rsp], 32 ; 00000020H

; 4703 :     int fh      = -1;

  0003c	c7 44 24 4c ff
	ff ff ff	 mov	 DWORD PTR fh$[rsp], -1

; 4704 :     errno_t err;
; 4705 : 
; 4706 :     if (oflag & O_CREAT)

  00044	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR oflag$[rsp]
  0004b	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00050	85 c0		 test	 eax, eax
  00052	74 27		 je	 SHORT $LN2@w32_hopen

; 4707 :     {
; 4708 :         va_list vargs;
; 4709 :         va_start( vargs, oflag );

  00054	48 8d 84 24 a0
	02 00 00	 lea	 rax, QWORD PTR oflag$[rsp+8]
  0005c	48 89 44 24 50	 mov	 QWORD PTR vargs$1[rsp], rax

; 4710 :         pmode = va_arg( vargs, int );

  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR vargs$1[rsp]
  00066	48 83 c0 08	 add	 rax, 8
  0006a	48 89 44 24 50	 mov	 QWORD PTR vargs$1[rsp], rax
  0006f	48 8b 44 24 50	 mov	 rax, QWORD PTR vargs$1[rsp]
  00074	8b 40 f8	 mov	 eax, DWORD PTR [rax-8]
  00077	89 44 24 44	 mov	 DWORD PTR pmode$[rsp], eax
$LN2@w32_hopen:

; 4711 :     }
; 4712 : 
; 4713 :     err = _sopen_s( &fh, path, oflag, sh_flg, pmode );

  0007b	8b 44 24 44	 mov	 eax, DWORD PTR pmode$[rsp]
  0007f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00083	44 8b 4c 24 48	 mov	 r9d, DWORD PTR sh_flg$[rsp]
  00088	44 8b 84 24 98
	02 00 00	 mov	 r8d, DWORD PTR oflag$[rsp]
  00090	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  00098	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR fh$[rsp]
  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__sopen_s
  000a3	89 44 24 40	 mov	 DWORD PTR err$[rsp], eax

; 4714 : 
; 4715 :     // If only read-only access was requested and permission was denied,
; 4716 :     // then the file is already opened with write access by someone else.
; 4717 :     // Try again without requesting write access denial to others. This
; 4718 :     // allows batch utilities such as "dasdls" to open and read the file
; 4719 :     // even though e.g. Hercules already has it opened with write access.
; 4720 : 
; 4721 :     if (1
; 4722 :         && !(oflag & (_O_WRONLY | _O_RDWR))   // (open == read only?)
; 4723 :         && EACCES == err                      // (permission denied?)

  000a7	33 c0		 xor	 eax, eax
  000a9	83 f8 01	 cmp	 eax, 1
  000ac	74 49		 je	 SHORT $LN3@w32_hopen
  000ae	8b 84 24 98 02
	00 00		 mov	 eax, DWORD PTR oflag$[rsp]
  000b5	83 e0 03	 and	 eax, 3
  000b8	85 c0		 test	 eax, eax
  000ba	75 3b		 jne	 SHORT $LN3@w32_hopen
  000bc	83 7c 24 40 0d	 cmp	 DWORD PTR err$[rsp], 13
  000c1	75 34		 jne	 SHORT $LN3@w32_hopen

; 4724 :     )
; 4725 :     {
; 4726 :         sh_flg = _SH_DENYNO;  // (no read or write denials this time)

  000c3	c7 44 24 48 40
	00 00 00	 mov	 DWORD PTR sh_flg$[rsp], 64 ; 00000040H

; 4727 :         err = _sopen_s( &fh, path, oflag, sh_flg, pmode );

  000cb	8b 44 24 44	 mov	 eax, DWORD PTR pmode$[rsp]
  000cf	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  000d3	44 8b 4c 24 48	 mov	 r9d, DWORD PTR sh_flg$[rsp]
  000d8	44 8b 84 24 98
	02 00 00	 mov	 r8d, DWORD PTR oflag$[rsp]
  000e0	48 8b 94 24 90
	02 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  000e8	48 8d 4c 24 4c	 lea	 rcx, QWORD PTR fh$[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__sopen_s
  000f3	89 44 24 40	 mov	 DWORD PTR err$[rsp], eax
$LN3@w32_hopen:

; 4728 :     }
; 4729 : 
; 4730 :     // Issue an error message only if verbose debugging is enabled
; 4731 :     if (1
; 4732 :         && err != 0
; 4733 :         && MLVL( DEBUG )
; 4734 :         && MLVL( VERBOSE )

  000f7	33 c0		 xor	 eax, eax
  000f9	83 f8 01	 cmp	 eax, 1
  000fc	0f 84 c3 00 00
	00		 je	 $LN4@w32_hopen
  00102	83 7c 24 40 00	 cmp	 DWORD PTR err$[rsp], 0
  00107	0f 84 b8 00 00
	00		 je	 $LN4@w32_hopen
  0010d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00114	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  0011a	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0011f	85 c0		 test	 eax, eax
  00121	0f 84 9e 00 00
	00		 je	 $LN4@w32_hopen
  00127	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0012e	8b 80 80 75 01
	00		 mov	 eax, DWORD PTR [rax+95616]
  00134	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  00139	85 c0		 test	 eax, eax
  0013b	0f 84 84 00 00
	00		 je	 $LN4@w32_hopen

; 4735 :     )
; 4736 :     {
; 4737 :         char msgbuf[MAX_PATH * 2];
; 4738 :         MSGBUF( msgbuf, "Error opening '%s'; errno(%d) %s", path, err, strerror(err) );

  00141	8b 4c 24 40	 mov	 ecx, DWORD PTR err$[rsp]
  00145	e8 00 00 00 00	 call	 w32_strerror
  0014a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014f	8b 44 24 40	 mov	 eax, DWORD PTR err$[rsp]
  00153	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00157	4c 8b 8c 24 90
	02 00 00	 mov	 r9, QWORD PTR path$[rsp]
  0015f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG161997
  00166	ba 08 02 00 00	 mov	 edx, 520		; 00000208H
  0016b	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msgbuf$2[rsp]
  00170	e8 00 00 00 00	 call	 w32_snprintf

; 4739 :         // "DBG: %s"
; 4740 :         WRMSG( HHC90000, "D", msgbuf );

  00175	b9 01 00 00 00	 mov	 ecx, 1
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00180	48 8d 4c 24 60	 lea	 rcx, QWORD PTR msgbuf$2[rsp]
  00185	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0018a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161998
  00191	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161999
  0019d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a7	41 b9 03 00 00
	00		 mov	 r9d, 3
  001ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG162000
  001b4	ba 84 12 00 00	 mov	 edx, 4740		; 00001284H
  001b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG162001
  001c0	e8 00 00 00 00	 call	 fwritemsg
$LN4@w32_hopen:

; 4741 :     }
; 4742 :     return fh;

  001c5	8b 44 24 4c	 mov	 eax, DWORD PTR fh$[rsp]

; 4743 : }

  001c9	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d1	48 33 cc	 xor	 rcx, rsp
  001d4	e8 00 00 00 00	 call	 __security_check_cookie
  001d9	48 81 c4 88 02
	00 00		 add	 rsp, 648		; 00000288H
  001e0	c3		 ret	 0
w32_hopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv68 = 32
addr$ = 64
len$ = 72
w32_munlock PROC

; 4691 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4692 :     return VirtualUnlock( addr, len ) ? 0 : -1;

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualUnlock
  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN3@w32_munloc
  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  0002a	eb 08		 jmp	 SHORT $LN4@w32_munloc
$LN3@w32_munloc:
  0002c	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv68[rsp], -1
$LN4@w32_munloc:
  00034	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]

; 4693 : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
w32_munlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv68 = 32
addr$ = 64
len$ = 72
w32_mlock PROC

; 4686 : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 4687 :     return VirtualLock( addr, len ) ? 0 : -1;

  0000e	48 8b 54 24 48	 mov	 rdx, QWORD PTR len$[rsp]
  00013	48 8b 4c 24 40	 mov	 rcx, QWORD PTR addr$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_VirtualLock
  0001e	85 c0		 test	 eax, eax
  00020	74 0a		 je	 SHORT $LN3@w32_mlock
  00022	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  0002a	eb 08		 jmp	 SHORT $LN4@w32_mlock
$LN3@w32_mlock:
  0002c	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv68[rsp], -1
$LN4@w32_mlock:
  00034	8b 44 24 20	 mov	 eax, DWORD PTR tv68[rsp]

; 4688 : }

  00038	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003c	c3		 ret	 0
w32_mlock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
system_info$1 = 32
w32_hpagesize PROC

; 4672 : {

$LN4:
  00000	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 4673 :     static long g_pagesize = 0;
; 4674 :     if (!g_pagesize)

  00004	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?g_pagesize@?1??w32_hpagesize@@9@9, 0
  0000b	75 15		 jne	 SHORT $LN2@w32_hpages

; 4675 :     {
; 4676 :         SYSTEM_INFO system_info ;
; 4677 :         GetSystemInfo(&system_info) ;

  0000d	48 8d 4c 24 20	 lea	 rcx, QWORD PTR system_info$1[rsp]
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemInfo

; 4678 :         g_pagesize = system_info.dwPageSize ;

  00018	8b 44 24 24	 mov	 eax, DWORD PTR system_info$1[rsp+4]
  0001c	89 05 00 00 00
	00		 mov	 DWORD PTR ?g_pagesize@?1??w32_hpagesize@@9@9, eax
$LN2@w32_hpages:

; 4679 :     }
; 4680 :     return (unsigned long) g_pagesize ;

  00022	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?g_pagesize@?1??w32_hpagesize@@9@9

; 4681 : }

  00028	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0002c	c3		 ret	 0
w32_hpagesize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
info$ = 32
tid$ = 80
name$ = 88
w32_set_thread_name PROC

; 4486 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 4487 :     THREADNAME_INFO info;
; 4488 : 
; 4489 :     if (!name) return;              // (ignore premature calls)

  0000d	48 83 7c 24 58
	00		 cmp	 QWORD PTR name$[rsp], 0
  00013	75 02		 jne	 SHORT $LN2@w32_set_th
  00015	eb 3c		 jmp	 SHORT $LN5@w32_set_th
$LN2@w32_set_th:

; 4490 : 
; 4491 :     info.dwType     = 0x1000;

  00017	c7 44 24 20 00
	10 00 00	 mov	 DWORD PTR info$[rsp], 4096 ; 00001000H

; 4492 :     info.pszName    = name;         // (should really be LPCTSTR)

  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR name$[rsp]
  00024	48 89 44 24 28	 mov	 QWORD PTR info$[rsp+8], rax

; 4493 :     info.dwThreadID = (DWORD)tid;   // (-1 == current thread, else tid)

  00029	8b 44 24 50	 mov	 eax, DWORD PTR tid$[rsp]
  0002d	89 44 24 30	 mov	 DWORD PTR info$[rsp+16], eax

; 4494 :     info.dwFlags    = 0;

  00031	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR info$[rsp+20], 0

; 4495 : 
; 4496 :     __try
; 4497 :     {
; 4498 :         RaiseException( MS_VC_EXCEPTION, 0, sizeof(info) / sizeof(DWORD), (const U_LONG_PTR*)&info );

  00039	4c 8d 4c 24 20	 lea	 r9, QWORD PTR info$[rsp]
  0003e	41 b8 06 00 00
	00		 mov	 r8d, 6
  00044	33 d2		 xor	 edx, edx
  00046	b9 88 13 6d 40	 mov	 ecx, 1080890248		; 406d1388H
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RaiseException

; 4499 :     }

  00051	eb 00		 jmp	 SHORT $LN5@w32_set_th
$LN7@w32_set_th:
$LN5@w32_set_th:

; 4500 :     __except ( EXCEPTION_CONTINUE_EXECUTION )
; 4501 :     {
; 4502 :         /* (do nothing) */
; 4503 :     }
; 4504 : }

  00053	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00057	c3		 ret	 0
w32_set_thread_name ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
text$x	SEGMENT
info$ = 32
tid$ = 80
name$ = 88
w32_set_thread_name$filt$0 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
$LN6@w32_set_th:

; 4500 :     __except ( EXCEPTION_CONTINUE_EXECUTION )

  00009	b8 ff ff ff ff	 mov	 eax, -1
$LN8@w32_set_th:
  0000e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00012	5d		 pop	 rbp
  00013	c3		 ret	 0
  00014	cc		 int	 3
w32_set_thread_name$filt$0 ENDP
text$x	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
rc$ = 80
pPipedProcessCtl$ = 88
dwThreadId$ = 96
pPipedStdOutThreadCtl$ = 104
pPipedStdErrThreadCtl$ = 112
hStdOutWorkerThread$ = 120
hOurProcess$ = 128
hPipeReadHandle$ = 136
hStdErrWorkerThread$ = 144
hOurReadFromStdout$ = 152
hOurReadFromStderr$ = 160
hOurWriteToStdin$ = 168
bSuccess$ = 176
hChildReadFromStdin$ = 184
pszNewCommandLine$ = 192
hPipeWriteHandle$ = 200
len$ = 208
hChildWriteToStdout$ = 216
hChildWriteToStderr$ = 224
piProcInfo$ = 232
saAttr$ = 256
siStartInfo$ = 288
pszCommandLine$ = 416
pnWriteToChildStdinFD$ = 424
w32_poor_mans_fork PROC

; 3899 : {

$LN230:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H

; 3900 :     HANDLE hChildReadFromStdin;         // child's stdin  pipe HANDLE (inherited from us)
; 3901 :     HANDLE hChildWriteToStdout;         // child's stdout pipe HANDLE (inherited from us)
; 3902 :     HANDLE hChildWriteToStderr;         // child's stderr pipe HANDLE (inherited from us)
; 3903 : 
; 3904 :     HANDLE hOurWriteToStdin;            // our HANDLE to write-end of child's stdin pipe
; 3905 :     HANDLE hOurReadFromStdout;          // our HANDLE to read-end of child's stdout pipe
; 3906 :     HANDLE hOurReadFromStderr;          // our HANDLE to read-end of child's stderr pipe
; 3907 : 
; 3908 :     HANDLE hOurProcess;                 // (temporary for creating pipes)
; 3909 :     HANDLE hPipeReadHandle;             // (temporary for creating pipes)
; 3910 :     HANDLE hPipeWriteHandle;            // (temporary for creating pipes)
; 3911 : 
; 3912 :     HANDLE hStdOutWorkerThread;         // (worker thread to monitor child's pipe)
; 3913 :     HANDLE hStdErrWorkerThread;         // (worker thread to monitor child's pipe)
; 3914 :     DWORD  dwThreadId;                  // (work)
; 3915 : 
; 3916 :     STARTUPINFO          siStartInfo;   // (info passed to CreateProcess)
; 3917 :     PROCESS_INFORMATION  piProcInfo;    // (info returned by CreateProcess)
; 3918 :     SECURITY_ATTRIBUTES  saAttr;        // (suckurity? we dunt need no stinkin suckurity!)
; 3919 : 
; 3920 :     char* pszNewCommandLine;            // (because we build pvt copy for CreateProcess)
; 3921 :     BOOL  bSuccess;                     // (work)
; 3922 :     int   rc;                           // (work)
; 3923 :     size_t len;                         // (work)
; 3924 : 
; 3925 :     PIPED_PROCESS_CTL*  pPipedProcessCtl        = NULL;

  00012	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR pPipedProcessCtl$[rsp], 0

; 3926 :     PIPED_THREAD_CTL*   pPipedStdOutThreadCtl   = NULL;

  0001b	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR pPipedStdOutThreadCtl$[rsp], 0

; 3927 :     PIPED_THREAD_CTL*   pPipedStdErrThreadCtl   = NULL;

  00024	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pPipedStdErrThreadCtl$[rsp], 0

; 3928 : 
; 3929 :     //////////////////////////////////////////////////
; 3930 :     // Initialize fields...
; 3931 : 
; 3932 :     buffer_overflow_msg         = MSG_TRUNCATED_MSG;

  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161520
  00034	48 89 05 00 00
	00 00		 mov	 QWORD PTR buffer_overflow_msg, rax

; 3933 :     buffer_overflow_msg_len     = strlen( buffer_overflow_msg );

  0003b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR buffer_overflow_msg
  00042	e8 00 00 00 00	 call	 strlen
  00047	48 89 05 00 00
	00 00		 mov	 QWORD PTR buffer_overflow_msg_len, rax

; 3934 :     saAttr.nLength              = sizeof( SECURITY_ATTRIBUTES );

  0004e	c7 84 24 00 01
	00 00 18 00 00
	00		 mov	 DWORD PTR saAttr$[rsp], 24

; 3935 :     saAttr.lpSecurityDescriptor = NULL; // (we dunt need no stinkin suckurity!)

  00059	48 c7 84 24 08
	01 00 00 00 00
	00 00		 mov	 QWORD PTR saAttr$[rsp+8], 0

; 3936 :     saAttr.bInheritHandle       = TRUE; // (allows our inheritable HANDLEs

  00065	c7 84 24 10 01
	00 00 01 00 00
	00		 mov	 DWORD PTR saAttr$[rsp+16], 1

; 3937 :                                         // to be inherited by child)
; 3938 :     hOurProcess = GetCurrentProcess();  // (for creating pipes)

  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  00076	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR hOurProcess$[rsp], rax

; 3939 : 
; 3940 :     //////////////////////////////////////////////////
; 3941 :     // Only create a stdin pipe if caller will be providing the child's stdin data...
; 3942 : 
; 3943 :     if (!pnWriteToChildStdinFD)         // (will caller be providing child's stdin?)

  0007e	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  00087	75 11		 jne	 SHORT $LN145@w32_poor_m

; 3944 :     {
; 3945 :         // PROGRAMMING NOTE: KB article 190351 "HOWTO: Spawn Console Processes with
; 3946 :         // Redirected Standard Handles" http://support.microsoft.com/?kbid=190351
; 3947 :         // is WRONG! (or at the very least quite misleading!)
; 3948 : 
; 3949 :         // It states that for those stdio handles you do NOT wish to redirect, you
; 3950 :         // should use "GetStdHandle(STD_xxx_HANDLE)", but that ONLY works when you
; 3951 :         // have a console to begin with! (which Hercules would NOT have when started
; 3952 :         // via HercGUI for example (since it specifies "DETACHED_PROCESS" (i.e. no
; 3953 :         // console) whenever it starts it via its own CreateProcess call).
; 3954 : 
; 3955 :         // If you wish to only redirect *some* (but NOT *all*) stdio handles in your
; 3956 :         // CreateProcess call, the ONLY way to properly do so (regardless of whether
; 3957 :         // you have a console or not) is by specifying NULL. Specifying NULL for your
; 3958 :         // stdio handle tells CreateProcess to use the default value for that HANDLE.
; 3959 : 
; 3960 :         hChildReadFromStdin = NULL;     // (no stdin redirection; use default)

  00089	48 c7 84 24 b8
	00 00 00 00 00
	00 00		 mov	 QWORD PTR hChildReadFromStdin$[rsp], 0

; 3961 :     }

  00095	e9 a7 01 00 00	 jmp	 $LN146@w32_poor_m
$LN145@w32_poor_m:
$LN4@w32_poor_m:

; 3962 :     else
; 3963 :     {
; 3964 :         // Create Stdin pipe for sending data to child...
; 3965 : 
; 3966 :         VERIFY( CreatePipe( &hChildReadFromStdin, &hPipeWriteHandle, &saAttr, PIPEBUFSIZE ));

  0009a	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  000a0	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR saAttr$[rsp]
  000a8	48 8d 94 24 c8
	00 00 00	 lea	 rdx, QWORD PTR hPipeWriteHandle$[rsp]
  000b0	48 8d 8c 24 b8
	00 00 00	 lea	 rcx, QWORD PTR hChildReadFromStdin$[rsp]
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePipe
  000be	85 c0		 test	 eax, eax
  000c0	75 5b		 jne	 SHORT $LN147@w32_poor_m
$LN7@w32_poor_m:
  000c2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161524
  000c9	41 b8 7e 0f 00
	00		 mov	 r8d, 3966		; 00000f7eH
  000cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161525
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161526
  000dd	e8 00 00 00 00	 call	 logmsg
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000e8	85 c0		 test	 eax, eax
  000ea	74 20		 je	 SHORT $LN148@w32_poor_m
  000ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161528
  000f3	41 b8 7e 0f 00
	00		 mov	 r8d, 3966		; 00000f7eH
  000f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161529
  00100	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161530
  00107	e8 00 00 00 00	 call	 DebuggerTrace
$LN148@w32_poor_m:
  0010c	33 c0		 xor	 eax, eax
  0010e	85 c0		 test	 eax, eax
  00110	75 b0		 jne	 SHORT $LN7@w32_poor_m
  00112	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00118	85 c0		 test	 eax, eax
  0011a	74 01		 je	 SHORT $LN149@w32_poor_m
  0011c	cc		 int	 3
$LN149@w32_poor_m:
$LN147@w32_poor_m:
  0011d	33 c0		 xor	 eax, eax
  0011f	85 c0		 test	 eax, eax
  00121	0f 85 73 ff ff
	ff		 jne	 $LN4@w32_poor_m
$LN10@w32_poor_m:

; 3967 : 
; 3968 :         // Create non-inheritable duplcate of pipe handle for our own private use...
; 3969 : 
; 3970 :         VERIFY( DuplicateHandle

  00127	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  0012f	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00137	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0013f	4c 8d 8c 24 a8
	00 00 00	 lea	 r9, QWORD PTR hOurWriteToStdin$[rsp]
  00147	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR hOurProcess$[rsp]
  0014f	48 8b 94 24 c8
	00 00 00	 mov	 rdx, QWORD PTR hPipeWriteHandle$[rsp]
  00157	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hOurProcess$[rsp]
  0015f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DuplicateHandle
  00165	85 c0		 test	 eax, eax
  00167	75 5b		 jne	 SHORT $LN150@w32_poor_m
$LN13@w32_poor_m:
  00169	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161533
  00170	41 b8 89 0f 00
	00		 mov	 r8d, 3977		; 00000f89H
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161534
  0017d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161535
  00184	e8 00 00 00 00	 call	 logmsg
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0018f	85 c0		 test	 eax, eax
  00191	74 20		 je	 SHORT $LN151@w32_poor_m
  00193	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161537
  0019a	41 b8 89 0f 00
	00		 mov	 r8d, 3977		; 00000f89H
  001a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161538
  001a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161539
  001ae	e8 00 00 00 00	 call	 DebuggerTrace
$LN151@w32_poor_m:
  001b3	33 c0		 xor	 eax, eax
  001b5	85 c0		 test	 eax, eax
  001b7	75 b0		 jne	 SHORT $LN13@w32_poor_m
  001b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001bf	85 c0		 test	 eax, eax
  001c1	74 01		 je	 SHORT $LN152@w32_poor_m
  001c3	cc		 int	 3
$LN152@w32_poor_m:
$LN150@w32_poor_m:
  001c4	33 c0		 xor	 eax, eax
  001c6	85 c0		 test	 eax, eax
  001c8	0f 85 59 ff ff
	ff		 jne	 $LN10@w32_poor_m
$LN16@w32_poor_m:

; 3971 :         (
; 3972 :             hOurProcess, hPipeWriteHandle,          // (handle to be duplicated)
; 3973 :             hOurProcess, &hOurWriteToStdin,         // (non-inheritable duplicate)
; 3974 :             0,
; 3975 :             FALSE,                                  // (prevents child from inheriting it)
; 3976 :             DUPLICATE_SAME_ACCESS
; 3977 :         ));
; 3978 :         VERIFY( CloseHandle( hPipeWriteHandle ));   // (MUST close so child won't hang!)

  001ce	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR hPipeWriteHandle$[rsp]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  001dc	85 c0		 test	 eax, eax
  001de	75 5b		 jne	 SHORT $LN153@w32_poor_m
$LN19@w32_poor_m:
  001e0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161542
  001e7	41 b8 8a 0f 00
	00		 mov	 r8d, 3978		; 00000f8aH
  001ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161543
  001f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161544
  001fb	e8 00 00 00 00	 call	 logmsg
  00200	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00206	85 c0		 test	 eax, eax
  00208	74 20		 je	 SHORT $LN154@w32_poor_m
  0020a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161546
  00211	41 b8 8a 0f 00
	00		 mov	 r8d, 3978		; 00000f8aH
  00217	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161547
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161548
  00225	e8 00 00 00 00	 call	 DebuggerTrace
$LN154@w32_poor_m:
  0022a	33 c0		 xor	 eax, eax
  0022c	85 c0		 test	 eax, eax
  0022e	75 b0		 jne	 SHORT $LN19@w32_poor_m
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00236	85 c0		 test	 eax, eax
  00238	74 01		 je	 SHORT $LN155@w32_poor_m
  0023a	cc		 int	 3
$LN155@w32_poor_m:
$LN153@w32_poor_m:
  0023b	33 c0		 xor	 eax, eax
  0023d	85 c0		 test	 eax, eax
  0023f	75 8d		 jne	 SHORT $LN16@w32_poor_m
$LN146@w32_poor_m:
$LN22@w32_poor_m:

; 3979 :     }
; 3980 : 
; 3981 :     //////////////////////////////////////////////////
; 3982 :     // Pipe child's Stdout output back to us...
; 3983 : 
; 3984 :     VERIFY( CreatePipe( &hPipeReadHandle, &hChildWriteToStdout, &saAttr, PIPEBUFSIZE ));

  00241	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  00247	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR saAttr$[rsp]
  0024f	48 8d 94 24 d8
	00 00 00	 lea	 rdx, QWORD PTR hChildWriteToStdout$[rsp]
  00257	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR hPipeReadHandle$[rsp]
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePipe
  00265	85 c0		 test	 eax, eax
  00267	75 5b		 jne	 SHORT $LN156@w32_poor_m
$LN25@w32_poor_m:
  00269	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161551
  00270	41 b8 90 0f 00
	00		 mov	 r8d, 3984		; 00000f90H
  00276	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161552
  0027d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161553
  00284	e8 00 00 00 00	 call	 logmsg
  00289	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0028f	85 c0		 test	 eax, eax
  00291	74 20		 je	 SHORT $LN157@w32_poor_m
  00293	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161555
  0029a	41 b8 90 0f 00
	00		 mov	 r8d, 3984		; 00000f90H
  002a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161556
  002a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161557
  002ae	e8 00 00 00 00	 call	 DebuggerTrace
$LN157@w32_poor_m:
  002b3	33 c0		 xor	 eax, eax
  002b5	85 c0		 test	 eax, eax
  002b7	75 b0		 jne	 SHORT $LN25@w32_poor_m
  002b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002bf	85 c0		 test	 eax, eax
  002c1	74 01		 je	 SHORT $LN158@w32_poor_m
  002c3	cc		 int	 3
$LN158@w32_poor_m:
$LN156@w32_poor_m:
  002c4	33 c0		 xor	 eax, eax
  002c6	85 c0		 test	 eax, eax
  002c8	0f 85 73 ff ff
	ff		 jne	 $LN22@w32_poor_m
$LN28@w32_poor_m:

; 3985 : 
; 3986 :     // Create non-inheritable duplcate of pipe handle for our own private use...
; 3987 : 
; 3988 :     VERIFY( DuplicateHandle

  002ce	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  002d6	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  002de	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  002e6	4c 8d 8c 24 98
	00 00 00	 lea	 r9, QWORD PTR hOurReadFromStdout$[rsp]
  002ee	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR hOurProcess$[rsp]
  002f6	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR hPipeReadHandle$[rsp]
  002fe	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hOurProcess$[rsp]
  00306	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DuplicateHandle
  0030c	85 c0		 test	 eax, eax
  0030e	75 5b		 jne	 SHORT $LN159@w32_poor_m
$LN31@w32_poor_m:
  00310	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161560
  00317	41 b8 9b 0f 00
	00		 mov	 r8d, 3995		; 00000f9bH
  0031d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161561
  00324	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161562
  0032b	e8 00 00 00 00	 call	 logmsg
  00330	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00336	85 c0		 test	 eax, eax
  00338	74 20		 je	 SHORT $LN160@w32_poor_m
  0033a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161564
  00341	41 b8 9b 0f 00
	00		 mov	 r8d, 3995		; 00000f9bH
  00347	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161565
  0034e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161566
  00355	e8 00 00 00 00	 call	 DebuggerTrace
$LN160@w32_poor_m:
  0035a	33 c0		 xor	 eax, eax
  0035c	85 c0		 test	 eax, eax
  0035e	75 b0		 jne	 SHORT $LN31@w32_poor_m
  00360	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00366	85 c0		 test	 eax, eax
  00368	74 01		 je	 SHORT $LN161@w32_poor_m
  0036a	cc		 int	 3
$LN161@w32_poor_m:
$LN159@w32_poor_m:
  0036b	33 c0		 xor	 eax, eax
  0036d	85 c0		 test	 eax, eax
  0036f	0f 85 59 ff ff
	ff		 jne	 $LN28@w32_poor_m
$LN34@w32_poor_m:

; 3989 :     (
; 3990 :         hOurProcess, hPipeReadHandle,           // (handle to be duplicated)
; 3991 :         hOurProcess, &hOurReadFromStdout,       // (non-inheritable duplicate)
; 3992 :         0,
; 3993 :         FALSE,                                  // (prevents child from inheriting it)
; 3994 :         DUPLICATE_SAME_ACCESS
; 3995 :     ));
; 3996 :     VERIFY( CloseHandle( hPipeReadHandle ));    // (MUST close so child won't hang!)

  00375	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR hPipeReadHandle$[rsp]
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00383	85 c0		 test	 eax, eax
  00385	75 5b		 jne	 SHORT $LN162@w32_poor_m
$LN37@w32_poor_m:
  00387	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161569
  0038e	41 b8 9c 0f 00
	00		 mov	 r8d, 3996		; 00000f9cH
  00394	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161570
  0039b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161571
  003a2	e8 00 00 00 00	 call	 logmsg
  003a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003ad	85 c0		 test	 eax, eax
  003af	74 20		 je	 SHORT $LN163@w32_poor_m
  003b1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161573
  003b8	41 b8 9c 0f 00
	00		 mov	 r8d, 3996		; 00000f9cH
  003be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161574
  003c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161575
  003cc	e8 00 00 00 00	 call	 DebuggerTrace
$LN163@w32_poor_m:
  003d1	33 c0		 xor	 eax, eax
  003d3	85 c0		 test	 eax, eax
  003d5	75 b0		 jne	 SHORT $LN37@w32_poor_m
  003d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  003dd	85 c0		 test	 eax, eax
  003df	74 01		 je	 SHORT $LN164@w32_poor_m
  003e1	cc		 int	 3
$LN164@w32_poor_m:
$LN162@w32_poor_m:
  003e2	33 c0		 xor	 eax, eax
  003e4	85 c0		 test	 eax, eax
  003e6	75 8d		 jne	 SHORT $LN34@w32_poor_m
$LN40@w32_poor_m:

; 3997 : 
; 3998 :     //////////////////////////////////////////////////
; 3999 :     // Pipe child's Stderr output back to us...
; 4000 : 
; 4001 :     VERIFY( CreatePipe( &hPipeReadHandle, &hChildWriteToStderr, &saAttr, PIPEBUFSIZE ));

  003e8	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  003ee	4c 8d 84 24 00
	01 00 00	 lea	 r8, QWORD PTR saAttr$[rsp]
  003f6	48 8d 94 24 e0
	00 00 00	 lea	 rdx, QWORD PTR hChildWriteToStderr$[rsp]
  003fe	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR hPipeReadHandle$[rsp]
  00406	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreatePipe
  0040c	85 c0		 test	 eax, eax
  0040e	75 5b		 jne	 SHORT $LN165@w32_poor_m
$LN43@w32_poor_m:
  00410	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161578
  00417	41 b8 a1 0f 00
	00		 mov	 r8d, 4001		; 00000fa1H
  0041d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161579
  00424	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161580
  0042b	e8 00 00 00 00	 call	 logmsg
  00430	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00436	85 c0		 test	 eax, eax
  00438	74 20		 je	 SHORT $LN166@w32_poor_m
  0043a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161582
  00441	41 b8 a1 0f 00
	00		 mov	 r8d, 4001		; 00000fa1H
  00447	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161583
  0044e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161584
  00455	e8 00 00 00 00	 call	 DebuggerTrace
$LN166@w32_poor_m:
  0045a	33 c0		 xor	 eax, eax
  0045c	85 c0		 test	 eax, eax
  0045e	75 b0		 jne	 SHORT $LN43@w32_poor_m
  00460	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00466	85 c0		 test	 eax, eax
  00468	74 01		 je	 SHORT $LN167@w32_poor_m
  0046a	cc		 int	 3
$LN167@w32_poor_m:
$LN165@w32_poor_m:
  0046b	33 c0		 xor	 eax, eax
  0046d	85 c0		 test	 eax, eax
  0046f	0f 85 73 ff ff
	ff		 jne	 $LN40@w32_poor_m
$LN46@w32_poor_m:

; 4002 : 
; 4003 :     // Create non-inheritable duplcate of pipe handle for our own private use...
; 4004 : 
; 4005 :     VERIFY( DuplicateHandle

  00475	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR [rsp+48], 2
  0047d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00485	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  0048d	4c 8d 8c 24 a0
	00 00 00	 lea	 r9, QWORD PTR hOurReadFromStderr$[rsp]
  00495	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR hOurProcess$[rsp]
  0049d	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR hPipeReadHandle$[rsp]
  004a5	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR hOurProcess$[rsp]
  004ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DuplicateHandle
  004b3	85 c0		 test	 eax, eax
  004b5	75 5b		 jne	 SHORT $LN168@w32_poor_m
$LN49@w32_poor_m:
  004b7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161587
  004be	41 b8 ac 0f 00
	00		 mov	 r8d, 4012		; 00000facH
  004c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161588
  004cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161589
  004d2	e8 00 00 00 00	 call	 logmsg
  004d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004dd	85 c0		 test	 eax, eax
  004df	74 20		 je	 SHORT $LN169@w32_poor_m
  004e1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161591
  004e8	41 b8 ac 0f 00
	00		 mov	 r8d, 4012		; 00000facH
  004ee	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161592
  004f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161593
  004fc	e8 00 00 00 00	 call	 DebuggerTrace
$LN169@w32_poor_m:
  00501	33 c0		 xor	 eax, eax
  00503	85 c0		 test	 eax, eax
  00505	75 b0		 jne	 SHORT $LN49@w32_poor_m
  00507	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0050d	85 c0		 test	 eax, eax
  0050f	74 01		 je	 SHORT $LN170@w32_poor_m
  00511	cc		 int	 3
$LN170@w32_poor_m:
$LN168@w32_poor_m:
  00512	33 c0		 xor	 eax, eax
  00514	85 c0		 test	 eax, eax
  00516	0f 85 59 ff ff
	ff		 jne	 $LN46@w32_poor_m
$LN52@w32_poor_m:

; 4006 :     (
; 4007 :         hOurProcess, hPipeReadHandle,           // (handle to be duplicated)
; 4008 :         hOurProcess, &hOurReadFromStderr,       // (non-inheritable duplicate)
; 4009 :         0,
; 4010 :         FALSE,                                  // (prevents child from inheriting it)
; 4011 :         DUPLICATE_SAME_ACCESS
; 4012 :     ));
; 4013 :     VERIFY( CloseHandle( hPipeReadHandle ));    // (MUST close so child won't hang!)

  0051c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR hPipeReadHandle$[rsp]
  00524	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0052a	85 c0		 test	 eax, eax
  0052c	75 5b		 jne	 SHORT $LN171@w32_poor_m
$LN55@w32_poor_m:
  0052e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161596
  00535	41 b8 ad 0f 00
	00		 mov	 r8d, 4013		; 00000fadH
  0053b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161597
  00542	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161598
  00549	e8 00 00 00 00	 call	 logmsg
  0054e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00554	85 c0		 test	 eax, eax
  00556	74 20		 je	 SHORT $LN172@w32_poor_m
  00558	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161600
  0055f	41 b8 ad 0f 00
	00		 mov	 r8d, 4013		; 00000fadH
  00565	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161601
  0056c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161602
  00573	e8 00 00 00 00	 call	 DebuggerTrace
$LN172@w32_poor_m:
  00578	33 c0		 xor	 eax, eax
  0057a	85 c0		 test	 eax, eax
  0057c	75 b0		 jne	 SHORT $LN55@w32_poor_m
  0057e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00584	85 c0		 test	 eax, eax
  00586	74 01		 je	 SHORT $LN173@w32_poor_m
  00588	cc		 int	 3
$LN173@w32_poor_m:
$LN171@w32_poor_m:
  00589	33 c0		 xor	 eax, eax
  0058b	85 c0		 test	 eax, eax
  0058d	75 8d		 jne	 SHORT $LN52@w32_poor_m

; 4014 : 
; 4015 :     //////////////////////////////////////////////////
; 4016 :     // Prepare for creation of child process...
; 4017 : 
; 4018 :     ZeroMemory( &piProcInfo,  sizeof( PROCESS_INFORMATION ));

  0058f	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR piProcInfo$[rsp]
  00597	48 8b f8	 mov	 rdi, rax
  0059a	33 c0		 xor	 eax, eax
  0059c	b9 18 00 00 00	 mov	 ecx, 24
  005a1	f3 aa		 rep stosb

; 4019 :     ZeroMemory( &siStartInfo, sizeof( STARTUPINFO         ));

  005a3	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR siStartInfo$[rsp]
  005ab	48 8b f8	 mov	 rdi, rax
  005ae	33 c0		 xor	 eax, eax
  005b0	b9 68 00 00 00	 mov	 ecx, 104		; 00000068H
  005b5	f3 aa		 rep stosb

; 4020 : 
; 4021 :     siStartInfo.cb         = sizeof( STARTUPINFO ); // (size of structure)

  005b7	c7 84 24 20 01
	00 00 68 00 00
	00		 mov	 DWORD PTR siStartInfo$[rsp], 104 ; 00000068H

; 4022 :     siStartInfo.dwFlags    = STARTF_USESTDHANDLES;  // (use redirected std HANDLEs)

  005c2	c7 84 24 5c 01
	00 00 00 01 00
	00		 mov	 DWORD PTR siStartInfo$[rsp+60], 256 ; 00000100H

; 4023 :     siStartInfo.hStdInput  = hChildReadFromStdin;   // (use redirected std HANDLEs)

  005cd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR hChildReadFromStdin$[rsp]
  005d5	48 89 84 24 70
	01 00 00	 mov	 QWORD PTR siStartInfo$[rsp+80], rax

; 4024 :     siStartInfo.hStdOutput = hChildWriteToStdout;   // (use redirected std HANDLEs)

  005dd	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR hChildWriteToStdout$[rsp]
  005e5	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR siStartInfo$[rsp+88], rax

; 4025 :     siStartInfo.hStdError  = hChildWriteToStderr;   // (use redirected std HANDLEs)

  005ed	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR hChildWriteToStderr$[rsp]
  005f5	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR siStartInfo$[rsp+96], rax

; 4026 : 
; 4027 :     // Build the command-line for the system to create the child process with...
; 4028 : 
; 4029 :     len = strlen( pszCommandLine ) + 1;

  005fd	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR pszCommandLine$[rsp]
  00605	e8 00 00 00 00	 call	 strlen
  0060a	48 ff c0	 inc	 rax
  0060d	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR len$[rsp], rax

; 4030 :     pszNewCommandLine = malloc( len );

  00615	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR len$[rsp]
  0061d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00623	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR pszNewCommandLine$[rsp], rax

; 4031 :     strlcpy( pszNewCommandLine, pszCommandLine, len );

  0062b	4c 8b 84 24 d0
	00 00 00	 mov	 r8, QWORD PTR len$[rsp]
  00633	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR pszCommandLine$[rsp]
  0063b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pszNewCommandLine$[rsp]
  00643	e8 00 00 00 00	 call	 strlcpy

; 4032 : 
; 4033 :     //////////////////////////////////////////////////
; 4034 :     // Now actually create the child process...
; 4035 :     //////////////////////////////////////////////////
; 4036 : 
; 4037 :     bSuccess = CreateProcess

  00648	48 8d 84 24 e8
	00 00 00	 lea	 rax, QWORD PTR piProcInfo$[rsp]
  00650	48 89 44 24 48	 mov	 QWORD PTR [rsp+72], rax
  00655	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR siStartInfo$[rsp]
  0065d	48 89 44 24 40	 mov	 QWORD PTR [rsp+64], rax
  00662	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  0066b	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00674	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  0067c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR [rsp+32], 1
  00684	45 33 c9	 xor	 r9d, r9d
  00687	45 33 c0	 xor	 r8d, r8d
  0068a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR pszNewCommandLine$[rsp]
  00692	33 c9		 xor	 ecx, ecx
  00694	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateProcessA
  0069a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR bSuccess$[rsp], eax

; 4038 :     (
; 4039 :         NULL,                   // name of executable module = from command-line
; 4040 :         pszNewCommandLine,      // command line with arguments
; 4041 : 
; 4042 :         NULL,                   // process security attributes = use defaults
; 4043 :         NULL,                   // primary thread security attributes = use defaults
; 4044 : 
; 4045 :         TRUE,                   // HANDLE inheritance flag = allow
; 4046 :                                 // (required when STARTF_USESTDHANDLES flag is used)
; 4047 : 
; 4048 :         0,  //  NOTE!  >>>--->  // UNDOCUMENTED SECRET! MUST BE ZERO! Can't be "CREATE_NO_WINDOW"
; 4049 :                                 // nor "DETACHED_PROCESS", etc, or else it sometimes doesn't work
; 4050 :                                 // or else a console window appears! ("ipconfig" being one such
; 4051 :                                 // example). THIS IS NOT DOCUMENTED *ANYWHERE* IN ANY MICROSOFT
; 4052 :                                 // DOCUMENTATION THAT I COULD FIND! I only stumbled across it by
; 4053 :                                 // sheer good fortune in a news group post after some intensive
; 4054 :                                 // Googling and have experimentally verified it works as desired.
; 4055 : 
; 4056 :         NULL,                   // environment block ptr = make a copy from parent's
; 4057 :         NULL,                   // initial working directory = same as parent's
; 4058 : 
; 4059 :         &siStartInfo,           // input STARTUPINFO pointer
; 4060 :         &piProcInfo             // output PROCESS_INFORMATION
; 4061 :     );
; 4062 : 
; 4063 :     rc = GetLastError();        // (save return code)

  006a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  006a7	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 4064 : 
; 4065 :     // Close the HANDLEs we don't need...
; 4066 : 
; 4067 :     if (pnWriteToChildStdinFD)

  006ab	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  006b4	74 73		 je	 SHORT $LN174@w32_poor_m
$LN58@w32_poor_m:

; 4068 :         VERIFY( CloseHandle( hChildReadFromStdin ));    // (MUST close so child won't hang!)

  006b6	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR hChildReadFromStdin$[rsp]
  006be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  006c4	85 c0		 test	 eax, eax
  006c6	75 5b		 jne	 SHORT $LN175@w32_poor_m
$LN61@w32_poor_m:
  006c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161606
  006cf	41 b8 e4 0f 00
	00		 mov	 r8d, 4068		; 00000fe4H
  006d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161607
  006dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161608
  006e3	e8 00 00 00 00	 call	 logmsg
  006e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  006ee	85 c0		 test	 eax, eax
  006f0	74 20		 je	 SHORT $LN176@w32_poor_m
  006f2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161610
  006f9	41 b8 e4 0f 00
	00		 mov	 r8d, 4068		; 00000fe4H
  006ff	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161611
  00706	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161612
  0070d	e8 00 00 00 00	 call	 DebuggerTrace
$LN176@w32_poor_m:
  00712	33 c0		 xor	 eax, eax
  00714	85 c0		 test	 eax, eax
  00716	75 b0		 jne	 SHORT $LN61@w32_poor_m
  00718	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0071e	85 c0		 test	 eax, eax
  00720	74 01		 je	 SHORT $LN177@w32_poor_m
  00722	cc		 int	 3
$LN177@w32_poor_m:
$LN175@w32_poor_m:
  00723	33 c0		 xor	 eax, eax
  00725	85 c0		 test	 eax, eax
  00727	75 8d		 jne	 SHORT $LN58@w32_poor_m
$LN174@w32_poor_m:
$LN64@w32_poor_m:

; 4069 : 
; 4070 :     VERIFY( CloseHandle( hChildWriteToStdout ));        // (MUST close so child won't hang!)

  00729	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR hChildWriteToStdout$[rsp]
  00731	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00737	85 c0		 test	 eax, eax
  00739	75 5b		 jne	 SHORT $LN178@w32_poor_m
$LN67@w32_poor_m:
  0073b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161615
  00742	41 b8 e6 0f 00
	00		 mov	 r8d, 4070		; 00000fe6H
  00748	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161616
  0074f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161617
  00756	e8 00 00 00 00	 call	 logmsg
  0075b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00761	85 c0		 test	 eax, eax
  00763	74 20		 je	 SHORT $LN179@w32_poor_m
  00765	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161619
  0076c	41 b8 e6 0f 00
	00		 mov	 r8d, 4070		; 00000fe6H
  00772	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161620
  00779	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161621
  00780	e8 00 00 00 00	 call	 DebuggerTrace
$LN179@w32_poor_m:
  00785	33 c0		 xor	 eax, eax
  00787	85 c0		 test	 eax, eax
  00789	75 b0		 jne	 SHORT $LN67@w32_poor_m
  0078b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00791	85 c0		 test	 eax, eax
  00793	74 01		 je	 SHORT $LN180@w32_poor_m
  00795	cc		 int	 3
$LN180@w32_poor_m:
$LN178@w32_poor_m:
  00796	33 c0		 xor	 eax, eax
  00798	85 c0		 test	 eax, eax
  0079a	75 8d		 jne	 SHORT $LN64@w32_poor_m
$LN70@w32_poor_m:

; 4071 :     VERIFY( CloseHandle( hChildWriteToStderr ));        // (MUST close so child won't hang!)

  0079c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR hChildWriteToStderr$[rsp]
  007a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  007aa	85 c0		 test	 eax, eax
  007ac	75 5b		 jne	 SHORT $LN181@w32_poor_m
$LN73@w32_poor_m:
  007ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161624
  007b5	41 b8 e7 0f 00
	00		 mov	 r8d, 4071		; 00000fe7H
  007bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161625
  007c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161626
  007c9	e8 00 00 00 00	 call	 logmsg
  007ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  007d4	85 c0		 test	 eax, eax
  007d6	74 20		 je	 SHORT $LN182@w32_poor_m
  007d8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161628
  007df	41 b8 e7 0f 00
	00		 mov	 r8d, 4071		; 00000fe7H
  007e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161629
  007ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161630
  007f3	e8 00 00 00 00	 call	 DebuggerTrace
$LN182@w32_poor_m:
  007f8	33 c0		 xor	 eax, eax
  007fa	85 c0		 test	 eax, eax
  007fc	75 b0		 jne	 SHORT $LN73@w32_poor_m
  007fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00804	85 c0		 test	 eax, eax
  00806	74 01		 je	 SHORT $LN183@w32_poor_m
  00808	cc		 int	 3
$LN183@w32_poor_m:
$LN181@w32_poor_m:
  00809	33 c0		 xor	 eax, eax
  0080b	85 c0		 test	 eax, eax
  0080d	75 8d		 jne	 SHORT $LN70@w32_poor_m

; 4072 : 
; 4073 :     CloseHandle( piProcInfo.hThread  );                 // (we don't need this one)

  0080f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR piProcInfo$[rsp+8]
  00817	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4074 : 
; 4075 :     free( pszNewCommandLine );                          // (not needed anymore)

  0081d	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR pszNewCommandLine$[rsp]
  00825	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4076 : 
; 4077 :     // Check results...
; 4078 : 
; 4079 :     if (!bSuccess)

  0082b	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR bSuccess$[rsp], 0
  00833	0f 85 c2 01 00
	00		 jne	 $LN184@w32_poor_m
$LN76@w32_poor_m:

; 4080 :     {
; 4081 :         TRACE("*** CreateProcess() failed! rc = %d : %s\n",

  00839	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  0083d	e8 00 00 00 00	 call	 w32_strerror
  00842	4c 8b c0	 mov	 r8, rax
  00845	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  00849	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161633
  00850	e8 00 00 00 00	 call	 logmsg
  00855	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0085b	85 c0		 test	 eax, eax
  0085d	74 1c		 je	 SHORT $LN185@w32_poor_m
  0085f	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00863	e8 00 00 00 00	 call	 w32_strerror
  00868	4c 8b c0	 mov	 r8, rax
  0086b	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  0086f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161635
  00876	e8 00 00 00 00	 call	 DebuggerTrace
$LN185@w32_poor_m:
  0087b	33 c0		 xor	 eax, eax
  0087d	85 c0		 test	 eax, eax
  0087f	75 b8		 jne	 SHORT $LN76@w32_poor_m

; 4082 :             rc,w32_strerror(rc));
; 4083 : 
; 4084 :         if (pnWriteToChildStdinFD)

  00881	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  0088a	74 73		 je	 SHORT $LN186@w32_poor_m
$LN79@w32_poor_m:

; 4085 :             VERIFY( CloseHandle( hOurWriteToStdin ));

  0088c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hOurWriteToStdin$[rsp]
  00894	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0089a	85 c0		 test	 eax, eax
  0089c	75 5b		 jne	 SHORT $LN187@w32_poor_m
$LN82@w32_poor_m:
  0089e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161638
  008a5	41 b8 f5 0f 00
	00		 mov	 r8d, 4085		; 00000ff5H
  008ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161639
  008b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161640
  008b9	e8 00 00 00 00	 call	 logmsg
  008be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  008c4	85 c0		 test	 eax, eax
  008c6	74 20		 je	 SHORT $LN188@w32_poor_m
  008c8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161642
  008cf	41 b8 f5 0f 00
	00		 mov	 r8d, 4085		; 00000ff5H
  008d5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161643
  008dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161644
  008e3	e8 00 00 00 00	 call	 DebuggerTrace
$LN188@w32_poor_m:
  008e8	33 c0		 xor	 eax, eax
  008ea	85 c0		 test	 eax, eax
  008ec	75 b0		 jne	 SHORT $LN82@w32_poor_m
  008ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  008f4	85 c0		 test	 eax, eax
  008f6	74 01		 je	 SHORT $LN189@w32_poor_m
  008f8	cc		 int	 3
$LN189@w32_poor_m:
$LN187@w32_poor_m:
  008f9	33 c0		 xor	 eax, eax
  008fb	85 c0		 test	 eax, eax
  008fd	75 8d		 jne	 SHORT $LN79@w32_poor_m
$LN186@w32_poor_m:
$LN85@w32_poor_m:

; 4086 : 
; 4087 :         VERIFY( CloseHandle( hOurReadFromStdout ));

  008ff	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStdout$[rsp]
  00907	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  0090d	85 c0		 test	 eax, eax
  0090f	75 5b		 jne	 SHORT $LN190@w32_poor_m
$LN88@w32_poor_m:
  00911	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161647
  00918	41 b8 f7 0f 00
	00		 mov	 r8d, 4087		; 00000ff7H
  0091e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161648
  00925	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161649
  0092c	e8 00 00 00 00	 call	 logmsg
  00931	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00937	85 c0		 test	 eax, eax
  00939	74 20		 je	 SHORT $LN191@w32_poor_m
  0093b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161651
  00942	41 b8 f7 0f 00
	00		 mov	 r8d, 4087		; 00000ff7H
  00948	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161652
  0094f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161653
  00956	e8 00 00 00 00	 call	 DebuggerTrace
$LN191@w32_poor_m:
  0095b	33 c0		 xor	 eax, eax
  0095d	85 c0		 test	 eax, eax
  0095f	75 b0		 jne	 SHORT $LN88@w32_poor_m
  00961	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00967	85 c0		 test	 eax, eax
  00969	74 01		 je	 SHORT $LN192@w32_poor_m
  0096b	cc		 int	 3
$LN192@w32_poor_m:
$LN190@w32_poor_m:
  0096c	33 c0		 xor	 eax, eax
  0096e	85 c0		 test	 eax, eax
  00970	75 8d		 jne	 SHORT $LN85@w32_poor_m
$LN91@w32_poor_m:

; 4088 :         VERIFY( CloseHandle( hOurReadFromStderr ));

  00972	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStderr$[rsp]
  0097a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00980	85 c0		 test	 eax, eax
  00982	75 5b		 jne	 SHORT $LN193@w32_poor_m
$LN94@w32_poor_m:
  00984	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161656
  0098b	41 b8 f8 0f 00
	00		 mov	 r8d, 4088		; 00000ff8H
  00991	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161657
  00998	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161658
  0099f	e8 00 00 00 00	 call	 logmsg
  009a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  009aa	85 c0		 test	 eax, eax
  009ac	74 20		 je	 SHORT $LN194@w32_poor_m
  009ae	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161660
  009b5	41 b8 f8 0f 00
	00		 mov	 r8d, 4088		; 00000ff8H
  009bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161661
  009c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161662
  009c9	e8 00 00 00 00	 call	 DebuggerTrace
$LN194@w32_poor_m:
  009ce	33 c0		 xor	 eax, eax
  009d0	85 c0		 test	 eax, eax
  009d2	75 b0		 jne	 SHORT $LN94@w32_poor_m
  009d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  009da	85 c0		 test	 eax, eax
  009dc	74 01		 je	 SHORT $LN195@w32_poor_m
  009de	cc		 int	 3
$LN195@w32_poor_m:
$LN193@w32_poor_m:
  009df	33 c0		 xor	 eax, eax
  009e1	85 c0		 test	 eax, eax
  009e3	75 8d		 jne	 SHORT $LN91@w32_poor_m

; 4089 : 
; 4090 :         errno = rc;

  009e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  009eb	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  009ef	89 08		 mov	 DWORD PTR [rax], ecx

; 4091 :         return -1;

  009f1	b8 ff ff ff ff	 mov	 eax, -1
  009f6	e9 60 07 00 00	 jmp	 $LN1@w32_poor_m
$LN184@w32_poor_m:

; 4092 :     }
; 4093 : 
; 4094 :     // Allocate/intialize control blocks for piped process/thread control...
; 4095 : 
; 4096 :     // If we were passed a pnWriteToChildStdinFD pointer, then the caller
; 4097 :     // is in charge of the process and will handle message capturing/logging
; 4098 :     // (such as is done with the print-to-pipe facility).
; 4099 : 
; 4100 :     // Otherwise (pnWriteToChildStdinFD is NULL) the caller wishes for us
; 4101 :     // to capture the piped process's o/p, so we pass a PIPED_PROCESS_CTL
; 4102 :     // structure to the stdout/stderr monitoring threads. This structure
; 4103 :     // contains a pointer to a buffer where they can accumulate messages.
; 4104 : 
; 4105 :     // Then once the process exits WE will then issue the "logmsg". This
; 4106 :     // is necessary in order to "capture" the process's o/p since the logmsg
; 4107 :     // capture facility is designed to capture o/p for a specific thread,
; 4108 :     // where that thread is US! (else if we let the monitoring thread issue
; 4109 :     // the logmsg's, they'll never get captured since they don't have the
; 4110 :     // same thread-id as the thread that started the capture, which was us!
; 4111 :     // (actually it was the caller, but we're the same thread as they are!)).
; 4112 : 
; 4113 :     pPipedStdOutThreadCtl = malloc( sizeof( PIPED_THREAD_CTL ));

  009fb	b9 10 00 00 00	 mov	 ecx, 16
  00a00	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00a06	48 89 44 24 68	 mov	 QWORD PTR pPipedStdOutThreadCtl$[rsp], rax

; 4114 :     pPipedStdErrThreadCtl = malloc( sizeof( PIPED_THREAD_CTL ));

  00a0b	b9 10 00 00 00	 mov	 ecx, 16
  00a10	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00a16	48 89 44 24 70	 mov	 QWORD PTR pPipedStdErrThreadCtl$[rsp], rax

; 4115 : 
; 4116 :     pPipedStdOutThreadCtl->hStdXXX = hOurReadFromStdout;

  00a1b	48 8b 44 24 68	 mov	 rax, QWORD PTR pPipedStdOutThreadCtl$[rsp]
  00a20	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStdout$[rsp]
  00a28	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4117 :     pPipedStdErrThreadCtl->hStdXXX = hOurReadFromStderr;

  00a2b	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedStdErrThreadCtl$[rsp]
  00a30	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStderr$[rsp]
  00a38	48 89 08	 mov	 QWORD PTR [rax], rcx

; 4118 : 
; 4119 :     if ( !pnWriteToChildStdinFD )

  00a3b	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  00a44	75 78		 jne	 SHORT $LN196@w32_poor_m

; 4120 :     {
; 4121 :         pPipedProcessCtl = malloc( sizeof( PIPED_PROCESS_CTL ));

  00a46	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00a4b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00a51	48 89 44 24 58	 mov	 QWORD PTR pPipedProcessCtl$[rsp], rax

; 4122 : 
; 4123 :         pPipedStdOutThreadCtl->pPipedProcessCtl = pPipedProcessCtl;

  00a56	48 8b 44 24 68	 mov	 rax, QWORD PTR pPipedStdOutThreadCtl$[rsp]
  00a5b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00a60	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4124 :         pPipedStdErrThreadCtl->pPipedProcessCtl = pPipedProcessCtl;

  00a64	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedStdErrThreadCtl$[rsp]
  00a69	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00a6e	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 4125 : 
; 4126 :         InitializeCriticalSection( &pPipedProcessCtl->csLock );

  00a72	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00a77	48 83 c0 18	 add	 rax, 24
  00a7b	48 8b c8	 mov	 rcx, rax
  00a7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 4127 :         pPipedProcessCtl->nAllocSize =         1;    // (purposely small for debugging)

  00a84	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00a89	48 c7 40 08 01
	00 00 00	 mov	 QWORD PTR [rax+8], 1

; 4128 :         pPipedProcessCtl->pszBuffer  = malloc( 1 );  // (purposely small for debugging)

  00a91	b9 01 00 00 00	 mov	 ecx, 1
  00a96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00a9c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00aa1	48 89 01	 mov	 QWORD PTR [rcx], rax

; 4129 :         *pPipedProcessCtl->pszBuffer = 0;            // (null terminate string buffer)

  00aa4	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00aa9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00aac	c6 00 00	 mov	 BYTE PTR [rax], 0

; 4130 :         pPipedProcessCtl->nStrLen    = 0;            // (no msgs yet)

  00aaf	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00ab4	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 4131 :     }

  00abc	eb 1a		 jmp	 SHORT $LN197@w32_poor_m
$LN196@w32_poor_m:

; 4132 :     else
; 4133 :     {
; 4134 :         pPipedStdOutThreadCtl->pPipedProcessCtl = NULL;

  00abe	48 8b 44 24 68	 mov	 rax, QWORD PTR pPipedStdOutThreadCtl$[rsp]
  00ac3	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0

; 4135 :         pPipedStdErrThreadCtl->pPipedProcessCtl = NULL;

  00acb	48 8b 44 24 70	 mov	 rax, QWORD PTR pPipedStdErrThreadCtl$[rsp]
  00ad0	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
$LN197@w32_poor_m:

; 4136 :     }
; 4137 : 
; 4138 :     //////////////////////////////////////////////////
; 4139 :     // Create o/p pipe monitoring worker threads...
; 4140 :     //////////////////////////////////////////////////
; 4141 :     // Stdout...
; 4142 : 
; 4143 :     hStdOutWorkerThread = (HANDLE) _beginthreadex

  00ad8	48 8d 44 24 60	 lea	 rax, QWORD PTR dwThreadId$[rsp]
  00add	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00ae2	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00aea	4c 8b 4c 24 68	 mov	 r9, QWORD PTR pPipedStdOutThreadCtl$[rsp]
  00aef	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:w32_read_piped_process_stdxxx_output_thread
  00af6	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00afb	33 c9		 xor	 ecx, ecx
  00afd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__beginthreadex
  00b03	48 89 44 24 78	 mov	 QWORD PTR hStdOutWorkerThread$[rsp], rax

; 4144 :     (
; 4145 :         NULL,                                       // pointer to security attributes = use defaults
; 4146 :         PIPE_THREAD_STACKSIZE,                      // initial thread stack size
; 4147 :         w32_read_piped_process_stdxxx_output_thread,
; 4148 :         pPipedStdOutThreadCtl,                      // thread argument
; 4149 :         0,                                          // special creation flags = none needed
; 4150 :         &dwThreadId                                 // pointer to receive thread ID
; 4151 :     );
; 4152 :     rc = GetLastError();                            // (save return code)

  00b08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00b0e	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 4153 : 
; 4154 :     if (!hStdOutWorkerThread || INVALID_HANDLE_VALUE == hStdOutWorkerThread)

  00b12	48 83 7c 24 78
	00		 cmp	 QWORD PTR hStdOutWorkerThread$[rsp], 0
  00b18	74 0c		 je	 SHORT $LN199@w32_poor_m
  00b1a	48 83 7c 24 78
	ff		 cmp	 QWORD PTR hStdOutWorkerThread$[rsp], -1
  00b20	0f 85 0e 02 00
	00		 jne	 $LN198@w32_poor_m
$LN199@w32_poor_m:
$LN97@w32_poor_m:

; 4155 :     {
; 4156 :         TRACE("*** _beginthreadex() failed! rc = %d : %s\n",

  00b26	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00b2a	e8 00 00 00 00	 call	 w32_strerror
  00b2f	4c 8b c0	 mov	 r8, rax
  00b32	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  00b36	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161668
  00b3d	e8 00 00 00 00	 call	 logmsg
  00b42	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00b48	85 c0		 test	 eax, eax
  00b4a	74 1c		 je	 SHORT $LN200@w32_poor_m
  00b4c	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00b50	e8 00 00 00 00	 call	 w32_strerror
  00b55	4c 8b c0	 mov	 r8, rax
  00b58	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  00b5c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161670
  00b63	e8 00 00 00 00	 call	 DebuggerTrace
$LN200@w32_poor_m:
  00b68	33 c0		 xor	 eax, eax
  00b6a	85 c0		 test	 eax, eax
  00b6c	75 b8		 jne	 SHORT $LN97@w32_poor_m

; 4157 :             rc,w32_strerror(rc));
; 4158 : 
; 4159 :         if (pnWriteToChildStdinFD)

  00b6e	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  00b77	74 73		 je	 SHORT $LN201@w32_poor_m
$LN100@w32_poor_m:

; 4160 :             VERIFY( CloseHandle( hOurWriteToStdin ));

  00b79	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hOurWriteToStdin$[rsp]
  00b81	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00b87	85 c0		 test	 eax, eax
  00b89	75 5b		 jne	 SHORT $LN202@w32_poor_m
$LN103@w32_poor_m:
  00b8b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161673
  00b92	41 b8 40 10 00
	00		 mov	 r8d, 4160		; 00001040H
  00b98	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161674
  00b9f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161675
  00ba6	e8 00 00 00 00	 call	 logmsg
  00bab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00bb1	85 c0		 test	 eax, eax
  00bb3	74 20		 je	 SHORT $LN203@w32_poor_m
  00bb5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161677
  00bbc	41 b8 40 10 00
	00		 mov	 r8d, 4160		; 00001040H
  00bc2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161678
  00bc9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161679
  00bd0	e8 00 00 00 00	 call	 DebuggerTrace
$LN203@w32_poor_m:
  00bd5	33 c0		 xor	 eax, eax
  00bd7	85 c0		 test	 eax, eax
  00bd9	75 b0		 jne	 SHORT $LN103@w32_poor_m
  00bdb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00be1	85 c0		 test	 eax, eax
  00be3	74 01		 je	 SHORT $LN204@w32_poor_m
  00be5	cc		 int	 3
$LN204@w32_poor_m:
$LN202@w32_poor_m:
  00be6	33 c0		 xor	 eax, eax
  00be8	85 c0		 test	 eax, eax
  00bea	75 8d		 jne	 SHORT $LN100@w32_poor_m
$LN201@w32_poor_m:
$LN106@w32_poor_m:

; 4161 : 
; 4162 :         VERIFY( CloseHandle( hOurReadFromStdout ));

  00bec	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStdout$[rsp]
  00bf4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00bfa	85 c0		 test	 eax, eax
  00bfc	75 5b		 jne	 SHORT $LN205@w32_poor_m
$LN109@w32_poor_m:
  00bfe	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161682
  00c05	41 b8 42 10 00
	00		 mov	 r8d, 4162		; 00001042H
  00c0b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161683
  00c12	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161684
  00c19	e8 00 00 00 00	 call	 logmsg
  00c1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c24	85 c0		 test	 eax, eax
  00c26	74 20		 je	 SHORT $LN206@w32_poor_m
  00c28	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161686
  00c2f	41 b8 42 10 00
	00		 mov	 r8d, 4162		; 00001042H
  00c35	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161687
  00c3c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161688
  00c43	e8 00 00 00 00	 call	 DebuggerTrace
$LN206@w32_poor_m:
  00c48	33 c0		 xor	 eax, eax
  00c4a	85 c0		 test	 eax, eax
  00c4c	75 b0		 jne	 SHORT $LN109@w32_poor_m
  00c4e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c54	85 c0		 test	 eax, eax
  00c56	74 01		 je	 SHORT $LN207@w32_poor_m
  00c58	cc		 int	 3
$LN207@w32_poor_m:
$LN205@w32_poor_m:
  00c59	33 c0		 xor	 eax, eax
  00c5b	85 c0		 test	 eax, eax
  00c5d	75 8d		 jne	 SHORT $LN106@w32_poor_m
$LN112@w32_poor_m:

; 4163 :         VERIFY( CloseHandle( hOurReadFromStderr ));

  00c5f	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStderr$[rsp]
  00c67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00c6d	85 c0		 test	 eax, eax
  00c6f	75 5b		 jne	 SHORT $LN208@w32_poor_m
$LN115@w32_poor_m:
  00c71	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161691
  00c78	41 b8 43 10 00
	00		 mov	 r8d, 4163		; 00001043H
  00c7e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161692
  00c85	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161693
  00c8c	e8 00 00 00 00	 call	 logmsg
  00c91	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00c97	85 c0		 test	 eax, eax
  00c99	74 20		 je	 SHORT $LN209@w32_poor_m
  00c9b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161695
  00ca2	41 b8 43 10 00
	00		 mov	 r8d, 4163		; 00001043H
  00ca8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161696
  00caf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161697
  00cb6	e8 00 00 00 00	 call	 DebuggerTrace
$LN209@w32_poor_m:
  00cbb	33 c0		 xor	 eax, eax
  00cbd	85 c0		 test	 eax, eax
  00cbf	75 b0		 jne	 SHORT $LN115@w32_poor_m
  00cc1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00cc7	85 c0		 test	 eax, eax
  00cc9	74 01		 je	 SHORT $LN210@w32_poor_m
  00ccb	cc		 int	 3
$LN210@w32_poor_m:
$LN208@w32_poor_m:
  00ccc	33 c0		 xor	 eax, eax
  00cce	85 c0		 test	 eax, eax
  00cd0	75 8d		 jne	 SHORT $LN112@w32_poor_m

; 4164 : 
; 4165 :         if ( !pnWriteToChildStdinFD )

  00cd2	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  00cdb	75 2b		 jne	 SHORT $LN211@w32_poor_m

; 4166 :         {
; 4167 :             DeleteCriticalSection( &pPipedProcessCtl->csLock );

  00cdd	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00ce2	48 83 c0 18	 add	 rax, 24
  00ce6	48 8b c8	 mov	 rcx, rax
  00ce9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 4168 :             free( pPipedProcessCtl->pszBuffer );

  00cef	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00cf4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00cf7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4169 :             free( pPipedProcessCtl );

  00cfd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00d02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN211@w32_poor_m:

; 4170 :         }
; 4171 :         free( pPipedStdOutThreadCtl );

  00d08	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pPipedStdOutThreadCtl$[rsp]
  00d0d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4172 :         free( pPipedStdErrThreadCtl );

  00d13	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedStdErrThreadCtl$[rsp]
  00d18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4173 : 
; 4174 :         errno = rc;

  00d1e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d24	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00d28	89 08		 mov	 DWORD PTR [rax], ecx

; 4175 :         return -1;

  00d2a	b8 ff ff ff ff	 mov	 eax, -1
  00d2f	e9 27 04 00 00	 jmp	 $LN1@w32_poor_m
$LN198@w32_poor_m:
$LN118@w32_poor_m:

; 4176 :     }
; 4177 : 
; 4178 :     SET_THREAD_NAME_ID( dwThreadId, "w32_pipe_stdOUT" );

  00d34	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161700
  00d3b	8b 4c 24 60	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  00d3f	e8 00 00 00 00	 call	 w32_set_thread_name
  00d44	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161701
  00d4b	8b 4c 24 60	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  00d4f	e8 00 00 00 00	 call	 hthread_set_thread_name
  00d54	33 c0		 xor	 eax, eax
  00d56	85 c0		 test	 eax, eax
  00d58	75 da		 jne	 SHORT $LN118@w32_poor_m

; 4179 : 
; 4180 :     //////////////////////////////////////////////////
; 4181 :     // Stderr...
; 4182 : 
; 4183 :     hStdErrWorkerThread = (HANDLE) _beginthreadex

  00d5a	48 8d 44 24 60	 lea	 rax, QWORD PTR dwThreadId$[rsp]
  00d5f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00d64	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00d6c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR pPipedStdErrThreadCtl$[rsp]
  00d71	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:w32_read_piped_process_stdxxx_output_thread
  00d78	ba 00 00 01 00	 mov	 edx, 65536		; 00010000H
  00d7d	33 c9		 xor	 ecx, ecx
  00d7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__beginthreadex
  00d85	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR hStdErrWorkerThread$[rsp], rax

; 4184 :     (
; 4185 :         NULL,                                       // pointer to security attributes = use defaults
; 4186 :         PIPE_THREAD_STACKSIZE,                      // initial thread stack size
; 4187 :         w32_read_piped_process_stdxxx_output_thread,
; 4188 :         pPipedStdErrThreadCtl,                      // thread argument
; 4189 :         0,                                          // special creation flags = none needed
; 4190 :         &dwThreadId                                 // pointer to receive thread ID
; 4191 :     );
; 4192 :     rc = GetLastError();                            // (save return code)

  00d8d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00d93	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 4193 : 
; 4194 :     if (!hStdErrWorkerThread || INVALID_HANDLE_VALUE == hStdErrWorkerThread)

  00d97	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR hStdErrWorkerThread$[rsp], 0
  00da0	74 0f		 je	 SHORT $LN213@w32_poor_m
  00da2	48 83 bc 24 90
	00 00 00 ff	 cmp	 QWORD PTR hStdErrWorkerThread$[rsp], -1
  00dab	0f 85 29 02 00
	00		 jne	 $LN212@w32_poor_m
$LN213@w32_poor_m:
$LN121@w32_poor_m:

; 4195 :     {
; 4196 :         TRACE("*** _beginthreadex() failed! rc = %d : %s\n",

  00db1	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00db5	e8 00 00 00 00	 call	 w32_strerror
  00dba	4c 8b c0	 mov	 r8, rax
  00dbd	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  00dc1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161704
  00dc8	e8 00 00 00 00	 call	 logmsg
  00dcd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00dd3	85 c0		 test	 eax, eax
  00dd5	74 1c		 je	 SHORT $LN214@w32_poor_m
  00dd7	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00ddb	e8 00 00 00 00	 call	 w32_strerror
  00de0	4c 8b c0	 mov	 r8, rax
  00de3	8b 54 24 50	 mov	 edx, DWORD PTR rc$[rsp]
  00de7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161706
  00dee	e8 00 00 00 00	 call	 DebuggerTrace
$LN214@w32_poor_m:
  00df3	33 c0		 xor	 eax, eax
  00df5	85 c0		 test	 eax, eax
  00df7	75 b8		 jne	 SHORT $LN121@w32_poor_m

; 4197 :             rc,w32_strerror(rc));
; 4198 : 
; 4199 :         if (pnWriteToChildStdinFD)

  00df9	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  00e02	74 73		 je	 SHORT $LN215@w32_poor_m
$LN124@w32_poor_m:

; 4200 :             VERIFY( CloseHandle( hOurWriteToStdin ));

  00e04	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hOurWriteToStdin$[rsp]
  00e0c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00e12	85 c0		 test	 eax, eax
  00e14	75 5b		 jne	 SHORT $LN216@w32_poor_m
$LN127@w32_poor_m:
  00e16	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161709
  00e1d	41 b8 68 10 00
	00		 mov	 r8d, 4200		; 00001068H
  00e23	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161710
  00e2a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161711
  00e31	e8 00 00 00 00	 call	 logmsg
  00e36	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00e3c	85 c0		 test	 eax, eax
  00e3e	74 20		 je	 SHORT $LN217@w32_poor_m
  00e40	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161713
  00e47	41 b8 68 10 00
	00		 mov	 r8d, 4200		; 00001068H
  00e4d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161714
  00e54	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161715
  00e5b	e8 00 00 00 00	 call	 DebuggerTrace
$LN217@w32_poor_m:
  00e60	33 c0		 xor	 eax, eax
  00e62	85 c0		 test	 eax, eax
  00e64	75 b0		 jne	 SHORT $LN127@w32_poor_m
  00e66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00e6c	85 c0		 test	 eax, eax
  00e6e	74 01		 je	 SHORT $LN218@w32_poor_m
  00e70	cc		 int	 3
$LN218@w32_poor_m:
$LN216@w32_poor_m:
  00e71	33 c0		 xor	 eax, eax
  00e73	85 c0		 test	 eax, eax
  00e75	75 8d		 jne	 SHORT $LN124@w32_poor_m
$LN215@w32_poor_m:
$LN130@w32_poor_m:

; 4201 : 
; 4202 :         VERIFY( CloseHandle( hOurReadFromStdout ));

  00e77	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStdout$[rsp]
  00e7f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00e85	85 c0		 test	 eax, eax
  00e87	75 5b		 jne	 SHORT $LN219@w32_poor_m
$LN133@w32_poor_m:
  00e89	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161718
  00e90	41 b8 6a 10 00
	00		 mov	 r8d, 4202		; 0000106aH
  00e96	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161719
  00e9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161720
  00ea4	e8 00 00 00 00	 call	 logmsg
  00ea9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00eaf	85 c0		 test	 eax, eax
  00eb1	74 20		 je	 SHORT $LN220@w32_poor_m
  00eb3	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161722
  00eba	41 b8 6a 10 00
	00		 mov	 r8d, 4202		; 0000106aH
  00ec0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161723
  00ec7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161724
  00ece	e8 00 00 00 00	 call	 DebuggerTrace
$LN220@w32_poor_m:
  00ed3	33 c0		 xor	 eax, eax
  00ed5	85 c0		 test	 eax, eax
  00ed7	75 b0		 jne	 SHORT $LN133@w32_poor_m
  00ed9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00edf	85 c0		 test	 eax, eax
  00ee1	74 01		 je	 SHORT $LN221@w32_poor_m
  00ee3	cc		 int	 3
$LN221@w32_poor_m:
$LN219@w32_poor_m:
  00ee4	33 c0		 xor	 eax, eax
  00ee6	85 c0		 test	 eax, eax
  00ee8	75 8d		 jne	 SHORT $LN130@w32_poor_m
$LN136@w32_poor_m:

; 4203 :         VERIFY( CloseHandle( hOurReadFromStderr ));

  00eea	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR hOurReadFromStderr$[rsp]
  00ef2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  00ef8	85 c0		 test	 eax, eax
  00efa	75 5b		 jne	 SHORT $LN222@w32_poor_m
$LN139@w32_poor_m:
  00efc	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161727
  00f03	41 b8 6b 10 00
	00		 mov	 r8d, 4203		; 0000106bH
  00f09	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161728
  00f10	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161729
  00f17	e8 00 00 00 00	 call	 logmsg
  00f1c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00f22	85 c0		 test	 eax, eax
  00f24	74 20		 je	 SHORT $LN223@w32_poor_m
  00f26	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161731
  00f2d	41 b8 6b 10 00
	00		 mov	 r8d, 4203		; 0000106bH
  00f33	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161732
  00f3a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161733
  00f41	e8 00 00 00 00	 call	 DebuggerTrace
$LN223@w32_poor_m:
  00f46	33 c0		 xor	 eax, eax
  00f48	85 c0		 test	 eax, eax
  00f4a	75 b0		 jne	 SHORT $LN139@w32_poor_m
  00f4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00f52	85 c0		 test	 eax, eax
  00f54	74 01		 je	 SHORT $LN224@w32_poor_m
  00f56	cc		 int	 3
$LN224@w32_poor_m:
$LN222@w32_poor_m:
  00f57	33 c0		 xor	 eax, eax
  00f59	85 c0		 test	 eax, eax
  00f5b	75 8d		 jne	 SHORT $LN136@w32_poor_m

; 4204 : 
; 4205 :         WaitForSingleObject( hStdOutWorkerThread, INFINITE );

  00f5d	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  00f62	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hStdOutWorkerThread$[rsp]
  00f67	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 4206 :         CloseHandle( hStdOutWorkerThread );

  00f6d	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hStdOutWorkerThread$[rsp]
  00f72	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4207 : 
; 4208 :         if ( !pnWriteToChildStdinFD )

  00f78	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  00f81	75 2b		 jne	 SHORT $LN225@w32_poor_m

; 4209 :         {
; 4210 :             DeleteCriticalSection( &pPipedProcessCtl->csLock );

  00f83	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00f88	48 83 c0 18	 add	 rax, 24
  00f8c	48 8b c8	 mov	 rcx, rax
  00f8f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 4211 :             free( pPipedProcessCtl->pszBuffer );

  00f95	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  00f9a	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00f9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4212 :             free( pPipedProcessCtl );

  00fa3	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  00fa8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN225@w32_poor_m:

; 4213 :         }
; 4214 :         free( pPipedStdOutThreadCtl );

  00fae	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pPipedStdOutThreadCtl$[rsp]
  00fb3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4215 :         free( pPipedStdErrThreadCtl );

  00fb9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR pPipedStdErrThreadCtl$[rsp]
  00fbe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4216 : 
; 4217 :         errno = rc;

  00fc4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00fca	8b 4c 24 50	 mov	 ecx, DWORD PTR rc$[rsp]
  00fce	89 08		 mov	 DWORD PTR [rax], ecx

; 4218 :         return -1;

  00fd0	b8 ff ff ff ff	 mov	 eax, -1
  00fd5	e9 81 01 00 00	 jmp	 $LN1@w32_poor_m
$LN212@w32_poor_m:
$LN142@w32_poor_m:

; 4219 :     }
; 4220 : 
; 4221 :     SET_THREAD_NAME_ID( dwThreadId, "w32_pipe_stdERR" );

  00fda	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161736
  00fe1	8b 4c 24 60	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  00fe5	e8 00 00 00 00	 call	 w32_set_thread_name
  00fea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161737
  00ff1	8b 4c 24 60	 mov	 ecx, DWORD PTR dwThreadId$[rsp]
  00ff5	e8 00 00 00 00	 call	 hthread_set_thread_name
  00ffa	33 c0		 xor	 eax, eax
  00ffc	85 c0		 test	 eax, eax
  00ffe	75 da		 jne	 SHORT $LN142@w32_poor_m

; 4222 : 
; 4223 :     // Piped process capture handling...
; 4224 : 
; 4225 :     if ( !pnWriteToChildStdinFD )

  01000	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR pnWriteToChildStdinFD$[rsp], 0
  01009	0f 85 04 01 00
	00		 jne	 $LN226@w32_poor_m

; 4226 :     {
; 4227 :         // We're in control of the process...
; 4228 : 
; 4229 :         // Wait for process to exit...
; 4230 : 
; 4231 :         WaitForSingleObject( piProcInfo.hProcess, INFINITE );

  0100f	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  01014	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR piProcInfo$[rsp]
  0101c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 4232 :         WaitForSingleObject( hStdOutWorkerThread, INFINITE );

  01022	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  01027	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hStdOutWorkerThread$[rsp]
  0102c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 4233 :         WaitForSingleObject( hStdErrWorkerThread, INFINITE );

  01032	ba ff ff ff ff	 mov	 edx, -1			; ffffffffH
  01037	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR hStdErrWorkerThread$[rsp]
  0103f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject

; 4234 : 
; 4235 :         CloseHandle( piProcInfo.hProcess );

  01045	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR piProcInfo$[rsp]
  0104d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4236 :         CloseHandle( hStdOutWorkerThread );

  01053	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hStdOutWorkerThread$[rsp]
  01058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4237 :         CloseHandle( hStdErrWorkerThread );

  0105e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR hStdErrWorkerThread$[rsp]
  01066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN143@w32_poor_m:

; 4238 : 
; 4239 :         // Now print ALL captured messages AT ONCE (if any)...
; 4240 : 
; 4241 :         while (pPipedProcessCtl->nStrLen && isspace( pPipedProcessCtl->pszBuffer[ pPipedProcessCtl->nStrLen - 1 ] ))

  0106c	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  01071	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  01076	74 39		 je	 SHORT $LN144@w32_poor_m
  01078	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  0107d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01081	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  01086	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  01089	0f be 44 01 ff	 movsx	 eax, BYTE PTR [rcx+rax-1]
  0108e	8b c8		 mov	 ecx, eax
  01090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isspace
  01096	85 c0		 test	 eax, eax
  01098	74 17		 je	 SHORT $LN144@w32_poor_m

; 4242 :             pPipedProcessCtl->nStrLen--;

  0109a	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  0109f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  010a3	48 ff c8	 dec	 rax
  010a6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  010ab	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  010af	eb bb		 jmp	 SHORT $LN143@w32_poor_m
$LN144@w32_poor_m:

; 4243 :         if (pPipedProcessCtl->nStrLen)

  010b1	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  010b6	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  010bb	74 29		 je	 SHORT $LN228@w32_poor_m

; 4244 :         {
; 4245 :             pPipedProcessCtl->pszBuffer[ pPipedProcessCtl->nStrLen ] = 0;  // (null terminate)

  010bd	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  010c2	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  010c6	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  010cb	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  010ce	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 4246 :             logmsg( "%s\n", pPipedProcessCtl->pszBuffer );

  010d2	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  010d7	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  010da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161741
  010e1	e8 00 00 00 00	 call	 logmsg
$LN228@w32_poor_m:

; 4247 :         }
; 4248 : 
; 4249 :         // Free resources...
; 4250 : 
; 4251 :         DeleteCriticalSection( &pPipedProcessCtl->csLock );

  010e6	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  010eb	48 83 c0 18	 add	 rax, 24
  010ef	48 8b c8	 mov	 rcx, rax
  010f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 4252 :         free( pPipedProcessCtl->pszBuffer );

  010f8	48 8b 44 24 58	 mov	 rax, QWORD PTR pPipedProcessCtl$[rsp]
  010fd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  01100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4253 :         free( pPipedProcessCtl );

  01106	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pPipedProcessCtl$[rsp]
  0110b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 4254 :     }

  01111	eb 41		 jmp	 SHORT $LN227@w32_poor_m
$LN226@w32_poor_m:

; 4255 :     else
; 4256 :     {
; 4257 :         // Caller is in control of the process...
; 4258 : 
; 4259 :         CloseHandle( piProcInfo.hProcess );

  01113	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR piProcInfo$[rsp]
  0111b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4260 :         CloseHandle( hStdOutWorkerThread );

  01121	48 8b 4c 24 78	 mov	 rcx, QWORD PTR hStdOutWorkerThread$[rsp]
  01126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4261 :         CloseHandle( hStdErrWorkerThread );

  0112c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR hStdErrWorkerThread$[rsp]
  01134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 4262 : 
; 4263 :         // Return a C run-time file descriptor
; 4264 :         // for the write-to-child-stdin HANDLE...
; 4265 : 
; 4266 :         *pnWriteToChildStdinFD = _open_osfhandle( (intptr_t) hOurWriteToStdin, 0 );

  0113a	33 d2		 xor	 edx, edx
  0113c	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR hOurWriteToStdin$[rsp]
  01144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle
  0114a	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR pnWriteToChildStdinFD$[rsp]
  01152	89 01		 mov	 DWORD PTR [rcx], eax
$LN227@w32_poor_m:

; 4267 :     }
; 4268 : 
; 4269 :     // Success!
; 4270 : 
; 4271 :     return piProcInfo.dwProcessId;      // (return process-id to caller)

  01154	8b 84 24 f8 00
	00 00		 mov	 eax, DWORD PTR piProcInfo$[rsp+16]
$LN1@w32_poor_m:

; 4272 : }

  0115b	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  01162	5f		 pop	 rdi
  01163	c3		 ret	 0
w32_poor_mans_fork ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
pCharBuff$ = 48
wait_millisecs$ = 56
w32_get_stdin_char PROC

; 2351 : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2352 :     if (!pCharBuff) {                   // (is this a silly call?)

  0000d	48 83 7c 24 30
	00		 cmp	 QWORD PTR pCharBuff$[rsp], 0
  00013	75 13		 jne	 SHORT $LN2@w32_get_st

; 2353 :         errno = EINVAL;                 // (go away silly person!)

  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0001b	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 2354 :         return -1;                      // (silliness return code)

  00021	b8 ff ff ff ff	 mov	 eax, -1
  00026	eb 56		 jmp	 SHORT $LN1@w32_get_st
$LN2@w32_get_st:

; 2355 :     }
; 2356 : 
; 2357 :     *pCharBuff = 0;                     // (initialize buffer to empty)

  00028	48 8b 44 24 30	 mov	 rax, QWORD PTR pCharBuff$[rsp]
  0002d	c6 00 00	 mov	 BYTE PTR [rax], 0

; 2358 :     CreateReadStdInThread();            // (N.B. only created if needed)

  00030	e8 00 00 00 00	 call	 CreateReadStdInThread

; 2359 : 
; 2360 :     if (WAIT_TIMEOUT == WaitForSingleObject( hStdInAvailable, wait_millisecs ))

  00035	8b 54 24 38	 mov	 edx, DWORD PTR wait_millisecs$[rsp]
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hStdInAvailable
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00046	3d 02 01 00 00	 cmp	 eax, 258		; 00000102H
  0004b	75 04		 jne	 SHORT $LN3@w32_get_st

; 2361 :         return 0;

  0004d	33 c0		 xor	 eax, eax
  0004f	eb 2d		 jmp	 SHORT $LN1@w32_get_st
$LN3@w32_get_st:

; 2362 : 
; 2363 :     *pCharBuff = chStdIn;               // (save the next char right away)

  00051	48 8b 44 24 30	 mov	 rax, QWORD PTR pCharBuff$[rsp]
  00056	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR chStdIn
  0005d	88 08		 mov	 BYTE PTR [rax], cl

; 2364 :     ResetEvent( hStdInAvailable );      // (reset OUR flag for next time)

  0005f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hStdInAvailable
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ResetEvent

; 2365 :     SetEvent( hGotStdIn );              // (allow thread to read next char)

  0006c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR hGotStdIn
  00073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetEvent

; 2366 :     return 1;

  00079	b8 01 00 00 00	 mov	 eax, 1
$LN1@w32_get_st:

; 2367 : }

  0007e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00082	c3		 ret	 0
w32_get_stdin_char ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
sd$ = 32
rc$ = 36
err$ = 40
sock$ = 48
stream$ = 80
w32_fclose PROC

; 3819 : {

$LN14:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@w32_fclose:

; 3820 :     int sd, rc, err;
; 3821 :     SOCKET sock;
; 3822 : 
; 3823 :     ASSERT( stream );

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR stream$[rsp], 0
  0000f	75 5b		 jne	 SHORT $LN8@w32_fclose
$LN7@w32_fclose:
  00011	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161285
  00018	41 b8 ef 0e 00
	00		 mov	 r8d, 3823		; 00000eefH
  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161286
  00025	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161287
  0002c	e8 00 00 00 00	 call	 logmsg
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00037	85 c0		 test	 eax, eax
  00039	74 20		 je	 SHORT $LN9@w32_fclose
  0003b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161289
  00042	41 b8 ef 0e 00
	00		 mov	 r8d, 3823		; 00000eefH
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161290
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161291
  00056	e8 00 00 00 00	 call	 DebuggerTrace
$LN9@w32_fclose:
  0005b	33 c0		 xor	 eax, eax
  0005d	85 c0		 test	 eax, eax
  0005f	75 b0		 jne	 SHORT $LN7@w32_fclose
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00067	85 c0		 test	 eax, eax
  00069	74 01		 je	 SHORT $LN10@w32_fclose
  0006b	cc		 int	 3
$LN10@w32_fclose:
$LN8@w32_fclose:
  0006c	33 c0		 xor	 eax, eax
  0006e	85 c0		 test	 eax, eax
  00070	75 97		 jne	 SHORT $LN4@w32_fclose

; 3824 : 
; 3825 :     sd = fileno( stream );

  00072	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stream$[rsp]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  0007d	89 44 24 20	 mov	 DWORD PTR sd$[rsp], eax

; 3826 : 
; 3827 :     if ( !socket_is_socket( sd ) )

  00081	8b 4c 24 20	 mov	 ecx, DWORD PTR sd$[rsp]
  00085	e8 00 00 00 00	 call	 socket_is_socket
  0008a	85 c0		 test	 eax, eax
  0008c	75 0d		 jne	 SHORT $LN11@w32_fclose

; 3828 :         return fclose( stream );

  0008e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stream$[rsp]
  00093	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  00099	eb 6a		 jmp	 SHORT $LN1@w32_fclose
$LN11@w32_fclose:

; 3829 : 
; 3830 :     // (SOCKETs get special handling)
; 3831 : 
; 3832 :     sock = (SOCKET) _get_osfhandle( sd );

  0009b	8b 4c 24 20	 mov	 ecx, DWORD PTR sd$[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  000a5	48 89 44 24 30	 mov	 QWORD PTR sock$[rsp], rax

; 3833 : 
; 3834 :     // Flush the data, close the socket, then deallocate
; 3835 :     // the crt's file descriptor for it by calling fclose.
; 3836 : 
; 3837 :     // Note that the fclose will fail since the closesocket
; 3838 :     // has already closed the o/s handle, but we don't care;
; 3839 :     // all we care about is the crt deallocating its file
; 3840 :     // descriptor for it...
; 3841 : 
; 3842 :     fflush( stream );               // (flush buffers)

  000aa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stream$[rsp]
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 3843 :     shutdown( sock, SD_BOTH);       // (try to be graceful)

  000b5	ba 02 00 00 00	 mov	 edx, 2
  000ba	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sock$[rsp]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_shutdown

; 3844 :     rc  = closesocket( sock );      // (close socket)

  000c5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sock$[rsp]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  000d0	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 3845 :     err = WSAGetLastError();        // (save retcode)

  000d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000da	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax

; 3846 :     fclose( stream );               // (ignore likely error)

  000de	48 8b 4c 24 50	 mov	 rcx, QWORD PTR stream$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose

; 3847 : 
; 3848 :     if ( SOCKET_ERROR == rc )       // (closesocket error?)

  000e9	83 7c 24 24 ff	 cmp	 DWORD PTR rc$[rsp], -1
  000ee	75 13		 jne	 SHORT $LN12@w32_fclose

; 3849 :     {
; 3850 :         errno = err;                // (yes, return error)

  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f6	8b 4c 24 28	 mov	 ecx, DWORD PTR err$[rsp]
  000fa	89 08		 mov	 DWORD PTR [rax], ecx

; 3851 :         return EOF;                 // (failed)

  000fc	b8 ff ff ff ff	 mov	 eax, -1
  00101	eb 02		 jmp	 SHORT $LN1@w32_fclose
$LN12@w32_fclose:

; 3852 :     }
; 3853 :     return 0;                       // (success)

  00103	33 c0		 xor	 eax, eax
$LN1@w32_fclose:

; 3854 : }

  00105	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00109	c3		 ret	 0
w32_fclose ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
bytes$ = 32
rc$ = 36
sd$1 = 40
tv151 = 44
buff$ = 48
vl$ = 56
sock$ = 64
stream$ = 96
format$ = 104
w32_fprintf PROC

; 3774 : {

$LN19:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 3775 :     char* buff = NULL;

  00018	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR buff$[rsp], 0

; 3776 :     int bytes = 0, rc;

  00021	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR bytes$[rsp], 0
$LN4@w32_fprint:

; 3777 :     va_list vl;
; 3778 :     SOCKET sock;
; 3779 : 
; 3780 :     ASSERT( stream && format );

  00029	48 83 7c 24 60
	00		 cmp	 QWORD PTR stream$[rsp], 0
  0002f	74 08		 je	 SHORT $LN12@w32_fprint
  00031	48 83 7c 24 68
	00		 cmp	 QWORD PTR format$[rsp], 0
  00037	75 5b		 jne	 SHORT $LN11@w32_fprint
$LN12@w32_fprint:
$LN7@w32_fprint:
  00039	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161259
  00040	41 b8 c4 0e 00
	00		 mov	 r8d, 3780		; 00000ec4H
  00046	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161260
  0004d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161261
  00054	e8 00 00 00 00	 call	 logmsg
  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0005f	85 c0		 test	 eax, eax
  00061	74 20		 je	 SHORT $LN13@w32_fprint
  00063	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161263
  0006a	41 b8 c4 0e 00
	00		 mov	 r8d, 3780		; 00000ec4H
  00070	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161264
  00077	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161265
  0007e	e8 00 00 00 00	 call	 DebuggerTrace
$LN13@w32_fprint:
  00083	33 c0		 xor	 eax, eax
  00085	85 c0		 test	 eax, eax
  00087	75 b0		 jne	 SHORT $LN7@w32_fprint
  00089	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0008f	85 c0		 test	 eax, eax
  00091	74 01		 je	 SHORT $LN14@w32_fprint
  00093	cc		 int	 3
$LN14@w32_fprint:
$LN11@w32_fprint:
  00094	33 c0		 xor	 eax, eax
  00096	85 c0		 test	 eax, eax
  00098	75 8f		 jne	 SHORT $LN4@w32_fprint

; 3781 : 
; 3782 :     va_start( vl, format );

  0009a	48 8d 44 24 70	 lea	 rax, QWORD PTR format$[rsp+8]
  0009f	48 89 44 24 38	 mov	 QWORD PTR vl$[rsp], rax

; 3783 : 
; 3784 :     {
; 3785 :         int sd = fileno( stream );

  000a4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR stream$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  000af	89 44 24 28	 mov	 DWORD PTR sd$1[rsp], eax

; 3786 :         if ( !socket_is_socket( sd ) )

  000b3	8b 4c 24 28	 mov	 ecx, DWORD PTR sd$1[rsp]
  000b7	e8 00 00 00 00	 call	 socket_is_socket
  000bc	85 c0		 test	 eax, eax
  000be	75 19		 jne	 SHORT $LN15@w32_fprint

; 3787 :             return vfprintf( stream, format, vl );

  000c0	4c 8b 44 24 38	 mov	 r8, QWORD PTR vl$[rsp]
  000c5	48 8b 54 24 68	 mov	 rdx, QWORD PTR format$[rsp]
  000ca	48 8b 4c 24 60	 mov	 rcx, QWORD PTR stream$[rsp]
  000cf	e8 00 00 00 00	 call	 vfprintf
  000d4	e9 d3 00 00 00	 jmp	 $LN1@w32_fprint
$LN15@w32_fprint:

; 3788 :         sock = (SOCKET) _get_osfhandle( sd );

  000d9	8b 4c 24 28	 mov	 ecx, DWORD PTR sd$1[rsp]
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  000e3	48 89 44 24 40	 mov	 QWORD PTR sock$[rsp], rax
$LN10@w32_fprint:

; 3789 :     }
; 3790 : 
; 3791 :     do
; 3792 :     {
; 3793 :         free( buff );

  000e8	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buff$[rsp]
  000ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3794 : 
; 3795 :         if ( !( buff = malloc( bytes += 1000 ) ) )

  000f3	8b 44 24 20	 mov	 eax, DWORD PTR bytes$[rsp]
  000f7	05 e8 03 00 00	 add	 eax, 1000		; 000003e8H
  000fc	89 44 24 20	 mov	 DWORD PTR bytes$[rsp], eax
  00100	48 63 44 24 20	 movsxd	 rax, DWORD PTR bytes$[rsp]
  00105	48 8b c8	 mov	 rcx, rax
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0010e	48 89 44 24 30	 mov	 QWORD PTR buff$[rsp], rax
  00113	48 83 7c 24 30
	00		 cmp	 QWORD PTR buff$[rsp], 0
  00119	75 13		 jne	 SHORT $LN16@w32_fprint

; 3796 :         {
; 3797 :             errno = ENOMEM;

  0011b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00121	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 3798 :             return -1;

  00127	b8 ff ff ff ff	 mov	 eax, -1
  0012c	eb 7e		 jmp	 SHORT $LN1@w32_fprint
$LN16@w32_fprint:

; 3799 :         }
; 3800 :     }
; 3801 :     while ( ( rc = vsnprintf( buff, bytes, format, vl ) ) < 0 );

  0012e	48 63 44 24 20	 movsxd	 rax, DWORD PTR bytes$[rsp]
  00133	4c 8b 4c 24 38	 mov	 r9, QWORD PTR vl$[rsp]
  00138	4c 8b 44 24 68	 mov	 r8, QWORD PTR format$[rsp]
  0013d	48 8b d0	 mov	 rdx, rax
  00140	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buff$[rsp]
  00145	e8 00 00 00 00	 call	 w32_vsnprintf
  0014a	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  0014e	83 7c 24 24 00	 cmp	 DWORD PTR rc$[rsp], 0
  00153	7c 93		 jl	 SHORT $LN10@w32_fprint

; 3802 : 
; 3803 :     rc = send( sock, buff, bytes = rc, 0 );

  00155	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
  00159	89 44 24 20	 mov	 DWORD PTR bytes$[rsp], eax
  0015d	45 33 c9	 xor	 r9d, r9d
  00160	44 8b 44 24 20	 mov	 r8d, DWORD PTR bytes$[rsp]
  00165	48 8b 54 24 30	 mov	 rdx, QWORD PTR buff$[rsp]
  0016a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sock$[rsp]
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  00175	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 3804 : 
; 3805 :     free( buff );

  00179	48 8b 4c 24 30	 mov	 rcx, QWORD PTR buff$[rsp]
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 3806 : 
; 3807 :     if ( SOCKET_ERROR == rc )

  00184	83 7c 24 24 ff	 cmp	 DWORD PTR rc$[rsp], -1
  00189	75 1d		 jne	 SHORT $LN17@w32_fprint

; 3808 :     {
; 3809 :         errno = WSAGetLastError();

  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00191	89 44 24 2c	 mov	 DWORD PTR tv151[rsp], eax
  00195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0019b	8b 4c 24 2c	 mov	 ecx, DWORD PTR tv151[rsp]
  0019f	89 08		 mov	 DWORD PTR [rax], ecx

; 3810 :         return -1;

  001a1	b8 ff ff ff ff	 mov	 eax, -1
  001a6	eb 04		 jmp	 SHORT $LN1@w32_fprint
$LN17@w32_fprint:

; 3811 :     }
; 3812 :     return rc;

  001a8	8b 44 24 24	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@w32_fprint:

; 3813 : }

  001ac	48 83 c4 58	 add	 rsp, 88			; 00000058H
  001b0	c3		 ret	 0
w32_fprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
rc$ = 32
vargs$ = 40
bfr$ = 64
cnt$ = 72
fmt$ = 80
w32_snprintf PROC

; 3761 : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3762 :     int       rc;
; 3763 :     va_list   vargs;
; 3764 :     va_start( vargs, fmt );

  00018	48 8d 44 24 58	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR vargs$[rsp], rax

; 3765 :     rc = w32_vsnprintf( bfr, cnt, fmt, vargs );

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR vargs$[rsp]
  00027	4c 8b 44 24 50	 mov	 r8, QWORD PTR fmt$[rsp]
  0002c	48 8b 54 24 48	 mov	 rdx, QWORD PTR cnt$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR bfr$[rsp]
  00036	e8 00 00 00 00	 call	 w32_vsnprintf
  0003b	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 3766 :     va_end( vargs);

  0003f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR vargs$[rsp], 0

; 3767 :     return rc;

  00048	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 3768 : }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
w32_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
rc$ = 48
bfr$ = 80
cnt$ = 88
fmt$ = 96
vargs$ = 104
w32_vsnprintf PROC

; 3743 : {

$LN4:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3744 :     int rc = _vsnprintf_s( bfr, cnt, _TRUNCATE, fmt, vargs );

  00018	48 8b 44 24 68	 mov	 rax, QWORD PTR vargs$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  00027	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0002e	48 8b 54 24 58	 mov	 rdx, QWORD PTR cnt$[rsp]
  00033	48 8b 4c 24 50	 mov	 rcx, QWORD PTR bfr$[rsp]
  00038	e8 00 00 00 00	 call	 _vsnprintf_s
  0003d	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax

; 3745 :     if (rc < 0)

  00041	83 7c 24 30 00	 cmp	 DWORD PTR rc$[rsp], 0
  00046	7d 13		 jge	 SHORT $LN2@w32_vsnpri

; 3746 :         rc = _vscprintf( fmt, vargs );

  00048	48 8b 54 24 68	 mov	 rdx, QWORD PTR vargs$[rsp]
  0004d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fmt$[rsp]
  00052	e8 00 00 00 00	 call	 _vscprintf
  00057	89 44 24 30	 mov	 DWORD PTR rc$[rsp], eax
$LN2@w32_vsnpri:

; 3747 :     return rc;

  0005b	8b 44 24 30	 mov	 eax, DWORD PTR rc$[rsp]

; 3748 : }

  0005f	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00063	c3		 ret	 0
w32_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
sd$1 = 32
rc$ = 36
tv135 = 40
sock$ = 48
buff$ = 80
size$ = 88
count$ = 96
stream$ = 104
w32_fwrite PROC

; 3711 : {

$LN15:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@w32_fwrite:

; 3712 :     int rc;
; 3713 :     SOCKET sock;
; 3714 : 
; 3715 :     ASSERT( buff && (size * count) && stream );

  00018	48 83 7c 24 50
	00		 cmp	 QWORD PTR buff$[rsp], 0
  0001e	74 18		 je	 SHORT $LN9@w32_fwrite
  00020	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  00025	48 0f af 44 24
	60		 imul	 rax, QWORD PTR count$[rsp]
  0002b	48 85 c0	 test	 rax, rax
  0002e	74 08		 je	 SHORT $LN9@w32_fwrite
  00030	48 83 7c 24 68
	00		 cmp	 QWORD PTR stream$[rsp], 0
  00036	75 5b		 jne	 SHORT $LN8@w32_fwrite
$LN9@w32_fwrite:
$LN7@w32_fwrite:
  00038	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161198
  0003f	41 b8 83 0e 00
	00		 mov	 r8d, 3715		; 00000e83H
  00045	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161199
  0004c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161200
  00053	e8 00 00 00 00	 call	 logmsg
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0005e	85 c0		 test	 eax, eax
  00060	74 20		 je	 SHORT $LN10@w32_fwrite
  00062	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161202
  00069	41 b8 83 0e 00
	00		 mov	 r8d, 3715		; 00000e83H
  0006f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161203
  00076	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161204
  0007d	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@w32_fwrite:
  00082	33 c0		 xor	 eax, eax
  00084	85 c0		 test	 eax, eax
  00086	75 b0		 jne	 SHORT $LN7@w32_fwrite
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0008e	85 c0		 test	 eax, eax
  00090	74 01		 je	 SHORT $LN11@w32_fwrite
  00092	cc		 int	 3
$LN11@w32_fwrite:
$LN8@w32_fwrite:
  00093	33 c0		 xor	 eax, eax
  00095	85 c0		 test	 eax, eax
  00097	0f 85 7b ff ff
	ff		 jne	 $LN4@w32_fwrite

; 3716 : 
; 3717 :     {
; 3718 :         int sd = fileno( stream );

  0009d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR stream$[rsp]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fileno
  000a8	89 44 24 20	 mov	 DWORD PTR sd$1[rsp], eax

; 3719 :         if ( !socket_is_socket( sd ) )

  000ac	8b 4c 24 20	 mov	 ecx, DWORD PTR sd$1[rsp]
  000b0	e8 00 00 00 00	 call	 socket_is_socket
  000b5	85 c0		 test	 eax, eax
  000b7	75 1c		 jne	 SHORT $LN12@w32_fwrite

; 3720 :             return fwrite( buff, size, count, stream );

  000b9	4c 8b 4c 24 68	 mov	 r9, QWORD PTR stream$[rsp]
  000be	4c 8b 44 24 60	 mov	 r8, QWORD PTR count$[rsp]
  000c3	48 8b 54 24 58	 mov	 rdx, QWORD PTR size$[rsp]
  000c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR buff$[rsp]
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  000d3	eb 66		 jmp	 SHORT $LN1@w32_fwrite
$LN12@w32_fwrite:

; 3721 :         sock = (SOCKET) _get_osfhandle( sd );

  000d5	8b 4c 24 20	 mov	 ecx, DWORD PTR sd$1[rsp]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  000df	48 89 44 24 30	 mov	 QWORD PTR sock$[rsp], rax

; 3722 :     }
; 3723 : 
; 3724 :     if ( ( rc = send( sock, buff, (int)(size * count), 0 ) ) == SOCKET_ERROR )

  000e4	48 8b 44 24 58	 mov	 rax, QWORD PTR size$[rsp]
  000e9	48 0f af 44 24
	60		 imul	 rax, QWORD PTR count$[rsp]
  000ef	45 33 c9	 xor	 r9d, r9d
  000f2	44 8b c0	 mov	 r8d, eax
  000f5	48 8b 54 24 50	 mov	 rdx, QWORD PTR buff$[rsp]
  000fa	48 8b 4c 24 30	 mov	 rcx, QWORD PTR sock$[rsp]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_send
  00105	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax
  00109	83 7c 24 24 ff	 cmp	 DWORD PTR rc$[rsp], -1
  0010e	75 1f		 jne	 SHORT $LN13@w32_fwrite

; 3725 :     {
; 3726 :         errno = WSAGetLastError();

  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00116	89 44 24 28	 mov	 DWORD PTR tv135[rsp], eax
  0011a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00120	8b 4c 24 28	 mov	 ecx, DWORD PTR tv135[rsp]
  00124	89 08		 mov	 DWORD PTR [rax], ecx

; 3727 :         return -1;

  00126	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0012d	eb 0c		 jmp	 SHORT $LN1@w32_fwrite
$LN13@w32_fwrite:

; 3728 :     }
; 3729 :     return ( rc / size );

  0012f	48 63 44 24 24	 movsxd	 rax, DWORD PTR rc$[rsp]
  00134	33 d2		 xor	 edx, edx
  00136	48 f7 74 24 58	 div	 QWORD PTR size$[rsp]
$LN1@w32_fwrite:

; 3730 : }

  0013b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0013f	c3		 ret	 0
w32_fwrite ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
pModeTransTab$ = 32
new_flags$ = 40
new_fd$ = 44
new_mode$ = 48
mode_trans_tab$ = 64
__$ArrayPad$ = 384
their_fd$ = 416
their_mode$ = 424
w32_fdopen PROC

; 3645 : {

$LN20:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3646 :     int new_fd, new_flags = 0;

  00022	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR new_flags$[rsp], 0

; 3647 :     const char* new_mode = NULL;

  0002a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR new_mode$[rsp], 0

; 3648 :     MODE_TRANS* pModeTransTab;
; 3649 :     MODE_TRANS  mode_trans_tab[] =

  00033	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161115
  0003a	48 89 44 24 40	 mov	 QWORD PTR mode_trans_tab$[rsp], rax
  0003f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161117
  00046	48 89 44 24 48	 mov	 QWORD PTR mode_trans_tab$[rsp+8], rax
  0004b	c7 44 24 50 00
	80 00 00	 mov	 DWORD PTR mode_trans_tab$[rsp+16], 32768 ; 00008000H
  00053	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161119
  0005a	48 89 44 24 58	 mov	 QWORD PTR mode_trans_tab$[rsp+24], rax
  0005f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161121
  00066	48 89 44 24 60	 mov	 QWORD PTR mode_trans_tab$[rsp+32], rax
  0006b	c7 44 24 68 02
	80 00 00	 mov	 DWORD PTR mode_trans_tab$[rsp+40], 32770 ; 00008002H
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161123
  0007a	48 89 44 24 70	 mov	 QWORD PTR mode_trans_tab$[rsp+48], rax
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161125
  00086	48 89 44 24 78	 mov	 QWORD PTR mode_trans_tab$[rsp+56], rax
  0008b	c7 84 24 80 00
	00 00 02 80 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+64], 32770 ; 00008002H
  00096	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161127
  0009d	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+72], rax
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161129
  000ac	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+80], rax
  000b4	c7 84 24 98 00
	00 00 02 80 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+88], 32770 ; 00008002H
  000bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161131
  000c6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+96], rax
  000ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161133
  000d5	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+104], rax
  000dd	c7 84 24 b0 00
	00 00 01 83 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+112], 33537 ; 00008301H
  000e8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161135
  000ef	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+120], rax
  000f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161137
  000fe	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+128], rax
  00106	c7 84 24 c8 00
	00 00 02 83 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+136], 33538 ; 00008302H
  00111	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161139
  00118	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+144], rax
  00120	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161141
  00127	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+152], rax
  0012f	c7 84 24 e0 00
	00 00 02 83 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+160], 33538 ; 00008302H
  0013a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161143
  00141	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+168], rax
  00149	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161145
  00150	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+176], rax
  00158	c7 84 24 f8 00
	00 00 02 83 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+184], 33538 ; 00008302H
  00163	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161147
  0016a	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+192], rax
  00172	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161149
  00179	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+200], rax
  00181	c7 84 24 10 01
	00 00 09 81 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+208], 33033 ; 00008109H
  0018c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161151
  00193	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+216], rax
  0019b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161153
  001a2	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+224], rax
  001aa	c7 84 24 28 01
	00 00 0a 81 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+232], 33034 ; 0000810aH
  001b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161155
  001bc	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+240], rax
  001c4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161157
  001cb	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+248], rax
  001d3	c7 84 24 40 01
	00 00 0a 81 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+256], 33034 ; 0000810aH
  001de	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161159
  001e5	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+264], rax
  001ed	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG161161
  001f4	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR mode_trans_tab$[rsp+272], rax
  001fc	c7 84 24 58 01
	00 00 0a 81 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+280], 33034 ; 0000810aH
  00207	48 c7 84 24 60
	01 00 00 00 00
	00 00		 mov	 QWORD PTR mode_trans_tab$[rsp+288], 0
  00213	48 c7 84 24 68
	01 00 00 00 00
	00 00		 mov	 QWORD PTR mode_trans_tab$[rsp+296], 0
  0021f	c7 84 24 70 01
	00 00 00 00 00
	00		 mov	 DWORD PTR mode_trans_tab$[rsp+304], 0
$LN4@w32_fdopen:

; 3650 :     {
; 3651 :         { "r",   "rbc",  _O_RDONLY                        | _O_BINARY },
; 3652 :         { "r+",  "r+bc", _O_RDWR                          | _O_BINARY },
; 3653 :         { "r+b", "r+bc", _O_RDWR                          | _O_BINARY },
; 3654 :         { "rb+", "r+bc", _O_RDWR                          | _O_BINARY },
; 3655 : 
; 3656 :         { "w",   "wbc",  _O_WRONLY | _O_CREAT | _O_TRUNC  | _O_BINARY },
; 3657 :         { "w+",  "w+bc", _O_RDWR   | _O_CREAT | _O_TRUNC  | _O_BINARY },
; 3658 :         { "w+b", "w+bc", _O_RDWR   | _O_CREAT | _O_TRUNC  | _O_BINARY },
; 3659 :         { "wb+", "w+bc", _O_RDWR   | _O_CREAT | _O_TRUNC  | _O_BINARY },
; 3660 : 
; 3661 :         { "a",   "abc",  _O_WRONLY | _O_CREAT | _O_APPEND | _O_BINARY },
; 3662 :         { "a+",  "a+bc", _O_RDWR   | _O_CREAT | _O_APPEND | _O_BINARY },
; 3663 :         { "a+b", "a+bc", _O_RDWR   | _O_CREAT | _O_APPEND | _O_BINARY },
; 3664 :         { "ab+", "a+bc", _O_RDWR   | _O_CREAT | _O_APPEND | _O_BINARY },
; 3665 : 
; 3666 :         { NULL, NULL, 0 }
; 3667 :     };
; 3668 : 
; 3669 :     ASSERT( their_mode );

  0022a	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR their_mode$[rsp], 0
  00233	75 5b		 jne	 SHORT $LN11@w32_fdopen
$LN7@w32_fdopen:
  00235	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161163
  0023c	41 b8 55 0e 00
	00		 mov	 r8d, 3669		; 00000e55H
  00242	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161164
  00249	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161165
  00250	e8 00 00 00 00	 call	 logmsg
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0025b	85 c0		 test	 eax, eax
  0025d	74 20		 je	 SHORT $LN12@w32_fdopen
  0025f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG161167
  00266	41 b8 55 0e 00
	00		 mov	 r8d, 3669		; 00000e55H
  0026c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161168
  00273	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161169
  0027a	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@w32_fdopen:
  0027f	33 c0		 xor	 eax, eax
  00281	85 c0		 test	 eax, eax
  00283	75 b0		 jne	 SHORT $LN7@w32_fdopen
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0028b	85 c0		 test	 eax, eax
  0028d	74 01		 je	 SHORT $LN13@w32_fdopen
  0028f	cc		 int	 3
$LN13@w32_fdopen:
$LN11@w32_fdopen:
  00290	33 c0		 xor	 eax, eax
  00292	85 c0		 test	 eax, eax
  00294	75 94		 jne	 SHORT $LN4@w32_fdopen

; 3670 : 
; 3671 :     // (we're only interested in socket calls)
; 3672 : 
; 3673 :     if ( !socket_is_socket( their_fd ) )

  00296	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR their_fd$[rsp]
  0029d	e8 00 00 00 00	 call	 socket_is_socket
  002a2	85 c0		 test	 eax, eax
  002a4	75 1a		 jne	 SHORT $LN14@w32_fdopen

; 3674 :         return _fdopen( their_fd, their_mode );

  002a6	48 8b 94 24 a8
	01 00 00	 mov	 rdx, QWORD PTR their_mode$[rsp]
  002ae	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR their_fd$[rsp]
  002b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fdopen
  002bb	e9 b2 00 00 00	 jmp	 $LN1@w32_fdopen
$LN14@w32_fdopen:

; 3675 : 
; 3676 :     // The passed "file descriptor" is actually a SOCKET handle...
; 3677 : 
; 3678 :     // Translate their original mode to our new mode
; 3679 :     // and determine what flags we should use in our
; 3680 :     // call to _open_osfhandle()...
; 3681 : 
; 3682 :     if ( their_mode )

  002c0	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR their_mode$[rsp], 0
  002c9	74 5c		 je	 SHORT $LN15@w32_fdopen

; 3683 :         for (pModeTransTab = mode_trans_tab; pModeTransTab->old_mode; pModeTransTab++)

  002cb	48 8d 44 24 40	 lea	 rax, QWORD PTR mode_trans_tab$[rsp]
  002d0	48 89 44 24 20	 mov	 QWORD PTR pModeTransTab$[rsp], rax
  002d5	eb 0e		 jmp	 SHORT $LN10@w32_fdopen
$LN8@w32_fdopen:
  002d7	48 8b 44 24 20	 mov	 rax, QWORD PTR pModeTransTab$[rsp]
  002dc	48 83 c0 18	 add	 rax, 24
  002e0	48 89 44 24 20	 mov	 QWORD PTR pModeTransTab$[rsp], rax
$LN10@w32_fdopen:
  002e5	48 8b 44 24 20	 mov	 rax, QWORD PTR pModeTransTab$[rsp]
  002ea	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  002ee	74 37		 je	 SHORT $LN9@w32_fdopen

; 3684 :             if ( strcmp( their_mode, pModeTransTab->old_mode ) == 0 )

  002f0	48 8b 44 24 20	 mov	 rax, QWORD PTR pModeTransTab$[rsp]
  002f5	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  002f8	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR their_mode$[rsp]
  00300	e8 00 00 00 00	 call	 strcmp
  00305	85 c0		 test	 eax, eax
  00307	75 1c		 jne	 SHORT $LN16@w32_fdopen

; 3685 :             {
; 3686 :                 new_mode  = pModeTransTab->new_mode;

  00309	48 8b 44 24 20	 mov	 rax, QWORD PTR pModeTransTab$[rsp]
  0030e	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  00312	48 89 44 24 30	 mov	 QWORD PTR new_mode$[rsp], rax

; 3687 :                 new_flags = pModeTransTab->new_flags;

  00317	48 8b 44 24 20	 mov	 rax, QWORD PTR pModeTransTab$[rsp]
  0031c	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0031f	89 44 24 28	 mov	 DWORD PTR new_flags$[rsp], eax

; 3688 :                 break;

  00323	eb 02		 jmp	 SHORT $LN9@w32_fdopen
$LN16@w32_fdopen:

; 3689 :             }

  00325	eb b0		 jmp	 SHORT $LN8@w32_fdopen
$LN9@w32_fdopen:
$LN15@w32_fdopen:

; 3690 : 
; 3691 :     if ( !new_mode )

  00327	48 83 7c 24 30
	00		 cmp	 QWORD PTR new_mode$[rsp], 0
  0032d	75 10		 jne	 SHORT $LN17@w32_fdopen

; 3692 :     {
; 3693 :         errno = EINVAL;

  0032f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00335	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 3694 :         return NULL;

  0033b	33 c0		 xor	 eax, eax
  0033d	eb 33		 jmp	 SHORT $LN1@w32_fdopen
$LN17@w32_fdopen:

; 3695 :     }
; 3696 : 
; 3697 :     // Allocate a CRT file descriptor integer for this SOCKET...
; 3698 : 
; 3699 :     if ( ( new_fd = _open_osfhandle( their_fd, new_flags ) ) < 0 )

  0033f	48 63 84 24 a0
	01 00 00	 movsxd	 rax, DWORD PTR their_fd$[rsp]
  00347	8b 54 24 28	 mov	 edx, DWORD PTR new_flags$[rsp]
  0034b	48 8b c8	 mov	 rcx, rax
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__open_osfhandle
  00354	89 44 24 2c	 mov	 DWORD PTR new_fd$[rsp], eax
  00358	83 7c 24 2c 00	 cmp	 DWORD PTR new_fd$[rsp], 0
  0035d	7d 04		 jge	 SHORT $LN18@w32_fdopen

; 3700 :         return NULL;  // (errno already set)

  0035f	33 c0		 xor	 eax, eax
  00361	eb 0f		 jmp	 SHORT $LN1@w32_fdopen
$LN18@w32_fdopen:

; 3701 : 
; 3702 :     // Now we should be able to do the actual fdopen...
; 3703 : 
; 3704 :     return _fdopen( new_fd, new_mode );

  00363	48 8b 54 24 30	 mov	 rdx, QWORD PTR new_mode$[rsp]
  00368	8b 4c 24 2c	 mov	 ecx, DWORD PTR new_fd$[rsp]
  0036c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fdopen
$LN1@w32_fdopen:

; 3705 : }

  00372	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037a	48 33 cc	 xor	 rcx, rsp
  0037d	e8 00 00 00 00	 call	 __security_check_cookie
  00382	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  00389	c3		 ret	 0
w32_fdopen ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
nPort$1 = 32
nPort$2 = 36
tv82 = 40
tv128 = 44
nScopeId$3 = 48
af$ = 80
src$ = 88
dst$ = 96
w32_inet_pton PROC

; 3580 : {

$LN12:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3581 :     // "The inet_pton() function shall return 1 if the conversion succeeds,
; 3582 :     // with the address pointed to by dst in network byte order. It shall
; 3583 :     // return 0 if the input is not a valid IPv4 dotted-decimal string or
; 3584 :     // a valid IPv6 address string, or -1 with errno set to [EAFNOSUPPORT]
; 3585 :     // if the af argument is unknown.
; 3586 : 
; 3587 :     // [EAFNOSUPPORT]   The af argument is invalid.
; 3588 : 
; 3589 :     if (!g_hNtdll_dll && !(g_hNtdll_dll = LoadLibraryA( "ntdll.dll" )))

  00012	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hNtdll_dll, 0
  0001a	75 31		 jne	 SHORT $LN2@w32_inet_p
  0001c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161078
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00029	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_hNtdll_dll, rax
  00030	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hNtdll_dll, 0
  00038	75 13		 jne	 SHORT $LN2@w32_inet_p

; 3590 :     {
; 3591 :         errno = ENOENT;

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00040	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 3592 :         return FALSE;

  00046	33 c0		 xor	 eax, eax
  00048	e9 0c 01 00 00	 jmp	 $LN1@w32_inet_p
$LN2@w32_inet_p:

; 3593 :     }
; 3594 : 
; 3595 :     if (af == AF_INET)

  0004d	83 7c 24 50 02	 cmp	 DWORD PTR af$[rsp], 2
  00052	75 78		 jne	 SHORT $LN3@w32_inet_p

; 3596 :     {
; 3597 :         USHORT nPort;
; 3598 : 
; 3599 :         if (! g_pRtlIpv4StringToAddressExA &&

  00054	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv4StringToAddressExA, 0
  0005c	75 38		 jne	 SHORT $LN4@w32_inet_p
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161081
  00065	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hNtdll_dll
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00072	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_pRtlIpv4StringToAddressExA, rax
  00079	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv4StringToAddressExA, 0
  00081	75 13		 jne	 SHORT $LN4@w32_inet_p

; 3600 :             !(g_pRtlIpv4StringToAddressExA =
; 3601 :                (PRTLIPV4STRINGTOADDRESSEXA) GetProcAddress( g_hNtdll_dll,
; 3602 :                 "RtlIpv4StringToAddressExA" )))
; 3603 :         {
; 3604 :             errno = ENOENT;

  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00089	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 3605 :             return FALSE;

  0008f	33 c0		 xor	 eax, eax
  00091	e9 c3 00 00 00	 jmp	 $LN1@w32_inet_p
$LN4@w32_inet_p:

; 3606 :         }
; 3607 : 
; 3608 :         return (g_pRtlIpv4StringToAddressExA( src, FALSE, dst, &nPort ) == NO_ERROR) ? TRUE : FALSE;

  00096	4c 8d 4c 24 20	 lea	 r9, QWORD PTR nPort$1[rsp]
  0009b	4c 8b 44 24 60	 mov	 r8, QWORD PTR dst$[rsp]
  000a0	33 d2		 xor	 edx, edx
  000a2	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR g_pRtlIpv4StringToAddressExA
  000ad	85 c0		 test	 eax, eax
  000af	75 0a		 jne	 SHORT $LN8@w32_inet_p
  000b1	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  000b9	eb 08		 jmp	 SHORT $LN9@w32_inet_p
$LN8@w32_inet_p:
  000bb	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN9@w32_inet_p:
  000c3	8b 44 24 28	 mov	 eax, DWORD PTR tv82[rsp]
  000c7	e9 8d 00 00 00	 jmp	 $LN1@w32_inet_p
$LN3@w32_inet_p:

; 3609 :     }
; 3610 : 
; 3611 : #if defined(ENABLE_IPV6)
; 3612 :     if (af == AF_INET6)

  000cc	83 7c 24 50 17	 cmp	 DWORD PTR af$[rsp], 23
  000d1	75 75		 jne	 SHORT $LN5@w32_inet_p

; 3613 :     {
; 3614 :         ULONG nScopeId;
; 3615 :         USHORT nPort;
; 3616 : 
; 3617 :         if (! g_pRtlIpv6StringToAddressExA &&

  000d3	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv6StringToAddressExA, 0
  000db	75 35		 jne	 SHORT $LN6@w32_inet_p
  000dd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161084
  000e4	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hNtdll_dll
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  000f1	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_pRtlIpv6StringToAddressExA, rax
  000f8	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv6StringToAddressExA, 0
  00100	75 10		 jne	 SHORT $LN6@w32_inet_p

; 3618 :             !(g_pRtlIpv6StringToAddressExA =
; 3619 :                (PRTLIPV6STRINGTOADDRESSEXA) GetProcAddress( g_hNtdll_dll,
; 3620 :                 "RtlIpv6StringToAddressExA" )))
; 3621 :         {
; 3622 :             errno = ENOENT;

  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00108	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 3623 :             return FALSE;

  0010e	33 c0		 xor	 eax, eax
  00110	eb 47		 jmp	 SHORT $LN1@w32_inet_p
$LN6@w32_inet_p:

; 3624 :         }
; 3625 : 
; 3626 :         return (g_pRtlIpv6StringToAddressExA( src, dst, &nScopeId, &nPort ) == NO_ERROR) ? TRUE : FALSE;

  00112	4c 8d 4c 24 24	 lea	 r9, QWORD PTR nPort$2[rsp]
  00117	4c 8d 44 24 30	 lea	 r8, QWORD PTR nScopeId$3[rsp]
  0011c	48 8b 54 24 60	 mov	 rdx, QWORD PTR dst$[rsp]
  00121	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR g_pRtlIpv6StringToAddressExA
  0012c	85 c0		 test	 eax, eax
  0012e	75 0a		 jne	 SHORT $LN10@w32_inet_p
  00130	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR tv128[rsp], 1
  00138	eb 08		 jmp	 SHORT $LN11@w32_inet_p
$LN10@w32_inet_p:
  0013a	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv128[rsp], 0
$LN11@w32_inet_p:
  00142	8b 44 24 2c	 mov	 eax, DWORD PTR tv128[rsp]
  00146	eb 11		 jmp	 SHORT $LN1@w32_inet_p
$LN5@w32_inet_p:

; 3627 :     }
; 3628 : #endif /* defined(ENABLE_IPV6) */
; 3629 :     errno = EAFNOSUPPORT;

  00148	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0014e	c7 00 66 00 00
	00		 mov	 DWORD PTR [rax], 102	; 00000066H

; 3630 :     return -1;

  00154	b8 ff ff ff ff	 mov	 eax, -1
$LN1@w32_inet_p:

; 3631 : }

  00159	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0015d	c3		 ret	 0
w32_inet_pton ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
len$ = 48
af$ = 80
src$ = 88
dst$ = 96
size$ = 104
w32_inet_ntop PROC

; 3517 : {

$LN10:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 3518 :     ULONG len = size;

  00017	8b 44 24 68	 mov	 eax, DWORD PTR size$[rsp]
  0001b	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 3519 : 
; 3520 :     // "The inet_ntop() function shall return a pointer to the buffer containing
; 3521 :     // the text string if the conversion succeeds, and NULL otherwise, and set errno
; 3522 :     // to indicate the error."
; 3523 : 
; 3524 :     // [EAFNOSUPPORT]   The af argument is invalid.
; 3525 :     // [ENOSPC]         The size of the inet_ntop() result buffer is inadequate.
; 3526 : 
; 3527 :     if (!g_hNtdll_dll && !(g_hNtdll_dll = LoadLibraryA( "ntdll.dll" )))

  0001f	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hNtdll_dll, 0
  00027	75 31		 jne	 SHORT $LN2@w32_inet_n
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG161056
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00036	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_hNtdll_dll, rax
  0003d	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hNtdll_dll, 0
  00045	75 13		 jne	 SHORT $LN2@w32_inet_n

; 3528 :     {
; 3529 :         errno = ENOENT;

  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004d	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 3530 :         return NULL;

  00053	33 c0		 xor	 eax, eax
  00055	e9 0f 01 00 00	 jmp	 $LN1@w32_inet_n
$LN2@w32_inet_n:

; 3531 :     }
; 3532 : 
; 3533 :     if (af == AF_INET)

  0005a	83 7c 24 50 02	 cmp	 DWORD PTR af$[rsp], 2
  0005f	75 7a		 jne	 SHORT $LN3@w32_inet_n

; 3534 :     {
; 3535 :         if (! g_pRtlIpv4AddressToStringExA &&

  00061	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv4AddressToStringExA, 0
  00069	75 38		 jne	 SHORT $LN4@w32_inet_n
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161059
  00072	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hNtdll_dll
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  0007f	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_pRtlIpv4AddressToStringExA, rax
  00086	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv4AddressToStringExA, 0
  0008e	75 13		 jne	 SHORT $LN4@w32_inet_n

; 3536 :             !(g_pRtlIpv4AddressToStringExA =
; 3537 :                (PRTLIPV4ADDRESSTOSTRINGEXA) GetProcAddress( g_hNtdll_dll,
; 3538 :                 "RtlIpv4AddressToStringExA" )))
; 3539 :         {
; 3540 :             errno = ENOENT;

  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00096	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 3541 :             return NULL;

  0009c	33 c0		 xor	 eax, eax
  0009e	e9 c6 00 00 00	 jmp	 $LN1@w32_inet_n
$LN4@w32_inet_n:

; 3542 :         }
; 3543 : 
; 3544 :         if (g_pRtlIpv4AddressToStringExA( src, 0, dst, &len ) == NO_ERROR)

  000a3	4c 8d 4c 24 30	 lea	 r9, QWORD PTR len$[rsp]
  000a8	4c 8b 44 24 60	 mov	 r8, QWORD PTR dst$[rsp]
  000ad	33 d2		 xor	 edx, edx
  000af	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR g_pRtlIpv4AddressToStringExA
  000ba	85 c0		 test	 eax, eax
  000bc	75 0a		 jne	 SHORT $LN5@w32_inet_n

; 3545 :             return dst;

  000be	48 8b 44 24 60	 mov	 rax, QWORD PTR dst$[rsp]
  000c3	e9 a1 00 00 00	 jmp	 $LN1@w32_inet_n
$LN5@w32_inet_n:

; 3546 : 
; 3547 :         errno = ENOSPC;

  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ce	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 3548 :         return NULL;

  000d4	33 c0		 xor	 eax, eax
  000d6	e9 8e 00 00 00	 jmp	 $LN1@w32_inet_n
$LN3@w32_inet_n:

; 3549 :     }
; 3550 : 
; 3551 : #if defined(ENABLE_IPV6)
; 3552 : 
; 3553 :     if (af == AF_INET6)

  000db	83 7c 24 50 17	 cmp	 DWORD PTR af$[rsp], 23
  000e0	75 79		 jne	 SHORT $LN6@w32_inet_n

; 3554 :     {
; 3555 :         if (! g_pRtlIpv6AddressToStringExA &&

  000e2	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv6AddressToStringExA, 0
  000ea	75 35		 jne	 SHORT $LN7@w32_inet_n
  000ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG161063
  000f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hNtdll_dll
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00100	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_pRtlIpv6AddressToStringExA, rax
  00107	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pRtlIpv6AddressToStringExA, 0
  0010f	75 10		 jne	 SHORT $LN7@w32_inet_n

; 3556 :             !(g_pRtlIpv6AddressToStringExA =
; 3557 :                (PRTLIPV6ADDRESSTOSTRINGEXA) GetProcAddress( g_hNtdll_dll,
; 3558 :                 "RtlIpv6AddressToStringExA" )))
; 3559 :         {
; 3560 :             errno = ENOENT;

  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00117	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2

; 3561 :             return NULL;

  0011d	33 c0		 xor	 eax, eax
  0011f	eb 48		 jmp	 SHORT $LN1@w32_inet_n
$LN7@w32_inet_n:

; 3562 :         }
; 3563 : 
; 3564 :         if (g_pRtlIpv6AddressToStringExA( src, 0, 0, dst, &len ) == NO_ERROR)

  00121	48 8d 44 24 30	 lea	 rax, QWORD PTR len$[rsp]
  00126	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR dst$[rsp]
  00130	45 33 c0	 xor	 r8d, r8d
  00133	33 d2		 xor	 edx, edx
  00135	48 8b 4c 24 58	 mov	 rcx, QWORD PTR src$[rsp]
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR g_pRtlIpv6AddressToStringExA
  00140	85 c0		 test	 eax, eax
  00142	75 07		 jne	 SHORT $LN8@w32_inet_n

; 3565 :             return dst;

  00144	48 8b 44 24 60	 mov	 rax, QWORD PTR dst$[rsp]
  00149	eb 1e		 jmp	 SHORT $LN1@w32_inet_n
$LN8@w32_inet_n:

; 3566 : 
; 3567 :         errno = ENOSPC;

  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00151	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 3568 :         return NULL;

  00157	33 c0		 xor	 eax, eax
  00159	eb 0e		 jmp	 SHORT $LN1@w32_inet_n
$LN6@w32_inet_n:

; 3569 :     }
; 3570 : #endif /* defined(ENABLE_IPV6) */
; 3571 : 
; 3572 :     errno = EAFNOSUPPORT;

  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00161	c7 00 66 00 00
	00		 mov	 DWORD PTR [rax], 102	; 00000066H

; 3573 :     return NULL;

  00167	33 c0		 xor	 eax, eax
$LN1@w32_inet_n:

; 3574 : }

  00169	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0016d	c3		 ret	 0
w32_inet_ntop ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv75 = 32
ifname$ = 64
w32_if_nametoindex PROC

; 3482 : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3483 :     if (!g_hIphlpapi_dll)

  00009	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hIphlpapi_dll, 0
  00011	75 14		 jne	 SHORT $LN2@w32_if_nam

; 3484 :         g_hIphlpapi_dll = LoadLibraryA( "iphlpapi.dll" );

  00013	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160985
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00020	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_hIphlpapi_dll, rax
$LN2@w32_if_nam:

; 3485 : 
; 3486 :     if (!g_hIphlpapi_dll)

  00027	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_hIphlpapi_dll, 0
  0002f	75 04		 jne	 SHORT $LN3@w32_if_nam

; 3487 :         return 0;

  00031	33 c0		 xor	 eax, eax
  00033	eb 4c		 jmp	 SHORT $LN1@w32_if_nam
$LN3@w32_if_nam:

; 3488 : 
; 3489 :     if (!g_pIf_NameToIndex)

  00035	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pIf_NameToIndex, 0
  0003d	75 1b		 jne	 SHORT $LN4@w32_if_nam

; 3490 :         g_pIf_NameToIndex = (PIF_NAMETOINDEX)

  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160988
  00046	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR g_hIphlpapi_dll
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00053	48 89 05 00 00
	00 00		 mov	 QWORD PTR g_pIf_NameToIndex, rax
$LN4@w32_if_nam:

; 3491 :             GetProcAddress( g_hIphlpapi_dll, "if_nametoindex" );
; 3492 : 
; 3493 :     return g_pIf_NameToIndex ? g_pIf_NameToIndex( ifname ) : 0;

  0005a	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR g_pIf_NameToIndex, 0
  00062	74 11		 je	 SHORT $LN6@w32_if_nam
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ifname$[rsp]
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR g_pIf_NameToIndex
  0006f	89 44 24 20	 mov	 DWORD PTR tv75[rsp], eax
  00073	eb 08		 jmp	 SHORT $LN7@w32_if_nam
$LN6@w32_if_nam:
  00075	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN7@w32_if_nam:
  0007d	8b 44 24 20	 mov	 eax, DWORD PTR tv75[rsp]
$LN1@w32_if_nam:

; 3494 : }

  00081	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00085	c3		 ret	 0
w32_if_nametoindex ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
rc$ = 64
select_timeout$ = 72
nfds$ = 96
pReadSet$ = 104
pWriteSet$ = 112
pExceptSet$ = 120
pTimeout$ = 128
pSigmask$ = 136
pszSourceFile$ = 144
nLineNumber$ = 152
w32_pselect PROC

; 3449 : {

$LN8:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 58	 sub	 rsp, 88			; 00000058H
$LN4@w32_pselec:

; 3450 :     struct timeval  select_timeout;
; 3451 :     int             rc;
; 3452 : 
; 3453 :     UNREFERENCED( pSigmask );

  00017	33 c0		 xor	 eax, eax
  00019	85 c0		 test	 eax, eax
  0001b	75 fa		 jne	 SHORT $LN4@w32_pselec

; 3454 : 
; 3455 :     if (!pTimeout)

  0001d	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR pTimeout$[rsp], 0
  00026	75 3f		 jne	 SHORT $LN5@w32_pselec

; 3456 :         rc = w32_select( nfds, pReadSet, pWriteSet, pExceptSet, NULL,

  00028	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR nLineNumber$[rsp]
  0002f	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00033	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pszSourceFile$[rsp]
  0003b	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00040	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00049	4c 8b 4c 24 78	 mov	 r9, QWORD PTR pExceptSet$[rsp]
  0004e	4c 8b 44 24 70	 mov	 r8, QWORD PTR pWriteSet$[rsp]
  00053	48 8b 54 24 68	 mov	 rdx, QWORD PTR pReadSet$[rsp]
  00058	8b 4c 24 60	 mov	 ecx, DWORD PTR nfds$[rsp]
  0005c	e8 00 00 00 00	 call	 w32_select
  00061	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
  00065	eb 63		 jmp	 SHORT $LN6@w32_pselec
$LN5@w32_pselec:

; 3457 :                          pszSourceFile, nLineNumber );
; 3458 :     else
; 3459 :     {
; 3460 :         select_timeout.tv_sec  = pTimeout->tv_sec;

  00067	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pTimeout$[rsp]
  0006f	8b 00		 mov	 eax, DWORD PTR [rax]
  00071	89 44 24 48	 mov	 DWORD PTR select_timeout$[rsp], eax

; 3461 :         select_timeout.tv_usec = pTimeout->tv_nsec / 1000;

  00075	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pTimeout$[rsp]
  0007d	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00080	99		 cdq
  00081	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00086	f7 f9		 idiv	 ecx
  00088	89 44 24 4c	 mov	 DWORD PTR select_timeout$[rsp+4], eax

; 3462 : 
; 3463 :         rc = w32_select( nfds, pReadSet, pWriteSet, pExceptSet, &select_timeout,

  0008c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR nLineNumber$[rsp]
  00093	89 44 24 30	 mov	 DWORD PTR [rsp+48], eax
  00097	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR pszSourceFile$[rsp]
  0009f	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000a4	48 8d 44 24 48	 lea	 rax, QWORD PTR select_timeout$[rsp]
  000a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ae	4c 8b 4c 24 78	 mov	 r9, QWORD PTR pExceptSet$[rsp]
  000b3	4c 8b 44 24 70	 mov	 r8, QWORD PTR pWriteSet$[rsp]
  000b8	48 8b 54 24 68	 mov	 rdx, QWORD PTR pReadSet$[rsp]
  000bd	8b 4c 24 60	 mov	 ecx, DWORD PTR nfds$[rsp]
  000c1	e8 00 00 00 00	 call	 w32_select
  000c6	89 44 24 40	 mov	 DWORD PTR rc$[rsp], eax
$LN6@w32_pselec:

; 3464 :                          pszSourceFile, nLineNumber );
; 3465 :     }
; 3466 : 
; 3467 :     return rc;

  000ca	8b 44 24 40	 mov	 eax, DWORD PTR rc$[rsp]

; 3468 : }

  000ce	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000d2	c3		 ret	 0
w32_pselect ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
dwWaitMilliSeconds$ = 64
bSocketFound$ = 68
dwHandles$ = 72
bNonSocketFound$ = 76
bExceptSetNonSocketFound$ = 80
dwWaitRetCode$ = 84
bExceptSetSocketFound$ = 88
arHandles$ = 96
buf$1 = 16480
buf$2 = 16736
buf$3 = 16992
__$ArrayPad$ = 17248
nfds$ = 17280
pReadSet$ = 17288
pWriteSet$ = 17296
pExceptSet$ = 17304
pTimeVal$ = 17312
pszSourceFile$ = 17320
nLineNumber$ = 17328
w32_select PROC

; 3282 : {

$LN41:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	b8 78 43 00 00	 mov	 eax, 17272		; 00004378H
  00018	e8 00 00 00 00	 call	 __chkstk
  0001d	48 2b e0	 sub	 rsp, rax
  00020	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00027	48 33 c4	 xor	 rax, rsp
  0002a	48 89 84 24 60
	43 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3283 :     HANDLE   arHandles[ 2 * FD_SETSIZE ];   // (max read + write set size)
; 3284 :     DWORD    dwHandles                 = 0;

  00032	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR dwHandles$[rsp], 0

; 3285 : 
; 3286 :     BOOL     bSocketFound              = FALSE;

  0003a	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR bSocketFound$[rsp], 0

; 3287 :     BOOL     bNonSocketFound           = FALSE;

  00042	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR bNonSocketFound$[rsp], 0

; 3288 : 
; 3289 :     BOOL     bExceptSetSocketFound     = FALSE;

  0004a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR bExceptSetSocketFound$[rsp], 0

; 3290 :     BOOL     bExceptSetNonSocketFound  = FALSE;

  00052	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR bExceptSetNonSocketFound$[rsp], 0

; 3291 : 
; 3292 :     DWORD    dwWaitMilliSeconds        = 0;

  0005a	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR dwWaitMilliSeconds$[rsp], 0

; 3293 :     DWORD    dwWaitRetCode             = 0;

  00062	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR dwWaitRetCode$[rsp], 0
$LN4@w32_select:

; 3294 : 
; 3295 :     UNREFERENCED( nfds );

  0006a	33 c0		 xor	 eax, eax
  0006c	85 c0		 test	 eax, eax
  0006e	75 fa		 jne	 SHORT $LN4@w32_select

; 3296 : 
; 3297 :     // Quick check for 'timer.c' call wherein all passed fd_set pointers are NULL...
; 3298 : 
; 3299 :     if ( !pReadSet && !pWriteSet && !pExceptSet )

  00070	48 83 bc 24 88
	43 00 00 00	 cmp	 QWORD PTR pReadSet$[rsp], 0
  00079	0f 85 91 01 00
	00		 jne	 $LN17@w32_select
  0007f	48 83 bc 24 90
	43 00 00 00	 cmp	 QWORD PTR pWriteSet$[rsp], 0
  00088	0f 85 82 01 00
	00		 jne	 $LN17@w32_select
  0008e	48 83 bc 24 98
	43 00 00 00	 cmp	 QWORD PTR pExceptSet$[rsp], 0
  00097	0f 85 73 01 00
	00		 jne	 $LN17@w32_select
$LN7@w32_select:

; 3300 :     {
; 3301 :         ASSERT( pTimeVal );     // (why else would we be called?!)

  0009d	48 83 bc 24 a0
	43 00 00 00	 cmp	 QWORD PTR pTimeVal$[rsp], 0
  000a6	75 5b		 jne	 SHORT $LN18@w32_select
$LN10@w32_select:
  000a8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160866
  000af	41 b8 e5 0c 00
	00		 mov	 r8d, 3301		; 00000ce5H
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160867
  000bc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160868
  000c3	e8 00 00 00 00	 call	 logmsg
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000ce	85 c0		 test	 eax, eax
  000d0	74 20		 je	 SHORT $LN19@w32_select
  000d2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160870
  000d9	41 b8 e5 0c 00
	00		 mov	 r8d, 3301		; 00000ce5H
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160871
  000e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160872
  000ed	e8 00 00 00 00	 call	 DebuggerTrace
$LN19@w32_select:
  000f2	33 c0		 xor	 eax, eax
  000f4	85 c0		 test	 eax, eax
  000f6	75 b0		 jne	 SHORT $LN10@w32_select
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000fe	85 c0		 test	 eax, eax
  00100	74 01		 je	 SHORT $LN20@w32_select
  00102	cc		 int	 3
$LN20@w32_select:
$LN18@w32_select:
  00103	33 c0		 xor	 eax, eax
  00105	85 c0		 test	 eax, eax
  00107	75 94		 jne	 SHORT $LN7@w32_select

; 3302 : 
; 3303 :         if ( !pTimeVal )

  00109	48 83 bc 24 a0
	43 00 00 00	 cmp	 QWORD PTR pTimeVal$[rsp], 0
  00112	0f 85 95 00 00
	00		 jne	 $LN21@w32_select

; 3304 :         {
; 3305 :             char buf[256];
; 3306 :             MSGBUF(buf, "** Win32 porting error: invalid call to 'w32_select' from %s(%d): NULL args",

  00118	8b 84 24 b0 43
	00 00		 mov	 eax, DWORD PTR nLineNumber$[rsp]
  0011f	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00123	4c 8b 8c 24 a8
	43 00 00	 mov	 r9, QWORD PTR pszSourceFile$[rsp]
  0012b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160875
  00132	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00137	48 8d 8c 24 60
	40 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  0013f	e8 00 00 00 00	 call	 w32_snprintf

; 3307 :                 pszSourceFile, nLineNumber );
; 3308 :             WRMSG(HHC90000, "D", buf);

  00144	b9 01 00 00 00	 mov	 ecx, 1
  00149	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0014f	48 8d 8c 24 60
	40 00 00	 lea	 rcx, QWORD PTR buf$1[rsp]
  00157	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160876
  00163	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00168	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160877
  0016f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00174	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00179	41 b9 03 00 00
	00		 mov	 r9d, 3
  0017f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160878
  00186	ba ec 0c 00 00	 mov	 edx, 3308		; 00000cecH
  0018b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160879
  00192	e8 00 00 00 00	 call	 fwritemsg

; 3309 :             errno = EINVAL;

  00197	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0019d	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 3310 :             return -1;

  001a3	b8 ff ff ff ff	 mov	 eax, -1
  001a8	e9 96 03 00 00	 jmp	 $LN1@w32_select
$LN21@w32_select:

; 3311 :         }
; 3312 : 
; 3313 :         // Sleep for the specified time period...
; 3314 : 
; 3315 :         if ( !pTimeVal->tv_sec && !pTimeVal->tv_usec )

  001ad	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  001b5	83 38 00	 cmp	 DWORD PTR [rax], 0
  001b8	75 15		 jne	 SHORT $LN22@w32_select
  001ba	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  001c2	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  001c6	75 07		 jne	 SHORT $LN22@w32_select

; 3316 :             sched_yield();

  001c8	e8 00 00 00 00	 call	 sched_yield
  001cd	eb 3a		 jmp	 SHORT $LN23@w32_select
$LN22@w32_select:

; 3317 :         else
; 3318 :         {
; 3319 :             if ( pTimeVal->tv_sec )

  001cf	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  001d7	83 38 00	 cmp	 DWORD PTR [rax], 0
  001da	74 0f		 je	 SHORT $LN24@w32_select

; 3320 :                 sleep( pTimeVal->tv_sec );

  001dc	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  001e4	8b 08		 mov	 ecx, DWORD PTR [rax]
  001e6	e8 00 00 00 00	 call	 sleep
$LN24@w32_select:

; 3321 : 
; 3322 :             if ( pTimeVal->tv_usec )

  001eb	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  001f3	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  001f7	74 10		 je	 SHORT $LN25@w32_select

; 3323 :                 usleep( pTimeVal->tv_usec );

  001f9	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  00201	8b 48 04	 mov	 ecx, DWORD PTR [rax+4]
  00204	e8 00 00 00 00	 call	 usleep
$LN25@w32_select:
$LN23@w32_select:

; 3324 :         }
; 3325 : 
; 3326 :         return 0;

  00209	33 c0		 xor	 eax, eax
  0020b	e9 33 03 00 00	 jmp	 $LN1@w32_select
$LN17@w32_select:

; 3327 :     }
; 3328 : 
; 3329 :     // Check for mixed sets and build HANDLE array...
; 3330 :     // (Note: we don't support except sets for non-sockets)
; 3331 : 
; 3332 :     SelectSet( pReadSet,   &bSocketFound,          &bNonSocketFound,          &dwHandles, arHandles );

  00210	48 8d 44 24 60	 lea	 rax, QWORD PTR arHandles$[rsp]
  00215	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0021a	4c 8d 4c 24 48	 lea	 r9, QWORD PTR dwHandles$[rsp]
  0021f	4c 8d 44 24 4c	 lea	 r8, QWORD PTR bNonSocketFound$[rsp]
  00224	48 8d 54 24 44	 lea	 rdx, QWORD PTR bSocketFound$[rsp]
  00229	48 8b 8c 24 88
	43 00 00	 mov	 rcx, QWORD PTR pReadSet$[rsp]
  00231	e8 00 00 00 00	 call	 SelectSet

; 3333 :     SelectSet( pWriteSet,  &bSocketFound,          &bNonSocketFound,          &dwHandles, arHandles );

  00236	48 8d 44 24 60	 lea	 rax, QWORD PTR arHandles$[rsp]
  0023b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00240	4c 8d 4c 24 48	 lea	 r9, QWORD PTR dwHandles$[rsp]
  00245	4c 8d 44 24 4c	 lea	 r8, QWORD PTR bNonSocketFound$[rsp]
  0024a	48 8d 54 24 44	 lea	 rdx, QWORD PTR bSocketFound$[rsp]
  0024f	48 8b 8c 24 90
	43 00 00	 mov	 rcx, QWORD PTR pWriteSet$[rsp]
  00257	e8 00 00 00 00	 call	 SelectSet

; 3334 :     SelectSet( pExceptSet, &bExceptSetSocketFound, &bExceptSetNonSocketFound, NULL,       NULL      );

  0025c	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00265	45 33 c9	 xor	 r9d, r9d
  00268	4c 8d 44 24 50	 lea	 r8, QWORD PTR bExceptSetNonSocketFound$[rsp]
  0026d	48 8d 54 24 58	 lea	 rdx, QWORD PTR bExceptSetSocketFound$[rsp]
  00272	48 8b 8c 24 98
	43 00 00	 mov	 rcx, QWORD PTR pExceptSet$[rsp]
  0027a	e8 00 00 00 00	 call	 SelectSet

; 3335 : 
; 3336 :     if (0
; 3337 :         || ( bSocketFound    && ( bNonSocketFound || bExceptSetNonSocketFound ) )
; 3338 :         || ( bNonSocketFound && ( bSocketFound    || bExceptSetSocketFound    ) )

  0027f	33 c0		 xor	 eax, eax
  00281	85 c0		 test	 eax, eax
  00283	75 32		 jne	 SHORT $LN27@w32_select
  00285	83 7c 24 44 00	 cmp	 DWORD PTR bSocketFound$[rsp], 0
  0028a	74 0e		 je	 SHORT $LN28@w32_select
  0028c	83 7c 24 4c 00	 cmp	 DWORD PTR bNonSocketFound$[rsp], 0
  00291	75 24		 jne	 SHORT $LN27@w32_select
  00293	83 7c 24 50 00	 cmp	 DWORD PTR bExceptSetNonSocketFound$[rsp], 0
  00298	75 1d		 jne	 SHORT $LN27@w32_select
$LN28@w32_select:
  0029a	83 7c 24 4c 00	 cmp	 DWORD PTR bNonSocketFound$[rsp], 0
  0029f	0f 84 a7 00 00
	00		 je	 $LN26@w32_select
  002a5	83 7c 24 44 00	 cmp	 DWORD PTR bSocketFound$[rsp], 0
  002aa	75 0b		 jne	 SHORT $LN29@w32_select
  002ac	83 7c 24 58 00	 cmp	 DWORD PTR bExceptSetSocketFound$[rsp], 0
  002b1	0f 84 95 00 00
	00		 je	 $LN26@w32_select
$LN29@w32_select:
$LN27@w32_select:

; 3339 :     )
; 3340 :     {
; 3341 :         char buf[256];
; 3342 :         MSGBUF(buf, "** Win32 porting error: invalid call to 'w32_select' from %s(%d): mixed set(s)",

  002b7	8b 84 24 b0 43
	00 00		 mov	 eax, DWORD PTR nLineNumber$[rsp]
  002be	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  002c2	4c 8b 8c 24 a8
	43 00 00	 mov	 r9, QWORD PTR pszSourceFile$[rsp]
  002ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160888
  002d1	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  002d6	48 8d 8c 24 60
	41 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  002de	e8 00 00 00 00	 call	 w32_snprintf

; 3343 :             pszSourceFile, nLineNumber );
; 3344 :         WRMSG(HHC90000, "D", buf);

  002e3	b9 01 00 00 00	 mov	 ecx, 1
  002e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002ee	48 8d 8c 24 60
	41 00 00	 lea	 rcx, QWORD PTR buf$2[rsp]
  002f6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  002fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160889
  00302	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00307	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160890
  0030e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00313	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00318	41 b9 03 00 00
	00		 mov	 r9d, 3
  0031e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160891
  00325	ba 10 0d 00 00	 mov	 edx, 3344		; 00000d10H
  0032a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160892
  00331	e8 00 00 00 00	 call	 fwritemsg

; 3345 :         errno = EBADF;

  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0033c	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 3346 :         return -1;

  00342	b8 ff ff ff ff	 mov	 eax, -1
  00347	e9 f7 01 00 00	 jmp	 $LN1@w32_select
$LN26@w32_select:

; 3347 :     }
; 3348 : 
; 3349 :     if ( bExceptSetNonSocketFound )

  0034c	83 7c 24 50 00	 cmp	 DWORD PTR bExceptSetNonSocketFound$[rsp], 0
  00351	0f 84 95 00 00
	00		 je	 $LN30@w32_select

; 3350 :     {
; 3351 :         char buf[256];
; 3352 :         MSGBUF(buf, "** Win32 porting error: invalid call to 'w32_select' from %s(%d): non-socket except set",

  00357	8b 84 24 b0 43
	00 00		 mov	 eax, DWORD PTR nLineNumber$[rsp]
  0035e	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00362	4c 8b 8c 24 a8
	43 00 00	 mov	 r9, QWORD PTR pszSourceFile$[rsp]
  0036a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160894
  00371	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00376	48 8d 8c 24 60
	42 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  0037e	e8 00 00 00 00	 call	 w32_snprintf

; 3353 :             pszSourceFile, nLineNumber );
; 3354 :         WRMSG(HHC90000, "D", buf);

  00383	b9 01 00 00 00	 mov	 ecx, 1
  00388	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0038e	48 8d 8c 24 60
	42 00 00	 lea	 rcx, QWORD PTR buf$3[rsp]
  00396	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0039b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160895
  003a2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160896
  003ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003b3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003b8	41 b9 03 00 00
	00		 mov	 r9d, 3
  003be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160897
  003c5	ba 1a 0d 00 00	 mov	 edx, 3354		; 00000d1aH
  003ca	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160898
  003d1	e8 00 00 00 00	 call	 fwritemsg

; 3355 :         errno = EBADF;

  003d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  003dc	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 3356 :         return -1;

  003e2	b8 ff ff ff ff	 mov	 eax, -1
  003e7	e9 57 01 00 00	 jmp	 $LN1@w32_select
$LN30@w32_select:

; 3357 :     }
; 3358 : 
; 3359 :     // If all SOCKETs, do a normal 'select'...
; 3360 : 
; 3361 :     if ( bSocketFound )

  003ec	83 7c 24 44 00	 cmp	 DWORD PTR bSocketFound$[rsp], 0
  003f1	74 37		 je	 SHORT $LN31@w32_select

; 3362 :         return select( nfds, pReadSet, pWriteSet, pExceptSet, pTimeVal );

  003f3	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  003fb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00400	4c 8b 8c 24 98
	43 00 00	 mov	 r9, QWORD PTR pExceptSet$[rsp]
  00408	4c 8b 84 24 90
	43 00 00	 mov	 r8, QWORD PTR pWriteSet$[rsp]
  00410	48 8b 94 24 88
	43 00 00	 mov	 rdx, QWORD PTR pReadSet$[rsp]
  00418	8b 8c 24 80 43
	00 00		 mov	 ecx, DWORD PTR nfds$[rsp]
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_select
  00425	e9 19 01 00 00	 jmp	 $LN1@w32_select
$LN31@w32_select:

; 3363 : 
; 3364 :     // Otherwise they're all HANDLEs, so do a WaitForMultipleObjects...
; 3365 : 
; 3366 :     if ( !pTimeVal )

  0042a	48 83 bc 24 a0
	43 00 00 00	 cmp	 QWORD PTR pTimeVal$[rsp], 0
  00433	75 0a		 jne	 SHORT $LN32@w32_select

; 3367 :         dwWaitMilliSeconds = INFINITE;

  00435	c7 44 24 40 ff
	ff ff ff	 mov	 DWORD PTR dwWaitMilliSeconds$[rsp], -1 ; ffffffffH
  0043d	eb 36		 jmp	 SHORT $LN33@w32_select
$LN32@w32_select:

; 3368 :     else
; 3369 :     {
; 3370 :         dwWaitMilliSeconds  = (   pTimeVal->tv_sec          * 1000 );

  0043f	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  00447	69 00 e8 03 00
	00		 imul	 eax, DWORD PTR [rax], 1000 ; 000003e8H
  0044d	89 44 24 40	 mov	 DWORD PTR dwWaitMilliSeconds$[rsp], eax

; 3371 :         dwWaitMilliSeconds += ( ( pTimeVal->tv_usec + 500 ) / 1000 );

  00451	48 8b 84 24 a0
	43 00 00	 mov	 rax, QWORD PTR pTimeVal$[rsp]
  00459	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0045c	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  00461	99		 cdq
  00462	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00467	f7 f9		 idiv	 ecx
  00469	8b 4c 24 40	 mov	 ecx, DWORD PTR dwWaitMilliSeconds$[rsp]
  0046d	03 c8		 add	 ecx, eax
  0046f	8b c1		 mov	 eax, ecx
  00471	89 44 24 40	 mov	 DWORD PTR dwWaitMilliSeconds$[rsp], eax
$LN33@w32_select:

; 3372 :     }
; 3373 : 
; 3374 :     if ( !dwHandles )

  00475	83 7c 24 48 00	 cmp	 DWORD PTR dwHandles$[rsp], 0
  0047a	75 11		 jne	 SHORT $LN34@w32_select

; 3375 :     {
; 3376 :         // Just sleep for the specified interval...
; 3377 :         Sleep( dwWaitMilliSeconds );

  0047c	8b 4c 24 40	 mov	 ecx, DWORD PTR dwWaitMilliSeconds$[rsp]
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 3378 :         return 0;   // (timeout)

  00486	33 c0		 xor	 eax, eax
  00488	e9 b6 00 00 00	 jmp	 $LN1@w32_select
$LN34@w32_select:

; 3379 :     }
; 3380 : 
; 3381 :     dwWaitRetCode = WaitForMultipleObjects( dwHandles, arHandles, FALSE, dwWaitMilliSeconds );

  0048d	44 8b 4c 24 40	 mov	 r9d, DWORD PTR dwWaitMilliSeconds$[rsp]
  00492	45 33 c0	 xor	 r8d, r8d
  00495	48 8d 54 24 60	 lea	 rdx, QWORD PTR arHandles$[rsp]
  0049a	8b 4c 24 48	 mov	 ecx, DWORD PTR dwHandles$[rsp]
  0049e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForMultipleObjects
  004a4	89 44 24 54	 mov	 DWORD PTR dwWaitRetCode$[rsp], eax

; 3382 : 
; 3383 :     if ( WAIT_TIMEOUT == dwWaitRetCode )

  004a8	81 7c 24 54 02
	01 00 00	 cmp	 DWORD PTR dwWaitRetCode$[rsp], 258 ; 00000102H
  004b0	75 07		 jne	 SHORT $LN35@w32_select

; 3384 :         return 0;

  004b2	33 c0		 xor	 eax, eax
  004b4	e9 8a 00 00 00	 jmp	 $LN1@w32_select
$LN35@w32_select:

; 3385 : 
; 3386 :     // NOTE: we don't support returning the actual total number of handles
; 3387 :     // that are ready; instead, we return 1 as long as ANY handle is ready...
; 3388 : 
; 3389 :     if ( dwWaitRetCode < ( WAIT_OBJECT_0 + dwHandles ) )

  004b9	8b 44 24 48	 mov	 eax, DWORD PTR dwHandles$[rsp]
  004bd	39 44 24 54	 cmp	 DWORD PTR dwWaitRetCode$[rsp], eax
  004c1	73 07		 jae	 SHORT $LN36@w32_select

; 3390 :         return 1;

  004c3	b8 01 00 00 00	 mov	 eax, 1
  004c8	eb 79		 jmp	 SHORT $LN1@w32_select
$LN36@w32_select:
$LN13@w32_select:

; 3391 : 
; 3392 :     // Something went wrong...
; 3393 : 
; 3394 :     ASSERT( FALSE );    // (in case this is a debug build)

  004ca	33 c0		 xor	 eax, eax
  004cc	83 f8 01	 cmp	 eax, 1
  004cf	74 5b		 je	 SHORT $LN37@w32_select
$LN16@w32_select:
  004d1	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160906
  004d8	41 b8 42 0d 00
	00		 mov	 r8d, 3394		; 00000d42H
  004de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160907
  004e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160908
  004ec	e8 00 00 00 00	 call	 logmsg
  004f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  004f7	85 c0		 test	 eax, eax
  004f9	74 20		 je	 SHORT $LN38@w32_select
  004fb	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160910
  00502	41 b8 42 0d 00
	00		 mov	 r8d, 3394		; 00000d42H
  00508	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160911
  0050f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160912
  00516	e8 00 00 00 00	 call	 DebuggerTrace
$LN38@w32_select:
  0051b	33 c0		 xor	 eax, eax
  0051d	85 c0		 test	 eax, eax
  0051f	75 b0		 jne	 SHORT $LN16@w32_select
  00521	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00527	85 c0		 test	 eax, eax
  00529	74 01		 je	 SHORT $LN39@w32_select
  0052b	cc		 int	 3
$LN39@w32_select:
$LN37@w32_select:
  0052c	33 c0		 xor	 eax, eax
  0052e	85 c0		 test	 eax, eax
  00530	75 98		 jne	 SHORT $LN13@w32_select

; 3395 :     errno = ENOSYS;     // (system call failure)

  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00538	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H

; 3396 :     return -1;

  0053e	b8 ff ff ff ff	 mov	 eax, -1
$LN1@w32_select:

; 3397 : }

  00543	48 8b 8c 24 60
	43 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0054b	48 33 cc	 xor	 rcx, rsp
  0054e	e8 00 00 00 00	 call	 __security_check_cookie
  00553	48 81 c4 78 43
	00 00		 add	 rsp, 17272		; 00004378H
  0055a	c3		 ret	 0
w32_select ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
i$ = 32
tv85 = 36
hFile$ = 40
fd$ = 64
pSet$ = 72
w32_FD_ISSET PROC

; 3121 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3122 :     int     i;
; 3123 :     HANDLE  hFile;
; 3124 : 
; 3125 :     if ( socket_is_socket( fd ) )                       // (is it already a SOCKET?)

  0000d	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00011	e8 00 00 00 00	 call	 socket_is_socket
  00016	85 c0		 test	 eax, eax
  00018	74 14		 je	 SHORT $LN5@w32_FD_ISS

; 3126 :         return ORIGINAL_FD_ISSET( (SOCKET)fd, pSet );   // (yes, do normal FD_ISSET)

  0001a	48 63 44 24 40	 movsxd	 rax, DWORD PTR fd$[rsp]
  0001f	48 8b 54 24 48	 mov	 rdx, QWORD PTR pSet$[rsp]
  00024	48 8b c8	 mov	 rcx, rax
  00027	e8 00 00 00 00	 call	 __WSAFDIsSet
  0002c	eb 73		 jmp	 SHORT $LN1@w32_FD_ISS
$LN5@w32_FD_ISS:

; 3127 : 
; 3128 :     hFile = (HANDLE) _get_osfhandle( fd );

  0002e	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  00038	48 89 44 24 28	 mov	 QWORD PTR hFile$[rsp], rax

; 3129 : 
; 3130 :     for ( i=0; i < (int)pSet->fd_count; i++ )

  0003d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00045	eb 0a		 jmp	 SHORT $LN4@w32_FD_ISS
$LN2@w32_FD_ISS:
  00047	8b 44 24 20	 mov	 eax, DWORD PTR i$[rsp]
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 20	 mov	 DWORD PTR i$[rsp], eax
$LN4@w32_FD_ISS:
  00051	48 8b 44 24 48	 mov	 rax, QWORD PTR pSet$[rsp]
  00056	8b 00		 mov	 eax, DWORD PTR [rax]
  00058	39 44 24 20	 cmp	 DWORD PTR i$[rsp], eax
  0005c	7d 41		 jge	 SHORT $LN3@w32_FD_ISS

; 3131 :         if ( pSet->fd_array[i] == (SOCKET) hFile )      // (is this the file?)

  0005e	48 63 44 24 20	 movsxd	 rax, DWORD PTR i$[rsp]
  00063	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pSet$[rsp]
  00068	48 8b 54 24 28	 mov	 rdx, QWORD PTR hFile$[rsp]
  0006d	48 39 54 c1 08	 cmp	 QWORD PTR [rcx+rax*8+8], rdx
  00072	75 29		 jne	 SHORT $LN6@w32_FD_ISS

; 3132 :             return IsEventSet( hFile );                 // (yes, return whether ready (signaled) or not)

  00074	33 d2		 xor	 edx, edx
  00076	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hFile$[rsp]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WaitForSingleObject
  00081	85 c0		 test	 eax, eax
  00083	75 0a		 jne	 SHORT $LN8@w32_FD_ISS
  00085	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  0008d	eb 08		 jmp	 SHORT $LN9@w32_FD_ISS
$LN8@w32_FD_ISS:
  0008f	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN9@w32_FD_ISS:
  00097	8b 44 24 24	 mov	 eax, DWORD PTR tv85[rsp]
  0009b	eb 04		 jmp	 SHORT $LN1@w32_FD_ISS
$LN6@w32_FD_ISS:
  0009d	eb a8		 jmp	 SHORT $LN2@w32_FD_ISS
$LN3@w32_FD_ISS:

; 3133 : 
; 3134 :     return 0;   // (file not a member of the specified set)

  0009f	33 c0		 xor	 eax, eax
$LN1@w32_FD_ISS:

; 3135 : }

  000a1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000a5	c3		 ret	 0
w32_FD_ISSET ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
i$1 = 32
hSocket$ = 40
fd$ = 64
pSet$ = 72
w32_FD_SET PROC

; 3097 : {

$LN13:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3098 :     SOCKET hSocket;
; 3099 : 
; 3100 :     if (0
; 3101 :         || socket_is_socket( fd )
; 3102 :         || (SOCKET) -1 == ( hSocket = (SOCKET) _get_osfhandle( fd ) )

  0000d	33 c0		 xor	 eax, eax
  0000f	85 c0		 test	 eax, eax
  00011	75 24		 jne	 SHORT $LN9@w32_FD_SET
  00013	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00017	e8 00 00 00 00	 call	 socket_is_socket
  0001c	85 c0		 test	 eax, eax
  0001e	75 17		 jne	 SHORT $LN9@w32_FD_SET
  00020	8b 4c 24 40	 mov	 ecx, DWORD PTR fd$[rsp]
  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  0002a	48 89 44 24 28	 mov	 QWORD PTR hSocket$[rsp], rax
  0002f	48 83 7c 24 28
	ff		 cmp	 QWORD PTR hSocket$[rsp], -1
  00035	75 0a		 jne	 SHORT $LN8@w32_FD_SET
$LN9@w32_FD_SET:

; 3103 :     )
; 3104 :         hSocket = (SOCKET) fd;

  00037	48 63 44 24 40	 movsxd	 rax, DWORD PTR fd$[rsp]
  0003c	48 89 44 24 28	 mov	 QWORD PTR hSocket$[rsp], rax
$LN8@w32_FD_SET:
$LN4@w32_FD_SET:

; 3105 : 
; 3106 :     ORIGINAL_FD_SET( hSocket, pSet );   // (add HANDLE/SOCKET to specified set)

  00041	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR i$1[rsp], 0
  00049	eb 0a		 jmp	 SHORT $LN7@w32_FD_SET
$LN5@w32_FD_SET:
  0004b	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  0004f	ff c0		 inc	 eax
  00051	89 44 24 20	 mov	 DWORD PTR i$1[rsp], eax
$LN7@w32_FD_SET:
  00055	48 8b 44 24 48	 mov	 rax, QWORD PTR pSet$[rsp]
  0005a	8b 00		 mov	 eax, DWORD PTR [rax]
  0005c	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00060	73 19		 jae	 SHORT $LN6@w32_FD_SET
  00062	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00066	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pSet$[rsp]
  0006b	48 8b 54 24 28	 mov	 rdx, QWORD PTR hSocket$[rsp]
  00070	48 39 54 c1 08	 cmp	 QWORD PTR [rcx+rax*8+8], rdx
  00075	75 02		 jne	 SHORT $LN10@w32_FD_SET
  00077	eb 02		 jmp	 SHORT $LN6@w32_FD_SET
$LN10@w32_FD_SET:
  00079	eb d0		 jmp	 SHORT $LN5@w32_FD_SET
$LN6@w32_FD_SET:
  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR pSet$[rsp]
  00080	8b 00		 mov	 eax, DWORD PTR [rax]
  00082	39 44 24 20	 cmp	 DWORD PTR i$1[rsp], eax
  00086	75 30		 jne	 SHORT $LN11@w32_FD_SET
  00088	48 8b 44 24 48	 mov	 rax, QWORD PTR pSet$[rsp]
  0008d	81 38 00 04 00
	00		 cmp	 DWORD PTR [rax], 1024	; 00000400H
  00093	73 23		 jae	 SHORT $LN11@w32_FD_SET
  00095	8b 44 24 20	 mov	 eax, DWORD PTR i$1[rsp]
  00099	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pSet$[rsp]
  0009e	48 8b 54 24 28	 mov	 rdx, QWORD PTR hSocket$[rsp]
  000a3	48 89 54 c1 08	 mov	 QWORD PTR [rcx+rax*8+8], rdx
  000a8	48 8b 44 24 48	 mov	 rax, QWORD PTR pSet$[rsp]
  000ad	8b 00		 mov	 eax, DWORD PTR [rax]
  000af	ff c0		 inc	 eax
  000b1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR pSet$[rsp]
  000b6	89 01		 mov	 DWORD PTR [rcx], eax
$LN11@w32_FD_SET:
  000b8	33 c0		 xor	 eax, eax
  000ba	85 c0		 test	 eax, eax
  000bc	75 83		 jne	 SHORT $LN4@w32_FD_SET

; 3107 : }

  000be	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c2	c3		 ret	 0
w32_FD_SET ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv70 = 32
fd$ = 64
w32_close_socket PROC

; 2844 : {

$LN5:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2845 :     rem_kasock( (SOCKET) fd );

  00008	48 63 44 24 40	 movsxd	 rax, DWORD PTR fd$[rsp]
  0000d	48 8b c8	 mov	 rcx, rax
  00010	e8 00 00 00 00	 call	 rem_kasock

; 2846 :     return (closesocket( (SOCKET) fd ) == SOCKET_ERROR) ? -1 : 0;

  00015	48 63 44 24 40	 movsxd	 rax, DWORD PTR fd$[rsp]
  0001a	48 8b c8	 mov	 rcx, rax
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket
  00023	83 f8 ff	 cmp	 eax, -1
  00026	75 0a		 jne	 SHORT $LN3@w32_close_
  00028	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR tv70[rsp], -1
  00030	eb 08		 jmp	 SHORT $LN4@w32_close_
$LN3@w32_close_:
  00032	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN4@w32_close_:
  0003a	8b 44 24 20	 mov	 eax, DWORD PTR tv70[rsp]

; 2847 : }

  0003e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00042	c3		 ret	 0
w32_close_socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv90 = 48
sock$ = 56
lsock$ = 80
addr$ = 88
addrlen$ = 96
w32_accept PROC

; 2824 : {

$LN14:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2825 :     SOCKET sock;
; 2826 : 
; 2827 :     sock = WSAAccept( (SOCKET) lsock, addr, addrlen, NULL, 0 );

  00012	48 63 44 24 50	 movsxd	 rax, DWORD PTR lsock$[rsp]
  00017	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00020	45 33 c9	 xor	 r9d, r9d
  00023	4c 8b 44 24 60	 mov	 r8, QWORD PTR addrlen$[rsp]
  00028	48 8b 54 24 58	 mov	 rdx, QWORD PTR addr$[rsp]
  0002d	48 8b c8	 mov	 rcx, rax
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAAccept
  00036	48 89 44 24 38	 mov	 QWORD PTR sock$[rsp], rax

; 2828 : 
; 2829 :     if (INVALID_SOCKET != sock)

  0003b	48 83 7c 24 38
	ff		 cmp	 QWORD PTR sock$[rsp], -1
  00041	74 71		 je	 SHORT $LN8@w32_accept
$LN4@w32_accept:

; 2830 :         VERIFY( add_kasock( sock ));

  00043	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sock$[rsp]
  00048	e8 00 00 00 00	 call	 add_kasock
  0004d	85 c0		 test	 eax, eax
  0004f	75 5b		 jne	 SHORT $LN10@w32_accept
$LN7@w32_accept:
  00051	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160608
  00058	41 b8 0e 0b 00
	00		 mov	 r8d, 2830		; 00000b0eH
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160609
  00065	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160610
  0006c	e8 00 00 00 00	 call	 logmsg
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00077	85 c0		 test	 eax, eax
  00079	74 20		 je	 SHORT $LN11@w32_accept
  0007b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160612
  00082	41 b8 0e 0b 00
	00		 mov	 r8d, 2830		; 00000b0eH
  00088	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160613
  0008f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160614
  00096	e8 00 00 00 00	 call	 DebuggerTrace
$LN11@w32_accept:
  0009b	33 c0		 xor	 eax, eax
  0009d	85 c0		 test	 eax, eax
  0009f	75 b0		 jne	 SHORT $LN7@w32_accept
  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a7	85 c0		 test	 eax, eax
  000a9	74 01		 je	 SHORT $LN12@w32_accept
  000ab	cc		 int	 3
$LN12@w32_accept:
$LN10@w32_accept:
  000ac	33 c0		 xor	 eax, eax
  000ae	85 c0		 test	 eax, eax
  000b0	75 91		 jne	 SHORT $LN4@w32_accept
  000b2	eb 1f		 jmp	 SHORT $LN9@w32_accept
$LN8@w32_accept:

; 2831 :     else
; 2832 :     {
; 2833 :         errno = WSAGetLastError();

  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000ba	89 44 24 30	 mov	 DWORD PTR tv90[rsp], eax
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c4	8b 4c 24 30	 mov	 ecx, DWORD PTR tv90[rsp]
  000c8	89 08		 mov	 DWORD PTR [rax], ecx

; 2834 :         sock = (SOCKET) -1;

  000ca	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR sock$[rsp], -1
$LN9@w32_accept:

; 2835 :     }
; 2836 : 
; 2837 :     return ((int) sock);

  000d3	8b 44 24 38	 mov	 eax, DWORD PTR sock$[rsp]

; 2838 : }

  000d7	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000db	c3		 ret	 0
w32_accept ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv90 = 48
sock$ = 56
af$ = 80
type$ = 88
protocol$ = 96
w32_socket PROC

; 2748 : {

$LN14:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000d	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 2749 :     ///////////////////////////////////////////////////////////////////////////////
; 2750 :     //
; 2751 :     //                         PROGRAMMING NOTE
; 2752 :     //
; 2753 :     // We need to request that all sockets we create [via the 'socket()' API]
; 2754 :     // be created WITHOUT the "OVERLAPPED" attribute so that our 'fgets()', etc,
; 2755 :     // calls (which end up calling the "ReadFile()", etc, Win32 API) work as
; 2756 :     // expected.
; 2757 :     //
; 2758 :     // Note that the "overlapped" attribute for a socket is completely different
; 2759 :     // from its non-blocking vs. blocking mode. All sockets are created, by default,
; 2760 :     // as blocking mode sockets, but WITH the "overlapped" attribute set. Thus all
; 2761 :     // sockets are actually asynchonous by default. (The winsock DLL(s) handle the
; 2762 :     // blocking mode separately programmatically internally even though the socket
; 2763 :     // is actually an asynchronous Win32 "file").
; 2764 :     //
; 2765 :     // Thus we need to specifically request that our [blocking mode] sockets be
; 2766 :     // created WITHOUT the Win32 "OVERLAPPED" attribute (so that when we call the
; 2767 :     // C runtime read/write/etc functions, the C runtime's ReadFile/WriteFile calls
; 2768 :     // work (which they don't (they fail with error 87 ERROR_INVALID_PARAMETER)
; 2769 :     // when called on a Win32 "file" handle created with the OVERLAPPED attribute
; 2770 :     // but without an OVERLAPPED structure pased in the ReadFile/WriteFile call
; 2771 :     // (which the C runtime functions don't use)). You follow?).
; 2772 :     //
; 2773 :     // See KB (Knowledge Base) article 181611 for more information:
; 2774 :     //
; 2775 :     //        "Socket overlapped I/O versus blocking/non-blocking mode"
; 2776 :     //            (http://support.microsoft.com/?kbid=181611)
; 2777 :     //
; 2778 :     //  ---------------------------------------------------------------------
; 2779 :     //   "However, you can call the setsockopt API with SO_OPENTYPE option
; 2780 :     //   on any socket handle -- including an INVALID_SOCKET -- to change
; 2781 :     //   the overlapped attributes for all successive socket calls in the
; 2782 :     //   same thread. The default SO_OPENTYPE option value is 0, which sets
; 2783 :     //   the overlapped attribute. All non-zero option values make the socket
; 2784 :     //   synchronous and make it so that you cannot use a completion function."
; 2785 :     //  ---------------------------------------------------------------------
; 2786 :     //
; 2787 :     // The documentation for the "SOL_SOCKET" SO_OPENTYPE socket option contains
; 2788 :     // the folowing advice/warning however:
; 2789 :     //
; 2790 :     //
; 2791 :     //    "Once set, subsequent sockets created will be non-overlapped.
; 2792 :     //     This option should not be used; use WSASocket and leave the
; 2793 :     //     WSA_FLAG_OVERLAPPED turned off."
; 2794 :     //
; 2795 :     //
; 2796 :     // So we'll use WSASocket instead as suggested.
; 2797 :     //
; 2798 :     ///////////////////////////////////////////////////////////////////////////////
; 2799 : 
; 2800 :     // The last parameter is where one would normally specify the WSA_FLAG_OVERLAPPED
; 2801 :     // option, but we're specifying '0' because we want our sockets to be synchronous
; 2802 :     // and not asynchronous so the C runtime functions can successfully perform ReadFile
; 2803 :     // and WriteFile on them...
; 2804 : 
; 2805 :     SOCKET sock;
; 2806 : 
; 2807 :     sock = WSASocket( af, type, protocol, NULL, 0, 0 );

  00011	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00019	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR [rsp+32], 0
  00021	45 33 c9	 xor	 r9d, r9d
  00024	44 8b 44 24 60	 mov	 r8d, DWORD PTR protocol$[rsp]
  00029	8b 54 24 58	 mov	 edx, DWORD PTR type$[rsp]
  0002d	8b 4c 24 50	 mov	 ecx, DWORD PTR af$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSASocketA
  00037	48 89 44 24 38	 mov	 QWORD PTR sock$[rsp], rax

; 2808 : 
; 2809 :     if (INVALID_SOCKET != sock)

  0003c	48 83 7c 24 38
	ff		 cmp	 QWORD PTR sock$[rsp], -1
  00042	74 71		 je	 SHORT $LN8@w32_socket
$LN4@w32_socket:

; 2810 :         VERIFY( add_kasock( sock ));

  00044	48 8b 4c 24 38	 mov	 rcx, QWORD PTR sock$[rsp]
  00049	e8 00 00 00 00	 call	 add_kasock
  0004e	85 c0		 test	 eax, eax
  00050	75 5b		 jne	 SHORT $LN10@w32_socket
$LN7@w32_socket:
  00052	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160578
  00059	41 b8 fa 0a 00
	00		 mov	 r8d, 2810		; 00000afaH
  0005f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160579
  00066	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160580
  0006d	e8 00 00 00 00	 call	 logmsg
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00078	85 c0		 test	 eax, eax
  0007a	74 20		 je	 SHORT $LN11@w32_socket
  0007c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160582
  00083	41 b8 fa 0a 00
	00		 mov	 r8d, 2810		; 00000afaH
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160583
  00090	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160584
  00097	e8 00 00 00 00	 call	 DebuggerTrace
$LN11@w32_socket:
  0009c	33 c0		 xor	 eax, eax
  0009e	85 c0		 test	 eax, eax
  000a0	75 b0		 jne	 SHORT $LN7@w32_socket
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a8	85 c0		 test	 eax, eax
  000aa	74 01		 je	 SHORT $LN12@w32_socket
  000ac	cc		 int	 3
$LN12@w32_socket:
$LN10@w32_socket:
  000ad	33 c0		 xor	 eax, eax
  000af	85 c0		 test	 eax, eax
  000b1	75 91		 jne	 SHORT $LN4@w32_socket
  000b3	eb 1f		 jmp	 SHORT $LN9@w32_socket
$LN8@w32_socket:

; 2811 :     else
; 2812 :     {
; 2813 :         errno = WSAGetLastError();

  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000bb	89 44 24 30	 mov	 DWORD PTR tv90[rsp], eax
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c5	8b 4c 24 30	 mov	 ecx, DWORD PTR tv90[rsp]
  000c9	89 08		 mov	 DWORD PTR [rax], ecx

; 2814 :         sock = (SOCKET) -1;

  000cb	48 c7 44 24 38
	ff ff ff ff	 mov	 QWORD PTR sock$[rsp], -1
$LN9@w32_socket:

; 2815 :     }
; 2816 : 
; 2817 :     return ((int) sock);

  000d4	8b 44 24 38	 mov	 eax, DWORD PTR sock$[rsp]

; 2818 : }

  000d8	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000dc	c3		 ret	 0
w32_socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
prod_id$ = 48
tv336 = 56
psz$ = 64
Cache$ = 72
size$1 = 80
ptr$ = 88
buffer$ = 96
done$2 = 104
retlen$3 = 108
byteOffset$4 = 112
dw$ = 116
n$5 = 120
ppi$6 = 128
tv316 = 136
tv549 = 140
prod_proc$ = 144
rc$7 = 152
ext$ = 156
glpi$ = 160
pgnsi$ = 168
si$ = 176
tv265 = 224
Pwrinfo$8 = 232
pgpi$ = 240
cs$ = 248
vi$ = 288
ms$ = 448
CPUInfo$9 = 512
CPUInfo$10 = 528
CPUString$11 = 544
CPUBrand$12 = 576
__$ArrayPad$ = 640
pHostInfo$ = 688
w32_init_hostinfo PROC

; 1473 : {

$LN198:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 81 ec 90 02
	00 00		 sub	 rsp, 656		; 00000290H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1474 :     CRITICAL_SECTION  cs;
; 1475 :     OSVERSIONINFOEX   vi;
; 1476 :     MEMORYSTATUSEX    ms;
; 1477 :     SYSTEM_INFO       si;
; 1478 :     BOOL              ext;
; 1479 :     char             *psz = "", *prod_id = "", *prod_proc = "";

  00021	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159931
  00028	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159932
  00034	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00039	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159933
  00040	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR prod_proc$[rsp], rax

; 1480 :     DWORD             dw;
; 1481 :     PGNSI             pgnsi;
; 1482 :     LPFN_GLPI         glpi;
; 1483 :     PGPI              pgpi;
; 1484 : 
; 1485 :     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;

  00048	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 1486 :     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = NULL;

  00051	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR ptr$[rsp], 0

; 1487 :     PCACHE_DESCRIPTOR Cache;
; 1488 : 
; 1489 :     ZeroMemory(&si, sizeof(SYSTEM_INFO));

  0005a	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR si$[rsp]
  00062	48 8b f8	 mov	 rdi, rax
  00065	33 c0		 xor	 eax, eax
  00067	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  0006c	f3 aa		 rep stosb

; 1490 :     ZeroMemory(&vi, sizeof(OSVERSIONINFOEX));

  0006e	48 8d 84 24 20
	01 00 00	 lea	 rax, QWORD PTR vi$[rsp]
  00076	48 8b f8	 mov	 rdi, rax
  00079	33 c0		 xor	 eax, eax
  0007b	b9 9c 00 00 00	 mov	 ecx, 156		; 0000009cH
  00080	f3 aa		 rep stosb

; 1491 :     ZeroMemory(&ms, sizeof(MEMORYSTATUSEX));

  00082	48 8d 84 24 c0
	01 00 00	 lea	 rax, QWORD PTR ms$[rsp]
  0008a	48 8b f8	 mov	 rdi, rax
  0008d	33 c0		 xor	 eax, eax
  0008f	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  00094	f3 aa		 rep stosb

; 1492 : 
; 1493 :     ms.dwLength = sizeof(ms);

  00096	c7 84 24 c0 01
	00 00 40 00 00
	00		 mov	 DWORD PTR ms$[rsp], 64	; 00000040H

; 1494 :     GlobalMemoryStatusEx(&ms);

  000a1	48 8d 8c 24 c0
	01 00 00	 lea	 rcx, QWORD PTR ms$[rsp]
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GlobalMemoryStatusEx

; 1495 : 
; 1496 :     pHostInfo->TotalPhys     = ms.ullTotalPhys;

  000af	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  000b7	48 8b 8c 24 c8
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp+8]
  000bf	48 89 88 30 02
	00 00		 mov	 QWORD PTR [rax+560], rcx

; 1497 :     pHostInfo->AvailPhys     = ms.ullAvailPhys;

  000c6	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  000ce	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp+16]
  000d6	48 89 88 38 02
	00 00		 mov	 QWORD PTR [rax+568], rcx

; 1498 :     pHostInfo->TotalPageFile = ms.ullTotalPageFile;

  000dd	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  000e5	48 8b 8c 24 d8
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp+24]
  000ed	48 89 88 40 02
	00 00		 mov	 QWORD PTR [rax+576], rcx

; 1499 :     pHostInfo->AvailPageFile = ms.ullAvailPageFile;

  000f4	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  000fc	48 8b 8c 24 e0
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp+32]
  00104	48 89 88 48 02
	00 00		 mov	 QWORD PTR [rax+584], rcx

; 1500 :     pHostInfo->TotalVirtual  = ms.ullTotalVirtual;

  0010b	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00113	48 8b 8c 24 e8
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp+40]
  0011b	48 89 88 50 02
	00 00		 mov	 QWORD PTR [rax+592], rcx

; 1501 :     pHostInfo->AvailVirtual  = ms.ullAvailVirtual;

  00122	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  0012a	48 8b 8c 24 f0
	01 00 00	 mov	 rcx, QWORD PTR ms$[rsp+48]
  00132	48 89 88 58 02
	00 00		 mov	 QWORD PTR [rax+600], rcx

; 1502 : 
; 1503 :     pHostInfo->maxfilesopen = _getmaxstdio();

  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__getmaxstdio
  0013f	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  00147	89 81 b4 01 00
	00		 mov	 DWORD PTR [rcx+436], eax

; 1504 : 
; 1505 :     dw = sizeof(pHostInfo->nodename)-1;

  0014d	c7 44 24 74 3f
	00 00 00	 mov	 DWORD PTR dw$[rsp], 63	; 0000003fH

; 1506 :     GetComputerName( pHostInfo->nodename, &dw );

  00155	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  0015d	48 83 c0 70	 add	 rax, 112		; 00000070H
  00161	48 8d 54 24 74	 lea	 rdx, QWORD PTR dw$[rsp]
  00166	48 8b c8	 mov	 rcx, rax
  00169	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetComputerNameA

; 1507 :     pHostInfo->nodename[sizeof(pHostInfo->nodename)-1] = 0;

  0016f	b8 01 00 00 00	 mov	 eax, 1
  00174	48 6b c0 3f	 imul	 rax, rax, 63		; 0000003fH
  00178	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  00180	c6 44 01 70 00	 mov	 BYTE PTR [rcx+rax+112], 0

; 1508 : 
; 1509 :     glpi = (LPFN_GLPI) GetProcAddress( GetModuleHandle(TEXT("kernel32.dll")),

  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159935
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00192	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159934
  00199	48 8b c8	 mov	 rcx, rax
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  001a2	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR glpi$[rsp], rax

; 1510 :                                    "GetLogicalProcessorInformation");
; 1511 :     if ( glpi != NULL )

  001aa	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR glpi$[rsp], 0
  001b3	0f 84 d0 02 00
	00		 je	 $LN12@w32_init_h

; 1512 :     {
; 1513 :         BOOL done = FALSE;

  001b9	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR done$2[rsp], 0

; 1514 :         DWORD       retlen = 0;

  001c1	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR retlen$3[rsp], 0
$LN2@w32_init_h:

; 1515 : 
; 1516 :         while (!done)

  001c9	83 7c 24 68 00	 cmp	 DWORD PTR done$2[rsp], 0
  001ce	75 6b		 jne	 SHORT $LN3@w32_init_h

; 1517 :         {
; 1518 :             DWORD rc = glpi( buffer, &retlen );

  001d0	48 8d 54 24 6c	 lea	 rdx, QWORD PTR retlen$3[rsp]
  001d5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buffer$[rsp]
  001da	ff 94 24 a0 00
	00 00		 call	 QWORD PTR glpi$[rsp]
  001e1	89 84 24 98 00
	00 00		 mov	 DWORD PTR rc$7[rsp], eax

; 1519 : 
; 1520 :             if ( rc == FALSE )

  001e8	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR rc$7[rsp], 0
  001f0	75 3f		 jne	 SHORT $LN13@w32_init_h

; 1521 :             {
; 1522 :                 if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )

  001f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  001f8	83 f8 7a	 cmp	 eax, 122		; 0000007aH
  001fb	75 30		 jne	 SHORT $LN15@w32_init_h

; 1523 :                 {
; 1524 :                     if (buffer)

  001fd	48 83 7c 24 60
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00203	74 0b		 je	 SHORT $LN17@w32_init_h

; 1525 :                         free(buffer);

  00205	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buffer$[rsp]
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN17@w32_init_h:

; 1526 : 
; 1527 :                     buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)malloc(retlen);

  00210	8b 44 24 6c	 mov	 eax, DWORD PTR retlen$3[rsp]
  00214	8b c8		 mov	 ecx, eax
  00216	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0021c	48 89 44 24 60	 mov	 QWORD PTR buffer$[rsp], rax

; 1528 : 
; 1529 :                     if (buffer == NULL)

  00221	48 83 7c 24 60
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00227	75 02		 jne	 SHORT $LN18@w32_init_h

; 1530 :                         break;

  00229	eb 10		 jmp	 SHORT $LN3@w32_init_h
$LN18@w32_init_h:

; 1531 :                 }

  0022b	eb 02		 jmp	 SHORT $LN16@w32_init_h
$LN15@w32_init_h:

; 1532 :                 else
; 1533 :                 {
; 1534 :                     break;

  0022d	eb 0c		 jmp	 SHORT $LN3@w32_init_h
$LN16@w32_init_h:

; 1535 :                 }
; 1536 :             }

  0022f	eb 08		 jmp	 SHORT $LN14@w32_init_h
$LN13@w32_init_h:

; 1537 :             else
; 1538 :                 done = TRUE;

  00231	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR done$2[rsp], 1
$LN14@w32_init_h:

; 1539 :         }

  00239	eb 8e		 jmp	 SHORT $LN2@w32_init_h
$LN3@w32_init_h:

; 1540 : 
; 1541 :         if ( done == TRUE )

  0023b	83 7c 24 68 01	 cmp	 DWORD PTR done$2[rsp], 1
  00240	0f 85 43 02 00
	00		 jne	 $LN19@w32_init_h

; 1542 :         {
; 1543 :             DWORD byteOffset = 0;

  00246	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR byteOffset$4[rsp], 0

; 1544 :             ptr = buffer;

  0024e	48 8b 44 24 60	 mov	 rax, QWORD PTR buffer$[rsp]
  00253	48 89 44 24 58	 mov	 QWORD PTR ptr$[rsp], rax

; 1545 : 
; 1546 :             pHostInfo->cachelinesz      = 0;

  00258	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00260	48 c7 80 f0 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+496], 0

; 1547 :             pHostInfo->num_physical_cpu = 0;       /* #of cores                 */

  0026b	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00273	c7 80 bc 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+444], 0

; 1548 :             pHostInfo->num_logical_cpu  = 0;       /* #of of hyperthreads       */

  0027d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00285	c7 80 c0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+448], 0

; 1549 :             pHostInfo->num_packages     = 0;       /* #of CPU "chips"           */

  0028f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00297	c7 80 c4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+452], 0
$LN4@w32_init_h:

; 1550 : 
; 1551 :             while (byteOffset + sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION) <= retlen)

  002a1	8b 44 24 70	 mov	 eax, DWORD PTR byteOffset$4[rsp]
  002a5	48 83 c0 20	 add	 rax, 32			; 00000020H
  002a9	8b 4c 24 6c	 mov	 ecx, DWORD PTR retlen$3[rsp]
  002ad	48 3b c1	 cmp	 rax, rcx
  002b0	0f 87 c0 01 00
	00		 ja	 $LN5@w32_init_h

; 1552 :             {
; 1553 :                 if ( ptr->Relationship == RelationProcessorCore )

  002b6	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  002bb	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002bf	75 4c		 jne	 SHORT $LN20@w32_init_h

; 1554 :                 {
; 1555 :                     pHostInfo->num_physical_cpu++;

  002c1	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  002c9	8b 80 bc 01 00
	00		 mov	 eax, DWORD PTR [rax+444]
  002cf	ff c0		 inc	 eax
  002d1	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  002d9	89 81 bc 01 00
	00		 mov	 DWORD PTR [rcx+444], eax

; 1556 :                     pHostInfo->num_logical_cpu += CountSetBits(ptr->ProcessorMask);

  002df	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  002e4	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002e7	e8 00 00 00 00	 call	 CountSetBits
  002ec	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  002f4	03 81 c0 01 00
	00		 add	 eax, DWORD PTR [rcx+448]
  002fa	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  00302	89 81 c0 01 00
	00		 mov	 DWORD PTR [rcx+448], eax

; 1557 :                 }

  00308	e9 4a 01 00 00	 jmp	 $LN21@w32_init_h
$LN20@w32_init_h:

; 1558 :                 else if ( ptr->Relationship == RelationProcessorPackage )

  0030d	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00312	83 78 08 03	 cmp	 DWORD PTR [rax+8], 3
  00316	75 23		 jne	 SHORT $LN22@w32_init_h

; 1559 :                 {
; 1560 :                     pHostInfo->num_packages++;

  00318	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00320	8b 80 c4 01 00
	00		 mov	 eax, DWORD PTR [rax+452]
  00326	ff c0		 inc	 eax
  00328	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  00330	89 81 c4 01 00
	00		 mov	 DWORD PTR [rcx+452], eax

; 1561 :                 }

  00336	e9 1c 01 00 00	 jmp	 $LN23@w32_init_h
$LN22@w32_init_h:

; 1562 :                 else if ( ptr->Relationship == RelationCache )

  0033b	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00340	83 78 08 02	 cmp	 DWORD PTR [rax+8], 2
  00344	0f 85 0d 01 00
	00		 jne	 $LN24@w32_init_h

; 1563 :                 {
; 1564 :                     Cache = &ptr->Cache;

  0034a	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  0034f	48 83 c0 10	 add	 rax, 16
  00353	48 89 44 24 48	 mov	 QWORD PTR Cache$[rsp], rax

; 1565 : 
; 1566 :                     if ( pHostInfo->cachelinesz == 0 )

  00358	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00360	48 83 b8 f0 01
	00 00 00	 cmp	 QWORD PTR [rax+496], 0
  00368	75 18		 jne	 SHORT $LN25@w32_init_h

; 1567 :                         pHostInfo->cachelinesz = (U64) Cache->LineSize;

  0036a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  0036f	0f b7 40 02	 movzx	 eax, WORD PTR [rax+2]
  00373	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  0037b	48 89 81 f0 01
	00 00		 mov	 QWORD PTR [rcx+496], rax
$LN25@w32_init_h:

; 1568 : 
; 1569 :                     if (Cache->Level == 1 && Cache->Type == CacheData)

  00382	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  00387	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0038a	83 f8 01	 cmp	 eax, 1
  0038d	75 22		 jne	 SHORT $LN26@w32_init_h
  0038f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  00394	83 78 08 02	 cmp	 DWORD PTR [rax+8], 2
  00398	75 17		 jne	 SHORT $LN26@w32_init_h

; 1570 :                     {
; 1571 :                         pHostInfo->L1Dcachesz = (U64) Cache->Size;

  0039a	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  0039f	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  003a2	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  003aa	48 89 81 00 02
	00 00		 mov	 QWORD PTR [rcx+512], rax
$LN26@w32_init_h:

; 1572 :                     }
; 1573 :                     if (Cache->Level == 1 && Cache->Type == CacheInstruction)

  003b1	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  003b6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003b9	83 f8 01	 cmp	 eax, 1
  003bc	75 22		 jne	 SHORT $LN27@w32_init_h
  003be	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  003c3	83 78 08 01	 cmp	 DWORD PTR [rax+8], 1
  003c7	75 17		 jne	 SHORT $LN27@w32_init_h

; 1574 :                     {
; 1575 :                         pHostInfo->L1Icachesz = (U64) Cache->Size;

  003c9	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  003ce	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  003d1	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  003d9	48 89 81 f8 01
	00 00		 mov	 QWORD PTR [rcx+504], rax
$LN27@w32_init_h:

; 1576 :                     }
; 1577 :                     if (Cache->Type == CacheUnified)

  003e0	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  003e5	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  003e9	75 6c		 jne	 SHORT $LN28@w32_init_h

; 1578 :                     {
; 1579 :                         if (Cache->Level == 1)

  003eb	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  003f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  003f3	83 f8 01	 cmp	 eax, 1
  003f6	75 17		 jne	 SHORT $LN29@w32_init_h

; 1580 :                         {
; 1581 :                             pHostInfo->L1Ucachesz = (U64) Cache->Size;

  003f8	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  003fd	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00400	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  00408	48 89 81 08 02
	00 00		 mov	 QWORD PTR [rcx+520], rax
$LN29@w32_init_h:

; 1582 :                         }
; 1583 :                         if (Cache->Level == 2)

  0040f	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  00414	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00417	83 f8 02	 cmp	 eax, 2
  0041a	75 17		 jne	 SHORT $LN30@w32_init_h

; 1584 :                         {
; 1585 :                             pHostInfo->L2cachesz = (U64) Cache->Size;

  0041c	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  00421	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00424	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  0042c	48 89 81 10 02
	00 00		 mov	 QWORD PTR [rcx+528], rax
$LN30@w32_init_h:

; 1586 :                         }
; 1587 :                         if (Cache->Level == 3)

  00433	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  00438	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0043b	83 f8 03	 cmp	 eax, 3
  0043e	75 17		 jne	 SHORT $LN31@w32_init_h

; 1588 :                         {
; 1589 :                             pHostInfo->L3cachesz = (U64) Cache->Size;

  00440	48 8b 44 24 48	 mov	 rax, QWORD PTR Cache$[rsp]
  00445	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  00448	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  00450	48 89 81 18 02
	00 00		 mov	 QWORD PTR [rcx+536], rax
$LN31@w32_init_h:
$LN28@w32_init_h:
$LN24@w32_init_h:
$LN23@w32_init_h:
$LN21@w32_init_h:

; 1590 :                         }
; 1591 :                     }
; 1592 :                 }
; 1593 :                 byteOffset += sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION);

  00457	8b 44 24 70	 mov	 eax, DWORD PTR byteOffset$4[rsp]
  0045b	48 83 c0 20	 add	 rax, 32			; 00000020H
  0045f	89 44 24 70	 mov	 DWORD PTR byteOffset$4[rsp], eax

; 1594 :                 ptr++;

  00463	48 8b 44 24 58	 mov	 rax, QWORD PTR ptr$[rsp]
  00468	48 83 c0 20	 add	 rax, 32			; 00000020H
  0046c	48 89 44 24 58	 mov	 QWORD PTR ptr$[rsp], rax

; 1595 :             }

  00471	e9 2b fe ff ff	 jmp	 $LN4@w32_init_h
$LN5@w32_init_h:

; 1596 : 
; 1597 :             if (buffer)

  00476	48 83 7c 24 60
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  0047c	74 0b		 je	 SHORT $LN32@w32_init_h

; 1598 :                 free(buffer);

  0047e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR buffer$[rsp]
  00483	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN32@w32_init_h:
$LN19@w32_init_h:
$LN12@w32_init_h:

; 1599 :         }
; 1600 :     }
; 1601 : 
; 1602 :     {
; 1603 :         PPROCESSOR_POWER_INFORMATION ppi = NULL;

  00489	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR ppi$6[rsp], 0

; 1604 :         CNPI        Pwrinfo;
; 1605 :         ULONG       size = (ULONG)sizeof(PROCESSOR_POWER_INFORMATION);

  00495	c7 44 24 50 18
	00 00 00	 mov	 DWORD PTR size$1[rsp], 24

; 1606 : 
; 1607 :         size *= (ULONG)pHostInfo->num_logical_cpu;

  0049d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  004a5	8b 4c 24 50	 mov	 ecx, DWORD PTR size$1[rsp]
  004a9	0f af 88 c0 01
	00 00		 imul	 ecx, DWORD PTR [rax+448]
  004b0	8b c1		 mov	 eax, ecx
  004b2	89 44 24 50	 mov	 DWORD PTR size$1[rsp], eax

; 1608 : 
; 1609 :         ppi = (PPROCESSOR_POWER_INFORMATION)malloc((size_t)size);

  004b6	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  004ba	8b c8		 mov	 ecx, eax
  004bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  004c2	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR ppi$6[rsp], rax

; 1610 : 
; 1611 :         if ( NULL != ppi )

  004ca	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR ppi$6[rsp], 0
  004d3	0f 84 99 00 00
	00		 je	 $LN33@w32_init_h

; 1612 :         {
; 1613 :             memset(ppi, 0, (size_t)size);

  004d9	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  004dd	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv265[rsp], rax
  004e5	48 8b bc 24 80
	00 00 00	 mov	 rdi, QWORD PTR ppi$6[rsp]
  004ed	33 c0		 xor	 eax, eax
  004ef	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv265[rsp]
  004f7	f3 aa		 rep stosb

; 1614 : 
; 1615 :             Pwrinfo = (CNPI)GetProcAddress(LoadLibrary(TEXT("powrprof.dll")), "CallNtPowerInformation");

  004f9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159959
  00500	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LoadLibraryA
  00506	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159958
  0050d	48 8b c8	 mov	 rcx, rax
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00516	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR Pwrinfo$8[rsp], rax

; 1616 : 
; 1617 :             if ( (LONG)0 == Pwrinfo(ProcessorInformation, NULL, 0, ppi, size) )

  0051e	8b 44 24 50	 mov	 eax, DWORD PTR size$1[rsp]
  00522	89 44 24 20	 mov	 DWORD PTR [rsp+32], eax
  00526	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR ppi$6[rsp]
  0052e	45 33 c0	 xor	 r8d, r8d
  00531	33 d2		 xor	 edx, edx
  00533	b9 0b 00 00 00	 mov	 ecx, 11
  00538	ff 94 24 e8 00
	00 00		 call	 QWORD PTR Pwrinfo$8[rsp]
  0053f	85 c0		 test	 eax, eax
  00541	75 21		 jne	 SHORT $LN34@w32_init_h

; 1618 :                 pHostInfo->cpu_speed = ((U64)ppi->MaxMhz * ONE_MILLION);

  00543	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR ppi$6[rsp]
  0054b	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  0054e	48 69 c0 40 42
	0f 00		 imul	 rax, rax, 1000000	; 000f4240H
  00555	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  0055d	48 89 81 e8 01
	00 00		 mov	 QWORD PTR [rcx+488], rax
$LN34@w32_init_h:

; 1619 : 
; 1620 :             free(ppi);

  00564	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR ppi$6[rsp]
  0056c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN33@w32_init_h:

; 1621 :         }
; 1622 :     }
; 1623 : 
; 1624 :     {   /* CPUID information */
; 1625 :         int CPUInfo[4] = {-1, -1, -1, -1 };

  00572	c7 84 24 10 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$10[rsp], -1
  0057d	c7 84 24 14 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$10[rsp+4], -1
  00588	c7 84 24 18 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$10[rsp+8], -1
  00593	c7 84 24 1c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$10[rsp+12], -1

; 1626 : 
; 1627 :         __cpuid(CPUInfo, 1);

  0059e	b8 01 00 00 00	 mov	 eax, 1
  005a3	33 c9		 xor	 ecx, ecx
  005a5	0f a2		 cpuid
  005a7	48 8d bc 24 10
	02 00 00	 lea	 rdi, QWORD PTR CPUInfo$10[rsp]
  005af	89 07		 mov	 DWORD PTR [rdi], eax
  005b1	89 5f 04	 mov	 DWORD PTR [rdi+4], ebx
  005b4	89 4f 08	 mov	 DWORD PTR [rdi+8], ecx
  005b7	89 57 0c	 mov	 DWORD PTR [rdi+12], edx

; 1628 :         if ( CPUInfo[2] & ( 1 << 25 ) )

  005ba	b8 04 00 00 00	 mov	 eax, 4
  005bf	48 6b c0 02	 imul	 rax, rax, 2
  005c3	8b 84 04 10 02
	00 00		 mov	 eax, DWORD PTR CPUInfo$10[rsp+rax]
  005ca	25 00 00 00 02	 and	 eax, 33554432		; 02000000H
  005cf	85 c0		 test	 eax, eax
  005d1	74 12		 je	 SHORT $LN35@w32_init_h

; 1629 :             pHostInfo->cpu_aes_extns = 1;

  005d3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  005db	c7 80 d4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+468], 1
$LN35@w32_init_h:

; 1630 :         if ( CPUInfo[3] & 1 )

  005e5	b8 04 00 00 00	 mov	 eax, 4
  005ea	48 6b c0 03	 imul	 rax, rax, 3
  005ee	8b 84 04 10 02
	00 00		 mov	 eax, DWORD PTR CPUInfo$10[rsp+rax]
  005f5	83 e0 01	 and	 eax, 1
  005f8	85 c0		 test	 eax, eax
  005fa	74 12		 je	 SHORT $LN36@w32_init_h

; 1631 :             pHostInfo->fp_unit = 1;

  005fc	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00604	c7 80 cc 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+460], 1
$LN36@w32_init_h:

; 1632 :         if ( CPUInfo[3] & 0x03800000 ) /* bit 23 = MMX, 24 = SSE, 25 == SSE2 */

  0060e	b8 04 00 00 00	 mov	 eax, 4
  00613	48 6b c0 03	 imul	 rax, rax, 3
  00617	8b 84 04 10 02
	00 00		 mov	 eax, DWORD PTR CPUInfo$10[rsp+rax]
  0061e	25 00 00 80 03	 and	 eax, 58720256		; 03800000H
  00623	85 c0		 test	 eax, eax
  00625	74 12		 je	 SHORT $LN37@w32_init_h

; 1633 :             pHostInfo->vector_unit = 1;

  00627	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  0062f	c7 80 c8 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+456], 1
$LN37@w32_init_h:

; 1634 :     }
; 1635 : 
; 1636 :     pgnsi = (PGNSI) GetProcAddress( GetModuleHandle(TEXT("kernel32.dll")), "GetNativeSystemInfo");

  00639	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159965
  00640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  00646	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159964
  0064d	48 8b c8	 mov	 rcx, rax
  00650	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  00656	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR pgnsi$[rsp], rax

; 1637 :     if (NULL != pgnsi)

  0065e	48 83 bc 24 a8
	00 00 00 00	 cmp	 QWORD PTR pgnsi$[rsp], 0
  00667	74 11		 je	 SHORT $LN38@w32_init_h

; 1638 :         pgnsi( &si );

  00669	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR si$[rsp]
  00671	ff 94 24 a8 00
	00 00		 call	 QWORD PTR pgnsi$[rsp]
  00678	eb 0e		 jmp	 SHORT $LN39@w32_init_h
$LN38@w32_init_h:

; 1639 :     else GetSystemInfo( &si );

  0067a	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR si$[rsp]
  00682	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemInfo
$LN39@w32_init_h:

; 1640 : 
; 1641 :     vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

  00688	c7 84 24 20 01
	00 00 9c 00 00
	00		 mov	 DWORD PTR vi$[rsp], 156	; 0000009cH

; 1642 :     if (!(ext = GetVersionEx ((OSVERSIONINFO *) &vi)))

  00693	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR vi$[rsp]
  0069b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetVersionExA
  006a1	89 84 24 9c 00
	00 00		 mov	 DWORD PTR ext$[rsp], eax
  006a8	83 bc 24 9c 00
	00 00 00	 cmp	 DWORD PTR ext$[rsp], 0
  006b0	75 29		 jne	 SHORT $LN40@w32_init_h

; 1643 :     {
; 1644 :         vi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

  006b2	c7 84 24 20 01
	00 00 94 00 00
	00		 mov	 DWORD PTR vi$[rsp], 148	; 00000094H

; 1645 :         if (!GetVersionEx ((OSVERSIONINFO *) &vi))

  006bd	48 8d 8c 24 20
	01 00 00	 lea	 rcx, QWORD PTR vi$[rsp]
  006c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetVersionExA
  006cb	85 c0		 test	 eax, eax
  006cd	75 0c		 jne	 SHORT $LN41@w32_init_h

; 1646 :         {
; 1647 :             psz = "??";

  006cf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159970
  006d6	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
$LN41@w32_init_h:
$LN40@w32_init_h:

; 1648 :         }
; 1649 :     }
; 1650 : 
; 1651 :     switch ( vi.dwPlatformId )

  006db	8b 84 24 30 01
	00 00		 mov	 eax, DWORD PTR vi$[rsp+16]
  006e2	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv316[rsp], eax
  006e9	83 bc 24 88 00
	00 00 01	 cmp	 DWORD PTR tv316[rsp], 1
  006f1	74 0f		 je	 SHORT $LN42@w32_init_h
  006f3	83 bc 24 88 00
	00 00 02	 cmp	 DWORD PTR tv316[rsp], 2
  006fb	74 16		 je	 SHORT $LN43@w32_init_h
  006fd	e9 bd 08 00 00	 jmp	 $LN168@w32_init_h
$LN42@w32_init_h:

; 1652 :     {
; 1653 :         case VER_PLATFORM_WIN32_WINDOWS:
; 1654 :             psz = "9x";

  00702	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159972
  00709	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax

; 1655 :             break;

  0070e	e9 c4 08 00 00	 jmp	 $LN6@w32_init_h
$LN43@w32_init_h:

; 1656 :         case VER_PLATFORM_WIN32_NT:
; 1657 : 
; 1658 :             // This list is current as of 2010-03-13 using V7.0 MS SDK
; 1659 : 
; 1660 :             if ( vi.dwMajorVersion == 6 )

  00713	83 bc 24 24 01
	00 00 06	 cmp	 DWORD PTR vi$[rsp+4], 6
  0071b	0f 85 8c 05 00
	00		 jne	 $LN44@w32_init_h

; 1661 :             {
; 1662 :                 pgpi = (PGPI) GetProcAddress(

  00721	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159976
  00728	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0072e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159975
  00735	48 8b c8	 mov	 rcx, rax
  00738	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetProcAddress
  0073e	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR pgpi$[rsp], rax

; 1663 :                                   GetModuleHandle( TEXT( "kernel32.dll" ) ),
; 1664 :                                  "GetProductInfo" );
; 1665 :                 pgpi( vi.dwMajorVersion, vi.dwMinorVersion,

  00746	0f b7 84 24 b6
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+150]
  0074e	0f b7 8c 24 b4
	01 00 00	 movzx	 ecx, WORD PTR vi$[rsp+148]
  00756	48 8d 54 24 74	 lea	 rdx, QWORD PTR dw$[rsp]
  0075b	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  00760	44 8b c8	 mov	 r9d, eax
  00763	44 8b c1	 mov	 r8d, ecx
  00766	8b 94 24 28 01
	00 00		 mov	 edx, DWORD PTR vi$[rsp+8]
  0076d	8b 8c 24 24 01
	00 00		 mov	 ecx, DWORD PTR vi$[rsp+4]
  00774	ff 94 24 f0 00
	00 00		 call	 QWORD PTR pgpi$[rsp]

; 1666 :                       vi.wServicePackMajor, vi.wServicePackMinor, &dw );
; 1667 : 
; 1668 :                 if ( vi.dwMinorVersion == 0 )

  0077b	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR vi$[rsp+8], 0
  00783	75 27		 jne	 SHORT $LN45@w32_init_h

; 1669 :                 {
; 1670 :                     if ( vi.wProductType == VER_NT_WORKSTATION )

  00785	0f b6 84 24 ba
	01 00 00	 movzx	 eax, BYTE PTR vi$[rsp+154]
  0078d	83 f8 01	 cmp	 eax, 1
  00790	75 0e		 jne	 SHORT $LN46@w32_init_h

; 1671 :                         psz = "Vista";

  00792	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159980
  00799	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  0079e	eb 0c		 jmp	 SHORT $LN47@w32_init_h
$LN46@w32_init_h:

; 1672 :                     else
; 1673 :                         psz = "Server 2008";

  007a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159981
  007a7	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
$LN47@w32_init_h:
$LN45@w32_init_h:

; 1674 :                 }
; 1675 :                 if ( vi.dwMinorVersion == 1 )

  007ac	83 bc 24 28 01
	00 00 01	 cmp	 DWORD PTR vi$[rsp+8], 1
  007b4	75 27		 jne	 SHORT $LN48@w32_init_h

; 1676 :                 {
; 1677 :                     if ( vi.wProductType == VER_NT_WORKSTATION )

  007b6	0f b6 84 24 ba
	01 00 00	 movzx	 eax, BYTE PTR vi$[rsp+154]
  007be	83 f8 01	 cmp	 eax, 1
  007c1	75 0e		 jne	 SHORT $LN49@w32_init_h

; 1678 :                         psz = "7";

  007c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159985
  007ca	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  007cf	eb 0c		 jmp	 SHORT $LN50@w32_init_h
$LN49@w32_init_h:

; 1679 :                     else
; 1680 :                         psz = "Server 2008 R2";

  007d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159986
  007d8	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
$LN50@w32_init_h:
$LN48@w32_init_h:

; 1681 :                 }
; 1682 : 
; 1683 :                 switch( dw )

  007dd	8b 44 24 74	 mov	 eax, DWORD PTR dw$[rsp]
  007e1	89 44 24 38	 mov	 DWORD PTR tv336[rsp], eax
  007e5	83 7c 24 38 24	 cmp	 DWORD PTR tv336[rsp], 36 ; 00000024H
  007ea	77 2d		 ja	 SHORT $LN190@w32_init_h
  007ec	83 7c 24 38 24	 cmp	 DWORD PTR tv336[rsp], 36 ; 00000024H
  007f1	0f 84 fa 02 00
	00		 je	 $LN94@w32_init_h
  007f7	83 7c 24 38 23	 cmp	 DWORD PTR tv336[rsp], 35 ; 00000023H
  007fc	0f 87 9f 04 00
	00		 ja	 $LN123@w32_init_h
  00802	8b 44 24 38	 mov	 eax, DWORD PTR tv336[rsp]
  00806	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0080d	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN197@w32_init_h[rcx+rax*4]
  00814	48 03 c1	 add	 rax, rcx
  00817	ff e0		 jmp	 rax
$LN190@w32_init_h:
  00819	83 7c 24 38 36	 cmp	 DWORD PTR tv336[rsp], 54 ; 00000036H
  0081e	77 38		 ja	 SHORT $LN191@w32_init_h
  00820	83 7c 24 38 36	 cmp	 DWORD PTR tv336[rsp], 54 ; 00000036H
  00825	0f 84 81 03 00
	00		 je	 $LN106@w32_init_h
  0082b	8b 44 24 38	 mov	 eax, DWORD PTR tv336[rsp]
  0082f	83 e8 25	 sub	 eax, 37			; 00000025H
  00832	89 44 24 38	 mov	 DWORD PTR tv336[rsp], eax
  00836	83 7c 24 38 10	 cmp	 DWORD PTR tv336[rsp], 16
  0083b	0f 87 60 04 00
	00		 ja	 $LN123@w32_init_h
  00841	8b 44 24 38	 mov	 eax, DWORD PTR tv336[rsp]
  00845	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0084c	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN196@w32_init_h[rcx+rax*4]
  00853	48 03 c1	 add	 rax, rcx
  00856	ff e0		 jmp	 rax
$LN191@w32_init_h:
  00858	83 7c 24 38 40	 cmp	 DWORD PTR tv336[rsp], 64 ; 00000040H
  0085d	77 38		 ja	 SHORT $LN192@w32_init_h
  0085f	83 7c 24 38 40	 cmp	 DWORD PTR tv336[rsp], 64 ; 00000040H
  00864	0f 84 77 01 00
	00		 je	 $LN78@w32_init_h
  0086a	8b 44 24 38	 mov	 eax, DWORD PTR tv336[rsp]
  0086e	83 e8 37	 sub	 eax, 55			; 00000037H
  00871	89 44 24 38	 mov	 DWORD PTR tv336[rsp], eax
  00875	83 7c 24 38 08	 cmp	 DWORD PTR tv336[rsp], 8
  0087a	0f 87 21 04 00
	00		 ja	 $LN123@w32_init_h
  00880	8b 44 24 38	 mov	 eax, DWORD PTR tv336[rsp]
  00884	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0088b	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN195@w32_init_h[rcx+rax*4]
  00892	48 03 c1	 add	 rax, rcx
  00895	ff e0		 jmp	 rax
$LN192@w32_init_h:
  00897	83 7c 24 38 45	 cmp	 DWORD PTR tv336[rsp], 69 ; 00000045H
  0089c	77 30		 ja	 SHORT $LN193@w32_init_h
  0089e	83 7c 24 38 45	 cmp	 DWORD PTR tv336[rsp], 69 ; 00000045H
  008a3	74 5f		 je	 SHORT $LN55@w32_init_h
  008a5	83 7c 24 38 41	 cmp	 DWORD PTR tv336[rsp], 65 ; 00000041H
  008aa	0f 84 ab 03 00
	00		 je	 $LN118@w32_init_h
  008b0	83 7c 24 38 42	 cmp	 DWORD PTR tv336[rsp], 66 ; 00000042H
  008b5	0f 84 04 01 00
	00		 je	 $LN75@w32_init_h
  008bb	83 7c 24 38 43	 cmp	 DWORD PTR tv336[rsp], 67 ; 00000043H
  008c0	74 64		 je	 SHORT $LN61@w32_init_h
  008c2	83 7c 24 38 44	 cmp	 DWORD PTR tv336[rsp], 68 ; 00000044H
  008c7	74 4c		 je	 SHORT $LN58@w32_init_h
  008c9	e9 d3 03 00 00	 jmp	 $LN123@w32_init_h
$LN193@w32_init_h:
  008ce	83 7c 24 38 46	 cmp	 DWORD PTR tv336[rsp], 70 ; 00000046H
  008d3	0f 84 91 00 00
	00		 je	 $LN67@w32_init_h
  008d9	83 7c 24 38 47	 cmp	 DWORD PTR tv336[rsp], 71 ; 00000047H
  008de	74 13		 je	 SHORT $LN52@w32_init_h
  008e0	81 7c 24 38 cd
	ab cd ab	 cmp	 DWORD PTR tv336[rsp], -1412584499 ; abcdabcdH
  008e8	0f 84 a5 03 00
	00		 je	 $LN122@w32_init_h
  008ee	e9 ae 03 00 00	 jmp	 $LN123@w32_init_h
$LN51@w32_init_h:
$LN52@w32_init_h:
$LN53@w32_init_h:

; 1684 :                 {
; 1685 :                     case PRODUCT_ULTIMATE:
; 1686 : #if defined(PRODUCT_ULTIMATE_E)
; 1687 :                     case PRODUCT_ULTIMATE_E:
; 1688 : #endif
; 1689 : #if defined(PRODUCT_ULTIMATE_N)
; 1690 :                     case PRODUCT_ULTIMATE_N:
; 1691 : #endif
; 1692 :                         prod_id = "Ultimate Edition";

  008f3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159990
  008fa	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1693 :                         break;

  008ff	e9 a9 03 00 00	 jmp	 $LN8@w32_init_h
$LN54@w32_init_h:
$LN55@w32_init_h:
$LN56@w32_init_h:

; 1694 : #if defined(PRODUCT_PROFESSIONAL) || defined(PRODUCT_PROFESSIONAL_E) || defined(PRODUCT_PROFESSION_N)
; 1695 : #if defined(PRODUCT_PROFESSIONAL)
; 1696 :                     case PRODUCT_PROFESSIONAL:
; 1697 : #endif
; 1698 : #if defined(PRODUCT_PROFESSIONAL_E)
; 1699 :                     case PRODUCT_PROFESSIONAL_E:
; 1700 : #endif
; 1701 : #if defined(PRODUCT_PROFESSIONAL_N)
; 1702 :                     case PRODUCT_PROFESSIONAL_N:
; 1703 : #endif
; 1704 :                         prod_id = "Professional";

  00904	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159994
  0090b	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1705 :                         break;

  00910	e9 98 03 00 00	 jmp	 $LN8@w32_init_h
$LN57@w32_init_h:
$LN58@w32_init_h:
$LN59@w32_init_h:

; 1706 : #endif
; 1707 :                     case PRODUCT_HOME_PREMIUM:
; 1708 : #if defined(PRODUCT_HOME_PREMIUM_E)
; 1709 :                     case PRODUCT_HOME_PREMIUM_E:
; 1710 : #endif
; 1711 : #if defined(PRODUCT_HOME_PREMIUM_N)
; 1712 :                     case PRODUCT_HOME_PREMIUM_N:
; 1713 : #endif
; 1714 :                         prod_id = "Home Premium Edition";

  00915	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG159998
  0091c	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1715 :                         break;

  00921	e9 87 03 00 00	 jmp	 $LN8@w32_init_h
$LN60@w32_init_h:
$LN61@w32_init_h:
$LN62@w32_init_h:

; 1716 :                     case PRODUCT_HOME_BASIC:
; 1717 : #if defined(PRODUCT_HOME_BASIC_E)
; 1718 :                     case PRODUCT_HOME_BASIC_E:
; 1719 : #endif
; 1720 :                     case PRODUCT_HOME_BASIC_N:
; 1721 :                         prod_id = "Home Basic Edition";

  00926	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160002
  0092d	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1722 :                         break;

  00932	e9 76 03 00 00	 jmp	 $LN8@w32_init_h
$LN63@w32_init_h:

; 1723 :                     case PRODUCT_HOME_SERVER:
; 1724 :                         prod_id = "Home Server";

  00937	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160004
  0093e	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1725 :                         break;

  00943	e9 65 03 00 00	 jmp	 $LN8@w32_init_h
$LN64@w32_init_h:

; 1726 : #if defined(PRODUCT_HOME_PREMIUM_SERVER)
; 1727 :                     case PRODUCT_HOME_PREMIUM_SERVER:
; 1728 :                         prod_id = "Home Premium Server";

  00948	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160006
  0094f	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1729 :                         break;

  00954	e9 54 03 00 00	 jmp	 $LN8@w32_init_h
$LN65@w32_init_h:

; 1730 : #endif
; 1731 : #if defined(PRODUCT_HYPERV)
; 1732 :                     case PRODUCT_HYPERV:
; 1733 :                         prod_id = "Hyper-V";

  00959	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160008
  00960	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1734 :                         break;

  00965	e9 43 03 00 00	 jmp	 $LN8@w32_init_h
$LN66@w32_init_h:
$LN67@w32_init_h:
$LN68@w32_init_h:

; 1735 : #endif
; 1736 :                     case PRODUCT_ENTERPRISE:
; 1737 : #if defined(PRODUCT_ENTERPRISE_E)
; 1738 :                     case PRODUCT_ENTERPRISE_E:
; 1739 : #endif
; 1740 : #if defined(PRODUCT_ENTERPRISE_N)
; 1741 :                     case PRODUCT_ENTERPRISE_N:
; 1742 : #endif
; 1743 :                         prod_id = "Enterprise Edition";

  0096a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160012
  00971	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1744 :                         break;

  00976	e9 32 03 00 00	 jmp	 $LN8@w32_init_h
$LN69@w32_init_h:
$LN70@w32_init_h:

; 1745 :                     case PRODUCT_BUSINESS:
; 1746 :                     case PRODUCT_BUSINESS_N:
; 1747 :                         prod_id = "Business Edition";

  0097b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160015
  00982	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1748 :                         break;

  00987	e9 21 03 00 00	 jmp	 $LN8@w32_init_h
$LN71@w32_init_h:

; 1749 : #if defined(PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT)
; 1750 :                     case PRODUCT_MEDIUMBUSINESS_SERVER_MANAGEMENT:
; 1751 :                         prod_id = "Essential Business Server Management";

  0098c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160017
  00993	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1752 :                         break;

  00998	e9 10 03 00 00	 jmp	 $LN8@w32_init_h
$LN72@w32_init_h:

; 1753 : #endif
; 1754 : #if defined(PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING)
; 1755 :                     case PRODUCT_MEDIUMBUSINESS_SERVER_MESSAGING:
; 1756 :                         prod_id = "Essential Business Server Messaging";

  0099d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160019
  009a4	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1757 :                         break;

  009a9	e9 ff 02 00 00	 jmp	 $LN8@w32_init_h
$LN73@w32_init_h:

; 1758 : #endif
; 1759 : #if defined(PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY)
; 1760 :                     case PRODUCT_MEDIUMBUSINESS_SERVER_SECURITY:
; 1761 :                         prod_id = "Essential Business Server Security";

  009ae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160021
  009b5	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1762 :                         break;

  009ba	e9 ee 02 00 00	 jmp	 $LN8@w32_init_h
$LN74@w32_init_h:
$LN75@w32_init_h:
$LN76@w32_init_h:

; 1763 : #endif
; 1764 :                     case PRODUCT_STARTER:
; 1765 : #if defined(PRODUCT_STARTER_E)
; 1766 :                     case PRODUCT_STARTER_E:
; 1767 : #endif
; 1768 : #if defined(PRODUCT_STARTER_N)
; 1769 :                     case PRODUCT_STARTER_N:
; 1770 : #endif
; 1771 :                         prod_id = "Starter Edition";

  009bf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160025
  009c6	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1772 :                         break;

  009cb	e9 dd 02 00 00	 jmp	 $LN8@w32_init_h
$LN77@w32_init_h:

; 1773 :                     case PRODUCT_CLUSTER_SERVER:
; 1774 :                         prod_id = "Cluster Server Edition";

  009d0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160027
  009d7	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1775 :                         break;

  009dc	e9 cc 02 00 00	 jmp	 $LN8@w32_init_h
$LN78@w32_init_h:

; 1776 : #if defined(PRODUCT_CLUSTER_SERVER_V)
; 1777 :                     case PRODUCT_CLUSTER_SERVER_V:
; 1778 :                         prod_id = "Cluster Server Edition w/o Hyper-V";

  009e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160029
  009e8	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1779 :                         break;

  009ed	e9 bb 02 00 00	 jmp	 $LN8@w32_init_h
$LN79@w32_init_h:

; 1780 : #endif
; 1781 :                     case PRODUCT_DATACENTER_SERVER:
; 1782 :                         prod_id = "Datacenter Edition";

  009f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160031
  009f9	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1783 :                         break;

  009fe	e9 aa 02 00 00	 jmp	 $LN8@w32_init_h
$LN80@w32_init_h:

; 1784 : #if defined(PRODUCT_DATACENTER_SERVER_V)
; 1785 :                     case PRODUCT_DATACENTER_SERVER_V:
; 1786 :                         prod_id = "Datacenter Edition w/o Hyper-V";

  00a03	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160033
  00a0a	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1787 :                         break;

  00a0f	e9 99 02 00 00	 jmp	 $LN8@w32_init_h
$LN81@w32_init_h:

; 1788 : #endif
; 1789 : 
; 1790 :                     case PRODUCT_DATACENTER_SERVER_CORE:
; 1791 :                         prod_id = "Datacenter Edition (core)";

  00a14	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160035
  00a1b	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1792 :                         break;

  00a20	e9 88 02 00 00	 jmp	 $LN8@w32_init_h
$LN82@w32_init_h:

; 1793 : #if defined(PRODUCT_DATACENTER_SERVER_CORE_V)
; 1794 :                     case PRODUCT_DATACENTER_SERVER_CORE_V:
; 1795 :                         prod_id = "Datacenter Edition w/o Hyper-V (core)";

  00a25	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160037
  00a2c	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1796 :                         break;

  00a31	e9 77 02 00 00	 jmp	 $LN8@w32_init_h
$LN83@w32_init_h:

; 1797 : #endif
; 1798 :                     case PRODUCT_ENTERPRISE_SERVER:
; 1799 :                         prod_id = "Enterprise Edition";

  00a36	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160039
  00a3d	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1800 :                         break;

  00a42	e9 66 02 00 00	 jmp	 $LN8@w32_init_h
$LN84@w32_init_h:

; 1801 : #if defined(PRODUCT_ENTERPRISE_SERVER_V)
; 1802 :                     case PRODUCT_ENTERPRISE_SERVER_V:
; 1803 :                         prod_id = "Enterprise Edition w/o Hyper-V";

  00a47	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160041
  00a4e	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1804 :                         break;

  00a53	e9 55 02 00 00	 jmp	 $LN8@w32_init_h
$LN85@w32_init_h:

; 1805 : #endif
; 1806 :                     case PRODUCT_ENTERPRISE_SERVER_CORE:
; 1807 :                         prod_id = "Enterprise Edition (core)";

  00a58	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160043
  00a5f	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1808 :                         break;

  00a64	e9 44 02 00 00	 jmp	 $LN8@w32_init_h
$LN86@w32_init_h:

; 1809 : #if defined(PRODUCT_ENTERPRISE_SERVER_CORE_V)
; 1810 :                     case PRODUCT_ENTERPRISE_SERVER_CORE_V:
; 1811 :                         prod_id = "Enterprise Edition w/o Hyper-V (core)";

  00a69	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160045
  00a70	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1812 :                         break;

  00a75	e9 33 02 00 00	 jmp	 $LN8@w32_init_h
$LN87@w32_init_h:

; 1813 : #endif
; 1814 :                     case PRODUCT_ENTERPRISE_SERVER_IA64:
; 1815 :                         prod_id = "Enterprise Edition for IA64 Systems";

  00a7a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160047
  00a81	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1816 :                         break;

  00a86	e9 22 02 00 00	 jmp	 $LN8@w32_init_h
$LN88@w32_init_h:

; 1817 :                     case PRODUCT_SERVER_FOR_SMALLBUSINESS:
; 1818 :                         prod_id = "Essential Server Solutions";

  00a8b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160049
  00a92	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1819 :                         break;

  00a97	e9 11 02 00 00	 jmp	 $LN8@w32_init_h
$LN89@w32_init_h:

; 1820 : #if defined(PRODUCT_SERVER_FOR_SMALLBUSINESS_V)
; 1821 :                     case PRODUCT_SERVER_FOR_SMALLBUSINESS_V:
; 1822 :                         prod_id = "Essential Server Solutions w/o Hyper-V";

  00a9c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160051
  00aa3	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1823 :                         break;

  00aa8	e9 00 02 00 00	 jmp	 $LN8@w32_init_h
$LN90@w32_init_h:

; 1824 : #endif
; 1825 : #if defined(PRODUCT_SERVER_FOUNDATION)
; 1826 :                     case PRODUCT_SERVER_FOUNDATION:
; 1827 :                         prod_id = "Server Foundation";

  00aad	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160053
  00ab4	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1828 :                         break;

  00ab9	e9 ef 01 00 00	 jmp	 $LN8@w32_init_h
$LN91@w32_init_h:

; 1829 : #endif
; 1830 :                     case PRODUCT_SMALLBUSINESS_SERVER:
; 1831 :                         prod_id = "Small Business Server";

  00abe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160055
  00ac5	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1832 :                         break;

  00aca	e9 de 01 00 00	 jmp	 $LN8@w32_init_h
$LN92@w32_init_h:

; 1833 :                     case PRODUCT_SMALLBUSINESS_SERVER_PREMIUM:
; 1834 :                         prod_id = "Small Business Server Premium Edition";

  00acf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160057
  00ad6	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1835 :                         break;

  00adb	e9 cd 01 00 00	 jmp	 $LN8@w32_init_h
$LN93@w32_init_h:

; 1836 :                     case PRODUCT_STANDARD_SERVER:
; 1837 :                         prod_id = "Standard Edition";

  00ae0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160059
  00ae7	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1838 :                         break;

  00aec	e9 bc 01 00 00	 jmp	 $LN8@w32_init_h
$LN94@w32_init_h:

; 1839 : #if defined(PRODUCT_STANDARD_SERVER_V)
; 1840 :                     case PRODUCT_STANDARD_SERVER_V:
; 1841 :                         prod_id = "Standard Edition w/o Hyper-V";

  00af1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160061
  00af8	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1842 :                         break;

  00afd	e9 ab 01 00 00	 jmp	 $LN8@w32_init_h
$LN95@w32_init_h:

; 1843 : #endif
; 1844 :                     case PRODUCT_STANDARD_SERVER_CORE:
; 1845 :                         prod_id = "Standard Edition (core)";

  00b02	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160063
  00b09	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1846 :                         break;

  00b0e	e9 9a 01 00 00	 jmp	 $LN8@w32_init_h
$LN96@w32_init_h:

; 1847 : #if defined(PRODUCT_STANDARD_SERVER_CORE_V)
; 1848 :                     case PRODUCT_STANDARD_SERVER_CORE_V:
; 1849 :                         prod_id = "Standard Edition w/o Hyper-V (core)";

  00b13	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160065
  00b1a	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1850 :                         break;

  00b1f	e9 89 01 00 00	 jmp	 $LN8@w32_init_h
$LN97@w32_init_h:

; 1851 : #endif
; 1852 :                     case PRODUCT_STORAGE_ENTERPRISE_SERVER:
; 1853 :                         prod_id = "Storage Server Enterprise";

  00b24	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160067
  00b2b	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1854 :                         break;

  00b30	e9 78 01 00 00	 jmp	 $LN8@w32_init_h
$LN98@w32_init_h:

; 1855 :                     case PRODUCT_STORAGE_EXPRESS_SERVER:
; 1856 :                         prod_id = "Storage Server Express";

  00b35	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160069
  00b3c	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1857 :                         break;

  00b41	e9 67 01 00 00	 jmp	 $LN8@w32_init_h
$LN99@w32_init_h:

; 1858 :                     case PRODUCT_STORAGE_STANDARD_SERVER:
; 1859 :                         prod_id = "Storage Server Standard";

  00b46	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160071
  00b4d	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1860 :                         break;

  00b52	e9 56 01 00 00	 jmp	 $LN8@w32_init_h
$LN100@w32_init_h:

; 1861 :                     case PRODUCT_STORAGE_WORKGROUP_SERVER:
; 1862 :                         prod_id = "Storage Server Workgroup";

  00b57	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160073
  00b5e	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1863 :                         break;

  00b63	e9 45 01 00 00	 jmp	 $LN8@w32_init_h
$LN101@w32_init_h:

; 1864 : #if defined(PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE)
; 1865 :                     case PRODUCT_STORAGE_ENTERPRISE_SERVER_CORE:
; 1866 :                         prod_id = "Storage Server Enterprise (core)";

  00b68	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160075
  00b6f	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1867 :                         break;

  00b74	e9 34 01 00 00	 jmp	 $LN8@w32_init_h
$LN102@w32_init_h:

; 1868 : #endif
; 1869 : #if defined(PRODUCT_STORAGE_EXPRESS_SERVER_CORE)
; 1870 :                     case PRODUCT_STORAGE_EXPRESS_SERVER_CORE:
; 1871 :                         prod_id = "Storage Server Express (core)";

  00b79	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160077
  00b80	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1872 :                         break;

  00b85	e9 23 01 00 00	 jmp	 $LN8@w32_init_h
$LN103@w32_init_h:

; 1873 : #endif
; 1874 : #if defined(PRODUCT_STORAGE_STANDARD_SERVER_CORE)
; 1875 :                     case PRODUCT_STORAGE_STANDARD_SERVER_CORE:
; 1876 :                         prod_id = "Storage Server Standard (core)";

  00b8a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160079
  00b91	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1877 :                         break;

  00b96	e9 12 01 00 00	 jmp	 $LN8@w32_init_h
$LN104@w32_init_h:

; 1878 : #endif
; 1879 : #if defined(PRODUCT_STORAGE_WORKGROUP_SERVER_CORE)
; 1880 :                     case PRODUCT_STORAGE_WORKGROUP_SERVER_CORE:
; 1881 :                         prod_id = "Storage Server Workgroup (core)";

  00b9b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160081
  00ba2	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1882 :                         break;

  00ba7	e9 01 01 00 00	 jmp	 $LN8@w32_init_h
$LN105@w32_init_h:
$LN106@w32_init_h:

; 1883 : #endif
; 1884 : #if defined(PRODUCT_SB_SOLUTION_SERVER) || defined(PRODUCT_SB_SOLUTION_SERVER_EM)
; 1885 : #if defined(PRODUCT_SB_SOLUTION_SERVER)
; 1886 :                     case PRODUCT_SB_SOLUTION_SERVER:
; 1887 : #endif
; 1888 : #if defined(PRODUCT_SB_SOLUTION_SERVER_EM)
; 1889 :                     case PRODUCT_SB_SOLUTION_SERVER_EM:
; 1890 : #endif
; 1891 :                         prod_id = "Small Business Solution Server";

  00bac	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160084
  00bb3	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1892 :                         break;

  00bb8	e9 f0 00 00 00	 jmp	 $LN8@w32_init_h
$LN107@w32_init_h:
$LN108@w32_init_h:

; 1893 : #endif
; 1894 : #if defined(PRODUCT_SERVER_FOR_SB_SOLUTIONS) || defined(PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM)
; 1895 : #if defined(PRODUCT_SERVER_FOR_SB_SOLUTIONS)
; 1896 :                     case PRODUCT_SERVER_FOR_SB_SOLUTIONS:
; 1897 : #endif
; 1898 : #if defined(PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM)
; 1899 :                     case PRODUCT_SERVER_FOR_SB_SOLUTIONS_EM:
; 1900 : #endif
; 1901 :                         prod_id = "Server for Small Business Solutions";

  00bbd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160087
  00bc4	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1902 :                         break;

  00bc9	e9 df 00 00 00	 jmp	 $LN8@w32_init_h
$LN109@w32_init_h:

; 1903 : #endif
; 1904 : #if defined(PRODUCT_STANDARD_SERVER_SOLUTIONS)
; 1905 :                     case PRODUCT_STANDARD_SERVER_SOLUTIONS:
; 1906 :                         prod_id = "Standard Server Solutions";

  00bce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160089
  00bd5	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1907 :                         break;

  00bda	e9 ce 00 00 00	 jmp	 $LN8@w32_init_h
$LN110@w32_init_h:

; 1908 : #endif
; 1909 : #if defined(PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE)
; 1910 :                     case PRODUCT_STANDARD_SERVER_SOLUTIONS_CORE:
; 1911 :                         prod_id = "Standard Server Solutions (core)";

  00bdf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160091
  00be6	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1912 :                         break;

  00beb	e9 bd 00 00 00	 jmp	 $LN8@w32_init_h
$LN111@w32_init_h:

; 1913 : #endif
; 1914 : #if defined(PRODUCT_SOLUTION_EMBEDDEDSERVER)
; 1915 :                     case PRODUCT_SOLUTION_EMBEDDEDSERVER:
; 1916 :                         prod_id = "Embedded Solution Server";

  00bf0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160093
  00bf7	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1917 :                         break;

  00bfc	e9 ac 00 00 00	 jmp	 $LN8@w32_init_h
$LN112@w32_init_h:

; 1918 : #endif
; 1919 : #if defined(PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE)
; 1920 :                     case PRODUCT_SOLUTION_EMBEDDEDSERVER_CORE:
; 1921 :                         prod_id = "Embedded Solution Server (core)";

  00c01	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160095
  00c08	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1922 :                         break;

  00c0d	e9 9b 00 00 00	 jmp	 $LN8@w32_init_h
$LN113@w32_init_h:

; 1923 : #endif
; 1924 : #if defined(PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE)
; 1925 :                     case PRODUCT_SMALLBUSINESS_SERVER_PREMIUM_CORE:
; 1926 :                         prod_id = "Small Business Server Premium Edition (core)";

  00c12	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160097
  00c19	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1927 :                         break;

  00c1e	e9 8a 00 00 00	 jmp	 $LN8@w32_init_h
$LN114@w32_init_h:

; 1928 : #endif
; 1929 : #if defined(PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT)
; 1930 :                     case PRODUCT_ESSENTIALBUSINESS_SERVER_MGMT:
; 1931 :                         prod_id = "EBS 2008 Management";

  00c23	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160099
  00c2a	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1932 :                         break;

  00c2f	eb 7c		 jmp	 SHORT $LN8@w32_init_h
$LN115@w32_init_h:

; 1933 : #endif
; 1934 : #if defined(PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL)
; 1935 :                     case PRODUCT_ESSENTIALBUSINESS_SERVER_ADDL:
; 1936 :                         prod_id = "EBS 2008 Additional";

  00c31	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160101
  00c38	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1937 :                         break;

  00c3d	eb 6e		 jmp	 SHORT $LN8@w32_init_h
$LN116@w32_init_h:

; 1938 : #endif
; 1939 : #if defined(PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC)
; 1940 :                     case PRODUCT_ESSENTIALBUSINESS_SERVER_MGMTSVC:
; 1941 :                         prod_id = "EBS 2008 Management Services";

  00c3f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160103
  00c46	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1942 :                         break;

  00c4b	eb 60		 jmp	 SHORT $LN8@w32_init_h
$LN117@w32_init_h:

; 1943 : #endif
; 1944 : #if defined(PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC)
; 1945 :                     case PRODUCT_ESSENTIALBUSINESS_SERVER_ADDLSVC:
; 1946 :                         prod_id = "EBS 2008 Additional Services";

  00c4d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160105
  00c54	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1947 :                         break;

  00c59	eb 52		 jmp	 SHORT $LN8@w32_init_h
$LN118@w32_init_h:

; 1948 : #endif
; 1949 : #if defined(PRODUCT_EMBEDDED)
; 1950 :                     case PRODUCT_EMBEDDED:
; 1951 :                         prod_id = "Embedded Server";

  00c5b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160107
  00c62	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1952 :                         break;

  00c67	eb 44		 jmp	 SHORT $LN8@w32_init_h
$LN119@w32_init_h:

; 1953 : #endif
; 1954 : #if defined(PRODUCT_WEB_SERVER)
; 1955 :                     case PRODUCT_WEB_SERVER:
; 1956 :                         prod_id = "Web Server Edition";

  00c69	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160109
  00c70	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1957 :                         break;

  00c75	eb 36		 jmp	 SHORT $LN8@w32_init_h
$LN120@w32_init_h:

; 1958 : #endif
; 1959 : #if defined(PRODUCT_WEB_SERVER_CORE)
; 1960 :                     case PRODUCT_WEB_SERVER_CORE:
; 1961 :                         prod_id = "Web Server Edition (core)";

  00c77	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160111
  00c7e	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1962 :                         break;

  00c83	eb 28		 jmp	 SHORT $LN8@w32_init_h
$LN121@w32_init_h:

; 1963 : #endif
; 1964 :                     case PRODUCT_UNDEFINED:
; 1965 :                         prod_id = "Undefined Product";

  00c85	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160113
  00c8c	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1966 :                         break;

  00c91	eb 1a		 jmp	 SHORT $LN8@w32_init_h
$LN122@w32_init_h:

; 1967 :                     case PRODUCT_UNLICENSED:
; 1968 :                         prod_id = "Unlicensed Product";

  00c93	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160115
  00c9a	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax

; 1969 :                         break;

  00c9f	eb 0c		 jmp	 SHORT $LN8@w32_init_h
$LN123@w32_init_h:

; 1970 :                     default:
; 1971 :                         prod_id = "unknown";

  00ca1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160117
  00ca8	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
$LN8@w32_init_h:
$LN44@w32_init_h:

; 1972 :                         break;
; 1973 :                 }
; 1974 :             }
; 1975 : 
; 1976 :             if ( vi.dwMajorVersion == 5 && vi.dwMinorVersion == 2 )

  00cad	83 bc 24 24 01
	00 00 05	 cmp	 DWORD PTR vi$[rsp+4], 5
  00cb5	0f 85 da 01 00
	00		 jne	 $LN124@w32_init_h
  00cbb	83 bc 24 28 01
	00 00 02	 cmp	 DWORD PTR vi$[rsp+8], 2
  00cc3	0f 85 cc 01 00
	00		 jne	 $LN124@w32_init_h

; 1977 :             {
; 1978 : #if defined(SM_SERVERR2)
; 1979 :                 if ( GetSystemMetrics (SM_SERVERR2) )

  00cc9	b9 59 00 00 00	 mov	 ecx, 89			; 00000059H
  00cce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemMetrics
  00cd4	85 c0		 test	 eax, eax
  00cd6	74 0e		 je	 SHORT $LN125@w32_init_h

; 1980 :                     psz = "Server 2003 R2";

  00cd8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160121
  00cdf	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  00ce4	eb 72		 jmp	 SHORT $LN126@w32_init_h
$LN125@w32_init_h:

; 1981 :                 else
; 1982 : #endif
; 1983 :                 if ( vi.wSuiteMask & VER_SUITE_STORAGE_SERVER )

  00ce6	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00cee	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00cf3	85 c0		 test	 eax, eax
  00cf5	74 0e		 je	 SHORT $LN127@w32_init_h

; 1984 :                     psz = "Storage Server 2003";

  00cf7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160124
  00cfe	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  00d03	eb 53		 jmp	 SHORT $LN128@w32_init_h
$LN127@w32_init_h:

; 1985 : #if defined(VER_SUITE_WH_SERVER)
; 1986 :                 else if ( vi.wSuiteMask & VER_SUITE_WH_SERVER )

  00d05	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00d0d	25 00 80 00 00	 and	 eax, 32768		; 00008000H
  00d12	85 c0		 test	 eax, eax
  00d14	74 0e		 je	 SHORT $LN129@w32_init_h

; 1987 :                     psz = "Home Server";

  00d16	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160127
  00d1d	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  00d22	eb 34		 jmp	 SHORT $LN130@w32_init_h
$LN129@w32_init_h:

; 1988 : #endif
; 1989 :                 else if ( vi.wProductType == VER_NT_WORKSTATION &&

  00d24	0f b6 84 24 ba
	01 00 00	 movzx	 eax, BYTE PTR vi$[rsp+154]
  00d2c	83 f8 01	 cmp	 eax, 1
  00d2f	75 1b		 jne	 SHORT $LN131@w32_init_h
  00d31	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR si$[rsp]
  00d39	83 f8 09	 cmp	 eax, 9
  00d3c	75 0e		 jne	 SHORT $LN131@w32_init_h

; 1990 :                           si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 )
; 1991 :                     psz = "XP Professional x64 Edition";

  00d3e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160130
  00d45	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  00d4a	eb 0c		 jmp	 SHORT $LN132@w32_init_h
$LN131@w32_init_h:

; 1992 :                 else
; 1993 :                     psz = "Server 2003";

  00d4c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160131
  00d53	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
$LN132@w32_init_h:
$LN130@w32_init_h:
$LN128@w32_init_h:
$LN126@w32_init_h:

; 1994 : 
; 1995 :                 // Test for the server type.
; 1996 :                 if ( vi.wProductType != VER_NT_WORKSTATION )

  00d58	0f b6 84 24 ba
	01 00 00	 movzx	 eax, BYTE PTR vi$[rsp+154]
  00d60	83 f8 01	 cmp	 eax, 1
  00d63	0f 84 2c 01 00
	00		 je	 $LN133@w32_init_h

; 1997 :                 {
; 1998 :                     if ( si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_IA64 )

  00d69	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR si$[rsp]
  00d71	83 f8 06	 cmp	 eax, 6
  00d74	75 3f		 jne	 SHORT $LN134@w32_init_h

; 1999 :                     {
; 2000 :                         if ( vi.wSuiteMask & VER_SUITE_DATACENTER )

  00d76	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00d7e	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00d83	85 c0		 test	 eax, eax
  00d85	74 0e		 je	 SHORT $LN136@w32_init_h

; 2001 :                             prod_id = "Datacenter Edition for IA64 Systems";

  00d87	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160137
  00d8e	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00d93	eb 1b		 jmp	 SHORT $LN137@w32_init_h
$LN136@w32_init_h:

; 2002 :                         else if ( vi.wSuiteMask & VER_SUITE_ENTERPRISE )

  00d95	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00d9d	83 e0 02	 and	 eax, 2
  00da0	85 c0		 test	 eax, eax
  00da2	74 0c		 je	 SHORT $LN138@w32_init_h

; 2003 :                             prod_id = "Enterprise Edition for IA64 Systems";

  00da4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160139
  00dab	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
$LN138@w32_init_h:
$LN137@w32_init_h:

; 2004 :                     }

  00db0	e9 e0 00 00 00	 jmp	 $LN135@w32_init_h
$LN134@w32_init_h:

; 2005 :                     else if ( si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 )

  00db5	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR si$[rsp]
  00dbd	83 f8 09	 cmp	 eax, 9
  00dc0	75 4d		 jne	 SHORT $LN139@w32_init_h

; 2006 :                     {
; 2007 :                         if ( vi.wSuiteMask & VER_SUITE_DATACENTER )

  00dc2	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00dca	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00dcf	85 c0		 test	 eax, eax
  00dd1	74 0e		 je	 SHORT $LN141@w32_init_h

; 2008 :                             prod_id = "Datacenter x64 Edition";

  00dd3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160144
  00dda	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00ddf	eb 29		 jmp	 SHORT $LN142@w32_init_h
$LN141@w32_init_h:

; 2009 :                         else if ( vi.wSuiteMask & VER_SUITE_ENTERPRISE )

  00de1	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00de9	83 e0 02	 and	 eax, 2
  00dec	85 c0		 test	 eax, eax
  00dee	74 0e		 je	 SHORT $LN143@w32_init_h

; 2010 :                             prod_id = "Enterprise x64 Edition";

  00df0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160147
  00df7	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00dfc	eb 0c		 jmp	 SHORT $LN144@w32_init_h
$LN143@w32_init_h:

; 2011 :                         else
; 2012 :                             prod_id = "Standard x64 Edition";

  00dfe	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160148
  00e05	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
$LN144@w32_init_h:
$LN142@w32_init_h:

; 2013 :                     }

  00e0a	e9 86 00 00 00	 jmp	 $LN140@w32_init_h
$LN139@w32_init_h:

; 2014 :                     else
; 2015 :                     {
; 2016 :                         if ( vi.wSuiteMask & VER_SUITE_COMPUTE_SERVER )

  00e0f	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00e17	25 00 40 00 00	 and	 eax, 16384		; 00004000H
  00e1c	85 c0		 test	 eax, eax
  00e1e	74 0e		 je	 SHORT $LN145@w32_init_h

; 2017 :                             prod_id = "Computer Cluster Edition";

  00e20	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160151
  00e27	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00e2c	eb 67		 jmp	 SHORT $LN146@w32_init_h
$LN145@w32_init_h:

; 2018 :                         else if ( vi.wSuiteMask & VER_SUITE_DATACENTER )

  00e2e	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00e36	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00e3b	85 c0		 test	 eax, eax
  00e3d	74 0e		 je	 SHORT $LN147@w32_init_h

; 2019 :                             prod_id = "Datacenter Edition";

  00e3f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160154
  00e46	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00e4b	eb 48		 jmp	 SHORT $LN148@w32_init_h
$LN147@w32_init_h:

; 2020 :                         else if ( vi.wSuiteMask & VER_SUITE_ENTERPRISE )

  00e4d	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00e55	83 e0 02	 and	 eax, 2
  00e58	85 c0		 test	 eax, eax
  00e5a	74 0e		 je	 SHORT $LN149@w32_init_h

; 2021 :                             prod_id = "Enterprise Edition";

  00e5c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160157
  00e63	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00e68	eb 2b		 jmp	 SHORT $LN150@w32_init_h
$LN149@w32_init_h:

; 2022 :                         else if ( vi.wSuiteMask & VER_SUITE_BLADE )

  00e6a	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00e72	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00e77	85 c0		 test	 eax, eax
  00e79	74 0e		 je	 SHORT $LN151@w32_init_h

; 2023 :                             prod_id = "Web Edition";

  00e7b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160160
  00e82	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00e87	eb 0c		 jmp	 SHORT $LN152@w32_init_h
$LN151@w32_init_h:

; 2024 :                         else
; 2025 :                             prod_id = "Standard Edition";

  00e89	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160161
  00e90	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
$LN152@w32_init_h:
$LN150@w32_init_h:
$LN148@w32_init_h:
$LN146@w32_init_h:
$LN140@w32_init_h:
$LN135@w32_init_h:
$LN133@w32_init_h:
$LN124@w32_init_h:

; 2026 :                     }
; 2027 :                 }
; 2028 :             }
; 2029 :             if ( vi.dwMajorVersion == 5 && vi.dwMinorVersion == 1 )

  00e95	83 bc 24 24 01
	00 00 05	 cmp	 DWORD PTR vi$[rsp+4], 5
  00e9d	75 35		 jne	 SHORT $LN153@w32_init_h
  00e9f	83 bc 24 28 01
	00 00 01	 cmp	 DWORD PTR vi$[rsp+8], 1
  00ea7	75 2b		 jne	 SHORT $LN153@w32_init_h

; 2030 :             {
; 2031 :                 if ( vi.wSuiteMask & VER_SUITE_PERSONAL )

  00ea9	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00eb1	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00eb6	85 c0		 test	 eax, eax
  00eb8	74 0e		 je	 SHORT $LN154@w32_init_h

; 2032 :                     psz = "XP Home Edition";

  00eba	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160165
  00ec1	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  00ec6	eb 0c		 jmp	 SHORT $LN155@w32_init_h
$LN154@w32_init_h:

; 2033 :                 else
; 2034 :                     psz = "XP Professional";

  00ec8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160166
  00ecf	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
$LN155@w32_init_h:
$LN153@w32_init_h:

; 2035 :             }
; 2036 :             if ( vi.dwMajorVersion == 5 && vi.dwMinorVersion == 0 )

  00ed4	83 bc 24 24 01
	00 00 05	 cmp	 DWORD PTR vi$[rsp+4], 5
  00edc	75 79		 jne	 SHORT $LN156@w32_init_h
  00ede	83 bc 24 28 01
	00 00 00	 cmp	 DWORD PTR vi$[rsp+8], 0
  00ee6	75 6f		 jne	 SHORT $LN156@w32_init_h

; 2037 :             {
; 2038 :                 if ( vi.wProductType == VER_NT_WORKSTATION )

  00ee8	0f b6 84 24 ba
	01 00 00	 movzx	 eax, BYTE PTR vi$[rsp+154]
  00ef0	83 f8 01	 cmp	 eax, 1
  00ef3	75 0e		 jne	 SHORT $LN157@w32_init_h

; 2039 :                     psz = "2000 Professional";

  00ef5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160170
  00efc	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax
  00f01	eb 54		 jmp	 SHORT $LN158@w32_init_h
$LN157@w32_init_h:

; 2040 :                 else
; 2041 :                 {
; 2042 :                     psz = "2000";

  00f03	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160171
  00f0a	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax

; 2043 :                     if ( vi.wSuiteMask & VER_SUITE_DATACENTER )

  00f0f	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00f17	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00f1c	85 c0		 test	 eax, eax
  00f1e	74 0e		 je	 SHORT $LN159@w32_init_h

; 2044 :                         prod_id = "Datacenter Server";

  00f20	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160174
  00f27	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00f2c	eb 29		 jmp	 SHORT $LN160@w32_init_h
$LN159@w32_init_h:

; 2045 :                     else if ( vi.wSuiteMask & VER_SUITE_ENTERPRISE )

  00f2e	0f b7 84 24 b8
	01 00 00	 movzx	 eax, WORD PTR vi$[rsp+152]
  00f36	83 e0 02	 and	 eax, 2
  00f39	85 c0		 test	 eax, eax
  00f3b	74 0e		 je	 SHORT $LN161@w32_init_h

; 2046 :                         prod_id = "Enterprise Server";

  00f3d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160177
  00f44	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
  00f49	eb 0c		 jmp	 SHORT $LN162@w32_init_h
$LN161@w32_init_h:

; 2047 :                     else
; 2048 :                         prod_id = "Server";

  00f4b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160178
  00f52	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
$LN162@w32_init_h:
$LN160@w32_init_h:
$LN158@w32_init_h:
$LN156@w32_init_h:

; 2049 :                 }
; 2050 :             }
; 2051 :             if ( vi.dwMajorVersion >= 6 )

  00f57	83 bc 24 24 01
	00 00 06	 cmp	 DWORD PTR vi$[rsp+4], 6
  00f5f	72 5c		 jb	 SHORT $LN163@w32_init_h

; 2052 :             {
; 2053 :                 if ( si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64 )

  00f61	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR si$[rsp]
  00f69	83 f8 09	 cmp	 eax, 9
  00f6c	75 23		 jne	 SHORT $LN164@w32_init_h

; 2054 :                 {
; 2055 :                     prod_proc = " 64-bit";

  00f6e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160182
  00f75	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR prod_proc$[rsp], rax

; 2056 :                     pHostInfo->cpu_64bits = 1;

  00f7d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00f85	c7 80 d0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+464], 1

; 2057 :                 }

  00f8f	eb 2c		 jmp	 SHORT $LN165@w32_init_h
$LN164@w32_init_h:

; 2058 :                 else if ( si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL )

  00f91	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR si$[rsp]
  00f99	85 c0		 test	 eax, eax
  00f9b	75 11		 jne	 SHORT $LN166@w32_init_h

; 2059 :                     prod_proc = " 32-bit";

  00f9d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160185
  00fa4	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR prod_proc$[rsp], rax
  00fac	eb 0f		 jmp	 SHORT $LN167@w32_init_h
$LN166@w32_init_h:

; 2060 :                 else
; 2061 :                     prod_proc = "";

  00fae	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160186
  00fb5	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR prod_proc$[rsp], rax
$LN167@w32_init_h:
$LN165@w32_init_h:
$LN163@w32_init_h:

; 2062 :             }
; 2063 :             break;

  00fbd	eb 18		 jmp	 SHORT $LN6@w32_init_h
$LN168@w32_init_h:

; 2064 :         default:
; 2065 :             psz = "unknown";

  00fbf	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160188
  00fc6	48 89 44 24 40	 mov	 QWORD PTR psz$[rsp], rax

; 2066 :             prod_id = "";

  00fcb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG160189
  00fd2	48 89 44 24 30	 mov	 QWORD PTR prod_id$[rsp], rax
$LN6@w32_init_h:

; 2067 :             break;
; 2068 :     }
; 2069 : 
; 2070 : #if defined(__MINGW32_VERSION)
; 2071 :  #define HWIN32_SYSNAME         "MINGW32"
; 2072 : #else
; 2073 :  #define HWIN32_SYSNAME         "Windows"
; 2074 : #endif
; 2075 : 
; 2076 :     _snprintf(

  00fd7	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  00fdf	48 83 c0 30	 add	 rax, 48			; 00000030H
  00fe3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160190
  00fea	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  00fef	48 8b c8	 mov	 rcx, rax
  00ff2	e8 00 00 00 00	 call	 _snprintf

; 2077 :         pHostInfo->sysname, sizeof(
; 2078 :         pHostInfo->sysname)-1,        HWIN32_SYSNAME );
; 2079 :         pHostInfo->sysname[ sizeof(
; 2080 :         pHostInfo->sysname)-1] = 0;

  00ff7	b8 01 00 00 00	 mov	 eax, 1
  00ffc	48 6b c0 3f	 imul	 rax, rax, 63		; 0000003fH
  01000	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  01008	c6 44 01 30 00	 mov	 BYTE PTR [rcx+rax+48], 0

; 2081 : 
; 2082 :     _snprintf(

  0100d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01015	48 05 b0 00 00
	00		 add	 rax, 176		; 000000b0H
  0101b	8b 8c 24 2c 01
	00 00		 mov	 ecx, DWORD PTR vi$[rsp+12]
  01022	89 4c 24 28	 mov	 DWORD PTR [rsp+40], ecx
  01026	8b 8c 24 28 01
	00 00		 mov	 ecx, DWORD PTR vi$[rsp+8]
  0102d	89 4c 24 20	 mov	 DWORD PTR [rsp+32], ecx
  01031	44 8b 8c 24 24
	01 00 00	 mov	 r9d, DWORD PTR vi$[rsp+4]
  01039	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160191
  01040	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  01045	48 8b c8	 mov	 rcx, rax
  01048	e8 00 00 00 00	 call	 _snprintf

; 2083 :         pHostInfo->release, sizeof(
; 2084 :         pHostInfo->release)-1,       "%d.%d.%d",            vi.dwMajorVersion,
; 2085 :                                                             vi.dwMinorVersion,
; 2086 :                                                             vi.dwBuildNumber);
; 2087 :         pHostInfo->release[ sizeof(
; 2088 :         pHostInfo->release)-1] = 0;

  0104d	b8 01 00 00 00	 mov	 eax, 1
  01052	48 6b c0 3f	 imul	 rax, rax, 63		; 0000003fH
  01056	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  0105e	c6 84 01 b0 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+176], 0

; 2089 : 
; 2090 :     _snprintf(

  01066	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  0106e	48 05 f0 00 00
	00		 add	 rax, 240		; 000000f0H
  01074	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR prod_proc$[rsp]
  0107c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01081	48 8b 4c 24 30	 mov	 rcx, QWORD PTR prod_id$[rsp]
  01086	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0108b	4c 8b 4c 24 40	 mov	 r9, QWORD PTR psz$[rsp]
  01090	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160192
  01097	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0109c	48 8b c8	 mov	 rcx, rax
  0109f	e8 00 00 00 00	 call	 _snprintf

; 2091 :         pHostInfo->version, sizeof(
; 2092 :         pHostInfo->version)-1,        "%s %s%s", psz, prod_id, prod_proc );
; 2093 :         pHostInfo->version[ sizeof(
; 2094 :         pHostInfo->version)-1] = 0;

  010a4	b8 01 00 00 00	 mov	 eax, 1
  010a9	48 6b c0 3f	 imul	 rax, rax, 63		; 0000003fH
  010ad	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  010b5	c6 84 01 f0 00
	00 00 00	 mov	 BYTE PTR [rcx+rax+240], 0

; 2095 : 
; 2096 : 
; 2097 :     switch ( si.wProcessorArchitecture )

  010bd	0f b7 84 24 b0
	00 00 00	 movzx	 eax, WORD PTR si$[rsp]
  010c5	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv549[rsp], eax
  010cc	83 bc 24 8c 00
	00 00 0a	 cmp	 DWORD PTR tv549[rsp], 10
  010d4	0f 87 d5 03 00
	00		 ja	 $LN186@w32_init_h
  010da	48 63 84 24 8c
	00 00 00	 movsxd	 rax, DWORD PTR tv549[rsp]
  010e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  010e9	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN194@w32_init_h[rcx+rax*4]
  010f0	48 03 c1	 add	 rax, rcx
  010f3	ff e0		 jmp	 rax
$LN169@w32_init_h:

; 2098 :     {
; 2099 :         case PROCESSOR_ARCHITECTURE_INTEL:
; 2100 :         {
; 2101 :             int n;
; 2102 : 
; 2103 :             if      ( si.wProcessorLevel < 3 ) n = 3;

  010f5	0f b7 84 24 dc
	00 00 00	 movzx	 eax, WORD PTR si$[rsp+44]
  010fd	83 f8 03	 cmp	 eax, 3
  01100	7d 0a		 jge	 SHORT $LN170@w32_init_h
  01102	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR n$5[rsp], 3
  0110a	eb 23		 jmp	 SHORT $LN171@w32_init_h
$LN170@w32_init_h:

; 2104 :             else if ( si.wProcessorLevel > 9 ) n = 6;

  0110c	0f b7 84 24 dc
	00 00 00	 movzx	 eax, WORD PTR si$[rsp+44]
  01114	83 f8 09	 cmp	 eax, 9
  01117	7e 0a		 jle	 SHORT $LN172@w32_init_h
  01119	c7 44 24 78 06
	00 00 00	 mov	 DWORD PTR n$5[rsp], 6
  01121	eb 0c		 jmp	 SHORT $LN173@w32_init_h
$LN172@w32_init_h:

; 2105 :             else                               n = si.wProcessorLevel;

  01123	0f b7 84 24 dc
	00 00 00	 movzx	 eax, WORD PTR si$[rsp+44]
  0112b	89 44 24 78	 mov	 DWORD PTR n$5[rsp], eax
$LN173@w32_init_h:
$LN171@w32_init_h:

; 2106 : 
; 2107 :             _snprintf(

  0112f	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01137	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  0113d	44 8b 4c 24 78	 mov	 r9d, DWORD PTR n$5[rsp]
  01142	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG160198
  01149	ba 3f 00 00 00	 mov	 edx, 63			; 0000003fH
  0114e	48 8b c8	 mov	 rcx, rax
  01151	e8 00 00 00 00	 call	 _snprintf

; 2108 :                 pHostInfo->machine, sizeof(
; 2109 :                 pHostInfo->machine)-1,        "i%d86",  n );
; 2110 :                 pHostInfo->machine[ sizeof(
; 2111 :                 pHostInfo->machine)-1] = 0;

  01156	b8 01 00 00 00	 mov	 eax, 1
  0115b	48 6b c0 3f	 imul	 rax, rax, 63		; 0000003fH
  0115f	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  01167	c6 84 01 30 01
	00 00 00	 mov	 BYTE PTR [rcx+rax+304], 0

; 2112 :         }
; 2113 :         break;

  0116f	e9 5e 03 00 00	 jmp	 $LN10@w32_init_h
$LN174@w32_init_h:

; 2114 : 
; 2115 : // The following are missing from MinGW's supplied version of <winnt.h>
; 2116 : 
; 2117 : #define PROCESSOR_ARCHITECTURE_MSIL             8
; 2118 : #define PROCESSOR_ARCHITECTURE_AMD64            9
; 2119 : #define PROCESSOR_ARCHITECTURE_IA32_ON_WIN64    10
; 2120 : 
; 2121 :         case PROCESSOR_ARCHITECTURE_AMD64:
; 2122 :             {
; 2123 :                 int CPUInfo[4] = {-1, -1, -1, -1 };

  01174	c7 84 24 00 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$9[rsp], -1
  0117f	c7 84 24 04 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$9[rsp+4], -1
  0118a	c7 84 24 08 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$9[rsp+8], -1
  01195	c7 84 24 0c 02
	00 00 ff ff ff
	ff		 mov	 DWORD PTR CPUInfo$9[rsp+12], -1

; 2124 :                 char CPUString[0x20];
; 2125 :                 char CPUBrand[0x40];
; 2126 : 
; 2127 :                 __cpuid(CPUInfo, 0);

  011a0	33 c0		 xor	 eax, eax
  011a2	33 c9		 xor	 ecx, ecx
  011a4	0f a2		 cpuid
  011a6	48 8d bc 24 00
	02 00 00	 lea	 rdi, QWORD PTR CPUInfo$9[rsp]
  011ae	89 07		 mov	 DWORD PTR [rdi], eax
  011b0	89 5f 04	 mov	 DWORD PTR [rdi+4], ebx
  011b3	89 4f 08	 mov	 DWORD PTR [rdi+8], ecx
  011b6	89 57 0c	 mov	 DWORD PTR [rdi+12], edx

; 2128 :                 memset(CPUString, 0, sizeof(CPUString));

  011b9	48 8d 84 24 20
	02 00 00	 lea	 rax, QWORD PTR CPUString$11[rsp]
  011c1	48 8b f8	 mov	 rdi, rax
  011c4	33 c0		 xor	 eax, eax
  011c6	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  011cb	f3 aa		 rep stosb

; 2129 :                 *((int*)CPUString) = CPUInfo[1];

  011cd	b8 04 00 00 00	 mov	 eax, 4
  011d2	48 6b c0 01	 imul	 rax, rax, 1
  011d6	8b 84 04 00 02
	00 00		 mov	 eax, DWORD PTR CPUInfo$9[rsp+rax]
  011dd	89 84 24 20 02
	00 00		 mov	 DWORD PTR CPUString$11[rsp], eax

; 2130 :                 *((int*)(CPUString+4)) = CPUInfo[3];

  011e4	b8 04 00 00 00	 mov	 eax, 4
  011e9	48 6b c0 03	 imul	 rax, rax, 3
  011ed	8b 84 04 00 02
	00 00		 mov	 eax, DWORD PTR CPUInfo$9[rsp+rax]
  011f4	89 84 24 24 02
	00 00		 mov	 DWORD PTR CPUString$11[rsp+4], eax

; 2131 :                 *((int*)(CPUString+8)) = CPUInfo[2];

  011fb	b8 04 00 00 00	 mov	 eax, 4
  01200	48 6b c0 02	 imul	 rax, rax, 2
  01204	8b 84 04 00 02
	00 00		 mov	 eax, DWORD PTR CPUInfo$9[rsp+rax]
  0120b	89 84 24 28 02
	00 00		 mov	 DWORD PTR CPUString$11[rsp+8], eax

; 2132 : 
; 2133 :                 if ( mem_eq(CPUString,"GenuineIntel",12) )

  01212	41 b8 0c 00 00
	00		 mov	 r8d, 12
  01218	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160202
  0121f	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR CPUString$11[rsp]
  01227	e8 00 00 00 00	 call	 memcmp
  0122c	85 c0		 test	 eax, eax
  0122e	75 25		 jne	 SHORT $LN175@w32_init_h

; 2134 :                 {
; 2135 :                     STRLCPY( pHostInfo->machine, "Intel(R) x64" );

  01230	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01238	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  0123e	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  01244	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160203
  0124b	48 8b c8	 mov	 rcx, rax
  0124e	e8 00 00 00 00	 call	 strlcpy

; 2136 :                 }

  01253	eb 66		 jmp	 SHORT $LN176@w32_init_h
$LN175@w32_init_h:

; 2137 :                 else if ( mem_eq(CPUString,"AuthenticAMD",12) )

  01255	41 b8 0c 00 00
	00		 mov	 r8d, 12
  0125b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160206
  01262	48 8d 8c 24 20
	02 00 00	 lea	 rcx, QWORD PTR CPUString$11[rsp]
  0126a	e8 00 00 00 00	 call	 memcmp
  0126f	85 c0		 test	 eax, eax
  01271	75 25		 jne	 SHORT $LN177@w32_init_h

; 2138 :                 {
; 2139 :                     STRLCPY( pHostInfo->machine, "AMD(R) x64" );

  01273	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  0127b	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  01281	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  01287	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160207
  0128e	48 8b c8	 mov	 rcx, rax
  01291	e8 00 00 00 00	 call	 strlcpy

; 2140 :                 }

  01296	eb 23		 jmp	 SHORT $LN178@w32_init_h
$LN177@w32_init_h:

; 2141 :                 else
; 2142 :                 {
; 2143 :                     STRLCPY( pHostInfo->machine, "AMD64" );

  01298	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  012a0	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  012a6	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  012ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160208
  012b3	48 8b c8	 mov	 rcx, rax
  012b6	e8 00 00 00 00	 call	 strlcpy
$LN178@w32_init_h:
$LN176@w32_init_h:

; 2144 :                 }
; 2145 :                 memset(CPUBrand, 0, sizeof(CPUBrand));

  012bb	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR CPUBrand$12[rsp]
  012c3	48 8b f8	 mov	 rdi, rax
  012c6	33 c0		 xor	 eax, eax
  012c8	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  012cd	f3 aa		 rep stosb

; 2146 : 
; 2147 :                 __cpuid(CPUInfo, 0x80000002);

  012cf	b8 02 00 00 80	 mov	 eax, -2147483646	; ffffffff80000002H
  012d4	33 c9		 xor	 ecx, ecx
  012d6	0f a2		 cpuid
  012d8	48 8d bc 24 00
	02 00 00	 lea	 rdi, QWORD PTR CPUInfo$9[rsp]
  012e0	89 07		 mov	 DWORD PTR [rdi], eax
  012e2	89 5f 04	 mov	 DWORD PTR [rdi+4], ebx
  012e5	89 4f 08	 mov	 DWORD PTR [rdi+8], ecx
  012e8	89 57 0c	 mov	 DWORD PTR [rdi+12], edx

; 2148 :                 memcpy(CPUBrand, CPUInfo, sizeof(CPUInfo));

  012eb	48 8d 84 24 40
	02 00 00	 lea	 rax, QWORD PTR CPUBrand$12[rsp]
  012f3	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR CPUInfo$9[rsp]
  012fb	48 8b f8	 mov	 rdi, rax
  012fe	48 8b f1	 mov	 rsi, rcx
  01301	b9 10 00 00 00	 mov	 ecx, 16
  01306	f3 a4		 rep movsb

; 2149 : 
; 2150 :                 __cpuid(CPUInfo, 0x80000003);

  01308	b8 03 00 00 80	 mov	 eax, -2147483645	; ffffffff80000003H
  0130d	33 c9		 xor	 ecx, ecx
  0130f	0f a2		 cpuid
  01311	48 8d bc 24 00
	02 00 00	 lea	 rdi, QWORD PTR CPUInfo$9[rsp]
  01319	89 07		 mov	 DWORD PTR [rdi], eax
  0131b	89 5f 04	 mov	 DWORD PTR [rdi+4], ebx
  0131e	89 4f 08	 mov	 DWORD PTR [rdi+8], ecx
  01321	89 57 0c	 mov	 DWORD PTR [rdi+12], edx

; 2151 :                 memcpy(CPUBrand+16, CPUInfo, sizeof(CPUInfo));

  01324	48 8d 84 24 50
	02 00 00	 lea	 rax, QWORD PTR CPUBrand$12[rsp+16]
  0132c	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR CPUInfo$9[rsp]
  01334	48 8b f8	 mov	 rdi, rax
  01337	48 8b f1	 mov	 rsi, rcx
  0133a	b9 10 00 00 00	 mov	 ecx, 16
  0133f	f3 a4		 rep movsb

; 2152 : 
; 2153 :                 __cpuid(CPUInfo, 0x80000004);

  01341	b8 04 00 00 80	 mov	 eax, -2147483644	; ffffffff80000004H
  01346	33 c9		 xor	 ecx, ecx
  01348	0f a2		 cpuid
  0134a	48 8d bc 24 00
	02 00 00	 lea	 rdi, QWORD PTR CPUInfo$9[rsp]
  01352	89 07		 mov	 DWORD PTR [rdi], eax
  01354	89 5f 04	 mov	 DWORD PTR [rdi+4], ebx
  01357	89 4f 08	 mov	 DWORD PTR [rdi+8], ecx
  0135a	89 57 0c	 mov	 DWORD PTR [rdi+12], edx

; 2154 :                 memcpy(CPUBrand+32, CPUInfo, sizeof(CPUInfo));

  0135d	48 8d 84 24 60
	02 00 00	 lea	 rax, QWORD PTR CPUBrand$12[rsp+32]
  01365	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR CPUInfo$9[rsp]
  0136d	48 8b f8	 mov	 rdi, rax
  01370	48 8b f1	 mov	 rsi, rcx
  01373	b9 10 00 00 00	 mov	 ecx, 16
  01378	f3 a4		 rep movsb

; 2155 : 
; 2156 :                 memcpy(pHostInfo->cpu_brand, CPUBrand, sizeof(pHostInfo->cpu_brand));

  0137a	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01382	48 8d 8c 24 40
	02 00 00	 lea	 rcx, QWORD PTR CPUBrand$12[rsp]
  0138a	48 8d b8 70 01
	00 00		 lea	 rdi, QWORD PTR [rax+368]
  01391	48 8b f1	 mov	 rsi, rcx
  01394	b9 40 00 00 00	 mov	 ecx, 64			; 00000040H
  01399	f3 a4		 rep movsb

; 2157 : 
; 2158 :             }
; 2159 :             break;

  0139b	e9 32 01 00 00	 jmp	 $LN10@w32_init_h
$LN179@w32_init_h:

; 2160 :         case PROCESSOR_ARCHITECTURE_PPC:           STRLCPY( pHostInfo->machine, "PowerPC"       ); break;

  013a0	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  013a8	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  013ae	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  013b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160210
  013bb	48 8b c8	 mov	 rcx, rax
  013be	e8 00 00 00 00	 call	 strlcpy
  013c3	e9 0a 01 00 00	 jmp	 $LN10@w32_init_h
$LN180@w32_init_h:

; 2161 :         case PROCESSOR_ARCHITECTURE_SHX:           STRLCPY( pHostInfo->machine, "SH"            ); break;

  013c8	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  013d0	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  013d6	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  013dc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160212
  013e3	48 8b c8	 mov	 rcx, rax
  013e6	e8 00 00 00 00	 call	 strlcpy
  013eb	e9 e2 00 00 00	 jmp	 $LN10@w32_init_h
$LN181@w32_init_h:

; 2162 :         case PROCESSOR_ARCHITECTURE_ARM:           STRLCPY( pHostInfo->machine, "ARM"           ); break;

  013f0	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  013f8	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  013fe	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  01404	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160214
  0140b	48 8b c8	 mov	 rcx, rax
  0140e	e8 00 00 00 00	 call	 strlcpy
  01413	e9 ba 00 00 00	 jmp	 $LN10@w32_init_h
$LN182@w32_init_h:

; 2163 :         case PROCESSOR_ARCHITECTURE_IA64:          STRLCPY( pHostInfo->machine, "IA64"          ); break;

  01418	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01420	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  01426	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0142c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160216
  01433	48 8b c8	 mov	 rcx, rax
  01436	e8 00 00 00 00	 call	 strlcpy
  0143b	e9 92 00 00 00	 jmp	 $LN10@w32_init_h
$LN183@w32_init_h:

; 2164 :         case PROCESSOR_ARCHITECTURE_IA32_ON_WIN64: STRLCPY( pHostInfo->machine, "IA32_ON_WIN64" ); break;

  01440	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01448	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  0144e	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  01454	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160218
  0145b	48 8b c8	 mov	 rcx, rax
  0145e	e8 00 00 00 00	 call	 strlcpy
  01463	eb 6d		 jmp	 SHORT $LN10@w32_init_h
$LN184@w32_init_h:

; 2165 :         case PROCESSOR_ARCHITECTURE_ALPHA:         STRLCPY( pHostInfo->machine, "ALPHA"         ); break;

  01465	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  0146d	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  01473	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  01479	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160220
  01480	48 8b c8	 mov	 rcx, rax
  01483	e8 00 00 00 00	 call	 strlcpy
  01488	eb 48		 jmp	 SHORT $LN10@w32_init_h
$LN185@w32_init_h:

; 2166 :         case PROCESSOR_ARCHITECTURE_MIPS:          STRLCPY( pHostInfo->machine, "MIPS"          ); break;

  0148a	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01492	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  01498	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  0149e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160222
  014a5	48 8b c8	 mov	 rcx, rax
  014a8	e8 00 00 00 00	 call	 strlcpy
  014ad	eb 23		 jmp	 SHORT $LN10@w32_init_h
$LN186@w32_init_h:

; 2167 :         default:                                   STRLCPY( pHostInfo->machine, "???"           ); break;

  014af	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  014b7	48 05 30 01 00
	00		 add	 rax, 304		; 00000130H
  014bd	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  014c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160224
  014ca	48 8b c8	 mov	 rcx, rax
  014cd	e8 00 00 00 00	 call	 strlcpy
$LN10@w32_init_h:

; 2168 :     }
; 2169 : 
; 2170 :     pHostInfo->num_procs = si.dwNumberOfProcessors;

  014d2	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  014da	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR si$[rsp+32]
  014e1	89 88 b8 01 00
	00		 mov	 DWORD PTR [rax+440], ecx

; 2171 :     pHostInfo->AllocationGranularity = (U64) si.dwAllocationGranularity;

  014e7	8b 84 24 d8 00
	00 00		 mov	 eax, DWORD PTR si$[rsp+40]
  014ee	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR pHostInfo$[rsp]
  014f6	48 89 81 28 02
	00 00		 mov	 QWORD PTR [rcx+552], rax

; 2172 : 
; 2173 :     InitializeCriticalSection( &cs );

  014fd	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR cs$[rsp]
  01505	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_InitializeCriticalSection

; 2174 : 
; 2175 :     if ( !TryEnterCriticalSection( &cs ) )

  0150b	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR cs$[rsp]
  01513	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_TryEnterCriticalSection
  01519	85 c0		 test	 eax, eax
  0151b	75 14		 jne	 SHORT $LN187@w32_init_h

; 2176 :         pHostInfo->trycritsec_avail = 0;

  0151d	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01525	c7 80 b0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+432], 0
  0152f	eb 20		 jmp	 SHORT $LN188@w32_init_h
$LN187@w32_init_h:

; 2177 :     else
; 2178 :     {
; 2179 :         pHostInfo->trycritsec_avail = 1;

  01531	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR pHostInfo$[rsp]
  01539	c7 80 b0 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+432], 1

; 2180 :         LeaveCriticalSection( &cs );

  01543	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR cs$[rsp]
  0154b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_LeaveCriticalSection
$LN188@w32_init_h:

; 2181 :     }
; 2182 : 
; 2183 :     DeleteCriticalSection( &cs );

  01551	48 8d 8c 24 f8
	00 00 00	 lea	 rcx, QWORD PTR cs$[rsp]
  01559	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_DeleteCriticalSection

; 2184 : 
; 2185 :     return;
; 2186 : 
; 2187 : }

  0155f	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  01567	48 33 cc	 xor	 rcx, rsp
  0156a	e8 00 00 00 00	 call	 __security_check_cookie
  0156f	48 81 c4 90 02
	00 00		 add	 rsp, 656		; 00000290H
  01576	5f		 pop	 rdi
  01577	5e		 pop	 rsi
  01578	5b		 pop	 rbx
  01579	c3		 ret	 0
  0157a	66 90		 npad	 2
$LN197@w32_init_h:
  0157c	00 00 00 00	 DD	 $LN121@w32_init_h
  01580	00 00 00 00	 DD	 $LN51@w32_init_h
  01584	00 00 00 00	 DD	 $LN60@w32_init_h
  01588	00 00 00 00	 DD	 $LN57@w32_init_h
  0158c	00 00 00 00	 DD	 $LN66@w32_init_h
  01590	00 00 00 00	 DD	 $LN62@w32_init_h
  01594	00 00 00 00	 DD	 $LN69@w32_init_h
  01598	00 00 00 00	 DD	 $LN93@w32_init_h
  0159c	00 00 00 00	 DD	 $LN79@w32_init_h
  015a0	00 00 00 00	 DD	 $LN91@w32_init_h
  015a4	00 00 00 00	 DD	 $LN83@w32_init_h
  015a8	00 00 00 00	 DD	 $LN74@w32_init_h
  015ac	00 00 00 00	 DD	 $LN81@w32_init_h
  015b0	00 00 00 00	 DD	 $LN95@w32_init_h
  015b4	00 00 00 00	 DD	 $LN85@w32_init_h
  015b8	00 00 00 00	 DD	 $LN87@w32_init_h
  015bc	00 00 00 00	 DD	 $LN70@w32_init_h
  015c0	00 00 00 00	 DD	 $LN119@w32_init_h
  015c4	00 00 00 00	 DD	 $LN77@w32_init_h
  015c8	00 00 00 00	 DD	 $LN63@w32_init_h
  015cc	00 00 00 00	 DD	 $LN98@w32_init_h
  015d0	00 00 00 00	 DD	 $LN99@w32_init_h
  015d4	00 00 00 00	 DD	 $LN100@w32_init_h
  015d8	00 00 00 00	 DD	 $LN97@w32_init_h
  015dc	00 00 00 00	 DD	 $LN88@w32_init_h
  015e0	00 00 00 00	 DD	 $LN92@w32_init_h
  015e4	00 00 00 00	 DD	 $LN59@w32_init_h
  015e8	00 00 00 00	 DD	 $LN68@w32_init_h
  015ec	00 00 00 00	 DD	 $LN53@w32_init_h
  015f0	00 00 00 00	 DD	 $LN120@w32_init_h
  015f4	00 00 00 00	 DD	 $LN71@w32_init_h
  015f8	00 00 00 00	 DD	 $LN73@w32_init_h
  015fc	00 00 00 00	 DD	 $LN72@w32_init_h
  01600	00 00 00 00	 DD	 $LN90@w32_init_h
  01604	00 00 00 00	 DD	 $LN64@w32_init_h
  01608	00 00 00 00	 DD	 $LN89@w32_init_h
$LN196@w32_init_h:
  0160c	00 00 00 00	 DD	 $LN80@w32_init_h
  01610	00 00 00 00	 DD	 $LN84@w32_init_h
  01614	00 00 00 00	 DD	 $LN82@w32_init_h
  01618	00 00 00 00	 DD	 $LN96@w32_init_h
  0161c	00 00 00 00	 DD	 $LN86@w32_init_h
  01620	00 00 00 00	 DD	 $LN65@w32_init_h
  01624	00 00 00 00	 DD	 $LN102@w32_init_h
  01628	00 00 00 00	 DD	 $LN103@w32_init_h
  0162c	00 00 00 00	 DD	 $LN104@w32_init_h
  01630	00 00 00 00	 DD	 $LN101@w32_init_h
  01634	00 00 00 00	 DD	 $LN76@w32_init_h
  01638	00 00 00 00	 DD	 $LN54@w32_init_h
  0163c	00 00 00 00	 DD	 $LN56@w32_init_h
  01640	00 00 00 00	 DD	 $LN105@w32_init_h
  01644	00 00 00 00	 DD	 $LN107@w32_init_h
  01648	00 00 00 00	 DD	 $LN109@w32_init_h
  0164c	00 00 00 00	 DD	 $LN110@w32_init_h
$LN195@w32_init_h:
  01650	00 00 00 00	 DD	 $LN108@w32_init_h
  01654	00 00 00 00	 DD	 $LN111@w32_init_h
  01658	00 00 00 00	 DD	 $LN112@w32_init_h
  0165c	00 00 00 00	 DD	 $LN123@w32_init_h
  01660	00 00 00 00	 DD	 $LN114@w32_init_h
  01664	00 00 00 00	 DD	 $LN115@w32_init_h
  01668	00 00 00 00	 DD	 $LN116@w32_init_h
  0166c	00 00 00 00	 DD	 $LN117@w32_init_h
  01670	00 00 00 00	 DD	 $LN113@w32_init_h
$LN194@w32_init_h:
  01674	00 00 00 00	 DD	 $LN169@w32_init_h
  01678	00 00 00 00	 DD	 $LN185@w32_init_h
  0167c	00 00 00 00	 DD	 $LN184@w32_init_h
  01680	00 00 00 00	 DD	 $LN179@w32_init_h
  01684	00 00 00 00	 DD	 $LN180@w32_init_h
  01688	00 00 00 00	 DD	 $LN181@w32_init_h
  0168c	00 00 00 00	 DD	 $LN182@w32_init_h
  01690	00 00 00 00	 DD	 $LN186@w32_init_h
  01694	00 00 00 00	 DD	 $LN186@w32_init_h
  01698	00 00 00 00	 DD	 $LN174@w32_init_h
  0169c	00 00 00 00	 DD	 $LN183@w32_init_h
w32_init_hostinfo ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
dwOutLen$ = 32
tv70 = 36
inbuff$ = 64
outbuff$ = 72
outbufsiz$ = 80
expand_environ_vars PROC

; 1418 : {

$LN5:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1419 :     // If the function succeeds, the return value is the number of TCHARs
; 1420 :     // stored in the destination buffer, including the terminating null character.
; 1421 :     // If the destination buffer is too small to hold the expanded string, the
; 1422 :     // return value is the required buffer size, in TCHARs. If the function fails,
; 1423 :     // the return value is zero.
; 1424 : 
; 1425 :     DWORD dwOutLen = ExpandEnvironmentStrings( inbuff, outbuff, outbufsiz );

  00013	44 8b 44 24 50	 mov	 r8d, DWORD PTR outbufsiz$[rsp]
  00018	48 8b 54 24 48	 mov	 rdx, QWORD PTR outbuff$[rsp]
  0001d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR inbuff$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExpandEnvironmentStringsA
  00028	89 44 24 20	 mov	 DWORD PTR dwOutLen$[rsp], eax

; 1426 :     return ( ( dwOutLen && dwOutLen < outbufsiz ) ? 0 : -1 );

  0002c	83 7c 24 20 00	 cmp	 DWORD PTR dwOutLen$[rsp], 0
  00031	74 14		 je	 SHORT $LN3@expand_env
  00033	8b 44 24 50	 mov	 eax, DWORD PTR outbufsiz$[rsp]
  00037	39 44 24 20	 cmp	 DWORD PTR dwOutLen$[rsp], eax
  0003b	73 0a		 jae	 SHORT $LN3@expand_env
  0003d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00045	eb 08		 jmp	 SHORT $LN4@expand_env
$LN3@expand_env:
  00047	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv70[rsp], -1
$LN4@expand_env:
  0004f	8b 44 24 24	 mov	 eax, DWORD PTR tv70[rsp]

; 1427 : }

  00053	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00057	c3		 ret	 0
expand_environ_vars ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
dwDirBytes$ = 32
tv83 = 36
p$ = 40
process_exec_dirbuf$ = 48
__$ArrayPad$ = 320
dirbuf$ = 352
bufsiz$ = 360
get_process_directory PROC

; 1402 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1403 :     char process_exec_dirbuf[MAX_PATH];
; 1404 :     char* p;
; 1405 :     DWORD dwDirBytes =

  00023	33 c9		 xor	 ecx, ecx
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleHandleA
  0002b	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00031	48 8d 54 24 30	 lea	 rdx, QWORD PTR process_exec_dirbuf$[rsp]
  00036	48 8b c8	 mov	 rcx, rax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetModuleFileNameA
  0003f	89 44 24 20	 mov	 DWORD PTR dwDirBytes$[rsp], eax

; 1406 :         GetModuleFileName(GetModuleHandle(NULL),process_exec_dirbuf,MAX_PATH);
; 1407 :     if (!dwDirBytes || dwDirBytes >= MAX_PATH)

  00043	83 7c 24 20 00	 cmp	 DWORD PTR dwDirBytes$[rsp], 0
  00048	74 0a		 je	 SHORT $LN3@get_proces
  0004a	81 7c 24 20 04
	01 00 00	 cmp	 DWORD PTR dwDirBytes$[rsp], 260 ; 00000104H
  00052	72 04		 jb	 SHORT $LN2@get_proces
$LN3@get_proces:

; 1408 :         return 0;

  00054	33 c0		 xor	 eax, eax
  00056	eb 67		 jmp	 SHORT $LN1@get_proces
$LN2@get_proces:

; 1409 :     p = strrchr(process_exec_dirbuf,'\\'); if (p) *(p+1) = 0;

  00058	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0005d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR process_exec_dirbuf$[rsp]
  00062	e8 00 00 00 00	 call	 strrchr
  00067	48 89 44 24 28	 mov	 QWORD PTR p$[rsp], rax
  0006c	48 83 7c 24 28
	00		 cmp	 QWORD PTR p$[rsp], 0
  00072	74 09		 je	 SHORT $LN4@get_proces
  00074	48 8b 44 24 28	 mov	 rax, QWORD PTR p$[rsp]
  00079	c6 40 01 00	 mov	 BYTE PTR [rax+1], 0
$LN4@get_proces:

; 1410 :     strlcpy(dirbuf,process_exec_dirbuf,bufsiz);

  0007d	4c 8b 84 24 68
	01 00 00	 mov	 r8, QWORD PTR bufsiz$[rsp]
  00085	48 8d 54 24 30	 lea	 rdx, QWORD PTR process_exec_dirbuf$[rsp]
  0008a	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dirbuf$[rsp]
  00092	e8 00 00 00 00	 call	 strlcpy

; 1411 :     return strlen(dirbuf) ? 1 : 0;

  00097	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR dirbuf$[rsp]
  0009f	e8 00 00 00 00	 call	 strlen
  000a4	48 85 c0	 test	 rax, rax
  000a7	74 0a		 je	 SHORT $LN6@get_proces
  000a9	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  000b1	eb 08		 jmp	 SHORT $LN7@get_proces
$LN6@get_proces:
  000b3	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN7@get_proces:
  000bb	8b 44 24 24	 mov	 eax, DWORD PTR tv83[rsp]
$LN1@get_proces:

; 1412 : }

  000bf	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000c7	48 33 cc	 xor	 rcx, rsp
  000ca	e8 00 00 00 00	 call	 __security_check_cookie
  000cf	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000d6	c3		 ret	 0
get_process_directory ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
pKASOCK$ = 32
sfd$ = 64
idle_time$ = 72
probe_interval$ = 80
probe_count$ = 88
get_socket_keepalive PROC

; 2994 : {

$LN13:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2995 :     // PROGRAMMING NOTE: querying the current SIO_KEEPALIVE_VALS is unsupported!
; 2996 :     // According to the web page describing the SIO_KEEPALIVE_VALS control code,
; 2997 :     // http://msdn.microsoft.com/en-us/library/windows/desktop/dd877220(v=vs.85).aspx
; 2998 :     // the output buffer parameter is not used and the size of the output buffer
; 2999 :     // must be zero, or else you will get rc = WSAEFAULT (10014): "The system
; 3000 :     // detected an invalid pointer address in attempting to use a pointer argument
; 3001 :     // in a call"! Did you catch that? What's it's basically admitting to is they
; 3002 :     // support SETTING keepalive values but not RETRIEVING them! So you can set
; 3003 :     // new values for a given socket different from the default, but cannot learn
; 3004 :     // what those values currently in use are somewhere else in your code! In my
; 3005 :     // 20+ years of programming on Windows I've never heard of anything so fucking
; 3006 :     // ridiculous! Anyway, that's the reason for all of the above KASOCK crap.
; 3007 : 
; 3008 :     KASOCK* pKASOCK;
; 3009 : 
; 3010 :     if (!socket_is_socket( sfd ))

  00017	8b 4c 24 40	 mov	 ecx, DWORD PTR sfd$[rsp]
  0001b	e8 00 00 00 00	 call	 socket_is_socket
  00020	85 c0		 test	 eax, eax
  00022	75 0a		 jne	 SHORT $LN8@get_socket

; 3011 :         return -1;

  00024	b8 ff ff ff ff	 mov	 eax, -1
  00029	e9 aa 00 00 00	 jmp	 $LN1@get_socket
$LN8@get_socket:
$LN4@get_socket:

; 3012 : 
; 3013 :     VERIFY((pKASOCK = get_kasock( sfd )) != NULL);

  0002e	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00033	48 8b c8	 mov	 rcx, rax
  00036	e8 00 00 00 00	 call	 get_kasock
  0003b	48 89 44 24 20	 mov	 QWORD PTR pKASOCK$[rsp], rax
  00040	48 83 7c 24 20
	00		 cmp	 QWORD PTR pKASOCK$[rsp], 0
  00046	75 5b		 jne	 SHORT $LN9@get_socket
$LN7@get_socket:
  00048	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160699
  0004f	41 b8 c5 0b 00
	00		 mov	 r8d, 3013		; 00000bc5H
  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160700
  0005c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160701
  00063	e8 00 00 00 00	 call	 logmsg
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0006e	85 c0		 test	 eax, eax
  00070	74 20		 je	 SHORT $LN10@get_socket
  00072	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG160703
  00079	41 b8 c5 0b 00
	00		 mov	 r8d, 3013		; 00000bc5H
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160704
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG160705
  0008d	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@get_socket:
  00092	33 c0		 xor	 eax, eax
  00094	85 c0		 test	 eax, eax
  00096	75 b0		 jne	 SHORT $LN7@get_socket
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0009e	85 c0		 test	 eax, eax
  000a0	74 01		 je	 SHORT $LN11@get_socket
  000a2	cc		 int	 3
$LN11@get_socket:
$LN9@get_socket:
  000a3	33 c0		 xor	 eax, eax
  000a5	85 c0		 test	 eax, eax
  000a7	75 85		 jne	 SHORT $LN4@get_socket

; 3014 : 
; 3015 :     *idle_time      = pKASOCK->time;

  000a9	48 8b 44 24 48	 mov	 rax, QWORD PTR idle_time$[rsp]
  000ae	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pKASOCK$[rsp]
  000b3	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  000b6	89 08		 mov	 DWORD PTR [rax], ecx

; 3016 :     *probe_interval = pKASOCK->intv;

  000b8	48 8b 44 24 50	 mov	 rax, QWORD PTR probe_interval$[rsp]
  000bd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pKASOCK$[rsp]
  000c2	8b 49 0c	 mov	 ecx, DWORD PTR [rcx+12]
  000c5	89 08		 mov	 DWORD PTR [rax], ecx

; 3017 :     *probe_count    = pKASOCK->cnt;

  000c7	48 8b 44 24 58	 mov	 rax, QWORD PTR probe_count$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR pKASOCK$[rsp]
  000d1	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  000d4	89 08		 mov	 DWORD PTR [rax], ecx

; 3018 : 
; 3019 :     return 0;

  000d6	33 c0		 xor	 eax, eax
$LN1@get_socket:

; 3020 : }

  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
get_socket_keepalive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
sfd$ = 64
idle_time$ = 72
probe_interval$ = 80
probe_count$ = 88
set_socket_keepalive PROC

; 2986 : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2987 :     return internal_set_socket_keepalive( sfd, idle_time, probe_interval, probe_count, 0 );

  00016	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0001b	44 8b 4c 24 58	 mov	 r9d, DWORD PTR probe_count$[rsp]
  00020	44 8b 44 24 50	 mov	 r8d, DWORD PTR probe_interval$[rsp]
  00025	8b 54 24 48	 mov	 edx, DWORD PTR idle_time$[rsp]
  00029	8b 4c 24 40	 mov	 ecx, DWORD PTR sfd$[rsp]
  0002d	e8 00 00 00 00	 call	 internal_set_socket_keepalive

; 2988 : }

  00032	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00036	c3		 ret	 0
set_socket_keepalive ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv80 = 48
rc$1 = 52
optLen$ = 56
dummy$ = 60
optVal$ = 64
sfd$ = 96
socket_is_socket PROC

; 2855 : {

$LN11:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 2856 :     DWORD       optVal;
; 2857 :     int         optLen = sizeof(optVal);

  00008	c7 44 24 38 04
	00 00 00	 mov	 DWORD PTR optLen$[rsp], 4

; 2858 :     u_long      dummy       = -1;

  00010	c7 44 24 3c ff
	ff ff ff	 mov	 DWORD PTR dummy$[rsp], -1 ; ffffffffH

; 2859 : 
; 2860 :     if (sfd >= 0 && sfd <=2) return FALSE; // handle stdin, stdout, stderr first

  00018	83 7c 24 60 00	 cmp	 DWORD PTR sfd$[rsp], 0
  0001d	7c 0e		 jl	 SHORT $LN2@socket_is_
  0001f	83 7c 24 60 02	 cmp	 DWORD PTR sfd$[rsp], 2
  00024	7f 07		 jg	 SHORT $LN2@socket_is_
  00026	33 c0		 xor	 eax, eax
  00028	e9 8c 00 00 00	 jmp	 $LN1@socket_is_
$LN2@socket_is_:

; 2861 : 
; 2862 :     if ( getsockopt( (SOCKET)sfd, SOL_SOCKET, SO_TYPE, (char*)&optVal, &optLen ) != SOCKET_ERROR )

  0002d	48 63 44 24 60	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00032	48 8d 4c 24 38	 lea	 rcx, QWORD PTR optLen$[rsp]
  00037	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  0003c	4c 8d 4c 24 40	 lea	 r9, QWORD PTR optVal$[rsp]
  00041	41 b8 08 10 00
	00		 mov	 r8d, 4104		; 00001008H
  00047	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockopt
  00055	83 f8 ff	 cmp	 eax, -1
  00058	74 36		 je	 SHORT $LN3@socket_is_

; 2863 :     {
; 2864 :         return WSAHtonl( (SOCKET)sfd, 666, &dummy ) == 0 ? TRUE : FALSE;

  0005a	48 63 44 24 60	 movsxd	 rax, DWORD PTR sfd$[rsp]
  0005f	4c 8d 44 24 3c	 lea	 r8, QWORD PTR dummy$[rsp]
  00064	ba 9a 02 00 00	 mov	 edx, 666		; 0000029aH
  00069	48 8b c8	 mov	 rcx, rax
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAHtonl
  00072	85 c0		 test	 eax, eax
  00074	75 0a		 jne	 SHORT $LN9@socket_is_
  00076	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  0007e	eb 08		 jmp	 SHORT $LN10@socket_is_
$LN9@socket_is_:
  00080	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN10@socket_is_:
  00088	8b 44 24 30	 mov	 eax, DWORD PTR tv80[rsp]
  0008c	eb 2b		 jmp	 SHORT $LN1@socket_is_

; 2865 :     }

  0008e	eb 29		 jmp	 SHORT $LN4@socket_is_
$LN3@socket_is_:

; 2866 :     else
; 2867 :     {
; 2868 :         int rc = WSAGetLastError();

  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00096	89 44 24 34	 mov	 DWORD PTR rc$1[rsp], eax

; 2869 :         if ( rc == WSAENOTSOCK || rc == WSANOTINITIALISED ) return FALSE;

  0009a	81 7c 24 34 36
	27 00 00	 cmp	 DWORD PTR rc$1[rsp], 10038 ; 00002736H
  000a2	74 0a		 je	 SHORT $LN7@socket_is_
  000a4	81 7c 24 34 6d
	27 00 00	 cmp	 DWORD PTR rc$1[rsp], 10093 ; 0000276dH
  000ac	75 06		 jne	 SHORT $LN5@socket_is_
$LN7@socket_is_:
  000ae	33 c0		 xor	 eax, eax
  000b0	eb 07		 jmp	 SHORT $LN1@socket_is_
  000b2	eb 05		 jmp	 SHORT $LN6@socket_is_
$LN5@socket_is_:

; 2870 :         else return TRUE;

  000b4	b8 01 00 00 00	 mov	 eax, 1
$LN6@socket_is_:
$LN4@socket_is_:
$LN1@socket_is_:

; 2871 :     }
; 2872 : }

  000b9	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000bd	c3		 ret	 0
socket_is_socket ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv73 = 32
tv65 = 36
non_blocking_option$ = 40
sfd$ = 64
blocking_mode$ = 72
socket_set_blocking_mode PROC

; 3228 : {

$LN12:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3229 :     u_long non_blocking_option = !blocking_mode;

  0000c	83 7c 24 48 00	 cmp	 DWORD PTR blocking_mode$[rsp], 0
  00011	75 0a		 jne	 SHORT $LN10@socket_set
  00013	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv65[rsp], 1
  0001b	eb 08		 jmp	 SHORT $LN11@socket_set
$LN10@socket_set:
  0001d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv65[rsp], 0
$LN11@socket_set:
  00025	8b 44 24 24	 mov	 eax, DWORD PTR tv65[rsp]
  00029	89 44 24 28	 mov	 DWORD PTR non_blocking_option$[rsp], eax

; 3230 : 
; 3231 :     if ( SOCKET_ERROR != ioctlsocket( sfd, FIONBIO, &non_blocking_option) )

  0002d	48 63 44 24 40	 movsxd	 rax, DWORD PTR sfd$[rsp]
  00032	4c 8d 44 24 28	 lea	 r8, QWORD PTR non_blocking_option$[rsp]
  00037	ba 7e 66 04 80	 mov	 edx, -2147195266	; ffffffff8004667eH
  0003c	48 8b c8	 mov	 rcx, rax
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ioctlsocket
  00045	83 f8 ff	 cmp	 eax, -1
  00048	74 04		 je	 SHORT $LN4@socket_set

; 3232 :         return 0;

  0004a	33 c0		 xor	 eax, eax
  0004c	eb 65		 jmp	 SHORT $LN1@socket_set
$LN4@socket_set:

; 3233 : 
; 3234 :     switch (WSAGetLastError())

  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  00054	89 44 24 20	 mov	 DWORD PTR tv73[rsp], eax
  00058	81 7c 24 20 1e
	27 00 00	 cmp	 DWORD PTR tv73[rsp], 10014 ; 0000271eH
  00060	74 32		 je	 SHORT $LN7@socket_set
  00062	81 7c 24 20 36
	27 00 00	 cmp	 DWORD PTR tv73[rsp], 10038 ; 00002736H
  0006a	74 1a		 je	 SHORT $LN6@socket_set
  0006c	81 7c 24 20 42
	27 00 00	 cmp	 DWORD PTR tv73[rsp], 10050 ; 00002742H
  00074	74 02		 je	 SHORT $LN5@socket_set
  00076	eb 2a		 jmp	 SHORT $LN8@socket_set
$LN5@socket_set:

; 3235 :     {
; 3236 :     case WSAENETDOWN: errno = ENETDOWN; break;

  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0007e	c7 00 74 00 00
	00		 mov	 DWORD PTR [rax], 116	; 00000074H
  00084	eb 28		 jmp	 SHORT $LN2@socket_set
$LN6@socket_set:

; 3237 :     case WSAENOTSOCK: errno = ENOTSOCK; break;

  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008c	c7 00 80 00 00
	00		 mov	 DWORD PTR [rax], 128	; 00000080H
  00092	eb 1a		 jmp	 SHORT $LN2@socket_set
$LN7@socket_set:

; 3238 :     case WSAEFAULT:   errno = EFAULT;   break;

  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0009a	c7 00 0e 00 00
	00		 mov	 DWORD PTR [rax], 14
  000a0	eb 0c		 jmp	 SHORT $LN2@socket_set
$LN8@socket_set:

; 3239 :     default:          errno = ENOSYS;   break;

  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a8	c7 00 28 00 00
	00		 mov	 DWORD PTR [rax], 40	; 00000028H
$LN2@socket_set:

; 3240 :     }
; 3241 : 
; 3242 :     return -1;

  000ae	b8 ff ff ff ff	 mov	 eax, -1
$LN1@socket_set:

; 3243 : }

  000b3	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b7	c3		 ret	 0
socket_set_blocking_mode ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
socket_deinit PROC

; 2467 :     // PROGRAMMING NOTE: regardless of the comments in the socket_init function above
; 2468 :     // regarding the need to always call WSACleanup for every WSAStartup call, it's not
; 2469 :     // really necessary in our particular case because we're not designed to continue
; 2470 :     // running after shutting down socket handling (which is really what the WSACleanup
; 2471 :     // function is designed for). That is to say, the WSACleanup function is designed
; 2472 :     // so a program can inform the operating system that it's finished using the socket
; 2473 :     // DLL (thus allowing it to free up all of the resources currently being used by
; 2474 :     // the process and allow the DLL to be unmapped from the process'es address space)
; 2475 :     // but not exit (i.e. continue running). In our case however, our entire process
; 2476 :     // is exiting (i.e. we're NOT going to continue running), and when a process exits,
; 2477 :     // all loaded DLLs are automatically notified by the operating system to allow them
; 2478 :     // to automatically free all resources for the process in question. Thus since we
; 2479 :     // are exiting we don't really need to call WSACleanup since whatever "cleanup" it
; 2480 :     // would do is going to get done *anyway* by virtue of our going away. Besides that,
; 2481 :     // WSACleanup appears to "hang" when it's called while socket resources are still
; 2482 :     // being used (which is true in our case since we're not designed (yet!) to cleanly
; 2483 :     // shutdown all of our socket-using threads before exiting). THUS (sorry to ramble)
; 2484 :     // we in fact probably SHOULDN'T be calling WSACleanup here (and besides, bypassing
; 2485 :     // it seems to resolve our hangs at shutdown whenever there's still a thread running
; 2486 :     // that doing sockets shit).
; 2487 : 
; 2488 : #if 0 // (see above)
; 2489 :     return
; 2490 :     (
; 2491 :         WSACleanup() == 0 ?
; 2492 :         0 : -1
; 2493 :     );
; 2494 : #else
; 2495 :     return 0;       // (not needed? see PROGRAMING NOTE above!)

  00000	33 c0		 xor	 eax, eax

; 2496 : #endif
; 2497 : }

  00002	c3		 ret	 0
socket_deinit ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
wVersionRequested$ = 32
tv68 = 36
rc$ = 40
sSocketPackageInfo$ = 48
__$ArrayPad$ = 464
socket_init PROC

; 2420 : {

$LN5:
  00000	48 81 ec e8 01
	00 00		 sub	 rsp, 488		; 000001e8H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 d0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2421 :     /*
; 2422 :     In order to support future Windows Sockets implementations
; 2423 :     and applications that can have functionality differences
; 2424 :     from the current version of Windows Sockets, a negotiation
; 2425 :     takes place in WSAStartup.
; 2426 : 
; 2427 :     The caller of WSAStartup and the WS2_32.DLL indicate to each
; 2428 :     other the highest version that they can support, and each
; 2429 :     confirms that the other's highest version is acceptable.
; 2430 : 
; 2431 :     Upon entry to WSAStartup, the WS2_32.DLL examines the version
; 2432 :     requested by the application. If this version is equal to or
; 2433 :     higher than the lowest version supported by the DLL, the call
; 2434 :     succeeds and the DLL returns in wHighVersion the highest
; 2435 :     version it supports and in wVersion the minimum of its high
; 2436 :     version and wVersionRequested.
; 2437 : 
; 2438 :     The WS2_32.DLL then assumes that the application will use
; 2439 :     wVersion If the wVersion parameter of the WSADATA structure
; 2440 :     is unacceptable to the caller, it should call WSACleanup and
; 2441 :     either search for another WS2_32.DLL or fail to initialize.
; 2442 :     */
; 2443 : 
; 2444 :     WSADATA  sSocketPackageInfo;
; 2445 :     WORD     wVersionRequested    = MAKEWORD(1,1);

  00019	b8 01 01 00 00	 mov	 eax, 257		; 00000101H
  0001e	66 89 44 24 20	 mov	 WORD PTR wVersionRequested$[rsp], ax

; 2446 : 
; 2447 :     int rc =

  00023	48 8d 54 24 30	 lea	 rdx, QWORD PTR sSocketPackageInfo$[rsp]
  00028	0f b7 4c 24 20	 movzx	 ecx, WORD PTR wVersionRequested$[rsp]
  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAStartup
  00033	85 c0		 test	 eax, eax
  00035	75 0a		 jne	 SHORT $LN3@socket_ini
  00037	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
  0003f	eb 08		 jmp	 SHORT $LN4@socket_ini
$LN3@socket_ini:
  00041	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv68[rsp], -1
$LN4@socket_ini:
  00049	8b 44 24 24	 mov	 eax, DWORD PTR tv68[rsp]
  0004d	89 44 24 28	 mov	 DWORD PTR rc$[rsp], eax

; 2448 :     (
; 2449 :         WSAStartup( wVersionRequested, &sSocketPackageInfo ) == 0 ?
; 2450 :         0 : -1
; 2451 :     );
; 2452 : 
; 2453 :     // PROGRAMMING NOTE: Hercules only ever calls this function
; 2454 :     // ONE TIME very early on at startup in the impl function,
; 2455 :     // so we use it to perform our own one-time initialization.
; 2456 : 
; 2457 :     kasock_init();      // Initialize socket keepalive handling

  00051	e8 00 00 00 00	 call	 kasock_init

; 2458 : 
; 2459 :     return rc;

  00056	8b 44 24 28	 mov	 eax, DWORD PTR rc$[rsp]

; 2460 : }

  0005a	48 8b 8c 24 d0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00062	48 33 cc	 xor	 rcx, rsp
  00065	e8 00 00 00 00	 call	 __security_check_cookie
  0006a	48 81 c4 e8 01
	00 00		 add	 rsp, 488		; 000001e8H
  00071	c3		 ret	 0
socket_init ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv76 = 32
pHostent$ = 40
szHostName$ = 48
__$ArrayPad$ = 304
gethostid PROC

; 2503 : {

$LN5:
  00000	48 81 ec 48 01
	00 00		 sub	 rsp, 328		; 00000148H
  00007	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000e	48 33 c4	 xor	 rax, rsp
  00011	48 89 84 24 30
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 2504 :     char             szHostName[ WSADESCRIPTION_LEN ];
; 2505 :     struct hostent*  pHostent = NULL;

  00019	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR pHostent$[rsp], 0

; 2506 :     return (gethostname( szHostName, sizeof(szHostName) ) == 0

  00022	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  00027	48 8d 4c 24 30	 lea	 rcx, QWORD PTR szHostName$[rsp]
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostname
  00032	85 c0		 test	 eax, eax
  00034	75 37		 jne	 SHORT $LN3@gethostid
  00036	48 8d 4c 24 30	 lea	 rcx, QWORD PTR szHostName$[rsp]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gethostbyname
  00041	48 89 44 24 28	 mov	 QWORD PTR pHostent$[rsp], rax
  00046	48 83 7c 24 28
	00		 cmp	 QWORD PTR pHostent$[rsp], 0
  0004c	74 1f		 je	 SHORT $LN3@gethostid
  0004e	b8 08 00 00 00	 mov	 eax, 8
  00053	48 6b c0 00	 imul	 rax, rax, 0
  00057	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pHostent$[rsp]
  0005c	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00060	48 8b 04 08	 mov	 rax, QWORD PTR [rax+rcx]
  00064	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00067	89 44 24 20	 mov	 DWORD PTR tv76[rsp], eax
  0006b	eb 08		 jmp	 SHORT $LN4@gethostid
$LN3@gethostid:
  0006d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN4@gethostid:
  00075	8b 44 24 20	 mov	 eax, DWORD PTR tv76[rsp]

; 2507 :         && (pHostent = gethostbyname( szHostName )) != NULL) ?
; 2508 :         (long)(*(pHostent->h_addr)) : 0;
; 2509 : }

  00079	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00081	48 33 cc	 xor	 rcx, rsp
  00084	e8 00 00 00 00	 call	 __security_check_cookie
  00089	48 81 c4 48 01
	00 00		 add	 rsp, 328		; 00000148H
  00090	c3		 ret	 0
gethostid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
read_write_buffer$ = 48
bCanRead$ = 52
bCanWrite$ = 56
dwNumBytesToReadOrWrite$ = 60
dwNumBytesReadOrWritten$ = 64
hFile$ = 72
fd$ = 96
get_file_accmode_flags PROC

; 1346 : {

$LN34:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1347 :     // PROGRAMMING NOTE: we unfortunately CANNOT use Microsoft's "_fstat" here
; 1348 :     // since it seems to always return the actual file's ATTRIBUTE permissions
; 1349 :     // and not the ACCESS MODE permissions specified when the file was opened!
; 1350 : 
; 1351 :     HANDLE  hFile;
; 1352 :     BOOL    bCanRead;
; 1353 :     BOOL    bCanWrite;
; 1354 :     DWORD   dwNumBytesToReadOrWrite;
; 1355 :     DWORD   dwNumBytesReadOrWritten;
; 1356 :     char    read_write_buffer;
; 1357 : 
; 1358 :     // TECHNIQUE: check whether or not we can "read" and/or "write" to the file
; 1359 :     // and return appropriate access-mode flags accordingly. Note that we do not
; 1360 :     // actually read nor write from/to the file per se, since we specify ZERO BYTES
; 1361 :     // for our "number of bytes to read/write" argument. This is valid under Win32
; 1362 :     // and does not modify the file position and so is safe to do. All it does is
; 1363 :     // return the appropriate success/failure return code (e.g. ERROR_ACCESS_DENIED)
; 1364 :     // depending on whether the file was opened with the proper access permissions.
; 1365 : 
; 1366 :     hFile  = (HANDLE)  _get_osfhandle( fd );

  00008	8b 4c 24 60	 mov	 ecx, DWORD PTR fd$[rsp]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_osfhandle
  00012	48 89 44 24 48	 mov	 QWORD PTR hFile$[rsp], rax

; 1367 : 
; 1368 :     if ( (HANDLE) -1 == hFile )

  00017	48 83 7c 24 48
	ff		 cmp	 QWORD PTR hFile$[rsp], -1
  0001d	75 16		 jne	 SHORT $LN20@get_file_a

; 1369 :     {
; 1370 :         errno = EBADF;      // (probably not a valid opened file descriptor)

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00025	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 1371 :         return -1;

  0002b	b8 ff ff ff ff	 mov	 eax, -1
  00030	e9 ff 01 00 00	 jmp	 $LN1@get_file_a
$LN20@get_file_a:

; 1372 :     }
; 1373 : 
; 1374 :     dwNumBytesToReadOrWrite = 0;  // ZERO!!! (we don't wish to modify the file!)

  00035	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR dwNumBytesToReadOrWrite$[rsp], 0
$LN4@get_file_a:

; 1375 : 
; 1376 :     VERIFY( ( bCanRead = ReadFile ( hFile, &read_write_buffer, dwNumBytesToReadOrWrite, &dwNumBytesReadOrWritten, NULL ) )

  0003d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00046	4c 8d 4c 24 40	 lea	 r9, QWORD PTR dwNumBytesReadOrWritten$[rsp]
  0004b	44 8b 44 24 3c	 mov	 r8d, DWORD PTR dwNumBytesToReadOrWrite$[rsp]
  00050	48 8d 54 24 30	 lea	 rdx, QWORD PTR read_write_buffer$[rsp]
  00055	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hFile$[rsp]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ReadFile
  00060	89 44 24 34	 mov	 DWORD PTR bCanRead$[rsp], eax
  00064	83 7c 24 34 00	 cmp	 DWORD PTR bCanRead$[rsp], 0
  00069	75 66		 jne	 SHORT $LN21@get_file_a
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00071	83 f8 05	 cmp	 eax, 5
  00074	74 5b		 je	 SHORT $LN21@get_file_a
$LN7@get_file_a:
  00076	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159759
  0007d	41 b8 61 05 00
	00		 mov	 r8d, 1377		; 00000561H
  00083	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159760
  0008a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159761
  00091	e8 00 00 00 00	 call	 logmsg
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0009c	85 c0		 test	 eax, eax
  0009e	74 20		 je	 SHORT $LN22@get_file_a
  000a0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159763
  000a7	41 b8 61 05 00
	00		 mov	 r8d, 1377		; 00000561H
  000ad	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159764
  000b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159765
  000bb	e8 00 00 00 00	 call	 DebuggerTrace
$LN22@get_file_a:
  000c0	33 c0		 xor	 eax, eax
  000c2	85 c0		 test	 eax, eax
  000c4	75 b0		 jne	 SHORT $LN7@get_file_a
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000cc	85 c0		 test	 eax, eax
  000ce	74 01		 je	 SHORT $LN23@get_file_a
  000d0	cc		 int	 3
$LN23@get_file_a:
$LN21@get_file_a:
  000d1	33 c0		 xor	 eax, eax
  000d3	85 c0		 test	 eax, eax
  000d5	0f 85 62 ff ff
	ff		 jne	 $LN4@get_file_a
$LN10@get_file_a:

; 1377 :         || ERROR_ACCESS_DENIED == GetLastError() );
; 1378 : 
; 1379 :     VERIFY( ( bCanWrite = WriteFile ( hFile, &read_write_buffer, dwNumBytesToReadOrWrite, &dwNumBytesReadOrWritten, NULL ) )

  000db	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000e4	4c 8d 4c 24 40	 lea	 r9, QWORD PTR dwNumBytesReadOrWritten$[rsp]
  000e9	44 8b 44 24 3c	 mov	 r8d, DWORD PTR dwNumBytesToReadOrWrite$[rsp]
  000ee	48 8d 54 24 30	 lea	 rdx, QWORD PTR read_write_buffer$[rsp]
  000f3	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hFile$[rsp]
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WriteFile
  000fe	89 44 24 38	 mov	 DWORD PTR bCanWrite$[rsp], eax
  00102	83 7c 24 38 00	 cmp	 DWORD PTR bCanWrite$[rsp], 0
  00107	75 66		 jne	 SHORT $LN24@get_file_a
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0010f	83 f8 05	 cmp	 eax, 5
  00112	74 5b		 je	 SHORT $LN24@get_file_a
$LN13@get_file_a:
  00114	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159768
  0011b	41 b8 64 05 00
	00		 mov	 r8d, 1380		; 00000564H
  00121	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159769
  00128	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159770
  0012f	e8 00 00 00 00	 call	 logmsg
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0013a	85 c0		 test	 eax, eax
  0013c	74 20		 je	 SHORT $LN25@get_file_a
  0013e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159772
  00145	41 b8 64 05 00
	00		 mov	 r8d, 1380		; 00000564H
  0014b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159773
  00152	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159774
  00159	e8 00 00 00 00	 call	 DebuggerTrace
$LN25@get_file_a:
  0015e	33 c0		 xor	 eax, eax
  00160	85 c0		 test	 eax, eax
  00162	75 b0		 jne	 SHORT $LN13@get_file_a
  00164	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016a	85 c0		 test	 eax, eax
  0016c	74 01		 je	 SHORT $LN26@get_file_a
  0016e	cc		 int	 3
$LN26@get_file_a:
$LN24@get_file_a:
  0016f	33 c0		 xor	 eax, eax
  00171	85 c0		 test	 eax, eax
  00173	0f 85 62 ff ff
	ff		 jne	 $LN10@get_file_a

; 1380 :         || ERROR_ACCESS_DENIED == GetLastError() );
; 1381 : 
; 1382 :     // For reference, 'fcntl.h' defines the flags as follows:
; 1383 :     //
; 1384 :     //  #define   _O_RDONLY    0
; 1385 :     //  #define   _O_WRONLY    1
; 1386 :     //  #define   _O_RDWR      2
; 1387 : 
; 1388 :     if (  bCanRead  &&  bCanWrite ) return _O_RDWR;

  00179	83 7c 24 34 00	 cmp	 DWORD PTR bCanRead$[rsp], 0
  0017e	74 11		 je	 SHORT $LN27@get_file_a
  00180	83 7c 24 38 00	 cmp	 DWORD PTR bCanWrite$[rsp], 0
  00185	74 0a		 je	 SHORT $LN27@get_file_a
  00187	b8 02 00 00 00	 mov	 eax, 2
  0018c	e9 a3 00 00 00	 jmp	 $LN1@get_file_a
$LN27@get_file_a:

; 1389 :     if (  bCanRead  && !bCanWrite ) return _O_RDONLY;

  00191	83 7c 24 34 00	 cmp	 DWORD PTR bCanRead$[rsp], 0
  00196	74 0e		 je	 SHORT $LN28@get_file_a
  00198	83 7c 24 38 00	 cmp	 DWORD PTR bCanWrite$[rsp], 0
  0019d	75 07		 jne	 SHORT $LN28@get_file_a
  0019f	33 c0		 xor	 eax, eax
  001a1	e9 8e 00 00 00	 jmp	 $LN1@get_file_a
$LN28@get_file_a:

; 1390 :     if ( !bCanRead  &&  bCanWrite ) return _O_WRONLY;

  001a6	83 7c 24 34 00	 cmp	 DWORD PTR bCanRead$[rsp], 0
  001ab	75 0e		 jne	 SHORT $LN29@get_file_a
  001ad	83 7c 24 38 00	 cmp	 DWORD PTR bCanWrite$[rsp], 0
  001b2	74 07		 je	 SHORT $LN29@get_file_a
  001b4	b8 01 00 00 00	 mov	 eax, 1
  001b9	eb 79		 jmp	 SHORT $LN1@get_file_a
$LN29@get_file_a:
$LN16@get_file_a:

; 1391 : 
; 1392 :     ASSERT( FALSE );    // (HUH?! Can neither read NOR write to the file?!)

  001bb	33 c0		 xor	 eax, eax
  001bd	83 f8 01	 cmp	 eax, 1
  001c0	74 5b		 je	 SHORT $LN30@get_file_a
$LN19@get_file_a:
  001c2	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159780
  001c9	41 b8 70 05 00
	00		 mov	 r8d, 1392		; 00000570H
  001cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159781
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159782
  001dd	e8 00 00 00 00	 call	 logmsg
  001e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001e8	85 c0		 test	 eax, eax
  001ea	74 20		 je	 SHORT $LN31@get_file_a
  001ec	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159784
  001f3	41 b8 70 05 00
	00		 mov	 r8d, 1392		; 00000570H
  001f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159785
  00200	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159786
  00207	e8 00 00 00 00	 call	 DebuggerTrace
$LN31@get_file_a:
  0020c	33 c0		 xor	 eax, eax
  0020e	85 c0		 test	 eax, eax
  00210	75 b0		 jne	 SHORT $LN19@get_file_a
  00212	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00218	85 c0		 test	 eax, eax
  0021a	74 01		 je	 SHORT $LN32@get_file_a
  0021c	cc		 int	 3
$LN32@get_file_a:
$LN30@get_file_a:
  0021d	33 c0		 xor	 eax, eax
  0021f	85 c0		 test	 eax, eax
  00221	75 98		 jne	 SHORT $LN16@get_file_a

; 1393 :     errno = EBADF;      // (maybe they closed it before we could test it??)

  00223	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00229	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9

; 1394 :     return -1;          // (oh well)

  0022f	b8 ff ff ff ff	 mov	 eax, -1
$LN1@get_file_a:

; 1395 : }

  00234	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00238	c3		 ret	 0
get_file_accmode_flags ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
c$1 = 32
inlen$2 = 40
outpath$ = 64
inpath$ = 72
buffsize$ = 80
hostpath PROC

; 1237 : {

$LN25:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1238 :     // The possibilities:
; 1239 : 
; 1240 :     //   a. Linux/Cygwin absolute:
; 1241 :     //      /dir/foo.bar
; 1242 : 
; 1243 :     //   b. Linux/Cygwin relative:
; 1244 :     //      ../dir/foo.bar
; 1245 :     //      ./dir/foo.bar
; 1246 :     //      ../../.././dir/foo.bar
; 1247 :     //      (etc)
; 1248 : 
; 1249 :     //   c. Windows relative:
; 1250 :     //      ./dir\foo.bar
; 1251 :     //      ../dir\foo.bar
; 1252 :     //      ..\dir\foo.bar
; 1253 :     //      .\dir\foo.bar
; 1254 :     //      ..\dir/foo.bar
; 1255 :     //      .\dir/foo.bar
; 1256 :     //      ../..\../.\dir/foo.bar
; 1257 :     //      (etc)
; 1258 : 
; 1259 :     //   d. Windows absolute
; 1260 :     //      x:/dir/foo.bar
; 1261 :     //      x:\dir\foo.bar
; 1262 :     //      x:/dir\foo.bar
; 1263 :     //      x:\dir/foo.bar
; 1264 : 
; 1265 :     //   e. Windows device name
; 1266 :     //      \\.\foo
; 1267 :     //      //./foo
; 1268 : 
; 1269 :     // For case a we check for special Cygwin format "/cygdrive/x/..."
; 1270 :     // and convert it to "normalized" (forward-slash) case d format.
; 1271 :     // (Note that the slashes in this case MUST be forward slashes
; 1272 :     // or else the special Cygwin path format will not be detected!)
; 1273 : 
; 1274 :     // Case b we treat the same as case c.
; 1275 : 
; 1276 :     // For case c we simply convert all backslashes to forward slashes
; 1277 :     // since Windows supports both.
; 1278 : 
; 1279 :     // For case d we do nothing since it is already a Windows path
; 1280 :     // (other than normalize all backward slashes to forward slashes
; 1281 :     // since Windows supports both)
; 1282 : 
; 1283 :     // For case e we convert forward slashes to backward slashes. If
; 1284 :     // the device name is already in the proper format we do nothing.
; 1285 : 
; 1286 :     // NOTE that we do NOT attempt to convert relative paths to absolute
; 1287 :     // paths! The caller is responsible for doing that themselves after
; 1288 :     // calling this function if so desired.
; 1289 : 
; 1290 :     if (!outpath || !buffsize)

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR outpath$[rsp], 0
  00019	74 08		 je	 SHORT $LN11@hostpath
  0001b	48 83 7c 24 50
	00		 cmp	 QWORD PTR buffsize$[rsp], 0
  00021	75 07		 jne	 SHORT $LN10@hostpath
$LN11@hostpath:

; 1291 :         return NULL;

  00023	33 c0		 xor	 eax, eax
  00025	e9 72 02 00 00	 jmp	 $LN1@hostpath
$LN10@hostpath:

; 1292 : 
; 1293 :     *outpath = 0;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  0002f	c6 00 00	 mov	 BYTE PTR [rax], 0

; 1294 : 
; 1295 :     if (!inpath)

  00032	48 83 7c 24 48
	00		 cmp	 QWORD PTR inpath$[rsp], 0
  00038	75 0a		 jne	 SHORT $LN12@hostpath

; 1296 :         return outpath;

  0003a	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  0003f	e9 58 02 00 00	 jmp	 $LN1@hostpath
$LN12@hostpath:
$LN4@hostpath:

; 1297 : 
; 1298 :     ASSERT( outpath && inpath && buffsize );

  00044	48 83 7c 24 40
	00		 cmp	 QWORD PTR outpath$[rsp], 0
  0004a	74 10		 je	 SHORT $LN14@hostpath
  0004c	48 83 7c 24 48
	00		 cmp	 QWORD PTR inpath$[rsp], 0
  00052	74 08		 je	 SHORT $LN14@hostpath
  00054	48 83 7c 24 50
	00		 cmp	 QWORD PTR buffsize$[rsp], 0
  0005a	75 5b		 jne	 SHORT $LN13@hostpath
$LN14@hostpath:
$LN7@hostpath:
  0005c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159707
  00063	41 b8 12 05 00
	00		 mov	 r8d, 1298		; 00000512H
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159708
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159709
  00077	e8 00 00 00 00	 call	 logmsg
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00082	85 c0		 test	 eax, eax
  00084	74 20		 je	 SHORT $LN15@hostpath
  00086	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159711
  0008d	41 b8 12 05 00
	00		 mov	 r8d, 1298		; 00000512H
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159712
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159713
  000a1	e8 00 00 00 00	 call	 DebuggerTrace
$LN15@hostpath:
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 b0		 jne	 SHORT $LN7@hostpath
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b2	85 c0		 test	 eax, eax
  000b4	74 01		 je	 SHORT $LN16@hostpath
  000b6	cc		 int	 3
$LN16@hostpath:
$LN13@hostpath:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 87		 jne	 SHORT $LN4@hostpath

; 1299 : 
; 1300 :     if (0
; 1301 :         || strncmp( (const char *)inpath, "\\\\.\\", 4 ) == 0   // (Windows device name?)
; 1302 :         || strncmp( (const char *)inpath, "//./",    4 ) == 0   // (unnormalized format?)

  000bd	33 c0		 xor	 eax, eax
  000bf	85 c0		 test	 eax, eax
  000c1	75 38		 jne	 SHORT $LN18@hostpath
  000c3	41 b8 04 00 00
	00		 mov	 r8d, 4
  000c9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159717
  000d0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR inpath$[rsp]
  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000db	85 c0		 test	 eax, eax
  000dd	74 1c		 je	 SHORT $LN18@hostpath
  000df	41 b8 04 00 00
	00		 mov	 r8d, 4
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159718
  000ec	48 8b 4c 24 48	 mov	 rcx, QWORD PTR inpath$[rsp]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000f7	85 c0		 test	 eax, eax
  000f9	75 3b		 jne	 SHORT $LN17@hostpath
$LN18@hostpath:

; 1303 :     )
; 1304 :     {
; 1305 :         strlcpy( (char *)outpath, "\\\\.\\", buffsize );

  000fb	4c 8b 44 24 50	 mov	 r8, QWORD PTR buffsize$[rsp]
  00100	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159719
  00107	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outpath$[rsp]
  0010c	e8 00 00 00 00	 call	 strlcpy

; 1306 :         strlcat( (char *)outpath, (const char *)inpath+4,  buffsize );

  00111	48 8b 44 24 48	 mov	 rax, QWORD PTR inpath$[rsp]
  00116	48 83 c0 04	 add	 rax, 4
  0011a	4c 8b 44 24 50	 mov	 r8, QWORD PTR buffsize$[rsp]
  0011f	48 8b d0	 mov	 rdx, rax
  00122	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outpath$[rsp]
  00127	e8 00 00 00 00	 call	 strlcat

; 1307 :         return outpath;

  0012c	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  00131	e9 66 01 00 00	 jmp	 $LN1@hostpath
$LN17@hostpath:

; 1308 :     }
; 1309 : 
; 1310 :     if (*inpath && buffsize > 1)

  00136	48 8b 44 24 48	 mov	 rax, QWORD PTR inpath$[rsp]
  0013b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013e	85 c0		 test	 eax, eax
  00140	0f 84 51 01 00
	00		 je	 $LN19@hostpath
  00146	48 83 7c 24 50
	01		 cmp	 QWORD PTR buffsize$[rsp], 1
  0014c	0f 86 45 01 00
	00		 jbe	 $LN19@hostpath

; 1311 :     {
; 1312 :         size_t inlen = strlen((const char *)inpath);

  00152	48 8b 4c 24 48	 mov	 rcx, QWORD PTR inpath$[rsp]
  00157	e8 00 00 00 00	 call	 strlen
  0015c	48 89 44 24 28	 mov	 QWORD PTR inlen$2[rsp], rax

; 1313 : 
; 1314 :         if (1
; 1315 :             && inlen >= 11
; 1316 :             && strncasecmp((const char *)inpath,"/cygdrive/",10) == 0
; 1317 :             && isalpha(inpath[10])

  00161	33 c0		 xor	 eax, eax
  00163	83 f8 01	 cmp	 eax, 1
  00166	0f 84 b5 00 00
	00		 je	 $LN20@hostpath
  0016c	48 83 7c 24 28
	0b		 cmp	 QWORD PTR inlen$2[rsp], 11
  00172	0f 82 a9 00 00
	00		 jb	 $LN20@hostpath
  00178	41 b8 0a 00 00
	00		 mov	 r8d, 10
  0017e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159722
  00185	48 8b 4c 24 48	 mov	 rcx, QWORD PTR inpath$[rsp]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__strnicmp
  00190	85 c0		 test	 eax, eax
  00192	0f 85 89 00 00
	00		 jne	 $LN20@hostpath
  00198	b8 01 00 00 00	 mov	 eax, 1
  0019d	48 6b c0 0a	 imul	 rax, rax, 10
  001a1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR inpath$[rsp]
  001a6	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  001aa	8b c8		 mov	 ecx, eax
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_isalpha
  001b2	85 c0		 test	 eax, eax
  001b4	74 6b		 je	 SHORT $LN20@hostpath

; 1318 :         )
; 1319 :         {
; 1320 :             *outpath++ = inpath[10];

  001b6	b8 01 00 00 00	 mov	 eax, 1
  001bb	48 6b c0 0a	 imul	 rax, rax, 10
  001bf	48 8b 4c 24 40	 mov	 rcx, QWORD PTR outpath$[rsp]
  001c4	48 8b 54 24 48	 mov	 rdx, QWORD PTR inpath$[rsp]
  001c9	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  001cd	88 01		 mov	 BYTE PTR [rcx], al
  001cf	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  001d4	48 ff c0	 inc	 rax
  001d7	48 89 44 24 40	 mov	 QWORD PTR outpath$[rsp], rax

; 1321 :             buffsize--;

  001dc	48 8b 44 24 50	 mov	 rax, QWORD PTR buffsize$[rsp]
  001e1	48 ff c8	 dec	 rax
  001e4	48 89 44 24 50	 mov	 QWORD PTR buffsize$[rsp], rax

; 1322 :             if (buffsize > 1)

  001e9	48 83 7c 24 50
	01		 cmp	 QWORD PTR buffsize$[rsp], 1
  001ef	76 22		 jbe	 SHORT $LN21@hostpath

; 1323 :             {
; 1324 :                 *outpath++ = ':';

  001f1	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  001f6	c6 00 3a	 mov	 BYTE PTR [rax], 58	; 0000003aH
  001f9	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  001fe	48 ff c0	 inc	 rax
  00201	48 89 44 24 40	 mov	 QWORD PTR outpath$[rsp], rax

; 1325 :                 buffsize--;

  00206	48 8b 44 24 50	 mov	 rax, QWORD PTR buffsize$[rsp]
  0020b	48 ff c8	 dec	 rax
  0020e	48 89 44 24 50	 mov	 QWORD PTR buffsize$[rsp], rax
$LN21@hostpath:

; 1326 :             }
; 1327 :             inpath += 11;

  00213	48 8b 44 24 48	 mov	 rax, QWORD PTR inpath$[rsp]
  00218	48 83 c0 0b	 add	 rax, 11
  0021c	48 89 44 24 48	 mov	 QWORD PTR inpath$[rsp], rax
$LN20@hostpath:
$LN8@hostpath:

; 1328 :         }
; 1329 : 
; 1330 :         while (*inpath && --buffsize)

  00221	48 8b 44 24 48	 mov	 rax, QWORD PTR inpath$[rsp]
  00226	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00229	85 c0		 test	 eax, eax
  0022b	74 62		 je	 SHORT $LN9@hostpath
  0022d	48 8b 44 24 50	 mov	 rax, QWORD PTR buffsize$[rsp]
  00232	48 ff c8	 dec	 rax
  00235	48 89 44 24 50	 mov	 QWORD PTR buffsize$[rsp], rax
  0023a	48 83 7c 24 50
	00		 cmp	 QWORD PTR buffsize$[rsp], 0
  00240	74 4d		 je	 SHORT $LN9@hostpath

; 1331 :         {
; 1332 :             BYTE c = *inpath++;

  00242	48 8b 44 24 48	 mov	 rax, QWORD PTR inpath$[rsp]
  00247	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0024a	88 44 24 20	 mov	 BYTE PTR c$1[rsp], al
  0024e	48 8b 44 24 48	 mov	 rax, QWORD PTR inpath$[rsp]
  00253	48 ff c0	 inc	 rax
  00256	48 89 44 24 48	 mov	 QWORD PTR inpath$[rsp], rax

; 1333 :             if (c == '\\' || c == '/' ) c = PATHSEPC;

  0025b	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  00260	83 f8 5c	 cmp	 eax, 92			; 0000005cH
  00263	74 0a		 je	 SHORT $LN23@hostpath
  00265	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$1[rsp]
  0026a	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  0026d	75 05		 jne	 SHORT $LN22@hostpath
$LN23@hostpath:
  0026f	c6 44 24 20 2f	 mov	 BYTE PTR c$1[rsp], 47	; 0000002fH
$LN22@hostpath:

; 1334 :             *outpath++ = c;

  00274	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  00279	0f b6 4c 24 20	 movzx	 ecx, BYTE PTR c$1[rsp]
  0027e	88 08		 mov	 BYTE PTR [rax], cl
  00280	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  00285	48 ff c0	 inc	 rax
  00288	48 89 44 24 40	 mov	 QWORD PTR outpath$[rsp], rax

; 1335 :         }

  0028d	eb 92		 jmp	 SHORT $LN8@hostpath
$LN9@hostpath:

; 1336 :         *outpath = 0;

  0028f	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
  00294	c6 00 00	 mov	 BYTE PTR [rax], 0
$LN19@hostpath:

; 1337 :     }
; 1338 :     return outpath;

  00297	48 8b 44 24 40	 mov	 rax, QWORD PTR outpath$[rsp]
$LN1@hostpath:

; 1339 : }

  0029c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002a0	c3		 ret	 0
hostpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv68 = 32
tv76 = 36
cp$ = 64
addr$ = 72
inet_aton PROC

; 3033 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3034 :     // Return success as long as both args are not NULL *and*
; 3035 :     // the result is not INADDR_NONE (0xFFFFFFFF), -OR- if it
; 3036 :     // is [INADDR_NONE], [we return success] if that is the
; 3037 :     // actual expected value of the conversion...
; 3038 : 
; 3039 :     return

  0000e	33 c0		 xor	 eax, eax
  00010	83 f8 01	 cmp	 eax, 1
  00013	74 56		 je	 SHORT $LN3@inet_aton
  00015	48 83 7c 24 40
	00		 cmp	 QWORD PTR cp$[rsp], 0
  0001b	74 4e		 je	 SHORT $LN3@inet_aton
  0001d	48 83 7c 24 48
	00		 cmp	 QWORD PTR addr$[rsp], 0
  00023	74 46		 je	 SHORT $LN3@inet_aton
  00025	33 c0		 xor	 eax, eax
  00027	85 c0		 test	 eax, eax
  00029	75 36		 jne	 SHORT $LN4@inet_aton
  0002b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cp$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_inet_addr
  00036	89 44 24 20	 mov	 DWORD PTR tv68[rsp], eax
  0003a	48 8b 44 24 48	 mov	 rax, QWORD PTR addr$[rsp]
  0003f	8b 4c 24 20	 mov	 ecx, DWORD PTR tv68[rsp]
  00043	89 08		 mov	 DWORD PTR [rax], ecx
  00045	83 7c 24 20 ff	 cmp	 DWORD PTR tv68[rsp], -1	; ffffffffH
  0004a	75 15		 jne	 SHORT $LN4@inet_aton
  0004c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG160712
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR cp$[rsp]
  00058	e8 00 00 00 00	 call	 strcmp
  0005d	85 c0		 test	 eax, eax
  0005f	75 0a		 jne	 SHORT $LN3@inet_aton
$LN4@inet_aton:
  00061	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv76[rsp], 1
  00069	eb 08		 jmp	 SHORT $LN5@inet_aton
$LN3@inet_aton:
  0006b	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv76[rsp], 0
$LN5@inet_aton:
  00073	8b 44 24 24	 mov	 eax, DWORD PTR tv76[rsp]

; 3040 :     (
; 3041 :         (1
; 3042 :             &&  cp      // (must not be NULL)
; 3043 :             &&  addr    // (must not be NULL)
; 3044 :             &&  (0
; 3045 :                     ||  INADDR_NONE != ( addr->s_addr = inet_addr( cp ) )
; 3046 :                     ||  strcmp( cp, "255.255.255.255" ) == 0
; 3047 :                 )
; 3048 :         )
; 3049 :         ? 1 : 0         //  1 == success,   0 == failure
; 3050 :     );
; 3051 : }

  00077	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0007b	c3		 ret	 0
inet_aton ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
retval$ = 32
file_name$ = 64
resolved_name$ = 72
realpath PROC

; 1200 : {

$LN6:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1201 :     char* retval;
; 1202 : 
; 1203 :     if ( !file_name || !resolved_name )

  0000e	48 83 7c 24 40
	00		 cmp	 QWORD PTR file_name$[rsp], 0
  00014	74 08		 je	 SHORT $LN3@realpath
  00016	48 83 7c 24 48
	00		 cmp	 QWORD PTR resolved_name$[rsp], 0
  0001c	75 10		 jne	 SHORT $LN2@realpath
$LN3@realpath:

; 1204 :     {
; 1205 :         errno = EINVAL;

  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00024	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 1206 :         return NULL;

  0002a	33 c0		 xor	 eax, eax
  0002c	eb 34		 jmp	 SHORT $LN1@realpath
$LN2@realpath:

; 1207 :     }
; 1208 : 
; 1209 :     // PROGRAMMING NOTE: unfortunately there's no possible way to implement an accurate
; 1210 :     // Win32 port of realpath in regard to the errno values returned whenever there's an
; 1211 :     // error. The errno values that are set whenever realpath fails are quite precise,
; 1212 :     // telling you exactly what went wrong (name too long, invalid directory component,
; 1213 :     // etc), whereas _fullpath only returns success/failure with absolutely no indication
; 1214 :     // as to WHY it failed. To further complicate matters, there's no real "generic" type
; 1215 :     // of errno value we can choose to return to the caller should _fullpath fail either,
; 1216 :     // so for this implementation we purposely return EIO (i/o error) if _fullpath fails
; 1217 :     // for any reason. That may perhaps be somewhat misleading (since the actual cause of
; 1218 :     // the failure was probably not because of an i/o error), but returning any of the
; 1219 :     // OTHER possible realpath errno values would be even MORE misleading in my opinion.
; 1220 : 
; 1221 :     if ( !(retval = _fullpath( resolved_name, file_name, PATH_MAX ) ) )

  0002e	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00034	48 8b 54 24 40	 mov	 rdx, QWORD PTR file_name$[rsp]
  00039	48 8b 4c 24 48	 mov	 rcx, QWORD PTR resolved_name$[rsp]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fullpath
  00044	48 89 44 24 20	 mov	 QWORD PTR retval$[rsp], rax
  00049	48 83 7c 24 20
	00		 cmp	 QWORD PTR retval$[rsp], 0
  0004f	75 0c		 jne	 SHORT $LN4@realpath

; 1222 :         errno = EIO;

  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00057	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
$LN4@realpath:

; 1223 : 
; 1224 :     return retval;

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR retval$[rsp]
$LN1@realpath:

; 1225 : }

  00062	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00066	c3		 ret	 0
realpath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv71 = 32
dwSize$ = 36
name$ = 64
namesize$ = 72
getlogin_r PROC

; 1162 : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1163 :     DWORD  dwSize = (DWORD)namesize;

  0000e	8b 44 24 48	 mov	 eax, DWORD PTR namesize$[rsp]
  00012	89 44 24 24	 mov	 DWORD PTR dwSize$[rsp], eax

; 1164 : 
; 1165 :     if ( !name )

  00016	48 83 7c 24 40
	00		 cmp	 QWORD PTR name$[rsp], 0
  0001c	75 07		 jne	 SHORT $LN2@getlogin_r

; 1166 :         return EFAULT;

  0001e	b8 0e 00 00 00	 mov	 eax, 14
  00023	eb 44		 jmp	 SHORT $LN1@getlogin_r
$LN2@getlogin_r:

; 1167 : 
; 1168 :     if ( namesize < 2 || namesize > ( LOGIN_NAME_MAX + 1 ) )

  00025	48 83 7c 24 48
	02		 cmp	 QWORD PTR namesize$[rsp], 2
  0002b	72 0b		 jb	 SHORT $LN4@getlogin_r
  0002d	48 81 7c 24 48
	01 01 00 00	 cmp	 QWORD PTR namesize$[rsp], 257 ; 00000101H
  00036	76 07		 jbe	 SHORT $LN3@getlogin_r
$LN4@getlogin_r:

; 1169 :         return EINVAL;

  00038	b8 16 00 00 00	 mov	 eax, 22
  0003d	eb 2a		 jmp	 SHORT $LN1@getlogin_r
$LN3@getlogin_r:

; 1170 : 
; 1171 :     return ( GetUserName( name, &dwSize ) ? 0 : ERANGE );

  0003f	48 8d 54 24 24	 lea	 rdx, QWORD PTR dwSize$[rsp]
  00044	48 8b 4c 24 40	 mov	 rcx, QWORD PTR name$[rsp]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetUserNameA
  0004f	85 c0		 test	 eax, eax
  00051	74 0a		 je	 SHORT $LN6@getlogin_r
  00053	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
  0005b	eb 08		 jmp	 SHORT $LN7@getlogin_r
$LN6@getlogin_r:
  0005d	c7 44 24 20 22
	00 00 00	 mov	 DWORD PTR tv71[rsp], 34	; 00000022H
$LN7@getlogin_r:
  00065	8b 44 24 20	 mov	 eax, DWORD PTR tv71[rsp]
$LN1@getlogin_r:

; 1172 : }

  00069	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006d	c3		 ret	 0
getlogin_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
rc$ = 32
getlogin PROC

; 1181 : {

$LN4:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1182 :     static char login_name [ LOGIN_NAME_MAX + 1 ];
; 1183 : 
; 1184 :     int rc;
; 1185 : 
; 1186 :     if ( ( rc = getlogin_r ( login_name, sizeof(login_name) ) ) == 0 )

  00004	ba 01 01 00 00	 mov	 edx, 257		; 00000101H
  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?login_name@?1??getlogin@@9@9
  00010	e8 00 00 00 00	 call	 getlogin_r
  00015	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax
  00019	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0001e	75 09		 jne	 SHORT $LN2@getlogin

; 1187 :         return login_name;

  00020	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?login_name@?1??getlogin@@9@9
  00027	eb 0e		 jmp	 SHORT $LN1@getlogin
$LN2@getlogin:

; 1188 : 
; 1189 :     errno = rc;

  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0002f	8b 4c 24 20	 mov	 ecx, DWORD PTR rc$[rsp]
  00033	89 08		 mov	 DWORD PTR [rax], ecx

; 1190 :     return NULL;

  00035	33 c0		 xor	 eax, eax
$LN1@getlogin:

; 1191 : }

  00037	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003b	c3		 ret	 0
getlogin ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tid$ = 8
clk_id$ = 16
pthread_getcpuclockid PROC

; 499  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 500  :     *clk_id = -tid;

  00009	8b 44 24 08	 mov	 eax, DWORD PTR tid$[rsp]
  0000d	f7 d8		 neg	 eax
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR clk_id$[rsp]
  00014	89 01		 mov	 DWORD PTR [rcx], eax

; 501  :     return 0;

  00016	33 c0		 xor	 eax, eax

; 502  : }

  00018	c3		 ret	 0
pthread_getcpuclockid ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
result$ = 32
tv67 = 36
hProcessSnap$1 = 40
tv209 = 48
dwOurProcessId$2 = 52
child_usage$3 = 56
pe32$4 = 80
__$ArrayPad$ = 384
who$ = 416
r_usage$ = 424
getrusage PROC

; 1076 : {

$LN47:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	57		 push	 rdi
  0000a	48 81 ec 90 01
	00 00		 sub	 rsp, 400		; 00000190H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1077 :     int result;
; 1078 : 
; 1079 :     if ( !r_usage || r_usage == NULL)

  00023	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR r_usage$[rsp], 0
  0002c	74 0b		 je	 SHORT $LN26@getrusage
  0002e	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR r_usage$[rsp], 0
  00037	75 16		 jne	 SHORT $LN25@getrusage
$LN26@getrusage:

; 1080 :     {
; 1081 :         errno = EFAULT;

  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0003f	c7 00 0e 00 00
	00		 mov	 DWORD PTR [rax], 14

; 1082 :         return ( -1 );

  00045	b8 ff ff ff ff	 mov	 eax, -1
  0004a	e9 36 03 00 00	 jmp	 $LN1@getrusage
$LN25@getrusage:

; 1083 :     }
; 1084 : 
; 1085 :     switch ( who )

  0004f	8b 84 24 a0 01
	00 00		 mov	 eax, DWORD PTR who$[rsp]
  00056	89 44 24 24	 mov	 DWORD PTR tv67[rsp], eax
  0005a	83 7c 24 24 ff	 cmp	 DWORD PTR tv67[rsp], -1
  0005f	74 33		 je	 SHORT $LN28@getrusage
  00061	83 7c 24 24 00	 cmp	 DWORD PTR tv67[rsp], 0
  00066	74 10		 je	 SHORT $LN27@getrusage
  00068	83 7c 24 24 01	 cmp	 DWORD PTR tv67[rsp], 1
  0006d	0f 84 a8 02 00
	00		 je	 $LN42@getrusage
  00073	e9 c3 02 00 00	 jmp	 $LN43@getrusage
$LN27@getrusage:

; 1086 :     {
; 1087 :         case RUSAGE_SELF:
; 1088 :             return DoGetRUsage( GetCurrentProcessId(), rusage_type_process, r_usage );

  00078	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcessId
  0007e	4c 8b 84 24 a8
	01 00 00	 mov	 r8, QWORD PTR r_usage$[rsp]
  00086	33 d2		 xor	 edx, edx
  00088	8b c8		 mov	 ecx, eax
  0008a	e8 00 00 00 00	 call	 DoGetRUsage
  0008f	e9 f1 02 00 00	 jmp	 $LN1@getrusage
$LN28@getrusage:

; 1089 : 
; 1090 :         case RUSAGE_CHILDREN:
; 1091 :         {
; 1092 :             DWORD           dwOurProcessId  = GetCurrentProcessId();

  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcessId
  0009a	89 44 24 34	 mov	 DWORD PTR dwOurProcessId$2[rsp], eax

; 1093 :             HANDLE          hProcessSnap    = NULL;

  0009e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR hProcessSnap$1[rsp], 0

; 1094 :             PROCESSENTRY32  pe32;
; 1095 :             struct rusage   child_usage;
; 1096 : 
; 1097 :             memset( &pe32, 0, sizeof(pe32) );

  000a7	48 8d 44 24 50	 lea	 rax, QWORD PTR pe32$4[rsp]
  000ac	48 8b f8	 mov	 rdi, rax
  000af	33 c0		 xor	 eax, eax
  000b1	b9 30 01 00 00	 mov	 ecx, 304		; 00000130H
  000b6	f3 aa		 rep stosb

; 1098 : 
; 1099 :             // Take a snapshot of all active processes...
; 1100 : 
; 1101 :             hProcessSnap = CreateToolhelp32Snapshot( TH32CS_SNAPPROCESS, 0 );

  000b8	33 d2		 xor	 edx, edx
  000ba	b9 02 00 00 00	 mov	 ecx, 2
  000bf	e8 00 00 00 00	 call	 CreateToolhelp32Snapshot
  000c4	48 89 44 24 28	 mov	 QWORD PTR hProcessSnap$1[rsp], rax

; 1102 : 
; 1103 :             if ( INVALID_HANDLE_VALUE == hProcessSnap )

  000c9	48 83 7c 24 28
	ff		 cmp	 QWORD PTR hProcessSnap$1[rsp], -1
  000cf	75 12		 jne	 SHORT $LN29@getrusage

; 1104 :                 return rusage_failure(r_usage);

  000d1	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR r_usage$[rsp]
  000d9	e8 00 00 00 00	 call	 rusage_failure
  000de	e9 a2 02 00 00	 jmp	 $LN1@getrusage
$LN29@getrusage:

; 1105 : 
; 1106 :             pe32.dwSize = sizeof( PROCESSENTRY32 );

  000e3	c7 44 24 50 30
	01 00 00	 mov	 DWORD PTR pe32$4[rsp], 304 ; 00000130H

; 1107 : 
; 1108 :             //  Walk the snapshot...
; 1109 : 
; 1110 :             if ( !Process32First( hProcessSnap, &pe32 ) )

  000eb	48 8d 54 24 50	 lea	 rdx, QWORD PTR pe32$4[rsp]
  000f0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hProcessSnap$1[rsp]
  000f5	e8 00 00 00 00	 call	 Process32First
  000fa	85 c0		 test	 eax, eax
  000fc	75 1d		 jne	 SHORT $LN30@getrusage

; 1111 :             {
; 1112 :                 CloseHandle( hProcessSnap );

  000fe	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hProcessSnap$1[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle

; 1113 :                 return rusage_failure( r_usage );

  00109	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR r_usage$[rsp]
  00111	e8 00 00 00 00	 call	 rusage_failure
  00116	e9 6a 02 00 00	 jmp	 $LN1@getrusage
$LN30@getrusage:

; 1114 :             }
; 1115 : 
; 1116 :             r_usage->ru_stime.tv_sec = r_usage->ru_stime.tv_usec = 0;

  0011b	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  00123	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0
  0012a	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  00132	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 1117 :             r_usage->ru_utime.tv_sec = r_usage->ru_utime.tv_usec = 0;

  00139	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  00141	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0
  00148	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  00150	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN6@getrusage:

; 1118 : 
; 1119 :             // Locate all children of the current process
; 1120 :             // and accumulate their process times together...
; 1121 : 
; 1122 :             do
; 1123 :             {
; 1124 :                 if ( pe32.th32ParentProcessID != dwOurProcessId )

  00156	8b 44 24 34	 mov	 eax, DWORD PTR dwOurProcessId$2[rsp]
  0015a	39 44 24 70	 cmp	 DWORD PTR pe32$4[rsp+32], eax
  0015e	74 05		 je	 SHORT $LN31@getrusage

; 1125 :                     continue;

  00160	e9 25 01 00 00	 jmp	 $LN4@getrusage
$LN31@getrusage:

; 1126 : 
; 1127 :                 result = DoGetRUsage( pe32.th32ProcessID, rusage_type_process, &child_usage );

  00165	4c 8d 44 24 38	 lea	 r8, QWORD PTR child_usage$3[rsp]
  0016a	33 d2		 xor	 edx, edx
  0016c	8b 4c 24 58	 mov	 ecx, DWORD PTR pe32$4[rsp+8]
  00170	e8 00 00 00 00	 call	 DoGetRUsage
  00175	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 1128 :                 if ( result != 0 )

  00179	83 7c 24 20 00	 cmp	 DWORD PTR result$[rsp], 0
  0017e	74 12		 je	 SHORT $LN32@getrusage

; 1129 :                     return rusage_failure( r_usage );

  00180	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR r_usage$[rsp]
  00188	e8 00 00 00 00	 call	 rusage_failure
  0018d	e9 f3 01 00 00	 jmp	 $LN1@getrusage
$LN32@getrusage:
$LN9@getrusage:

; 1130 : 
; 1131 :                 VERIFY( timeval_add( &child_usage.ru_stime, &r_usage->ru_stime ) == 0 );

  00192	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  0019a	48 83 c0 08	 add	 rax, 8
  0019e	48 8b d0	 mov	 rdx, rax
  001a1	48 8d 4c 24 40	 lea	 rcx, QWORD PTR child_usage$3[rsp+8]
  001a6	e8 00 00 00 00	 call	 timeval_add
  001ab	85 c0		 test	 eax, eax
  001ad	74 5b		 je	 SHORT $LN33@getrusage
$LN12@getrusage:
  001af	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159622
  001b6	41 b8 6b 04 00
	00		 mov	 r8d, 1131		; 0000046bH
  001bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159623
  001c3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159624
  001ca	e8 00 00 00 00	 call	 logmsg
  001cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  001d5	85 c0		 test	 eax, eax
  001d7	74 20		 je	 SHORT $LN34@getrusage
  001d9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159626
  001e0	41 b8 6b 04 00
	00		 mov	 r8d, 1131		; 0000046bH
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159627
  001ed	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159628
  001f4	e8 00 00 00 00	 call	 DebuggerTrace
$LN34@getrusage:
  001f9	33 c0		 xor	 eax, eax
  001fb	85 c0		 test	 eax, eax
  001fd	75 b0		 jne	 SHORT $LN12@getrusage
  001ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00205	85 c0		 test	 eax, eax
  00207	74 01		 je	 SHORT $LN35@getrusage
  00209	cc		 int	 3
$LN35@getrusage:
$LN33@getrusage:
  0020a	33 c0		 xor	 eax, eax
  0020c	85 c0		 test	 eax, eax
  0020e	75 82		 jne	 SHORT $LN9@getrusage
$LN15@getrusage:

; 1132 :                 VERIFY( timeval_add( &child_usage.ru_utime, &r_usage->ru_utime ) == 0 );

  00210	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR r_usage$[rsp]
  00218	48 8b d0	 mov	 rdx, rax
  0021b	48 8d 4c 24 38	 lea	 rcx, QWORD PTR child_usage$3[rsp]
  00220	e8 00 00 00 00	 call	 timeval_add
  00225	85 c0		 test	 eax, eax
  00227	74 5b		 je	 SHORT $LN36@getrusage
$LN18@getrusage:
  00229	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159631
  00230	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00236	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159632
  0023d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159633
  00244	e8 00 00 00 00	 call	 logmsg
  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0024f	85 c0		 test	 eax, eax
  00251	74 20		 je	 SHORT $LN37@getrusage
  00253	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159635
  0025a	41 b8 6c 04 00
	00		 mov	 r8d, 1132		; 0000046cH
  00260	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159636
  00267	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159637
  0026e	e8 00 00 00 00	 call	 DebuggerTrace
$LN37@getrusage:
  00273	33 c0		 xor	 eax, eax
  00275	85 c0		 test	 eax, eax
  00277	75 b0		 jne	 SHORT $LN18@getrusage
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0027f	85 c0		 test	 eax, eax
  00281	74 01		 je	 SHORT $LN38@getrusage
  00283	cc		 int	 3
$LN38@getrusage:
$LN36@getrusage:
  00284	33 c0		 xor	 eax, eax
  00286	85 c0		 test	 eax, eax
  00288	75 86		 jne	 SHORT $LN15@getrusage
$LN4@getrusage:

; 1133 :             }
; 1134 :             while ( Process32Next( hProcessSnap, &pe32 ) );

  0028a	48 8d 54 24 50	 lea	 rdx, QWORD PTR pe32$4[rsp]
  0028f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hProcessSnap$1[rsp]
  00294	e8 00 00 00 00	 call	 Process32Next
  00299	85 c0		 test	 eax, eax
  0029b	0f 85 b5 fe ff
	ff		 jne	 $LN6@getrusage
$LN21@getrusage:

; 1135 : 
; 1136 :             VERIFY( CloseHandle( hProcessSnap ) );

  002a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR hProcessSnap$1[rsp]
  002a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
  002ac	85 c0		 test	 eax, eax
  002ae	75 5b		 jne	 SHORT $LN39@getrusage
$LN24@getrusage:
  002b0	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159640
  002b7	41 b8 70 04 00
	00		 mov	 r8d, 1136		; 00000470H
  002bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159641
  002c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159642
  002cb	e8 00 00 00 00	 call	 logmsg
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002d6	85 c0		 test	 eax, eax
  002d8	74 20		 je	 SHORT $LN40@getrusage
  002da	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159644
  002e1	41 b8 70 04 00
	00		 mov	 r8d, 1136		; 00000470H
  002e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159645
  002ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159646
  002f5	e8 00 00 00 00	 call	 DebuggerTrace
$LN40@getrusage:
  002fa	33 c0		 xor	 eax, eax
  002fc	85 c0		 test	 eax, eax
  002fe	75 b0		 jne	 SHORT $LN24@getrusage
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00306	85 c0		 test	 eax, eax
  00308	74 01		 je	 SHORT $LN41@getrusage
  0030a	cc		 int	 3
$LN41@getrusage:
$LN39@getrusage:
  0030b	33 c0		 xor	 eax, eax
  0030d	85 c0		 test	 eax, eax
  0030f	75 90		 jne	 SHORT $LN21@getrusage

; 1137 : 
; 1138 :             result = 0;

  00311	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR result$[rsp], 0

; 1139 :             break;

  00319	eb 3d		 jmp	 SHORT $LN2@getrusage
$LN42@getrusage:

; 1140 :         }
; 1141 : 
; 1142 :         case RUSAGE_THREAD:
; 1143 :             result = DoGetRUsage( GetCurrentThreadId(), rusage_type_thread, r_usage );

  0031b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentThreadId
  00321	4c 8b 84 24 a8
	01 00 00	 mov	 r8, QWORD PTR r_usage$[rsp]
  00329	ba 01 00 00 00	 mov	 edx, 1
  0032e	8b c8		 mov	 ecx, eax
  00330	e8 00 00 00 00	 call	 DoGetRUsage
  00335	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax

; 1144 :             break;

  00339	eb 1d		 jmp	 SHORT $LN2@getrusage
$LN43@getrusage:

; 1145 : 
; 1146 :         default:
; 1147 :             result = DoGetRUsage( who, rusage_type_unknown, r_usage );

  0033b	4c 8b 84 24 a8
	01 00 00	 mov	 r8, QWORD PTR r_usage$[rsp]
  00343	ba 02 00 00 00	 mov	 edx, 2
  00348	8b 8c 24 a0 01
	00 00		 mov	 ecx, DWORD PTR who$[rsp]
  0034f	e8 00 00 00 00	 call	 DoGetRUsage
  00354	89 44 24 20	 mov	 DWORD PTR result$[rsp], eax
$LN2@getrusage:

; 1148 :             break;
; 1149 :     }
; 1150 : 
; 1151 :     errno = ( result == 0 ) ? 0 : errno;

  00358	83 7c 24 20 00	 cmp	 DWORD PTR result$[rsp], 0
  0035d	75 0a		 jne	 SHORT $LN45@getrusage
  0035f	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv209[rsp], 0
  00367	eb 0c		 jmp	 SHORT $LN46@getrusage
$LN45@getrusage:
  00369	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0036f	8b 00		 mov	 eax, DWORD PTR [rax]
  00371	89 44 24 30	 mov	 DWORD PTR tv209[rsp], eax
$LN46@getrusage:
  00375	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0037b	8b 4c 24 30	 mov	 ecx, DWORD PTR tv209[rsp]
  0037f	89 08		 mov	 DWORD PTR [rax], ecx

; 1152 :     return ( result );

  00381	8b 44 24 20	 mov	 eax, DWORD PTR result$[rsp]
$LN1@getrusage:

; 1153 : }

  00385	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0038d	48 33 cc	 xor	 rcx, rsp
  00390	e8 00 00 00 00	 call	 __security_check_cookie
  00395	48 81 c4 90 01
	00 00		 add	 rsp, 400		; 00000190H
  0039c	5f		 pop	 rdi
  0039d	c3		 ret	 0
getrusage ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
a$ = 48
b$ = 56
alphasort PROC

; 974  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 975  :     return  strfilenamecmp ( (*a)->d_name, (*b)->d_name );

  0000e	48 8b 44 24 38	 mov	 rax, QWORD PTR b$[rsp]
  00013	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00016	48 83 c0 04	 add	 rax, 4
  0001a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR a$[rsp]
  0001f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00022	48 83 c1 04	 add	 rcx, 4
  00026	48 8b d0	 mov	 rdx, rax
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stricmp

; 976  : }

  0002f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00033	c3		 ret	 0
alphasort ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
pos$ = 32
pattern$ = 40
count$ = 48
handle$ = 56
rtn$1 = 64
names$ = 72
m$ = 80
copyentry$2 = 88
file_data$ = 96
current$3 = 416
__$ArrayPad$ = 688
dir$ = 720
namelist$ = 728
filter$ = 736
compar$ = 744
scandir	PROC

; 891  : {

$LN16:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	57		 push	 rdi
  00015	48 81 ec c0 02
	00 00		 sub	 rsp, 704		; 000002c0H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 b0
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 892  :   WIN32_FIND_DATA file_data;
; 893  :   HANDLE handle;
; 894  :   int count, pos;
; 895  :   struct dirent **names;
; 896  :   char *pattern;
; 897  :   size_t    m;
; 898  : 
; 899  :   /* 3 for "*.*", 1 for "\", 1 for zero termination */
; 900  :   m = strlen(dir) +3 +1 +1;

  0002e	48 8b 8c 24 d0
	02 00 00	 mov	 rcx, QWORD PTR dir$[rsp]
  00036	e8 00 00 00 00	 call	 strlen
  0003b	48 83 c0 05	 add	 rax, 5
  0003f	48 89 44 24 50	 mov	 QWORD PTR m$[rsp], rax

; 901  : 
; 902  :   pattern = (char*)malloc(m);

  00044	48 8b 4c 24 50	 mov	 rcx, QWORD PTR m$[rsp]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0004f	48 89 44 24 28	 mov	 QWORD PTR pattern$[rsp], rax

; 903  :   strlcpy(pattern, dir,m);

  00054	4c 8b 44 24 50	 mov	 r8, QWORD PTR m$[rsp]
  00059	48 8b 94 24 d0
	02 00 00	 mov	 rdx, QWORD PTR dir$[rsp]
  00061	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  00066	e8 00 00 00 00	 call	 strlcpy

; 904  :   if ( pattern[strlen(pattern) - 1] != PATHSEPC)

  0006b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  00070	e8 00 00 00 00	 call	 strlen
  00075	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  0007a	0f be 44 01 ff	 movsx	 eax, BYTE PTR [rcx+rax-1]
  0007f	83 f8 2f	 cmp	 eax, 47			; 0000002fH
  00082	74 16		 je	 SHORT $LN6@scandir

; 905  :     strlcat(pattern, PATHSEPS, m);

  00084	4c 8b 44 24 50	 mov	 r8, QWORD PTR m$[rsp]
  00089	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159515
  00090	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  00095	e8 00 00 00 00	 call	 strlcat
$LN6@scandir:

; 906  :   strlcat(pattern, "*.*",m);

  0009a	4c 8b 44 24 50	 mov	 r8, QWORD PTR m$[rsp]
  0009f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159516
  000a6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  000ab	e8 00 00 00 00	 call	 strlcat

; 907  : 
; 908  :   /* 1st pass thru is just to count them */
; 909  :   handle = FindFirstFile(pattern, &file_data);

  000b0	48 8d 54 24 60	 lea	 rdx, QWORD PTR file_data$[rsp]
  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  000ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileA
  000c0	48 89 44 24 38	 mov	 QWORD PTR handle$[rsp], rax

; 910  :   if (handle == INVALID_HANDLE_VALUE)

  000c5	48 83 7c 24 38
	ff		 cmp	 QWORD PTR handle$[rsp], -1
  000cb	75 15		 jne	 SHORT $LN7@scandir

; 911  :     {
; 912  :       free(pattern);

  000cd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 913  :       return -1;

  000d8	b8 ff ff ff ff	 mov	 eax, -1
  000dd	e9 aa 01 00 00	 jmp	 $LN1@scandir
$LN7@scandir:

; 914  :     }
; 915  : 
; 916  :   count = 0;

  000e2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR count$[rsp], 0
$LN2@scandir:

; 917  :   while (1)

  000ea	33 c0		 xor	 eax, eax
  000ec	83 f8 01	 cmp	 eax, 1
  000ef	74 22		 je	 SHORT $LN3@scandir

; 918  :     {
; 919  :       count++;

  000f1	8b 44 24 30	 mov	 eax, DWORD PTR count$[rsp]
  000f5	ff c0		 inc	 eax
  000f7	89 44 24 30	 mov	 DWORD PTR count$[rsp], eax

; 920  :       if (!FindNextFile(handle, &file_data))

  000fb	48 8d 54 24 60	 lea	 rdx, QWORD PTR file_data$[rsp]
  00100	48 8b 4c 24 38	 mov	 rcx, QWORD PTR handle$[rsp]
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindNextFileA
  0010b	85 c0		 test	 eax, eax
  0010d	75 02		 jne	 SHORT $LN8@scandir

; 921  :         break;

  0010f	eb 02		 jmp	 SHORT $LN3@scandir
$LN8@scandir:

; 922  :     }

  00111	eb d7		 jmp	 SHORT $LN2@scandir
$LN3@scandir:

; 923  :   FindClose(handle);

  00113	48 8b 4c 24 38	 mov	 rcx, QWORD PTR handle$[rsp]
  00118	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindClose

; 924  : 
; 925  :   /* Now we know how many, we can alloc & make 2nd pass to copy them */
; 926  :   names = (struct dirent**)malloc(sizeof(struct dirent*) * count);

  0011e	48 63 44 24 30	 movsxd	 rax, DWORD PTR count$[rsp]
  00123	48 c1 e0 03	 shl	 rax, 3
  00127	48 8b c8	 mov	 rcx, rax
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00130	48 89 44 24 48	 mov	 QWORD PTR names$[rsp], rax

; 927  :   memset(names, 0, sizeof(*names));

  00135	48 8b 7c 24 48	 mov	 rdi, QWORD PTR names$[rsp]
  0013a	33 c0		 xor	 eax, eax
  0013c	b9 08 00 00 00	 mov	 ecx, 8
  00141	f3 aa		 rep stosb

; 928  :   handle = FindFirstFile(pattern, &file_data);

  00143	48 8d 54 24 60	 lea	 rdx, QWORD PTR file_data$[rsp]
  00148	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  0014d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindFirstFileA
  00153	48 89 44 24 38	 mov	 QWORD PTR handle$[rsp], rax

; 929  :   if (handle == INVALID_HANDLE_VALUE)

  00158	48 83 7c 24 38
	ff		 cmp	 QWORD PTR handle$[rsp], -1
  0015e	75 20		 jne	 SHORT $LN9@scandir

; 930  :     {
; 931  :       free(pattern);

  00160	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  00165	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 932  :       free(names);

  0016b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR names$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 933  :       return -1;

  00176	b8 ff ff ff ff	 mov	 eax, -1
  0017b	e9 0c 01 00 00	 jmp	 $LN1@scandir
$LN9@scandir:

; 934  :     }
; 935  : 
; 936  :   /* Now let caller filter them if requested */
; 937  :   pos = 0;

  00180	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR pos$[rsp], 0
$LN4@scandir:

; 938  :   while (1)

  00188	33 c0		 xor	 eax, eax
  0018a	83 f8 01	 cmp	 eax, 1
  0018d	0f 84 ae 00 00
	00		 je	 $LN5@scandir

; 939  :     {
; 940  :       int rtn;
; 941  :       struct dirent current;
; 942  : 
; 943  :       STRLCPY( current.d_name, file_data.cFileName );

  00193	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00199	48 8d 94 24 8c
	00 00 00	 lea	 rdx, QWORD PTR file_data$[rsp+44]
  001a1	48 8d 8c 24 a4
	01 00 00	 lea	 rcx, QWORD PTR current$3[rsp+4]
  001a9	e8 00 00 00 00	 call	 strlcpy

; 944  : 
; 945  :       if (!filter || filter(&current))

  001ae	48 83 bc 24 e0
	02 00 00 00	 cmp	 QWORD PTR filter$[rsp], 0
  001b7	74 13		 je	 SHORT $LN11@scandir
  001b9	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR current$3[rsp]
  001c1	ff 94 24 e0 02
	00 00		 call	 QWORD PTR filter$[rsp]
  001c8	85 c0		 test	 eax, eax
  001ca	74 4c		 je	 SHORT $LN10@scandir
$LN11@scandir:

; 946  :         {
; 947  :           struct dirent *copyentry = (struct dirent *)malloc(sizeof(struct dirent));

  001cc	b9 0c 01 00 00	 mov	 ecx, 268		; 0000010cH
  001d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  001d7	48 89 44 24 58	 mov	 QWORD PTR copyentry$2[rsp], rax

; 948  :           STRLCPY( copyentry->d_name, current.d_name );

  001dc	48 8b 44 24 58	 mov	 rax, QWORD PTR copyentry$2[rsp]
  001e1	48 83 c0 04	 add	 rax, 4
  001e5	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  001eb	48 8d 94 24 a4
	01 00 00	 lea	 rdx, QWORD PTR current$3[rsp+4]
  001f3	48 8b c8	 mov	 rcx, rax
  001f6	e8 00 00 00 00	 call	 strlcpy

; 949  :           names[pos] = copyentry;

  001fb	48 63 44 24 20	 movsxd	 rax, DWORD PTR pos$[rsp]
  00200	48 8b 4c 24 48	 mov	 rcx, QWORD PTR names$[rsp]
  00205	48 8b 54 24 58	 mov	 rdx, QWORD PTR copyentry$2[rsp]
  0020a	48 89 14 c1	 mov	 QWORD PTR [rcx+rax*8], rdx

; 950  :           pos++;

  0020e	8b 44 24 20	 mov	 eax, DWORD PTR pos$[rsp]
  00212	ff c0		 inc	 eax
  00214	89 44 24 20	 mov	 DWORD PTR pos$[rsp], eax
$LN10@scandir:

; 951  :         }
; 952  : 
; 953  :       rtn = FindNextFile(handle, &file_data);

  00218	48 8d 54 24 60	 lea	 rdx, QWORD PTR file_data$[rsp]
  0021d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR handle$[rsp]
  00222	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FindNextFileA
  00228	89 44 24 40	 mov	 DWORD PTR rtn$1[rsp], eax

; 954  :       if (!rtn || rtn==ERROR_NO_MORE_FILES)

  0022c	83 7c 24 40 00	 cmp	 DWORD PTR rtn$1[rsp], 0
  00231	74 07		 je	 SHORT $LN13@scandir
  00233	83 7c 24 40 12	 cmp	 DWORD PTR rtn$1[rsp], 18
  00238	75 02		 jne	 SHORT $LN12@scandir
$LN13@scandir:

; 955  :         break;

  0023a	eb 05		 jmp	 SHORT $LN5@scandir
$LN12@scandir:

; 956  :     }

  0023c	e9 47 ff ff ff	 jmp	 $LN4@scandir
$LN5@scandir:

; 957  : 
; 958  :   free(pattern);

  00241	48 8b 4c 24 28	 mov	 rcx, QWORD PTR pattern$[rsp]
  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 959  :   /* Now sort them */
; 960  :   if (compar)

  0024c	48 83 bc 24 e8
	02 00 00 00	 cmp	 QWORD PTR compar$[rsp], 0
  00255	74 21		 je	 SHORT $LN14@scandir

; 961  :     // (fishfix: fix benign "passing incompatible pointer type" compiler warning..)
; 962  :     qsort(names, pos, sizeof(names[0]), (PFN_QSORT_COMPARE_FUNC)compar);

  00257	48 63 44 24 20	 movsxd	 rax, DWORD PTR pos$[rsp]
  0025c	4c 8b 8c 24 e8
	02 00 00	 mov	 r9, QWORD PTR compar$[rsp]
  00264	41 b8 08 00 00
	00		 mov	 r8d, 8
  0026a	48 8b d0	 mov	 rdx, rax
  0026d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR names$[rsp]
  00272	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_qsort
$LN14@scandir:

; 963  :   *namelist = names;

  00278	48 8b 84 24 d8
	02 00 00	 mov	 rax, QWORD PTR namelist$[rsp]
  00280	48 8b 4c 24 48	 mov	 rcx, QWORD PTR names$[rsp]
  00285	48 89 08	 mov	 QWORD PTR [rax], rcx

; 964  :   return pos;

  00288	8b 44 24 20	 mov	 eax, DWORD PTR pos$[rsp]
$LN1@scandir:

; 965  : }

  0028c	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00294	48 33 cc	 xor	 rcx, rsp
  00297	e8 00 00 00 00	 call	 __security_check_cookie
  0029c	48 81 c4 c0 02
	00 00		 add	 rsp, 704		; 000002c0H
  002a3	5f		 pop	 rdi
  002a4	c3		 ret	 0
scandir	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
sched_yield PROC

; 232  : {

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 233  :     if (!SwitchToThread())

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SwitchToThread
  0000a	85 c0		 test	 eax, eax
  0000c	75 08		 jne	 SHORT $LN2@sched_yiel

; 234  :         Sleep(0);

  0000e	33 c9		 xor	 ecx, ecx
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
$LN2@sched_yiel:

; 235  :     return 0;

  00016	33 c0		 xor	 eax, eax

; 236  : }

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
sched_yield ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
seconds$ = 48
sleep	PROC

; 844  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 845  :     Sleep( seconds * 1000 );

  00008	69 44 24 30 e8
	03 00 00	 imul	 eax, DWORD PTR seconds$[rsp], 1000 ; 000003e8H
  00010	8b c8		 mov	 ecx, eax
  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 846  :     return 0;

  00018	33 c0		 xor	 eax, eax

; 847  : }

  0001a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001e	c3		 ret	 0
sleep	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv68 = 32
rqtp$ = 40
__$ArrayPad$ = 56
useconds$ = 80
usleep	PROC

; 802  : {

$LN8:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000f	48 33 c4	 xor	 rax, rsp
  00012	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 803  :     //  "The useconds argument shall be less than one million. If the value of
; 804  :     //   useconds is 0, then the call has no effect."
; 805  : 
; 806  :     //  "Implementations may place limitations on the granularity of timer values.
; 807  :     //   For each interval timer, if the requested timer value requires a finer
; 808  :     //   granularity than the implementation supports, the actual timer value shall
; 809  :     //   be rounded up to the next supported value."
; 810  : 
; 811  :     //  "Upon successful completion, usleep() shall return 0; otherwise, it shall
; 812  :     //   return -1 and set errno to indicate the error."
; 813  : 
; 814  :     //  "The usleep() function may fail if:
; 815  :     //
; 816  :     //     [EINVAL]     The time interval specified
; 817  :     //                  one million or more microseconds"
; 818  : 
; 819  :     struct timespec rqtp;
; 820  : 
; 821  :     if (unlikely( useconds >= MILLION ))

  00017	81 7c 24 50 40
	42 0f 00	 cmp	 DWORD PTR useconds$[rsp], 1000000 ; 000f4240H
  0001f	72 0a		 jb	 SHORT $LN6@usleep
  00021	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  00029	eb 08		 jmp	 SHORT $LN7@usleep
$LN6@usleep:
  0002b	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN7@usleep:
  00033	83 7c 24 20 00	 cmp	 DWORD PTR tv68[rsp], 0
  00038	74 13		 je	 SHORT $LN2@usleep

; 822  :     {
; 823  :         errno = EINVAL;

  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00040	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 824  :         return -1;

  00046	b8 ff ff ff ff	 mov	 eax, -1
  0004b	eb 1f		 jmp	 SHORT $LN1@usleep
$LN2@usleep:

; 825  :     }
; 826  : 
; 827  :     rqtp.tv_sec  = 0;

  0004d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR rqtp$[rsp], 0

; 828  :     rqtp.tv_nsec = useconds * 1000;

  00056	69 44 24 50 e8
	03 00 00	 imul	 eax, DWORD PTR useconds$[rsp], 1000 ; 000003e8H
  0005e	89 44 24 30	 mov	 DWORD PTR rqtp$[rsp+8], eax

; 829  : 
; 830  :     return w32_nanosleep ( &rqtp );

  00062	48 8d 4c 24 28	 lea	 rcx, QWORD PTR rqtp$[rsp]
  00067	e8 00 00 00 00	 call	 w32_nanosleep
$LN1@usleep:

; 831  : }

  0006c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00071	48 33 cc	 xor	 rcx, rsp
  00074	e8 00 00 00 00	 call	 __security_check_cookie
  00079	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0007d	c3		 ret	 0
usleep	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv68 = 32
rqtp$ = 64
rmtp$ = 72
nanosleep PROC

; 784  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 785  :     if (unlikely( rmtp ))

  0000e	48 83 7c 24 48
	00		 cmp	 QWORD PTR rmtp$[rsp], 0
  00014	74 0a		 je	 SHORT $LN6@nanosleep
  00016	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv68[rsp], 1
  0001e	eb 08		 jmp	 SHORT $LN7@nanosleep
$LN6@nanosleep:
  00020	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv68[rsp], 0
$LN7@nanosleep:
  00028	83 7c 24 20 00	 cmp	 DWORD PTR tv68[rsp], 0
  0002d	74 18		 je	 SHORT $LN2@nanosleep

; 786  :     {
; 787  :         rmtp->tv_sec  = 0;

  0002f	48 8b 44 24 48	 mov	 rax, QWORD PTR rmtp$[rsp]
  00034	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 788  :         rmtp->tv_nsec = 0;

  0003b	48 8b 44 24 48	 mov	 rax, QWORD PTR rmtp$[rsp]
  00040	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN2@nanosleep:

; 789  :     }
; 790  : 
; 791  :     return w32_nanosleep ( rqtp );

  00047	48 8b 4c 24 40	 mov	 rcx, QWORD PTR rqtp$[rsp]
  0004c	e8 00 00 00 00	 call	 w32_nanosleep

; 792  : }

  00051	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00055	c3		 ret	 0
nanosleep ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
tv85 = 32
tv90 = 36
tv153 = 40
ts$ = 48
__$ArrayPad$ = 64
pTV$ = 96
pTZ$ = 104
gettimeofday PROC

; 518  : {

$LN36:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 519  :     static struct timeval tvPrevRetVal = {0};
; 520  :     struct timespec ts = {0};

  0001e	48 8d 44 24 30	 lea	 rax, QWORD PTR ts$[rsp]
  00023	48 8b f8	 mov	 rdi, rax
  00026	33 c0		 xor	 eax, eax
  00028	b9 10 00 00 00	 mov	 ecx, 16
  0002d	f3 aa		 rep stosb
$LN4@gettimeofd:

; 521  : 
; 522  :     // Validate parameters...
; 523  : 
; 524  :     UNREFERENCED( pTZ );

  0002f	33 c0		 xor	 eax, eax
  00031	85 c0		 test	 eax, eax
  00033	75 fa		 jne	 SHORT $LN4@gettimeofd
$LN7@gettimeofd:

; 525  :     ASSERT( pTV );

  00035	48 83 7c 24 60
	00		 cmp	 QWORD PTR pTV$[rsp], 0
  0003b	75 5b		 jne	 SHORT $LN17@gettimeofd
$LN10@gettimeofd:
  0003d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159304
  00044	41 b8 0d 02 00
	00		 mov	 r8d, 525		; 0000020dH
  0004a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159305
  00051	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159306
  00058	e8 00 00 00 00	 call	 logmsg
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00063	85 c0		 test	 eax, eax
  00065	74 20		 je	 SHORT $LN18@gettimeofd
  00067	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159308
  0006e	41 b8 0d 02 00
	00		 mov	 r8d, 525		; 0000020dH
  00074	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159309
  0007b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159310
  00082	e8 00 00 00 00	 call	 DebuggerTrace
$LN18@gettimeofd:
  00087	33 c0		 xor	 eax, eax
  00089	85 c0		 test	 eax, eax
  0008b	75 b0		 jne	 SHORT $LN10@gettimeofd
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00093	85 c0		 test	 eax, eax
  00095	74 01		 je	 SHORT $LN19@gettimeofd
  00097	cc		 int	 3
$LN19@gettimeofd:
$LN17@gettimeofd:
  00098	33 c0		 xor	 eax, eax
  0009a	85 c0		 test	 eax, eax
  0009c	75 97		 jne	 SHORT $LN7@gettimeofd

; 526  : 
; 527  :     if (unlikely( !pTV ))

  0009e	48 83 7c 24 60
	00		 cmp	 QWORD PTR pTV$[rsp], 0
  000a4	75 0a		 jne	 SHORT $LN26@gettimeofd
  000a6	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv85[rsp], 1
  000ae	eb 08		 jmp	 SHORT $LN27@gettimeofd
$LN26@gettimeofd:
  000b0	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv85[rsp], 0
$LN27@gettimeofd:
  000b8	83 7c 24 20 00	 cmp	 DWORD PTR tv85[rsp], 0
  000bd	74 0a		 je	 SHORT $LN30@gettimeofd
  000bf	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv90[rsp], 1
  000c7	eb 08		 jmp	 SHORT $LN31@gettimeofd
$LN30@gettimeofd:
  000c9	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv90[rsp], 0
$LN31@gettimeofd:
  000d1	83 7c 24 24 00	 cmp	 DWORD PTR tv90[rsp], 0
  000d6	74 16		 je	 SHORT $LN20@gettimeofd

; 528  :     {
; 529  :         errno = EINVAL;

  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000de	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 530  :         return -1;

  000e4	b8 ff ff ff ff	 mov	 eax, -1
  000e9	e9 e3 00 00 00	 jmp	 $LN1@gettimeofd
$LN20@gettimeofd:
$LN13@gettimeofd:

; 531  :     }
; 532  : 
; 533  :     // Get nanosecond resolution TOD...
; 534  : 
; 535  :     VERIFY( clock_gettime( CLOCK_REALTIME, &ts ) == 0 );

  000ee	48 8d 54 24 30	 lea	 rdx, QWORD PTR ts$[rsp]
  000f3	33 c9		 xor	 ecx, ecx
  000f5	e8 00 00 00 00	 call	 clock_gettime
  000fa	85 c0		 test	 eax, eax
  000fc	74 5b		 je	 SHORT $LN21@gettimeofd
$LN16@gettimeofd:
  000fe	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159314
  00105	41 b8 17 02 00
	00		 mov	 r8d, 535		; 00000217H
  0010b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159315
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159316
  00119	e8 00 00 00 00	 call	 logmsg
  0011e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00124	85 c0		 test	 eax, eax
  00126	74 20		 je	 SHORT $LN22@gettimeofd
  00128	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159318
  0012f	41 b8 17 02 00
	00		 mov	 r8d, 535		; 00000217H
  00135	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159319
  0013c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159320
  00143	e8 00 00 00 00	 call	 DebuggerTrace
$LN22@gettimeofd:
  00148	33 c0		 xor	 eax, eax
  0014a	85 c0		 test	 eax, eax
  0014c	75 b0		 jne	 SHORT $LN16@gettimeofd
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00154	85 c0		 test	 eax, eax
  00156	74 01		 je	 SHORT $LN23@gettimeofd
  00158	cc		 int	 3
$LN23@gettimeofd:
$LN21@gettimeofd:
  00159	33 c0		 xor	 eax, eax
  0015b	85 c0		 test	 eax, eax
  0015d	75 8f		 jne	 SHORT $LN13@gettimeofd

; 536  : 
; 537  :     // Convert to microsecond resolution...
; 538  : 
; 539  :     pTV->tv_sec  = (long)  (ts.tv_sec);

  0015f	48 8b 44 24 60	 mov	 rax, QWORD PTR pTV$[rsp]
  00164	8b 4c 24 30	 mov	 ecx, DWORD PTR ts$[rsp]
  00168	89 08		 mov	 DWORD PTR [rax], ecx

; 540  :     pTV->tv_usec = (long) ((ts.tv_nsec + 500) / 1000);

  0016a	8b 44 24 38	 mov	 eax, DWORD PTR ts$[rsp+8]
  0016e	05 f4 01 00 00	 add	 eax, 500		; 000001f4H
  00173	99		 cdq
  00174	b9 e8 03 00 00	 mov	 ecx, 1000		; 000003e8H
  00179	f7 f9		 idiv	 ecx
  0017b	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pTV$[rsp]
  00180	89 41 04	 mov	 DWORD PTR [rcx+4], eax

; 541  : 
; 542  :     if (unlikely( pTV->tv_usec >= MILLION ))

  00183	48 8b 44 24 60	 mov	 rax, QWORD PTR pTV$[rsp]
  00188	81 78 04 40 42
	0f 00		 cmp	 DWORD PTR [rax+4], 1000000 ; 000f4240H
  0018f	7c 0a		 jl	 SHORT $LN34@gettimeofd
  00191	c7 44 24 28 01
	00 00 00	 mov	 DWORD PTR tv153[rsp], 1
  00199	eb 08		 jmp	 SHORT $LN35@gettimeofd
$LN34@gettimeofd:
  0019b	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN35@gettimeofd:
  001a3	83 7c 24 28 00	 cmp	 DWORD PTR tv153[rsp], 0
  001a8	74 25		 je	 SHORT $LN24@gettimeofd

; 543  :     {
; 544  :         pTV->tv_sec  += 1;

  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR pTV$[rsp]
  001af	8b 00		 mov	 eax, DWORD PTR [rax]
  001b1	ff c0		 inc	 eax
  001b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pTV$[rsp]
  001b8	89 01		 mov	 DWORD PTR [rcx], eax

; 545  :         pTV->tv_usec -= MILLION;

  001ba	48 8b 44 24 60	 mov	 rax, QWORD PTR pTV$[rsp]
  001bf	8b 40 04	 mov	 eax, DWORD PTR [rax+4]
  001c2	2d 40 42 0f 00	 sub	 eax, 1000000		; 000f4240H
  001c7	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pTV$[rsp]
  001cc	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN24@gettimeofd:

; 546  :     }
; 547  : 
; 548  :     return 0;

  001cf	33 c0		 xor	 eax, eax
$LN1@gettimeofd:

; 549  : }

  001d1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001d6	48 33 cc	 xor	 rcx, rsp
  001d9	e8 00 00 00 00	 call	 __security_check_cookie
  001de	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001e2	5f		 pop	 rdi
  001e3	c3		 ret	 0
gettimeofday ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
uliWork$ = 64
tv86 = 72
tv169 = 76
tv174 = 80
tv227 = 84
tv237 = 88
tv252 = 92
tv255 = 96
tv260 = 100
tv281 = 104
tv324 = 108
tv348 = 112
result$1 = 116
tv196 = 120
tv205 = 128
ftStartingSystemTime$2 = 136
r_usage$3 = 144
__$ArrayPad$ = 160
clk_id$ = 192
tp$ = 200
clock_gettime PROC

; 297  : {

$LN94:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@clock_gett:

; 298  :     ULARGE_INTEGER          uliWork;                    // (current HPC tick count and work)
; 299  :     static ULARGE_INTEGER   uliHPCTicksPerSec   = {0};  // (HPC ticks per second)
; 300  :     static ULARGE_INTEGER   uliStartingHPCTick;         // (HPC tick count @ start of interval)
; 301  :     static ULARGE_INTEGER   uliMaxElapsedHPCTicks;      // (HPC tick count resync threshold)
; 302  :     static ULARGE_INTEGER   uliStartingNanoTime;        // (time of last resync in nanoseconds)
; 303  :     static struct timespec  tsPrevRetVal        = {0};  // (previously returned timespec value)
; 304  : 
; 305  :     static U64   u64ClockResolution  = MAX_GTOD_RESOLUTION;   // (max emulated TOD clock resolution)
; 306  :     static U64   u64ClockNanoScale;                           // (elapsed nanoseconds scale factor)
; 307  :     static UINT  uiResyncSecs        = DEF_GTOD_RESYNC_SECS;  // (host TOD clock resync interval)
; 308  :     static BOOL  bInSync             = FALSE;                 // (host TOD clock resync flag)
; 309  : 
; 310  :     // Validate parameters...
; 311  : 
; 312  :     ASSERT( tp );

  00022	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR tp$[rsp], 0
  0002b	75 5b		 jne	 SHORT $LN26@clock_gett
$LN7@clock_gett:
  0002d	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159229
  00034	41 b8 38 01 00
	00		 mov	 r8d, 312		; 00000138H
  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159230
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159231
  00048	e8 00 00 00 00	 call	 logmsg
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00053	85 c0		 test	 eax, eax
  00055	74 20		 je	 SHORT $LN27@clock_gett
  00057	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159233
  0005e	41 b8 38 01 00
	00		 mov	 r8d, 312		; 00000138H
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159234
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159235
  00072	e8 00 00 00 00	 call	 DebuggerTrace
$LN27@clock_gett:
  00077	33 c0		 xor	 eax, eax
  00079	85 c0		 test	 eax, eax
  0007b	75 b0		 jne	 SHORT $LN7@clock_gett
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00083	85 c0		 test	 eax, eax
  00085	74 01		 je	 SHORT $LN28@clock_gett
  00087	cc		 int	 3
$LN28@clock_gett:
$LN26@clock_gett:
  00088	33 c0		 xor	 eax, eax
  0008a	85 c0		 test	 eax, eax
  0008c	75 94		 jne	 SHORT $LN4@clock_gett

; 313  : 
; 314  :     if (unlikely( clk_id > CLOCK_MONOTONIC || !tp ))

  0008e	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR clk_id$[rsp], 1
  00096	7f 15		 jg	 SHORT $LN50@clock_gett
  00098	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR tp$[rsp], 0
  000a1	74 0a		 je	 SHORT $LN50@clock_gett
  000a3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv86[rsp], 0
  000ab	eb 08		 jmp	 SHORT $LN53@clock_gett
$LN50@clock_gett:
  000ad	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv86[rsp], 1
$LN53@clock_gett:
  000b5	83 7c 24 48 00	 cmp	 DWORD PTR tv86[rsp], 0
  000ba	74 16		 je	 SHORT $LN29@clock_gett

; 315  :     {
; 316  :         errno = EINVAL;

  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000c2	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22

; 317  :         return -1;

  000c8	b8 ff ff ff ff	 mov	 eax, -1
  000cd	e9 c3 06 00 00	 jmp	 $LN1@clock_gett
$LN29@clock_gett:

; 318  :     }
; 319  : 
; 320  :     // Simulate clock_gettime with a clk_id as set by pthread_getcpuclockid,
; 321  :     // which is simply a minus thread_id, i.e. clk_id = -tid. (PJJ Jan-2018)
; 322  : 
; 323  :     if (clk_id < 0)

  000d2	83 bc 24 c0 00
	00 00 00	 cmp	 DWORD PTR clk_id$[rsp], 0
  000da	0f 8d fb 00 00
	00		 jge	 $LN30@clock_gett

; 324  :     {
; 325  :         struct rusage  r_usage;
; 326  :         int            result;
; 327  : 
; 328  :         result = getrusage( -clk_id, &r_usage );

  000e0	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR clk_id$[rsp]
  000e7	f7 d8		 neg	 eax
  000e9	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR r_usage$3[rsp]
  000f1	8b c8		 mov	 ecx, eax
  000f3	e8 00 00 00 00	 call	 getrusage
  000f8	89 44 24 74	 mov	 DWORD PTR result$1[rsp], eax

; 329  : 
; 330  :         tp->tv_sec   = r_usage.ru_utime.tv_sec;

  000fc	48 63 84 24 90
	00 00 00	 movsxd	 rax, DWORD PTR r_usage$3[rsp]
  00104	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  0010c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 331  :         tp->tv_nsec  = r_usage.ru_utime.tv_usec;

  0010f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00117	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR r_usage$3[rsp+4]
  0011e	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 332  : 
; 333  :         tp->tv_sec  += r_usage.ru_stime.tv_sec;

  00121	48 63 84 24 98
	00 00 00	 movsxd	 rax, DWORD PTR r_usage$3[rsp+8]
  00129	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  00131	48 03 01	 add	 rax, QWORD PTR [rcx]
  00134	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  0013c	48 89 01	 mov	 QWORD PTR [rcx], rax

; 334  :         tp->tv_nsec += r_usage.ru_stime.tv_usec;

  0013f	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00147	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0014a	03 84 24 9c 00
	00 00		 add	 eax, DWORD PTR r_usage$3[rsp+12]
  00151	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  00159	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 335  : 
; 336  :         if (tp->tv_nsec > 1000000)

  0015c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00164	81 78 08 40 42
	0f 00		 cmp	 DWORD PTR [rax+8], 1000000 ; 000f4240H
  0016b	7e 4b		 jle	 SHORT $LN31@clock_gett

; 337  :         {
; 338  :             tp->tv_sec += tp->tv_nsec / 1000000;

  0016d	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00175	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00178	99		 cdq
  00179	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  0017e	f7 f9		 idiv	 ecx
  00180	48 98		 cdqe
  00182	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  0018a	48 03 01	 add	 rax, QWORD PTR [rcx]
  0018d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  00195	48 89 01	 mov	 QWORD PTR [rcx], rax

; 339  :             tp->tv_nsec = tp->tv_nsec % 1000000;

  00198	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  001a0	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001a3	99		 cdq
  001a4	b9 40 42 0f 00	 mov	 ecx, 1000000		; 000f4240H
  001a9	f7 f9		 idiv	 ecx
  001ab	8b c2		 mov	 eax, edx
  001ad	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  001b5	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN31@clock_gett:

; 340  :         }
; 341  : 
; 342  :         tp->tv_nsec *= 1000;

  001b8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  001c0	69 40 08 e8 03
	00 00		 imul	 eax, DWORD PTR [rax+8], 1000 ; 000003e8H
  001c7	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  001cf	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 343  :         return result;

  001d2	8b 44 24 74	 mov	 eax, DWORD PTR result$1[rsp]
  001d6	e9 ba 05 00 00	 jmp	 $LN1@clock_gett
$LN30@clock_gett:
$LN8@clock_gett:

; 344  :     }
; 345  : 
; 346  :     while (1) { // (for easy backward branching)

  001db	33 c0		 xor	 eax, eax
  001dd	83 f8 01	 cmp	 eax, 1
  001e0	0f 84 b1 03 00
	00		 je	 $LN9@clock_gett
$LN12@clock_gett:

; 347  : 
; 348  :     // Query current high-performance counter value...
; 349  : 
; 350  :     VERIFY( QueryPerformanceCounter( (LARGE_INTEGER*)&uliWork ) );

  001e6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR uliWork$[rsp]
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceCounter
  001f1	85 c0		 test	 eax, eax
  001f3	75 5b		 jne	 SHORT $LN32@clock_gett
$LN15@clock_gett:
  001f5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159241
  001fc	41 b8 5e 01 00
	00		 mov	 r8d, 350		; 0000015eH
  00202	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159242
  00209	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159243
  00210	e8 00 00 00 00	 call	 logmsg
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0021b	85 c0		 test	 eax, eax
  0021d	74 20		 je	 SHORT $LN33@clock_gett
  0021f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159245
  00226	41 b8 5e 01 00
	00		 mov	 r8d, 350		; 0000015eH
  0022c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159246
  00233	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159247
  0023a	e8 00 00 00 00	 call	 DebuggerTrace
$LN33@clock_gett:
  0023f	33 c0		 xor	 eax, eax
  00241	85 c0		 test	 eax, eax
  00243	75 b0		 jne	 SHORT $LN15@clock_gett
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0024b	85 c0		 test	 eax, eax
  0024d	74 01		 je	 SHORT $LN34@clock_gett
  0024f	cc		 int	 3
$LN34@clock_gett:
$LN32@clock_gett:
  00250	33 c0		 xor	 eax, eax
  00252	85 c0		 test	 eax, eax
  00254	75 90		 jne	 SHORT $LN12@clock_gett

; 351  : 
; 352  :     // Perform (re-)initialization...
; 353  : 
; 354  :     if (unlikely( !bInSync ))       // (do this once per resync interval)

  00256	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bInSync@?1??clock_gettime@@9@9, 0
  0025d	75 0a		 jne	 SHORT $LN54@clock_gett
  0025f	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv169[rsp], 1
  00267	eb 08		 jmp	 SHORT $LN55@clock_gett
$LN54@clock_gett:
  00269	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN55@clock_gett:
  00271	83 7c 24 4c 00	 cmp	 DWORD PTR tv169[rsp], 0
  00276	74 0a		 je	 SHORT $LN58@clock_gett
  00278	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR tv174[rsp], 1
  00280	eb 08		 jmp	 SHORT $LN59@clock_gett
$LN58@clock_gett:
  00282	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv174[rsp], 0
$LN59@clock_gett:
  0028a	83 7c 24 50 00	 cmp	 DWORD PTR tv174[rsp], 0
  0028f	0f 84 e3 01 00
	00		 je	 $LN35@clock_gett

; 355  :     {
; 356  :         FILETIME  ftStartingSystemTime;
; 357  : 
; 358  :         // The "GetSystemTimeAsFileTime" function obtains the current system date
; 359  :         // and time. The information is in Coordinated Universal Time (UTC) format.
; 360  : 
; 361  :         GetSystemTimeAsFileTime( &ftStartingSystemTime );

  00295	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR ftStartingSystemTime$2[rsp]
  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTimeAsFileTime

; 362  :         uliStartingHPCTick.QuadPart = uliWork.QuadPart;

  002a3	48 8b 44 24 40	 mov	 rax, QWORD PTR uliWork$[rsp]
  002a8	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?uliStartingHPCTick@?1??clock_gettime@@9@9, rax

; 363  : 
; 364  :         // PROGRAMMING NOTE: According to Microsoft Desktop Dev Center (MSDN):
; 365  :         // http://msdn.microsoft.com/en-us/library/windows/desktop/ms644905(v=vs.85).aspx
; 366  :         // "The [HPC] frequency cannot change while the system is running."
; 367  : 
; 368  :         if (!uliHPCTicksPerSec.QuadPart)  // (we only need to do this once)

  002af	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?uliHPCTicksPerSec@?1??clock_gettime@@9@9, 0
  002b7	0f 85 9d 01 00
	00		 jne	 $LN36@clock_gett
$LN18@clock_gett:

; 369  :         {
; 370  :             VERIFY( QueryPerformanceFrequency( (LARGE_INTEGER*)&uliHPCTicksPerSec ));

  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?uliHPCTicksPerSec@?1??clock_gettime@@9@9
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_QueryPerformanceFrequency
  002ca	85 c0		 test	 eax, eax
  002cc	75 5b		 jne	 SHORT $LN37@clock_gett
$LN21@clock_gett:
  002ce	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159252
  002d5	41 b8 72 01 00
	00		 mov	 r8d, 370		; 00000172H
  002db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159253
  002e2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159254
  002e9	e8 00 00 00 00	 call	 logmsg
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002f4	85 c0		 test	 eax, eax
  002f6	74 20		 je	 SHORT $LN38@clock_gett
  002f8	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159256
  002ff	41 b8 72 01 00
	00		 mov	 r8d, 370		; 00000172H
  00305	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159257
  0030c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159258
  00313	e8 00 00 00 00	 call	 DebuggerTrace
$LN38@clock_gett:
  00318	33 c0		 xor	 eax, eax
  0031a	85 c0		 test	 eax, eax
  0031c	75 b0		 jne	 SHORT $LN21@clock_gett
  0031e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00324	85 c0		 test	 eax, eax
  00326	74 01		 je	 SHORT $LN39@clock_gett
  00328	cc		 int	 3
$LN39@clock_gett:
$LN37@clock_gett:
  00329	33 c0		 xor	 eax, eax
  0032b	85 c0		 test	 eax, eax
  0032d	75 8e		 jne	 SHORT $LN18@clock_gett
$LN22@clock_gett:

; 371  : 
; 372  :             // Verify the length of time between host TOD clock resyncs isn't
; 373  :             // so very long that the number of High Performance Counter ticks
; 374  :             // times our resync interval would then overflow 64-bits. If so,
; 375  :             // we need to decrease our interval until we're certain it won't.
; 376  : 
; 377  :             while (uliHPCTicksPerSec.QuadPart > (_UI64_MAX / (uiResyncSecs + 1)))

  0032f	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?uiResyncSecs@?1??clock_gettime@@9@9
  00335	ff c0		 inc	 eax
  00337	8b c0		 mov	 eax, eax
  00339	48 89 44 24 78	 mov	 QWORD PTR tv196[rsp], rax
  0033e	33 d2		 xor	 edx, edx
  00340	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00347	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv196[rsp]
  0034c	48 f7 f1	 div	 rcx
  0034f	48 39 05 00 00
	00 00		 cmp	 QWORD PTR ?uliHPCTicksPerSec@?1??clock_gettime@@9@9, rax
  00356	76 10		 jbe	 SHORT $LN23@clock_gett

; 378  :                 uiResyncSecs--;

  00358	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?uiResyncSecs@?1??clock_gettime@@9@9
  0035e	ff c8		 dec	 eax
  00360	89 05 00 00 00
	00		 mov	 DWORD PTR ?uiResyncSecs@?1??clock_gettime@@9@9, eax
  00366	eb c7		 jmp	 SHORT $LN22@clock_gett
$LN23@clock_gett:

; 379  : 
; 380  :             uliMaxElapsedHPCTicks.QuadPart =

  00368	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?uiResyncSecs@?1??clock_gettime@@9@9
  0036e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?uliHPCTicksPerSec@?1??clock_gettime@@9@9
  00375	48 0f af c8	 imul	 rcx, rax
  00379	48 8b c1	 mov	 rax, rcx
  0037c	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?uliMaxElapsedHPCTicks@?1??clock_gettime@@9@9, rax
$LN24@clock_gett:

; 381  :                 uliHPCTicksPerSec.QuadPart * uiResyncSecs;
; 382  : 
; 383  :             // Calculate the maximum supported clock resolution such that we don't
; 384  :             // resync with the host TOD clock more than once every resync interval.
; 385  : 
; 386  :             while (u64ClockResolution >= MIN_GTOD_RESOLUTION &&

  00383	48 81 3d 00 00
	00 00 40 42 0f
	00		 cmp	 QWORD PTR ?u64ClockResolution@?1??clock_gettime@@9@9, 1000000 ; 000f4240H
  0038e	72 57		 jb	 SHORT $LN25@clock_gett
  00390	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?uiResyncSecs@?1??clock_gettime@@9@9
  00396	ff c0		 inc	 eax
  00398	8b c0		 mov	 eax, eax
  0039a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?uliHPCTicksPerSec@?1??clock_gettime@@9@9
  003a1	48 0f af c8	 imul	 rcx, rax
  003a5	48 8b c1	 mov	 rax, rcx
  003a8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv205[rsp], rax
  003b0	33 d2		 xor	 edx, edx
  003b2	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  003b9	48 f7 35 00 00
	00 00		 div	 QWORD PTR ?u64ClockResolution@?1??clock_gettime@@9@9
  003c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv205[rsp]
  003c8	48 3b c8	 cmp	 rcx, rax
  003cb	72 1a		 jb	 SHORT $LN25@clock_gett

; 387  :                 (uliHPCTicksPerSec.QuadPart * (uiResyncSecs + 1)) >= (_UI64_MAX / u64ClockResolution))
; 388  :             {
; 389  :                 u64ClockResolution /= 10;  // (decrease TOD clock resolution)

  003cd	33 d2		 xor	 edx, edx
  003cf	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?u64ClockResolution@?1??clock_gettime@@9@9
  003d6	b9 0a 00 00 00	 mov	 ecx, 10
  003db	48 f7 f1	 div	 rcx
  003de	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?u64ClockResolution@?1??clock_gettime@@9@9, rax

; 390  :             }

  003e5	eb 9c		 jmp	 SHORT $LN24@clock_gett
$LN25@clock_gett:

; 391  : 
; 392  :             // (check for error condition...)
; 393  : 
; 394  :             if (u64ClockResolution < MIN_GTOD_RESOLUTION)

  003e7	48 81 3d 00 00
	00 00 40 42 0f
	00		 cmp	 QWORD PTR ?u64ClockResolution@?1??clock_gettime@@9@9, 1000000 ; 000f4240H
  003f2	73 51		 jae	 SHORT $LN40@clock_gett

; 395  :             {
; 396  :                 // "Cannot provide minimum emulated TOD clock resolution"
; 397  :                 WRMSG( HHC04112, "S" );

  003f4	b9 01 00 00 00	 mov	 ecx, 1
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  003ff	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159261
  00406	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0040b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159262
  00412	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00417	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0041c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00422	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG159263
  00429	ba 8d 01 00 00	 mov	 edx, 397		; 0000018dH
  0042e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159264
  00435	e8 00 00 00 00	 call	 fwritemsg

; 398  :                 exit(1);

  0043a	b9 01 00 00 00	 mov	 ecx, 1
  0043f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
$LN40@clock_gett:

; 399  :             }
; 400  : 
; 401  :             u64ClockNanoScale = (MAX_GTOD_RESOLUTION / u64ClockResolution);

  00445	33 d2		 xor	 edx, edx
  00447	b8 00 ca 9a 3b	 mov	 eax, 1000000000		; 3b9aca00H
  0044c	48 f7 35 00 00
	00 00		 div	 QWORD PTR ?u64ClockResolution@?1??clock_gettime@@9@9
  00453	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?u64ClockNanoScale@?1??clock_gettime@@9@9, rax
$LN36@clock_gett:

; 402  :         }
; 403  : 
; 404  :         uliStartingNanoTime = FileTimeTo1970Nanoseconds( &ftStartingSystemTime );

  0045a	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR ftStartingSystemTime$2[rsp]
  00462	e8 00 00 00 00	 call	 FileTimeTo1970Nanoseconds
  00467	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?uliStartingNanoTime@?1??clock_gettime@@9@9, rax

; 405  :         bInSync = TRUE;

  0046e	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR ?bInSync@?1??clock_gettime@@9@9, 1
$LN35@clock_gett:

; 406  :     }
; 407  : 
; 408  :     // Calculate elapsed HPC ticks...
; 409  : 
; 410  :     if (likely( uliWork.QuadPart >= uliStartingHPCTick.QuadPart ))

  00478	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?uliStartingHPCTick@?1??clock_gettime@@9@9
  0047f	48 39 44 24 40	 cmp	 QWORD PTR uliWork$[rsp], rax
  00484	72 0a		 jb	 SHORT $LN62@clock_gett
  00486	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv227[rsp], 1
  0048e	eb 08		 jmp	 SHORT $LN63@clock_gett
$LN62@clock_gett:
  00490	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv227[rsp], 0
$LN63@clock_gett:
  00498	83 7c 24 54 00	 cmp	 DWORD PTR tv227[rsp], 0
  0049d	74 19		 je	 SHORT $LN41@clock_gett

; 411  :     {
; 412  :         uliWork.QuadPart -= uliStartingHPCTick.QuadPart;

  0049f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?uliStartingHPCTick@?1??clock_gettime@@9@9
  004a6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR uliWork$[rsp]
  004ab	48 2b c8	 sub	 rcx, rax
  004ae	48 8b c1	 mov	 rax, rcx
  004b1	48 89 44 24 40	 mov	 QWORD PTR uliWork$[rsp], rax

; 413  :     }

  004b6	eb 1d		 jmp	 SHORT $LN42@clock_gett
$LN41@clock_gett:

; 414  :     else // (counter wrapped)
; 415  :     {
; 416  :         uliWork.QuadPart += _UI64_MAX - uliStartingHPCTick.QuadPart + 1;

  004b8	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  004bf	48 2b 05 00 00
	00 00		 sub	 rax, QWORD PTR ?uliStartingHPCTick@?1??clock_gettime@@9@9
  004c6	48 8b 4c 24 40	 mov	 rcx, QWORD PTR uliWork$[rsp]
  004cb	48 8d 44 01 01	 lea	 rax, QWORD PTR [rcx+rax+1]
  004d0	48 89 44 24 40	 mov	 QWORD PTR uliWork$[rsp], rax
$LN42@clock_gett:

; 417  :     }
; 418  : 
; 419  :     // Re-sync to system clock every so often to prevent clock drift
; 420  :     // since high-performance timer updated independently from clock.
; 421  : 
; 422  :     if (unlikely( uliWork.QuadPart >= uliMaxElapsedHPCTicks.QuadPart ))

  004d5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?uliMaxElapsedHPCTicks@?1??clock_gettime@@9@9
  004dc	48 39 44 24 40	 cmp	 QWORD PTR uliWork$[rsp], rax
  004e1	72 0a		 jb	 SHORT $LN66@clock_gett
  004e3	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv237[rsp], 1
  004eb	eb 08		 jmp	 SHORT $LN67@clock_gett
$LN66@clock_gett:
  004ed	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv237[rsp], 0
$LN67@clock_gett:
  004f5	83 7c 24 58 00	 cmp	 DWORD PTR tv237[rsp], 0
  004fa	74 0f		 je	 SHORT $LN43@clock_gett

; 423  :     {
; 424  :         bInSync = FALSE;    // (force resync)

  004fc	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?bInSync@?1??clock_gettime@@9@9, 0

; 425  :         continue;           // (start over)

  00506	e9 d0 fc ff ff	 jmp	 $LN8@clock_gett
$LN43@clock_gett:

; 426  :     }
; 427  : 
; 428  :     // Convert elapsed HPC ticks to elapsed nanoseconds...
; 429  : 
; 430  :     uliWork.QuadPart *= u64ClockResolution;

  0050b	48 8b 44 24 40	 mov	 rax, QWORD PTR uliWork$[rsp]
  00510	48 0f af 05 00
	00 00 00	 imul	 rax, QWORD PTR ?u64ClockResolution@?1??clock_gettime@@9@9
  00518	48 89 44 24 40	 mov	 QWORD PTR uliWork$[rsp], rax

; 431  :     uliWork.QuadPart /= uliHPCTicksPerSec.QuadPart;

  0051d	33 d2		 xor	 edx, edx
  0051f	48 8b 44 24 40	 mov	 rax, QWORD PTR uliWork$[rsp]
  00524	48 f7 35 00 00
	00 00		 div	 QWORD PTR ?uliHPCTicksPerSec@?1??clock_gettime@@9@9
  0052b	48 89 44 24 40	 mov	 QWORD PTR uliWork$[rsp], rax

; 432  :     uliWork.QuadPart *= u64ClockNanoScale;

  00530	48 8b 44 24 40	 mov	 rax, QWORD PTR uliWork$[rsp]
  00535	48 0f af 05 00
	00 00 00	 imul	 rax, QWORD PTR ?u64ClockNanoScale@?1??clock_gettime@@9@9
  0053d	48 89 44 24 40	 mov	 QWORD PTR uliWork$[rsp], rax

; 433  : 
; 434  :     // Add starting time to yield current TOD in nanoseconds...
; 435  : 
; 436  :     uliWork.QuadPart += uliStartingNanoTime.QuadPart;

  00542	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?uliStartingNanoTime@?1??clock_gettime@@9@9
  00549	48 8b 4c 24 40	 mov	 rcx, QWORD PTR uliWork$[rsp]
  0054e	48 03 c8	 add	 rcx, rax
  00551	48 8b c1	 mov	 rax, rcx
  00554	48 89 44 24 40	 mov	 QWORD PTR uliWork$[rsp], rax

; 437  : 
; 438  :     // Build results...
; 439  : 
; 440  :     tp->tv_sec   =  (time_t) (uliWork.QuadPart / BILLION);

  00559	33 d2		 xor	 edx, edx
  0055b	48 8b 44 24 40	 mov	 rax, QWORD PTR uliWork$[rsp]
  00560	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  00565	48 f7 f1	 div	 rcx
  00568	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  00570	48 89 01	 mov	 QWORD PTR [rcx], rax

; 441  :     tp->tv_nsec  =  (long)   (uliWork.QuadPart % BILLION);

  00573	33 d2		 xor	 edx, edx
  00575	48 8b 44 24 40	 mov	 rax, QWORD PTR uliWork$[rsp]
  0057a	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  0057f	48 f7 f1	 div	 rcx
  00582	48 8b c2	 mov	 rax, rdx
  00585	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  0058d	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 442  : 
; 443  :     break; } // end while(1)

  00590	eb 05		 jmp	 SHORT $LN9@clock_gett
  00592	e9 44 fc ff ff	 jmp	 $LN8@clock_gett
$LN9@clock_gett:

; 444  : 
; 445  :     // If monotonic request, ensure each call returns a unique, ever-increasing value...
; 446  : 
; 447  :     if (unlikely( clk_id == CLOCK_MONOTONIC ))

  00597	83 bc 24 c0 00
	00 00 01	 cmp	 DWORD PTR clk_id$[rsp], 1
  0059f	75 0a		 jne	 SHORT $LN70@clock_gett
  005a1	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv252[rsp], 1
  005a9	eb 08		 jmp	 SHORT $LN71@clock_gett
$LN70@clock_gett:
  005ab	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv252[rsp], 0
$LN71@clock_gett:
  005b3	83 7c 24 5c 00	 cmp	 DWORD PTR tv252[rsp], 0
  005b8	0f 84 5e 01 00
	00		 je	 $LN44@clock_gett

; 448  :     {
; 449  :         if (unlikely( !tsPrevRetVal.tv_sec ))

  005be	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9, 0
  005c6	75 0a		 jne	 SHORT $LN72@clock_gett
  005c8	c7 44 24 60 01
	00 00 00	 mov	 DWORD PTR tv255[rsp], 1
  005d0	eb 08		 jmp	 SHORT $LN73@clock_gett
$LN72@clock_gett:
  005d2	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv255[rsp], 0
$LN73@clock_gett:
  005da	83 7c 24 60 00	 cmp	 DWORD PTR tv255[rsp], 0
  005df	74 0a		 je	 SHORT $LN76@clock_gett
  005e1	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR tv260[rsp], 1
  005e9	eb 08		 jmp	 SHORT $LN77@clock_gett
$LN76@clock_gett:
  005eb	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv260[rsp], 0
$LN77@clock_gett:
  005f3	83 7c 24 64 00	 cmp	 DWORD PTR tv260[rsp], 0
  005f8	74 23		 je	 SHORT $LN45@clock_gett

; 450  :         {
; 451  :             tsPrevRetVal.tv_sec  = tp->tv_sec;

  005fa	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00602	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00605	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9, rax

; 452  :             tsPrevRetVal.tv_nsec = tp->tv_nsec;

  0060c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00614	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00617	89 05 08 00 00
	00		 mov	 DWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9+8, eax
$LN45@clock_gett:

; 453  :         }
; 454  : 
; 455  :         if (unlikely

  0061d	33 c0		 xor	 eax, eax
  0061f	85 c0		 test	 eax, eax
  00621	75 4c		 jne	 SHORT $LN78@clock_gett
  00623	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  0062b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9
  00632	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00635	7c 38		 jl	 SHORT $LN78@clock_gett
  00637	33 c0		 xor	 eax, eax
  00639	83 f8 01	 cmp	 eax, 1
  0063c	74 27		 je	 SHORT $LN79@clock_gett
  0063e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00646	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9
  0064d	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00650	75 13		 jne	 SHORT $LN79@clock_gett
  00652	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  0065a	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9+8
  00660	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00663	7e 0a		 jle	 SHORT $LN78@clock_gett
$LN79@clock_gett:
  00665	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv281[rsp], 0
  0066d	eb 08		 jmp	 SHORT $LN83@clock_gett
$LN78@clock_gett:
  0066f	c7 44 24 68 01
	00 00 00	 mov	 DWORD PTR tv281[rsp], 1
$LN83@clock_gett:
  00677	83 7c 24 68 00	 cmp	 DWORD PTR tv281[rsp], 0
  0067c	0f 84 9a 00 00
	00		 je	 $LN46@clock_gett

; 456  :         (0
; 457  :             ||      tp->tv_sec  <  tsPrevRetVal.tv_sec
; 458  :             || (1
; 459  :                 &&  tp->tv_sec  == tsPrevRetVal.tv_sec
; 460  :                 &&  tp->tv_nsec <= tsPrevRetVal.tv_nsec
; 461  :                )
; 462  :         ))
; 463  :         {
; 464  :             tp->tv_sec  = tsPrevRetVal.tv_sec;

  00682	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  0068a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9
  00691	48 89 08	 mov	 QWORD PTR [rax], rcx

; 465  :             tp->tv_nsec = tsPrevRetVal.tv_nsec + 1;

  00694	8b 05 08 00 00
	00		 mov	 eax, DWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9+8
  0069a	ff c0		 inc	 eax
  0069c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  006a4	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 466  : 
; 467  :             if (unlikely(tp->tv_nsec >= BILLION))

  006a7	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  006af	81 78 08 00 ca
	9a 3b		 cmp	 DWORD PTR [rax+8], 1000000000 ; 3b9aca00H
  006b6	7c 0a		 jl	 SHORT $LN86@clock_gett
  006b8	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv324[rsp], 1
  006c0	eb 08		 jmp	 SHORT $LN87@clock_gett
$LN86@clock_gett:
  006c2	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv324[rsp], 0
$LN87@clock_gett:
  006ca	83 7c 24 6c 00	 cmp	 DWORD PTR tv324[rsp], 0
  006cf	74 4b		 je	 SHORT $LN47@clock_gett

; 468  :             {
; 469  :                 tp->tv_sec  += tp->tv_nsec / BILLION;

  006d1	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  006d9	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  006dc	99		 cdq
  006dd	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  006e2	f7 f9		 idiv	 ecx
  006e4	48 98		 cdqe
  006e6	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  006ee	48 03 01	 add	 rax, QWORD PTR [rcx]
  006f1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  006f9	48 89 01	 mov	 QWORD PTR [rcx], rax

; 470  :                 tp->tv_nsec  = tp->tv_nsec % BILLION;

  006fc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00704	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00707	99		 cdq
  00708	b9 00 ca 9a 3b	 mov	 ecx, 1000000000		; 3b9aca00H
  0070d	f7 f9		 idiv	 ecx
  0070f	8b c2		 mov	 eax, edx
  00711	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tp$[rsp]
  00719	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN47@clock_gett:
$LN46@clock_gett:
$LN44@clock_gett:

; 471  :             }
; 472  :         }
; 473  :     }
; 474  : 
; 475  : 
; 476  :     // Save previously returned high clock value for next MONOTONIC clock time...
; 477  : 
; 478  :     if (likely( tp->tv_sec > tsPrevRetVal.tv_sec ||

  0071c	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00724	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9
  0072b	48 39 08	 cmp	 QWORD PTR [rax], rcx
  0072e	7f 31		 jg	 SHORT $LN89@clock_gett
  00730	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00738	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9
  0073f	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00742	75 13		 jne	 SHORT $LN88@clock_gett
  00744	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  0074c	8b 0d 08 00 00
	00		 mov	 ecx, DWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9+8
  00752	39 48 08	 cmp	 DWORD PTR [rax+8], ecx
  00755	7f 0a		 jg	 SHORT $LN89@clock_gett
$LN88@clock_gett:
  00757	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv348[rsp], 0
  0075f	eb 08		 jmp	 SHORT $LN93@clock_gett
$LN89@clock_gett:
  00761	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv348[rsp], 1
$LN93@clock_gett:
  00769	83 7c 24 70 00	 cmp	 DWORD PTR tv348[rsp], 0
  0076e	74 23		 je	 SHORT $LN48@clock_gett

; 479  :         (tp->tv_sec == tsPrevRetVal.tv_sec &&
; 480  :          tp->tv_nsec > tsPrevRetVal.tv_nsec)))
; 481  :     {
; 482  :         tsPrevRetVal.tv_sec  = tp->tv_sec;

  00770	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  00778	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0077b	48 89 05 00 00
	00 00		 mov	 QWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9, rax

; 483  :         tsPrevRetVal.tv_nsec = tp->tv_nsec;

  00782	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR tp$[rsp]
  0078a	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0078d	89 05 08 00 00
	00		 mov	 DWORD PTR ?tsPrevRetVal@?1??clock_gettime@@9@9+8, eax
$LN48@clock_gett:

; 484  :     }
; 485  : 
; 486  : 
; 487  :     // Done!
; 488  : 
; 489  :     return 0;       // (always, unless user error)

  00793	33 c0		 xor	 eax, eax
$LN1@clock_gett:
$LN49@clock_gett:

; 490  : }

  00795	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0079d	48 33 cc	 xor	 rcx, rsp
  007a0	e8 00 00 00 00	 call	 __security_check_cookie
  007a5	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  007ac	c3		 ret	 0
clock_gettime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
s$ = 48
sep$ = 56
lasts$ = 64
strtok_r PROC

; 247  : {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 248  :     return strtok_s( s, sep, lasts );

  00013	4c 8b 44 24 40	 mov	 r8, QWORD PTR lasts$[rsp]
  00018	48 8b 54 24 38	 mov	 rdx, QWORD PTR sep$[rsp]
  0001d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strtok_s

; 249  : }

  00028	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002c	c3		 ret	 0
strtok_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
fork	PROC

; 220  : {

$LN3:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 221  :     errno = ENOTSUP;

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	c7 00 81 00 00
	00		 mov	 DWORD PTR [rax], 129	; 00000081H

; 222  :     return -1;          // *** NOT SUPPORTED ***

  00010	b8 ff ff ff ff	 mov	 eax, -1

; 223  : }

  00015	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00019	c3		 ret	 0
fork	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
len$ = 32
temp_listen_socket$ = 40
talen$ = 48
tv165 = 52
tv80 = 56
nLastError$1 = 60
nLastError$2 = 64
tv144 = 72
tv83 = 80
tv88 = 88
localhost_addr$ = 96
tempaddr$ = 112
__$ArrayPad$ = 128
domain$ = 160
type$ = 168
protocol$ = 176
socket_vector$ = 184
socketpair PROC

; 3142 : {

$LN11:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00012	57		 push	 rdi
  00013	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00021	48 33 c4	 xor	 rax, rsp
  00024	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 3143 :     // PROGRAMMING NOTE: we do NOT support type AF_UNIX socketpairs on Win32.
; 3144 :     //                   we *ONLY* support AF_INET, IPPROTO_IP, SOCK_STREAM.
; 3145 : 
; 3146 :     SOCKET temp_listen_socket;
; 3147 :     struct sockaddr_in  localhost_addr;
; 3148 :     int    len = sizeof(localhost_addr);

  0002c	c7 44 24 20 10
	00 00 00	 mov	 DWORD PTR len$[rsp], 16

; 3149 : 
; 3150 :     /* FIXME ISW ? In some situations, it seems the sockaddr_in structure */
; 3151 :     /*         returned by getsockname() isn't appropriate for use        */
; 3152 :     /*         by connect(). We therefore use another sockaddr_in for the */
; 3153 :     /*         sole purpose of fetching the automatic port number issued  */
; 3154 :     /*         during the bind() operation.                               */
; 3155 :     /* NOTE : This is a workaround. The actual root cause for this        */
; 3156 :     /*        problem is presently unknown because it is hard to reproduce*/
; 3157 : 
; 3158 :     struct sockaddr_in tempaddr;
; 3159 :     int talen = sizeof(tempaddr);

  00034	c7 44 24 30 10
	00 00 00	 mov	 DWORD PTR talen$[rsp], 16

; 3160 : 
; 3161 :     // Technique: create a pair of sockets bound to each other by first creating a
; 3162 :     // temporary listening socket bound to the localhost loopback address (127.0.0.1)
; 3163 :     // and then having the other socket connect to it...
; 3164 : 
; 3165 :     //  "Upon successful completion, 0 shall be returned; otherwise,
; 3166 :     //   -1 shall be returned and errno set to indicate the error."
; 3167 : 
; 3168 :     if ( AF_INET     != domain   ) { errno = WSAEAFNOSUPPORT;    return -1; }

  0003c	83 bc 24 a0 00
	00 00 02	 cmp	 DWORD PTR domain$[rsp], 2
  00044	74 16		 je	 SHORT $LN2@socketpair
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004c	c7 00 3f 27 00
	00		 mov	 DWORD PTR [rax], 10047	; 0000273fH
  00052	b8 ff ff ff ff	 mov	 eax, -1
  00057	e9 a7 02 00 00	 jmp	 $LN1@socketpair
$LN2@socketpair:

; 3169 :     if ( SOCK_STREAM != type     ) { errno = WSAEPROTONOSUPPORT; return -1; }

  0005c	83 bc 24 a8 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00064	74 16		 je	 SHORT $LN3@socketpair
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006c	c7 00 3b 27 00
	00		 mov	 DWORD PTR [rax], 10043	; 0000273bH
  00072	b8 ff ff ff ff	 mov	 eax, -1
  00077	e9 87 02 00 00	 jmp	 $LN1@socketpair
$LN3@socketpair:

; 3170 :     if ( IPPROTO_IP  != protocol ) { errno = WSAEPROTOTYPE;      return -1; }

  0007c	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR protocol$[rsp], 0
  00084	74 16		 je	 SHORT $LN4@socketpair
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008c	c7 00 39 27 00
	00		 mov	 DWORD PTR [rax], 10041	; 00002739H
  00092	b8 ff ff ff ff	 mov	 eax, -1
  00097	e9 67 02 00 00	 jmp	 $LN1@socketpair
$LN4@socketpair:

; 3171 : 
; 3172 :     socket_vector[0] = socket_vector[1] = INVALID_SOCKET;

  0009c	b8 04 00 00 00	 mov	 eax, 4
  000a1	48 6b c0 01	 imul	 rax, rax, 1
  000a5	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR socket_vector$[rsp]
  000ad	c7 04 01 ff ff
	ff ff		 mov	 DWORD PTR [rcx+rax], -1
  000b4	b8 04 00 00 00	 mov	 eax, 4
  000b9	48 6b c0 00	 imul	 rax, rax, 0
  000bd	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR socket_vector$[rsp]
  000c5	c7 04 01 ff ff
	ff ff		 mov	 DWORD PTR [rcx+rax], -1

; 3173 : 
; 3174 :     if ( INVALID_SOCKET == (temp_listen_socket = socket( AF_INET, SOCK_STREAM, 0 )) )

  000cc	45 33 c0	 xor	 r8d, r8d
  000cf	ba 01 00 00 00	 mov	 edx, 1
  000d4	b9 02 00 00 00	 mov	 ecx, 2
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  000df	48 89 44 24 28	 mov	 QWORD PTR temp_listen_socket$[rsp], rax
  000e4	48 83 7c 24 28
	ff		 cmp	 QWORD PTR temp_listen_socket$[rsp], -1
  000ea	75 20		 jne	 SHORT $LN5@socketpair

; 3175 :     {
; 3176 :         errno = (int)WSAGetLastError();

  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  000f2	89 44 24 38	 mov	 DWORD PTR tv80[rsp], eax
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000fc	8b 4c 24 38	 mov	 ecx, DWORD PTR tv80[rsp]
  00100	89 08		 mov	 DWORD PTR [rax], ecx

; 3177 :         return -1;

  00102	b8 ff ff ff ff	 mov	 eax, -1
  00107	e9 f7 01 00 00	 jmp	 $LN1@socketpair
$LN5@socketpair:

; 3178 :     }
; 3179 : 
; 3180 :     memset( &localhost_addr, 0, len   );

  0010c	48 63 44 24 20	 movsxd	 rax, DWORD PTR len$[rsp]
  00111	48 89 44 24 50	 mov	 QWORD PTR tv83[rsp], rax
  00116	48 8d 4c 24 60	 lea	 rcx, QWORD PTR localhost_addr$[rsp]
  0011b	48 8b f9	 mov	 rdi, rcx
  0011e	33 c0		 xor	 eax, eax
  00120	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv83[rsp]
  00125	f3 aa		 rep stosb

; 3181 :     memset( &tempaddr,       0, talen );

  00127	48 63 44 24 30	 movsxd	 rax, DWORD PTR talen$[rsp]
  0012c	48 89 44 24 58	 mov	 QWORD PTR tv88[rsp], rax
  00131	48 8d 4c 24 70	 lea	 rcx, QWORD PTR tempaddr$[rsp]
  00136	48 8b f9	 mov	 rdi, rcx
  00139	33 c0		 xor	 eax, eax
  0013b	48 8b 4c 24 58	 mov	 rcx, QWORD PTR tv88[rsp]
  00140	f3 aa		 rep stosb

; 3182 : 
; 3183 :     localhost_addr.sin_family       = AF_INET;

  00142	b8 02 00 00 00	 mov	 eax, 2
  00147	66 89 44 24 60	 mov	 WORD PTR localhost_addr$[rsp], ax

; 3184 :     localhost_addr.sin_port         = htons( 0 );

  0014c	33 c9		 xor	 ecx, ecx
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htons
  00154	66 89 44 24 62	 mov	 WORD PTR localhost_addr$[rsp+2], ax

; 3185 :     localhost_addr.sin_addr.s_addr  = htonl( INADDR_LOOPBACK );

  00159	b9 01 00 00 7f	 mov	 ecx, 2130706433		; 7f000001H
  0015e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_htonl
  00164	89 44 24 64	 mov	 DWORD PTR localhost_addr$[rsp+4], eax

; 3186 : 
; 3187 :     if (0
; 3188 :         || SOCKET_ERROR   == bind( temp_listen_socket, (SOCKADDR*) &localhost_addr, len )
; 3189 :         || SOCKET_ERROR   == listen( temp_listen_socket, 1 )
; 3190 :         || SOCKET_ERROR   == getsockname( temp_listen_socket, (SOCKADDR*) &tempaddr, &talen )
; 3191 :         || INVALID_SOCKET == (SOCKET)( socket_vector[1] = socket( AF_INET, SOCK_STREAM, 0 ) )

  00168	33 c0		 xor	 eax, eax
  0016a	85 c0		 test	 eax, eax
  0016c	0f 85 84 00 00
	00		 jne	 $LN7@socketpair
  00172	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00177	48 8d 54 24 60	 lea	 rdx, QWORD PTR localhost_addr$[rsp]
  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR temp_listen_socket$[rsp]
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_bind
  00187	83 f8 ff	 cmp	 eax, -1
  0018a	74 6a		 je	 SHORT $LN7@socketpair
  0018c	ba 01 00 00 00	 mov	 edx, 1
  00191	48 8b 4c 24 28	 mov	 rcx, QWORD PTR temp_listen_socket$[rsp]
  00196	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_listen
  0019c	83 f8 ff	 cmp	 eax, -1
  0019f	74 55		 je	 SHORT $LN7@socketpair
  001a1	4c 8d 44 24 30	 lea	 r8, QWORD PTR talen$[rsp]
  001a6	48 8d 54 24 70	 lea	 rdx, QWORD PTR tempaddr$[rsp]
  001ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR temp_listen_socket$[rsp]
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_getsockname
  001b6	83 f8 ff	 cmp	 eax, -1
  001b9	74 3b		 je	 SHORT $LN7@socketpair
  001bb	45 33 c0	 xor	 r8d, r8d
  001be	ba 01 00 00 00	 mov	 edx, 1
  001c3	b9 02 00 00 00	 mov	 ecx, 2
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_socket
  001ce	48 89 44 24 48	 mov	 QWORD PTR tv144[rsp], rax
  001d3	b8 04 00 00 00	 mov	 eax, 4
  001d8	48 6b c0 01	 imul	 rax, rax, 1
  001dc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR socket_vector$[rsp]
  001e4	8b 54 24 48	 mov	 edx, DWORD PTR tv144[rsp]
  001e8	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  001eb	48 63 44 24 48	 movsxd	 rax, DWORD PTR tv144[rsp]
  001f0	48 83 f8 ff	 cmp	 rax, -1
  001f4	75 2b		 jne	 SHORT $LN6@socketpair
$LN7@socketpair:

; 3192 :     )
; 3193 :     {
; 3194 :         int nLastError = (int)WSAGetLastError();

  001f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  001fc	89 44 24 3c	 mov	 DWORD PTR nLastError$1[rsp], eax

; 3195 :         closesocket( temp_listen_socket );

  00200	48 8b 4c 24 28	 mov	 rcx, QWORD PTR temp_listen_socket$[rsp]
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 3196 :         errno = nLastError;

  0020b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00211	8b 4c 24 3c	 mov	 ecx, DWORD PTR nLastError$1[rsp]
  00215	89 08		 mov	 DWORD PTR [rax], ecx

; 3197 :         return -1;

  00217	b8 ff ff ff ff	 mov	 eax, -1
  0021c	e9 e2 00 00 00	 jmp	 $LN1@socketpair
$LN6@socketpair:

; 3198 :     }
; 3199 : 
; 3200 :     /* Get the temporary port number assigned automatically */
; 3201 :     /* by bind(127.0.0.1/0)                                 */
; 3202 : 
; 3203 :     localhost_addr.sin_port = tempaddr.sin_port;

  00221	0f b7 44 24 72	 movzx	 eax, WORD PTR tempaddr$[rsp+2]
  00226	66 89 44 24 62	 mov	 WORD PTR localhost_addr$[rsp+2], ax

; 3204 : 
; 3205 :     if (0
; 3206 :         || SOCKET_ERROR   == connect( socket_vector[1], (SOCKADDR*) &localhost_addr, len )
; 3207 :         || INVALID_SOCKET == (SOCKET)( socket_vector[0] = accept( temp_listen_socket, (SOCKADDR*) &localhost_addr, &len ) )

  0022b	33 c0		 xor	 eax, eax
  0022d	85 c0		 test	 eax, eax
  0022f	75 67		 jne	 SHORT $LN9@socketpair
  00231	b8 04 00 00 00	 mov	 eax, 4
  00236	48 6b c0 01	 imul	 rax, rax, 1
  0023a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR socket_vector$[rsp]
  00242	48 63 04 01	 movsxd	 rax, DWORD PTR [rcx+rax]
  00246	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  0024b	48 8d 54 24 60	 lea	 rdx, QWORD PTR localhost_addr$[rsp]
  00250	48 8b c8	 mov	 rcx, rax
  00253	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_connect
  00259	83 f8 ff	 cmp	 eax, -1
  0025c	74 3a		 je	 SHORT $LN9@socketpair
  0025e	4c 8d 44 24 20	 lea	 r8, QWORD PTR len$[rsp]
  00263	48 8d 54 24 60	 lea	 rdx, QWORD PTR localhost_addr$[rsp]
  00268	8b 4c 24 28	 mov	 ecx, DWORD PTR temp_listen_socket$[rsp]
  0026c	e8 00 00 00 00	 call	 w32_accept
  00271	89 44 24 34	 mov	 DWORD PTR tv165[rsp], eax
  00275	b8 04 00 00 00	 mov	 eax, 4
  0027a	48 6b c0 00	 imul	 rax, rax, 0
  0027e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR socket_vector$[rsp]
  00286	8b 54 24 34	 mov	 edx, DWORD PTR tv165[rsp]
  0028a	89 14 01	 mov	 DWORD PTR [rcx+rax], edx
  0028d	48 63 44 24 34	 movsxd	 rax, DWORD PTR tv165[rsp]
  00292	48 83 f8 ff	 cmp	 rax, -1
  00296	75 5e		 jne	 SHORT $LN8@socketpair
$LN9@socketpair:

; 3208 :     )
; 3209 :     {
; 3210 :         int nLastError = (int)WSAGetLastError();

  00298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_WSAGetLastError
  0029e	89 44 24 40	 mov	 DWORD PTR nLastError$2[rsp], eax

; 3211 :         closesocket( socket_vector[1] );

  002a2	b8 04 00 00 00	 mov	 eax, 4
  002a7	48 6b c0 01	 imul	 rax, rax, 1
  002ab	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR socket_vector$[rsp]
  002b3	48 63 04 01	 movsxd	 rax, DWORD PTR [rcx+rax]
  002b7	48 8b c8	 mov	 rcx, rax
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 3212 :                      socket_vector[1] = INVALID_SOCKET;

  002c0	b8 04 00 00 00	 mov	 eax, 4
  002c5	48 6b c0 01	 imul	 rax, rax, 1
  002c9	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR socket_vector$[rsp]
  002d1	c7 04 01 ff ff
	ff ff		 mov	 DWORD PTR [rcx+rax], -1

; 3213 :         closesocket( temp_listen_socket );

  002d8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR temp_listen_socket$[rsp]
  002dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 3214 :         errno = nLastError;

  002e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002e9	8b 4c 24 40	 mov	 ecx, DWORD PTR nLastError$2[rsp]
  002ed	89 08		 mov	 DWORD PTR [rax], ecx

; 3215 :         return -1;

  002ef	b8 ff ff ff ff	 mov	 eax, -1
  002f4	eb 0d		 jmp	 SHORT $LN1@socketpair
$LN8@socketpair:

; 3216 :     }
; 3217 : 
; 3218 :     closesocket( temp_listen_socket );

  002f6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR temp_listen_socket$[rsp]
  002fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_closesocket

; 3219 :     return 0;

  00301	33 c0		 xor	 eax, eax
$LN1@socketpair:

; 3220 : }

  00303	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0030b	48 33 cc	 xor	 rcx, rsp
  0030e	e8 00 00 00 00	 call	 __security_check_cookie
  00313	48 81 c4 90 00
	00 00		 add	 rsp, 144		; 00000090H
  0031a	5f		 pop	 rdi
  0031b	c3		 ret	 0
socketpair ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
dwOrigError$ = 32
dwLastError$ = 36
dwDummy$ = 40
ovl$ = 48
ntStatus$ = 96
w32_NtStatusToLastError PROC

; 198  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 199  :     OVERLAPPED  ovl;
; 200  :     DWORD       dwOrigError, dwLastError, dwDummy;
; 201  : 
; 202  :     ovl.InternalHigh = 0;

  00008	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR ovl$[rsp+8], 0

; 203  :     ovl.Internal     = ntStatus;

  00011	48 63 44 24 60	 movsxd	 rax, DWORD PTR ntStatus$[rsp]
  00016	48 89 44 24 30	 mov	 QWORD PTR ovl$[rsp], rax

; 204  :     ovl.OffsetHigh   = 0;

  0001b	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR ovl$[rsp+20], 0

; 205  :     ovl.Offset       = 0;

  00023	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR ovl$[rsp+16], 0

; 206  :     ovl.hEvent       = NULL;

  0002b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR ovl$[rsp+24], 0

; 207  : 
; 208  :     dwOrigError = GetLastError();   // (save original value)

  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  0003a	89 44 24 20	 mov	 DWORD PTR dwOrigError$[rsp], eax

; 209  :     GetOverlappedResult( NULL, &ovl, &dwDummy, FALSE );

  0003e	45 33 c9	 xor	 r9d, r9d
  00041	4c 8d 44 24 28	 lea	 r8, QWORD PTR dwDummy$[rsp]
  00046	48 8d 54 24 30	 lea	 rdx, QWORD PTR ovl$[rsp]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetOverlappedResult

; 210  :     dwLastError = GetLastError();   // (save converted result)

  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetLastError
  00059	89 44 24 24	 mov	 DWORD PTR dwLastError$[rsp], eax

; 211  :     SetLastError( dwOrigError );    // (restore original value)

  0005d	8b 4c 24 20	 mov	 ecx, DWORD PTR dwOrigError$[rsp]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetLastError

; 212  :     return dwLastError;             // (return converted result)

  00067	8b 44 24 24	 mov	 eax, DWORD PTR dwLastError$[rsp]

; 213  : }

  0006b	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0006f	c3		 ret	 0
w32_NtStatusToLastError ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
dwBytesReturned$ = 64
dwBuffSize$ = 68
errnum$ = 96
pszBuffer$ = 104
nBuffSize$ = 112
w32_w32errmsg PROC

; 170  : {

$LN13:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 171  :     DWORD dwBytesReturned = 0;

  00012	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR dwBytesReturned$[rsp], 0

; 172  :     DWORD dwBuffSize = (DWORD)nBuffSize;

  0001a	8b 44 24 70	 mov	 eax, DWORD PTR nBuffSize$[rsp]
  0001e	89 44 24 44	 mov	 DWORD PTR dwBuffSize$[rsp], eax
$LN4@w32_w32err:

; 173  : 
; 174  :     ASSERT( pszBuffer && nBuffSize );

  00022	48 83 7c 24 68
	00		 cmp	 QWORD PTR pszBuffer$[rsp], 0
  00028	74 08		 je	 SHORT $LN9@w32_w32err
  0002a	48 83 7c 24 70
	00		 cmp	 QWORD PTR nBuffSize$[rsp], 0
  00030	75 5b		 jne	 SHORT $LN8@w32_w32err
$LN9@w32_w32err:
$LN7@w32_w32err:
  00032	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159123
  00039	41 b8 ae 00 00
	00		 mov	 r8d, 174		; 000000aeH
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159124
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159125
  0004d	e8 00 00 00 00	 call	 logmsg
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00058	85 c0		 test	 eax, eax
  0005a	74 20		 je	 SHORT $LN10@w32_w32err
  0005c	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG159127
  00063	41 b8 ae 00 00
	00		 mov	 r8d, 174		; 000000aeH
  00069	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159128
  00070	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG159129
  00077	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@w32_w32err:
  0007c	33 c0		 xor	 eax, eax
  0007e	85 c0		 test	 eax, eax
  00080	75 b0		 jne	 SHORT $LN7@w32_w32err
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00088	85 c0		 test	 eax, eax
  0008a	74 01		 je	 SHORT $LN11@w32_w32err
  0008c	cc		 int	 3
$LN11@w32_w32err:
$LN8@w32_w32err:
  0008d	33 c0		 xor	 eax, eax
  0008f	85 c0		 test	 eax, eax
  00091	75 8f		 jne	 SHORT $LN4@w32_w32err

; 175  : 
; 176  :     dwBytesReturned = FormatMessageA

  00093	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  0009c	8b 44 24 44	 mov	 eax, DWORD PTR dwBuffSize$[rsp]
  000a0	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  000a4	48 8b 44 24 68	 mov	 rax, QWORD PTR pszBuffer$[rsp]
  000a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ae	41 b9 00 04 00
	00		 mov	 r9d, 1024		; 00000400H
  000b4	44 8b 44 24 60	 mov	 r8d, DWORD PTR errnum$[rsp]
  000b9	33 d2		 xor	 edx, edx
  000bb	b9 00 12 00 00	 mov	 ecx, 4608		; 00001200H
  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_FormatMessageA
  000c6	89 44 24 40	 mov	 DWORD PTR dwBytesReturned$[rsp], eax

; 177  :     (
; 178  :         0
; 179  :             | FORMAT_MESSAGE_FROM_SYSTEM
; 180  :             | FORMAT_MESSAGE_IGNORE_INSERTS
; 181  :         ,
; 182  :         NULL,
; 183  :         errnum,
; 184  :         MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
; 185  :         pszBuffer,
; 186  :         dwBuffSize,
; 187  :         NULL
; 188  :     );
; 189  : 
; 190  :     pszBuffer[ dwBytesReturned ] = 0;

  000ca	8b 44 24 40	 mov	 eax, DWORD PTR dwBytesReturned$[rsp]
  000ce	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pszBuffer$[rsp]
  000d3	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0

; 191  :     return RTRIM( pszBuffer );

  000d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG159131
  000de	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pszBuffer$[rsp]
  000e3	e8 00 00 00 00	 call	 rtrim

; 192  : }

  000e8	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000ec	c3		 ret	 0
w32_w32errmsg ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
errnum$ = 48
buffer$ = 56
buffsize$ = 64
w32_strerror_r PROC

; 144  : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 145  :     // Route all 'errno' values outside the normal CRT (C Runtime) error
; 146  :     // message table range to the Win32 'w32_w32errmsg' function instead.
; 147  :     // Otherwise simply use the CRT's error message table directly...
; 148  : 
; 149  :     if ( !buffer || !buffsize ) return -1;

  00012	48 83 7c 24 38
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00018	74 08		 je	 SHORT $LN3@w32_strerr
  0001a	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffsize$[rsp], 0
  00020	75 07		 jne	 SHORT $LN2@w32_strerr
$LN3@w32_strerr:
  00022	b8 ff ff ff ff	 mov	 eax, -1
  00027	eb 4a		 jmp	 SHORT $LN1@w32_strerr
$LN2@w32_strerr:

; 150  : 
; 151  :     if ( errnum >= 0 && errnum < _sys_nerr )

  00029	83 7c 24 30 00	 cmp	 DWORD PTR errnum$[rsp], 0
  0002e	7c 2e		 jl	 SHORT $LN4@w32_strerr
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___sys_nerr
  00036	8b 00		 mov	 eax, DWORD PTR [rax]
  00038	39 44 24 30	 cmp	 DWORD PTR errnum$[rsp], eax
  0003c	7d 20		 jge	 SHORT $LN4@w32_strerr

; 152  :     {
; 153  :         // Use CRT's error message table directly...
; 154  :         strlcpy( buffer, _sys_errlist[ errnum ], buffsize );

  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___sys_errlist
  00044	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR errnum$[rsp]
  00049	4c 8b 44 24 40	 mov	 r8, QWORD PTR buffsize$[rsp]
  0004e	48 8b 14 c8	 mov	 rdx, QWORD PTR [rax+rcx*8]
  00052	48 8b 4c 24 38	 mov	 rcx, QWORD PTR buffer$[rsp]
  00057	e8 00 00 00 00	 call	 strlcpy

; 155  :     }

  0005c	eb 13		 jmp	 SHORT $LN5@w32_strerr
$LN4@w32_strerr:

; 156  :     else
; 157  :     {
; 158  :         // 'errno' value is actually a Win32 [WSA]GetLastError value...
; 159  :         w32_w32errmsg( errnum, buffer, buffsize );

  0005e	4c 8b 44 24 40	 mov	 r8, QWORD PTR buffsize$[rsp]
  00063	48 8b 54 24 38	 mov	 rdx, QWORD PTR buffer$[rsp]
  00068	8b 4c 24 30	 mov	 ecx, DWORD PTR errnum$[rsp]
  0006c	e8 00 00 00 00	 call	 w32_w32errmsg
$LN5@w32_strerr:

; 160  :     }
; 161  : 
; 162  :     return 0;

  00071	33 c0		 xor	 eax, eax
$LN1@w32_strerr:

; 163  : }

  00073	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00077	c3		 ret	 0
w32_strerror_r ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
errnum$ = 48
w32_strerror PROC

; 134  : {

$LN3:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 135  :     static char szMsgBuff[ 256 ]; // (s/b plenty big enough)
; 136  :     w32_strerror_r( errnum, szMsgBuff, sizeof(szMsgBuff) );

  00008	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  0000e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?szMsgBuff@?1??w32_strerror@@9@9
  00015	8b 4c 24 30	 mov	 ecx, DWORD PTR errnum$[rsp]
  00019	e8 00 00 00 00	 call	 w32_strerror_r

; 137  :     return szMsgBuff;

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?szMsgBuff@?1??w32_strerror@@9@9

; 138  : }

  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
w32_strerror ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
i$ = 0
dwLastError$ = 32
w32_trans_w32error PROC

; 123  : {

$LN7:
  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00004	48 83 ec 18	 sub	 rsp, 24

; 124  :     int i; for ( i=0; i < NUM_ERRNOTAB_ENTRIES; i++ )

  00008	c7 04 24 00 00
	00 00		 mov	 DWORD PTR i$[rsp], 0
  0000f	eb 08		 jmp	 SHORT $LN4@w32_trans_
$LN2@w32_trans_:
  00011	8b 04 24	 mov	 eax, DWORD PTR i$[rsp]
  00014	ff c0		 inc	 eax
  00016	89 04 24	 mov	 DWORD PTR i$[rsp], eax
$LN4@w32_trans_:
  00019	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0001d	48 83 f8 0d	 cmp	 rax, 13
  00021	73 27		 jae	 SHORT $LN3@w32_trans_

; 125  :         if ( dwLastError == w32_errno_tab[i].dwLastError )

  00023	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  00027	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:w32_errno_tab
  0002e	8b 04 c1	 mov	 eax, DWORD PTR [rcx+rax*8]
  00031	39 44 24 20	 cmp	 DWORD PTR dwLastError$[rsp], eax
  00035	75 11		 jne	 SHORT $LN5@w32_trans_

; 126  :             return w32_errno_tab[i].nErrNo;

  00037	48 63 04 24	 movsxd	 rax, DWORD PTR i$[rsp]
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:w32_errno_tab
  00042	8b 44 c1 04	 mov	 eax, DWORD PTR [rcx+rax*8+4]
  00046	eb 06		 jmp	 SHORT $LN1@w32_trans_
$LN5@w32_trans_:
  00048	eb c7		 jmp	 SHORT $LN2@w32_trans_
$LN3@w32_trans_:

; 127  :     return (int) dwLastError;

  0004a	8b 44 24 20	 mov	 eax, DWORD PTR dwLastError$[rsp]
$LN1@w32_trans_:

; 128  : }

  0004e	48 83 c4 18	 add	 rsp, 24
  00052	c3		 ret	 0
w32_trans_w32error ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\w32util.c
_TEXT	SEGMENT
elevated$ = 48
Elevation$1 = 52
tv82 = 56
tv84 = 60
cbSize$2 = 64
hToken$ = 72
are_elevated PROC

; 4750 : {

$LN10:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 4751 :     bool elevated = false;

  00006	c6 44 24 30 00	 mov	 BYTE PTR elevated$[rsp], 0

; 4752 :     HANDLE hToken = NULL;

  0000b	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR hToken$[rsp], 0

; 4753 : 
; 4754 :     if (OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken ))

  00014	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetCurrentProcess
  0001a	4c 8d 44 24 48	 lea	 r8, QWORD PTR hToken$[rsp]
  0001f	ba 08 00 00 00	 mov	 edx, 8
  00024	48 8b c8	 mov	 rcx, rax
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OpenProcessToken
  0002d	85 c0		 test	 eax, eax
  0002f	74 7d		 je	 SHORT $LN2@are_elevat

; 4755 :     {
; 4756 :         TOKEN_ELEVATION Elevation = {0};

  00031	48 8d 44 24 34	 lea	 rax, QWORD PTR Elevation$1[rsp]
  00036	48 8b f8	 mov	 rdi, rax
  00039	33 c0		 xor	 eax, eax
  0003b	b9 04 00 00 00	 mov	 ecx, 4
  00040	f3 aa		 rep stosb

; 4757 :         DWORD cbSize = sizeof( Elevation );

  00042	c7 44 24 40 04
	00 00 00	 mov	 DWORD PTR cbSize$2[rsp], 4

; 4758 : 
; 4759 :         if (GetTokenInformation( hToken, TokenElevation, &Elevation, sizeof( Elevation ), &cbSize ))

  0004a	48 8d 44 24 40	 lea	 rax, QWORD PTR cbSize$2[rsp]
  0004f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00054	41 b9 04 00 00
	00		 mov	 r9d, 4
  0005a	4c 8d 44 24 34	 lea	 r8, QWORD PTR Elevation$1[rsp]
  0005f	ba 14 00 00 00	 mov	 edx, 20
  00064	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hToken$[rsp]
  00069	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetTokenInformation
  0006f	85 c0		 test	 eax, eax
  00071	74 3b		 je	 SHORT $LN3@are_elevat

; 4760 :             elevated = Elevation.TokenIsElevated ? true : false;

  00073	83 7c 24 34 00	 cmp	 DWORD PTR Elevation$1[rsp], 0
  00078	74 0a		 je	 SHORT $LN6@are_elevat
  0007a	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv82[rsp], 1
  00082	eb 08		 jmp	 SHORT $LN7@are_elevat
$LN6@are_elevat:
  00084	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv82[rsp], 0
$LN7@are_elevat:
  0008c	83 7c 24 38 00	 cmp	 DWORD PTR tv82[rsp], 0
  00091	75 0a		 jne	 SHORT $LN8@are_elevat
  00093	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv84[rsp], 0
  0009b	eb 08		 jmp	 SHORT $LN9@are_elevat
$LN8@are_elevat:
  0009d	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv84[rsp], 1
$LN9@are_elevat:
  000a5	0f b6 44 24 3c	 movzx	 eax, BYTE PTR tv84[rsp]
  000aa	88 44 24 30	 mov	 BYTE PTR elevated$[rsp], al
$LN3@are_elevat:
$LN2@are_elevat:

; 4761 :     }
; 4762 : 
; 4763 :     if (hToken)

  000ae	48 83 7c 24 48
	00		 cmp	 QWORD PTR hToken$[rsp], 0
  000b4	74 0b		 je	 SHORT $LN4@are_elevat

; 4764 :         CloseHandle( hToken );

  000b6	48 8b 4c 24 48	 mov	 rcx, QWORD PTR hToken$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CloseHandle
$LN4@are_elevat:

; 4765 : 
; 4766 :     return elevated;

  000c1	0f b6 44 24 30	 movzx	 eax, BYTE PTR elevated$[rsp]

; 4767 : }

  000c6	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000ca	5f		 pop	 rdi
  000cb	c3		 ret	 0
are_elevated ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _snprintf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_snprintf PROC						; COMDAT

; 1947 :     {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1948 :         int _Result;
; 1949 :         va_list _ArgList;
; 1950 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 58	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 1951 :         _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Format$[rsp]
  0002c	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  00031	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00036	e8 00 00 00 00	 call	 _vsnprintf
  0003b	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 1952 :         __crt_va_end(_ArgList);

  0003f	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 1953 :         return _Result;

  00048	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 1954 :     }

  0004c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00050	c3		 ret	 0
_snprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vscprintf
_TEXT	SEGMENT
_Format$ = 48
_ArgList$ = 56
_vscprintf PROC						; COMDAT

; 1668 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1669 :         return _vscprintf_l(_Format, NULL, _ArgList);

  0000e	4c 8b 44 24 38	 mov	 r8, QWORD PTR _ArgList$[rsp]
  00013	33 d2		 xor	 edx, edx
  00015	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Format$[rsp]
  0001a	e8 00 00 00 00	 call	 _vscprintf_l

; 1670 :     }

  0001f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00023	c3		 ret	 0
_vscprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vscprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Format$ = 80
_Locale$ = 88
_ArgList$ = 96
_vscprintf_l PROC					; COMDAT

; 1651 :     {

$LN5:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1652 :         int const _Result = __stdio_common_vsprintf(

  00013	e8 00 00 00 00	 call	 __local_stdio_printf_options
  00018	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0001b	48 83 c8 02	 or	 rax, 2
  0001f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00024	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00029	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00033	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Format$[rsp]
  00038	45 33 c0	 xor	 r8d, r8d
  0003b	33 d2		 xor	 edx, edx
  0003d	48 8b c8	 mov	 rcx, rax
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00046	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1653 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR,
; 1654 :             NULL, 0, _Format, _Locale, _ArgList);
; 1655 : 
; 1656 :         return _Result < 0 ? -1 : _Result;

  0004a	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  0004f	7d 0a		 jge	 SHORT $LN3@vscprintf_
  00051	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00059	eb 08		 jmp	 SHORT $LN4@vscprintf_
$LN3@vscprintf_:
  0005b	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  0005f	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vscprintf_:
  00063	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1657 :     }

  00067	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0006b	c3		 ret	 0
_vscprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_Format$ = 80
_ArgList$ = 88
_vsnprintf PROC						; COMDAT

; 1411 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1412 :         return _vsnprintf_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 58	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00022	45 33 c9	 xor	 r9d, r9d
  00025	4c 8b 44 24 50	 mov	 r8, QWORD PTR _Format$[rsp]
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsnprintf_l

; 1413 :     }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
_vsnprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_l
_TEXT	SEGMENT
_Result$ = 48
tv74 = 52
_Buffer$ = 80
_BufferCount$ = 88
_Format$ = 96
_Locale$ = 104
_ArgList$ = 112
_vsnprintf_l PROC					; COMDAT

; 1391 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1392 :         int const _Result = __stdio_common_vsprintf(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00020	48 83 c8 01	 or	 rax, 1
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00029	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0002e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00033	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00038	4c 8b 4c 24 60	 mov	 r9, QWORD PTR _Format$[rsp]
  0003d	4c 8b 44 24 58	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  00042	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00047	48 8b c8	 mov	 rcx, rax
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsprintf
  00050	89 44 24 30	 mov	 DWORD PTR _Result$[rsp], eax

; 1393 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1394 :             _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1395 : 
; 1396 :         return _Result < 0 ? -1 : _Result;

  00054	83 7c 24 30 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00059	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  0005b	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  00063	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  00065	8b 44 24 30	 mov	 eax, DWORD PTR _Result$[rsp]
  00069	89 44 24 34	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  0006d	8b 44 24 34	 mov	 eax, DWORD PTR tv74[rsp]

; 1397 :     }

  00071	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00075	c3		 ret	 0
_vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT vfprintf
_TEXT	SEGMENT
_Stream$ = 48
_Format$ = 56
_ArgList$ = 64
vfprintf PROC						; COMDAT

; 658  :     {

$LN3:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 659  :         return _vfprintf_l(_Stream, _Format, NULL, _ArgList);

  00013	4c 8b 4c 24 40	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00018	45 33 c0	 xor	 r8d, r8d
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Format$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Stream$[rsp]
  00025	e8 00 00 00 00	 call	 _vfprintf_l

; 660  :     }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
vfprintf ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vfprintf_l
_TEXT	SEGMENT
_Stream$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vfprintf_l PROC					; COMDAT

; 644  :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 645  :         return __stdio_common_vfprintf(_CRT_INTERNAL_LOCAL_PRINTF_OPTIONS, _Stream, _Format, _Locale, _ArgList);

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00027	4c 8b 4c 24 50	 mov	 r9, QWORD PTR _Locale$[rsp]
  0002c	4c 8b 44 24 48	 mov	 r8, QWORD PTR _Format$[rsp]
  00031	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Stream$[rsp]
  00036	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vfprintf

; 646  :     }

  0003f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00043	c3		 ret	 0
_vfprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
