; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	fba_dasd_init_handler
PUBLIC	fba_dasd_execute_ccw
PUBLIC	fba_dasd_close_device
PUBLIC	fba_dasd_query_device
PUBLIC	fba_dasd_hsuspend
PUBLIC	fba_dasd_hresume
PUBLIC	fba_dasd_device_hndinfo
_DATA	SEGMENT
fba_dasd_device_hndinfo DQ FLAT:fba_dasd_init_handler
	DQ	FLAT:fba_dasd_execute_ccw
	DQ	FLAT:fba_dasd_close_device
	DQ	FLAT:fba_dasd_query_device
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fba_dasd_end
	DQ	0000000000000000H
	DQ	FLAT:fba_dasd_end
	DQ	0000000000000000H
	DQ	FLAT:fba_dasd_read_blkgrp
	DQ	FLAT:fba_dasd_update_blkgrp
	DQ	FLAT:fba_dasd_used
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	0000000000000000H
	DQ	FLAT:fba_dasd_hsuspend
	DQ	FLAT:fba_dasd_hresume
_DATA	ENDS
CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
VOL1_KEYA DB	056H
	DB	04fH
	DB	04cH
	DB	031H
VOL1_KEY DB	0e5H
	DB	0d6H
	DB	0d3H
	DB	0f1H
IPL1_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f1H
IPL2_KEY DB	0c9H
	DB	0d7H
	DB	0d3H
	DB	0f2H
iplpsw	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
iplccw1	DB	06H
	DB	00H
	DB	03aH
	DB	098H
	DB	060H
	DB	00H
	DB	00H
	DB	060H
iplccw2	DB	08H
	DB	00H
	DB	03aH
	DB	098H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
noiplpsw DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0fH
noiplccw1 DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01H
noiplccw2 DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
ipl2data DB	07H
	DB	00H
	DB	03aH
	DB	0b8H
	DB	040H
	DB	00H
	DB	00H
	DB	06H
	DB	031H
	DB	00H
	DB	03aH
	DB	0beH
	DB	040H
	DB	00H
	DB	00H
	DB	05H
	DB	08H
	DB	00H
	DB	03aH
	DB	0a0H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	06H
	DB	00H
	DB	00H
	DB	00H
	DB	020H
	DB	00H
	DB	07fH
	DB	0ffH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	04H
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	store_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	fbadasd_syncblk_io
PUBLIC	fbadasd_read_block
PUBLIC	fbadasd_write_block
PUBLIC	fbadasd_purge_cache
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strcmp:PROC
EXTRN	strlen:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__fstat64:PROC
EXTRN	__imp__stat64:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_tf_0516:PROC
EXTRN	__imp_tf_0517:PROC
EXTRN	__imp_tf_0518:PROC
EXTRN	__imp_tf_0519:PROC
EXTRN	__imp_tf_0520:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fwrite:PROC
EXTRN	__imp_w32_snprintf:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_w32_basename:PROC
EXTRN	cache_lookup:PROC
EXTRN	cache_scan:PROC
EXTRN	cache_lock:PROC
EXTRN	cache_unlock:PROC
EXTRN	cache_wait:PROC
EXTRN	cache_getkey:PROC
EXTRN	cache_setkey:PROC
EXTRN	cache_setflag:PROC
EXTRN	cache_setage:PROC
EXTRN	cache_getbuf:PROC
EXTRN	cache_getlen:PROC
EXTRN	cache_release:PROC
EXTRN	dasd_lookup:PROC
EXTRN	dasd_build_fba_devid:PROC
EXTRN	dasd_build_fba_devchar:PROC
EXTRN	shared_update_notify:PROC
EXTRN	shared_fba_init:PROC
EXTRN	fba64_dasd_init_handler:PROC
EXTRN	cckd_dasd_init_handler:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	is_dh_devid_typ:PROC
EXTRN	cckd_sf_parse_sfn:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	memcmp:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
$SG169977 DB	01H DUP (?)
$SG169980 DB	01H DUP (?)
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$fbadasd_syncblk_io DD imagerel $LN10
	DD	imagerel $LN10+276
	DD	imagerel $unwind$fbadasd_syncblk_io
$pdata$fbadasd_read_block DD imagerel $LN5
	DD	imagerel $LN5+234
	DD	imagerel $unwind$fbadasd_read_block
$pdata$fbadasd_write_block DD imagerel $LN6
	DD	imagerel $LN6+241
	DD	imagerel $unwind$fbadasd_write_block
$pdata$fba_dasd_init_handler DD imagerel $LN100
	DD	imagerel $LN100+5882
	DD	imagerel $unwind$fba_dasd_init_handler
$pdata$fba_dasd_execute_ccw DD imagerel $LN120
	DD	imagerel $LN120+6687
	DD	imagerel $unwind$fba_dasd_execute_ccw
$pdata$fba_dasd_close_device DD imagerel $LN3
	DD	imagerel $LN3+142
	DD	imagerel $unwind$fba_dasd_close_device
$pdata$fba_dasd_query_device DD imagerel $LN17
	DD	imagerel $LN17+670
	DD	imagerel $unwind$fba_dasd_query_device
$pdata$fba_dasd_hsuspend DD imagerel $LN64
	DD	imagerel $LN64+857
	DD	imagerel $unwind$fba_dasd_hsuspend
$pdata$fba_dasd_hresume DD imagerel $LN111
	DD	imagerel $LN111+2172
	DD	imagerel $unwind$fba_dasd_hresume
$pdata$sr_write_hdr DD imagerel sr_write_hdr
	DD	imagerel sr_write_hdr+199
	DD	imagerel $unwind$sr_write_hdr
$pdata$sr_write_value DD imagerel sr_write_value
	DD	imagerel sr_write_value+378
	DD	imagerel $unwind$sr_write_value
$pdata$sr_read_hdr DD imagerel sr_read_hdr
	DD	imagerel sr_read_hdr+221
	DD	imagerel $unwind$sr_read_hdr
$pdata$sr_read_value DD imagerel sr_read_value
	DD	imagerel sr_read_value+588
	DD	imagerel $unwind$sr_read_value
$pdata$sr_read_skip DD imagerel sr_read_skip
	DD	imagerel sr_read_skip+248
	DD	imagerel $unwind$sr_read_skip
$pdata$sr_write_error_ DD imagerel sr_write_error_
	DD	imagerel sr_write_error_+121
	DD	imagerel $unwind$sr_write_error_
$pdata$sr_read_error_ DD imagerel sr_read_error_
	DD	imagerel sr_read_error_+121
	DD	imagerel $unwind$sr_read_error_
$pdata$sr_value_error_ DD imagerel sr_value_error_
	DD	imagerel sr_value_error_+80
	DD	imagerel $unwind$sr_value_error_
$pdata$fba_read DD imagerel fba_read
	DD	imagerel fba_read+559
	DD	imagerel $unwind$fba_read
$pdata$fba_blkgrp_len DD imagerel fba_blkgrp_len
	DD	imagerel fba_blkgrp_len+87
	DD	imagerel $unwind$fba_blkgrp_len
$pdata$fba_write DD imagerel fba_write
	DD	imagerel fba_write+559
	DD	imagerel $unwind$fba_write
$pdata$fba_dasd_read_blkgrp DD imagerel fba_dasd_read_blkgrp
	DD	imagerel fba_dasd_read_blkgrp+4214
	DD	imagerel $unwind$fba_dasd_read_blkgrp
$pdata$fba_dasd_update_blkgrp DD imagerel fba_dasd_update_blkgrp
	DD	imagerel fba_dasd_update_blkgrp+313
	DD	imagerel $unwind$fba_dasd_update_blkgrp
$pdata$fba_dasd_end DD imagerel fba_dasd_end
	DD	imagerel fba_dasd_end+44
	DD	imagerel $unwind$fba_dasd_end
$pdata$fbadasd_purge_cache DD imagerel $LN7
	DD	imagerel $LN7+132
	DD	imagerel $unwind$fbadasd_purge_cache
pdata	ENDS
_DATA	SEGMENT
$SG168722 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG168724 DB	'SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+1
$SG168827 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG168915 DB	'write()', 00H
$SG168788 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG168790 DB	'SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16'
	DB	'.16llx', 0aH, 00H
$SG168810 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG168812 DB	'SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x', 0aH, 00H
	ORG $+3
$SG168829 DB	'SR: sr_read_skip:                  len=0x%8.8x', 0aH, 00H
$SG168897 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+7
$SG168907 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG168916 DB	'E', 00H
	ORG $+2
$SG168918 DB	'sr_write_error_', 00H
$SG168919 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG168899 DB	'SR: sr_read_value:              suslen=0x%8.8x, reslen=0'
	DB	'x%8.8x,', 0aH, 00H
	ORG $+3
$SG168921 DB	'read()', 00H
	ORG $+1
$SG168922 DB	'E', 00H
	ORG $+2
$SG168909 DB	'                           val=0x%16.16llx', 0aH, 00H
$SG168933 DB	'E', 00H
	ORG $+2
$SG168917 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169849 DB	'%hx', 00H
$SG168923 DB	'HHC02001%s SR: error in function %s: %s', 0aH, 00H
	ORG $+3
$SG169852 DB	'E', 00H
	ORG $+2
$SG168924 DB	'sr_read_error_', 00H
	ORG $+1
$SG168925 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
$SG169859 DB	'E', 00H
	ORG $+2
$SG168934 DB	'HHC02020%s SR: value error, incorrect length', 0aH, 00H
	ORG $+2
$SG168935 DB	'sr_value_error_', 00H
$SG168936 DB	'C:\papa\MyGit\hyperion-zvector\sr.h', 00H
	ORG $+4
$SG169853 DB	'HHC00500%s %1d:%04X FBA file: name missing or invalid fi'
	DB	'lename length', 0aH, 00H
	ORG $+1
$SG169854 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169855 DB	'fbadasd.c', 00H
	ORG $+2
$SG169865 DB	'open()', 00H
	ORG $+1
$SG169866 DB	'E', 00H
	ORG $+2
$SG169860 DB	'HHC00501%s %1d:%04X FBA file %s not found or invalid', 0aH
	DB	00H
	ORG $+2
$SG169861 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169862 DB	'fbadasd.c', 00H
	ORG $+2
$SG169873 DB	'read()', 00H
	ORG $+1
$SG169874 DB	'E', 00H
	ORG $+2
$SG169867 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169880 DB	'E', 00H
	ORG $+2
$SG169868 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169869 DB	'fbadasd.c', 00H
	ORG $+2
$SG169879 DB	'read()', 00H
	ORG $+1
$SG169890 DB	'E', 00H
	ORG $+2
$SG169875 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169896 DB	'E', 00H
	ORG $+2
$SG169876 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169877 DB	'fbadasd.c', 00H
	ORG $+2
$SG169889 DB	'read()', 00H
	ORG $+1
$SG169901 DB	'sf=', 00H
$SG169878 DB	'unexpected end of file', 00H
	ORG $+1
$SG169881 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169903 DB	'cu=', 00H
$SG169882 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169883 DB	'fbadasd.c', 00H
	ORG $+2
$SG169895 DB	'read()', 00H
	ORG $+1
$SG169905 DB	'FBA', 00H
$SG169891 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169906 DB	'E', 00H
	ORG $+2
$SG169892 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169893 DB	'fbadasd.c', 00H
	ORG $+2
$SG169914 DB	'E', 00H
	ORG $+2
$SG169894 DB	'unexpected end of file', 00H
	ORG $+1
$SG169897 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169923 DB	'FBA', 00H
$SG169898 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169899 DB	'fbadasd.c', 00H
	ORG $+2
$SG169904 DB	'CFBA', 00H
	ORG $+7
$SG169908 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169907 DB	'HHC00503%s %1d:%04X %s file: parameter %s in argument %d'
	DB	' is invalid', 0aH, 00H
	ORG $+3
$SG169909 DB	'fbadasd.c', 00H
	ORG $+2
$SG169924 DB	'E', 00H
	ORG $+2
$SG169913 DB	'fstat()', 00H
$SG169915 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG169929 DB	'*', 00H
	ORG $+2
$SG169916 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169917 DB	'fbadasd.c', 00H
	ORG $+2
$SG169921 DB	'%u%c', 00H
	ORG $+3
$SG169922 DB	'CFBA', 00H
	ORG $+7
$SG169926 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169925 DB	'HHC00505%s %1d:%04X %s file %s: invalid device origin bl'
	DB	'ock number %s', 0aH, 00H
	ORG $+1
$SG169927 DB	'fbadasd.c', 00H
	ORG $+2
$SG169932 DB	'%u%c', 00H
	ORG $+3
$SG169933 DB	'CFBA', 00H
	ORG $+3
$SG169934 DB	'FBA', 00H
$SG169935 DB	'E', 00H
	ORG $+2
$SG169941 DB	'FBA', 00H
$SG169936 DB	'HHC00506%s %1d:%04X %s file %s: invalid device block cou'
	DB	'nt %s', 0aH, 00H
	ORG $+1
$SG169937 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169938 DB	'fbadasd.c', 00H
	ORG $+2
$SG169940 DB	'CFBA', 00H
	ORG $+3
$SG169942 DB	'I', 00H
	ORG $+2
$SG169943 DB	'HHC00507%s %1d:%04X %s file %s: origin %lld, blks %d', 0aH
	DB	00H
	ORG $+2
$SG169944 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169945 DB	'fbadasd.c', 00H
	ORG $+2
$SG169947 DB	'CFBA', 00H
	ORG $+3
$SG169948 DB	'FBA', 00H
$SG169949 DB	'E', 00H
	ORG $+6
$SG169950 DB	'HHC00508%s %1d:%04X %s file %s: device type %4.4X not fo'
	DB	'und in dasd table', 0aH, 00H
	ORG $+1
$SG169973 DB	'.', 00H
	ORG $+2
$SG169951 DB	'fba_dasd_init_handler', 00H
	ORG $+2
$SG169952 DB	'fbadasd.c', 00H
	ORG $+2
$SG169967 DB	'DASD', 00H
	ORG $+3
$SG169976 DB	'*64* ', 00H
	ORG $+2
$SG170081 DB	'E', 00H
	ORG $+2
$SG169978 DB	'%s%s [%lld,%d] IO[%llu]', 00H
$SG169979 DB	'*64* ', 00H
	ORG $+2
$SG169981 DB	'%s%s [%lld,%d] [%d sfs] IO[%llu]', 00H
	ORG $+3
$SG170087 DB	'E', 00H
	ORG $+2
$SG170080 DB	'lseek()', 00H
$SG170082 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170097 DB	'I', 00H
	ORG $+2
$SG170083 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170084 DB	'fbadasd.c', 00H
	ORG $+2
$SG170105 DB	'I', 00H
	ORG $+2
$SG170086 DB	'write()', 00H
$SG170088 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170112 DB	'I', 00H
	ORG $+2
$SG170089 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170090 DB	'fbadasd.c', 00H
	ORG $+6
$SG170098 DB	'HHC00516%s %1d:%04X FBA file %s: read blkgrp %d cache hi'
	DB	't, using cache[%d]', 0aH, 00H
$SG170119 DB	'I', 00H
	ORG $+2
$SG170099 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170100 DB	'fbadasd.c', 00H
	ORG $+6
$SG170107 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170106 DB	'HHC00517%s %1d:%04X FBA file %s: read blkgrp %d no avail'
	DB	'able cache entry, waiting', 0aH, 00H
	ORG $+1
$SG170125 DB	'E', 00H
	ORG $+2
$SG170108 DB	'fbadasd.c', 00H
	ORG $+6
$SG170114 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170113 DB	'HHC00518%s %1d:%04X FBA file %s: read blkgrp %d cache mi'
	DB	'ss, using cache[%d]', 0aH, 00H
	ORG $+3
$SG170115 DB	'fbadasd.c', 00H
	ORG $+6
$SG170120 DB	'HHC00519%s %1d:%04X FBA file %s: read blkgrp %d offset %'
	DB	'lld len %d', 0aH, 00H
$SG170132 DB	'E', 00H
	ORG $+2
$SG170121 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170122 DB	'fbadasd.c', 00H
	ORG $+2
$SG170131 DB	'read()', 00H
	ORG $+1
$SG170286 DB	'I', 00H
	ORG $+2
$SG170124 DB	'lseek()', 00H
$SG170126 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170292 DB	'E', 00H
	ORG $+2
$SG170127 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170128 DB	'fbadasd.c', 00H
	ORG $+2
$SG170297 DB	'E', 00H
	ORG $+2
$SG170130 DB	'unexpected end of file', 00H
	ORG $+1
$SG170133 DB	'HHC00502%s %1d:%04X FBA file %s: error in function %s: %'
	DB	's', 0aH, 00H
	ORG $+1
$SG170303 DB	'E', 00H
	ORG $+2
$SG170134 DB	'fba_dasd_read_blkgrp', 00H
	ORG $+3
$SG170135 DB	'fbadasd.c', 00H
	ORG $+2
$SG170309 DB	'E', 00H
	ORG $+2
$SG170287 DB	'HHC00520%s %1d:%04X FBA file %s: positioning to 0x%llX %'
	DB	'lld', 0aH, 00H
	ORG $+3
$SG170288 DB	'fba_dasd_execute_ccw', 00H
	ORG $+3
$SG170289 DB	'fbadasd.c', 00H
	ORG $+6
$SG170293 DB	'HHC00509%s %1d:%04X FBA file %s: define extent data too '
	DB	'short: %d bytes', 0aH, 00H
	ORG $+3
$SG170671 DB	'E', 00H
	ORG $+2
$SG170294 DB	'fba_dasd_execute_ccw', 00H
	ORG $+3
$SG170295 DB	'fbadasd.c', 00H
	ORG $+6
$SG170299 DB	'fba_dasd_execute_ccw', 00H
	ORG $+3
$SG170298 DB	'HHC00510%s %1d:%04X FBA file %s: second define extent in'
	DB	' chain', 0aH, 00H
$SG170300 DB	'fbadasd.c', 00H
	ORG $+2
$SG170678 DB	'E', 00H
	ORG $+2
$SG170304 DB	'HHC00511%s %1d:%04X FBA file %s: invalid file mask %2.2X'
	DB	0aH, 00H
	ORG $+2
$SG170699 DB	'E', 00H
	ORG $+2
$SG170305 DB	'fba_dasd_execute_ccw', 00H
	ORG $+3
$SG170306 DB	'fbadasd.c', 00H
	ORG $+6
$SG170311 DB	'fba_dasd_execute_ccw', 00H
	ORG $+3
$SG170310 DB	'HHC00512%s %1d:%04X FBA file %s: invalid extent: first b'
	DB	'lock %d last block %d numblks %d device size %d', 0aH, 00H
	ORG $+7
$SG170312 DB	'fbadasd.c', 00H
	ORG $+6
$SG170318 DB	'fbadasd.c:1223', 00H
	ORG $+1
$SG170319 DB	'fbadasd.c:1225', 00H
	ORG $+1
$SG170322 DB	'fbadasd.c:1244', 00H
	ORG $+1
$SG170323 DB	'fbadasd.c:1246', 00H
	ORG $+1
$SG170327 DB	'fbadasd.c:1267', 00H
	ORG $+1
$SG170328 DB	'fbadasd.c:1269', 00H
	ORG $+1
$SG170672 DB	'HHC00513%s %1d:%04X FBA file %s: FBA origin mismatch: %d'
	DB	', expected %d,', 0aH, 00H
$SG170673 DB	'fba_dasd_hresume', 00H
	ORG $+7
$SG170674 DB	'fbadasd.c', 00H
	ORG $+6
$SG170679 DB	'HHC00514%s %1d:%04X FBA file %s: FBA numblk mismatch: %d'
	DB	', expected %d,', 0aH, 00H
$SG170680 DB	'fba_dasd_hresume', 00H
	ORG $+7
$SG170681 DB	'fbadasd.c', 00H
	ORG $+6
$SG170700 DB	'HHC00515%s %1d:%04X FBA file %s: FBA blksiz mismatch: %d'
	DB	', expected %d,', 0aH, 00H
$SG170701 DB	'fba_dasd_hresume', 00H
	ORG $+7
$SG170702 DB	'fbadasd.c', 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_skip
	DD	01aH
	DD	0e0H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_value
	DD	021H
	DD	023aH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_read_hdr
	DD	01dH
	DD	0cbH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_value
	DD	021H
	DD	0168H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:sr_write_hdr
	DD	01cH
	DD	0b5H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fba_dasd_query_device
	DD	025H
	DD	0286H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fba_dasd_execute_ccw
	DD	026H
	DD	018e8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:fba_dasd_init_handler
	DD	01fH
	DD	016e2H
voltbl	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$fbadasd_syncblk_io DD 011701H
	DD	06217H
$unwind$fbadasd_read_block DD 011701H
	DD	06217H
$unwind$fbadasd_write_block DD 011701H
	DD	06217H
$unwind$fba_dasd_init_handler DD 022719H
	DD	0c30115H
	DD	imagerel __GSHandlerCheck
	DD	0600H
$unwind$fba_dasd_execute_ccw DD 042e19H
	DD	065011cH
	DD	060147015H
	DD	imagerel __GSHandlerCheck
	DD	0310H
$unwind$fba_dasd_close_device DD 010901H
	DD	06209H
$unwind$fba_dasd_query_device DD 022d19H
	DD	033011bH
	DD	imagerel __GSHandlerCheck
	DD	0180H
$unwind$fba_dasd_hsuspend DD 010e01H
	DD	0420eH
$unwind$fba_dasd_hresume DD 021101H
	DD	0190111H
$unwind$sr_write_hdr DD 012119H
	DD	06212H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_write_value DD 012619H
	DD	08217H
	DD	imagerel __GSHandlerCheck
	DD	030H
$unwind$sr_read_hdr DD 012219H
	DD	06213H
	DD	imagerel __GSHandlerCheck
	DD	028H
$unwind$sr_read_value DD 012619H
	DD	0c217H
	DD	imagerel __GSHandlerCheck
	DD	058H
$unwind$sr_read_skip DD 022219H
	DD	02b0110H
	DD	imagerel __GSHandlerCheck
	DD	0140H
$unwind$sr_write_error_ DD 010401H
	DD	0c204H
$unwind$sr_read_error_ DD 010401H
	DD	0c204H
$unwind$sr_value_error_ DD 010401H
	DD	08204H
$unwind$fba_read DD 031a01H
	DD	07016821aH
	DD	06015H
$unwind$fba_blkgrp_len DD 010e01H
	DD	0220eH
$unwind$fba_write DD 011801H
	DD	0c218H
$unwind$fba_dasd_read_blkgrp DD 021501H
	DD	0270115H
$unwind$fba_dasd_update_blkgrp DD 031901H
	DD	070156219H
	DD	06014H
$unwind$fba_dasd_end DD 010901H
	DD	06209H
$unwind$fbadasd_purge_cache DD 011701H
	DD	06217H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
dev$ = 8
fba_dasd_used PROC

; 785  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 786  :     return dev->fbanumblk;

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0000a	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]

; 787  : }

  00010	c3		 ret	 0
fba_dasd_used ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
devnum$ = 32
blkgrp$ = 36
dev$ = 40
answer$ = 64
ix$ = 72
i$ = 80
data$ = 88
fbadasd_purge_cache PROC

; 743  : {

$LN7:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 744  : U16             devnum;                 /* Cached device number      */
; 745  : int             blkgrp;                 /* Cached block group        */
; 746  : DEVBLK         *dev = data;             /* -> device block           */

  00017	48 8b 44 24 58	 mov	 rax, QWORD PTR data$[rsp]
  0001c	48 89 44 24 28	 mov	 QWORD PTR dev$[rsp], rax
$LN4@fbadasd_pu:

; 747  : 
; 748  :     UNREFERENCED(answer);

  00021	33 c0		 xor	 eax, eax
  00023	85 c0		 test	 eax, eax
  00025	75 fa		 jne	 SHORT $LN4@fbadasd_pu

; 749  :     FBA_CACHE_GETKEY(i, devnum, blkgrp);

  00027	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  0002b	33 c9		 xor	 ecx, ecx
  0002d	e8 00 00 00 00	 call	 cache_getkey
  00032	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00036	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  0003c	66 89 44 24 20	 mov	 WORD PTR devnum$[rsp], ax
  00041	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  00045	33 c9		 xor	 ecx, ecx
  00047	e8 00 00 00 00	 call	 cache_getkey
  0004c	b9 ff ff ff ff	 mov	 ecx, -1			; ffffffffH
  00051	48 23 c1	 and	 rax, rcx
  00054	89 44 24 24	 mov	 DWORD PTR blkgrp$[rsp], eax

; 750  :     if (dev->devnum == devnum)

  00058	48 8b 44 24 28	 mov	 rax, QWORD PTR dev$[rsp]
  0005d	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00061	0f b7 4c 24 20	 movzx	 ecx, WORD PTR devnum$[rsp]
  00066	3b c1		 cmp	 eax, ecx
  00068	75 13		 jne	 SHORT $LN5@fbadasd_pu

; 751  :         cache_release (ix, i, CACHE_FREEBUF);

  0006a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00070	8b 54 24 50	 mov	 edx, DWORD PTR i$[rsp]
  00074	8b 4c 24 48	 mov	 ecx, DWORD PTR ix$[rsp]
  00078	e8 00 00 00 00	 call	 cache_release
$LN5@fbadasd_pu:

; 752  :     return 0;

  0007d	33 c0		 xor	 eax, eax

; 753  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
fbadasd_purge_cache ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
unitstat$ = 32
dev$ = 64
fba_dasd_end PROC

; 732  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 733  : BYTE            unitstat;
; 734  : 
; 735  :     /* Forces updated buffer to be written */
; 736  :     (dev->hnd->read) (dev, -1, &unitstat);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00015	4c 8d 44 24 20	 lea	 r8, QWORD PTR unitstat$[rsp]
  0001a	ba ff ff ff ff	 mov	 edx, -1
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00024	ff 50 50	 call	 QWORD PTR [rax+80]

; 737  : }

  00027	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002b	c3		 ret	 0
fba_dasd_end ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
rc$ = 32
dev$ = 80
blkgrp$ = 88
off$ = 96
buf$ = 104
len$ = 112
unitstat$ = 120
fba_dasd_update_blkgrp PROC

; 694  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 695  : int             rc;                     /* Return code               */
; 696  : 
; 697  :     /* Read the block group */
; 698  :     if (blkgrp != dev->bufcur)

  00019	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  00024	39 44 24 58	 cmp	 DWORD PTR blkgrp$[rsp], eax
  00028	74 50		 je	 SHORT $LN2@fba_dasd_u

; 699  :     {
; 700  :         rc = (dev->hnd->read) (dev, blkgrp, unitstat);

  0002a	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0002f	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00036	4c 8b 44 24 78	 mov	 r8, QWORD PTR unitstat$[rsp]
  0003b	8b 54 24 58	 mov	 edx, DWORD PTR blkgrp$[rsp]
  0003f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00044	ff 50 50	 call	 QWORD PTR [rax+80]
  00047	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 701  :         if (rc < 0)

  0004b	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  00050	7d 28		 jge	 SHORT $LN3@fba_dasd_u

; 702  :         {
; 703  :             dev->bufcur = dev->cache = -1;

  00052	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00057	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00061	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00066	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 704  :             return -1;

  00070	b8 ff ff ff ff	 mov	 eax, -1
  00075	e9 b8 00 00 00	 jmp	 $LN1@fba_dasd_u
$LN3@fba_dasd_u:
$LN2@fba_dasd_u:

; 705  :         }
; 706  :     }
; 707  : 
; 708  :     /* Copy to the device buffer */
; 709  :     if (buf) memcpy (dev->buf + off, buf, len);

  0007a	48 83 7c 24 68
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00080	74 23		 je	 SHORT $LN4@fba_dasd_u
  00082	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  00087	48 63 4c 24 60	 movsxd	 rcx, DWORD PTR off$[rsp]
  0008c	48 8b 54 24 50	 mov	 rdx, QWORD PTR dev$[rsp]
  00091	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00098	48 8b f9	 mov	 rdi, rcx
  0009b	48 8b 74 24 68	 mov	 rsi, QWORD PTR buf$[rsp]
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	f3 a4		 rep movsb
$LN4@fba_dasd_u:

; 710  : 
; 711  :     /* Update high/low offsets */
; 712  :     if (!dev->bufupd || off < dev->bufupdlo)

  000a5	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000aa	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  000b1	74 11		 je	 SHORT $LN6@fba_dasd_u
  000b3	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000b8	8b 80 ec 01 00
	00		 mov	 eax, DWORD PTR [rax+492]
  000be	39 44 24 60	 cmp	 DWORD PTR off$[rsp], eax
  000c2	7d 0f		 jge	 SHORT $LN5@fba_dasd_u
$LN6@fba_dasd_u:

; 713  :         dev->bufupdlo = off;

  000c4	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000c9	8b 4c 24 60	 mov	 ecx, DWORD PTR off$[rsp]
  000cd	89 88 ec 01 00
	00		 mov	 DWORD PTR [rax+492], ecx
$LN5@fba_dasd_u:

; 714  :     if (off + len > dev-> bufupdhi)

  000d3	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000d7	8b 4c 24 60	 mov	 ecx, DWORD PTR off$[rsp]
  000db	03 c8		 add	 ecx, eax
  000dd	8b c1		 mov	 eax, ecx
  000df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000e4	3b 81 f0 01 00
	00		 cmp	 eax, DWORD PTR [rcx+496]
  000ea	7e 17		 jle	 SHORT $LN7@fba_dasd_u

; 715  :         dev->bufupdhi = off + len;

  000ec	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  000f0	8b 4c 24 60	 mov	 ecx, DWORD PTR off$[rsp]
  000f4	03 c8		 add	 ecx, eax
  000f6	8b c1		 mov	 eax, ecx
  000f8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  000fd	89 81 f0 01 00
	00		 mov	 DWORD PTR [rcx+496], eax
$LN7@fba_dasd_u:

; 716  : 
; 717  :     /* Indicate block group has been modified */
; 718  :     if (!dev->bufupd)

  00103	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00108	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0010f	75 1d		 jne	 SHORT $LN8@fba_dasd_u

; 719  :     {
; 720  :         dev->bufupd = 1;

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  00116	c7 80 f4 01 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+500], 1

; 721  :         shared_update_notify (dev, blkgrp);

  00120	8b 54 24 58	 mov	 edx, DWORD PTR blkgrp$[rsp]
  00124	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dev$[rsp]
  00129	e8 00 00 00 00	 call	 shared_update_notify
$LN8@fba_dasd_u:

; 722  :     }
; 723  : 
; 724  :     return len;

  0012e	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
$LN1@fba_dasd_u:

; 725  : } /* end function fba_dasd_update_blkgrp */

  00132	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00136	5f		 pop	 rdi
  00137	5e		 pop	 rsi
  00138	c3		 ret	 0
fba_dasd_update_blkgrp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
o$ = 112
i$ = 116
rc$ = 120
offset$ = 128
tv92 = 136
tv130 = 140
tv181 = 144
tv187 = 148
tv467 = 152
tv473 = 156
len$ = 160
tv511 = 164
tv549 = 168
tv265 = 172
tv322 = 176
tv326 = 180
tv361 = 184
tv365 = 188
tv425 = 192
tv435 = 196
tv439 = 200
tv261 = 204
tv503 = 208
tv82 = 216
tv87 = 224
tv171 = 232
tv176 = 240
tv258 = 248
tv319 = 256
tv358 = 264
tv432 = 272
tv457 = 280
tv462 = 288
tv506 = 296
dev$ = 320
blkgrp$ = 328
unitstat$ = 336
fba_dasd_read_blkgrp PROC

; 506  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 38 01
	00 00		 sub	 rsp, 312		; 00000138H

; 507  : int             rc;                     /* Return code               */
; 508  : int             i, o;                   /* Cache indexes             */
; 509  : int             len;                    /* Length to read            */
; 510  : off_t           offset;                 /* File offsets              */
; 511  : 
; 512  :     /* Return if reading the same block group */
; 513  :     if (blkgrp >= 0 && blkgrp == dev->bufcur)

  00015	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR blkgrp$[rsp], 0
  0001d	7c 1e		 jl	 SHORT $LN14@fba_dasd_r
  0001f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00027	8b 80 c0 01 00
	00		 mov	 eax, DWORD PTR [rax+448]
  0002d	39 84 24 48 01
	00 00		 cmp	 DWORD PTR blkgrp$[rsp], eax
  00034	75 07		 jne	 SHORT $LN14@fba_dasd_r

; 514  :         return 0;

  00036	33 c0		 xor	 eax, eax
  00038	e9 31 10 00 00	 jmp	 $LN1@fba_dasd_r
$LN14@fba_dasd_r:

; 515  : 
; 516  :     /* Write the previous block group if modified */
; 517  :     if (dev->bufupd)

  0003d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00045	83 b8 f4 01 00
	00 00		 cmp	 DWORD PTR [rax+500], 0
  0004c	0f 84 72 04 00
	00		 je	 $LN15@fba_dasd_r

; 518  :     {
; 519  :         dev->bufupd = 0;

  00052	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	c7 80 f4 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+500], 0

; 520  : 
; 521  :         /* Seek to the old block group offset */
; 522  :         offset = (off_t)(((S64)dev->bufcur * CFBA_BLKGRP_SIZE) + dev->bufupdlo);

  00064	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006c	48 63 80 c0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+448]
  00073	48 69 c0 00 f0
	00 00		 imul	 rax, rax, 61440		; 0000f000H
  0007a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00082	48 63 89 ec 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+492]
  00089	48 03 c1	 add	 rax, rcx
  0008c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 523  :         offset = lseek (dev->fd, offset, SEEK_SET);

  00094	45 33 c0	 xor	 r8d, r8d
  00097	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR offset$[rsp]
  0009f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a7	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000b3	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 524  :         if (offset < 0)

  000bb	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR offset$[rsp], 0
  000c4	0f 8d aa 01 00
	00		 jge	 $LN16@fba_dasd_r

; 525  :         {
; 526  :             /* Handle seek error condition */
; 527  :             // "%1d:%04X FBA file %s: error in function %s: %s"
; 528  :             WRMSG( HHC00502, "E", LCSS_DEVNUM,

  000ca	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d3	74 15		 je	 SHORT $LN37@fba_dasd_r
  000d5	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000e1	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv92[rsp], eax
  000e8	eb 0b		 jmp	 SHORT $LN38@fba_dasd_r
$LN37@fba_dasd_r:
  000ea	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv92[rsp], 0
$LN38@fba_dasd_r:
  000f5	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000fe	74 17		 je	 SHORT $LN39@fba_dasd_r
  00100	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00108	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0010c	d1 f8		 sar	 eax, 1
  0010e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv130[rsp], eax
  00115	eb 0b		 jmp	 SHORT $LN40@fba_dasd_r
$LN39@fba_dasd_r:
  00117	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv130[rsp], 0
$LN40@fba_dasd_r:
  00122	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00128	8b 08		 mov	 ecx, DWORD PTR [rax]
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00130	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  00138	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00140	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00147	48 89 8c 24 e0
	00 00 00	 mov	 QWORD PTR tv87[rsp], rcx
  0014f	b9 01 00 00 00	 mov	 ecx, 1
  00154	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0015a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  00162	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00167	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170080
  0016e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00173	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv87[rsp]
  0017b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00180	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv92[rsp]
  00187	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0018b	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv130[rsp]
  00192	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00196	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170081
  0019d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170082
  001a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  001b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170083
  001c0	ba 11 02 00 00	 mov	 edx, 529		; 00000211H
  001c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170084
  001cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 529  :                    dev->filename, "lseek()", strerror( errno ));
; 530  :             dev->sense[0] = SENSE_EC;

  001d2	b8 01 00 00 00	 mov	 eax, 1
  001d7	48 6b c0 00	 imul	 rax, rax, 0
  001db	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e3	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 531  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  001eb	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  001f3	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 532  :             cache_lock(CACHE_DEVBUF);

  001f6	33 c9		 xor	 ecx, ecx
  001f8	e8 00 00 00 00	 call	 cache_lock

; 533  :             cache_setflag(CACHE_DEVBUF, dev->cache, ~FBA_CACHE_ACTIVE, 0);

  001fd	45 33 c9	 xor	 r9d, r9d
  00200	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00206	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020e	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00214	33 c9		 xor	 ecx, ecx
  00216	e8 00 00 00 00	 call	 cache_setflag

; 534  :             cache_unlock(CACHE_DEVBUF);

  0021b	33 c9		 xor	 ecx, ecx
  0021d	e8 00 00 00 00	 call	 cache_unlock

; 535  :             dev->bufupdlo = dev->bufupdhi = 0;

  00222	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0022a	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  00234	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023c	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 536  :             dev->bufcur = dev->cache = -1;

  00246	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024e	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00258	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00260	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 537  :             return -1;

  0026a	b8 ff ff ff ff	 mov	 eax, -1
  0026f	e9 fa 0d 00 00	 jmp	 $LN1@fba_dasd_r
$LN16@fba_dasd_r:

; 538  :         }
; 539  : 
; 540  :         /* Write the portion of the block group that was modified */
; 541  :         rc = write (dev->fd, dev->buf + dev->bufupdlo,

  00274	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0027c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00284	8b 89 ec 01 00
	00		 mov	 ecx, DWORD PTR [rcx+492]
  0028a	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [rax+496]
  00290	2b c1		 sub	 eax, ecx
  00292	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0029a	48 63 89 ec 01
	00 00		 movsxd	 rcx, DWORD PTR [rcx+492]
  002a1	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002a9	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  002b0	44 8b c0	 mov	 r8d, eax
  002b3	48 8b d1	 mov	 rdx, rcx
  002b6	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002be	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  002c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  002ca	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 542  :                     dev->bufupdhi - dev->bufupdlo);
; 543  :         if (rc < dev->bufupdhi - dev->bufupdlo)

  002ce	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002d6	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002de	8b 89 ec 01 00
	00		 mov	 ecx, DWORD PTR [rcx+492]
  002e4	8b 80 f0 01 00
	00		 mov	 eax, DWORD PTR [rax+496]
  002ea	2b c1		 sub	 eax, ecx
  002ec	39 44 24 78	 cmp	 DWORD PTR rc$[rsp], eax
  002f0	0f 8d aa 01 00
	00		 jge	 $LN17@fba_dasd_r

; 544  :         {
; 545  :             /* Handle write error condition */
; 546  :             // "%1d:%04X FBA file %s: error in function %s: %s"
; 547  :             WRMSG( HHC00502, "E", LCSS_DEVNUM,

  002f6	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  002ff	74 15		 je	 SHORT $LN41@fba_dasd_r
  00301	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00309	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0030d	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
  00314	eb 0b		 jmp	 SHORT $LN42@fba_dasd_r
$LN41@fba_dasd_r:
  00316	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv181[rsp], 0
$LN42@fba_dasd_r:
  00321	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0032a	74 17		 je	 SHORT $LN43@fba_dasd_r
  0032c	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00334	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00338	d1 f8		 sar	 eax, 1
  0033a	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv187[rsp], eax
  00341	eb 0b		 jmp	 SHORT $LN44@fba_dasd_r
$LN43@fba_dasd_r:
  00343	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv187[rsp], 0
$LN44@fba_dasd_r:
  0034e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00354	8b 08		 mov	 ecx, DWORD PTR [rax]
  00356	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0035c	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv171[rsp], rax
  00364	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0036c	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00373	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR tv176[rsp], rcx
  0037b	b9 01 00 00 00	 mov	 ecx, 1
  00380	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00386	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv171[rsp]
  0038e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00393	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170086
  0039a	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0039f	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv176[rsp]
  003a7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003ac	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv181[rsp]
  003b3	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003b7	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv187[rsp]
  003be	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170087
  003c9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003ce	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170088
  003d5	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003da	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003df	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170089
  003ec	ba 24 02 00 00	 mov	 edx, 548		; 00000224H
  003f1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170090
  003f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 548  :                    dev->filename, "write()", strerror( errno ));
; 549  :             dev->sense[0] = SENSE_EC;

  003fe	b8 01 00 00 00	 mov	 eax, 1
  00403	48 6b c0 00	 imul	 rax, rax, 0
  00407	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0040f	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 550  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00417	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0041f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 551  :             cache_lock(CACHE_DEVBUF);

  00422	33 c9		 xor	 ecx, ecx
  00424	e8 00 00 00 00	 call	 cache_lock

; 552  :             cache_setflag(CACHE_DEVBUF, dev->cache, ~FBA_CACHE_ACTIVE, 0);

  00429	45 33 c9	 xor	 r9d, r9d
  0042c	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  00432	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0043a	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00440	33 c9		 xor	 ecx, ecx
  00442	e8 00 00 00 00	 call	 cache_setflag

; 553  :             cache_unlock(CACHE_DEVBUF);

  00447	33 c9		 xor	 ecx, ecx
  00449	e8 00 00 00 00	 call	 cache_unlock

; 554  :             dev->bufupdlo = dev->bufupdhi = 0;

  0044e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00456	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  00460	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00468	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0

; 555  :             dev->bufcur = dev->cache = -1;

  00472	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0047a	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  00484	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0048c	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 556  :             return -1;

  00496	b8 ff ff ff ff	 mov	 eax, -1
  0049b	e9 ce 0b 00 00	 jmp	 $LN1@fba_dasd_r
$LN17@fba_dasd_r:

; 557  :         }
; 558  : 
; 559  :         dev->bufupdlo = dev->bufupdhi = 0;

  004a0	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004a8	c7 80 f0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+496], 0
  004b2	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ba	c7 80 ec 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+492], 0
$LN15@fba_dasd_r:

; 560  :     }
; 561  : 
; 562  :     cache_lock (CACHE_DEVBUF);

  004c4	33 c9		 xor	 ecx, ecx
  004c6	e8 00 00 00 00	 call	 cache_lock

; 563  : 
; 564  :     /* Make the previous cache entry inactive */
; 565  :     if (dev->cache >= 0)

  004cb	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004d3	83 b8 f8 01 00
	00 00		 cmp	 DWORD PTR [rax+504], 0
  004da	7c 1e		 jl	 SHORT $LN18@fba_dasd_r

; 566  :         cache_setflag(CACHE_DEVBUF, dev->cache, ~FBA_CACHE_ACTIVE, 0);

  004dc	45 33 c9	 xor	 r9d, r9d
  004df	41 b8 ff ff ff
	7f		 mov	 r8d, 2147483647		; 7fffffffH
  004e5	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004ed	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  004f3	33 c9		 xor	 ecx, ecx
  004f5	e8 00 00 00 00	 call	 cache_setflag
$LN18@fba_dasd_r:

; 567  :     dev->bufcur = dev->cache = -1;

  004fa	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00502	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  0050c	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00514	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 568  : 
; 569  :     /* Return on special case when called by the close handler */
; 570  :     if (blkgrp < 0)

  0051e	83 bc 24 48 01
	00 00 00	 cmp	 DWORD PTR blkgrp$[rsp], 0
  00526	7d 0e		 jge	 SHORT $LN19@fba_dasd_r

; 571  :     {
; 572  :         cache_unlock (CACHE_DEVBUF);

  00528	33 c9		 xor	 ecx, ecx
  0052a	e8 00 00 00 00	 call	 cache_unlock

; 573  :         return 0;

  0052f	33 c0		 xor	 eax, eax
  00531	e9 38 0b 00 00	 jmp	 $LN1@fba_dasd_r
$LN19@fba_dasd_r:
$fba_read_blkgrp_retry$55:

; 574  :     }
; 575  : 
; 576  : fba_read_blkgrp_retry:
; 577  : 
; 578  :     /* Search the cache */
; 579  :     i = cache_lookup (CACHE_DEVBUF, FBA_CACHE_SETKEY(dev->devnum, blkgrp), &o);

  00536	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0053e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00542	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00546	48 63 8c 24 48
	01 00 00	 movsxd	 rcx, DWORD PTR blkgrp$[rsp]
  0054e	48 0b c1	 or	 rax, rcx
  00551	4c 8d 44 24 70	 lea	 r8, QWORD PTR o$[rsp]
  00556	48 8b d0	 mov	 rdx, rax
  00559	33 c9		 xor	 ecx, ecx
  0055b	e8 00 00 00 00	 call	 cache_lookup
  00560	89 44 24 74	 mov	 DWORD PTR i$[rsp], eax

; 580  : 
; 581  :     /* Cache hit */
; 582  :     if (i >= 0)

  00564	83 7c 24 74 00	 cmp	 DWORD PTR i$[rsp], 0
  00569	0f 8c 46 02 00
	00		 jl	 $LN20@fba_dasd_r

; 583  :     {
; 584  :         cache_setflag(CACHE_DEVBUF, i, ~0, FBA_CACHE_ACTIVE);

  0056f	41 b9 00 00 00
	80		 mov	 r9d, -2147483648	; 80000000H
  00575	41 b8 ff ff ff
	ff		 mov	 r8d, -1			; ffffffffH
  0057b	8b 54 24 74	 mov	 edx, DWORD PTR i$[rsp]
  0057f	33 c9		 xor	 ecx, ecx
  00581	e8 00 00 00 00	 call	 cache_setflag

; 585  :         cache_setage(CACHE_DEVBUF, i);

  00586	8b 54 24 74	 mov	 edx, DWORD PTR i$[rsp]
  0058a	33 c9		 xor	 ecx, ecx
  0058c	e8 00 00 00 00	 call	 cache_setage

; 586  :         cache_unlock(CACHE_DEVBUF);

  00591	33 c9		 xor	 ecx, ecx
  00593	e8 00 00 00 00	 call	 cache_unlock

; 587  : 
; 588  :         // "%1d:%04X FBA file %s: read blkgrp %d cache hit, using cache[%d]"
; 589  :         if (dev->ccwtrace && sysblk.traceFILE)

  00598	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005a0	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005a6	c1 e8 0f	 shr	 eax, 15
  005a9	83 e0 01	 and	 eax, 1
  005ac	85 c0		 test	 eax, eax
  005ae	74 30		 je	 SHORT $LN21@fba_dasd_r
  005b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b7	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  005bf	74 1f		 je	 SHORT $LN21@fba_dasd_r

; 590  :             tf_0516( dev, blkgrp, i );

  005c1	44 8b 44 24 74	 mov	 r8d, DWORD PTR i$[rsp]
  005c6	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR blkgrp$[rsp]
  005cd	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0516
  005db	e9 e1 00 00 00	 jmp	 $LN22@fba_dasd_r
$LN21@fba_dasd_r:
$LN4@fba_dasd_r:

; 591  :         else
; 592  :             LOGDEVTR( HHC00516, "I", dev->filename, blkgrp, i );

  005e0	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005e8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  005ee	c1 e8 0f	 shr	 eax, 15
  005f1	83 e0 01	 and	 eax, 1
  005f4	85 c0		 test	 eax, eax
  005f6	0f 84 bb 00 00
	00		 je	 $LN23@fba_dasd_r
  005fc	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00604	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0060a	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv258[rsp], rax
  00612	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0061a	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0061e	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv261[rsp], ecx
  00625	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0062d	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00631	d1 fa		 sar	 edx, 1
  00633	89 94 24 ac 00
	00 00		 mov	 DWORD PTR tv265[rsp], edx
  0063a	b9 01 00 00 00	 mov	 ecx, 1
  0063f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00645	8b 4c 24 74	 mov	 ecx, DWORD PTR i$[rsp]
  00649	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  0064d	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR blkgrp$[rsp]
  00654	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00658	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv258[rsp]
  00660	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00665	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv261[rsp]
  0066c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00670	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv265[rsp]
  00677	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0067b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170097
  00682	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00687	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170098
  0068e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00693	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00698	41 b9 03 00 00
	00		 mov	 r9d, 3
  0069e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170099
  006a5	ba 50 02 00 00	 mov	 edx, 592		; 00000250H
  006aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170100
  006b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN23@fba_dasd_r:
  006b7	33 c0		 xor	 eax, eax
  006b9	85 c0		 test	 eax, eax
  006bb	0f 85 1f ff ff
	ff		 jne	 $LN4@fba_dasd_r
$LN22@fba_dasd_r:

; 593  : 
; 594  :         dev->cachehits++;

  006c1	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006c9	8b 80 fc 01 00
	00		 mov	 eax, DWORD PTR [rax+508]
  006cf	ff c0		 inc	 eax
  006d1	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  006d9	89 81 fc 01 00
	00		 mov	 DWORD PTR [rcx+508], eax

; 595  :         dev->cache = i;

  006df	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006e7	8b 4c 24 74	 mov	 ecx, DWORD PTR i$[rsp]
  006eb	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 596  :         dev->buf = cache_getbuf(CACHE_DEVBUF, dev->cache, 0);

  006f1	45 33 c0	 xor	 r8d, r8d
  006f4	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006fc	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00702	33 c9		 xor	 ecx, ecx
  00704	e8 00 00 00 00	 call	 cache_getbuf
  00709	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00711	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 597  :         dev->bufcur = blkgrp;

  00718	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00720	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR blkgrp$[rsp]
  00727	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 598  :         dev->bufoff = 0;

  0072d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00735	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 599  :         dev->bufoffhi = fba_blkgrp_len (dev, blkgrp);

  0073f	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  00747	48 8b d0	 mov	 rdx, rax
  0074a	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00752	e8 00 00 00 00	 call	 fba_blkgrp_len
  00757	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0075f	89 81 e8 01 00
	00		 mov	 DWORD PTR [rcx+488], eax

; 600  :         dev->buflen = fba_blkgrp_len (dev, blkgrp);

  00765	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  0076d	48 8b d0	 mov	 rdx, rax
  00770	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00778	e8 00 00 00 00	 call	 fba_blkgrp_len
  0077d	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00785	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 601  :         dev->bufsize = cache_getlen(CACHE_DEVBUF, dev->cache);

  0078b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00793	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00799	33 c9		 xor	 ecx, ecx
  0079b	e8 00 00 00 00	 call	 cache_getlen
  007a0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007a8	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 602  :         return 0;

  007ae	33 c0		 xor	 eax, eax
  007b0	e9 b9 08 00 00	 jmp	 $LN1@fba_dasd_r
$LN20@fba_dasd_r:

; 603  :     }
; 604  : 
; 605  :     /* Wait if no available cache entry */
; 606  :     if (o < 0)

  007b5	83 7c 24 70 00	 cmp	 DWORD PTR o$[rsp], 0
  007ba	0f 8d 46 01 00
	00		 jge	 $LN24@fba_dasd_r

; 607  :     {
; 608  :         // "%1d:%04X FBA file %s: read blkgrp %d no available cache entry, waiting"
; 609  :         if (dev->ccwtrace && sysblk.traceFILE)

  007c0	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007c8	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  007ce	c1 e8 0f	 shr	 eax, 15
  007d1	83 e0 01	 and	 eax, 1
  007d4	85 c0		 test	 eax, eax
  007d6	74 2b		 je	 SHORT $LN25@fba_dasd_r
  007d8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  007df	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  007e7	74 1a		 je	 SHORT $LN25@fba_dasd_r

; 610  :             tf_0517( dev, blkgrp );

  007e9	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR blkgrp$[rsp]
  007f0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  007f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0517
  007fe	e9 d9 00 00 00	 jmp	 $LN26@fba_dasd_r
$LN25@fba_dasd_r:
$LN7@fba_dasd_r:

; 611  :         else
; 612  :             LOGDEVTR( HHC00517, "I", dev->filename, blkgrp );

  00803	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0080b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00811	c1 e8 0f	 shr	 eax, 15
  00814	83 e0 01	 and	 eax, 1
  00817	85 c0		 test	 eax, eax
  00819	0f 84 b3 00 00
	00		 je	 $LN27@fba_dasd_r
  0081f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00827	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0082d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv319[rsp], rax
  00835	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0083d	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00841	89 8c 24 b0 00
	00 00		 mov	 DWORD PTR tv322[rsp], ecx
  00848	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00850	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00854	d1 fa		 sar	 edx, 1
  00856	89 94 24 b4 00
	00 00		 mov	 DWORD PTR tv326[rsp], edx
  0085d	b9 01 00 00 00	 mov	 ecx, 1
  00862	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00868	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR blkgrp$[rsp]
  0086f	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00873	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv319[rsp]
  0087b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00880	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv322[rsp]
  00887	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0088b	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv326[rsp]
  00892	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00896	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170105
  0089d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  008a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170106
  008a9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008ae	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008b3	41 b9 03 00 00
	00		 mov	 r9d, 3
  008b9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170107
  008c0	ba 64 02 00 00	 mov	 edx, 612		; 00000264H
  008c5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170108
  008cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN27@fba_dasd_r:
  008d2	33 c0		 xor	 eax, eax
  008d4	85 c0		 test	 eax, eax
  008d6	0f 85 27 ff ff
	ff		 jne	 $LN7@fba_dasd_r
$LN26@fba_dasd_r:

; 613  :         dev->cachewaits++;

  008dc	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008e4	8b 80 04 02 00
	00		 mov	 eax, DWORD PTR [rax+516]
  008ea	ff c0		 inc	 eax
  008ec	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008f4	89 81 04 02 00
	00		 mov	 DWORD PTR [rcx+516], eax

; 614  :         cache_wait(CACHE_DEVBUF);

  008fa	33 c9		 xor	 ecx, ecx
  008fc	e8 00 00 00 00	 call	 cache_wait

; 615  :         goto fba_read_blkgrp_retry;

  00901	e9 30 fc ff ff	 jmp	 $fba_read_blkgrp_retry$55
$LN24@fba_dasd_r:

; 616  :     }
; 617  : 
; 618  :     /* Cache miss */
; 619  :     // "%1d:%04X FBA file %s: read blkgrp %d cache miss, using cache[%d]"
; 620  :     if (dev->ccwtrace && sysblk.traceFILE)

  00906	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0090e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00914	c1 e8 0f	 shr	 eax, 15
  00917	83 e0 01	 and	 eax, 1
  0091a	85 c0		 test	 eax, eax
  0091c	74 30		 je	 SHORT $LN28@fba_dasd_r
  0091e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00925	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  0092d	74 1f		 je	 SHORT $LN28@fba_dasd_r

; 621  :         tf_0518( dev, blkgrp, o );

  0092f	44 8b 44 24 70	 mov	 r8d, DWORD PTR o$[rsp]
  00934	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR blkgrp$[rsp]
  0093b	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00943	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0518
  00949	e9 e1 00 00 00	 jmp	 $LN29@fba_dasd_r
$LN28@fba_dasd_r:
$LN10@fba_dasd_r:

; 622  :     else
; 623  :         LOGDEVTR( HHC00518, "I", dev->filename, blkgrp, o );

  0094e	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00956	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0095c	c1 e8 0f	 shr	 eax, 15
  0095f	83 e0 01	 and	 eax, 1
  00962	85 c0		 test	 eax, eax
  00964	0f 84 bb 00 00
	00		 je	 $LN30@fba_dasd_r
  0096a	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00972	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00978	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv358[rsp], rax
  00980	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00988	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  0098c	89 8c 24 b8 00
	00 00		 mov	 DWORD PTR tv361[rsp], ecx
  00993	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0099b	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  0099f	d1 fa		 sar	 edx, 1
  009a1	89 94 24 bc 00
	00 00		 mov	 DWORD PTR tv365[rsp], edx
  009a8	b9 01 00 00 00	 mov	 ecx, 1
  009ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  009b3	8b 4c 24 70	 mov	 ecx, DWORD PTR o$[rsp]
  009b7	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  009bb	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR blkgrp$[rsp]
  009c2	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  009c6	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv358[rsp]
  009ce	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  009d3	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv361[rsp]
  009da	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  009de	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv365[rsp]
  009e5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  009e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170112
  009f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  009f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170113
  009fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00a01	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00a06	41 b9 03 00 00
	00		 mov	 r9d, 3
  00a0c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170114
  00a13	ba 6f 02 00 00	 mov	 edx, 623		; 0000026fH
  00a18	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170115
  00a1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN30@fba_dasd_r:
  00a25	33 c0		 xor	 eax, eax
  00a27	85 c0		 test	 eax, eax
  00a29	0f 85 1f ff ff
	ff		 jne	 $LN10@fba_dasd_r
$LN29@fba_dasd_r:

; 624  : 
; 625  :     dev->cachemisses++;

  00a2f	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a37	8b 80 00 02 00
	00		 mov	 eax, DWORD PTR [rax+512]
  00a3d	ff c0		 inc	 eax
  00a3f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a47	89 81 00 02 00
	00		 mov	 DWORD PTR [rcx+512], eax

; 626  : 
; 627  :     /* Make this cache entry active */
; 628  :     cache_setkey (CACHE_DEVBUF, o, FBA_CACHE_SETKEY(dev->devnum, blkgrp));

  00a4d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a55	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00a59	48 c1 e0 20	 shl	 rax, 32			; 00000020H
  00a5d	48 63 8c 24 48
	01 00 00	 movsxd	 rcx, DWORD PTR blkgrp$[rsp]
  00a65	48 0b c1	 or	 rax, rcx
  00a68	4c 8b c0	 mov	 r8, rax
  00a6b	8b 54 24 70	 mov	 edx, DWORD PTR o$[rsp]
  00a6f	33 c9		 xor	 ecx, ecx
  00a71	e8 00 00 00 00	 call	 cache_setkey

; 629  :     cache_setflag(CACHE_DEVBUF, o, 0, FBA_CACHE_ACTIVE|DEVBUF_TYPE_FBA);

  00a76	41 b9 01 00 00
	80		 mov	 r9d, -2147483647	; 80000001H
  00a7c	45 33 c0	 xor	 r8d, r8d
  00a7f	8b 54 24 70	 mov	 edx, DWORD PTR o$[rsp]
  00a83	33 c9		 xor	 ecx, ecx
  00a85	e8 00 00 00 00	 call	 cache_setflag

; 630  :     cache_setage (CACHE_DEVBUF, o);

  00a8a	8b 54 24 70	 mov	 edx, DWORD PTR o$[rsp]
  00a8e	33 c9		 xor	 ecx, ecx
  00a90	e8 00 00 00 00	 call	 cache_setage

; 631  :     dev->buf = cache_getbuf(CACHE_DEVBUF, o, CFBA_BLKGRP_SIZE);

  00a95	41 b8 00 f0 00
	00		 mov	 r8d, 61440		; 0000f000H
  00a9b	8b 54 24 70	 mov	 edx, DWORD PTR o$[rsp]
  00a9f	33 c9		 xor	 ecx, ecx
  00aa1	e8 00 00 00 00	 call	 cache_getbuf
  00aa6	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00aae	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 632  :     cache_unlock (CACHE_DEVBUF);

  00ab5	33 c9		 xor	 ecx, ecx
  00ab7	e8 00 00 00 00	 call	 cache_unlock

; 633  : 
; 634  :     /* Get offset and length */
; 635  :     offset = (off_t)((S64)blkgrp * CFBA_BLKGRP_SIZE);

  00abc	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  00ac4	48 69 c0 00 f0
	00 00		 imul	 rax, rax, 61440		; 0000f000H
  00acb	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 636  :     len = fba_blkgrp_len (dev, blkgrp);

  00ad3	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  00adb	48 8b d0	 mov	 rdx, rax
  00ade	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ae6	e8 00 00 00 00	 call	 fba_blkgrp_len
  00aeb	89 84 24 a0 00
	00 00		 mov	 DWORD PTR len$[rsp], eax

; 637  : 
; 638  :     // "%1d:%04X FBA file %s: read blkgrp %d offset %"PRId64" len %d"
; 639  :     if (dev->ccwtrace && sysblk.traceFILE)

  00af2	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00afa	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b00	c1 e8 0f	 shr	 eax, 15
  00b03	83 e0 01	 and	 eax, 1
  00b06	85 c0		 test	 eax, eax
  00b08	74 4e		 je	 SHORT $LN31@fba_dasd_r
  00b0a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00b11	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00b19	74 3d		 je	 SHORT $LN31@fba_dasd_r

; 640  :         tf_0519( dev, blkgrp, offset, fba_blkgrp_len( dev, blkgrp ));

  00b1b	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  00b23	48 8b d0	 mov	 rdx, rax
  00b26	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b2e	e8 00 00 00 00	 call	 fba_blkgrp_len
  00b33	44 8b c8	 mov	 r9d, eax
  00b36	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR offset$[rsp]
  00b3e	8b 94 24 48 01
	00 00		 mov	 edx, DWORD PTR blkgrp$[rsp]
  00b45	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0519
  00b53	e9 14 01 00 00	 jmp	 $LN32@fba_dasd_r
$LN31@fba_dasd_r:
$LN13@fba_dasd_r:

; 641  :     else
; 642  :         LOGDEVTR( HHC00519, "I", dev->filename, blkgrp, offset, fba_blkgrp_len( dev, blkgrp ));

  00b58	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b60	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00b66	c1 e8 0f	 shr	 eax, 15
  00b69	83 e0 01	 and	 eax, 1
  00b6c	85 c0		 test	 eax, eax
  00b6e	0f 84 ee 00 00
	00		 je	 $LN33@fba_dasd_r
  00b74	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  00b7c	48 8b d0	 mov	 rdx, rax
  00b7f	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b87	e8 00 00 00 00	 call	 fba_blkgrp_len
  00b8c	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv425[rsp], eax
  00b93	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b9b	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00ba2	48 89 8c 24 10
	01 00 00	 mov	 QWORD PTR tv432[rsp], rcx
  00baa	48 8b 94 24 40
	01 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00bb2	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00bb6	89 94 24 c4 00
	00 00		 mov	 DWORD PTR tv435[rsp], edx
  00bbd	4c 8b 84 24 40
	01 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00bc5	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00bca	41 d1 f8	 sar	 r8d, 1
  00bcd	44 89 84 24 c8
	00 00 00	 mov	 DWORD PTR tv439[rsp], r8d
  00bd5	b9 01 00 00 00	 mov	 ecx, 1
  00bda	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00be0	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv425[rsp]
  00be7	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  00beb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR offset$[rsp]
  00bf3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00bf8	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR blkgrp$[rsp]
  00bff	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00c03	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv432[rsp]
  00c0b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c10	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv435[rsp]
  00c17	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c1b	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv439[rsp]
  00c22	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170119
  00c2d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c32	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170120
  00c39	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c3e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c43	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c49	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170121
  00c50	ba 82 02 00 00	 mov	 edx, 642		; 00000282H
  00c55	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170122
  00c5c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN33@fba_dasd_r:
  00c62	33 c0		 xor	 eax, eax
  00c64	85 c0		 test	 eax, eax
  00c66	0f 85 ec fe ff
	ff		 jne	 $LN13@fba_dasd_r
$LN32@fba_dasd_r:

; 643  : 
; 644  :     /* Seek to the block group offset */
; 645  :     offset = lseek (dev->fd, offset, SEEK_SET);

  00c6c	45 33 c0	 xor	 r8d, r8d
  00c6f	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR offset$[rsp]
  00c77	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c7f	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00c85	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  00c8b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR offset$[rsp], rax

; 646  :     if (offset < 0)

  00c93	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR offset$[rsp], 0
  00c9c	0f 8d 52 01 00
	00		 jge	 $LN34@fba_dasd_r

; 647  :     {
; 648  :         /* Handle seek error condition */
; 649  :         // "%1d:%04X FBA file %s: error in function %s: %s"
; 650  :         WRMSG( HHC00502, "E", LCSS_DEVNUM,

  00ca2	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00cab	74 15		 je	 SHORT $LN45@fba_dasd_r
  00cad	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cb5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00cb9	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv467[rsp], eax
  00cc0	eb 0b		 jmp	 SHORT $LN46@fba_dasd_r
$LN45@fba_dasd_r:
  00cc2	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv467[rsp], 0
$LN46@fba_dasd_r:
  00ccd	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00cd6	74 17		 je	 SHORT $LN47@fba_dasd_r
  00cd8	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ce0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ce4	d1 f8		 sar	 eax, 1
  00ce6	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv473[rsp], eax
  00ced	eb 0b		 jmp	 SHORT $LN48@fba_dasd_r
$LN47@fba_dasd_r:
  00cef	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv473[rsp], 0
$LN48@fba_dasd_r:
  00cfa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d00	8b 08		 mov	 ecx, DWORD PTR [rax]
  00d02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00d08	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv457[rsp], rax
  00d10	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d18	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00d1f	48 89 8c 24 20
	01 00 00	 mov	 QWORD PTR tv462[rsp], rcx
  00d27	b9 01 00 00 00	 mov	 ecx, 1
  00d2c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00d32	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv457[rsp]
  00d3a	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00d3f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170124
  00d46	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00d4b	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv462[rsp]
  00d53	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00d58	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv467[rsp]
  00d5f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00d63	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv473[rsp]
  00d6a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00d6e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170125
  00d75	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00d7a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170126
  00d81	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d86	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d8b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d91	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170127
  00d98	ba 8b 02 00 00	 mov	 edx, 651		; 0000028bH
  00d9d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170128
  00da4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 651  :                dev->filename, "lseek()", strerror( errno ));
; 652  :         dev->sense[0] = SENSE_EC;

  00daa	b8 01 00 00 00	 mov	 eax, 1
  00daf	48 6b c0 00	 imul	 rax, rax, 0
  00db3	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00dbb	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 653  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00dc3	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00dcb	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 654  :         cache_lock(CACHE_DEVBUF);

  00dce	33 c9		 xor	 ecx, ecx
  00dd0	e8 00 00 00 00	 call	 cache_lock

; 655  :         cache_release(CACHE_DEVBUF, o, 0);

  00dd5	45 33 c0	 xor	 r8d, r8d
  00dd8	8b 54 24 70	 mov	 edx, DWORD PTR o$[rsp]
  00ddc	33 c9		 xor	 ecx, ecx
  00dde	e8 00 00 00 00	 call	 cache_release

; 656  :         cache_unlock(CACHE_DEVBUF);

  00de3	33 c9		 xor	 ecx, ecx
  00de5	e8 00 00 00 00	 call	 cache_unlock

; 657  :         return -1;

  00dea	b8 ff ff ff ff	 mov	 eax, -1
  00def	e9 7a 02 00 00	 jmp	 $LN1@fba_dasd_r
$LN34@fba_dasd_r:

; 658  :     }
; 659  : 
; 660  :     /* Read the block group */
; 661  :     rc = read (dev->fd, dev->buf, len);

  00df4	44 8b 84 24 a0
	00 00 00	 mov	 r8d, DWORD PTR len$[rsp]
  00dfc	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e04	48 8b 90 c8 01
	00 00		 mov	 rdx, QWORD PTR [rax+456]
  00e0b	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e13	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00e19	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00e1f	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 662  :     if (rc < len)

  00e23	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00e2a	39 44 24 78	 cmp	 DWORD PTR rc$[rsp], eax
  00e2e	0f 8d 69 01 00
	00		 jge	 $LN35@fba_dasd_r

; 663  :     {
; 664  :         /* Handle read error condition */
; 665  :         // "%1d:%04X FBA file %s: error in function %s: %s"
; 666  :         WRMSG( HHC00502, "E", LCSS_DEVNUM,

  00e34	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00e39	7d 18		 jge	 SHORT $LN49@fba_dasd_r
  00e3b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00e41	8b 08		 mov	 ecx, DWORD PTR [rax]
  00e43	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00e49	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv503[rsp], rax
  00e51	eb 0f		 jmp	 SHORT $LN50@fba_dasd_r
$LN49@fba_dasd_r:
  00e53	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG170130
  00e5a	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR tv503[rsp], rax
$LN50@fba_dasd_r:
  00e62	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e6b	74 15		 je	 SHORT $LN51@fba_dasd_r
  00e6d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e75	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00e79	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv511[rsp], eax
  00e80	eb 0b		 jmp	 SHORT $LN52@fba_dasd_r
$LN51@fba_dasd_r:
  00e82	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv511[rsp], 0
$LN52@fba_dasd_r:
  00e8d	48 83 bc 24 40
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00e96	74 17		 je	 SHORT $LN53@fba_dasd_r
  00e98	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ea0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00ea4	d1 f8		 sar	 eax, 1
  00ea6	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv549[rsp], eax
  00ead	eb 0b		 jmp	 SHORT $LN54@fba_dasd_r
$LN53@fba_dasd_r:
  00eaf	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv549[rsp], 0
$LN54@fba_dasd_r:
  00eba	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ec2	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00ec8	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv506[rsp], rax
  00ed0	b9 01 00 00 00	 mov	 ecx, 1
  00ed5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00edb	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR tv503[rsp]
  00ee3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ee8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170131
  00eef	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00ef4	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv506[rsp]
  00efc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f01	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv511[rsp]
  00f08	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f0c	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv549[rsp]
  00f13	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f17	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170132
  00f1e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f23	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170133
  00f2a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f2f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f34	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f3a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170134
  00f41	ba 9b 02 00 00	 mov	 edx, 667		; 0000029bH
  00f46	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170135
  00f4d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 667  :                dev->filename, "read()", rc < 0 ? strerror( errno ) : "unexpected end of file" );
; 668  :         dev->sense[0] = SENSE_EC;

  00f53	b8 01 00 00 00	 mov	 eax, 1
  00f58	48 6b c0 00	 imul	 rax, rax, 0
  00f5c	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00f64	c6 84 01 64 03
	00 00 10	 mov	 BYTE PTR [rcx+rax+868], 16

; 669  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00f6c	48 8b 84 24 50
	01 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00f74	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 670  :         cache_lock(CACHE_DEVBUF);

  00f77	33 c9		 xor	 ecx, ecx
  00f79	e8 00 00 00 00	 call	 cache_lock

; 671  :         cache_release(CACHE_DEVBUF, o, 0);

  00f7e	45 33 c0	 xor	 r8d, r8d
  00f81	8b 54 24 70	 mov	 edx, DWORD PTR o$[rsp]
  00f85	33 c9		 xor	 ecx, ecx
  00f87	e8 00 00 00 00	 call	 cache_release

; 672  :         cache_unlock(CACHE_DEVBUF);

  00f8c	33 c9		 xor	 ecx, ecx
  00f8e	e8 00 00 00 00	 call	 cache_unlock

; 673  :         return -1;

  00f93	b8 ff ff ff ff	 mov	 eax, -1
  00f98	e9 d1 00 00 00	 jmp	 $LN1@fba_dasd_r
$LN35@fba_dasd_r:

; 674  :     }
; 675  : 
; 676  :     dev->cache = o;

  00f9d	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fa5	8b 4c 24 70	 mov	 ecx, DWORD PTR o$[rsp]
  00fa9	89 88 f8 01 00
	00		 mov	 DWORD PTR [rax+504], ecx

; 677  :     dev->buf = cache_getbuf(CACHE_DEVBUF, dev->cache, 0);

  00faf	45 33 c0	 xor	 r8d, r8d
  00fb2	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fba	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  00fc0	33 c9		 xor	 ecx, ecx
  00fc2	e8 00 00 00 00	 call	 cache_getbuf
  00fc7	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fcf	48 89 81 c8 01
	00 00		 mov	 QWORD PTR [rcx+456], rax

; 678  :     dev->bufcur = blkgrp;

  00fd6	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fde	8b 8c 24 48 01
	00 00		 mov	 ecx, DWORD PTR blkgrp$[rsp]
  00fe5	89 88 c0 01 00
	00		 mov	 DWORD PTR [rax+448], ecx

; 679  :     dev->bufoff = 0;

  00feb	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ff3	c7 80 e0 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+480], 0

; 680  :     dev->bufoffhi = fba_blkgrp_len (dev, blkgrp);

  00ffd	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  01005	48 8b d0	 mov	 rdx, rax
  01008	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01010	e8 00 00 00 00	 call	 fba_blkgrp_len
  01015	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0101d	89 81 e8 01 00
	00		 mov	 DWORD PTR [rcx+488], eax

; 681  :     dev->buflen = fba_blkgrp_len (dev, blkgrp);

  01023	48 63 84 24 48
	01 00 00	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  0102b	48 8b d0	 mov	 rdx, rax
  0102e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01036	e8 00 00 00 00	 call	 fba_blkgrp_len
  0103b	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01043	89 81 dc 01 00
	00		 mov	 DWORD PTR [rcx+476], eax

; 682  :     dev->bufsize = cache_getlen(CACHE_DEVBUF, dev->cache);

  01049	48 8b 84 24 40
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01051	8b 90 f8 01 00
	00		 mov	 edx, DWORD PTR [rax+504]
  01057	33 c9		 xor	 ecx, ecx
  01059	e8 00 00 00 00	 call	 cache_getlen
  0105e	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01066	89 81 d8 01 00
	00		 mov	 DWORD PTR [rcx+472], eax

; 683  : 
; 684  :     return 0;

  0106c	33 c0		 xor	 eax, eax
$LN1@fba_dasd_r:

; 685  : 
; 686  : } /* end function fba_dasd_read_blkgrp */

  0106e	48 81 c4 38 01
	00 00		 add	 rsp, 312		; 00000138H
  01075	c3		 ret	 0
fba_dasd_read_blkgrp ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
copylen$ = 48
blkgrp$ = 52
rc$ = 56
bufoff$ = 60
len$1 = 64
off$ = 68
blklen$ = 72
tv95 = 76
tv152 = 80
dev$ = 112
buf$ = 120
len$ = 128
unitstat$ = 136
fba_write PROC

; 446  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 447  : int     rc;                             /* Return code               */
; 448  : int     blkgrp;                         /* Block group number        */
; 449  : int     blklen;                         /* Length left in block group*/
; 450  : int     off;                            /* Target buffer offset      */
; 451  : int     bufoff;                         /* Source buffer offset      */
; 452  : int     copylen;                        /* Length left to copy       */
; 453  : 
; 454  :     /* Command reject if referencing outside the volume */
; 455  :     if (dev->fbarba < dev->fbaorigin * dev->fbablksiz
; 456  :      || dev->fbarba + len > dev->fbaend)

  00018	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0001d	48 63 80 8c 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4492]
  00024	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  00030	48 0f af c8	 imul	 rcx, rax
  00034	48 8b c1	 mov	 rax, rcx
  00037	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0003c	48 39 81 98 11
	00 00		 cmp	 QWORD PTR [rcx+4504], rax
  00043	72 22		 jb	 SHORT $LN5@fba_write
  00045	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0004d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00052	48 03 81 98 11
	00 00		 add	 rax, QWORD PTR [rcx+4504]
  00059	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0005e	48 3b 81 a0 11
	00 00		 cmp	 rax, QWORD PTR [rcx+4512]
  00065	76 2b		 jbe	 SHORT $LN4@fba_write
$LN5@fba_write:

; 457  :     {
; 458  :         dev->sense[0] = SENSE_CR;

  00067	b8 01 00 00 00	 mov	 eax, 1
  0006c	48 6b c0 00	 imul	 rax, rax, 0
  00070	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00075	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 459  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0007d	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00085	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 460  :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 98 01 00 00	 jmp	 $LN1@fba_write
$LN4@fba_write:

; 461  :     }
; 462  : 
; 463  :     /* Read the block group */
; 464  :     blkgrp = (int)(dev->fbarba / CFBA_BLKGRP_SIZE);

  00092	33 d2		 xor	 edx, edx
  00094	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  000a0	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  000a5	48 f7 f1	 div	 rcx
  000a8	89 44 24 34	 mov	 DWORD PTR blkgrp$[rsp], eax

; 465  :     rc = (dev->hnd->read) (dev, blkgrp, unitstat);

  000ac	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000b1	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000b8	4c 8b 84 24 88
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000c0	8b 54 24 34	 mov	 edx, DWORD PTR blkgrp$[rsp]
  000c4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  000c9	ff 50 50	 call	 QWORD PTR [rax+80]
  000cc	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax

; 466  :     if (rc < 0)

  000d0	83 7c 24 38 00	 cmp	 DWORD PTR rc$[rsp], 0
  000d5	7d 0a		 jge	 SHORT $LN6@fba_write

; 467  :         return -1;

  000d7	b8 ff ff ff ff	 mov	 eax, -1
  000dc	e9 49 01 00 00	 jmp	 $LN1@fba_write
$LN6@fba_write:

; 468  : 
; 469  :     off = dev->fbarba % CFBA_BLKGRP_SIZE;

  000e1	33 d2		 xor	 edx, edx
  000e3	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  000e8	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  000ef	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  000f4	48 f7 f1	 div	 rcx
  000f7	48 8b c2	 mov	 rax, rdx
  000fa	89 44 24 44	 mov	 DWORD PTR off$[rsp], eax

; 470  :     blklen = dev->buflen - off;

  000fe	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00103	8b 4c 24 44	 mov	 ecx, DWORD PTR off$[rsp]
  00107	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  0010d	2b c1		 sub	 eax, ecx
  0010f	89 44 24 48	 mov	 DWORD PTR blklen$[rsp], eax

; 471  : 
; 472  :     /* Initialize source buffer offset and length to copy */
; 473  :     bufoff = 0;

  00113	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR bufoff$[rsp], 0

; 474  :     copylen = len;

  0011b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00122	89 44 24 30	 mov	 DWORD PTR copylen$[rsp], eax
$LN2@fba_write:

; 475  : 
; 476  :     /* Copy to the device buffer from the target buffer */
; 477  :     while (copylen > 0)

  00126	83 7c 24 30 00	 cmp	 DWORD PTR copylen$[rsp], 0
  0012b	0f 8e d2 00 00
	00		 jle	 $LN3@fba_write

; 478  :     {
; 479  :         int len = copylen < blklen ? copylen : blklen;

  00131	8b 44 24 48	 mov	 eax, DWORD PTR blklen$[rsp]
  00135	39 44 24 30	 cmp	 DWORD PTR copylen$[rsp], eax
  00139	7d 0a		 jge	 SHORT $LN9@fba_write
  0013b	8b 44 24 30	 mov	 eax, DWORD PTR copylen$[rsp]
  0013f	89 44 24 4c	 mov	 DWORD PTR tv95[rsp], eax
  00143	eb 08		 jmp	 SHORT $LN10@fba_write
$LN9@fba_write:
  00145	8b 44 24 48	 mov	 eax, DWORD PTR blklen$[rsp]
  00149	89 44 24 4c	 mov	 DWORD PTR tv95[rsp], eax
$LN10@fba_write:
  0014d	8b 44 24 4c	 mov	 eax, DWORD PTR tv95[rsp]
  00151	89 44 24 40	 mov	 DWORD PTR len$1[rsp], eax

; 480  : 
; 481  :         /* Write to the block group */
; 482  :         rc = (dev->hnd->write) (dev, blkgrp, off, buf + bufoff,

  00155	48 63 44 24 3c	 movsxd	 rax, DWORD PTR bufoff$[rsp]
  0015a	48 8b 4c 24 78	 mov	 rcx, QWORD PTR buf$[rsp]
  0015f	48 03 c8	 add	 rcx, rax
  00162	48 8b c1	 mov	 rax, rcx
  00165	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0016a	48 8b 89 90 02
	00 00		 mov	 rcx, QWORD PTR [rcx+656]
  00171	48 89 4c 24 50	 mov	 QWORD PTR tv152[rsp], rcx
  00176	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  0017e	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00183	8b 54 24 40	 mov	 edx, DWORD PTR len$1[rsp]
  00187	89 54 24 20	 mov	 DWORD PTR [rsp+32], edx
  0018b	4c 8b c8	 mov	 r9, rax
  0018e	44 8b 44 24 44	 mov	 r8d, DWORD PTR off$[rsp]
  00193	8b 54 24 34	 mov	 edx, DWORD PTR blkgrp$[rsp]
  00197	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0019c	48 8b 44 24 50	 mov	 rax, QWORD PTR tv152[rsp]
  001a1	ff 50 58	 call	 QWORD PTR [rax+88]
  001a4	89 44 24 38	 mov	 DWORD PTR rc$[rsp], eax

; 483  :                                 len, unitstat);
; 484  :         if (rc < 0)

  001a8	83 7c 24 38 00	 cmp	 DWORD PTR rc$[rsp], 0
  001ad	7d 07		 jge	 SHORT $LN7@fba_write

; 485  :             return -1;

  001af	b8 ff ff ff ff	 mov	 eax, -1
  001b4	eb 74		 jmp	 SHORT $LN1@fba_write
$LN7@fba_write:

; 486  : 
; 487  :         /* Update offsets and lengths */
; 488  :         bufoff += len;

  001b6	8b 44 24 40	 mov	 eax, DWORD PTR len$1[rsp]
  001ba	8b 4c 24 3c	 mov	 ecx, DWORD PTR bufoff$[rsp]
  001be	03 c8		 add	 ecx, eax
  001c0	8b c1		 mov	 eax, ecx
  001c2	89 44 24 3c	 mov	 DWORD PTR bufoff$[rsp], eax

; 489  :         copylen -= len;

  001c6	8b 44 24 40	 mov	 eax, DWORD PTR len$1[rsp]
  001ca	8b 4c 24 30	 mov	 ecx, DWORD PTR copylen$[rsp]
  001ce	2b c8		 sub	 ecx, eax
  001d0	8b c1		 mov	 eax, ecx
  001d2	89 44 24 30	 mov	 DWORD PTR copylen$[rsp], eax

; 490  :         blkgrp++;

  001d6	8b 44 24 34	 mov	 eax, DWORD PTR blkgrp$[rsp]
  001da	ff c0		 inc	 eax
  001dc	89 44 24 34	 mov	 DWORD PTR blkgrp$[rsp], eax

; 491  :         off = 0;

  001e0	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR off$[rsp], 0

; 492  :         blklen = fba_blkgrp_len (dev, blkgrp);

  001e8	48 63 44 24 34	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  001ed	48 8b d0	 mov	 rdx, rax
  001f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  001f5	e8 00 00 00 00	 call	 fba_blkgrp_len
  001fa	89 44 24 48	 mov	 DWORD PTR blklen$[rsp], eax

; 493  :     }

  001fe	e9 23 ff ff ff	 jmp	 $LN2@fba_write
$LN3@fba_write:

; 494  : 
; 495  :     /* Update the rba */
; 496  :     dev->fbarba += len;

  00203	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR len$[rsp]
  0020b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00210	48 03 81 98 11
	00 00		 add	 rax, QWORD PTR [rcx+4504]
  00217	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0021c	48 89 81 98 11
	00 00		 mov	 QWORD PTR [rcx+4504], rax

; 497  : 
; 498  :     return len;

  00223	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
$LN1@fba_write:

; 499  : } /* end function fba_write */

  0022a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0022e	c3		 ret	 0
fba_write ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
offset$ = 0
dev$ = 32
blkgrp$ = 40
fba_blkgrp_len PROC

; 367  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 18	 sub	 rsp, 24

; 368  : off_t   offset;                         /* Offset of block group     */
; 369  : 
; 370  :     offset = blkgrp *          CFBA_BLKGRP_SIZE;

  0000e	48 69 44 24 28
	00 f0 00 00	 imul	 rax, QWORD PTR blkgrp$[rsp], 61440 ; 0000f000H
  00017	48 89 04 24	 mov	 QWORD PTR offset$[rsp], rax

; 371  : 
; 372  :     if (dev->fbaend - offset < CFBA_BLKGRP_SIZE)

  0001b	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  00020	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  00024	48 8b 80 a0 11
	00 00		 mov	 rax, QWORD PTR [rax+4512]
  0002b	48 2b c1	 sub	 rax, rcx
  0002e	48 3d 00 f0 00
	00		 cmp	 rax, 61440		; 0000f000H
  00034	73 17		 jae	 SHORT $LN2@fba_blkgrp

; 373  :          return (int)(dev->fbaend - offset);

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR dev$[rsp]
  0003b	48 8b 0c 24	 mov	 rcx, QWORD PTR offset$[rsp]
  0003f	48 8b 80 a0 11
	00 00		 mov	 rax, QWORD PTR [rax+4512]
  00046	48 2b c1	 sub	 rax, rcx
  00049	eb 07		 jmp	 SHORT $LN1@fba_blkgrp
  0004b	eb 05		 jmp	 SHORT $LN3@fba_blkgrp
$LN2@fba_blkgrp:

; 374  :     else
; 375  :         return                 CFBA_BLKGRP_SIZE;

  0004d	b8 00 f0 00 00	 mov	 eax, 61440		; 0000f000H
$LN3@fba_blkgrp:
$LN1@fba_blkgrp:

; 376  : }

  00052	48 83 c4 18	 add	 rsp, 24
  00056	c3		 ret	 0
fba_blkgrp_len ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
copylen$ = 32
blkgrp$ = 36
blklen$ = 40
bufoff$ = 44
off$ = 48
rc$ = 52
tv95 = 56
len$1 = 60
dev$ = 96
buf$ = 104
len$ = 112
unitstat$ = 120
fba_read PROC

; 382  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	56		 push	 rsi
  00015	57		 push	 rdi
  00016	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 383  : int     rc;                             /* Return code               */
; 384  : int     blkgrp;                         /* Block group number        */
; 385  : int     blklen;                         /* Length left in block group*/
; 386  : int     off;                            /* Device buffer offset      */
; 387  : int     bufoff;                         /* Buffer offset             */
; 388  : int     copylen;                        /* Length left to copy       */
; 389  : 
; 390  :     /* Command reject if referencing outside the volume */
; 391  :     if (dev->fbarba < dev->fbaorigin * dev->fbablksiz
; 392  :      || dev->fbarba + len > dev->fbaend)

  0001a	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  0001f	48 63 80 8c 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4492]
  00026	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  00032	48 0f af c8	 imul	 rcx, rax
  00036	48 8b c1	 mov	 rax, rcx
  00039	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0003e	48 39 81 98 11
	00 00		 cmp	 QWORD PTR [rcx+4504], rax
  00045	72 1f		 jb	 SHORT $LN5@fba_read
  00047	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  0004c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	48 03 81 98 11
	00 00		 add	 rax, QWORD PTR [rcx+4504]
  00058	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0005d	48 3b 81 a0 11
	00 00		 cmp	 rax, QWORD PTR [rcx+4512]
  00064	76 28		 jbe	 SHORT $LN4@fba_read
$LN5@fba_read:

; 393  :     {
; 394  :         dev->sense[0] = SENSE_CR;

  00066	b8 01 00 00 00	 mov	 eax, 1
  0006b	48 6b c0 00	 imul	 rax, rax, 0
  0006f	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00074	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 395  :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0007c	48 8b 44 24 78	 mov	 rax, QWORD PTR unitstat$[rsp]
  00081	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 396  :         return -1;

  00084	b8 ff ff ff ff	 mov	 eax, -1
  00089	e9 9a 01 00 00	 jmp	 $LN1@fba_read
$LN4@fba_read:

; 397  :     }
; 398  : 
; 399  :     /* Read the block group */
; 400  :     blkgrp = (int)(dev->fbarba / CFBA_BLKGRP_SIZE);

  0008e	33 d2		 xor	 edx, edx
  00090	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00095	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  0009c	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  000a1	48 f7 f1	 div	 rcx
  000a4	89 44 24 24	 mov	 DWORD PTR blkgrp$[rsp], eax

; 401  :     rc = (dev->hnd->read) (dev, blkgrp, unitstat);

  000a8	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000ad	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000b4	4c 8b 44 24 78	 mov	 r8, QWORD PTR unitstat$[rsp]
  000b9	8b 54 24 24	 mov	 edx, DWORD PTR blkgrp$[rsp]
  000bd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  000c2	ff 50 50	 call	 QWORD PTR [rax+80]
  000c5	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 402  :     if (rc < 0)

  000c9	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ce	7d 0a		 jge	 SHORT $LN6@fba_read

; 403  :         return -1;

  000d0	b8 ff ff ff ff	 mov	 eax, -1
  000d5	e9 4e 01 00 00	 jmp	 $LN1@fba_read
$LN6@fba_read:

; 404  : 
; 405  :     off = dev->fbarba % CFBA_BLKGRP_SIZE;

  000da	33 d2		 xor	 edx, edx
  000dc	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000e1	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  000e8	b9 00 f0 00 00	 mov	 ecx, 61440		; 0000f000H
  000ed	48 f7 f1	 div	 rcx
  000f0	48 8b c2	 mov	 rax, rdx
  000f3	89 44 24 30	 mov	 DWORD PTR off$[rsp], eax

; 406  :     blklen = dev->buflen - off;

  000f7	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  000fc	8b 4c 24 30	 mov	 ecx, DWORD PTR off$[rsp]
  00100	8b 80 dc 01 00
	00		 mov	 eax, DWORD PTR [rax+476]
  00106	2b c1		 sub	 eax, ecx
  00108	89 44 24 28	 mov	 DWORD PTR blklen$[rsp], eax

; 407  : 
; 408  :     /* Initialize target buffer offset and length to copy */
; 409  :     bufoff = 0;

  0010c	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR bufoff$[rsp], 0

; 410  :     copylen = len;

  00114	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
  00118	89 44 24 20	 mov	 DWORD PTR copylen$[rsp], eax
$LN2@fba_read:

; 411  : 
; 412  :     /* Copy from the device buffer to the target buffer */
; 413  :     while (copylen > 0)

  0011c	83 7c 24 20 00	 cmp	 DWORD PTR copylen$[rsp], 0
  00121	0f 8e e0 00 00
	00		 jle	 $LN3@fba_read

; 414  :     {
; 415  :         int len = copylen < blklen ? copylen : blklen;

  00127	8b 44 24 28	 mov	 eax, DWORD PTR blklen$[rsp]
  0012b	39 44 24 20	 cmp	 DWORD PTR copylen$[rsp], eax
  0012f	7d 0a		 jge	 SHORT $LN11@fba_read
  00131	8b 44 24 20	 mov	 eax, DWORD PTR copylen$[rsp]
  00135	89 44 24 38	 mov	 DWORD PTR tv95[rsp], eax
  00139	eb 08		 jmp	 SHORT $LN12@fba_read
$LN11@fba_read:
  0013b	8b 44 24 28	 mov	 eax, DWORD PTR blklen$[rsp]
  0013f	89 44 24 38	 mov	 DWORD PTR tv95[rsp], eax
$LN12@fba_read:
  00143	8b 44 24 38	 mov	 eax, DWORD PTR tv95[rsp]
  00147	89 44 24 3c	 mov	 DWORD PTR len$1[rsp], eax

; 416  : 
; 417  :         /* Copy to the target buffer */
; 418  :         if (buf) memcpy (buf + bufoff, dev->buf + off, len);

  0014b	48 83 7c 24 68
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00151	74 31		 je	 SHORT $LN7@fba_read
  00153	48 63 44 24 3c	 movsxd	 rax, DWORD PTR len$1[rsp]
  00158	48 63 4c 24 30	 movsxd	 rcx, DWORD PTR off$[rsp]
  0015d	48 8b 54 24 60	 mov	 rdx, QWORD PTR dev$[rsp]
  00162	48 03 8a c8 01
	00 00		 add	 rcx, QWORD PTR [rdx+456]
  00169	48 63 54 24 2c	 movsxd	 rdx, DWORD PTR bufoff$[rsp]
  0016e	4c 8b 44 24 68	 mov	 r8, QWORD PTR buf$[rsp]
  00173	4c 03 c2	 add	 r8, rdx
  00176	49 8b d0	 mov	 rdx, r8
  00179	48 8b fa	 mov	 rdi, rdx
  0017c	48 8b f1	 mov	 rsi, rcx
  0017f	48 8b c8	 mov	 rcx, rax
  00182	f3 a4		 rep movsb
$LN7@fba_read:

; 419  : 
; 420  :         /* Update offsets and lengths */
; 421  :         bufoff += len;

  00184	8b 44 24 3c	 mov	 eax, DWORD PTR len$1[rsp]
  00188	8b 4c 24 2c	 mov	 ecx, DWORD PTR bufoff$[rsp]
  0018c	03 c8		 add	 ecx, eax
  0018e	8b c1		 mov	 eax, ecx
  00190	89 44 24 2c	 mov	 DWORD PTR bufoff$[rsp], eax

; 422  :         copylen -= blklen;

  00194	8b 44 24 28	 mov	 eax, DWORD PTR blklen$[rsp]
  00198	8b 4c 24 20	 mov	 ecx, DWORD PTR copylen$[rsp]
  0019c	2b c8		 sub	 ecx, eax
  0019e	8b c1		 mov	 eax, ecx
  001a0	89 44 24 20	 mov	 DWORD PTR copylen$[rsp], eax

; 423  : 
; 424  :         /* Read the next block group if still more to copy */
; 425  :         if (copylen > 0)

  001a4	83 7c 24 20 00	 cmp	 DWORD PTR copylen$[rsp], 0
  001a9	7e 57		 jle	 SHORT $LN8@fba_read

; 426  :         {
; 427  :             blkgrp++;

  001ab	8b 44 24 24	 mov	 eax, DWORD PTR blkgrp$[rsp]
  001af	ff c0		 inc	 eax
  001b1	89 44 24 24	 mov	 DWORD PTR blkgrp$[rsp], eax

; 428  :             off = 0;

  001b5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR off$[rsp], 0

; 429  :             rc = (dev->hnd->read) (dev, blkgrp, unitstat);

  001bd	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  001c2	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  001c9	4c 8b 44 24 78	 mov	 r8, QWORD PTR unitstat$[rsp]
  001ce	8b 54 24 24	 mov	 edx, DWORD PTR blkgrp$[rsp]
  001d2	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001d7	ff 50 50	 call	 QWORD PTR [rax+80]
  001da	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 430  :             if (rc < 0)

  001de	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  001e3	7d 07		 jge	 SHORT $LN9@fba_read

; 431  :                 return -1;

  001e5	b8 ff ff ff ff	 mov	 eax, -1
  001ea	eb 3c		 jmp	 SHORT $LN1@fba_read
$LN9@fba_read:

; 432  :             blklen = fba_blkgrp_len (dev, blkgrp);

  001ec	48 63 44 24 24	 movsxd	 rax, DWORD PTR blkgrp$[rsp]
  001f1	48 8b d0	 mov	 rdx, rax
  001f4	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  001f9	e8 00 00 00 00	 call	 fba_blkgrp_len
  001fe	89 44 24 28	 mov	 DWORD PTR blklen$[rsp], eax
$LN8@fba_read:

; 433  :         }
; 434  :     }

  00202	e9 15 ff ff ff	 jmp	 $LN2@fba_read
$LN3@fba_read:

; 435  : 
; 436  :     /* Update the rba */
; 437  :     dev->fbarba += len;

  00207	48 63 44 24 70	 movsxd	 rax, DWORD PTR len$[rsp]
  0020c	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  00211	48 03 81 98 11
	00 00		 add	 rax, QWORD PTR [rcx+4504]
  00218	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  0021d	48 89 81 98 11
	00 00		 mov	 QWORD PTR [rcx+4504], rax

; 438  : 
; 439  :     return len;

  00224	8b 44 24 70	 mov	 eax, DWORD PTR len$[rsp]
$LN1@fba_read:

; 440  : } /* end function fba_read */

  00228	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0022c	5f		 pop	 rdi
  0022d	5e		 pop	 rsi
  0022e	c3		 ret	 0
fba_read ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
sr_value_error_ PROC

; 836  : {

  00000	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 837  :     // "SR: value error, incorrect length"
; 838  :     WRMSG(HHC02020, "E");

  00004	b9 01 00 00 00	 mov	 ecx, 1
  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168933
  00016	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0001b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168934
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0002c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168935
  00039	ba 46 03 00 00	 mov	 edx, 838		; 00000346H
  0003e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168936
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 839  : }

  0004b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0004f	c3		 ret	 0
sr_value_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_read_error_ PROC

; 824  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 825  :     // "SR: error in function '%s': '%s'"
; 826  :     WRMSG(HHC02001, "E", "read()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168921
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168922
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168923
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168924
  00062	ba 3a 03 00 00	 mov	 edx, 826		; 0000033aH
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168925
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 827  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_read_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv64 = 80
sr_write_error_ PROC

; 818  : {

  00000	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 819  :     // "SR: error in function '%s': '%s'"
; 820  :     WRMSG(HHC02001, "E", "write()", strerror(errno));

  00004	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0000a	8b 08		 mov	 ecx, DWORD PTR [rax]
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00012	48 89 44 24 50	 mov	 QWORD PTR tv64[rsp], rax
  00017	b9 01 00 00 00	 mov	 ecx, 1
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00022	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv64[rsp]
  00027	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168915
  00033	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00038	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168916
  0003f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00044	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168917
  0004b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00050	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00055	41 b9 03 00 00
	00		 mov	 r9d, 3
  0005b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG168918
  00062	ba 34 03 00 00	 mov	 edx, 820		; 00000334H
  00067	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168919
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 821  : }

  00074	48 83 c4 68	 add	 rsp, 104		; 00000068H
  00078	c3		 ret	 0
sr_write_error_ ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tot$ = 32
siz$ = 40
tv74 = 48
buf$ = 64
__$ArrayPad$ = 320
file$ = 352
len$ = 360
sr_read_skip PROC

; 677  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 58 01
	00 00		 sub	 rsp, 344		; 00000158H
  00010	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00017	48 33 c4	 xor	 rax, rsp
  0001a	48 89 84 24 40
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_sk:

; 678  : /* FIXME: Workaround for problem involving gzseek
; 679  :           and large files.  Just read the data. */
; 680  : 
; 681  : BYTE    buf[SR_SKIP_CHUNKSIZE];
; 682  : size_t  siz;
; 683  : size_t  tot;
; 684  : 
; 685  :     TRACE("SR: sr_read_skip:                  len=0x%8.8x\n", len);

  00022	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168827
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003c	85 c0		 test	 eax, eax
  0003e	74 13		 je	 SHORT $LN7@sr_read_sk
  00040	8b 94 24 68 01
	00 00		 mov	 edx, DWORD PTR len$[rsp]
  00047	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168829
  0004e	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_read_sk:
  00053	33 c0		 xor	 eax, eax
  00055	85 c0		 test	 eax, eax
  00057	75 c9		 jne	 SHORT $LN4@sr_read_sk

; 686  : 
; 687  :     tot = len;

  00059	8b 84 24 68 01
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00060	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax
$LN5@sr_read_sk:

; 688  : 
; 689  :     while (tot)

  00065	48 83 7c 24 20
	00		 cmp	 QWORD PTR tot$[rsp], 0
  0006b	74 71		 je	 SHORT $LN6@sr_read_sk

; 690  :     {
; 691  :         siz = tot < SR_SKIP_CHUNKSIZE ? tot : SR_SKIP_CHUNKSIZE;

  0006d	48 81 7c 24 20
	00 01 00 00	 cmp	 QWORD PTR tot$[rsp], 256 ; 00000100H
  00076	73 0c		 jae	 SHORT $LN10@sr_read_sk
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR tot$[rsp]
  0007d	48 89 44 24 30	 mov	 QWORD PTR tv74[rsp], rax
  00082	eb 09		 jmp	 SHORT $LN11@sr_read_sk
$LN10@sr_read_sk:
  00084	48 c7 44 24 30
	00 01 00 00	 mov	 QWORD PTR tv74[rsp], 256 ; 00000100H
$LN11@sr_read_sk:
  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR tv74[rsp]
  00092	48 89 44 24 28	 mov	 QWORD PTR siz$[rsp], rax

; 692  : 
; 693  :         if ((size_t)SR_READ(buf, 1, siz, file) != siz)

  00097	4c 8b 8c 24 60
	01 00 00	 mov	 r9, QWORD PTR file$[rsp]
  0009f	4c 8b 44 24 28	 mov	 r8, QWORD PTR siz$[rsp]
  000a4	ba 01 00 00 00	 mov	 edx, 1
  000a9	48 8d 4c 24 40	 lea	 rcx, QWORD PTR buf$[rsp]
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000b4	48 3b 44 24 28	 cmp	 rax, QWORD PTR siz$[rsp]
  000b9	74 0c		 je	 SHORT $LN8@sr_read_sk

; 694  :         {
; 695  :             sr_read_error_();

  000bb	e8 00 00 00 00	 call	 sr_read_error_

; 696  :             return -1;

  000c0	b8 ff ff ff ff	 mov	 eax, -1
  000c5	eb 19		 jmp	 SHORT $LN1@sr_read_sk
$LN8@sr_read_sk:

; 697  :         }
; 698  :         tot -= siz;

  000c7	48 8b 44 24 28	 mov	 rax, QWORD PTR siz$[rsp]
  000cc	48 8b 4c 24 20	 mov	 rcx, QWORD PTR tot$[rsp]
  000d1	48 2b c8	 sub	 rcx, rax
  000d4	48 8b c1	 mov	 rax, rcx
  000d7	48 89 44 24 20	 mov	 QWORD PTR tot$[rsp], rax

; 699  :     }

  000dc	eb 87		 jmp	 SHORT $LN5@sr_read_sk
$LN6@sr_read_sk:

; 700  :     return 0;

  000de	33 c0		 xor	 eax, eax
$LN1@sr_read_sk:

; 701  : }

  000e0	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000e8	48 33 cc	 xor	 rcx, rsp
  000eb	e8 00 00 00 00	 call	 __security_check_cookie
  000f0	48 81 c4 58 01
	00 00		 add	 rsp, 344		; 00000158H
  000f7	c3		 ret	 0
sr_read_skip ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
value$ = 32
tv85 = 40
tv146 = 44
ptr$1 = 48
ptr$2 = 56
ptr$3 = 64
ptr$4 = 72
buf$ = 80
__$ArrayPad$ = 88
file$ = 112
suslen$ = 120
p$ = 128
reslen$ = 136
sr_read_value PROC

; 754  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 68	 sub	 rsp, 104		; 00000068H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 58	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_read_va:

; 755  : BYTE    buf[8];
; 756  : U64     value;
; 757  : 
; 758  :     TRACE("SR: sr_read_value:              suslen=0x%8.8x, reslen=0x%8.8x,\n", suslen, reslen);

  00026	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  0002e	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00032	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168897
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00045	85 c0		 test	 eax, eax
  00047	74 18		 je	 SHORT $LN12@sr_read_va
  00049	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR reslen$[rsp]
  00051	8b 54 24 78	 mov	 edx, DWORD PTR suslen$[rsp]
  00055	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168899
  0005c	e8 00 00 00 00	 call	 DebuggerTrace
$LN12@sr_read_va:
  00061	33 c0		 xor	 eax, eax
  00063	85 c0		 test	 eax, eax
  00065	75 bf		 jne	 SHORT $LN4@sr_read_va

; 759  : 
; 760  :     if (suslen != 1 && suslen != 2 && suslen != 4 && suslen != 8)

  00067	83 7c 24 78 01	 cmp	 DWORD PTR suslen$[rsp], 1
  0006c	74 24		 je	 SHORT $LN13@sr_read_va
  0006e	83 7c 24 78 02	 cmp	 DWORD PTR suslen$[rsp], 2
  00073	74 1d		 je	 SHORT $LN13@sr_read_va
  00075	83 7c 24 78 04	 cmp	 DWORD PTR suslen$[rsp], 4
  0007a	74 16		 je	 SHORT $LN13@sr_read_va
  0007c	83 7c 24 78 08	 cmp	 DWORD PTR suslen$[rsp], 8
  00081	74 0f		 je	 SHORT $LN13@sr_read_va

; 761  :     {
; 762  :         sr_value_error_();

  00083	e8 00 00 00 00	 call	 sr_value_error_

; 763  :         return -1;

  00088	b8 ff ff ff ff	 mov	 eax, -1
  0008d	e9 a8 01 00 00	 jmp	 $LN1@sr_read_va
$LN13@sr_read_va:

; 764  :     }
; 765  : 
; 766  :     if ((U32)SR_READ(buf, 1, suslen, file) != suslen)

  00092	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  00096	4c 8b 4c 24 70	 mov	 r9, QWORD PTR file$[rsp]
  0009b	44 8b c0	 mov	 r8d, eax
  0009e	ba 01 00 00 00	 mov	 edx, 1
  000a3	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  000ae	3b 44 24 78	 cmp	 eax, DWORD PTR suslen$[rsp]
  000b2	74 0f		 je	 SHORT $LN14@sr_read_va

; 767  :     {
; 768  :         sr_read_error_();

  000b4	e8 00 00 00 00	 call	 sr_read_error_

; 769  :         return -1;

  000b9	b8 ff ff ff ff	 mov	 eax, -1
  000be	e9 77 01 00 00	 jmp	 $LN1@sr_read_va
$LN14@sr_read_va:

; 770  :     }
; 771  : 
; 772  :     switch (suslen)

  000c3	8b 44 24 78	 mov	 eax, DWORD PTR suslen$[rsp]
  000c7	89 44 24 28	 mov	 DWORD PTR tv85[rsp], eax
  000cb	83 7c 24 28 01	 cmp	 DWORD PTR tv85[rsp], 1
  000d0	74 17		 je	 SHORT $LN15@sr_read_va
  000d2	83 7c 24 28 02	 cmp	 DWORD PTR tv85[rsp], 2
  000d7	74 25		 je	 SHORT $LN16@sr_read_va
  000d9	83 7c 24 28 04	 cmp	 DWORD PTR tv85[rsp], 4
  000de	74 3a		 je	 SHORT $LN17@sr_read_va
  000e0	83 7c 24 28 08	 cmp	 DWORD PTR tv85[rsp], 8
  000e5	74 4d		 je	 SHORT $LN18@sr_read_va
  000e7	eb 64		 jmp	 SHORT $LN19@sr_read_va
$LN15@sr_read_va:

; 773  :     {
; 774  :         case 1:  value = buf[0];         break;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	48 6b c0 00	 imul	 rax, rax, 0
  000f2	0f b6 44 04 50	 movzx	 eax, BYTE PTR buf$[rsp+rax]
  000f7	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  000fc	eb 58		 jmp	 SHORT $LN5@sr_read_va
$LN16@sr_read_va:

; 775  :         case 2:  value = fetch_hw (buf); break;

  000fe	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 fetch_hw_noswap
  00108	0f b7 c8	 movzx	 ecx, ax
  0010b	e8 00 00 00 00	 call	 _byteswap_ushort
  00110	0f b7 c0	 movzx	 eax, ax
  00113	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00118	eb 3c		 jmp	 SHORT $LN5@sr_read_va
$LN17@sr_read_va:

; 776  :         case 4:  value = fetch_fw (buf); break;

  0011a	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  0011f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00124	8b c8		 mov	 ecx, eax
  00126	e8 00 00 00 00	 call	 _byteswap_ulong
  0012b	8b c0		 mov	 eax, eax
  0012d	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  00132	eb 22		 jmp	 SHORT $LN5@sr_read_va
$LN18@sr_read_va:

; 777  :         case 8:  value = fetch_dw (buf); break;

  00134	48 8d 4c 24 50	 lea	 rcx, QWORD PTR buf$[rsp]
  00139	e8 00 00 00 00	 call	 fetch_dw_noswap
  0013e	48 8b c8	 mov	 rcx, rax
  00141	e8 00 00 00 00	 call	 _byteswap_uint64
  00146	48 89 44 24 20	 mov	 QWORD PTR value$[rsp], rax
  0014b	eb 09		 jmp	 SHORT $LN5@sr_read_va
$LN19@sr_read_va:

; 778  :         default: value = 0;              break; /* To ward off gcc -Wall */

  0014d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR value$[rsp], 0
$LN5@sr_read_va:
$LN9@sr_read_va:

; 779  :     }
; 780  : 
; 781  :     TRACE("                           val=0x%16.16"PRIx64"\n", value);

  00156	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  0015b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168907
  00162	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00168	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0016e	85 c0		 test	 eax, eax
  00170	74 11		 je	 SHORT $LN20@sr_read_va
  00172	48 8b 54 24 20	 mov	 rdx, QWORD PTR value$[rsp]
  00177	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168909
  0017e	e8 00 00 00 00	 call	 DebuggerTrace
$LN20@sr_read_va:
  00183	33 c0		 xor	 eax, eax
  00185	85 c0		 test	 eax, eax
  00187	75 cd		 jne	 SHORT $LN9@sr_read_va

; 782  : 
; 783  :     switch (reslen)

  00189	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR reslen$[rsp]
  00190	89 44 24 2c	 mov	 DWORD PTR tv146[rsp], eax
  00194	83 7c 24 2c 01	 cmp	 DWORD PTR tv146[rsp], 1
  00199	74 1a		 je	 SHORT $LN21@sr_read_va
  0019b	83 7c 24 2c 02	 cmp	 DWORD PTR tv146[rsp], 2
  001a0	74 34		 je	 SHORT $LN22@sr_read_va
  001a2	83 7c 24 2c 04	 cmp	 DWORD PTR tv146[rsp], 4
  001a7	74 4f		 je	 SHORT $LN23@sr_read_va
  001a9	83 7c 24 2c 08	 cmp	 DWORD PTR tv146[rsp], 8
  001ae	74 6e		 je	 SHORT $LN24@sr_read_va
  001b0	e9 83 00 00 00	 jmp	 $LN10@sr_read_va
$LN21@sr_read_va:

; 784  :     {
; 785  :         case 1:
; 786  :         {
; 787  :             BYTE* ptr = p;

  001b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001bd	48 89 44 24 30	 mov	 QWORD PTR ptr$1[rsp], rax

; 788  :             *ptr = (BYTE)(value & 0xFF);

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001c7	48 25 ff 00 00
	00		 and	 rax, 255		; 000000ffH
  001cd	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ptr$1[rsp]
  001d2	88 01		 mov	 BYTE PTR [rcx], al

; 789  :             break;

  001d4	eb 62		 jmp	 SHORT $LN10@sr_read_va
$LN22@sr_read_va:

; 790  :         }
; 791  :         case 2:
; 792  :         {
; 793  :             U16* ptr = p;

  001d6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  001de	48 89 44 24 38	 mov	 QWORD PTR ptr$2[rsp], rax

; 794  :             *ptr = (U16)(value & 0xFFFF);

  001e3	48 8b 44 24 20	 mov	 rax, QWORD PTR value$[rsp]
  001e8	48 25 ff ff 00
	00		 and	 rax, 65535		; 0000ffffH
  001ee	48 8b 4c 24 38	 mov	 rcx, QWORD PTR ptr$2[rsp]
  001f3	66 89 01	 mov	 WORD PTR [rcx], ax

; 795  :             break;

  001f6	eb 40		 jmp	 SHORT $LN10@sr_read_va
$LN23@sr_read_va:

; 796  :         }
; 797  :         case 4:
; 798  :         {
; 799  :             U32* ptr = p;

  001f8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00200	48 89 44 24 40	 mov	 QWORD PTR ptr$3[rsp], rax

; 800  :             *ptr = (U32)(value & 0xFFFFFFFF);

  00205	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  0020a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  0020f	48 23 c8	 and	 rcx, rax
  00212	48 8b c1	 mov	 rax, rcx
  00215	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ptr$3[rsp]
  0021a	89 01		 mov	 DWORD PTR [rcx], eax

; 801  :             break;

  0021c	eb 1a		 jmp	 SHORT $LN10@sr_read_va
$LN24@sr_read_va:

; 802  :         }
; 803  :         case 8:
; 804  :         {
; 805  :             U64* ptr = p;

  0021e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR p$[rsp]
  00226	48 89 44 24 48	 mov	 QWORD PTR ptr$4[rsp], rax

; 806  :             *ptr = (U64)(value & 0xFFFFFFFFFFFFFFFFULL);

  0022b	48 8b 44 24 48	 mov	 rax, QWORD PTR ptr$4[rsp]
  00230	48 8b 4c 24 20	 mov	 rcx, QWORD PTR value$[rsp]
  00235	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN10@sr_read_va:

; 807  :             break;
; 808  :         }
; 809  :     }
; 810  :     return 0;

  00238	33 c0		 xor	 eax, eax
$LN1@sr_read_va:

; 811  : }

  0023a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0023f	48 33 cc	 xor	 rcx, rsp
  00242	e8 00 00 00 00	 call	 __security_check_cookie
  00247	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0024b	c3		 ret	 0
sr_read_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_read_hdr PROC

; 656  : {

  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001a	48 33 c4	 xor	 rax, rsp
  0001d	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : BYTE  buf[8];
; 658  : 
; 659  :     if (SR_READ(buf, 1, 8, file) != 8)

  00022	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  00027	41 b8 08 00 00
	00		 mov	 r8d, 8
  0002d	ba 01 00 00 00	 mov	 edx, 1
  00032	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0003d	48 83 f8 08	 cmp	 rax, 8
  00041	74 0c		 je	 SHORT $LN5@sr_read_hd

; 660  :     {
; 661  :         sr_read_error_();

  00043	e8 00 00 00 00	 call	 sr_read_error_

; 662  :         return -1;

  00048	b8 ff ff ff ff	 mov	 eax, -1
  0004d	eb 7c		 jmp	 SHORT $LN1@sr_read_hd
$LN5@sr_read_hd:

; 663  :     }
; 664  : 
; 665  :     *key = fetch_fw (buf);

  0004f	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  00054	e8 00 00 00 00	 call	 fetch_fw_noswap
  00059	8b c8		 mov	 ecx, eax
  0005b	e8 00 00 00 00	 call	 _byteswap_ulong
  00060	48 8b 4c 24 48	 mov	 rcx, QWORD PTR key$[rsp]
  00065	89 01		 mov	 DWORD PTR [rcx], eax

; 666  :     *len = fetch_fw (buf+4);

  00067	48 8d 44 24 24	 lea	 rax, QWORD PTR buf$[rsp+4]
  0006c	48 8b c8	 mov	 rcx, rax
  0006f	e8 00 00 00 00	 call	 fetch_fw_noswap
  00074	8b c8		 mov	 ecx, eax
  00076	e8 00 00 00 00	 call	 _byteswap_ulong
  0007b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR len$[rsp]
  00080	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@sr_read_hd:

; 667  : 
; 668  :     TRACE("SR: sr_read_hdr:   key=0x%8.8x, len=0x%8.8x\n", *key, *len);

  00082	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  00087	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  0008a	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  0008f	8b 10		 mov	 edx, DWORD PTR [rax]
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168810
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000a4	85 c0		 test	 eax, eax
  000a6	74 1b		 je	 SHORT $LN6@sr_read_hd
  000a8	48 8b 44 24 50	 mov	 rax, QWORD PTR len$[rsp]
  000ad	44 8b 00	 mov	 r8d, DWORD PTR [rax]
  000b0	48 8b 44 24 48	 mov	 rax, QWORD PTR key$[rsp]
  000b5	8b 10		 mov	 edx, DWORD PTR [rax]
  000b7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168812
  000be	e8 00 00 00 00	 call	 DebuggerTrace
$LN6@sr_read_hd:
  000c3	33 c0		 xor	 eax, eax
  000c5	85 c0		 test	 eax, eax
  000c7	75 b9		 jne	 SHORT $LN4@sr_read_hd

; 669  : 
; 670  :     return 0;

  000c9	33 c0		 xor	 eax, eax
$LN1@sr_read_hd:

; 671  : }

  000cb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000d0	48 33 cc	 xor	 rcx, rsp
  000d3	e8 00 00 00 00	 call	 __security_check_cookie
  000d8	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000dc	c3		 ret	 0
sr_read_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
tv84 = 32
buf$ = 40
__$ArrayPad$ = 48
file$ = 80
key$ = 88
val$ = 96
len$ = 104
sr_write_value PROC

; 622  : {

  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_v:

; 623  : BYTE    buf[8];
; 624  : 
; 625  :     TRACE("SR: sr_write_value:  key=0x%8.8x, len=0x%8.8x, val=0x%16.16"PRIx64"\n", key, len, val);

  00026	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  0002b	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00030	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00034	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168788
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00047	85 c0		 test	 eax, eax
  00049	74 1a		 je	 SHORT $LN7@sr_write_v
  0004b	4c 8b 4c 24 60	 mov	 r9, QWORD PTR val$[rsp]
  00050	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  00055	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  00059	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168790
  00060	e8 00 00 00 00	 call	 DebuggerTrace
$LN7@sr_write_v:
  00065	33 c0		 xor	 eax, eax
  00067	85 c0		 test	 eax, eax
  00069	75 bb		 jne	 SHORT $LN4@sr_write_v

; 626  : 
; 627  :     if (len != 1 && len != 2 && len != 4 && len != 8)

  0006b	83 7c 24 68 01	 cmp	 DWORD PTR len$[rsp], 1
  00070	74 24		 je	 SHORT $LN8@sr_write_v
  00072	83 7c 24 68 02	 cmp	 DWORD PTR len$[rsp], 2
  00077	74 1d		 je	 SHORT $LN8@sr_write_v
  00079	83 7c 24 68 04	 cmp	 DWORD PTR len$[rsp], 4
  0007e	74 16		 je	 SHORT $LN8@sr_write_v
  00080	83 7c 24 68 08	 cmp	 DWORD PTR len$[rsp], 8
  00085	74 0f		 je	 SHORT $LN8@sr_write_v

; 628  :     {
; 629  :         sr_value_error_();

  00087	e8 00 00 00 00	 call	 sr_value_error_

; 630  :         return -1;

  0008c	b8 ff ff ff ff	 mov	 eax, -1
  00091	e9 d2 00 00 00	 jmp	 $LN1@sr_write_v
$LN8@sr_write_v:

; 631  :     }
; 632  : 
; 633  :     if (sr_write_hdr(file, key, len) != 0)

  00096	44 8b 44 24 68	 mov	 r8d, DWORD PTR len$[rsp]
  0009b	8b 54 24 58	 mov	 edx, DWORD PTR key$[rsp]
  0009f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR file$[rsp]
  000a4	e8 00 00 00 00	 call	 sr_write_hdr
  000a9	85 c0		 test	 eax, eax
  000ab	74 0a		 je	 SHORT $LN9@sr_write_v

; 634  :         return -1;

  000ad	b8 ff ff ff ff	 mov	 eax, -1
  000b2	e9 b1 00 00 00	 jmp	 $LN1@sr_write_v
$LN9@sr_write_v:

; 635  : 
; 636  :     switch (len)

  000b7	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  000bb	89 44 24 20	 mov	 DWORD PTR tv84[rsp], eax
  000bf	83 7c 24 20 01	 cmp	 DWORD PTR tv84[rsp], 1
  000c4	74 17		 je	 SHORT $LN10@sr_write_v
  000c6	83 7c 24 20 02	 cmp	 DWORD PTR tv84[rsp], 2
  000cb	74 24		 je	 SHORT $LN11@sr_write_v
  000cd	83 7c 24 20 04	 cmp	 DWORD PTR tv84[rsp], 4
  000d2	74 36		 je	 SHORT $LN12@sr_write_v
  000d4	83 7c 24 20 08	 cmp	 DWORD PTR tv84[rsp], 8
  000d9	74 46		 je	 SHORT $LN13@sr_write_v
  000db	eb 5b		 jmp	 SHORT $LN5@sr_write_v
$LN10@sr_write_v:

; 637  :     {
; 638  :         case 1: buf[0]     =  (BYTE)val;  break;

  000dd	b8 01 00 00 00	 mov	 eax, 1
  000e2	48 6b c0 00	 imul	 rax, rax, 0
  000e6	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR val$[rsp]
  000eb	88 4c 04 28	 mov	 BYTE PTR buf$[rsp+rax], cl
  000ef	eb 47		 jmp	 SHORT $LN5@sr_write_v
$LN11@sr_write_v:

; 639  :         case 2: store_hw (buf, (U16)val); break;

  000f1	0f b7 4c 24 60	 movzx	 ecx, WORD PTR val$[rsp]
  000f6	e8 00 00 00 00	 call	 _byteswap_ushort
  000fb	0f b7 d0	 movzx	 edx, ax
  000fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00103	e8 00 00 00 00	 call	 store_hw_noswap
  00108	eb 2e		 jmp	 SHORT $LN5@sr_write_v
$LN12@sr_write_v:

; 640  :         case 4: store_fw (buf, (U32)val); break;

  0010a	8b 4c 24 60	 mov	 ecx, DWORD PTR val$[rsp]
  0010e	e8 00 00 00 00	 call	 _byteswap_ulong
  00113	8b d0		 mov	 edx, eax
  00115	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0011a	e8 00 00 00 00	 call	 store_fw_noswap
  0011f	eb 17		 jmp	 SHORT $LN5@sr_write_v
$LN13@sr_write_v:

; 641  :         case 8: store_dw (buf, (U64)val); break;

  00121	48 8b 4c 24 60	 mov	 rcx, QWORD PTR val$[rsp]
  00126	e8 00 00 00 00	 call	 _byteswap_uint64
  0012b	48 8b d0	 mov	 rdx, rax
  0012e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  00133	e8 00 00 00 00	 call	 store_dw_noswap
$LN5@sr_write_v:

; 642  :     }
; 643  : 
; 644  :     if ((U32)SR_WRITE(buf, 1, len, file) != len)

  00138	8b 44 24 68	 mov	 eax, DWORD PTR len$[rsp]
  0013c	4c 8b 4c 24 50	 mov	 r9, QWORD PTR file$[rsp]
  00141	44 8b c0	 mov	 r8d, eax
  00144	ba 01 00 00 00	 mov	 edx, 1
  00149	48 8d 4c 24 28	 lea	 rcx, QWORD PTR buf$[rsp]
  0014e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  00154	3b 44 24 68	 cmp	 eax, DWORD PTR len$[rsp]
  00158	74 0c		 je	 SHORT $LN14@sr_write_v

; 645  :     {
; 646  :         sr_write_error_();

  0015a	e8 00 00 00 00	 call	 sr_write_error_

; 647  :         return -1;

  0015f	b8 ff ff ff ff	 mov	 eax, -1
  00164	eb 02		 jmp	 SHORT $LN1@sr_write_v
$LN14@sr_write_v:

; 648  :     }
; 649  :     return 0;

  00166	33 c0		 xor	 eax, eax
$LN1@sr_write_v:

; 650  : }

  00168	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0016d	48 33 cc	 xor	 rcx, rsp
  00170	e8 00 00 00 00	 call	 __security_check_cookie
  00175	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00179	c3		 ret	 0
sr_write_value ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\sr.h
_TEXT	SEGMENT
buf$ = 32
__$ArrayPad$ = 40
file$ = 64
key$ = 72
len$ = 80
sr_write_hdr PROC

; 546  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00019	48 33 c4	 xor	 rax, rsp
  0001c	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
$LN4@sr_write_h:

; 547  : BYTE  buf[8];
; 548  : 
; 549  :     TRACE("SR: sr_write_hdr:    key=0x%8.8x, len=0x%8.8x\n", key, len);

  00021	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00026	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168722
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0003d	85 c0		 test	 eax, eax
  0003f	74 15		 je	 SHORT $LN5@sr_write_h
  00041	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00046	8b 54 24 48	 mov	 edx, DWORD PTR key$[rsp]
  0004a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG168724
  00051	e8 00 00 00 00	 call	 DebuggerTrace
$LN5@sr_write_h:
  00056	33 c0		 xor	 eax, eax
  00058	85 c0		 test	 eax, eax
  0005a	75 c5		 jne	 SHORT $LN4@sr_write_h

; 550  : 
; 551  :     store_fw (buf, key);

  0005c	8b 4c 24 48	 mov	 ecx, DWORD PTR key$[rsp]
  00060	e8 00 00 00 00	 call	 _byteswap_ulong
  00065	8b d0		 mov	 edx, eax
  00067	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0006c	e8 00 00 00 00	 call	 store_fw_noswap

; 552  :     store_fw (buf+4, len);

  00071	8b 4c 24 50	 mov	 ecx, DWORD PTR len$[rsp]
  00075	e8 00 00 00 00	 call	 _byteswap_ulong
  0007a	48 8d 4c 24 24	 lea	 rcx, QWORD PTR buf$[rsp+4]
  0007f	8b d0		 mov	 edx, eax
  00081	e8 00 00 00 00	 call	 store_fw_noswap

; 553  : 
; 554  :     if (SR_WRITE(buf, 1, 8, file) != 8)

  00086	4c 8b 4c 24 40	 mov	 r9, QWORD PTR file$[rsp]
  0008b	41 b8 08 00 00
	00		 mov	 r8d, 8
  00091	ba 01 00 00 00	 mov	 edx, 1
  00096	48 8d 4c 24 20	 lea	 rcx, QWORD PTR buf$[rsp]
  0009b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fwrite
  000a1	48 83 f8 08	 cmp	 rax, 8
  000a5	74 0c		 je	 SHORT $LN6@sr_write_h

; 555  :     {
; 556  :         sr_write_error_();

  000a7	e8 00 00 00 00	 call	 sr_write_error_

; 557  :         return -1;

  000ac	b8 ff ff ff ff	 mov	 eax, -1
  000b1	eb 02		 jmp	 SHORT $LN1@sr_write_h
$LN6@sr_write_h:

; 558  :     }
; 559  :     return 0;

  000b3	33 c0		 xor	 eax, eax
$LN1@sr_write_h:

; 560  : }

  000b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000ba	48 33 cc	 xor	 rcx, rsp
  000bd	e8 00 00 00 00	 call	 __security_check_cookie
  000c2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c6	c3		 ret	 0
sr_write_hdr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
rc$ = 96
len$ = 104
byte$ = 112
tv89 = 116
tv149 = 120
tv155 = 124
tv183 = 128
tv189 = 132
tv273 = 136
tv279 = 140
tv72 = 144
k$1 = 152
l$2 = 156
key$ = 160
tv144 = 168
tv178 = 176
tv268 = 184
dev$ = 208
file$ = 216
fba_dasd_hresume PROC

; 1513 : {

$LN111:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
$LN4@fba_dasd_h:
$LN7@fba_dasd_h:

; 1514 : int     rc;
; 1515 : size_t  key, len;
; 1516 : BYTE byte;
; 1517 : 
; 1518 :     do {
; 1519 :         SR_READ_HDR(file, key, len);

  00011	4c 8d 84 24 9c
	00 00 00	 lea	 r8, QWORD PTR l$2[rsp]
  00019	48 8d 94 24 98
	00 00 00	 lea	 rdx, QWORD PTR k$1[rsp]
  00021	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00029	e8 00 00 00 00	 call	 sr_read_hdr
  0002e	85 c0		 test	 eax, eax
  00030	74 0a		 je	 SHORT $LN58@fba_dasd_h
  00032	b8 ff ff ff ff	 mov	 eax, -1
  00037	e9 fb 07 00 00	 jmp	 $LN1@fba_dasd_h
$LN58@fba_dasd_h:
  0003c	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR k$1[rsp]
  00043	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR key$[rsp], rax
  0004b	8b 84 24 9c 00
	00 00		 mov	 eax, DWORD PTR l$2[rsp]
  00052	48 89 44 24 68	 mov	 QWORD PTR len$[rsp], rax
  00057	33 c0		 xor	 eax, eax
  00059	85 c0		 test	 eax, eax
  0005b	75 b4		 jne	 SHORT $LN7@fba_dasd_h

; 1520 :         switch (key) {

  0005d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR key$[rsp]
  00065	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv72[rsp], rax
  0006d	b8 01 20 e3 ac	 mov	 eax, -1394401279	; ace32001H
  00072	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv72[rsp]
  0007a	48 2b c8	 sub	 rcx, rax
  0007d	48 8b c1	 mov	 rax, rcx
  00080	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv72[rsp], rax
  00088	48 83 bc 24 90
	00 00 00 0e	 cmp	 QWORD PTR tv72[rsp], 14
  00091	0f 87 5b 07 00
	00		 ja	 $LN93@fba_dasd_h
  00097	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  0009e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv72[rsp]
  000a6	8b 8c 88 00 00
	00 00		 mov	 ecx, DWORD PTR $LN110@fba_dasd_h[rax+rcx*4]
  000ad	48 03 c8	 add	 rcx, rax
  000b0	ff e1		 jmp	 rcx
$LN59@fba_dasd_h:
$LN12@fba_dasd_h:

; 1521 :         case SR_DEV_FBA_BUFCUR:
; 1522 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  000b2	41 b9 04 00 00
	00		 mov	 r9d, 4
  000b8	4c 8d 44 24 60	 lea	 r8, QWORD PTR rc$[rsp]
  000bd	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  000c1	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  000c9	e8 00 00 00 00	 call	 sr_read_value
  000ce	85 c0		 test	 eax, eax
  000d0	74 0a		 je	 SHORT $LN60@fba_dasd_h
  000d2	b8 ff ff ff ff	 mov	 eax, -1
  000d7	e9 5b 07 00 00	 jmp	 $LN1@fba_dasd_h
$LN60@fba_dasd_h:
  000dc	33 c0		 xor	 eax, eax
  000de	85 c0		 test	 eax, eax
  000e0	75 d0		 jne	 SHORT $LN12@fba_dasd_h

; 1523 :             rc = (dev->hnd->read) ? (dev->hnd->read)(dev, rc, &byte) : -1;

  000e2	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ea	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  000f1	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  000f6	74 29		 je	 SHORT $LN96@fba_dasd_h
  000f8	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00100	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00107	4c 8d 44 24 70	 lea	 r8, QWORD PTR byte$[rsp]
  0010c	8b 54 24 60	 mov	 edx, DWORD PTR rc$[rsp]
  00110	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00118	ff 50 50	 call	 QWORD PTR [rax+80]
  0011b	89 44 24 74	 mov	 DWORD PTR tv89[rsp], eax
  0011f	eb 08		 jmp	 SHORT $LN97@fba_dasd_h
$LN96@fba_dasd_h:
  00121	c7 44 24 74 ff
	ff ff ff	 mov	 DWORD PTR tv89[rsp], -1
$LN97@fba_dasd_h:
  00129	8b 44 24 74	 mov	 eax, DWORD PTR tv89[rsp]
  0012d	89 44 24 60	 mov	 DWORD PTR rc$[rsp], eax

; 1524 :             if ((int)rc < 0) return -1;

  00131	83 7c 24 60 00	 cmp	 DWORD PTR rc$[rsp], 0
  00136	7d 0a		 jge	 SHORT $LN61@fba_dasd_h
  00138	b8 ff ff ff ff	 mov	 eax, -1
  0013d	e9 f5 06 00 00	 jmp	 $LN1@fba_dasd_h
$LN61@fba_dasd_h:

; 1525 :             break;

  00142	e9 cd 06 00 00	 jmp	 $LN8@fba_dasd_h
$LN62@fba_dasd_h:
$LN15@fba_dasd_h:

; 1526 :         case SR_DEV_FBA_BUFOFF:
; 1527 :             SR_READ_VALUE(file, len, &dev->bufoff, sizeof(dev->bufoff));

  00147	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0014f	48 05 e0 01 00
	00		 add	 rax, 480		; 000001e0H
  00155	41 b9 04 00 00
	00		 mov	 r9d, 4
  0015b	4c 8b c0	 mov	 r8, rax
  0015e	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  00162	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0016a	e8 00 00 00 00	 call	 sr_read_value
  0016f	85 c0		 test	 eax, eax
  00171	74 0a		 je	 SHORT $LN63@fba_dasd_h
  00173	b8 ff ff ff ff	 mov	 eax, -1
  00178	e9 ba 06 00 00	 jmp	 $LN1@fba_dasd_h
$LN63@fba_dasd_h:
  0017d	33 c0		 xor	 eax, eax
  0017f	85 c0		 test	 eax, eax
  00181	75 c4		 jne	 SHORT $LN15@fba_dasd_h

; 1528 :             break;

  00183	e9 8c 06 00 00	 jmp	 $LN8@fba_dasd_h
$LN64@fba_dasd_h:
$LN18@fba_dasd_h:

; 1529 :         case SR_DEV_FBA_ORIGIN:
; 1530 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  00188	41 b9 04 00 00
	00		 mov	 r9d, 4
  0018e	4c 8d 44 24 60	 lea	 r8, QWORD PTR rc$[rsp]
  00193	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  00197	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0019f	e8 00 00 00 00	 call	 sr_read_value
  001a4	85 c0		 test	 eax, eax
  001a6	74 0a		 je	 SHORT $LN65@fba_dasd_h
  001a8	b8 ff ff ff ff	 mov	 eax, -1
  001ad	e9 85 06 00 00	 jmp	 $LN1@fba_dasd_h
$LN65@fba_dasd_h:
  001b2	33 c0		 xor	 eax, eax
  001b4	85 c0		 test	 eax, eax
  001b6	75 d0		 jne	 SHORT $LN18@fba_dasd_h

; 1531 :             if ((U64)rc != dev->fbaorigin)

  001b8	48 63 44 24 60	 movsxd	 rax, DWORD PTR rc$[rsp]
  001bd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c5	48 3b 81 90 11
	00 00		 cmp	 rax, QWORD PTR [rcx+4496]
  001cc	0f 84 ea 00 00
	00		 je	 $LN66@fba_dasd_h

; 1532 :             {
; 1533 :                 // "%1d:%04X FBA file %s: FBA origin mismatch: %d, expected %d,"
; 1534 :                 WRMSG( HHC00513, "E", LCSS_DEVNUM,

  001d2	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001db	74 12		 je	 SHORT $LN98@fba_dasd_h
  001dd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e5	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001e9	89 44 24 78	 mov	 DWORD PTR tv149[rsp], eax
  001ed	eb 08		 jmp	 SHORT $LN99@fba_dasd_h
$LN98@fba_dasd_h:
  001ef	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN99@fba_dasd_h:
  001f7	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00200	74 14		 je	 SHORT $LN100@fba_dasd_h
  00202	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020a	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0020e	d1 f8		 sar	 eax, 1
  00210	89 44 24 7c	 mov	 DWORD PTR tv155[rsp], eax
  00214	eb 08		 jmp	 SHORT $LN101@fba_dasd_h
$LN100@fba_dasd_h:
  00216	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN101@fba_dasd_h:
  0021e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00226	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0022c	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv144[rsp], rax
  00234	b9 01 00 00 00	 mov	 ecx, 1
  00239	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0023f	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00247	8b 89 90 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4496]
  0024d	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00251	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00255	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00259	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv144[rsp]
  00261	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00266	8b 4c 24 78	 mov	 ecx, DWORD PTR tv149[rsp]
  0026a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0026e	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv155[rsp]
  00272	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00276	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170671
  0027d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00282	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170672
  00289	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0028e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00293	41 b9 03 00 00
	00		 mov	 r9d, 3
  00299	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170673
  002a0	ba ff 05 00 00	 mov	 edx, 1535		; 000005ffH
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170674
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1535 :                        dev->filename, rc, (int)dev->fbaorigin );
; 1536 :                 return -1;

  002b2	b8 ff ff ff ff	 mov	 eax, -1
  002b7	e9 7b 05 00 00	 jmp	 $LN1@fba_dasd_h
$LN66@fba_dasd_h:

; 1537 :             }
; 1538 :             break;

  002bc	e9 53 05 00 00	 jmp	 $LN8@fba_dasd_h
$LN67@fba_dasd_h:
$LN21@fba_dasd_h:

; 1539 :         case SR_DEV_FBA_NUMBLK:
; 1540 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  002c1	41 b9 04 00 00
	00		 mov	 r9d, 4
  002c7	4c 8d 44 24 60	 lea	 r8, QWORD PTR rc$[rsp]
  002cc	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  002d0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  002d8	e8 00 00 00 00	 call	 sr_read_value
  002dd	85 c0		 test	 eax, eax
  002df	74 0a		 je	 SHORT $LN68@fba_dasd_h
  002e1	b8 ff ff ff ff	 mov	 eax, -1
  002e6	e9 4c 05 00 00	 jmp	 $LN1@fba_dasd_h
$LN68@fba_dasd_h:
  002eb	33 c0		 xor	 eax, eax
  002ed	85 c0		 test	 eax, eax
  002ef	75 d0		 jne	 SHORT $LN21@fba_dasd_h

; 1541 :             if ((int)rc != dev->fbanumblk)

  002f1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f9	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  002ff	39 44 24 60	 cmp	 DWORD PTR rc$[rsp], eax
  00303	0f 84 fc 00 00
	00		 je	 $LN69@fba_dasd_h

; 1542 :             {
; 1543 :                 // "%1d:%04X FBA file %s: FBA numblk mismatch: %d, expected %d,"
; 1544 :                 WRMSG( HHC00514, "E", LCSS_DEVNUM,

  00309	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00312	74 15		 je	 SHORT $LN102@fba_dasd_h
  00314	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00320	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv183[rsp], eax
  00327	eb 0b		 jmp	 SHORT $LN103@fba_dasd_h
$LN102@fba_dasd_h:
  00329	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv183[rsp], 0
$LN103@fba_dasd_h:
  00334	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0033d	74 17		 je	 SHORT $LN104@fba_dasd_h
  0033f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00347	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0034b	d1 f8		 sar	 eax, 1
  0034d	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv189[rsp], eax
  00354	eb 0b		 jmp	 SHORT $LN105@fba_dasd_h
$LN104@fba_dasd_h:
  00356	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv189[rsp], 0
$LN105@fba_dasd_h:
  00361	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00369	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0036f	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv178[rsp], rax
  00377	b9 01 00 00 00	 mov	 ecx, 1
  0037c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00382	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0038a	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  00390	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00394	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  00398	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  0039c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv178[rsp]
  003a4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003a9	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv183[rsp]
  003b0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003b4	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv189[rsp]
  003bb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003bf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170678
  003c6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170679
  003d2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003dc	41 b9 03 00 00
	00		 mov	 r9d, 3
  003e2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170680
  003e9	ba 09 06 00 00	 mov	 edx, 1545		; 00000609H
  003ee	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170681
  003f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1545 :                        dev->filename, rc, dev->fbanumblk );
; 1546 :                 return -1;

  003fb	b8 ff ff ff ff	 mov	 eax, -1
  00400	e9 32 04 00 00	 jmp	 $LN1@fba_dasd_h
$LN69@fba_dasd_h:

; 1547 :             }
; 1548 :             break;

  00405	e9 0a 04 00 00	 jmp	 $LN8@fba_dasd_h
$LN70@fba_dasd_h:
$LN24@fba_dasd_h:

; 1549 :         case SR_DEV_FBA_RBA:
; 1550 :             SR_READ_VALUE(file, len, &dev->fbarba, sizeof(dev->fbarba));

  0040a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00412	48 05 98 11 00
	00		 add	 rax, 4504		; 00001198H
  00418	41 b9 08 00 00
	00		 mov	 r9d, 8
  0041e	4c 8b c0	 mov	 r8, rax
  00421	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  00425	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0042d	e8 00 00 00 00	 call	 sr_read_value
  00432	85 c0		 test	 eax, eax
  00434	74 0a		 je	 SHORT $LN71@fba_dasd_h
  00436	b8 ff ff ff ff	 mov	 eax, -1
  0043b	e9 f7 03 00 00	 jmp	 $LN1@fba_dasd_h
$LN71@fba_dasd_h:
  00440	33 c0		 xor	 eax, eax
  00442	85 c0		 test	 eax, eax
  00444	75 c4		 jne	 SHORT $LN24@fba_dasd_h

; 1551 :             break;

  00446	e9 c9 03 00 00	 jmp	 $LN8@fba_dasd_h
$LN72@fba_dasd_h:
$LN27@fba_dasd_h:

; 1552 :         case SR_DEV_FBA_END:
; 1553 :             SR_READ_VALUE(file, len, &dev->fbaend, sizeof(dev->fbaend));

  0044b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00453	48 05 a0 11 00
	00		 add	 rax, 4512		; 000011a0H
  00459	41 b9 08 00 00
	00		 mov	 r9d, 8
  0045f	4c 8b c0	 mov	 r8, rax
  00462	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  00466	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0046e	e8 00 00 00 00	 call	 sr_read_value
  00473	85 c0		 test	 eax, eax
  00475	74 0a		 je	 SHORT $LN73@fba_dasd_h
  00477	b8 ff ff ff ff	 mov	 eax, -1
  0047c	e9 b6 03 00 00	 jmp	 $LN1@fba_dasd_h
$LN73@fba_dasd_h:
  00481	33 c0		 xor	 eax, eax
  00483	85 c0		 test	 eax, eax
  00485	75 c4		 jne	 SHORT $LN27@fba_dasd_h

; 1554 :             break;

  00487	e9 88 03 00 00	 jmp	 $LN8@fba_dasd_h
$LN74@fba_dasd_h:
$LN30@fba_dasd_h:

; 1555 :         case SR_DEV_FBA_DXBLKN:
; 1556 :             SR_READ_VALUE(file, len, &dev->fbaxblkn, sizeof(dev->fbaxblkn));

  0048c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00494	48 05 b0 11 00
	00		 add	 rax, 4528		; 000011b0H
  0049a	41 b9 04 00 00
	00		 mov	 r9d, 4
  004a0	4c 8b c0	 mov	 r8, rax
  004a3	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  004a7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  004af	e8 00 00 00 00	 call	 sr_read_value
  004b4	85 c0		 test	 eax, eax
  004b6	74 0a		 je	 SHORT $LN75@fba_dasd_h
  004b8	b8 ff ff ff ff	 mov	 eax, -1
  004bd	e9 75 03 00 00	 jmp	 $LN1@fba_dasd_h
$LN75@fba_dasd_h:
  004c2	33 c0		 xor	 eax, eax
  004c4	85 c0		 test	 eax, eax
  004c6	75 c4		 jne	 SHORT $LN30@fba_dasd_h

; 1557 :             break;

  004c8	e9 47 03 00 00	 jmp	 $LN8@fba_dasd_h
$LN76@fba_dasd_h:
$LN33@fba_dasd_h:

; 1558 :         case SR_DEV_FBA_DXFIRST:
; 1559 :             SR_READ_VALUE(file, len, &dev->fbaxfirst, sizeof(dev->fbaxfirst));

  004cd	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004d5	48 05 b4 11 00
	00		 add	 rax, 4532		; 000011b4H
  004db	41 b9 04 00 00
	00		 mov	 r9d, 4
  004e1	4c 8b c0	 mov	 r8, rax
  004e4	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  004e8	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  004f0	e8 00 00 00 00	 call	 sr_read_value
  004f5	85 c0		 test	 eax, eax
  004f7	74 0a		 je	 SHORT $LN77@fba_dasd_h
  004f9	b8 ff ff ff ff	 mov	 eax, -1
  004fe	e9 34 03 00 00	 jmp	 $LN1@fba_dasd_h
$LN77@fba_dasd_h:
  00503	33 c0		 xor	 eax, eax
  00505	85 c0		 test	 eax, eax
  00507	75 c4		 jne	 SHORT $LN33@fba_dasd_h

; 1560 :             break;

  00509	e9 06 03 00 00	 jmp	 $LN8@fba_dasd_h
$LN78@fba_dasd_h:
$LN36@fba_dasd_h:

; 1561 :         case SR_DEV_FBA_DXLAST:
; 1562 :             SR_READ_VALUE(file, len, &dev->fbaxlast, sizeof(dev->fbaxlast));

  0050e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00516	48 05 b8 11 00
	00		 add	 rax, 4536		; 000011b8H
  0051c	41 b9 04 00 00
	00		 mov	 r9d, 4
  00522	4c 8b c0	 mov	 r8, rax
  00525	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  00529	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00531	e8 00 00 00 00	 call	 sr_read_value
  00536	85 c0		 test	 eax, eax
  00538	74 0a		 je	 SHORT $LN79@fba_dasd_h
  0053a	b8 ff ff ff ff	 mov	 eax, -1
  0053f	e9 f3 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN79@fba_dasd_h:
  00544	33 c0		 xor	 eax, eax
  00546	85 c0		 test	 eax, eax
  00548	75 c4		 jne	 SHORT $LN36@fba_dasd_h

; 1563 :             break;

  0054a	e9 c5 02 00 00	 jmp	 $LN8@fba_dasd_h
$LN80@fba_dasd_h:
$LN39@fba_dasd_h:

; 1564 :         case SR_DEV_FBA_LCBLK:
; 1565 :             SR_READ_VALUE(file, len, &dev->fbalcblk, sizeof(dev->fbalcblk));

  0054f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00557	48 05 c0 11 00
	00		 add	 rax, 4544		; 000011c0H
  0055d	41 b9 04 00 00
	00		 mov	 r9d, 4
  00563	4c 8b c0	 mov	 r8, rax
  00566	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  0056a	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00572	e8 00 00 00 00	 call	 sr_read_value
  00577	85 c0		 test	 eax, eax
  00579	74 0a		 je	 SHORT $LN81@fba_dasd_h
  0057b	b8 ff ff ff ff	 mov	 eax, -1
  00580	e9 b2 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN81@fba_dasd_h:
  00585	33 c0		 xor	 eax, eax
  00587	85 c0		 test	 eax, eax
  00589	75 c4		 jne	 SHORT $LN39@fba_dasd_h

; 1566 :             break;

  0058b	e9 84 02 00 00	 jmp	 $LN8@fba_dasd_h
$LN82@fba_dasd_h:
$LN42@fba_dasd_h:

; 1567 :         case SR_DEV_FBA_LCNUM:
; 1568 :             SR_READ_VALUE(file, len, &dev->fbalcnum, sizeof(dev->fbalcnum));

  00590	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00598	48 05 be 11 00
	00		 add	 rax, 4542		; 000011beH
  0059e	41 b9 02 00 00
	00		 mov	 r9d, 2
  005a4	4c 8b c0	 mov	 r8, rax
  005a7	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  005ab	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  005b3	e8 00 00 00 00	 call	 sr_read_value
  005b8	85 c0		 test	 eax, eax
  005ba	74 0a		 je	 SHORT $LN83@fba_dasd_h
  005bc	b8 ff ff ff ff	 mov	 eax, -1
  005c1	e9 71 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN83@fba_dasd_h:
  005c6	33 c0		 xor	 eax, eax
  005c8	85 c0		 test	 eax, eax
  005ca	75 c4		 jne	 SHORT $LN42@fba_dasd_h

; 1569 :             break;

  005cc	e9 43 02 00 00	 jmp	 $LN8@fba_dasd_h
$LN84@fba_dasd_h:
$LN45@fba_dasd_h:

; 1570 :         case SR_DEV_FBA_BLKSIZ:
; 1571 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  005d1	41 b9 04 00 00
	00		 mov	 r9d, 4
  005d7	4c 8d 44 24 60	 lea	 r8, QWORD PTR rc$[rsp]
  005dc	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  005e0	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  005e8	e8 00 00 00 00	 call	 sr_read_value
  005ed	85 c0		 test	 eax, eax
  005ef	74 0a		 je	 SHORT $LN85@fba_dasd_h
  005f1	b8 ff ff ff ff	 mov	 eax, -1
  005f6	e9 3c 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN85@fba_dasd_h:
  005fb	33 c0		 xor	 eax, eax
  005fd	85 c0		 test	 eax, eax
  005ff	75 d0		 jne	 SHORT $LN45@fba_dasd_h

; 1572 :             if ((int)rc != dev->fbablksiz)

  00601	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00609	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  0060f	39 44 24 60	 cmp	 DWORD PTR rc$[rsp], eax
  00613	0f 84 fc 00 00
	00		 je	 $LN86@fba_dasd_h

; 1573 :             {
; 1574 :                 // "%1d:%04X FBA file %s: FBA blksiz mismatch: %d, expected %d,"
; 1575 :                 WRMSG( HHC00515, "E", LCSS_DEVNUM,

  00619	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00622	74 15		 je	 SHORT $LN106@fba_dasd_h
  00624	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0062c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00630	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv273[rsp], eax
  00637	eb 0b		 jmp	 SHORT $LN107@fba_dasd_h
$LN106@fba_dasd_h:
  00639	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv273[rsp], 0
$LN107@fba_dasd_h:
  00644	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0064d	74 17		 je	 SHORT $LN108@fba_dasd_h
  0064f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00657	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0065b	d1 f8		 sar	 eax, 1
  0065d	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv279[rsp], eax
  00664	eb 0b		 jmp	 SHORT $LN109@fba_dasd_h
$LN108@fba_dasd_h:
  00666	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv279[rsp], 0
$LN109@fba_dasd_h:
  00671	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00679	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0067f	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR tv268[rsp], rax
  00687	b9 01 00 00 00	 mov	 ecx, 1
  0068c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00692	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0069a	8b 89 8c 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4492]
  006a0	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  006a4	8b 4c 24 60	 mov	 ecx, DWORD PTR rc$[rsp]
  006a8	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  006ac	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv268[rsp]
  006b4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006b9	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv273[rsp]
  006c0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006c4	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv279[rsp]
  006cb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170699
  006d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170700
  006e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  006f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170701
  006f9	ba 28 06 00 00	 mov	 edx, 1576		; 00000628H
  006fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170702
  00705	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1576 :                        dev->filename, rc, dev->fbablksiz );
; 1577 :                 return -1;

  0070b	b8 ff ff ff ff	 mov	 eax, -1
  00710	e9 22 01 00 00	 jmp	 $LN1@fba_dasd_h
$LN86@fba_dasd_h:

; 1578 :             }
; 1579 :             break;

  00715	e9 fa 00 00 00	 jmp	 $LN8@fba_dasd_h
$LN87@fba_dasd_h:
$LN48@fba_dasd_h:

; 1580 :         case SR_DEV_FBA_XTDEF:
; 1581 :             SR_READ_VALUE(file, len, &rc, sizeof(rc));

  0071a	41 b9 04 00 00
	00		 mov	 r9d, 4
  00720	4c 8d 44 24 60	 lea	 r8, QWORD PTR rc$[rsp]
  00725	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  00729	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00731	e8 00 00 00 00	 call	 sr_read_value
  00736	85 c0		 test	 eax, eax
  00738	74 0a		 je	 SHORT $LN88@fba_dasd_h
  0073a	b8 ff ff ff ff	 mov	 eax, -1
  0073f	e9 f3 00 00 00	 jmp	 $LN1@fba_dasd_h
$LN88@fba_dasd_h:
  00744	33 c0		 xor	 eax, eax
  00746	85 c0		 test	 eax, eax
  00748	75 d0		 jne	 SHORT $LN48@fba_dasd_h

; 1582 :             dev->fbaxtdef = rc;

  0074a	8b 44 24 60	 mov	 eax, DWORD PTR rc$[rsp]
  0074e	83 e0 01	 and	 eax, 1
  00751	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00759	8b 89 a8 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4520]
  0075f	83 e1 fe	 and	 ecx, -2			; fffffffeH
  00762	0b c8		 or	 ecx, eax
  00764	8b c1		 mov	 eax, ecx
  00766	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0076e	89 81 a8 11 00
	00		 mov	 DWORD PTR [rcx+4520], eax

; 1583 :             break;

  00774	e9 9b 00 00 00	 jmp	 $LN8@fba_dasd_h
$LN89@fba_dasd_h:
$LN51@fba_dasd_h:

; 1584 :         case SR_DEV_FBA_OPER:
; 1585 :             SR_READ_VALUE(file, len, &dev->fbaoper, sizeof(dev->fbaoper));

  00779	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00781	48 05 bc 11 00
	00		 add	 rax, 4540		; 000011bcH
  00787	41 b9 01 00 00
	00		 mov	 r9d, 1
  0078d	4c 8b c0	 mov	 r8, rax
  00790	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  00794	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  0079c	e8 00 00 00 00	 call	 sr_read_value
  007a1	85 c0		 test	 eax, eax
  007a3	74 0a		 je	 SHORT $LN90@fba_dasd_h
  007a5	b8 ff ff ff ff	 mov	 eax, -1
  007aa	e9 88 00 00 00	 jmp	 $LN1@fba_dasd_h
$LN90@fba_dasd_h:
  007af	33 c0		 xor	 eax, eax
  007b1	85 c0		 test	 eax, eax
  007b3	75 c4		 jne	 SHORT $LN51@fba_dasd_h

; 1586 :             break;

  007b5	eb 5d		 jmp	 SHORT $LN8@fba_dasd_h
$LN91@fba_dasd_h:
$LN54@fba_dasd_h:

; 1587 :         case SR_DEV_FBA_MASK:
; 1588 :             SR_READ_VALUE(file, len, &dev->fbamask, sizeof(dev->fbamask));

  007b7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007bf	48 05 ac 11 00
	00		 add	 rax, 4524		; 000011acH
  007c5	41 b9 01 00 00
	00		 mov	 r9d, 1
  007cb	4c 8b c0	 mov	 r8, rax
  007ce	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  007d2	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  007da	e8 00 00 00 00	 call	 sr_read_value
  007df	85 c0		 test	 eax, eax
  007e1	74 07		 je	 SHORT $LN92@fba_dasd_h
  007e3	b8 ff ff ff ff	 mov	 eax, -1
  007e8	eb 4d		 jmp	 SHORT $LN1@fba_dasd_h
$LN92@fba_dasd_h:
  007ea	33 c0		 xor	 eax, eax
  007ec	85 c0		 test	 eax, eax
  007ee	75 c7		 jne	 SHORT $LN54@fba_dasd_h

; 1589 :             break;

  007f0	eb 22		 jmp	 SHORT $LN8@fba_dasd_h
$LN93@fba_dasd_h:
$LN57@fba_dasd_h:

; 1590 :         default:
; 1591 :             SR_READ_SKIP(file, len);

  007f2	8b 54 24 68	 mov	 edx, DWORD PTR len$[rsp]
  007f6	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  007fe	e8 00 00 00 00	 call	 sr_read_skip
  00803	85 c0		 test	 eax, eax
  00805	74 07		 je	 SHORT $LN94@fba_dasd_h
  00807	b8 ff ff ff ff	 mov	 eax, -1
  0080c	eb 29		 jmp	 SHORT $LN1@fba_dasd_h
$LN94@fba_dasd_h:
  0080e	33 c0		 xor	 eax, eax
  00810	85 c0		 test	 eax, eax
  00812	75 de		 jne	 SHORT $LN57@fba_dasd_h
$LN8@fba_dasd_h:

; 1592 :             break;
; 1593 :         } /* switch (key) */
; 1594 :     } while ((key & SR_DEV_MASK) == SR_DEV_FBA);

  00814	b8 00 f0 ff ff	 mov	 eax, -4096		; fffff000H
  00819	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR key$[rsp]
  00821	48 23 c8	 and	 rcx, rax
  00824	48 8b c1	 mov	 rax, rcx
  00827	b9 00 20 e3 ac	 mov	 ecx, -1394401280	; ace32000H
  0082c	48 3b c1	 cmp	 rax, rcx
  0082f	0f 84 dc f7 ff
	ff		 je	 $LN4@fba_dasd_h

; 1595 :     return 0;

  00835	33 c0		 xor	 eax, eax
$LN1@fba_dasd_h:

; 1596 : }

  00837	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0083e	c3		 ret	 0
  0083f	90		 npad	 1
$LN110@fba_dasd_h:
  00840	00 00 00 00	 DD	 $LN59@fba_dasd_h
  00844	00 00 00 00	 DD	 $LN62@fba_dasd_h
  00848	00 00 00 00	 DD	 $LN64@fba_dasd_h
  0084c	00 00 00 00	 DD	 $LN67@fba_dasd_h
  00850	00 00 00 00	 DD	 $LN70@fba_dasd_h
  00854	00 00 00 00	 DD	 $LN72@fba_dasd_h
  00858	00 00 00 00	 DD	 $LN74@fba_dasd_h
  0085c	00 00 00 00	 DD	 $LN76@fba_dasd_h
  00860	00 00 00 00	 DD	 $LN78@fba_dasd_h
  00864	00 00 00 00	 DD	 $LN80@fba_dasd_h
  00868	00 00 00 00	 DD	 $LN82@fba_dasd_h
  0086c	00 00 00 00	 DD	 $LN84@fba_dasd_h
  00870	00 00 00 00	 DD	 $LN87@fba_dasd_h
  00874	00 00 00 00	 DD	 $LN89@fba_dasd_h
  00878	00 00 00 00	 DD	 $LN91@fba_dasd_h
fba_dasd_hresume ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
dev$ = 48
file$ = 56
fba_dasd_hsuspend PROC

; 1485 : {

$LN64:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1486 :     if (dev->bufcur >= 0)

  0000e	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00013	83 b8 c0 01 00
	00 00		 cmp	 DWORD PTR [rax+448], 0
  0001a	7c 70		 jl	 SHORT $LN47@fba_dasd_h
$LN4@fba_dasd_h:

; 1487 :     {
; 1488 :         SR_WRITE_VALUE( file, SR_DEV_FBA_BUFCUR, dev->bufcur, sizeof( dev->bufcur ));

  0001c	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00021	48 63 80 c0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+448]
  00028	41 b9 04 00 00
	00		 mov	 r9d, 4
  0002e	4c 8b c0	 mov	 r8, rax
  00031	ba 01 20 e3 ac	 mov	 edx, -1394401279	; ace32001H
  00036	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0003b	e8 00 00 00 00	 call	 sr_write_value
  00040	85 c0		 test	 eax, eax
  00042	74 0a		 je	 SHORT $LN48@fba_dasd_h
  00044	b8 ff ff ff ff	 mov	 eax, -1
  00049	e9 06 03 00 00	 jmp	 $LN1@fba_dasd_h
$LN48@fba_dasd_h:
  0004e	33 c0		 xor	 eax, eax
  00050	85 c0		 test	 eax, eax
  00052	75 c8		 jne	 SHORT $LN4@fba_dasd_h
$LN7@fba_dasd_h:

; 1489 :         SR_WRITE_VALUE( file, SR_DEV_FBA_BUFOFF, dev->bufoff, sizeof( dev->bufoff ));

  00054	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00059	48 63 80 e0 01
	00 00		 movsxd	 rax, DWORD PTR [rax+480]
  00060	41 b9 04 00 00
	00		 mov	 r9d, 4
  00066	4c 8b c0	 mov	 r8, rax
  00069	ba 02 20 e3 ac	 mov	 edx, -1394401278	; ace32002H
  0006e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00073	e8 00 00 00 00	 call	 sr_write_value
  00078	85 c0		 test	 eax, eax
  0007a	74 0a		 je	 SHORT $LN49@fba_dasd_h
  0007c	b8 ff ff ff ff	 mov	 eax, -1
  00081	e9 ce 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN49@fba_dasd_h:
  00086	33 c0		 xor	 eax, eax
  00088	85 c0		 test	 eax, eax
  0008a	75 c8		 jne	 SHORT $LN7@fba_dasd_h
$LN47@fba_dasd_h:
$LN10@fba_dasd_h:

; 1490 :     }
; 1491 : 
; 1492 :     SR_WRITE_VALUE( file, SR_DEV_FBA_ORIGIN,  dev->fbaorigin, sizeof( dev->fbaorigin ));

  0008c	41 b9 08 00 00
	00		 mov	 r9d, 8
  00092	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00097	4c 8b 80 90 11
	00 00		 mov	 r8, QWORD PTR [rax+4496]
  0009e	ba 03 20 e3 ac	 mov	 edx, -1394401277	; ace32003H
  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  000a8	e8 00 00 00 00	 call	 sr_write_value
  000ad	85 c0		 test	 eax, eax
  000af	74 0a		 je	 SHORT $LN50@fba_dasd_h
  000b1	b8 ff ff ff ff	 mov	 eax, -1
  000b6	e9 99 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN50@fba_dasd_h:
  000bb	33 c0		 xor	 eax, eax
  000bd	85 c0		 test	 eax, eax
  000bf	75 cb		 jne	 SHORT $LN10@fba_dasd_h
$LN13@fba_dasd_h:

; 1493 :     SR_WRITE_VALUE( file, SR_DEV_FBA_NUMBLK,  dev->fbanumblk, sizeof( dev->fbanumblk ));

  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  000c6	48 63 80 88 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4488]
  000cd	41 b9 04 00 00
	00		 mov	 r9d, 4
  000d3	4c 8b c0	 mov	 r8, rax
  000d6	ba 04 20 e3 ac	 mov	 edx, -1394401276	; ace32004H
  000db	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  000e0	e8 00 00 00 00	 call	 sr_write_value
  000e5	85 c0		 test	 eax, eax
  000e7	74 0a		 je	 SHORT $LN51@fba_dasd_h
  000e9	b8 ff ff ff ff	 mov	 eax, -1
  000ee	e9 61 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN51@fba_dasd_h:
  000f3	33 c0		 xor	 eax, eax
  000f5	85 c0		 test	 eax, eax
  000f7	75 c8		 jne	 SHORT $LN13@fba_dasd_h
$LN16@fba_dasd_h:

; 1494 :     SR_WRITE_VALUE( file, SR_DEV_FBA_RBA,     dev->fbarba,    sizeof( dev->fbarba    ));

  000f9	41 b9 08 00 00
	00		 mov	 r9d, 8
  000ff	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00104	4c 8b 80 98 11
	00 00		 mov	 r8, QWORD PTR [rax+4504]
  0010b	ba 05 20 e3 ac	 mov	 edx, -1394401275	; ace32005H
  00110	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00115	e8 00 00 00 00	 call	 sr_write_value
  0011a	85 c0		 test	 eax, eax
  0011c	74 0a		 je	 SHORT $LN52@fba_dasd_h
  0011e	b8 ff ff ff ff	 mov	 eax, -1
  00123	e9 2c 02 00 00	 jmp	 $LN1@fba_dasd_h
$LN52@fba_dasd_h:
  00128	33 c0		 xor	 eax, eax
  0012a	85 c0		 test	 eax, eax
  0012c	75 cb		 jne	 SHORT $LN16@fba_dasd_h
$LN19@fba_dasd_h:

; 1495 :     SR_WRITE_VALUE( file, SR_DEV_FBA_END,     dev->fbaend,    sizeof( dev->fbaend    ));

  0012e	41 b9 08 00 00
	00		 mov	 r9d, 8
  00134	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00139	4c 8b 80 a0 11
	00 00		 mov	 r8, QWORD PTR [rax+4512]
  00140	ba 06 20 e3 ac	 mov	 edx, -1394401274	; ace32006H
  00145	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0014a	e8 00 00 00 00	 call	 sr_write_value
  0014f	85 c0		 test	 eax, eax
  00151	74 0a		 je	 SHORT $LN53@fba_dasd_h
  00153	b8 ff ff ff ff	 mov	 eax, -1
  00158	e9 f7 01 00 00	 jmp	 $LN1@fba_dasd_h
$LN53@fba_dasd_h:
  0015d	33 c0		 xor	 eax, eax
  0015f	85 c0		 test	 eax, eax
  00161	75 cb		 jne	 SHORT $LN19@fba_dasd_h
$LN22@fba_dasd_h:

; 1496 :     SR_WRITE_VALUE( file, SR_DEV_FBA_DXBLKN,  dev->fbaxblkn,  sizeof( dev->fbaxblkn  ));

  00163	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00168	8b 80 b0 11 00
	00		 mov	 eax, DWORD PTR [rax+4528]
  0016e	41 b9 04 00 00
	00		 mov	 r9d, 4
  00174	44 8b c0	 mov	 r8d, eax
  00177	ba 07 20 e3 ac	 mov	 edx, -1394401273	; ace32007H
  0017c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00181	e8 00 00 00 00	 call	 sr_write_value
  00186	85 c0		 test	 eax, eax
  00188	74 0a		 je	 SHORT $LN54@fba_dasd_h
  0018a	b8 ff ff ff ff	 mov	 eax, -1
  0018f	e9 c0 01 00 00	 jmp	 $LN1@fba_dasd_h
$LN54@fba_dasd_h:
  00194	33 c0		 xor	 eax, eax
  00196	85 c0		 test	 eax, eax
  00198	75 c9		 jne	 SHORT $LN22@fba_dasd_h
$LN25@fba_dasd_h:

; 1497 :     SR_WRITE_VALUE( file, SR_DEV_FBA_DXFIRST, dev->fbaxfirst, sizeof( dev->fbaxfirst ));

  0019a	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	8b 80 b4 11 00
	00		 mov	 eax, DWORD PTR [rax+4532]
  001a5	41 b9 04 00 00
	00		 mov	 r9d, 4
  001ab	44 8b c0	 mov	 r8d, eax
  001ae	ba 08 20 e3 ac	 mov	 edx, -1394401272	; ace32008H
  001b3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  001b8	e8 00 00 00 00	 call	 sr_write_value
  001bd	85 c0		 test	 eax, eax
  001bf	74 0a		 je	 SHORT $LN55@fba_dasd_h
  001c1	b8 ff ff ff ff	 mov	 eax, -1
  001c6	e9 89 01 00 00	 jmp	 $LN1@fba_dasd_h
$LN55@fba_dasd_h:
  001cb	33 c0		 xor	 eax, eax
  001cd	85 c0		 test	 eax, eax
  001cf	75 c9		 jne	 SHORT $LN25@fba_dasd_h
$LN28@fba_dasd_h:

; 1498 :     SR_WRITE_VALUE( file, SR_DEV_FBA_DXLAST,  dev->fbaxlast,  sizeof( dev->fbaxlast  ));

  001d1	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  001d6	8b 80 b8 11 00
	00		 mov	 eax, DWORD PTR [rax+4536]
  001dc	41 b9 04 00 00
	00		 mov	 r9d, 4
  001e2	44 8b c0	 mov	 r8d, eax
  001e5	ba 09 20 e3 ac	 mov	 edx, -1394401271	; ace32009H
  001ea	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  001ef	e8 00 00 00 00	 call	 sr_write_value
  001f4	85 c0		 test	 eax, eax
  001f6	74 0a		 je	 SHORT $LN56@fba_dasd_h
  001f8	b8 ff ff ff ff	 mov	 eax, -1
  001fd	e9 52 01 00 00	 jmp	 $LN1@fba_dasd_h
$LN56@fba_dasd_h:
  00202	33 c0		 xor	 eax, eax
  00204	85 c0		 test	 eax, eax
  00206	75 c9		 jne	 SHORT $LN28@fba_dasd_h
$LN31@fba_dasd_h:

; 1499 :     SR_WRITE_VALUE( file, SR_DEV_FBA_LCBLK,   dev->fbalcblk,  sizeof( dev->fbalcblk  ));

  00208	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0020d	8b 80 c0 11 00
	00		 mov	 eax, DWORD PTR [rax+4544]
  00213	41 b9 04 00 00
	00		 mov	 r9d, 4
  00219	44 8b c0	 mov	 r8d, eax
  0021c	ba 0a 20 e3 ac	 mov	 edx, -1394401270	; ace3200aH
  00221	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00226	e8 00 00 00 00	 call	 sr_write_value
  0022b	85 c0		 test	 eax, eax
  0022d	74 0a		 je	 SHORT $LN57@fba_dasd_h
  0022f	b8 ff ff ff ff	 mov	 eax, -1
  00234	e9 1b 01 00 00	 jmp	 $LN1@fba_dasd_h
$LN57@fba_dasd_h:
  00239	33 c0		 xor	 eax, eax
  0023b	85 c0		 test	 eax, eax
  0023d	75 c9		 jne	 SHORT $LN31@fba_dasd_h
$LN34@fba_dasd_h:

; 1500 :     SR_WRITE_VALUE( file, SR_DEV_FBA_LCNUM,   dev->fbalcnum,  sizeof( dev->fbalcnum  ));

  0023f	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00244	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  0024b	41 b9 02 00 00
	00		 mov	 r9d, 2
  00251	44 8b c0	 mov	 r8d, eax
  00254	ba 0b 20 e3 ac	 mov	 edx, -1394401269	; ace3200bH
  00259	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0025e	e8 00 00 00 00	 call	 sr_write_value
  00263	85 c0		 test	 eax, eax
  00265	74 0a		 je	 SHORT $LN58@fba_dasd_h
  00267	b8 ff ff ff ff	 mov	 eax, -1
  0026c	e9 e3 00 00 00	 jmp	 $LN1@fba_dasd_h
$LN58@fba_dasd_h:
  00271	33 c0		 xor	 eax, eax
  00273	85 c0		 test	 eax, eax
  00275	75 c8		 jne	 SHORT $LN34@fba_dasd_h
$LN37@fba_dasd_h:

; 1501 :     SR_WRITE_VALUE( file, SR_DEV_FBA_BLKSIZ,  dev->fbablksiz, sizeof( dev->fbablksiz ));

  00277	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0027c	48 63 80 8c 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4492]
  00283	41 b9 04 00 00
	00		 mov	 r9d, 4
  00289	4c 8b c0	 mov	 r8, rax
  0028c	ba 0c 20 e3 ac	 mov	 edx, -1394401268	; ace3200cH
  00291	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00296	e8 00 00 00 00	 call	 sr_write_value
  0029b	85 c0		 test	 eax, eax
  0029d	74 0a		 je	 SHORT $LN59@fba_dasd_h
  0029f	b8 ff ff ff ff	 mov	 eax, -1
  002a4	e9 ab 00 00 00	 jmp	 $LN1@fba_dasd_h
$LN59@fba_dasd_h:
  002a9	33 c0		 xor	 eax, eax
  002ab	85 c0		 test	 eax, eax
  002ad	75 c8		 jne	 SHORT $LN37@fba_dasd_h
$LN40@fba_dasd_h:

; 1502 :     SR_WRITE_VALUE( file, SR_DEV_FBA_XTDEF,   dev->fbaxtdef,                   1      );

  002af	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  002b4	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  002ba	83 e0 01	 and	 eax, 1
  002bd	8b c0		 mov	 eax, eax
  002bf	41 b9 01 00 00
	00		 mov	 r9d, 1
  002c5	44 8b c0	 mov	 r8d, eax
  002c8	ba 0d 20 e3 ac	 mov	 edx, -1394401267	; ace3200dH
  002cd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  002d2	e8 00 00 00 00	 call	 sr_write_value
  002d7	85 c0		 test	 eax, eax
  002d9	74 07		 je	 SHORT $LN60@fba_dasd_h
  002db	b8 ff ff ff ff	 mov	 eax, -1
  002e0	eb 72		 jmp	 SHORT $LN1@fba_dasd_h
$LN60@fba_dasd_h:
  002e2	33 c0		 xor	 eax, eax
  002e4	85 c0		 test	 eax, eax
  002e6	75 c7		 jne	 SHORT $LN40@fba_dasd_h
$LN43@fba_dasd_h:

; 1503 :     SR_WRITE_VALUE( file, SR_DEV_FBA_OPER,    dev->fbaoper,   sizeof( dev->fbaoper   ));

  002e8	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  002ed	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  002f4	41 b9 01 00 00
	00		 mov	 r9d, 1
  002fa	44 8b c0	 mov	 r8d, eax
  002fd	ba 0e 20 e3 ac	 mov	 edx, -1394401266	; ace3200eH
  00302	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  00307	e8 00 00 00 00	 call	 sr_write_value
  0030c	85 c0		 test	 eax, eax
  0030e	74 07		 je	 SHORT $LN61@fba_dasd_h
  00310	b8 ff ff ff ff	 mov	 eax, -1
  00315	eb 3d		 jmp	 SHORT $LN1@fba_dasd_h
$LN61@fba_dasd_h:
  00317	33 c0		 xor	 eax, eax
  00319	85 c0		 test	 eax, eax
  0031b	75 cb		 jne	 SHORT $LN43@fba_dasd_h
$LN46@fba_dasd_h:

; 1504 :     SR_WRITE_VALUE( file, SR_DEV_FBA_MASK,    dev->fbamask,   sizeof( dev->fbamask   ));

  0031d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00322	0f b6 80 ac 11
	00 00		 movzx	 eax, BYTE PTR [rax+4524]
  00329	41 b9 01 00 00
	00		 mov	 r9d, 1
  0032f	44 8b c0	 mov	 r8d, eax
  00332	ba 0f 20 e3 ac	 mov	 edx, -1394401265	; ace3200fH
  00337	48 8b 4c 24 38	 mov	 rcx, QWORD PTR file$[rsp]
  0033c	e8 00 00 00 00	 call	 sr_write_value
  00341	85 c0		 test	 eax, eax
  00343	74 07		 je	 SHORT $LN62@fba_dasd_h
  00345	b8 ff ff ff ff	 mov	 eax, -1
  0034a	eb 08		 jmp	 SHORT $LN1@fba_dasd_h
$LN62@fba_dasd_h:
  0034c	33 c0		 xor	 eax, eax
  0034e	85 c0		 test	 eax, eax
  00350	75 cb		 jne	 SHORT $LN46@fba_dasd_h

; 1505 : 
; 1506 :     return 0;

  00352	33 c0		 xor	 eax, eax
$LN1@fba_dasd_h:

; 1507 : }

  00354	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00358	c3		 ret	 0
fba_dasd_hsuspend ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
$T1 = 80
tv136 = 88
cckd$ = 96
tv155 = 104
filename$ = 112
__$ArrayPad$ = 384
dev$ = 416
devclass$ = 424
buflen$ = 432
buffer$ = 440
fba_dasd_query_device PROC

; 335  : {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 01
	00 00		 sub	 rsp, 408		; 00000198H
  0001b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00022	48 33 c4	 xor	 rax, rsp
  00025	48 89 84 24 80
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 336  :     char       filename[ PATH_MAX + 1 ];/* full path or just name    */
; 337  :     CCKD_EXT*  cckd;                    /* CCKD Extension Block      */
; 338  : 
; 339  :     BEGIN_DEVICE_CLASS_QUERY( "DASD", dev, devclass, buflen, buffer );

  0002d	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  00036	74 12		 je	 SHORT $LN2@fba_dasd_q
  00038	48 8b 84 24 a8
	01 00 00	 mov	 rax, QWORD PTR devclass$[rsp]
  00040	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169967
  00047	48 89 08	 mov	 QWORD PTR [rax], rcx
$LN2@fba_dasd_q:
  0004a	48 83 bc 24 a0
	01 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00053	74 20		 je	 SHORT $LN4@fba_dasd_q
  00055	48 83 bc 24 a8
	01 00 00 00	 cmp	 QWORD PTR devclass$[rsp], 0
  0005e	74 15		 je	 SHORT $LN4@fba_dasd_q
  00060	83 bc 24 b0 01
	00 00 00	 cmp	 DWORD PTR buflen$[rsp], 0
  00068	74 0b		 je	 SHORT $LN4@fba_dasd_q
  0006a	48 83 bc 24 b8
	01 00 00 00	 cmp	 QWORD PTR buffer$[rsp], 0
  00073	75 05		 jne	 SHORT $LN3@fba_dasd_q
$LN4@fba_dasd_q:
  00075	e9 0c 02 00 00	 jmp	 $LN1@fba_dasd_q
$LN3@fba_dasd_q:
  0007a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00081	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00087	c1 e8 1a	 shr	 eax, 26
  0008a	83 e0 01	 and	 eax, 1
  0008d	85 c0		 test	 eax, eax
  0008f	74 6c		 je	 SHORT $LN5@fba_dasd_q
  00091	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00099	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0009f	48 8b c8	 mov	 rcx, rax
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_basename
  000a8	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  000ae	48 8b d0	 mov	 rdx, rax
  000b1	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
  000bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169973
  000c3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  000c8	e8 00 00 00 00	 call	 strcmp
  000cd	85 c0		 test	 eax, eax
  000cf	75 2a		 jne	 SHORT $LN7@fba_dasd_q
  000d1	b8 01 00 00 00	 mov	 eax, 1
  000d6	48 6b c0 00	 imul	 rax, rax, 0
  000da	48 89 44 24 50	 mov	 QWORD PTR $T1[rsp], rax
  000df	48 81 7c 24 50
	05 01 00 00	 cmp	 QWORD PTR $T1[rsp], 261	; 00000105H
  000e8	73 02		 jae	 SHORT $LN11@fba_dasd_q
  000ea	eb 05		 jmp	 SHORT $LN12@fba_dasd_q
$LN11@fba_dasd_q:
  000ec	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN12@fba_dasd_q:
  000f1	48 8b 44 24 50	 mov	 rax, QWORD PTR $T1[rsp]
  000f6	c6 44 04 70 00	 mov	 BYTE PTR filename$[rsp+rax], 0
$LN7@fba_dasd_q:
  000fb	eb 22		 jmp	 SHORT $LN6@fba_dasd_q
$LN5@fba_dasd_q:
  000fd	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00105	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0010b	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  00111	48 8b d0	 mov	 rdx, rax
  00114	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  00119	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy
$LN6@fba_dasd_q:

; 340  : 
; 341  :     cckd = dev->cckd_ext;

  0011f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00127	48 8b 80 08 13
	00 00		 mov	 rax, QWORD PTR [rax+4872]
  0012e	48 89 44 24 60	 mov	 QWORD PTR cckd$[rsp], rax

; 342  : 
; 343  :     if (!cckd)

  00133	48 83 7c 24 60
	00		 cmp	 QWORD PTR cckd$[rsp], 0
  00139	0f 85 a0 00 00
	00		 jne	 $LN8@fba_dasd_q

; 344  :     {
; 345  :         snprintf( buffer, buflen, "%s%s [%"PRId64",%d] IO[%"PRIu64"]",

  0013f	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00147	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  0014e	24 01		 and	 al, 1
  00150	0f b6 c0	 movzx	 eax, al
  00153	85 c0		 test	 eax, eax
  00155	74 0e		 je	 SHORT $LN13@fba_dasd_q
  00157	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169976
  0015e	48 89 44 24 58	 mov	 QWORD PTR tv136[rsp], rax
  00163	eb 0c		 jmp	 SHORT $LN14@fba_dasd_q
$LN13@fba_dasd_q:
  00165	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169977
  0016c	48 89 44 24 58	 mov	 QWORD PTR tv136[rsp], rax
$LN14@fba_dasd_q:
  00171	48 63 84 24 b0
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00179	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00181	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  00188	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0018d	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00195	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  0019b	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0019f	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001a7	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  001ae	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001b3	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  001b8	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  001bd	4c 8b 4c 24 58	 mov	 r9, QWORD PTR tv136[rsp]
  001c2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169978
  001c9	48 8b d0	 mov	 rdx, rax
  001cc	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  001d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf

; 346  :                   dev->cckd64 ? "*64* " : "",
; 347  :                   filename,
; 348  :                   dev->fbaorigin, dev->fbanumblk,
; 349  :                   dev->excps);
; 350  :     }

  001da	e9 a7 00 00 00	 jmp	 $LN9@fba_dasd_q
$LN8@fba_dasd_q:

; 351  :     else
; 352  :     {
; 353  :         snprintf( buffer, buflen, "%s%s [%"PRId64",%d] [%d sfs] IO[%"PRIu64"]",

  001df	48 8b 84 24 a0
	01 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e7	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  001ee	24 01		 and	 al, 1
  001f0	0f b6 c0	 movzx	 eax, al
  001f3	85 c0		 test	 eax, eax
  001f5	74 0e		 je	 SHORT $LN15@fba_dasd_q
  001f7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169979
  001fe	48 89 44 24 68	 mov	 QWORD PTR tv155[rsp], rax
  00203	eb 0c		 jmp	 SHORT $LN16@fba_dasd_q
$LN15@fba_dasd_q:
  00205	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169980
  0020c	48 89 44 24 68	 mov	 QWORD PTR tv155[rsp], rax
$LN16@fba_dasd_q:
  00211	48 63 84 24 b0
	01 00 00	 movsxd	 rax, DWORD PTR buflen$[rsp]
  00219	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00221	48 8b 89 00 06
	00 00		 mov	 rcx, QWORD PTR [rcx+1536]
  00228	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0022d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR cckd$[rsp]
  00232	8b 49 3c	 mov	 ecx, DWORD PTR [rcx+60]
  00235	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00239	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00241	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  00247	89 4c 24 30	 mov	 DWORD PTR [rsp+48], ecx
  0024b	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00253	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  0025a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0025f	48 8d 4c 24 70	 lea	 rcx, QWORD PTR filename$[rsp]
  00264	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00269	4c 8b 4c 24 68	 mov	 r9, QWORD PTR tv155[rsp]
  0026e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169981
  00275	48 8b d0	 mov	 rdx, rax
  00278	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR buffer$[rsp]
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_snprintf
$LN9@fba_dasd_q:
$LN1@fba_dasd_q:
$LN10@fba_dasd_q:

; 354  :                   dev->cckd64 ? "*64* " : "",
; 355  :                   filename,
; 356  :                   dev->fbaorigin, dev->fbanumblk,
; 357  :                   cckd->sfn,
; 358  :                   dev->excps);
; 359  :     }
; 360  : 
; 361  : } /* end function fba_dasd_query_device */

  00286	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0028e	48 33 cc	 xor	 rcx, rsp
  00291	e8 00 00 00 00	 call	 __security_check_cookie
  00296	48 81 c4 98 01
	00 00		 add	 rsp, 408		; 00000198H
  0029d	c3		 ret	 0
fba_dasd_query_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
unitstat$ = 32
dev$ = 64
fba_dasd_close_device PROC

; 759  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 760  : BYTE            unitstat;
; 761  : 
; 762  :     /* Forces updated buffer to be written */
; 763  :     (dev->hnd->read) (dev, -1, &unitstat);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0000e	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  00015	4c 8d 44 24 20	 lea	 r8, QWORD PTR unitstat$[rsp]
  0001a	ba ff ff ff ff	 mov	 edx, -1
  0001f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00024	ff 50 50	 call	 QWORD PTR [rax+80]

; 764  : 
; 765  :     /* Free the cache */
; 766  :     cache_lock(CACHE_DEVBUF);

  00027	33 c9		 xor	 ecx, ecx
  00029	e8 00 00 00 00	 call	 cache_lock

; 767  :     cache_scan(CACHE_DEVBUF, fbadasd_purge_cache, dev);

  0002e	4c 8b 44 24 40	 mov	 r8, QWORD PTR dev$[rsp]
  00033	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:fbadasd_purge_cache
  0003a	33 c9		 xor	 ecx, ecx
  0003c	e8 00 00 00 00	 call	 cache_scan

; 768  :     cache_unlock(CACHE_DEVBUF);

  00041	33 c9		 xor	 ecx, ecx
  00043	e8 00 00 00 00	 call	 cache_unlock

; 769  : 
; 770  :     /* Close the device file */
; 771  :     close (dev->fd);

  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 772  :     dev->fd = -1;

  00059	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0005e	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 773  : 
; 774  :     dev->buf = NULL;

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0006d	48 c7 80 c8 01
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+456], 0

; 775  :     dev->bufsize = 0;

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	c7 80 d8 01 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+472], 0

; 776  : 
; 777  :     return 0;

  00087	33 c0		 xor	 eax, eax

; 778  : } /* end function fba_dasd_close_device */

  00089	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0008d	c3		 ret	 0
fba_dasd_close_device ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
num$ = 112
rc$ = 116
tv70 = 120
tv130 = 124
tv181 = 128
rem$ = 132
tv249 = 136
tv272 = 140
repcnt$ = 144
tv428 = 148
tv437 = 152
tv443 = 156
tv465 = 160
tv471 = 164
tv504 = 168
tv510 = 172
tv568 = 176
tv574 = 180
tv594 = 184
tv669 = 188
tv688 = 192
tv700 = 196
tv373 = 200
tv411 = 204
tv415 = 208
tv497 = 212
tv408 = 216
tv432 = 224
tv460 = 232
tv499 = 240
tv563 = 248
tv705 = 256
hexzeroes$ = 272
__$ArrayPad$ = 784
dev$ = 832
code$ = 840
flags$ = 848
chained$ = 856
count$ = 864
prevcode$ = 872
ccwseq$ = 880
iobuf$ = 888
more$ = 896
unitstat$ = 904
residual$ = 912
fba_dasd_execute_ccw PROC

; 795  : {

$LN120:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	56		 push	 rsi
  00014	57		 push	 rdi
  00015	48 81 ec 28 03
	00 00		 sub	 rsp, 808		; 00000328H
  0001c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00023	48 33 c4	 xor	 rax, rsp
  00026	48 89 84 24 10
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 796  : int     rc;                             /* Return code               */
; 797  : int     num;                            /* Number of bytes to move   */
; 798  : BYTE    hexzeroes[512];                 /* Bytes for zero fill       */
; 799  : int     rem;                            /* Byte count for zero fill  */
; 800  : int     repcnt;                         /* Replication count         */
; 801  : 
; 802  :     /* Reset extent flag at start of CCW chain */
; 803  :     if (chained == 0)

  0002e	0f b6 84 24 58
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  00036	85 c0		 test	 eax, eax
  00038	75 1f		 jne	 SHORT $LN11@fba_dasd_e

; 804  :         dev->fbaxtdef = 0;

  0003a	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00042	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  00048	83 e0 fe	 and	 eax, -2			; fffffffeH
  0004b	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00053	89 81 a8 11 00
	00		 mov	 DWORD PTR [rcx+4520], eax
$LN11@fba_dasd_e:

; 805  : 
; 806  :     /* Process depending on CCW opcode */
; 807  :     switch (code) {

  00059	0f b6 84 24 48
	03 00 00	 movzx	 eax, BYTE PTR code$[rsp]
  00061	89 44 24 78	 mov	 DWORD PTR tv70[rsp], eax
  00065	8b 44 24 78	 mov	 eax, DWORD PTR tv70[rsp]
  00069	83 e8 02	 sub	 eax, 2
  0006c	89 44 24 78	 mov	 DWORD PTR tv70[rsp], eax
  00070	81 7c 24 78 e2
	00 00 00	 cmp	 DWORD PTR tv70[rsp], 226 ; 000000e2H
  00078	0f 87 46 18 00
	00		 ja	 $LN82@fba_dasd_e
  0007e	48 63 44 24 78	 movsxd	 rax, DWORD PTR tv70[rsp]
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  0008a	0f b6 84 01 00
	00 00 00	 movzx	 eax, BYTE PTR $LN118@fba_dasd_e[rcx+rax]
  00092	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN119@fba_dasd_e[rcx+rax*4]
  00099	48 03 c1	 add	 rax, rcx
  0009c	ff e0		 jmp	 rax
$LN12@fba_dasd_e:

; 808  : 
; 809  :     case 0x02:
; 810  :     /*---------------------------------------------------------------*/
; 811  :     /* READ IPL                                                      */
; 812  :     /*---------------------------------------------------------------*/
; 813  :         /* Must be first CCW or chained from a previous READ IPL CCW */
; 814  :         if (chained && prevcode != 0x02)

  0009e	0f b6 84 24 58
	03 00 00	 movzx	 eax, BYTE PTR chained$[rsp]
  000a6	85 c0		 test	 eax, eax
  000a8	74 36		 je	 SHORT $LN13@fba_dasd_e
  000aa	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  000b2	83 f8 02	 cmp	 eax, 2
  000b5	74 29		 je	 SHORT $LN13@fba_dasd_e

; 815  :         {
; 816  :             dev->sense[0] = SENSE_CR;

  000b7	b8 01 00 00 00	 mov	 eax, 1
  000bc	48 6b c0 00	 imul	 rax, rax, 0
  000c0	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000c8	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 817  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  000d0	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  000d8	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 818  :             break;

  000db	e9 08 18 00 00	 jmp	 $LN2@fba_dasd_e
$LN13@fba_dasd_e:

; 819  :         }
; 820  : 
; 821  :         /* Zeroize the file mask and set extent for entire device */
; 822  :         dev->fbamask = 0;

  000e0	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e8	c6 80 ac 11 00
	00 00		 mov	 BYTE PTR [rax+4524], 0

; 823  :         dev->fbaxblkn = 0;

  000ef	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f7	c7 80 b0 11 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4528], 0

; 824  :         dev->fbaxfirst = 0;

  00101	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00109	c7 80 b4 11 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4532], 0

; 825  :         dev->fbaxlast = dev->fbanumblk - 1;

  00113	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011b	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  00121	ff c8		 dec	 eax
  00123	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012b	89 81 b8 11 00
	00		 mov	 DWORD PTR [rcx+4536], eax

; 826  : 
; 827  :         /* Seek to start of block zero */
; 828  :         dev->fbarba = dev->fbaorigin * dev->fbablksiz;

  00131	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00139	48 63 80 8c 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4492]
  00140	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00148	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  0014f	48 0f af c8	 imul	 rcx, rax
  00153	48 8b c1	 mov	 rax, rcx
  00156	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0015e	48 89 81 98 11
	00 00		 mov	 QWORD PTR [rcx+4504], rax

; 829  : 
; 830  :         /* Overrun if data chaining */
; 831  :         if ((flags & CCW_FLAGS_CD))

  00165	0f b6 84 24 50
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0016d	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00172	85 c0		 test	 eax, eax
  00174	74 29		 je	 SHORT $LN14@fba_dasd_e

; 832  :         {
; 833  :             dev->sense[0] = SENSE_OR;

  00176	b8 01 00 00 00	 mov	 eax, 1
  0017b	48 6b c0 00	 imul	 rax, rax, 0
  0017f	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00187	c6 84 01 64 03
	00 00 04	 mov	 BYTE PTR [rcx+rax+868], 4

; 834  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0018f	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00197	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 835  :             break;

  0019a	e9 49 17 00 00	 jmp	 $LN2@fba_dasd_e
$LN14@fba_dasd_e:

; 836  :         }
; 837  : 
; 838  :         /* Calculate number of bytes to read and set residual count */
; 839  :         num = (count < (U32)dev->fbablksiz) ?

  0019f	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a7	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  001ad	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  001b4	73 0d		 jae	 SHORT $LN84@fba_dasd_e
  001b6	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  001bd	89 44 24 7c	 mov	 DWORD PTR tv130[rsp], eax
  001c1	eb 12		 jmp	 SHORT $LN85@fba_dasd_e
$LN84@fba_dasd_e:
  001c3	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001cb	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  001d1	89 44 24 7c	 mov	 DWORD PTR tv130[rsp], eax
$LN85@fba_dasd_e:
  001d5	8b 44 24 7c	 mov	 eax, DWORD PTR tv130[rsp]
  001d9	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 840  :                count : (U32)dev->fbablksiz;
; 841  :         *residual = count - num;

  001dd	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  001e1	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  001e8	2b c8		 sub	 ecx, eax
  001ea	8b c1		 mov	 eax, ecx
  001ec	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  001f4	89 01		 mov	 DWORD PTR [rcx], eax

; 842  :         if (count < (U32)dev->fbablksiz) *more = 1;

  001f6	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fe	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  00204	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0020b	73 0b		 jae	 SHORT $LN15@fba_dasd_e
  0020d	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00215	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN15@fba_dasd_e:

; 843  : 
; 844  :         /* Read physical block into channel buffer */
; 845  :         rc = fba_read (dev, iobuf, num, unitstat);

  00218	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  00220	44 8b 44 24 70	 mov	 r8d, DWORD PTR num$[rsp]
  00225	48 8b 94 24 78
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0022d	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00235	e8 00 00 00 00	 call	 fba_read
  0023a	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 846  :         if (rc < num) break;

  0023e	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  00242	39 44 24 74	 cmp	 DWORD PTR rc$[rsp], eax
  00246	7d 05		 jge	 SHORT $LN16@fba_dasd_e
  00248	e9 9b 16 00 00	 jmp	 $LN2@fba_dasd_e
$LN16@fba_dasd_e:

; 847  : 
; 848  :         /* Set extent defined flag */
; 849  :         dev->fbaxtdef = 1;

  0024d	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00255	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  0025b	83 c8 01	 or	 eax, 1
  0025e	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00266	89 81 a8 11 00
	00		 mov	 DWORD PTR [rcx+4520], eax

; 850  : 
; 851  :         /* Set normal status */
; 852  :         *unitstat = CSW_CE | CSW_DE;

  0026c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00274	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 853  :         break;

  00277	e9 6c 16 00 00	 jmp	 $LN2@fba_dasd_e
$LN17@fba_dasd_e:

; 854  : 
; 855  :     case 0x03:
; 856  :     /*---------------------------------------------------------------*/
; 857  :     /* CONTROL NO-OPERATION                                          */
; 858  :     /*---------------------------------------------------------------*/
; 859  :         *unitstat = CSW_CE | CSW_DE;

  0027c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00284	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 860  :         break;

  00287	e9 5c 16 00 00	 jmp	 $LN2@fba_dasd_e
$LN18@fba_dasd_e:

; 861  : 
; 862  :     case 0x41:
; 863  :     /*---------------------------------------------------------------*/
; 864  :     /* WRITE                                                         */
; 865  :     /*---------------------------------------------------------------*/
; 866  :         /* Reject if previous command was not LOCATE */
; 867  :         if (prevcode != 0x43)

  0028c	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  00294	83 f8 43	 cmp	 eax, 67			; 00000043H
  00297	74 29		 je	 SHORT $LN19@fba_dasd_e

; 868  :         {
; 869  :             dev->sense[0] = SENSE_CR;

  00299	b8 01 00 00 00	 mov	 eax, 1
  0029e	48 6b c0 00	 imul	 rax, rax, 0
  002a2	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002aa	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 870  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  002b2	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  002ba	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 871  :             break;

  002bd	e9 26 16 00 00	 jmp	 $LN2@fba_dasd_e
$LN19@fba_dasd_e:

; 872  :         }
; 873  : 
; 874  :         /* Reject if locate command did not specify write operation */
; 875  :         if ((dev->fbaoper & FBAOPER_CODE) != FBAOPER_WRITE
; 876  :             && (dev->fbaoper & FBAOPER_CODE) != FBAOPER_WRTVRFY)

  002c2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ca	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  002d1	83 e0 0f	 and	 eax, 15
  002d4	83 f8 01	 cmp	 eax, 1
  002d7	74 40		 je	 SHORT $LN20@fba_dasd_e
  002d9	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002e1	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  002e8	83 e0 0f	 and	 eax, 15
  002eb	83 f8 05	 cmp	 eax, 5
  002ee	74 29		 je	 SHORT $LN20@fba_dasd_e

; 877  :         {
; 878  :             dev->sense[0] = SENSE_CR;

  002f0	b8 01 00 00 00	 mov	 eax, 1
  002f5	48 6b c0 00	 imul	 rax, rax, 0
  002f9	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00301	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 879  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00309	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00311	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 880  :             break;

  00314	e9 cf 15 00 00	 jmp	 $LN2@fba_dasd_e
$LN20@fba_dasd_e:

; 881  :         }
; 882  : 
; 883  :         /* Prepare a block of zeroes for write padding */
; 884  :         memset( hexzeroes, 0, sizeof(hexzeroes) );

  00319	48 8d 84 24 10
	01 00 00	 lea	 rax, QWORD PTR hexzeroes$[rsp]
  00321	48 8b f8	 mov	 rdi, rax
  00324	33 c0		 xor	 eax, eax
  00326	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0032b	f3 aa		 rep stosb
$LN4@fba_dasd_e:

; 885  : 
; 886  :         /* Write physical blocks of data to the device */
; 887  :         while (dev->fbalcnum > 0)

  0032d	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00335	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  0033c	85 c0		 test	 eax, eax
  0033e	0f 8e d1 01 00
	00		 jle	 $LN5@fba_dasd_e

; 888  :         {
; 889  :             /* Exit if data chaining and this CCW is exhausted */
; 890  :             if ((flags & CCW_FLAGS_CD) && count == 0)

  00344	0f b6 84 24 50
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0034c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00351	85 c0		 test	 eax, eax
  00353	74 0f		 je	 SHORT $LN21@fba_dasd_e
  00355	83 bc 24 60 03
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  0035d	75 05		 jne	 SHORT $LN21@fba_dasd_e

; 891  :                 break;

  0035f	e9 b1 01 00 00	 jmp	 $LN5@fba_dasd_e
$LN21@fba_dasd_e:

; 892  : 
; 893  :             /* Overrun if data chaining within a physical block */
; 894  :             if ((flags & CCW_FLAGS_CD) && count < (U32)dev->fbablksiz)

  00364	0f b6 84 24 50
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  0036c	25 80 00 00 00	 and	 eax, 128		; 00000080H
  00371	85 c0		 test	 eax, eax
  00373	74 40		 je	 SHORT $LN22@fba_dasd_e
  00375	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0037d	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  00383	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  0038a	73 29		 jae	 SHORT $LN22@fba_dasd_e

; 895  :             {
; 896  :                 dev->sense[0] = SENSE_OR;

  0038c	b8 01 00 00 00	 mov	 eax, 1
  00391	48 6b c0 00	 imul	 rax, rax, 0
  00395	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0039d	c6 84 01 64 03
	00 00 04	 mov	 BYTE PTR [rcx+rax+868], 4

; 897  :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  003a5	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  003ad	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 898  :                 break;

  003b0	e9 60 01 00 00	 jmp	 $LN5@fba_dasd_e
$LN22@fba_dasd_e:

; 899  :             }
; 900  : 
; 901  :             /* Calculate number of bytes to write */
; 902  :             num = (count < (U32)dev->fbablksiz) ?

  003b5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003bd	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  003c3	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  003ca	73 10		 jae	 SHORT $LN86@fba_dasd_e
  003cc	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  003d3	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
  003da	eb 15		 jmp	 SHORT $LN87@fba_dasd_e
$LN86@fba_dasd_e:
  003dc	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003e4	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  003ea	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv181[rsp], eax
$LN87@fba_dasd_e:
  003f1	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv181[rsp]
  003f8	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 903  :                    count : (U32)dev->fbablksiz;
; 904  :             if (num < dev->fbablksiz) *more = 1;

  003fc	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00404	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  0040a	39 44 24 70	 cmp	 DWORD PTR num$[rsp], eax
  0040e	7d 0b		 jge	 SHORT $LN23@fba_dasd_e
  00410	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00418	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN23@fba_dasd_e:

; 905  : 
; 906  :             /* Write physical block from channel buffer */
; 907  :             if (num > 0)

  0041b	83 7c 24 70 00	 cmp	 DWORD PTR num$[rsp], 0
  00420	7e 35		 jle	 SHORT $LN24@fba_dasd_e

; 908  :             {
; 909  :                 rc = fba_write (dev, iobuf, num, unitstat);

  00422	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0042a	44 8b 44 24 70	 mov	 r8d, DWORD PTR num$[rsp]
  0042f	48 8b 94 24 78
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00437	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0043f	e8 00 00 00 00	 call	 fba_write
  00444	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 910  :                 if (rc < num) break;

  00448	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  0044c	39 44 24 74	 cmp	 DWORD PTR rc$[rsp], eax
  00450	7d 05		 jge	 SHORT $LN25@fba_dasd_e
  00452	e9 be 00 00 00	 jmp	 $LN5@fba_dasd_e
$LN25@fba_dasd_e:
$LN24@fba_dasd_e:

; 911  :             }
; 912  : 
; 913  :             /* Fill remainder of block with zeroes */
; 914  :             if (num < dev->fbablksiz)

  00457	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045f	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  00465	39 44 24 70	 cmp	 DWORD PTR num$[rsp], eax
  00469	7d 53		 jge	 SHORT $LN26@fba_dasd_e

; 915  :             {
; 916  :                 rem = dev->fbablksiz - num;

  0046b	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00473	8b 4c 24 70	 mov	 ecx, DWORD PTR num$[rsp]
  00477	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  0047d	2b c1		 sub	 eax, ecx
  0047f	89 84 24 84 00
	00 00		 mov	 DWORD PTR rem$[rsp], eax

; 917  :                 rc = fba_write (dev, hexzeroes, rem, unitstat);

  00486	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  0048e	44 8b 84 24 84
	00 00 00	 mov	 r8d, DWORD PTR rem$[rsp]
  00496	48 8d 94 24 10
	01 00 00	 lea	 rdx, QWORD PTR hexzeroes$[rsp]
  0049e	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004a6	e8 00 00 00 00	 call	 fba_write
  004ab	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 918  :                 if (rc < rem) break;

  004af	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR rem$[rsp]
  004b6	39 44 24 74	 cmp	 DWORD PTR rc$[rsp], eax
  004ba	7d 02		 jge	 SHORT $LN27@fba_dasd_e
  004bc	eb 57		 jmp	 SHORT $LN5@fba_dasd_e
$LN27@fba_dasd_e:
$LN26@fba_dasd_e:

; 919  :             }
; 920  : 
; 921  :             /* Prepare to write next block */
; 922  :             count -= num;

  004be	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  004c2	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  004c9	2b c8		 sub	 ecx, eax
  004cb	8b c1		 mov	 eax, ecx
  004cd	89 84 24 60 03
	00 00		 mov	 DWORD PTR count$[rsp], eax

; 923  :             iobuf += num;

  004d4	48 63 44 24 70	 movsxd	 rax, DWORD PTR num$[rsp]
  004d9	48 8b 8c 24 78
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  004e1	48 03 c8	 add	 rcx, rax
  004e4	48 8b c1	 mov	 rax, rcx
  004e7	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR iobuf$[rsp], rax

; 924  :             dev->fbalcnum--;

  004ef	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004f7	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  004fe	66 ff c8	 dec	 ax
  00501	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00509	66 89 81 be 11
	00 00		 mov	 WORD PTR [rcx+4542], ax

; 925  : 
; 926  :         } /* end while */

  00510	e9 18 fe ff ff	 jmp	 $LN4@fba_dasd_e
$LN5@fba_dasd_e:

; 927  : 
; 928  :         /* Set residual byte count */
; 929  :         *residual = count;

  00515	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  0051d	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00524	89 08		 mov	 DWORD PTR [rax], ecx

; 930  :         if (dev->fbalcnum > 0) *more = 1;

  00526	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0052e	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  00535	85 c0		 test	 eax, eax
  00537	7e 0b		 jle	 SHORT $LN28@fba_dasd_e
  00539	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00541	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN28@fba_dasd_e:

; 931  : 
; 932  :         /* Set ending status */
; 933  :         *unitstat |= CSW_CE | CSW_DE;

  00544	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0054c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0054f	83 c8 0c	 or	 eax, 12
  00552	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  0055a	88 01		 mov	 BYTE PTR [rcx], al

; 934  :         break;

  0055c	e9 87 13 00 00	 jmp	 $LN2@fba_dasd_e
$LN29@fba_dasd_e:

; 935  : 
; 936  :     case 0x42:
; 937  :     /*---------------------------------------------------------------*/
; 938  :     /* READ                                                          */
; 939  :     /*---------------------------------------------------------------*/
; 940  :         /* Reject if previous command was not LOCATE or READ IPL */
; 941  :         if (prevcode != 0x43 && prevcode != 0x02)

  00561	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  00569	83 f8 43	 cmp	 eax, 67			; 00000043H
  0056c	74 36		 je	 SHORT $LN30@fba_dasd_e
  0056e	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  00576	83 f8 02	 cmp	 eax, 2
  00579	74 29		 je	 SHORT $LN30@fba_dasd_e

; 942  :         {
; 943  :             dev->sense[0] = SENSE_CR;

  0057b	b8 01 00 00 00	 mov	 eax, 1
  00580	48 6b c0 00	 imul	 rax, rax, 0
  00584	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0058c	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 944  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00594	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0059c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 945  :             break;

  0059f	e9 44 13 00 00	 jmp	 $LN2@fba_dasd_e
$LN30@fba_dasd_e:

; 946  :         }
; 947  : 
; 948  :         /* Reject if locate command did not specify read operation */
; 949  :         if (prevcode != 0x02
; 950  :             && (dev->fbaoper & FBAOPER_CODE) != FBAOPER_READ
; 951  :             && (dev->fbaoper & FBAOPER_CODE) != FBAOPER_READREP)

  005a4	0f b6 84 24 68
	03 00 00	 movzx	 eax, BYTE PTR prevcode$[rsp]
  005ac	83 f8 02	 cmp	 eax, 2
  005af	74 57		 je	 SHORT $LN31@fba_dasd_e
  005b1	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005b9	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  005c0	83 e0 0f	 and	 eax, 15
  005c3	83 f8 06	 cmp	 eax, 6
  005c6	74 40		 je	 SHORT $LN31@fba_dasd_e
  005c8	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005d0	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  005d7	83 e0 0f	 and	 eax, 15
  005da	83 f8 02	 cmp	 eax, 2
  005dd	74 29		 je	 SHORT $LN31@fba_dasd_e

; 952  :         {
; 953  :             dev->sense[0] = SENSE_CR;

  005df	b8 01 00 00 00	 mov	 eax, 1
  005e4	48 6b c0 00	 imul	 rax, rax, 0
  005e8	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  005f0	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 954  :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  005f8	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00600	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 955  :             break;

  00603	e9 e0 12 00 00	 jmp	 $LN2@fba_dasd_e
$LN31@fba_dasd_e:
$LN6@fba_dasd_e:

; 956  :         }
; 957  : 
; 958  :         /* Read physical blocks of data from device */
; 959  :         while (dev->fbalcnum > 0 && count > 0)

  00608	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00610	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  00617	85 c0		 test	 eax, eax
  00619	0f 8e 4e 01 00
	00		 jle	 $LN7@fba_dasd_e
  0061f	83 bc 24 60 03
	00 00 00	 cmp	 DWORD PTR count$[rsp], 0
  00627	0f 86 40 01 00
	00		 jbe	 $LN7@fba_dasd_e

; 960  :         {
; 961  :             /* Overrun if data chaining within a physical block */
; 962  :             if ((flags & CCW_FLAGS_CD) && count < (U32)dev->fbablksiz)

  0062d	0f b6 84 24 50
	03 00 00	 movzx	 eax, BYTE PTR flags$[rsp]
  00635	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0063a	85 c0		 test	 eax, eax
  0063c	74 40		 je	 SHORT $LN32@fba_dasd_e
  0063e	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00646	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  0064c	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00653	73 29		 jae	 SHORT $LN32@fba_dasd_e

; 963  :             {
; 964  :                 dev->sense[0] = SENSE_OR;

  00655	b8 01 00 00 00	 mov	 eax, 1
  0065a	48 6b c0 00	 imul	 rax, rax, 0
  0065e	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00666	c6 84 01 64 03
	00 00 04	 mov	 BYTE PTR [rcx+rax+868], 4

; 965  :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0066e	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00676	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 966  :                 break;

  00679	e9 ef 00 00 00	 jmp	 $LN7@fba_dasd_e
$LN32@fba_dasd_e:

; 967  :             }
; 968  : 
; 969  :             /* Calculate number of bytes to read */
; 970  :             num = (count < (U32)dev->fbablksiz) ?

  0067e	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00686	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  0068c	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  00693	73 10		 jae	 SHORT $LN88@fba_dasd_e
  00695	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  0069c	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv249[rsp], eax
  006a3	eb 15		 jmp	 SHORT $LN89@fba_dasd_e
$LN88@fba_dasd_e:
  006a5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006ad	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  006b3	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv249[rsp], eax
$LN89@fba_dasd_e:
  006ba	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR tv249[rsp]
  006c1	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 971  :                    count : (U32)dev->fbablksiz;
; 972  :             if (num < dev->fbablksiz) *more = 1;

  006c5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  006cd	8b 80 8c 11 00
	00		 mov	 eax, DWORD PTR [rax+4492]
  006d3	39 44 24 70	 cmp	 DWORD PTR num$[rsp], eax
  006d7	7d 0b		 jge	 SHORT $LN33@fba_dasd_e
  006d9	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  006e1	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN33@fba_dasd_e:

; 973  : 
; 974  :             /* Read physical block into channel buffer */
; 975  :             rc = fba_read (dev, iobuf, num, unitstat);

  006e4	4c 8b 8c 24 88
	03 00 00	 mov	 r9, QWORD PTR unitstat$[rsp]
  006ec	44 8b 44 24 70	 mov	 r8d, DWORD PTR num$[rsp]
  006f1	48 8b 94 24 78
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  006f9	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00701	e8 00 00 00 00	 call	 fba_read
  00706	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 976  :             if (rc < num) break;

  0070a	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  0070e	39 44 24 74	 cmp	 DWORD PTR rc$[rsp], eax
  00712	7d 02		 jge	 SHORT $LN34@fba_dasd_e
  00714	eb 57		 jmp	 SHORT $LN7@fba_dasd_e
$LN34@fba_dasd_e:

; 977  : 
; 978  :             /* Prepare to read next block */
; 979  :             count -= num;

  00716	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  0071a	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00721	2b c8		 sub	 ecx, eax
  00723	8b c1		 mov	 eax, ecx
  00725	89 84 24 60 03
	00 00		 mov	 DWORD PTR count$[rsp], eax

; 980  :             iobuf += num;

  0072c	48 63 44 24 70	 movsxd	 rax, DWORD PTR num$[rsp]
  00731	48 8b 8c 24 78
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00739	48 03 c8	 add	 rcx, rax
  0073c	48 8b c1	 mov	 rax, rcx
  0073f	48 89 84 24 78
	03 00 00	 mov	 QWORD PTR iobuf$[rsp], rax

; 981  :             dev->fbalcnum--;

  00747	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0074f	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  00756	66 ff c8	 dec	 ax
  00759	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00761	66 89 81 be 11
	00 00		 mov	 WORD PTR [rcx+4542], ax

; 982  : 
; 983  :         } /* end while */

  00768	e9 9b fe ff ff	 jmp	 $LN6@fba_dasd_e
$LN7@fba_dasd_e:

; 984  : 
; 985  :         /* Set residual byte count */
; 986  :         *residual = count;

  0076d	48 8b 84 24 90
	03 00 00	 mov	 rax, QWORD PTR residual$[rsp]
  00775	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  0077c	89 08		 mov	 DWORD PTR [rax], ecx

; 987  :         if (dev->fbalcnum > 0) *more = 1;

  0077e	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00786	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  0078d	85 c0		 test	 eax, eax
  0078f	7e 0b		 jle	 SHORT $LN35@fba_dasd_e
  00791	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  00799	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN35@fba_dasd_e:

; 988  : 
; 989  :         /* Set ending status */
; 990  :         *unitstat |= CSW_CE | CSW_DE;

  0079c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  007a4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  007a7	83 c8 0c	 or	 eax, 12
  007aa	48 8b 8c 24 88
	03 00 00	 mov	 rcx, QWORD PTR unitstat$[rsp]
  007b2	88 01		 mov	 BYTE PTR [rcx], al

; 991  : 
; 992  :         break;

  007b4	e9 2f 11 00 00	 jmp	 $LN2@fba_dasd_e
$LN36@fba_dasd_e:

; 993  : 
; 994  :     case 0x43:
; 995  :     /*---------------------------------------------------------------*/
; 996  :     /* LOCATE                                                        */
; 997  :     /*---------------------------------------------------------------*/
; 998  :         /* Calculate residual byte count */
; 999  :         num = (count < 8) ? count : 8;

  007b9	83 bc 24 60 03
	00 00 08	 cmp	 DWORD PTR count$[rsp], 8
  007c1	73 10		 jae	 SHORT $LN90@fba_dasd_e
  007c3	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  007ca	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv272[rsp], eax
  007d1	eb 0b		 jmp	 SHORT $LN91@fba_dasd_e
$LN90@fba_dasd_e:
  007d3	c7 84 24 8c 00
	00 00 08 00 00
	00		 mov	 DWORD PTR tv272[rsp], 8
$LN91@fba_dasd_e:
  007de	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv272[rsp]
  007e5	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 1000 :         *residual = count - num;

  007e9	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  007ed	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  007f4	2b c8		 sub	 ecx, eax
  007f6	8b c1		 mov	 eax, ecx
  007f8	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00800	89 01		 mov	 DWORD PTR [rcx], eax

; 1001 : 
; 1002 :         /* Control information length must be at least 8 bytes */
; 1003 :         if (count < 8)

  00802	83 bc 24 60 03
	00 00 08	 cmp	 DWORD PTR count$[rsp], 8
  0080a	73 29		 jae	 SHORT $LN37@fba_dasd_e

; 1004 :         {
; 1005 :             dev->sense[0] = SENSE_CR;

  0080c	b8 01 00 00 00	 mov	 eax, 1
  00811	48 6b c0 00	 imul	 rax, rax, 0
  00815	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0081d	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1006 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00825	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0082d	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1007 :             break;

  00830	e9 b3 10 00 00	 jmp	 $LN2@fba_dasd_e
$LN37@fba_dasd_e:

; 1008 :         }
; 1009 : 
; 1010 :         /* LOCATE must be preceded by DEFINE EXTENT or READ IPL */
; 1011 :         if (dev->fbaxtdef == 0)

  00835	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0083d	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  00843	83 e0 01	 and	 eax, 1
  00846	85 c0		 test	 eax, eax
  00848	75 29		 jne	 SHORT $LN38@fba_dasd_e

; 1012 :         {
; 1013 :             dev->sense[0] = SENSE_CR;

  0084a	b8 01 00 00 00	 mov	 eax, 1
  0084f	48 6b c0 00	 imul	 rax, rax, 0
  00853	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0085b	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1014 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00863	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0086b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1015 :             break;

  0086e	e9 75 10 00 00	 jmp	 $LN2@fba_dasd_e
$LN38@fba_dasd_e:

; 1016 :         }
; 1017 : 
; 1018 :         /* Save and validate the operation byte */
; 1019 :         dev->fbaoper = iobuf[0];

  00873	b8 01 00 00 00	 mov	 eax, 1
  00878	48 6b c0 00	 imul	 rax, rax, 0
  0087c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00884	48 8b 94 24 78
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0088c	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00890	88 81 bc 11 00
	00		 mov	 BYTE PTR [rcx+4540], al

; 1020 :         if (dev->fbaoper & FBAOPER_RESV)

  00896	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0089e	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  008a5	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  008aa	85 c0		 test	 eax, eax
  008ac	74 29		 je	 SHORT $LN39@fba_dasd_e

; 1021 :         {
; 1022 :             dev->sense[0] = SENSE_CR;

  008ae	b8 01 00 00 00	 mov	 eax, 1
  008b3	48 6b c0 00	 imul	 rax, rax, 0
  008b7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  008bf	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1023 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  008c7	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  008cf	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1024 :             break;

  008d2	e9 11 10 00 00	 jmp	 $LN2@fba_dasd_e
$LN39@fba_dasd_e:

; 1025 :         }
; 1026 : 
; 1027 :         /* Validate and process operation code */
; 1028 :         if ((dev->fbaoper & FBAOPER_CODE) == FBAOPER_WRITE
; 1029 :             || (dev->fbaoper & FBAOPER_CODE) == FBAOPER_WRTVRFY)

  008d7	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008df	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  008e6	83 e0 0f	 and	 eax, 15
  008e9	83 f8 01	 cmp	 eax, 1
  008ec	74 17		 je	 SHORT $LN42@fba_dasd_e
  008ee	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008f6	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  008fd	83 e0 0f	 and	 eax, 15
  00900	83 f8 05	 cmp	 eax, 5
  00903	75 47		 jne	 SHORT $LN40@fba_dasd_e
$LN42@fba_dasd_e:

; 1030 :         {
; 1031 :             /* Reject command if file mask inhibits all writes */
; 1032 :             if ((dev->fbamask & FBAMASK_CTL) == FBAMASK_CTL_INHWRT)

  00905	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0090d	0f b6 80 ac 11
	00 00		 movzx	 eax, BYTE PTR [rax+4524]
  00914	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00919	83 f8 40	 cmp	 eax, 64			; 00000040H
  0091c	75 29		 jne	 SHORT $LN43@fba_dasd_e

; 1033 :             {
; 1034 :                 dev->sense[0] = SENSE_CR;

  0091e	b8 01 00 00 00	 mov	 eax, 1
  00923	48 6b c0 00	 imul	 rax, rax, 0
  00927	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0092f	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1035 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00937	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0093f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1036 :                 break;

  00942	e9 a1 0f 00 00	 jmp	 $LN2@fba_dasd_e
$LN43@fba_dasd_e:

; 1037 :             }
; 1038 :         }

  00947	e9 b6 00 00 00	 jmp	 $LN41@fba_dasd_e
$LN40@fba_dasd_e:

; 1039 :         else if ((dev->fbaoper & FBAOPER_CODE) == FBAOPER_READ
; 1040 :                 || (dev->fbaoper & FBAOPER_CODE) == FBAOPER_READREP)

  0094c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00954	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  0095b	83 e0 0f	 and	 eax, 15
  0095e	83 f8 06	 cmp	 eax, 6
  00961	74 17		 je	 SHORT $LN46@fba_dasd_e
  00963	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0096b	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  00972	83 e0 0f	 and	 eax, 15
  00975	83 f8 02	 cmp	 eax, 2
  00978	75 05		 jne	 SHORT $LN44@fba_dasd_e
$LN46@fba_dasd_e:

; 1041 :         {
; 1042 :         }

  0097a	e9 83 00 00 00	 jmp	 $LN45@fba_dasd_e
$LN44@fba_dasd_e:

; 1043 :         else if ((dev->fbaoper & FBAOPER_CODE) == FBAOPER_FMTDEFC)

  0097f	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00987	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  0098e	83 e0 0f	 and	 eax, 15
  00991	83 f8 04	 cmp	 eax, 4
  00994	75 43		 jne	 SHORT $LN47@fba_dasd_e

; 1044 :         {
; 1045 :             /* Reject command if file mask inhibits format writes */
; 1046 :             if ((dev->fbamask & FBAMASK_CTL) == FBAMASK_CTL_INHFMT)

  00996	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0099e	0f b6 80 ac 11
	00 00		 movzx	 eax, BYTE PTR [rax+4524]
  009a5	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  009aa	85 c0		 test	 eax, eax
  009ac	75 29		 jne	 SHORT $LN49@fba_dasd_e

; 1047 :             {
; 1048 :                 dev->sense[0] = SENSE_CR;

  009ae	b8 01 00 00 00	 mov	 eax, 1
  009b3	48 6b c0 00	 imul	 rax, rax, 0
  009b7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009bf	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1049 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  009c7	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  009cf	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1050 :                 break;

  009d2	e9 11 0f 00 00	 jmp	 $LN2@fba_dasd_e
$LN49@fba_dasd_e:

; 1051 :             }
; 1052 :         }

  009d7	eb 29		 jmp	 SHORT $LN48@fba_dasd_e
$LN47@fba_dasd_e:

; 1053 :         else /* Operation code is invalid */
; 1054 :         {
; 1055 :             dev->sense[0] = SENSE_CR;

  009d9	b8 01 00 00 00	 mov	 eax, 1
  009de	48 6b c0 00	 imul	 rax, rax, 0
  009e2	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  009ea	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1056 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  009f2	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  009fa	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1057 :             break;

  009fd	e9 e6 0e 00 00	 jmp	 $LN2@fba_dasd_e
$LN48@fba_dasd_e:
$LN45@fba_dasd_e:
$LN41@fba_dasd_e:

; 1058 :         }
; 1059 : 
; 1060 :         /* Byte 1 contains the replication count */
; 1061 :         repcnt = iobuf[1];

  00a02	b8 01 00 00 00	 mov	 eax, 1
  00a07	48 6b c0 01	 imul	 rax, rax, 1
  00a0b	48 8b 8c 24 78
	03 00 00	 mov	 rcx, QWORD PTR iobuf$[rsp]
  00a13	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a17	89 84 24 90 00
	00 00		 mov	 DWORD PTR repcnt$[rsp], eax

; 1062 : 
; 1063 :         /* Bytes 2-3 contain the block count */
; 1064 :         dev->fbalcnum = fetch_hw(iobuf + 2);

  00a1e	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  00a26	48 83 c0 02	 add	 rax, 2
  00a2a	48 8b c8	 mov	 rcx, rax
  00a2d	e8 00 00 00 00	 call	 fetch_hw_noswap
  00a32	0f b7 c8	 movzx	 ecx, ax
  00a35	e8 00 00 00 00	 call	 _byteswap_ushort
  00a3a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a42	66 89 81 be 11
	00 00		 mov	 WORD PTR [rcx+4542], ax

; 1065 : 
; 1066 :         /* Bytes 4-7 contain the displacement of the first block
; 1067 :            relative to the start of the dataset */
; 1068 :         dev->fbalcblk = fetch_fw(iobuf + 4);

  00a49	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  00a51	48 83 c0 04	 add	 rax, 4
  00a55	48 8b c8	 mov	 rcx, rax
  00a58	e8 00 00 00 00	 call	 fetch_fw_noswap
  00a5d	8b c8		 mov	 ecx, eax
  00a5f	e8 00 00 00 00	 call	 _byteswap_ulong
  00a64	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a6c	89 81 c0 11 00
	00		 mov	 DWORD PTR [rcx+4544], eax

; 1069 : 
; 1070 :         /* Verify that the block count is non-zero, and that
; 1071 :            the starting and ending blocks fall within the extent */
; 1072 :         if (   dev->fbalcnum == 0
; 1073 :             || dev->fbalcnum >  dev->fbaxlast + 1
; 1074 :             || dev->fbalcblk <  dev->fbaxfirst
; 1075 :             || dev->fbalcblk >  dev->fbaxlast + 1 - dev->fbalcnum)

  00a72	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a7a	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  00a81	85 c0		 test	 eax, eax
  00a83	74 72		 je	 SHORT $LN51@fba_dasd_e
  00a85	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a8d	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  00a94	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a9c	8b 89 b8 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4536]
  00aa2	ff c1		 inc	 ecx
  00aa4	3b c1		 cmp	 eax, ecx
  00aa6	77 4f		 ja	 SHORT $LN51@fba_dasd_e
  00aa8	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ab0	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ab8	8b 89 b4 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4532]
  00abe	39 88 c0 11 00
	00		 cmp	 DWORD PTR [rax+4544], ecx
  00ac4	72 31		 jb	 SHORT $LN51@fba_dasd_e
  00ac6	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ace	8b 80 b8 11 00
	00		 mov	 eax, DWORD PTR [rax+4536]
  00ad4	ff c0		 inc	 eax
  00ad6	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ade	0f b7 89 be 11
	00 00		 movzx	 ecx, WORD PTR [rcx+4542]
  00ae5	2b c1		 sub	 eax, ecx
  00ae7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00aef	39 81 c0 11 00
	00		 cmp	 DWORD PTR [rcx+4544], eax
  00af5	76 29		 jbe	 SHORT $LN50@fba_dasd_e
$LN51@fba_dasd_e:

; 1076 :         {
; 1077 :             dev->sense[0] = SENSE_CR;

  00af7	b8 01 00 00 00	 mov	 eax, 1
  00afc	48 6b c0 00	 imul	 rax, rax, 0
  00b00	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b08	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1078 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00b10	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00b18	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1079 :             break;

  00b1b	e9 c8 0d 00 00	 jmp	 $LN2@fba_dasd_e
$LN50@fba_dasd_e:

; 1080 :         }
; 1081 : 
; 1082 :         /* For replicated data, verify that the replication count
; 1083 :            is non-zero and is a multiple of the block count */
; 1084 :         if ((dev->fbaoper & FBAOPER_CODE) == FBAOPER_READREP)

  00b20	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b28	0f b6 80 bc 11
	00 00		 movzx	 eax, BYTE PTR [rax+4540]
  00b2f	83 e0 0f	 and	 eax, 15
  00b32	83 f8 02	 cmp	 eax, 2
  00b35	75 60		 jne	 SHORT $LN52@fba_dasd_e

; 1085 :         {
; 1086 :             if (repcnt == 0 || repcnt % dev->fbalcnum != 0)

  00b37	83 bc 24 90 00
	00 00 00	 cmp	 DWORD PTR repcnt$[rsp], 0
  00b3f	74 2d		 je	 SHORT $LN54@fba_dasd_e
  00b41	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b49	0f b7 80 be 11
	00 00		 movzx	 eax, WORD PTR [rax+4542]
  00b50	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv373[rsp], eax
  00b57	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR repcnt$[rsp]
  00b5e	99		 cdq
  00b5f	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv373[rsp]
  00b66	f7 f9		 idiv	 ecx
  00b68	8b c2		 mov	 eax, edx
  00b6a	85 c0		 test	 eax, eax
  00b6c	74 29		 je	 SHORT $LN53@fba_dasd_e
$LN54@fba_dasd_e:

; 1087 :             {
; 1088 :                 dev->sense[0] = SENSE_CR;

  00b6e	b8 01 00 00 00	 mov	 eax, 1
  00b73	48 6b c0 00	 imul	 rax, rax, 0
  00b77	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00b7f	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1089 :                 *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00b87	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00b8f	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1090 :                 break;

  00b92	e9 51 0d 00 00	 jmp	 $LN2@fba_dasd_e
$LN53@fba_dasd_e:
$LN52@fba_dasd_e:

; 1091 :             }
; 1092 :         }
; 1093 : 
; 1094 :         /* Position device to start of block */
; 1095 :         dev->fbarba = (dev->fbaorigin

  00b97	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b9f	8b 80 b0 11 00
	00		 mov	 eax, DWORD PTR [rax+4528]
  00ba5	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bad	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  00bb4	48 03 c8	 add	 rcx, rax
  00bb7	48 8b c1	 mov	 rax, rcx
  00bba	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bc2	8b 89 c0 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4544]
  00bc8	48 03 c1	 add	 rax, rcx
  00bcb	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bd3	8b 89 b4 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4532]
  00bd9	48 2b c1	 sub	 rax, rcx
  00bdc	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00be4	48 63 89 8c 11
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4492]
  00beb	48 0f af c1	 imul	 rax, rcx
  00bef	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00bf7	48 89 81 98 11
	00 00		 mov	 QWORD PTR [rcx+4504], rax

; 1096 :                      + dev->fbaxblkn
; 1097 :                      + dev->fbalcblk - dev->fbaxfirst
; 1098 :                       ) * dev->fbablksiz;
; 1099 : 
; 1100 :         // "%1d:%04X FBA file %s: positioning to 0x%"PRIX64" %"PRId64
; 1101 :         if (dev->ccwtrace && sysblk.traceFILE)

  00bfe	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c06	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00c0c	c1 e8 0f	 shr	 eax, 15
  00c0f	83 e0 01	 and	 eax, 1
  00c12	85 c0		 test	 eax, eax
  00c14	74 24		 je	 SHORT $LN55@fba_dasd_e
  00c16	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00c1d	48 83 b8 20 14
	00 00 00	 cmp	 QWORD PTR [rax+5152], 0
  00c25	74 13		 je	 SHORT $LN55@fba_dasd_e

; 1102 :             tf_0520( dev );

  00c27	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_tf_0520
  00c35	e9 f6 00 00 00	 jmp	 $LN56@fba_dasd_e
$LN55@fba_dasd_e:
$LN10@fba_dasd_e:

; 1103 :         else
; 1104 :             LOGDEVTR( HHC00520, "I", dev->filename, dev->fbarba, dev->fbarba );

  00c3a	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c42	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00c48	c1 e8 0f	 shr	 eax, 15
  00c4b	83 e0 01	 and	 eax, 1
  00c4e	85 c0		 test	 eax, eax
  00c50	0f 84 d0 00 00
	00		 je	 $LN57@fba_dasd_e
  00c56	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c5e	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00c64	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR tv408[rsp], rax
  00c6c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c74	0f b7 49 48	 movzx	 ecx, WORD PTR [rcx+72]
  00c78	89 8c 24 cc 00
	00 00		 mov	 DWORD PTR tv411[rsp], ecx
  00c7f	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00c87	0f b7 52 44	 movzx	 edx, WORD PTR [rdx+68]
  00c8b	d1 fa		 sar	 edx, 1
  00c8d	89 94 24 d0 00
	00 00		 mov	 DWORD PTR tv415[rsp], edx
  00c94	b9 01 00 00 00	 mov	 ecx, 1
  00c99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00c9f	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ca7	48 8b 89 98 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4504]
  00cae	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00cb3	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00cbb	48 8b 89 98 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4504]
  00cc2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00cc7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR tv408[rsp]
  00ccf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00cd4	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv411[rsp]
  00cdb	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00cdf	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv415[rsp]
  00ce6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00cea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170286
  00cf1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00cf6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170287
  00cfd	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00d02	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00d07	41 b9 03 00 00
	00		 mov	 r9d, 3
  00d0d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170288
  00d14	ba 50 04 00 00	 mov	 edx, 1104		; 00000450H
  00d19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170289
  00d20	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN57@fba_dasd_e:
  00d26	33 c0		 xor	 eax, eax
  00d28	85 c0		 test	 eax, eax
  00d2a	0f 85 0a ff ff
	ff		 jne	 $LN10@fba_dasd_e
$LN56@fba_dasd_e:

; 1105 : 
; 1106 :         /* Return normal status */
; 1107 :         *unitstat = CSW_CE | CSW_DE;

  00d30	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00d38	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1108 :         break;

  00d3b	e9 a8 0b 00 00	 jmp	 $LN2@fba_dasd_e
$LN58@fba_dasd_e:

; 1109 : 
; 1110 :     case 0x63:
; 1111 :     /*---------------------------------------------------------------*/
; 1112 :     /* DEFINE EXTENT                                                 */
; 1113 :     /*---------------------------------------------------------------*/
; 1114 :         /* Calculate residual byte count */
; 1115 :         num = (count < 16) ? count : 16;

  00d40	83 bc 24 60 03
	00 00 10	 cmp	 DWORD PTR count$[rsp], 16
  00d48	73 10		 jae	 SHORT $LN92@fba_dasd_e
  00d4a	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  00d51	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv428[rsp], eax
  00d58	eb 0b		 jmp	 SHORT $LN93@fba_dasd_e
$LN92@fba_dasd_e:
  00d5a	c7 84 24 94 00
	00 00 10 00 00
	00		 mov	 DWORD PTR tv428[rsp], 16
$LN93@fba_dasd_e:
  00d65	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR tv428[rsp]
  00d6c	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 1116 :         *residual = count - num;

  00d70	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  00d74	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00d7b	2b c8		 sub	 ecx, eax
  00d7d	8b c1		 mov	 eax, ecx
  00d7f	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  00d87	89 01		 mov	 DWORD PTR [rcx], eax

; 1117 : 
; 1118 :         /* Control information length must be at least 16 bytes */
; 1119 :         if (count < 16)

  00d89	83 bc 24 60 03
	00 00 10	 cmp	 DWORD PTR count$[rsp], 16
  00d91	0f 83 0c 01 00
	00		 jae	 $LN59@fba_dasd_e

; 1120 :         {
; 1121 :             // "%1d:%04X FBA file %s: define extent data too short: %d bytes"
; 1122 :             WRMSG( HHC00509, "E", LCSS_DEVNUM, dev->filename, count );

  00d97	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00da0	74 15		 je	 SHORT $LN94@fba_dasd_e
  00da2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00daa	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00dae	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv437[rsp], eax
  00db5	eb 0b		 jmp	 SHORT $LN95@fba_dasd_e
$LN94@fba_dasd_e:
  00db7	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv437[rsp], 0
$LN95@fba_dasd_e:
  00dc2	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00dcb	74 17		 je	 SHORT $LN96@fba_dasd_e
  00dcd	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00dd5	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00dd9	d1 f8		 sar	 eax, 1
  00ddb	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv443[rsp], eax
  00de2	eb 0b		 jmp	 SHORT $LN97@fba_dasd_e
$LN96@fba_dasd_e:
  00de4	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv443[rsp], 0
$LN97@fba_dasd_e:
  00def	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00df7	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00dfd	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv432[rsp], rax
  00e05	b9 01 00 00 00	 mov	 ecx, 1
  00e0a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00e10	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  00e17	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  00e1b	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR tv432[rsp]
  00e23	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00e28	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv437[rsp]
  00e2f	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00e33	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv443[rsp]
  00e3a	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e3e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170292
  00e45	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e4a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170293
  00e51	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e56	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e5b	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e61	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170294
  00e68	ba 62 04 00 00	 mov	 edx, 1122		; 00000462H
  00e6d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170295
  00e74	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1123 :             dev->sense[0] = SENSE_CR;

  00e7a	b8 01 00 00 00	 mov	 eax, 1
  00e7f	48 6b c0 00	 imul	 rax, rax, 0
  00e83	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00e8b	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1124 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00e93	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00e9b	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1125 :             break;

  00e9e	e9 45 0a 00 00	 jmp	 $LN2@fba_dasd_e
$LN59@fba_dasd_e:

; 1126 :         }
; 1127 : 
; 1128 :         /* Reject if extent previously defined in this CCW chain */
; 1129 :         if (dev->fbaxtdef)

  00ea3	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00eab	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  00eb1	83 e0 01	 and	 eax, 1
  00eb4	85 c0		 test	 eax, eax
  00eb6	0f 84 01 01 00
	00		 je	 $LN60@fba_dasd_e

; 1130 :         {
; 1131 :             // "%1d:%04X FBA file %s: second define extent in chain"
; 1132 :             WRMSG( HHC00510, "E", LCSS_DEVNUM, dev->filename );

  00ebc	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ec5	74 15		 je	 SHORT $LN98@fba_dasd_e
  00ec7	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ecf	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00ed3	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv465[rsp], eax
  00eda	eb 0b		 jmp	 SHORT $LN99@fba_dasd_e
$LN98@fba_dasd_e:
  00edc	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv465[rsp], 0
$LN99@fba_dasd_e:
  00ee7	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00ef0	74 17		 je	 SHORT $LN100@fba_dasd_e
  00ef2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00efa	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00efe	d1 f8		 sar	 eax, 1
  00f00	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv471[rsp], eax
  00f07	eb 0b		 jmp	 SHORT $LN101@fba_dasd_e
$LN100@fba_dasd_e:
  00f09	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv471[rsp], 0
$LN101@fba_dasd_e:
  00f14	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f1c	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00f22	48 89 84 24 e8
	00 00 00	 mov	 QWORD PTR tv460[rsp], rax
  00f2a	b9 01 00 00 00	 mov	 ecx, 1
  00f2f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00f35	48 8b 8c 24 e8
	00 00 00	 mov	 rcx, QWORD PTR tv460[rsp]
  00f3d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00f42	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv465[rsp]
  00f49	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00f4d	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv471[rsp]
  00f54	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00f58	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170297
  00f5f	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00f64	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170298
  00f6b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f70	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f75	41 b9 03 00 00
	00		 mov	 r9d, 3
  00f7b	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170299
  00f82	ba 6c 04 00 00	 mov	 edx, 1132		; 0000046cH
  00f87	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170300
  00f8e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1133 :             dev->sense[0] = SENSE_CR;

  00f94	b8 01 00 00 00	 mov	 eax, 1
  00f99	48 6b c0 00	 imul	 rax, rax, 0
  00f9d	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fa5	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1134 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00fad	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  00fb5	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1135 :             break;

  00fb8	e9 2b 09 00 00	 jmp	 $LN2@fba_dasd_e
$LN60@fba_dasd_e:

; 1136 :         }
; 1137 : 
; 1138 :         /* Save and validate the file mask */
; 1139 :         dev->fbamask = iobuf[0];

  00fbd	b8 01 00 00 00	 mov	 eax, 1
  00fc2	48 6b c0 00	 imul	 rax, rax, 0
  00fc6	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fce	48 8b 94 24 78
	03 00 00	 mov	 rdx, QWORD PTR iobuf$[rsp]
  00fd6	0f b6 04 02	 movzx	 eax, BYTE PTR [rdx+rax]
  00fda	88 81 ac 11 00
	00		 mov	 BYTE PTR [rcx+4524], al

; 1140 :         if ((dev->fbamask & (FBAMASK_RESV | FBAMASK_CE))
; 1141 :             || (dev->fbamask & FBAMASK_CTL) == FBAMASK_CTL_RESV)

  00fe0	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00fe8	0f b6 80 ac 11
	00 00		 movzx	 eax, BYTE PTR [rax+4524]
  00fef	83 e0 3b	 and	 eax, 59			; 0000003bH
  00ff2	85 c0		 test	 eax, eax
  00ff4	75 1f		 jne	 SHORT $LN62@fba_dasd_e
  00ff6	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ffe	0f b6 80 ac 11
	00 00		 movzx	 eax, BYTE PTR [rax+4524]
  01005	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0100a	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  0100f	0f 85 23 01 00
	00		 jne	 $LN61@fba_dasd_e
$LN62@fba_dasd_e:

; 1142 :         {
; 1143 :             // "%1d:%04X FBA file %s: invalid file mask %2.2X"
; 1144 :             WRMSG( HHC00511, "E", LCSS_DEVNUM, dev->filename, dev->fbamask );

  01015	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0101e	74 15		 je	 SHORT $LN102@fba_dasd_e
  01020	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01028	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0102c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv504[rsp], eax
  01033	eb 0b		 jmp	 SHORT $LN103@fba_dasd_e
$LN102@fba_dasd_e:
  01035	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv504[rsp], 0
$LN103@fba_dasd_e:
  01040	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01049	74 17		 je	 SHORT $LN104@fba_dasd_e
  0104b	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01053	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01057	d1 f8		 sar	 eax, 1
  01059	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv510[rsp], eax
  01060	eb 0b		 jmp	 SHORT $LN105@fba_dasd_e
$LN104@fba_dasd_e:
  01062	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv510[rsp], 0
$LN105@fba_dasd_e:
  0106d	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01075	0f b6 80 ac 11
	00 00		 movzx	 eax, BYTE PTR [rax+4524]
  0107c	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv497[rsp], eax
  01083	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0108b	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  01092	48 89 8c 24 f0
	00 00 00	 mov	 QWORD PTR tv499[rsp], rcx
  0109a	b9 01 00 00 00	 mov	 ecx, 1
  0109f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  010a5	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv497[rsp]
  010ac	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  010b0	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv499[rsp]
  010b8	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  010bd	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv504[rsp]
  010c4	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  010c8	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv510[rsp]
  010cf	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  010d3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170303
  010da	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  010df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170304
  010e6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  010eb	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  010f0	41 b9 03 00 00
	00		 mov	 r9d, 3
  010f6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170305
  010fd	ba 78 04 00 00	 mov	 edx, 1144		; 00000478H
  01102	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170306
  01109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1145 :             dev->sense[0] = SENSE_CR;

  0110f	b8 01 00 00 00	 mov	 eax, 1
  01114	48 6b c0 00	 imul	 rax, rax, 0
  01118	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01120	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1146 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  01128	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01130	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1147 :             break;

  01133	e9 b0 07 00 00	 jmp	 $LN2@fba_dasd_e
$LN61@fba_dasd_e:

; 1148 :         }
; 1149 : 
; 1150 : //      VM/ESA sends 0x00000200 0x00000000 0x00000000 0x0001404F
; 1151 : //      /* Verify that bytes 1-3 are zeroes */
; 1152 : //      if (iobuf[1] != 0 || iobuf[2] != 0 || iobuf[3] != 0)
; 1153 : //      {
; 1154 : //          LOGMSG( "fbadasd: invalid reserved bytes %2.2X %2.2X %2.2X\n",
; 1155 : //                  iobuf[1], iobuf[2], iobuf[3] );
; 1156 : //          dev->sense[0] = SENSE_CR;
; 1157 : //          *unitstat = CSW_CE | CSW_DE | CSW_UC;
; 1158 : //          break;
; 1159 : //      }
; 1160 : 
; 1161 :         /* Bytes 4-7 contain the block number of the first block
; 1162 :            of the extent relative to the start of the device */
; 1163 :         dev->fbaxblkn = fetch_fw(iobuf + 4);

  01138	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  01140	48 83 c0 04	 add	 rax, 4
  01144	48 8b c8	 mov	 rcx, rax
  01147	e8 00 00 00 00	 call	 fetch_fw_noswap
  0114c	8b c8		 mov	 ecx, eax
  0114e	e8 00 00 00 00	 call	 _byteswap_ulong
  01153	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0115b	89 81 b0 11 00
	00		 mov	 DWORD PTR [rcx+4528], eax

; 1164 : 
; 1165 :         /* Bytes 8-11 contain the block number of the first block
; 1166 :            of the extent relative to the start of the dataset */
; 1167 :         dev->fbaxfirst = fetch_fw(iobuf + 8);

  01161	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  01169	48 83 c0 08	 add	 rax, 8
  0116d	48 8b c8	 mov	 rcx, rax
  01170	e8 00 00 00 00	 call	 fetch_fw_noswap
  01175	8b c8		 mov	 ecx, eax
  01177	e8 00 00 00 00	 call	 _byteswap_ulong
  0117c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01184	89 81 b4 11 00
	00		 mov	 DWORD PTR [rcx+4532], eax

; 1168 : 
; 1169 :         /* Bytes 12-15 contain the block number of the last block
; 1170 :            of the extent relative to the start of the dataset */
; 1171 :         dev->fbaxlast = fetch_fw(iobuf + 12);

  0118a	48 8b 84 24 78
	03 00 00	 mov	 rax, QWORD PTR iobuf$[rsp]
  01192	48 83 c0 0c	 add	 rax, 12
  01196	48 8b c8	 mov	 rcx, rax
  01199	e8 00 00 00 00	 call	 fetch_fw_noswap
  0119e	8b c8		 mov	 ecx, eax
  011a0	e8 00 00 00 00	 call	 _byteswap_ulong
  011a5	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011ad	89 81 b8 11 00
	00		 mov	 DWORD PTR [rcx+4536], eax

; 1172 : 
; 1173 :         /* Validate the extent description by checking that the
; 1174 :            ending block is not less than the starting block and
; 1175 :            that the ending block does not exceed the device size */
; 1176 :         if (dev->fbaxlast < dev->fbaxfirst
; 1177 :          || dev->fbaxblkn > (U32)dev->fbanumblk
; 1178 :          || dev->fbaxlast - dev->fbaxfirst >= dev->fbanumblk - dev->fbaxblkn)

  011b3	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011bb	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011c3	8b 89 b4 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4532]
  011c9	39 88 b8 11 00
	00		 cmp	 DWORD PTR [rax+4536], ecx
  011cf	72 62		 jb	 SHORT $LN64@fba_dasd_e
  011d1	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011d9	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011e1	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  011e7	39 88 b0 11 00
	00		 cmp	 DWORD PTR [rax+4528], ecx
  011ed	77 44		 ja	 SHORT $LN64@fba_dasd_e
  011ef	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011f7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011ff	8b 89 b4 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4532]
  01205	8b 80 b8 11 00
	00		 mov	 eax, DWORD PTR [rax+4536]
  0120b	2b c1		 sub	 eax, ecx
  0120d	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01215	48 8b 94 24 40
	03 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0121d	8b 92 b0 11 00
	00		 mov	 edx, DWORD PTR [rdx+4528]
  01223	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  01229	2b ca		 sub	 ecx, edx
  0122b	3b c1		 cmp	 eax, ecx
  0122d	0f 82 49 01 00
	00		 jb	 $LN63@fba_dasd_e
$LN64@fba_dasd_e:

; 1179 :         {
; 1180 :             // "%1d:%04X FBA file %s: invalid extent: first block %d last block %d numblks %d device size %d"
; 1181 :             WRMSG( HHC00512, "E", LCSS_DEVNUM,

  01233	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0123c	74 15		 je	 SHORT $LN106@fba_dasd_e
  0123e	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01246	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0124a	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv568[rsp], eax
  01251	eb 0b		 jmp	 SHORT $LN107@fba_dasd_e
$LN106@fba_dasd_e:
  01253	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv568[rsp], 0
$LN107@fba_dasd_e:
  0125e	48 83 bc 24 40
	03 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01267	74 17		 je	 SHORT $LN108@fba_dasd_e
  01269	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01271	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01275	d1 f8		 sar	 eax, 1
  01277	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv574[rsp], eax
  0127e	eb 0b		 jmp	 SHORT $LN109@fba_dasd_e
$LN108@fba_dasd_e:
  01280	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv574[rsp], 0
$LN109@fba_dasd_e:
  0128b	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01293	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  01299	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv563[rsp], rax
  012a1	b9 01 00 00 00	 mov	 ecx, 1
  012a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  012ac	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012b4	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  012ba	89 4c 24 68	 mov	 DWORD PTR [rsp+104], ecx
  012be	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012c6	8b 89 b0 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4528]
  012cc	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  012d0	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012d8	8b 89 b8 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4536]
  012de	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  012e2	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012ea	8b 89 b4 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4532]
  012f0	89 4c 24 50	 mov	 DWORD PTR [rsp+80], ecx
  012f4	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv563[rsp]
  012fc	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01301	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv568[rsp]
  01308	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0130c	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv574[rsp]
  01313	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01317	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170309
  0131e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01323	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170310
  0132a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0132f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01334	41 b9 03 00 00
	00		 mov	 r9d, 3
  0133a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170311
  01341	ba 9f 04 00 00	 mov	 edx, 1183		; 0000049fH
  01346	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170312
  0134d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1182 :                    dev->filename, dev->fbaxfirst, dev->fbaxlast,
; 1183 :                    dev->fbaxblkn, dev->fbanumblk );
; 1184 :             dev->sense[0] = SENSE_CR;

  01353	b8 01 00 00 00	 mov	 eax, 1
  01358	48 6b c0 00	 imul	 rax, rax, 0
  0135c	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01364	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1185 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0136c	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01374	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1186 :             break;

  01377	e9 6c 05 00 00	 jmp	 $LN2@fba_dasd_e
$LN63@fba_dasd_e:

; 1187 :         }
; 1188 : 
; 1189 :         /* Set extent defined flag and return normal status */
; 1190 :         dev->fbaxtdef = 1;

  0137c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01384	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  0138a	83 c8 01	 or	 eax, 1
  0138d	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01395	89 81 a8 11 00
	00		 mov	 DWORD PTR [rcx+4520], eax

; 1191 :         *unitstat = CSW_CE | CSW_DE;

  0139b	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  013a3	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1192 :         break;

  013a6	e9 3d 05 00 00	 jmp	 $LN2@fba_dasd_e
$LN65@fba_dasd_e:

; 1193 : 
; 1194 :     case 0x64:
; 1195 :     /*---------------------------------------------------------------*/
; 1196 :     /* READ DEVICE CHARACTERISTICS                                   */
; 1197 :     /*---------------------------------------------------------------*/
; 1198 :         /* Calculate residual byte count */
; 1199 :         num = (count < dev->numdevchar) ? count : dev->numdevchar;

  013ab	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013b3	8b 80 68 05 00
	00		 mov	 eax, DWORD PTR [rax+1384]
  013b9	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  013c0	73 10		 jae	 SHORT $LN110@fba_dasd_e
  013c2	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  013c9	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv594[rsp], eax
  013d0	eb 15		 jmp	 SHORT $LN111@fba_dasd_e
$LN110@fba_dasd_e:
  013d2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013da	8b 80 68 05 00
	00		 mov	 eax, DWORD PTR [rax+1384]
  013e0	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv594[rsp], eax
$LN111@fba_dasd_e:
  013e7	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR tv594[rsp]
  013ee	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 1200 :         *residual = count - num;

  013f2	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  013f6	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  013fd	2b c8		 sub	 ecx, eax
  013ff	8b c1		 mov	 eax, ecx
  01401	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01409	89 01		 mov	 DWORD PTR [rcx], eax

; 1201 :         if (count < dev->numdevchar) *more = 1;

  0140b	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01413	8b 80 68 05 00
	00		 mov	 eax, DWORD PTR [rax+1384]
  01419	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  01420	73 0b		 jae	 SHORT $LN66@fba_dasd_e
  01422	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  0142a	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN66@fba_dasd_e:

; 1202 : 
; 1203 :         /* Copy device characteristics bytes to channel buffer */
; 1204 :         memcpy (iobuf, dev->devchar, num);

  0142d	48 63 44 24 70	 movsxd	 rax, DWORD PTR num$[rsp]
  01432	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0143a	48 81 c1 6c 05
	00 00		 add	 rcx, 1388		; 0000056cH
  01441	48 8b bc 24 78
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01449	48 8b f1	 mov	 rsi, rcx
  0144c	48 8b c8	 mov	 rcx, rax
  0144f	f3 a4		 rep movsb

; 1205 : 
; 1206 :         *unitstat = CSW_CE | CSW_DE;

  01451	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01459	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1207 :         break;

  0145c	e9 87 04 00 00	 jmp	 $LN2@fba_dasd_e
$LN67@fba_dasd_e:

; 1208 : 
; 1209 :     case 0x94:
; 1210 :     /*---------------------------------------------------------------*/
; 1211 :     /* DEVICE RELEASE                                                */
; 1212 :     /*---------------------------------------------------------------*/
; 1213 :         /* Reject if extent previously defined in this CCW chain */
; 1214 :         if (dev->fbaxtdef)

  01461	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01469	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  0146f	83 e0 01	 and	 eax, 1
  01472	85 c0		 test	 eax, eax
  01474	74 29		 je	 SHORT $LN68@fba_dasd_e

; 1215 :         {
; 1216 :             dev->sense[0] = SENSE_CR;

  01476	b8 01 00 00 00	 mov	 eax, 1
  0147b	48 6b c0 00	 imul	 rax, rax, 0
  0147f	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01487	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1217 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0148f	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01497	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1218 :             break;

  0149a	e9 49 04 00 00	 jmp	 $LN2@fba_dasd_e
$LN68@fba_dasd_e:

; 1219 :         }
; 1220 : 
; 1221 :         if (dev->hnd->release) (dev->hnd->release) (dev);

  0149f	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014a7	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  014ae	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  014b3	74 1a		 je	 SHORT $LN69@fba_dasd_e
  014b5	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014bd	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  014c4	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  014cc	ff 50 70	 call	 QWORD PTR [rax+112]
$LN69@fba_dasd_e:

; 1222 : 
; 1223 :         obtain_lock (&dev->lock);

  014cf	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014d7	48 83 c0 38	 add	 rax, 56			; 00000038H
  014db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170318
  014e2	48 8b c8	 mov	 rcx, rax
  014e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1224 :         dev->reserved = 0;

  014eb	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014f3	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  014f9	0f ba f0 14	 btr	 eax, 20
  014fd	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01505	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1225 :         release_lock (&dev->lock);

  0150b	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01513	48 83 c0 38	 add	 rax, 56			; 00000038H
  01517	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170319
  0151e	48 8b c8	 mov	 rcx, rax
  01521	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1226 : 
; 1227 :         /* Return sense information */
; 1228 :         goto sense;

  01527	e9 86 01 00 00	 jmp	 $sense$121
$LN70@fba_dasd_e:

; 1229 : 
; 1230 :     case 0xB4:
; 1231 :     /*---------------------------------------------------------------*/
; 1232 :     /* DEVICE RESERVE                                                */
; 1233 :     /*---------------------------------------------------------------*/
; 1234 :         /* Reject if extent previously defined in this CCW chain */
; 1235 :         if (dev->fbaxtdef)

  0152c	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01534	8b 80 a8 11 00
	00		 mov	 eax, DWORD PTR [rax+4520]
  0153a	83 e0 01	 and	 eax, 1
  0153d	85 c0		 test	 eax, eax
  0153f	74 29		 je	 SHORT $LN71@fba_dasd_e

; 1236 :         {
; 1237 :             dev->sense[0] = SENSE_CR;

  01541	b8 01 00 00 00	 mov	 eax, 1
  01546	48 6b c0 00	 imul	 rax, rax, 0
  0154a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01552	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1238 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0155a	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01562	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1239 :             break;

  01565	e9 7e 03 00 00	 jmp	 $LN2@fba_dasd_e
$LN71@fba_dasd_e:

; 1240 :         }
; 1241 : 
; 1242 :         /* Reserve device to the ID of the active channel program */
; 1243 : 
; 1244 :         obtain_lock (&dev->lock);

  0156a	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01572	48 83 c0 38	 add	 rax, 56			; 00000038H
  01576	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170322
  0157d	48 8b c8	 mov	 rcx, rax
  01580	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1245 :         dev->reserved = 1;

  01586	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0158e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01594	0f ba e8 14	 bts	 eax, 20
  01598	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  015a0	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1246 :         release_lock (&dev->lock);

  015a6	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015ae	48 83 c0 38	 add	 rax, 56			; 00000038H
  015b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170323
  015b9	48 8b c8	 mov	 rcx, rax
  015bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1247 : 
; 1248 :         if (dev->hnd->reserve) (dev->hnd->reserve) (dev);

  015c2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015ca	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  015d1	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  015d6	74 1a		 je	 SHORT $LN72@fba_dasd_e
  015d8	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015e0	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  015e7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  015ef	ff 50 68	 call	 QWORD PTR [rax+104]
$LN72@fba_dasd_e:

; 1249 : 
; 1250 :         /* Return sense information */
; 1251 :         goto sense;

  015f2	e9 bb 00 00 00	 jmp	 $sense$121
$LN73@fba_dasd_e:

; 1252 : 
; 1253 :     case 0x14:
; 1254 :     /*---------------------------------------------------------------*/
; 1255 :     /* UNCONDITIONAL RESERVE                                         */
; 1256 :     /*---------------------------------------------------------------*/
; 1257 :         /* Reject if this is not the first CCW in the chain */
; 1258 :         if (ccwseq > 0)

  015f7	83 bc 24 70 03
	00 00 00	 cmp	 DWORD PTR ccwseq$[rsp], 0
  015ff	7e 29		 jle	 SHORT $LN74@fba_dasd_e

; 1259 :         {
; 1260 :             dev->sense[0] = SENSE_CR;

  01601	b8 01 00 00 00	 mov	 eax, 1
  01606	48 6b c0 00	 imul	 rax, rax, 0
  0160a	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01612	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1261 :             *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0161a	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01622	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1262 :             break;

  01625	e9 be 02 00 00	 jmp	 $LN2@fba_dasd_e
$LN74@fba_dasd_e:

; 1263 :         }
; 1264 : 
; 1265 :         /* Reserve device to the ID of the active channel program */
; 1266 : 
; 1267 :         obtain_lock (&dev->lock);

  0162a	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01632	48 83 c0 38	 add	 rax, 56			; 00000038H
  01636	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170327
  0163d	48 8b c8	 mov	 rcx, rax
  01640	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1268 :         dev->reserved = 1;

  01646	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0164e	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01654	0f ba e8 14	 bts	 eax, 20
  01658	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01660	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 1269 :         release_lock (&dev->lock);

  01666	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0166e	48 83 c0 38	 add	 rax, 56			; 00000038H
  01672	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170328
  01679	48 8b c8	 mov	 rcx, rax
  0167c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1270 : 
; 1271 :         if (dev->hnd->reserve) (dev->hnd->reserve) (dev);

  01682	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0168a	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  01691	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  01696	74 1a		 je	 SHORT $LN75@fba_dasd_e
  01698	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016a0	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  016a7	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  016af	ff 50 68	 call	 QWORD PTR [rax+104]
$LN75@fba_dasd_e:
$LN76@fba_dasd_e:
$sense$121:

; 1272 : 
; 1273 :         /* Return sense information */
; 1274 :         goto sense;
; 1275 : 
; 1276 :     case 0x04:
; 1277 :     /*---------------------------------------------------------------*/
; 1278 :     /* SENSE                                                         */
; 1279 :     /*---------------------------------------------------------------*/
; 1280 :     sense:
; 1281 :         /* Calculate residual byte count */
; 1282 :         num = (count < dev->numsense) ? count : dev->numsense;

  016b2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016ba	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  016c0	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  016c7	73 10		 jae	 SHORT $LN112@fba_dasd_e
  016c9	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  016d0	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv669[rsp], eax
  016d7	eb 15		 jmp	 SHORT $LN113@fba_dasd_e
$LN112@fba_dasd_e:
  016d9	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016e1	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  016e7	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv669[rsp], eax
$LN113@fba_dasd_e:
  016ee	8b 84 24 bc 00
	00 00		 mov	 eax, DWORD PTR tv669[rsp]
  016f5	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 1283 :         *residual = count - num;

  016f9	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  016fd	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  01704	2b c8		 sub	 ecx, eax
  01706	8b c1		 mov	 eax, ecx
  01708	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  01710	89 01		 mov	 DWORD PTR [rcx], eax

; 1284 :         if (count < dev->numsense) *more = 1;

  01712	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0171a	8b 80 60 03 00
	00		 mov	 eax, DWORD PTR [rax+864]
  01720	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  01727	73 0b		 jae	 SHORT $LN77@fba_dasd_e
  01729	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01731	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN77@fba_dasd_e:

; 1285 : 
; 1286 :         /* Copy device sense bytes to channel I/O buffer */
; 1287 :         memcpy (iobuf, dev->sense, num);

  01734	48 63 44 24 70	 movsxd	 rax, DWORD PTR num$[rsp]
  01739	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01741	48 81 c1 64 03
	00 00		 add	 rcx, 868		; 00000364H
  01748	48 8b bc 24 78
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01750	48 8b f1	 mov	 rsi, rcx
  01753	48 8b c8	 mov	 rcx, rax
  01756	f3 a4		 rep movsb

; 1288 : 
; 1289 :         /* Clear the device sense bytes */
; 1290 :         memset(dev->sense, 0, sizeof(dev->sense));

  01758	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01760	48 05 64 03 00
	00		 add	 rax, 868		; 00000364H
  01766	48 8b f8	 mov	 rdi, rax
  01769	33 c0		 xor	 eax, eax
  0176b	b9 00 01 00 00	 mov	 ecx, 256		; 00000100H
  01770	f3 aa		 rep stosb

; 1291 : 
; 1292 :         /* Return unit status */
; 1293 :         *unitstat = CSW_CE | CSW_DE;

  01772	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  0177a	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1294 :         break;

  0177d	e9 66 01 00 00	 jmp	 $LN2@fba_dasd_e
$LN78@fba_dasd_e:

; 1295 : 
; 1296 :     case 0xE4:
; 1297 :     /*---------------------------------------------------------------*/
; 1298 :     /* SENSE ID                                                      */
; 1299 :     /*---------------------------------------------------------------*/
; 1300 :         /* Calculate residual byte count */
; 1301 :         num = (count < dev->numdevid) ? count : dev->numdevid;

  01782	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0178a	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  01790	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  01797	73 10		 jae	 SHORT $LN114@fba_dasd_e
  01799	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  017a0	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv688[rsp], eax
  017a7	eb 15		 jmp	 SHORT $LN115@fba_dasd_e
$LN114@fba_dasd_e:
  017a9	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017b1	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  017b7	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv688[rsp], eax
$LN115@fba_dasd_e:
  017be	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR tv688[rsp]
  017c5	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 1302 :         *residual = count - num;

  017c9	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  017cd	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  017d4	2b c8		 sub	 ecx, eax
  017d6	8b c1		 mov	 eax, ecx
  017d8	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  017e0	89 01		 mov	 DWORD PTR [rcx], eax

; 1303 :         if (count < dev->numdevid) *more = 1;

  017e2	48 8b 84 24 40
	03 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  017ea	8b 80 64 04 00
	00		 mov	 eax, DWORD PTR [rax+1124]
  017f0	39 84 24 60 03
	00 00		 cmp	 DWORD PTR count$[rsp], eax
  017f7	73 0b		 jae	 SHORT $LN79@fba_dasd_e
  017f9	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01801	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN79@fba_dasd_e:

; 1304 : 
; 1305 :         /* Copy device identifier bytes to channel I/O buffer */
; 1306 :         memcpy (iobuf, dev->devid, num);

  01804	48 63 44 24 70	 movsxd	 rax, DWORD PTR num$[rsp]
  01809	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01811	48 81 c1 68 04
	00 00		 add	 rcx, 1128		; 00000468H
  01818	48 8b bc 24 78
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  01820	48 8b f1	 mov	 rsi, rcx
  01823	48 8b c8	 mov	 rcx, rax
  01826	f3 a4		 rep movsb

; 1307 : 
; 1308 :         /* Return unit status */
; 1309 :         *unitstat = CSW_CE | CSW_DE;

  01828	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  01830	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1310 :         break;

  01833	e9 b0 00 00 00	 jmp	 $LN2@fba_dasd_e
$LN80@fba_dasd_e:

; 1311 : 
; 1312 :     case 0xA4:
; 1313 :     /*---------------------------------------------------------------*/
; 1314 :     /* READ AND RESET BUFFERED LOG                                   */
; 1315 :     /*---------------------------------------------------------------*/
; 1316 :         /* Calculate residual byte count */
; 1317 :         num = (count < 24) ? count : 24;

  01838	83 bc 24 60 03
	00 00 18	 cmp	 DWORD PTR count$[rsp], 24
  01840	73 10		 jae	 SHORT $LN116@fba_dasd_e
  01842	8b 84 24 60 03
	00 00		 mov	 eax, DWORD PTR count$[rsp]
  01849	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv700[rsp], eax
  01850	eb 0b		 jmp	 SHORT $LN117@fba_dasd_e
$LN116@fba_dasd_e:
  01852	c7 84 24 c4 00
	00 00 18 00 00
	00		 mov	 DWORD PTR tv700[rsp], 24
$LN117@fba_dasd_e:
  0185d	8b 84 24 c4 00
	00 00		 mov	 eax, DWORD PTR tv700[rsp]
  01864	89 44 24 70	 mov	 DWORD PTR num$[rsp], eax

; 1318 :         *residual = count - num;

  01868	8b 44 24 70	 mov	 eax, DWORD PTR num$[rsp]
  0186c	8b 8c 24 60 03
	00 00		 mov	 ecx, DWORD PTR count$[rsp]
  01873	2b c8		 sub	 ecx, eax
  01875	8b c1		 mov	 eax, ecx
  01877	48 8b 8c 24 90
	03 00 00	 mov	 rcx, QWORD PTR residual$[rsp]
  0187f	89 01		 mov	 DWORD PTR [rcx], eax

; 1319 :         if (count < 24) *more = 1;

  01881	83 bc 24 60 03
	00 00 18	 cmp	 DWORD PTR count$[rsp], 24
  01889	73 0b		 jae	 SHORT $LN81@fba_dasd_e
  0188b	48 8b 84 24 80
	03 00 00	 mov	 rax, QWORD PTR more$[rsp]
  01893	c6 00 01	 mov	 BYTE PTR [rax], 1
$LN81@fba_dasd_e:

; 1320 : 
; 1321 :         /* Copy device identifier bytes to channel I/O buffer */
; 1322 :         memset( iobuf, 0, num );

  01896	48 63 44 24 70	 movsxd	 rax, DWORD PTR num$[rsp]
  0189b	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv705[rsp], rax
  018a3	48 8b bc 24 78
	03 00 00	 mov	 rdi, QWORD PTR iobuf$[rsp]
  018ab	33 c0		 xor	 eax, eax
  018ad	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv705[rsp]
  018b5	f3 aa		 rep stosb

; 1323 : 
; 1324 :         /* Return unit status */
; 1325 :         *unitstat = CSW_CE | CSW_DE;

  018b7	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  018bf	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1326 :         break;

  018c2	eb 24		 jmp	 SHORT $LN2@fba_dasd_e
$LN82@fba_dasd_e:

; 1327 : 
; 1328 :     default:
; 1329 :     /*---------------------------------------------------------------*/
; 1330 :     /* INVALID OPERATION                                             */
; 1331 :     /*---------------------------------------------------------------*/
; 1332 :         /* Set command reject sense byte, and unit check status */
; 1333 :         dev->sense[0] = SENSE_CR;

  018c4	b8 01 00 00 00	 mov	 eax, 1
  018c9	48 6b c0 00	 imul	 rax, rax, 0
  018cd	48 8b 8c 24 40
	03 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  018d5	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1334 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  018dd	48 8b 84 24 88
	03 00 00	 mov	 rax, QWORD PTR unitstat$[rsp]
  018e5	c6 00 0e	 mov	 BYTE PTR [rax], 14
$LN2@fba_dasd_e:

; 1335 : 
; 1336 :     } /* end switch(code) */
; 1337 : 
; 1338 : } /* end function fba_dasd_execute_ccw */

  018e8	48 8b 8c 24 10
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  018f0	48 33 cc	 xor	 rcx, rsp
  018f3	e8 00 00 00 00	 call	 __security_check_cookie
  018f8	48 81 c4 28 03
	00 00		 add	 rsp, 808		; 00000328H
  018ff	5f		 pop	 rdi
  01900	5e		 pop	 rsi
  01901	c3		 ret	 0
  01902	66 90		 npad	 2
$LN119@fba_dasd_e:
  01904	00 00 00 00	 DD	 $LN12@fba_dasd_e
  01908	00 00 00 00	 DD	 $LN17@fba_dasd_e
  0190c	00 00 00 00	 DD	 $LN76@fba_dasd_e
  01910	00 00 00 00	 DD	 $LN73@fba_dasd_e
  01914	00 00 00 00	 DD	 $LN18@fba_dasd_e
  01918	00 00 00 00	 DD	 $LN29@fba_dasd_e
  0191c	00 00 00 00	 DD	 $LN36@fba_dasd_e
  01920	00 00 00 00	 DD	 $LN58@fba_dasd_e
  01924	00 00 00 00	 DD	 $LN65@fba_dasd_e
  01928	00 00 00 00	 DD	 $LN67@fba_dasd_e
  0192c	00 00 00 00	 DD	 $LN80@fba_dasd_e
  01930	00 00 00 00	 DD	 $LN70@fba_dasd_e
  01934	00 00 00 00	 DD	 $LN78@fba_dasd_e
  01938	00 00 00 00	 DD	 $LN82@fba_dasd_e
$LN118@fba_dasd_e:
  0193c	00		 DB	 0
  0193d	01		 DB	 1
  0193e	02		 DB	 2
  0193f	0d		 DB	 13
  01940	0d		 DB	 13
  01941	0d		 DB	 13
  01942	0d		 DB	 13
  01943	0d		 DB	 13
  01944	0d		 DB	 13
  01945	0d		 DB	 13
  01946	0d		 DB	 13
  01947	0d		 DB	 13
  01948	0d		 DB	 13
  01949	0d		 DB	 13
  0194a	0d		 DB	 13
  0194b	0d		 DB	 13
  0194c	0d		 DB	 13
  0194d	0d		 DB	 13
  0194e	03		 DB	 3
  0194f	0d		 DB	 13
  01950	0d		 DB	 13
  01951	0d		 DB	 13
  01952	0d		 DB	 13
  01953	0d		 DB	 13
  01954	0d		 DB	 13
  01955	0d		 DB	 13
  01956	0d		 DB	 13
  01957	0d		 DB	 13
  01958	0d		 DB	 13
  01959	0d		 DB	 13
  0195a	0d		 DB	 13
  0195b	0d		 DB	 13
  0195c	0d		 DB	 13
  0195d	0d		 DB	 13
  0195e	0d		 DB	 13
  0195f	0d		 DB	 13
  01960	0d		 DB	 13
  01961	0d		 DB	 13
  01962	0d		 DB	 13
  01963	0d		 DB	 13
  01964	0d		 DB	 13
  01965	0d		 DB	 13
  01966	0d		 DB	 13
  01967	0d		 DB	 13
  01968	0d		 DB	 13
  01969	0d		 DB	 13
  0196a	0d		 DB	 13
  0196b	0d		 DB	 13
  0196c	0d		 DB	 13
  0196d	0d		 DB	 13
  0196e	0d		 DB	 13
  0196f	0d		 DB	 13
  01970	0d		 DB	 13
  01971	0d		 DB	 13
  01972	0d		 DB	 13
  01973	0d		 DB	 13
  01974	0d		 DB	 13
  01975	0d		 DB	 13
  01976	0d		 DB	 13
  01977	0d		 DB	 13
  01978	0d		 DB	 13
  01979	0d		 DB	 13
  0197a	0d		 DB	 13
  0197b	04		 DB	 4
  0197c	05		 DB	 5
  0197d	06		 DB	 6
  0197e	0d		 DB	 13
  0197f	0d		 DB	 13
  01980	0d		 DB	 13
  01981	0d		 DB	 13
  01982	0d		 DB	 13
  01983	0d		 DB	 13
  01984	0d		 DB	 13
  01985	0d		 DB	 13
  01986	0d		 DB	 13
  01987	0d		 DB	 13
  01988	0d		 DB	 13
  01989	0d		 DB	 13
  0198a	0d		 DB	 13
  0198b	0d		 DB	 13
  0198c	0d		 DB	 13
  0198d	0d		 DB	 13
  0198e	0d		 DB	 13
  0198f	0d		 DB	 13
  01990	0d		 DB	 13
  01991	0d		 DB	 13
  01992	0d		 DB	 13
  01993	0d		 DB	 13
  01994	0d		 DB	 13
  01995	0d		 DB	 13
  01996	0d		 DB	 13
  01997	0d		 DB	 13
  01998	0d		 DB	 13
  01999	0d		 DB	 13
  0199a	0d		 DB	 13
  0199b	0d		 DB	 13
  0199c	0d		 DB	 13
  0199d	07		 DB	 7
  0199e	08		 DB	 8
  0199f	0d		 DB	 13
  019a0	0d		 DB	 13
  019a1	0d		 DB	 13
  019a2	0d		 DB	 13
  019a3	0d		 DB	 13
  019a4	0d		 DB	 13
  019a5	0d		 DB	 13
  019a6	0d		 DB	 13
  019a7	0d		 DB	 13
  019a8	0d		 DB	 13
  019a9	0d		 DB	 13
  019aa	0d		 DB	 13
  019ab	0d		 DB	 13
  019ac	0d		 DB	 13
  019ad	0d		 DB	 13
  019ae	0d		 DB	 13
  019af	0d		 DB	 13
  019b0	0d		 DB	 13
  019b1	0d		 DB	 13
  019b2	0d		 DB	 13
  019b3	0d		 DB	 13
  019b4	0d		 DB	 13
  019b5	0d		 DB	 13
  019b6	0d		 DB	 13
  019b7	0d		 DB	 13
  019b8	0d		 DB	 13
  019b9	0d		 DB	 13
  019ba	0d		 DB	 13
  019bb	0d		 DB	 13
  019bc	0d		 DB	 13
  019bd	0d		 DB	 13
  019be	0d		 DB	 13
  019bf	0d		 DB	 13
  019c0	0d		 DB	 13
  019c1	0d		 DB	 13
  019c2	0d		 DB	 13
  019c3	0d		 DB	 13
  019c4	0d		 DB	 13
  019c5	0d		 DB	 13
  019c6	0d		 DB	 13
  019c7	0d		 DB	 13
  019c8	0d		 DB	 13
  019c9	0d		 DB	 13
  019ca	0d		 DB	 13
  019cb	0d		 DB	 13
  019cc	0d		 DB	 13
  019cd	0d		 DB	 13
  019ce	09		 DB	 9
  019cf	0d		 DB	 13
  019d0	0d		 DB	 13
  019d1	0d		 DB	 13
  019d2	0d		 DB	 13
  019d3	0d		 DB	 13
  019d4	0d		 DB	 13
  019d5	0d		 DB	 13
  019d6	0d		 DB	 13
  019d7	0d		 DB	 13
  019d8	0d		 DB	 13
  019d9	0d		 DB	 13
  019da	0d		 DB	 13
  019db	0d		 DB	 13
  019dc	0d		 DB	 13
  019dd	0d		 DB	 13
  019de	0a		 DB	 10
  019df	0d		 DB	 13
  019e0	0d		 DB	 13
  019e1	0d		 DB	 13
  019e2	0d		 DB	 13
  019e3	0d		 DB	 13
  019e4	0d		 DB	 13
  019e5	0d		 DB	 13
  019e6	0d		 DB	 13
  019e7	0d		 DB	 13
  019e8	0d		 DB	 13
  019e9	0d		 DB	 13
  019ea	0d		 DB	 13
  019eb	0d		 DB	 13
  019ec	0d		 DB	 13
  019ed	0d		 DB	 13
  019ee	0b		 DB	 11
  019ef	0d		 DB	 13
  019f0	0d		 DB	 13
  019f1	0d		 DB	 13
  019f2	0d		 DB	 13
  019f3	0d		 DB	 13
  019f4	0d		 DB	 13
  019f5	0d		 DB	 13
  019f6	0d		 DB	 13
  019f7	0d		 DB	 13
  019f8	0d		 DB	 13
  019f9	0d		 DB	 13
  019fa	0d		 DB	 13
  019fb	0d		 DB	 13
  019fc	0d		 DB	 13
  019fd	0d		 DB	 13
  019fe	0d		 DB	 13
  019ff	0d		 DB	 13
  01a00	0d		 DB	 13
  01a01	0d		 DB	 13
  01a02	0d		 DB	 13
  01a03	0d		 DB	 13
  01a04	0d		 DB	 13
  01a05	0d		 DB	 13
  01a06	0d		 DB	 13
  01a07	0d		 DB	 13
  01a08	0d		 DB	 13
  01a09	0d		 DB	 13
  01a0a	0d		 DB	 13
  01a0b	0d		 DB	 13
  01a0c	0d		 DB	 13
  01a0d	0d		 DB	 13
  01a0e	0d		 DB	 13
  01a0f	0d		 DB	 13
  01a10	0d		 DB	 13
  01a11	0d		 DB	 13
  01a12	0d		 DB	 13
  01a13	0d		 DB	 13
  01a14	0d		 DB	 13
  01a15	0d		 DB	 13
  01a16	0d		 DB	 13
  01a17	0d		 DB	 13
  01a18	0d		 DB	 13
  01a19	0d		 DB	 13
  01a1a	0d		 DB	 13
  01a1b	0d		 DB	 13
  01a1c	0d		 DB	 13
  01a1d	0d		 DB	 13
  01a1e	0c		 DB	 12
fba_dasd_execute_ccw ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
i$ = 112
rc$ = 116
c$ = 120
cfba$ = 124
startblk$ = 128
tv89 = 132
tv95 = 136
tv162 = 140
tv168 = 144
tv203 = 148
tv209 = 152
tv237 = 156
tv243 = 160
tv261 = 164
tv267 = 168
tv306 = 172
tv312 = 176
tv330 = 180
tv336 = 184
tv447 = 188
tv453 = 192
tv497 = 196
tv503 = 200
tv546 = 204
tv552 = 208
tv599 = 212
tv605 = 216
numblks$ = 220
tv676 = 224
tv682 = 228
tv716 = 232
tv722 = 236
tv435 = 240
tv706 = 244
tv442 = 248
tv541 = 256
tv594 = 264
tv639 = 272
tv711 = 280
tv157 = 288
tv193 = 296
tv198 = 304
tv227 = 312
tv232 = 320
tv256 = 328
tv296 = 336
tv301 = 344
tv325 = 352
cu$ = 360
tv437 = 368
tv487 = 376
tv492 = 384
tv521 = 392
tv535 = 400
tv538 = 408
tv588 = 416
tv591 = 424
tv636 = 432
tv708 = 440
statbuf$ = 448
devhdr$ = 512
cdevhdr$ = 1024
__$ArrayPad$ = 1536
dev$ = 1568
argc$ = 1576
argv$ = 1584
fba_dasd_init_handler PROC

; 66   : {

$LN100:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec 18 06
	00 00		 sub	 rsp, 1560		; 00000618H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 00
	06 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 67   : int     rc;                             /* Return code               */
; 68   : struct  stat statbuf;                   /* File information          */
; 69   : int     startblk;                       /* Device origin block number*/
; 70   : int     numblks;                        /* Device block count        */
; 71   : BYTE    c;                              /* Character work area       */
; 72   : char   *cu = NULL;                      /* Specified control unit    */

  00027	48 c7 84 24 68
	01 00 00 00 00
	00 00		 mov	 QWORD PTR cu$[rsp], 0

; 73   : int     cfba = 0;                       /* 1 = Compressed fba        */

  00033	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR cfba$[rsp], 0

; 74   : int     i;                              /* Loop index                */
; 75   : CKD_DEVHDR      devhdr;                 /* Device header             */
; 76   : CCKD_DEVHDR     cdevhdr;                /* Compressed device header  */
; 77   : 
; 78   :     /* For re-initialisation, close the existing file, if any */
; 79   :     if (dev->fd >= 0)

  0003b	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0004a	7c 1a		 jl	 SHORT $LN5@fba_dasd_i

; 80   :         (dev->hnd->close)(dev);

  0004c	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00054	48 8b 80 90 02
	00 00		 mov	 rax, QWORD PTR [rax+656]
  0005b	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00063	ff 50 10	 call	 QWORD PTR [rax+16]
$LN5@fba_dasd_i:

; 81   : 
; 82   :     if (!dev->typname || !sscanf(dev->typname,"%hx",&(dev->devtype)))

  00066	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006e	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00073	74 2b		 je	 SHORT $LN7@fba_dasd_i
  00075	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	48 83 c0 4a	 add	 rax, 74			; 0000004aH
  00081	4c 8b c0	 mov	 r8, rax
  00084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169849
  0008b	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00093	48 8b 48 50	 mov	 rcx, QWORD PTR [rax+80]
  00097	e8 00 00 00 00	 call	 sscanf
  0009c	85 c0		 test	 eax, eax
  0009e	75 11		 jne	 SHORT $LN6@fba_dasd_i
$LN7@fba_dasd_i:

; 83   :         dev->devtype = DEFAULT_FBA_TYPE;

  000a0	b8 70 33 00 00	 mov	 eax, 13168		; 00003370H
  000a5	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ad	66 89 41 4a	 mov	 WORD PTR [rcx+74], ax
$LN6@fba_dasd_i:

; 84   : 
; 85   :     /* reset excps count */
; 86   :     dev->excps = 0;

  000b1	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b9	48 c7 80 00 06
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+1536], 0

; 87   : 
; 88   :     /* The first argument is the file name */
; 89   :     if (argc == 0 || strlen(argv[0]) >= sizeof(dev->filename))

  000c4	83 bc 24 28 06
	00 00 00	 cmp	 DWORD PTR argc$[rsp], 0
  000cc	74 26		 je	 SHORT $LN9@fba_dasd_i
  000ce	b8 08 00 00 00	 mov	 eax, 8
  000d3	48 6b c0 00	 imul	 rax, rax, 0
  000d7	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  000df	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  000e3	e8 00 00 00 00	 call	 strlen
  000e8	48 3d 05 01 00
	00		 cmp	 rax, 261		; 00000105H
  000ee	0f 82 bf 00 00
	00		 jb	 $LN8@fba_dasd_i
$LN9@fba_dasd_i:

; 90   :     {
; 91   :         // "%1d:%04X FBA file: name missing or invalid filename length"
; 92   :         WRMSG( HHC00500, "E", LCSS_DEVNUM);

  000f4	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000fd	74 15		 je	 SHORT $LN38@fba_dasd_i
  000ff	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00107	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0010b	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv89[rsp], eax
  00112	eb 0b		 jmp	 SHORT $LN39@fba_dasd_i
$LN38@fba_dasd_i:
  00114	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv89[rsp], 0
$LN39@fba_dasd_i:
  0011f	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00128	74 17		 je	 SHORT $LN40@fba_dasd_i
  0012a	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00132	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00136	d1 f8		 sar	 eax, 1
  00138	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv95[rsp], eax
  0013f	eb 0b		 jmp	 SHORT $LN41@fba_dasd_i
$LN40@fba_dasd_i:
  00141	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv95[rsp], 0
$LN41@fba_dasd_i:
  0014c	b9 01 00 00 00	 mov	 ecx, 1
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00157	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv89[rsp]
  0015e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00162	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv95[rsp]
  00169	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169852
  00174	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169853
  00180	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00185	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00190	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169854
  00197	ba 5c 00 00 00	 mov	 edx, 92			; 0000005cH
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169855
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 93   :         return -1;

  001a9	b8 ff ff ff ff	 mov	 eax, -1
  001ae	e9 2f 15 00 00	 jmp	 $LN1@fba_dasd_i
$LN8@fba_dasd_i:

; 94   :     }
; 95   : 
; 96   :     /* Save the file name in the device block */
; 97   :     hostpath(dev->filename, argv[0], sizeof(dev->filename));

  001b3	b8 08 00 00 00	 mov	 eax, 8
  001b8	48 6b c0 00	 imul	 rax, rax, 0
  001bc	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c4	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  001cb	41 b8 05 01 00
	00		 mov	 r8d, 261		; 00000105H
  001d1	48 8b 94 24 30
	06 00 00	 mov	 rdx, QWORD PTR argv$[rsp]
  001d9	48 8b 14 02	 mov	 rdx, QWORD PTR [rdx+rax]
  001dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 98   : 
; 99   : #if defined( OPTION_SHARED_DEVICES )
; 100  :     /* Device is shareable */
; 101  :     dev->shareable = 1;

  001e3	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001eb	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001f1	83 c8 08	 or	 eax, 8
  001f4	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001fc	89 81 f8 05 00
	00		 mov	 DWORD PTR [rcx+1528], eax

; 102  : #endif // defined( OPTION_SHARED_DEVICES )
; 103  : 
; 104  :     /* Check for possible remote device */
; 105  :     if (stat(dev->filename, &statbuf) < 0)

  00202	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020a	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00210	48 8d 94 24 c0
	01 00 00	 lea	 rdx, QWORD PTR statbuf$[rsp]
  00218	48 8b c8	 mov	 rcx, rax
  0021b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__stat64
  00221	85 c0		 test	 eax, eax
  00223	0f 8d 18 01 00
	00		 jge	 $LN10@fba_dasd_i

; 106  :     {
; 107  :         rc = shared_fba_init ( dev, argc, argv);

  00229	4c 8b 84 24 30
	06 00 00	 mov	 r8, QWORD PTR argv$[rsp]
  00231	8b 94 24 28 06
	00 00		 mov	 edx, DWORD PTR argc$[rsp]
  00238	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00240	e8 00 00 00 00	 call	 shared_fba_init
  00245	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 108  :         if (rc < 0)

  00249	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  0024e	0f 8d e4 00 00
	00		 jge	 $LN11@fba_dasd_i

; 109  :         {
; 110  :             // "%1d:%04X FBA file %s not found or invalid"
; 111  :             WRMSG( HHC00501, "E", LCSS_DEVNUM, dev->filename );

  00254	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0025d	74 15		 je	 SHORT $LN42@fba_dasd_i
  0025f	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00267	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0026b	89 84 24 8c 00
	00 00		 mov	 DWORD PTR tv162[rsp], eax
  00272	eb 0b		 jmp	 SHORT $LN43@fba_dasd_i
$LN42@fba_dasd_i:
  00274	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv162[rsp], 0
$LN43@fba_dasd_i:
  0027f	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00288	74 17		 je	 SHORT $LN44@fba_dasd_i
  0028a	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00292	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00296	d1 f8		 sar	 eax, 1
  00298	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv168[rsp], eax
  0029f	eb 0b		 jmp	 SHORT $LN45@fba_dasd_i
$LN44@fba_dasd_i:
  002a1	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv168[rsp], 0
$LN45@fba_dasd_i:
  002ac	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b4	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  002ba	48 89 84 24 20
	01 00 00	 mov	 QWORD PTR tv157[rsp], rax
  002c2	b9 01 00 00 00	 mov	 ecx, 1
  002c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002cd	48 8b 8c 24 20
	01 00 00	 mov	 rcx, QWORD PTR tv157[rsp]
  002d5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002da	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv162[rsp]
  002e1	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002e5	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv168[rsp]
  002ec	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169859
  002f7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002fc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169860
  00303	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00308	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0030d	41 b9 03 00 00
	00		 mov	 r9d, 3
  00313	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169861
  0031a	ba 6f 00 00 00	 mov	 edx, 111		; 0000006fH
  0031f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169862
  00326	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 112  :             return -1;

  0032c	b8 ff ff ff ff	 mov	 eax, -1
  00331	e9 ac 13 00 00	 jmp	 $LN1@fba_dasd_i

; 113  :         }

  00336	eb 09		 jmp	 SHORT $LN12@fba_dasd_i
$LN11@fba_dasd_i:

; 114  :         else
; 115  :             return rc;

  00338	8b 44 24 74	 mov	 eax, DWORD PTR rc$[rsp]
  0033c	e9 a1 13 00 00	 jmp	 $LN1@fba_dasd_i
$LN12@fba_dasd_i:
$LN10@fba_dasd_i:

; 116  :     }
; 117  : 
; 118  :     /* Open the device file */
; 119  :     dev->fd = HOPEN (dev->filename, O_RDWR|O_BINARY);

  00341	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00349	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0034f	ba 02 80 00 00	 mov	 edx, 32770		; 00008002H
  00354	48 8b c8	 mov	 rcx, rax
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0035d	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00365	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 120  :     if (dev->fd < 0)

  0036b	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00373	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0037a	0f 8d 51 01 00
	00		 jge	 $LN13@fba_dasd_i

; 121  :     {
; 122  :         dev->fd = HOPEN (dev->filename, O_RDONLY|O_BINARY);

  00380	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00388	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  0038e	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00393	48 8b c8	 mov	 rcx, rax
  00396	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0039c	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003a4	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 123  :         if (dev->fd < 0)

  003aa	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b2	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  003b9	0f 8d 12 01 00
	00		 jge	 $LN14@fba_dasd_i

; 124  :         {
; 125  :             // "%1d:%04X FBA file %s: error in function %s: %s"
; 126  :             WRMSG( HHC00502, "E", LCSS_DEVNUM,

  003bf	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003c8	74 15		 je	 SHORT $LN46@fba_dasd_i
  003ca	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  003d6	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv203[rsp], eax
  003dd	eb 0b		 jmp	 SHORT $LN47@fba_dasd_i
$LN46@fba_dasd_i:
  003df	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv203[rsp], 0
$LN47@fba_dasd_i:
  003ea	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  003f3	74 17		 je	 SHORT $LN48@fba_dasd_i
  003f5	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003fd	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00401	d1 f8		 sar	 eax, 1
  00403	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv209[rsp], eax
  0040a	eb 0b		 jmp	 SHORT $LN49@fba_dasd_i
$LN48@fba_dasd_i:
  0040c	c7 84 24 98 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv209[rsp], 0
$LN49@fba_dasd_i:
  00417	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0041d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0041f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00425	48 89 84 24 28
	01 00 00	 mov	 QWORD PTR tv193[rsp], rax
  0042d	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00435	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0043c	48 89 8c 24 30
	01 00 00	 mov	 QWORD PTR tv198[rsp], rcx
  00444	b9 01 00 00 00	 mov	 ecx, 1
  00449	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0044f	48 8b 8c 24 28
	01 00 00	 mov	 rcx, QWORD PTR tv193[rsp]
  00457	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0045c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169865
  00463	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00468	48 8b 8c 24 30
	01 00 00	 mov	 rcx, QWORD PTR tv198[rsp]
  00470	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00475	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv203[rsp]
  0047c	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00480	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv209[rsp]
  00487	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0048b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169866
  00492	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00497	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169867
  0049e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  004a3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  004a8	41 b9 03 00 00
	00		 mov	 r9d, 3
  004ae	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169868
  004b5	ba 7f 00 00 00	 mov	 edx, 127		; 0000007fH
  004ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169869
  004c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 127  :                    dev->filename, "open()", strerror( errno ));
; 128  :             return -1;

  004c7	b8 ff ff ff ff	 mov	 eax, -1
  004cc	e9 11 12 00 00	 jmp	 $LN1@fba_dasd_i
$LN14@fba_dasd_i:
$LN13@fba_dasd_i:

; 129  :         }
; 130  :     }
; 131  : 
; 132  :     /* Read the first block to see if it's compressed */
; 133  :     rc = read (dev->fd, &devhdr, CKD_DEVHDR_SIZE);

  004d1	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  004d7	48 8d 94 24 00
	02 00 00	 lea	 rdx, QWORD PTR devhdr$[rsp]
  004df	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  004e7	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  004ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  004f3	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 134  :     if (rc < (int)               CKD_DEVHDR_SIZE)

  004f7	81 7c 24 74 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  004ff	0f 8d 38 02 00
	00		 jge	 $LN15@fba_dasd_i

; 135  :     {
; 136  :         /* Handle read error condition */
; 137  :         if (rc < 0)

  00505	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  0050a	0f 8d 0d 01 00
	00		 jge	 $LN16@fba_dasd_i

; 138  :             // "%1d:%04X FBA file %s: error in function %s: %s"
; 139  :             WRMSG( HHC00502, "E", LCSS_DEVNUM,

  00510	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00519	74 15		 je	 SHORT $LN50@fba_dasd_i
  0051b	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00523	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00527	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv237[rsp], eax
  0052e	eb 0b		 jmp	 SHORT $LN51@fba_dasd_i
$LN50@fba_dasd_i:
  00530	c7 84 24 9c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv237[rsp], 0
$LN51@fba_dasd_i:
  0053b	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00544	74 17		 je	 SHORT $LN52@fba_dasd_i
  00546	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0054e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00552	d1 f8		 sar	 eax, 1
  00554	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv243[rsp], eax
  0055b	eb 0b		 jmp	 SHORT $LN53@fba_dasd_i
$LN52@fba_dasd_i:
  0055d	c7 84 24 a0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv243[rsp], 0
$LN53@fba_dasd_i:
  00568	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0056e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00570	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00576	48 89 84 24 38
	01 00 00	 mov	 QWORD PTR tv227[rsp], rax
  0057e	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00586	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0058d	48 89 8c 24 40
	01 00 00	 mov	 QWORD PTR tv232[rsp], rcx
  00595	b9 01 00 00 00	 mov	 ecx, 1
  0059a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  005a0	48 8b 8c 24 38
	01 00 00	 mov	 rcx, QWORD PTR tv227[rsp]
  005a8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  005ad	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169873
  005b4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  005b9	48 8b 8c 24 40
	01 00 00	 mov	 rcx, QWORD PTR tv232[rsp]
  005c1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  005c6	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv237[rsp]
  005cd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  005d1	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv243[rsp]
  005d8	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  005dc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169874
  005e3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  005e8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169875
  005ef	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  005f4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  005f9	41 b9 03 00 00
	00		 mov	 r9d, 3
  005ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169876
  00606	ba 8c 00 00 00	 mov	 edx, 140		; 0000008cH
  0060b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169877
  00612	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  00618	e9 f0 00 00 00	 jmp	 $LN17@fba_dasd_i
$LN16@fba_dasd_i:

; 140  :                    dev->filename, "read()", strerror( errno ));
; 141  :         else
; 142  :             // "%1d:%04X FBA file %s: error in function %s: %s"
; 143  :             WRMSG( HHC00502, "E", LCSS_DEVNUM,

  0061d	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00626	74 15		 je	 SHORT $LN54@fba_dasd_i
  00628	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00630	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00634	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv261[rsp], eax
  0063b	eb 0b		 jmp	 SHORT $LN55@fba_dasd_i
$LN54@fba_dasd_i:
  0063d	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv261[rsp], 0
$LN55@fba_dasd_i:
  00648	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00651	74 17		 je	 SHORT $LN56@fba_dasd_i
  00653	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0065b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0065f	d1 f8		 sar	 eax, 1
  00661	89 84 24 a8 00
	00 00		 mov	 DWORD PTR tv267[rsp], eax
  00668	eb 0b		 jmp	 SHORT $LN57@fba_dasd_i
$LN56@fba_dasd_i:
  0066a	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv267[rsp], 0
$LN57@fba_dasd_i:
  00675	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0067d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00683	48 89 84 24 48
	01 00 00	 mov	 QWORD PTR tv256[rsp], rax
  0068b	b9 01 00 00 00	 mov	 ecx, 1
  00690	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00696	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169878
  0069d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  006a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169879
  006a9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  006ae	48 8b 8c 24 48
	01 00 00	 mov	 rcx, QWORD PTR tv256[rsp]
  006b6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  006bb	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv261[rsp]
  006c2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  006c6	8b 8c 24 a8 00
	00 00		 mov	 ecx, DWORD PTR tv267[rsp]
  006cd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  006d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169880
  006d8	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  006dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169881
  006e4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  006e9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  006ee	41 b9 03 00 00
	00		 mov	 r9d, 3
  006f4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169882
  006fb	ba 90 00 00 00	 mov	 edx, 144		; 00000090H
  00700	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169883
  00707	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@fba_dasd_i:

; 144  :                    dev->filename, "read()", "unexpected end of file" );
; 145  :         close (dev->fd);

  0070d	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00715	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0071b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 146  :         dev->fd = -1;

  00721	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00729	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 147  :         return -1;

  00733	b8 ff ff ff ff	 mov	 eax, -1
  00738	e9 a5 0f 00 00	 jmp	 $LN1@fba_dasd_i
$LN15@fba_dasd_i:

; 148  :     }
; 149  : 
; 150  :     /* Processing for compressed fba dasd */
; 151  :     if (is_dh_devid_typ( devhdr.dh_devid, FBA_C370_TYP ))

  0073d	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  00742	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  0074a	e8 00 00 00 00	 call	 is_dh_devid_typ
  0074f	0f b6 c0	 movzx	 eax, al
  00752	85 c0		 test	 eax, eax
  00754	0f 84 13 05 00
	00		 je	 $LN18@fba_dasd_i

; 152  :     {
; 153  :         dev->cckd64 = 0;

  0075a	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00762	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00769	24 fe		 and	 al, 254			; 000000feH
  0076b	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00773	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 154  : 
; 155  :         cfba = 1;

  00779	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR cfba$[rsp], 1

; 156  : 
; 157  :         /* Read the compressed device header */
; 158  :         rc = read (dev->fd, &cdevhdr, CCKD_DEVHDR_SIZE);

  00781	41 b8 00 02 00
	00		 mov	 r8d, 512		; 00000200H
  00787	48 8d 94 24 00
	04 00 00	 lea	 rdx, QWORD PTR cdevhdr$[rsp]
  0078f	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00797	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0079d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  007a3	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 159  :         if (rc < (int)                CCKD_DEVHDR_SIZE)

  007a7	81 7c 24 74 00
	02 00 00	 cmp	 DWORD PTR rc$[rsp], 512	; 00000200H
  007af	0f 8d 38 02 00
	00		 jge	 $LN20@fba_dasd_i

; 160  :         {
; 161  :             /* Handle read error condition */
; 162  :             if (rc < 0)

  007b5	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  007ba	0f 8d 0d 01 00
	00		 jge	 $LN21@fba_dasd_i

; 163  :                 // "%1d:%04X FBA file %s: error in function %s: %s"
; 164  :                 WRMSG( HHC00502, "E", LCSS_DEVNUM,

  007c0	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007c9	74 15		 je	 SHORT $LN58@fba_dasd_i
  007cb	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007d3	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  007d7	89 84 24 ac 00
	00 00		 mov	 DWORD PTR tv306[rsp], eax
  007de	eb 0b		 jmp	 SHORT $LN59@fba_dasd_i
$LN58@fba_dasd_i:
  007e0	c7 84 24 ac 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv306[rsp], 0
$LN59@fba_dasd_i:
  007eb	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  007f4	74 17		 je	 SHORT $LN60@fba_dasd_i
  007f6	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  007fe	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00802	d1 f8		 sar	 eax, 1
  00804	89 84 24 b0 00
	00 00		 mov	 DWORD PTR tv312[rsp], eax
  0080b	eb 0b		 jmp	 SHORT $LN61@fba_dasd_i
$LN60@fba_dasd_i:
  0080d	c7 84 24 b0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv312[rsp], 0
$LN61@fba_dasd_i:
  00818	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0081e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00820	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00826	48 89 84 24 50
	01 00 00	 mov	 QWORD PTR tv296[rsp], rax
  0082e	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00836	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0083d	48 89 8c 24 58
	01 00 00	 mov	 QWORD PTR tv301[rsp], rcx
  00845	b9 01 00 00 00	 mov	 ecx, 1
  0084a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00850	48 8b 8c 24 50
	01 00 00	 mov	 rcx, QWORD PTR tv296[rsp]
  00858	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0085d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169889
  00864	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00869	48 8b 8c 24 58
	01 00 00	 mov	 rcx, QWORD PTR tv301[rsp]
  00871	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00876	8b 8c 24 ac 00
	00 00		 mov	 ecx, DWORD PTR tv306[rsp]
  0087d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00881	8b 8c 24 b0 00
	00 00		 mov	 ecx, DWORD PTR tv312[rsp]
  00888	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0088c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169890
  00893	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00898	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169891
  0089f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008a4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008a9	41 b9 03 00 00
	00		 mov	 r9d, 3
  008af	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169892
  008b6	ba a5 00 00 00	 mov	 edx, 165		; 000000a5H
  008bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169893
  008c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
  008c8	e9 f0 00 00 00	 jmp	 $LN22@fba_dasd_i
$LN21@fba_dasd_i:

; 165  :                        dev->filename, "read()", strerror( errno ));
; 166  :             else
; 167  :                 // "%1d:%04X FBA file %s: error in function %s: %s"
; 168  :                 WRMSG( HHC00502, "E", LCSS_DEVNUM,

  008cd	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  008d6	74 15		 je	 SHORT $LN62@fba_dasd_i
  008d8	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  008e0	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  008e4	89 84 24 b4 00
	00 00		 mov	 DWORD PTR tv330[rsp], eax
  008eb	eb 0b		 jmp	 SHORT $LN63@fba_dasd_i
$LN62@fba_dasd_i:
  008ed	c7 84 24 b4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv330[rsp], 0
$LN63@fba_dasd_i:
  008f8	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00901	74 17		 je	 SHORT $LN64@fba_dasd_i
  00903	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0090b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0090f	d1 f8		 sar	 eax, 1
  00911	89 84 24 b8 00
	00 00		 mov	 DWORD PTR tv336[rsp], eax
  00918	eb 0b		 jmp	 SHORT $LN65@fba_dasd_i
$LN64@fba_dasd_i:
  0091a	c7 84 24 b8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv336[rsp], 0
$LN65@fba_dasd_i:
  00925	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0092d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00933	48 89 84 24 60
	01 00 00	 mov	 QWORD PTR tv325[rsp], rax
  0093b	b9 01 00 00 00	 mov	 ecx, 1
  00940	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00946	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169894
  0094d	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00952	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169895
  00959	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0095e	48 8b 8c 24 60
	01 00 00	 mov	 rcx, QWORD PTR tv325[rsp]
  00966	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0096b	8b 8c 24 b4 00
	00 00		 mov	 ecx, DWORD PTR tv330[rsp]
  00972	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00976	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR tv336[rsp]
  0097d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00981	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169896
  00988	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0098d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169897
  00994	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00999	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0099e	41 b9 03 00 00
	00		 mov	 r9d, 3
  009a4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169898
  009ab	ba a9 00 00 00	 mov	 edx, 169		; 000000a9H
  009b0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169899
  009b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN22@fba_dasd_i:

; 169  :                        dev->filename, "read()", "unexpected end of file" );
; 170  :             close (dev->fd);

  009bd	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009c5	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  009cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 171  :             dev->fd = -1;

  009d1	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009d9	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 172  :             return -1;

  009e3	b8 ff ff ff ff	 mov	 eax, -1
  009e8	e9 f5 0c 00 00	 jmp	 $LN1@fba_dasd_i
$LN20@fba_dasd_i:

; 173  :         }
; 174  : 
; 175  :         /* Set block size, device origin, and device size in blocks */
; 176  :         dev->fbablksiz = 512;

  009ed	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  009f5	c7 80 8c 11 00
	00 00 02 00 00	 mov	 DWORD PTR [rax+4492], 512 ; 00000200H

; 177  :         dev->fbaorigin = 0;

  009ff	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00a07	48 c7 80 90 11
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4496], 0

; 178  :         FETCH_LE_FW( dev->fbanumblk, cdevhdr.cdh_cyls );

  00a12	48 8d 8c 24 28
	04 00 00	 lea	 rcx, QWORD PTR cdevhdr$[rsp+40]
  00a1a	e8 00 00 00 00	 call	 fetch_fw_noswap
  00a1f	8b c8		 mov	 ecx, eax
  00a21	e8 00 00 00 00	 call	 _byteswap_ulong
  00a26	8b c8		 mov	 ecx, eax
  00a28	e8 00 00 00 00	 call	 _byteswap_ulong
  00a2d	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00a35	89 81 88 11 00
	00		 mov	 DWORD PTR [rcx+4488], eax

; 179  : 
; 180  :         /* process the remaining arguments */
; 181  :         for (i = 1; i < argc; i++)

  00a3b	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR i$[rsp], 1
  00a43	eb 0a		 jmp	 SHORT $LN4@fba_dasd_i
$LN2@fba_dasd_i:
  00a45	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00a49	ff c0		 inc	 eax
  00a4b	89 44 24 70	 mov	 DWORD PTR i$[rsp], eax
$LN4@fba_dasd_i:
  00a4f	8b 84 24 28 06
	00 00		 mov	 eax, DWORD PTR argc$[rsp]
  00a56	39 44 24 70	 cmp	 DWORD PTR i$[rsp], eax
  00a5a	0f 8d 08 02 00
	00		 jge	 $LN3@fba_dasd_i

; 182  :         {
; 183  :             if (strlen (argv[i]) > 3
; 184  :              && memcmp ("sf=", argv[i], 3) == 0)

  00a60	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00a65	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a6d	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00a71	e8 00 00 00 00	 call	 strlen
  00a76	48 83 f8 03	 cmp	 rax, 3
  00a7a	76 51		 jbe	 SHORT $LN23@fba_dasd_i
  00a7c	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00a81	41 b8 03 00 00
	00		 mov	 r8d, 3
  00a87	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00a8f	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00a93	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169901
  00a9a	e8 00 00 00 00	 call	 memcmp
  00a9f	85 c0		 test	 eax, eax
  00aa1	75 2a		 jne	 SHORT $LN23@fba_dasd_i

; 185  :             {
; 186  :                 /* Parse the shadow file name parameter */
; 187  :                 cckd_sf_parse_sfn( dev, argv[i]+3 );

  00aa3	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00aa8	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00ab0	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00ab4	48 83 c0 03	 add	 rax, 3
  00ab8	48 8b d0	 mov	 rdx, rax
  00abb	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ac3	e8 00 00 00 00	 call	 cckd_sf_parse_sfn

; 188  :                 continue;

  00ac8	e9 78 ff ff ff	 jmp	 $LN2@fba_dasd_i
$LN23@fba_dasd_i:

; 189  :             }
; 190  :             if (strlen (argv[i]) > 3
; 191  :              && memcmp("cu=", argv[i], 3) == 0)   /* support for cu= added but  */

  00acd	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00ad2	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00ada	48 8b 0c c1	 mov	 rcx, QWORD PTR [rcx+rax*8]
  00ade	e8 00 00 00 00	 call	 strlen
  00ae3	48 83 f8 03	 cmp	 rax, 3
  00ae7	76 49		 jbe	 SHORT $LN24@fba_dasd_i
  00ae9	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00aee	41 b8 03 00 00
	00		 mov	 r8d, 3
  00af4	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00afc	48 8b 14 c1	 mov	 rdx, QWORD PTR [rcx+rax*8]
  00b00	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169903
  00b07	e8 00 00 00 00	 call	 memcmp
  00b0c	85 c0		 test	 eax, eax
  00b0e	75 22		 jne	 SHORT $LN24@fba_dasd_i

; 192  :             {                                     /* is ignored for the present */
; 193  :                 cu = argv[i]+3;

  00b10	48 63 44 24 70	 movsxd	 rax, DWORD PTR i$[rsp]
  00b15	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00b1d	48 8b 04 c1	 mov	 rax, QWORD PTR [rcx+rax*8]
  00b21	48 83 c0 03	 add	 rax, 3
  00b25	48 89 84 24 68
	01 00 00	 mov	 QWORD PTR cu$[rsp], rax

; 194  :                 continue;

  00b2d	e9 13 ff ff ff	 jmp	 $LN2@fba_dasd_i
$LN24@fba_dasd_i:

; 195  :             }
; 196  : 
; 197  :             // "%1d:%04X %s file: parameter %s in argument %d is invalid"
; 198  :             WRMSG( HHC00503, "E", LCSS_DEVNUM, FBATYP( cfba, 0 ), argv[i], i + 1 );

  00b32	83 7c 24 7c 00	 cmp	 DWORD PTR cfba$[rsp], 0
  00b37	74 11		 je	 SHORT $LN66@fba_dasd_i
  00b39	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169904
  00b40	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv442[rsp], rax
  00b48	eb 0f		 jmp	 SHORT $LN67@fba_dasd_i
$LN66@fba_dasd_i:
  00b4a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169905
  00b51	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv442[rsp], rax
$LN67@fba_dasd_i:
  00b59	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b62	74 15		 je	 SHORT $LN68@fba_dasd_i
  00b64	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b6c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00b70	89 84 24 bc 00
	00 00		 mov	 DWORD PTR tv447[rsp], eax
  00b77	eb 0b		 jmp	 SHORT $LN69@fba_dasd_i
$LN68@fba_dasd_i:
  00b79	c7 84 24 bc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv447[rsp], 0
$LN69@fba_dasd_i:
  00b84	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00b8d	74 17		 je	 SHORT $LN70@fba_dasd_i
  00b8f	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00b97	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00b9b	d1 f8		 sar	 eax, 1
  00b9d	89 84 24 c0 00
	00 00		 mov	 DWORD PTR tv453[rsp], eax
  00ba4	eb 0b		 jmp	 SHORT $LN71@fba_dasd_i
$LN70@fba_dasd_i:
  00ba6	c7 84 24 c0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv453[rsp], 0
$LN71@fba_dasd_i:
  00bb1	8b 44 24 70	 mov	 eax, DWORD PTR i$[rsp]
  00bb5	ff c0		 inc	 eax
  00bb7	89 84 24 f0 00
	00 00		 mov	 DWORD PTR tv435[rsp], eax
  00bbe	48 63 4c 24 70	 movsxd	 rcx, DWORD PTR i$[rsp]
  00bc3	48 89 8c 24 70
	01 00 00	 mov	 QWORD PTR tv437[rsp], rcx
  00bcb	b9 01 00 00 00	 mov	 ecx, 1
  00bd0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00bd6	8b 8c 24 f0 00
	00 00		 mov	 ecx, DWORD PTR tv435[rsp]
  00bdd	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00be1	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00be9	48 8b 94 24 70
	01 00 00	 mov	 rdx, QWORD PTR tv437[rsp]
  00bf1	48 8b 0c d1	 mov	 rcx, QWORD PTR [rcx+rdx*8]
  00bf5	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00bfa	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv442[rsp]
  00c02	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00c07	8b 8c 24 bc 00
	00 00		 mov	 ecx, DWORD PTR tv447[rsp]
  00c0e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00c12	8b 8c 24 c0 00
	00 00		 mov	 ecx, DWORD PTR tv453[rsp]
  00c19	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00c1d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169906
  00c24	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00c29	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169907
  00c30	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00c35	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00c3a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00c40	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169908
  00c47	ba c6 00 00 00	 mov	 edx, 198		; 000000c6H
  00c4c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169909
  00c53	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 199  :             return -1;

  00c59	b8 ff ff ff ff	 mov	 eax, -1
  00c5e	e9 7f 0a 00 00	 jmp	 $LN1@fba_dasd_i

; 200  :         }

  00c63	e9 dd fd ff ff	 jmp	 $LN2@fba_dasd_i
$LN3@fba_dasd_i:

; 201  :     }

  00c68	e9 65 06 00 00	 jmp	 $LN19@fba_dasd_i
$LN18@fba_dasd_i:

; 202  : 
; 203  :     /* Processing for compressed fba64 dasd */
; 204  :     else if (is_dh_devid_typ( devhdr.dh_devid, FBA_C064_TYP ))

  00c6d	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  00c72	48 8d 8c 24 00
	02 00 00	 lea	 rcx, QWORD PTR devhdr$[rsp]
  00c7a	e8 00 00 00 00	 call	 is_dh_devid_typ
  00c7f	0f b6 c0	 movzx	 eax, al
  00c82	85 c0		 test	 eax, eax
  00c84	74 6b		 je	 SHORT $LN25@fba_dasd_i

; 205  :     {
; 206  :         dev->cckd64 = 1;

  00c86	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00c8e	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00c95	0c 01		 or	 al, 1
  00c97	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00c9f	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 207  :         close( dev->fd );

  00ca5	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cad	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00cb3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 208  :         dev->fd = -1;

  00cb9	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cc1	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 209  :         return fba64_dasd_init_handler( dev, argc, argv );

  00ccb	4c 8b 84 24 30
	06 00 00	 mov	 r8, QWORD PTR argv$[rsp]
  00cd3	8b 94 24 28 06
	00 00		 mov	 edx, DWORD PTR argc$[rsp]
  00cda	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ce2	e8 00 00 00 00	 call	 fba64_dasd_init_handler
  00ce7	e9 f6 09 00 00	 jmp	 $LN1@fba_dasd_i

; 210  :     }

  00cec	e9 e1 05 00 00	 jmp	 $LN26@fba_dasd_i
$LN25@fba_dasd_i:

; 211  : 
; 212  :     /* Processing for regular fba dasd */
; 213  :     else
; 214  :     {
; 215  :         dev->cckd64 = 0;

  00cf1	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00cf9	0f b6 80 10 13
	00 00		 movzx	 eax, BYTE PTR [rax+4880]
  00d00	24 fe		 and	 al, 254			; 000000feH
  00d02	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00d0a	88 81 10 13 00
	00		 mov	 BYTE PTR [rcx+4880], al

; 216  : 
; 217  :         /* Determine the device size */
; 218  :         rc = fstat (dev->fd, &statbuf);

  00d10	48 8d 94 24 c0
	01 00 00	 lea	 rdx, QWORD PTR statbuf$[rsp]
  00d18	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d20	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00d26	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fstat64
  00d2c	89 44 24 74	 mov	 DWORD PTR rc$[rsp], eax

; 219  :         if (rc < 0)

  00d30	83 7c 24 74 00	 cmp	 DWORD PTR rc$[rsp], 0
  00d35	0f 8d 38 01 00
	00		 jge	 $LN27@fba_dasd_i

; 220  :         {
; 221  :             // "%1d:%04X FBA file %s: error in function %s: %s"
; 222  :             WRMSG( HHC00502, "E", LCSS_DEVNUM,

  00d3b	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d44	74 15		 je	 SHORT $LN72@fba_dasd_i
  00d46	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d4e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00d52	89 84 24 c4 00
	00 00		 mov	 DWORD PTR tv497[rsp], eax
  00d59	eb 0b		 jmp	 SHORT $LN73@fba_dasd_i
$LN72@fba_dasd_i:
  00d5b	c7 84 24 c4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv497[rsp], 0
$LN73@fba_dasd_i:
  00d66	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00d6f	74 17		 je	 SHORT $LN74@fba_dasd_i
  00d71	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00d79	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00d7d	d1 f8		 sar	 eax, 1
  00d7f	89 84 24 c8 00
	00 00		 mov	 DWORD PTR tv503[rsp], eax
  00d86	eb 0b		 jmp	 SHORT $LN75@fba_dasd_i
$LN74@fba_dasd_i:
  00d88	c7 84 24 c8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv503[rsp], 0
$LN75@fba_dasd_i:
  00d93	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00d99	8b 08		 mov	 ecx, DWORD PTR [rax]
  00d9b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00da1	48 89 84 24 78
	01 00 00	 mov	 QWORD PTR tv487[rsp], rax
  00da9	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00db1	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00db8	48 89 8c 24 80
	01 00 00	 mov	 QWORD PTR tv492[rsp], rcx
  00dc0	b9 01 00 00 00	 mov	 ecx, 1
  00dc5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00dcb	48 8b 8c 24 78
	01 00 00	 mov	 rcx, QWORD PTR tv487[rsp]
  00dd3	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00dd8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169913
  00ddf	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00de4	48 8b 8c 24 80
	01 00 00	 mov	 rcx, QWORD PTR tv492[rsp]
  00dec	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00df1	8b 8c 24 c4 00
	00 00		 mov	 ecx, DWORD PTR tv497[rsp]
  00df8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00dfc	8b 8c 24 c8 00
	00 00		 mov	 ecx, DWORD PTR tv503[rsp]
  00e03	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00e07	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169914
  00e0e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00e13	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169915
  00e1a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00e1f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e24	41 b9 03 00 00
	00		 mov	 r9d, 3
  00e2a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169916
  00e31	ba df 00 00 00	 mov	 edx, 223		; 000000dfH
  00e36	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169917
  00e3d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 223  :                    dev->filename, "fstat()", strerror( errno ));
; 224  :             close (dev->fd);

  00e43	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e4b	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00e51	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 225  :             dev->fd = -1;

  00e57	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e5f	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 226  :             return -1;

  00e69	b8 ff ff ff ff	 mov	 eax, -1
  00e6e	e9 6f 08 00 00	 jmp	 $LN1@fba_dasd_i
$LN27@fba_dasd_i:

; 227  :         }
; 228  : #if defined(OPTION_FBA_BLKDEVICE) && defined(BLKGETSIZE)
; 229  :         if(S_ISBLK(statbuf.st_mode))
; 230  :         {
; 231  :             rc=ioctl(dev->fd,BLKGETSIZE,&statbuf.st_size);
; 232  :             if(rc<0)
; 233  :             {
; 234  :                 // "%1d:%04X FBA file %s: error in function %s: %s"
; 235  :                 WRMSG( HHC00502, "E", LCSS_DEVNUM,
; 236  :                        dev->filename, "ioctl()", strerror( errno ));
; 237  :                 close (dev->fd);
; 238  :                 dev->fd = -1;
; 239  :                 return -1;
; 240  :             }
; 241  :             dev->fbablksiz = 512;
; 242  :             dev->fbaorigin = 0;
; 243  :             dev->fbanumblk = statbuf.st_size;
; 244  :             if (!dev->quiet)
; 245  :                 // "%1d:%04X FBA file %s: REAL FBA opened"
; 246  :                 WRMSG( HHC00504, "I", LCSS_DEVNUM, dev->filename );
; 247  :         }
; 248  :         else
; 249  : #endif // defined(OPTION_FBA_BLKDEVICE) && defined(BLKGETSIZE)
; 250  :         {
; 251  :             /* Set block size, device origin, and device size in blocks */
; 252  :             dev->fbablksiz = 512;

  00e73	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e7b	c7 80 8c 11 00
	00 00 02 00 00	 mov	 DWORD PTR [rax+4492], 512 ; 00000200H

; 253  :             dev->fbaorigin = 0;

  00e85	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00e8d	48 c7 80 90 11
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4496], 0

; 254  :             dev->fbanumblk = (int)(statbuf.st_size / dev->fbablksiz);

  00e98	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00ea0	48 63 80 8c 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4492]
  00ea7	48 89 84 24 88
	01 00 00	 mov	 QWORD PTR tv521[rsp], rax
  00eaf	48 8b 84 24 d8
	01 00 00	 mov	 rax, QWORD PTR statbuf$[rsp+24]
  00eb7	48 99		 cdq
  00eb9	48 8b 8c 24 88
	01 00 00	 mov	 rcx, QWORD PTR tv521[rsp]
  00ec1	48 f7 f9	 idiv	 rcx
  00ec4	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00ecc	89 81 88 11 00
	00		 mov	 DWORD PTR [rcx+4488], eax

; 255  :         }
; 256  : 
; 257  :         /* The second argument is the device origin block number */
; 258  :         if (argc >= 2)

  00ed2	83 bc 24 28 06
	00 00 02	 cmp	 DWORD PTR argc$[rsp], 2
  00eda	0f 8c f1 01 00
	00		 jl	 $LN28@fba_dasd_i

; 259  :         {
; 260  :             if (sscanf(argv[1], "%u%c", &startblk, &c) != 1
; 261  :              || startblk >= dev->fbanumblk)

  00ee0	b8 08 00 00 00	 mov	 eax, 8
  00ee5	48 6b c0 01	 imul	 rax, rax, 1
  00ee9	4c 8d 4c 24 78	 lea	 r9, QWORD PTR c$[rsp]
  00eee	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR startblk$[rsp]
  00ef6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169921
  00efd	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00f05	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  00f09	e8 00 00 00 00	 call	 sscanf
  00f0e	83 f8 01	 cmp	 eax, 1
  00f11	75 1b		 jne	 SHORT $LN30@fba_dasd_i
  00f13	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f1b	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  00f21	39 84 24 80 00
	00 00		 cmp	 DWORD PTR startblk$[rsp], eax
  00f28	0f 8c 67 01 00
	00		 jl	 $LN29@fba_dasd_i
$LN30@fba_dasd_i:

; 262  :             {
; 263  :                 // "%1d:%04X %s file %s: invalid device origin block number %s"
; 264  :                 WRMSG( HHC00505, "E", LCSS_DEVNUM, FBATYP( cfba, 0 ), dev->filename, argv[1] );

  00f2e	83 7c 24 7c 00	 cmp	 DWORD PTR cfba$[rsp], 0
  00f33	74 11		 je	 SHORT $LN76@fba_dasd_i
  00f35	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169922
  00f3c	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv541[rsp], rax
  00f44	eb 0f		 jmp	 SHORT $LN77@fba_dasd_i
$LN76@fba_dasd_i:
  00f46	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169923
  00f4d	48 89 84 24 00
	01 00 00	 mov	 QWORD PTR tv541[rsp], rax
$LN77@fba_dasd_i:
  00f55	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f5e	74 15		 je	 SHORT $LN78@fba_dasd_i
  00f60	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f68	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00f6c	89 84 24 cc 00
	00 00		 mov	 DWORD PTR tv546[rsp], eax
  00f73	eb 0b		 jmp	 SHORT $LN79@fba_dasd_i
$LN78@fba_dasd_i:
  00f75	c7 84 24 cc 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv546[rsp], 0
$LN79@fba_dasd_i:
  00f80	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00f89	74 17		 je	 SHORT $LN80@fba_dasd_i
  00f8b	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00f93	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00f97	d1 f8		 sar	 eax, 1
  00f99	89 84 24 d0 00
	00 00		 mov	 DWORD PTR tv552[rsp], eax
  00fa0	eb 0b		 jmp	 SHORT $LN81@fba_dasd_i
$LN80@fba_dasd_i:
  00fa2	c7 84 24 d0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv552[rsp], 0
$LN81@fba_dasd_i:
  00fad	b8 08 00 00 00	 mov	 eax, 8
  00fb2	48 6b c0 01	 imul	 rax, rax, 1
  00fb6	48 89 84 24 90
	01 00 00	 mov	 QWORD PTR tv535[rsp], rax
  00fbe	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00fc6	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00fcd	48 89 8c 24 98
	01 00 00	 mov	 QWORD PTR tv538[rsp], rcx
  00fd5	b9 01 00 00 00	 mov	 ecx, 1
  00fda	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00fe0	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  00fe8	48 8b 94 24 90
	01 00 00	 mov	 rdx, QWORD PTR tv535[rsp]
  00ff0	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  00ff4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00ff9	48 8b 8c 24 98
	01 00 00	 mov	 rcx, QWORD PTR tv538[rsp]
  01001	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01006	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv541[rsp]
  0100e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01013	8b 8c 24 cc 00
	00 00		 mov	 ecx, DWORD PTR tv546[rsp]
  0101a	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0101e	8b 8c 24 d0 00
	00 00		 mov	 ecx, DWORD PTR tv552[rsp]
  01025	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01029	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169924
  01030	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01035	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169925
  0103c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01041	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01046	41 b9 03 00 00
	00		 mov	 r9d, 3
  0104c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169926
  01053	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  01058	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169927
  0105f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 265  :                 close (dev->fd);

  01065	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0106d	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  01073	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 266  :                 dev->fd = -1;

  01079	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01081	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 267  :                 return -1;

  0108b	b8 ff ff ff ff	 mov	 eax, -1
  01090	e9 4d 06 00 00	 jmp	 $LN1@fba_dasd_i
$LN29@fba_dasd_i:

; 268  :             }
; 269  :             dev->fbaorigin = (off_t)startblk;

  01095	48 63 84 24 80
	00 00 00	 movsxd	 rax, DWORD PTR startblk$[rsp]
  0109d	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010a5	48 89 81 90 11
	00 00		 mov	 QWORD PTR [rcx+4496], rax

; 270  :             dev->fbanumblk -= startblk;

  010ac	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  010b4	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR startblk$[rsp]
  010bb	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  010c1	2b c1		 sub	 eax, ecx
  010c3	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  010cb	89 81 88 11 00
	00		 mov	 DWORD PTR [rcx+4488], eax
$LN28@fba_dasd_i:

; 271  :         }
; 272  : 
; 273  :         /* The third argument is the device block count */
; 274  :         if (argc >= 3 && strcmp(argv[2],"*") != 0)

  010d1	83 bc 24 28 06
	00 00 03	 cmp	 DWORD PTR argc$[rsp], 3
  010d9	0f 8c f3 01 00
	00		 jl	 $LN31@fba_dasd_i
  010df	b8 08 00 00 00	 mov	 eax, 8
  010e4	48 6b c0 02	 imul	 rax, rax, 2
  010e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169929
  010ef	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  010f7	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  010fb	e8 00 00 00 00	 call	 strcmp
  01100	85 c0		 test	 eax, eax
  01102	0f 84 ca 01 00
	00		 je	 $LN31@fba_dasd_i

; 275  :         {
; 276  :             if (sscanf(argv[2], "%u%c", &numblks, &c) != 1
; 277  :              || numblks > dev->fbanumblk)

  01108	b8 08 00 00 00	 mov	 eax, 8
  0110d	48 6b c0 02	 imul	 rax, rax, 2
  01111	4c 8d 4c 24 78	 lea	 r9, QWORD PTR c$[rsp]
  01116	4c 8d 84 24 dc
	00 00 00	 lea	 r8, QWORD PTR numblks$[rsp]
  0111e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169932
  01125	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  0112d	48 8b 0c 01	 mov	 rcx, QWORD PTR [rcx+rax]
  01131	e8 00 00 00 00	 call	 sscanf
  01136	83 f8 01	 cmp	 eax, 1
  01139	75 1b		 jne	 SHORT $LN33@fba_dasd_i
  0113b	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01143	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  01149	39 84 24 dc 00
	00 00		 cmp	 DWORD PTR numblks$[rsp], eax
  01150	0f 8e 67 01 00
	00		 jle	 $LN32@fba_dasd_i
$LN33@fba_dasd_i:

; 278  :             {
; 279  :                 // "%1d:%04X %s file %s: invalid device block count %s"
; 280  :                 WRMSG( HHC00506, "E", LCSS_DEVNUM, FBATYP( cfba, 0 ), dev->filename, argv[2] );

  01156	83 7c 24 7c 00	 cmp	 DWORD PTR cfba$[rsp], 0
  0115b	74 11		 je	 SHORT $LN82@fba_dasd_i
  0115d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169933
  01164	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv594[rsp], rax
  0116c	eb 0f		 jmp	 SHORT $LN83@fba_dasd_i
$LN82@fba_dasd_i:
  0116e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169934
  01175	48 89 84 24 08
	01 00 00	 mov	 QWORD PTR tv594[rsp], rax
$LN83@fba_dasd_i:
  0117d	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01186	74 15		 je	 SHORT $LN84@fba_dasd_i
  01188	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01190	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01194	89 84 24 d4 00
	00 00		 mov	 DWORD PTR tv599[rsp], eax
  0119b	eb 0b		 jmp	 SHORT $LN85@fba_dasd_i
$LN84@fba_dasd_i:
  0119d	c7 84 24 d4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv599[rsp], 0
$LN85@fba_dasd_i:
  011a8	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  011b1	74 17		 je	 SHORT $LN86@fba_dasd_i
  011b3	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  011bb	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  011bf	d1 f8		 sar	 eax, 1
  011c1	89 84 24 d8 00
	00 00		 mov	 DWORD PTR tv605[rsp], eax
  011c8	eb 0b		 jmp	 SHORT $LN87@fba_dasd_i
$LN86@fba_dasd_i:
  011ca	c7 84 24 d8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv605[rsp], 0
$LN87@fba_dasd_i:
  011d5	b8 08 00 00 00	 mov	 eax, 8
  011da	48 6b c0 02	 imul	 rax, rax, 2
  011de	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR tv588[rsp], rax
  011e6	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  011ee	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  011f5	48 89 8c 24 a8
	01 00 00	 mov	 QWORD PTR tv591[rsp], rcx
  011fd	b9 01 00 00 00	 mov	 ecx, 1
  01202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  01208	48 8b 8c 24 30
	06 00 00	 mov	 rcx, QWORD PTR argv$[rsp]
  01210	48 8b 94 24 a0
	01 00 00	 mov	 rdx, QWORD PTR tv588[rsp]
  01218	48 8b 0c 11	 mov	 rcx, QWORD PTR [rcx+rdx]
  0121c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  01221	48 8b 8c 24 a8
	01 00 00	 mov	 rcx, QWORD PTR tv591[rsp]
  01229	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0122e	48 8b 8c 24 08
	01 00 00	 mov	 rcx, QWORD PTR tv594[rsp]
  01236	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0123b	8b 8c 24 d4 00
	00 00		 mov	 ecx, DWORD PTR tv599[rsp]
  01242	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  01246	8b 8c 24 d8 00
	00 00		 mov	 ecx, DWORD PTR tv605[rsp]
  0124d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  01251	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169935
  01258	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0125d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169936
  01264	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01269	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0126e	41 b9 03 00 00
	00		 mov	 r9d, 3
  01274	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169937
  0127b	ba 18 01 00 00	 mov	 edx, 280		; 00000118H
  01280	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169938
  01287	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 281  :                 close (dev->fd);

  0128d	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01295	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0129b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 282  :                 dev->fd = -1;

  012a1	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012a9	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 283  :                 return -1;

  012b3	b8 ff ff ff ff	 mov	 eax, -1
  012b8	e9 25 04 00 00	 jmp	 $LN1@fba_dasd_i
$LN32@fba_dasd_i:

; 284  :             }
; 285  :             dev->fbanumblk = numblks;

  012bd	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012c5	8b 8c 24 dc 00
	00 00		 mov	 ecx, DWORD PTR numblks$[rsp]
  012cc	89 88 88 11 00
	00		 mov	 DWORD PTR [rax+4488], ecx
$LN31@fba_dasd_i:
$LN26@fba_dasd_i:
$LN19@fba_dasd_i:

; 286  :         }
; 287  :     }
; 288  : 
; 289  :     dev->fbaend = (dev->fbaorigin + dev->fbanumblk) * dev->fbablksiz;

  012d2	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  012da	48 63 80 88 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4488]
  012e1	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012e9	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  012f0	48 03 c8	 add	 rcx, rax
  012f3	48 8b c1	 mov	 rax, rcx
  012f6	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  012fe	48 63 89 8c 11
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4492]
  01305	48 0f af c1	 imul	 rax, rcx
  01309	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01311	48 89 81 a0 11
	00 00		 mov	 QWORD PTR [rcx+4512], rax

; 290  : 
; 291  :     if (!dev->quiet)

  01318	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01320	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  01326	c1 e8 0c	 shr	 eax, 12
  01329	83 e0 01	 and	 eax, 1
  0132c	85 c0		 test	 eax, eax
  0132e	0f 85 32 01 00
	00		 jne	 $LN34@fba_dasd_i

; 292  :         // "%1d:%04X %s file %s: origin %"PRId64", blks %d"
; 293  :         WRMSG( HHC00507, "I", LCSS_DEVNUM, FBATYP( cfba, 0 ),

  01334	83 7c 24 7c 00	 cmp	 DWORD PTR cfba$[rsp], 0
  01339	74 11		 je	 SHORT $LN88@fba_dasd_i
  0133b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169940
  01342	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv639[rsp], rax
  0134a	eb 0f		 jmp	 SHORT $LN89@fba_dasd_i
$LN88@fba_dasd_i:
  0134c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169941
  01353	48 89 84 24 10
	01 00 00	 mov	 QWORD PTR tv639[rsp], rax
$LN89@fba_dasd_i:
  0135b	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01364	74 15		 je	 SHORT $LN90@fba_dasd_i
  01366	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0136e	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01372	89 84 24 e0 00
	00 00		 mov	 DWORD PTR tv676[rsp], eax
  01379	eb 0b		 jmp	 SHORT $LN91@fba_dasd_i
$LN90@fba_dasd_i:
  0137b	c7 84 24 e0 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv676[rsp], 0
$LN91@fba_dasd_i:
  01386	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0138f	74 17		 je	 SHORT $LN92@fba_dasd_i
  01391	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01399	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0139d	d1 f8		 sar	 eax, 1
  0139f	89 84 24 e4 00
	00 00		 mov	 DWORD PTR tv682[rsp], eax
  013a6	eb 0b		 jmp	 SHORT $LN93@fba_dasd_i
$LN92@fba_dasd_i:
  013a8	c7 84 24 e4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv682[rsp], 0
$LN93@fba_dasd_i:
  013b3	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  013bb	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  013c1	48 89 84 24 b0
	01 00 00	 mov	 QWORD PTR tv636[rsp], rax
  013c9	b9 01 00 00 00	 mov	 ecx, 1
  013ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  013d4	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013dc	8b 89 88 11 00
	00		 mov	 ecx, DWORD PTR [rcx+4488]
  013e2	89 4c 24 60	 mov	 DWORD PTR [rsp+96], ecx
  013e6	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  013ee	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  013f5	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  013fa	48 8b 8c 24 b0
	01 00 00	 mov	 rcx, QWORD PTR tv636[rsp]
  01402	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01407	48 8b 8c 24 10
	01 00 00	 mov	 rcx, QWORD PTR tv639[rsp]
  0140f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  01414	8b 8c 24 e0 00
	00 00		 mov	 ecx, DWORD PTR tv676[rsp]
  0141b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0141f	8b 8c 24 e4 00
	00 00		 mov	 ecx, DWORD PTR tv682[rsp]
  01426	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0142a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169942
  01431	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  01436	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169943
  0143d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01442	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01447	41 b9 03 00 00
	00		 mov	 r9d, 3
  0144d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169944
  01454	ba 26 01 00 00	 mov	 edx, 294		; 00000126H
  01459	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169945
  01460	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN34@fba_dasd_i:

; 294  :                dev->filename, dev->fbaorigin, dev->fbanumblk );
; 295  : 
; 296  :     /* Set number of sense bytes */
; 297  :     dev->numsense = 24;

  01466	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0146e	c7 80 60 03 00
	00 18 00 00 00	 mov	 DWORD PTR [rax+864], 24

; 298  : 
; 299  :     /* Locate the FBA dasd table entry */
; 300  :     dev->fbatab = dasd_lookup (DASD_FBADEV, NULL, dev->devtype, dev->fbanumblk);

  01478	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01480	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01484	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0148c	44 8b 89 88 11
	00 00		 mov	 r9d, DWORD PTR [rcx+4488]
  01493	44 8b c0	 mov	 r8d, eax
  01496	33 d2		 xor	 edx, edx
  01498	b9 03 00 00 00	 mov	 ecx, 3
  0149d	e8 00 00 00 00	 call	 dasd_lookup
  014a2	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  014aa	48 89 81 80 11
	00 00		 mov	 QWORD PTR [rcx+4480], rax

; 301  :     if (dev->fbatab == NULL)

  014b1	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  014b9	48 83 b8 80 11
	00 00 00	 cmp	 QWORD PTR [rax+4480], 0
  014c1	0f 85 5b 01 00
	00		 jne	 $LN35@fba_dasd_i

; 302  :     {
; 303  :         // "%1d:%04X %s file %s: device type %4.4X not found in dasd table"
; 304  :         WRMSG( HHC00508, "E", LCSS_DEVNUM, FBATYP( cfba, 0 ), dev->filename, dev->devtype );

  014c7	83 7c 24 7c 00	 cmp	 DWORD PTR cfba$[rsp], 0
  014cc	74 11		 je	 SHORT $LN94@fba_dasd_i
  014ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169947
  014d5	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv711[rsp], rax
  014dd	eb 0f		 jmp	 SHORT $LN95@fba_dasd_i
$LN94@fba_dasd_i:
  014df	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169948
  014e6	48 89 84 24 18
	01 00 00	 mov	 QWORD PTR tv711[rsp], rax
$LN95@fba_dasd_i:
  014ee	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  014f7	74 15		 je	 SHORT $LN96@fba_dasd_i
  014f9	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  01501	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  01505	89 84 24 e8 00
	00 00		 mov	 DWORD PTR tv716[rsp], eax
  0150c	eb 0b		 jmp	 SHORT $LN97@fba_dasd_i
$LN96@fba_dasd_i:
  0150e	c7 84 24 e8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv716[rsp], 0
$LN97@fba_dasd_i:
  01519	48 83 bc 24 20
	06 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  01522	74 17		 je	 SHORT $LN98@fba_dasd_i
  01524	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0152c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  01530	d1 f8		 sar	 eax, 1
  01532	89 84 24 ec 00
	00 00		 mov	 DWORD PTR tv722[rsp], eax
  01539	eb 0b		 jmp	 SHORT $LN99@fba_dasd_i
$LN98@fba_dasd_i:
  0153b	c7 84 24 ec 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv722[rsp], 0
$LN99@fba_dasd_i:
  01546	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0154e	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  01552	89 84 24 f4 00
	00 00		 mov	 DWORD PTR tv706[rsp], eax
  01559	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01561	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  01568	48 89 8c 24 b8
	01 00 00	 mov	 QWORD PTR tv708[rsp], rcx
  01570	b9 01 00 00 00	 mov	 ecx, 1
  01575	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0157b	8b 8c 24 f4 00
	00 00		 mov	 ecx, DWORD PTR tv706[rsp]
  01582	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  01586	48 8b 8c 24 b8
	01 00 00	 mov	 rcx, QWORD PTR tv708[rsp]
  0158e	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  01593	48 8b 8c 24 18
	01 00 00	 mov	 rcx, QWORD PTR tv711[rsp]
  0159b	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  015a0	8b 8c 24 e8 00
	00 00		 mov	 ecx, DWORD PTR tv716[rsp]
  015a7	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  015ab	8b 8c 24 ec 00
	00 00		 mov	 ecx, DWORD PTR tv722[rsp]
  015b2	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  015b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169949
  015bd	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  015c2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169950
  015c9	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  015ce	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  015d3	41 b9 03 00 00
	00		 mov	 r9d, 3
  015d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169951
  015e0	ba 30 01 00 00	 mov	 edx, 304		; 00000130H
  015e5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169952
  015ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 305  :         close (dev->fd);

  015f2	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  015fa	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  01600	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 306  :         dev->fd = -1;

  01606	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0160e	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 307  :         return -1;

  01618	b8 ff ff ff ff	 mov	 eax, -1
  0161d	e9 c0 00 00 00	 jmp	 $LN1@fba_dasd_i
$LN35@fba_dasd_i:

; 308  :     }
; 309  : 
; 310  :     /* Build the dh_devid area */
; 311  :     dev->numdevid = dasd_build_fba_devid (dev->fbatab,(BYTE *)&dev->devid);

  01622	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0162a	48 05 68 04 00
	00		 add	 rax, 1128		; 00000468H
  01630	48 8b d0	 mov	 rdx, rax
  01633	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0163b	48 8b 88 80 11
	00 00		 mov	 rcx, QWORD PTR [rax+4480]
  01642	e8 00 00 00 00	 call	 dasd_build_fba_devid
  01647	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0164f	89 81 64 04 00
	00		 mov	 DWORD PTR [rcx+1124], eax

; 312  : 
; 313  :     /* Build the devchar area */
; 314  :     dev->numdevchar = dasd_build_fba_devchar (dev->fbatab,

  01655	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0165d	48 05 6c 05 00
	00		 add	 rax, 1388		; 0000056cH
  01663	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0166b	44 8b 81 88 11
	00 00		 mov	 r8d, DWORD PTR [rcx+4488]
  01672	48 8b d0	 mov	 rdx, rax
  01675	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0167d	48 8b 88 80 11
	00 00		 mov	 rcx, QWORD PTR [rax+4480]
  01684	e8 00 00 00 00	 call	 dasd_build_fba_devchar
  01689	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  01691	89 81 68 05 00
	00		 mov	 DWORD PTR [rcx+1384], eax

; 315  :                                  (BYTE *)&dev->devchar,dev->fbanumblk);
; 316  : 
; 317  :     /* Initialize current blkgrp and cache entry */
; 318  :     dev->bufcur = dev->cache = -1;

  01697	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0169f	c7 80 f8 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+504], -1
  016a9	48 8b 84 24 20
	06 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  016b1	c7 80 c0 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+448], -1

; 319  : 
; 320  :     /* Activate I/O tracing */
; 321  : //  dev->ccwtrace = 1;
; 322  : 
; 323  :     /* Call the compressed init handler if compressed fba */
; 324  :     if (cfba)

  016bb	83 7c 24 7c 00	 cmp	 DWORD PTR cfba$[rsp], 0
  016c0	74 1e		 je	 SHORT $LN36@fba_dasd_i

; 325  :         return cckd_dasd_init_handler (dev, argc, argv);

  016c2	4c 8b 84 24 30
	06 00 00	 mov	 r8, QWORD PTR argv$[rsp]
  016ca	8b 94 24 28 06
	00 00		 mov	 edx, DWORD PTR argc$[rsp]
  016d1	48 8b 8c 24 20
	06 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  016d9	e8 00 00 00 00	 call	 cckd_dasd_init_handler
  016de	eb 02		 jmp	 SHORT $LN1@fba_dasd_i
$LN36@fba_dasd_i:

; 326  : 
; 327  :     return 0;

  016e0	33 c0		 xor	 eax, eax
$LN1@fba_dasd_i:

; 328  : } /* end function fba_dasd_init_handler */

  016e2	48 8b 8c 24 00
	06 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  016ea	48 33 cc	 xor	 rcx, rsp
  016ed	e8 00 00 00 00	 call	 __security_check_cookie
  016f2	48 81 c4 18 06
	00 00		 add	 rsp, 1560		; 00000618H
  016f9	c3		 ret	 0
fba_dasd_init_handler ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
sector$ = 32
rc$ = 36
dev$ = 64
blknum$ = 72
blksize$ = 80
blkfactor$ = 88
iobuf$ = 96
unitstat$ = 104
residual$ = 112
fbadasd_write_block PROC

; 1383 : {

$LN6:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1384 : int     rc;           /* Return code from write function             */
; 1385 : int     sector;       /* First sector being read                     */
; 1386 : 
; 1387 :     /* Unit check if block number is invalid */
; 1388 :     sector = blknum * blkfactor;

  00017	8b 44 24 48	 mov	 eax, DWORD PTR blknum$[rsp]
  0001b	0f af 44 24 58	 imul	 eax, DWORD PTR blkfactor$[rsp]
  00020	89 44 24 20	 mov	 DWORD PTR sector$[rsp], eax

; 1389 :     if (sector >= dev->fbanumblk || sector < 0 )

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00029	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  0002f	39 44 24 20	 cmp	 DWORD PTR sector$[rsp], eax
  00033	7d 07		 jge	 SHORT $LN3@fbadasd_wr
  00035	83 7c 24 20 00	 cmp	 DWORD PTR sector$[rsp], 0
  0003a	7d 23		 jge	 SHORT $LN2@fbadasd_wr
$LN3@fbadasd_wr:

; 1390 :     {
; 1391 :         dev->sense[0] = SENSE_CR;

  0003c	b8 01 00 00 00	 mov	 eax, 1
  00041	48 6b c0 00	 imul	 rax, rax, 0
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004a	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1392 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00052	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  00057	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1393 :         return;

  0005a	e9 8d 00 00 00	 jmp	 $LN1@fbadasd_wr
$LN2@fbadasd_wr:

; 1394 :     }
; 1395 : 
; 1396 :     /* Seek to start of desired block */
; 1397 :     dev->fbarba = (off_t)(( dev->fbaorigin + sector ) * dev->fbablksiz);

  0005f	48 63 44 24 20	 movsxd	 rax, DWORD PTR sector$[rsp]
  00064	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00069	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  00070	48 03 c8	 add	 rcx, rax
  00073	48 8b c1	 mov	 rax, rcx
  00076	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0007b	48 63 89 8c 11
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4492]
  00082	48 0f af c1	 imul	 rax, rcx
  00086	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0008b	48 89 81 98 11
	00 00		 mov	 QWORD PTR [rcx+4504], rax

; 1398 : 
; 1399 :     /* Read block into I/O buffer */
; 1400 :     rc = fba_write (dev, iobuf, blksize, unitstat);

  00092	4c 8b 4c 24 68	 mov	 r9, QWORD PTR unitstat$[rsp]
  00097	44 8b 44 24 50	 mov	 r8d, DWORD PTR blksize$[rsp]
  0009c	48 8b 54 24 60	 mov	 rdx, QWORD PTR iobuf$[rsp]
  000a1	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000a6	e8 00 00 00 00	 call	 fba_write
  000ab	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1401 :     if (rc < blksize)

  000af	8b 44 24 50	 mov	 eax, DWORD PTR blksize$[rsp]
  000b3	39 44 24 24	 cmp	 DWORD PTR rc$[rsp], eax
  000b7	7d 20		 jge	 SHORT $LN4@fbadasd_wr

; 1402 :     {
; 1403 :        dev->sense[0] = SENSE_CR;

  000b9	b8 01 00 00 00	 mov	 eax, 1
  000be	48 6b c0 00	 imul	 rax, rax, 0
  000c2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000c7	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1404 :        *unitstat = CSW_CE | CSW_DE | CSW_UC;

  000cf	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  000d4	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1405 :        return;

  000d7	eb 13		 jmp	 SHORT $LN1@fbadasd_wr
$LN4@fbadasd_wr:

; 1406 :     }
; 1407 : 
; 1408 :     /* Return unit status and residual byte count */
; 1409 :     *unitstat = CSW_CE | CSW_DE;

  000d9	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  000de	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1410 :     *residual = 0;

  000e1	48 8b 44 24 70	 mov	 rax, QWORD PTR residual$[rsp]
  000e6	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN1@fbadasd_wr:

; 1411 : 
; 1412 : } /* end function fbadasd_write_block */

  000ec	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f0	c3		 ret	 0
fbadasd_write_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
sector$ = 32
rc$ = 36
dev$ = 64
blknum$ = 72
blksize$ = 80
blkfactor$ = 88
iobuf$ = 96
unitstat$ = 104
residual$ = 112
fbadasd_read_block PROC

; 1346 : {

$LN5:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1347 : int     rc;                             /* Return code               */
; 1348 : int     sector;       /* First sector being read                     */
; 1349 : 
; 1350 :     /* Unit check if block number is invalid */
; 1351 :     sector = blknum * blkfactor;

  00017	8b 44 24 48	 mov	 eax, DWORD PTR blknum$[rsp]
  0001b	0f af 44 24 58	 imul	 eax, DWORD PTR blkfactor$[rsp]
  00020	89 44 24 20	 mov	 DWORD PTR sector$[rsp], eax

; 1352 :     if (sector >= dev->fbanumblk)

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00029	8b 80 88 11 00
	00		 mov	 eax, DWORD PTR [rax+4488]
  0002f	39 44 24 20	 cmp	 DWORD PTR sector$[rsp], eax
  00033	7c 23		 jl	 SHORT $LN2@fbadasd_re

; 1353 :     {
; 1354 :         dev->sense[0] = SENSE_CR;

  00035	b8 01 00 00 00	 mov	 eax, 1
  0003a	48 6b c0 00	 imul	 rax, rax, 0
  0003e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00043	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1355 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  0004b	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  00050	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1356 :         return;

  00053	e9 8d 00 00 00	 jmp	 $LN1@fbadasd_re
$LN2@fbadasd_re:

; 1357 :     }
; 1358 : 
; 1359 :     /* Seek to start of desired block */
; 1360 :     dev->fbarba = ( dev->fbaorigin + sector ) * dev->fbablksiz;

  00058	48 63 44 24 20	 movsxd	 rax, DWORD PTR sector$[rsp]
  0005d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00062	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  00069	48 03 c8	 add	 rcx, rax
  0006c	48 8b c1	 mov	 rax, rcx
  0006f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00074	48 63 89 8c 11
	00 00		 movsxd	 rcx, DWORD PTR [rcx+4492]
  0007b	48 0f af c1	 imul	 rax, rcx
  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00084	48 89 81 98 11
	00 00		 mov	 QWORD PTR [rcx+4504], rax

; 1361 : 
; 1362 :     /* Read block into I/O buffer */
; 1363 :     rc = fba_read (dev, iobuf, blksize, unitstat);

  0008b	4c 8b 4c 24 68	 mov	 r9, QWORD PTR unitstat$[rsp]
  00090	44 8b 44 24 50	 mov	 r8d, DWORD PTR blksize$[rsp]
  00095	48 8b 54 24 60	 mov	 rdx, QWORD PTR iobuf$[rsp]
  0009a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0009f	e8 00 00 00 00	 call	 fba_read
  000a4	89 44 24 24	 mov	 DWORD PTR rc$[rsp], eax

; 1364 :     if (rc < blksize)

  000a8	8b 44 24 50	 mov	 eax, DWORD PTR blksize$[rsp]
  000ac	39 44 24 24	 cmp	 DWORD PTR rc$[rsp], eax
  000b0	7d 20		 jge	 SHORT $LN3@fbadasd_re

; 1365 :     {
; 1366 :        dev->sense[0] = SENSE_CR;

  000b2	b8 01 00 00 00	 mov	 eax, 1
  000b7	48 6b c0 00	 imul	 rax, rax, 0
  000bb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000c0	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1367 :        *unitstat = CSW_CE | CSW_DE | CSW_UC;

  000c8	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  000cd	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1368 :        return;

  000d0	eb 13		 jmp	 SHORT $LN1@fbadasd_re
$LN3@fbadasd_re:

; 1369 :     }
; 1370 : 
; 1371 :     /* Return unit status and residual byte count */
; 1372 :     *unitstat = CSW_CE | CSW_DE;

  000d2	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  000d7	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1373 :     *residual = 0;

  000da	48 8b 44 24 70	 mov	 rax, QWORD PTR residual$[rsp]
  000df	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN1@fbadasd_re:

; 1374 : 
; 1375 : } /* end function fbadasd_read_block */

  000e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e9	c3		 ret	 0
fbadasd_read_block ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\fbadasd.c
_TEXT	SEGMENT
rc$ = 32
tv78 = 36
blkfactor$ = 40
dev$ = 64
type$ = 72
blknum$ = 80
blksize$ = 88
iobuf$ = 96
unitstat$ = 104
residual$ = 112
fbadasd_syncblk_io PROC

; 1420 : {

$LN10:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1421 : int     rc;                             /* Return code               */
; 1422 : int     blkfactor;                      /* Number of device blocks
; 1423 :                                            per logical block         */
; 1424 : 
; 1425 :     /* Calculate the blocking factor */
; 1426 :     blkfactor = blksize / dev->fbablksiz;

  00017	8b 44 24 58	 mov	 eax, DWORD PTR blksize$[rsp]
  0001b	99		 cdq
  0001c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00021	f7 b9 8c 11 00
	00		 idiv	 DWORD PTR [rcx+4492]
  00027	89 44 24 28	 mov	 DWORD PTR blkfactor$[rsp], eax

; 1427 : 
; 1428 :     /* Unit check if block number is invalid */
; 1429 :     if (blknum * blkfactor >= dev->fbanumblk)

  0002b	8b 44 24 50	 mov	 eax, DWORD PTR blknum$[rsp]
  0002f	0f af 44 24 28	 imul	 eax, DWORD PTR blkfactor$[rsp]
  00034	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00039	3b 81 88 11 00
	00		 cmp	 eax, DWORD PTR [rcx+4488]
  0003f	7c 23		 jl	 SHORT $LN4@fbadasd_sy

; 1430 :     {
; 1431 :         dev->sense[0] = SENSE_CR;

  00041	b8 01 00 00 00	 mov	 eax, 1
  00046	48 6b c0 00	 imul	 rax, rax, 0
  0004a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  0004f	c6 84 01 64 03
	00 00 80	 mov	 BYTE PTR [rcx+rax+868], 128 ; 00000080H

; 1432 :         *unitstat = CSW_CE | CSW_DE | CSW_UC;

  00057	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  0005c	c6 00 0e	 mov	 BYTE PTR [rax], 14

; 1433 :         return;

  0005f	e9 ab 00 00 00	 jmp	 $LN1@fbadasd_sy
$LN4@fbadasd_sy:

; 1434 :     }
; 1435 : 
; 1436 :     /* Seek to start of desired block */
; 1437 :     dev->fbarba = dev->fbaorigin * dev->fbablksiz;

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00069	48 63 80 8c 11
	00 00		 movsxd	 rax, DWORD PTR [rax+4492]
  00070	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00075	48 8b 89 90 11
	00 00		 mov	 rcx, QWORD PTR [rcx+4496]
  0007c	48 0f af c8	 imul	 rcx, rax
  00080	48 8b c1	 mov	 rax, rcx
  00083	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00088	48 89 81 98 11
	00 00		 mov	 QWORD PTR [rcx+4504], rax

; 1438 : 
; 1439 :     /* Process depending on operation type */
; 1440 :     switch (type) {

  0008f	0f b6 44 24 48	 movzx	 eax, BYTE PTR type$[rsp]
  00094	88 44 24 24	 mov	 BYTE PTR tv78[rsp], al
  00098	80 7c 24 24 01	 cmp	 BYTE PTR tv78[rsp], 1
  0009d	74 09		 je	 SHORT $LN5@fbadasd_sy
  0009f	80 7c 24 24 02	 cmp	 BYTE PTR tv78[rsp], 2
  000a4	74 2d		 je	 SHORT $LN7@fbadasd_sy
  000a6	eb 54		 jmp	 SHORT $LN2@fbadasd_sy
$LN5@fbadasd_sy:

; 1441 : 
; 1442 :     case 0x01:
; 1443 :         /* Write block from I/O buffer */
; 1444 :         rc = fba_write (dev, iobuf, blksize, unitstat);

  000a8	4c 8b 4c 24 68	 mov	 r9, QWORD PTR unitstat$[rsp]
  000ad	44 8b 44 24 58	 mov	 r8d, DWORD PTR blksize$[rsp]
  000b2	48 8b 54 24 60	 mov	 rdx, QWORD PTR iobuf$[rsp]
  000b7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000bc	e8 00 00 00 00	 call	 fba_write
  000c1	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1445 :         if (rc < blksize) return;

  000c5	8b 44 24 58	 mov	 eax, DWORD PTR blksize$[rsp]
  000c9	39 44 24 20	 cmp	 DWORD PTR rc$[rsp], eax
  000cd	7d 02		 jge	 SHORT $LN6@fbadasd_sy
  000cf	eb 3e		 jmp	 SHORT $LN1@fbadasd_sy
$LN6@fbadasd_sy:

; 1446 :         break;

  000d1	eb 29		 jmp	 SHORT $LN2@fbadasd_sy
$LN7@fbadasd_sy:

; 1447 : 
; 1448 :     case 0x02:
; 1449 :         /* Read block into I/O buffer */
; 1450 :         rc = fba_read (dev, iobuf, blksize, unitstat);

  000d3	4c 8b 4c 24 68	 mov	 r9, QWORD PTR unitstat$[rsp]
  000d8	44 8b 44 24 58	 mov	 r8d, DWORD PTR blksize$[rsp]
  000dd	48 8b 54 24 60	 mov	 rdx, QWORD PTR iobuf$[rsp]
  000e2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  000e7	e8 00 00 00 00	 call	 fba_read
  000ec	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 1451 :         if (rc < blksize) return;

  000f0	8b 44 24 58	 mov	 eax, DWORD PTR blksize$[rsp]
  000f4	39 44 24 20	 cmp	 DWORD PTR rc$[rsp], eax
  000f8	7d 02		 jge	 SHORT $LN8@fbadasd_sy
  000fa	eb 13		 jmp	 SHORT $LN1@fbadasd_sy
$LN8@fbadasd_sy:
$LN2@fbadasd_sy:

; 1452 :         break;
; 1453 : 
; 1454 :     } /* end switch(type) */
; 1455 : 
; 1456 :     /* Return unit status and residual byte count */
; 1457 :     *unitstat = CSW_CE | CSW_DE;

  000fc	48 8b 44 24 68	 mov	 rax, QWORD PTR unitstat$[rsp]
  00101	c6 00 0c	 mov	 BYTE PTR [rax], 12

; 1458 :     *residual = 0;

  00104	48 8b 44 24 70	 mov	 rax, QWORD PTR residual$[rsp]
  00109	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0
$LN1@fbadasd_sy:

; 1459 : 
; 1460 : } /* end function fbadasd_syncblk_io */

  0010f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00113	c3		 ret	 0
fbadasd_syncblk_io ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_fw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_fw_noswap PROC					; COMDAT

; 764  :     inline void store_fw_noswap(void *ptr, U32 value) {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 765  :       memcpy((BYTE *)ptr, (BYTE *)&value, 4);

  00009	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 4c 24 10	 mov	 ecx, DWORD PTR value$[rsp]
  00012	89 08		 mov	 DWORD PTR [rax], ecx

; 766  :     }

  00014	c3		 ret	 0
store_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
