; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
?noisy@?1??z900_load_hmc@@9@9 DB 01H			; `z900_load_hmc'::`2'::noisy
?noisy@?1??z900_scedio_ior@@9@9 DB 01H			; `z900_scedio_ior'::`2'::noisy
?noisy@?1??s370_load_hmc@@9@9 DB 01H			; `s370_load_hmc'::`2'::noisy
?noisy@?1??s390_load_hmc@@9@9 DB 01H			; `s390_load_hmc'::`2'::noisy
?noisy@?1??s390_scedio_ior@@9@9 DB 01H			; `s390_scedio_ior'::`2'::noisy
CONST	ENDS
PUBLIC	__local_stdio_scanf_options
PUBLIC	_vsscanf_l
PUBLIC	sscanf
PUBLIC	set_sce_dir
PUBLIC	get_sce_dir
PUBLIC	load_main
PUBLIC	s370_load_main
PUBLIC	load_hmc
PUBLIC	s370_load_hmc
PUBLIC	fetch_hw_noswap
PUBLIC	store_hw_noswap
PUBLIC	fetch_fw_noswap
PUBLIC	fetch_dw_noswap
PUBLIC	store_dw_noswap
PUBLIC	_get_storekey_ptr
PUBLIC	_get_storekey1_ptr
PUBLIC	_get_storekey2_ptr
PUBLIC	s370__or_storage_key
PUBLIC	s370_or_2K_storage_key
PUBLIC	s370_or_storage_key
PUBLIC	s390_load_main
PUBLIC	s390_load_hmc
PUBLIC	s390_sclp_scedio_request
PUBLIC	s390_sclp_scedio_event
PUBLIC	s390__or_storage_key
PUBLIC	s390_or_4K_storage_key
PUBLIC	s390_or_storage_key
PUBLIC	z900_load_main
PUBLIC	z900_load_hmc
PUBLIC	z900_sclp_scedio_request
PUBLIC	z900_sclp_scedio_event
PUBLIC	z900__or_storage_key
PUBLIC	z900_or_4K_storage_key
PUBLIC	z900_or_storage_key
PUBLIC	__real@4000000000000000
EXTRN	__report_rangecheckfailure:PROC
EXTRN	__imp__errno:PROC
EXTRN	strrchr:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strncmp:PROC
EXTRN	__imp_strdup:PROC
EXTRN	__imp_free:PROC
EXTRN	_byteswap_ushort:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	_byteswap_uint64:PROC
EXTRN	__imp__lseeki64:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	__imp_write:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp_fgets:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp___stdio_common_vsscanf:PROC
EXTRN	__imp__difftime64:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_signal_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_ptt_pthread_trace:PROC
EXTRN	__imp_strlcpy:PROC
EXTRN	__imp_strlcat:PROC
EXTRN	__imp_fmt_memsize:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_sched_yield:PROC
EXTRN	__imp_realpath:PROC
EXTRN	__imp_hostpath:PROC
EXTRN	__imp_w32_fclose:PROC
EXTRN	__imp_w32_hopen:PROC
EXTRN	__imp_guest_to_host:PROC
EXTRN	s370_common_load_begin:PROC
EXTRN	s370_common_load_finish:PROC
EXTRN	sclp_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	s390_common_load_begin:PROC
EXTRN	s390_common_load_finish:PROC
EXTRN	z900_common_load_begin:PROC
EXTRN	z900_common_load_finish:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_pttclass:QWORD
EXTRN	__imp_sysblk:BYTE
EXTRN	__imp_debug_cpu_state:QWORD
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9:QWORD							; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_DATA	ENDS
_BSS	SEGMENT
scedio_tid DD	01H DUP (?)
	ALIGN	8

sce_basedir DQ	01H DUP (?)
?static_scedio_bk@?1??s390_scedio_request@@9@9 DB 0138H DUP (?) ; `s390_scedio_request'::`2'::static_scedio_bk
?scedio_pending@?1??s390_scedio_request@@9@9 DB 01H DUP (?) ; `s390_scedio_request'::`2'::scedio_pending
	ALIGN	4

?static_scedio_bk@?1??z900_scedio_request@@9@9 DB 0138H DUP (?) ; `z900_scedio_request'::`2'::static_scedio_bk
?scedio_pending@?1??z900_scedio_request@@9@9 DB 01H DUP (?) ; `z900_scedio_request'::`2'::scedio_pending
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsscanf_l DD imagerel $LN3
	DD	imagerel $LN3+80
	DD	imagerel $unwind$_vsscanf_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$sscanf DD imagerel $LN3
	DD	imagerel $LN3+79
	DD	imagerel $unwind$sscanf
pdata	ENDS
pdata	SEGMENT
$pdata$difftime DD imagerel difftime
	DD	imagerel difftime+35
	DD	imagerel $unwind$difftime
$pdata$time DD	imagerel time
	DD	imagerel time+25
	DD	imagerel $unwind$time
$pdata$set_sce_dir DD imagerel $LN8
	DD	imagerel $LN8+351
	DD	imagerel $unwind$set_sce_dir
$pdata$load_main DD imagerel $LN12
	DD	imagerel $LN12+153
	DD	imagerel $unwind$load_main
$pdata$s370_load_main DD imagerel $LN23
	DD	imagerel $LN23+1206
	DD	imagerel $unwind$s370_load_main
$pdata$load_hmc DD imagerel $LN12
	DD	imagerel $LN12+149
	DD	imagerel $unwind$load_hmc
$pdata$s370_load_hmc DD imagerel $LN18
	DD	imagerel $LN18+1099
	DD	imagerel $unwind$s370_load_hmc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_hw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_hw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_fw_noswap DD imagerel $LN3
	DD	imagerel $LN3+27
	DD	imagerel $unwind$fetch_fw_noswap
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$fetch_dw_noswap DD imagerel $LN3
	DD	imagerel $LN3+30
	DD	imagerel $unwind$fetch_dw_noswap
pdata	ENDS
pdata	SEGMENT
$pdata$Interrupt_Lock_Obtained DD imagerel Interrupt_Lock_Obtained
	DD	imagerel Interrupt_Lock_Obtained+269
	DD	imagerel $unwind$Interrupt_Lock_Obtained
$pdata$Obtain_Interrupt_Lock DD imagerel Obtain_Interrupt_Lock
	DD	imagerel Obtain_Interrupt_Lock+88
	DD	imagerel $unwind$Obtain_Interrupt_Lock
$pdata$Release_Interrupt_Lock DD imagerel Release_Interrupt_Lock
	DD	imagerel Release_Interrupt_Lock+71
	DD	imagerel $unwind$Release_Interrupt_Lock
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_get_storekey_ptr DD imagerel $LN5
	DD	imagerel $LN5+104
	DD	imagerel $unwind$_get_storekey_ptr
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+170
	DD	imagerel $unwind$s370__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_2K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s370_or_2K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s370_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s370_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$set_sce_basedir DD imagerel set_sce_basedir
	DD	imagerel set_sce_basedir+451
	DD	imagerel $unwind$set_sce_basedir
$pdata$check_sce_filepath DD imagerel check_sce_filepath
	DD	imagerel check_sce_filepath+365
	DD	imagerel $unwind$check_sce_filepath
$pdata$s390_load_main DD imagerel $LN23
	DD	imagerel $LN23+1206
	DD	imagerel $unwind$s390_load_main
$pdata$s390_load_hmc DD imagerel $LN18
	DD	imagerel $LN18+1099
	DD	imagerel $unwind$s390_load_hmc
$pdata$s390_sclp_scedio_request DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$s390_sclp_scedio_request
$pdata$s390_sclp_scedio_event DD imagerel $LN5
	DD	imagerel $LN5+192
	DD	imagerel $unwind$s390_sclp_scedio_event
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$s390__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$s390_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$s390_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$s390_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$s390_write_file DD imagerel s390_write_file
	DD	imagerel s390_write_file+756
	DD	imagerel $unwind$s390_write_file
$pdata$s390_read_file DD imagerel s390_read_file
	DD	imagerel s390_read_file+791
	DD	imagerel $unwind$s390_read_file
$pdata$s390_scedio_ior DD imagerel s390_scedio_ior
	DD	imagerel s390_scedio_ior+459
	DD	imagerel $unwind$s390_scedio_ior
$pdata$s390_scedio_iov DD imagerel s390_scedio_iov
	DD	imagerel s390_scedio_iov+1054
	DD	imagerel $unwind$s390_scedio_iov
$pdata$s390_scedio_thread DD imagerel s390_scedio_thread
	DD	imagerel s390_scedio_thread+439
	DD	imagerel $unwind$s390_scedio_thread
$pdata$s390_scedio_request DD imagerel s390_scedio_request
	DD	imagerel s390_scedio_request+858
	DD	imagerel $unwind$s390_scedio_request
$pdata$z900_load_main DD imagerel $LN23
	DD	imagerel $LN23+1206
	DD	imagerel $unwind$z900_load_main
$pdata$z900_load_hmc DD imagerel $LN18
	DD	imagerel $LN18+1099
	DD	imagerel $unwind$z900_load_hmc
$pdata$z900_sclp_scedio_request DD imagerel $LN5
	DD	imagerel $LN5+106
	DD	imagerel $unwind$z900_sclp_scedio_request
$pdata$z900_sclp_scedio_event DD imagerel $LN5
	DD	imagerel $LN5+192
	DD	imagerel $unwind$z900_sclp_scedio_event
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900__or_storage_key DD imagerel $LN8
	DD	imagerel $LN8+159
	DD	imagerel $unwind$z900__or_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_4K_storage_key DD imagerel $LN3
	DD	imagerel $LN3+42
	DD	imagerel $unwind$z900_or_4K_storage_key
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$z900_or_storage_key DD imagerel $LN3
	DD	imagerel $LN3+33
	DD	imagerel $unwind$z900_or_storage_key
pdata	ENDS
pdata	SEGMENT
$pdata$z900_write_file DD imagerel z900_write_file
	DD	imagerel z900_write_file+799
	DD	imagerel $unwind$z900_write_file
$pdata$z900_read_file DD imagerel z900_read_file
	DD	imagerel z900_read_file+839
	DD	imagerel $unwind$z900_read_file
$pdata$z900_scedio_ior DD imagerel z900_scedio_ior
	DD	imagerel z900_scedio_ior+459
	DD	imagerel $unwind$z900_scedio_ior
$pdata$z900_scedio_iov DD imagerel z900_scedio_iov
	DD	imagerel z900_scedio_iov+1055
	DD	imagerel $unwind$z900_scedio_iov
$pdata$z900_scedio_thread DD imagerel z900_scedio_thread
	DD	imagerel z900_scedio_thread+439
	DD	imagerel $unwind$z900_scedio_thread
$pdata$z900_scedio_request DD imagerel z900_scedio_request
	DD	imagerel z900_scedio_request+858
	DD	imagerel $unwind$z900_scedio_request
pdata	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
_DATA	SEGMENT
$SG169554 DB	'realpath()', 00H
	ORG $+1
$SG169555 DB	'E', 00H
	ORG $+2
$SG169556 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169559 DB	'/', 00H
	ORG $+2
$SG169557 DB	'set_sce_dir', 00H
$SG169575 DB	'E', 00H
	ORG $+2
$SG169558 DB	'scedasd.c', 00H
	ORG $+2
$SG169624 DB	'open()', 00H
	ORG $+1
$SG169625 DB	'E', 00H
	ORG $+2
$SG169574 DB	'realpath()', 00H
	ORG $+1
$SG169633 DB	'E', 00H
	ORG $+2
$SG169576 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169632 DB	'read()', 00H
	ORG $+1
$SG169642 DB	'W', 00H
	ORG $+2
$SG169577 DB	'set_sce_basedir', 00H
$SG169578 DB	'scedasd.c', 00H
	ORG $+2
$SG169648 DB	'loaded', 00H
	ORG $+1
$SG169649 DB	'I', 00H
	ORG $+2
$SG169626 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169681 DB	'E', 00H
	ORG $+2
$SG169627 DB	's370_load_main', 00H
	ORG $+1
$SG169628 DB	'scedasd.c', 00H
	ORG $+2
$SG169685 DB	'r', 00H
	ORG $+2
$SG169634 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG169688 DB	'E', 00H
	ORG $+2
$SG169635 DB	's370_load_main', 00H
	ORG $+1
$SG169636 DB	'scedasd.c', 00H
	ORG $+6
$SG169644 DB	's370_load_main', 00H
	ORG $+1
$SG169650 DB	'HHC02317%s %s bytes %s so far...', 0aH, 00H
	ORG $+6
$SG169643 DB	'HHC00603%s SCE file %s: load main terminated at end of m'
	DB	'ainstor', 0aH, 00H
	ORG $+3
$SG169697 DB	'E', 00H
	ORG $+2
$SG169645 DB	'scedasd.c', 00H
	ORG $+2
$SG179747 DB	'open()', 00H
	ORG $+1
$SG179748 DB	'E', 00H
	ORG $+2
$SG169651 DB	's370_load_main', 00H
	ORG $+1
$SG169652 DB	'scedasd.c', 00H
	ORG $+2
$SG179755 DB	'read()', 00H
	ORG $+1
$SG179756 DB	'E', 00H
	ORG $+2
$SG169678 DB	'HERCULES.ins', 00H
	ORG $+3
$SG169682 DB	'HHC00601%s SCE file %s: load from file failed: %s', 0aH, 00H
	ORG $+1
$SG179765 DB	'W', 00H
	ORG $+2
$SG169683 DB	's370_load_hmc', 00H
	ORG $+2
$SG169684 DB	'scedasd.c', 00H
	ORG $+2
$SG179771 DB	'loaded', 00H
	ORG $+1
$SG179772 DB	'I', 00H
	ORG $+2
$SG169687 DB	'fopen()', 00H
$SG169689 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG179804 DB	'E', 00H
	ORG $+2
$SG169690 DB	's370_load_hmc', 00H
	ORG $+2
$SG169691 DB	'scedasd.c', 00H
	ORG $+2
$SG179808 DB	'r', 00H
	ORG $+2
$SG169693 DB	'%260s %i', 00H
	ORG $+3
$SG179811 DB	'E', 00H
	ORG $+2
$SG169698 DB	'HHC00602%s SCE file %s: load from path failed: %s', 0aH, 00H
	ORG $+1
$SG179820 DB	'E', 00H
	ORG $+2
$SG169699 DB	's370_load_hmc', 00H
	ORG $+2
$SG169700 DB	'scedasd.c', 00H
	ORG $+2
$SG179854 DB	'open()', 00H
	ORG $+1
$SG179855 DB	'E', 00H
	ORG $+2
$SG179749 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG179897 DB	'open()', 00H
	ORG $+1
$SG179898 DB	'E', 00H
	ORG $+2
$SG179750 DB	's390_load_main', 00H
	ORG $+1
$SG179751 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG179927 DB	'E', 00H
	ORG $+2
$SG179757 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG179960 DB	'E', 00H
	ORG $+2
$SG179758 DB	's390_load_main', 00H
	ORG $+1
$SG179759 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG179766 DB	'HHC00603%s SCE file %s: load main terminated at end of m'
	DB	'ainstor', 0aH, 00H
	ORG $+3
$SG179972 DB	'E', 00H
	ORG $+2
$SG179767 DB	's390_load_main', 00H
	ORG $+1
$SG179768 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG179983 DB	'*SERVC', 00H
	ORG $+1
$SG180111 DB	'E', 00H
	ORG $+2
$SG179773 DB	'HHC02317%s %s bytes %s so far...', 0aH, 00H
	ORG $+2
$SG180024 DB	'*SERVC', 00H
	ORG $+1
$SG193055 DB	'E', 00H
	ORG $+2
$SG179774 DB	's390_load_main', 00H
	ORG $+1
$SG179775 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG180101 DB	'*SERVC', 00H
	ORG $+1
$SG193063 DB	'E', 00H
	ORG $+2
$SG179801 DB	'HERCULES.ins', 00H
	ORG $+3
$SG179805 DB	'HHC00601%s SCE file %s: load from file failed: %s', 0aH, 00H
	ORG $+1
$SG193072 DB	'W', 00H
	ORG $+2
$SG179806 DB	's390_load_hmc', 00H
	ORG $+2
$SG179807 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG180107 DB	'*SERVC', 00H
	ORG $+1
$SG193079 DB	'I', 00H
	ORG $+2
$SG179810 DB	'fopen()', 00H
$SG179812 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG193054 DB	'open()', 00H
	ORG $+1
$SG193111 DB	'E', 00H
	ORG $+2
$SG179813 DB	's390_load_hmc', 00H
	ORG $+2
$SG179814 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG193062 DB	'read()', 00H
	ORG $+1
$SG193115 DB	'r', 00H
	ORG $+2
$SG179816 DB	'%260s %i', 00H
	ORG $+3
$SG193078 DB	'loaded', 00H
	ORG $+1
$SG193118 DB	'E', 00H
	ORG $+2
$SG179821 DB	'HHC00602%s SCE file %s: load from path failed: %s', 0aH, 00H
	ORG $+1
$SG193127 DB	'E', 00H
	ORG $+2
$SG179822 DB	's390_load_hmc', 00H
	ORG $+2
$SG179823 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG193161 DB	'open()', 00H
	ORG $+1
$SG193162 DB	'E', 00H
	ORG $+2
$SG179856 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG193204 DB	'open()', 00H
	ORG $+1
$SG193205 DB	'E', 00H
	ORG $+2
$SG179857 DB	's390_write_file', 00H
$SG179858 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG193234 DB	'E', 00H
	ORG $+2
$SG179899 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+2
$SG193267 DB	'E', 00H
	ORG $+2
$SG179900 DB	's390_read_file', 00H
	ORG $+1
$SG179901 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG193279 DB	'E', 00H
	ORG $+2
$SG179928 DB	'HHC00604%s SCE file %s: access error on image %s: %s', 0aH
	DB	00H
	ORG $+2
$SG179929 DB	's390_scedio_ior', 00H
$SG179930 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG193290 DB	'*SERVC', 00H
	ORG $+1
$SG193418 DB	'E', 00H
	ORG $+2
$SG179961 DB	'HHC00605%s SCE file %s: access error: %s', 0aH, 00H
	ORG $+2
$SG193331 DB	'*SERVC', 00H
	ORG $+5
$SG179962 DB	's390_scedio_iov', 00H
$SG179963 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG193408 DB	'*SERVC', 00H
	ORG $+5
$SG179973 DB	'HHC00605%s SCE file %s: access error: %s', 0aH, 00H
	ORG $+6
$SG179974 DB	's390_scedio_iov', 00H
$SG179975 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+3
$SG193414 DB	'*SERVC', 00H
	ORG $+5
$SG179982 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:730', 00H
	ORG $+3
$SG180023 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:771', 00H
	ORG $+3
$SG180025 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:774', 00H
	ORG $+3
$SG180026 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:778', 00H
	ORG $+3
$SG180027 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:782', 00H
	ORG $+3
$SG180028 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:788', 00H
	ORG $+3
$SG180100 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:874', 00H
	ORG $+3
$SG180106 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:910', 00H
	ORG $+3
$SG180108 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:915', 00H
	ORG $+3
$SG180109 DB	'scedio_thread', 00H
	ORG $+2
$SG180112 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG180113 DB	's390_scedio_request', 00H
	ORG $+4
$SG180114 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193056 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG193057 DB	'z900_load_main', 00H
	ORG $+1
$SG193058 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193064 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG193065 DB	'z900_load_main', 00H
	ORG $+1
$SG193066 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193073 DB	'HHC00603%s SCE file %s: load main terminated at end of m'
	DB	'ainstor', 0aH, 00H
	ORG $+7
$SG193074 DB	'z900_load_main', 00H
	ORG $+1
$SG193075 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193080 DB	'HHC02317%s %s bytes %s so far...', 0aH, 00H
	ORG $+6
$SG193081 DB	'z900_load_main', 00H
	ORG $+1
$SG193082 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193108 DB	'HERCULES.ins', 00H
	ORG $+3
$SG193112 DB	'HHC00601%s SCE file %s: load from file failed: %s', 0aH, 00H
	ORG $+5
$SG193113 DB	'z900_load_hmc', 00H
	ORG $+2
$SG193114 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193117 DB	'fopen()', 00H
$SG193119 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG193120 DB	'z900_load_hmc', 00H
	ORG $+2
$SG193121 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193123 DB	'%260s %i', 00H
	ORG $+7
$SG193128 DB	'HHC00602%s SCE file %s: load from path failed: %s', 0aH, 00H
	ORG $+5
$SG193129 DB	'z900_load_hmc', 00H
	ORG $+2
$SG193130 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193163 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG193164 DB	'z900_write_file', 00H
$SG193165 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193206 DB	'HHC00600%s SCE file %s: error in function %s: %s', 0aH, 00H
	ORG $+6
$SG193207 DB	'z900_read_file', 00H
	ORG $+1
$SG193208 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193235 DB	'HHC00604%s SCE file %s: access error on image %s: %s', 0aH
	DB	00H
	ORG $+2
$SG193236 DB	'z900_scedio_ior', 00H
$SG193237 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193268 DB	'HHC00605%s SCE file %s: access error: %s', 0aH, 00H
	ORG $+6
$SG193269 DB	'z900_scedio_iov', 00H
$SG193270 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193280 DB	'HHC00605%s SCE file %s: access error: %s', 0aH, 00H
	ORG $+6
$SG193281 DB	'z900_scedio_iov', 00H
$SG193282 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
	ORG $+7
$SG193289 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:730', 00H
	ORG $+3
$SG193330 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:771', 00H
	ORG $+3
$SG193332 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:774', 00H
	ORG $+3
$SG193333 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:778', 00H
	ORG $+3
$SG193334 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:782', 00H
	ORG $+3
$SG193335 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:788', 00H
	ORG $+3
$SG193407 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:874', 00H
	ORG $+3
$SG193413 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:910', 00H
	ORG $+3
$SG193415 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c:915', 00H
	ORG $+3
$SG193416 DB	'scedio_thread', 00H
	ORG $+2
$SG193419 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG193420 DB	'z900_scedio_request', 00H
	ORG $+4
$SG193421 DB	'C:\papa\MyGit\hyperion-zvector\scedasd.c', 00H
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$z900__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390_or_4K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s390__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370_or_2K_storage_key DD 010d01H
	DD	0420dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$s370__or_storage_key DD 011201H
	DD	08212H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_get_storekey_ptr DD 010d01H
	DD	0220dH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_dw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_fw_noswap DD 010901H
	DD	02209H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fetch_hw_noswap DD 010901H
	DD	02209H
xdata	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_scedio_iov
	DD	016H
	DD	0407H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_scedio_ior
	DD	016H
	DD	01b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_hmc
	DD	01fH
	DD	0433H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:z900_load_main
	DD	020H
	DD	049eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_scedio_iov
	DD	016H
	DD	0406H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_scedio_ior
	DD	016H
	DD	01b3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_hmc
	DD	01fH
	DD	0433H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s390_load_main
	DD	020H
	DD	049eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:check_sce_filepath
	DD	01bH
	DD	0155H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:set_sce_basedir
	DD	016H
	DD	01abH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_hmc
	DD	01fH
	DD	0433H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:s370_load_main
	DD	020H
	DD	049eH
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:set_sce_dir
	DD	016H
	DD	0147H
voltbl	ENDS
xdata	SEGMENT
$unwind$difftime DD 010e01H
	DD	0420eH
$unwind$time DD	010901H
	DD	04209H
$unwind$set_sce_dir DD 021e19H
	DD	053010cH
	DD	imagerel __GSHandlerCheck
	DD	0280H
$unwind$load_main DD 011301H
	DD	06213H
$unwind$s370_load_main DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$load_hmc DD 011201H
	DD	06212H
$unwind$s370_load_hmc DD 022719H
	DD	07b0115H
	DD	imagerel __GSHandlerCheck
	DD	03c0H
$unwind$Interrupt_Lock_Obtained DD 010e01H
	DD	0420eH
$unwind$Obtain_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$Release_Interrupt_Lock DD 010e01H
	DD	0420eH
$unwind$set_sce_basedir DD 021e19H
	DD	055010cH
	DD	imagerel __GSHandlerCheck
	DD	0290H
$unwind$check_sce_filepath DD 022319H
	DD	04b0111H
	DD	imagerel __GSHandlerCheck
	DD	0240H
$unwind$s390_load_main DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$s390_load_hmc DD 022719H
	DD	07b0115H
	DD	imagerel __GSHandlerCheck
	DD	03c0H
$unwind$s390_sclp_scedio_request DD 010901H
	DD	06209H
$unwind$s390_sclp_scedio_event DD 010901H
	DD	06209H
$unwind$s390_write_file DD 021a01H
	DD	013011aH
$unwind$s390_read_file DD 021a01H
	DD	013011aH
$unwind$s390_scedio_ior DD 021e19H
	DD	037010cH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$s390_scedio_iov DD 021e19H
	DD	037010cH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$s390_scedio_thread DD 010901H
	DD	0c209H
$unwind$s390_scedio_request DD 041201H
	DD	0110112H
	DD	0600a700bH
$unwind$z900_load_main DD 022819H
	DD	0190116H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$z900_load_hmc DD 022719H
	DD	07b0115H
	DD	imagerel __GSHandlerCheck
	DD	03c0H
$unwind$z900_sclp_scedio_request DD 010901H
	DD	06209H
$unwind$z900_sclp_scedio_event DD 010901H
	DD	06209H
$unwind$z900_write_file DD 021a01H
	DD	015011aH
$unwind$z900_read_file DD 021b01H
	DD	015011bH
$unwind$z900_scedio_ior DD 021e19H
	DD	037010cH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$z900_scedio_iov DD 021e19H
	DD	037010cH
	DD	imagerel __GSHandlerCheck
	DD	01a0H
$unwind$z900_scedio_thread DD 010901H
	DD	0c209H
$unwind$z900_scedio_request DD 041201H
	DD	0110112H
	DD	0600a700bH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$sscanf DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsscanf_l DD 011801H
	DD	06218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
evd_len$1 = 64
pending_req$2 = 68
scedio_bk$ = 72
tv83 = 80
tv173 = 84
rc$ = 88
scedio_r_bk$ = 96
scedio_v_bk$ = 104
tv219 = 112
sclp_command$ = 160
evd_hdr$ = 168
z900_scedio_request PROC

; 809  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 810  : int rc;
; 811  : SCCB_SCEDIO_V_BK* scedio_v_bk;
; 812  : SCCB_SCEDIO_R_BK* scedio_r_bk;
; 813  : SCCB_SCEDIO_BK*   scedio_bk  = (SCCB_SCEDIO_BK*)(evd_hdr + 1);

  00012	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0001a	48 83 c0 06	 add	 rax, 6
  0001e	48 89 44 24 48	 mov	 QWORD PTR scedio_bk$[rsp], rax

; 814  : 
; 815  : static struct
; 816  : {
; 817  :     SCCB_SCEDIO_BK  scedio_bk;
; 818  :     union
; 819  :     {
; 820  :         SCCB_SCEDIO_V_BK  v;
; 821  :         SCCB_SCEDIO_R_BK  r;
; 822  :     }
; 823  :     io;
; 824  : }
; 825  : static_scedio_bk;
; 826  : 
; 827  : static bool scedio_pending;
; 828  : 
; 829  :     if (sclp_command == SCLP_READ_EVENT_DATA)

  00023	81 bc 24 a0 00
	00 00 05 00 77
	00		 cmp	 DWORD PTR sclp_command$[rsp], 7798789 ; 00770005H
  0002e	0f 85 7c 01 00
	00		 jne	 $LN12@z900_scedi

; 830  :     {
; 831  :         bool pending_req = scedio_pending;

  00034	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?scedio_pending@?1??z900_scedio_request@@9@9
  0003b	88 44 24 44	 mov	 BYTE PTR pending_req$2[rsp], al

; 832  :         U16 evd_len;
; 833  : 
; 834  :         /* Return not-completed if the scedio thread is still active */
; 835  :         if (scedio_tid)

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR scedio_tid, 0
  00046	74 07		 je	 SHORT $LN13@z900_scedi

; 836  :         {
; 837  :             return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 01 03 00 00	 jmp	 $LN1@z900_scedi
$LN13@z900_scedi:

; 838  :         }
; 839  : 
; 840  :         /* Was there a preceding I/O request to respond to? */
; 841  :         if (scedio_pending)

  0004f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?scedio_pending@?1??z900_scedio_request@@9@9
  00056	85 c0		 test	 eax, eax
  00058	0f 84 48 01 00
	00		 je	 $LN14@z900_scedi

; 842  :         {
; 843  :             /* Update the scedio_bk copy in the SCCB... */
; 844  : 
; 845  :             /* Zero all event fields */
; 846  :             memset( evd_hdr, 0, sizeof( SCCB_EVD_HDR ));

  0005e	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR evd_hdr$[rsp]
  00066	33 c0		 xor	 eax, eax
  00068	b9 06 00 00 00	 mov	 ecx, 6
  0006d	f3 aa		 rep stosb

; 847  : 
; 848  :             /* Set type in event header */
; 849  :             evd_hdr->type = SCCB_EVD_TYPE_SCEDIO;

  0006f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00077	c6 40 02 07	 mov	 BYTE PTR [rax+2], 7

; 850  : 
; 851  :             /* Store copy of original saved SCEDIO header */
; 852  :             memcpy( scedio_bk, &static_scedio_bk.scedio_bk, sizeof( SCCB_SCEDIO_BK ));

  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?static_scedio_bk@?1??z900_scedio_request@@9@9
  00086	89 08		 mov	 DWORD PTR [rax], ecx

; 853  : 
; 854  :             /* Calculate event response length */
; 855  :             evd_len = sizeof( SCCB_EVD_HDR ) + sizeof( SCCB_SCEDIO_BK );

  00088	b8 0a 00 00 00	 mov	 eax, 10
  0008d	66 89 44 24 40	 mov	 WORD PTR evd_len$1[rsp], ax

; 856  : 
; 857  :             switch (scedio_bk->flag1)

  00092	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00097	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009b	88 44 24 50	 mov	 BYTE PTR tv83[rsp], al
  0009f	80 7c 24 50 03	 cmp	 BYTE PTR tv83[rsp], 3
  000a4	74 09		 je	 SHORT $LN15@z900_scedi
  000a6	80 7c 24 50 04	 cmp	 BYTE PTR tv83[rsp], 4
  000ab	74 39		 je	 SHORT $LN16@z900_scedi
  000ad	eb 6d		 jmp	 SHORT $LN17@z900_scedi
$LN15@z900_scedi:

; 858  :             {
; 859  :             case SCCB_SCEDIO_FLG1_IOR:
; 860  : 
; 861  :                 scedio_r_bk = (SCCB_SCEDIO_R_BK*)(scedio_bk + 1);

  000af	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000b4	48 83 c0 04	 add	 rax, 4
  000b8	48 89 44 24 60	 mov	 QWORD PTR scedio_r_bk$[rsp], rax

; 862  :                 memcpy( scedio_r_bk, &static_scedio_bk.io.r, sizeof( SCCB_SCEDIO_R_BK ));

  000bd	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??z900_scedio_request@@9@9+4
  000c4	48 8b 7c 24 60	 mov	 rdi, QWORD PTR scedio_r_bk$[rsp]
  000c9	48 8b f0	 mov	 rsi, rax
  000cc	b9 18 00 00 00	 mov	 ecx, 24
  000d1	f3 a4		 rep movsb

; 863  :                 evd_len += sizeof( SCCB_SCEDIO_R_BK );

  000d3	0f b7 44 24 40	 movzx	 eax, WORD PTR evd_len$1[rsp]
  000d8	48 83 c0 18	 add	 rax, 24
  000dc	66 89 44 24 40	 mov	 WORD PTR evd_len$1[rsp], ax

; 864  :                 break;

  000e1	e9 9f 00 00 00	 jmp	 $LN2@z900_scedi
$LN16@z900_scedi:

; 865  : 
; 866  :             case SCCB_SCEDIO_FLG1_IOV:
; 867  : 
; 868  :                 scedio_v_bk = (SCCB_SCEDIO_V_BK*)(scedio_bk + 1);

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000eb	48 83 c0 04	 add	 rax, 4
  000ef	48 89 44 24 68	 mov	 QWORD PTR scedio_v_bk$[rsp], rax

; 869  :                 memcpy( scedio_v_bk, &static_scedio_bk.io.v, sizeof( SCCB_SCEDIO_V_BK ));

  000f4	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??z900_scedio_request@@9@9+4
  000fb	48 8b 7c 24 68	 mov	 rdi, QWORD PTR scedio_v_bk$[rsp]
  00100	48 8b f0	 mov	 rsi, rax
  00103	b9 34 01 00 00	 mov	 ecx, 308		; 00000134H
  00108	f3 a4		 rep movsb

; 870  :                 evd_len += sizeof( SCCB_SCEDIO_V_BK );

  0010a	0f b7 44 24 40	 movzx	 eax, WORD PTR evd_len$1[rsp]
  0010f	48 05 34 01 00
	00		 add	 rax, 308		; 00000134H
  00115	66 89 44 24 40	 mov	 WORD PTR evd_len$1[rsp], ax

; 871  :                 break;

  0011a	eb 69		 jmp	 SHORT $LN2@z900_scedi
$LN17@z900_scedi:
$LN6@z900_scedi:

; 872  : 
; 873  :             default:
; 874  :                 PTT_ERR("*SERVC",(U32)evd_hdr->type,(U32)scedio_bk->flag1,scedio_bk->flag3);

  0011c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00123	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00126	48 83 e0 10	 and	 rax, 16
  0012a	48 85 c0	 test	 rax, rax
  0012d	74 50		 je	 SHORT $LN18@z900_scedi
  0012f	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00134	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00138	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  0013d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00141	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  00149	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  0014d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00156	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0015b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193407
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	44 8b c9	 mov	 r9d, ecx
  0016a	44 8b c2	 mov	 r8d, edx
  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193408
  00174	b9 10 00 00 00	 mov	 ecx, 16
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@z900_scedi:
  0017f	33 c0		 xor	 eax, eax
  00181	85 c0		 test	 eax, eax
  00183	75 97		 jne	 SHORT $LN6@z900_scedi
$LN2@z900_scedi:

; 875  :             }
; 876  : 
; 877  :             /* Set length in event header */
; 878  :             STORE_HW( evd_hdr->totlen, evd_len );

  00185	0f b7 4c 24 40	 movzx	 ecx, WORD PTR evd_len$1[rsp]
  0018a	e8 00 00 00 00	 call	 _byteswap_ushort
  0018f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00197	0f b7 d0	 movzx	 edx, ax
  0019a	e8 00 00 00 00	 call	 store_hw_noswap

; 879  : 
; 880  :             /* Indicate I/O request no longer active */
; 881  :             scedio_pending = false;

  0019f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?scedio_pending@?1??z900_scedio_request@@9@9, 0
$LN14@z900_scedi:

; 882  :         }
; 883  : 
; 884  :         /* Return true if a request was pending */
; 885  :         return pending_req;

  001a6	0f b6 44 24 44	 movzx	 eax, BYTE PTR pending_req$2[rsp]
  001ab	e9 a0 01 00 00	 jmp	 $LN1@z900_scedi
$LN12@z900_scedi:

; 886  :     }
; 887  : 
; 888  :     // else... 'SCLP_WRITE_EVENT_DATA' or 'SCLP_WRITE_EVENT_MASK'
; 889  : 
; 890  :     /* Save copy of original dasd I/O header */
; 891  :     memcpy( &static_scedio_bk.scedio_bk, scedio_bk, sizeof( SCCB_SCEDIO_BK ));

  001b0	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  001b5	8b 00		 mov	 eax, DWORD PTR [rax]
  001b7	89 05 00 00 00
	00		 mov	 DWORD PTR ?static_scedio_bk@?1??z900_scedio_request@@9@9, eax

; 892  : 
; 893  :     switch (scedio_bk->flag1)

  001bd	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  001c2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001c6	88 44 24 54	 mov	 BYTE PTR tv173[rsp], al
  001ca	80 7c 24 54 03	 cmp	 BYTE PTR tv173[rsp], 3
  001cf	74 09		 je	 SHORT $LN19@z900_scedi
  001d1	80 7c 24 54 04	 cmp	 BYTE PTR tv173[rsp], 4
  001d6	74 2b		 je	 SHORT $LN20@z900_scedi
  001d8	eb 4f		 jmp	 SHORT $LN21@z900_scedi
$LN19@z900_scedi:

; 894  :     {
; 895  :     case SCCB_SCEDIO_FLG1_IOR:
; 896  : 
; 897  :         /* Save copy of original dasd I/O block */
; 898  :         scedio_r_bk = (SCCB_SCEDIO_R_BK*)(scedio_bk + 1);

  001da	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  001df	48 83 c0 04	 add	 rax, 4
  001e3	48 89 44 24 60	 mov	 QWORD PTR scedio_r_bk$[rsp], rax

; 899  :         memcpy( &static_scedio_bk.io.r, scedio_r_bk, sizeof( SCCB_SCEDIO_R_BK ));

  001e8	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??z900_scedio_request@@9@9+4
  001ef	48 8b f8	 mov	 rdi, rax
  001f2	48 8b 74 24 60	 mov	 rsi, QWORD PTR scedio_r_bk$[rsp]
  001f7	b9 18 00 00 00	 mov	 ecx, 24
  001fc	f3 a4		 rep movsb

; 900  :         break;

  001fe	e9 8f 00 00 00	 jmp	 $LN7@z900_scedi
$LN20@z900_scedi:

; 901  : 
; 902  :     case SCCB_SCEDIO_FLG1_IOV:
; 903  : 
; 904  :         /* Save copy of original dasd I/O block */
; 905  :         scedio_v_bk = (SCCB_SCEDIO_V_BK*)(scedio_bk + 1);

  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00208	48 83 c0 04	 add	 rax, 4
  0020c	48 89 44 24 68	 mov	 QWORD PTR scedio_v_bk$[rsp], rax

; 906  :         memcpy( &static_scedio_bk.io.v, scedio_v_bk, sizeof( SCCB_SCEDIO_V_BK ));

  00211	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??z900_scedio_request@@9@9+4
  00218	48 8b f8	 mov	 rdi, rax
  0021b	48 8b 74 24 68	 mov	 rsi, QWORD PTR scedio_v_bk$[rsp]
  00220	b9 34 01 00 00	 mov	 ecx, 308		; 00000134H
  00225	f3 a4		 rep movsb

; 907  :         break;

  00227	eb 69		 jmp	 SHORT $LN7@z900_scedi
$LN21@z900_scedi:
$LN11@z900_scedi:

; 908  : 
; 909  :     default:
; 910  :         PTT_ERR("*SERVC",(U32)evd_hdr->type,(U32)scedio_bk->flag1,scedio_bk->flag3);

  00229	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00230	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00233	48 83 e0 10	 and	 rax, 16
  00237	48 85 c0	 test	 rax, rax
  0023a	74 50		 je	 SHORT $LN22@z900_scedi
  0023c	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00241	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00245	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  0024a	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0024e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  00256	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  0025a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00263	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00268	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193413
  0026f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00274	44 8b c9	 mov	 r9d, ecx
  00277	44 8b c2	 mov	 r8d, edx
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193414
  00281	b9 10 00 00 00	 mov	 ecx, 16
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@z900_scedi:
  0028c	33 c0		 xor	 eax, eax
  0028e	85 c0		 test	 eax, eax
  00290	75 97		 jne	 SHORT $LN11@z900_scedi
$LN7@z900_scedi:

; 911  :     }
; 912  : 
; 913  :     /* Create the scedio thread */
; 914  :     rc = create_thread( &scedio_tid, &sysblk.detattr,

  00292	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00299	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193415
  002a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193416
  002b2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002b7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?static_scedio_bk@?1??z900_scedio_request@@9@9
  002be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:z900_scedio_thread
  002c5	48 8b d0	 mov	 rdx, rax
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scedio_tid
  002cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  002d5	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax

; 915  :         ARCH_DEP( scedio_thread ), &static_scedio_bk, "scedio_thread" );
; 916  : 
; 917  :     if (rc)

  002d9	83 7c 24 58 00	 cmp	 DWORD PTR rc$[rsp], 0
  002de	74 67		 je	 SHORT $LN23@z900_scedi

; 918  :     {
; 919  :         // "Error in function create_thread(): %s"
; 920  :         WRMSG( HHC00102, "E", strerror( rc ));

  002e0	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$[rsp]
  002e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ea	48 89 44 24 70	 mov	 QWORD PTR tv219[rsp], rax
  002ef	b9 01 00 00 00	 mov	 ecx, 1
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv219[rsp]
  002ff	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193418
  0030b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00310	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193419
  00317	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0031c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00321	41 b9 03 00 00
	00		 mov	 r9d, 3
  00327	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193420
  0032e	ba 98 03 00 00	 mov	 edx, 920		; 00000398H
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193421
  0033a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 921  :         return -1;

  00340	b8 ff ff ff ff	 mov	 eax, -1
  00345	eb 09		 jmp	 SHORT $LN1@z900_scedi
$LN23@z900_scedi:

; 922  :     }
; 923  : 
; 924  :     /* Remember an I/O request was started and is now running */
; 925  :     scedio_pending = true;

  00347	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?scedio_pending@?1??z900_scedio_request@@9@9, 1

; 926  : 
; 927  :     return 0;

  0034e	33 c0		 xor	 eax, eax
$LN1@z900_scedi:

; 928  : }

  00350	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00357	5f		 pop	 rdi
  00358	5e		 pop	 rsi
  00359	c3		 ret	 0
z900_scedio_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
tv66 = 64
scedio_bk$ = 72
scedio_r_bk$ = 80
scedio_v_bk$ = 88
arg$ = 112
z900_scedio_thread PROC

; 739  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 740  : SCCB_SCEDIO_V_BK* scedio_v_bk;
; 741  : SCCB_SCEDIO_R_BK* scedio_r_bk;
; 742  : SCCB_SCEDIO_BK*   scedio_bk  = (SCCB_SCEDIO_BK*) arg;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR arg$[rsp]
  0000e	48 89 44 24 48	 mov	 QWORD PTR scedio_bk$[rsp], rax

; 743  : 
; 744  :     switch (scedio_bk->flag1)

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	88 44 24 40	 mov	 BYTE PTR tv66[rsp], al
  00020	80 7c 24 40 03	 cmp	 BYTE PTR tv66[rsp], 3
  00025	74 5c		 je	 SHORT $LN12@z900_scedi
  00027	80 7c 24 40 04	 cmp	 BYTE PTR tv66[rsp], 4
  0002c	74 05		 je	 SHORT $LN9@z900_scedi
  0002e	e9 af 00 00 00	 jmp	 $LN15@z900_scedi
$LN9@z900_scedi:

; 745  :     {
; 746  :     case SCCB_SCEDIO_FLG1_IOV:
; 747  : 
; 748  :         scedio_v_bk = (SCCB_SCEDIO_V_BK*)(scedio_bk + 1);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00038	48 83 c0 04	 add	 rax, 4
  0003c	48 89 44 24 58	 mov	 QWORD PTR scedio_v_bk$[rsp], rax

; 749  : 
; 750  :         if (ARCH_DEP( scedio_iov )( scedio_v_bk ))

  00041	48 8b 4c 24 58	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  00046	e8 00 00 00 00	 call	 z900_scedio_iov
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	74 17		 je	 SHORT $LN10@z900_scedi

; 751  :             scedio_bk->flag3 |= SCCB_SCEDIO_FLG3_COMPLETE;

  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00057	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0005b	0f ba e8 07	 bts	 eax, 7
  0005f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  00064	88 41 03	 mov	 BYTE PTR [rcx+3], al
  00067	eb 15		 jmp	 SHORT $LN11@z900_scedi
$LN10@z900_scedi:

; 752  :         else
; 753  :             scedio_bk->flag3 &= ~SCCB_SCEDIO_FLG3_COMPLETE;

  00069	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  0006e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00072	0f ba f0 07	 btr	 eax, 7
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  0007b	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN11@z900_scedi:

; 754  :         break;

  0007e	e9 c4 00 00 00	 jmp	 $LN2@z900_scedi
$LN12@z900_scedi:

; 755  : 
; 756  :     case SCCB_SCEDIO_FLG1_IOR:
; 757  : 
; 758  :         scedio_r_bk = (SCCB_SCEDIO_R_BK*)(scedio_bk + 1);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00088	48 83 c0 04	 add	 rax, 4
  0008c	48 89 44 24 50	 mov	 QWORD PTR scedio_r_bk$[rsp], rax

; 759  : 
; 760  :         if (ARCH_DEP( scedio_ior )( scedio_r_bk ))

  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  00096	e8 00 00 00 00	 call	 z900_scedio_ior
  0009b	0f b6 c0	 movzx	 eax, al
  0009e	85 c0		 test	 eax, eax
  000a0	74 29		 je	 SHORT $LN13@z900_scedi

; 761  :         {
; 762  :             /* Indicate what SCE dasd file we finished reading? */
; 763  :             memcpy( scedio_r_bk->imageout, scedio_r_bk->imagein, SCCB_SCEDIO_R_IMAGE_LEN );

  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR scedio_r_bk$[rsp]
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  000ac	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 764  :             scedio_bk->flag3 |= SCCB_SCEDIO_FLG3_COMPLETE;

  000b4	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000b9	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000bd	0f ba e8 07	 bts	 eax, 7
  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  000c6	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 765  :         }

  000c9	eb 15		 jmp	 SHORT $LN14@z900_scedi
$LN13@z900_scedi:

; 766  :         else
; 767  :             scedio_bk->flag3 &= ~SCCB_SCEDIO_FLG3_COMPLETE;

  000cb	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000d0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000d4	0f ba f0 07	 btr	 eax, 7
  000d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  000dd	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN14@z900_scedi:

; 768  :         break;

  000e0	eb 65		 jmp	 SHORT $LN2@z900_scedi
$LN15@z900_scedi:
$LN6@z900_scedi:

; 769  : 
; 770  :     default:
; 771  :         PTT_ERR("*SERVC", (U32)scedio_bk->flag0, (U32)scedio_bk->flag1, scedio_bk->flag3 );

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ec	48 83 e0 10	 and	 rax, 16
  000f0	48 85 c0	 test	 rax, rax
  000f3	74 4c		 je	 SHORT $LN16@z900_scedi
  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000fa	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000fe	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  00103	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00107	48 8b 54 24 48	 mov	 rdx, QWORD PTR scedio_bk$[rsp]
  0010c	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0010f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00118	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193330
  00124	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00129	44 8b c9	 mov	 r9d, ecx
  0012c	44 8b c2	 mov	 r8d, edx
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193331
  00136	b9 10 00 00 00	 mov	 ecx, 16
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@z900_scedi:
  00141	33 c0		 xor	 eax, eax
  00143	85 c0		 test	 eax, eax
  00145	75 9b		 jne	 SHORT $LN6@z900_scedi
$LN2@z900_scedi:

; 772  :     }
; 773  : 
; 774  :     OBTAIN_INTLOCK( NULL );

  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193332
  0014e	33 c9		 xor	 ecx, ecx
  00150	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN7@z900_scedi:

; 775  :     {
; 776  :         while (IS_IC_SERVSIG)

  00155	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015c	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00162	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00167	85 c0		 test	 eax, eax
  00169	74 24		 je	 SHORT $LN8@z900_scedi

; 777  :         {
; 778  :             RELEASE_INTLOCK( NULL );

  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193333
  00172	33 c9		 xor	 ecx, ecx
  00174	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 779  :             {
; 780  :                 sched_yield();

  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 781  :             }
; 782  :             OBTAIN_INTLOCK( NULL );

  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193334
  00186	33 c9		 xor	 ecx, ecx
  00188	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 783  :         }

  0018d	eb c6		 jmp	 SHORT $LN7@z900_scedi
$LN8@z900_scedi:

; 784  : 
; 785  :         sclp_attention( SCCB_EVD_TYPE_SCEDIO );

  0018f	66 b9 07 00	 mov	 cx, 7
  00193	e8 00 00 00 00	 call	 sclp_attention

; 786  :         scedio_tid = 0;

  00198	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR scedio_tid, 0

; 787  :     }
; 788  :     RELEASE_INTLOCK( NULL );

  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193335
  001a9	33 c9		 xor	 ecx, ecx
  001ab	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 789  :     return NULL;

  001b0	33 c0		 xor	 eax, eax

; 790  : }

  001b2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001b6	c3		 ret	 0
z900_scedio_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
tv66 = 80
tv200 = 84
totread$ = 88
length$ = 96
sto$ = 104
seek$ = 112
totwrite$ = 120
tv74 = 128
tv165 = 136
fname$ = 144
__$ArrayPad$ = 416
scedio_v_bk$ = 448
z900_scedio_iov PROC

; 656  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : S64     seek;
; 658  : S64     length;
; 659  : S64     totread, totwrite;
; 660  : U64     sto;
; 661  : char    fname[MAX_PATH];
; 662  : 
; 663  :     switch (scedio_v_bk->type)

  0001e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00029	88 44 24 50	 mov	 BYTE PTR tv66[rsp], al
  0002d	80 7c 24 50 00	 cmp	 BYTE PTR tv66[rsp], 0
  00032	74 22		 je	 SHORT $LN7@z900_scedi
  00034	80 7c 24 50 01	 cmp	 BYTE PTR tv66[rsp], 1
  00039	74 22		 je	 SHORT $LN8@z900_scedi
  0003b	80 7c 24 50 02	 cmp	 BYTE PTR tv66[rsp], 2
  00040	0f 84 d4 01 00
	00		 je	 $LN15@z900_scedi
  00046	80 7c 24 50 03	 cmp	 BYTE PTR tv66[rsp], 3
  0004b	0f 84 c9 01 00
	00		 je	 $LN16@z900_scedi
  00051	e9 41 03 00 00	 jmp	 $LN23@z900_scedi
$LN7@z900_scedi:

; 664  :     {
; 665  :     case SCCB_SCEDIOV_TYPE_INIT:
; 666  : 
; 667  :         return true;

  00056	b0 01		 mov	 al, 1
  00058	e9 aa 03 00 00	 jmp	 $LN1@z900_scedi
$LN8@z900_scedi:

; 668  : 
; 669  :     case SCCB_SCEDIOV_TYPE_READ:
; 670  : 
; 671  :         /* Ensure file access is allowed and within specified directory */
; 672  :         if (!check_sce_filepath( (char*)scedio_v_bk->filename, fname ))

  0005d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00065	48 83 c0 34	 add	 rax, 52			; 00000034H
  00069	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR fname$[rsp]
  00071	48 8b c8	 mov	 rcx, rax
  00074	e8 00 00 00 00	 call	 check_sce_filepath
  00079	48 85 c0	 test	 rax, rax
  0007c	0f 85 89 00 00
	00		 jne	 $LN9@z900_scedi

; 673  :         {
; 674  :             if (errno != ENOENT)

  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00088	83 38 02	 cmp	 DWORD PTR [rax], 2
  0008b	74 77		 je	 SHORT $LN10@z900_scedi

; 675  :                 // "SCE file %s: access error: %s"
; 676  :                 WRMSG( HHC00605, "E", fname, strerror( errno ));

  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00093	8b 08		 mov	 ecx, DWORD PTR [rax]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0009b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv74[rsp]
  000b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000bb	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  000c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193267
  000cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193268
  000db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  000eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193269
  000f2	ba a4 02 00 00	 mov	 edx, 676		; 000002a4H
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193270
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@z900_scedi:

; 677  :             return false;

  00104	32 c0		 xor	 al, al
  00106	e9 fc 02 00 00	 jmp	 $LN1@z900_scedi
$LN9@z900_scedi:

; 678  :         }
; 679  : 
; 680  :         FETCH_DW( sto,    scedio_v_bk->sto );

  0010b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00113	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 fetch_dw_noswap
  0011f	48 8b c8	 mov	 rcx, rax
  00122	e8 00 00 00 00	 call	 _byteswap_uint64
  00127	48 89 44 24 68	 mov	 QWORD PTR sto$[rsp], rax

; 681  :         FETCH_DW( seek,   scedio_v_bk->seek );

  0012c	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00134	48 83 c0 04	 add	 rax, 4
  00138	48 8b c8	 mov	 rcx, rax
  0013b	e8 00 00 00 00	 call	 fetch_dw_noswap
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 _byteswap_uint64
  00148	48 89 44 24 70	 mov	 QWORD PTR seek$[rsp], rax

; 682  :         FETCH_DW( length, scedio_v_bk->length );

  0014d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00155	48 83 c0 14	 add	 rax, 20
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 fetch_dw_noswap
  00161	48 8b c8	 mov	 rcx, rax
  00164	e8 00 00 00 00	 call	 _byteswap_uint64
  00169	48 89 44 24 60	 mov	 QWORD PTR length$[rsp], rax

; 683  : 
; 684  :         totread = ARCH_DEP( read_file )( fname, sto, seek, length );

  0016e	4c 8b 4c 24 60	 mov	 r9, QWORD PTR length$[rsp]
  00173	4c 8b 44 24 70	 mov	 r8, QWORD PTR seek$[rsp]
  00178	48 8b 54 24 68	 mov	 rdx, QWORD PTR sto$[rsp]
  0017d	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00185	e8 00 00 00 00	 call	 z900_read_file
  0018a	48 89 44 24 58	 mov	 QWORD PTR totread$[rsp], rax

; 685  : 
; 686  :         if (totread > 0)

  0018f	48 83 7c 24 58
	00		 cmp	 QWORD PTR totread$[rsp], 0
  00195	7e 7c		 jle	 SHORT $LN11@z900_scedi

; 687  :         {
; 688  :             STORE_DW( scedio_v_bk->length, totread );

  00197	48 8b 4c 24 58	 mov	 rcx, QWORD PTR totread$[rsp]
  0019c	e8 00 00 00 00	 call	 _byteswap_uint64
  001a1	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  001a9	48 83 c1 14	 add	 rcx, 20
  001ad	48 8b d0	 mov	 rdx, rax
  001b0	e8 00 00 00 00	 call	 store_dw_noswap

; 689  : 
; 690  :             if (totread == length)

  001b5	48 8b 44 24 60	 mov	 rax, QWORD PTR length$[rsp]
  001ba	48 39 44 24 58	 cmp	 QWORD PTR totread$[rsp], rax
  001bf	75 1d		 jne	 SHORT $LN13@z900_scedi

; 691  :                 STORE_DW( scedio_v_bk->ncomp, 0 );

  001c1	33 c9		 xor	 ecx, ecx
  001c3	e8 00 00 00 00	 call	 _byteswap_uint64
  001c8	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  001d0	48 83 c1 0c	 add	 rcx, 12
  001d4	48 8b d0	 mov	 rdx, rax
  001d7	e8 00 00 00 00	 call	 store_dw_noswap
  001dc	eb 2c		 jmp	 SHORT $LN14@z900_scedi
$LN13@z900_scedi:

; 692  :             else
; 693  :                 STORE_DW( scedio_v_bk->ncomp, seek + totread );

  001de	48 8b 44 24 58	 mov	 rax, QWORD PTR totread$[rsp]
  001e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR seek$[rsp]
  001e8	48 03 c8	 add	 rcx, rax
  001eb	48 8b c1	 mov	 rax, rcx
  001ee	48 8b c8	 mov	 rcx, rax
  001f1	e8 00 00 00 00	 call	 _byteswap_uint64
  001f6	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  001fe	48 83 c1 0c	 add	 rcx, 12
  00202	48 8b d0	 mov	 rdx, rax
  00205	e8 00 00 00 00	 call	 store_dw_noswap
$LN14@z900_scedi:

; 694  : 
; 695  :             return true;

  0020a	b0 01		 mov	 al, 1
  0020c	e9 f6 01 00 00	 jmp	 $LN1@z900_scedi

; 696  :         }

  00211	eb 07		 jmp	 SHORT $LN12@z900_scedi
$LN11@z900_scedi:

; 697  :         else
; 698  :             return false;

  00213	32 c0		 xor	 al, al
  00215	e9 ed 01 00 00	 jmp	 $LN1@z900_scedi
$LN12@z900_scedi:
$LN15@z900_scedi:
$LN16@z900_scedi:

; 699  : 
; 700  :     case SCCB_SCEDIOV_TYPE_CREATE:
; 701  :     case SCCB_SCEDIOV_TYPE_APPEND:
; 702  : 
; 703  :         /* Ensure file access is allowed and within specified directory */
; 704  :         if (!check_sce_filepath( (char*)scedio_v_bk->filename, fname ))

  0021a	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00222	48 83 c0 34	 add	 rax, 52			; 00000034H
  00226	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR fname$[rsp]
  0022e	48 8b c8	 mov	 rcx, rax
  00231	e8 00 00 00 00	 call	 check_sce_filepath
  00236	48 85 c0	 test	 rax, rax
  00239	0f 85 a4 00 00
	00		 jne	 $LN17@z900_scedi

; 705  :         {
; 706  :             if (errno != ENOENT)

  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00245	83 38 02	 cmp	 DWORD PTR [rax], 2
  00248	74 77		 je	 SHORT $LN18@z900_scedi

; 707  :                 // "SCE file %s: access error: %s"
; 708  :                 WRMSG( HHC00605, "E", fname, strerror( errno ));

  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00250	8b 08		 mov	 ecx, DWORD PTR [rax]
  00252	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00258	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
  00260	b9 01 00 00 00	 mov	 ecx, 1
  00265	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv165[rsp]
  00273	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00278	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00280	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00285	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193279
  0028c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00291	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193280
  00298	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193281
  002af	ba c4 02 00 00	 mov	 edx, 708		; 000002c4H
  002b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193282
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@z900_scedi:

; 709  : 
; 710  :             /* A file not found error may be expected for a create request */
; 711  :             if (!(errno == ENOENT && scedio_v_bk->type == SCCB_SCEDIOV_TYPE_CREATE))

  002c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002c7	83 38 02	 cmp	 DWORD PTR [rax], 2
  002ca	75 10		 jne	 SHORT $LN20@z900_scedi
  002cc	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  002d4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002d7	83 f8 02	 cmp	 eax, 2
  002da	74 07		 je	 SHORT $LN19@z900_scedi
$LN20@z900_scedi:

; 712  :                 return false;

  002dc	32 c0		 xor	 al, al
  002de	e9 24 01 00 00	 jmp	 $LN1@z900_scedi
$LN19@z900_scedi:
$LN17@z900_scedi:

; 713  :         }
; 714  : 
; 715  :         FETCH_DW( sto,    scedio_v_bk->sto );

  002e3	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  002eb	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  002ef	48 8b c8	 mov	 rcx, rax
  002f2	e8 00 00 00 00	 call	 fetch_dw_noswap
  002f7	48 8b c8	 mov	 rcx, rax
  002fa	e8 00 00 00 00	 call	 _byteswap_uint64
  002ff	48 89 44 24 68	 mov	 QWORD PTR sto$[rsp], rax

; 716  :         FETCH_DW( length, scedio_v_bk->length );

  00304	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  0030c	48 83 c0 14	 add	 rax, 20
  00310	48 8b c8	 mov	 rcx, rax
  00313	e8 00 00 00 00	 call	 fetch_dw_noswap
  00318	48 8b c8	 mov	 rcx, rax
  0031b	e8 00 00 00 00	 call	 _byteswap_uint64
  00320	48 89 44 24 60	 mov	 QWORD PTR length$[rsp], rax

; 717  : 
; 718  :         totwrite = ARCH_DEP( write_file ) (fname,

  00325	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  0032d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00330	83 f8 02	 cmp	 eax, 2
  00333	75 0a		 jne	 SHORT $LN26@z900_scedi
  00335	c7 44 24 54 00
	03 00 00	 mov	 DWORD PTR tv200[rsp], 768 ; 00000300H
  0033d	eb 08		 jmp	 SHORT $LN27@z900_scedi
$LN26@z900_scedi:
  0033f	c7 44 24 54 08
	00 00 00	 mov	 DWORD PTR tv200[rsp], 8
$LN27@z900_scedi:
  00347	4c 8b 4c 24 60	 mov	 r9, QWORD PTR length$[rsp]
  0034c	4c 8b 44 24 68	 mov	 r8, QWORD PTR sto$[rsp]
  00351	8b 54 24 54	 mov	 edx, DWORD PTR tv200[rsp]
  00355	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  0035d	e8 00 00 00 00	 call	 z900_write_file
  00362	48 89 44 24 78	 mov	 QWORD PTR totwrite$[rsp], rax

; 719  :             scedio_v_bk->type == SCCB_SCEDIOV_TYPE_CREATE ? (O_CREAT | O_TRUNC) : O_APPEND, sto, length );
; 720  : 
; 721  :         if(totwrite >= 0)

  00367	48 83 7c 24 78
	00		 cmp	 QWORD PTR totwrite$[rsp], 0
  0036d	7c 24		 jl	 SHORT $LN21@z900_scedi

; 722  :         {
; 723  :             STORE_DW( scedio_v_bk->ncomp, totwrite );

  0036f	48 8b 4c 24 78	 mov	 rcx, QWORD PTR totwrite$[rsp]
  00374	e8 00 00 00 00	 call	 _byteswap_uint64
  00379	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  00381	48 83 c1 0c	 add	 rcx, 12
  00385	48 8b d0	 mov	 rdx, rax
  00388	e8 00 00 00 00	 call	 store_dw_noswap

; 724  :             return true;

  0038d	b0 01		 mov	 al, 1
  0038f	eb 76		 jmp	 SHORT $LN1@z900_scedi

; 725  :         }

  00391	eb 04		 jmp	 SHORT $LN22@z900_scedi
$LN21@z900_scedi:

; 726  :         else
; 727  :             return false;

  00393	32 c0		 xor	 al, al
  00395	eb 70		 jmp	 SHORT $LN1@z900_scedi
$LN22@z900_scedi:
$LN23@z900_scedi:
$LN6@z900_scedi:

; 728  : 
; 729  :     default:
; 730  :         PTT_ERR("*SERVC", (U32)scedio_v_bk->type, (U32)scedio_v_bk->flag1, scedio_v_bk->flag2 );

  00397	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0039e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a1	48 83 e0 10	 and	 rax, 16
  003a5	48 85 c0	 test	 rax, rax
  003a8	74 55		 je	 SHORT $LN24@z900_scedi
  003aa	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  003b2	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003b6	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  003be	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  003c2	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR scedio_v_bk$[rsp]
  003ca	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  003cd	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003d6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003db	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193289
  003e2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e7	44 8b c9	 mov	 r9d, ecx
  003ea	44 8b c2	 mov	 r8d, edx
  003ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193290
  003f4	b9 10 00 00 00	 mov	 ecx, 16
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@z900_scedi:
  003ff	33 c0		 xor	 eax, eax
  00401	85 c0		 test	 eax, eax
  00403	75 92		 jne	 SHORT $LN6@z900_scedi

; 731  :         return false;

  00405	32 c0		 xor	 al, al
$LN1@z900_scedi:

; 732  :     }
; 733  : }

  00407	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0040f	48 33 cc	 xor	 rcx, rsp
  00412	e8 00 00 00 00	 call	 __security_check_cookie
  00417	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  0041e	c3		 ret	 0
z900_scedio_iov ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
success$ = 80
i$ = 84
tv150 = 88
tv152 = 92
origin$ = 96
$T1 = 104
tv128 = 112
image$ = 120
filename$ = 144
__$ArrayPad$ = 416
scedio_r_bk$ = 448
z900_scedio_ior PROC

; 618  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 619  : U32           origin;
; 620  : char          image[9];
; 621  : unsigned int  i;
; 622  : char          filename[MAX_PATH];
; 623  : bool          success;
; 624  : 
; 625  : static const bool noisy =
; 626  : #if defined(_DEBUG) || defined(DEBUG)
; 627  :     true;
; 628  : #else
; 629  :     false;
; 630  : #endif
; 631  : 
; 632  :     FETCH_FW( origin, scedio_r_bk->origin );

  0001e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_r_bk$[rsp]
  00026	48 83 c0 04	 add	 rax, 4
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 60	 mov	 DWORD PTR origin$[rsp], eax

; 633  : 
; 634  :     /* Convert image filename to null terminated ascii string */
; 635  :     for (i=0; i < sizeof( image ) - 1 && scedio_r_bk->imagein[i] != 0x40; i++)

  0003d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00045	eb 0a		 jmp	 SHORT $LN4@z900_scedi
$LN2@z900_scedi:
  00047	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN4@z900_scedi:
  00051	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00055	48 83 f8 08	 cmp	 rax, 8
  00059	73 37		 jae	 SHORT $LN3@z900_scedi
  0005b	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0005f	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  00067	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  0006c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0006f	74 21		 je	 SHORT $LN3@z900_scedi

; 636  :         image[i] = guest_to_host( (int)  scedio_r_bk->imagein[i]);

  00071	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00075	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  0007d	0f b6 4c 01 10	 movzx	 ecx, BYTE PTR [rcx+rax+16]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00088	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  0008c	88 44 0c 78	 mov	 BYTE PTR image$[rsp+rcx], al
  00090	eb b5		 jmp	 SHORT $LN2@z900_scedi
$LN3@z900_scedi:

; 637  :     image[i] = '\0';

  00092	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00096	48 89 44 24 68	 mov	 QWORD PTR $T1[rsp], rax
  0009b	48 83 7c 24 68
	09		 cmp	 QWORD PTR $T1[rsp], 9
  000a1	73 02		 jae	 SHORT $LN8@z900_scedi
  000a3	eb 05		 jmp	 SHORT $LN9@z900_scedi
$LN8@z900_scedi:
  000a5	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN9@z900_scedi:
  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR $T1[rsp]
  000af	c6 44 04 78 00	 mov	 BYTE PTR image$[rsp+rax], 0

; 638  : 
; 639  :     /* Ensure file access is allowed and within specified directory */
; 640  :     if (!check_sce_filepath( image, filename ))

  000b4	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  000bc	48 8d 4c 24 78	 lea	 rcx, QWORD PTR image$[rsp]
  000c1	e8 00 00 00 00	 call	 check_sce_filepath
  000c6	48 85 c0	 test	 rax, rax
  000c9	0f 85 8a 00 00
	00		 jne	 $LN5@z900_scedi

; 641  :     {
; 642  :         if (errno != ENOENT)

  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d5	83 38 02	 cmp	 DWORD PTR [rax], 2
  000d8	74 7b		 je	 SHORT $LN6@z900_scedi

; 643  :             // "SCE file %s: access error on image %s: %s"
; 644  :             WRMSG( HHC00604, "E", filename, image, strerror( errno ));

  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e0	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000e8	48 89 44 24 70	 mov	 QWORD PTR tv128[rsp], rax
  000ed	b9 01 00 00 00	 mov	 ecx, 1
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv128[rsp]
  000fd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00102	48 8d 4c 24 78	 lea	 rcx, QWORD PTR image$[rsp]
  00107	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0010c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00114	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193234
  00120	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193235
  0012c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00131	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00136	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193236
  00143	ba 84 02 00 00	 mov	 edx, 644		; 00000284H
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193237
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@z900_scedi:

; 645  :         return false;

  00155	32 c0		 xor	 al, al
  00157	eb 5a		 jmp	 SHORT $LN1@z900_scedi
$LN5@z900_scedi:

; 646  :     }
; 647  : 
; 648  :     success = ARCH_DEP( load_main )( filename, origin, noisy ) == 0;

  00159	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?noisy@?1??z900_scedio_ior@@9@9
  00160	8b 4c 24 60	 mov	 ecx, DWORD PTR origin$[rsp]
  00164	44 8b c0	 mov	 r8d, eax
  00167	8b d1		 mov	 edx, ecx
  00169	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00171	e8 00 00 00 00	 call	 z900_load_main
  00176	85 c0		 test	 eax, eax
  00178	75 0a		 jne	 SHORT $LN10@z900_scedi
  0017a	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  00182	eb 08		 jmp	 SHORT $LN11@z900_scedi
$LN10@z900_scedi:
  00184	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN11@z900_scedi:
  0018c	83 7c 24 58 00	 cmp	 DWORD PTR tv150[rsp], 0
  00191	75 0a		 jne	 SHORT $LN12@z900_scedi
  00193	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
  0019b	eb 08		 jmp	 SHORT $LN13@z900_scedi
$LN12@z900_scedi:
  0019d	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
$LN13@z900_scedi:
  001a5	0f b6 44 24 5c	 movzx	 eax, BYTE PTR tv152[rsp]
  001aa	88 44 24 50	 mov	 BYTE PTR success$[rsp], al

; 649  :     return success;

  001ae	0f b6 44 24 50	 movzx	 eax, BYTE PTR success$[rsp]
$LN1@z900_scedi:
$LN7@z900_scedi:

; 650  : }

  001b3	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bb	48 33 cc	 xor	 rcx, rsp
  001be	e8 00 00 00 00	 call	 __security_check_cookie
  001c3	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  001ca	c3		 ret	 0
z900_scedio_ior ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
fd$ = 80
pto$1 = 88
nread$ = 96
pgo$2 = 104
pti$3 = 112
totread$ = 120
tv70 = 128
ste$4 = 136
pte$5 = 144
page$6 = 152
fname$ = 176
sto$ = 184
seek$ = 192
size$ = 200
z900_read_file PROC

; 513  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 514  : int  fd, nread;
; 515  : U64  totread = 0;

  0001b	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR totread$[rsp], 0

; 516  : 
; 517  :     fd = HOPEN( fname, O_RDONLY | O_BINARY );

  00024	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00029	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00037	89 44 24 50	 mov	 DWORD PTR fd$[rsp], eax

; 518  : 
; 519  :     if (fd < 0)

  0003b	83 7c 24 50 00	 cmp	 DWORD PTR fd$[rsp], 0
  00040	0f 8d 9e 00 00
	00		 jge	 $LN8@z900_read_

; 520  :     {
; 521  :         if (errno != ENOENT)

  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004c	83 38 02	 cmp	 DWORD PTR [rax], 2
  0004f	0f 84 83 00 00
	00		 je	 $LN9@z900_read_

; 522  :             // "SCE file %s: error in function %s: %s"
; 523  :             WRMSG( HHC00600, "E", fname, "open()", strerror( errno ));

  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005b	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00063	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  0006b	b9 01 00 00 00	 mov	 ecx, 1
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00076	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  0007e	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00083	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193204
  0008a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0008f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00097	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0009c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193205
  000a3	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193206
  000af	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b4	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b9	41 b9 03 00 00
	00		 mov	 r9d, 3
  000bf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193207
  000c6	ba 0b 02 00 00	 mov	 edx, 523		; 0000020bH
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193208
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@z900_read_:

; 524  :         return -1;

  000d8	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000df	e9 5b 02 00 00	 jmp	 $LN1@z900_read_
$LN8@z900_read_:

; 525  :     }
; 526  : 
; 527  :     if (lseek( fd, (off_t)seek, SEEK_SET ) == (off_t) seek)

  000e4	45 33 c0	 xor	 r8d, r8d
  000e7	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR seek$[rsp]
  000ef	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000f9	48 3b 84 24 c0
	00 00 00	 cmp	 rax, QWORD PTR seek$[rsp]
  00101	0f 85 29 02 00
	00		 jne	 $LN10@z900_read_

; 528  :     {
; 529  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 530  :         sto &= ASCE_TO;

  00107	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR sto$[rsp]
  0010f	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00115	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR sto$[rsp], rax

; 531  : #else
; 532  :         sto &= STD_STO;
; 533  : #endif
; 534  :         for ( ; size > 0 ; sto += sizeof( sto ))

  0011d	eb 14		 jmp	 SHORT $LN4@z900_read_
$LN2@z900_read_:
  0011f	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR sto$[rsp]
  00127	48 83 c0 08	 add	 rax, 8
  0012b	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR sto$[rsp], rax
$LN4@z900_read_:
  00133	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  0013c	0f 8e ee 01 00
	00		 jle	 $LN3@z900_read_

; 535  :         {
; 536  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 537  :         DBLWRD* ste;
; 538  : #else
; 539  :         FWORD*  ste;
; 540  : #endif
; 541  :         CREG    pto, pti;
; 542  : 
; 543  :             /* Fetch segment table entry and calc Page Table Origin */
; 544  :             if (sto >= sysblk.mainsize)

  00142	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00149	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00150	48 39 84 24 b8
	00 00 00	 cmp	 QWORD PTR sto$[rsp], rax
  00158	72 05		 jb	 SHORT $LN11@z900_read_

; 545  :                 goto eof;

  0015a	e9 d1 01 00 00	 jmp	 $eof$18
$LN11@z900_read_:

; 546  : 
; 547  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 548  :             ste = (DBLWRD*)(sysblk.mainstor + sto);

  0015f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00166	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0016d	48 03 84 24 b8
	00 00 00	 add	 rax, QWORD PTR sto$[rsp]
  00175	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ste$4[rsp], rax

; 549  : #else
; 550  :             ste = (FWORD*) (sysblk.mainstor + sto);
; 551  : #endif
; 552  :             FETCH_W( pto, ste );

  0017d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ste$4[rsp]
  00185	e8 00 00 00 00	 call	 fetch_dw_noswap
  0018a	48 8b c8	 mov	 rcx, rax
  0018d	e8 00 00 00 00	 call	 _byteswap_uint64
  00192	48 89 44 24 58	 mov	 QWORD PTR pto$1[rsp], rax

; 553  :             ARCH_DEP( or_storage_key )( sto, STORKEY_REF );

  00197	b2 04		 mov	 dl, 4
  00199	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR sto$[rsp]
  001a1	e8 00 00 00 00	 call	 z900_or_storage_key

; 554  : 
; 555  :             if (pto & SEGTAB_INVALID)

  001a6	48 8b 44 24 58	 mov	 rax, QWORD PTR pto$1[rsp]
  001ab	48 83 e0 20	 and	 rax, 32			; 00000020H
  001af	48 85 c0	 test	 rax, rax
  001b2	74 05		 je	 SHORT $LN12@z900_read_

; 556  :                 goto eof;

  001b4	e9 77 01 00 00	 jmp	 $eof$18
$LN12@z900_read_:

; 557  : 
; 558  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 559  :             pto &= ZSEGTAB_PTO;

  001b9	48 8b 44 24 58	 mov	 rax, QWORD PTR pto$1[rsp]
  001be	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  001c4	48 89 44 24 58	 mov	 QWORD PTR pto$1[rsp], rax

; 560  : #else
; 561  :             pto &= SEGTAB_PTO;
; 562  : #endif
; 563  :             for (pti = 0; pti < 256 && size > 0; pti++, pto += sizeof( pto ))

  001c9	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pti$3[rsp], 0
  001d2	eb 1b		 jmp	 SHORT $LN7@z900_read_
$LN5@z900_read_:
  001d4	48 8b 44 24 70	 mov	 rax, QWORD PTR pti$3[rsp]
  001d9	48 ff c0	 inc	 rax
  001dc	48 89 44 24 70	 mov	 QWORD PTR pti$3[rsp], rax
  001e1	48 8b 44 24 58	 mov	 rax, QWORD PTR pto$1[rsp]
  001e6	48 83 c0 08	 add	 rax, 8
  001ea	48 89 44 24 58	 mov	 QWORD PTR pto$1[rsp], rax
$LN7@z900_read_:
  001ef	48 81 7c 24 70
	00 01 00 00	 cmp	 QWORD PTR pti$3[rsp], 256 ; 00000100H
  001f8	0f 83 2d 01 00
	00		 jae	 $LN6@z900_read_
  001fe	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  00207	0f 8e 1e 01 00
	00		 jle	 $LN6@z900_read_

; 564  :             {
; 565  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 566  :             DBLWRD* pte;
; 567  : #else
; 568  :             FWORD*  pte;
; 569  : #endif
; 570  :             CREG    pgo;
; 571  :             BYTE*   page;
; 572  : 
; 573  :                 /* Fetch Page Table Entry to get page origin */
; 574  :                 if (pto >= sysblk.mainsize)

  0020d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00214	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0021b	48 39 44 24 58	 cmp	 QWORD PTR pto$1[rsp], rax
  00220	72 05		 jb	 SHORT $LN13@z900_read_

; 575  :                     goto eof;

  00222	e9 09 01 00 00	 jmp	 $eof$18
$LN13@z900_read_:

; 576  : 
; 577  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 578  :                 pte = (DBLWRD*)(sysblk.mainstor + pto );

  00227	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0022e	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00235	48 03 44 24 58	 add	 rax, QWORD PTR pto$1[rsp]
  0023a	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pte$5[rsp], rax

; 579  : #else
; 580  :                 pte = (FWORD*) (sysblk.mainstor + pto);
; 581  : #endif
; 582  :                 FETCH_W( pgo, pte );

  00242	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pte$5[rsp]
  0024a	e8 00 00 00 00	 call	 fetch_dw_noswap
  0024f	48 8b c8	 mov	 rcx, rax
  00252	e8 00 00 00 00	 call	 _byteswap_uint64
  00257	48 89 44 24 68	 mov	 QWORD PTR pgo$2[rsp], rax

; 583  :                 ARCH_DEP( or_storage_key )( pto, STORKEY_REF );

  0025c	b2 04		 mov	 dl, 4
  0025e	48 8b 4c 24 58	 mov	 rcx, QWORD PTR pto$1[rsp]
  00263	e8 00 00 00 00	 call	 z900_or_storage_key

; 584  : 
; 585  :                 if (pgo & PAGETAB_INVALID)

  00268	48 8b 44 24 68	 mov	 rax, QWORD PTR pgo$2[rsp]
  0026d	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00273	48 85 c0	 test	 rax, rax
  00276	74 05		 je	 SHORT $LN14@z900_read_

; 586  :                     goto eof;

  00278	e9 b3 00 00 00	 jmp	 $eof$18
$LN14@z900_read_:

; 587  : 
; 588  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 589  :                 pgo &= ZPGETAB_PFRA;

  0027d	48 8b 44 24 68	 mov	 rax, QWORD PTR pgo$2[rsp]
  00282	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00288	48 89 44 24 68	 mov	 QWORD PTR pgo$2[rsp], rax

; 590  : #else
; 591  :                 pgo &= PAGETAB_PFRA;
; 592  : #endif
; 593  :                 /* Read page into main storage */
; 594  :                 if (pgo >= sysblk.mainsize)

  0028d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00294	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0029b	48 39 44 24 68	 cmp	 QWORD PTR pgo$2[rsp], rax
  002a0	72 05		 jb	 SHORT $LN15@z900_read_

; 595  :                     goto eof;

  002a2	e9 89 00 00 00	 jmp	 $eof$18
$LN15@z900_read_:

; 596  : 
; 597  :                 page = sysblk.mainstor + pgo;

  002a7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002ae	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  002b5	48 03 44 24 68	 add	 rax, QWORD PTR pgo$2[rsp]
  002ba	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR page$6[rsp], rax

; 598  :                 nread = read( fd, page, STORAGE_KEY_PAGESIZE );

  002c2	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  002c8	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR page$6[rsp]
  002d0	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  002d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  002da	89 44 24 60	 mov	 DWORD PTR nread$[rsp], eax

; 599  :                 totread += nread;

  002de	48 63 44 24 60	 movsxd	 rax, DWORD PTR nread$[rsp]
  002e3	48 8b 4c 24 78	 mov	 rcx, QWORD PTR totread$[rsp]
  002e8	48 03 c8	 add	 rcx, rax
  002eb	48 8b c1	 mov	 rax, rcx
  002ee	48 89 44 24 78	 mov	 QWORD PTR totread$[rsp], rax

; 600  :                 size -= nread;

  002f3	48 63 44 24 60	 movsxd	 rax, DWORD PTR nread$[rsp]
  002f8	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  00300	48 2b c8	 sub	 rcx, rax
  00303	48 8b c1	 mov	 rax, rcx
  00306	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR size$[rsp], rax

; 601  : 
; 602  :                 if (nread != STORAGE_KEY_PAGESIZE)

  0030e	81 7c 24 60 00
	10 00 00	 cmp	 DWORD PTR nread$[rsp], 4096 ; 00001000H
  00316	74 02		 je	 SHORT $LN16@z900_read_

; 603  :                     goto eof;

  00318	eb 16		 jmp	 SHORT $eof$18
$LN16@z900_read_:

; 604  : 
; 605  :                 ARCH_DEP( or_storage_key )( pgo, (STORKEY_REF | STORKEY_CHANGE) );

  0031a	b2 06		 mov	 dl, 6
  0031c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR pgo$2[rsp]
  00321	e8 00 00 00 00	 call	 z900_or_storage_key

; 606  :             }

  00326	e9 a9 fe ff ff	 jmp	 $LN5@z900_read_
$LN6@z900_read_:

; 607  :         }

  0032b	e9 ef fd ff ff	 jmp	 $LN2@z900_read_
$LN3@z900_read_:
$LN10@z900_read_:
$eof$18:

; 608  :     }
; 609  : eof:
; 610  :     close( fd );

  00330	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 611  :     return totread;

  0033a	48 8b 44 24 78	 mov	 rax, QWORD PTR totread$[rsp]
$LN1@z900_read_:

; 612  : }

  0033f	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00346	c3		 ret	 0
z900_read_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
pto$1 = 80
fd$ = 88
pgo$2 = 96
nwrite$ = 104
pti$3 = 112
totwrite$ = 120
tv71 = 128
ste$4 = 136
pte$5 = 144
page$6 = 152
fname$ = 176
mode$ = 184
sto$ = 192
size$ = 200
z900_write_file PROC

; 409  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 410  : int  fd, nwrite;
; 411  : U64  totwrite = 0;

  0001a	48 c7 44 24 78
	00 00 00 00	 mov	 QWORD PTR totwrite$[rsp], 0

; 412  : 
; 413  :     fd = HOPEN( fname, mode | O_WRONLY | O_BINARY,

  00023	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  0002a	83 c8 01	 or	 eax, 1
  0002d	0f ba e8 0f	 bts	 eax, 15
  00031	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00037	8b d0		 mov	 edx, eax
  00039	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00047	89 44 24 58	 mov	 DWORD PTR fd$[rsp], eax

; 414  :             S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH );
; 415  : 
; 416  :     if (fd < 0)

  0004b	83 7c 24 58 00	 cmp	 DWORD PTR fd$[rsp], 0
  00050	0f 8d 8f 00 00
	00		 jge	 $LN8@z900_write

; 417  :     {
; 418  :         // "SCE file %s: error in function %s: %s"
; 419  :         WRMSG( HHC00600, "E", fname, "open()", strerror( errno ));

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00064	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv71[rsp], rax
  0006c	b9 01 00 00 00	 mov	 ecx, 1
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00077	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv71[rsp]
  0007f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00084	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193161
  0008b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00090	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00098	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193162
  000a4	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193163
  000b0	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b5	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ba	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193164
  000c7	ba a3 01 00 00	 mov	 edx, 419		; 000001a3H
  000cc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193165
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 420  :         return -1;

  000d9	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000e0	e9 32 02 00 00	 jmp	 $LN1@z900_write
$LN8@z900_write:

; 421  :     }
; 422  : 
; 423  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 424  :     sto &= ASCE_TO;

  000e5	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sto$[rsp]
  000ed	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  000f3	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR sto$[rsp], rax

; 425  : #else
; 426  :     sto &= STD_STO;
; 427  : #endif
; 428  : 
; 429  :     for ( ; size > 0 ; sto += sizeof( sto ))

  000fb	eb 14		 jmp	 SHORT $LN4@z900_write
$LN2@z900_write:
  000fd	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR sto$[rsp]
  00105	48 83 c0 08	 add	 rax, 8
  00109	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR sto$[rsp], rax
$LN4@z900_write:
  00111	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  0011a	0f 8e e8 01 00
	00		 jle	 $LN3@z900_write

; 430  :     {
; 431  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 432  :     DBLWRD* ste;
; 433  : #else
; 434  :     FWORD*  ste;
; 435  : #endif
; 436  :     CREG    pto, pti;
; 437  : 
; 438  :         /* Fetch segment table entry and calc Page Table Origin */
; 439  :         if (sto >= sysblk.mainsize)

  00120	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00127	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  0012e	48 39 84 24 c0
	00 00 00	 cmp	 QWORD PTR sto$[rsp], rax
  00136	72 05		 jb	 SHORT $LN9@z900_write

; 440  :             goto eof;

  00138	e9 cb 01 00 00	 jmp	 $eof$16
$LN9@z900_write:

; 441  : 
; 442  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 443  :         ste = (DBLWRD*)(sysblk.mainstor + sto);

  0013d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00144	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  0014b	48 03 84 24 c0
	00 00 00	 add	 rax, QWORD PTR sto$[rsp]
  00153	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR ste$4[rsp], rax

; 444  : #else
; 445  :         ste = (FWORD*) (sysblk.mainstor + sto);
; 446  : #endif
; 447  :         FETCH_W( pto, ste );

  0015b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR ste$4[rsp]
  00163	e8 00 00 00 00	 call	 fetch_dw_noswap
  00168	48 8b c8	 mov	 rcx, rax
  0016b	e8 00 00 00 00	 call	 _byteswap_uint64
  00170	48 89 44 24 50	 mov	 QWORD PTR pto$1[rsp], rax

; 448  :         ARCH_DEP( or_storage_key )( sto, STORKEY_REF );

  00175	b2 04		 mov	 dl, 4
  00177	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR sto$[rsp]
  0017f	e8 00 00 00 00	 call	 z900_or_storage_key

; 449  : 
; 450  :         if (pto & SEGTAB_INVALID)

  00184	48 8b 44 24 50	 mov	 rax, QWORD PTR pto$1[rsp]
  00189	48 83 e0 20	 and	 rax, 32			; 00000020H
  0018d	48 85 c0	 test	 rax, rax
  00190	74 05		 je	 SHORT $LN10@z900_write

; 451  :             goto eof;

  00192	e9 71 01 00 00	 jmp	 $eof$16
$LN10@z900_write:

; 452  : 
; 453  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 454  :         pto &= ZSEGTAB_PTO;

  00197	48 8b 44 24 50	 mov	 rax, QWORD PTR pto$1[rsp]
  0019c	48 25 00 f8 ff
	ff		 and	 rax, -2048		; fffffffffffff800H
  001a2	48 89 44 24 50	 mov	 QWORD PTR pto$1[rsp], rax

; 455  : #else
; 456  :         pto &= SEGTAB_PTO;
; 457  : #endif
; 458  :         for (pti = 0; pti < 256 && size > 0; pti++, pto += sizeof( pto ))

  001a7	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR pti$3[rsp], 0
  001b0	eb 1b		 jmp	 SHORT $LN7@z900_write
$LN5@z900_write:
  001b2	48 8b 44 24 70	 mov	 rax, QWORD PTR pti$3[rsp]
  001b7	48 ff c0	 inc	 rax
  001ba	48 89 44 24 70	 mov	 QWORD PTR pti$3[rsp], rax
  001bf	48 8b 44 24 50	 mov	 rax, QWORD PTR pto$1[rsp]
  001c4	48 83 c0 08	 add	 rax, 8
  001c8	48 89 44 24 50	 mov	 QWORD PTR pto$1[rsp], rax
$LN7@z900_write:
  001cd	48 81 7c 24 70
	00 01 00 00	 cmp	 QWORD PTR pti$3[rsp], 256 ; 00000100H
  001d6	0f 83 27 01 00
	00		 jae	 $LN6@z900_write
  001dc	48 83 bc 24 c8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  001e5	0f 8e 18 01 00
	00		 jle	 $LN6@z900_write

; 459  :         {
; 460  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 461  :         DBLWRD* pte;
; 462  : #else
; 463  :         FWORD*  pte;
; 464  : #endif
; 465  :         CREG    pgo;
; 466  :         BYTE*   page;
; 467  : 
; 468  :             /* Fetch Page Table Entry to get page origin */
; 469  :             if (pto >= sysblk.mainsize)

  001eb	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f2	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  001f9	48 39 44 24 50	 cmp	 QWORD PTR pto$1[rsp], rax
  001fe	72 05		 jb	 SHORT $LN11@z900_write

; 470  :                 goto eof;

  00200	e9 03 01 00 00	 jmp	 $eof$16
$LN11@z900_write:

; 471  : 
; 472  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 473  :             pte = (DBLWRD*)(sysblk.mainstor + pto);

  00205	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020c	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00213	48 03 44 24 50	 add	 rax, QWORD PTR pto$1[rsp]
  00218	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR pte$5[rsp], rax

; 474  : #else
; 475  :             pte = (FWORD*) (sysblk.mainstor + pto);
; 476  : #endif
; 477  :             FETCH_W( pgo, pte );

  00220	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR pte$5[rsp]
  00228	e8 00 00 00 00	 call	 fetch_dw_noswap
  0022d	48 8b c8	 mov	 rcx, rax
  00230	e8 00 00 00 00	 call	 _byteswap_uint64
  00235	48 89 44 24 60	 mov	 QWORD PTR pgo$2[rsp], rax

; 478  :             ARCH_DEP( or_storage_key )( pto, STORKEY_REF );

  0023a	b2 04		 mov	 dl, 4
  0023c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR pto$1[rsp]
  00241	e8 00 00 00 00	 call	 z900_or_storage_key

; 479  : 
; 480  :             if (!(pgo & PAGETAB_INVALID))

  00246	48 8b 44 24 60	 mov	 rax, QWORD PTR pgo$2[rsp]
  0024b	48 25 00 04 00
	00		 and	 rax, 1024		; 00000400H
  00251	48 85 c0	 test	 rax, rax
  00254	0f 85 8e 00 00
	00		 jne	 $LN12@z900_write

; 481  :             {
; 482  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 483  :                 pgo &= ZPGETAB_PFRA;

  0025a	48 8b 44 24 60	 mov	 rax, QWORD PTR pgo$2[rsp]
  0025f	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  00265	48 89 44 24 60	 mov	 QWORD PTR pgo$2[rsp], rax

; 484  : #else
; 485  :                 pgo &= PAGETAB_PFRA;
; 486  : #endif
; 487  :                 /* Write page to SCE disk */
; 488  :                 if (pgo >= sysblk.mainsize)

  0026a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00271	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00278	48 39 44 24 60	 cmp	 QWORD PTR pgo$2[rsp], rax
  0027d	72 05		 jb	 SHORT $LN13@z900_write

; 489  :                     goto eof;

  0027f	e9 84 00 00 00	 jmp	 $eof$16
$LN13@z900_write:

; 490  : 
; 491  :                 page = sysblk.mainstor + pgo;

  00284	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0028b	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00292	48 03 44 24 60	 add	 rax, QWORD PTR pgo$2[rsp]
  00297	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR page$6[rsp], rax

; 492  :                 nwrite = write( fd, page, STORAGE_KEY_PAGESIZE );

  0029f	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  002a5	48 8b 94 24 98
	00 00 00	 mov	 rdx, QWORD PTR page$6[rsp]
  002ad	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  002b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  002b7	89 44 24 68	 mov	 DWORD PTR nwrite$[rsp], eax

; 493  :                 totwrite += nwrite;

  002bb	48 63 44 24 68	 movsxd	 rax, DWORD PTR nwrite$[rsp]
  002c0	48 8b 4c 24 78	 mov	 rcx, QWORD PTR totwrite$[rsp]
  002c5	48 03 c8	 add	 rcx, rax
  002c8	48 8b c1	 mov	 rax, rcx
  002cb	48 89 44 24 78	 mov	 QWORD PTR totwrite$[rsp], rax

; 494  : 
; 495  :                 if (nwrite != STORAGE_KEY_PAGESIZE)

  002d0	81 7c 24 68 00
	10 00 00	 cmp	 DWORD PTR nwrite$[rsp], 4096 ; 00001000H
  002d8	74 02		 je	 SHORT $LN14@z900_write

; 496  :                     goto eof;

  002da	eb 2c		 jmp	 SHORT $eof$16
$LN14@z900_write:

; 497  : 
; 498  :                 ARCH_DEP( or_storage_key )( pgo, STORKEY_REF );

  002dc	b2 04		 mov	 dl, 4
  002de	48 8b 4c 24 60	 mov	 rcx, QWORD PTR pgo$2[rsp]
  002e3	e8 00 00 00 00	 call	 z900_or_storage_key
$LN12@z900_write:

; 499  :             }
; 500  :             size -= STORAGE_KEY_PAGESIZE;

  002e8	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  002f0	48 2d 00 10 00
	00		 sub	 rax, 4096		; 00001000H
  002f6	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR size$[rsp], rax

; 501  :         }

  002fe	e9 af fe ff ff	 jmp	 $LN5@z900_write
$LN6@z900_write:

; 502  :     }

  00303	e9 f5 fd ff ff	 jmp	 $LN2@z900_write
$LN3@z900_write:
$eof$16:

; 503  : eof:
; 504  :     close( fd );

  00308	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 505  :     return totwrite;

  00312	48 8b 44 24 78	 mov	 rax, QWORD PTR totwrite$[rsp]
$LN1@z900_write:

; 506  : }

  00317	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0031e	c3		 ret	 0
z900_write_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 z900_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
z900_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
z900_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 z900__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
z900_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT z900__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
z900__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@z900__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@z900__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@z900__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@z900__or_s
$LN5@z900__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@z900__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
z900__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
evd_len$ = 32
sccb_len$ = 36
evd_hdr$ = 40
sccb$ = 64
z900_sclp_scedio_event PROC

; 960  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 961  : SCCB_EVD_HDR*  evd_hdr  = (SCCB_EVD_HDR*)(sccb + 1);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 89 44 24 28	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 962  : U16            evd_len;
; 963  : U16            sccb_len;
; 964  : 
; 965  :     if (ARCH_DEP( scedio_request )( SCLP_READ_EVENT_DATA, evd_hdr ))

  00017	48 8b 54 24 28	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  0001c	b9 05 00 77 00	 mov	 ecx, 7798789		; 00770005H
  00021	e8 00 00 00 00	 call	 z900_scedio_request
  00026	85 c0		 test	 eax, eax
  00028	0f 84 8d 00 00
	00		 je	 $LN2@z900_sclp_

; 966  :     {
; 967  :         // true: an I/O request WAS pending and has now completed
; 968  : 
; 969  :         /* Update SCCB length field if variable request */
; 970  :         if (sccb->type & SCCB_TYPE_VARIABLE)

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00033	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00037	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0003c	85 c0		 test	 eax, eax
  0003e	74 54		 je	 SHORT $LN3@z900_sclp_

; 971  :         {
; 972  :             FETCH_HW( evd_len, evd_hdr->totlen );

  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 fetch_hw_noswap
  0004d	0f b7 c8	 movzx	 ecx, ax
  00050	e8 00 00 00 00	 call	 _byteswap_ushort
  00055	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 973  :             sccb_len = evd_len + sizeof( SCCB_HEADER );

  0005a	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  0005f	48 83 c0 08	 add	 rax, 8
  00063	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 974  :             STORE_HW( sccb->length, sccb_len );

  00068	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  0006d	e8 00 00 00 00	 call	 _byteswap_ushort
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  00077	0f b7 d0	 movzx	 edx, ax
  0007a	e8 00 00 00 00	 call	 store_hw_noswap

; 975  :             sccb->type &= ~SCCB_TYPE_VARIABLE;

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00084	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00088	0f ba f0 07	 btr	 eax, 7
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  00091	88 41 05	 mov	 BYTE PTR [rcx+5], al
$LN3@z900_sclp_:

; 976  :         }
; 977  : 
; 978  :         /* Set response code X'0020' in SCCB header */
; 979  :         sccb->reas = SCCB_REAS_NONE;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00099	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 980  :         sccb->resp = SCCB_RESP_COMPLETE;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000a2	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 981  : 
; 982  :         /* Event read processed and now no events are pending */
; 983  :         evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  000a6	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  000ab	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000af	0f ba e8 07	 bts	 eax, 7
  000b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  000b8	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN2@z900_sclp_:

; 984  :     }
; 985  : }

  000bb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bf	c3		 ret	 0
z900_sclp_scedio_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
evd_hdr$ = 32
sccb$ = 64
z900_sclp_scedio_request PROC

; 934  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 935  :     SCCB_EVD_HDR*  evd_hdr  = (SCCB_EVD_HDR*)(sccb + 1);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 89 44 24 20	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 936  : 
; 937  :     if (ARCH_DEP( scedio_request )( SCLP_WRITE_EVENT_DATA, evd_hdr ))

  00017	48 8b 54 24 20	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  0001c	b9 05 00 76 00	 mov	 ecx, 7733253		; 00760005H
  00021	e8 00 00 00 00	 call	 z900_scedio_request
  00026	85 c0		 test	 eax, eax
  00028	74 14		 je	 SHORT $LN2@z900_sclp_

; 938  :     {
; 939  :         // non-zero: error: I/O request NOT started...
; 940  : 
; 941  :         /* Set response code X'0040' in SCCB header */
; 942  :         sccb->reas = SCCB_REAS_NONE;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0002f	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 943  :         sccb->resp = SCCB_RESP_BACKOUT;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00038	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 944  :     }

  0003c	eb 27		 jmp	 SHORT $LN3@z900_sclp_
$LN2@z900_sclp_:

; 945  :     else // zero: I/O request WAS successfully started...
; 946  :     {
; 947  :         /* Set response code X'0020' in SCCB header */
; 948  :         sccb->reas = SCCB_REAS_NONE;

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00043	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 949  :         sccb->resp = SCCB_RESP_COMPLETE;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0004c	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 950  : 
; 951  :         /* Event write processed and event read now pending */
; 952  :         evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00055	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00059	0f ba e8 07	 bts	 eax, 7
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00062	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN3@z900_sclp_:

; 953  :     }
; 954  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
z900_sclp_scedio_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
rc$ = 80
fileaddr$ = 84
inputline$ = 88
fp$ = 96
regs$ = 104
tv83 = 112
tv133 = 120
tv177 = 128
tv202 = 136
filename$ = 144
pathname$ = 416
inputbuff$ = 688
__$ArrayPad$ = 960
fname$ = 992
cpu$ = 1000
clear$ = 1008
z900_load_hmc PROC

; 304  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec d8 03
	00 00		 sub	 rsp, 984		; 000003d8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 305  : REGS*   regs;                           /* -> Regs                   */
; 306  : FILE*   fp;
; 307  : char    inputbuff[MAX_PATH];
; 308  : char*   inputline;
; 309  : char    filename[MAX_PATH];             /* filename of image file    */
; 310  : char    pathname[MAX_PATH];             /* pathname of image file    */
; 311  : U32     fileaddr;
; 312  : int     rc = 0;                         /* Return codes (work)       */

  00027	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 313  : 
; 314  : static const bool noisy =
; 315  : #if defined(_DEBUG) || defined(DEBUG)
; 316  :     true;
; 317  : #else
; 318  :     false;
; 319  : #endif
; 320  : 
; 321  :     /* Get started */
; 322  :     if (ARCH_DEP( common_load_begin )( cpu, clear ) != 0)

  0002f	8b 94 24 f0 03
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00036	8b 8c 24 e8 03
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0003d	e8 00 00 00 00	 call	 z900_common_load_begin
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN5@z900_load_

; 323  :         return -1;

  00046	b8 ff ff ff ff	 mov	 eax, -1
  0004b	e9 e3 03 00 00	 jmp	 $LN1@z900_load_
$LN5@z900_load_:

; 324  : 
; 325  :     /* The actual IPL proper starts here... */
; 326  : 
; 327  :     regs = sysblk.regs[ cpu ];          /* Point to IPL CPU's regs   */

  00050	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00067	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax

; 328  : 
; 329  :     if (fname == NULL)                  /* Default ipl from DASD     */

  0006c	48 83 bc 24 e0
	03 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  00075	75 0f		 jne	 SHORT $LN6@z900_load_

; 330  :         fname = "HERCULES.ins";         /*   from HERCULES.ins       */

  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG193108
  0007e	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR fname$[rsp], rax
$LN6@z900_load_:

; 331  : 
; 332  :     hostpath( pathname, fname, sizeof( pathname ));

  00086	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0008c	48 8b 94 24 e0
	03 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00094	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 333  : 
; 334  :     if (!(fname = set_sce_basedir( pathname )))

  000a2	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000aa	e8 00 00 00 00	 call	 set_sce_basedir
  000af	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR fname$[rsp], rax
  000b7	48 83 bc 24 e0
	03 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  000c0	75 0a		 jne	 SHORT $LN7@z900_load_

; 335  :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	e9 67 03 00 00	 jmp	 $LN1@z900_load_
$LN7@z900_load_:

; 336  : 
; 337  :     /* Construct and check full pathname */
; 338  :     if (!check_sce_filepath( fname, filename ))

  000cc	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  000d4	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000dc	e8 00 00 00 00	 call	 check_sce_filepath
  000e1	48 85 c0	 test	 rax, rax
  000e4	75 7b		 jne	 SHORT $LN8@z900_load_

; 339  :     {
; 340  :         // "SCE file %s: load from file failed: %s"
; 341  :         WRMSG( HHC00601,"E", fname, strerror( errno ));

  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ec	8b 08		 mov	 ecx, DWORD PTR [rax]
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000f4	48 89 44 24 70	 mov	 QWORD PTR tv83[rsp], rax
  000f9	b9 01 00 00 00	 mov	 ecx, 1
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00104	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv83[rsp]
  00109	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0010e	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00116	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193111
  00122	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193112
  0012e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00133	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00138	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193113
  00145	ba 55 01 00 00	 mov	 edx, 341		; 00000155H
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193114
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 342  :         return -1;

  00157	b8 ff ff ff ff	 mov	 eax, -1
  0015c	e9 d2 02 00 00	 jmp	 $LN1@z900_load_
$LN8@z900_load_:

; 343  :     }
; 344  : 
; 345  :     fp = fopen( filename, "r" );

  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193115
  00168	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00176	48 89 44 24 60	 mov	 QWORD PTR fp$[rsp], rax

; 346  :     if (fp == NULL)

  0017b	48 83 7c 24 60
	00		 cmp	 QWORD PTR fp$[rsp], 0
  00181	0f 85 87 00 00
	00		 jne	 $LN9@z900_load_

; 347  :     {
; 348  :         // "SCE file %s: error in function %s: %s"
; 349  :         WRMSG( HHC00600,"E", fname,"fopen()", strerror( errno ));

  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0018d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00195	48 89 44 24 78	 mov	 QWORD PTR tv133[rsp], rax
  0019a	b9 01 00 00 00	 mov	 ecx, 1
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv133[rsp]
  001aa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193117
  001b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001bb	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193118
  001cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193119
  001db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193120
  001f2	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193121
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 350  :         return -1;

  00204	b8 ff ff ff ff	 mov	 eax, -1
  00209	e9 25 02 00 00	 jmp	 $LN1@z900_load_
$LN9@z900_load_:
$LN4@z900_load_:

; 351  :     }
; 352  : 
; 353  :     do
; 354  :     {
; 355  :         inputline = fgets( inputbuff, sizeof( inputbuff ), fp );

  0020e	4c 8b 44 24 60	 mov	 r8, QWORD PTR fp$[rsp]
  00213	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  00218	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR inputbuff$[rsp]
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00226	48 89 44 24 58	 mov	 QWORD PTR inputline$[rsp], rax

; 356  : 
; 357  : #if !defined(_MSVC_)
; 358  :         if (inputline && *inputline == 0x1a)
; 359  :             inputline = NULL;
; 360  : #endif
; 361  :         if (inputline)

  0022b	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00231	74 22		 je	 SHORT $LN10@z900_load_

; 362  :         {
; 363  :             rc = sscanf( inputline,"%" QSTR( MAX_PATH ) "s %i", filename, &fileaddr );

  00233	4c 8d 4c 24 54	 lea	 r9, QWORD PTR fileaddr$[rsp]
  00238	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR filename$[rsp]
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG193123
  00247	48 8b 4c 24 58	 mov	 rcx, QWORD PTR inputline$[rsp]
  0024c	e8 00 00 00 00	 call	 sscanf
  00251	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN10@z900_load_:

; 364  :         }
; 365  : 
; 366  :         /* If no load address was found load to location zero */
; 367  :         if (inputline && rc < 2)

  00255	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  0025b	74 0f		 je	 SHORT $LN11@z900_load_
  0025d	83 7c 24 50 02	 cmp	 DWORD PTR rc$[rsp], 2
  00262	7d 08		 jge	 SHORT $LN11@z900_load_

; 368  :             fileaddr = 0;

  00264	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR fileaddr$[rsp], 0
$LN11@z900_load_:

; 369  : 
; 370  :         if (inputline && rc > 0 && *filename != '*' && *filename != '#')

  0026c	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00272	0f 84 9a 01 00
	00		 je	 $LN12@z900_load_
  00278	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0027d	0f 8e 8f 01 00
	00		 jle	 $LN12@z900_load_
  00283	b8 01 00 00 00	 mov	 eax, 1
  00288	48 6b c0 00	 imul	 rax, rax, 0
  0028c	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  00294	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00297	0f 84 75 01 00
	00		 je	 $LN12@z900_load_
  0029d	b8 01 00 00 00	 mov	 eax, 1
  002a2	48 6b c0 00	 imul	 rax, rax, 0
  002a6	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  002ae	83 f8 23	 cmp	 eax, 35			; 00000023H
  002b1	0f 84 5b 01 00
	00		 je	 $LN12@z900_load_

; 371  :         {
; 372  :             hostpath( pathname, filename, sizeof( pathname ));

  002b7	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  002bd	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  002c5	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 373  : 
; 374  :             /* Construct and check full pathname */
; 375  :             if (!check_sce_filepath( pathname, filename ))

  002d3	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  002db	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  002e3	e8 00 00 00 00	 call	 check_sce_filepath
  002e8	48 85 c0	 test	 rax, rax
  002eb	0f 85 81 00 00
	00		 jne	 $LN13@z900_load_

; 376  :             {
; 377  :                 // "SCE file %s: load from path failed: %s"
; 378  :                 WRMSG( HHC00602,"E",pathname,strerror( errno ));

  002f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002f7	8b 08		 mov	 ecx, DWORD PTR [rax]
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ff	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  00307	b9 01 00 00 00	 mov	 ecx, 1
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00312	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv177[rsp]
  0031a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0031f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00327	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193127
  00333	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193128
  0033f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00344	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00349	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193129
  00356	ba 7a 01 00 00	 mov	 edx, 378		; 0000017aH
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193130
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 379  :                 return -1;

  00368	b8 ff ff ff ff	 mov	 eax, -1
  0036d	e9 c1 00 00 00	 jmp	 $LN1@z900_load_
$LN13@z900_load_:

; 380  :             }
; 381  : 
; 382  :             if (ARCH_DEP( load_main )( filename, fileaddr, noisy ) < 0)

  00372	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?noisy@?1??z900_load_hmc@@9@9
  00379	8b 4c 24 54	 mov	 ecx, DWORD PTR fileaddr$[rsp]
  0037d	44 8b c0	 mov	 r8d, eax
  00380	8b d1		 mov	 edx, ecx
  00382	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0038a	e8 00 00 00 00	 call	 z900_load_main
  0038f	85 c0		 test	 eax, eax
  00391	7d 43		 jge	 SHORT $LN14@z900_load_

; 383  :             {
; 384  :                 // Error!
; 385  :                 fclose( fp );

  00393	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 386  :                 HDC1( debug_cpu_state, regs );

  0039e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  003a5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003a9	74 18		 je	 SHORT $LN16@z900_load_
  003ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  003b7	ff 10		 call	 QWORD PTR [rax]
  003b9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv202[rsp], rax
  003c1	eb 0c		 jmp	 SHORT $LN17@z900_load_
$LN16@z900_load_:
  003c3	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv202[rsp], 0
$LN17@z900_load_:

; 387  :                 return -1;

  003cf	b8 ff ff ff ff	 mov	 eax, -1
  003d4	eb 5d		 jmp	 SHORT $LN1@z900_load_
$LN14@z900_load_:

; 388  :             }
; 389  : 
; 390  :             sysblk.main_clear = sysblk.xpnd_clear = 0;

  003d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003dd	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  003e3	0f ba f0 0f	 btr	 eax, 15
  003e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003ee	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  003f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003fb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00401	0f ba f0 0e	 btr	 eax, 14
  00405	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0040c	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN12@z900_load_:

; 391  :         }
; 392  :     }
; 393  :     while (inputline);

  00412	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00418	0f 85 f0 fd ff
	ff		 jne	 $LN4@z900_load_

; 394  : 
; 395  :     fclose( fp );

  0041e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 396  : 
; 397  :     /* Finish up... */
; 398  :     return ARCH_DEP( common_load_finish )( regs );

  00429	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0042e	e8 00 00 00 00	 call	 z900_common_load_finish
$LN1@z900_load_:

; 399  : 
; 400  : } /* end function load_hmc */

  00433	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043b	48 33 cc	 xor	 rcx, rsp
  0043e	e8 00 00 00 00	 call	 __security_check_cookie
  00443	48 81 c4 d8 03
	00 00		 add	 rsp, 984		; 000003d8H
  0044a	c3		 ret	 0
z900_load_hmc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
fd$ = 80
bytes$ = 84
aaddr$ = 88
pages$ = 96
rc$1 = 100
tv155 = 104
chunk$ = 112
pageaddr$ = 120
loaded$ = 128
curtime$ = 136
begtime$ = 144
tv70 = 152
tv133 = 160
tv193 = 168
fmt_mem$ = 176
__$ArrayPad$ = 184
fname$ = 208
startloc$ = 216
noisy$ = 224
z900_load_main PROC

; 169  : {

$LN23:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 170  : U64     loaded;
; 171  : RADR    aaddr;
; 172  : RADR    pageaddr;
; 173  : int     fd;
; 174  : int     pages;
; 175  : size_t  chunk;
; 176  : int     bytes;
; 177  : time_t  begtime, curtime;
; 178  : char    fmt_mem[8];
; 179  : 
; 180  :     fd = HOPEN( fname, O_RDONLY | O_BINARY );

  00028	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0002d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0003b	89 44 24 50	 mov	 DWORD PTR fd$[rsp], eax

; 181  : 
; 182  :     if (fd < 0)

  0003f	83 7c 24 50 00	 cmp	 DWORD PTR fd$[rsp], 0
  00044	0f 8d 9b 00 00
	00		 jge	 $LN8@z900_load_

; 183  :     {
; 184  :         if (errno != ENOENT)

  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00050	83 38 02	 cmp	 DWORD PTR [rax], 2
  00053	0f 84 83 00 00
	00		 je	 $LN9@z900_load_

; 185  :             // "SCE file %s: error in function %s: %s"
; 186  :             WRMSG( HHC00600, "E", fname, "open()", strerror( errno ));

  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00067	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  00082	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193054
  0008e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00093	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0009b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193055
  000a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193056
  000b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193057
  000ca	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193058
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@z900_load_:

; 187  :         return fd;

  000dc	8b 44 24 50	 mov	 eax, DWORD PTR fd$[rsp]
  000e0	e9 b9 03 00 00	 jmp	 $LN1@z900_load_
$LN8@z900_load_:

; 188  :     }
; 189  : 
; 190  :     /* Calculate size of first chunk to reach page boundary */
; 191  :     chunk = PAGEFRAME_PAGESIZE - (startloc & PAGEFRAME_BYTEMASK);

  000e5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR startloc$[rsp]
  000ed	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000f3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000f8	48 2b c8	 sub	 rcx, rax
  000fb	48 8b c1	 mov	 rax, rcx
  000fe	48 89 44 24 70	 mov	 QWORD PTR chunk$[rsp], rax

; 192  :     aaddr = startloc;

  00103	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR startloc$[rsp]
  0010b	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 193  : 
; 194  :     if (noisy)

  00110	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  00118	74 19		 je	 SHORT $LN10@z900_load_

; 195  :     {
; 196  :         loaded = 0;

  0011a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR loaded$[rsp], 0

; 197  :         time( &begtime );

  00126	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR begtime$[rsp]
  0012e	e8 00 00 00 00	 call	 time
$LN10@z900_load_:
$LN2@z900_load_:

; 198  :     }
; 199  : 
; 200  :     /* Read file into storage until end of file or end of storage */
; 201  :     for (;;)
; 202  :     {
; 203  :         if (chunk > (sysblk.mainsize - aaddr))

  00133	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0013f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00146	48 2b c1	 sub	 rax, rcx
  00149	48 39 44 24 70	 cmp	 QWORD PTR chunk$[rsp], rax
  0014e	76 1b		 jbe	 SHORT $LN11@z900_load_

; 204  :             chunk = (sysblk.mainsize - aaddr);

  00150	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00157	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0015c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00163	48 2b c1	 sub	 rax, rcx
  00166	48 89 44 24 70	 mov	 QWORD PTR chunk$[rsp], rax
$LN11@z900_load_:

; 205  : 
; 206  :         bytes = read( fd, sysblk.mainstor + aaddr, chunk );

  0016b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00172	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00179	48 03 44 24 58	 add	 rax, QWORD PTR aaddr$[rsp]
  0017e	44 8b 44 24 70	 mov	 r8d, DWORD PTR chunk$[rsp]
  00183	48 8b d0	 mov	 rdx, rax
  00186	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00190	89 44 24 54	 mov	 DWORD PTR bytes$[rsp], eax

; 207  : 
; 208  :         chunk = CHUNKSIZE;

  00194	48 c7 44 24 70
	00 00 00 04	 mov	 QWORD PTR chunk$[rsp], 67108864 ; 04000000H

; 209  : 
; 210  :         /* Check for I/O error */
; 211  :         if (bytes < 0)

  0019d	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  001a2	0f 8d 97 00 00
	00		 jge	 $LN12@z900_load_

; 212  :         {
; 213  :             // "SCE file %s: error in function %s: %s"
; 214  :             WRMSG( HHC00600, "E", fname, "read()",strerror( errno ));

  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ae	8b 08		 mov	 ecx, DWORD PTR [rax]
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001be	b9 01 00 00 00	 mov	 ecx, 1
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001d1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193062
  001dd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001e2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001ea	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193063
  001f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193064
  00202	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00207	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00212	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193065
  00219	ba d6 00 00 00	 mov	 edx, 214		; 000000d6H
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193066
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 215  :             close( fd );

  0022b	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 216  :             return -1;

  00235	b8 ff ff ff ff	 mov	 eax, -1
  0023a	e9 5f 02 00 00	 jmp	 $LN1@z900_load_
$LN12@z900_load_:

; 217  :         }
; 218  : 
; 219  :         /* Check for end-of-file */
; 220  :         if (bytes == 0)

  0023f	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  00244	75 11		 jne	 SHORT $LN13@z900_load_

; 221  :         {
; 222  :             close( fd );

  00246	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 223  :             return 0;

  00250	33 c0		 xor	 eax, eax
  00252	e9 47 02 00 00	 jmp	 $LN1@z900_load_
$LN13@z900_load_:

; 224  :         }
; 225  : 
; 226  :         /* Update the storage keys for all of the pages we just read */
; 227  :         pages = ROUND_UP( bytes, PAGEFRAME_PAGESIZE ) / PAGEFRAME_PAGESIZE;

  00257	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  0025c	74 21		 je	 SHORT $LN21@z900_load_
  0025e	8b 44 24 54	 mov	 eax, DWORD PTR bytes$[rsp]
  00262	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  00267	99		 cdq
  00268	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0026e	03 c2		 add	 eax, edx
  00270	c1 f8 0c	 sar	 eax, 12
  00273	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00279	89 44 24 68	 mov	 DWORD PTR tv155[rsp], eax
  0027d	eb 08		 jmp	 SHORT $LN22@z900_load_
$LN21@z900_load_:
  0027f	c7 44 24 68 00
	10 00 00	 mov	 DWORD PTR tv155[rsp], 4096 ; 00001000H
$LN22@z900_load_:
  00287	8b 44 24 68	 mov	 eax, DWORD PTR tv155[rsp]
  0028b	99		 cdq
  0028c	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00292	03 c2		 add	 eax, edx
  00294	c1 f8 0c	 sar	 eax, 12
  00297	89 44 24 60	 mov	 DWORD PTR pages$[rsp], eax

; 228  :         pageaddr = aaddr;

  0029b	48 8b 44 24 58	 mov	 rax, QWORD PTR aaddr$[rsp]
  002a0	48 89 44 24 78	 mov	 QWORD PTR pageaddr$[rsp], rax
$LN7@z900_load_:

; 229  : 
; 230  :         do
; 231  :         {
; 232  :             ARCH_DEP( or_storage_key )( pageaddr, STORKEY_REF | STORKEY_CHANGE );

  002a5	b2 06		 mov	 dl, 6
  002a7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pageaddr$[rsp]
  002ac	e8 00 00 00 00	 call	 z900_or_storage_key

; 233  :             pageaddr += PAGEFRAME_PAGESIZE;

  002b1	48 8b 44 24 78	 mov	 rax, QWORD PTR pageaddr$[rsp]
  002b6	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  002bc	48 89 44 24 78	 mov	 QWORD PTR pageaddr$[rsp], rax

; 234  :         }
; 235  :         while (--pages);

  002c1	8b 44 24 60	 mov	 eax, DWORD PTR pages$[rsp]
  002c5	ff c8		 dec	 eax
  002c7	89 44 24 60	 mov	 DWORD PTR pages$[rsp], eax
  002cb	83 7c 24 60 00	 cmp	 DWORD PTR pages$[rsp], 0
  002d0	75 d3		 jne	 SHORT $LN7@z900_load_

; 236  : 
; 237  :         aaddr += bytes;

  002d2	48 63 44 24 54	 movsxd	 rax, DWORD PTR bytes$[rsp]
  002d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  002dc	48 03 c8	 add	 rcx, rax
  002df	48 8b c1	 mov	 rax, rcx
  002e2	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 238  :         aaddr &= PAGEFRAME_PAGEMASK;

  002e7	48 8b 44 24 58	 mov	 rax, QWORD PTR aaddr$[rsp]
  002ec	48 25 00 f0 ff
	ff		 and	 rax, -4096		; fffffffffffff000H
  002f2	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 239  : 
; 240  :         /* Check if end of storge reached */
; 241  :         if (aaddr >= sysblk.mainsize)

  002f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002fe	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00305	48 39 44 24 58	 cmp	 QWORD PTR aaddr$[rsp], rax
  0030a	0f 82 9c 00 00
	00		 jb	 $LN14@z900_load_

; 242  :         {
; 243  :             int rc;
; 244  :        
; 245  :             if (read( fd, &rc, 1 ) > 0)

  00310	41 b8 01 00 00
	00		 mov	 r8d, 1
  00316	48 8d 54 24 64	 lea	 rdx, QWORD PTR rc$1[rsp]
  0031b	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00325	85 c0		 test	 eax, eax
  00327	7e 68		 jle	 SHORT $LN15@z900_load_

; 246  :             {
; 247  :                 rc = +1;

  00329	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1

; 248  : 
; 249  :                 if (noisy)

  00331	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  00339	74 54		 je	 SHORT $LN17@z900_load_

; 250  :                 {
; 251  :                     // "SCE file %s: load main terminated at end of mainstor"
; 252  :                     WRMSG( HHC00603, "W", fname );

  0033b	b9 01 00 00 00	 mov	 ecx, 1
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00346	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0034e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193072
  0035a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193073
  00366	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00370	41 b9 03 00 00
	00		 mov	 r9d, 3
  00376	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193074
  0037d	ba fc 00 00 00	 mov	 edx, 252		; 000000fcH
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193075
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@z900_load_:

; 253  :                 }
; 254  :             }

  0038f	eb 08		 jmp	 SHORT $LN16@z900_load_
$LN15@z900_load_:

; 255  :             else /* ignore any error; we're at end of storage anyway */
; 256  :                 rc = 0;

  00391	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 0
$LN16@z900_load_:

; 257  : 
; 258  :             close( fd );

  00399	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0039d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 259  :             return rc;

  003a3	8b 44 24 64	 mov	 eax, DWORD PTR rc$1[rsp]
  003a7	e9 f2 00 00 00	 jmp	 $LN1@z900_load_
$LN14@z900_load_:

; 260  :         }
; 261  : 
; 262  :         /* Issue periodic progress messages */
; 263  :         if (noisy)

  003ac	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  003b4	0f 84 df 00 00
	00		 je	 $LN18@z900_load_

; 264  :         {
; 265  :             loaded += bytes;

  003ba	48 63 44 24 54	 movsxd	 rax, DWORD PTR bytes$[rsp]
  003bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR loaded$[rsp]
  003c7	48 03 c8	 add	 rcx, rax
  003ca	48 8b c1	 mov	 rax, rcx
  003cd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR loaded$[rsp], rax

; 266  :             time( &curtime );

  003d5	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR curtime$[rsp]
  003dd	e8 00 00 00 00	 call	 time

; 267  : 
; 268  :             if (difftime( curtime, begtime ) > 2.0)

  003e2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR begtime$[rsp]
  003ea	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR curtime$[rsp]
  003f2	e8 00 00 00 00	 call	 difftime
  003f7	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4000000000000000
  003ff	0f 86 94 00 00
	00		 jbe	 $LN19@z900_load_

; 269  :             {
; 270  :                 begtime = curtime;

  00405	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR curtime$[rsp]
  0040d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR begtime$[rsp], rax

; 271  : 
; 272  :                 // "%s bytes %s so far..."
; 273  :                 WRMSG( HHC02317, "I",

  00415	41 b8 08 00 00
	00		 mov	 r8d, 8
  0041b	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR fmt_mem$[rsp]
  00423	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR loaded$[rsp]
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_memsize
  00431	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv193[rsp], rax
  00439	b9 01 00 00 00	 mov	 ecx, 1
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193078
  0044b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00450	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv193[rsp]
  00458	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0045d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193079
  00464	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193080
  00470	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00475	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00480	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG193081
  00487	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  0048c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG193082
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@z900_load_:
$LN18@z900_load_:

; 274  :                     fmt_memsize( loaded, fmt_mem, sizeof( fmt_mem )),
; 275  :                         "loaded" );
; 276  :             }
; 277  :         }
; 278  :     } /* end for (;;) */

  00499	e9 95 fc ff ff	 jmp	 $LN2@z900_load_
$LN1@z900_load_:

; 279  : 
; 280  : } /* end function load_main */

  0049e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a6	48 33 cc	 xor	 rcx, rsp
  004a9	e8 00 00 00 00	 call	 __security_check_cookie
  004ae	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004b5	c3		 ret	 0
z900_load_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
evd_len$1 = 64
pending_req$2 = 68
scedio_bk$ = 72
tv83 = 80
tv173 = 84
rc$ = 88
scedio_r_bk$ = 96
scedio_v_bk$ = 104
tv219 = 112
sclp_command$ = 160
evd_hdr$ = 168
s390_scedio_request PROC

; 809  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	56		 push	 rsi
  0000a	57		 push	 rdi
  0000b	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 810  : int rc;
; 811  : SCCB_SCEDIO_V_BK* scedio_v_bk;
; 812  : SCCB_SCEDIO_R_BK* scedio_r_bk;
; 813  : SCCB_SCEDIO_BK*   scedio_bk  = (SCCB_SCEDIO_BK*)(evd_hdr + 1);

  00012	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  0001a	48 83 c0 06	 add	 rax, 6
  0001e	48 89 44 24 48	 mov	 QWORD PTR scedio_bk$[rsp], rax

; 814  : 
; 815  : static struct
; 816  : {
; 817  :     SCCB_SCEDIO_BK  scedio_bk;
; 818  :     union
; 819  :     {
; 820  :         SCCB_SCEDIO_V_BK  v;
; 821  :         SCCB_SCEDIO_R_BK  r;
; 822  :     }
; 823  :     io;
; 824  : }
; 825  : static_scedio_bk;
; 826  : 
; 827  : static bool scedio_pending;
; 828  : 
; 829  :     if (sclp_command == SCLP_READ_EVENT_DATA)

  00023	81 bc 24 a0 00
	00 00 05 00 77
	00		 cmp	 DWORD PTR sclp_command$[rsp], 7798789 ; 00770005H
  0002e	0f 85 7c 01 00
	00		 jne	 $LN12@s390_scedi

; 830  :     {
; 831  :         bool pending_req = scedio_pending;

  00034	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?scedio_pending@?1??s390_scedio_request@@9@9
  0003b	88 44 24 44	 mov	 BYTE PTR pending_req$2[rsp], al

; 832  :         U16 evd_len;
; 833  : 
; 834  :         /* Return not-completed if the scedio thread is still active */
; 835  :         if (scedio_tid)

  0003f	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR scedio_tid, 0
  00046	74 07		 je	 SHORT $LN13@s390_scedi

; 836  :         {
; 837  :             return 0;

  00048	33 c0		 xor	 eax, eax
  0004a	e9 01 03 00 00	 jmp	 $LN1@s390_scedi
$LN13@s390_scedi:

; 838  :         }
; 839  : 
; 840  :         /* Was there a preceding I/O request to respond to? */
; 841  :         if (scedio_pending)

  0004f	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?scedio_pending@?1??s390_scedio_request@@9@9
  00056	85 c0		 test	 eax, eax
  00058	0f 84 48 01 00
	00		 je	 $LN14@s390_scedi

; 842  :         {
; 843  :             /* Update the scedio_bk copy in the SCCB... */
; 844  : 
; 845  :             /* Zero all event fields */
; 846  :             memset( evd_hdr, 0, sizeof( SCCB_EVD_HDR ));

  0005e	48 8b bc 24 a8
	00 00 00	 mov	 rdi, QWORD PTR evd_hdr$[rsp]
  00066	33 c0		 xor	 eax, eax
  00068	b9 06 00 00 00	 mov	 ecx, 6
  0006d	f3 aa		 rep stosb

; 847  : 
; 848  :             /* Set type in event header */
; 849  :             evd_hdr->type = SCCB_EVD_TYPE_SCEDIO;

  0006f	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00077	c6 40 02 07	 mov	 BYTE PTR [rax+2], 7

; 850  : 
; 851  :             /* Store copy of original saved SCEDIO header */
; 852  :             memcpy( scedio_bk, &static_scedio_bk.scedio_bk, sizeof( SCCB_SCEDIO_BK ));

  0007b	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00080	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?static_scedio_bk@?1??s390_scedio_request@@9@9
  00086	89 08		 mov	 DWORD PTR [rax], ecx

; 853  : 
; 854  :             /* Calculate event response length */
; 855  :             evd_len = sizeof( SCCB_EVD_HDR ) + sizeof( SCCB_SCEDIO_BK );

  00088	b8 0a 00 00 00	 mov	 eax, 10
  0008d	66 89 44 24 40	 mov	 WORD PTR evd_len$1[rsp], ax

; 856  : 
; 857  :             switch (scedio_bk->flag1)

  00092	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00097	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0009b	88 44 24 50	 mov	 BYTE PTR tv83[rsp], al
  0009f	80 7c 24 50 03	 cmp	 BYTE PTR tv83[rsp], 3
  000a4	74 09		 je	 SHORT $LN15@s390_scedi
  000a6	80 7c 24 50 04	 cmp	 BYTE PTR tv83[rsp], 4
  000ab	74 39		 je	 SHORT $LN16@s390_scedi
  000ad	eb 6d		 jmp	 SHORT $LN17@s390_scedi
$LN15@s390_scedi:

; 858  :             {
; 859  :             case SCCB_SCEDIO_FLG1_IOR:
; 860  : 
; 861  :                 scedio_r_bk = (SCCB_SCEDIO_R_BK*)(scedio_bk + 1);

  000af	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000b4	48 83 c0 04	 add	 rax, 4
  000b8	48 89 44 24 60	 mov	 QWORD PTR scedio_r_bk$[rsp], rax

; 862  :                 memcpy( scedio_r_bk, &static_scedio_bk.io.r, sizeof( SCCB_SCEDIO_R_BK ));

  000bd	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??s390_scedio_request@@9@9+4
  000c4	48 8b 7c 24 60	 mov	 rdi, QWORD PTR scedio_r_bk$[rsp]
  000c9	48 8b f0	 mov	 rsi, rax
  000cc	b9 18 00 00 00	 mov	 ecx, 24
  000d1	f3 a4		 rep movsb

; 863  :                 evd_len += sizeof( SCCB_SCEDIO_R_BK );

  000d3	0f b7 44 24 40	 movzx	 eax, WORD PTR evd_len$1[rsp]
  000d8	48 83 c0 18	 add	 rax, 24
  000dc	66 89 44 24 40	 mov	 WORD PTR evd_len$1[rsp], ax

; 864  :                 break;

  000e1	e9 9f 00 00 00	 jmp	 $LN2@s390_scedi
$LN16@s390_scedi:

; 865  : 
; 866  :             case SCCB_SCEDIO_FLG1_IOV:
; 867  : 
; 868  :                 scedio_v_bk = (SCCB_SCEDIO_V_BK*)(scedio_bk + 1);

  000e6	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000eb	48 83 c0 04	 add	 rax, 4
  000ef	48 89 44 24 68	 mov	 QWORD PTR scedio_v_bk$[rsp], rax

; 869  :                 memcpy( scedio_v_bk, &static_scedio_bk.io.v, sizeof( SCCB_SCEDIO_V_BK ));

  000f4	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??s390_scedio_request@@9@9+4
  000fb	48 8b 7c 24 68	 mov	 rdi, QWORD PTR scedio_v_bk$[rsp]
  00100	48 8b f0	 mov	 rsi, rax
  00103	b9 34 01 00 00	 mov	 ecx, 308		; 00000134H
  00108	f3 a4		 rep movsb

; 870  :                 evd_len += sizeof( SCCB_SCEDIO_V_BK );

  0010a	0f b7 44 24 40	 movzx	 eax, WORD PTR evd_len$1[rsp]
  0010f	48 05 34 01 00
	00		 add	 rax, 308		; 00000134H
  00115	66 89 44 24 40	 mov	 WORD PTR evd_len$1[rsp], ax

; 871  :                 break;

  0011a	eb 69		 jmp	 SHORT $LN2@s390_scedi
$LN17@s390_scedi:
$LN6@s390_scedi:

; 872  : 
; 873  :             default:
; 874  :                 PTT_ERR("*SERVC",(U32)evd_hdr->type,(U32)scedio_bk->flag1,scedio_bk->flag3);

  0011c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00123	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00126	48 83 e0 10	 and	 rax, 16
  0012a	48 85 c0	 test	 rax, rax
  0012d	74 50		 je	 SHORT $LN18@s390_scedi
  0012f	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00134	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00138	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  0013d	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00141	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  00149	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  0014d	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00156	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0015b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180100
  00162	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00167	44 8b c9	 mov	 r9d, ecx
  0016a	44 8b c2	 mov	 r8d, edx
  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180101
  00174	b9 10 00 00 00	 mov	 ecx, 16
  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN18@s390_scedi:
  0017f	33 c0		 xor	 eax, eax
  00181	85 c0		 test	 eax, eax
  00183	75 97		 jne	 SHORT $LN6@s390_scedi
$LN2@s390_scedi:

; 875  :             }
; 876  : 
; 877  :             /* Set length in event header */
; 878  :             STORE_HW( evd_hdr->totlen, evd_len );

  00185	0f b7 4c 24 40	 movzx	 ecx, WORD PTR evd_len$1[rsp]
  0018a	e8 00 00 00 00	 call	 _byteswap_ushort
  0018f	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00197	0f b7 d0	 movzx	 edx, ax
  0019a	e8 00 00 00 00	 call	 store_hw_noswap

; 879  : 
; 880  :             /* Indicate I/O request no longer active */
; 881  :             scedio_pending = false;

  0019f	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?scedio_pending@?1??s390_scedio_request@@9@9, 0
$LN14@s390_scedi:

; 882  :         }
; 883  : 
; 884  :         /* Return true if a request was pending */
; 885  :         return pending_req;

  001a6	0f b6 44 24 44	 movzx	 eax, BYTE PTR pending_req$2[rsp]
  001ab	e9 a0 01 00 00	 jmp	 $LN1@s390_scedi
$LN12@s390_scedi:

; 886  :     }
; 887  : 
; 888  :     // else... 'SCLP_WRITE_EVENT_DATA' or 'SCLP_WRITE_EVENT_MASK'
; 889  : 
; 890  :     /* Save copy of original dasd I/O header */
; 891  :     memcpy( &static_scedio_bk.scedio_bk, scedio_bk, sizeof( SCCB_SCEDIO_BK ));

  001b0	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  001b5	8b 00		 mov	 eax, DWORD PTR [rax]
  001b7	89 05 00 00 00
	00		 mov	 DWORD PTR ?static_scedio_bk@?1??s390_scedio_request@@9@9, eax

; 892  : 
; 893  :     switch (scedio_bk->flag1)

  001bd	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  001c2	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001c6	88 44 24 54	 mov	 BYTE PTR tv173[rsp], al
  001ca	80 7c 24 54 03	 cmp	 BYTE PTR tv173[rsp], 3
  001cf	74 09		 je	 SHORT $LN19@s390_scedi
  001d1	80 7c 24 54 04	 cmp	 BYTE PTR tv173[rsp], 4
  001d6	74 2b		 je	 SHORT $LN20@s390_scedi
  001d8	eb 4f		 jmp	 SHORT $LN21@s390_scedi
$LN19@s390_scedi:

; 894  :     {
; 895  :     case SCCB_SCEDIO_FLG1_IOR:
; 896  : 
; 897  :         /* Save copy of original dasd I/O block */
; 898  :         scedio_r_bk = (SCCB_SCEDIO_R_BK*)(scedio_bk + 1);

  001da	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  001df	48 83 c0 04	 add	 rax, 4
  001e3	48 89 44 24 60	 mov	 QWORD PTR scedio_r_bk$[rsp], rax

; 899  :         memcpy( &static_scedio_bk.io.r, scedio_r_bk, sizeof( SCCB_SCEDIO_R_BK ));

  001e8	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??s390_scedio_request@@9@9+4
  001ef	48 8b f8	 mov	 rdi, rax
  001f2	48 8b 74 24 60	 mov	 rsi, QWORD PTR scedio_r_bk$[rsp]
  001f7	b9 18 00 00 00	 mov	 ecx, 24
  001fc	f3 a4		 rep movsb

; 900  :         break;

  001fe	e9 8f 00 00 00	 jmp	 $LN7@s390_scedi
$LN20@s390_scedi:

; 901  : 
; 902  :     case SCCB_SCEDIO_FLG1_IOV:
; 903  : 
; 904  :         /* Save copy of original dasd I/O block */
; 905  :         scedio_v_bk = (SCCB_SCEDIO_V_BK*)(scedio_bk + 1);

  00203	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00208	48 83 c0 04	 add	 rax, 4
  0020c	48 89 44 24 68	 mov	 QWORD PTR scedio_v_bk$[rsp], rax

; 906  :         memcpy( &static_scedio_bk.io.v, scedio_v_bk, sizeof( SCCB_SCEDIO_V_BK ));

  00211	48 8d 05 04 00
	00 00		 lea	 rax, OFFSET FLAT:?static_scedio_bk@?1??s390_scedio_request@@9@9+4
  00218	48 8b f8	 mov	 rdi, rax
  0021b	48 8b 74 24 68	 mov	 rsi, QWORD PTR scedio_v_bk$[rsp]
  00220	b9 34 01 00 00	 mov	 ecx, 308		; 00000134H
  00225	f3 a4		 rep movsb

; 907  :         break;

  00227	eb 69		 jmp	 SHORT $LN7@s390_scedi
$LN21@s390_scedi:
$LN11@s390_scedi:

; 908  : 
; 909  :     default:
; 910  :         PTT_ERR("*SERVC",(U32)evd_hdr->type,(U32)scedio_bk->flag1,scedio_bk->flag3);

  00229	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  00230	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00233	48 83 e0 10	 and	 rax, 16
  00237	48 85 c0	 test	 rax, rax
  0023a	74 50		 je	 SHORT $LN22@s390_scedi
  0023c	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00241	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00245	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  0024a	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  0024e	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  00256	0f b6 52 02	 movzx	 edx, BYTE PTR [rdx+2]
  0025a	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00263	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00268	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180106
  0026f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00274	44 8b c9	 mov	 r9d, ecx
  00277	44 8b c2	 mov	 r8d, edx
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180107
  00281	b9 10 00 00 00	 mov	 ecx, 16
  00286	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN22@s390_scedi:
  0028c	33 c0		 xor	 eax, eax
  0028e	85 c0		 test	 eax, eax
  00290	75 97		 jne	 SHORT $LN11@s390_scedi
$LN7@s390_scedi:

; 911  :     }
; 912  : 
; 913  :     /* Create the scedio thread */
; 914  :     rc = create_thread( &scedio_tid, &sysblk.detattr,

  00292	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00299	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  0029f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180108
  002a6	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002ab	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180109
  002b2	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  002b7	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?static_scedio_bk@?1??s390_scedio_request@@9@9
  002be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:s390_scedio_thread
  002c5	48 8b d0	 mov	 rdx, rax
  002c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:scedio_tid
  002cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  002d5	89 44 24 58	 mov	 DWORD PTR rc$[rsp], eax

; 915  :         ARCH_DEP( scedio_thread ), &static_scedio_bk, "scedio_thread" );
; 916  : 
; 917  :     if (rc)

  002d9	83 7c 24 58 00	 cmp	 DWORD PTR rc$[rsp], 0
  002de	74 67		 je	 SHORT $LN23@s390_scedi

; 918  :     {
; 919  :         // "Error in function create_thread(): %s"
; 920  :         WRMSG( HHC00102, "E", strerror( rc ));

  002e0	8b 4c 24 58	 mov	 ecx, DWORD PTR rc$[rsp]
  002e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ea	48 89 44 24 70	 mov	 QWORD PTR tv219[rsp], rax
  002ef	b9 01 00 00 00	 mov	 ecx, 1
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002fa	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv219[rsp]
  002ff	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00304	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180111
  0030b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00310	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180112
  00317	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0031c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00321	41 b9 03 00 00
	00		 mov	 r9d, 3
  00327	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG180113
  0032e	ba 98 03 00 00	 mov	 edx, 920		; 00000398H
  00333	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG180114
  0033a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 921  :         return -1;

  00340	b8 ff ff ff ff	 mov	 eax, -1
  00345	eb 09		 jmp	 SHORT $LN1@s390_scedi
$LN23@s390_scedi:

; 922  :     }
; 923  : 
; 924  :     /* Remember an I/O request was started and is now running */
; 925  :     scedio_pending = true;

  00347	c6 05 00 00 00
	00 01		 mov	 BYTE PTR ?scedio_pending@?1??s390_scedio_request@@9@9, 1

; 926  : 
; 927  :     return 0;

  0034e	33 c0		 xor	 eax, eax
$LN1@s390_scedi:

; 928  : }

  00350	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  00357	5f		 pop	 rdi
  00358	5e		 pop	 rsi
  00359	c3		 ret	 0
s390_scedio_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
tv66 = 64
scedio_bk$ = 72
scedio_r_bk$ = 80
scedio_v_bk$ = 88
arg$ = 112
s390_scedio_thread PROC

; 739  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 740  : SCCB_SCEDIO_V_BK* scedio_v_bk;
; 741  : SCCB_SCEDIO_R_BK* scedio_r_bk;
; 742  : SCCB_SCEDIO_BK*   scedio_bk  = (SCCB_SCEDIO_BK*) arg;

  00009	48 8b 44 24 70	 mov	 rax, QWORD PTR arg$[rsp]
  0000e	48 89 44 24 48	 mov	 QWORD PTR scedio_bk$[rsp], rax

; 743  : 
; 744  :     switch (scedio_bk->flag1)

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00018	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0001c	88 44 24 40	 mov	 BYTE PTR tv66[rsp], al
  00020	80 7c 24 40 03	 cmp	 BYTE PTR tv66[rsp], 3
  00025	74 5c		 je	 SHORT $LN12@s390_scedi
  00027	80 7c 24 40 04	 cmp	 BYTE PTR tv66[rsp], 4
  0002c	74 05		 je	 SHORT $LN9@s390_scedi
  0002e	e9 af 00 00 00	 jmp	 $LN15@s390_scedi
$LN9@s390_scedi:

; 745  :     {
; 746  :     case SCCB_SCEDIO_FLG1_IOV:
; 747  : 
; 748  :         scedio_v_bk = (SCCB_SCEDIO_V_BK*)(scedio_bk + 1);

  00033	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00038	48 83 c0 04	 add	 rax, 4
  0003c	48 89 44 24 58	 mov	 QWORD PTR scedio_v_bk$[rsp], rax

; 749  : 
; 750  :         if (ARCH_DEP( scedio_iov )( scedio_v_bk ))

  00041	48 8b 4c 24 58	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  00046	e8 00 00 00 00	 call	 s390_scedio_iov
  0004b	0f b6 c0	 movzx	 eax, al
  0004e	85 c0		 test	 eax, eax
  00050	74 17		 je	 SHORT $LN10@s390_scedi

; 751  :             scedio_bk->flag3 |= SCCB_SCEDIO_FLG3_COMPLETE;

  00052	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00057	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  0005b	0f ba e8 07	 bts	 eax, 7
  0005f	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  00064	88 41 03	 mov	 BYTE PTR [rcx+3], al
  00067	eb 15		 jmp	 SHORT $LN11@s390_scedi
$LN10@s390_scedi:

; 752  :         else
; 753  :             scedio_bk->flag3 &= ~SCCB_SCEDIO_FLG3_COMPLETE;

  00069	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  0006e	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00072	0f ba f0 07	 btr	 eax, 7
  00076	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  0007b	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN11@s390_scedi:

; 754  :         break;

  0007e	e9 c4 00 00 00	 jmp	 $LN2@s390_scedi
$LN12@s390_scedi:

; 755  : 
; 756  :     case SCCB_SCEDIO_FLG1_IOR:
; 757  : 
; 758  :         scedio_r_bk = (SCCB_SCEDIO_R_BK*)(scedio_bk + 1);

  00083	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  00088	48 83 c0 04	 add	 rax, 4
  0008c	48 89 44 24 50	 mov	 QWORD PTR scedio_r_bk$[rsp], rax

; 759  : 
; 760  :         if (ARCH_DEP( scedio_ior )( scedio_r_bk ))

  00091	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  00096	e8 00 00 00 00	 call	 s390_scedio_ior
  0009b	0f b6 c0	 movzx	 eax, al
  0009e	85 c0		 test	 eax, eax
  000a0	74 29		 je	 SHORT $LN13@s390_scedi

; 761  :         {
; 762  :             /* Indicate what SCE dasd file we finished reading? */
; 763  :             memcpy( scedio_r_bk->imageout, scedio_r_bk->imagein, SCCB_SCEDIO_R_IMAGE_LEN );

  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR scedio_r_bk$[rsp]
  000a7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  000ac	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000b0	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 764  :             scedio_bk->flag3 |= SCCB_SCEDIO_FLG3_COMPLETE;

  000b4	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000b9	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000bd	0f ba e8 07	 bts	 eax, 7
  000c1	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  000c6	88 41 03	 mov	 BYTE PTR [rcx+3], al

; 765  :         }

  000c9	eb 15		 jmp	 SHORT $LN14@s390_scedi
$LN13@s390_scedi:

; 766  :         else
; 767  :             scedio_bk->flag3 &= ~SCCB_SCEDIO_FLG3_COMPLETE;

  000cb	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000d0	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000d4	0f ba f0 07	 btr	 eax, 7
  000d8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  000dd	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN14@s390_scedi:

; 768  :         break;

  000e0	eb 65		 jmp	 SHORT $LN2@s390_scedi
$LN15@s390_scedi:
$LN6@s390_scedi:

; 769  : 
; 770  :     default:
; 771  :         PTT_ERR("*SERVC", (U32)scedio_bk->flag0, (U32)scedio_bk->flag1, scedio_bk->flag3 );

  000e2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  000e9	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ec	48 83 e0 10	 and	 rax, 16
  000f0	48 85 c0	 test	 rax, rax
  000f3	74 4c		 je	 SHORT $LN16@s390_scedi
  000f5	48 8b 44 24 48	 mov	 rax, QWORD PTR scedio_bk$[rsp]
  000fa	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000fe	48 8b 4c 24 48	 mov	 rcx, QWORD PTR scedio_bk$[rsp]
  00103	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  00107	48 8b 54 24 48	 mov	 rdx, QWORD PTR scedio_bk$[rsp]
  0010c	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  0010f	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  00118	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG180023
  00124	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00129	44 8b c9	 mov	 r9d, ecx
  0012c	44 8b c2	 mov	 r8d, edx
  0012f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180024
  00136	b9 10 00 00 00	 mov	 ecx, 16
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN16@s390_scedi:
  00141	33 c0		 xor	 eax, eax
  00143	85 c0		 test	 eax, eax
  00145	75 9b		 jne	 SHORT $LN6@s390_scedi
$LN2@s390_scedi:

; 772  :     }
; 773  : 
; 774  :     OBTAIN_INTLOCK( NULL );

  00147	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180025
  0014e	33 c9		 xor	 ecx, ecx
  00150	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock
$LN7@s390_scedi:

; 775  :     {
; 776  :         while (IS_IC_SERVSIG)

  00155	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0015c	8b 80 a0 12 00
	00		 mov	 eax, DWORD PTR [rax+4768]
  00162	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00167	85 c0		 test	 eax, eax
  00169	74 24		 je	 SHORT $LN8@s390_scedi

; 777  :         {
; 778  :             RELEASE_INTLOCK( NULL );

  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180026
  00172	33 c9		 xor	 ecx, ecx
  00174	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 779  :             {
; 780  :                 sched_yield();

  00179	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sched_yield

; 781  :             }
; 782  :             OBTAIN_INTLOCK( NULL );

  0017f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180027
  00186	33 c9		 xor	 ecx, ecx
  00188	e8 00 00 00 00	 call	 Obtain_Interrupt_Lock

; 783  :         }

  0018d	eb c6		 jmp	 SHORT $LN7@s390_scedi
$LN8@s390_scedi:

; 784  : 
; 785  :         sclp_attention( SCCB_EVD_TYPE_SCEDIO );

  0018f	66 b9 07 00	 mov	 cx, 7
  00193	e8 00 00 00 00	 call	 sclp_attention

; 786  :         scedio_tid = 0;

  00198	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR scedio_tid, 0

; 787  :     }
; 788  :     RELEASE_INTLOCK( NULL );

  001a2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG180028
  001a9	33 c9		 xor	 ecx, ecx
  001ab	e8 00 00 00 00	 call	 Release_Interrupt_Lock

; 789  :     return NULL;

  001b0	33 c0		 xor	 eax, eax

; 790  : }

  001b2	48 83 c4 68	 add	 rsp, 104		; 00000068H
  001b6	c3		 ret	 0
s390_scedio_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
tv66 = 80
tv200 = 84
totread$ = 88
length$ = 96
sto$ = 104
seek$ = 112
totwrite$ = 120
tv74 = 128
tv165 = 136
fname$ = 144
__$ArrayPad$ = 416
scedio_v_bk$ = 448
s390_scedio_iov PROC

; 656  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 657  : S64     seek;
; 658  : S64     length;
; 659  : S64     totread, totwrite;
; 660  : U64     sto;
; 661  : char    fname[MAX_PATH];
; 662  : 
; 663  :     switch (scedio_v_bk->type)

  0001e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00026	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00029	88 44 24 50	 mov	 BYTE PTR tv66[rsp], al
  0002d	80 7c 24 50 00	 cmp	 BYTE PTR tv66[rsp], 0
  00032	74 22		 je	 SHORT $LN7@s390_scedi
  00034	80 7c 24 50 01	 cmp	 BYTE PTR tv66[rsp], 1
  00039	74 22		 je	 SHORT $LN8@s390_scedi
  0003b	80 7c 24 50 02	 cmp	 BYTE PTR tv66[rsp], 2
  00040	0f 84 d3 01 00
	00		 je	 $LN15@s390_scedi
  00046	80 7c 24 50 03	 cmp	 BYTE PTR tv66[rsp], 3
  0004b	0f 84 c8 01 00
	00		 je	 $LN16@s390_scedi
  00051	e9 40 03 00 00	 jmp	 $LN23@s390_scedi
$LN7@s390_scedi:

; 664  :     {
; 665  :     case SCCB_SCEDIOV_TYPE_INIT:
; 666  : 
; 667  :         return true;

  00056	b0 01		 mov	 al, 1
  00058	e9 a9 03 00 00	 jmp	 $LN1@s390_scedi
$LN8@s390_scedi:

; 668  : 
; 669  :     case SCCB_SCEDIOV_TYPE_READ:
; 670  : 
; 671  :         /* Ensure file access is allowed and within specified directory */
; 672  :         if (!check_sce_filepath( (char*)scedio_v_bk->filename, fname ))

  0005d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00065	48 83 c0 34	 add	 rax, 52			; 00000034H
  00069	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR fname$[rsp]
  00071	48 8b c8	 mov	 rcx, rax
  00074	e8 00 00 00 00	 call	 check_sce_filepath
  00079	48 85 c0	 test	 rax, rax
  0007c	0f 85 89 00 00
	00		 jne	 $LN9@s390_scedi

; 673  :         {
; 674  :             if (errno != ENOENT)

  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00088	83 38 02	 cmp	 DWORD PTR [rax], 2
  0008b	74 77		 je	 SHORT $LN10@s390_scedi

; 675  :                 // "SCE file %s: access error: %s"
; 676  :                 WRMSG( HHC00605, "E", fname, strerror( errno ));

  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00093	8b 08		 mov	 ecx, DWORD PTR [rax]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0009b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv74[rsp], rax
  000a3	b9 01 00 00 00	 mov	 ecx, 1
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000ae	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv74[rsp]
  000b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000bb	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  000c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179960
  000cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179961
  000db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  000eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179962
  000f2	ba a4 02 00 00	 mov	 edx, 676		; 000002a4H
  000f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179963
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN10@s390_scedi:

; 677  :             return false;

  00104	32 c0		 xor	 al, al
  00106	e9 fb 02 00 00	 jmp	 $LN1@s390_scedi
$LN9@s390_scedi:

; 678  :         }
; 679  : 
; 680  :         FETCH_DW( sto,    scedio_v_bk->sto );

  0010b	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00113	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  00117	48 8b c8	 mov	 rcx, rax
  0011a	e8 00 00 00 00	 call	 fetch_dw_noswap
  0011f	48 8b c8	 mov	 rcx, rax
  00122	e8 00 00 00 00	 call	 _byteswap_uint64
  00127	48 89 44 24 68	 mov	 QWORD PTR sto$[rsp], rax

; 681  :         FETCH_DW( seek,   scedio_v_bk->seek );

  0012c	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00134	48 83 c0 04	 add	 rax, 4
  00138	48 8b c8	 mov	 rcx, rax
  0013b	e8 00 00 00 00	 call	 fetch_dw_noswap
  00140	48 8b c8	 mov	 rcx, rax
  00143	e8 00 00 00 00	 call	 _byteswap_uint64
  00148	48 89 44 24 70	 mov	 QWORD PTR seek$[rsp], rax

; 682  :         FETCH_DW( length, scedio_v_bk->length );

  0014d	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00155	48 83 c0 14	 add	 rax, 20
  00159	48 8b c8	 mov	 rcx, rax
  0015c	e8 00 00 00 00	 call	 fetch_dw_noswap
  00161	48 8b c8	 mov	 rcx, rax
  00164	e8 00 00 00 00	 call	 _byteswap_uint64
  00169	48 89 44 24 60	 mov	 QWORD PTR length$[rsp], rax

; 683  : 
; 684  :         totread = ARCH_DEP( read_file )( fname, sto, seek, length );

  0016e	4c 8b 4c 24 60	 mov	 r9, QWORD PTR length$[rsp]
  00173	4c 8b 44 24 70	 mov	 r8, QWORD PTR seek$[rsp]
  00178	8b 54 24 68	 mov	 edx, DWORD PTR sto$[rsp]
  0017c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  00184	e8 00 00 00 00	 call	 s390_read_file
  00189	48 89 44 24 58	 mov	 QWORD PTR totread$[rsp], rax

; 685  : 
; 686  :         if (totread > 0)

  0018e	48 83 7c 24 58
	00		 cmp	 QWORD PTR totread$[rsp], 0
  00194	7e 7c		 jle	 SHORT $LN11@s390_scedi

; 687  :         {
; 688  :             STORE_DW( scedio_v_bk->length, totread );

  00196	48 8b 4c 24 58	 mov	 rcx, QWORD PTR totread$[rsp]
  0019b	e8 00 00 00 00	 call	 _byteswap_uint64
  001a0	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  001a8	48 83 c1 14	 add	 rcx, 20
  001ac	48 8b d0	 mov	 rdx, rax
  001af	e8 00 00 00 00	 call	 store_dw_noswap

; 689  : 
; 690  :             if (totread == length)

  001b4	48 8b 44 24 60	 mov	 rax, QWORD PTR length$[rsp]
  001b9	48 39 44 24 58	 cmp	 QWORD PTR totread$[rsp], rax
  001be	75 1d		 jne	 SHORT $LN13@s390_scedi

; 691  :                 STORE_DW( scedio_v_bk->ncomp, 0 );

  001c0	33 c9		 xor	 ecx, ecx
  001c2	e8 00 00 00 00	 call	 _byteswap_uint64
  001c7	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  001cf	48 83 c1 0c	 add	 rcx, 12
  001d3	48 8b d0	 mov	 rdx, rax
  001d6	e8 00 00 00 00	 call	 store_dw_noswap
  001db	eb 2c		 jmp	 SHORT $LN14@s390_scedi
$LN13@s390_scedi:

; 692  :             else
; 693  :                 STORE_DW( scedio_v_bk->ncomp, seek + totread );

  001dd	48 8b 44 24 58	 mov	 rax, QWORD PTR totread$[rsp]
  001e2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR seek$[rsp]
  001e7	48 03 c8	 add	 rcx, rax
  001ea	48 8b c1	 mov	 rax, rcx
  001ed	48 8b c8	 mov	 rcx, rax
  001f0	e8 00 00 00 00	 call	 _byteswap_uint64
  001f5	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  001fd	48 83 c1 0c	 add	 rcx, 12
  00201	48 8b d0	 mov	 rdx, rax
  00204	e8 00 00 00 00	 call	 store_dw_noswap
$LN14@s390_scedi:

; 694  : 
; 695  :             return true;

  00209	b0 01		 mov	 al, 1
  0020b	e9 f6 01 00 00	 jmp	 $LN1@s390_scedi

; 696  :         }

  00210	eb 07		 jmp	 SHORT $LN12@s390_scedi
$LN11@s390_scedi:

; 697  :         else
; 698  :             return false;

  00212	32 c0		 xor	 al, al
  00214	e9 ed 01 00 00	 jmp	 $LN1@s390_scedi
$LN12@s390_scedi:
$LN15@s390_scedi:
$LN16@s390_scedi:

; 699  : 
; 700  :     case SCCB_SCEDIOV_TYPE_CREATE:
; 701  :     case SCCB_SCEDIOV_TYPE_APPEND:
; 702  : 
; 703  :         /* Ensure file access is allowed and within specified directory */
; 704  :         if (!check_sce_filepath( (char*)scedio_v_bk->filename, fname ))

  00219	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  00221	48 83 c0 34	 add	 rax, 52			; 00000034H
  00225	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR fname$[rsp]
  0022d	48 8b c8	 mov	 rcx, rax
  00230	e8 00 00 00 00	 call	 check_sce_filepath
  00235	48 85 c0	 test	 rax, rax
  00238	0f 85 a4 00 00
	00		 jne	 $LN17@s390_scedi

; 705  :         {
; 706  :             if (errno != ENOENT)

  0023e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00244	83 38 02	 cmp	 DWORD PTR [rax], 2
  00247	74 77		 je	 SHORT $LN18@s390_scedi

; 707  :                 // "SCE file %s: access error: %s"
; 708  :                 WRMSG( HHC00605, "E", fname, strerror( errno ));

  00249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0024f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00251	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00257	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
  0025f	b9 01 00 00 00	 mov	 ecx, 1
  00264	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0026a	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv165[rsp]
  00272	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00277	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  0027f	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00284	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179972
  0028b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00290	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179973
  00297	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a1	41 b9 03 00 00
	00		 mov	 r9d, 3
  002a7	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179974
  002ae	ba c4 02 00 00	 mov	 edx, 708		; 000002c4H
  002b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179975
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN18@s390_scedi:

; 709  : 
; 710  :             /* A file not found error may be expected for a create request */
; 711  :             if (!(errno == ENOENT && scedio_v_bk->type == SCCB_SCEDIOV_TYPE_CREATE))

  002c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002c6	83 38 02	 cmp	 DWORD PTR [rax], 2
  002c9	75 10		 jne	 SHORT $LN20@s390_scedi
  002cb	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  002d3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002d6	83 f8 02	 cmp	 eax, 2
  002d9	74 07		 je	 SHORT $LN19@s390_scedi
$LN20@s390_scedi:

; 712  :                 return false;

  002db	32 c0		 xor	 al, al
  002dd	e9 24 01 00 00	 jmp	 $LN1@s390_scedi
$LN19@s390_scedi:
$LN17@s390_scedi:

; 713  :         }
; 714  : 
; 715  :         FETCH_DW( sto,    scedio_v_bk->sto );

  002e2	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  002ea	48 83 c0 2c	 add	 rax, 44			; 0000002cH
  002ee	48 8b c8	 mov	 rcx, rax
  002f1	e8 00 00 00 00	 call	 fetch_dw_noswap
  002f6	48 8b c8	 mov	 rcx, rax
  002f9	e8 00 00 00 00	 call	 _byteswap_uint64
  002fe	48 89 44 24 68	 mov	 QWORD PTR sto$[rsp], rax

; 716  :         FETCH_DW( length, scedio_v_bk->length );

  00303	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  0030b	48 83 c0 14	 add	 rax, 20
  0030f	48 8b c8	 mov	 rcx, rax
  00312	e8 00 00 00 00	 call	 fetch_dw_noswap
  00317	48 8b c8	 mov	 rcx, rax
  0031a	e8 00 00 00 00	 call	 _byteswap_uint64
  0031f	48 89 44 24 60	 mov	 QWORD PTR length$[rsp], rax

; 717  : 
; 718  :         totwrite = ARCH_DEP( write_file ) (fname,

  00324	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  0032c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0032f	83 f8 02	 cmp	 eax, 2
  00332	75 0a		 jne	 SHORT $LN26@s390_scedi
  00334	c7 44 24 54 00
	03 00 00	 mov	 DWORD PTR tv200[rsp], 768 ; 00000300H
  0033c	eb 08		 jmp	 SHORT $LN27@s390_scedi
$LN26@s390_scedi:
  0033e	c7 44 24 54 08
	00 00 00	 mov	 DWORD PTR tv200[rsp], 8
$LN27@s390_scedi:
  00346	4c 8b 4c 24 60	 mov	 r9, QWORD PTR length$[rsp]
  0034b	44 8b 44 24 68	 mov	 r8d, DWORD PTR sto$[rsp]
  00350	8b 54 24 54	 mov	 edx, DWORD PTR tv200[rsp]
  00354	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR fname$[rsp]
  0035c	e8 00 00 00 00	 call	 s390_write_file
  00361	48 89 44 24 78	 mov	 QWORD PTR totwrite$[rsp], rax

; 719  :             scedio_v_bk->type == SCCB_SCEDIOV_TYPE_CREATE ? (O_CREAT | O_TRUNC) : O_APPEND, sto, length );
; 720  : 
; 721  :         if(totwrite >= 0)

  00366	48 83 7c 24 78
	00		 cmp	 QWORD PTR totwrite$[rsp], 0
  0036c	7c 24		 jl	 SHORT $LN21@s390_scedi

; 722  :         {
; 723  :             STORE_DW( scedio_v_bk->ncomp, totwrite );

  0036e	48 8b 4c 24 78	 mov	 rcx, QWORD PTR totwrite$[rsp]
  00373	e8 00 00 00 00	 call	 _byteswap_uint64
  00378	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  00380	48 83 c1 0c	 add	 rcx, 12
  00384	48 8b d0	 mov	 rdx, rax
  00387	e8 00 00 00 00	 call	 store_dw_noswap

; 724  :             return true;

  0038c	b0 01		 mov	 al, 1
  0038e	eb 76		 jmp	 SHORT $LN1@s390_scedi

; 725  :         }

  00390	eb 04		 jmp	 SHORT $LN22@s390_scedi
$LN21@s390_scedi:

; 726  :         else
; 727  :             return false;

  00392	32 c0		 xor	 al, al
  00394	eb 70		 jmp	 SHORT $LN1@s390_scedi
$LN22@s390_scedi:
$LN23@s390_scedi:
$LN6@s390_scedi:

; 728  : 
; 729  :     default:
; 730  :         PTT_ERR("*SERVC", (U32)scedio_v_bk->type, (U32)scedio_v_bk->flag1, scedio_v_bk->flag2 );

  00396	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_pttclass
  0039d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  003a0	48 83 e0 10	 and	 rax, 16
  003a4	48 85 c0	 test	 rax, rax
  003a7	74 55		 je	 SHORT $LN24@s390_scedi
  003a9	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_v_bk$[rsp]
  003b1	0f b6 40 02	 movzx	 eax, BYTE PTR [rax+2]
  003b5	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_v_bk$[rsp]
  003bd	0f b6 49 01	 movzx	 ecx, BYTE PTR [rcx+1]
  003c1	48 8b 94 24 c0
	01 00 00	 mov	 rdx, QWORD PTR scedio_v_bk$[rsp]
  003c9	0f b6 12	 movzx	 edx, BYTE PTR [rdx]
  003cc	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  003d5	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  003da	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179982
  003e1	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003e6	44 8b c9	 mov	 r9d, ecx
  003e9	44 8b c2	 mov	 r8d, edx
  003ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179983
  003f3	b9 10 00 00 00	 mov	 ecx, 16
  003f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ptt_pthread_trace
$LN24@s390_scedi:
  003fe	33 c0		 xor	 eax, eax
  00400	85 c0		 test	 eax, eax
  00402	75 92		 jne	 SHORT $LN6@s390_scedi

; 731  :         return false;

  00404	32 c0		 xor	 al, al
$LN1@s390_scedi:

; 732  :     }
; 733  : }

  00406	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0040e	48 33 cc	 xor	 rcx, rsp
  00411	e8 00 00 00 00	 call	 __security_check_cookie
  00416	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  0041d	c3		 ret	 0
s390_scedio_iov ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
success$ = 80
i$ = 84
tv150 = 88
tv152 = 92
origin$ = 96
$T1 = 104
tv128 = 112
image$ = 120
filename$ = 144
__$ArrayPad$ = 416
scedio_r_bk$ = 448
s390_scedio_ior PROC

; 618  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec b8 01
	00 00		 sub	 rsp, 440		; 000001b8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 a0
	01 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 619  : U32           origin;
; 620  : char          image[9];
; 621  : unsigned int  i;
; 622  : char          filename[MAX_PATH];
; 623  : bool          success;
; 624  : 
; 625  : static const bool noisy =
; 626  : #if defined(_DEBUG) || defined(DEBUG)
; 627  :     true;
; 628  : #else
; 629  :     false;
; 630  : #endif
; 631  : 
; 632  :     FETCH_FW( origin, scedio_r_bk->origin );

  0001e	48 8b 84 24 c0
	01 00 00	 mov	 rax, QWORD PTR scedio_r_bk$[rsp]
  00026	48 83 c0 04	 add	 rax, 4
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00032	8b c8		 mov	 ecx, eax
  00034	e8 00 00 00 00	 call	 _byteswap_ulong
  00039	89 44 24 60	 mov	 DWORD PTR origin$[rsp], eax

; 633  : 
; 634  :     /* Convert image filename to null terminated ascii string */
; 635  :     for (i=0; i < sizeof( image ) - 1 && scedio_r_bk->imagein[i] != 0x40; i++)

  0003d	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR i$[rsp], 0
  00045	eb 0a		 jmp	 SHORT $LN4@s390_scedi
$LN2@s390_scedi:
  00047	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0004b	ff c0		 inc	 eax
  0004d	89 44 24 54	 mov	 DWORD PTR i$[rsp], eax
$LN4@s390_scedi:
  00051	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00055	48 83 f8 08	 cmp	 rax, 8
  00059	73 37		 jae	 SHORT $LN3@s390_scedi
  0005b	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  0005f	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  00067	0f b6 44 01 10	 movzx	 eax, BYTE PTR [rcx+rax+16]
  0006c	83 f8 40	 cmp	 eax, 64			; 00000040H
  0006f	74 21		 je	 SHORT $LN3@s390_scedi

; 636  :         image[i] = guest_to_host( (int)  scedio_r_bk->imagein[i]);

  00071	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00075	48 8b 8c 24 c0
	01 00 00	 mov	 rcx, QWORD PTR scedio_r_bk$[rsp]
  0007d	0f b6 4c 01 10	 movzx	 ecx, BYTE PTR [rcx+rax+16]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_guest_to_host
  00088	8b 4c 24 54	 mov	 ecx, DWORD PTR i$[rsp]
  0008c	88 44 0c 78	 mov	 BYTE PTR image$[rsp+rcx], al
  00090	eb b5		 jmp	 SHORT $LN2@s390_scedi
$LN3@s390_scedi:

; 637  :     image[i] = '\0';

  00092	8b 44 24 54	 mov	 eax, DWORD PTR i$[rsp]
  00096	48 89 44 24 68	 mov	 QWORD PTR $T1[rsp], rax
  0009b	48 83 7c 24 68
	09		 cmp	 QWORD PTR $T1[rsp], 9
  000a1	73 02		 jae	 SHORT $LN8@s390_scedi
  000a3	eb 05		 jmp	 SHORT $LN9@s390_scedi
$LN8@s390_scedi:
  000a5	e8 00 00 00 00	 call	 __report_rangecheckfailure
$LN9@s390_scedi:
  000aa	48 8b 44 24 68	 mov	 rax, QWORD PTR $T1[rsp]
  000af	c6 44 04 78 00	 mov	 BYTE PTR image$[rsp+rax], 0

; 638  : 
; 639  :     /* Ensure file access is allowed and within specified directory */
; 640  :     if (!check_sce_filepath( image, filename ))

  000b4	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  000bc	48 8d 4c 24 78	 lea	 rcx, QWORD PTR image$[rsp]
  000c1	e8 00 00 00 00	 call	 check_sce_filepath
  000c6	48 85 c0	 test	 rax, rax
  000c9	0f 85 8a 00 00
	00		 jne	 $LN5@s390_scedi

; 641  :     {
; 642  :         if (errno != ENOENT)

  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d5	83 38 02	 cmp	 DWORD PTR [rax], 2
  000d8	74 7b		 je	 SHORT $LN6@s390_scedi

; 643  :             // "SCE file %s: access error on image %s: %s"
; 644  :             WRMSG( HHC00604, "E", filename, image, strerror( errno ));

  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e0	8b 08		 mov	 ecx, DWORD PTR [rax]
  000e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000e8	48 89 44 24 70	 mov	 QWORD PTR tv128[rsp], rax
  000ed	b9 01 00 00 00	 mov	 ecx, 1
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000f8	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv128[rsp]
  000fd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00102	48 8d 4c 24 78	 lea	 rcx, QWORD PTR image$[rsp]
  00107	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0010c	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00114	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179927
  00120	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00125	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179928
  0012c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00131	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00136	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179929
  00143	ba 84 02 00 00	 mov	 edx, 644		; 00000284H
  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179930
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@s390_scedi:

; 645  :         return false;

  00155	32 c0		 xor	 al, al
  00157	eb 5a		 jmp	 SHORT $LN1@s390_scedi
$LN5@s390_scedi:

; 646  :     }
; 647  : 
; 648  :     success = ARCH_DEP( load_main )( filename, origin, noisy ) == 0;

  00159	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?noisy@?1??s390_scedio_ior@@9@9
  00160	8b 4c 24 60	 mov	 ecx, DWORD PTR origin$[rsp]
  00164	44 8b c0	 mov	 r8d, eax
  00167	8b d1		 mov	 edx, ecx
  00169	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00171	e8 00 00 00 00	 call	 s390_load_main
  00176	85 c0		 test	 eax, eax
  00178	75 0a		 jne	 SHORT $LN10@s390_scedi
  0017a	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv150[rsp], 1
  00182	eb 08		 jmp	 SHORT $LN11@s390_scedi
$LN10@s390_scedi:
  00184	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN11@s390_scedi:
  0018c	83 7c 24 58 00	 cmp	 DWORD PTR tv150[rsp], 0
  00191	75 0a		 jne	 SHORT $LN12@s390_scedi
  00193	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
  0019b	eb 08		 jmp	 SHORT $LN13@s390_scedi
$LN12@s390_scedi:
  0019d	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv152[rsp], 1
$LN13@s390_scedi:
  001a5	0f b6 44 24 5c	 movzx	 eax, BYTE PTR tv152[rsp]
  001aa	88 44 24 50	 mov	 BYTE PTR success$[rsp], al

; 649  :     return success;

  001ae	0f b6 44 24 50	 movzx	 eax, BYTE PTR success$[rsp]
$LN1@s390_scedi:
$LN7@s390_scedi:

; 650  : }

  001b3	48 8b 8c 24 a0
	01 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bb	48 33 cc	 xor	 rcx, rsp
  001be	e8 00 00 00 00	 call	 __security_check_cookie
  001c3	48 81 c4 b8 01
	00 00		 add	 rsp, 440		; 000001b8H
  001ca	c3		 ret	 0
s390_scedio_ior ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
pto$1 = 80
pgo$2 = 84
fd$ = 88
pti$3 = 92
nread$ = 96
totread$ = 104
tv70 = 112
ste$4 = 120
pte$5 = 128
page$6 = 136
fname$ = 160
sto$ = 168
seek$ = 176
size$ = 184
s390_read_file PROC

; 513  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 514  : int  fd, nread;
; 515  : U64  totread = 0;

  0001a	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR totread$[rsp], 0

; 516  : 
; 517  :     fd = HOPEN( fname, O_RDONLY | O_BINARY );

  00023	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00028	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00036	89 44 24 58	 mov	 DWORD PTR fd$[rsp], eax

; 518  : 
; 519  :     if (fd < 0)

  0003a	83 7c 24 58 00	 cmp	 DWORD PTR fd$[rsp], 0
  0003f	0f 8d 94 00 00
	00		 jge	 $LN8@s390_read_

; 520  :     {
; 521  :         if (errno != ENOENT)

  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004b	83 38 02	 cmp	 DWORD PTR [rax], 2
  0004e	74 7d		 je	 SHORT $LN9@s390_read_

; 522  :             // "SCE file %s: error in function %s: %s"
; 523  :             WRMSG( HHC00600, "E", fname, "open()", strerror( errno ));

  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00056	8b 08		 mov	 ecx, DWORD PTR [rax]
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0005e	48 89 44 24 70	 mov	 QWORD PTR tv70[rsp], rax
  00063	b9 01 00 00 00	 mov	 ecx, 1
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0006e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv70[rsp]
  00073	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00078	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179897
  0007f	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00084	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0008c	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00091	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179898
  00098	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0009d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179899
  000a4	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000a9	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000ae	41 b9 03 00 00
	00		 mov	 r9d, 3
  000b4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179900
  000bb	ba 0b 02 00 00	 mov	 edx, 523		; 0000020bH
  000c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179901
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@s390_read_:

; 524  :         return -1;

  000cd	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000d4	e9 36 02 00 00	 jmp	 $LN1@s390_read_
$LN8@s390_read_:

; 525  :     }
; 526  : 
; 527  :     if (lseek( fd, (off_t)seek, SEEK_SET ) == (off_t) seek)

  000d9	45 33 c0	 xor	 r8d, r8d
  000dc	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR seek$[rsp]
  000e4	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__lseeki64
  000ee	48 3b 84 24 b0
	00 00 00	 cmp	 rax, QWORD PTR seek$[rsp]
  000f6	0f 85 04 02 00
	00		 jne	 $LN10@s390_read_

; 528  :     {
; 529  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 530  :         sto &= ASCE_TO;
; 531  : #else
; 532  :         sto &= STD_STO;

  000fc	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  00103	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  00108	89 84 24 a8 00
	00 00		 mov	 DWORD PTR sto$[rsp], eax

; 533  : #endif
; 534  :         for ( ; size > 0 ; sto += sizeof( sto ))

  0010f	eb 12		 jmp	 SHORT $LN4@s390_read_
$LN2@s390_read_:
  00111	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  00118	48 83 c0 04	 add	 rax, 4
  0011c	89 84 24 a8 00
	00 00		 mov	 DWORD PTR sto$[rsp], eax
$LN4@s390_read_:
  00123	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  0012c	0f 8e ce 01 00
	00		 jle	 $LN3@s390_read_

; 535  :         {
; 536  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 537  :         DBLWRD* ste;
; 538  : #else
; 539  :         FWORD*  ste;
; 540  : #endif
; 541  :         CREG    pto, pti;
; 542  : 
; 543  :             /* Fetch segment table entry and calc Page Table Origin */
; 544  :             if (sto >= sysblk.mainsize)

  00132	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  00139	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00140	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  00147	72 05		 jb	 SHORT $LN11@s390_read_

; 545  :                 goto eof;

  00149	e9 b2 01 00 00	 jmp	 $eof$18
$LN11@s390_read_:

; 546  : 
; 547  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 548  :             ste = (DBLWRD*)(sysblk.mainstor + sto);
; 549  : #else
; 550  :             ste = (FWORD*) (sysblk.mainstor + sto);

  0014e	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  00155	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0015c	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  00163	48 89 44 24 78	 mov	 QWORD PTR ste$4[rsp], rax

; 551  : #endif
; 552  :             FETCH_W( pto, ste );

  00168	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ste$4[rsp]
  0016d	e8 00 00 00 00	 call	 fetch_fw_noswap
  00172	8b c8		 mov	 ecx, eax
  00174	e8 00 00 00 00	 call	 _byteswap_ulong
  00179	89 44 24 50	 mov	 DWORD PTR pto$1[rsp], eax

; 553  :             ARCH_DEP( or_storage_key )( sto, STORKEY_REF );

  0017d	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  00184	b2 04		 mov	 dl, 4
  00186	8b c8		 mov	 ecx, eax
  00188	e8 00 00 00 00	 call	 s390_or_storage_key

; 554  : 
; 555  :             if (pto & SEGTAB_INVALID)

  0018d	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  00191	83 e0 20	 and	 eax, 32			; 00000020H
  00194	85 c0		 test	 eax, eax
  00196	74 05		 je	 SHORT $LN12@s390_read_

; 556  :                 goto eof;

  00198	e9 63 01 00 00	 jmp	 $eof$18
$LN12@s390_read_:

; 557  : 
; 558  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 559  :             pto &= ZSEGTAB_PTO;
; 560  : #else
; 561  :             pto &= SEGTAB_PTO;

  0019d	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  001a1	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  001a6	89 44 24 50	 mov	 DWORD PTR pto$1[rsp], eax

; 562  : #endif
; 563  :             for (pti = 0; pti < 256 && size > 0; pti++, pto += sizeof( pto ))

  001aa	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR pti$3[rsp], 0
  001b2	eb 16		 jmp	 SHORT $LN7@s390_read_
$LN5@s390_read_:
  001b4	8b 44 24 5c	 mov	 eax, DWORD PTR pti$3[rsp]
  001b8	ff c0		 inc	 eax
  001ba	89 44 24 5c	 mov	 DWORD PTR pti$3[rsp], eax
  001be	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  001c2	48 83 c0 04	 add	 rax, 4
  001c6	89 44 24 50	 mov	 DWORD PTR pto$1[rsp], eax
$LN7@s390_read_:
  001ca	81 7c 24 5c 00
	01 00 00	 cmp	 DWORD PTR pti$3[rsp], 256 ; 00000100H
  001d2	0f 83 23 01 00
	00		 jae	 $LN6@s390_read_
  001d8	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  001e1	0f 8e 14 01 00
	00		 jle	 $LN6@s390_read_

; 564  :             {
; 565  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 566  :             DBLWRD* pte;
; 567  : #else
; 568  :             FWORD*  pte;
; 569  : #endif
; 570  :             CREG    pgo;
; 571  :             BYTE*   page;
; 572  : 
; 573  :                 /* Fetch Page Table Entry to get page origin */
; 574  :                 if (pto >= sysblk.mainsize)

  001e7	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  001eb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001f2	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  001f9	72 05		 jb	 SHORT $LN13@s390_read_

; 575  :                     goto eof;

  001fb	e9 00 01 00 00	 jmp	 $eof$18
$LN13@s390_read_:

; 576  : 
; 577  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 578  :                 pte = (DBLWRD*)(sysblk.mainstor + pto );
; 579  : #else
; 580  :                 pte = (FWORD*) (sysblk.mainstor + pto);

  00200	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  00204	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0020b	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  00212	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pte$5[rsp], rax

; 581  : #endif
; 582  :                 FETCH_W( pgo, pte );

  0021a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pte$5[rsp]
  00222	e8 00 00 00 00	 call	 fetch_fw_noswap
  00227	8b c8		 mov	 ecx, eax
  00229	e8 00 00 00 00	 call	 _byteswap_ulong
  0022e	89 44 24 54	 mov	 DWORD PTR pgo$2[rsp], eax

; 583  :                 ARCH_DEP( or_storage_key )( pto, STORKEY_REF );

  00232	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  00236	b2 04		 mov	 dl, 4
  00238	8b c8		 mov	 ecx, eax
  0023a	e8 00 00 00 00	 call	 s390_or_storage_key

; 584  : 
; 585  :                 if (pgo & PAGETAB_INVALID)

  0023f	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  00243	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  00248	85 c0		 test	 eax, eax
  0024a	74 05		 je	 SHORT $LN14@s390_read_

; 586  :                     goto eof;

  0024c	e9 af 00 00 00	 jmp	 $eof$18
$LN14@s390_read_:

; 587  : 
; 588  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 589  :                 pgo &= ZPGETAB_PFRA;
; 590  : #else
; 591  :                 pgo &= PAGETAB_PFRA;

  00251	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  00255	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0025a	89 44 24 54	 mov	 DWORD PTR pgo$2[rsp], eax

; 592  : #endif
; 593  :                 /* Read page into main storage */
; 594  :                 if (pgo >= sysblk.mainsize)

  0025e	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  00262	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00269	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  00270	72 05		 jb	 SHORT $LN15@s390_read_

; 595  :                     goto eof;

  00272	e9 89 00 00 00	 jmp	 $eof$18
$LN15@s390_read_:

; 596  : 
; 597  :                 page = sysblk.mainstor + pgo;

  00277	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  0027b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00282	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  00289	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR page$6[rsp], rax

; 598  :                 nread = read( fd, page, STORAGE_KEY_PAGESIZE );

  00291	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00297	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR page$6[rsp]
  0029f	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  002a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  002a9	89 44 24 60	 mov	 DWORD PTR nread$[rsp], eax

; 599  :                 totread += nread;

  002ad	48 63 44 24 60	 movsxd	 rax, DWORD PTR nread$[rsp]
  002b2	48 8b 4c 24 68	 mov	 rcx, QWORD PTR totread$[rsp]
  002b7	48 03 c8	 add	 rcx, rax
  002ba	48 8b c1	 mov	 rax, rcx
  002bd	48 89 44 24 68	 mov	 QWORD PTR totread$[rsp], rax

; 600  :                 size -= nread;

  002c2	48 63 44 24 60	 movsxd	 rax, DWORD PTR nread$[rsp]
  002c7	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR size$[rsp]
  002cf	48 2b c8	 sub	 rcx, rax
  002d2	48 8b c1	 mov	 rax, rcx
  002d5	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR size$[rsp], rax

; 601  : 
; 602  :                 if (nread != STORAGE_KEY_PAGESIZE)

  002dd	81 7c 24 60 00
	10 00 00	 cmp	 DWORD PTR nread$[rsp], 4096 ; 00001000H
  002e5	74 02		 je	 SHORT $LN16@s390_read_

; 603  :                     goto eof;

  002e7	eb 17		 jmp	 SHORT $eof$18
$LN16@s390_read_:

; 604  : 
; 605  :                 ARCH_DEP( or_storage_key )( pgo, (STORKEY_REF | STORKEY_CHANGE) );

  002e9	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  002ed	b2 06		 mov	 dl, 6
  002ef	8b c8		 mov	 ecx, eax
  002f1	e8 00 00 00 00	 call	 s390_or_storage_key

; 606  :             }

  002f6	e9 b9 fe ff ff	 jmp	 $LN5@s390_read_
$LN6@s390_read_:

; 607  :         }

  002fb	e9 11 fe ff ff	 jmp	 $LN2@s390_read_
$LN3@s390_read_:
$LN10@s390_read_:
$eof$18:

; 608  :     }
; 609  : eof:
; 610  :     close( fd );

  00300	8b 4c 24 58	 mov	 ecx, DWORD PTR fd$[rsp]
  00304	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 611  :     return totread;

  0030a	48 8b 44 24 68	 mov	 rax, QWORD PTR totread$[rsp]
$LN1@s390_read_:

; 612  : }

  0030f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00316	c3		 ret	 0
s390_read_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
pto$1 = 80
pgo$2 = 84
pti$3 = 88
fd$ = 92
nwrite$ = 96
totwrite$ = 104
tv71 = 112
ste$4 = 120
pte$5 = 128
page$6 = 136
fname$ = 160
mode$ = 168
sto$ = 176
size$ = 184
s390_write_file PROC

; 409  : {

  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 410  : int  fd, nwrite;
; 411  : U64  totwrite = 0;

  0001a	48 c7 44 24 68
	00 00 00 00	 mov	 QWORD PTR totwrite$[rsp], 0

; 412  : 
; 413  :     fd = HOPEN( fname, mode | O_WRONLY | O_BINARY,

  00023	8b 84 24 a8 00
	00 00		 mov	 eax, DWORD PTR mode$[rsp]
  0002a	83 c8 01	 or	 eax, 1
  0002d	0f ba e8 0f	 bts	 eax, 15
  00031	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00037	8b d0		 mov	 edx, eax
  00039	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  00047	89 44 24 5c	 mov	 DWORD PTR fd$[rsp], eax

; 414  :             S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH );
; 415  : 
; 416  :     if (fd < 0)

  0004b	83 7c 24 5c 00	 cmp	 DWORD PTR fd$[rsp], 0
  00050	0f 8d 89 00 00
	00		 jge	 $LN8@s390_write

; 417  :     {
; 418  :         // "SCE file %s: error in function %s: %s"
; 419  :         WRMSG( HHC00600, "E", fname, "open()", strerror( errno ));

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005c	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00064	48 89 44 24 70	 mov	 QWORD PTR tv71[rsp], rax
  00069	b9 01 00 00 00	 mov	 ecx, 1
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00074	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv71[rsp]
  00079	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179854
  00085	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0008a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00092	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00097	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179855
  0009e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179856
  000aa	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000af	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000b4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ba	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179857
  000c1	ba a3 01 00 00	 mov	 edx, 419		; 000001a3H
  000c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179858
  000cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 420  :         return -1;

  000d3	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  000da	e9 0d 02 00 00	 jmp	 $LN1@s390_write
$LN8@s390_write:

; 421  :     }
; 422  : 
; 423  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 424  :     sto &= ASCE_TO;
; 425  : #else
; 426  :     sto &= STD_STO;

  000df	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  000e6	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  000eb	89 84 24 b0 00
	00 00		 mov	 DWORD PTR sto$[rsp], eax

; 427  : #endif
; 428  : 
; 429  :     for ( ; size > 0 ; sto += sizeof( sto ))

  000f2	eb 12		 jmp	 SHORT $LN4@s390_write
$LN2@s390_write:
  000f4	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  000fb	48 83 c0 04	 add	 rax, 4
  000ff	89 84 24 b0 00
	00 00		 mov	 DWORD PTR sto$[rsp], eax
$LN4@s390_write:
  00106	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  0010f	0f 8e c8 01 00
	00		 jle	 $LN3@s390_write

; 430  :     {
; 431  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 432  :     DBLWRD* ste;
; 433  : #else
; 434  :     FWORD*  ste;
; 435  : #endif
; 436  :     CREG    pto, pti;
; 437  : 
; 438  :         /* Fetch segment table entry and calc Page Table Origin */
; 439  :         if (sto >= sysblk.mainsize)

  00115	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  0011c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00123	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  0012a	72 05		 jb	 SHORT $LN9@s390_write

; 440  :             goto eof;

  0012c	e9 ac 01 00 00	 jmp	 $eof$16
$LN9@s390_write:

; 441  : 
; 442  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 443  :         ste = (DBLWRD*)(sysblk.mainstor + sto);
; 444  : #else
; 445  :         ste = (FWORD*) (sysblk.mainstor + sto);

  00131	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  00138	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0013f	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  00146	48 89 44 24 78	 mov	 QWORD PTR ste$4[rsp], rax

; 446  : #endif
; 447  :         FETCH_W( pto, ste );

  0014b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR ste$4[rsp]
  00150	e8 00 00 00 00	 call	 fetch_fw_noswap
  00155	8b c8		 mov	 ecx, eax
  00157	e8 00 00 00 00	 call	 _byteswap_ulong
  0015c	89 44 24 50	 mov	 DWORD PTR pto$1[rsp], eax

; 448  :         ARCH_DEP( or_storage_key )( sto, STORKEY_REF );

  00160	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR sto$[rsp]
  00167	b2 04		 mov	 dl, 4
  00169	8b c8		 mov	 ecx, eax
  0016b	e8 00 00 00 00	 call	 s390_or_storage_key

; 449  : 
; 450  :         if (pto & SEGTAB_INVALID)

  00170	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  00174	83 e0 20	 and	 eax, 32			; 00000020H
  00177	85 c0		 test	 eax, eax
  00179	74 05		 je	 SHORT $LN10@s390_write

; 451  :             goto eof;

  0017b	e9 5d 01 00 00	 jmp	 $eof$16
$LN10@s390_write:

; 452  : 
; 453  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 454  :         pto &= ZSEGTAB_PTO;
; 455  : #else
; 456  :         pto &= SEGTAB_PTO;

  00180	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  00184	25 c0 ff ff 7f	 and	 eax, 2147483584		; 7fffffc0H
  00189	89 44 24 50	 mov	 DWORD PTR pto$1[rsp], eax

; 457  : #endif
; 458  :         for (pti = 0; pti < 256 && size > 0; pti++, pto += sizeof( pto ))

  0018d	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR pti$3[rsp], 0
  00195	eb 16		 jmp	 SHORT $LN7@s390_write
$LN5@s390_write:
  00197	8b 44 24 58	 mov	 eax, DWORD PTR pti$3[rsp]
  0019b	ff c0		 inc	 eax
  0019d	89 44 24 58	 mov	 DWORD PTR pti$3[rsp], eax
  001a1	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  001a5	48 83 c0 04	 add	 rax, 4
  001a9	89 44 24 50	 mov	 DWORD PTR pto$1[rsp], eax
$LN7@s390_write:
  001ad	81 7c 24 58 00
	01 00 00	 cmp	 DWORD PTR pti$3[rsp], 256 ; 00000100H
  001b5	0f 83 1d 01 00
	00		 jae	 $LN6@s390_write
  001bb	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR size$[rsp], 0
  001c4	0f 8e 0e 01 00
	00		 jle	 $LN6@s390_write

; 459  :         {
; 460  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 461  :         DBLWRD* pte;
; 462  : #else
; 463  :         FWORD*  pte;
; 464  : #endif
; 465  :         CREG    pgo;
; 466  :         BYTE*   page;
; 467  : 
; 468  :             /* Fetch Page Table Entry to get page origin */
; 469  :             if (pto >= sysblk.mainsize)

  001ca	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  001ce	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001d5	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  001dc	72 05		 jb	 SHORT $LN11@s390_write

; 470  :                 goto eof;

  001de	e9 fa 00 00 00	 jmp	 $eof$16
$LN11@s390_write:

; 471  : 
; 472  : #if defined( FEATURE_001_ZARCH_INSTALLED_FACILITY )
; 473  :             pte = (DBLWRD*)(sysblk.mainstor + pto);
; 474  : #else
; 475  :             pte = (FWORD*) (sysblk.mainstor + pto);

  001e3	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  001e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  001ee	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  001f5	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pte$5[rsp], rax

; 476  : #endif
; 477  :             FETCH_W( pgo, pte );

  001fd	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR pte$5[rsp]
  00205	e8 00 00 00 00	 call	 fetch_fw_noswap
  0020a	8b c8		 mov	 ecx, eax
  0020c	e8 00 00 00 00	 call	 _byteswap_ulong
  00211	89 44 24 54	 mov	 DWORD PTR pgo$2[rsp], eax

; 478  :             ARCH_DEP( or_storage_key )( pto, STORKEY_REF );

  00215	8b 44 24 50	 mov	 eax, DWORD PTR pto$1[rsp]
  00219	b2 04		 mov	 dl, 4
  0021b	8b c8		 mov	 ecx, eax
  0021d	e8 00 00 00 00	 call	 s390_or_storage_key

; 479  : 
; 480  :             if (!(pgo & PAGETAB_INVALID))

  00222	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  00226	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0022b	85 c0		 test	 eax, eax
  0022d	0f 85 8a 00 00
	00		 jne	 $LN12@s390_write

; 481  :             {
; 482  : #if defined(FEATURE_001_ZARCH_INSTALLED_FACILITY)
; 483  :                 pgo &= ZPGETAB_PFRA;
; 484  : #else
; 485  :                 pgo &= PAGETAB_PFRA;

  00233	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  00237	25 00 f0 ff 7f	 and	 eax, 2147479552		; 7ffff000H
  0023c	89 44 24 54	 mov	 DWORD PTR pgo$2[rsp], eax

; 486  : #endif
; 487  :                 /* Write page to SCE disk */
; 488  :                 if (pgo >= sysblk.mainsize)

  00240	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  00244	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0024b	48 3b 81 90 00
	00 00		 cmp	 rax, QWORD PTR [rcx+144]
  00252	72 05		 jb	 SHORT $LN13@s390_write

; 489  :                     goto eof;

  00254	e9 84 00 00 00	 jmp	 $eof$16
$LN13@s390_write:

; 490  : 
; 491  :                 page = sysblk.mainstor + pgo;

  00259	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  0025d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00264	48 03 81 98 00
	00 00		 add	 rax, QWORD PTR [rcx+152]
  0026b	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR page$6[rsp], rax

; 492  :                 nwrite = write( fd, page, STORAGE_KEY_PAGESIZE );

  00273	41 b8 00 10 00
	00		 mov	 r8d, 4096		; 00001000H
  00279	48 8b 94 24 88
	00 00 00	 mov	 rdx, QWORD PTR page$6[rsp]
  00281	8b 4c 24 5c	 mov	 ecx, DWORD PTR fd$[rsp]
  00285	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  0028b	89 44 24 60	 mov	 DWORD PTR nwrite$[rsp], eax

; 493  :                 totwrite += nwrite;

  0028f	48 63 44 24 60	 movsxd	 rax, DWORD PTR nwrite$[rsp]
  00294	48 8b 4c 24 68	 mov	 rcx, QWORD PTR totwrite$[rsp]
  00299	48 03 c8	 add	 rcx, rax
  0029c	48 8b c1	 mov	 rax, rcx
  0029f	48 89 44 24 68	 mov	 QWORD PTR totwrite$[rsp], rax

; 494  : 
; 495  :                 if (nwrite != STORAGE_KEY_PAGESIZE)

  002a4	81 7c 24 60 00
	10 00 00	 cmp	 DWORD PTR nwrite$[rsp], 4096 ; 00001000H
  002ac	74 02		 je	 SHORT $LN14@s390_write

; 496  :                     goto eof;

  002ae	eb 2d		 jmp	 SHORT $eof$16
$LN14@s390_write:

; 497  : 
; 498  :                 ARCH_DEP( or_storage_key )( pgo, STORKEY_REF );

  002b0	8b 44 24 54	 mov	 eax, DWORD PTR pgo$2[rsp]
  002b4	b2 04		 mov	 dl, 4
  002b6	8b c8		 mov	 ecx, eax
  002b8	e8 00 00 00 00	 call	 s390_or_storage_key
$LN12@s390_write:

; 499  :             }
; 500  :             size -= STORAGE_KEY_PAGESIZE;

  002bd	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR size$[rsp]
  002c5	48 2d 00 10 00
	00		 sub	 rax, 4096		; 00001000H
  002cb	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR size$[rsp], rax

; 501  :         }

  002d3	e9 bf fe ff ff	 jmp	 $LN5@s390_write
$LN6@s390_write:

; 502  :     }

  002d8	e9 17 fe ff ff	 jmp	 $LN2@s390_write
$LN3@s390_write:
$eof$16:

; 503  : eof:
; 504  :     close( fd );

  002dd	8b 4c 24 5c	 mov	 ecx, DWORD PTR fd$[rsp]
  002e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 505  :     return totwrite;

  002e7	48 8b 44 24 68	 mov	 rax, QWORD PTR totwrite$[rsp]
$LN1@s390_write:

; 506  : }

  002ec	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  002f3	c3		 ret	 0
s390_write_file ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );
; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s390_or_4K_storage_key

; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s390_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390_or_4K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s390_or_4K_storage_key PROC				; COMDAT

; 242  :   inline void  ARCH_DEP( or_4K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 4 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 04	 mov	 r8b, 4
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s390__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s390_or_4K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s390__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s390__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s390__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s390__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	33 c0		 xor	 eax, eax
  0001a	85 c0		 test	 eax, eax
  0001c	74 50		 je	 SHORT $LN5@s390__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  0001e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00023	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00028	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  0002d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00032	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00037	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  0003c	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00041	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00046	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00049	0b c8		 or	 ecx, eax
  0004b	8b c1		 mov	 eax, ecx
  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00052	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  00054	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00059	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0005e	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00061	0b c8		 or	 ecx, eax
  00063	8b c1		 mov	 eax, ecx
  00065	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  0006a	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  0006c	eb 2c		 jmp	 SHORT $LN6@s390__or_s
$LN5@s390__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  0006e	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  00073	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00078	e8 00 00 00 00	 call	 _get_storekey_ptr
  0007d	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  00082	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00087	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  0008c	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0008f	0b c8		 or	 ecx, eax
  00091	8b c1		 mov	 eax, ecx
  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00098	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s390__or_s:

; 202  :     }
; 203  : }

  0009a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0009e	c3		 ret	 0
s390__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
evd_len$ = 32
sccb_len$ = 36
evd_hdr$ = 40
sccb$ = 64
s390_sclp_scedio_event PROC

; 960  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 961  : SCCB_EVD_HDR*  evd_hdr  = (SCCB_EVD_HDR*)(sccb + 1);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 89 44 24 28	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 962  : U16            evd_len;
; 963  : U16            sccb_len;
; 964  : 
; 965  :     if (ARCH_DEP( scedio_request )( SCLP_READ_EVENT_DATA, evd_hdr ))

  00017	48 8b 54 24 28	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  0001c	b9 05 00 77 00	 mov	 ecx, 7798789		; 00770005H
  00021	e8 00 00 00 00	 call	 s390_scedio_request
  00026	85 c0		 test	 eax, eax
  00028	0f 84 8d 00 00
	00		 je	 $LN2@s390_sclp_

; 966  :     {
; 967  :         // true: an I/O request WAS pending and has now completed
; 968  : 
; 969  :         /* Update SCCB length field if variable request */
; 970  :         if (sccb->type & SCCB_TYPE_VARIABLE)

  0002e	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00033	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00037	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0003c	85 c0		 test	 eax, eax
  0003e	74 54		 je	 SHORT $LN3@s390_sclp_

; 971  :         {
; 972  :             FETCH_HW( evd_len, evd_hdr->totlen );

  00040	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00045	48 8b c8	 mov	 rcx, rax
  00048	e8 00 00 00 00	 call	 fetch_hw_noswap
  0004d	0f b7 c8	 movzx	 ecx, ax
  00050	e8 00 00 00 00	 call	 _byteswap_ushort
  00055	66 89 44 24 20	 mov	 WORD PTR evd_len$[rsp], ax

; 973  :             sccb_len = evd_len + sizeof( SCCB_HEADER );

  0005a	0f b7 44 24 20	 movzx	 eax, WORD PTR evd_len$[rsp]
  0005f	48 83 c0 08	 add	 rax, 8
  00063	66 89 44 24 24	 mov	 WORD PTR sccb_len$[rsp], ax

; 974  :             STORE_HW( sccb->length, sccb_len );

  00068	0f b7 4c 24 24	 movzx	 ecx, WORD PTR sccb_len$[rsp]
  0006d	e8 00 00 00 00	 call	 _byteswap_ushort
  00072	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  00077	0f b7 d0	 movzx	 edx, ax
  0007a	e8 00 00 00 00	 call	 store_hw_noswap

; 975  :             sccb->type &= ~SCCB_TYPE_VARIABLE;

  0007f	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00084	0f b6 40 05	 movzx	 eax, BYTE PTR [rax+5]
  00088	0f ba f0 07	 btr	 eax, 7
  0008c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR sccb$[rsp]
  00091	88 41 05	 mov	 BYTE PTR [rcx+5], al
$LN3@s390_sclp_:

; 976  :         }
; 977  : 
; 978  :         /* Set response code X'0020' in SCCB header */
; 979  :         sccb->reas = SCCB_REAS_NONE;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00099	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 980  :         sccb->resp = SCCB_RESP_COMPLETE;

  0009d	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  000a2	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 981  : 
; 982  :         /* Event read processed and now no events are pending */
; 983  :         evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  000a6	48 8b 44 24 28	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  000ab	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  000af	0f ba e8 07	 bts	 eax, 7
  000b3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  000b8	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN2@s390_sclp_:

; 984  :     }
; 985  : }

  000bb	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000bf	c3		 ret	 0
s390_sclp_scedio_event ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
evd_hdr$ = 32
sccb$ = 64
s390_sclp_scedio_request PROC

; 934  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 935  :     SCCB_EVD_HDR*  evd_hdr  = (SCCB_EVD_HDR*)(sccb + 1);

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0000e	48 83 c0 08	 add	 rax, 8
  00012	48 89 44 24 20	 mov	 QWORD PTR evd_hdr$[rsp], rax

; 936  : 
; 937  :     if (ARCH_DEP( scedio_request )( SCLP_WRITE_EVENT_DATA, evd_hdr ))

  00017	48 8b 54 24 20	 mov	 rdx, QWORD PTR evd_hdr$[rsp]
  0001c	b9 05 00 76 00	 mov	 ecx, 7733253		; 00760005H
  00021	e8 00 00 00 00	 call	 s390_scedio_request
  00026	85 c0		 test	 eax, eax
  00028	74 14		 je	 SHORT $LN2@s390_sclp_

; 938  :     {
; 939  :         // non-zero: error: I/O request NOT started...
; 940  : 
; 941  :         /* Set response code X'0040' in SCCB header */
; 942  :         sccb->reas = SCCB_REAS_NONE;

  0002a	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0002f	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 943  :         sccb->resp = SCCB_RESP_BACKOUT;

  00033	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00038	c6 40 07 40	 mov	 BYTE PTR [rax+7], 64	; 00000040H

; 944  :     }

  0003c	eb 27		 jmp	 SHORT $LN3@s390_sclp_
$LN2@s390_sclp_:

; 945  :     else // zero: I/O request WAS successfully started...
; 946  :     {
; 947  :         /* Set response code X'0020' in SCCB header */
; 948  :         sccb->reas = SCCB_REAS_NONE;

  0003e	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  00043	c6 40 06 00	 mov	 BYTE PTR [rax+6], 0

; 949  :         sccb->resp = SCCB_RESP_COMPLETE;

  00047	48 8b 44 24 40	 mov	 rax, QWORD PTR sccb$[rsp]
  0004c	c6 40 07 20	 mov	 BYTE PTR [rax+7], 32	; 00000020H

; 950  : 
; 951  :         /* Event write processed and event read now pending */
; 952  :         evd_hdr->flag |= SCCB_EVD_FLAG_PROC;

  00050	48 8b 44 24 20	 mov	 rax, QWORD PTR evd_hdr$[rsp]
  00055	0f b6 40 03	 movzx	 eax, BYTE PTR [rax+3]
  00059	0f ba e8 07	 bts	 eax, 7
  0005d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR evd_hdr$[rsp]
  00062	88 41 03	 mov	 BYTE PTR [rcx+3], al
$LN3@s390_sclp_:

; 953  :     }
; 954  : }

  00065	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00069	c3		 ret	 0
s390_sclp_scedio_request ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
rc$ = 80
fileaddr$ = 84
inputline$ = 88
fp$ = 96
regs$ = 104
tv83 = 112
tv133 = 120
tv177 = 128
tv202 = 136
filename$ = 144
pathname$ = 416
inputbuff$ = 688
__$ArrayPad$ = 960
fname$ = 992
cpu$ = 1000
clear$ = 1008
s390_load_hmc PROC

; 304  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec d8 03
	00 00		 sub	 rsp, 984		; 000003d8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 305  : REGS*   regs;                           /* -> Regs                   */
; 306  : FILE*   fp;
; 307  : char    inputbuff[MAX_PATH];
; 308  : char*   inputline;
; 309  : char    filename[MAX_PATH];             /* filename of image file    */
; 310  : char    pathname[MAX_PATH];             /* pathname of image file    */
; 311  : U32     fileaddr;
; 312  : int     rc = 0;                         /* Return codes (work)       */

  00027	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 313  : 
; 314  : static const bool noisy =
; 315  : #if defined(_DEBUG) || defined(DEBUG)
; 316  :     true;
; 317  : #else
; 318  :     false;
; 319  : #endif
; 320  : 
; 321  :     /* Get started */
; 322  :     if (ARCH_DEP( common_load_begin )( cpu, clear ) != 0)

  0002f	8b 94 24 f0 03
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00036	8b 8c 24 e8 03
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0003d	e8 00 00 00 00	 call	 s390_common_load_begin
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN5@s390_load_

; 323  :         return -1;

  00046	b8 ff ff ff ff	 mov	 eax, -1
  0004b	e9 e3 03 00 00	 jmp	 $LN1@s390_load_
$LN5@s390_load_:

; 324  : 
; 325  :     /* The actual IPL proper starts here... */
; 326  : 
; 327  :     regs = sysblk.regs[ cpu ];          /* Point to IPL CPU's regs   */

  00050	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00067	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax

; 328  : 
; 329  :     if (fname == NULL)                  /* Default ipl from DASD     */

  0006c	48 83 bc 24 e0
	03 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  00075	75 0f		 jne	 SHORT $LN6@s390_load_

; 330  :         fname = "HERCULES.ins";         /*   from HERCULES.ins       */

  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG179801
  0007e	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR fname$[rsp], rax
$LN6@s390_load_:

; 331  : 
; 332  :     hostpath( pathname, fname, sizeof( pathname ));

  00086	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0008c	48 8b 94 24 e0
	03 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00094	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 333  : 
; 334  :     if (!(fname = set_sce_basedir( pathname )))

  000a2	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000aa	e8 00 00 00 00	 call	 set_sce_basedir
  000af	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR fname$[rsp], rax
  000b7	48 83 bc 24 e0
	03 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  000c0	75 0a		 jne	 SHORT $LN7@s390_load_

; 335  :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	e9 67 03 00 00	 jmp	 $LN1@s390_load_
$LN7@s390_load_:

; 336  : 
; 337  :     /* Construct and check full pathname */
; 338  :     if (!check_sce_filepath( fname, filename ))

  000cc	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  000d4	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000dc	e8 00 00 00 00	 call	 check_sce_filepath
  000e1	48 85 c0	 test	 rax, rax
  000e4	75 7b		 jne	 SHORT $LN8@s390_load_

; 339  :     {
; 340  :         // "SCE file %s: load from file failed: %s"
; 341  :         WRMSG( HHC00601,"E", fname, strerror( errno ));

  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ec	8b 08		 mov	 ecx, DWORD PTR [rax]
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000f4	48 89 44 24 70	 mov	 QWORD PTR tv83[rsp], rax
  000f9	b9 01 00 00 00	 mov	 ecx, 1
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00104	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv83[rsp]
  00109	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0010e	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00116	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179804
  00122	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179805
  0012e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00133	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00138	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179806
  00145	ba 55 01 00 00	 mov	 edx, 341		; 00000155H
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179807
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 342  :         return -1;

  00157	b8 ff ff ff ff	 mov	 eax, -1
  0015c	e9 d2 02 00 00	 jmp	 $LN1@s390_load_
$LN8@s390_load_:

; 343  :     }
; 344  : 
; 345  :     fp = fopen( filename, "r" );

  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179808
  00168	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00176	48 89 44 24 60	 mov	 QWORD PTR fp$[rsp], rax

; 346  :     if (fp == NULL)

  0017b	48 83 7c 24 60
	00		 cmp	 QWORD PTR fp$[rsp], 0
  00181	0f 85 87 00 00
	00		 jne	 $LN9@s390_load_

; 347  :     {
; 348  :         // "SCE file %s: error in function %s: %s"
; 349  :         WRMSG( HHC00600,"E", fname,"fopen()", strerror( errno ));

  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0018d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00195	48 89 44 24 78	 mov	 QWORD PTR tv133[rsp], rax
  0019a	b9 01 00 00 00	 mov	 ecx, 1
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv133[rsp]
  001aa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179810
  001b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001bb	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179811
  001cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179812
  001db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179813
  001f2	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179814
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 350  :         return -1;

  00204	b8 ff ff ff ff	 mov	 eax, -1
  00209	e9 25 02 00 00	 jmp	 $LN1@s390_load_
$LN9@s390_load_:
$LN4@s390_load_:

; 351  :     }
; 352  : 
; 353  :     do
; 354  :     {
; 355  :         inputline = fgets( inputbuff, sizeof( inputbuff ), fp );

  0020e	4c 8b 44 24 60	 mov	 r8, QWORD PTR fp$[rsp]
  00213	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  00218	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR inputbuff$[rsp]
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00226	48 89 44 24 58	 mov	 QWORD PTR inputline$[rsp], rax

; 356  : 
; 357  : #if !defined(_MSVC_)
; 358  :         if (inputline && *inputline == 0x1a)
; 359  :             inputline = NULL;
; 360  : #endif
; 361  :         if (inputline)

  0022b	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00231	74 22		 je	 SHORT $LN10@s390_load_

; 362  :         {
; 363  :             rc = sscanf( inputline,"%" QSTR( MAX_PATH ) "s %i", filename, &fileaddr );

  00233	4c 8d 4c 24 54	 lea	 r9, QWORD PTR fileaddr$[rsp]
  00238	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR filename$[rsp]
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG179816
  00247	48 8b 4c 24 58	 mov	 rcx, QWORD PTR inputline$[rsp]
  0024c	e8 00 00 00 00	 call	 sscanf
  00251	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN10@s390_load_:

; 364  :         }
; 365  : 
; 366  :         /* If no load address was found load to location zero */
; 367  :         if (inputline && rc < 2)

  00255	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  0025b	74 0f		 je	 SHORT $LN11@s390_load_
  0025d	83 7c 24 50 02	 cmp	 DWORD PTR rc$[rsp], 2
  00262	7d 08		 jge	 SHORT $LN11@s390_load_

; 368  :             fileaddr = 0;

  00264	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR fileaddr$[rsp], 0
$LN11@s390_load_:

; 369  : 
; 370  :         if (inputline && rc > 0 && *filename != '*' && *filename != '#')

  0026c	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00272	0f 84 9a 01 00
	00		 je	 $LN12@s390_load_
  00278	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0027d	0f 8e 8f 01 00
	00		 jle	 $LN12@s390_load_
  00283	b8 01 00 00 00	 mov	 eax, 1
  00288	48 6b c0 00	 imul	 rax, rax, 0
  0028c	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  00294	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00297	0f 84 75 01 00
	00		 je	 $LN12@s390_load_
  0029d	b8 01 00 00 00	 mov	 eax, 1
  002a2	48 6b c0 00	 imul	 rax, rax, 0
  002a6	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  002ae	83 f8 23	 cmp	 eax, 35			; 00000023H
  002b1	0f 84 5b 01 00
	00		 je	 $LN12@s390_load_

; 371  :         {
; 372  :             hostpath( pathname, filename, sizeof( pathname ));

  002b7	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  002bd	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  002c5	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 373  : 
; 374  :             /* Construct and check full pathname */
; 375  :             if (!check_sce_filepath( pathname, filename ))

  002d3	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  002db	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  002e3	e8 00 00 00 00	 call	 check_sce_filepath
  002e8	48 85 c0	 test	 rax, rax
  002eb	0f 85 81 00 00
	00		 jne	 $LN13@s390_load_

; 376  :             {
; 377  :                 // "SCE file %s: load from path failed: %s"
; 378  :                 WRMSG( HHC00602,"E",pathname,strerror( errno ));

  002f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002f7	8b 08		 mov	 ecx, DWORD PTR [rax]
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ff	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  00307	b9 01 00 00 00	 mov	 ecx, 1
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00312	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv177[rsp]
  0031a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0031f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00327	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179820
  00333	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179821
  0033f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00344	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00349	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179822
  00356	ba 7a 01 00 00	 mov	 edx, 378		; 0000017aH
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179823
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 379  :                 return -1;

  00368	b8 ff ff ff ff	 mov	 eax, -1
  0036d	e9 c1 00 00 00	 jmp	 $LN1@s390_load_
$LN13@s390_load_:

; 380  :             }
; 381  : 
; 382  :             if (ARCH_DEP( load_main )( filename, fileaddr, noisy ) < 0)

  00372	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?noisy@?1??s390_load_hmc@@9@9
  00379	8b 4c 24 54	 mov	 ecx, DWORD PTR fileaddr$[rsp]
  0037d	44 8b c0	 mov	 r8d, eax
  00380	8b d1		 mov	 edx, ecx
  00382	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0038a	e8 00 00 00 00	 call	 s390_load_main
  0038f	85 c0		 test	 eax, eax
  00391	7d 43		 jge	 SHORT $LN14@s390_load_

; 383  :             {
; 384  :                 // Error!
; 385  :                 fclose( fp );

  00393	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 386  :                 HDC1( debug_cpu_state, regs );

  0039e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  003a5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003a9	74 18		 je	 SHORT $LN16@s390_load_
  003ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  003b7	ff 10		 call	 QWORD PTR [rax]
  003b9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv202[rsp], rax
  003c1	eb 0c		 jmp	 SHORT $LN17@s390_load_
$LN16@s390_load_:
  003c3	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv202[rsp], 0
$LN17@s390_load_:

; 387  :                 return -1;

  003cf	b8 ff ff ff ff	 mov	 eax, -1
  003d4	eb 5d		 jmp	 SHORT $LN1@s390_load_
$LN14@s390_load_:

; 388  :             }
; 389  : 
; 390  :             sysblk.main_clear = sysblk.xpnd_clear = 0;

  003d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003dd	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  003e3	0f ba f0 0f	 btr	 eax, 15
  003e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003ee	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  003f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003fb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00401	0f ba f0 0e	 btr	 eax, 14
  00405	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0040c	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN12@s390_load_:

; 391  :         }
; 392  :     }
; 393  :     while (inputline);

  00412	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00418	0f 85 f0 fd ff
	ff		 jne	 $LN4@s390_load_

; 394  : 
; 395  :     fclose( fp );

  0041e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 396  : 
; 397  :     /* Finish up... */
; 398  :     return ARCH_DEP( common_load_finish )( regs );

  00429	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0042e	e8 00 00 00 00	 call	 s390_common_load_finish
$LN1@s390_load_:

; 399  : 
; 400  : } /* end function load_hmc */

  00433	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043b	48 33 cc	 xor	 rcx, rsp
  0043e	e8 00 00 00 00	 call	 __security_check_cookie
  00443	48 81 c4 d8 03
	00 00		 add	 rsp, 984		; 000003d8H
  0044a	c3		 ret	 0
s390_load_hmc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
fd$ = 80
bytes$ = 84
aaddr$ = 88
pages$ = 96
rc$1 = 100
tv155 = 104
chunk$ = 112
pageaddr$ = 120
loaded$ = 128
curtime$ = 136
begtime$ = 144
tv70 = 152
tv133 = 160
tv193 = 168
fmt_mem$ = 176
__$ArrayPad$ = 184
fname$ = 208
startloc$ = 216
noisy$ = 224
s390_load_main PROC

; 169  : {

$LN23:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 170  : U64     loaded;
; 171  : RADR    aaddr;
; 172  : RADR    pageaddr;
; 173  : int     fd;
; 174  : int     pages;
; 175  : size_t  chunk;
; 176  : int     bytes;
; 177  : time_t  begtime, curtime;
; 178  : char    fmt_mem[8];
; 179  : 
; 180  :     fd = HOPEN( fname, O_RDONLY | O_BINARY );

  00028	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0002d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0003b	89 44 24 50	 mov	 DWORD PTR fd$[rsp], eax

; 181  : 
; 182  :     if (fd < 0)

  0003f	83 7c 24 50 00	 cmp	 DWORD PTR fd$[rsp], 0
  00044	0f 8d 9b 00 00
	00		 jge	 $LN8@s390_load_

; 183  :     {
; 184  :         if (errno != ENOENT)

  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00050	83 38 02	 cmp	 DWORD PTR [rax], 2
  00053	0f 84 83 00 00
	00		 je	 $LN9@s390_load_

; 185  :             // "SCE file %s: error in function %s: %s"
; 186  :             WRMSG( HHC00600, "E", fname, "open()", strerror( errno ));

  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00067	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  00082	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179747
  0008e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00093	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0009b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179748
  000a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179749
  000b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179750
  000ca	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179751
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@s390_load_:

; 187  :         return fd;

  000dc	8b 44 24 50	 mov	 eax, DWORD PTR fd$[rsp]
  000e0	e9 b9 03 00 00	 jmp	 $LN1@s390_load_
$LN8@s390_load_:

; 188  :     }
; 189  : 
; 190  :     /* Calculate size of first chunk to reach page boundary */
; 191  :     chunk = PAGEFRAME_PAGESIZE - (startloc & PAGEFRAME_BYTEMASK);

  000e5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR startloc$[rsp]
  000ed	48 25 ff 0f 00
	00		 and	 rax, 4095		; 00000fffH
  000f3	b9 00 10 00 00	 mov	 ecx, 4096		; 00001000H
  000f8	48 2b c8	 sub	 rcx, rax
  000fb	48 8b c1	 mov	 rax, rcx
  000fe	48 89 44 24 70	 mov	 QWORD PTR chunk$[rsp], rax

; 192  :     aaddr = startloc;

  00103	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR startloc$[rsp]
  0010b	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 193  : 
; 194  :     if (noisy)

  00110	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  00118	74 19		 je	 SHORT $LN10@s390_load_

; 195  :     {
; 196  :         loaded = 0;

  0011a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR loaded$[rsp], 0

; 197  :         time( &begtime );

  00126	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR begtime$[rsp]
  0012e	e8 00 00 00 00	 call	 time
$LN10@s390_load_:
$LN2@s390_load_:

; 198  :     }
; 199  : 
; 200  :     /* Read file into storage until end of file or end of storage */
; 201  :     for (;;)
; 202  :     {
; 203  :         if (chunk > (sysblk.mainsize - aaddr))

  00133	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0013f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00146	48 2b c1	 sub	 rax, rcx
  00149	48 39 44 24 70	 cmp	 QWORD PTR chunk$[rsp], rax
  0014e	76 1b		 jbe	 SHORT $LN11@s390_load_

; 204  :             chunk = (sysblk.mainsize - aaddr);

  00150	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00157	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0015c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00163	48 2b c1	 sub	 rax, rcx
  00166	48 89 44 24 70	 mov	 QWORD PTR chunk$[rsp], rax
$LN11@s390_load_:

; 205  : 
; 206  :         bytes = read( fd, sysblk.mainstor + aaddr, chunk );

  0016b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00172	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00179	48 03 44 24 58	 add	 rax, QWORD PTR aaddr$[rsp]
  0017e	44 8b 44 24 70	 mov	 r8d, DWORD PTR chunk$[rsp]
  00183	48 8b d0	 mov	 rdx, rax
  00186	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00190	89 44 24 54	 mov	 DWORD PTR bytes$[rsp], eax

; 207  : 
; 208  :         chunk = CHUNKSIZE;

  00194	48 c7 44 24 70
	00 00 00 04	 mov	 QWORD PTR chunk$[rsp], 67108864 ; 04000000H

; 209  : 
; 210  :         /* Check for I/O error */
; 211  :         if (bytes < 0)

  0019d	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  001a2	0f 8d 97 00 00
	00		 jge	 $LN12@s390_load_

; 212  :         {
; 213  :             // "SCE file %s: error in function %s: %s"
; 214  :             WRMSG( HHC00600, "E", fname, "read()",strerror( errno ));

  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ae	8b 08		 mov	 ecx, DWORD PTR [rax]
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001be	b9 01 00 00 00	 mov	 ecx, 1
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001d1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179755
  001dd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001e2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001ea	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179756
  001f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179757
  00202	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00207	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00212	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179758
  00219	ba d6 00 00 00	 mov	 edx, 214		; 000000d6H
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179759
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 215  :             close( fd );

  0022b	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 216  :             return -1;

  00235	b8 ff ff ff ff	 mov	 eax, -1
  0023a	e9 5f 02 00 00	 jmp	 $LN1@s390_load_
$LN12@s390_load_:

; 217  :         }
; 218  : 
; 219  :         /* Check for end-of-file */
; 220  :         if (bytes == 0)

  0023f	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  00244	75 11		 jne	 SHORT $LN13@s390_load_

; 221  :         {
; 222  :             close( fd );

  00246	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 223  :             return 0;

  00250	33 c0		 xor	 eax, eax
  00252	e9 47 02 00 00	 jmp	 $LN1@s390_load_
$LN13@s390_load_:

; 224  :         }
; 225  : 
; 226  :         /* Update the storage keys for all of the pages we just read */
; 227  :         pages = ROUND_UP( bytes, PAGEFRAME_PAGESIZE ) / PAGEFRAME_PAGESIZE;

  00257	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  0025c	74 21		 je	 SHORT $LN21@s390_load_
  0025e	8b 44 24 54	 mov	 eax, DWORD PTR bytes$[rsp]
  00262	05 ff 0f 00 00	 add	 eax, 4095		; 00000fffH
  00267	99		 cdq
  00268	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  0026e	03 c2		 add	 eax, edx
  00270	c1 f8 0c	 sar	 eax, 12
  00273	69 c0 00 10 00
	00		 imul	 eax, eax, 4096		; 00001000H
  00279	89 44 24 68	 mov	 DWORD PTR tv155[rsp], eax
  0027d	eb 08		 jmp	 SHORT $LN22@s390_load_
$LN21@s390_load_:
  0027f	c7 44 24 68 00
	10 00 00	 mov	 DWORD PTR tv155[rsp], 4096 ; 00001000H
$LN22@s390_load_:
  00287	8b 44 24 68	 mov	 eax, DWORD PTR tv155[rsp]
  0028b	99		 cdq
  0028c	81 e2 ff 0f 00
	00		 and	 edx, 4095		; 00000fffH
  00292	03 c2		 add	 eax, edx
  00294	c1 f8 0c	 sar	 eax, 12
  00297	89 44 24 60	 mov	 DWORD PTR pages$[rsp], eax

; 228  :         pageaddr = aaddr;

  0029b	48 8b 44 24 58	 mov	 rax, QWORD PTR aaddr$[rsp]
  002a0	48 89 44 24 78	 mov	 QWORD PTR pageaddr$[rsp], rax
$LN7@s390_load_:

; 229  : 
; 230  :         do
; 231  :         {
; 232  :             ARCH_DEP( or_storage_key )( pageaddr, STORKEY_REF | STORKEY_CHANGE );

  002a5	b2 06		 mov	 dl, 6
  002a7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pageaddr$[rsp]
  002ac	e8 00 00 00 00	 call	 s390_or_storage_key

; 233  :             pageaddr += PAGEFRAME_PAGESIZE;

  002b1	48 8b 44 24 78	 mov	 rax, QWORD PTR pageaddr$[rsp]
  002b6	48 05 00 10 00
	00		 add	 rax, 4096		; 00001000H
  002bc	48 89 44 24 78	 mov	 QWORD PTR pageaddr$[rsp], rax

; 234  :         }
; 235  :         while (--pages);

  002c1	8b 44 24 60	 mov	 eax, DWORD PTR pages$[rsp]
  002c5	ff c8		 dec	 eax
  002c7	89 44 24 60	 mov	 DWORD PTR pages$[rsp], eax
  002cb	83 7c 24 60 00	 cmp	 DWORD PTR pages$[rsp], 0
  002d0	75 d3		 jne	 SHORT $LN7@s390_load_

; 236  : 
; 237  :         aaddr += bytes;

  002d2	48 63 44 24 54	 movsxd	 rax, DWORD PTR bytes$[rsp]
  002d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  002dc	48 03 c8	 add	 rcx, rax
  002df	48 8b c1	 mov	 rax, rcx
  002e2	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 238  :         aaddr &= PAGEFRAME_PAGEMASK;

  002e7	48 8b 44 24 58	 mov	 rax, QWORD PTR aaddr$[rsp]
  002ec	48 25 00 f0 ff
	7f		 and	 rax, 2147479552		; 7ffff000H
  002f2	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 239  : 
; 240  :         /* Check if end of storge reached */
; 241  :         if (aaddr >= sysblk.mainsize)

  002f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002fe	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00305	48 39 44 24 58	 cmp	 QWORD PTR aaddr$[rsp], rax
  0030a	0f 82 9c 00 00
	00		 jb	 $LN14@s390_load_

; 242  :         {
; 243  :             int rc;
; 244  :        
; 245  :             if (read( fd, &rc, 1 ) > 0)

  00310	41 b8 01 00 00
	00		 mov	 r8d, 1
  00316	48 8d 54 24 64	 lea	 rdx, QWORD PTR rc$1[rsp]
  0031b	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00325	85 c0		 test	 eax, eax
  00327	7e 68		 jle	 SHORT $LN15@s390_load_

; 246  :             {
; 247  :                 rc = +1;

  00329	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1

; 248  : 
; 249  :                 if (noisy)

  00331	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  00339	74 54		 je	 SHORT $LN17@s390_load_

; 250  :                 {
; 251  :                     // "SCE file %s: load main terminated at end of mainstor"
; 252  :                     WRMSG( HHC00603, "W", fname );

  0033b	b9 01 00 00 00	 mov	 ecx, 1
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00346	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0034e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179765
  0035a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179766
  00366	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00370	41 b9 03 00 00
	00		 mov	 r9d, 3
  00376	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179767
  0037d	ba fc 00 00 00	 mov	 edx, 252		; 000000fcH
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179768
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@s390_load_:

; 253  :                 }
; 254  :             }

  0038f	eb 08		 jmp	 SHORT $LN16@s390_load_
$LN15@s390_load_:

; 255  :             else /* ignore any error; we're at end of storage anyway */
; 256  :                 rc = 0;

  00391	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 0
$LN16@s390_load_:

; 257  : 
; 258  :             close( fd );

  00399	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0039d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 259  :             return rc;

  003a3	8b 44 24 64	 mov	 eax, DWORD PTR rc$1[rsp]
  003a7	e9 f2 00 00 00	 jmp	 $LN1@s390_load_
$LN14@s390_load_:

; 260  :         }
; 261  : 
; 262  :         /* Issue periodic progress messages */
; 263  :         if (noisy)

  003ac	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  003b4	0f 84 df 00 00
	00		 je	 $LN18@s390_load_

; 264  :         {
; 265  :             loaded += bytes;

  003ba	48 63 44 24 54	 movsxd	 rax, DWORD PTR bytes$[rsp]
  003bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR loaded$[rsp]
  003c7	48 03 c8	 add	 rcx, rax
  003ca	48 8b c1	 mov	 rax, rcx
  003cd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR loaded$[rsp], rax

; 266  :             time( &curtime );

  003d5	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR curtime$[rsp]
  003dd	e8 00 00 00 00	 call	 time

; 267  : 
; 268  :             if (difftime( curtime, begtime ) > 2.0)

  003e2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR begtime$[rsp]
  003ea	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR curtime$[rsp]
  003f2	e8 00 00 00 00	 call	 difftime
  003f7	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4000000000000000
  003ff	0f 86 94 00 00
	00		 jbe	 $LN19@s390_load_

; 269  :             {
; 270  :                 begtime = curtime;

  00405	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR curtime$[rsp]
  0040d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR begtime$[rsp], rax

; 271  : 
; 272  :                 // "%s bytes %s so far..."
; 273  :                 WRMSG( HHC02317, "I",

  00415	41 b8 08 00 00
	00		 mov	 r8d, 8
  0041b	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR fmt_mem$[rsp]
  00423	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR loaded$[rsp]
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_memsize
  00431	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv193[rsp], rax
  00439	b9 01 00 00 00	 mov	 ecx, 1
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179771
  0044b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00450	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv193[rsp]
  00458	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0045d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179772
  00464	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179773
  00470	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00475	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00480	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG179774
  00487	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  0048c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG179775
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@s390_load_:
$LN18@s390_load_:

; 274  :                     fmt_memsize( loaded, fmt_mem, sizeof( fmt_mem )),
; 275  :                         "loaded" );
; 276  :             }
; 277  :         }
; 278  :     } /* end for (;;) */

  00499	e9 95 fc ff ff	 jmp	 $LN2@s390_load_
$LN1@s390_load_:

; 279  : 
; 280  : } /* end function load_main */

  0049e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a6	48 33 cc	 xor	 rcx, rsp
  004a9	e8 00 00 00 00	 call	 __security_check_cookie
  004ae	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004b5	c3		 ret	 0
s390_load_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
temppath$ = 32
tempreal$ = 304
__$ArrayPad$ = 576
path$ = 608
fullpath$ = 616
check_sce_filepath PROC

; 107  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 81 ec 58 02
	00 00		 sub	 rsp, 600		; 00000258H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 40
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 108  : char temppath[ MAX_PATH ];
; 109  : char tempreal[ MAX_PATH ];
; 110  : 
; 111  :     /* Return file access error if no basedir has been set */
; 112  :     if (!sce_basedir)

  00023	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sce_basedir, 0
  0002b	75 2f		 jne	 SHORT $LN2@check_sce_

; 113  :     {
; 114  :         strlcpy( fullpath, path, sizeof( temppath ));

  0002d	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00033	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  0003b	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR fullpath$[rsp]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 115  :         errno = EACCES;

  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004f	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 116  :         return NULL;

  00055	33 c0		 xor	 eax, eax
  00057	e9 f9 00 00 00	 jmp	 $LN1@check_sce_
$LN2@check_sce_:

; 117  :     }
; 118  : 
; 119  :     /* Establish the full path of the file we are trying to access */
; 120  :     STRLCPY( temppath, sce_basedir );

  0005c	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00062	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR sce_basedir
  00069	48 8d 4c 24 20	 lea	 rcx, QWORD PTR temppath$[rsp]
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcpy

; 121  :     STRLCAT( temppath, path );

  00074	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0007a	48 8b 94 24 60
	02 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  00082	48 8d 4c 24 20	 lea	 rcx, QWORD PTR temppath$[rsp]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 122  : 
; 123  :     if (!realpath( temppath, tempreal ))

  0008d	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR tempreal$[rsp]
  00095	48 8d 4c 24 20	 lea	 rcx, QWORD PTR temppath$[rsp]
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realpath
  000a0	48 85 c0	 test	 rax, rax
  000a3	75 54		 jne	 SHORT $LN3@check_sce_

; 124  :     {
; 125  :         hostpath( fullpath, tempreal, sizeof( temppath ));

  000a5	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000ab	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR tempreal$[rsp]
  000b3	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR fullpath$[rsp]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 126  :         if (strncmp( sce_basedir, fullpath, strlen( sce_basedir )))

  000c1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sce_basedir
  000c8	e8 00 00 00 00	 call	 strlen
  000cd	4c 8b c0	 mov	 r8, rax
  000d0	48 8b 94 24 68
	02 00 00	 mov	 rdx, QWORD PTR fullpath$[rsp]
  000d8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sce_basedir
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  000e5	85 c0		 test	 eax, eax
  000e7	74 0c		 je	 SHORT $LN4@check_sce_

; 127  :             errno = EACCES;

  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ef	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13
$LN4@check_sce_:

; 128  :         return NULL;

  000f5	33 c0		 xor	 eax, eax
  000f7	eb 5c		 jmp	 SHORT $LN1@check_sce_
$LN3@check_sce_:

; 129  :     }
; 130  : 
; 131  :     hostpath( fullpath, tempreal, sizeof( temppath ));

  000f9	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000ff	48 8d 94 24 30
	01 00 00	 lea	 rdx, QWORD PTR tempreal$[rsp]
  00107	48 8b 8c 24 68
	02 00 00	 mov	 rcx, QWORD PTR fullpath$[rsp]
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 132  : 
; 133  :     if (strncmp( sce_basedir, fullpath, strlen( sce_basedir )))

  00115	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sce_basedir
  0011c	e8 00 00 00 00	 call	 strlen
  00121	4c 8b c0	 mov	 r8, rax
  00124	48 8b 94 24 68
	02 00 00	 mov	 rdx, QWORD PTR fullpath$[rsp]
  0012c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sce_basedir
  00133	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strncmp
  00139	85 c0		 test	 eax, eax
  0013b	74 10		 je	 SHORT $LN5@check_sce_

; 134  :     {
; 135  :         errno = EACCES;

  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00143	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 136  :         return NULL;

  00149	33 c0		 xor	 eax, eax
  0014b	eb 08		 jmp	 SHORT $LN1@check_sce_
$LN5@check_sce_:

; 137  :     }
; 138  : 
; 139  :     return fullpath;

  0014d	48 8b 84 24 68
	02 00 00	 mov	 rax, QWORD PTR fullpath$[rsp]
$LN1@check_sce_:

; 140  : }

  00155	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0015d	48 33 cc	 xor	 rcx, rsp
  00160	e8 00 00 00 00	 call	 __security_check_cookie
  00165	48 81 c4 58 02
	00 00		 add	 rsp, 600		; 00000258H
  0016c	c3		 ret	 0
check_sce_filepath ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
basedir$ = 80
tv132 = 88
tv70 = 96
realdir$ = 112
tempdir$ = 384
__$ArrayPad$ = 656
path$ = 688
set_sce_basedir PROC

; 70   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec a8 02
	00 00		 sub	 rsp, 680		; 000002a8H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 90
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 71   : char* basedir;
; 72   : char  realdir[ MAX_PATH ];
; 73   : char  tempdir[ MAX_PATH ];
; 74   : 
; 75   :     if (sce_basedir)

  0001e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sce_basedir, 0
  00026	74 18		 je	 SHORT $LN2@set_sce_ba

; 76   :     {
; 77   :         free( sce_basedir );

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sce_basedir
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 78   :         sce_basedir = NULL;

  00035	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sce_basedir, 0
$LN2@set_sce_ba:

; 79   :     }
; 80   : 
; 81   :     if (!realpath( path, tempdir ))

  00040	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR tempdir$[rsp]
  00048	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realpath
  00056	48 85 c0	 test	 rax, rax
  00059	0f 85 8f 00 00
	00		 jne	 $LN3@set_sce_ba

; 82   :     {
; 83   :         // "SCE file %s: error in function %s: %s"
; 84   :         WRMSG( HHC00600, "E", path, "realpath()", strerror( errno ));

  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00065	8b 08		 mov	 ecx, DWORD PTR [rax]
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0006d	48 89 44 24 60	 mov	 QWORD PTR tv70[rsp], rax
  00072	b9 01 00 00 00	 mov	 ecx, 1
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007d	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv70[rsp]
  00082	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169574
  0008e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00093	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0009b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169575
  000a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169576
  000b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169577
  000ca	ba 54 00 00 00	 mov	 edx, 84			; 00000054H
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169578
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 85   :         sce_basedir = NULL;

  000dc	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sce_basedir, 0

; 86   :         return NULL;

  000e7	33 c0		 xor	 eax, eax
  000e9	e9 bd 00 00 00	 jmp	 $LN1@set_sce_ba
$LN3@set_sce_ba:

; 87   :     }
; 88   : 
; 89   :     hostpath( realdir, tempdir, sizeof( realdir ));

  000ee	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  000f4	48 8d 94 24 80
	01 00 00	 lea	 rdx, QWORD PTR tempdir$[rsp]
  000fc	48 8d 4c 24 70	 lea	 rcx, QWORD PTR realdir$[rsp]
  00101	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 90   : 
; 91   :     if ((basedir = strrchr( realdir, PATHSEPC )))

  00107	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0010c	48 8d 4c 24 70	 lea	 rcx, QWORD PTR realdir$[rsp]
  00111	e8 00 00 00 00	 call	 strrchr
  00116	48 89 44 24 50	 mov	 QWORD PTR basedir$[rsp], rax
  0011b	48 83 7c 24 50
	00		 cmp	 QWORD PTR basedir$[rsp], 0
  00121	74 75		 je	 SHORT $LN4@set_sce_ba

; 92   :     {
; 93   :         *(++basedir) = '\0';

  00123	48 8b 44 24 50	 mov	 rax, QWORD PTR basedir$[rsp]
  00128	48 ff c0	 inc	 rax
  0012b	48 89 44 24 50	 mov	 QWORD PTR basedir$[rsp], rax
  00130	48 8b 44 24 50	 mov	 rax, QWORD PTR basedir$[rsp]
  00135	c6 00 00	 mov	 BYTE PTR [rax], 0

; 94   :         sce_basedir = strdup( realdir );

  00138	48 8d 4c 24 70	 lea	 rcx, QWORD PTR realdir$[rsp]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00143	48 89 05 00 00
	00 00		 mov	 QWORD PTR sce_basedir, rax

; 95   :         return (basedir = strrchr( path, PATHSEPC )) ? ++basedir : path;

  0014a	ba 2f 00 00 00	 mov	 edx, 47			; 0000002fH
  0014f	48 8b 8c 24 b0
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00157	e8 00 00 00 00	 call	 strrchr
  0015c	48 89 44 24 50	 mov	 QWORD PTR basedir$[rsp], rax
  00161	48 83 7c 24 50
	00		 cmp	 QWORD PTR basedir$[rsp], 0
  00167	74 19		 je	 SHORT $LN7@set_sce_ba
  00169	48 8b 44 24 50	 mov	 rax, QWORD PTR basedir$[rsp]
  0016e	48 ff c0	 inc	 rax
  00171	48 89 44 24 50	 mov	 QWORD PTR basedir$[rsp], rax
  00176	48 8b 44 24 50	 mov	 rax, QWORD PTR basedir$[rsp]
  0017b	48 89 44 24 58	 mov	 QWORD PTR tv132[rsp], rax
  00180	eb 0d		 jmp	 SHORT $LN8@set_sce_ba
$LN7@set_sce_ba:
  00182	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR path$[rsp]
  0018a	48 89 44 24 58	 mov	 QWORD PTR tv132[rsp], rax
$LN8@set_sce_ba:
  0018f	48 8b 44 24 58	 mov	 rax, QWORD PTR tv132[rsp]
  00194	eb 15		 jmp	 SHORT $LN1@set_sce_ba

; 96   :     }

  00196	eb 13		 jmp	 SHORT $LN5@set_sce_ba
$LN4@set_sce_ba:

; 97   :     else
; 98   :     {
; 99   :         sce_basedir = NULL;

  00198	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sce_basedir, 0

; 100  :         return path;

  001a3	48 8b 84 24 b0
	02 00 00	 mov	 rax, QWORD PTR path$[rsp]
$LN5@set_sce_ba:
$LN1@set_sce_ba:

; 101  :     }
; 102  : }

  001ab	48 8b 8c 24 90
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001b3	48 33 cc	 xor	 rcx, rsp
  001b6	e8 00 00 00 00	 call	 __security_check_cookie
  001bb	48 81 c4 a8 02
	00 00		 add	 rsp, 680		; 000002a8H
  001c2	c3		 ret	 0
set_sce_basedir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_storage_key PROC				; COMDAT

; 290  : {

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 291  : #if defined( FEATURE_2K_STORAGE_KEYS )
; 292  :     ARCH_DEP( or_2K_storage_key )( abs, bits );

  0000d	0f b6 54 24 38	 movzx	 edx, BYTE PTR bits$[rsp]
  00012	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00017	e8 00 00 00 00	 call	 s370_or_2K_storage_key

; 293  : #else
; 294  :     ARCH_DEP( or_4K_storage_key )( abs, bits );
; 295  : #endif
; 296  : }

  0001c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00020	c3		 ret	 0
s370_or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370_or_2K_storage_key
_TEXT	SEGMENT
abs$ = 48
bits$ = 56
s370_or_2K_storage_key PROC				; COMDAT

; 231  :   inline void  ARCH_DEP( or_2K_storage_key )      (              U64 abs, BYTE bits ) {        ARCH_DEP( _or_storage_key      )(      abs, bits & ~STORKEY_BADFRM, 2 ); }

$LN3:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  0000d	0f b6 44 24 38	 movzx	 eax, BYTE PTR bits$[rsp]
  00012	83 e0 fe	 and	 eax, -2
  00015	41 b0 02	 mov	 r8b, 2
  00018	0f b6 d0	 movzx	 edx, al
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR abs$[rsp]
  00020	e8 00 00 00 00	 call	 s370__or_storage_key
  00025	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00029	c3		 ret	 0
s370_or_2K_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT s370__or_storage_key
_TEXT	SEGMENT
skey1_ptr$1 = 32
skey2_ptr$2 = 40
skey_ptr$3 = 48
abs$ = 80
bits$ = 88
K$ = 96
s370__or_storage_key PROC				; COMDAT

; 189  : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H
$LN4@s370__or_s:

; 190  :     UNREFERENCED( K ); // (for FEATURE_4K_STORAGE_KEYS case)

  00012	33 c0		 xor	 eax, eax
  00014	85 c0		 test	 eax, eax
  00016	75 fa		 jne	 SHORT $LN4@s370__or_s

; 191  :     if (IS_DOUBLE_KEYED_4K_BYTE_BLOCK( K ))

  00018	0f b6 44 24 60	 movzx	 eax, BYTE PTR K$[rsp]
  0001d	83 f8 04	 cmp	 eax, 4
  00020	75 57		 jne	 SHORT $LN5@s370__or_s
  00022	33 c0		 xor	 eax, eax
  00024	83 f8 01	 cmp	 eax, 1
  00027	74 50		 je	 SHORT $LN5@s370__or_s

; 192  :     {
; 193  :         BYTE* skey1_ptr = _get_storekey1_ptr( abs );

  00029	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0002e	e8 00 00 00 00	 call	 _get_storekey1_ptr
  00033	48 89 44 24 20	 mov	 QWORD PTR skey1_ptr$1[rsp], rax

; 194  :         BYTE* skey2_ptr = _get_storekey2_ptr( abs );

  00038	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  0003d	e8 00 00 00 00	 call	 _get_storekey2_ptr
  00042	48 89 44 24 28	 mov	 QWORD PTR skey2_ptr$2[rsp], rax

; 195  :         OR_SKEY( skey1_ptr, bits );

  00047	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  0004c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  00051	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00054	0b c8		 or	 ecx, eax
  00056	8b c1		 mov	 eax, ecx
  00058	48 8b 4c 24 20	 mov	 rcx, QWORD PTR skey1_ptr$1[rsp]
  0005d	88 01		 mov	 BYTE PTR [rcx], al

; 196  :         OR_SKEY( skey2_ptr, bits );

  0005f	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00064	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00069	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0006c	0b c8		 or	 ecx, eax
  0006e	8b c1		 mov	 eax, ecx
  00070	48 8b 4c 24 28	 mov	 rcx, QWORD PTR skey2_ptr$2[rsp]
  00075	88 01		 mov	 BYTE PTR [rcx], al

; 197  :     }

  00077	eb 2c		 jmp	 SHORT $LN6@s370__or_s
$LN5@s370__or_s:

; 198  :     else
; 199  :     {
; 200  :         BYTE* skey_ptr  = _get_storekey_ptr( abs, K );

  00079	0f b6 54 24 60	 movzx	 edx, BYTE PTR K$[rsp]
  0007e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR abs$[rsp]
  00083	e8 00 00 00 00	 call	 _get_storekey_ptr
  00088	48 89 44 24 30	 mov	 QWORD PTR skey_ptr$3[rsp], rax

; 201  :         OR_SKEY( skey_ptr, bits );

  0008d	0f b6 44 24 58	 movzx	 eax, BYTE PTR bits$[rsp]
  00092	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  00097	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  0009a	0b c8		 or	 ecx, eax
  0009c	8b c1		 mov	 eax, ecx
  0009e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR skey_ptr$3[rsp]
  000a3	88 01		 mov	 BYTE PTR [rcx], al
$LN6@s370__or_s:

; 202  :     }
; 203  : }

  000a5	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000a9	c3		 ret	 0
s370__or_storage_key ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey2_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey2_ptr PROC					; COMDAT

; 60   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 61   :     ABS_CHECK( abs );
; 62   :     return &STOREKEY2( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 c8 01	 or	 rax, 1
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 63   : }

  00026	c3		 ret	 0
_get_storekey2_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey1_ptr
_TEXT	SEGMENT
abs$ = 8
_get_storekey1_ptr PROC					; COMDAT

; 54   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 55   :     ABS_CHECK( abs );
; 56   :     return &STOREKEY1( abs, &sysblk );

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR abs$[rsp]
  0000a	48 c1 e8 0b	 shr	 rax, 11
  0000e	48 83 e0 fe	 and	 rax, -2
  00012	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00019	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00020	48 03 c8	 add	 rcx, rax
  00023	48 8b c1	 mov	 rax, rcx

; 57   : }

  00026	c3		 ret	 0
_get_storekey1_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\skey.h
;	COMDAT _get_storekey_ptr
_TEXT	SEGMENT
tv75 = 0
abs$ = 32
K$ = 40
_get_storekey_ptr PROC					; COMDAT

; 40   : {

$LN5:
  00000	88 54 24 10	 mov	 BYTE PTR [rsp+16], dl
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 18	 sub	 rsp, 24

; 41   :     ABS_CHECK( abs );
; 42   :     return (4 == K) ? &STOREKEY1( abs, &sysblk ) // (see feature.h PROGRAMMING NOTE)

  0000d	0f b6 44 24 28	 movzx	 eax, BYTE PTR K$[rsp]
  00012	83 f8 04	 cmp	 eax, 4
  00015	75 27		 jne	 SHORT $LN3@get_storek
  00017	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  0001c	48 c1 e8 0b	 shr	 rax, 11
  00020	48 83 e0 fe	 and	 rax, -2
  00024	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0002b	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00032	48 03 c8	 add	 rcx, rax
  00035	48 8b c1	 mov	 rax, rcx
  00038	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
  0003c	eb 21		 jmp	 SHORT $LN4@get_storek
$LN3@get_storek:
  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR abs$[rsp]
  00043	48 c1 e8 0b	 shr	 rax, 11
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004e	48 8b 89 a0 00
	00 00		 mov	 rcx, QWORD PTR [rcx+160]
  00055	48 03 c8	 add	 rcx, rax
  00058	48 8b c1	 mov	 rax, rcx
  0005b	48 89 04 24	 mov	 QWORD PTR tv75[rsp], rax
$LN4@get_storek:
  0005f	48 8b 04 24	 mov	 rax, QWORD PTR tv75[rsp]

; 43   :                     : &STOREKEY(  abs, &sysblk );
; 44   : }

  00063	48 83 c4 18	 add	 rsp, 24
  00067	c3		 ret	 0
_get_storekey_ptr ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Release_Interrupt_Lock PROC

; 403  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@Release_In:

; 404  :     UNREFERENCED( regs );

  0000e	33 c0		 xor	 eax, eax
  00010	85 c0		 test	 eax, eax
  00012	75 fa		 jne	 SHORT $LN4@Release_In

; 405  :     sysblk.intowner = LOCK_OWNER_NONE;

  00014	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00019	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00020	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 406  :     hthread_release_lock( &sysblk.intlock, location );

  00027	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002e	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00034	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00039	48 8b c8	 mov	 rcx, rax
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 407  : }

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
Release_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Obtain_Interrupt_Lock PROC

; 379  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 380  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	74 13		 je	 SHORT $LN2@Obtain_Int

; 381  :         HOSTREGS->intwait = true;

  00016	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  0001b	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  00022	c6 80 f0 08 00
	00 01		 mov	 BYTE PTR [rax+2288], 1
$LN2@Obtain_Int:

; 382  :     hthread_obtain_lock( &sysblk.intlock, location );

  00029	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00030	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  00036	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  0003b	48 8b c8	 mov	 rcx, rax
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 383  :     Interrupt_Lock_Obtained( regs, location );

  00044	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00049	48 8b 4c 24 30	 mov	 rcx, QWORD PTR regs$[rsp]
  0004e	e8 00 00 00 00	 call	 Interrupt_Lock_Obtained

; 384  : }

  00053	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00057	c3		 ret	 0
Obtain_Interrupt_Lock ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\hinlines.h
_TEXT	SEGMENT
regs$ = 48
location$ = 56
Interrupt_Lock_Obtained PROC

; 347  : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 348  :     if (regs)

  0000e	48 83 7c 24 30
	00		 cmp	 QWORD PTR regs$[rsp], 0
  00014	0f 84 db 00 00
	00		 je	 $LN4@Interrupt_
$LN2@Interrupt_:

; 349  :     {
; 350  :         /* Wait for any SYNCHRONIZE_CPUS to finish before proceeding */
; 351  :         while (sysblk.syncing)

  0001a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00021	0f b6 80 7c 13
	00 00		 movzx	 eax, BYTE PTR [rax+4988]
  00028	85 c0		 test	 eax, eax
  0002a	0f 84 8f 00 00
	00		 je	 $LN3@Interrupt_

; 352  :         {
; 353  :             /* Indicate we have reached the sync point */
; 354  :             sysblk.sync_mask &= ~HOSTREGS->cpubit;

  00030	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  00035	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  0003c	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00040	48 f7 d0	 not	 rax
  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0004a	48 8b 89 80 13
	00 00		 mov	 rcx, QWORD PTR [rcx+4992]
  00051	48 23 c8	 and	 rcx, rax
  00054	48 8b c1	 mov	 rax, rcx
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005e	48 89 81 80 13
	00 00		 mov	 QWORD PTR [rcx+4992], rax

; 355  : 
; 356  :             /* If we're the last CPU to reach this sync point,
; 357  :                signal the CPU that requested the sync that it
; 358  :                may now safely proceed with its exclusive logic.
; 359  :             */
; 360  :             if (!sysblk.sync_mask)

  00065	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0006c	48 83 b8 80 13
	00 00 00	 cmp	 QWORD PTR [rax+4992], 0
  00074	75 1b		 jne	 SHORT $LN6@Interrupt_

; 361  :                 hthread_signal_condition( &sysblk.all_synced_cond, location );

  00076	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0007d	48 05 88 13 00
	00		 add	 rax, 5000		; 00001388H
  00083	48 8b 54 24 38	 mov	 rdx, QWORD PTR location$[rsp]
  00088	48 8b c8	 mov	 rcx, rax
  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_signal_condition
$LN6@Interrupt_:

; 362  : 
; 363  :             /* Wait for CPU that requested the sync to indicate
; 364  :                it's done and thus is now safe for us to proceed.
; 365  :             */
; 366  :             hthread_wait_condition( &sysblk.sync_done_cond, &sysblk.intlock, location );

  00091	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00098	48 05 70 10 00
	00		 add	 rax, 4208		; 00001070H
  0009e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000a5	48 81 c1 90 13
	00 00		 add	 rcx, 5008		; 00001390H
  000ac	4c 8b 44 24 38	 mov	 r8, QWORD PTR location$[rsp]
  000b1	48 8b d0	 mov	 rdx, rax
  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition

; 367  :         }

  000ba	e9 5b ff ff ff	 jmp	 $LN2@Interrupt_
$LN3@Interrupt_:

; 368  : 
; 369  :         HOSTREGS->intwait = false;

  000bf	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000c4	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000cb	c6 80 f0 08 00
	00 00		 mov	 BYTE PTR [rax+2288], 0

; 370  :         sysblk.intowner = HOSTREGS->cpuad;

  000d2	48 8b 44 24 30	 mov	 rax, QWORD PTR regs$[rsp]
  000d7	48 8b 80 68 08
	00 00		 mov	 rax, QWORD PTR [rax+2152]
  000de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000e5	0f b7 80 3c 08
	00 00		 movzx	 eax, WORD PTR [rax+2108]
  000ec	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax

; 371  :     }

  000f3	eb 13		 jmp	 SHORT $LN5@Interrupt_
$LN4@Interrupt_:

; 372  :     else
; 373  :         sysblk.intowner = LOCK_OWNER_OTHER;

  000f5	b8 fe ff 00 00	 mov	 eax, 65534		; 0000fffeH
  000fa	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00101	66 89 81 62 10
	00 00		 mov	 WORD PTR [rcx+4194], ax
$LN5@Interrupt_:

; 374  : }

  00108	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0010c	c3		 ret	 0
Interrupt_Lock_Obtained ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_dw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_dw_noswap PROC					; COMDAT

; 834  :     inline void store_dw_noswap(void *ptr, U64 value) {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 835  :       memcpy((BYTE *)ptr, (BYTE *)&value, 8);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	48 8b 4c 24 10	 mov	 rcx, QWORD PTR value$[rsp]
  00014	48 89 08	 mov	 QWORD PTR [rax], rcx

; 836  :     }

  00017	c3		 ret	 0
store_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_dw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_dw_noswap PROC					; COMDAT

; 816  :     inline U64 fetch_dw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 817  :       U64 value;
; 818  :       memcpy(&value, (BYTE *)ptr, 8);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00011	48 89 04 24	 mov	 QWORD PTR value$[rsp], rax

; 819  :       return value;

  00015	48 8b 04 24	 mov	 rax, QWORD PTR value$[rsp]

; 820  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_dw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_fw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_fw_noswap PROC					; COMDAT

; 746  :     inline U32 fetch_fw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 747  :       U32 value;
; 748  :       memcpy(&value, (BYTE *)ptr, 4);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	8b 00		 mov	 eax, DWORD PTR [rax]
  00010	89 04 24	 mov	 DWORD PTR value$[rsp], eax

; 749  :       return value;

  00013	8b 04 24	 mov	 eax, DWORD PTR value$[rsp]

; 750  :     }

  00016	48 83 c4 18	 add	 rsp, 24
  0001a	c3		 ret	 0
fetch_fw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT store_hw_noswap
_TEXT	SEGMENT
ptr$ = 8
value$ = 16
store_hw_noswap PROC					; COMDAT

; 730  :     inline void store_hw_noswap(void *ptr, U16 value) {

  00000	66 89 54 24 10	 mov	 WORD PTR [rsp+16], dx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 731  :       memcpy((BYTE *)ptr, (BYTE *)&value, 2);

  0000a	48 8b 44 24 08	 mov	 rax, QWORD PTR ptr$[rsp]
  0000f	0f b7 4c 24 10	 movzx	 ecx, WORD PTR value$[rsp]
  00014	66 89 08	 mov	 WORD PTR [rax], cx

; 732  :     }

  00017	c3		 ret	 0
store_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\machdep.h
;	COMDAT fetch_hw_noswap
_TEXT	SEGMENT
value$ = 0
ptr$ = 32
fetch_hw_noswap PROC					; COMDAT

; 712  :     inline U16 fetch_hw_noswap(const void *ptr) {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 713  :       U16 value;
; 714  :       memcpy(&value, (BYTE *)ptr, 2);

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR ptr$[rsp]
  0000e	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00011	66 89 04 24	 mov	 WORD PTR value$[rsp], ax

; 715  :       return value;

  00015	0f b7 04 24	 movzx	 eax, WORD PTR value$[rsp]

; 716  :     }

  00019	48 83 c4 18	 add	 rsp, 24
  0001d	c3		 ret	 0
fetch_hw_noswap ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
rc$ = 80
fileaddr$ = 84
inputline$ = 88
fp$ = 96
regs$ = 104
tv83 = 112
tv133 = 120
tv177 = 128
tv202 = 136
filename$ = 144
pathname$ = 416
inputbuff$ = 688
__$ArrayPad$ = 960
fname$ = 992
cpu$ = 1000
clear$ = 1008
s370_load_hmc PROC

; 304  : {

$LN18:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 81 ec d8 03
	00 00		 sub	 rsp, 984		; 000003d8H
  00015	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001c	48 33 c4	 xor	 rax, rsp
  0001f	48 89 84 24 c0
	03 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 305  : REGS*   regs;                           /* -> Regs                   */
; 306  : FILE*   fp;
; 307  : char    inputbuff[MAX_PATH];
; 308  : char*   inputline;
; 309  : char    filename[MAX_PATH];             /* filename of image file    */
; 310  : char    pathname[MAX_PATH];             /* pathname of image file    */
; 311  : U32     fileaddr;
; 312  : int     rc = 0;                         /* Return codes (work)       */

  00027	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 313  : 
; 314  : static const bool noisy =
; 315  : #if defined(_DEBUG) || defined(DEBUG)
; 316  :     true;
; 317  : #else
; 318  :     false;
; 319  : #endif
; 320  : 
; 321  :     /* Get started */
; 322  :     if (ARCH_DEP( common_load_begin )( cpu, clear ) != 0)

  0002f	8b 94 24 f0 03
	00 00		 mov	 edx, DWORD PTR clear$[rsp]
  00036	8b 8c 24 e8 03
	00 00		 mov	 ecx, DWORD PTR cpu$[rsp]
  0003d	e8 00 00 00 00	 call	 s370_common_load_begin
  00042	85 c0		 test	 eax, eax
  00044	74 0a		 je	 SHORT $LN5@s370_load_

; 323  :         return -1;

  00046	b8 ff ff ff ff	 mov	 eax, -1
  0004b	e9 e3 03 00 00	 jmp	 $LN1@s370_load_
$LN5@s370_load_:

; 324  : 
; 325  :     /* The actual IPL proper starts here... */
; 326  : 
; 327  :     regs = sysblk.regs[ cpu ];          /* Point to IPL CPU's regs   */

  00050	48 63 84 24 e8
	03 00 00	 movsxd	 rax, DWORD PTR cpu$[rsp]
  00058	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0005f	48 8b 84 c1 98
	0b 00 00	 mov	 rax, QWORD PTR [rcx+rax*8+2968]
  00067	48 89 44 24 68	 mov	 QWORD PTR regs$[rsp], rax

; 328  : 
; 329  :     if (fname == NULL)                  /* Default ipl from DASD     */

  0006c	48 83 bc 24 e0
	03 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  00075	75 0f		 jne	 SHORT $LN6@s370_load_

; 330  :         fname = "HERCULES.ins";         /*   from HERCULES.ins       */

  00077	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169678
  0007e	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR fname$[rsp], rax
$LN6@s370_load_:

; 331  : 
; 332  :     hostpath( pathname, fname, sizeof( pathname ));

  00086	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0008c	48 8b 94 24 e0
	03 00 00	 mov	 rdx, QWORD PTR fname$[rsp]
  00094	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 333  : 
; 334  :     if (!(fname = set_sce_basedir( pathname )))

  000a2	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  000aa	e8 00 00 00 00	 call	 set_sce_basedir
  000af	48 89 84 24 e0
	03 00 00	 mov	 QWORD PTR fname$[rsp], rax
  000b7	48 83 bc 24 e0
	03 00 00 00	 cmp	 QWORD PTR fname$[rsp], 0
  000c0	75 0a		 jne	 SHORT $LN7@s370_load_

; 335  :         return -1;

  000c2	b8 ff ff ff ff	 mov	 eax, -1
  000c7	e9 67 03 00 00	 jmp	 $LN1@s370_load_
$LN7@s370_load_:

; 336  : 
; 337  :     /* Construct and check full pathname */
; 338  :     if (!check_sce_filepath( fname, filename ))

  000cc	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  000d4	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  000dc	e8 00 00 00 00	 call	 check_sce_filepath
  000e1	48 85 c0	 test	 rax, rax
  000e4	75 7b		 jne	 SHORT $LN8@s370_load_

; 339  :     {
; 340  :         // "SCE file %s: load from file failed: %s"
; 341  :         WRMSG( HHC00601,"E", fname, strerror( errno ));

  000e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ec	8b 08		 mov	 ecx, DWORD PTR [rax]
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000f4	48 89 44 24 70	 mov	 QWORD PTR tv83[rsp], rax
  000f9	b9 01 00 00 00	 mov	 ecx, 1
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00104	48 8b 4c 24 70	 mov	 rcx, QWORD PTR tv83[rsp]
  00109	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0010e	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00116	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0011b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169681
  00122	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00127	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169682
  0012e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00133	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00138	41 b9 03 00 00
	00		 mov	 r9d, 3
  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169683
  00145	ba 55 01 00 00	 mov	 edx, 341		; 00000155H
  0014a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169684
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 342  :         return -1;

  00157	b8 ff ff ff ff	 mov	 eax, -1
  0015c	e9 d2 02 00 00	 jmp	 $LN1@s370_load_
$LN8@s370_load_:

; 343  :     }
; 344  : 
; 345  :     fp = fopen( filename, "r" );

  00161	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169685
  00168	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  00170	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00176	48 89 44 24 60	 mov	 QWORD PTR fp$[rsp], rax

; 346  :     if (fp == NULL)

  0017b	48 83 7c 24 60
	00		 cmp	 QWORD PTR fp$[rsp], 0
  00181	0f 85 87 00 00
	00		 jne	 $LN9@s370_load_

; 347  :     {
; 348  :         // "SCE file %s: error in function %s: %s"
; 349  :         WRMSG( HHC00600,"E", fname,"fopen()", strerror( errno ));

  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0018d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00195	48 89 44 24 78	 mov	 QWORD PTR tv133[rsp], rax
  0019a	b9 01 00 00 00	 mov	 ecx, 1
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a5	48 8b 4c 24 78	 mov	 rcx, QWORD PTR tv133[rsp]
  001aa	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169687
  001b6	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001bb	48 8b 8c 24 e0
	03 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001c3	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001c8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169688
  001cf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001d4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169689
  001db	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001e5	41 b9 03 00 00
	00		 mov	 r9d, 3
  001eb	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169690
  001f2	ba 5d 01 00 00	 mov	 edx, 349		; 0000015dH
  001f7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169691
  001fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 350  :         return -1;

  00204	b8 ff ff ff ff	 mov	 eax, -1
  00209	e9 25 02 00 00	 jmp	 $LN1@s370_load_
$LN9@s370_load_:
$LN4@s370_load_:

; 351  :     }
; 352  : 
; 353  :     do
; 354  :     {
; 355  :         inputline = fgets( inputbuff, sizeof( inputbuff ), fp );

  0020e	4c 8b 44 24 60	 mov	 r8, QWORD PTR fp$[rsp]
  00213	ba 04 01 00 00	 mov	 edx, 260		; 00000104H
  00218	48 8d 8c 24 b0
	02 00 00	 lea	 rcx, QWORD PTR inputbuff$[rsp]
  00220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgets
  00226	48 89 44 24 58	 mov	 QWORD PTR inputline$[rsp], rax

; 356  : 
; 357  : #if !defined(_MSVC_)
; 358  :         if (inputline && *inputline == 0x1a)
; 359  :             inputline = NULL;
; 360  : #endif
; 361  :         if (inputline)

  0022b	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00231	74 22		 je	 SHORT $LN10@s370_load_

; 362  :         {
; 363  :             rc = sscanf( inputline,"%" QSTR( MAX_PATH ) "s %i", filename, &fileaddr );

  00233	4c 8d 4c 24 54	 lea	 r9, QWORD PTR fileaddr$[rsp]
  00238	4c 8d 84 24 90
	00 00 00	 lea	 r8, QWORD PTR filename$[rsp]
  00240	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169693
  00247	48 8b 4c 24 58	 mov	 rcx, QWORD PTR inputline$[rsp]
  0024c	e8 00 00 00 00	 call	 sscanf
  00251	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax
$LN10@s370_load_:

; 364  :         }
; 365  : 
; 366  :         /* If no load address was found load to location zero */
; 367  :         if (inputline && rc < 2)

  00255	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  0025b	74 0f		 je	 SHORT $LN11@s370_load_
  0025d	83 7c 24 50 02	 cmp	 DWORD PTR rc$[rsp], 2
  00262	7d 08		 jge	 SHORT $LN11@s370_load_

; 368  :             fileaddr = 0;

  00264	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR fileaddr$[rsp], 0
$LN11@s370_load_:

; 369  : 
; 370  :         if (inputline && rc > 0 && *filename != '*' && *filename != '#')

  0026c	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00272	0f 84 9a 01 00
	00		 je	 $LN12@s370_load_
  00278	83 7c 24 50 00	 cmp	 DWORD PTR rc$[rsp], 0
  0027d	0f 8e 8f 01 00
	00		 jle	 $LN12@s370_load_
  00283	b8 01 00 00 00	 mov	 eax, 1
  00288	48 6b c0 00	 imul	 rax, rax, 0
  0028c	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  00294	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00297	0f 84 75 01 00
	00		 je	 $LN12@s370_load_
  0029d	b8 01 00 00 00	 mov	 eax, 1
  002a2	48 6b c0 00	 imul	 rax, rax, 0
  002a6	0f be 84 04 90
	00 00 00	 movsx	 eax, BYTE PTR filename$[rsp+rax]
  002ae	83 f8 23	 cmp	 eax, 35			; 00000023H
  002b1	0f 84 5b 01 00
	00		 je	 $LN12@s370_load_

; 371  :         {
; 372  :             hostpath( pathname, filename, sizeof( pathname ));

  002b7	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  002bd	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  002c5	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  002cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 373  : 
; 374  :             /* Construct and check full pathname */
; 375  :             if (!check_sce_filepath( pathname, filename ))

  002d3	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR filename$[rsp]
  002db	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  002e3	e8 00 00 00 00	 call	 check_sce_filepath
  002e8	48 85 c0	 test	 rax, rax
  002eb	0f 85 81 00 00
	00		 jne	 $LN13@s370_load_

; 376  :             {
; 377  :                 // "SCE file %s: load from path failed: %s"
; 378  :                 WRMSG( HHC00602,"E",pathname,strerror( errno ));

  002f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002f7	8b 08		 mov	 ecx, DWORD PTR [rax]
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  002ff	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv177[rsp], rax
  00307	b9 01 00 00 00	 mov	 ecx, 1
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00312	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv177[rsp]
  0031a	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  0031f	48 8d 8c 24 a0
	01 00 00	 lea	 rcx, QWORD PTR pathname$[rsp]
  00327	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0032c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169697
  00333	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00338	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169698
  0033f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00344	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00349	41 b9 03 00 00
	00		 mov	 r9d, 3
  0034f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169699
  00356	ba 7a 01 00 00	 mov	 edx, 378		; 0000017aH
  0035b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169700
  00362	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 379  :                 return -1;

  00368	b8 ff ff ff ff	 mov	 eax, -1
  0036d	e9 c1 00 00 00	 jmp	 $LN1@s370_load_
$LN13@s370_load_:

; 380  :             }
; 381  : 
; 382  :             if (ARCH_DEP( load_main )( filename, fileaddr, noisy ) < 0)

  00372	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR ?noisy@?1??s370_load_hmc@@9@9
  00379	8b 4c 24 54	 mov	 ecx, DWORD PTR fileaddr$[rsp]
  0037d	44 8b c0	 mov	 r8d, eax
  00380	8b d1		 mov	 edx, ecx
  00382	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR filename$[rsp]
  0038a	e8 00 00 00 00	 call	 s370_load_main
  0038f	85 c0		 test	 eax, eax
  00391	7d 43		 jge	 SHORT $LN14@s370_load_

; 383  :             {
; 384  :                 // Error!
; 385  :                 fclose( fp );

  00393	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00398	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 386  :                 HDC1( debug_cpu_state, regs );

  0039e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  003a5	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  003a9	74 18		 je	 SHORT $LN16@s370_load_
  003ab	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  003b0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_debug_cpu_state
  003b7	ff 10		 call	 QWORD PTR [rax]
  003b9	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv202[rsp], rax
  003c1	eb 0c		 jmp	 SHORT $LN17@s370_load_
$LN16@s370_load_:
  003c3	48 c7 84 24 88
	00 00 00 00 00
	00 00		 mov	 QWORD PTR tv202[rsp], 0
$LN17@s370_load_:

; 387  :                 return -1;

  003cf	b8 ff ff ff ff	 mov	 eax, -1
  003d4	eb 5d		 jmp	 SHORT $LN1@s370_load_
$LN14@s370_load_:

; 388  :             }
; 389  : 
; 390  :             sysblk.main_clear = sysblk.xpnd_clear = 0;

  003d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003dd	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  003e3	0f ba f0 0f	 btr	 eax, 15
  003e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003ee	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
  003f4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003fb	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00401	0f ba f0 0e	 btr	 eax, 14
  00405	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0040c	89 81 94 12 00
	00		 mov	 DWORD PTR [rcx+4756], eax
$LN12@s370_load_:

; 391  :         }
; 392  :     }
; 393  :     while (inputline);

  00412	48 83 7c 24 58
	00		 cmp	 QWORD PTR inputline$[rsp], 0
  00418	0f 85 f0 fd ff
	ff		 jne	 $LN4@s370_load_

; 394  : 
; 395  :     fclose( fp );

  0041e	48 8b 4c 24 60	 mov	 rcx, QWORD PTR fp$[rsp]
  00423	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_fclose

; 396  : 
; 397  :     /* Finish up... */
; 398  :     return ARCH_DEP( common_load_finish )( regs );

  00429	48 8b 4c 24 68	 mov	 rcx, QWORD PTR regs$[rsp]
  0042e	e8 00 00 00 00	 call	 s370_common_load_finish
$LN1@s370_load_:

; 399  : 
; 400  : } /* end function load_hmc */

  00433	48 8b 8c 24 c0
	03 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0043b	48 33 cc	 xor	 rcx, rsp
  0043e	e8 00 00 00 00	 call	 __security_check_cookie
  00443	48 81 c4 d8 03
	00 00		 add	 rsp, 984		; 000003d8H
  0044a	c3		 ret	 0
s370_load_hmc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
tv65 = 32
p$1 = 40
fname$ = 64
cpu$ = 72
clear$ = 80
load_hmc PROC

; 1026 : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1027 :     switch (sysblk.arch_mode)

  00012	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00019	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0001f	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00023	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  00028	74 10		 je	 SHORT $LN7@load_hmc
  0002a	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  0002f	74 1e		 je	 SHORT $LN8@load_hmc
  00031	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  00036	74 2c		 je	 SHORT $LN9@load_hmc
  00038	eb 3f		 jmp	 SHORT $LN10@load_hmc
$LN7@load_hmc:

; 1028 :     {
; 1029 : #if defined(       _370 )
; 1030 :         case   ARCH_370_IDX:
; 1031 :             return s370_load_hmc (fname, cpu, clear);

  0003a	44 8b 44 24 50	 mov	 r8d, DWORD PTR clear$[rsp]
  0003f	8b 54 24 48	 mov	 edx, DWORD PTR cpu$[rsp]
  00043	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fname$[rsp]
  00048	e8 00 00 00 00	 call	 s370_load_hmc
  0004d	eb 41		 jmp	 SHORT $LN1@load_hmc
$LN8@load_hmc:

; 1032 : #endif
; 1033 : #if defined(       _390 )
; 1034 :         case   ARCH_390_IDX:
; 1035 :             return s390_load_hmc (fname, cpu, clear);

  0004f	44 8b 44 24 50	 mov	 r8d, DWORD PTR clear$[rsp]
  00054	8b 54 24 48	 mov	 edx, DWORD PTR cpu$[rsp]
  00058	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fname$[rsp]
  0005d	e8 00 00 00 00	 call	 s390_load_hmc
  00062	eb 2c		 jmp	 SHORT $LN1@load_hmc
$LN9@load_hmc:

; 1036 : #endif
; 1037 : #if defined(       _900 )
; 1038 :         case   ARCH_900_IDX:
; 1039 :             /* z/Arch always starts out in ESA390 mode */
; 1040 :             return s390_load_hmc (fname, cpu, clear);

  00064	44 8b 44 24 50	 mov	 r8d, DWORD PTR clear$[rsp]
  00069	8b 54 24 48	 mov	 edx, DWORD PTR cpu$[rsp]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fname$[rsp]
  00072	e8 00 00 00 00	 call	 s390_load_hmc
  00077	eb 17		 jmp	 SHORT $LN1@load_hmc
$LN10@load_hmc:
$LN6@load_hmc:

; 1041 : #endif
; 1042 :         default: CRASH();

  00079	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00082	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  00087	c6 00 00	 mov	 BYTE PTR [rax], 0
  0008a	33 c0		 xor	 eax, eax
  0008c	85 c0		 test	 eax, eax
  0008e	75 e9		 jne	 SHORT $LN6@load_hmc
$LN1@load_hmc:
$LN11@load_hmc:

; 1043 :     }
; 1044 :     UNREACHABLE_CODE( return -1 );
; 1045 : }

  00090	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00094	c3		 ret	 0
load_hmc ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
fd$ = 80
bytes$ = 84
aaddr$ = 88
pages$ = 96
rc$1 = 100
tv155 = 104
chunk$ = 112
pageaddr$ = 120
loaded$ = 128
curtime$ = 136
begtime$ = 144
tv70 = 152
tv133 = 160
tv193 = 168
fmt_mem$ = 176
__$ArrayPad$ = 184
fname$ = 208
startloc$ = 216
noisy$ = 224
s370_load_main PROC

; 169  : {

$LN23:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00016	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001d	48 33 c4	 xor	 rax, rsp
  00020	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 170  : U64     loaded;
; 171  : RADR    aaddr;
; 172  : RADR    pageaddr;
; 173  : int     fd;
; 174  : int     pages;
; 175  : size_t  chunk;
; 176  : int     bytes;
; 177  : time_t  begtime, curtime;
; 178  : char    fmt_mem[8];
; 179  : 
; 180  :     fd = HOPEN( fname, O_RDONLY | O_BINARY );

  00028	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  0002d	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_hopen
  0003b	89 44 24 50	 mov	 DWORD PTR fd$[rsp], eax

; 181  : 
; 182  :     if (fd < 0)

  0003f	83 7c 24 50 00	 cmp	 DWORD PTR fd$[rsp], 0
  00044	0f 8d 9b 00 00
	00		 jge	 $LN8@s370_load_

; 183  :     {
; 184  :         if (errno != ENOENT)

  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00050	83 38 02	 cmp	 DWORD PTR [rax], 2
  00053	0f 84 83 00 00
	00		 je	 $LN9@s370_load_

; 185  :             // "SCE file %s: error in function %s: %s"
; 186  :             WRMSG( HHC00600, "E", fname, "open()", strerror( errno ));

  00059	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0005f	8b 08		 mov	 ecx, DWORD PTR [rax]
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00067	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  0006f	b9 01 00 00 00	 mov	 ecx, 1
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0007a	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  00082	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169624
  0008e	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00093	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0009b	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169625
  000a7	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000ac	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169626
  000b3	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000b8	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000bd	41 b9 03 00 00
	00		 mov	 r9d, 3
  000c3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169627
  000ca	ba ba 00 00 00	 mov	 edx, 186		; 000000baH
  000cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169628
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@s370_load_:

; 187  :         return fd;

  000dc	8b 44 24 50	 mov	 eax, DWORD PTR fd$[rsp]
  000e0	e9 b9 03 00 00	 jmp	 $LN1@s370_load_
$LN8@s370_load_:

; 188  :     }
; 189  : 
; 190  :     /* Calculate size of first chunk to reach page boundary */
; 191  :     chunk = PAGEFRAME_PAGESIZE - (startloc & PAGEFRAME_BYTEMASK);

  000e5	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR startloc$[rsp]
  000ed	48 25 ff 07 00
	00		 and	 rax, 2047		; 000007ffH
  000f3	b9 00 08 00 00	 mov	 ecx, 2048		; 00000800H
  000f8	48 2b c8	 sub	 rcx, rax
  000fb	48 8b c1	 mov	 rax, rcx
  000fe	48 89 44 24 70	 mov	 QWORD PTR chunk$[rsp], rax

; 192  :     aaddr = startloc;

  00103	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR startloc$[rsp]
  0010b	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 193  : 
; 194  :     if (noisy)

  00110	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  00118	74 19		 je	 SHORT $LN10@s370_load_

; 195  :     {
; 196  :         loaded = 0;

  0011a	48 c7 84 24 80
	00 00 00 00 00
	00 00		 mov	 QWORD PTR loaded$[rsp], 0

; 197  :         time( &begtime );

  00126	48 8d 8c 24 90
	00 00 00	 lea	 rcx, QWORD PTR begtime$[rsp]
  0012e	e8 00 00 00 00	 call	 time
$LN10@s370_load_:
$LN2@s370_load_:

; 198  :     }
; 199  : 
; 200  :     /* Read file into storage until end of file or end of storage */
; 201  :     for (;;)
; 202  :     {
; 203  :         if (chunk > (sysblk.mainsize - aaddr))

  00133	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0013a	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0013f	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00146	48 2b c1	 sub	 rax, rcx
  00149	48 39 44 24 70	 cmp	 QWORD PTR chunk$[rsp], rax
  0014e	76 1b		 jbe	 SHORT $LN11@s370_load_

; 204  :             chunk = (sysblk.mainsize - aaddr);

  00150	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00157	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  0015c	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00163	48 2b c1	 sub	 rax, rcx
  00166	48 89 44 24 70	 mov	 QWORD PTR chunk$[rsp], rax
$LN11@s370_load_:

; 205  : 
; 206  :         bytes = read( fd, sysblk.mainstor + aaddr, chunk );

  0016b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00172	48 8b 80 98 00
	00 00		 mov	 rax, QWORD PTR [rax+152]
  00179	48 03 44 24 58	 add	 rax, QWORD PTR aaddr$[rsp]
  0017e	44 8b 44 24 70	 mov	 r8d, DWORD PTR chunk$[rsp]
  00183	48 8b d0	 mov	 rdx, rax
  00186	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00190	89 44 24 54	 mov	 DWORD PTR bytes$[rsp], eax

; 207  : 
; 208  :         chunk = CHUNKSIZE;

  00194	48 c7 44 24 70
	00 00 00 04	 mov	 QWORD PTR chunk$[rsp], 67108864 ; 04000000H

; 209  : 
; 210  :         /* Check for I/O error */
; 211  :         if (bytes < 0)

  0019d	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  001a2	0f 8d 97 00 00
	00		 jge	 $LN12@s370_load_

; 212  :         {
; 213  :             // "SCE file %s: error in function %s: %s"
; 214  :             WRMSG( HHC00600, "E", fname, "read()",strerror( errno ));

  001a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001ae	8b 08		 mov	 ecx, DWORD PTR [rax]
  001b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001be	b9 01 00 00 00	 mov	 ecx, 1
  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001c9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001d1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169632
  001dd	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  001e2	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  001ea	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169633
  001f6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169634
  00202	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00207	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020c	41 b9 03 00 00
	00		 mov	 r9d, 3
  00212	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169635
  00219	ba d6 00 00 00	 mov	 edx, 214		; 000000d6H
  0021e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169636
  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 215  :             close( fd );

  0022b	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 216  :             return -1;

  00235	b8 ff ff ff ff	 mov	 eax, -1
  0023a	e9 5f 02 00 00	 jmp	 $LN1@s370_load_
$LN12@s370_load_:

; 217  :         }
; 218  : 
; 219  :         /* Check for end-of-file */
; 220  :         if (bytes == 0)

  0023f	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  00244	75 11		 jne	 SHORT $LN13@s370_load_

; 221  :         {
; 222  :             close( fd );

  00246	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0024a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 223  :             return 0;

  00250	33 c0		 xor	 eax, eax
  00252	e9 47 02 00 00	 jmp	 $LN1@s370_load_
$LN13@s370_load_:

; 224  :         }
; 225  : 
; 226  :         /* Update the storage keys for all of the pages we just read */
; 227  :         pages = ROUND_UP( bytes, PAGEFRAME_PAGESIZE ) / PAGEFRAME_PAGESIZE;

  00257	83 7c 24 54 00	 cmp	 DWORD PTR bytes$[rsp], 0
  0025c	74 21		 je	 SHORT $LN21@s370_load_
  0025e	8b 44 24 54	 mov	 eax, DWORD PTR bytes$[rsp]
  00262	05 ff 07 00 00	 add	 eax, 2047		; 000007ffH
  00267	99		 cdq
  00268	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  0026e	03 c2		 add	 eax, edx
  00270	c1 f8 0b	 sar	 eax, 11
  00273	69 c0 00 08 00
	00		 imul	 eax, eax, 2048		; 00000800H
  00279	89 44 24 68	 mov	 DWORD PTR tv155[rsp], eax
  0027d	eb 08		 jmp	 SHORT $LN22@s370_load_
$LN21@s370_load_:
  0027f	c7 44 24 68 00
	08 00 00	 mov	 DWORD PTR tv155[rsp], 2048 ; 00000800H
$LN22@s370_load_:
  00287	8b 44 24 68	 mov	 eax, DWORD PTR tv155[rsp]
  0028b	99		 cdq
  0028c	81 e2 ff 07 00
	00		 and	 edx, 2047		; 000007ffH
  00292	03 c2		 add	 eax, edx
  00294	c1 f8 0b	 sar	 eax, 11
  00297	89 44 24 60	 mov	 DWORD PTR pages$[rsp], eax

; 228  :         pageaddr = aaddr;

  0029b	48 8b 44 24 58	 mov	 rax, QWORD PTR aaddr$[rsp]
  002a0	48 89 44 24 78	 mov	 QWORD PTR pageaddr$[rsp], rax
$LN7@s370_load_:

; 229  : 
; 230  :         do
; 231  :         {
; 232  :             ARCH_DEP( or_storage_key )( pageaddr, STORKEY_REF | STORKEY_CHANGE );

  002a5	b2 06		 mov	 dl, 6
  002a7	48 8b 4c 24 78	 mov	 rcx, QWORD PTR pageaddr$[rsp]
  002ac	e8 00 00 00 00	 call	 s370_or_storage_key

; 233  :             pageaddr += PAGEFRAME_PAGESIZE;

  002b1	48 8b 44 24 78	 mov	 rax, QWORD PTR pageaddr$[rsp]
  002b6	48 05 00 08 00
	00		 add	 rax, 2048		; 00000800H
  002bc	48 89 44 24 78	 mov	 QWORD PTR pageaddr$[rsp], rax

; 234  :         }
; 235  :         while (--pages);

  002c1	8b 44 24 60	 mov	 eax, DWORD PTR pages$[rsp]
  002c5	ff c8		 dec	 eax
  002c7	89 44 24 60	 mov	 DWORD PTR pages$[rsp], eax
  002cb	83 7c 24 60 00	 cmp	 DWORD PTR pages$[rsp], 0
  002d0	75 d3		 jne	 SHORT $LN7@s370_load_

; 236  : 
; 237  :         aaddr += bytes;

  002d2	48 63 44 24 54	 movsxd	 rax, DWORD PTR bytes$[rsp]
  002d7	48 8b 4c 24 58	 mov	 rcx, QWORD PTR aaddr$[rsp]
  002dc	48 03 c8	 add	 rcx, rax
  002df	48 8b c1	 mov	 rax, rcx
  002e2	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 238  :         aaddr &= PAGEFRAME_PAGEMASK;

  002e7	48 8b 44 24 58	 mov	 rax, QWORD PTR aaddr$[rsp]
  002ec	48 25 00 f8 ff
	7f		 and	 rax, 2147481600		; 7ffff800H
  002f2	48 89 44 24 58	 mov	 QWORD PTR aaddr$[rsp], rax

; 239  : 
; 240  :         /* Check if end of storge reached */
; 241  :         if (aaddr >= sysblk.mainsize)

  002f7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002fe	48 8b 80 90 00
	00 00		 mov	 rax, QWORD PTR [rax+144]
  00305	48 39 44 24 58	 cmp	 QWORD PTR aaddr$[rsp], rax
  0030a	0f 82 9c 00 00
	00		 jb	 $LN14@s370_load_

; 242  :         {
; 243  :             int rc;
; 244  :        
; 245  :             if (read( fd, &rc, 1 ) > 0)

  00310	41 b8 01 00 00
	00		 mov	 r8d, 1
  00316	48 8d 54 24 64	 lea	 rdx, QWORD PTR rc$1[rsp]
  0031b	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0031f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read
  00325	85 c0		 test	 eax, eax
  00327	7e 68		 jle	 SHORT $LN15@s370_load_

; 246  :             {
; 247  :                 rc = +1;

  00329	c7 44 24 64 01
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 1

; 248  : 
; 249  :                 if (noisy)

  00331	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  00339	74 54		 je	 SHORT $LN17@s370_load_

; 250  :                 {
; 251  :                     // "SCE file %s: load main terminated at end of mainstor"
; 252  :                     WRMSG( HHC00603, "W", fname );

  0033b	b9 01 00 00 00	 mov	 ecx, 1
  00340	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00346	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR fname$[rsp]
  0034e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00353	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169642
  0035a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0035f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169643
  00366	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0036b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00370	41 b9 03 00 00
	00		 mov	 r9d, 3
  00376	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169644
  0037d	ba fc 00 00 00	 mov	 edx, 252		; 000000fcH
  00382	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169645
  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN17@s370_load_:

; 253  :                 }
; 254  :             }

  0038f	eb 08		 jmp	 SHORT $LN16@s370_load_
$LN15@s370_load_:

; 255  :             else /* ignore any error; we're at end of storage anyway */
; 256  :                 rc = 0;

  00391	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR rc$1[rsp], 0
$LN16@s370_load_:

; 257  : 
; 258  :             close( fd );

  00399	8b 4c 24 50	 mov	 ecx, DWORD PTR fd$[rsp]
  0039d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 259  :             return rc;

  003a3	8b 44 24 64	 mov	 eax, DWORD PTR rc$1[rsp]
  003a7	e9 f2 00 00 00	 jmp	 $LN1@s370_load_
$LN14@s370_load_:

; 260  :         }
; 261  : 
; 262  :         /* Issue periodic progress messages */
; 263  :         if (noisy)

  003ac	83 bc 24 e0 00
	00 00 00	 cmp	 DWORD PTR noisy$[rsp], 0
  003b4	0f 84 df 00 00
	00		 je	 $LN18@s370_load_

; 264  :         {
; 265  :             loaded += bytes;

  003ba	48 63 44 24 54	 movsxd	 rax, DWORD PTR bytes$[rsp]
  003bf	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR loaded$[rsp]
  003c7	48 03 c8	 add	 rcx, rax
  003ca	48 8b c1	 mov	 rax, rcx
  003cd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR loaded$[rsp], rax

; 266  :             time( &curtime );

  003d5	48 8d 8c 24 88
	00 00 00	 lea	 rcx, QWORD PTR curtime$[rsp]
  003dd	e8 00 00 00 00	 call	 time

; 267  : 
; 268  :             if (difftime( curtime, begtime ) > 2.0)

  003e2	48 8b 94 24 90
	00 00 00	 mov	 rdx, QWORD PTR begtime$[rsp]
  003ea	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR curtime$[rsp]
  003f2	e8 00 00 00 00	 call	 difftime
  003f7	66 0f 2f 05 00
	00 00 00	 comisd	 xmm0, QWORD PTR __real@4000000000000000
  003ff	0f 86 94 00 00
	00		 jbe	 $LN19@s370_load_

; 269  :             {
; 270  :                 begtime = curtime;

  00405	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR curtime$[rsp]
  0040d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR begtime$[rsp], rax

; 271  : 
; 272  :                 // "%s bytes %s so far..."
; 273  :                 WRMSG( HHC02317, "I",

  00415	41 b8 08 00 00
	00		 mov	 r8d, 8
  0041b	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR fmt_mem$[rsp]
  00423	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR loaded$[rsp]
  0042b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fmt_memsize
  00431	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR tv193[rsp], rax
  00439	b9 01 00 00 00	 mov	 ecx, 1
  0043e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00444	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169648
  0044b	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00450	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv193[rsp]
  00458	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0045d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169649
  00464	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00469	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169650
  00470	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00475	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0047a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00480	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169651
  00487	ba 13 01 00 00	 mov	 edx, 275		; 00000113H
  0048c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169652
  00493	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN19@s370_load_:
$LN18@s370_load_:

; 274  :                     fmt_memsize( loaded, fmt_mem, sizeof( fmt_mem )),
; 275  :                         "loaded" );
; 276  :             }
; 277  :         }
; 278  :     } /* end for (;;) */

  00499	e9 95 fc ff ff	 jmp	 $LN2@s370_load_
$LN1@s370_load_:

; 279  : 
; 280  : } /* end function load_main */

  0049e	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  004a6	48 33 cc	 xor	 rcx, rsp
  004a9	e8 00 00 00 00	 call	 __security_check_cookie
  004ae	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  004b5	c3		 ret	 0
s370_load_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
tv65 = 32
p$1 = 40
fname$ = 64
startloc$ = 72
noisy$ = 80
load_main PROC

; 1051 : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1052 :     switch (sysblk.arch_mode)

  00013	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001a	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00020	89 44 24 20	 mov	 DWORD PTR tv65[rsp], eax
  00024	83 7c 24 20 00	 cmp	 DWORD PTR tv65[rsp], 0
  00029	74 10		 je	 SHORT $LN7@load_main
  0002b	83 7c 24 20 01	 cmp	 DWORD PTR tv65[rsp], 1
  00030	74 1f		 je	 SHORT $LN8@load_main
  00032	83 7c 24 20 02	 cmp	 DWORD PTR tv65[rsp], 2
  00037	74 2e		 je	 SHORT $LN9@load_main
  00039	eb 42		 jmp	 SHORT $LN10@load_main
$LN7@load_main:

; 1053 :     {
; 1054 : #if defined(       _370 )
; 1055 :         case   ARCH_370_IDX:
; 1056 :             return s370_load_main (fname, startloc, noisy);

  0003b	44 8b 44 24 50	 mov	 r8d, DWORD PTR noisy$[rsp]
  00040	48 8b 54 24 48	 mov	 rdx, QWORD PTR startloc$[rsp]
  00045	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fname$[rsp]
  0004a	e8 00 00 00 00	 call	 s370_load_main
  0004f	eb 43		 jmp	 SHORT $LN1@load_main
$LN8@load_main:

; 1057 : #endif
; 1058 : #if defined(       _390 )
; 1059 :         case   ARCH_390_IDX:
; 1060 :             return s390_load_main (fname, startloc, noisy);

  00051	44 8b 44 24 50	 mov	 r8d, DWORD PTR noisy$[rsp]
  00056	48 8b 54 24 48	 mov	 rdx, QWORD PTR startloc$[rsp]
  0005b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fname$[rsp]
  00060	e8 00 00 00 00	 call	 s390_load_main
  00065	eb 2d		 jmp	 SHORT $LN1@load_main
$LN9@load_main:

; 1061 : #endif
; 1062 : #if defined(       _900 )
; 1063 :         case   ARCH_900_IDX:
; 1064 :             return z900_load_main (fname, startloc, noisy);

  00067	44 8b 44 24 50	 mov	 r8d, DWORD PTR noisy$[rsp]
  0006c	48 8b 54 24 48	 mov	 rdx, QWORD PTR startloc$[rsp]
  00071	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fname$[rsp]
  00076	e8 00 00 00 00	 call	 z900_load_main
  0007b	eb 17		 jmp	 SHORT $LN1@load_main
$LN10@load_main:
$LN6@load_main:

; 1065 : #endif
; 1066 :         default: CRASH();

  0007d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR p$1[rsp], 0
  00086	48 8b 44 24 28	 mov	 rax, QWORD PTR p$1[rsp]
  0008b	c6 00 00	 mov	 BYTE PTR [rax], 0
  0008e	33 c0		 xor	 eax, eax
  00090	85 c0		 test	 eax, eax
  00092	75 e9		 jne	 SHORT $LN6@load_main
$LN1@load_main:
$LN11@load_main:

; 1067 :     }
; 1068 :     UNREACHABLE_CODE( return -1 );
; 1069 : }

  00094	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00098	c3		 ret	 0
load_main ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
get_sce_dir PROC

; 32   :     return sce_basedir;

  00000	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR sce_basedir

; 33   : }

  00007	c3		 ret	 0
get_sce_dir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scedasd.c
_TEXT	SEGMENT
tv71 = 80
realdir$ = 96
tempdir$ = 368
__$ArrayPad$ = 640
path$ = 672
set_sce_dir PROC

; 38   : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 98 02
	00 00		 sub	 rsp, 664		; 00000298H
  0000c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00013	48 33 c4	 xor	 rax, rsp
  00016	48 89 84 24 80
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 39   : char realdir[ MAX_PATH ];
; 40   : char tempdir[ MAX_PATH ];
; 41   : 
; 42   :     if (sce_basedir)

  0001e	48 83 3d 00 00
	00 00 00	 cmp	 QWORD PTR sce_basedir, 0
  00026	74 18		 je	 SHORT $LN2@set_sce_di

; 43   :     {
; 44   :         free( sce_basedir );

  00028	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR sce_basedir
  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 45   :         sce_basedir = NULL;

  00035	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sce_basedir, 0
$LN2@set_sce_di:

; 46   :     }
; 47   : 
; 48   :     if (!path)

  00040	48 83 bc 24 a0
	02 00 00 00	 cmp	 QWORD PTR path$[rsp], 0
  00049	75 10		 jne	 SHORT $LN3@set_sce_di

; 49   :         sce_basedir = NULL;

  0004b	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sce_basedir, 0
  00056	e9 ec 00 00 00	 jmp	 $LN4@set_sce_di
$LN3@set_sce_di:

; 50   :     else
; 51   :     {
; 52   :         if (!realpath( path, tempdir ))

  0005b	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR tempdir$[rsp]
  00063	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_realpath
  00071	48 85 c0	 test	 rax, rax
  00074	0f 85 8a 00 00
	00		 jne	 $LN5@set_sce_di

; 53   :         {
; 54   :             // "SCE file %s: error in function %s: %s"
; 55   :             WRMSG( HHC00600, "E", path, "realpath()", strerror( errno ));

  0007a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00080	8b 08		 mov	 ecx, DWORD PTR [rax]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00088	48 89 44 24 50	 mov	 QWORD PTR tv71[rsp], rax
  0008d	b9 01 00 00 00	 mov	 ecx, 1
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00098	48 8b 4c 24 50	 mov	 rcx, QWORD PTR tv71[rsp]
  0009d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000a2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169554
  000a9	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  000ae	48 8b 8c 24 a0
	02 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  000b6	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  000bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169555
  000c2	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000c7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169556
  000ce	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000d3	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000d8	41 b9 03 00 00
	00		 mov	 r9d, 3
  000de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169557
  000e5	ba 37 00 00 00	 mov	 edx, 55			; 00000037H
  000ea	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169558
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 56   :             sce_basedir = NULL;

  000f7	48 c7 05 00 00
	00 00 00 00 00
	00		 mov	 QWORD PTR sce_basedir, 0

; 57   :         }

  00102	eb 43		 jmp	 SHORT $LN6@set_sce_di
$LN5@set_sce_di:

; 58   :         else
; 59   :         {
; 60   :             hostpath( realdir, tempdir, sizeof( realdir ));

  00104	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  0010a	48 8d 94 24 70
	01 00 00	 lea	 rdx, QWORD PTR tempdir$[rsp]
  00112	48 8d 4c 24 60	 lea	 rcx, QWORD PTR realdir$[rsp]
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hostpath

; 61   :             STRLCAT( realdir, PATHSEPS );

  0011d	41 b8 04 01 00
	00		 mov	 r8d, 260		; 00000104H
  00123	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169559
  0012a	48 8d 4c 24 60	 lea	 rcx, QWORD PTR realdir$[rsp]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strlcat

; 62   :             sce_basedir = strdup( realdir );

  00135	48 8d 4c 24 60	 lea	 rcx, QWORD PTR realdir$[rsp]
  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strdup
  00140	48 89 05 00 00
	00 00		 mov	 QWORD PTR sce_basedir, rax
$LN6@set_sce_di:
$LN4@set_sce_di:

; 63   :         }
; 64   :     }
; 65   : }

  00147	48 8b 8c 24 80
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0014f	48 33 cc	 xor	 rcx, rsp
  00152	e8 00 00 00 00	 call	 __security_check_cookie
  00157	48 81 c4 98 02
	00 00		 add	 rsp, 664		; 00000298H
  0015e	c3		 ret	 0
set_sce_dir ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time$ = 48
time	PROC

; 521  :         {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 522  :             return _time64(_Time);

  00009	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time$[rsp]
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64

; 523  :         }

  00014	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00018	c3		 ret	 0
time	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\time.h
_TEXT	SEGMENT
_Time1$ = 48
_Time2$ = 56
difftime PROC

; 483  :         {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 484  :             return _difftime64(_Time1, _Time2);

  0000e	48 8b 54 24 38	 mov	 rdx, QWORD PTR _Time2$[rsp]
  00013	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Time1$[rsp]
  00018	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__difftime64

; 485  :         }

  0001e	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00022	c3		 ret	 0
difftime ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT sscanf
_TEXT	SEGMENT
_Result$ = 32
_ArgList$ = 40
_Buffer$ = 64
_Format$ = 72
sscanf	PROC						; COMDAT

; 2247 :     {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2248 :         int _Result;
; 2249 :         va_list _ArgList;
; 2250 :         __crt_va_start(_ArgList, _Format);

  00018	48 8d 44 24 50	 lea	 rax, QWORD PTR _Format$[rsp+8]
  0001d	48 89 44 24 28	 mov	 QWORD PTR _ArgList$[rsp], rax

; 2251 :         _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);

  00022	4c 8b 4c 24 28	 mov	 r9, QWORD PTR _ArgList$[rsp]
  00027	45 33 c0	 xor	 r8d, r8d
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR _Format$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  00034	e8 00 00 00 00	 call	 _vsscanf_l
  00039	89 44 24 20	 mov	 DWORD PTR _Result$[rsp], eax

; 2252 :         __crt_va_end(_ArgList);

  0003d	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR _ArgList$[rsp], 0

; 2253 :         return _Result;

  00046	8b 44 24 20	 mov	 eax, DWORD PTR _Result$[rsp]

; 2254 :     }

  0004a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004e	c3		 ret	 0
sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsscanf_l
_TEXT	SEGMENT
_Buffer$ = 64
_Format$ = 72
_Locale$ = 80
_ArgList$ = 88
_vsscanf_l PROC						; COMDAT

; 2152 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2153 :         return __stdio_common_vsscanf(

  00018	e8 00 00 00 00	 call	 __local_stdio_scanf_options
  0001d	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00022	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00027	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _Locale$[rsp]
  0002c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00031	4c 8b 4c 24 48	 mov	 r9, QWORD PTR _Format$[rsp]
  00036	49 c7 c0 ff ff
	ff ff		 mov	 r8, -1
  0003d	48 8b 54 24 40	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00042	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsscanf

; 2154 :             _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2155 :             _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2156 :     }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
_vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_scanf_options
_TEXT	SEGMENT
__local_stdio_scanf_options PROC			; COMDAT

; 101  :         static unsigned __int64 _OptionsStorage;
; 102  :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_scanf_options@@9@9 ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 103  :     }

  00007	c3		 ret	 0
__local_stdio_scanf_options ENDP
_TEXT	ENDS
END
