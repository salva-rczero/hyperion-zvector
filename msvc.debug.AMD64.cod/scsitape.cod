; Listing generated by Microsoft (R) Optimizing Compiler Version 19.34.31937.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
CKD_ENDTRK DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
	DB	0ffH
CONST	ENDS
PUBLIC	__local_stdio_printf_options
PUBLIC	_vsnprintf_s_l
PUBLIC	_vsnprintf_s
PUBLIC	update_status_scsitape
PUBLIC	open_scsitape
PUBLIC	finish_scsitape_open
PUBLIC	close_scsitape
PUBLIC	read_scsitape
PUBLIC	write_scsitape
PUBLIC	rewind_scsitape
PUBLIC	bsb_scsitape
PUBLIC	fsb_scsitape
PUBLIC	bsf_scsitape
PUBLIC	fsf_scsitape
PUBLIC	write_scsimark
PUBLIC	sync_scsitape
PUBLIC	dse_scsitape
PUBLIC	erg_scsitape
PUBLIC	is_tape_mounted_scsitape
PUBLIC	passedeot_scsitape
PUBLIC	readblkid_scsitape
PUBLIC	locateblk_scsitape
PUBLIC	int_scsi_rewind_unload
PUBLIC	int_scsi_status_update
PUBLIC	int_scsi_status_mounted
PUBLIC	int_write_scsimark
PUBLIC	blockid_emulated_to_actual
PUBLIC	blockid_actual_to_emulated
PUBLIC	blockid_32_to_22
PUBLIC	blockid_22_to_32
PUBLIC	create_automount_thread
PUBLIC	scsi_tapemountmon_thread
PUBLIC	define_BOT_pos
EXTRN	__imp__errno:PROC
EXTRN	__imp_IsDebuggerPresent:PROC
EXTRN	__imp_OutputDebugStringA:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	_byteswap_ulong:PROC
EXTRN	__imp___acrt_iob_func:PROC
EXTRN	__imp___stdio_common_vsnprintf_s:PROC
EXTRN	__imp_fthread_self:PROC
EXTRN	__imp_hthread_obtain_lock:PROC
EXTRN	__imp_hthread_release_lock:PROC
EXTRN	__imp_hthread_broadcast_condition:PROC
EXTRN	__imp_hthread_wait_condition:PROC
EXTRN	__imp_hthread_create_thread:PROC
EXTRN	__imp_hthread_set_thread_prio:PROC
EXTRN	__imp_hthread_get_thread_prio:PROC
EXTRN	__imp_timed_wait_condition_relative_usecs_impl:PROC
EXTRN	__imp_w32_strerror:PROC
EXTRN	__imp_gettimeofday:PROC
EXTRN	__imp_device_attention:PROC
EXTRN	__imp_fwritemsg:PROC
EXTRN	__imp_logmsg:PROC
EXTRN	build_senseX:PROC
EXTRN	__imp_w32_open_tape:PROC
EXTRN	__imp_w32_define_BOT:PROC
EXTRN	__imp_w32_ioctl_tape:PROC
EXTRN	__imp_w32_close_tape:PROC
EXTRN	__imp_w32_read_tape:PROC
EXTRN	__imp_w32_write_tape:PROC
EXTRN	gstat2str:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp_sysblk:BYTE
EXTRN	__security_cookie:QWORD
_DATA	SEGMENT
COMM	?_OptionsStorage@?1??__local_stdio_printf_options@@9@9:QWORD							; `__local_stdio_printf_options'::`2'::_OptionsStorage
_DATA	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s_l DD imagerel $LN5
	DD	imagerel $LN5+127
	DD	imagerel $unwind$_vsnprintf_s_l
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$_vsnprintf_s DD imagerel $LN3
	DD	imagerel $LN3+73
	DD	imagerel $unwind$_vsnprintf_s
pdata	ENDS
pdata	SEGMENT
$pdata$DebuggerTrace DD imagerel DebuggerTrace
	DD	imagerel DebuggerTrace+247
	DD	imagerel $unwind$DebuggerTrace
$pdata$is_tape_feat DD imagerel is_tape_feat
	DD	imagerel is_tape_feat+94
	DD	imagerel $unwind$is_tape_feat
$pdata$update_status_scsitape DD imagerel $LN4
	DD	imagerel $LN4+44
	DD	imagerel $unwind$update_status_scsitape
$pdata$open_scsitape DD imagerel $LN26
	DD	imagerel $LN26+1180
	DD	imagerel $unwind$open_scsitape
$pdata$finish_scsitape_open DD imagerel $LN26
	DD	imagerel $LN26+1532
	DD	imagerel $unwind$finish_scsitape_open
$pdata$close_scsitape DD imagerel $LN16
	DD	imagerel $LN16+1036
	DD	imagerel $unwind$close_scsitape
$pdata$read_scsitape DD imagerel $LN11
	DD	imagerel $LN11+522
	DD	imagerel $unwind$read_scsitape
$pdata$write_scsitape DD imagerel $LN17
	DD	imagerel $LN17+823
	DD	imagerel $unwind$write_scsitape
$pdata$rewind_scsitape DD imagerel $LN11
	DD	imagerel $LN11+668
	DD	imagerel $unwind$rewind_scsitape
$pdata$bsb_scsitape DD imagerel $LN15
	DD	imagerel $LN15+946
	DD	imagerel $unwind$bsb_scsitape
$pdata$fsb_scsitape DD imagerel $LN18
	DD	imagerel $LN18+830
	DD	imagerel $unwind$fsb_scsitape
$pdata$bsf_scsitape DD imagerel $LN14
	DD	imagerel $LN14+826
	DD	imagerel $unwind$bsf_scsitape
$pdata$fsf_scsitape DD imagerel $LN18
	DD	imagerel $LN18+781
	DD	imagerel $unwind$fsf_scsitape
$pdata$write_scsimark DD imagerel $LN20
	DD	imagerel $LN20+748
	DD	imagerel $unwind$write_scsimark
$pdata$sync_scsitape DD imagerel $LN20
	DD	imagerel $LN20+843
	DD	imagerel $unwind$sync_scsitape
$pdata$dse_scsitape DD imagerel $LN8
	DD	imagerel $LN8+388
	DD	imagerel $unwind$dse_scsitape
$pdata$erg_scsitape DD imagerel $LN13
	DD	imagerel $LN13+610
	DD	imagerel $unwind$erg_scsitape
$pdata$is_tape_mounted_scsitape DD imagerel $LN9
	DD	imagerel $LN9+63
	DD	imagerel $unwind$is_tape_mounted_scsitape
$pdata$readblkid_scsitape DD imagerel $LN7
	DD	imagerel $LN7+458
	DD	imagerel $unwind$readblkid_scsitape
$pdata$locateblk_scsitape DD imagerel $LN11
	DD	imagerel $LN11+449
	DD	imagerel $unwind$locateblk_scsitape
$pdata$int_scsi_rewind_unload DD imagerel $LN16
	DD	imagerel $LN16+886
	DD	imagerel $unwind$int_scsi_rewind_unload
$pdata$int_scsi_status_update DD imagerel $LN27
	DD	imagerel $LN27+908
	DD	imagerel $unwind$int_scsi_status_update
$pdata$int_scsi_status_mounted DD imagerel $LN9
	DD	imagerel $LN9+138
	DD	imagerel $unwind$int_scsi_status_mounted
$pdata$int_write_scsimark DD imagerel $LN4
	DD	imagerel $LN4+98
	DD	imagerel $unwind$int_write_scsimark
$pdata$blockid_emulated_to_actual DD imagerel $LN10
	DD	imagerel $LN10+177
	DD	imagerel $unwind$blockid_emulated_to_actual
$pdata$blockid_actual_to_emulated DD imagerel $LN10
	DD	imagerel $LN10+173
	DD	imagerel $unwind$blockid_actual_to_emulated
$pdata$create_automount_thread DD imagerel $LN25
	DD	imagerel $LN25+631
	DD	imagerel $unwind$create_automount_thread
$pdata$scsi_tapemountmon_thread DD imagerel $LN31
	DD	imagerel $LN31+1930
	DD	imagerel $unwind$scsi_tapemountmon_thread
$pdata$define_BOT_pos DD imagerel $LN13
	DD	imagerel $LN13+194
	DD	imagerel $unwind$define_BOT_pos
$pdata$int_nbio_scsitape_open DD imagerel int_nbio_scsitape_open
	DD	imagerel int_nbio_scsitape_open+97
	DD	imagerel $unwind$int_nbio_scsitape_open
$pdata$get_max_blocksize DD imagerel get_max_blocksize
	DD	imagerel get_max_blocksize+207
	DD	imagerel $unwind$get_max_blocksize
$pdata$int_scsi_status_wait DD imagerel int_scsi_status_wait
	DD	imagerel int_scsi_status_wait+736
	DD	imagerel $unwind$int_scsi_status_wait
$pdata$get_stape_status_thread DD imagerel get_stape_status_thread
	DD	imagerel get_stape_status_thread+1506
	DD	imagerel $unwind$get_stape_status_thread
pdata	ENDS
_DATA	SEGMENT
?blksize@?1??get_max_blocksize@@9@9 DD 0200000H		; `get_max_blocksize'::`2'::blksize
	DD	01fffffH
	DD	040000H
	DD	03ffffH
	DD	020000H
	DD	01ffffH
	DD	010000H
	DD	0ffffH
	DD	08000H
	DD	07fffH
$SG169244 DB	'open_scsitape', 00H
	ORG $+2
$SG169245 DB	'scsitape.c', 00H
	ORG $+5
$SG169248 DB	'open_scsitape', 00H
	ORG $+2
$SG169254 DB	'scsi', 00H
	ORG $+3
$SG169246 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169249 DB	'scsitape.c', 00H
	ORG $+5
$SG169253 DB	'open_tape()', 00H
$SG169255 DB	'E', 00H
	ORG $+2
$SG169260 DB	'open_scsitape ', 00H
	ORG $+1
$SG169305 DB	'scsi', 00H
	ORG $+3
$SG169250 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169257 DB	'open_scsitape', 00H
	ORG $+2
$SG169308 DB	'finish_scsitape_open', 00H
	ORG $+3
$SG169256 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169258 DB	'scsitape.c', 00H
	ORG $+1
$SG169261 DB	'D', 00H
	ORG $+2
$SG169262 DB	'HHC92702%s Tape %s: %smt_gstat 0x%8.8X %s', 0aH, 00H
	ORG $+1
$SG169306 DB	'E', 00H
	ORG $+2
$SG169263 DB	'open_scsitape', 00H
	ORG $+2
$SG169264 DB	'scsitape.c', 00H
	ORG $+1
$SG169321 DB	'D', 00H
	ORG $+2
$SG169304 DB	'finish_scsitape_open(reopen)', 00H
	ORG $+3
$SG169312 DB	'finish_scsitape_open', 00H
	ORG $+3
$SG169307 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169309 DB	'scsitape.c', 00H
	ORG $+1
$SG169328 DB	'E', 00H
	ORG $+2
$SG169313 DB	'scsitape.c', 00H
	ORG $+5
$SG169316 DB	'finish_scsitape_open', 00H
	ORG $+3
$SG169314 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169317 DB	'scsitape.c', 00H
	ORG $+5
$SG169320 DB	'finish_scsitape_open ', 00H
	ORG $+2
$SG169318 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169322 DB	'HHC92702%s Tape %s: %smt_gstat 0x%8.8X %s', 0aH, 00H
	ORG $+1
$SG169357 DB	'E', 00H
	ORG $+2
$SG169323 DB	'finish_scsitape_open', 00H
	ORG $+3
$SG169324 DB	'scsitape.c', 00H
	ORG $+1
$SG169376 DB	'E', 00H
	ORG $+2
$SG169326 DB	'ioctl_tape(MTSETBLK)', 00H
	ORG $+3
$SG169327 DB	'scsi', 00H
	ORG $+3
$SG169329 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169330 DB	'finish_scsitape_open', 00H
	ORG $+3
$SG169331 DB	'scsitape.c', 00H
	ORG $+1
$SG169403 DB	'E', 00H
	ORG $+2
$SG169349 DB	'scsitape.c:339', 00H
	ORG $+1
$SG169355 DB	'ioctl_tape(MTREW)', 00H
	ORG $+2
$SG169356 DB	'scsi', 00H
	ORG $+7
$SG169358 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169359 DB	'close_scsitape', 00H
	ORG $+1
$SG169360 DB	'scsitape.c', 00H
	ORG $+1
$SG169430 DB	'E', 00H
	ORG $+2
$SG169361 DB	'scsitape.c:386', 00H
	ORG $+1
$SG169374 DB	'read_tape()', 00H
$SG169375 DB	'scsi', 00H
	ORG $+7
$SG169377 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169378 DB	'read_scsitape', 00H
	ORG $+2
$SG169379 DB	'scsitape.c', 00H
	ORG $+1
$SG169474 DB	'E', 00H
	ORG $+2
$SG169401 DB	'write_tape()', 00H
	ORG $+3
$SG169402 DB	'scsi', 00H
	ORG $+3
$SG169404 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169405 DB	'write_scsitape', 00H
	ORG $+1
$SG169406 DB	'scsitape.c', 00H
	ORG $+1
$SG169504 DB	'E', 00H
	ORG $+2
$SG169428 DB	'write_scsimark()', 00H
	ORG $+3
$SG169429 DB	'scsi', 00H
	ORG $+7
$SG169432 DB	'write_scsimark', 00H
	ORG $+1
$SG169472 DB	'ioctl_tape(MTWEOF)', 00H
	ORG $+5
$SG169431 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169433 DB	'scsitape.c', 00H
	ORG $+1
$SG169473 DB	'scsi', 00H
	ORG $+7
$SG169475 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169476 DB	'sync_scsitape', 00H
	ORG $+2
$SG169477 DB	'scsitape.c', 00H
	ORG $+1
$SG169536 DB	'E', 00H
	ORG $+2
$SG169502 DB	'ioctl_tape(MTFSR)', 00H
	ORG $+2
$SG169503 DB	'scsi', 00H
	ORG $+7
$SG169506 DB	'fsb_scsitape', 00H
	ORG $+3
$SG169534 DB	'ioctl_tape(MTBSR)', 00H
	ORG $+6
$SG169505 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169507 DB	'scsitape.c', 00H
	ORG $+1
$SG169535 DB	'scsi', 00H
	ORG $+7
$SG169537 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169538 DB	'bsb_scsitape', 00H
	ORG $+3
$SG169539 DB	'scsitape.c', 00H
	ORG $+1
$SG169565 DB	'E', 00H
	ORG $+2
$SG169563 DB	'ioctl_tape(MTFSF)', 00H
	ORG $+2
$SG169564 DB	'scsi', 00H
	ORG $+7
$SG169567 DB	'fsf_scsitape', 00H
	ORG $+3
$SG169594 DB	'ioctl_tape(MTBSF)', 00H
	ORG $+6
$SG169566 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169568 DB	'scsitape.c', 00H
	ORG $+1
$SG169595 DB	'scsi', 00H
	ORG $+3
$SG169596 DB	'E', 00H
	ORG $+2
$SG169597 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169598 DB	'bsf_scsitape', 00H
	ORG $+3
$SG169599 DB	'scsitape.c', 00H
	ORG $+1
$SG169622 DB	'E', 00H
	ORG $+2
$SG169620 DB	'ioctl_tape(MTREW)', 00H
	ORG $+2
$SG169621 DB	'scsi', 00H
	ORG $+7
$SG169624 DB	'rewind_scsitape', 00H
$SG169644 DB	'scsi', 00H
	ORG $+3
$SG169623 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169625 DB	'scsitape.c', 00H
	ORG $+1
$SG169645 DB	'I', 00H
	ORG $+2
$SG169646 DB	'HHC00210%s %1d:%04X Tape file %s, type %s: tape unloaded'
	DB	0aH, 00H
	ORG $+2
$SG169652 DB	'E', 00H
	ORG $+2
$SG169647 DB	'int_scsi_rewind_unload', 00H
	ORG $+1
$SG169648 DB	'scsitape.c', 00H
	ORG $+1
$SG169681 DB	'E', 00H
	ORG $+2
$SG169650 DB	'ioctl_tape(MTOFFL)', 00H
	ORG $+1
$SG169651 DB	'scsi', 00H
	ORG $+7
$SG169653 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169654 DB	'int_scsi_rewind_unload', 00H
	ORG $+1
$SG169655 DB	'scsitape.c', 00H
	ORG $+1
$SG169699 DB	'E', 00H
	ORG $+2
$SG169679 DB	'ioctl_tape(MTERASE)', 00H
$SG169680 DB	'scsi', 00H
	ORG $+7
$SG169682 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169683 DB	'erg_scsitape', 00H
	ORG $+3
$SG169684 DB	'scsitape.c', 00H
	ORG $+1
$SG169721 DB	'D', 00H
	ORG $+2
$SG169697 DB	'ioctl_tape(MTERASE)', 00H
$SG169698 DB	'scsi', 00H
	ORG $+7
$SG169701 DB	'dse_scsitape', 00H
	ORG $+3
$SG169719 DB	'ioctl_tape(MTTELL)', 00H
	ORG $+5
$SG169700 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169702 DB	'scsitape.c', 00H
	ORG $+1
$SG169720 DB	'scsi', 00H
	ORG $+7
$SG169722 DB	'HHC90205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169723 DB	'readblkid_scsitape', 00H
	ORG $+1
$SG169754 DB	'W', 00H
	ORG $+2
$SG169724 DB	'scsitape.c', 00H
	ORG $+1
$SG169846 DB	'I', 00H
	ORG $+2
$SG169752 DB	'ioctl_tape(MTSEEK)', 00H
	ORG $+1
$SG169753 DB	'scsi', 00H
	ORG $+7
$SG169755 DB	'HHC00205%s %1d:%04X Tape file %s, type %s: error in func'
	DB	'tion %s: %s', 0aH, 00H
	ORG $+3
$SG169756 DB	'locateblk_scsitape', 00H
	ORG $+1
$SG169863 DB	'I', 00H
	ORG $+2
$SG169757 DB	'scsitape.c', 00H
	ORG $+1
$SG169901 DB	'E', 00H
	ORG $+2
$SG169843 DB	'scsitape.c:1724', 00H
$SG169844 DB	'scsi_status', 00H
$SG169945 DB	'W', 00H
	ORG $+2
$SG169845 DB	'scsitape.c:1727', 00H
$SG169847 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG169848 DB	'get_stape_status_thread', 00H
$SG169849 DB	'scsitape.c', 00H
	ORG $+1
$SG169953 DB	'I', 00H
	ORG $+2
$SG169850 DB	'scsitape.c:1729', 00H
$SG169851 DB	'scsitape.c:1734', 00H
$SG169852 DB	'scsitape.c:1762', 00H
$SG169854 DB	'scsitape.c:1774', 00H
$SG169856 DB	'scsitape.c:1792', 00H
$SG169857 DB	'scsitape.c:1794', 00H
$SG169859 DB	'scsitape.c:1805', 00H
$SG169860 DB	'scsitape.c:1807', 00H
$SG169861 DB	'scsi_status', 00H
$SG169986 DB	'E', 00H
	ORG $+2
$SG169862 DB	'scsitape.c:1821', 00H
$SG169864 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG169865 DB	'get_stape_status_thread', 00H
$SG169866 DB	'scsitape.c', 00H
	ORG $+1
$SG170040 DB	'I', 00H
	ORG $+2
$SG169867 DB	'scsitape.c:1825', 00H
$SG169868 DB	'scsitape.c:1826', 00H
$SG169887 DB	'scsitape.c:1843', 00H
$SG169890 DB	'scsitape.c:1864', 00H
$SG169891 DB	'scsi_status', 00H
$SG170050 DB	'E', 00H
	ORG $+2
$SG169892 DB	'int_scsi_status_wait', 00H
	ORG $+3
$SG169893 DB	'scsitape.c', 00H
	ORG $+5
$SG169896 DB	'int_scsi_status_wait', 00H
	ORG $+3
$SG169894 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169897 DB	'scsitape.c', 00H
	ORG $+5
$SG169902 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG169898 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169903 DB	'int_scsi_status_wait', 00H
	ORG $+3
$SG169904 DB	'scsitape.c', 00H
	ORG $+1
$SG170065 DB	'I', 00H
	ORG $+2
$SG169907 DB	'scsitape.c:1881', 00H
$SG169908 DB	'scsitape.c:1892', 00H
$SG169909 DB	'scsitape.c:1894', 00H
$SG169946 DB	'HHC00243%s %1d:%04X Tape status retrieval timeout', 0aH, 00H
	ORG $+5
$SG169947 DB	'int_scsi_status_update', 00H
	ORG $+1
$SG169948 DB	'scsitape.c', 00H
	ORG $+1
$SG169950 DB	'closed', 00H
	ORG $+1
$SG169951 DB	'opened', 00H
	ORG $+5
$SG169952 DB	'(undefined)', 00H
	ORG $+4
$SG169954 DB	'HHC00211%s %1d:%04X Tape file %s, type scsi status %s, s'
	DB	'stat 0x%8.8X: %s', 0aH, 00H
	ORG $+6
$SG169955 DB	'int_scsi_status_update', 00H
	ORG $+1
$SG169956 DB	'scsitape.c', 00H
	ORG $+5
$SG169971 DB	'scsitape.c:2053', 00H
$SG169975 DB	'scsitape.c:2075', 00H
$SG169976 DB	'scsi_mount', 00H
	ORG $+5
$SG169977 DB	'create_automount_thread', 00H
$SG169978 DB	'scsitape.c', 00H
	ORG $+5
$SG169979 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169981 DB	'create_automount_thread', 00H
$SG169982 DB	'scsitape.c', 00H
	ORG $+5
$SG169983 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG169987 DB	'HHC00102%s Error in function create_thread(): %s', 0aH, 00H
	ORG $+6
$SG169988 DB	'create_automount_thread', 00H
$SG169989 DB	'scsitape.c', 00H
	ORG $+5
$SG169992 DB	'scsitape.c:2092', 00H
$SG170038 DB	'scsi_mount', 00H
	ORG $+5
$SG170039 DB	'scsitape.c:2111', 00H
$SG170041 DB	'HHC00100%s Thread id %8.8x, prio %d, name ''%s'' started'
	DB	0aH, 00H
$SG170042 DB	'scsi_tapemountmon_thread', 00H
	ORG $+7
$SG170043 DB	'scsitape.c', 00H
	ORG $+5
$SG170044 DB	'scsitape.c:2113', 00H
$SG170045 DB	'scsitape.c:2134', 00H
$SG170049 DB	'scsi', 00H
	ORG $+3
$SG170054 DB	'scsitape.c:2180', 00H
$SG170066 DB	'HHC00101%s Thread id %8.8x, prio %d, name ''%s'' ended', 0aH
	DB	00H
	ORG $+2
$SG170051 DB	'HHC00213%s %1d:%04X Tape file %s, type %s: Error opening'
	DB	': errno=%d: %s', 0aH, 00H
$SG170052 DB	'scsi_tapemountmon_thread', 00H
	ORG $+7
$SG170053 DB	'scsitape.c', 00H
	ORG $+5
$SG170055 DB	'scsitape.c:2184', 00H
$SG170059 DB	'scsitape.c:2215', 00H
$SG170061 DB	'scsitape.c:2225', 00H
$SG170063 DB	'scsi_mount', 00H
	ORG $+5
$SG170064 DB	'scsitape.c:2252', 00H
$SG170067 DB	'scsi_tapemountmon_thread', 00H
	ORG $+7
$SG170068 DB	'scsitape.c', 00H
	ORG $+5
$SG170069 DB	'scsitape.c:2255', 00H
$SG170083 DB	'define_BOT_pos', 00H
	ORG $+1
$SG170084 DB	'scsitape.c', 00H
	ORG $+5
$SG170087 DB	'define_BOT_pos', 00H
	ORG $+9
$SG170085 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
	ORG $+3
$SG170088 DB	'scsitape.c', 00H
	ORG $+13
$SG170089 DB	'%s(%d) : warning HHC90999W : *** Assertion Failed! *** f'
	DB	'unction: %s', 0aH, 00H
_DATA	ENDS
voltbl	SEGMENT
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:get_stape_status_thread
	DD	018H
	DD	05c8H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:int_scsi_status_update
	DD	01bH
	DD	0373H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:bsb_scsitape
	DD	022H
	DD	0398H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:finish_scsitape_open
	DD	021H
	DD	05e3H
_volmd	DD	0ffffffffH
	DDSymXIndex: 	FLAT:open_scsitape
	DD	021H
	DD	0483H
voltbl	ENDS
xdata	SEGMENT
$unwind$DebuggerTrace DD 011801H
	DD	0a218H
$unwind$is_tape_feat DD 010d01H
	DD	0620dH
$unwind$update_status_scsitape DD 010901H
	DD	04209H
$unwind$open_scsitape DD 032919H
	DD	0480117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0230H
$unwind$finish_scsitape_open DD 032919H
	DD	04c0117H
	DD	07010H
	DD	imagerel __GSHandlerCheck
	DD	0250H
$unwind$close_scsitape DD 020c01H
	DD	019010cH
$unwind$read_scsitape DD 021b01H
	DD	013011bH
$unwind$write_scsitape DD 021b01H
	DD	013011bH
$unwind$rewind_scsitape DD 021601H
	DD	0150116H
$unwind$bsb_scsitape DD 042a19H
	DD	0190118H
	DD	060107011H
	DD	imagerel __GSHandlerCheck
	DD	0b8H
$unwind$fsb_scsitape DD 021601H
	DD	0150116H
$unwind$bsf_scsitape DD 021601H
	DD	0150116H
$unwind$fsf_scsitape DD 021601H
	DD	0150116H
$unwind$write_scsimark DD 021601H
	DD	0150116H
$unwind$sync_scsitape DD 021601H
	DD	0150116H
$unwind$dse_scsitape DD 021601H
	DD	0130116H
$unwind$erg_scsitape DD 021601H
	DD	0150116H
$unwind$is_tape_mounted_scsitape DD 011301H
	DD	04213H
$unwind$readblkid_scsitape DD 021601H
	DD	0150116H
$unwind$locateblk_scsitape DD 021a01H
	DD	015011aH
$unwind$int_scsi_rewind_unload DD 021601H
	DD	0170116H
$unwind$int_scsi_status_update DD 032319H
	DD	0460111H
	DD	0700aH
	DD	imagerel __GSHandlerCheck
	DD	0220H
$unwind$int_scsi_status_mounted DD 010d01H
	DD	0420dH
$unwind$int_write_scsimark DD 010901H
	DD	06209H
$unwind$blockid_emulated_to_actual DD 011301H
	DD	04213H
$unwind$blockid_actual_to_emulated DD 011301H
	DD	04213H
$unwind$create_automount_thread DD 010901H
	DD	0e209H
$unwind$scsi_tapemountmon_thread DD 020c01H
	DD	023010cH
$unwind$define_BOT_pos DD 010901H
	DD	06209H
$unwind$int_nbio_scsitape_open DD 010e01H
	DD	0620eH
$unwind$get_max_blocksize DD 010e01H
	DD	0820eH
$unwind$int_scsi_status_wait DD 010d01H
	DD	0e20dH
$unwind$get_stape_status_thread DD 042019H
	DD	01d010eH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	0d0H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s DD 011801H
	DD	06218H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$_vsnprintf_s_l DD 011801H
	DD	0a218H
xdata	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
pListEntry$ = 80
timeout$ = 88
dev$ = 96
tv68 = 104
tv72 = 108
tv77 = 112
tv226 = 116
tv231 = 120
_EX_Flink$1 = 128
_EX_Blink$2 = 136
_EX_Flink$3 = 144
_EX_Blink$4 = 152
req$ = 160
tv160 = 168
mtget$ = 176
__$ArrayPad$ = 208
notused$ = 256
get_stape_status_thread PROC

; 1698 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	48 81 ec e8 00
	00 00		 sub	 rsp, 232		; 000000e8H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1699 :     LIST_ENTRY*   pListEntry;
; 1700 :     STSTATRQ*     req;
; 1701 :     DEVBLK*       dev = NULL;

  00020	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0
$LN4@get_stape_:

; 1702 :     struct mtget  mtget;
; 1703 :     int           timeout;
; 1704 : 
; 1705 :     UNREFERENCED( notused );

  00029	33 c0		 xor	 eax, eax
  0002b	85 c0		 test	 eax, eax
  0002d	75 fa		 jne	 SHORT $LN4@get_stape_

; 1706 : 
; 1707 :     // PROGRAMMING NOTE: it is EXTREMELY IMPORTANT that the status-
; 1708 :     // retrieval thread (i.e. ourselves) be set to a priority that
; 1709 :     // is HIGHER than what the device-threads are currently set to
; 1710 :     // in order to prevent their request for new/updated status from
; 1711 :     // erroneously timing out (thereby misleading them to mistakenly
; 1712 :     // believe no tape is mounted when in acuality there is!). The
; 1713 :     // issue is, the caller only waits for so long for us to return
; 1714 :     // the status to them so we better ensure we return it to them
; 1715 :     // in a timely fashion else they be mislead to believe there's
; 1716 :     // no tape mounted (since, by virtue of their request having
; 1717 :     // timed out, they presume no tape is mounted since the retrieval
; 1718 :     // took too long (which only occurs whenever (duh!) there's no
; 1719 :     // tape mounted!)). Thus, if there *is* a tape mounted, we better
; 1720 :     // be DARN sure to return them the status as quickly as possible
; 1721 :     // in order to prevent their wait from timing out. We ensure this
; 1722 :     // by setting our own priority HIGHER than theirs.
; 1723 : 
; 1724 :     set_thread_priority( sysblk.devprio + 1 );

  0002f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00036	8b 80 70 13 00
	00		 mov	 eax, DWORD PTR [rax+4976]
  0003c	ff c0		 inc	 eax
  0003e	89 44 24 68	 mov	 DWORD PTR tv68[rsp], eax
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00048	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169843
  0004f	8b 4c 24 68	 mov	 ecx, DWORD PTR tv68[rsp]
  00053	8b d1		 mov	 edx, ecx
  00055	8b c8		 mov	 ecx, eax
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_set_thread_prio

; 1725 : 
; 1726 :     // "Thread id "TIDPAT", prio %2d, name %s started"
; 1727 :     LOG_THREAD_BEGIN( SCSISTAT_THREAD_NAME  );

  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00063	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169845
  0006a	8b c8		 mov	 ecx, eax
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00072	89 44 24 6c	 mov	 DWORD PTR tv72[rsp], eax
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0007c	89 44 24 70	 mov	 DWORD PTR tv77[rsp], eax
  00080	b9 01 00 00 00	 mov	 ecx, 1
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0008b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169844
  00092	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00097	8b 4c 24 6c	 mov	 ecx, DWORD PTR tv72[rsp]
  0009b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0009f	8b 4c 24 70	 mov	 ecx, DWORD PTR tv77[rsp]
  000a3	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  000a7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169846
  000ae	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  000b3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169847
  000ba	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  000bf	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000c4	41 b9 03 00 00
	00		 mov	 r9d, 3
  000ca	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169848
  000d1	ba bf 06 00 00	 mov	 edx, 1727		; 000006bfH
  000d6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169849
  000dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1728 : 
; 1729 :     obtain_lock( &sysblk.stape_lock );

  000e3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ea	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  000f0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169850
  000f7	48 8b c8	 mov	 rcx, rax
  000fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN7@get_stape_:

; 1730 : 
; 1731 :     do
; 1732 :     {
; 1733 :         sysblk.stape_getstat_busy = 1;

  00100	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00107	8b 80 90 11 00
	00		 mov	 eax, DWORD PTR [rax+4496]
  0010d	83 c8 01	 or	 eax, 1
  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00117	89 81 90 11 00
	00		 mov	 DWORD PTR [rcx+4496], eax

; 1734 :         broadcast_condition( &sysblk.stape_getstat_cond );

  0011d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00124	48 05 88 11 00
	00		 add	 rax, 4488		; 00001188H
  0012a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169851
  00131	48 8b c8	 mov	 rcx, rax
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN8@get_stape_:

; 1735 : 
; 1736 :         // Process all work items currently in our queue...
; 1737 : 
; 1738 :         while (!IsListEmpty( &sysblk.stape_status_link ) && !sysblk.shutdown)

  0013a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00141	48 05 98 11 00
	00		 add	 rax, 4504		; 00001198H
  00147	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  0014e	48 39 81 98 11
	00 00		 cmp	 QWORD PTR [rcx+4504], rax
  00155	0f 84 3a 02 00
	00		 je	 $LN9@get_stape_
  0015b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00162	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00168	c1 e8 0b	 shr	 eax, 11
  0016b	83 e0 01	 and	 eax, 1
  0016e	85 c0		 test	 eax, eax
  00170	0f 85 1f 02 00
	00		 jne	 $LN9@get_stape_

; 1739 :         {
; 1740 :             pListEntry = RemoveListHead( &sysblk.stape_status_link );

  00176	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0017d	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  00184	48 89 44 24 50	 mov	 QWORD PTR pListEntry$[rsp], rax
  00189	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00190	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  00197	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0019a	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  001a2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001a9	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  001b0	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001b4	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  001bc	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  001c4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  001cc	48 89 08	 mov	 QWORD PTR [rax], rcx
  001cf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  001d7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  001df	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1741 :             InitializeListLink( pListEntry );

  001e3	48 8b 44 24 50	 mov	 rax, QWORD PTR pListEntry$[rsp]
  001e8	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  001f0	48 8b 44 24 50	 mov	 rax, QWORD PTR pListEntry$[rsp]
  001f5	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1742 :             req = CONTAINING_RECORD( pListEntry, STSTATRQ, link );

  001fc	48 8b 44 24 50	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00201	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR req$[rsp], rax

; 1743 :             dev = req->dev;

  00209	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR req$[rsp]
  00211	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00215	48 89 44 24 60	 mov	 QWORD PTR dev$[rsp], rax

; 1744 : 
; 1745 :             // Status queries limited GLOBALLY to one per second,
; 1746 :             // since there's no way of knowing whether a drive is
; 1747 :             // on the same or different bus as the other drive(s).
; 1748 : 
; 1749 :             for
; 1750 :             (
; 1751 :                 timeout = 0

  0021a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR timeout$[rsp], 0
$LN10@get_stape_:

; 1752 :                 ;
; 1753 :                 1
; 1754 :                     && !sysblk.shutdown
; 1755 :                     && sysblk.stape_query_status_tod.tv_sec
; 1756 :                     && !(timeout = timed_wait_condition_relative_usecs

  00222	33 c0		 xor	 eax, eax
  00224	83 f8 01	 cmp	 eax, 1
  00227	0f 84 91 00 00
	00		 je	 $LN11@get_stape_
  0022d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00234	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0023a	c1 e8 0b	 shr	 eax, 11
  0023d	83 e0 01	 and	 eax, 1
  00240	85 c0		 test	 eax, eax
  00242	75 7a		 jne	 SHORT $LN11@get_stape_
  00244	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0024b	83 b8 b8 11 00
	00 00		 cmp	 DWORD PTR [rax+4536], 0
  00252	74 6a		 je	 SHORT $LN11@get_stape_
  00254	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025b	48 05 b8 11 00
	00		 add	 rax, 4536		; 000011b8H
  00261	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00268	48 81 c1 70 11
	00 00		 add	 rcx, 4464		; 00001170H
  0026f	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00276	48 81 c2 88 11
	00 00		 add	 rdx, 4488		; 00001188H
  0027d	48 89 94 24 a8
	00 00 00	 mov	 QWORD PTR tv160[rsp], rdx
  00285	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169852
  0028c	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  00291	4c 8b c8	 mov	 r9, rax
  00294	41 b8 40 42 0f
	00		 mov	 r8d, 1000000		; 000f4240H
  0029a	48 8b d1	 mov	 rdx, rcx
  0029d	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR tv160[rsp]
  002a5	48 8b c8	 mov	 rcx, rax
  002a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  002ae	89 44 24 58	 mov	 DWORD PTR timeout$[rsp], eax
  002b2	83 7c 24 58 00	 cmp	 DWORD PTR timeout$[rsp], 0
  002b7	75 05		 jne	 SHORT $LN11@get_stape_

; 1757 :                         (
; 1758 :                             &sysblk.stape_getstat_cond,
; 1759 :                             &sysblk.stape_lock,
; 1760 :                             MAX_GSTAT_FREQ_USECS,
; 1761 :                             &sysblk.stape_query_status_tod
; 1762 :                         ))
; 1763 :                 ;
; 1764 :             );

  002b9	e9 64 ff ff ff	 jmp	 $LN10@get_stape_
$LN11@get_stape_:

; 1765 : 
; 1766 :             if (!sysblk.shutdown)

  002be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002c5	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  002cb	c1 e8 0b	 shr	 eax, 11
  002ce	83 e0 01	 and	 eax, 1
  002d1	85 c0		 test	 eax, eax
  002d3	0f 85 b7 00 00
	00		 jne	 $LN15@get_stape_

; 1767 :             {
; 1768 :                 // Query drive status...
; 1769 : 
; 1770 :                 // Since this may take quite a while to do if there's no tape
; 1771 :                 // mounted, we release the lock before attempting to retrieve
; 1772 :                 // the status and then re-acquire it afterwards...
; 1773 : 
; 1774 :                 release_lock( &sysblk.stape_lock );

  002d9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002e0	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  002e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169854
  002ed	48 8b c8	 mov	 rcx, rax
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1775 :                 {
; 1776 :                     define_BOT_pos( dev );  // (always before MTIOCGET)

  002f6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR dev$[rsp]
  002fb	e8 00 00 00 00	 call	 define_BOT_pos

; 1777 : 
; 1778 :                     // NOTE: the following may take up to *>10<* seconds to
; 1779 :                     // complete on Windows whenever there's no tape mounted,
; 1780 :                     // but apparently only with certain hardware. On a fast
; 1781 :                     // quad-cpu Windows 2003 Server system with an Adaptec
; 1782 :                     // AHA2944UW SCSI control for example, it completes right
; 1783 :                     // away (i.e. IMMEDIATELY), whereas on a medium dual-proc
; 1784 :                     // Windows 2000 Server system with TEKRAM SCSI controller
; 1785 :                     // it takes  *>> 10 <<*  seconds!...
; 1786 : 
; 1787 :                     if (0 == ioctl_tape( dev->fd, MTIOCGET, (char*)&mtget ))

  00300	4c 8d 84 24 b0
	00 00 00	 lea	 r8, QWORD PTR mtget$[rsp]
  00308	ba 02 6d 1c 40	 mov	 edx, 1075604738		; 401c6d02H
  0030d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00312	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00318	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0031e	85 c0		 test	 eax, eax
  00320	75 1e		 jne	 SHORT $LN16@get_stape_

; 1788 :                     {
; 1789 :                         memcpy( &dev->mtget, &mtget, sizeof( mtget ));

  00322	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00327	48 8d 8c 24 b0
	00 00 00	 lea	 rcx, QWORD PTR mtget$[rsp]
  0032f	48 8d b8 7c 10
	00 00		 lea	 rdi, QWORD PTR [rax+4220]
  00336	48 8b f1	 mov	 rsi, rcx
  00339	b9 1c 00 00 00	 mov	 ecx, 28
  0033e	f3 a4		 rep movsb
$LN16@get_stape_:

; 1790 :                     }
; 1791 :                 }
; 1792 :                 obtain_lock( &sysblk.stape_lock );

  00340	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00347	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  0034d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169856
  00354	48 8b c8	 mov	 rcx, rax
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1793 : 
; 1794 :                 broadcast_condition( &dev->stape_sstat_cond );

  0035d	48 8b 44 24 60	 mov	 rax, QWORD PTR dev$[rsp]
  00362	48 05 a0 10 00
	00		 add	 rax, 4256		; 000010a0H
  00368	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169857
  0036f	48 8b c8	 mov	 rcx, rax
  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 1795 :                 gettimeofday( &sysblk.stape_query_status_tod, NULL );

  00378	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0037f	48 05 b8 11 00
	00		 add	 rax, 4536		; 000011b8H
  00385	33 d2		 xor	 edx, edx
  00387	48 8b c8	 mov	 rcx, rax
  0038a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday
$LN15@get_stape_:

; 1796 :             }
; 1797 : 
; 1798 :         } // end while (!IsListEmpty)...

  00390	e9 a5 fd ff ff	 jmp	 $LN8@get_stape_
$LN9@get_stape_:

; 1799 : 
; 1800 :         if (!sysblk.shutdown)

  00395	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0039c	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  003a2	c1 e8 0b	 shr	 eax, 11
  003a5	83 e0 01	 and	 eax, 1
  003a8	85 c0		 test	 eax, eax
  003aa	75 65		 jne	 SHORT $LN17@get_stape_

; 1801 :         {
; 1802 :             // Sleep until more/new work arrives...
; 1803 : 
; 1804 :             sysblk.stape_getstat_busy = 0;

  003ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003b3	8b 80 90 11 00
	00		 mov	 eax, DWORD PTR [rax+4496]
  003b9	83 e0 fe	 and	 eax, -2			; fffffffeH
  003bc	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003c3	89 81 90 11 00
	00		 mov	 DWORD PTR [rcx+4496], eax

; 1805 :             broadcast_condition( &sysblk.stape_getstat_cond );

  003c9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003d0	48 05 88 11 00
	00		 add	 rax, 4488		; 00001188H
  003d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169859
  003dd	48 8b c8	 mov	 rcx, rax
  003e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 1806 :             wait_condition( &sysblk.stape_getstat_cond,

  003e6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003ed	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  003f3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  003fa	48 81 c1 88 11
	00 00		 add	 rcx, 4488		; 00001188H
  00401	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169860
  00408	48 8b d0	 mov	 rdx, rax
  0040b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_wait_condition
$LN17@get_stape_:

; 1807 :                             &sysblk.stape_lock );
; 1808 :         }
; 1809 :     }
; 1810 :     while (!sysblk.shutdown);

  00411	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00418	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0041e	c1 e8 0b	 shr	 eax, 11
  00421	83 e0 01	 and	 eax, 1
  00424	85 c0		 test	 eax, eax
  00426	0f 84 d4 fc ff
	ff		 je	 $LN7@get_stape_
$LN13@get_stape_:

; 1811 : 
; 1812 :     // (discard all work items since we're going away)
; 1813 : 
; 1814 :     while (!IsListEmpty( &sysblk.stape_status_link ))

  0042c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00433	48 05 98 11 00
	00		 add	 rax, 4504		; 00001198H
  00439	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00440	48 39 81 98 11
	00 00		 cmp	 QWORD PTR [rcx+4504], rax
  00447	0f 84 8b 00 00
	00		 je	 $LN14@get_stape_

; 1815 :     {
; 1816 :         pListEntry = RemoveListHead( &sysblk.stape_status_link );

  0044d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00454	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  0045b	48 89 44 24 50	 mov	 QWORD PTR pListEntry$[rsp], rax
  00460	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00467	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  0046e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00471	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _EX_Flink$3[rsp], rax
  00479	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00480	48 8b 80 98 11
	00 00		 mov	 rax, QWORD PTR [rax+4504]
  00487	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  0048b	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR _EX_Blink$4[rsp], rax
  00493	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$4[rsp]
  0049b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$3[rsp]
  004a3	48 89 08	 mov	 QWORD PTR [rax], rcx
  004a6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$3[rsp]
  004ae	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$4[rsp]
  004b6	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 1817 :         InitializeListLink( pListEntry );

  004ba	48 8b 44 24 50	 mov	 rax, QWORD PTR pListEntry$[rsp]
  004bf	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  004c7	48 8b 44 24 50	 mov	 rax, QWORD PTR pListEntry$[rsp]
  004cc	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 1818 :     }

  004d3	e9 54 ff ff ff	 jmp	 $LN13@get_stape_
$LN14@get_stape_:

; 1819 : 
; 1820 :     // "Thread id "TIDPAT", prio %2d, name %s ended"
; 1821 :     LOG_THREAD_END( SCSISTAT_THREAD_NAME  );

  004d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  004de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169862
  004e5	8b c8		 mov	 ecx, eax
  004e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  004ed	89 44 24 74	 mov	 DWORD PTR tv226[rsp], eax
  004f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  004f7	89 44 24 78	 mov	 DWORD PTR tv231[rsp], eax
  004fb	b9 01 00 00 00	 mov	 ecx, 1
  00500	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00506	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169861
  0050d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00512	8b 4c 24 74	 mov	 ecx, DWORD PTR tv226[rsp]
  00516	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0051a	8b 4c 24 78	 mov	 ecx, DWORD PTR tv231[rsp]
  0051e	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00522	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169863
  00529	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0052e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169864
  00535	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0053a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0053f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00545	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169865
  0054c	ba 1d 07 00 00	 mov	 edx, 1821		; 0000071dH
  00551	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169866
  00558	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1822 : 
; 1823 :     sysblk.stape_getstat_busy = 0;

  0055e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00565	8b 80 90 11 00
	00		 mov	 eax, DWORD PTR [rax+4496]
  0056b	83 e0 fe	 and	 eax, -2			; fffffffeH
  0056e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00575	89 81 90 11 00
	00		 mov	 DWORD PTR [rcx+4496], eax

; 1824 :     sysblk.stape_getstat_tid = 0;

  0057b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00582	c7 80 7c 11 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4476], 0

; 1825 :     broadcast_condition( &sysblk.stape_getstat_cond );

  0058c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00593	48 05 88 11 00
	00		 add	 rax, 4488		; 00001188H
  00599	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169867
  005a0	48 8b c8	 mov	 rcx, rax
  005a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition

; 1826 :     release_lock( &sysblk.stape_lock );

  005a9	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005b0	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  005b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169868
  005bd	48 8b c8	 mov	 rcx, rax
  005c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1827 : 
; 1828 :     return NULL;

  005c6	33 c0		 xor	 eax, eax

; 1829 : 
; 1830 : } /* end function get_stape_status_thread */

  005c8	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005d0	48 33 cc	 xor	 rcx, rsp
  005d3	e8 00 00 00 00	 call	 __security_check_cookie
  005d8	48 81 c4 e8 00
	00 00		 add	 rsp, 232		; 000000e8H
  005df	5f		 pop	 rdi
  005e0	5e		 pop	 rsi
  005e1	c3		 ret	 0
get_stape_status_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$1 = 64
tv70 = 68
tv77 = 72
tv83 = 76
rc$ = 80
_EX_Head$2 = 88
_EX_Tail$3 = 96
tv142 = 104
dev$ = 128
usecs$ = 136
int_scsi_status_wait PROC

; 1837 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1838 :     int rc;
; 1839 : 
; 1840 :     if (unlikely( dev->fd < 0 ))    // (has drive been opened yet?)

  0000d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00015	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0001c	7d 0a		 jge	 SHORT $LN19@int_scsi_s
  0001e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  00026	eb 08		 jmp	 SHORT $LN20@int_scsi_s
$LN19@int_scsi_s:
  00028	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN20@int_scsi_s:
  00030	83 7c 24 44 00	 cmp	 DWORD PTR tv70[rsp], 0
  00035	74 0a		 je	 SHORT $LN8@int_scsi_s

; 1841 :         return -1;                  // (cannot proceed until it is)

  00037	b8 ff ff ff ff	 mov	 eax, -1
  0003c	e9 9a 02 00 00	 jmp	 $LN1@int_scsi_s
$LN8@int_scsi_s:

; 1842 : 
; 1843 :     obtain_lock( &sysblk.stape_lock );

  00041	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00048	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  0004e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169887
  00055	48 8b c8	 mov	 rcx, rax
  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 1844 : 
; 1845 :     // Create the status retrieval thread if it hasn't been yet.
; 1846 :     // We do the actual retrieval of the status in a worker thread
; 1847 :     // because retrieving the status from a drive that doesn't have
; 1848 :     // a tape mounted may take a long time (at least on Windows).
; 1849 : 
; 1850 :     if (unlikely( !sysblk.stape_getstat_tid ))

  0005e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00065	83 b8 7c 11 00
	00 00		 cmp	 DWORD PTR [rax+4476], 0
  0006c	75 0a		 jne	 SHORT $LN21@int_scsi_s
  0006e	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
  00076	eb 08		 jmp	 SHORT $LN22@int_scsi_s
$LN21@int_scsi_s:
  00078	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
$LN22@int_scsi_s:
  00080	83 7c 24 48 00	 cmp	 DWORD PTR tv77[rsp], 0
  00085	74 0a		 je	 SHORT $LN25@int_scsi_s
  00087	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv83[rsp], 1
  0008f	eb 08		 jmp	 SHORT $LN26@int_scsi_s
$LN25@int_scsi_s:
  00091	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN26@int_scsi_s:
  00099	83 7c 24 4c 00	 cmp	 DWORD PTR tv83[rsp], 0
  0009e	0f 84 1e 01 00
	00		 je	 $LN9@int_scsi_s
$LN4@int_scsi_s:

; 1851 :     {
; 1852 :         int rc;
; 1853 :         VERIFY

  000a4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000ab	48 05 98 10 00
	00		 add	 rax, 4248		; 00001098H
  000b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000b8	48 81 c1 7c 11
	00 00		 add	 rcx, 4476		; 0000117cH
  000bf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169890
  000c6	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  000cb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169891
  000d2	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000d7	45 33 c9	 xor	 r9d, r9d
  000da	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:get_stape_status_thread
  000e1	48 8b d0	 mov	 rdx, rax
  000e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  000ea	89 44 24 40	 mov	 DWORD PTR rc$1[rsp], eax
  000ee	83 7c 24 40 00	 cmp	 DWORD PTR rc$1[rsp], 0
  000f3	74 5c		 je	 SHORT $LN10@int_scsi_s
$LN7@int_scsi_s:
  000f5	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169892
  000fc	41 b8 48 07 00
	00		 mov	 r8d, 1864		; 00000748H
  00102	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169893
  00109	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169894
  00110	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0011c	85 c0		 test	 eax, eax
  0011e	74 20		 je	 SHORT $LN11@int_scsi_s
  00120	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169896
  00127	41 b8 48 07 00
	00		 mov	 r8d, 1864		; 00000748H
  0012d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169897
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169898
  0013b	e8 00 00 00 00	 call	 DebuggerTrace
$LN11@int_scsi_s:
  00140	33 c0		 xor	 eax, eax
  00142	85 c0		 test	 eax, eax
  00144	75 af		 jne	 SHORT $LN7@int_scsi_s
  00146	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0014c	85 c0		 test	 eax, eax
  0014e	74 01		 je	 SHORT $LN12@int_scsi_s
  00150	cc		 int	 3
$LN12@int_scsi_s:
$LN10@int_scsi_s:
  00151	33 c0		 xor	 eax, eax
  00153	85 c0		 test	 eax, eax
  00155	0f 85 49 ff ff
	ff		 jne	 $LN4@int_scsi_s

; 1854 :         (
; 1855 :             (rc = create_thread
; 1856 :             (
; 1857 :                 &sysblk.stape_getstat_tid,
; 1858 :                 JOINABLE,
; 1859 :                 get_stape_status_thread,
; 1860 :                 NULL,
; 1861 :                 SCSISTAT_THREAD_NAME
; 1862 :             ))
; 1863 :             == 0
; 1864 :         );
; 1865 :         if (rc)

  0015b	83 7c 24 40 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00160	74 60		 je	 SHORT $LN13@int_scsi_s

; 1866 :             // "Error in function create_thread(): %s"
; 1867 :             WRMSG( HHC00102, "E", strerror( rc ));

  00162	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$1[rsp]
  00166	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0016c	48 89 44 24 68	 mov	 QWORD PTR tv142[rsp], rax
  00171	b9 01 00 00 00	 mov	 ecx, 1
  00176	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0017c	48 8b 4c 24 68	 mov	 rcx, QWORD PTR tv142[rsp]
  00181	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00186	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169901
  0018d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00192	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169902
  00199	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a3	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169903
  001b0	ba 4b 07 00 00	 mov	 edx, 1867		; 0000074bH
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169904
  001bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@int_scsi_s:
$LN9@int_scsi_s:

; 1868 :     }
; 1869 : 
; 1870 :     // Add our request to its work queue if needed...
; 1871 : 
; 1872 :     if (!dev->stape_statrq.link.Flink)

  001c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ca	48 83 b8 a8 10
	00 00 00	 cmp	 QWORD PTR [rax+4264], 0
  001d2	75 75		 jne	 SHORT $LN14@int_scsi_s

; 1873 :     {
; 1874 :         InsertListTail( &sysblk.stape_status_link, &dev->stape_statrq.link );

  001d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001db	48 05 98 11 00
	00		 add	 rax, 4504		; 00001198H
  001e1	48 89 44 24 58	 mov	 QWORD PTR _EX_Head$2[rsp], rax
  001e6	48 8b 44 24 58	 mov	 rax, QWORD PTR _EX_Head$2[rsp]
  001eb	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001ef	48 89 44 24 60	 mov	 QWORD PTR _EX_Tail$3[rsp], rax
  001f4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fc	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  00201	48 89 88 a8 10
	00 00		 mov	 QWORD PTR [rax+4264], rcx
  00208	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00210	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _EX_Tail$3[rsp]
  00215	48 89 88 b0 10
	00 00		 mov	 QWORD PTR [rax+4272], rcx
  0021c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00224	48 05 a8 10 00
	00		 add	 rax, 4264		; 000010a8H
  0022a	48 8b 4c 24 60	 mov	 rcx, QWORD PTR _EX_Tail$3[rsp]
  0022f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00232	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023a	48 05 a8 10 00
	00		 add	 rax, 4264		; 000010a8H
  00240	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  00245	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN14@int_scsi_s:

; 1875 :     }
; 1876 : 
; 1877 :     // Wake up the status retrieval thread (if needed)...
; 1878 : 
; 1879 :     if (!sysblk.stape_getstat_busy)

  00249	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00250	8b 80 90 11 00
	00		 mov	 eax, DWORD PTR [rax+4496]
  00256	83 e0 01	 and	 eax, 1
  00259	85 c0		 test	 eax, eax
  0025b	75 1d		 jne	 SHORT $LN15@int_scsi_s

; 1880 :     {
; 1881 :         broadcast_condition( &sysblk.stape_getstat_cond );

  0025d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00264	48 05 88 11 00
	00		 add	 rax, 4488		; 00001188H
  0026a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169907
  00271	48 8b c8	 mov	 rcx, rax
  00274	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_broadcast_condition
$LN15@int_scsi_s:

; 1882 :     }
; 1883 : 
; 1884 :     // Wait only so long for the status to be updated...
; 1885 : 
; 1886 :     rc = timed_wait_condition_relative_usecs

  0027a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00281	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00287	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0028f	48 81 c1 a0 10
	00 00		 add	 rcx, 4256		; 000010a0H
  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169908
  0029d	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  002a2	45 33 c9	 xor	 r9d, r9d
  002a5	44 8b 84 24 88
	00 00 00	 mov	 r8d, DWORD PTR usecs$[rsp]
  002ad	48 8b d0	 mov	 rdx, rax
  002b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  002b6	89 44 24 50	 mov	 DWORD PTR rc$[rsp], eax

; 1887 :     (
; 1888 :         &dev->stape_sstat_cond,     // ptr to condition to wait on
; 1889 :         &sysblk.stape_lock,         // ptr to controlling lock (must be held!)
; 1890 :         usecs,                      // max #of microseconds to wait
; 1891 :         NULL                        // [OPTIONAL] ptr to tod value (may be NULL)
; 1892 :     );
; 1893 : 
; 1894 :     release_lock( &sysblk.stape_lock );

  002ba	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  002c1	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  002c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169909
  002ce	48 8b c8	 mov	 rcx, rax
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 1895 :     return rc;

  002d7	8b 44 24 50	 mov	 eax, DWORD PTR rc$[rsp]
$LN1@int_scsi_s:

; 1896 : } /* end function int_scsi_status_wait */

  002db	48 83 c4 78	 add	 rsp, 120		; 00000078H
  002df	c3		 ret	 0
int_scsi_status_wait ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 32
i$ = 40
opblk$ = 48
dev$ = 80
maxblk$ = 88
get_max_blocksize PROC

; 61   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 62   :     //                       2M       2M-1     256K    256K-1  128K
; 63   :     static int blksize[] = { 2097152, 2097151, 262144, 262143, 131072,
; 64   :     //                       128K-1  64K    64K-1  32K    32K-1
; 65   :                              131071, 65536, 65535, 32768, 32767 };
; 66   :     struct mtop opblk;
; 67   :     size_t i;
; 68   :     int rc;
; 69   : 
; 70   :     // Technique: keep trying to set ever decreasing fixed-
; 71   :     // length block sizes until one of them eventually works.
; 72   : 
; 73   :     for (i=0; i < _countof( blksize ); ++i)

  0000e	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR i$[rsp], 0
  00017	eb 0d		 jmp	 SHORT $LN4@get_max_bl
$LN2@get_max_bl:
  00019	48 8b 44 24 28	 mov	 rax, QWORD PTR i$[rsp]
  0001e	48 ff c0	 inc	 rax
  00021	48 89 44 24 28	 mov	 QWORD PTR i$[rsp], rax
$LN4@get_max_bl:
  00026	48 83 7c 24 28
	0a		 cmp	 QWORD PTR i$[rsp], 10
  0002c	73 40		 jae	 SHORT $LN3@get_max_bl

; 74   :     {
; 75   :         opblk.mt_op    = MTSETBLK;

  0002e	b8 14 00 00 00	 mov	 eax, 20
  00033	66 89 44 24 30	 mov	 WORD PTR opblk$[rsp], ax

; 76   :         opblk.mt_count = blksize[i];

  00038	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?blksize@?1??get_max_blocksize@@9@9
  0003f	48 8b 4c 24 28	 mov	 rcx, QWORD PTR i$[rsp]
  00044	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00047	89 44 24 34	 mov	 DWORD PTR opblk$[rsp+4], eax

; 77   : 
; 78   :         if (ioctl_tape( dev->fd, MTIOCTOP, (char*) &opblk ) == 0)

  0004b	4c 8d 44 24 30	 lea	 r8, QWORD PTR opblk$[rsp]
  00050	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00055	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  0005a	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00066	85 c0		 test	 eax, eax
  00068	75 02		 jne	 SHORT $LN5@get_max_bl

; 79   :             break;

  0006a	eb 02		 jmp	 SHORT $LN3@get_max_bl
$LN5@get_max_bl:

; 80   :     }

  0006c	eb ab		 jmp	 SHORT $LN2@get_max_bl
$LN3@get_max_bl:

; 81   : 
; 82   :     if (i >= _countof( blksize ))

  0006e	48 83 7c 24 28
	0a		 cmp	 QWORD PTR i$[rsp], 10
  00074	72 09		 jb	 SHORT $LN6@get_max_bl

; 83   :         i  = _countof( blksize ) - 1;

  00076	48 c7 44 24 28
	09 00 00 00	 mov	 QWORD PTR i$[rsp], 9
$LN6@get_max_bl:

; 84   : 
; 85   :     *maxblk = blksize[i];

  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?blksize@?1??get_max_blocksize@@9@9
  00086	48 8b 4c 24 58	 mov	 rcx, QWORD PTR maxblk$[rsp]
  0008b	48 8b 54 24 28	 mov	 rdx, QWORD PTR i$[rsp]
  00090	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00093	89 01		 mov	 DWORD PTR [rcx], eax

; 86   : 
; 87   :     // (reset back to variable blocksize mode again)
; 88   : 
; 89   :     opblk.mt_op    = MTSETBLK;

  00095	b8 14 00 00 00	 mov	 eax, 20
  0009a	66 89 44 24 30	 mov	 WORD PTR opblk$[rsp], ax

; 90   :     opblk.mt_count = 0;

  0009f	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR opblk$[rsp+4], 0

; 91   : 
; 92   :     rc = ioctl_tape( dev->fd, MTIOCTOP, (char*) &opblk );

  000a7	4c 8d 44 24 30	 lea	 r8, QWORD PTR opblk$[rsp]
  000ac	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  000b1	48 8b 44 24 50	 mov	 rax, QWORD PTR dev$[rsp]
  000b6	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000bc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  000c2	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 93   :     return rc;

  000c6	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 94   : }

  000ca	48 83 c4 48	 add	 rsp, 72			; 00000048H
  000ce	c3		 ret	 0
get_max_blocksize ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
fd$ = 32
fn$ = 64
ro$ = 72
int_nbio_scsitape_open PROC

; 40   : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 41   :     int fd;
; 42   : 
; 43   :     /* Try opening device in read/write mode first */
; 44   :     *ro = 0;

  0000e	48 8b 44 24 48	 mov	 rax, QWORD PTR ro$[rsp]
  00013	c6 00 00	 mov	 BYTE PTR [rax], 0

; 45   :     fd = open_tape( fn, O_RDWR | O_BINARY | O_NONBLOCK );

  00016	ba 02 80 00 00	 mov	 edx, 32770		; 00008002H
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fn$[rsp]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_open_tape
  00026	89 44 24 20	 mov	 DWORD PTR fd$[rsp], eax

; 46   : 
; 47   :     if (fd < 0 && EROFS == errno )

  0002a	83 7c 24 20 00	 cmp	 DWORD PTR fd$[rsp], 0
  0002f	7d 27		 jge	 SHORT $LN2@int_nbio_s
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00037	83 38 1e	 cmp	 DWORD PTR [rax], 30
  0003a	75 1c		 jne	 SHORT $LN2@int_nbio_s

; 48   :     {
; 49   :         /* If that didn't work then try read-only */
; 50   :         *ro = 1;

  0003c	48 8b 44 24 48	 mov	 rax, QWORD PTR ro$[rsp]
  00041	c6 00 01	 mov	 BYTE PTR [rax], 1

; 51   :         fd = open_tape( fn, O_RDONLY | O_BINARY | O_NONBLOCK );

  00044	ba 00 80 00 00	 mov	 edx, 32768		; 00008000H
  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR fn$[rsp]
  0004e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_open_tape
  00054	89 44 24 20	 mov	 DWORD PTR fd$[rsp], eax
$LN2@int_nbio_s:

; 52   :     }
; 53   : 
; 54   :     return fd;

  00058	8b 44 24 20	 mov	 eax, DWORD PTR fd$[rsp]

; 55   : }

  0005c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00060	c3		 ret	 0
int_nbio_scsitape_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
bot$ = 32
msk$ = 36
dev$ = 64
define_BOT_pos PROC

; 2264 : {

$LN13:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 2265 : #ifdef _MSVC_
; 2266 : 
; 2267 :     // PROGRAMMING NOTE: Need to tell 'w32stape.c' here the
; 2268 :     // information it needs to detect physical BOT (load-point).
; 2269 : 
; 2270 :     // This is not normally needed as most drivers determine
; 2271 :     // it for themselves based on the type (manufacturer/model)
; 2272 :     // of tape drive being used, but since I haven't added the
; 2273 :     // code to 'w32stape.c' to do that yet (involves talking
; 2274 :     // directly to the SCSI device itself) we thus, for now,
; 2275 :     // need to pass that information directly to 'w32stape.c'
; 2276 :     // ourselves...
; 2277 : 
; 2278 :     U32 msk  = 0xFF3FFFFF;      // (3480/3490 default)

  00009	c7 44 24 24 ff
	ff 3f ff	 mov	 DWORD PTR msk$[rsp], -12582913 ; ff3fffffH

; 2279 :     U32 bot  = 0x01000000;      // (3480/3490 default)

  00011	c7 44 24 20 00
	00 00 01	 mov	 DWORD PTR bot$[rsp], 16777216 ; 01000000H

; 2280 : 
; 2281 :     if ( dev->stape_blkid_32 )

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  00024	d1 e8		 shr	 eax, 1
  00026	83 e0 01	 and	 eax, 1
  00029	85 c0		 test	 eax, eax
  0002b	74 10		 je	 SHORT $LN8@define_BOT

; 2282 :     {
; 2283 :         msk  = 0xFFFFFFFF;      // (3590 default)

  0002d	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR msk$[rsp], -1	; ffffffffH

; 2284 :         bot  = 0x00000000;      // (3590 default)

  00035	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR bot$[rsp], 0
$LN8@define_BOT:
$LN4@define_BOT:

; 2285 :     }
; 2286 : 
; 2287 :     VERIFY( 0 == w32_define_BOT( dev->fd, msk, bot ) );

  0003d	44 8b 44 24 20	 mov	 r8d, DWORD PTR bot$[rsp]
  00042	8b 54 24 24	 mov	 edx, DWORD PTR msk$[rsp]
  00046	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_define_BOT
  00057	85 c0		 test	 eax, eax
  00059	74 5c		 je	 SHORT $LN9@define_BOT
$LN7@define_BOT:
  0005b	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170083
  00062	41 b8 ef 08 00
	00		 mov	 r8d, 2287		; 000008efH
  00068	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170084
  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170085
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00082	85 c0		 test	 eax, eax
  00084	74 20		 je	 SHORT $LN10@define_BOT
  00086	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG170087
  0008d	41 b8 ef 08 00
	00		 mov	 r8d, 2287		; 000008efH
  00093	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170088
  0009a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170089
  000a1	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@define_BOT:
  000a6	33 c0		 xor	 eax, eax
  000a8	85 c0		 test	 eax, eax
  000aa	75 af		 jne	 SHORT $LN7@define_BOT
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000b2	85 c0		 test	 eax, eax
  000b4	74 01		 je	 SHORT $LN11@define_BOT
  000b6	cc		 int	 3
$LN11@define_BOT:
$LN9@define_BOT:
  000b7	33 c0		 xor	 eax, eax
  000b9	85 c0		 test	 eax, eax
  000bb	75 80		 jne	 SHORT $LN4@define_BOT

; 2288 : 
; 2289 : #else
; 2290 :     UNREFERENCED(dev);
; 2291 : #endif // _MSVC_
; 2292 : }

  000bd	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000c1	c3		 ret	 0
define_BOT_pos ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
dev$ = 112
ro$1 = 120
fd$ = 124
pListEntry$ = 128
timeout$ = 136
tv163 = 140
tv182 = 144
tv188 = 148
tv66 = 152
tv71 = 156
tv260 = 160
tv265 = 164
req$ = 168
_EX_Flink$2 = 176
_EX_Blink$3 = 184
_EX_Flink$4 = 192
_EX_Blink$5 = 200
_EX_Flink$6 = 208
_EX_Blink$7 = 216
now$ = 224
tv140 = 232
tv170 = 240
tv174 = 248
tv177 = 256
notused$ = 288
scsi_tapemountmon_thread PROC

; 2101 : {

$LN31:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec 18 01
	00 00		 sub	 rsp, 280		; 00000118H

; 2102 :     struct timeval  now;
; 2103 :     int             timeout, fd;
; 2104 :     LIST_ENTRY*     pListEntry;
; 2105 :     STMNTDRQ*       req;
; 2106 :     DEVBLK*         dev = NULL;

  0000c	48 c7 44 24 70
	00 00 00 00	 mov	 QWORD PTR dev$[rsp], 0
$LN4@scsi_tapem:

; 2107 : 
; 2108 :     UNREFERENCED( notused );

  00015	33 c0		 xor	 eax, eax
  00017	85 c0		 test	 eax, eax
  00019	75 fa		 jne	 SHORT $LN4@scsi_tapem

; 2109 : 
; 2110 :     // "Thread id "TIDPAT", prio %d, name '%s' started"
; 2111 :     LOG_THREAD_BEGIN( SCSIMOUNT_THREAD_NAME  );

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170039
  00028	8b c8		 mov	 ecx, eax
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  00030	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv66[rsp], eax
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  0003d	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv71[rsp], eax
  00044	b9 01 00 00 00	 mov	 ecx, 1
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0004f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170038
  00056	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0005b	8b 8c 24 98 00
	00 00		 mov	 ecx, DWORD PTR tv66[rsp]
  00062	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00066	8b 8c 24 9c 00
	00 00		 mov	 ecx, DWORD PTR tv71[rsp]
  0006d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00071	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170040
  00078	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0007d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170041
  00084	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00089	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0008e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00094	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170042
  0009b	ba 3f 08 00 00	 mov	 edx, 2111		; 0000083fH
  000a0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170043
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2112 : 
; 2113 :     obtain_lock( &sysblk.stape_lock );

  000ad	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000b4	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  000ba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170044
  000c1	48 8b c8	 mov	 rcx, rax
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock
$LN5@scsi_tapem:

; 2114 : 
; 2115 :     while (sysblk.auto_scsi_mount_secs && !sysblk.shutdown)

  000ca	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000d1	83 b8 78 11 00
	00 00		 cmp	 DWORD PTR [rax+4472], 0
  000d8	0f 84 8e 04 00
	00		 je	 $LN6@scsi_tapem
  000de	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000e5	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  000eb	c1 e8 0b	 shr	 eax, 11
  000ee	83 e0 01	 and	 eax, 1
  000f1	85 c0		 test	 eax, eax
  000f3	0f 85 73 04 00
	00		 jne	 $LN6@scsi_tapem

; 2116 :     {
; 2117 :         // Wait for automount interval to expire...
; 2118 : 
; 2119 :         gettimeofday( &now, NULL );

  000f9	33 d2		 xor	 edx, edx
  000fb	48 8d 8c 24 e0
	00 00 00	 lea	 rcx, QWORD PTR now$[rsp]
  00103	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_gettimeofday

; 2120 : 
; 2121 :         for
; 2122 :         (
; 2123 :             timeout = 0

  00109	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR timeout$[rsp], 0
$LN7@scsi_tapem:

; 2124 :             ;
; 2125 :             1
; 2126 :                 && !sysblk.shutdown
; 2127 :                 && sysblk.auto_scsi_mount_secs
; 2128 :                 && !(timeout = timed_wait_condition_relative_usecs

  00114	33 c0		 xor	 eax, eax
  00116	83 f8 01	 cmp	 eax, 1
  00119	0f 84 a1 00 00
	00		 je	 $LN8@scsi_tapem
  0011f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00126	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  0012c	c1 e8 0b	 shr	 eax, 11
  0012f	83 e0 01	 and	 eax, 1
  00132	85 c0		 test	 eax, eax
  00134	0f 85 86 00 00
	00		 jne	 $LN8@scsi_tapem
  0013a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00141	83 b8 78 11 00
	00 00		 cmp	 DWORD PTR [rax+4472], 0
  00148	74 76		 je	 SHORT $LN8@scsi_tapem
  0014a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00151	69 80 78 11 00
	00 40 42 0f 00	 imul	 eax, DWORD PTR [rax+4472], 1000000 ; 000f4240H
  0015b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00162	48 81 c1 70 11
	00 00		 add	 rcx, 4464		; 00001170H
  00169	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_sysblk
  00170	48 81 c2 88 11
	00 00		 add	 rdx, 4488		; 00001188H
  00177	48 89 94 24 e8
	00 00 00	 mov	 QWORD PTR tv140[rsp], rdx
  0017f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170045
  00186	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  0018b	4c 8d 8c 24 e0
	00 00 00	 lea	 r9, QWORD PTR now$[rsp]
  00193	44 8b c0	 mov	 r8d, eax
  00196	48 8b d1	 mov	 rdx, rcx
  00199	48 8b 84 24 e8
	00 00 00	 mov	 rax, QWORD PTR tv140[rsp]
  001a1	48 8b c8	 mov	 rcx, rax
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_timed_wait_condition_relative_usecs_impl
  001aa	89 84 24 88 00
	00 00		 mov	 DWORD PTR timeout$[rsp], eax
  001b1	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR timeout$[rsp], 0
  001b9	75 05		 jne	 SHORT $LN8@scsi_tapem

; 2129 :                     (
; 2130 :                         &sysblk.stape_getstat_cond,
; 2131 :                         &sysblk.stape_lock,
; 2132 :                         sysblk.auto_scsi_mount_secs * 1000000,
; 2133 :                         &now
; 2134 :                     ))
; 2135 :             ;
; 2136 :         );

  001bb	e9 54 ff ff ff	 jmp	 $LN7@scsi_tapem
$LN8@scsi_tapem:

; 2137 : 
; 2138 :         if (sysblk.auto_scsi_mount_secs && !sysblk.shutdown)

  001c0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001c7	83 b8 78 11 00
	00 00		 cmp	 DWORD PTR [rax+4472], 0
  001ce	0f 84 93 03 00
	00		 je	 $LN14@scsi_tapem
  001d4	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001db	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  001e1	c1 e8 0b	 shr	 eax, 11
  001e4	83 e0 01	 and	 eax, 1
  001e7	85 c0		 test	 eax, eax
  001e9	0f 85 78 03 00
	00		 jne	 $LN14@scsi_tapem

; 2139 :         {
; 2140 :             // Process all work items...
; 2141 : 
; 2142 :             pListEntry = sysblk.stape_mount_link.Flink;

  001ef	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001f6	48 8b 80 a8 11
	00 00		 mov	 rax, QWORD PTR [rax+4520]
  001fd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pListEntry$[rsp], rax
$LN30@scsi_tapem:
$LN29@scsi_tapem:
$LN10@scsi_tapem:

; 2143 : 
; 2144 :             while (pListEntry != &sysblk.stape_mount_link)

  00205	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0020c	48 05 a8 11 00
	00		 add	 rax, 4520		; 000011a8H
  00212	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR pListEntry$[rsp], rax
  0021a	0f 84 47 03 00
	00		 je	 $LN11@scsi_tapem

; 2145 :             {
; 2146 :                 req = CONTAINING_RECORD( pListEntry, STMNTDRQ, link );

  00220	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00228	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR req$[rsp], rax

; 2147 :                 dev = req->dev;

  00230	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR req$[rsp]
  00238	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0023c	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax

; 2148 :                 pListEntry  = pListEntry->Flink;

  00241	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00249	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0024c	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pListEntry$[rsp], rax

; 2149 : 
; 2150 :                 // Open drive if needed...
; 2151 : 
; 2152 :                 if ((fd = dev->fd) < 0)

  00254	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00259	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  0025f	89 44 24 7c	 mov	 DWORD PTR fd$[rsp], eax
  00263	83 7c 24 7c 00	 cmp	 DWORD PTR fd$[rsp], 0
  00268	0f 8d a4 01 00
	00		 jge	 $LN15@scsi_tapem

; 2153 :                 {
; 2154 :                     BYTE ro;
; 2155 : 
; 2156 :                     fd = int_nbio_scsitape_open( dev->filename, &ro );

  0026e	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00273	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00279	48 8d 54 24 78	 lea	 rdx, QWORD PTR ro$1[rsp]
  0027e	48 8b c8	 mov	 rcx, rax
  00281	e8 00 00 00 00	 call	 int_nbio_scsitape_open
  00286	89 44 24 7c	 mov	 DWORD PTR fd$[rsp], eax

; 2157 :                     dev->readonly = ro ? 1 : 0;

  0028a	0f b6 44 24 78	 movzx	 eax, BYTE PTR ro$1[rsp]
  0028f	85 c0		 test	 eax, eax
  00291	74 0d		 je	 SHORT $LN23@scsi_tapem
  00293	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv163[rsp], 1
  0029e	eb 0b		 jmp	 SHORT $LN24@scsi_tapem
$LN23@scsi_tapem:
  002a0	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv163[rsp], 0
$LN24@scsi_tapem:
  002ab	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv163[rsp]
  002b2	83 e0 01	 and	 eax, 1
  002b5	d1 e0		 shl	 eax, 1
  002b7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  002bc	8b 89 78 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4216]
  002c2	83 e1 fd	 and	 ecx, -3			; fffffffdH
  002c5	0b c8		 or	 ecx, eax
  002c7	8b c1		 mov	 eax, ecx
  002c9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  002ce	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 2158 : 
; 2159 :                     // Check for successful open
; 2160 : 
; 2161 :                     if (fd < 0)

  002d4	83 7c 24 7c 00	 cmp	 DWORD PTR fd$[rsp], 0
  002d9	0f 8d 1a 01 00
	00		 jge	 $LN16@scsi_tapem

; 2162 :                     {
; 2163 :                         // "%1d:%04X Tape file %s, type %s: Error opening: errno=%d: %s"
; 2164 :                         WRMSG( HHC00213, "E", LCSS_DEVNUM,

  002df	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  002e5	74 12		 je	 SHORT $LN25@scsi_tapem
  002e7	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  002ec	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  002f0	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv182[rsp], eax
  002f7	eb 0b		 jmp	 SHORT $LN26@scsi_tapem
$LN25@scsi_tapem:
  002f9	c7 84 24 90 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv182[rsp], 0
$LN26@scsi_tapem:
  00304	48 83 7c 24 70
	00		 cmp	 QWORD PTR dev$[rsp], 0
  0030a	74 14		 je	 SHORT $LN27@scsi_tapem
  0030c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00311	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00315	d1 f8		 sar	 eax, 1
  00317	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv188[rsp], eax
  0031e	eb 0b		 jmp	 SHORT $LN28@scsi_tapem
$LN27@scsi_tapem:
  00320	c7 84 24 94 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv188[rsp], 0
$LN28@scsi_tapem:
  0032b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00331	8b 08		 mov	 ecx, DWORD PTR [rax]
  00333	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00339	48 89 84 24 f0
	00 00 00	 mov	 QWORD PTR tv170[rsp], rax
  00341	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00347	48 89 84 24 f8
	00 00 00	 mov	 QWORD PTR tv174[rsp], rax
  0034f	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00354	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0035b	48 89 8c 24 00
	01 00 00	 mov	 QWORD PTR tv177[rsp], rcx
  00363	b9 01 00 00 00	 mov	 ecx, 1
  00368	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0036e	48 8b 8c 24 f0
	00 00 00	 mov	 rcx, QWORD PTR tv170[rsp]
  00376	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0037b	48 8b 8c 24 f8
	00 00 00	 mov	 rcx, QWORD PTR tv174[rsp]
  00383	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00385	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170049
  00390	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00395	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR tv177[rsp]
  0039d	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  003a2	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR tv182[rsp]
  003a9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  003ad	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR tv188[rsp]
  003b4	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  003b8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170050
  003bf	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003c4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170051
  003cb	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003d0	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003d5	41 b9 03 00 00
	00		 mov	 r9d, 3
  003db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170052
  003e2	ba 75 08 00 00	 mov	 edx, 2165		; 00000875H
  003e7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170053
  003ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2165 :                                 dev->filename, "scsi", errno, strerror( errno ));
; 2166 :                         continue; // (go on to next drive)

  003f4	e9 0c fe ff ff	 jmp	 $LN10@scsi_tapem
$LN16@scsi_tapem:

; 2167 :                     }
; 2168 : 
; 2169 :                     define_BOT_pos( dev );  // (always after successful open)

  003f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  003fe	e8 00 00 00 00	 call	 define_BOT_pos

; 2170 :                     dev->fd = fd;           // (so far so good)

  00403	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00408	8b 4c 24 7c	 mov	 ecx, DWORD PTR fd$[rsp]
  0040c	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
$LN15@scsi_tapem:

; 2171 :                 }
; 2172 : 
; 2173 :                 // Retrieve the current status...
; 2174 : 
; 2175 :                 // PLEASE NOTE that we must do this WITHOUT holding the stape_lock
; 2176 :                 // since the 'int_scsi_status_update' and sub-functions all expect
; 2177 :                 // the lock to NOT be held so that THEY can then attempt to acquire
; 2178 :                 // it when needed...
; 2179 : 
; 2180 :                 release_lock( &sysblk.stape_lock );

  00412	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00419	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  0041f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170054
  00426	48 8b c8	 mov	 rcx, rax
  00429	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2181 :                 {
; 2182 :                     int_scsi_status_update( dev, 0 );

  0042f	33 d2		 xor	 edx, edx
  00431	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  00436	e8 00 00 00 00	 call	 int_scsi_status_update

; 2183 :                 }
; 2184 :                 obtain_lock( &sysblk.stape_lock );

  0043b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00442	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00448	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170055
  0044f	48 8b c8	 mov	 rcx, rax
  00452	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2185 : 
; 2186 :                 // (check again for shutdown)
; 2187 : 
; 2188 :                 if (sysblk.shutdown || !sysblk.auto_scsi_mount_secs)

  00458	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0045f	8b 80 94 12 00
	00		 mov	 eax, DWORD PTR [rax+4756]
  00465	c1 e8 0b	 shr	 eax, 11
  00468	83 e0 01	 and	 eax, 1
  0046b	85 c0		 test	 eax, eax
  0046d	75 10		 jne	 SHORT $LN18@scsi_tapem
  0046f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00476	83 b8 78 11 00
	00 00		 cmp	 DWORD PTR [rax+4472], 0
  0047d	75 05		 jne	 SHORT $LN17@scsi_tapem
$LN18@scsi_tapem:

; 2189 :                     break;

  0047f	e9 e3 00 00 00	 jmp	 $LN11@scsi_tapem
$LN17@scsi_tapem:

; 2190 : 
; 2191 :                 // Has a tape [finally] been mounted yet??
; 2192 : 
; 2193 :                 if (STS_NOT_MOUNTED( dev ))

  00484	33 d2		 xor	 edx, edx
  00486	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0048b	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00490	85 c0		 test	 eax, eax
  00492	75 05		 jne	 SHORT $LN19@scsi_tapem

; 2194 :                 {
; 2195 : #if !defined( _MSVC_ )
; 2196 :                     dev->fd = -1;
; 2197 :                     close_tape( fd );
; 2198 : #endif
; 2199 :                     continue; // (go on to next drive)

  00494	e9 6c fd ff ff	 jmp	 $LN29@scsi_tapem
$LN19@scsi_tapem:

; 2200 :                 }
; 2201 : 
; 2202 :                 // Yes, remove completed work item...
; 2203 : 
; 2204 :                 RemoveListEntry( &dev->stape_mntdrq.link );

  00499	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  0049e	48 8b 80 c0 10
	00 00		 mov	 rax, QWORD PTR [rax+4288]
  004a5	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR _EX_Flink$2[rsp], rax
  004ad	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004b2	48 8b 80 c8 10
	00 00		 mov	 rax, QWORD PTR [rax+4296]
  004b9	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR _EX_Blink$3[rsp], rax
  004c1	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$3[rsp]
  004c9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$2[rsp]
  004d1	48 89 08	 mov	 QWORD PTR [rax], rcx
  004d4	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$2[rsp]
  004dc	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$3[rsp]
  004e4	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2205 :                 InitializeListLink( &dev->stape_mntdrq.link );

  004e8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004ed	48 c7 80 c8 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4296], 0
  004f8	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  004fd	48 c7 80 c0 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4288], 0

; 2206 : 
; 2207 :                 // Finish the open drive process (set drive to variable length
; 2208 :                 // block processing mode, etc)...
; 2209 : 
; 2210 :                 // PLEASE NOTE that we must do this WITHOUT holding the stape_lock
; 2211 :                 // since the 'finish_scsitape_open' and sub-functions all expect
; 2212 :                 // the lock to NOT be held so that THEY can then attempt to acquire
; 2213 :                 // it when needed...
; 2214 : 
; 2215 :                 release_lock( &sysblk.stape_lock );

  00508	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0050f	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00515	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170059
  0051c	48 8b c8	 mov	 rcx, rax
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2216 :                 {
; 2217 :                     if ( finish_scsitape_open( dev, NULL, 0 ) == 0 )

  00525	45 33 c0	 xor	 r8d, r8d
  00528	33 d2		 xor	 edx, edx
  0052a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0052f	e8 00 00 00 00	 call	 finish_scsitape_open
  00534	85 c0		 test	 eax, eax
  00536	75 0d		 jne	 SHORT $LN20@scsi_tapem

; 2218 :                     {
; 2219 :                         // Notify the guest that the tape has now been loaded by
; 2220 :                         // presenting an unsolicited device attention interrupt...
; 2221 : 
; 2222 :                         device_attention( dev, CSW_DE );

  00538	b2 04		 mov	 dl, 4
  0053a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR dev$[rsp]
  0053f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_device_attention
$LN20@scsi_tapem:

; 2223 :                     }
; 2224 :                 }
; 2225 :                 obtain_lock( &sysblk.stape_lock );

  00545	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0054c	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00552	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170061
  00559	48 8b c8	 mov	 rcx, rax
  0055c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2226 : 
; 2227 :             } // end for (all work items)...

  00562	e9 9e fc ff ff	 jmp	 $LN30@scsi_tapem
$LN11@scsi_tapem:
$LN14@scsi_tapem:

; 2228 : 
; 2229 :         } // end if (sysblk.auto_scsi_mount_secs && !sysblk.shutdown)
; 2230 : 
; 2231 :     } // end while (sysblk.auto_scsi_mount_secs && !sysblk.shutdown)

  00567	e9 5e fb ff ff	 jmp	 $LN5@scsi_tapem
$LN6@scsi_tapem:
$LN12@scsi_tapem:

; 2232 : 
; 2233 :     // (discard all work items since we're going away)
; 2234 : 
; 2235 :     while (!IsListEmpty( &sysblk.stape_mount_link ))

  0056c	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00573	48 05 a8 11 00
	00		 add	 rax, 4520		; 000011a8H
  00579	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  00580	48 39 81 a8 11
	00 00		 cmp	 QWORD PTR [rcx+4520], rax
  00587	0f 84 33 01 00
	00		 je	 $LN13@scsi_tapem

; 2236 :     {
; 2237 :         pListEntry = RemoveListHead( &sysblk.stape_mount_link );

  0058d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00594	48 8b 80 a8 11
	00 00		 mov	 rax, QWORD PTR [rax+4520]
  0059b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR pListEntry$[rsp], rax
  005a3	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005aa	48 8b 80 a8 11
	00 00		 mov	 rax, QWORD PTR [rax+4520]
  005b1	48 8b 00	 mov	 rax, QWORD PTR [rax]
  005b4	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR _EX_Flink$4[rsp], rax
  005bc	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  005c3	48 8b 80 a8 11
	00 00		 mov	 rax, QWORD PTR [rax+4520]
  005ca	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  005ce	48 89 84 24 c8
	00 00 00	 mov	 QWORD PTR _EX_Blink$5[rsp], rax
  005d6	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$5[rsp]
  005de	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$4[rsp]
  005e6	48 89 08	 mov	 QWORD PTR [rax], rcx
  005e9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$4[rsp]
  005f1	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$5[rsp]
  005f9	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2238 :         InitializeListLink( pListEntry );

  005fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00605	48 c7 40 08 00
	00 00 00	 mov	 QWORD PTR [rax+8], 0
  0060d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00615	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 2239 : 
; 2240 :         // (remove from the STATUS thread's work queue too!)
; 2241 : 
; 2242 :         req = CONTAINING_RECORD( pListEntry, STMNTDRQ, link );

  0061c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR pListEntry$[rsp]
  00624	48 89 84 24 a8
	00 00 00	 mov	 QWORD PTR req$[rsp], rax

; 2243 :         dev = req->dev;

  0062c	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR req$[rsp]
  00634	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00638	48 89 44 24 70	 mov	 QWORD PTR dev$[rsp], rax

; 2244 : 
; 2245 :         if (                     dev->stape_statrq.link.Flink) {

  0063d	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00642	48 83 b8 a8 10
	00 00 00	 cmp	 QWORD PTR [rax+4264], 0
  0064a	74 6f		 je	 SHORT $LN21@scsi_tapem

; 2246 :             RemoveListEntry(    &dev->stape_statrq.link );

  0064c	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00651	48 8b 80 a8 10
	00 00		 mov	 rax, QWORD PTR [rax+4264]
  00658	48 89 84 24 d0
	00 00 00	 mov	 QWORD PTR _EX_Flink$6[rsp], rax
  00660	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  00665	48 8b 80 b0 10
	00 00		 mov	 rax, QWORD PTR [rax+4272]
  0066c	48 89 84 24 d8
	00 00 00	 mov	 QWORD PTR _EX_Blink$7[rsp], rax
  00674	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$7[rsp]
  0067c	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$6[rsp]
  00684	48 89 08	 mov	 QWORD PTR [rax], rcx
  00687	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$6[rsp]
  0068f	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$7[rsp]
  00697	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 2247 :             InitializeListLink( &dev->stape_statrq.link );

  0069b	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006a0	48 c7 80 b0 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4272], 0
  006ab	48 8b 44 24 70	 mov	 rax, QWORD PTR dev$[rsp]
  006b0	48 c7 80 a8 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4264], 0
$LN21@scsi_tapem:

; 2248 :         }
; 2249 :     }

  006bb	e9 ac fe ff ff	 jmp	 $LN12@scsi_tapem
$LN13@scsi_tapem:

; 2250 : 
; 2251 :     // "Thread id "TIDPAT", prio %d, name '%s' ended"
; 2252 :     LOG_THREAD_END( SCSIMOUNT_THREAD_NAME  );

  006c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  006c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170064
  006cd	8b c8		 mov	 ecx, eax
  006cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_get_thread_prio
  006d5	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv260[rsp], eax
  006dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fthread_self
  006e2	89 84 24 a4 00
	00 00		 mov	 DWORD PTR tv265[rsp], eax
  006e9	b9 01 00 00 00	 mov	 ecx, 1
  006ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  006f4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170063
  006fb	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00700	8b 8c 24 a0 00
	00 00		 mov	 ecx, DWORD PTR tv260[rsp]
  00707	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0070b	8b 8c 24 a4 00
	00 00		 mov	 ecx, DWORD PTR tv265[rsp]
  00712	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00716	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170065
  0071d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00722	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170066
  00729	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0072e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00733	41 b9 03 00 00
	00		 mov	 r9d, 3
  00739	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG170067
  00740	ba cc 08 00 00	 mov	 edx, 2252		; 000008ccH
  00745	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG170068
  0074c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2253 : 
; 2254 :     sysblk.stape_mountmon_tid = 0;  // (we're going away)

  00752	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00759	c7 80 80 11 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4480], 0

; 2255 :     release_lock( &sysblk.stape_lock );

  00763	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0076a	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00770	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG170069
  00777	48 8b c8	 mov	 rcx, rax
  0077a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2256 :     return NULL;

  00780	33 c0		 xor	 eax, eax

; 2257 : 
; 2258 : } /* end function scsi_tapemountmon_thread */

  00782	48 81 c4 18 01
	00 00		 add	 rsp, 280		; 00000118H
  00789	c3		 ret	 0
scsi_tapemountmon_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$1 = 64
tv70 = 68
tv74 = 72
tv80 = 76
_EX_Head$2 = 80
_EX_Tail$3 = 88
tv139 = 96
dev$ = 128
create_automount_thread PROC

; 2045 : {

$LN25:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 2046 :     //               AUTO-SCSI-MOUNT
; 2047 :     //
; 2048 :     // If no tape is currently mounted on this device,
; 2049 :     // kick off the tape mount monitoring thread that
; 2050 :     // will monitor for tape mounts (if it doesn't al-
; 2051 :     // ready still exist)...
; 2052 : 
; 2053 :     obtain_lock( &sysblk.stape_lock );

  00009	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  00010	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00016	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169971
  0001d	48 8b c8	 mov	 rcx, rax
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 2054 : 
; 2055 :     // Is scsimount enabled?
; 2056 : 
; 2057 :     if (likely( sysblk.auto_scsi_mount_secs ))

  00026	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0002d	83 b8 78 11 00
	00 00		 cmp	 DWORD PTR [rax+4472], 0
  00034	74 0a		 je	 SHORT $LN17@create_aut
  00036	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR tv70[rsp], 1
  0003e	eb 08		 jmp	 SHORT $LN18@create_aut
$LN17@create_aut:
  00040	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
$LN18@create_aut:
  00048	83 7c 24 44 00	 cmp	 DWORD PTR tv70[rsp], 0
  0004d	0f 84 02 02 00
	00		 je	 $LN8@create_aut

; 2058 :     {
; 2059 :         // Create thread if needed...
; 2060 : 
; 2061 :         if (unlikely( !sysblk.stape_mountmon_tid ))

  00053	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0005a	83 b8 80 11 00
	00 00		 cmp	 DWORD PTR [rax+4480], 0
  00061	75 0a		 jne	 SHORT $LN19@create_aut
  00063	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv74[rsp], 1
  0006b	eb 08		 jmp	 SHORT $LN20@create_aut
$LN19@create_aut:
  0006d	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv74[rsp], 0
$LN20@create_aut:
  00075	83 7c 24 48 00	 cmp	 DWORD PTR tv74[rsp], 0
  0007a	74 0a		 je	 SHORT $LN23@create_aut
  0007c	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv80[rsp], 1
  00084	eb 08		 jmp	 SHORT $LN24@create_aut
$LN23@create_aut:
  00086	c7 44 24 4c 00
	00 00 00	 mov	 DWORD PTR tv80[rsp], 0
$LN24@create_aut:
  0008e	83 7c 24 4c 00	 cmp	 DWORD PTR tv80[rsp], 0
  00093	0f 84 1e 01 00
	00		 je	 $LN9@create_aut
$LN4@create_aut:

; 2062 :         {
; 2063 :             int rc;
; 2064 :             VERIFY

  00099	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  000a0	48 05 88 10 00
	00		 add	 rax, 4232		; 00001088H
  000a6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_sysblk
  000ad	48 81 c1 80 11
	00 00		 add	 rcx, 4480		; 00001180H
  000b4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169975
  000bb	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  000c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169976
  000c7	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  000cc	45 33 c9	 xor	 r9d, r9d
  000cf	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:scsi_tapemountmon_thread
  000d6	48 8b d0	 mov	 rdx, rax
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_create_thread
  000df	89 44 24 40	 mov	 DWORD PTR rc$1[rsp], eax
  000e3	83 7c 24 40 00	 cmp	 DWORD PTR rc$1[rsp], 0
  000e8	74 5c		 je	 SHORT $LN10@create_aut
$LN7@create_aut:
  000ea	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169977
  000f1	41 b8 1b 08 00
	00		 mov	 r8d, 2075		; 0000081bH
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169978
  000fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169979
  00105	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00111	85 c0		 test	 eax, eax
  00113	74 20		 je	 SHORT $LN11@create_aut
  00115	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169981
  0011c	41 b8 1b 08 00
	00		 mov	 r8d, 2075		; 0000081bH
  00122	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169982
  00129	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169983
  00130	e8 00 00 00 00	 call	 DebuggerTrace
$LN11@create_aut:
  00135	33 c0		 xor	 eax, eax
  00137	85 c0		 test	 eax, eax
  00139	75 af		 jne	 SHORT $LN7@create_aut
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  00141	85 c0		 test	 eax, eax
  00143	74 01		 je	 SHORT $LN12@create_aut
  00145	cc		 int	 3
$LN12@create_aut:
$LN10@create_aut:
  00146	33 c0		 xor	 eax, eax
  00148	85 c0		 test	 eax, eax
  0014a	0f 85 49 ff ff
	ff		 jne	 $LN4@create_aut

; 2065 :             (
; 2066 :                 (rc = create_thread
; 2067 :                 (
; 2068 :                     &sysblk.stape_mountmon_tid,
; 2069 :                     DETACHED,
; 2070 :                     scsi_tapemountmon_thread,
; 2071 :                     NULL,
; 2072 :                     SCSIMOUNT_THREAD_NAME
; 2073 :                 ))
; 2074 :                 == 0
; 2075 :             );
; 2076 :             if (rc)

  00150	83 7c 24 40 00	 cmp	 DWORD PTR rc$1[rsp], 0
  00155	74 60		 je	 SHORT $LN13@create_aut

; 2077 :                 // "Error in function create_thread(): %s"
; 2078 :                 WRMSG( HHC00102, "E", strerror( rc ));

  00157	8b 4c 24 40	 mov	 ecx, DWORD PTR rc$1[rsp]
  0015b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00161	48 89 44 24 60	 mov	 QWORD PTR tv139[rsp], rax
  00166	b9 01 00 00 00	 mov	 ecx, 1
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00171	48 8b 4c 24 60	 mov	 rcx, QWORD PTR tv139[rsp]
  00176	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  0017b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169986
  00182	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00187	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169987
  0018e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00193	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00198	41 b9 03 00 00
	00		 mov	 r9d, 3
  0019e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169988
  001a5	ba 1e 08 00 00	 mov	 edx, 2078		; 0000081eH
  001aa	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169989
  001b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@create_aut:
$LN9@create_aut:

; 2079 :         }
; 2080 : 
; 2081 :         // Enable it for our drive if needed...
; 2082 : 
; 2083 :         if (STS_NOT_MOUNTED( dev ))

  001b7	33 d2		 xor	 edx, edx
  001b9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c1	e8 00 00 00 00	 call	 int_scsi_status_mounted
  001c6	85 c0		 test	 eax, eax
  001c8	0f 85 87 00 00
	00		 jne	 $LN14@create_aut

; 2084 :         {
; 2085 :             if (!dev->stape_mntdrq.link.Flink)

  001ce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d6	48 83 b8 c0 10
	00 00 00	 cmp	 QWORD PTR [rax+4288], 0
  001de	75 75		 jne	 SHORT $LN15@create_aut

; 2086 :             {
; 2087 :                 InsertListTail( &sysblk.stape_mount_link, &dev->stape_mntdrq.link );

  001e0	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  001e7	48 05 a8 11 00
	00		 add	 rax, 4520		; 000011a8H
  001ed	48 89 44 24 50	 mov	 QWORD PTR _EX_Head$2[rsp], rax
  001f2	48 8b 44 24 50	 mov	 rax, QWORD PTR _EX_Head$2[rsp]
  001f7	48 8b 40 08	 mov	 rax, QWORD PTR [rax+8]
  001fb	48 89 44 24 58	 mov	 QWORD PTR _EX_Tail$3[rsp], rax
  00200	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00208	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  0020d	48 89 88 c0 10
	00 00		 mov	 QWORD PTR [rax+4288], rcx
  00214	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0021c	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Tail$3[rsp]
  00221	48 89 88 c8 10
	00 00		 mov	 QWORD PTR [rax+4296], rcx
  00228	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00230	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  00236	48 8b 4c 24 58	 mov	 rcx, QWORD PTR _EX_Tail$3[rsp]
  0023b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0023e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00246	48 05 c0 10 00
	00		 add	 rax, 4288		; 000010c0H
  0024c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR _EX_Head$2[rsp]
  00251	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
$LN15@create_aut:
$LN14@create_aut:
$LN8@create_aut:

; 2088 :             }
; 2089 :         }
; 2090 :     }
; 2091 : 
; 2092 :     release_lock( &sysblk.stape_lock );

  00255	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0025c	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00262	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169992
  00269	48 8b c8	 mov	 rcx, rax
  0026c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 2093 : }

  00272	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00276	c3		 ret	 0
create_automount_thread ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
in_22blkid$ = 8
out_32blkid$ = 16
blockid_22_to_32 PROC

; 1677 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1678 :     out_32blkid[0] = (in_22blkid[0] >> 2) & 0x3F;

  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR in_22blkid$[rsp]
  00018	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001c	c1 f8 02	 sar	 eax, 2
  0001f	83 e0 3f	 and	 eax, 63			; 0000003fH
  00022	b9 01 00 00 00	 mov	 ecx, 1
  00027	48 6b c9 00	 imul	 rcx, rcx, 0
  0002b	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_32blkid$[rsp]
  00030	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1679 :     out_32blkid[1] = ((in_22blkid[0] << 6) & 0xC0) | (in_22blkid[1] & 0x3F);

  00033	b8 01 00 00 00	 mov	 eax, 1
  00038	48 6b c0 00	 imul	 rax, rax, 0
  0003c	48 8b 4c 24 08	 mov	 rcx, QWORD PTR in_22blkid$[rsp]
  00041	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00045	c1 e0 06	 shl	 eax, 6
  00048	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  0004d	b9 01 00 00 00	 mov	 ecx, 1
  00052	48 6b c9 01	 imul	 rcx, rcx, 1
  00056	48 8b 54 24 08	 mov	 rdx, QWORD PTR in_22blkid$[rsp]
  0005b	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  0005f	83 e1 3f	 and	 ecx, 63			; 0000003fH
  00062	0b c1		 or	 eax, ecx
  00064	b9 01 00 00 00	 mov	 ecx, 1
  00069	48 6b c9 01	 imul	 rcx, rcx, 1
  0006d	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_32blkid$[rsp]
  00072	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1680 :     out_32blkid[2] = in_22blkid[2];

  00075	b8 01 00 00 00	 mov	 eax, 1
  0007a	48 6b c0 02	 imul	 rax, rax, 2
  0007e	b9 01 00 00 00	 mov	 ecx, 1
  00083	48 6b c9 02	 imul	 rcx, rcx, 2
  00087	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_32blkid$[rsp]
  0008c	4c 8b 44 24 08	 mov	 r8, QWORD PTR in_22blkid$[rsp]
  00091	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00096	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1681 :     out_32blkid[3] = in_22blkid[3];

  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 03	 imul	 rax, rax, 3
  000a2	b9 01 00 00 00	 mov	 ecx, 1
  000a7	48 6b c9 03	 imul	 rcx, rcx, 3
  000ab	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_32blkid$[rsp]
  000b0	4c 8b 44 24 08	 mov	 r8, QWORD PTR in_22blkid$[rsp]
  000b5	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000ba	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1682 : }

  000bd	c3		 ret	 0
blockid_22_to_32 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
in_32blkid$ = 8
out_22blkid$ = 16
blockid_32_to_22 PROC

; 1663 : {

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1664 :     out_22blkid[0] = ((in_32blkid[0] << 2) & 0xFC) | ((in_32blkid[1] >> 6) & 0x03);

  0000a	b8 01 00 00 00	 mov	 eax, 1
  0000f	48 6b c0 00	 imul	 rax, rax, 0
  00013	48 8b 4c 24 08	 mov	 rcx, QWORD PTR in_32blkid$[rsp]
  00018	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  0001c	c1 e0 02	 shl	 eax, 2
  0001f	25 fc 00 00 00	 and	 eax, 252		; 000000fcH
  00024	b9 01 00 00 00	 mov	 ecx, 1
  00029	48 6b c9 01	 imul	 rcx, rcx, 1
  0002d	48 8b 54 24 08	 mov	 rdx, QWORD PTR in_32blkid$[rsp]
  00032	0f b6 0c 0a	 movzx	 ecx, BYTE PTR [rdx+rcx]
  00036	c1 f9 06	 sar	 ecx, 6
  00039	83 e1 03	 and	 ecx, 3
  0003c	0b c1		 or	 eax, ecx
  0003e	b9 01 00 00 00	 mov	 ecx, 1
  00043	48 6b c9 00	 imul	 rcx, rcx, 0
  00047	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_22blkid$[rsp]
  0004c	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1665 :     out_22blkid[1] = in_32blkid[1] & 0x3F;

  0004f	b8 01 00 00 00	 mov	 eax, 1
  00054	48 6b c0 01	 imul	 rax, rax, 1
  00058	48 8b 4c 24 08	 mov	 rcx, QWORD PTR in_32blkid$[rsp]
  0005d	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00061	83 e0 3f	 and	 eax, 63			; 0000003fH
  00064	b9 01 00 00 00	 mov	 ecx, 1
  00069	48 6b c9 01	 imul	 rcx, rcx, 1
  0006d	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_22blkid$[rsp]
  00072	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1666 :     out_22blkid[2] = in_32blkid[2];

  00075	b8 01 00 00 00	 mov	 eax, 1
  0007a	48 6b c0 02	 imul	 rax, rax, 2
  0007e	b9 01 00 00 00	 mov	 ecx, 1
  00083	48 6b c9 02	 imul	 rcx, rcx, 2
  00087	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_22blkid$[rsp]
  0008c	4c 8b 44 24 08	 mov	 r8, QWORD PTR in_32blkid$[rsp]
  00091	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  00096	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1667 :     out_22blkid[3] = in_32blkid[3];

  00099	b8 01 00 00 00	 mov	 eax, 1
  0009e	48 6b c0 03	 imul	 rax, rax, 3
  000a2	b9 01 00 00 00	 mov	 ecx, 1
  000a7	48 6b c9 03	 imul	 rcx, rcx, 3
  000ab	48 8b 54 24 10	 mov	 rdx, QWORD PTR out_22blkid$[rsp]
  000b0	4c 8b 44 24 08	 mov	 r8, QWORD PTR in_32blkid$[rsp]
  000b5	41 0f b6 04 00	 movzx	 eax, BYTE PTR [r8+rax]
  000ba	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al

; 1668 : }

  000bd	c3		 ret	 0
blockid_32_to_22 ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
dev$ = 48
act_blkid$ = 56
emu_blkid$ = 64
blockid_actual_to_emulated PROC

; 1616 : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1617 :     if ( TAPEDEVT_SCSITAPE != dev->tapedevt )

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00018	0f b6 80 dc 10
	00 00		 movzx	 eax, BYTE PTR [rax+4316]
  0001f	83 f8 03	 cmp	 eax, 3
  00022	74 10		 je	 SHORT $LN2@blockid_ac

; 1618 :     {
; 1619 :         memcpy( emu_blkid, act_blkid, 4 );

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR emu_blkid$[rsp]
  00029	48 8b 4c 24 38	 mov	 rcx, QWORD PTR act_blkid$[rsp]
  0002e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00030	89 08		 mov	 DWORD PTR [rax], ecx

; 1620 :         return;

  00032	eb 74		 jmp	 SHORT $LN1@blockid_ac
$LN2@blockid_ac:

; 1621 :     }
; 1622 : 
; 1623 : #if defined(OPTION_SCSI_TAPE)
; 1624 :     if (dev->stape_blkid_32)

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00039	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  0003f	d1 e8		 shr	 eax, 1
  00041	83 e0 01	 and	 eax, 1
  00044	85 c0		 test	 eax, eax
  00046	74 31		 je	 SHORT $LN3@blockid_ac

; 1625 :     {
; 1626 :         // SCSI using full 32-bit block-ids...
; 1627 :         if (0x3590 == dev->devtype)

  00048	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0004d	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00051	3d 90 35 00 00	 cmp	 eax, 13712		; 00003590H
  00056	75 10		 jne	 SHORT $LN5@blockid_ac

; 1628 :         {
; 1629 :             // Emulated device is a 3590 too. Just copy as-is...
; 1630 :             memcpy( emu_blkid, act_blkid, 4 );

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR emu_blkid$[rsp]
  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR act_blkid$[rsp]
  00062	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00064	89 08		 mov	 DWORD PTR [rax], ecx

; 1631 :         }

  00066	eb 0f		 jmp	 SHORT $LN6@blockid_ac
$LN5@blockid_ac:

; 1632 :         else
; 1633 :         {
; 1634 :             // Emulated device using 22-bit format. Convert...
; 1635 :             blockid_32_to_22 ( act_blkid, emu_blkid );

  00068	48 8b 54 24 40	 mov	 rdx, QWORD PTR emu_blkid$[rsp]
  0006d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR act_blkid$[rsp]
  00072	e8 00 00 00 00	 call	 blockid_32_to_22
$LN6@blockid_ac:

; 1636 :         }
; 1637 :     }

  00077	eb 2f		 jmp	 SHORT $LN4@blockid_ac
$LN3@blockid_ac:

; 1638 :     else
; 1639 :     {
; 1640 :         // SCSI using 22-bit format block-ids...
; 1641 :         if (0x3590 == dev->devtype)

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0007e	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  00082	3d 90 35 00 00	 cmp	 eax, 13712		; 00003590H
  00087	75 11		 jne	 SHORT $LN7@blockid_ac

; 1642 :         {
; 1643 :             // Emulated device using full 32-bit format. Convert...
; 1644 :             blockid_22_to_32 ( act_blkid, emu_blkid );

  00089	48 8b 54 24 40	 mov	 rdx, QWORD PTR emu_blkid$[rsp]
  0008e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR act_blkid$[rsp]
  00093	e8 00 00 00 00	 call	 blockid_22_to_32

; 1645 :         }

  00098	eb 0e		 jmp	 SHORT $LN8@blockid_ac
$LN7@blockid_ac:

; 1646 :         else
; 1647 :         {
; 1648 :             // Emulated device using 22-bit format too. Just copy as-is...
; 1649 :             memcpy( emu_blkid, act_blkid, 4 );

  0009a	48 8b 44 24 40	 mov	 rax, QWORD PTR emu_blkid$[rsp]
  0009f	48 8b 4c 24 38	 mov	 rcx, QWORD PTR act_blkid$[rsp]
  000a4	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000a6	89 08		 mov	 DWORD PTR [rax], ecx
$LN8@blockid_ac:
$LN4@blockid_ac:
$LN1@blockid_ac:

; 1650 :         }
; 1651 :     }
; 1652 : #endif /* defined(OPTION_SCSI_TAPE) */
; 1653 : 
; 1654 : } /* end function blockid_actual_to_emulated */

  000a8	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000ac	c3		 ret	 0
blockid_actual_to_emulated ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
dev$ = 48
emu_blkid$ = 56
act_blkid$ = 64
blockid_emulated_to_actual PROC

; 1553 : {

$LN10:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1554 :     if ( TAPEDEVT_SCSITAPE != dev->tapedevt )

  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00018	0f b6 80 dc 10
	00 00		 movzx	 eax, BYTE PTR [rax+4316]
  0001f	83 f8 03	 cmp	 eax, 3
  00022	74 10		 je	 SHORT $LN2@blockid_em

; 1555 :     {
; 1556 :         memcpy( act_blkid, emu_blkid, 4 );

  00024	48 8b 44 24 40	 mov	 rax, QWORD PTR act_blkid$[rsp]
  00029	48 8b 4c 24 38	 mov	 rcx, QWORD PTR emu_blkid$[rsp]
  0002e	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00030	89 08		 mov	 DWORD PTR [rax], ecx

; 1557 :         return;

  00032	eb 78		 jmp	 SHORT $LN1@blockid_em
$LN2@blockid_em:

; 1558 :     }
; 1559 : 
; 1560 : #if defined(OPTION_SCSI_TAPE)
; 1561 :     if (0x3590 == dev->devtype)

  00034	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00039	0f b7 40 4a	 movzx	 eax, WORD PTR [rax+74]
  0003d	3d 90 35 00 00	 cmp	 eax, 13712		; 00003590H
  00042	75 35		 jne	 SHORT $LN3@blockid_em

; 1562 :     {
; 1563 :         // 3590 being emulated; guest block-id is full 32-bits...
; 1564 : 
; 1565 :         if (dev->stape_blkid_32)

  00044	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00049	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  0004f	d1 e8		 shr	 eax, 1
  00051	83 e0 01	 and	 eax, 1
  00054	85 c0		 test	 eax, eax
  00056	74 10		 je	 SHORT $LN5@blockid_em

; 1566 :         {
; 1567 :             // SCSI using full 32-bit block-ids too. Just copy as-is...
; 1568 : 
; 1569 :             memcpy( act_blkid, emu_blkid, 4 );

  00058	48 8b 44 24 40	 mov	 rax, QWORD PTR act_blkid$[rsp]
  0005d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR emu_blkid$[rsp]
  00062	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00064	89 08		 mov	 DWORD PTR [rax], ecx

; 1570 :         }

  00066	eb 0f		 jmp	 SHORT $LN6@blockid_em
$LN5@blockid_em:

; 1571 :         else
; 1572 :         {
; 1573 :             // SCSI using 22-bit block-ids. Use low-order 30 bits
; 1574 :             // of 32-bit guest-supplied blockid and convert it
; 1575 :             // into a "22-bit format" blockid value for SCSI...
; 1576 : 
; 1577 :             blockid_32_to_22 ( emu_blkid, act_blkid );

  00068	48 8b 54 24 40	 mov	 rdx, QWORD PTR act_blkid$[rsp]
  0006d	48 8b 4c 24 38	 mov	 rcx, QWORD PTR emu_blkid$[rsp]
  00072	e8 00 00 00 00	 call	 blockid_32_to_22
$LN6@blockid_em:

; 1578 :         }
; 1579 :     }

  00077	eb 33		 jmp	 SHORT $LN4@blockid_em
$LN3@blockid_em:

; 1580 :     else // non-3590 being emulated; guest block-id is 22-bits...
; 1581 :     {
; 1582 :         if (dev->stape_blkid_32)

  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0007e	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  00084	d1 e8		 shr	 eax, 1
  00086	83 e0 01	 and	 eax, 1
  00089	85 c0		 test	 eax, eax
  0008b	74 11		 je	 SHORT $LN7@blockid_em

; 1583 :         {
; 1584 :             // SCSI using full 32-bit block-ids. Extract the wrap,
; 1585 :             // segment# and 22-bit blockid bits from the "22-bit
; 1586 :             // format" guest-supplied blockid value and combine
; 1587 :             // (append) them into a contiguous low-order 30 bits
; 1588 :             // of a 32-bit blockid value for SCSI to use...
; 1589 : 
; 1590 :             blockid_22_to_32 ( emu_blkid, act_blkid );

  0008d	48 8b 54 24 40	 mov	 rdx, QWORD PTR act_blkid$[rsp]
  00092	48 8b 4c 24 38	 mov	 rcx, QWORD PTR emu_blkid$[rsp]
  00097	e8 00 00 00 00	 call	 blockid_22_to_32

; 1591 :         }

  0009c	eb 0e		 jmp	 SHORT $LN8@blockid_em
$LN7@blockid_em:

; 1592 :         else
; 1593 :         {
; 1594 :             // SCSI using 22-bit block-ids too. Just copy as-is...
; 1595 : 
; 1596 :             memcpy( act_blkid, emu_blkid, 4 );

  0009e	48 8b 44 24 40	 mov	 rax, QWORD PTR act_blkid$[rsp]
  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR emu_blkid$[rsp]
  000a8	8b 09		 mov	 ecx, DWORD PTR [rcx]
  000aa	89 08		 mov	 DWORD PTR [rax], ecx
$LN8@blockid_em:
$LN4@blockid_em:
$LN1@blockid_em:

; 1597 :         }
; 1598 :     }
; 1599 : #endif /* defined(OPTION_SCSI_TAPE) */
; 1600 : 
; 1601 : } /* end function blockid_emulated_to_actual */

  000ac	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000b0	c3		 ret	 0
blockid_emulated_to_actual ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 32
opblk$ = 40
dev$ = 64
int_write_scsimark PROC

; 603  : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 604  : int  rc;
; 605  : struct mtop opblk;
; 606  : 
; 607  :     opblk.mt_op    = MTWEOF;

  00009	b8 05 00 00 00	 mov	 eax, 5
  0000e	66 89 44 24 28	 mov	 WORD PTR opblk$[rsp], ax

; 608  :     opblk.mt_count = 1;

  00013	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR opblk$[rsp+4], 1

; 609  : 
; 610  :     rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  0001b	4c 8d 44 24 28	 lea	 r8, QWORD PTR opblk$[rsp]
  00020	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00025	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  0002a	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00036	89 44 24 20	 mov	 DWORD PTR rc$[rsp], eax

; 611  : 
; 612  :     if (rc >= 0)

  0003a	83 7c 24 20 00	 cmp	 DWORD PTR rc$[rsp], 0
  0003f	7c 18		 jl	 SHORT $LN2@int_write_

; 613  :     {
; 614  :         /* Increment current file number since tapemark was written */
; 615  :         /*dev->curfilen++;*/ /* (CCW processor handles this automatically
; 616  :                              so there's no need for us to do it here) */
; 617  : 
; 618  :         /* (tapemarks count as block identifiers too!) */
; 619  :         dev->blockid++;

  00041	48 8b 44 24 40	 mov	 rax, QWORD PTR dev$[rsp]
  00046	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  0004c	ff c0		 inc	 eax
  0004e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dev$[rsp]
  00053	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax
$LN2@int_write_:

; 620  :     }
; 621  : 
; 622  :     return rc;

  00059	8b 44 24 20	 mov	 eax, DWORD PTR rc$[rsp]

; 623  : }

  0005d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00061	c3		 ret	 0
int_write_scsimark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
dev$ = 48
update_status$ = 56
int_scsi_status_mounted PROC

; 206  : {

$LN9:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 207  :     /* If device is not even opened yet, then no tape is mounted */
; 208  :     if (dev->fd < 0)

  0000d	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00012	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00019	7d 04		 jge	 SHORT $LN2@int_scsi_s

; 209  :         return FALSE;

  0001b	33 c0		 xor	 eax, eax
  0001d	eb 66		 jmp	 SHORT $LN1@int_scsi_s
$LN2@int_scsi_s:

; 210  : 
; 211  :     /* Make sure status is current if requested */
; 212  :     if (update_status)

  0001f	83 7c 24 38 00	 cmp	 DWORD PTR update_status$[rsp], 0
  00024	74 0c		 je	 SHORT $LN3@int_scsi_s

; 213  :         int_scsi_status_update( dev, 0 );

  00026	33 d2		 xor	 edx, edx
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  0002d	e8 00 00 00 00	 call	 int_scsi_status_update
$LN3@int_scsi_s:

; 214  : 
; 215  :     /* Which status flag should we check? */
; 216  :     if (dev->stape_online)

  00032	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  00037	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  0003d	c1 e8 03	 shr	 eax, 3
  00040	83 e0 01	 and	 eax, 1
  00043	85 c0		 test	 eax, eax
  00045	74 21		 je	 SHORT $LN4@int_scsi_s

; 217  :     {
; 218  :         /* If "online" flag is set then tape is mounted */
; 219  :         if (GMT_ONLINE( dev->sstat ))

  00047	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0004c	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00052	25 00 00 00 01	 and	 eax, 16777216		; 01000000H
  00057	85 c0		 test	 eax, eax
  00059	74 07		 je	 SHORT $LN6@int_scsi_s

; 220  :             return TRUE;

  0005b	b8 01 00 00 00	 mov	 eax, 1
  00060	eb 23		 jmp	 SHORT $LN1@int_scsi_s
$LN6@int_scsi_s:

; 221  : 
; 222  :         /* Otherwise tape is NOT mounted */
; 223  :         return FALSE;

  00062	33 c0		 xor	 eax, eax
  00064	eb 1f		 jmp	 SHORT $LN1@int_scsi_s

; 224  :     }

  00066	eb 1d		 jmp	 SHORT $LN5@int_scsi_s
$LN4@int_scsi_s:

; 225  :     else
; 226  :     {
; 227  :         /* If "door open" flag is set then tape is NOT mounted */
; 228  :         if (GMT_DR_OPEN( dev->sstat ))

  00068	48 8b 44 24 30	 mov	 rax, QWORD PTR dev$[rsp]
  0006d	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00073	25 00 00 04 00	 and	 eax, 262144		; 00040000H
  00078	85 c0		 test	 eax, eax
  0007a	74 04		 je	 SHORT $LN7@int_scsi_s

; 229  :             return FALSE;

  0007c	33 c0		 xor	 eax, eax
  0007e	eb 05		 jmp	 SHORT $LN1@int_scsi_s
$LN7@int_scsi_s:

; 230  : 
; 231  :         /* Otherwise tape IS mounted */
; 232  :         return TRUE;

  00080	b8 01 00 00 00	 mov	 eax, 1
$LN5@int_scsi_s:
$LN1@int_scsi_s:

; 233  :     }
; 234  : } /* end function int_scsi_status_mounted */

  00085	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00089	c3		 ret	 0
int_scsi_status_mounted ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
tv66 = 112
tv75 = 116
tv88 = 120
tv94 = 124
tv150 = 128
rc$1 = 132
tv176 = 136
tv180 = 140
tv165 = 144
tv173 = 152
sstat_str$2 = 160
__$ArrayPad$ = 544
dev$ = 576
mountstat_only$ = 584
int_scsi_status_update PROC

; 1959 : {

$LN27:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	57		 push	 rdi
  0000a	48 81 ec 30 02
	00 00		 sub	 rsp, 560		; 00000230H
  00011	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00018	48 33 c4	 xor	 rax, rsp
  0001b	48 89 84 24 20
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 1960 :     create_automount_thread( dev );     // (only if needed of course)

  00023	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0002b	e8 00 00 00 00	 call	 create_automount_thread

; 1961 : 
; 1962 :     // PROGRAMMING NOTE: only normal i/o requests (as well as the
; 1963 :     // scsi_tapemountmon_thread thread whenever AUTO_SCSI_MOUNT is
; 1964 :     // enabled and active) ever actually call us with mountstat_only
; 1965 :     // set to zero (in order to update our actual status value).
; 1966 :     //
; 1967 :     // Thus if we're called with a non-zero mountstat_only argument
; 1968 :     // (meaning all the caller is interested in is whether or not
; 1969 :     // there's a tape mounted on the drive (which only the panel
; 1970 :     // and GUI threads normally do (and which they do continuously
; 1971 :     // whenever they do do it!))) then we simply return immediately
; 1972 :     // so as to cause the caller to continue using whatever status
; 1973 :     // happens to already be set for the drive (which should always
; 1974 :     // be accurate).
; 1975 :     //
; 1976 :     // This prevents us from continuously "banging on the drive"
; 1977 :     // asking for the status when in reality the status we already
; 1978 :     // have should already be accurate (since it is updated after
; 1979 :     // every i/o or automatically by the auto-mount thread)
; 1980 : 
; 1981 :     if (likely(mountstat_only))           // (if only want mount status)

  00030	83 bc 24 48 02
	00 00 00	 cmp	 DWORD PTR mountstat_only$[rsp], 0
  00038	74 0a		 je	 SHORT $LN11@int_scsi_s
  0003a	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv66[rsp], 1
  00042	eb 08		 jmp	 SHORT $LN12@int_scsi_s
$LN11@int_scsi_s:
  00044	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv66[rsp], 0
$LN12@int_scsi_s:
  0004c	83 7c 24 70 00	 cmp	 DWORD PTR tv66[rsp], 0
  00051	74 05		 je	 SHORT $LN4@int_scsi_s

; 1982 :         return;                           // (then current should be ok)

  00053	e9 1b 03 00 00	 jmp	 $LN1@int_scsi_s
$LN4@int_scsi_s:

; 1983 : 
; 1984 :     // Update status...
; 1985 : 
; 1986 :     if (likely(STS_MOUNTED( dev )))

  00058	33 d2		 xor	 edx, edx
  0005a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00062	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00067	85 c0		 test	 eax, eax
  00069	74 0a		 je	 SHORT $LN13@int_scsi_s
  0006b	c7 44 24 74 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00073	eb 08		 jmp	 SHORT $LN14@int_scsi_s
$LN13@int_scsi_s:
  00075	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN14@int_scsi_s:
  0007d	83 7c 24 74 00	 cmp	 DWORD PTR tv75[rsp], 0
  00082	0f 84 f0 00 00
	00		 je	 $LN5@int_scsi_s
$LN2@int_scsi_s:

; 1987 :     {
; 1988 :         // According to our current status value there is a tape mounted,
; 1989 :         // so we should wait for a full/complete/accurate status update,
; 1990 :         // regardless of however long that may take...
; 1991 : 
; 1992 :         int rc;
; 1993 :         while (ETIMEDOUT == (rc = int_scsi_status_wait( dev,

  00088	ba 60 e3 16 00	 mov	 edx, 1500000		; 0016e360H
  0008d	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00095	e8 00 00 00 00	 call	 int_scsi_status_wait
  0009a	89 84 24 84 00
	00 00		 mov	 DWORD PTR rc$1[rsp], eax
  000a1	81 bc 24 84 00
	00 00 8a 00 00
	00		 cmp	 DWORD PTR rc$1[rsp], 138 ; 0000008aH
  000ac	0f 85 c4 00 00
	00		 jne	 $LN3@int_scsi_s

; 1994 :             MAX_GSTAT_FREQ_USECS + (2 * SLOW_UPDATE_STATUS_TIMEOUT) )))
; 1995 :         {
; 1996 :             if (dev->ccwtrace)

  000b2	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ba	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c0	c1 e8 0f	 shr	 eax, 15
  000c3	83 e0 01	 and	 eax, 1
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 a3 00 00
	00		 je	 $LN7@int_scsi_s

; 1997 :             {
; 1998 :                 // "%1d:%04X Tape status retrieval timeout"
; 1999 :                 WRMSG( HHC00243, "W", LCSS_DEVNUM );

  000ce	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d7	74 12		 je	 SHORT $LN15@int_scsi_s
  000d9	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e1	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000e5	89 44 24 78	 mov	 DWORD PTR tv88[rsp], eax
  000e9	eb 08		 jmp	 SHORT $LN16@int_scsi_s
$LN15@int_scsi_s:
  000eb	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv88[rsp], 0
$LN16@int_scsi_s:
  000f3	48 83 bc 24 40
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000fc	74 14		 je	 SHORT $LN17@int_scsi_s
  000fe	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00106	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0010a	d1 f8		 sar	 eax, 1
  0010c	89 44 24 7c	 mov	 DWORD PTR tv94[rsp], eax
  00110	eb 08		 jmp	 SHORT $LN18@int_scsi_s
$LN17@int_scsi_s:
  00112	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN18@int_scsi_s:
  0011a	b9 01 00 00 00	 mov	 ecx, 1
  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00125	8b 4c 24 78	 mov	 ecx, DWORD PTR tv88[rsp]
  00129	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0012d	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv94[rsp]
  00131	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169945
  0013c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169946
  00148	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00152	41 b9 03 00 00
	00		 mov	 r9d, 3
  00158	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169947
  0015f	ba cf 07 00 00	 mov	 edx, 1999		; 000007cfH
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169948
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN7@int_scsi_s:

; 2000 :             }
; 2001 :         }

  00171	e9 12 ff ff ff	 jmp	 $LN2@int_scsi_s
$LN3@int_scsi_s:

; 2002 :     }

  00176	eb 12		 jmp	 SHORT $LN6@int_scsi_s
$LN5@int_scsi_s:

; 2003 :     else
; 2004 :     {
; 2005 :         // No tape is mounted (or so we believe). Attempt to retrieve
; 2006 :         // an updated tape status value, but if we cannot do so within
; 2007 :         // a reasonable period of time (SLOW_UPDATE_STATUS_TIMEOUT),
; 2008 :         // then continue using whatever our current tape status is...
; 2009 : 
; 2010 :         int_scsi_status_wait( dev, SLOW_UPDATE_STATUS_TIMEOUT );

  00178	ba 90 d0 03 00	 mov	 edx, 250000		; 0003d090H
  0017d	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00185	e8 00 00 00 00	 call	 int_scsi_status_wait
$LN6@int_scsi_s:

; 2011 :     }
; 2012 : 
; 2013 :     create_automount_thread( dev );     // (in case status changed)

  0018a	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00192	e8 00 00 00 00	 call	 create_automount_thread

; 2014 : 
; 2015 :     /* Display tape status if tracing is active */
; 2016 :     if (unlikely( dev->ccwtrace ))

  00197	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019f	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  001a5	c1 e8 0f	 shr	 eax, 15
  001a8	83 e0 01	 and	 eax, 1
  001ab	85 c0		 test	 eax, eax
  001ad	74 0d		 je	 SHORT $LN21@int_scsi_s
  001af	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv150[rsp], 1
  001ba	eb 0b		 jmp	 SHORT $LN22@int_scsi_s
$LN21@int_scsi_s:
  001bc	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv150[rsp], 0
$LN22@int_scsi_s:
  001c7	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv150[rsp], 0
  001cf	0f 84 9e 01 00
	00		 je	 $LN8@int_scsi_s

; 2017 :     {
; 2018 :         char sstat_str[ 384 ] = {0};

  001d5	48 8d 84 24 a0
	00 00 00	 lea	 rax, QWORD PTR sstat_str$2[rsp]
  001dd	48 8b f8	 mov	 rdi, rax
  001e0	33 c0		 xor	 eax, eax
  001e2	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  001e7	f3 aa		 rep stosb

; 2019 :         gstat2str( (U32) dev->sstat, sstat_str, sizeof( sstat_str ));

  001e9	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  001ef	48 8d 94 24 a0
	00 00 00	 lea	 rdx, QWORD PTR sstat_str$2[rsp]
  001f7	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001ff	8b 88 88 10 00
	00		 mov	 ecx, DWORD PTR [rax+4232]
  00205	e8 00 00 00 00	 call	 gstat2str

; 2020 : 
; 2021 :         // "%1d:%04X Tape file %s, type scsi status %s, sstat 0x%8.8"PRIX32": %s"
; 2022 :         WRMSG( HHC00211, "I"

  0020a	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00212	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00219	7d 11		 jge	 SHORT $LN23@int_scsi_s
  0021b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169950
  00222	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
  0022a	eb 0f		 jmp	 SHORT $LN24@int_scsi_s
$LN23@int_scsi_s:
  0022c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169951
  00233	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv165[rsp], rax
$LN24@int_scsi_s:
  0023b	b8 01 00 00 00	 mov	 eax, 1
  00240	48 6b c0 00	 imul	 rax, rax, 0
  00244	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0024c	0f be 84 01 a4
	00 00 00	 movsx	 eax, BYTE PTR [rcx+rax+164]
  00254	85 c0		 test	 eax, eax
  00256	74 18		 je	 SHORT $LN25@int_scsi_s
  00258	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00260	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00266	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  0026e	eb 0f		 jmp	 SHORT $LN26@int_scsi_s
$LN25@int_scsi_s:
  00270	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:$SG169952
  00277	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
$LN26@int_scsi_s:
  0027f	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00287	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0028b	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv176[rsp], eax
  00292	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0029a	0f b7 49 44	 movzx	 ecx, WORD PTR [rcx+68]
  0029e	d1 f9		 sar	 ecx, 1
  002a0	89 8c 24 8c 00
	00 00		 mov	 DWORD PTR tv180[rsp], ecx
  002a7	b9 01 00 00 00	 mov	 ecx, 1
  002ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  002b2	48 8d 8c 24 a0
	00 00 00	 lea	 rcx, QWORD PTR sstat_str$2[rsp]
  002ba	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002bf	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002c7	8b 89 88 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4232]
  002cd	89 4c 24 58	 mov	 DWORD PTR [rsp+88], ecx
  002d1	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv165[rsp]
  002d9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002de	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  002e6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002eb	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv176[rsp]
  002f2	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002f6	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR tv180[rsp]
  002fd	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00301	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169953
  00308	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0030d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169954
  00314	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00319	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0031e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00324	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169955
  0032b	ba ed 07 00 00	 mov	 edx, 2029		; 000007edH
  00330	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169956
  00337	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 2023 :             , SSID_TO_LCSS(dev->ssid)
; 2024 :             , dev->devnum
; 2025 :             , ( (dev->filename[0]) ? (dev->filename)  : ("(undefined)") )
; 2026 :             , ( (dev->fd   <   0 ) ? (   "closed"  )  : (   "opened"  ) )
; 2027 :             , (U32) dev->sstat
; 2028 :             , sstat_str
; 2029 :         );
; 2030 : 
; 2031 :         if ( STS_BOT(dev) )

  0033d	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00345	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  0034b	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00350	85 c0		 test	 eax, eax
  00352	74 1f		 je	 SHORT $LN9@int_scsi_s

; 2032 :             dev->eotwarning = 0;

  00354	48 8b 84 24 40
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0035c	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00362	83 e0 df	 and	 eax, -33		; ffffffdfH
  00365	48 8b 8c 24 40
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0036d	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN9@int_scsi_s:
$LN8@int_scsi_s:
$LN1@int_scsi_s:

; 2033 :     }
; 2034 : 
; 2035 : } /* end function int_scsi_status_update */

  00373	48 8b 8c 24 20
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037b	48 33 cc	 xor	 rcx, rsp
  0037e	e8 00 00 00 00	 call	 __security_check_cookie
  00383	48 81 c4 30 02
	00 00		 add	 rsp, 560		; 00000230H
  0038a	5f		 pop	 rdi
  0038b	c3		 ret	 0
int_scsi_status_update ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
tv83 = 112
tv89 = 116
tv161 = 120
tv167 = 124
rc$ = 128
opblk$ = 136
tv78 = 144
tv150 = 152
tv156 = 160
dev$ = 192
unitstat$ = 200
code$ = 208
int_scsi_rewind_unload PROC

; 1197 : {

$LN16:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 1198 : int rc;
; 1199 : struct mtop opblk;
; 1200 : 
; 1201 : //  opblk.mt_op    = MTUNLOAD;  // (not sure which is more correct)
; 1202 :     opblk.mt_op    = MTOFFL;

  00016	b8 07 00 00 00	 mov	 eax, 7
  0001b	66 89 84 24 88
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 1203 :     opblk.mt_count = 1;

  00023	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 1204 : 
; 1205 :     rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  0002e	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  00036	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  0003b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0004f	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 1206 : 
; 1207 :     if ( rc >= 0 )

  00056	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005e	0f 8c 3e 01 00
	00		 jl	 $LN2@int_scsi_r

; 1208 :     {
; 1209 :         dev->fenced = 0;

  00064	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006c	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00072	83 e0 fe	 and	 eax, -2			; fffffffeH
  00075	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0007d	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 1210 : 
; 1211 :         if (dev->ccwtrace)

  00083	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00091	c1 e8 0f	 shr	 eax, 15
  00094	83 e0 01	 and	 eax, 1
  00097	85 c0		 test	 eax, eax
  00099	0f 84 d2 00 00
	00		 je	 $LN3@int_scsi_r

; 1212 :             // "%1d:%04X Tape file %s, type %s: tape unloaded"
; 1213 :             WRMSG (HHC00210, "I", LCSS_DEVNUM, dev->filename, "scsi");

  0009f	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000a8	74 12		 je	 SHORT $LN8@int_scsi_r
  000aa	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000b6	89 44 24 70	 mov	 DWORD PTR tv83[rsp], eax
  000ba	eb 08		 jmp	 SHORT $LN9@int_scsi_r
$LN8@int_scsi_r:
  000bc	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv83[rsp], 0
$LN9@int_scsi_r:
  000c4	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000cd	74 14		 je	 SHORT $LN10@int_scsi_r
  000cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000db	d1 f8		 sar	 eax, 1
  000dd	89 44 24 74	 mov	 DWORD PTR tv89[rsp], eax
  000e1	eb 08		 jmp	 SHORT $LN11@int_scsi_r
$LN10@int_scsi_r:
  000e3	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv89[rsp], 0
$LN11@int_scsi_r:
  000eb	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f3	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  000f9	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv78[rsp], rax
  00101	b9 01 00 00 00	 mov	 ecx, 1
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169644
  00113	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00118	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv78[rsp]
  00120	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00125	8b 4c 24 70	 mov	 ecx, DWORD PTR tv83[rsp]
  00129	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0012d	8b 4c 24 74	 mov	 ecx, DWORD PTR tv89[rsp]
  00131	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169645
  0013c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00141	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169646
  00148	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0014d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00152	41 b9 03 00 00
	00		 mov	 r9d, 3
  00158	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169647
  0015f	ba bd 04 00 00	 mov	 edx, 1213		; 000004bdH
  00164	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169648
  0016b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@int_scsi_r:

; 1214 : 
; 1215 :         // PR# tape/88: no sense with 'close_scsitape'
; 1216 :         // attempting a rewind if the tape is unloaded!
; 1217 : 
; 1218 :         dev->stape_close_rewinds = 0;   // (skip rewind attempt)

  00171	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00179	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  0017f	83 e0 fe	 and	 eax, -2			; fffffffeH
  00182	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018a	89 81 98 10 00
	00		 mov	 DWORD PTR [rcx+4248], eax

; 1219 : 
; 1220 :         close_scsitape( dev ); // (required for REW UNLD)

  00190	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00198	e8 00 00 00 00	 call	 close_scsitape

; 1221 :         return;

  0019d	e9 cc 01 00 00	 jmp	 $LN1@int_scsi_r
$LN2@int_scsi_r:

; 1222 :     }
; 1223 : 
; 1224 :     if (!SVF_ENABLED())

  001a2	b8 01 00 00 00	 mov	 eax, 1
  001a7	48 6b c0 00	 imul	 rax, rax, 0
  001ab	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b3	48 8d 84 01 72
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1394]
  001bb	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  001c0	48 8b c8	 mov	 rcx, rax
  001c3	e8 00 00 00 00	 call	 is_tape_feat
  001c8	0f b6 c0	 movzx	 eax, al
  001cb	85 c0		 test	 eax, eax
  001cd	75 1f		 jne	 SHORT $LN4@int_scsi_r

; 1225 :         dev->fenced = 1;// (because the rewind-unload failed)

  001cf	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  001dd	83 c8 01	 or	 eax, 1
  001e0	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e8	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN4@int_scsi_r:

; 1226 :     dev->curfilen = -1; // (because the rewind-unload failed)

  001ee	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  001f3	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001fb	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 1227 :     dev->blockid  = -1; // (because the rewind-unload failed)

  00202	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0020a	c7 80 04 10 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+4100], -1 ; ffffffffH

; 1228 : 
; 1229 :     // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1230 :     WRMSG (HHC00205, "E", LCSS_DEVNUM,

  00214	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0021d	74 12		 je	 SHORT $LN12@int_scsi_r
  0021f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00227	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0022b	89 44 24 78	 mov	 DWORD PTR tv161[rsp], eax
  0022f	eb 08		 jmp	 SHORT $LN13@int_scsi_r
$LN12@int_scsi_r:
  00231	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN13@int_scsi_r:
  00239	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00242	74 14		 je	 SHORT $LN14@int_scsi_r
  00244	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0024c	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00250	d1 f8		 sar	 eax, 1
  00252	89 44 24 7c	 mov	 DWORD PTR tv167[rsp], eax
  00256	eb 08		 jmp	 SHORT $LN15@int_scsi_r
$LN14@int_scsi_r:
  00258	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv167[rsp], 0
$LN15@int_scsi_r:
  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00266	8b 08		 mov	 ecx, DWORD PTR [rax]
  00268	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0026e	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv150[rsp], rax
  00276	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0027e	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00285	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv156[rsp], rcx
  0028d	b9 01 00 00 00	 mov	 ecx, 1
  00292	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00298	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  002a0	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  002a5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169650
  002ac	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  002b1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169651
  002b8	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  002bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv156[rsp]
  002c5	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  002ca	8b 4c 24 78	 mov	 ecx, DWORD PTR tv161[rsp]
  002ce	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  002d2	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv167[rsp]
  002d6	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  002da	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169652
  002e1	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  002e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169653
  002ed	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002f2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002f7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002fd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169654
  00304	ba cf 04 00 00	 mov	 edx, 1231		; 000004cfH
  00309	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169655
  00310	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1231 :             dev->filename, "scsi", "ioctl_tape(MTOFFL)", strerror( errno ) );
; 1232 : 
; 1233 :     if ( STS_NOT_MOUNTED( dev ) )

  00316	33 d2		 xor	 edx, edx
  00318	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00320	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00325	85 c0		 test	 eax, eax
  00327	75 22		 jne	 SHORT $LN5@int_scsi_r

; 1234 :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  00329	44 0f b6 8c 24
	d0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00332	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0033a	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00342	33 c9		 xor	 ecx, ecx
  00344	e8 00 00 00 00	 call	 build_senseX
  00349	eb 23		 jmp	 SHORT $LN6@int_scsi_r
$LN5@int_scsi_r:

; 1235 :     else
; 1236 :         build_senseX(TAPE_BSENSE_REWINDFAILED,dev,unitstat,code);

  0034b	44 0f b6 8c 24
	d0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00354	4c 8b 84 24 c8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0035c	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00364	b9 13 00 00 00	 mov	 ecx, 19
  00369	e8 00 00 00 00	 call	 build_senseX
$LN6@int_scsi_r:
$LN1@int_scsi_r:

; 1237 : 
; 1238 : } /* end function int_scsi_rewind_unload */

  0036e	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  00375	c3		 ret	 0
int_scsi_rewind_unload ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 112
tv93 = 116
tv129 = 120
save_errno$1 = 124
mtop$ = 128
tv84 = 136
tv90 = 144
dev$ = 176
blockid$ = 184
unitstat$ = 192
code$ = 200
locateblk_scsitape PROC

; 1423 : {

$LN11:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H
$LN4@locateblk_:

; 1424 :     int rc;
; 1425 :     struct mtop  mtop;
; 1426 : 
; 1427 :     UNREFERENCED( unitstat );                   // (not used)

  0001a	33 c0		 xor	 eax, eax
  0001c	85 c0		 test	 eax, eax
  0001e	75 fa		 jne	 SHORT $LN4@locateblk_
$LN7@locateblk_:

; 1428 :     UNREFERENCED(   code   );                   // (not used)

  00020	33 c0		 xor	 eax, eax
  00022	85 c0		 test	 eax, eax
  00024	75 fa		 jne	 SHORT $LN7@locateblk_

; 1429 : 
; 1430 :     // Convert the passed host-format blockid value into the proper
; 1431 :     // 32-bit vs. 22-bit guest-format the physical device expects ...
; 1432 : 
; 1433 :     blockid = CSWAP32( blockid );               // (guest <- host)

  00026	8b 8c 24 b8 00
	00 00		 mov	 ecx, DWORD PTR blockid$[rsp]
  0002d	e8 00 00 00 00	 call	 _byteswap_ulong
  00032	89 84 24 b8 00
	00 00		 mov	 DWORD PTR blockid$[rsp], eax

; 1434 : 
; 1435 :     blockid_emulated_to_actual( dev, (BYTE*)&blockid, (BYTE*)&mtop.mt_count );

  00039	4c 8d 84 24 84
	00 00 00	 lea	 r8, QWORD PTR mtop$[rsp+4]
  00041	48 8d 94 24 b8
	00 00 00	 lea	 rdx, QWORD PTR blockid$[rsp]
  00049	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00051	e8 00 00 00 00	 call	 blockid_emulated_to_actual

; 1436 : 
; 1437 :     mtop.mt_count = CSWAP32( mtop.mt_count );   // (host <- guest)

  00056	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR mtop$[rsp+4]
  0005d	e8 00 00 00 00	 call	 _byteswap_ulong
  00062	89 84 24 84 00
	00 00		 mov	 DWORD PTR mtop$[rsp+4], eax

; 1438 :     mtop.mt_op    = MTSEEK;

  00069	b8 16 00 00 00	 mov	 eax, 22
  0006e	66 89 84 24 80
	00 00 00	 mov	 WORD PTR mtop$[rsp], ax

; 1439 : 
; 1440 :     // Ask the actual hardware to do an actual physical locate...
; 1441 : 
; 1442 :     if ((rc = ioctl_tape( dev->fd, MTIOCTOP, (char*)&mtop )) < 0)

  00076	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR mtop$[rsp]
  0007e	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00083	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0008b	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00097	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  0009b	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  000a0	0f 8d 0f 01 00
	00		 jge	 $LN8@locateblk_

; 1443 :     {
; 1444 :         int save_errno = errno;

  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ac	8b 00		 mov	 eax, DWORD PTR [rax]
  000ae	89 44 24 7c	 mov	 DWORD PTR save_errno$1[rsp], eax

; 1445 :         {
; 1446 :             // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1447 :             if (dev->ccwtrace)

  000b2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ba	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  000c0	c1 e8 0f	 shr	 eax, 15
  000c3	83 e0 01	 and	 eax, 1
  000c6	85 c0		 test	 eax, eax
  000c8	0f 84 db 00 00
	00		 je	 $LN9@locateblk_

; 1448 :                 WRMSG(HHC00205, "W"

  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d4	8b 08		 mov	 ecx, DWORD PTR [rax]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000dc	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv84[rsp], rax
  000e4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ec	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  000f3	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv90[rsp], rcx
  000fb	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00103	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  00107	89 54 24 74	 mov	 DWORD PTR tv93[rsp], edx
  0010b	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  00113	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  00118	41 d1 f8	 sar	 r8d, 1
  0011b	44 89 44 24 78	 mov	 DWORD PTR tv129[rsp], r8d
  00120	b9 01 00 00 00	 mov	 ecx, 1
  00125	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0012b	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv84[rsp]
  00133	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00138	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169752
  0013f	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00144	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169753
  0014b	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00150	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv90[rsp]
  00158	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0015d	8b 4c 24 74	 mov	 ecx, DWORD PTR tv93[rsp]
  00161	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00165	8b 4c 24 78	 mov	 ecx, DWORD PTR tv129[rsp]
  00169	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0016d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169754
  00174	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00179	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169755
  00180	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00185	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0018a	41 b9 03 00 00
	00		 mov	 r9d, 3
  00190	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169756
  00197	ba ae 05 00 00	 mov	 edx, 1454		; 000005aeH
  0019c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169757
  001a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@locateblk_:

; 1449 :                     ,SSID_TO_LCSS(dev->ssid)
; 1450 :                     ,dev->devnum
; 1451 :                     ,dev->filename
; 1452 :                     ,"scsi", "ioctl_tape(MTSEEK)"
; 1453 :                     ,strerror(errno)
; 1454 :                     );
; 1455 :         }
; 1456 :         errno = save_errno;

  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001af	8b 4c 24 7c	 mov	 ecx, DWORD PTR save_errno$1[rsp]
  001b3	89 08		 mov	 DWORD PTR [rax], ecx
$LN8@locateblk_:

; 1457 :     }
; 1458 : 
; 1459 :     return rc;

  001b5	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]

; 1460 : }

  001b9	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001c0	c3		 ret	 0
locateblk_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
mtpos$ = 112
blockid$ = 116
tv84 = 120
tv88 = 124
save_errno$1 = 128
tv75 = 136
tv81 = 144
dev$ = 176
logical$ = 184
physical$ = 192
readblkid_scsitape PROC

; 1353 : {

$LN7:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1354 :     // ZZ FIXME: The two blockid fields that READ BLOCK ID
; 1355 :     // are returning are the "Channel block ID" and "Device
; 1356 :     // block ID" fields, which correspond directly to the
; 1357 :     // SCSI "First block location" and "Last block location"
; 1358 :     // fields (as returned by a READ POSITION scsi command),
; 1359 :     // so we really SHOULD be doing our own direct scsi i/o
; 1360 :     // for ourselves so we can retrieve BOTH of those values
; 1361 :     // directly from the real/actual physical device itself,
; 1362 :     // but until we can add code to Herc to do that, we must
; 1363 :     // return the same value for each since ioctl(MTIOCPOS)
; 1364 :     // only returns us one value (the logical position) and
; 1365 :     // not both that we really prefer...
; 1366 : 
; 1367 :     // (And for the record, we want the "Channel block ID"
; 1368 :     // value, also known as the SCSI "First block location"
; 1369 :     // value, also known as the >>LOGICAL<< value and *NOT*
; 1370 :     // the absolute/physical device-relative value)
; 1371 : 
; 1372 :     struct  mtpos  mtpos;
; 1373 :     BYTE    blockid[4];
; 1374 : 
; 1375 :     if (ioctl_tape( dev->fd, MTIOCPOS, (char*) &mtpos ) < 0 )

  00016	4c 8d 44 24 70	 lea	 r8, QWORD PTR mtpos$[rsp]
  0001b	ba 03 6d 04 40	 mov	 edx, 1074031875		; 40046d03H
  00020	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00028	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00034	85 c0		 test	 eax, eax
  00036	0f 8d 1c 01 00
	00		 jge	 $LN2@readblkid_

; 1376 :     {
; 1377 :         /* Informative ERROR message if tracing */
; 1378 : 
; 1379 :         int save_errno = errno;

  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00042	8b 00		 mov	 eax, DWORD PTR [rax]
  00044	89 84 24 80 00
	00 00		 mov	 DWORD PTR save_errno$1[rsp], eax

; 1380 :         {
; 1381 :             // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1382 :             if (dev->ccwtrace)

  0004b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00053	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00059	c1 e8 0f	 shr	 eax, 15
  0005c	83 e0 01	 and	 eax, 1
  0005f	85 c0		 test	 eax, eax
  00061	0f 84 db 00 00
	00		 je	 $LN3@readblkid_

; 1383 :                 WRMSG(HHC90205, "D"

  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00075	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv75[rsp], rax
  0007d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00085	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0008c	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv81[rsp], rcx
  00094	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0009c	0f b7 52 48	 movzx	 edx, WORD PTR [rdx+72]
  000a0	89 54 24 78	 mov	 DWORD PTR tv84[rsp], edx
  000a4	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR dev$[rsp]
  000ac	45 0f b7 40 44	 movzx	 r8d, WORD PTR [r8+68]
  000b1	41 d1 f8	 sar	 r8d, 1
  000b4	44 89 44 24 7c	 mov	 DWORD PTR tv88[rsp], r8d
  000b9	b9 01 00 00 00	 mov	 ecx, 1
  000be	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000c4	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv75[rsp]
  000cc	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  000d1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169719
  000d8	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000dd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169720
  000e4	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000e9	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv81[rsp]
  000f1	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  000f6	8b 4c 24 78	 mov	 ecx, DWORD PTR tv84[rsp]
  000fa	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  000fe	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv88[rsp]
  00102	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00106	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169721
  0010d	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00112	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169722
  00119	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0011e	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00123	41 b9 03 00 00
	00		 mov	 r9d, 3
  00129	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169723
  00130	ba 6d 05 00 00	 mov	 edx, 1389		; 0000056dH
  00135	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169724
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN3@readblkid_:

; 1384 :                     ,SSID_TO_LCSS(dev->ssid)
; 1385 :                     ,dev->devnum
; 1386 :                     ,dev->filename
; 1387 :                     ,"scsi", "ioctl_tape(MTTELL)"
; 1388 :                     ,strerror(errno)
; 1389 :                     );
; 1390 :         }
; 1391 :         errno = save_errno;

  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00148	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR save_errno$1[rsp]
  0014f	89 08		 mov	 DWORD PTR [rax], ecx

; 1392 : 
; 1393 :         return  -1;     // (errno should already be set)

  00151	b8 ff ff ff ff	 mov	 eax, -1
  00156	eb 6a		 jmp	 SHORT $LN1@readblkid_
$LN2@readblkid_:

; 1394 :     }
; 1395 : 
; 1396 :     // Convert MTIOCPOS value to guest BIG-ENDIAN format...
; 1397 : 
; 1398 :     mtpos.mt_blkno = CSWAP32( mtpos.mt_blkno );     // (guest <- host)

  00158	8b 4c 24 70	 mov	 ecx, DWORD PTR mtpos$[rsp]
  0015c	e8 00 00 00 00	 call	 _byteswap_ulong
  00161	89 44 24 70	 mov	 DWORD PTR mtpos$[rsp], eax

; 1399 : 
; 1400 :     // Handle emulated vs. physical tape-device block-id format issue...
; 1401 : 
; 1402 :     blockid_actual_to_emulated( dev, (BYTE*)&mtpos.mt_blkno, blockid );

  00165	4c 8d 44 24 74	 lea	 r8, QWORD PTR blockid$[rsp]
  0016a	48 8d 54 24 70	 lea	 rdx, QWORD PTR mtpos$[rsp]
  0016f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00177	e8 00 00 00 00	 call	 blockid_actual_to_emulated

; 1403 : 
; 1404 :     // Until we can add code to Herc to do direct SCSI i/o (so that
; 1405 :     // we can retrieve BOTH values directly from the device itself),
; 1406 :     // we have no choice but to return the same value for each since
; 1407 :     // the ioctl(MTIOCPOS) call only returns the logical value and
; 1408 :     // not also the physical value that we wish it would...
; 1409 : 
; 1410 :     if (logical)  memcpy( logical,  &blockid[0], 4 );

  0017c	48 83 bc 24 b8
	00 00 00 00	 cmp	 QWORD PTR logical$[rsp], 0
  00185	74 17		 je	 SHORT $LN4@readblkid_
  00187	b8 01 00 00 00	 mov	 eax, 1
  0018c	48 6b c0 00	 imul	 rax, rax, 0
  00190	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR logical$[rsp]
  00198	8b 44 04 74	 mov	 eax, DWORD PTR blockid$[rsp+rax]
  0019c	89 01		 mov	 DWORD PTR [rcx], eax
$LN4@readblkid_:

; 1411 :     if (physical) memcpy( physical, &blockid[0], 4 );

  0019e	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR physical$[rsp], 0
  001a7	74 17		 je	 SHORT $LN5@readblkid_
  001a9	b8 01 00 00 00	 mov	 eax, 1
  001ae	48 6b c0 00	 imul	 rax, rax, 0
  001b2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR physical$[rsp]
  001ba	8b 44 04 74	 mov	 eax, DWORD PTR blockid$[rsp+rax]
  001be	89 01		 mov	 DWORD PTR [rcx], eax
$LN5@readblkid_:

; 1412 : 
; 1413 :     return 0;       // (success)

  001c0	33 c0		 xor	 eax, eax
$LN1@readblkid_:

; 1414 : 
; 1415 : } /* end function readblkid_scsitape */

  001c2	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  001c9	c3		 ret	 0
readblkid_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
dev$ = 8
passedeot_scsitape PROC

; 1902 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 1903 :     return dev->eotwarning;     // (1==past EOT reflector; 0==not)

  00005	48 8b 44 24 08	 mov	 rax, QWORD PTR dev$[rsp]
  0000a	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00010	c1 e8 05	 shr	 eax, 5
  00013	83 e0 01	 and	 eax, 1

; 1904 : }

  00016	c3		 ret	 0
passedeot_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
dev$ = 48
unitstat$ = 56
code$ = 64
is_tape_mounted_scsitape PROC

; 1911 : {

$LN9:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H
$LN4@is_tape_mo:

; 1912 :     UNREFERENCED(unitstat);

  00013	33 c0		 xor	 eax, eax
  00015	85 c0		 test	 eax, eax
  00017	75 fa		 jne	 SHORT $LN4@is_tape_mo
$LN7@is_tape_mo:

; 1913 :     UNREFERENCED(code);

  00019	33 c0		 xor	 eax, eax
  0001b	85 c0		 test	 eax, eax
  0001d	75 fa		 jne	 SHORT $LN7@is_tape_mo

; 1914 : 
; 1915 :     /* Update tape mounted status */
; 1916 :     int_scsi_status_update( dev, 1 ); // (safe/fast internal call)

  0001f	ba 01 00 00 00	 mov	 edx, 1
  00024	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00029	e8 00 00 00 00	 call	 int_scsi_status_update

; 1917 : 
; 1918 :     return ( STS_MOUNTED( dev ) );

  0002e	33 d2		 xor	 edx, edx
  00030	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00035	e8 00 00 00 00	 call	 int_scsi_status_mounted

; 1919 : } /* end function driveready_scsitape */

  0003a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003e	c3		 ret	 0
is_tape_mounted_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 112
tv136 = 116
tv142 = 120
opblk$1 = 128
tv93 = 136
tv131 = 144
dev$ = 176
unitstat$ = 184
code$ = 192
erg_scsitape PROC

; 1244 : {

$LN13:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1245 : #if defined( OPTION_SCSI_ERASE_GAP )
; 1246 : int rc;
; 1247 : 
; 1248 :     if (!dev->stape_no_erg)

  00016	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0001e	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  00024	c1 e8 02	 shr	 eax, 2
  00027	83 e0 01	 and	 eax, 1
  0002a	85 c0		 test	 eax, eax
  0002c	0f 85 26 02 00
	00		 jne	 $LN2@erg_scsita

; 1249 :     {
; 1250 :         struct mtop opblk;
; 1251 : 
; 1252 :         opblk.mt_op    = MTERASE;

  00032	b8 0d 00 00 00	 mov	 eax, 13
  00037	66 89 84 24 80
	00 00 00	 mov	 WORD PTR opblk$1[rsp], ax

; 1253 :         opblk.mt_count = 0;         // (zero means "short" erase-gap)

  0003f	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR opblk$1[rsp+4], 0

; 1254 : 
; 1255 :         rc = ioctl_tape( dev->fd, MTIOCTOP, (char*)&opblk );

  0004a	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR opblk$1[rsp]
  00052	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00057	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005f	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0006b	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 1256 : 
; 1257 : #if defined( _MSVC_ )
; 1258 :         if (errno == ENOSPC)

  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00075	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00078	75 1f		 jne	 SHORT $LN3@erg_scsita

; 1259 :             dev->eotwarning = 1;

  0007a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00082	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00088	83 c8 20	 or	 eax, 32			; 00000020H
  0008b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00093	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN3@erg_scsita:

; 1260 : #endif
; 1261 : 
; 1262 :         if ( rc < 0 )

  00099	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  0009e	0f 8d b4 01 00
	00		 jge	 $LN4@erg_scsita

; 1263 :         {
; 1264 :             /*         LINUX EOM BEHAVIOUR WHEN WRITING
; 1265 : 
; 1266 :               When the end of medium early warning is encountered,
; 1267 :               the current write is finished and the number of bytes
; 1268 :               is returned. The next write returns -1 and errno is
; 1269 :               set to ENOSPC. To enable writing a trailer, the next
; 1270 :               write is allowed to proceed and, if successful, the
; 1271 :               number of bytes is returned. After this, -1 and the
; 1272 :               number of bytes are alternately returned until the
; 1273 :               physical end of medium (or some other error) occurs.
; 1274 :             */
; 1275 : 
; 1276 :             if (errno == ENOSPC)

  000a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000aa	83 38 1c	 cmp	 DWORD PTR [rax], 28
  000ad	75 72		 jne	 SHORT $LN5@erg_scsita

; 1277 :             {
; 1278 :                 int_scsi_status_update( dev, 0 );

  000af	33 d2		 xor	 edx, edx
  000b1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b9	e8 00 00 00 00	 call	 int_scsi_status_update

; 1279 : 
; 1280 :                 opblk.mt_op    = MTERASE;

  000be	b8 0d 00 00 00	 mov	 eax, 13
  000c3	66 89 84 24 80
	00 00 00	 mov	 WORD PTR opblk$1[rsp], ax

; 1281 :                 opblk.mt_count = 0;         // (zero means "short" erase-gap)

  000cb	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR opblk$1[rsp+4], 0

; 1282 : 
; 1283 :                 if ( (rc = ioctl_tape( dev->fd, MTIOCTOP, (char*)&opblk )) >= 0 )

  000d6	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR opblk$1[rsp]
  000de	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  000e3	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000eb	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  000f7	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  000fb	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00100	7c 1f		 jl	 SHORT $LN6@erg_scsita

; 1284 :                     dev->eotwarning = 1;

  00102	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0010a	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00110	83 c8 20	 or	 eax, 32			; 00000020H
  00113	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0011b	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN6@erg_scsita:
$LN5@erg_scsita:

; 1285 :             }
; 1286 : 
; 1287 :             if ( rc < 0)

  00121	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00126	0f 8d 2c 01 00
	00		 jge	 $LN7@erg_scsita

; 1288 :             {
; 1289 :                 // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1290 :                 WRMSG (HHC00205, "E", LCSS_DEVNUM,

  0012c	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00135	74 12		 je	 SHORT $LN9@erg_scsita
  00137	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013f	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00143	89 44 24 74	 mov	 DWORD PTR tv136[rsp], eax
  00147	eb 08		 jmp	 SHORT $LN10@erg_scsita
$LN9@erg_scsita:
  00149	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv136[rsp], 0
$LN10@erg_scsita:
  00151	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0015a	74 14		 je	 SHORT $LN11@erg_scsita
  0015c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00164	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00168	d1 f8		 sar	 eax, 1
  0016a	89 44 24 78	 mov	 DWORD PTR tv142[rsp], eax
  0016e	eb 08		 jmp	 SHORT $LN12@erg_scsita
$LN11@erg_scsita:
  00170	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv142[rsp], 0
$LN12@erg_scsita:
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0017e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00180	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00186	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv93[rsp], rax
  0018e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00196	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0019d	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv131[rsp], rcx
  001a5	b9 01 00 00 00	 mov	 ecx, 1
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b0	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv93[rsp]
  001b8	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169679
  001c4	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169680
  001d0	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001d5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv131[rsp]
  001dd	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001e2	8b 4c 24 74	 mov	 ecx, DWORD PTR tv136[rsp]
  001e6	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ea	8b 4c 24 78	 mov	 ecx, DWORD PTR tv142[rsp]
  001ee	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169681
  001f9	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169682
  00205	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0020f	41 b9 03 00 00
	00		 mov	 r9d, 3
  00215	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169683
  0021c	ba 0b 05 00 00	 mov	 edx, 1291		; 0000050bH
  00221	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169684
  00228	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1291 :                         dev->filename, "scsi", "ioctl_tape(MTERASE)", strerror(errno));
; 1292 :                 build_senseX(TAPE_BSENSE_WRITEFAIL,dev,unitstat,code);

  0022e	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00237	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0023f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00247	b9 03 00 00 00	 mov	 ecx, 3
  0024c	e8 00 00 00 00	 call	 build_senseX

; 1293 :                 return -1;

  00251	b8 ff ff ff ff	 mov	 eax, -1
  00256	eb 02		 jmp	 SHORT $LN1@erg_scsita
$LN7@erg_scsita:
$LN4@erg_scsita:
$LN2@erg_scsita:

; 1294 :             }
; 1295 :         }
; 1296 :     }
; 1297 : 
; 1298 :     return 0;       // (success)

  00258	33 c0		 xor	 eax, eax
$LN1@erg_scsita:

; 1299 : 
; 1300 : #else // !defined( OPTION_SCSI_ERASE_GAP )
; 1301 : 
; 1302 :     UNREFERENCED ( dev );
; 1303 :     UNREFERENCED ( code );
; 1304 :     UNREFERENCED ( unitstat );
; 1305 : 
; 1306 :     return 0;       // (treat as nop)
; 1307 : 
; 1308 : #endif // defined( OPTION_SCSI_ERASE_GAP )
; 1309 : 
; 1310 : } /* end function erg_scsitape */

  0025a	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00261	c3		 ret	 0
erg_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
tv81 = 112
tv87 = 116
opblk$ = 120
tv70 = 128
tv76 = 136
dev$ = 160
unitstat$ = 168
code$ = 176
dse_scsitape PROC

; 1316 : {

$LN8:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 1317 : #if defined( OPTION_SCSI_ERASE_TAPE )
; 1318 : 
; 1319 :     struct mtop opblk;
; 1320 : 
; 1321 :     opblk.mt_op    = MTERASE;

  00016	b8 0d 00 00 00	 mov	 eax, 13
  0001b	66 89 44 24 78	 mov	 WORD PTR opblk$[rsp], ax

; 1322 :     opblk.mt_count = 1;         // (one means "long" erase-tape)

  00020	c7 44 24 7c 01
	00 00 00	 mov	 DWORD PTR opblk$[rsp+4], 1

; 1323 : 
; 1324 :     if ( ioctl_tape( dev->fd, MTIOCTOP, (char*)&opblk ) < 0 )

  00028	4c 8d 44 24 78	 lea	 r8, QWORD PTR opblk$[rsp]
  0002d	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  00032	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  00046	85 c0		 test	 eax, eax
  00048	0f 8d 2c 01 00
	00		 jge	 $LN2@dse_scsita

; 1325 :     {
; 1326 :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1327 :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  0004e	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00057	74 12		 je	 SHORT $LN4@dse_scsita
  00059	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00061	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00065	89 44 24 70	 mov	 DWORD PTR tv81[rsp], eax
  00069	eb 08		 jmp	 SHORT $LN5@dse_scsita
$LN4@dse_scsita:
  0006b	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv81[rsp], 0
$LN5@dse_scsita:
  00073	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0007c	74 14		 je	 SHORT $LN6@dse_scsita
  0007e	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00086	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0008a	d1 f8		 sar	 eax, 1
  0008c	89 44 24 74	 mov	 DWORD PTR tv87[rsp], eax
  00090	eb 08		 jmp	 SHORT $LN7@dse_scsita
$LN6@dse_scsita:
  00092	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv87[rsp], 0
$LN7@dse_scsita:
  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a0	8b 08		 mov	 ecx, DWORD PTR [rax]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000a8	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv70[rsp], rax
  000b0	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b8	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  000bf	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv76[rsp], rcx
  000c7	b9 01 00 00 00	 mov	 ecx, 1
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  000d2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv70[rsp]
  000da	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  000df	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169697
  000e6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  000eb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169698
  000f2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  000f7	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv76[rsp]
  000ff	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00104	8b 4c 24 70	 mov	 ecx, DWORD PTR tv81[rsp]
  00108	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0010c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv87[rsp]
  00110	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169699
  0011b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00120	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169700
  00127	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0012c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00131	41 b9 03 00 00
	00		 mov	 r9d, 3
  00137	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169701
  0013e	ba 30 05 00 00	 mov	 edx, 1328		; 00000530H
  00143	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169702
  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1328 :                 dev->filename, "scsi", "ioctl_tape(MTERASE)", strerror(errno));
; 1329 :         build_senseX(TAPE_BSENSE_WRITEFAIL,dev,unitstat,code);

  00150	44 0f b6 8c 24
	b0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00159	4c 8b 84 24 a8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00161	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00169	b9 03 00 00 00	 mov	 ecx, 3
  0016e	e8 00 00 00 00	 call	 build_senseX

; 1330 :         return -1;

  00173	b8 ff ff ff ff	 mov	 eax, -1
  00178	eb 02		 jmp	 SHORT $LN1@dse_scsita
$LN2@dse_scsita:

; 1331 :     }
; 1332 : 
; 1333 :     return 0;       // (success)

  0017a	33 c0		 xor	 eax, eax
$LN1@dse_scsita:

; 1334 : 
; 1335 : #else // !defined( OPTION_SCSI_ERASE_TAPE )
; 1336 : 
; 1337 :     UNREFERENCED ( dev );
; 1338 :     UNREFERENCED ( code );
; 1339 :     UNREFERENCED ( unitstat );
; 1340 : 
; 1341 :     return 0;       // (treat as nop)
; 1342 : 
; 1343 : #endif // defined( OPTION_SCSI_ERASE_TAPE )
; 1344 : 
; 1345 : } /* end function dse_scsitape */

  0017c	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00183	c3		 ret	 0
dse_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 112
tv132 = 116
tv138 = 120
tv161 = 124
save_errno$ = 128
opblk$ = 136
tv89 = 144
tv95 = 152
dev$ = 176
unitstat$ = 184
code$ = 192
sync_scsitape PROC

; 632  : {

$LN20:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 633  : int  rc;
; 634  : int  save_errno;
; 635  : struct mtop opblk;
; 636  : 
; 637  :     /*
; 638  :         GA32-0566-02 ("IBM Tape Device Drivers - Programming
; 639  :         Reference"):
; 640  : 
; 641  :         STIOCQRYPOS
; 642  : 
; 643  :         "[...] A write filemark of count 0 is always issued to
; 644  :          the drive, which flushes all data from the buffers to
; 645  :          the tape media. After the write filemark completes, the
; 646  :          query is issued."
; 647  : 
; 648  :         Write Tapemark
; 649  : 
; 650  :         "[...] The WriteTapemark entry point may also be called
; 651  :          with the dwTapemarkCount parameter set to 0 and the
; 652  :          bImmediate parameter set to FALSE. This has the effect
; 653  :          of committing any uncommitted data written by previous
; 654  :          WriteFile calls ... to the media."
; 655  :     */
; 656  : 
; 657  :     opblk.mt_op    = MTWEOF;

  00016	b8 05 00 00 00	 mov	 eax, 5
  0001b	66 89 84 24 88
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 658  :     opblk.mt_count = 0;             // (zero to force a commit)

  00023	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 0

; 659  : 
; 660  :     if ((rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk)) >= 0)

  0002e	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  00036	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  0003b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0004f	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  00053	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00058	7c 31		 jl	 SHORT $LN4@sync_scsit

; 661  :     {
; 662  : #if defined( _MSVC_ )
; 663  :         if (errno == ENOSPC)

  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00060	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00063	75 1f		 jne	 SHORT $LN5@sync_scsit

; 664  :             dev->eotwarning = 1;

  00065	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006d	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00073	83 c8 20	 or	 eax, 32			; 00000020H
  00076	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0007e	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN5@sync_scsit:

; 665  : #endif
; 666  :         return 0;       // (success)

  00084	33 c0		 xor	 eax, eax
  00086	e9 b8 02 00 00	 jmp	 $LN1@sync_scsit
$LN4@sync_scsit:

; 667  :     }
; 668  : 
; 669  :     /*         LINUX EOM BEHAVIOUR WHEN WRITING
; 670  : 
; 671  :       When the end of medium early warning is encountered,
; 672  :       the current write is finished and the number of bytes
; 673  :       is returned. The next write returns -1 and errno is
; 674  :       set to ENOSPC. To enable writing a trailer, the next
; 675  :       write is allowed to proceed and, if successful, the
; 676  :       number of bytes is returned. After this, -1 and the
; 677  :       number of bytes are alternately returned until the
; 678  :       physical end of medium (or some other error) occurs.
; 679  :     */
; 680  : 
; 681  :     if (errno == ENOSPC)

  0008b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00091	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00094	75 79		 jne	 SHORT $LN6@sync_scsit

; 682  :     {
; 683  :         int_scsi_status_update( dev, 0 );

  00096	33 d2		 xor	 edx, edx
  00098	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a0	e8 00 00 00 00	 call	 int_scsi_status_update

; 684  : 
; 685  :         opblk.mt_op    = MTWEOF;

  000a5	b8 05 00 00 00	 mov	 eax, 5
  000aa	66 89 84 24 88
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 686  :         opblk.mt_count = 0;         // (zero to force a commit)

  000b2	c7 84 24 8c 00
	00 00 00 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 0

; 687  : 
; 688  :         if ((rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk)) >= 0)

  000bd	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  000c5	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  000ca	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d2	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  000de	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  000e2	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  000e7	7c 26		 jl	 SHORT $LN7@sync_scsit

; 689  :         {
; 690  :             dev->eotwarning = 1;

  000e9	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f1	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  000f7	83 c8 20	 or	 eax, 32			; 00000020H
  000fa	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00102	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 691  :             return 0;

  00108	33 c0		 xor	 eax, eax
  0010a	e9 34 02 00 00	 jmp	 $LN1@sync_scsit
$LN7@sync_scsit:
$LN6@sync_scsit:

; 692  :         }
; 693  :     }
; 694  : 
; 695  :     /* Handle write error condition... */
; 696  : 
; 697  :     save_errno = errno;

  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00115	8b 00		 mov	 eax, DWORD PTR [rax]
  00117	89 84 24 80 00
	00 00		 mov	 DWORD PTR save_errno$[rsp], eax

; 698  :     {
; 699  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 700  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  0011e	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00127	74 12		 je	 SHORT $LN16@sync_scsit
  00129	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00131	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00135	89 44 24 74	 mov	 DWORD PTR tv132[rsp], eax
  00139	eb 08		 jmp	 SHORT $LN17@sync_scsit
$LN16@sync_scsit:
  0013b	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN17@sync_scsit:
  00143	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0014c	74 14		 je	 SHORT $LN18@sync_scsit
  0014e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00156	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0015a	d1 f8		 sar	 eax, 1
  0015c	89 44 24 78	 mov	 DWORD PTR tv138[rsp], eax
  00160	eb 08		 jmp	 SHORT $LN19@sync_scsit
$LN18@sync_scsit:
  00162	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv138[rsp], 0
$LN19@sync_scsit:
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00170	8b 08		 mov	 ecx, DWORD PTR [rax]
  00172	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00178	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv89[rsp], rax
  00180	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00188	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0018f	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv95[rsp], rcx
  00197	b9 01 00 00 00	 mov	 ecx, 1
  0019c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a2	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv89[rsp]
  001aa	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169472
  001b6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169473
  001c2	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001c7	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv95[rsp]
  001cf	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d4	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  001d8	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001dc	8b 4c 24 78	 mov	 ecx, DWORD PTR tv138[rsp]
  001e0	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169474
  001eb	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169475
  001f7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001fc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00201	41 b9 03 00 00
	00		 mov	 r9d, 3
  00207	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169476
  0020e	ba bd 02 00 00	 mov	 edx, 701		; 000002bdH
  00213	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169477
  0021a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 701  :             dev->filename, "scsi", "ioctl_tape(MTWEOF)", strerror(errno));
; 702  : 
; 703  :         int_scsi_status_update( dev, 0 );

  00220	33 d2		 xor	 edx, edx
  00222	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022a	e8 00 00 00 00	 call	 int_scsi_status_update

; 704  :     }
; 705  :     errno = save_errno;

  0022f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00235	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR save_errno$[rsp]
  0023c	89 08		 mov	 DWORD PTR [rax], ecx

; 706  : 
; 707  :     if ( STS_NOT_MOUNTED( dev ) )

  0023e	33 d2		 xor	 edx, edx
  00240	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00248	e8 00 00 00 00	 call	 int_scsi_status_mounted
  0024d	85 c0		 test	 eax, eax
  0024f	75 25		 jne	 SHORT $LN8@sync_scsit

; 708  :     {
; 709  :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  00251	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  0025a	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00262	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0026a	33 c9		 xor	 ecx, ecx
  0026c	e8 00 00 00 00	 call	 build_senseX

; 710  :     }

  00271	e9 c8 00 00 00	 jmp	 $LN9@sync_scsit
$LN8@sync_scsit:

; 711  :     else
; 712  :     {
; 713  :         switch(errno)

  00276	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0027c	8b 00		 mov	 eax, DWORD PTR [rax]
  0027e	89 44 24 7c	 mov	 DWORD PTR tv161[rsp], eax
  00282	83 7c 24 7c 05	 cmp	 DWORD PTR tv161[rsp], 5
  00287	74 0c		 je	 SHORT $LN10@sync_scsit
  00289	83 7c 24 7c 1c	 cmp	 DWORD PTR tv161[rsp], 28
  0028e	74 66		 je	 SHORT $LN13@sync_scsit
  00290	e9 86 00 00 00	 jmp	 $LN14@sync_scsit
$LN10@sync_scsit:

; 714  :         {
; 715  :         case EIO:
; 716  :             if(STS_EOT(dev))

  00295	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0029d	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  002a3	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002a8	85 c0		 test	 eax, eax
  002aa	74 25		 je	 SHORT $LN11@sync_scsit

; 717  :                 build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  002ac	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002b5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002bd	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002c5	b9 08 00 00 00	 mov	 ecx, 8
  002ca	e8 00 00 00 00	 call	 build_senseX
  002cf	eb 23		 jmp	 SHORT $LN12@sync_scsit
$LN11@sync_scsit:

; 718  :             else
; 719  :                 build_senseX(TAPE_BSENSE_WRITEFAIL,dev,unitstat,code);

  002d1	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002da	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002e2	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002ea	b9 03 00 00 00	 mov	 ecx, 3
  002ef	e8 00 00 00 00	 call	 build_senseX
$LN12@sync_scsit:

; 720  :             break;

  002f4	eb 48		 jmp	 SHORT $LN2@sync_scsit
$LN13@sync_scsit:

; 721  :         case ENOSPC:
; 722  :             build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  002f6	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002ff	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00307	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0030f	b9 08 00 00 00	 mov	 ecx, 8
  00314	e8 00 00 00 00	 call	 build_senseX

; 723  :             break;

  00319	eb 23		 jmp	 SHORT $LN2@sync_scsit
$LN14@sync_scsit:

; 724  :         default:
; 725  :             build_senseX(TAPE_BSENSE_ITFERROR,dev,unitstat,code);

  0031b	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00324	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0032c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00334	b9 12 00 00 00	 mov	 ecx, 18
  00339	e8 00 00 00 00	 call	 build_senseX
$LN2@sync_scsit:
$LN9@sync_scsit:

; 726  :             break;
; 727  :         }
; 728  :     }
; 729  : 
; 730  :     return -1;

  0033e	b8 ff ff ff ff	 mov	 eax, -1
$LN1@sync_scsit:

; 731  : 
; 732  : } /* end function sync_scsitape */

  00343	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0034a	c3		 ret	 0
sync_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
tv94 = 112
tv132 = 116
tv155 = 120
rc$ = 124
save_errno$ = 128
tv83 = 136
tv89 = 144
dev$ = 176
unitstat$ = 184
code$ = 192
write_scsimark PROC

; 522  : {

$LN20:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 523  : int  rc, save_errno;
; 524  : 
; 525  :     /* Write tape mark to SCSI tape */
; 526  : 
; 527  :     rc = int_write_scsimark( dev );

  00016	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0001e	e8 00 00 00 00	 call	 int_write_scsimark
  00023	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 528  : 
; 529  : #if defined( _MSVC_ )
; 530  :     if (errno == ENOSPC)

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0002d	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00030	75 1f		 jne	 SHORT $LN4@write_scsi

; 531  :         dev->eotwarning = 1;

  00032	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003a	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00040	83 c8 20	 or	 eax, 32			; 00000020H
  00043	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0004b	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN4@write_scsi:

; 532  : #endif
; 533  : 
; 534  :     if (rc >= 0)

  00051	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  00056	7c 07		 jl	 SHORT $LN5@write_scsi

; 535  :         return 0;

  00058	33 c0		 xor	 eax, eax
  0005a	e9 85 02 00 00	 jmp	 $LN1@write_scsi
$LN5@write_scsi:

; 536  : 
; 537  :     /*         LINUX EOM BEHAVIOUR WHEN WRITING
; 538  : 
; 539  :       When the end of medium early warning is encountered,
; 540  :       the current write is finished and the number of bytes
; 541  :       is returned. The next write returns -1 and errno is
; 542  :       set to ENOSPC. To enable writing a trailer, the next
; 543  :       write is allowed to proceed and, if successful, the
; 544  :       number of bytes is returned. After this, -1 and the
; 545  :       number of bytes are alternately returned until the
; 546  :       physical end of medium (or some other error) occurs.
; 547  :     */
; 548  : 
; 549  :     if (errno == ENOSPC)

  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00065	83 38 1c	 cmp	 DWORD PTR [rax], 28
  00068	75 46		 jne	 SHORT $LN6@write_scsi

; 550  :     {
; 551  :         int_scsi_status_update( dev, 0 );

  0006a	33 d2		 xor	 edx, edx
  0006c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00074	e8 00 00 00 00	 call	 int_scsi_status_update

; 552  : 
; 553  :         if (int_write_scsimark( dev ) >= 0)

  00079	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00081	e8 00 00 00 00	 call	 int_write_scsimark
  00086	85 c0		 test	 eax, eax
  00088	7c 26		 jl	 SHORT $LN7@write_scsi

; 554  :         {
; 555  :             dev->eotwarning = 1;

  0008a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00092	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00098	83 c8 20	 or	 eax, 32			; 00000020H
  0009b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a3	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 556  :             return 0;

  000a9	33 c0		 xor	 eax, eax
  000ab	e9 34 02 00 00	 jmp	 $LN1@write_scsi
$LN7@write_scsi:
$LN6@write_scsi:

; 557  :         }
; 558  :     }
; 559  : 
; 560  :     /* Handle write error condition... */
; 561  : 
; 562  :     save_errno = errno;

  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b6	8b 00		 mov	 eax, DWORD PTR [rax]
  000b8	89 84 24 80 00
	00 00		 mov	 DWORD PTR save_errno$[rsp], eax

; 563  :     {
; 564  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 565  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  000bf	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000c8	74 12		 je	 SHORT $LN16@write_scsi
  000ca	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d2	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000d6	89 44 24 70	 mov	 DWORD PTR tv94[rsp], eax
  000da	eb 08		 jmp	 SHORT $LN17@write_scsi
$LN16@write_scsi:
  000dc	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN17@write_scsi:
  000e4	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ed	74 14		 je	 SHORT $LN18@write_scsi
  000ef	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f7	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000fb	d1 f8		 sar	 eax, 1
  000fd	89 44 24 74	 mov	 DWORD PTR tv132[rsp], eax
  00101	eb 08		 jmp	 SHORT $LN19@write_scsi
$LN18@write_scsi:
  00103	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv132[rsp], 0
$LN19@write_scsi:
  0010b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00111	8b 08		 mov	 ecx, DWORD PTR [rax]
  00113	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00119	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
  00121	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00129	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00130	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv89[rsp], rcx
  00138	b9 01 00 00 00	 mov	 ecx, 1
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00143	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  0014b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00150	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169428
  00157	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0015c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169429
  00163	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00168	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv89[rsp]
  00170	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00175	8b 4c 24 70	 mov	 ecx, DWORD PTR tv94[rsp]
  00179	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0017d	8b 4c 24 74	 mov	 ecx, DWORD PTR tv132[rsp]
  00181	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00185	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169430
  0018c	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00191	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169431
  00198	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0019d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001a2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001a8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169432
  001af	ba 36 02 00 00	 mov	 edx, 566		; 00000236H
  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169433
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 566  :                 dev->filename, "scsi", "write_scsimark()", strerror(errno));
; 567  : 
; 568  :         int_scsi_status_update( dev, 0 );

  001c1	33 d2		 xor	 edx, edx
  001c3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001cb	e8 00 00 00 00	 call	 int_scsi_status_update

; 569  :     }
; 570  :     errno = save_errno;

  001d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001d6	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR save_errno$[rsp]
  001dd	89 08		 mov	 DWORD PTR [rax], ecx

; 571  : 
; 572  :     if ( STS_NOT_MOUNTED( dev ) )

  001df	33 d2		 xor	 edx, edx
  001e1	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001e9	e8 00 00 00 00	 call	 int_scsi_status_mounted
  001ee	85 c0		 test	 eax, eax
  001f0	75 25		 jne	 SHORT $LN8@write_scsi

; 573  :     {
; 574  :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  001f2	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  001fb	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00203	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0020b	33 c9		 xor	 ecx, ecx
  0020d	e8 00 00 00 00	 call	 build_senseX

; 575  :     }

  00212	e9 c8 00 00 00	 jmp	 $LN9@write_scsi
$LN8@write_scsi:

; 576  :     else
; 577  :     {
; 578  :         switch(errno)

  00217	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0021d	8b 00		 mov	 eax, DWORD PTR [rax]
  0021f	89 44 24 78	 mov	 DWORD PTR tv155[rsp], eax
  00223	83 7c 24 78 05	 cmp	 DWORD PTR tv155[rsp], 5
  00228	74 0c		 je	 SHORT $LN10@write_scsi
  0022a	83 7c 24 78 1c	 cmp	 DWORD PTR tv155[rsp], 28
  0022f	74 66		 je	 SHORT $LN13@write_scsi
  00231	e9 86 00 00 00	 jmp	 $LN14@write_scsi
$LN10@write_scsi:

; 579  :         {
; 580  :         case EIO:
; 581  :             if(STS_EOT(dev))

  00236	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0023e	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00244	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  00249	85 c0		 test	 eax, eax
  0024b	74 25		 je	 SHORT $LN11@write_scsi

; 582  :                 build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  0024d	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00256	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0025e	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00266	b9 08 00 00 00	 mov	 ecx, 8
  0026b	e8 00 00 00 00	 call	 build_senseX
  00270	eb 23		 jmp	 SHORT $LN12@write_scsi
$LN11@write_scsi:

; 583  :             else
; 584  :                 build_senseX(TAPE_BSENSE_WRITEFAIL,dev,unitstat,code);

  00272	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  0027b	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00283	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0028b	b9 03 00 00 00	 mov	 ecx, 3
  00290	e8 00 00 00 00	 call	 build_senseX
$LN12@write_scsi:

; 585  :             break;

  00295	eb 48		 jmp	 SHORT $LN2@write_scsi
$LN13@write_scsi:

; 586  :         case ENOSPC:
; 587  :             build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  00297	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002a0	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002a8	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002b0	b9 08 00 00 00	 mov	 ecx, 8
  002b5	e8 00 00 00 00	 call	 build_senseX

; 588  :             break;

  002ba	eb 23		 jmp	 SHORT $LN2@write_scsi
$LN14@write_scsi:

; 589  :         default:
; 590  :             build_senseX(TAPE_BSENSE_ITFERROR,dev,unitstat,code);

  002bc	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002c5	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002cd	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002d5	b9 12 00 00 00	 mov	 ecx, 18
  002da	e8 00 00 00 00	 call	 build_senseX
$LN2@write_scsi:
$LN9@write_scsi:

; 591  :             break;
; 592  :         }
; 593  :     }
; 594  : 
; 595  :     return -1;

  002df	b8 ff ff ff ff	 mov	 eax, -1
$LN1@write_scsi:

; 596  : 
; 597  : } /* end function write_scsimark */

  002e4	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  002eb	c3		 ret	 0
write_scsimark ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
tv131 = 112
tv137 = 116
tv158 = 120
rc$ = 124
save_errno$ = 128
opblk$ = 136
tv88 = 144
tv94 = 152
dev$ = 176
unitstat$ = 184
code$ = 192
fsf_scsitape PROC

; 994  : {

$LN18:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 995  : int  rc;
; 996  : int  save_errno;
; 997  : struct mtop opblk;
; 998  : 
; 999  :     /* Forward space file on SCSI tape */
; 1000 : 
; 1001 :     opblk.mt_op    = MTFSF;

  00016	b8 01 00 00 00	 mov	 eax, 1
  0001b	66 89 84 24 88
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 1002 :     opblk.mt_count = 1;

  00023	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 1003 : 
; 1004 :     rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  0002e	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  00036	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  0003b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0004f	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 1005 : 
; 1006 :     /* Since we have no idea how many blocks we've skipped over
; 1007 :        (as a result of doing the forward-space file), we now have
; 1008 :        no clue as to what the proper current blockid should be.
; 1009 :     */
; 1010 :     dev->blockid = -1;      // (actual position now unknown!)

  00053	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005b	c7 80 04 10 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+4100], -1 ; ffffffffH

; 1011 : 
; 1012 :     if ( rc >= 0 )

  00065	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  0006a	7c 28		 jl	 SHORT $LN4@fsf_scsita

; 1013 :     {
; 1014 :         dev->curfilen++;

  0006c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00074	0f b7 80 02 10
	00 00		 movzx	 eax, WORD PTR [rax+4098]
  0007b	66 ff c0	 inc	 ax
  0007e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00086	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 1015 :         return 0;

  0008d	33 c0		 xor	 eax, eax
  0008f	e9 71 02 00 00	 jmp	 $LN1@fsf_scsita
$LN4@fsf_scsita:

; 1016 :     }
; 1017 : 
; 1018 :     /* Handle error condition */
; 1019 :     if (!SVF_ENABLED())

  00094	b8 01 00 00 00	 mov	 eax, 1
  00099	48 6b c0 00	 imul	 rax, rax, 0
  0009d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000a5	48 8d 84 01 72
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1394]
  000ad	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 is_tape_feat
  000ba	0f b6 c0	 movzx	 eax, al
  000bd	85 c0		 test	 eax, eax
  000bf	75 1f		 jne	 SHORT $LN5@fsf_scsita

; 1020 :         dev->fenced = 1;    // (actual position now unknown!)

  000c1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c9	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  000cf	83 c8 01	 or	 eax, 1
  000d2	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000da	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN5@fsf_scsita:

; 1021 : 
; 1022 :     save_errno = errno;

  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000e6	8b 00		 mov	 eax, DWORD PTR [rax]
  000e8	89 84 24 80 00
	00 00		 mov	 DWORD PTR save_errno$[rsp], eax

; 1023 :     {
; 1024 :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1025 :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  000ef	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000f8	74 12		 je	 SHORT $LN14@fsf_scsita
  000fa	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00102	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00106	89 44 24 70	 mov	 DWORD PTR tv131[rsp], eax
  0010a	eb 08		 jmp	 SHORT $LN15@fsf_scsita
$LN14@fsf_scsita:
  0010c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN15@fsf_scsita:
  00114	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0011d	74 14		 je	 SHORT $LN16@fsf_scsita
  0011f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00127	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0012b	d1 f8		 sar	 eax, 1
  0012d	89 44 24 74	 mov	 DWORD PTR tv137[rsp], eax
  00131	eb 08		 jmp	 SHORT $LN17@fsf_scsita
$LN16@fsf_scsita:
  00133	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN17@fsf_scsita:
  0013b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00141	8b 08		 mov	 ecx, DWORD PTR [rax]
  00143	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00149	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv88[rsp], rax
  00151	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00159	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00160	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv94[rsp], rcx
  00168	b9 01 00 00 00	 mov	 ecx, 1
  0016d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00173	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  0017b	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00180	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169563
  00187	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0018c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169564
  00193	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00198	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  001a0	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001a5	8b 4c 24 70	 mov	 ecx, DWORD PTR tv131[rsp]
  001a9	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001ad	8b 4c 24 74	 mov	 ecx, DWORD PTR tv137[rsp]
  001b1	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001b5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169565
  001bc	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001c1	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169566
  001c8	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001cd	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001d2	41 b9 03 00 00
	00		 mov	 r9d, 3
  001d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169567
  001df	ba 02 04 00 00	 mov	 edx, 1026		; 00000402H
  001e4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169568
  001eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1026 :                 dev->filename, "scsi", "ioctl_tape(MTFSF)", strerror(errno));
; 1027 :     }
; 1028 :     errno = save_errno;

  001f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001f7	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR save_errno$[rsp]
  001fe	89 08		 mov	 DWORD PTR [rax], ecx

; 1029 : 
; 1030 :     if ( STS_NOT_MOUNTED( dev ) )

  00200	33 d2		 xor	 edx, edx
  00202	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0020a	e8 00 00 00 00	 call	 int_scsi_status_mounted
  0020f	85 c0		 test	 eax, eax
  00211	75 25		 jne	 SHORT $LN6@fsf_scsita

; 1031 :     {
; 1032 :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  00213	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  0021c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00224	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0022c	33 c9		 xor	 ecx, ecx
  0022e	e8 00 00 00 00	 call	 build_senseX

; 1033 :     }

  00233	e9 c8 00 00 00	 jmp	 $LN7@fsf_scsita
$LN6@fsf_scsita:

; 1034 :     else
; 1035 :     {
; 1036 :         switch(errno)

  00238	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0023e	8b 00		 mov	 eax, DWORD PTR [rax]
  00240	89 44 24 78	 mov	 DWORD PTR tv158[rsp], eax
  00244	83 7c 24 78 05	 cmp	 DWORD PTR tv158[rsp], 5
  00249	74 0c		 je	 SHORT $LN8@fsf_scsita
  0024b	83 7c 24 78 1c	 cmp	 DWORD PTR tv158[rsp], 28
  00250	74 66		 je	 SHORT $LN11@fsf_scsita
  00252	e9 86 00 00 00	 jmp	 $LN12@fsf_scsita
$LN8@fsf_scsita:

; 1037 :         {
; 1038 :         case EIO:
; 1039 :             if(STS_EOT(dev))

  00257	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0025f	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00265	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0026a	85 c0		 test	 eax, eax
  0026c	74 25		 je	 SHORT $LN9@fsf_scsita

; 1040 :                 build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  0026e	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00277	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0027f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00287	b9 08 00 00 00	 mov	 ecx, 8
  0028c	e8 00 00 00 00	 call	 build_senseX
  00291	eb 23		 jmp	 SHORT $LN10@fsf_scsita
$LN9@fsf_scsita:

; 1041 :             else
; 1042 :                 build_senseX(TAPE_BSENSE_READFAIL,dev,unitstat,code);

  00293	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  0029c	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002a4	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002ac	b9 02 00 00 00	 mov	 ecx, 2
  002b1	e8 00 00 00 00	 call	 build_senseX
$LN10@fsf_scsita:

; 1043 :             break;

  002b6	eb 48		 jmp	 SHORT $LN2@fsf_scsita
$LN11@fsf_scsita:

; 1044 :         case ENOSPC:
; 1045 :             build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  002b8	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002c1	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002c9	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002d1	b9 08 00 00 00	 mov	 ecx, 8
  002d6	e8 00 00 00 00	 call	 build_senseX

; 1046 :             break;

  002db	eb 23		 jmp	 SHORT $LN2@fsf_scsita
$LN12@fsf_scsita:

; 1047 :         default:
; 1048 :             build_senseX(TAPE_BSENSE_ITFERROR,dev,unitstat,code);

  002dd	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002e6	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002ee	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002f6	b9 12 00 00 00	 mov	 ecx, 18
  002fb	e8 00 00 00 00	 call	 build_senseX
$LN2@fsf_scsita:
$LN7@fsf_scsita:

; 1049 :             break;
; 1050 :         }
; 1051 :     }
; 1052 : 
; 1053 :     return -1;

  00300	b8 ff ff ff ff	 mov	 eax, -1
$LN1@fsf_scsita:

; 1054 : 
; 1055 : } /* end function fsf_scsitape */

  00305	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0030c	c3		 ret	 0
fsf_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
tv143 = 112
tv149 = 116
rc$ = 120
save_errno$ = 124
opblk$ = 128
tv132 = 136
tv138 = 144
dev$ = 176
unitstat$ = 184
code$ = 192
bsf_scsitape PROC

; 1065 : {

$LN14:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1066 : int  rc;
; 1067 : int  save_errno;
; 1068 : struct mtop opblk;
; 1069 : 
; 1070 :     /* PROGRAMMING NOTE: There is currently no way to distinguish
; 1071 :     ** between a "normal" backspace-file error and a "backspaced-
; 1072 :     ** into-loadpoint" i/o error, since the only error indication
; 1073 :     ** we get [in response to a backspace file attempt] is simply
; 1074 :     ** 'EIO'. (Interrogating the status AFTER the fact (to see if
; 1075 :     ** we're positioned at loadpoint) doesn't tell us whether we
; 1076 :     ** were already positioned at loadpoint *before* the error was
; 1077 :     ** was encountered or whether we're only positioned ar load-
; 1078 :     ** point because we *did* in fact backspace over a BOT tape-
; 1079 :     ** mark on the tape (and are thus now, after the fact, sitting
; 1080 :     ** at loadpoint because we *did* backspace over a tape-mark
; 1081 :     ** but it just got an error for some reason).
; 1082 :     **
; 1083 :     ** Thus, we have absolutely no choice here but to retrieve the
; 1084 :     ** status BEFORE we attempt the i/o to see if we're ALREADY at
; 1085 :     ** loadpoint. If we are, then we immediately return an error
; 1086 :     ** ("backspaced-into-loadpoint") *without* even attemting the
; 1087 :     ** i/o at all. If we're *not* already sitting at loadpoint how-
; 1088 :     ** ever, then we go ahead an attempt the i/o and then check for
; 1089 :     ** an error afterwards.
; 1090 :     */
; 1091 : 
; 1092 :     /* Obtain tape status before backward space... (no choice!) */
; 1093 :     int_scsi_status_update( dev, 0 );

  00016	33 d2		 xor	 edx, edx
  00018	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00020	e8 00 00 00 00	 call	 int_scsi_status_update

; 1094 : 
; 1095 :     /* Unit check if already at start of tape */
; 1096 :     if ( STS_BOT( dev ) )

  00025	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0002d	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00033	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00038	85 c0		 test	 eax, eax
  0003a	74 4c		 je	 SHORT $LN2@bsf_scsita

; 1097 :     {
; 1098 :         dev->eotwarning = 0;

  0003c	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00044	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  0004a	83 e0 df	 and	 eax, -33		; ffffffdfH
  0004d	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00055	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 1099 :         build_senseX(TAPE_BSENSE_LOADPTERR,dev,unitstat,code);

  0005b	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00064	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0006c	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00074	b9 09 00 00 00	 mov	 ecx, 9
  00079	e8 00 00 00 00	 call	 build_senseX

; 1100 :         return -1;

  0007e	b8 ff ff ff ff	 mov	 eax, -1
  00083	e9 aa 02 00 00	 jmp	 $LN1@bsf_scsita
$LN2@bsf_scsita:

; 1101 :     }
; 1102 : 
; 1103 :     /* Attempt the backspace i/o...*/
; 1104 : 
; 1105 :     opblk.mt_op    = MTBSF;

  00088	b8 02 00 00 00	 mov	 eax, 2
  0008d	66 89 84 24 80
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 1106 :     opblk.mt_count = 1;

  00095	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 1107 : 
; 1108 :     rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  000a0	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  000a8	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  000ad	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b5	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  000c1	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 1109 : 
; 1110 :     /* Since we have no idea how many blocks we've skipped over
; 1111 :        (as a result of doing the back-space file), we now have
; 1112 :        no clue as to what the proper current blockid should be.
; 1113 :     */
; 1114 :     dev->blockid = -1;      // (actual position now unknown!)

  000c5	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cd	c7 80 04 10 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+4100], -1 ; ffffffffH

; 1115 : 
; 1116 :     if ( rc >= 0 )

  000d7	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  000dc	7c 28		 jl	 SHORT $LN3@bsf_scsita

; 1117 :     {
; 1118 :         dev->curfilen--;

  000de	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000e6	0f b7 80 02 10
	00 00		 movzx	 eax, WORD PTR [rax+4098]
  000ed	66 ff c8	 dec	 ax
  000f0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000f8	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 1119 :         return 0;

  000ff	33 c0		 xor	 eax, eax
  00101	e9 2c 02 00 00	 jmp	 $LN1@bsf_scsita
$LN3@bsf_scsita:

; 1120 :     }
; 1121 : 
; 1122 :     /* Handle error condition */
; 1123 :     if (!SVF_ENABLED())

  00106	b8 01 00 00 00	 mov	 eax, 1
  0010b	48 6b c0 00	 imul	 rax, rax, 0
  0010f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00117	48 8d 84 01 72
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1394]
  0011f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00124	48 8b c8	 mov	 rcx, rax
  00127	e8 00 00 00 00	 call	 is_tape_feat
  0012c	0f b6 c0	 movzx	 eax, al
  0012f	85 c0		 test	 eax, eax
  00131	75 1f		 jne	 SHORT $LN4@bsf_scsita

; 1124 :         dev->fenced = 1;    // (actual position now unknown!)

  00133	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0013b	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00141	83 c8 01	 or	 eax, 1
  00144	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0014c	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN4@bsf_scsita:

; 1125 : 
; 1126 :     save_errno = errno;

  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00158	8b 00		 mov	 eax, DWORD PTR [rax]
  0015a	89 44 24 7c	 mov	 DWORD PTR save_errno$[rsp], eax

; 1127 :     {
; 1128 :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1129 :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  0015e	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00167	74 12		 je	 SHORT $LN10@bsf_scsita
  00169	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00171	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00175	89 44 24 70	 mov	 DWORD PTR tv143[rsp], eax
  00179	eb 08		 jmp	 SHORT $LN11@bsf_scsita
$LN10@bsf_scsita:
  0017b	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN11@bsf_scsita:
  00183	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0018c	74 14		 je	 SHORT $LN12@bsf_scsita
  0018e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00196	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0019a	d1 f8		 sar	 eax, 1
  0019c	89 44 24 74	 mov	 DWORD PTR tv149[rsp], eax
  001a0	eb 08		 jmp	 SHORT $LN13@bsf_scsita
$LN12@bsf_scsita:
  001a2	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv149[rsp], 0
$LN13@bsf_scsita:
  001aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001b0	8b 08		 mov	 ecx, DWORD PTR [rax]
  001b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001b8	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv132[rsp], rax
  001c0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001c8	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  001cf	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv138[rsp], rcx
  001d7	b9 01 00 00 00	 mov	 ecx, 1
  001dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001e2	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  001ea	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001ef	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169594
  001f6	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169595
  00202	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00207	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv138[rsp]
  0020f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00214	8b 4c 24 70	 mov	 ecx, DWORD PTR tv143[rsp]
  00218	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0021c	8b 4c 24 74	 mov	 ecx, DWORD PTR tv149[rsp]
  00220	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00224	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169596
  0022b	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00230	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169597
  00237	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0023c	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00241	41 b9 03 00 00
	00		 mov	 r9d, 3
  00247	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169598
  0024e	ba 6a 04 00 00	 mov	 edx, 1130		; 0000046aH
  00253	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169599
  0025a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1130 :                 dev->filename, "scsi", "ioctl_tape(MTBSF)", strerror(errno));
; 1131 :     }
; 1132 :     errno = save_errno;

  00260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00266	8b 4c 24 7c	 mov	 ecx, DWORD PTR save_errno$[rsp]
  0026a	89 08		 mov	 DWORD PTR [rax], ecx

; 1133 : 
; 1134 :     if ( STS_NOT_MOUNTED( dev ) )

  0026c	33 d2		 xor	 edx, edx
  0026e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00276	e8 00 00 00 00	 call	 int_scsi_status_mounted
  0027b	85 c0		 test	 eax, eax
  0027d	75 25		 jne	 SHORT $LN5@bsf_scsita

; 1135 :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  0027f	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00288	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00290	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00298	33 c9		 xor	 ecx, ecx
  0029a	e8 00 00 00 00	 call	 build_senseX
  0029f	e9 89 00 00 00	 jmp	 $LN6@bsf_scsita
$LN5@bsf_scsita:

; 1136 :     else
; 1137 :     {
; 1138 :         if ( EIO == errno && STS_BOT(dev) )

  002a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002aa	83 38 05	 cmp	 DWORD PTR [rax], 5
  002ad	75 5b		 jne	 SHORT $LN7@bsf_scsita
  002af	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002b7	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  002bd	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  002c2	85 c0		 test	 eax, eax
  002c4	74 44		 je	 SHORT $LN7@bsf_scsita

; 1139 :         {
; 1140 :             dev->eotwarning = 0;

  002c6	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ce	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  002d4	83 e0 df	 and	 eax, -33		; ffffffdfH
  002d7	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002df	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 1141 :             build_senseX(TAPE_BSENSE_LOADPTERR,dev,unitstat,code);

  002e5	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002ee	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002f6	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002fe	b9 09 00 00 00	 mov	 ecx, 9
  00303	e8 00 00 00 00	 call	 build_senseX

; 1142 :         }

  00308	eb 23		 jmp	 SHORT $LN8@bsf_scsita
$LN7@bsf_scsita:

; 1143 :         else
; 1144 :             build_senseX(TAPE_BSENSE_LOCATEERR,dev,unitstat,code);

  0030a	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00313	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0031b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00323	b9 0e 00 00 00	 mov	 ecx, 14
  00328	e8 00 00 00 00	 call	 build_senseX
$LN8@bsf_scsita:
$LN6@bsf_scsita:

; 1145 :     }
; 1146 : 
; 1147 :     return -1;

  0032d	b8 ff ff ff ff	 mov	 eax, -1
$LN1@bsf_scsita:

; 1148 : 
; 1149 : } /* end function bsf_scsitape */

  00332	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  00339	c3		 ret	 0
bsf_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
save_errno$ = 112
tv135 = 116
tv141 = 120
tv162 = 124
rc$ = 128
opblk$ = 136
tv92 = 144
tv130 = 152
dev$ = 176
unitstat$ = 184
code$ = 192
fsb_scsitape PROC

; 743  : {

$LN18:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 744  : int  rc;
; 745  : int  save_errno;
; 746  : struct mtop opblk;
; 747  : 
; 748  :     /* Forward space block on SCSI tape */
; 749  : 
; 750  :     opblk.mt_op    = MTFSR;

  00016	b8 03 00 00 00	 mov	 eax, 3
  0001b	66 89 84 24 88
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 751  :     opblk.mt_count = 1;

  00023	c7 84 24 8c 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 752  : 
; 753  :     rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  0002e	4c 8d 84 24 88
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  00036	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  0003b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0004f	89 84 24 80 00
	00 00		 mov	 DWORD PTR rc$[rsp], eax

; 754  : 
; 755  :     if ( rc >= 0 )

  00056	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR rc$[rsp], 0
  0005e	7c 28		 jl	 SHORT $LN4@fsb_scsita

; 756  :     {
; 757  :         dev->blockid++;

  00060	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00068	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  0006e	ff c0		 inc	 eax
  00070	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00078	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax

; 758  :         /* Return +1 to indicate forward space successful */
; 759  :         return +1;

  0007e	b8 01 00 00 00	 mov	 eax, 1
  00083	e9 ae 02 00 00	 jmp	 $LN1@fsb_scsita
$LN4@fsb_scsita:

; 760  :     }
; 761  : 
; 762  :     /* Check for spacing over a tapemark... */
; 763  : 
; 764  :     save_errno = errno;

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008e	8b 00		 mov	 eax, DWORD PTR [rax]
  00090	89 44 24 70	 mov	 DWORD PTR save_errno$[rsp], eax

; 765  :     {
; 766  :         int_scsi_status_update( dev, 0 );

  00094	33 d2		 xor	 edx, edx
  00096	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0009e	e8 00 00 00 00	 call	 int_scsi_status_update

; 767  :     }
; 768  :     errno = save_errno;

  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a9	8b 4c 24 70	 mov	 ecx, DWORD PTR save_errno$[rsp]
  000ad	89 08		 mov	 DWORD PTR [rax], ecx

; 769  : 
; 770  :     // PROGRAMMING NOTE: please see the "Programming Note" in the
; 771  :     // 'bsb_scsitape' function regarding usage of the 'EOF' status
; 772  :     // to detect spacing over tapemarks.
; 773  : 
; 774  :     if ( EIO == errno && STS_EOF(dev) ) // (fwd-spaced over tapemark?)

  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b5	83 38 05	 cmp	 DWORD PTR [rax], 5
  000b8	75 5d		 jne	 SHORT $LN5@fsb_scsita
  000ba	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c2	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  000c8	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  000cd	85 c0		 test	 eax, eax
  000cf	74 46		 je	 SHORT $LN5@fsb_scsita

; 775  :     {
; 776  :         dev->curfilen++;

  000d1	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d9	0f b7 80 02 10
	00 00		 movzx	 eax, WORD PTR [rax+4098]
  000e0	66 ff c0	 inc	 ax
  000e3	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000eb	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 777  :         dev->blockid++;

  000f2	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fa	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  00100	ff c0		 inc	 eax
  00102	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010a	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax

; 778  :         /* Return 0 to indicate tapemark was spaced over */
; 779  :         return 0;

  00110	33 c0		 xor	 eax, eax
  00112	e9 1f 02 00 00	 jmp	 $LN1@fsb_scsita
$LN5@fsb_scsita:

; 780  :     }
; 781  : 
; 782  :     /* Bonafide forward space block error ... */
; 783  : 
; 784  :     save_errno = errno;

  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0011d	8b 00		 mov	 eax, DWORD PTR [rax]
  0011f	89 44 24 70	 mov	 DWORD PTR save_errno$[rsp], eax

; 785  :     {
; 786  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 787  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  00123	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0012c	74 12		 je	 SHORT $LN14@fsb_scsita
  0012e	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00136	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0013a	89 44 24 74	 mov	 DWORD PTR tv135[rsp], eax
  0013e	eb 08		 jmp	 SHORT $LN15@fsb_scsita
$LN14@fsb_scsita:
  00140	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN15@fsb_scsita:
  00148	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00151	74 14		 je	 SHORT $LN16@fsb_scsita
  00153	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0015b	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0015f	d1 f8		 sar	 eax, 1
  00161	89 44 24 78	 mov	 DWORD PTR tv141[rsp], eax
  00165	eb 08		 jmp	 SHORT $LN17@fsb_scsita
$LN16@fsb_scsita:
  00167	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN17@fsb_scsita:
  0016f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00175	8b 08		 mov	 ecx, DWORD PTR [rax]
  00177	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0017d	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00185	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00194	48 89 8c 24 98
	00 00 00	 mov	 QWORD PTR tv130[rsp], rcx
  0019c	b9 01 00 00 00	 mov	 ecx, 1
  001a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001a7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  001af	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001b4	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169502
  001bb	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001c0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169503
  001c7	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001cc	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv130[rsp]
  001d4	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001d9	8b 4c 24 74	 mov	 ecx, DWORD PTR tv135[rsp]
  001dd	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001e1	8b 4c 24 78	 mov	 ecx, DWORD PTR tv141[rsp]
  001e5	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169504
  001f0	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001f5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169505
  001fc	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00201	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00206	41 b9 03 00 00
	00		 mov	 r9d, 3
  0020c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169506
  00213	ba 14 03 00 00	 mov	 edx, 788		; 00000314H
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169507
  0021f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 788  :                 dev->filename, "scsi", "ioctl_tape(MTFSR)", strerror(errno));
; 789  :     }
; 790  :     errno = save_errno;

  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0022b	8b 4c 24 70	 mov	 ecx, DWORD PTR save_errno$[rsp]
  0022f	89 08		 mov	 DWORD PTR [rax], ecx

; 791  : 
; 792  :     if ( STS_NOT_MOUNTED( dev ) )

  00231	33 d2		 xor	 edx, edx
  00233	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0023b	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00240	85 c0		 test	 eax, eax
  00242	75 25		 jne	 SHORT $LN6@fsb_scsita

; 793  :     {
; 794  :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  00244	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  0024d	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00255	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0025d	33 c9		 xor	 ecx, ecx
  0025f	e8 00 00 00 00	 call	 build_senseX

; 795  :     }

  00264	e9 c8 00 00 00	 jmp	 $LN7@fsb_scsita
$LN6@fsb_scsita:

; 796  :     else
; 797  :     {
; 798  :         switch(errno)

  00269	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0026f	8b 00		 mov	 eax, DWORD PTR [rax]
  00271	89 44 24 7c	 mov	 DWORD PTR tv162[rsp], eax
  00275	83 7c 24 7c 05	 cmp	 DWORD PTR tv162[rsp], 5
  0027a	74 0c		 je	 SHORT $LN8@fsb_scsita
  0027c	83 7c 24 7c 1c	 cmp	 DWORD PTR tv162[rsp], 28
  00281	74 66		 je	 SHORT $LN11@fsb_scsita
  00283	e9 86 00 00 00	 jmp	 $LN12@fsb_scsita
$LN8@fsb_scsita:

; 799  :         {
; 800  :         case EIO:
; 801  :             if(STS_EOT(dev))

  00288	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00290	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00296	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  0029b	85 c0		 test	 eax, eax
  0029d	74 25		 je	 SHORT $LN9@fsb_scsita

; 802  :                 build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  0029f	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002a8	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002b0	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002b8	b9 08 00 00 00	 mov	 ecx, 8
  002bd	e8 00 00 00 00	 call	 build_senseX
  002c2	eb 23		 jmp	 SHORT $LN10@fsb_scsita
$LN9@fsb_scsita:

; 803  :             else
; 804  :                 build_senseX(TAPE_BSENSE_READFAIL,dev,unitstat,code);

  002c4	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002cd	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002d5	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002dd	b9 02 00 00 00	 mov	 ecx, 2
  002e2	e8 00 00 00 00	 call	 build_senseX
$LN10@fsb_scsita:

; 805  :             break;

  002e7	eb 48		 jmp	 SHORT $LN2@fsb_scsita
$LN11@fsb_scsita:

; 806  :         case ENOSPC:
; 807  :             build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  002e9	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002f2	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002fa	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00302	b9 08 00 00 00	 mov	 ecx, 8
  00307	e8 00 00 00 00	 call	 build_senseX

; 808  :             break;

  0030c	eb 23		 jmp	 SHORT $LN2@fsb_scsita
$LN12@fsb_scsita:

; 809  :         default:
; 810  :             build_senseX(TAPE_BSENSE_ITFERROR,dev,unitstat,code);

  0030e	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00317	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0031f	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00327	b9 12 00 00 00	 mov	 ecx, 18
  0032c	e8 00 00 00 00	 call	 build_senseX
$LN2@fsb_scsita:
$LN7@fsb_scsita:

; 811  :             break;
; 812  :         }
; 813  :     }
; 814  : 
; 815  :     return -1;

  00331	b8 ff ff ff ff	 mov	 eax, -1
$LN1@fsb_scsita:

; 816  : 
; 817  : } /* end function fsb_scsitape */

  00336	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0033d	c3		 ret	 0
fsb_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
save_errno$ = 112
tv155 = 116
tv161 = 120
rc$ = 124
opblk$ = 128
tv144 = 136
tv150 = 144
starting_mtget$ = 152
__$ArrayPad$ = 184
dev$ = 224
unitstat$ = 232
code$ = 240
bsb_scsitape PROC

; 828  : {

$LN15:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	56		 push	 rsi
  00010	57		 push	 rdi
  00011	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 84 24 b8
	00 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 829  : int  rc;
; 830  : int  save_errno;
; 831  : struct mtop opblk;
; 832  : struct mtget starting_mtget;
; 833  : 
; 834  :     /* PROGRAMMING NOTE: There is currently no way to distinguish
; 835  :     ** between a "normal" backspace-block error and a "backspaced-
; 836  :     ** into-loadpoint" i/o error, since the only error indication
; 837  :     ** we get [in response to a backspace block attempt] is simply
; 838  :     ** 'EIO'. (Interrogating the status AFTER the fact (to see if
; 839  :     ** we're positioned at loadpoint) doesn't tell us whether we
; 840  :     ** were already positioned at loadpoint *before* the error was
; 841  :     ** was encountered or whether we're only positioned at load-
; 842  :     ** point because we *did* in fact backspace over the very first
; 843  :     ** block on the tape (and are thus now, after the fact, sitting
; 844  :     ** at loadpoint because we *did* backspace over a block but it
; 845  :     ** just got an error for some reason).
; 846  :     **
; 847  :     ** Thus, we have absolutely no choice here but to retrieve the
; 848  :     ** status BEFORE we attempt the i/o to see if we're ALREADY at
; 849  :     ** loadpoint. If we are, then we immediately return an error
; 850  :     ** ("backspaced-into-loadpoint") *without* even attemting the
; 851  :     ** i/o at all. If we're *not* already sitting at loadpoint how-
; 852  :     ** ever, then we go ahead an attempt the i/o and then check for
; 853  :     ** an error afterwards.
; 854  :     */
; 855  : 
; 856  :     /* Obtain tape status before backward space... */
; 857  :     int_scsi_status_update( dev, 0 );

  0002a	33 d2		 xor	 edx, edx
  0002c	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00034	e8 00 00 00 00	 call	 int_scsi_status_update

; 858  : 
; 859  :     /* (save the current status before the i/o in case of error) */
; 860  :     memcpy( &starting_mtget, &dev->mtget, sizeof( struct mtget ) );

  00039	48 8d 84 24 98
	00 00 00	 lea	 rax, QWORD PTR starting_mtget$[rsp]
  00041	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00049	48 8b f8	 mov	 rdi, rax
  0004c	48 8d b1 7c 10
	00 00		 lea	 rsi, QWORD PTR [rcx+4220]
  00053	b9 1c 00 00 00	 mov	 ecx, 28
  00058	f3 a4		 rep movsb

; 861  : 
; 862  :     /* Unit check if already at start of tape */
; 863  :     if ( STS_BOT( dev ) )

  0005a	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00062	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00068	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  0006d	85 c0		 test	 eax, eax
  0006f	74 4c		 je	 SHORT $LN2@bsb_scsita

; 864  :     {
; 865  :         dev->eotwarning = 0;

  00071	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00079	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  0007f	83 e0 df	 and	 eax, -33		; ffffffdfH
  00082	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0008a	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 866  :         build_senseX(TAPE_BSENSE_LOADPTERR,dev,unitstat,code);

  00090	44 0f b6 8c 24
	f0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00099	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  000a1	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  000a9	b9 09 00 00 00	 mov	 ecx, 9
  000ae	e8 00 00 00 00	 call	 build_senseX

; 867  :         return -1;

  000b3	b8 ff ff ff ff	 mov	 eax, -1
  000b8	e9 db 02 00 00	 jmp	 $LN1@bsb_scsita
$LN2@bsb_scsita:

; 868  :     }
; 869  : 
; 870  :     /* Attempt the backspace i/o...*/
; 871  :     opblk.mt_op    = MTBSR;

  000bd	b8 04 00 00 00	 mov	 eax, 4
  000c2	66 89 84 24 80
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 872  :     opblk.mt_count = 1;

  000ca	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 873  : 
; 874  :     rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  000d5	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  000dd	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  000e2	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ea	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  000f6	89 44 24 7c	 mov	 DWORD PTR rc$[rsp], eax

; 875  : 
; 876  :     if ( rc >= 0 )

  000fa	83 7c 24 7c 00	 cmp	 DWORD PTR rc$[rsp], 0
  000ff	7c 28		 jl	 SHORT $LN3@bsb_scsita

; 877  :     {
; 878  :         dev->blockid--;

  00101	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00109	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  0010f	ff c8		 dec	 eax
  00111	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00119	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax

; 879  :         /* Return +1 to indicate backspace successful */
; 880  :         return +1;

  0011f	b8 01 00 00 00	 mov	 eax, 1
  00124	e9 6f 02 00 00	 jmp	 $LN1@bsb_scsita
$LN3@bsb_scsita:

; 881  :     }
; 882  : 
; 883  :     /* Retrieve new status after the [supposed] i/o error... */
; 884  :     save_errno = errno;

  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0012f	8b 00		 mov	 eax, DWORD PTR [rax]
  00131	89 44 24 70	 mov	 DWORD PTR save_errno$[rsp], eax

; 885  :     {
; 886  :         int_scsi_status_update( dev, 0 );

  00135	33 d2		 xor	 edx, edx
  00137	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0013f	e8 00 00 00 00	 call	 int_scsi_status_update

; 887  :     }
; 888  :     errno = save_errno;

  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0014a	8b 4c 24 70	 mov	 ecx, DWORD PTR save_errno$[rsp]
  0014e	89 08		 mov	 DWORD PTR [rax], ecx

; 889  : 
; 890  :     /* Check for backspacing over tapemark... */
; 891  : 
; 892  :     /* PROGRAMMING NOTE: on Windows, our scsi tape driver (w32stape.c)
; 893  :     ** sets 'EOF' status whenever a tapemark is spaced over in EITHER
; 894  :     ** direction (forward OR backward), whereas *nix operating systems
; 895  :     ** do not. They set 'EOF' status only when FORWARD spacing over a
; 896  :     ** tapemark but not when BACKSPACING over one.
; 897  :     **
; 898  :     ** (Apparently the EOF status was actually meant to mean that the
; 899  :     ** tape is "PHYSICALLY POSITIONED PAST [physical] eof" (i.e. past
; 900  :     ** an "eof marker" (i.e. a tapemark)) and nothing more. That is to
; 901  :     ** say, it is apparently NOT meant to mean a tapemark was passed
; 902  :     ** over, but rather only that you're "POSITIONED PAST" a tapemark.)
; 903  :     **
; 904  :     ** Therefore since 'EOF' status will thus *NEVER* be set whenever
; 905  :     ** a tapemark is spaced over in the *BACKWARD* direction [on non-
; 906  :     ** Windows operating systems], we need some other means of distin-
; 907  :     ** guishing between true backspace-block i/o errors and ordinary
; 908  :     ** spacing over a tapemark (which is NOT an i/o error but which
; 909  :     ** *is* an "out of the ordinary" (unit exception) type of event).
; 910  :     **
; 911  :     ** Extensive research on this issue has revealed the *ONLY* semi-
; 912  :     ** reliable means of distinguishing between them is by checking
; 913  :     ** the "file#" and "block#" fields of the status structure after
; 914  :     ** the supposed i/o error. If the file# is one less than it was
; 915  :     ** before and the block# is -1, then a tapemark was simply spaced
; 916  :     ** over. If the file# and block# is anything else however, then
; 917  :     ** the originally reported error was a bonafide i/o error (i.e.
; 918  :     ** the original backspace-block (MTBSR) actually *failed*).
; 919  :     **
; 920  :     ** I say "semi-reliable" because comments seem to indicate that
; 921  :     ** the "file#" and "block#" fields of the mtget status structure
; 922  :     ** "are not always used". The best that I can tell however, is
; 923  :     ** most *nix operating systems *do* seem to maintain them. Thus,
; 924  :     ** for now, we're going to rely on their accuracy since without
; 925  :     ** them there's really no way whatsoever to distingish between
; 926  :     ** a normal backspacing over a tapemark unit exception condition
; 927  :     ** and a bonafide i/o error (other than doing our own SCSI i/o
; 928  :     ** of course (which we don't support (yet))). -- Fish, May 2008
; 929  :     */
; 930  :     if ( EIO == errno )

  00150	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00156	83 38 05	 cmp	 DWORD PTR [rax], 5
  00159	75 5d		 jne	 SHORT $LN4@bsb_scsita

; 931  :     {
; 932  : #if defined( _MSVC_ )
; 933  : 
; 934  :         /* Windows always sets 'EOF' status whenever a tapemark is
; 935  :            spaced over in EITHER direction (forward OR backward) */
; 936  : 
; 937  :         if ( STS_EOF(dev) )     /* (passed over tapemark?) */

  0015b	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00163	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00169	25 00 00 00 80	 and	 eax, -2147483648	; 80000000H
  0016e	85 c0		 test	 eax, eax
  00170	74 46		 je	 SHORT $LN5@bsb_scsita

; 938  : 
; 939  : #else // !defined( _MSVC_ )
; 940  : 
; 941  :         /* Unix-type systems unfortunately do NOT set 'EOF' whenever
; 942  :            backspacing over a tapemark (see PROGRAMMING NOTE above),
; 943  :            so we need to check the status struct's file# and block#
; 944  :            fields instead... */
; 945  : 
; 946  :         /* (passed over tapemark?) */
; 947  :         if (1
; 948  :             && dev->mtget.mt_fileno == (starting_mtget.mt_fileno - 1)
; 949  :             && dev->mtget.mt_blkno == -1
; 950  :         )
; 951  : #endif // defined( _MSVC_ )
; 952  :         {
; 953  :             dev->curfilen--;

  00172	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017a	0f b7 80 02 10
	00 00		 movzx	 eax, WORD PTR [rax+4098]
  00181	66 ff c8	 dec	 ax
  00184	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018c	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 954  :             dev->blockid--;

  00193	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019b	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  001a1	ff c8		 dec	 eax
  001a3	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001ab	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax

; 955  :             /* Return 0 to indicate tapemark was spaced over */
; 956  :             return 0;

  001b1	33 c0		 xor	 eax, eax
  001b3	e9 e0 01 00 00	 jmp	 $LN1@bsb_scsita
$LN5@bsb_scsita:
$LN4@bsb_scsita:

; 957  :         }
; 958  :     }
; 959  : 
; 960  :     /* Bonafide backspace block i/o error ... */
; 961  :     save_errno = errno;

  001b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  001be	8b 00		 mov	 eax, DWORD PTR [rax]
  001c0	89 44 24 70	 mov	 DWORD PTR save_errno$[rsp], eax

; 962  :     {
; 963  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 964  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  001c4	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001cd	74 12		 je	 SHORT $LN11@bsb_scsita
  001cf	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d7	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001db	89 44 24 74	 mov	 DWORD PTR tv155[rsp], eax
  001df	eb 08		 jmp	 SHORT $LN12@bsb_scsita
$LN11@bsb_scsita:
  001e1	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv155[rsp], 0
$LN12@bsb_scsita:
  001e9	48 83 bc 24 e0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001f2	74 14		 je	 SHORT $LN13@bsb_scsita
  001f4	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001fc	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00200	d1 f8		 sar	 eax, 1
  00202	89 44 24 78	 mov	 DWORD PTR tv161[rsp], eax
  00206	eb 08		 jmp	 SHORT $LN14@bsb_scsita
$LN13@bsb_scsita:
  00208	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv161[rsp], 0
$LN14@bsb_scsita:
  00210	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00216	8b 08		 mov	 ecx, DWORD PTR [rax]
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0021e	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv144[rsp], rax
  00226	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022e	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00235	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv150[rsp], rcx
  0023d	b9 01 00 00 00	 mov	 ecx, 1
  00242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00248	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv144[rsp]
  00250	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00255	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169534
  0025c	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00261	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169535
  00268	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0026d	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv150[rsp]
  00275	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0027a	8b 4c 24 74	 mov	 ecx, DWORD PTR tv155[rsp]
  0027e	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00282	8b 4c 24 78	 mov	 ecx, DWORD PTR tv161[rsp]
  00286	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0028a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169536
  00291	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00296	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169537
  0029d	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  002a2	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a7	41 b9 03 00 00
	00		 mov	 r9d, 3
  002ad	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169538
  002b4	ba c5 03 00 00	 mov	 edx, 965		; 000003c5H
  002b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169539
  002c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 965  :                 dev->filename, "scsi", "ioctl_tape(MTBSR)", strerror(errno));
; 966  :     }
; 967  :     errno = save_errno;

  002c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002cc	8b 4c 24 70	 mov	 ecx, DWORD PTR save_errno$[rsp]
  002d0	89 08		 mov	 DWORD PTR [rax], ecx

; 968  : 
; 969  :     if ( STS_NOT_MOUNTED( dev ) )

  002d2	33 d2		 xor	 edx, edx
  002d4	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002dc	e8 00 00 00 00	 call	 int_scsi_status_mounted
  002e1	85 c0		 test	 eax, eax
  002e3	75 25		 jne	 SHORT $LN6@bsb_scsita

; 970  :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  002e5	44 0f b6 8c 24
	f0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002ee	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002f6	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002fe	33 c9		 xor	 ecx, ecx
  00300	e8 00 00 00 00	 call	 build_senseX
  00305	e9 89 00 00 00	 jmp	 $LN7@bsb_scsita
$LN6@bsb_scsita:

; 971  :     else
; 972  :     {
; 973  :         if ( EIO == errno && STS_BOT(dev) )

  0030a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00310	83 38 05	 cmp	 DWORD PTR [rax], 5
  00313	75 5b		 jne	 SHORT $LN8@bsb_scsita
  00315	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0031d	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00323	25 00 00 00 40	 and	 eax, 1073741824		; 40000000H
  00328	85 c0		 test	 eax, eax
  0032a	74 44		 je	 SHORT $LN8@bsb_scsita

; 974  :         {
; 975  :             dev->eotwarning = 0;

  0032c	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00334	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  0033a	83 e0 df	 and	 eax, -33		; ffffffdfH
  0033d	48 8b 8c 24 e0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00345	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 976  :             build_senseX(TAPE_BSENSE_LOADPTERR,dev,unitstat,code);

  0034b	44 0f b6 8c 24
	f0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00354	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0035c	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00364	b9 09 00 00 00	 mov	 ecx, 9
  00369	e8 00 00 00 00	 call	 build_senseX

; 977  :         }

  0036e	eb 23		 jmp	 SHORT $LN9@bsb_scsita
$LN8@bsb_scsita:

; 978  :         else
; 979  :             build_senseX(TAPE_BSENSE_LOCATEERR,dev,unitstat,code);

  00370	44 0f b6 8c 24
	f0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00379	4c 8b 84 24 e8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00381	48 8b 94 24 e0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00389	b9 0e 00 00 00	 mov	 ecx, 14
  0038e	e8 00 00 00 00	 call	 build_senseX
$LN9@bsb_scsita:
$LN7@bsb_scsita:

; 980  :     }
; 981  : 
; 982  :     return -1;

  00393	b8 ff ff ff ff	 mov	 eax, -1
$LN1@bsb_scsita:

; 983  : 
; 984  : } /* end function bsb_scsitape */

  00398	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  003a0	48 33 cc	 xor	 rcx, rsp
  003a3	e8 00 00 00 00	 call	 __security_check_cookie
  003a8	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003af	5f		 pop	 rdi
  003b0	5e		 pop	 rsi
  003b1	c3		 ret	 0
bsb_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
tv135 = 112
tv141 = 116
rc$ = 120
opblk$ = 128
tv92 = 136
tv130 = 144
dev$ = 176
unitstat$ = 184
code$ = 192
rewind_scsitape PROC

; 1155 : {

$LN11:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 1156 : int rc;
; 1157 : /* int  save_errno; */
; 1158 : struct mtop opblk;
; 1159 : 
; 1160 : //  opblk.mt_op    = MTLOAD;    // (not sure which is more correct)
; 1161 :     opblk.mt_op    = MTREW;

  00016	b8 06 00 00 00	 mov	 eax, 6
  0001b	66 89 84 24 80
	00 00 00	 mov	 WORD PTR opblk$[rsp], ax

; 1162 :     opblk.mt_count = 1;

  00023	c7 84 24 84 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$[rsp+4], 1

; 1163 : 
; 1164 :     rc = ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  0002e	4c 8d 84 24 80
	00 00 00	 lea	 r8, QWORD PTR opblk$[rsp]
  00036	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  0003b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00043	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  0004f	89 44 24 78	 mov	 DWORD PTR rc$[rsp], eax

; 1165 : 
; 1166 :     if ( rc >= 0 )

  00053	83 7c 24 78 00	 cmp	 DWORD PTR rc$[rsp], 0
  00058	7c 69		 jl	 SHORT $LN2@rewind_scs

; 1167 :     {
; 1168 :         dev->sstat |= GMT_BOT( -1 );  // (forced)

  0005a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00062	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00068	0f ba e8 1e	 bts	 eax, 30
  0006c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00074	89 81 88 10 00
	00		 mov	 DWORD PTR [rcx+4232], eax

; 1169 :         dev->blockid = 0;

  0007a	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00082	c7 80 04 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4100], 0

; 1170 :         dev->curfilen = 0;

  0008c	33 c0		 xor	 eax, eax
  0008e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00096	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 1171 :         dev->fenced = 0;

  0009d	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a5	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  000ab	83 e0 fe	 and	 eax, -2			; fffffffeH
  000ae	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000b6	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 1172 :         return 0;

  000bc	33 c0		 xor	 eax, eax
  000be	e9 d1 01 00 00	 jmp	 $LN1@rewind_scs
$LN2@rewind_scs:

; 1173 :     }
; 1174 : 
; 1175 :     if (!SVF_ENABLED())

  000c3	b8 01 00 00 00	 mov	 eax, 1
  000c8	48 6b c0 00	 imul	 rax, rax, 0
  000cc	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000d4	48 8d 84 01 72
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1394]
  000dc	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  000e1	48 8b c8	 mov	 rcx, rax
  000e4	e8 00 00 00 00	 call	 is_tape_feat
  000e9	0f b6 c0	 movzx	 eax, al
  000ec	85 c0		 test	 eax, eax
  000ee	75 1f		 jne	 SHORT $LN3@rewind_scs

; 1176 :         dev->fenced = 1;    // (because the rewind failed)

  000f0	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000f8	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  000fe	83 c8 01	 or	 eax, 1
  00101	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00109	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN3@rewind_scs:

; 1177 :     dev->blockid  = -1;     // (because the rewind failed)

  0010f	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00117	c7 80 04 10 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+4100], -1 ; ffffffffH

; 1178 :     dev->curfilen = -1;     // (because the rewind failed)

  00121	b8 ff ff 00 00	 mov	 eax, 65535		; 0000ffffH
  00126	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012e	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 1179 : 
; 1180 :     // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 1181 :     WRMSG (HHC00205, "E", LCSS_DEVNUM,

  00135	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0013e	74 12		 je	 SHORT $LN7@rewind_scs
  00140	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00148	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0014c	89 44 24 70	 mov	 DWORD PTR tv135[rsp], eax
  00150	eb 08		 jmp	 SHORT $LN8@rewind_scs
$LN7@rewind_scs:
  00152	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv135[rsp], 0
$LN8@rewind_scs:
  0015a	48 83 bc 24 b0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00163	74 14		 je	 SHORT $LN9@rewind_scs
  00165	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0016d	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00171	d1 f8		 sar	 eax, 1
  00173	89 44 24 74	 mov	 DWORD PTR tv141[rsp], eax
  00177	eb 08		 jmp	 SHORT $LN10@rewind_scs
$LN9@rewind_scs:
  00179	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN10@rewind_scs:
  00181	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00187	8b 08		 mov	 ecx, DWORD PTR [rax]
  00189	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0018f	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv92[rsp], rax
  00197	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0019f	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  001a6	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv130[rsp], rcx
  001ae	b9 01 00 00 00	 mov	 ecx, 1
  001b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001b9	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv92[rsp]
  001c1	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001c6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169620
  001cd	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001d2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169621
  001d9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001de	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv130[rsp]
  001e6	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001eb	8b 4c 24 70	 mov	 ecx, DWORD PTR tv135[rsp]
  001ef	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001f3	8b 4c 24 74	 mov	 ecx, DWORD PTR tv141[rsp]
  001f7	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001fb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169622
  00202	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00207	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169623
  0020e	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00213	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00218	41 b9 03 00 00
	00		 mov	 r9d, 3
  0021e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169624
  00225	ba 9e 04 00 00	 mov	 edx, 1182		; 0000049eH
  0022a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169625
  00231	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 1182 :             dev->filename, "scsi", "ioctl_tape(MTREW)", strerror(errno));
; 1183 : 
; 1184 :     if ( STS_NOT_MOUNTED( dev ) )

  00237	33 d2		 xor	 edx, edx
  00239	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00241	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00246	85 c0		 test	 eax, eax
  00248	75 22		 jne	 SHORT $LN4@rewind_scs

; 1185 :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  0024a	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00253	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0025b	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00263	33 c9		 xor	 ecx, ecx
  00265	e8 00 00 00 00	 call	 build_senseX
  0026a	eb 23		 jmp	 SHORT $LN5@rewind_scs
$LN4@rewind_scs:

; 1186 :     else
; 1187 :         build_senseX(TAPE_BSENSE_REWINDFAILED,dev,unitstat,code);

  0026c	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00275	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0027d	48 8b 94 24 b0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00285	b9 13 00 00 00	 mov	 ecx, 19
  0028a	e8 00 00 00 00	 call	 build_senseX
$LN5@rewind_scs:

; 1188 : 
; 1189 :     return -1;

  0028f	b8 ff ff ff ff	 mov	 eax, -1
$LN1@rewind_scs:

; 1190 : 
; 1191 : } /* end function rewind_scsitape */

  00294	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  0029b	c3		 ret	 0
rewind_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 112
tv144 = 116
tv150 = 120
save_errno$ = 124
tv133 = 128
tv139 = 136
dev$ = 160
buf$ = 168
len$ = 176
unitstat$ = 184
code$ = 192
write_scsitape PROC

; 439  : {

$LN17:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 440  : int  rc;
; 441  : int  save_errno;
; 442  : 
; 443  :     /* Write data block to SCSI tape device */
; 444  : 
; 445  :     rc = write_tape (dev->fd, buf, len);

  0001b	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00022	44 8b c0	 mov	 r8d, eax
  00025	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  0002d	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00035	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_write_tape
  00041	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 446  : 
; 447  : #if defined( _MSVC_ )
; 448  :     if (errno == ENOSPC)

  00045	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0004b	83 38 1c	 cmp	 DWORD PTR [rax], 28
  0004e	75 1f		 jne	 SHORT $LN2@write_scsi

; 449  :         dev->eotwarning = 1;

  00050	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00058	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  0005e	83 c8 20	 or	 eax, 32			; 00000020H
  00061	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00069	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax
$LN2@write_scsi:

; 450  : #endif
; 451  : 
; 452  :     if (rc >= (int)len)

  0006f	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  00076	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  0007a	7c 25		 jl	 SHORT $LN3@write_scsi

; 453  :     {
; 454  :         dev->blockid++;

  0007c	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00084	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  0008a	ff c0		 inc	 eax
  0008c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00094	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax

; 455  :         return 0;

  0009a	33 c0		 xor	 eax, eax
  0009c	e9 8e 02 00 00	 jmp	 $LN1@write_scsi
$LN3@write_scsi:

; 456  :     }
; 457  : 
; 458  :     /*         LINUX EOM BEHAVIOUR WHEN WRITING
; 459  : 
; 460  :       When the end of medium early warning is encountered,
; 461  :       the current write is finished and the number of bytes
; 462  :       is returned. The next write returns -1 and errno is
; 463  :       set to ENOSPC. To enable writing a trailer, the next
; 464  :       write is allowed to proceed and, if successful, the
; 465  :       number of bytes is returned. After this, -1 and the
; 466  :       number of bytes are alternately returned until the
; 467  :       physical end of medium (or some other error) occurs.
; 468  :     */
; 469  : 
; 470  :     if (errno == ENOSPC)

  000a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000a7	83 38 1c	 cmp	 DWORD PTR [rax], 28
  000aa	0f 85 8a 00 00
	00		 jne	 $LN4@write_scsi

; 471  :     {
; 472  :         int_scsi_status_update( dev, 0 );

  000b0	33 d2		 xor	 edx, edx
  000b2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  000ba	e8 00 00 00 00	 call	 int_scsi_status_update

; 473  : 
; 474  :         rc = write_tape (dev->fd, buf, len);

  000bf	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000c6	44 8b c0	 mov	 r8d, eax
  000c9	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  000d1	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d9	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_write_tape
  000e5	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 475  : 
; 476  :         if (rc >= (int)len)

  000e9	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR len$[rsp]
  000f0	39 44 24 70	 cmp	 DWORD PTR rc$[rsp], eax
  000f4	7c 44		 jl	 SHORT $LN5@write_scsi

; 477  :         {
; 478  :             dev->eotwarning = 1;

  000f6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000fe	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  00104	83 c8 20	 or	 eax, 32			; 00000020H
  00107	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010f	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 479  :             dev->blockid++;

  00115	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0011d	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  00123	ff c0		 inc	 eax
  00125	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0012d	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax

; 480  :             return 0;

  00133	33 c0		 xor	 eax, eax
  00135	e9 f5 01 00 00	 jmp	 $LN1@write_scsi
$LN5@write_scsi:
$LN4@write_scsi:

; 481  :         }
; 482  :     }
; 483  : 
; 484  :     /* Handle write error condition... */
; 485  : 
; 486  :     save_errno = errno;

  0013a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00140	8b 00		 mov	 eax, DWORD PTR [rax]
  00142	89 44 24 7c	 mov	 DWORD PTR save_errno$[rsp], eax

; 487  :     {
; 488  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 489  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  00146	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0014f	74 12		 je	 SHORT $LN13@write_scsi
  00151	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00159	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  0015d	89 44 24 74	 mov	 DWORD PTR tv144[rsp], eax
  00161	eb 08		 jmp	 SHORT $LN14@write_scsi
$LN13@write_scsi:
  00163	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv144[rsp], 0
$LN14@write_scsi:
  0016b	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00174	74 14		 je	 SHORT $LN15@write_scsi
  00176	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0017e	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  00182	d1 f8		 sar	 eax, 1
  00184	89 44 24 78	 mov	 DWORD PTR tv150[rsp], eax
  00188	eb 08		 jmp	 SHORT $LN16@write_scsi
$LN15@write_scsi:
  0018a	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv150[rsp], 0
$LN16@write_scsi:
  00192	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00198	8b 08		 mov	 ecx, DWORD PTR [rax]
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  001a0	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv133[rsp], rax
  001a8	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001b0	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  001b7	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv139[rsp], rcx
  001bf	b9 01 00 00 00	 mov	 ecx, 1
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  001ca	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv133[rsp]
  001d2	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  001d7	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169401
  001de	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001e3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169402
  001ea	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001ef	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv139[rsp]
  001f7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001fc	8b 4c 24 74	 mov	 ecx, DWORD PTR tv144[rsp]
  00200	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00204	8b 4c 24 78	 mov	 ecx, DWORD PTR tv150[rsp]
  00208	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  0020c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169403
  00213	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00218	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169404
  0021f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00224	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00229	41 b9 03 00 00
	00		 mov	 r9d, 3
  0022f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169405
  00236	ba ea 01 00 00	 mov	 edx, 490		; 000001eaH
  0023b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169406
  00242	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 490  :                 dev->filename, "scsi", "write_tape()", strerror(errno));
; 491  : 
; 492  :         int_scsi_status_update( dev, 0 );

  00248	33 d2		 xor	 edx, edx
  0024a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00252	e8 00 00 00 00	 call	 int_scsi_status_update

; 493  :     }
; 494  :     errno = save_errno;

  00257	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0025d	8b 4c 24 7c	 mov	 ecx, DWORD PTR save_errno$[rsp]
  00261	89 08		 mov	 DWORD PTR [rax], ecx

; 495  : 
; 496  :     if ( STS_NOT_MOUNTED( dev ) )

  00263	33 d2		 xor	 edx, edx
  00265	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0026d	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00272	85 c0		 test	 eax, eax
  00274	75 25		 jne	 SHORT $LN6@write_scsi

; 497  :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  00276	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  0027f	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00287	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0028f	33 c9		 xor	 ecx, ecx
  00291	e8 00 00 00 00	 call	 build_senseX
  00296	e9 8f 00 00 00	 jmp	 $LN7@write_scsi
$LN6@write_scsi:

; 498  :     else
; 499  :     {
; 500  :         if (errno == EIO)

  0029b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002a1	83 38 05	 cmp	 DWORD PTR [rax], 5
  002a4	75 61		 jne	 SHORT $LN8@write_scsi

; 501  :         {
; 502  :             if(STS_EOT(dev))

  002a6	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002ae	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  002b4	25 00 00 00 20	 and	 eax, 536870912		; 20000000H
  002b9	85 c0		 test	 eax, eax
  002bb	74 25		 je	 SHORT $LN10@write_scsi

; 503  :                 build_senseX(TAPE_BSENSE_ENDOFTAPE,dev,unitstat,code);

  002bd	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002c6	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002ce	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002d6	b9 08 00 00 00	 mov	 ecx, 8
  002db	e8 00 00 00 00	 call	 build_senseX
  002e0	eb 23		 jmp	 SHORT $LN11@write_scsi
$LN10@write_scsi:

; 504  :             else
; 505  :                 build_senseX(TAPE_BSENSE_WRITEFAIL,dev,unitstat,code);

  002e2	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002eb	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002f3	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002fb	b9 03 00 00 00	 mov	 ecx, 3
  00300	e8 00 00 00 00	 call	 build_senseX
$LN11@write_scsi:

; 506  :         }

  00305	eb 23		 jmp	 SHORT $LN9@write_scsi
$LN8@write_scsi:

; 507  :         else
; 508  :             build_senseX(TAPE_BSENSE_ITFERROR,dev,unitstat,code);

  00307	44 0f b6 8c 24
	c0 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00310	4c 8b 84 24 b8
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00318	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00320	b9 12 00 00 00	 mov	 ecx, 18
  00325	e8 00 00 00 00	 call	 build_senseX
$LN9@write_scsi:
$LN7@write_scsi:

; 509  :     }
; 510  : 
; 511  :     return -1;

  0032a	b8 ff ff ff ff	 mov	 eax, -1
$LN1@write_scsi:

; 512  : 
; 513  : } /* end function write_scsitape */

  0032f	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00336	c3		 ret	 0
write_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 112
tv93 = 116
tv131 = 120
tv82 = 128
tv88 = 136
dev$ = 160
buf$ = 168
unitstat$ = 176
code$ = 184
read_scsitape PROC

; 399  : {

$LN11:
  00000	44 88 4c 24 20	 mov	 BYTE PTR [rsp+32], r9b
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 400  : int  rc;
; 401  : 
; 402  :     rc = read_tape( dev->fd, buf, dev->bufsize );

  0001b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00023	48 63 80 d8 01
	00 00		 movsxd	 rax, DWORD PTR [rax+472]
  0002a	4c 8b c0	 mov	 r8, rax
  0002d	48 8b 94 24 a8
	00 00 00	 mov	 rdx, QWORD PTR buf$[rsp]
  00035	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0003d	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_read_tape
  00049	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 403  : 
; 404  :     if (rc >= 0)

  0004d	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00052	7c 4f		 jl	 SHORT $LN2@read_scsit

; 405  :     {
; 406  :         dev->blockid++;

  00054	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0005c	8b 80 04 10 00
	00		 mov	 eax, DWORD PTR [rax+4100]
  00062	ff c0		 inc	 eax
  00064	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0006c	89 81 04 10 00
	00		 mov	 DWORD PTR [rcx+4100], eax

; 407  : 
; 408  :         /* Increment current file number if tapemark was read */
; 409  :         if (rc == 0)

  00072	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00077	75 21		 jne	 SHORT $LN3@read_scsit

; 410  :             dev->curfilen++;

  00079	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00081	0f b7 80 02 10
	00 00		 movzx	 eax, WORD PTR [rax+4098]
  00088	66 ff c0	 inc	 ax
  0008b	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00093	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax
$LN3@read_scsit:

; 411  : 
; 412  :         /* Return block length or zero if tapemark  */
; 413  :         return rc;

  0009a	8b 44 24 70	 mov	 eax, DWORD PTR rc$[rsp]
  0009e	e9 5f 01 00 00	 jmp	 $LN1@read_scsit
$LN2@read_scsit:

; 414  :     }
; 415  : 
; 416  :     /* Handle read error condition */
; 417  : 
; 418  :     // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 419  :     WRMSG (HHC00205, "E", LCSS_DEVNUM,

  000a3	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000ac	74 12		 je	 SHORT $LN7@read_scsit
  000ae	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b6	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  000ba	89 44 24 74	 mov	 DWORD PTR tv93[rsp], eax
  000be	eb 08		 jmp	 SHORT $LN8@read_scsit
$LN7@read_scsit:
  000c0	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv93[rsp], 0
$LN8@read_scsit:
  000c8	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  000d1	74 14		 je	 SHORT $LN9@read_scsit
  000d3	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000db	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  000df	d1 f8		 sar	 eax, 1
  000e1	89 44 24 78	 mov	 DWORD PTR tv131[rsp], eax
  000e5	eb 08		 jmp	 SHORT $LN10@read_scsit
$LN9@read_scsit:
  000e7	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv131[rsp], 0
$LN10@read_scsit:
  000ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f5	8b 08		 mov	 ecx, DWORD PTR [rax]
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  000fd	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR tv82[rsp], rax
  00105	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0010d	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00114	48 89 8c 24 88
	00 00 00	 mov	 QWORD PTR tv88[rsp], rcx
  0011c	b9 01 00 00 00	 mov	 ecx, 1
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00127	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR tv82[rsp]
  0012f	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00134	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169374
  0013b	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  00140	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169375
  00147	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0014c	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv88[rsp]
  00154	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00159	8b 4c 24 74	 mov	 ecx, DWORD PTR tv93[rsp]
  0015d	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00161	8b 4c 24 78	 mov	 ecx, DWORD PTR tv131[rsp]
  00165	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00169	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169376
  00170	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00175	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169377
  0017c	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00181	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00186	41 b9 03 00 00
	00		 mov	 r9d, 3
  0018c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169378
  00193	ba a4 01 00 00	 mov	 edx, 420		; 000001a4H
  00198	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169379
  0019f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 420  :             dev->filename, "scsi", "read_tape()", strerror(errno));
; 421  : 
; 422  :     if ( STS_NOT_MOUNTED( dev ) )

  001a5	33 d2		 xor	 edx, edx
  001a7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  001af	e8 00 00 00 00	 call	 int_scsi_status_mounted
  001b4	85 c0		 test	 eax, eax
  001b6	75 22		 jne	 SHORT $LN4@read_scsit

; 423  :         build_senseX(TAPE_BSENSE_TAPEUNLOADED,dev,unitstat,code);

  001b8	44 0f b6 8c 24
	b8 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  001c1	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  001c9	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001d1	33 c9		 xor	 ecx, ecx
  001d3	e8 00 00 00 00	 call	 build_senseX
  001d8	eb 23		 jmp	 SHORT $LN5@read_scsit
$LN4@read_scsit:

; 424  :     else
; 425  :         build_senseX(TAPE_BSENSE_READFAIL,dev,unitstat,code);

  001da	44 0f b6 8c 24
	b8 00 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  001e3	4c 8b 84 24 b0
	00 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  001eb	48 8b 94 24 a0
	00 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  001f3	b9 02 00 00 00	 mov	 ecx, 2
  001f8	e8 00 00 00 00	 call	 build_senseX
$LN5@read_scsit:

; 426  : 
; 427  :     return -1;

  001fd	b8 ff ff ff ff	 mov	 eax, -1
$LN1@read_scsit:

; 428  : 
; 429  : } /* end function read_scsitape */

  00202	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00209	c3		 ret	 0
read_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 112
tv137 = 116
tv143 = 120
tv166 = 124
tv178 = 128
_EX_Flink$1 = 136
_EX_Blink$2 = 144
_EX_Flink$3 = 152
_EX_Blink$4 = 160
opblk$5 = 168
tv94 = 176
tv132 = 184
dev$ = 208
close_scsitape PROC

; 336  : {

$LN16:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H

; 337  :     int rc = 0;

  0000c	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR rc$[rsp], 0

; 338  : 
; 339  :     obtain_lock( &sysblk.stape_lock );

  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  0001b	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  00021	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169349
  00028	48 8b c8	 mov	 rcx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_obtain_lock

; 340  : 
; 341  :     // Remove drive from SCSIMOUNT thread's work queue...
; 342  : 
; 343  :     if (                     dev->stape_mntdrq.link.Flink) {

  00031	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00039	48 83 b8 c0 10
	00 00 00	 cmp	 QWORD PTR [rax+4288], 0
  00041	74 7b		 je	 SHORT $LN2@close_scsi

; 344  :         RemoveListEntry(    &dev->stape_mntdrq.link );

  00043	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0004b	48 8b 80 c0 10
	00 00		 mov	 rax, QWORD PTR [rax+4288]
  00052	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR _EX_Flink$1[rsp], rax
  0005a	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00062	48 8b 80 c8 10
	00 00		 mov	 rax, QWORD PTR [rax+4296]
  00069	48 89 84 24 90
	00 00 00	 mov	 QWORD PTR _EX_Blink$2[rsp], rax
  00071	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$2[rsp]
  00079	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$1[rsp]
  00081	48 89 08	 mov	 QWORD PTR [rax], rcx
  00084	48 8b 84 24 88
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$1[rsp]
  0008c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$2[rsp]
  00094	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 345  :         InitializeListLink( &dev->stape_mntdrq.link );

  00098	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000a0	48 c7 80 c8 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4296], 0
  000ab	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000b3	48 c7 80 c0 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4288], 0
$LN2@close_scsi:

; 346  :     }
; 347  : 
; 348  :     // Remove drive from the STATUS thread's work queue...
; 349  : 
; 350  :     if (                     dev->stape_statrq.link.Flink) {

  000be	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000c6	48 83 b8 a8 10
	00 00 00	 cmp	 QWORD PTR [rax+4264], 0
  000ce	74 7b		 je	 SHORT $LN3@close_scsi

; 351  :         RemoveListEntry(    &dev->stape_statrq.link );

  000d0	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000d8	48 8b 80 a8 10
	00 00		 mov	 rax, QWORD PTR [rax+4264]
  000df	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR _EX_Flink$3[rsp], rax
  000e7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ef	48 8b 80 b0 10
	00 00		 mov	 rax, QWORD PTR [rax+4272]
  000f6	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR _EX_Blink$4[rsp], rax
  000fe	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR _EX_Blink$4[rsp]
  00106	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR _EX_Flink$3[rsp]
  0010e	48 89 08	 mov	 QWORD PTR [rax], rcx
  00111	48 8b 84 24 98
	00 00 00	 mov	 rax, QWORD PTR _EX_Flink$3[rsp]
  00119	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR _EX_Blink$4[rsp]
  00121	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx

; 352  :         InitializeListLink( &dev->stape_statrq.link );

  00125	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012d	48 c7 80 b0 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4272], 0
  00138	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00140	48 c7 80 a8 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4264], 0
$LN3@close_scsi:

; 353  :     }
; 354  : 
; 355  :     // Close the file if it's open...
; 356  :     if (dev->fd >= 0)

  0014b	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00153	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  0015a	0f 8c d2 01 00
	00		 jl	 $LN4@close_scsi

; 357  :     {
; 358  :         if (dev->stape_close_rewinds)

  00160	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00168	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  0016e	83 e0 01	 and	 eax, 1
  00171	85 c0		 test	 eax, eax
  00173	0f 84 4a 01 00
	00		 je	 $LN5@close_scsi

; 359  :         {
; 360  :             struct mtop opblk;
; 361  : //          opblk.mt_op    = MTLOAD;    // (not sure which is more correct)
; 362  :             opblk.mt_op    = MTREW;

  00179	b8 06 00 00 00	 mov	 eax, 6
  0017e	66 89 84 24 a8
	00 00 00	 mov	 WORD PTR opblk$5[rsp], ax

; 363  :             opblk.mt_count = 1;

  00186	c7 84 24 ac 00
	00 00 01 00 00
	00		 mov	 DWORD PTR opblk$5[rsp+4], 1

; 364  : 
; 365  :             if ((rc = ioctl_tape ( dev->fd, MTIOCTOP, (char*)&opblk)) != 0)

  00191	4c 8d 84 24 a8
	00 00 00	 lea	 r8, QWORD PTR opblk$5[rsp]
  00199	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  0019e	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001a6	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
  001b2	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax
  001b6	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  001bb	0f 84 02 01 00
	00		 je	 $LN6@close_scsi

; 366  :             {
; 367  :                 // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 368  :                 WRMSG (HHC00205, "E", LCSS_DEVNUM,

  001c1	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ca	74 12		 je	 SHORT $LN8@close_scsi
  001cc	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001d4	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001d8	89 44 24 74	 mov	 DWORD PTR tv137[rsp], eax
  001dc	eb 08		 jmp	 SHORT $LN9@close_scsi
$LN8@close_scsi:
  001de	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv137[rsp], 0
$LN9@close_scsi:
  001e6	48 83 bc 24 d0
	00 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001ef	74 14		 je	 SHORT $LN10@close_scsi
  001f1	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001f9	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001fd	d1 f8		 sar	 eax, 1
  001ff	89 44 24 78	 mov	 DWORD PTR tv143[rsp], eax
  00203	eb 08		 jmp	 SHORT $LN11@close_scsi
$LN10@close_scsi:
  00205	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv143[rsp], 0
$LN11@close_scsi:
  0020d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00213	8b 08		 mov	 ecx, DWORD PTR [rax]
  00215	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  0021b	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv94[rsp], rax
  00223	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0022b	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00232	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR tv132[rsp], rcx
  0023a	b9 01 00 00 00	 mov	 ecx, 1
  0023f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00245	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv94[rsp]
  0024d	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00252	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169355
  00259	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0025e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169356
  00265	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  0026a	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv132[rsp]
  00272	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00277	8b 4c 24 74	 mov	 ecx, DWORD PTR tv137[rsp]
  0027b	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0027f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv143[rsp]
  00283	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00287	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169357
  0028e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00293	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169358
  0029a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0029f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  002a4	41 b9 03 00 00
	00		 mov	 r9d, 3
  002aa	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169359
  002b1	ba 71 01 00 00	 mov	 edx, 369		; 00000171H
  002b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169360
  002bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN6@close_scsi:
$LN5@close_scsi:

; 369  :                         dev->filename, "scsi", "ioctl_tape(MTREW)", strerror(errno));
; 370  :             }
; 371  :         }
; 372  : 
; 373  :         // Close tape drive...
; 374  :         close_tape( dev->fd );

  002c3	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002cb	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  002d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_tape

; 375  : 
; 376  :         dev->fd        = -1;

  002d7	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002df	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 377  :         dev->blockid   = -1;

  002e9	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f1	c7 80 04 10 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+4100], -1 ; ffffffffH

; 378  :         dev->curfilen  =  0;

  002fb	33 c0		 xor	 eax, eax
  002fd	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00305	66 89 81 02 10
	00 00		 mov	 WORD PTR [rcx+4098], ax

; 379  :         dev->nxtblkpos =  0;

  0030c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00314	48 c7 80 08 10
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+4104], 0

; 380  :         dev->prvblkpos = -1;

  0031f	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00327	48 c7 80 10 10
	00 00 ff ff ff
	ff		 mov	 QWORD PTR [rax+4112], -1
$LN4@close_scsi:

; 381  :     }
; 382  : 
; 383  :     dev->sstat  = dev->stape_online ? 0 : GMT_DR_OPEN(-1); // (forced)

  00332	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0033a	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  00340	c1 e8 03	 shr	 eax, 3
  00343	83 e0 01	 and	 eax, 1
  00346	85 c0		 test	 eax, eax
  00348	74 0a		 je	 SHORT $LN12@close_scsi
  0034a	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv166[rsp], 0
  00352	eb 08		 jmp	 SHORT $LN13@close_scsi
$LN12@close_scsi:
  00354	c7 44 24 7c 00
	00 04 00	 mov	 DWORD PTR tv166[rsp], 262144 ; 00040000H
$LN13@close_scsi:
  0035c	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00364	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv166[rsp]
  00368	89 88 88 10 00
	00		 mov	 DWORD PTR [rax+4232], ecx

; 384  :     dev->fenced = (rc < 0 && !SVF_ENABLED()) ? 1 : 0;

  0036e	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  00373	7d 3a		 jge	 SHORT $LN14@close_scsi
  00375	b8 01 00 00 00	 mov	 eax, 1
  0037a	48 6b c0 00	 imul	 rax, rax, 0
  0037e	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00386	48 8d 84 01 72
	05 00 00	 lea	 rax, QWORD PTR [rcx+rax+1394]
  0038e	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00393	48 8b c8	 mov	 rcx, rax
  00396	e8 00 00 00 00	 call	 is_tape_feat
  0039b	0f b6 c0	 movzx	 eax, al
  0039e	85 c0		 test	 eax, eax
  003a0	75 0d		 jne	 SHORT $LN14@close_scsi
  003a2	c7 84 24 80 00
	00 00 01 00 00
	00		 mov	 DWORD PTR tv178[rsp], 1
  003ad	eb 0b		 jmp	 SHORT $LN15@close_scsi
$LN14@close_scsi:
  003af	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv178[rsp], 0
$LN15@close_scsi:
  003ba	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR tv178[rsp]
  003c1	83 e0 01	 and	 eax, 1
  003c4	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003cc	8b 89 78 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4216]
  003d2	83 e1 fe	 and	 ecx, -2			; fffffffeH
  003d5	0b c8		 or	 ecx, eax
  003d7	8b c1		 mov	 eax, ecx
  003d9	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e1	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 385  : 
; 386  :     release_lock( &sysblk.stape_lock );

  003e7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_sysblk
  003ee	48 05 70 11 00
	00		 add	 rax, 4464		; 00001170H
  003f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169361
  003fb	48 8b c8	 mov	 rcx, rax
  003fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_hthread_release_lock

; 387  : 
; 388  : } /* end function close_scsitape */

  00404	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  0040b	c3		 ret	 0
close_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
rc$ = 112
tv70 = 116
tv73 = 120
tv94 = 124
tv132 = 128
tv218 = 132
tv224 = 136
oflags$ = 140
save_errno$1 = 144
save_errno$2 = 148
opblk$3 = 152
tv83 = 160
tv89 = 168
tv173 = 176
tv182 = 184
tv207 = 192
tv213 = 200
buffer$4 = 208
__$ArrayPad$ = 592
dev$ = 624
unitstat$ = 632
code$ = 640
finish_scsitape_open PROC

; 244  : {

$LN26:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 60 02
	00 00		 sub	 rsp, 608		; 00000260H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 50
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 245  :     int rc;                             /* Return code               */
; 246  :     int oflags;                         /* re-open flags             */
; 247  : 
; 248  :     /* Switch over to BLOCKING-mode I/O... (without O_NONBLOCK flag) */
; 249  : 
; 250  :     close_tape( dev->fd );

  00029	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00031	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_tape

; 251  :     oflags = O_BINARY | (dev->readonly ? O_RDONLY : O_RDWR);

  0003d	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00045	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  0004b	d1 e8		 shr	 eax, 1
  0004d	83 e0 01	 and	 eax, 1
  00050	85 c0		 test	 eax, eax
  00052	74 0a		 je	 SHORT $LN16@finish_scs
  00054	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  0005c	eb 08		 jmp	 SHORT $LN17@finish_scs
$LN16@finish_scs:
  0005e	c7 44 24 74 02
	00 00 00	 mov	 DWORD PTR tv70[rsp], 2
$LN17@finish_scs:
  00066	8b 44 24 74	 mov	 eax, DWORD PTR tv70[rsp]
  0006a	0f ba e8 0f	 bts	 eax, 15
  0006e	89 84 24 8c 00
	00 00		 mov	 DWORD PTR oflags$[rsp], eax

; 252  : 
; 253  :     if ((dev->fd = open_tape( dev->filename, oflags )) < 0)

  00075	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0007d	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00083	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR oflags$[rsp]
  0008a	48 8b c8	 mov	 rcx, rax
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_open_tape
  00093	89 44 24 78	 mov	 DWORD PTR tv73[rsp], eax
  00097	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0009f	8b 4c 24 78	 mov	 ecx, DWORD PTR tv73[rsp]
  000a3	89 88 ac 01 00
	00		 mov	 DWORD PTR [rax+428], ecx
  000a9	83 7c 24 78 00	 cmp	 DWORD PTR tv73[rsp], 0
  000ae	0f 8d 84 01 00
	00		 jge	 $LN8@finish_scs

; 254  :     {
; 255  :         /* Device cannot be used; fail the open */
; 256  :         int save_errno = errno;

  000b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000ba	8b 00		 mov	 eax, DWORD PTR [rax]
  000bc	89 84 24 90 00
	00 00		 mov	 DWORD PTR save_errno$1[rsp], eax

; 257  :         rc = dev->fd;

  000c3	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000cb	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  000d1	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 258  :         dev->fd = -1;

  000d5	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 259  :         close_tape( rc );

  000e7	8b 4c 24 70	 mov	 ecx, DWORD PTR rc$[rsp]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_tape

; 260  :         errno = save_errno;

  000f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000f7	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR save_errno$1[rsp]
  000fe	89 08		 mov	 DWORD PTR [rax], ecx

; 261  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 262  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  00100	48 83 bc 24 70
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00109	74 12		 je	 SHORT $LN18@finish_scs
  0010b	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00113	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00117	89 44 24 7c	 mov	 DWORD PTR tv94[rsp], eax
  0011b	eb 08		 jmp	 SHORT $LN19@finish_scs
$LN18@finish_scs:
  0011d	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv94[rsp], 0
$LN19@finish_scs:
  00125	48 83 bc 24 70
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0012e	74 17		 je	 SHORT $LN20@finish_scs
  00130	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00138	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0013c	d1 f8		 sar	 eax, 1
  0013e	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv132[rsp], eax
  00145	eb 0b		 jmp	 SHORT $LN21@finish_scs
$LN20@finish_scs:
  00147	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv132[rsp], 0
$LN21@finish_scs:
  00152	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00158	8b 08		 mov	 ecx, DWORD PTR [rax]
  0015a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00160	48 89 84 24 a0
	00 00 00	 mov	 QWORD PTR tv83[rsp], rax
  00168	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00170	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00177	48 89 8c 24 a8
	00 00 00	 mov	 QWORD PTR tv89[rsp], rcx
  0017f	b9 01 00 00 00	 mov	 ecx, 1
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0018a	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv83[rsp]
  00192	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169304
  0019e	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  001a3	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169305
  001aa	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  001af	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR tv89[rsp]
  001b7	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  001bc	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv94[rsp]
  001c0	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  001c4	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv132[rsp]
  001cb	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  001cf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169306
  001d6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  001db	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169307
  001e2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  001e7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  001ec	41 b9 03 00 00
	00		 mov	 r9d, 3
  001f2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169308
  001f9	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  001fe	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169309
  00205	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 263  :                 dev->filename, "scsi", "finish_scsitape_open(reopen)",
; 264  :                 strerror(errno));
; 265  :         build_senseX(TAPE_BSENSE_ITFERROR,dev,unitstat,code);

  0020b	44 0f b6 8c 24
	80 02 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00214	4c 8b 84 24 78
	02 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0021c	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00224	b9 12 00 00 00	 mov	 ecx, 18
  00229	e8 00 00 00 00	 call	 build_senseX

; 266  :         return -1; /* (fatal error) */

  0022e	b8 ff ff ff ff	 mov	 eax, -1
  00233	e9 ab 03 00 00	 jmp	 $LN1@finish_scs
$LN8@finish_scs:

; 267  :     }
; 268  : 
; 269  :     /* Display status flags if debugging */
; 270  :     if (dev->debug)

  00238	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00240	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  00246	c1 e8 11	 shr	 eax, 17
  00249	83 e0 01	 and	 eax, 1
  0024c	85 c0		 test	 eax, eax
  0024e	0f 84 4b 01 00
	00		 je	 $LN9@finish_scs

; 271  :     {
; 272  :         char buffer[ 384 ] = {0};

  00254	48 8d 84 24 d0
	00 00 00	 lea	 rax, QWORD PTR buffer$4[rsp]
  0025c	48 8b f8	 mov	 rdi, rax
  0025f	33 c0		 xor	 eax, eax
  00261	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  00266	f3 aa		 rep stosb
$LN4@finish_scs:

; 273  :         VERIFY( int_scsi_status_mounted( dev, 1 ));  /* sanity check */

  00268	ba 01 00 00 00	 mov	 edx, 1
  0026d	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00275	e8 00 00 00 00	 call	 int_scsi_status_mounted
  0027a	85 c0		 test	 eax, eax
  0027c	75 5c		 jne	 SHORT $LN10@finish_scs
$LN7@finish_scs:
  0027e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169312
  00285	41 b8 11 01 00
	00		 mov	 r8d, 273		; 00000111H
  0028b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169313
  00292	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169314
  00299	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  0029f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002a5	85 c0		 test	 eax, eax
  002a7	74 20		 je	 SHORT $LN11@finish_scs
  002a9	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169316
  002b0	41 b8 11 01 00
	00		 mov	 r8d, 273		; 00000111H
  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169317
  002bd	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169318
  002c4	e8 00 00 00 00	 call	 DebuggerTrace
$LN11@finish_scs:
  002c9	33 c0		 xor	 eax, eax
  002cb	85 c0		 test	 eax, eax
  002cd	75 af		 jne	 SHORT $LN7@finish_scs
  002cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  002d5	85 c0		 test	 eax, eax
  002d7	74 01		 je	 SHORT $LN12@finish_scs
  002d9	cc		 int	 3
$LN12@finish_scs:
$LN10@finish_scs:
  002da	33 c0		 xor	 eax, eax
  002dc	85 c0		 test	 eax, eax
  002de	75 88		 jne	 SHORT $LN4@finish_scs

; 274  :         // "Tape %s: %smt_gstat 0x%8.8"PRIX32" %s"
; 275  :         WRMSG( HHC92702, "D", dev->filename, "finish_scsitape_open ",

  002e0	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  002e6	48 8d 94 24 d0
	00 00 00	 lea	 rdx, QWORD PTR buffer$4[rsp]
  002ee	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  002f6	8b 88 88 10 00
	00		 mov	 ecx, DWORD PTR [rax+4232]
  002fc	e8 00 00 00 00	 call	 gstat2str
  00301	48 89 84 24 b0
	00 00 00	 mov	 QWORD PTR tv173[rsp], rax
  00309	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00311	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00318	48 89 8c 24 b8
	00 00 00	 mov	 QWORD PTR tv182[rsp], rcx
  00320	b9 01 00 00 00	 mov	 ecx, 1
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  0032b	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR tv173[rsp]
  00333	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00338	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00340	8b 89 88 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4232]
  00346	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  0034a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169320
  00351	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  00356	48 8b 8c 24 b8
	00 00 00	 mov	 rcx, QWORD PTR tv182[rsp]
  0035e	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  00363	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169321
  0036a	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0036f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169322
  00376	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0037b	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00380	41 b9 03 00 00
	00		 mov	 r9d, 3
  00386	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169323
  0038d	ba 14 01 00 00	 mov	 edx, 276		; 00000114H
  00392	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169324
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN9@finish_scs:

; 276  :             (U32) dev->sstat, gstat2str( (U32) dev->sstat, buffer, sizeof( buffer )));
; 277  :     }
; 278  : 
; 279  :     /* Since a tape was just mounted, reset the blockid back to zero */
; 280  : 
; 281  :     dev->blockid = 0;

  0039f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003a7	c7 80 04 10 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+4100], 0

; 282  :     dev->fenced = 0;

  003b1	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003b9	8b 80 78 10 00
	00		 mov	 eax, DWORD PTR [rax+4216]
  003bf	83 e0 fe	 and	 eax, -2			; fffffffeH
  003c2	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003ca	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 283  : 
; 284  :     /*  Determine maximum I/O size and set the tape device to variable
; 285  :         length block mode. We must do this regardless of whether we'll
; 286  :         be writing to to tape or not.
; 287  :     */
; 288  :     rc = get_max_blocksize( dev, &dev->bufsize );

  003d0	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003d8	48 05 d8 01 00
	00		 add	 rax, 472		; 000001d8H
  003de	48 8b d0	 mov	 rdx, rax
  003e1	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  003e9	e8 00 00 00 00	 call	 get_max_blocksize
  003ee	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 289  : 
; 290  :     if (rc < 0)

  003f2	83 7c 24 70 00	 cmp	 DWORD PTR rc$[rsp], 0
  003f7	0f 8d 8a 01 00
	00		 jge	 $LN13@finish_scs

; 291  :     {
; 292  :         /* Device cannot be used; fail the open */
; 293  :         int save_errno = errno;

  003fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00403	8b 00		 mov	 eax, DWORD PTR [rax]
  00405	89 84 24 94 00
	00 00		 mov	 DWORD PTR save_errno$2[rsp], eax

; 294  :         rc = dev->fd;

  0040c	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00414	8b 80 ac 01 00
	00		 mov	 eax, DWORD PTR [rax+428]
  0041a	89 44 24 70	 mov	 DWORD PTR rc$[rsp], eax

; 295  :         dev->fd = -1;

  0041e	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00426	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 296  :         close_tape( rc );

  00430	8b 4c 24 70	 mov	 ecx, DWORD PTR rc$[rsp]
  00434	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_close_tape

; 297  :         errno = save_errno;

  0043a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00440	8b 8c 24 94 00
	00 00		 mov	 ecx, DWORD PTR save_errno$2[rsp]
  00447	89 08		 mov	 DWORD PTR [rax], ecx

; 298  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 299  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  00449	48 83 bc 24 70
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  00452	74 15		 je	 SHORT $LN22@finish_scs
  00454	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0045c	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  00460	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv218[rsp], eax
  00467	eb 0b		 jmp	 SHORT $LN23@finish_scs
$LN22@finish_scs:
  00469	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv218[rsp], 0
$LN23@finish_scs:
  00474	48 83 bc 24 70
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  0047d	74 17		 je	 SHORT $LN24@finish_scs
  0047f	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00487	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  0048b	d1 f8		 sar	 eax, 1
  0048d	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv224[rsp], eax
  00494	eb 0b		 jmp	 SHORT $LN25@finish_scs
$LN24@finish_scs:
  00496	c7 84 24 88 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv224[rsp], 0
$LN25@finish_scs:
  004a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  004a7	8b 08		 mov	 ecx, DWORD PTR [rax]
  004a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  004af	48 89 84 24 c0
	00 00 00	 mov	 QWORD PTR tv207[rsp], rax
  004b7	48 8b 8c 24 70
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  004bf	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  004c6	48 89 8c 24 c8
	00 00 00	 mov	 QWORD PTR tv213[rsp], rcx
  004ce	b9 01 00 00 00	 mov	 ecx, 1
  004d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  004d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR tv207[rsp]
  004e1	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  004e6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169326
  004ed	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  004f2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169327
  004f9	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  004fe	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR tv213[rsp]
  00506	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  0050b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR tv218[rsp]
  00512	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  00516	8b 8c 24 88 00
	00 00		 mov	 ecx, DWORD PTR tv224[rsp]
  0051d	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00521	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169328
  00528	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0052d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169329
  00534	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00539	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0053e	41 b9 03 00 00
	00		 mov	 r9d, 3
  00544	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169330
  0054b	ba 2c 01 00 00	 mov	 edx, 300		; 0000012cH
  00550	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169331
  00557	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 300  :                 dev->filename, "scsi", "ioctl_tape(MTSETBLK)", strerror(errno));
; 301  :         build_senseX(TAPE_BSENSE_ITFERROR,dev,unitstat,code);

  0055d	44 0f b6 8c 24
	80 02 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00566	4c 8b 84 24 78
	02 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0056e	48 8b 94 24 70
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00576	b9 12 00 00 00	 mov	 ecx, 18
  0057b	e8 00 00 00 00	 call	 build_senseX

; 302  :         return -1; /* (fatal error) */

  00580	b8 ff ff ff ff	 mov	 eax, -1
  00585	eb 5c		 jmp	 SHORT $LN1@finish_scs
$LN13@finish_scs:

; 303  :     }
; 304  : 
; 305  : #if defined( HAVE_DECL_MTEWARN ) && HAVE_DECL_MTEWARN
; 306  : 
; 307  :     // Try to request EOM/EOT (end-of-media/tape) early-warning
; 308  : 
; 309  :     // Note: if it fails, oh well. There's no need to scare the
; 310  :     // user with a warning message. We'll either get the warning
; 311  :     // or we won't. Either way there's nothing we can do about it.
; 312  :     // We did the best we could.
; 313  : 
; 314  :     if (!STS_WR_PROT( dev ))

  00587	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0058f	8b 80 88 10 00
	00		 mov	 eax, DWORD PTR [rax+4232]
  00595	25 00 00 00 04	 and	 eax, 67108864		; 04000000H
  0059a	85 c0		 test	 eax, eax
  0059c	75 43		 jne	 SHORT $LN14@finish_scs

; 315  :     {
; 316  :         struct mtop opblk;
; 317  : 
; 318  :         opblk.mt_op    = MTEWARN;

  0059e	b8 11 00 00 00	 mov	 eax, 17
  005a3	66 89 84 24 98
	00 00 00	 mov	 WORD PTR opblk$3[rsp], ax

; 319  :         opblk.mt_count = dev->eotmargin;

  005ab	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005b3	8b 80 70 10 00
	00		 mov	 eax, DWORD PTR [rax+4208]
  005b9	89 84 24 9c 00
	00 00		 mov	 DWORD PTR opblk$3[rsp+4], eax

; 320  : 
; 321  :         ioctl_tape (dev->fd, MTIOCTOP, (char*)&opblk);

  005c0	4c 8d 84 24 98
	00 00 00	 lea	 r8, QWORD PTR opblk$3[rsp]
  005c8	ba 01 6d 08 80	 mov	 edx, -2146931455	; ffffffff80086d01H
  005cd	48 8b 84 24 70
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  005d5	8b 88 ac 01 00
	00		 mov	 ecx, DWORD PTR [rax+428]
  005db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_ioctl_tape
$LN14@finish_scs:

; 322  : 
; 323  :         // (ignore any error; it either worked or it didn't)
; 324  :     }
; 325  : 
; 326  : #endif // defined( HAVE_DECL_MTEWARN ) && HAVE_DECL_MTEWARN
; 327  : 
; 328  :     return 0;  /* (success) */

  005e1	33 c0		 xor	 eax, eax
$LN1@finish_scs:

; 329  : 
; 330  : } /* end function finish_scsitape_open */

  005e3	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  005eb	48 33 cc	 xor	 rcx, rsp
  005ee	e8 00 00 00 00	 call	 __security_check_cookie
  005f3	48 81 c4 60 02
	00 00		 add	 rsp, 608		; 00000260H
  005fa	5f		 pop	 rdi
  005fb	c3		 ret	 0
finish_scsitape_open ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
ro$ = 112
tv92 = 116
tv133 = 120
tv152 = 124
tv158 = 128
tv141 = 136
tv147 = 144
tv180 = 152
tv193 = 160
buffer$1 = 176
__$ArrayPad$ = 560
dev$ = 592
unitstat$ = 600
code$ = 608
open_scsitape PROC

; 123  : {

$LN26:
  00000	44 88 44 24 18	 mov	 BYTE PTR [rsp+24], r8b
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	57		 push	 rdi
  00010	48 81 ec 40 02
	00 00		 sub	 rsp, 576		; 00000240H
  00017	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001e	48 33 c4	 xor	 rax, rsp
  00021	48 89 84 24 30
	02 00 00	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 124  :     BYTE  ro;                               /* Read-only flag        */
; 125  : 
; 126  :     /* Is an open for this device already in progress? */
; 127  :     if (dev->stape_mntdrq.link.Flink)

  00029	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00031	48 83 b8 c0 10
	00 00 00	 cmp	 QWORD PTR [rax+4288], 0
  00039	74 27		 je	 SHORT $LN8@open_scsit

; 128  :     {
; 129  :         /* Yes. Device is good but no tape is mounted (yet) */
; 130  :         build_senseX( TAPE_BSENSE_TAPEUNLOADED, dev, unitstat, code );

  0003b	44 0f b6 8c 24
	60 02 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00044	4c 8b 84 24 58
	02 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0004c	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00054	33 c9		 xor	 ecx, ecx
  00056	e8 00 00 00 00	 call	 build_senseX

; 131  :         return 0; // (quick exit; in progress == open success)

  0005b	33 c0		 xor	 eax, eax
  0005d	e9 21 04 00 00	 jmp	 $LN1@open_scsit
$LN8@open_scsit:
$LN4@open_scsit:

; 132  :     }
; 133  : 
; 134  :     ASSERT( dev->fd < 0 );  // (sanity check)

  00062	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0006a	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  00071	7c 5c		 jl	 SHORT $LN9@open_scsit
$LN7@open_scsit:
  00073	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169244
  0007a	41 b8 86 00 00
	00		 mov	 r8d, 134		; 00000086H
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169245
  00087	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169246
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_logmsg
  00094	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  0009a	85 c0		 test	 eax, eax
  0009c	74 20		 je	 SHORT $LN10@open_scsit
  0009e	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:$SG169248
  000a5	41 b8 86 00 00
	00		 mov	 r8d, 134		; 00000086H
  000ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:$SG169249
  000b2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169250
  000b9	e8 00 00 00 00	 call	 DebuggerTrace
$LN10@open_scsit:
  000be	33 c0		 xor	 eax, eax
  000c0	85 c0		 test	 eax, eax
  000c2	75 af		 jne	 SHORT $LN7@open_scsit
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IsDebuggerPresent
  000ca	85 c0		 test	 eax, eax
  000cc	74 01		 je	 SHORT $LN11@open_scsit
  000ce	cc		 int	 3
$LN11@open_scsit:
$LN9@open_scsit:
  000cf	33 c0		 xor	 eax, eax
  000d1	85 c0		 test	 eax, eax
  000d3	75 8d		 jne	 SHORT $LN4@open_scsit

; 135  :     dev->fd = -1;

  000d5	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000dd	c7 80 ac 01 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+428], -1

; 136  :     dev->sstat = dev->stape_online ? 0 : GMT_DR_OPEN( -1 );

  000e7	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  000ef	8b 80 98 10 00
	00		 mov	 eax, DWORD PTR [rax+4248]
  000f5	c1 e8 03	 shr	 eax, 3
  000f8	83 e0 01	 and	 eax, 1
  000fb	85 c0		 test	 eax, eax
  000fd	74 0a		 je	 SHORT $LN18@open_scsit
  000ff	c7 44 24 74 00
	00 00 00	 mov	 DWORD PTR tv92[rsp], 0
  00107	eb 08		 jmp	 SHORT $LN19@open_scsit
$LN18@open_scsit:
  00109	c7 44 24 74 00
	00 04 00	 mov	 DWORD PTR tv92[rsp], 262144 ; 00040000H
$LN19@open_scsit:
  00111	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00119	8b 4c 24 74	 mov	 ecx, DWORD PTR tv92[rsp]
  0011d	89 88 88 10 00
	00		 mov	 DWORD PTR [rax+4232], ecx

; 137  : 
; 138  :     /* Open the SCSI tape device */
; 139  :     dev->fd = int_nbio_scsitape_open( dev->filename, &ro );

  00123	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0012b	48 05 a4 00 00
	00		 add	 rax, 164		; 000000a4H
  00131	48 8d 54 24 70	 lea	 rdx, QWORD PTR ro$[rsp]
  00136	48 8b c8	 mov	 rcx, rax
  00139	e8 00 00 00 00	 call	 int_nbio_scsitape_open
  0013e	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00146	89 81 ac 01 00
	00		 mov	 DWORD PTR [rcx+428], eax

; 140  :     dev->readonly = ro ? 1 : 0;

  0014c	0f b6 44 24 70	 movzx	 eax, BYTE PTR ro$[rsp]
  00151	85 c0		 test	 eax, eax
  00153	74 0a		 je	 SHORT $LN20@open_scsit
  00155	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR tv133[rsp], 1
  0015d	eb 08		 jmp	 SHORT $LN21@open_scsit
$LN20@open_scsit:
  0015f	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv133[rsp], 0
$LN21@open_scsit:
  00167	8b 44 24 78	 mov	 eax, DWORD PTR tv133[rsp]
  0016b	83 e0 01	 and	 eax, 1
  0016e	d1 e0		 shl	 eax, 1
  00170	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00178	8b 89 78 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4216]
  0017e	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00181	0b c8		 or	 ecx, eax
  00183	8b c1		 mov	 eax, ecx
  00185	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0018d	89 81 78 10 00
	00		 mov	 DWORD PTR [rcx+4216], eax

; 141  : 
; 142  :     /* Check for successful open */
; 143  :     if (dev->fd < 0)

  00193	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  0019b	83 b8 ac 01 00
	00 00		 cmp	 DWORD PTR [rax+428], 0
  001a2	0f 8d 38 01 00
	00		 jge	 $LN12@open_scsit

; 144  :     {
; 145  :         // "%1d:%04X Tape file %s, type %s: error in function %s: %s"
; 146  :         WRMSG (HHC00205, "E", LCSS_DEVNUM,

  001a8	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001b1	74 12		 je	 SHORT $LN22@open_scsit
  001b3	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001bb	0f b7 40 48	 movzx	 eax, WORD PTR [rax+72]
  001bf	89 44 24 7c	 mov	 DWORD PTR tv152[rsp], eax
  001c3	eb 08		 jmp	 SHORT $LN23@open_scsit
$LN22@open_scsit:
  001c5	c7 44 24 7c 00
	00 00 00	 mov	 DWORD PTR tv152[rsp], 0
$LN23@open_scsit:
  001cd	48 83 bc 24 50
	02 00 00 00	 cmp	 QWORD PTR dev$[rsp], 0
  001d6	74 17		 je	 SHORT $LN24@open_scsit
  001d8	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  001e0	0f b7 40 44	 movzx	 eax, WORD PTR [rax+68]
  001e4	d1 f8		 sar	 eax, 1
  001e6	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv158[rsp], eax
  001ed	eb 0b		 jmp	 SHORT $LN25@open_scsit
$LN24@open_scsit:
  001ef	c7 84 24 80 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv158[rsp], 0
$LN25@open_scsit:
  001fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00200	8b 08		 mov	 ecx, DWORD PTR [rax]
  00202	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_w32_strerror
  00208	48 89 84 24 88
	00 00 00	 mov	 QWORD PTR tv141[rsp], rax
  00210	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00218	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  0021f	48 89 8c 24 90
	00 00 00	 mov	 QWORD PTR tv147[rsp], rcx
  00227	b9 01 00 00 00	 mov	 ecx, 1
  0022c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00232	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR tv141[rsp]
  0023a	48 89 4c 24 60	 mov	 QWORD PTR [rsp+96], rcx
  0023f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169253
  00246	48 89 4c 24 58	 mov	 QWORD PTR [rsp+88], rcx
  0024b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169254
  00252	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00257	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR tv147[rsp]
  0025f	48 89 4c 24 48	 mov	 QWORD PTR [rsp+72], rcx
  00264	8b 4c 24 7c	 mov	 ecx, DWORD PTR tv152[rsp]
  00268	89 4c 24 40	 mov	 DWORD PTR [rsp+64], ecx
  0026c	8b 8c 24 80 00
	00 00		 mov	 ecx, DWORD PTR tv158[rsp]
  00273	89 4c 24 38	 mov	 DWORD PTR [rsp+56], ecx
  00277	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169255
  0027e	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00283	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169256
  0028a	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0028f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00294	41 b9 03 00 00
	00		 mov	 r9d, 3
  0029a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169257
  002a1	ba 93 00 00 00	 mov	 edx, 147		; 00000093H
  002a6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169258
  002ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg

; 147  :                 dev->filename, "scsi", "open_tape()", strerror(errno));
; 148  :         build_senseX( TAPE_BSENSE_ITFERROR, dev, unitstat, code );

  002b3	44 0f b6 8c 24
	60 02 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  002bc	4c 8b 84 24 58
	02 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  002c4	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  002cc	b9 12 00 00 00	 mov	 ecx, 18
  002d1	e8 00 00 00 00	 call	 build_senseX

; 149  :         return -1; // (FATAL error; device cannot be opened)

  002d6	b8 ff ff ff ff	 mov	 eax, -1
  002db	e9 a3 01 00 00	 jmp	 $LN1@open_scsit
$LN12@open_scsit:

; 150  :     }
; 151  :     define_BOT_pos( dev );  // (always after successful open)

  002e0	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002e8	e8 00 00 00 00	 call	 define_BOT_pos

; 152  : 
; 153  :     /* Obtain the initial tape device/media status information */
; 154  :     /* and start the mount-monitoring thread if option enabled */
; 155  :     int_scsi_status_update( dev, 0 );

  002ed	33 d2		 xor	 edx, edx
  002ef	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  002f7	e8 00 00 00 00	 call	 int_scsi_status_update

; 156  : 
; 157  :     /* Display status flags if debugging */
; 158  :     if (dev->debug)

  002fc	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00304	8b 80 f8 05 00
	00		 mov	 eax, DWORD PTR [rax+1528]
  0030a	c1 e8 11	 shr	 eax, 17
  0030d	83 e0 01	 and	 eax, 1
  00310	85 c0		 test	 eax, eax
  00312	0f 84 d3 00 00
	00		 je	 $LN13@open_scsit

; 159  :     {
; 160  :         char buffer[ 384 ] = {0};

  00318	48 8d 84 24 b0
	00 00 00	 lea	 rax, QWORD PTR buffer$1[rsp]
  00320	48 8b f8	 mov	 rdi, rax
  00323	33 c0		 xor	 eax, eax
  00325	b9 80 01 00 00	 mov	 ecx, 384		; 00000180H
  0032a	f3 aa		 rep stosb

; 161  :         // "Tape %s: %smt_gstat 0x%8.8"PRIX32" %s"
; 162  :         WRMSG( HHC92702, "D", dev->filename, "open_scsitape ",

  0032c	41 b8 80 01 00
	00		 mov	 r8d, 384		; 00000180H
  00332	48 8d 94 24 b0
	00 00 00	 lea	 rdx, QWORD PTR buffer$1[rsp]
  0033a	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  00342	8b 88 88 10 00
	00		 mov	 ecx, DWORD PTR [rax+4232]
  00348	e8 00 00 00 00	 call	 gstat2str
  0034d	48 89 84 24 98
	00 00 00	 mov	 QWORD PTR tv180[rsp], rax
  00355	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0035d	48 81 c1 a4 00
	00 00		 add	 rcx, 164		; 000000a4H
  00364	48 89 8c 24 a0
	00 00 00	 mov	 QWORD PTR tv193[rsp], rcx
  0036c	b9 01 00 00 00	 mov	 ecx, 1
  00371	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___acrt_iob_func
  00377	48 8b 8c 24 98
	00 00 00	 mov	 rcx, QWORD PTR tv180[rsp]
  0037f	48 89 4c 24 50	 mov	 QWORD PTR [rsp+80], rcx
  00384	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0038c	8b 89 88 10 00
	00		 mov	 ecx, DWORD PTR [rcx+4232]
  00392	89 4c 24 48	 mov	 DWORD PTR [rsp+72], ecx
  00396	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169260
  0039d	48 89 4c 24 40	 mov	 QWORD PTR [rsp+64], rcx
  003a2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR tv193[rsp]
  003aa	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  003af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169261
  003b6	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  003bb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169262
  003c2	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  003c7	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  003cc	41 b9 03 00 00
	00		 mov	 r9d, 3
  003d2	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:$SG169263
  003d9	ba a3 00 00 00	 mov	 edx, 163		; 000000a3H
  003de	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:$SG169264
  003e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwritemsg
$LN13@open_scsit:

; 163  :             (U32) dev->sstat, gstat2str( (U32) dev->sstat, buffer, sizeof( buffer )));
; 164  :     }
; 165  : 
; 166  :     /* Asynchronous open now in progress? */
; 167  :     if (dev->stape_mntdrq.link.Flink)

  003eb	48 8b 84 24 50
	02 00 00	 mov	 rax, QWORD PTR dev$[rsp]
  003f3	48 83 b8 c0 10
	00 00 00	 cmp	 QWORD PTR [rax+4288], 0
  003fb	74 24		 je	 SHORT $LN14@open_scsit

; 168  :     {
; 169  :         /* Yes. Device is good but no tape is mounted (yet) */
; 170  :         build_senseX( TAPE_BSENSE_TAPEUNLOADED, dev, unitstat, code );

  003fd	44 0f b6 8c 24
	60 02 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  00406	4c 8b 84 24 58
	02 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  0040e	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  00416	33 c9		 xor	 ecx, ecx
  00418	e8 00 00 00 00	 call	 build_senseX

; 171  :         return 0; // (quick exit; in progress == open success)

  0041d	33 c0		 xor	 eax, eax
  0041f	eb 62		 jmp	 SHORT $LN1@open_scsit
$LN14@open_scsit:

; 172  :     }
; 173  : 
; 174  :     /* Finish up the open process... */
; 175  :     if (STS_NOT_MOUNTED( dev ))

  00421	33 d2		 xor	 edx, edx
  00423	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  0042b	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00430	85 c0		 test	 eax, eax
  00432	75 24		 jne	 SHORT $LN15@open_scsit

; 176  :     {
; 177  :         /* Intervention required if no tape is currently mounted.
; 178  :            Note: we return "success" because the filename is good
; 179  :            (device CAN be opened) but close the file descriptor
; 180  :            since there's no tape currently mounted on the drive.*/
; 181  : #if !defined( _MSVC_ )
; 182  :         int fd = dev->fd;
; 183  :         dev->fd = -1;
; 184  :         close_tape( fd );
; 185  : #endif // !_MSVC_
; 186  :         build_senseX( TAPE_BSENSE_TAPEUNLOADED, dev, unitstat, code );

  00434	44 0f b6 8c 24
	60 02 00 00	 movzx	 r9d, BYTE PTR code$[rsp]
  0043d	4c 8b 84 24 58
	02 00 00	 mov	 r8, QWORD PTR unitstat$[rsp]
  00445	48 8b 94 24 50
	02 00 00	 mov	 rdx, QWORD PTR dev$[rsp]
  0044d	33 c9		 xor	 ecx, ecx
  0044f	e8 00 00 00 00	 call	 build_senseX

; 187  :         return 0; // (because device file IS valid and CAN be opened)

  00454	33 c0		 xor	 eax, eax
  00456	eb 2b		 jmp	 SHORT $LN1@open_scsit
$LN15@open_scsit:

; 188  :     }
; 189  : 
; 190  :     /* Set variable length block processing to complete the open */
; 191  :     if (finish_scsitape_open( dev, unitstat, code ) != 0)

  00458	44 0f b6 84 24
	60 02 00 00	 movzx	 r8d, BYTE PTR code$[rsp]
  00461	48 8b 94 24 58
	02 00 00	 mov	 rdx, QWORD PTR unitstat$[rsp]
  00469	48 8b 8c 24 50
	02 00 00	 mov	 rcx, QWORD PTR dev$[rsp]
  00471	e8 00 00 00 00	 call	 finish_scsitape_open
  00476	85 c0		 test	 eax, eax
  00478	74 07		 je	 SHORT $LN16@open_scsit

; 192  :     {
; 193  :         /* We cannot use this device; fail the open.
; 194  :            'finish_scsitape_open' has already issued
; 195  :            the error message and closed the device. */
; 196  :         return -1;  // (open failure)

  0047a	b8 ff ff ff ff	 mov	 eax, -1
  0047f	eb 02		 jmp	 SHORT $LN1@open_scsit
$LN16@open_scsit:

; 197  :     }
; 198  :     return 0;       // (open success)

  00481	33 c0		 xor	 eax, eax
$LN1@open_scsit:

; 199  : 
; 200  : } /* end function open_scsitape */

  00483	48 8b 8c 24 30
	02 00 00	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0048b	48 33 cc	 xor	 rcx, rsp
  0048e	e8 00 00 00 00	 call	 __security_check_cookie
  00493	48 81 c4 40 02
	00 00		 add	 rsp, 576		; 00000240H
  0049a	5f		 pop	 rdi
  0049b	c3		 ret	 0
open_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\scsitape.c
_TEXT	SEGMENT
dev$ = 48
update_status_scsitape PROC

; 1925 : {

$LN4:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1926 :     //                  * *  WARNING!  * *
; 1927 : 
; 1928 :     // PROGRAMMING NOTE: do NOT call this function indiscriminately,
; 1929 :     // as doing so COULD cause improper functioning of the guest o/s!
; 1930 : 
; 1931 :     // How? Simple: if there's already a tape job running on the guest
; 1932 :     // using the tape drive and we just so happen to request a status
; 1933 :     // update at the precise moment a guest i/o encounters a tapemark,
; 1934 :     // it's possible for US to receive the "tapemark" status and thus
; 1935 :     // cause the guest to end up NOT SEEING the tapemark! Therefore,
; 1936 :     // you should ONLY call this function whenever the current status
; 1937 :     // indicates there's no tape mounted. If the current status says
; 1938 :     // there *is* a tape mounted, you must NOT call this function!
; 1939 : 
; 1940 :     // If the current status says there's a tape mounted and the user
; 1941 :     // knows this to be untrue (e.g. they manually unloaded it maybe)
; 1942 :     // then to kick off the auto-scsi-mount thread they must manually
; 1943 :     // issue the 'devinit' command themselves. We CANNOT presume that
; 1944 :     // a "mounted" status is bogus. We can ONLY safely presume that a
; 1945 :     // "UNmounted" status may possibly be bogus. Thus we only ask for
; 1946 :     // a status refresh if the current status is "not mounted" but we
; 1947 :     // purposely do NOT force a refresh if the status is "mounted"!!
; 1948 : 
; 1949 :     if ( STS_NOT_MOUNTED( dev ) )           // (if no tape mounted)

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00010	e8 00 00 00 00	 call	 int_scsi_status_mounted
  00015	85 c0		 test	 eax, eax
  00017	75 0c		 jne	 SHORT $LN2@update_sta

; 1950 :         int_scsi_status_update( dev, 0 );   // (then probably safe)

  00019	33 d2		 xor	 edx, edx
  0001b	48 8b 4c 24 30	 mov	 rcx, QWORD PTR dev$[rsp]
  00020	e8 00 00 00 00	 call	 int_scsi_status_update
$LN2@update_sta:

; 1951 : 
; 1952 :     return 0;

  00025	33 c0		 xor	 eax, eax

; 1953 : } /* end function update_status_scsitape */

  00027	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002b	c3		 ret	 0
update_status_scsitape ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\tapedev.h
_TEXT	SEGMENT
tv75 = 32
tv77 = 36
work$ = 40
feats$ = 64
flags$ = 72
is_tape_feat PROC

; 194  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 195  :     U32 work;
; 196  :     memcpy( &work, feats, sizeof( U32 ));

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR feats$[rsp]
  00012	8b 00		 mov	 eax, DWORD PTR [rax]
  00014	89 44 24 28	 mov	 DWORD PTR work$[rsp], eax

; 197  :     return (CSWAP32( work ) & flags) ? true : false;

  00018	8b 4c 24 28	 mov	 ecx, DWORD PTR work$[rsp]
  0001c	e8 00 00 00 00	 call	 _byteswap_ulong
  00021	23 44 24 48	 and	 eax, DWORD PTR flags$[rsp]
  00025	85 c0		 test	 eax, eax
  00027	74 0a		 je	 SHORT $LN3@is_tape_fe
  00029	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR tv75[rsp], 1
  00031	eb 08		 jmp	 SHORT $LN4@is_tape_fe
$LN3@is_tape_fe:
  00033	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR tv75[rsp], 0
$LN4@is_tape_fe:
  0003b	83 7c 24 20 00	 cmp	 DWORD PTR tv75[rsp], 0
  00040	75 0a		 jne	 SHORT $LN5@is_tape_fe
  00042	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv77[rsp], 0
  0004a	eb 08		 jmp	 SHORT $LN6@is_tape_fe
$LN5@is_tape_fe:
  0004c	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR tv77[rsp], 1
$LN6@is_tape_fe:
  00054	0f b6 44 24 24	 movzx	 eax, BYTE PTR tv77[rsp]

; 198  : }

  00059	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0005d	c3		 ret	 0
is_tape_feat ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\papa\MyGit\hyperion-zvector\dbgtrace.h
_TEXT	SEGMENT
buffsize$ = 48
rc$ = 52
chunksize$ = 56
buffer$ = 64
args$ = 72
fmt$ = 96
DebuggerTrace PROC

; 94   :   static inline void DebuggerTrace(char* fmt, ...) {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 95   :       const int chunksize = 512;

  00018	c7 44 24 38 00
	02 00 00	 mov	 DWORD PTR chunksize$[rsp], 512 ; 00000200H

; 96   :       int buffsize = 0;

  00020	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR buffsize$[rsp], 0

; 97   :       char* buffer = NULL;

  00028	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR buffer$[rsp], 0

; 98   :       int rc = -1;

  00031	c7 44 24 34 ff
	ff ff ff	 mov	 DWORD PTR rc$[rsp], -1

; 99   :       va_list args;
; 100  :       va_start( args, fmt );

  00039	48 8d 44 24 68	 lea	 rax, QWORD PTR fmt$[rsp+8]
  0003e	48 89 44 24 48	 mov	 QWORD PTR args$[rsp], rax
$LN9@DebuggerTr:
$LN4@DebuggerTr:

; 101  :       do {
; 102  :           if (buffer) free( buffer );

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00049	74 0b		 je	 SHORT $LN5@DebuggerTr
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN5@DebuggerTr:

; 103  :           buffsize += chunksize;

  00056	8b 44 24 38	 mov	 eax, DWORD PTR chunksize$[rsp]
  0005a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0005e	03 c8		 add	 ecx, eax
  00060	8b c1		 mov	 eax, ecx
  00062	89 44 24 30	 mov	 DWORD PTR buffsize$[rsp], eax

; 104  :           buffer = malloc( buffsize + 1 );

  00066	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  0006a	ff c0		 inc	 eax
  0006c	48 98		 cdqe
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00077	48 89 44 24 40	 mov	 QWORD PTR buffer$[rsp], rax

; 105  :           if (!buffer) BREAK_INTO_DEBUGGER();

  0007c	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  00082	75 01		 jne	 SHORT $LN6@DebuggerTr
  00084	cc		 int	 3
$LN6@DebuggerTr:

; 106  :           rc = _vsnprintf_s( buffer, buffsize+1, buffsize, fmt, args);

  00085	48 63 44 24 30	 movsxd	 rax, DWORD PTR buffsize$[rsp]
  0008a	8b 4c 24 30	 mov	 ecx, DWORD PTR buffsize$[rsp]
  0008e	ff c1		 inc	 ecx
  00090	48 63 c9	 movsxd	 rcx, ecx
  00093	48 8b 54 24 48	 mov	 rdx, QWORD PTR args$[rsp]
  00098	48 89 54 24 20	 mov	 QWORD PTR [rsp+32], rdx
  0009d	4c 8b 4c 24 60	 mov	 r9, QWORD PTR fmt$[rsp]
  000a2	4c 8b c0	 mov	 r8, rax
  000a5	48 8b d1	 mov	 rdx, rcx
  000a8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000ad	e8 00 00 00 00	 call	 _vsnprintf_s
  000b2	89 44 24 34	 mov	 DWORD PTR rc$[rsp], eax

; 107  :       } while (rc < 0 || rc >= buffsize);

  000b6	83 7c 24 34 00	 cmp	 DWORD PTR rc$[rsp], 0
  000bb	7c 86		 jl	 SHORT $LN4@DebuggerTr
  000bd	8b 44 24 30	 mov	 eax, DWORD PTR buffsize$[rsp]
  000c1	39 44 24 34	 cmp	 DWORD PTR rc$[rsp], eax
  000c5	0f 8d 78 ff ff
	ff		 jge	 $LN9@DebuggerTr

; 108  :       OutputDebugStringA( buffer ); /* send to debugger pane */

  000cb	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_OutputDebugStringA

; 109  :       if (buffer) free( buffer );

  000d6	48 83 7c 24 40
	00		 cmp	 QWORD PTR buffer$[rsp], 0
  000dc	74 0b		 je	 SHORT $LN7@DebuggerTr
  000de	48 8b 4c 24 40	 mov	 rcx, QWORD PTR buffer$[rsp]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN7@DebuggerTr:

; 110  :       va_end( args );

  000e9	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR args$[rsp], 0

; 111  :   }

  000f2	48 83 c4 58	 add	 rsp, 88			; 00000058H
  000f6	c3		 ret	 0
DebuggerTrace ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s
_TEXT	SEGMENT
_Buffer$ = 64
_BufferCount$ = 72
_MaxCount$ = 80
_Format$ = 88
_ArgList$ = 96
_vsnprintf_s PROC					; COMDAT

; 1598 :     {

$LN3:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1599 :         return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, NULL, _ArgList);

  00018	48 8b 44 24 60	 mov	 rax, QWORD PTR _ArgList$[rsp]
  0001d	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00022	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  0002b	4c 8b 4c 24 58	 mov	 r9, QWORD PTR _Format$[rsp]
  00030	4c 8b 44 24 50	 mov	 r8, QWORD PTR _MaxCount$[rsp]
  00035	48 8b 54 24 48	 mov	 rdx, QWORD PTR _BufferCount$[rsp]
  0003a	48 8b 4c 24 40	 mov	 rcx, QWORD PTR _Buffer$[rsp]
  0003f	e8 00 00 00 00	 call	 _vsnprintf_s_l

; 1600 :     }

  00044	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00048	c3		 ret	 0
_vsnprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\stdio.h
;	COMDAT _vsnprintf_s_l
_TEXT	SEGMENT
_Result$ = 64
tv74 = 68
_Buffer$ = 96
_BufferCount$ = 104
_MaxCount$ = 112
_Format$ = 120
_Locale$ = 128
_ArgList$ = 136
_vsnprintf_s_l PROC					; COMDAT

; 1577 :     {

$LN5:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1578 :         int const _Result = __stdio_common_vsnprintf_s(

  00018	e8 00 00 00 00	 call	 __local_stdio_printf_options
  0001d	48 8b 8c 24 88
	00 00 00	 mov	 rcx, QWORD PTR _ArgList$[rsp]
  00025	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  0002a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR _Locale$[rsp]
  00032	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00037	48 8b 4c 24 78	 mov	 rcx, QWORD PTR _Format$[rsp]
  0003c	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00041	4c 8b 4c 24 70	 mov	 r9, QWORD PTR _MaxCount$[rsp]
  00046	4c 8b 44 24 68	 mov	 r8, QWORD PTR _BufferCount$[rsp]
  0004b	48 8b 54 24 60	 mov	 rdx, QWORD PTR _Buffer$[rsp]
  00050	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00053	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___stdio_common_vsnprintf_s
  00059	89 44 24 40	 mov	 DWORD PTR _Result$[rsp], eax

; 1579 :             _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1580 :             _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
; 1581 : 
; 1582 :         return _Result < 0 ? -1 : _Result;

  0005d	83 7c 24 40 00	 cmp	 DWORD PTR _Result$[rsp], 0
  00062	7d 0a		 jge	 SHORT $LN3@vsnprintf_
  00064	c7 44 24 44 ff
	ff ff ff	 mov	 DWORD PTR tv74[rsp], -1
  0006c	eb 08		 jmp	 SHORT $LN4@vsnprintf_
$LN3@vsnprintf_:
  0006e	8b 44 24 40	 mov	 eax, DWORD PTR _Result$[rsp]
  00072	89 44 24 44	 mov	 DWORD PTR tv74[rsp], eax
$LN4@vsnprintf_:
  00076	8b 44 24 44	 mov	 eax, DWORD PTR tv74[rsp]

; 1583 :     }

  0007a	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0007e	c3		 ret	 0
_vsnprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Odtp
; File C:\Program Files (x86)\Windows Kits\10\include\10.0.22000.0\ucrt\corecrt_stdio_config.h
;	COMDAT __local_stdio_printf_options
_TEXT	SEGMENT
__local_stdio_printf_options PROC			; COMDAT

; 91   :         static unsigned __int64 _OptionsStorage;
; 92   :         return &_OptionsStorage;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?_OptionsStorage@?1??__local_stdio_printf_options@@9@9 ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 93   :     }

  00007	c3		 ret	 0
__local_stdio_printf_options ENDP
_TEXT	ENDS
END
